{"sha": "24e489f1e1326208aecabf390879c2320f212b7c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0ZTQ4OWYxZTEzMjYyMDhhZWNhYmYzOTA4NzljMjMyMGYyMTJiN2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-30T18:01:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-30T18:01:37Z"}, "message": "auto merge of #14520 : Ryman/rust/SnakeCaseLint, r=alexcrichton\n\nThis enforces `snake_case` for functions and methods only. Might be worth extending it to fields and locals too at some point in the future.\r\n\r\nA number of breaking changes each detailed in the attached commits.", "tree": {"sha": "3f2ee7bcb73a0789677d57f7dfdf609932b75c38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f2ee7bcb73a0789677d57f7dfdf609932b75c38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24e489f1e1326208aecabf390879c2320f212b7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24e489f1e1326208aecabf390879c2320f212b7c", "html_url": "https://github.com/rust-lang/rust/commit/24e489f1e1326208aecabf390879c2320f212b7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24e489f1e1326208aecabf390879c2320f212b7c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36c2c56277b368e5200fc4a7e8ed6752562ce030", "url": "https://api.github.com/repos/rust-lang/rust/commits/36c2c56277b368e5200fc4a7e8ed6752562ce030", "html_url": "https://github.com/rust-lang/rust/commit/36c2c56277b368e5200fc4a7e8ed6752562ce030"}, {"sha": "030b3a2499a73a6d3b4629ad676d2d9cd6a79df0", "url": "https://api.github.com/repos/rust-lang/rust/commits/030b3a2499a73a6d3b4629ad676d2d9cd6a79df0", "html_url": "https://github.com/rust-lang/rust/commit/030b3a2499a73a6d3b4629ad676d2d9cd6a79df0"}], "stats": {"total": 1093, "additions": 605, "deletions": 488}, "files": [{"sha": "16149e9f277dbf354703615e6350afcb4e0b3aad", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -73,7 +73,7 @@ fn run_cfail_test(config: &Config, props: &TestProps, testfile: &Path) {\n     let proc_res = compile_test(config, props, testfile);\n \n     if proc_res.status.success() {\n-        fatal_ProcRes(\"compile-fail test compiled successfully!\".to_string(),\n+        fatal_proc_rec(\"compile-fail test compiled successfully!\".to_string(),\n                       &proc_res);\n     }\n \n@@ -97,7 +97,7 @@ fn run_rfail_test(config: &Config, props: &TestProps, testfile: &Path) {\n         let proc_res = compile_test(config, props, testfile);\n \n         if !proc_res.status.success() {\n-            fatal_ProcRes(\"compilation failed!\".to_string(), &proc_res);\n+            fatal_proc_rec(\"compilation failed!\".to_string(), &proc_res);\n         }\n \n         exec_compiled_test(config, props, testfile)\n@@ -108,7 +108,7 @@ fn run_rfail_test(config: &Config, props: &TestProps, testfile: &Path) {\n     // The value our Makefile configures valgrind to return on failure\n     static VALGRIND_ERR: int = 100;\n     if proc_res.status.matches_exit_status(VALGRIND_ERR) {\n-        fatal_ProcRes(\"run-fail test isn't valgrind-clean!\".to_string(),\n+        fatal_proc_rec(\"run-fail test isn't valgrind-clean!\".to_string(),\n                       &proc_res);\n     }\n \n@@ -120,7 +120,7 @@ fn check_correct_failure_status(proc_res: &ProcRes) {\n     // The value the rust runtime returns on failure\n     static RUST_ERR: int = 101;\n     if !proc_res.status.matches_exit_status(RUST_ERR) {\n-        fatal_ProcRes(\n+        fatal_proc_rec(\n             format!(\"failure produced the wrong error: {}\", proc_res.status),\n             proc_res);\n     }\n@@ -131,19 +131,19 @@ fn run_rpass_test(config: &Config, props: &TestProps, testfile: &Path) {\n         let mut proc_res = compile_test(config, props, testfile);\n \n         if !proc_res.status.success() {\n-            fatal_ProcRes(\"compilation failed!\".to_string(), &proc_res);\n+            fatal_proc_rec(\"compilation failed!\".to_string(), &proc_res);\n         }\n \n         proc_res = exec_compiled_test(config, props, testfile);\n \n         if !proc_res.status.success() {\n-            fatal_ProcRes(\"test run failed!\".to_string(), &proc_res);\n+            fatal_proc_rec(\"test run failed!\".to_string(), &proc_res);\n         }\n     } else {\n         let proc_res = jit_test(config, props, testfile);\n \n         if !proc_res.status.success() {\n-            fatal_ProcRes(\"jit failed!\".to_string(), &proc_res);\n+            fatal_proc_rec(\"jit failed!\".to_string(), &proc_res);\n         }\n     }\n }\n@@ -172,7 +172,7 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n                                     \"normal\");\n \n         if !proc_res.status.success() {\n-            fatal_ProcRes(format!(\"pretty-printing failed in round {}\", round),\n+            fatal_proc_rec(format!(\"pretty-printing failed in round {}\", round),\n                           &proc_res);\n         }\n \n@@ -204,21 +204,21 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n     let proc_res = typecheck_source(config, props, testfile, actual);\n \n     if !proc_res.status.success() {\n-        fatal_ProcRes(\"pretty-printed source does not typecheck\".to_string(),\n+        fatal_proc_rec(\"pretty-printed source does not typecheck\".to_string(),\n                       &proc_res);\n     }\n     if props.no_pretty_expanded { return }\n \n     // additionally, run `--pretty expanded` and try to build it.\n     let proc_res = print_source(config, props, testfile, (*srcs.get(round)).clone(), \"expanded\");\n     if !proc_res.status.success() {\n-        fatal_ProcRes(format!(\"pretty-printing (expanded) failed\"), &proc_res);\n+        fatal_proc_rec(format!(\"pretty-printing (expanded) failed\"), &proc_res);\n     }\n \n     let ProcRes{ stdout: expanded_src, .. } = proc_res;\n     let proc_res = typecheck_source(config, props, testfile, expanded_src);\n     if !proc_res.status.success() {\n-        fatal_ProcRes(format!(\"pretty-printed source (expanded) does \\\n+        fatal_proc_rec(format!(\"pretty-printed source (expanded) does \\\n                                not typecheck\"),\n                       &proc_res);\n     }\n@@ -326,7 +326,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n     // compile test file (it shoud have 'compile-flags:-g' in the header)\n     let compiler_run_result = compile_test(config, props, testfile);\n     if !compiler_run_result.status.success() {\n-        fatal_ProcRes(\"compilation failed!\".to_string(), &compiler_run_result);\n+        fatal_proc_rec(\"compilation failed!\".to_string(), &compiler_run_result);\n     }\n \n     let exe_file = make_exe_name(config, testfile);\n@@ -517,7 +517,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n     // compile test file (it shoud have 'compile-flags:-g' in the header)\n     let compile_result = compile_test(config, props, testfile);\n     if !compile_result.status.success() {\n-        fatal_ProcRes(\"compilation failed!\".to_string(), &compile_result);\n+        fatal_proc_rec(\"compilation failed!\".to_string(), &compile_result);\n     }\n \n     let exe_file = make_exe_name(config, testfile);\n@@ -560,7 +560,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n     let debugger_run_result = run_lldb(config, &exe_file, &debugger_script);\n \n     if !debugger_run_result.status.success() {\n-        fatal_ProcRes(\"Error while running LLDB\".to_string(),\n+        fatal_proc_rec(\"Error while running LLDB\".to_string(),\n                       &debugger_run_result);\n     }\n \n@@ -720,7 +720,7 @@ fn check_debugger_output(debugger_run_result: &ProcRes, check_lines: &[String])\n             }\n         }\n         if i != num_check_lines {\n-            fatal_ProcRes(format!(\"line not found in debugger output: {}\",\n+            fatal_proc_rec(format!(\"line not found in debugger output: {}\",\n                                   check_lines.get(i).unwrap()),\n                           debugger_run_result);\n         }\n@@ -764,22 +764,22 @@ fn check_error_patterns(props: &TestProps,\n     let missing_patterns =\n         props.error_patterns.slice(next_err_idx, props.error_patterns.len());\n     if missing_patterns.len() == 1u {\n-        fatal_ProcRes(format!(\"error pattern '{}' not found!\",\n+        fatal_proc_rec(format!(\"error pattern '{}' not found!\",\n                               missing_patterns[0]),\n                       proc_res);\n     } else {\n         for pattern in missing_patterns.iter() {\n             error(format!(\"error pattern '{}' not found!\", *pattern));\n         }\n-        fatal_ProcRes(\"multiple error patterns not found\".to_string(),\n+        fatal_proc_rec(\"multiple error patterns not found\".to_string(),\n                       proc_res);\n     }\n }\n \n fn check_no_compiler_crash(proc_res: &ProcRes) {\n     for line in proc_res.stderr.as_slice().lines() {\n         if line.starts_with(\"error: internal compiler error:\") {\n-            fatal_ProcRes(\"compiler encountered internal error\".to_string(),\n+            fatal_proc_rec(\"compiler encountered internal error\".to_string(),\n                           proc_res);\n         }\n     }\n@@ -857,7 +857,7 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n         }\n \n         if !was_expected && is_compiler_error_or_warning(line) {\n-            fatal_ProcRes(format!(\"unexpected compiler error or warning: '{}'\",\n+            fatal_proc_rec(format!(\"unexpected compiler error or warning: '{}'\",\n                                   line),\n                           proc_res);\n         }\n@@ -866,7 +866,7 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n     for (i, &flag) in found_flags.iter().enumerate() {\n         if !flag {\n             let ee = expected_errors.get(i);\n-            fatal_ProcRes(format!(\"expected {} on line {} not found: {}\",\n+            fatal_proc_rec(format!(\"expected {} on line {} not found: {}\",\n                                   ee.kind, ee.line, ee.msg),\n                           proc_res);\n         }\n@@ -1047,7 +1047,7 @@ fn compose_and_run_compiler(\n                                      config.compile_lib_path.as_slice(),\n                                      None);\n         if !auxres.status.success() {\n-            fatal_ProcRes(\n+            fatal_proc_rec(\n                 format!(\"auxiliary build of {} failed to compile: \",\n                         abs_ab.display()),\n                 &auxres);\n@@ -1286,7 +1286,7 @@ fn error(err: String) { println!(\"\\nerror: {}\", err); }\n \n fn fatal(err: String) -> ! { error(err); fail!(); }\n \n-fn fatal_ProcRes(err: String, proc_res: &ProcRes) -> ! {\n+fn fatal_proc_rec(err: String, proc_res: &ProcRes) -> ! {\n     print!(\"\\n\\\n error: {}\\n\\\n status: {}\\n\\\n@@ -1562,35 +1562,35 @@ fn run_codegen_test(config: &Config, props: &TestProps,\n \n     let mut proc_res = compile_test_and_save_bitcode(config, props, testfile);\n     if !proc_res.status.success() {\n-        fatal_ProcRes(\"compilation failed!\".to_string(), &proc_res);\n+        fatal_proc_rec(\"compilation failed!\".to_string(), &proc_res);\n     }\n \n     proc_res = extract_function_from_bitcode(config, props, \"test\", testfile, \"\");\n     if !proc_res.status.success() {\n-        fatal_ProcRes(\"extracting 'test' function failed\".to_string(),\n+        fatal_proc_rec(\"extracting 'test' function failed\".to_string(),\n                       &proc_res);\n     }\n \n     proc_res = disassemble_extract(config, props, testfile, \"\");\n     if !proc_res.status.success() {\n-        fatal_ProcRes(\"disassembling extract failed\".to_string(), &proc_res);\n+        fatal_proc_rec(\"disassembling extract failed\".to_string(), &proc_res);\n     }\n \n \n     let mut proc_res = compile_cc_with_clang_and_save_bitcode(config, props, testfile);\n     if !proc_res.status.success() {\n-        fatal_ProcRes(\"compilation failed!\".to_string(), &proc_res);\n+        fatal_proc_rec(\"compilation failed!\".to_string(), &proc_res);\n     }\n \n     proc_res = extract_function_from_bitcode(config, props, \"test\", testfile, \"clang\");\n     if !proc_res.status.success() {\n-        fatal_ProcRes(\"extracting 'test' function failed\".to_string(),\n+        fatal_proc_rec(\"extracting 'test' function failed\".to_string(),\n                       &proc_res);\n     }\n \n     proc_res = disassemble_extract(config, props, testfile, \"clang\");\n     if !proc_res.status.success() {\n-        fatal_ProcRes(\"disassembling extract failed\".to_string(), &proc_res);\n+        fatal_proc_rec(\"disassembling extract failed\".to_string(), &proc_res);\n     }\n \n     let base = output_base_name(config, testfile);"}, {"sha": "ad80f2b46c8e083b25e10cd20df022a8acd87351", "filename": "src/doc/guide-ffi.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Fdoc%2Fguide-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Fdoc%2Fguide-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-ffi.md?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -476,6 +476,7 @@ extern crate libc;\n \n #[cfg(target_os = \"win32\", target_arch = \"x86\")]\n #[link(name = \"kernel32\")]\n+#[allow(non_snake_case_functions)]\n extern \"stdcall\" {\n     fn SetEnvironmentVariableA(n: *u8, v: *u8) -> libc::c_int;\n }"}, {"sha": "932011baa56f153c73447dfa40de939c83b64d32", "filename": "src/libcollections/smallintmap.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibcollections%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibcollections%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fsmallintmap.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -296,20 +296,20 @@ mod test_map {\n \n         // given a new key, initialize it with this new count,\n         // given an existing key, add more to its count\n-        fn addMoreToCount(_k: uint, v0: uint, v1: uint) -> uint {\n+        fn add_more_to_count(_k: uint, v0: uint, v1: uint) -> uint {\n             v0 + v1\n         }\n \n-        fn addMoreToCount_simple(v0: uint, v1: uint) -> uint {\n+        fn add_more_to_count_simple(v0: uint, v1: uint) -> uint {\n             v0 + v1\n         }\n \n         // count integers\n-        map.update(3, 1, addMoreToCount_simple);\n-        map.update_with_key(9, 1, addMoreToCount);\n-        map.update(3, 7, addMoreToCount_simple);\n-        map.update_with_key(5, 3, addMoreToCount);\n-        map.update_with_key(3, 2, addMoreToCount);\n+        map.update(3, 1, add_more_to_count_simple);\n+        map.update_with_key(9, 1, add_more_to_count);\n+        map.update(3, 7, add_more_to_count_simple);\n+        map.update_with_key(5, 3, add_more_to_count);\n+        map.update_with_key(3, 2, add_more_to_count);\n \n         // check the total counts\n         assert_eq!(map.find(&3).unwrap(), &10);"}, {"sha": "6b0f0b705612ed22934879a7b8bf15f690f9d85f", "filename": "src/libcore/char.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -23,6 +23,7 @@\n //! however the converse is not always true due to the above range limits\n //! and, as such, should be performed via the `from_u32` function..\n \n+#![allow(non_snake_case_functions)]\n \n use mem::transmute;\n use option::{None, Option, Some};"}, {"sha": "c6fc5f16ed142afbbaa95c0705fc9be57bf3a644", "filename": "src/libcore/unicode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibcore%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibcore%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -10,7 +10,7 @@\n \n // NOTE: The following code was generated by \"src/etc/unicode.py\", do not edit directly\n \n-#![allow(missing_doc, non_uppercase_statics)]\n+#![allow(missing_doc, non_uppercase_statics, non_snake_case_functions)]\n \n \n fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {"}, {"sha": "997d3427122e8daf373b2b6660d231b70147c850", "filename": "src/libdebug/reflect.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibdebug%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibdebug%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibdebug%2Freflect.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -42,11 +42,12 @@ pub fn align(size: uint, align: uint) -> uint {\n pub struct MovePtrAdaptor<V> {\n     inner: V\n }\n-pub fn MovePtrAdaptor<V:TyVisitor + MovePtr>(v: V) -> MovePtrAdaptor<V> {\n-    MovePtrAdaptor { inner: v }\n-}\n \n impl<V:TyVisitor + MovePtr> MovePtrAdaptor<V> {\n+    pub fn new(v: V) -> MovePtrAdaptor<V> {\n+        MovePtrAdaptor { inner: v }\n+    }\n+\n     #[inline]\n     pub fn bump(&mut self, sz: uint) {\n         self.inner.move_ptr(|p| ((p as uint) + sz) as *u8)"}, {"sha": "e6cc9785b44e72b4576b65028acd769aaaf85e94", "filename": "src/libdebug/repr.rs", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibdebug%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibdebug%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibdebug%2Frepr.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -99,17 +99,6 @@ pub struct ReprVisitor<'a> {\n     last_err: Option<io::IoError>,\n }\n \n-pub fn ReprVisitor<'a>(ptr: *u8,\n-                       writer: &'a mut io::Writer) -> ReprVisitor<'a> {\n-    ReprVisitor {\n-        ptr: ptr,\n-        ptr_stk: vec!(),\n-        var_stk: vec!(),\n-        writer: writer,\n-        last_err: None,\n-    }\n-}\n-\n impl<'a> MovePtr for ReprVisitor<'a> {\n     #[inline]\n     fn move_ptr(&mut self, adjustment: |*u8| -> *u8) {\n@@ -125,6 +114,15 @@ impl<'a> MovePtr for ReprVisitor<'a> {\n \n impl<'a> ReprVisitor<'a> {\n     // Various helpers for the TyVisitor impl\n+    pub fn new(ptr: *u8, writer: &'a mut io::Writer) -> ReprVisitor<'a> {\n+        ReprVisitor {\n+            ptr: ptr,\n+            ptr_stk: vec!(),\n+            var_stk: vec!(),\n+            writer: writer,\n+            last_err: None,\n+        }\n+    }\n \n     #[inline]\n     pub fn get<T>(&mut self, f: |&mut ReprVisitor, &T| -> bool) -> bool {\n@@ -141,16 +139,8 @@ impl<'a> ReprVisitor<'a> {\n     #[inline]\n     pub fn visit_ptr_inner(&mut self, ptr: *u8, inner: *TyDesc) -> bool {\n         unsafe {\n-            // This should call the constructor up above, but due to limiting\n-            // issues we have to recreate it here.\n-            let u = ReprVisitor {\n-                ptr: ptr,\n-                ptr_stk: vec!(),\n-                var_stk: vec!(),\n-                writer: mem::transmute_copy(&self.writer),\n-                last_err: None,\n-            };\n-            let mut v = reflect::MovePtrAdaptor(u);\n+            let u = ReprVisitor::new(ptr, mem::transmute_copy(&self.writer));\n+            let mut v = reflect::MovePtrAdaptor::new(u);\n             // Obviously this should not be a thing, but blame #8401 for now\n             visit_tydesc(inner, &mut v as &mut TyVisitor);\n             match v.unwrap().last_err {\n@@ -584,8 +574,8 @@ pub fn write_repr<T>(writer: &mut io::Writer, object: &T) -> io::IoResult<()> {\n     unsafe {\n         let ptr = object as *T as *u8;\n         let tydesc = get_tydesc::<T>();\n-        let u = ReprVisitor(ptr, writer);\n-        let mut v = reflect::MovePtrAdaptor(u);\n+        let u = ReprVisitor::new(ptr, writer);\n+        let mut v = reflect::MovePtrAdaptor::new(u);\n         visit_tydesc(tydesc, &mut v as &mut TyVisitor);\n         match v.unwrap().last_err {\n             Some(e) => Err(e),"}, {"sha": "3a9f8bc863b15dea7765e3a3aeb59fb28da486fa", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -71,6 +71,7 @@\n */\n \n #![allow(non_camel_case_types)]\n+#![allow(non_snake_case_functions)]\n #![allow(non_uppercase_statics)]\n #![allow(missing_doc)]\n #![allow(uppercase_variables)]"}, {"sha": "240b87fda084d13e39110543d842ac9d9cfdf313", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -21,6 +21,8 @@\n //! play. The only dependencies of these modules are the normal system libraries\n //! that you would find on the respective platform.\n \n+#![allow(non_snake_case_functions)]\n+\n use libc::c_int;\n use libc;\n use std::c_str::CString;"}, {"sha": "cddae53fa42f62d6ff4bbae74b0f00adf8d2b3c0", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -758,6 +758,7 @@ fn free_handle(_handle: *()) {\n \n #[cfg(unix)]\n fn translate_status(status: c_int) -> p::ProcessExit {\n+    #![allow(non_snake_case_functions)]\n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"android\")]\n     mod imp {"}, {"sha": "0e4581a401e9056bad45ebe6856a48dfd46aedff", "filename": "src/libregex/test/bench.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibregex%2Ftest%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibregex%2Ftest%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Fbench.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -7,6 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+#![allow(non_snake_case_functions)]\n \n use std::rand::{Rng, task_rng};\n use std::str;"}, {"sha": "5f53cd8570520c2d2d00916149fb20e250c09f1f", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -69,7 +69,7 @@ pub fn llvm_err(sess: &Session, msg: String) -> ! {\n     }\n }\n \n-pub fn WriteOutputFile(\n+pub fn write_output_file(\n         sess: &Session,\n         target: lib::llvm::TargetMachineRef,\n         pm: lib::llvm::PassManagerRef,\n@@ -90,7 +90,7 @@ pub fn WriteOutputFile(\n pub mod write {\n \n     use back::lto;\n-    use back::link::{WriteOutputFile, OutputType};\n+    use back::link::{write_output_file, OutputType};\n     use back::link::{OutputTypeAssembly, OutputTypeBitcode};\n     use back::link::{OutputTypeExe, OutputTypeLlvmAssembly};\n     use back::link::{OutputTypeObject};\n@@ -310,7 +310,7 @@ pub mod write {\n                             output.temp_path(OutputTypeAssembly)\n                         };\n                         with_codegen(tm, llmod, trans.no_builtins, |cpm| {\n-                            WriteOutputFile(sess, tm, cpm, llmod, &path,\n+                            write_output_file(sess, tm, cpm, llmod, &path,\n                                             lib::llvm::AssemblyFile);\n                         });\n                     }\n@@ -328,7 +328,7 @@ pub mod write {\n                 match object_file {\n                     Some(ref path) => {\n                         with_codegen(tm, llmod, trans.no_builtins, |cpm| {\n-                            WriteOutputFile(sess, tm, cpm, llmod, path,\n+                            write_output_file(sess, tm, cpm, llmod, path,\n                                             lib::llvm::ObjectFile);\n                         });\n                     }\n@@ -339,7 +339,7 @@ pub mod write {\n                                  trans.no_builtins, |cpm| {\n                         let out = output.temp_path(OutputTypeObject)\n                                         .with_extension(\"metadata.o\");\n-                        WriteOutputFile(sess, tm, cpm,\n+                        write_output_file(sess, tm, cpm,\n                                         trans.metadata_module, &out,\n                                         lib::llvm::ObjectFile);\n                     })"}, {"sha": "4a36dfd784285bf51e4d3b8afc12f21f5d923a81", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,6 +10,7 @@\n \n #![allow(non_uppercase_pattern_statics)]\n #![allow(non_camel_case_types)]\n+#![allow(non_snake_case_functions)]\n #![allow(dead_code)]\n \n use std::c_str::ToCStr;"}, {"sha": "74a804763e83ef95cf5c21fc5cfbd31d7745f4e5", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -19,7 +19,8 @@ use middle::lang_items;\n use middle::ty;\n use middle::typeck;\n \n-use reader = serialize::ebml::reader;\n+use serialize::ebml;\n+use serialize::ebml::reader;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::ast_map;\n@@ -206,7 +207,7 @@ pub fn get_field_type(tcx: &ty::ctxt, class_id: ast::DefId,\n                       def: ast::DefId) -> ty::ty_param_bounds_and_ty {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(class_id.krate);\n-    let all_items = reader::get_doc(reader::Doc(cdata.data()), tag_items);\n+    let all_items = reader::get_doc(ebml::Doc::new(cdata.data()), tag_items);\n     let class_doc = expect(tcx.sess.diagnostic(),\n                            decoder::maybe_find_item(class_id.node, all_items),\n                            || {"}, {"sha": "56b320d2a07225c58456907dc3097bf877d76331", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -99,7 +99,7 @@ fn find_item<'a>(item_id: ast::NodeId, items: ebml::Doc<'a>) -> ebml::Doc<'a> {\n // Looks up an item in the given metadata and returns an ebml doc pointing\n // to the item data.\n fn lookup_item<'a>(item_id: ast::NodeId, data: &'a [u8]) -> ebml::Doc<'a> {\n-    let items = reader::get_doc(reader::Doc(data), tag_items);\n+    let items = reader::get_doc(ebml::Doc::new(data), tag_items);\n     find_item(item_id, items)\n }\n \n@@ -383,7 +383,7 @@ pub fn get_trait_def(cdata: Cmd,\n                                      tag_items_data_item_ty_param_bounds);\n     let rp_defs = item_region_param_defs(item_doc, cdata);\n     let sized = item_sized(item_doc);\n-    let mut bounds = ty::EmptyBuiltinBounds();\n+    let mut bounds = ty::empty_builtin_bounds();\n     // Collect the builtin bounds from the encoded supertraits.\n     // FIXME(#8559): They should be encoded directly.\n     reader::tagged_docs(item_doc, tag_item_super_trait_ref, |trait_doc| {\n@@ -443,7 +443,7 @@ pub fn get_impl_vtables(cdata: Cmd,\n {\n     let item_doc = lookup_item(id, cdata.data());\n     let vtables_doc = reader::get_doc(item_doc, tag_item_impl_vtables);\n-    let mut decoder = reader::Decoder(vtables_doc);\n+    let mut decoder = reader::Decoder::new(vtables_doc);\n \n     typeck::impl_res {\n         trait_vtables: decoder.read_vtable_res(tcx, cdata),\n@@ -466,7 +466,7 @@ pub enum DefLike {\n \n /// Iterates over the language items in the given crate.\n pub fn each_lang_item(cdata: Cmd, f: |ast::NodeId, uint| -> bool) -> bool {\n-    let root = reader::Doc(cdata.data());\n+    let root = ebml::Doc::new(cdata.data());\n     let lang_items = reader::get_doc(root, tag_lang_items);\n     reader::tagged_docs(lang_items, tag_lang_items_item, |item_doc| {\n         let id_doc = reader::get_doc(item_doc, tag_lang_items_item_id);\n@@ -506,7 +506,7 @@ fn each_child_of_item_or_crate(intr: Rc<IdentInterner>,\n             None => cdata\n         };\n \n-        let other_crates_items = reader::get_doc(reader::Doc(crate_data.data()), tag_items);\n+        let other_crates_items = reader::get_doc(ebml::Doc::new(crate_data.data()), tag_items);\n \n         // Get the item.\n         match maybe_find_item(child_def_id.node, other_crates_items) {\n@@ -534,7 +534,7 @@ fn each_child_of_item_or_crate(intr: Rc<IdentInterner>,\n                                 |inherent_impl_def_id_doc| {\n         let inherent_impl_def_id = item_def_id(inherent_impl_def_id_doc,\n                                                cdata);\n-        let items = reader::get_doc(reader::Doc(cdata.data()), tag_items);\n+        let items = reader::get_doc(ebml::Doc::new(cdata.data()), tag_items);\n         match maybe_find_item(inherent_impl_def_id.node, items) {\n             None => {}\n             Some(inherent_impl_doc) => {\n@@ -599,7 +599,7 @@ fn each_child_of_item_or_crate(intr: Rc<IdentInterner>,\n             None => cdata\n         };\n \n-        let other_crates_items = reader::get_doc(reader::Doc(crate_data.data()), tag_items);\n+        let other_crates_items = reader::get_doc(ebml::Doc::new(crate_data.data()), tag_items);\n \n         // Get the item.\n         match maybe_find_item(child_def_id.node, other_crates_items) {\n@@ -626,7 +626,7 @@ pub fn each_child_of_item(intr: Rc<IdentInterner>,\n                           get_crate_data: GetCrateDataCb,\n                           callback: |DefLike, ast::Ident, ast::Visibility|) {\n     // Find the item.\n-    let root_doc = reader::Doc(cdata.data());\n+    let root_doc = ebml::Doc::new(cdata.data());\n     let items = reader::get_doc(root_doc, tag_items);\n     let item_doc = match maybe_find_item(id, items) {\n         None => return,\n@@ -647,7 +647,7 @@ pub fn each_top_level_item_of_crate(intr: Rc<IdentInterner>,\n                                     callback: |DefLike,\n                                                ast::Ident,\n                                                ast::Visibility|) {\n-    let root_doc = reader::Doc(cdata.data());\n+    let root_doc = ebml::Doc::new(cdata.data());\n     let misc_info_doc = reader::get_doc(root_doc, tag_misc_info);\n     let crate_items_doc = reader::get_doc(misc_info_doc,\n                                           tag_misc_info_crate_items);\n@@ -696,7 +696,7 @@ pub fn maybe_get_item_ast(cdata: Cmd, tcx: &ty::ctxt, id: ast::NodeId,\n pub fn get_enum_variants(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId,\n                      tcx: &ty::ctxt) -> Vec<Rc<ty::VariantInfo>> {\n     let data = cdata.data();\n-    let items = reader::get_doc(reader::Doc(data), tag_items);\n+    let items = reader::get_doc(ebml::Doc::new(data), tag_items);\n     let item = find_item(id, items);\n     let mut disr_val = 0;\n     enum_variant_ids(item, cdata).iter().map(|did| {\n@@ -829,7 +829,7 @@ pub fn get_item_variances(cdata: Cmd, id: ast::NodeId) -> ty::ItemVariances {\n     let data = cdata.data();\n     let item_doc = lookup_item(id, data);\n     let variance_doc = reader::get_doc(item_doc, tag_item_variances);\n-    let mut decoder = reader::Decoder(variance_doc);\n+    let mut decoder = reader::Decoder::new(variance_doc);\n     Decodable::decode(&mut decoder).unwrap()\n }\n \n@@ -1078,7 +1078,7 @@ fn list_crate_attributes(md: ebml::Doc, hash: &Svh,\n }\n \n pub fn get_crate_attributes(data: &[u8]) -> Vec<ast::Attribute> {\n-    get_attributes(reader::Doc(data))\n+    get_attributes(ebml::Doc::new(data))\n }\n \n #[deriving(Clone)]\n@@ -1090,7 +1090,7 @@ pub struct CrateDep {\n \n pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n     let mut deps: Vec<CrateDep> = Vec::new();\n-    let cratedoc = reader::Doc(data);\n+    let cratedoc = ebml::Doc::new(data);\n     let depsdoc = reader::get_doc(cratedoc, tag_crate_deps);\n     let mut crate_num = 1;\n     fn docstr(doc: ebml::Doc, tag_: uint) -> String {\n@@ -1123,40 +1123,40 @@ fn list_crate_deps(data: &[u8], out: &mut io::Writer) -> io::IoResult<()> {\n }\n \n pub fn maybe_get_crate_hash(data: &[u8]) -> Option<Svh> {\n-    let cratedoc = reader::Doc(data);\n+    let cratedoc = ebml::Doc::new(data);\n     reader::maybe_get_doc(cratedoc, tag_crate_hash).map(|doc| {\n         Svh::new(doc.as_str_slice())\n     })\n }\n \n pub fn get_crate_hash(data: &[u8]) -> Svh {\n-    let cratedoc = reader::Doc(data);\n+    let cratedoc = ebml::Doc::new(data);\n     let hashdoc = reader::get_doc(cratedoc, tag_crate_hash);\n     Svh::new(hashdoc.as_str_slice())\n }\n \n pub fn maybe_get_crate_id(data: &[u8]) -> Option<CrateId> {\n-    let cratedoc = reader::Doc(data);\n+    let cratedoc = ebml::Doc::new(data);\n     reader::maybe_get_doc(cratedoc, tag_crate_crateid).map(|doc| {\n         from_str(doc.as_str_slice()).unwrap()\n     })\n }\n \n pub fn get_crate_triple(data: &[u8]) -> String {\n-    let cratedoc = reader::Doc(data);\n+    let cratedoc = ebml::Doc::new(data);\n     let triple_doc = reader::maybe_get_doc(cratedoc, tag_crate_triple);\n     triple_doc.expect(\"No triple in crate\").as_str().to_string()\n }\n \n pub fn get_crate_id(data: &[u8]) -> CrateId {\n-    let cratedoc = reader::Doc(data);\n+    let cratedoc = ebml::Doc::new(data);\n     let hashdoc = reader::get_doc(cratedoc, tag_crate_crateid);\n     from_str(hashdoc.as_str_slice()).unwrap()\n }\n \n pub fn list_crate_metadata(bytes: &[u8], out: &mut io::Writer) -> io::IoResult<()> {\n     let hash = get_crate_hash(bytes);\n-    let md = reader::Doc(bytes);\n+    let md = ebml::Doc::new(bytes);\n     try!(list_crate_attributes(md, &hash, out));\n     list_crate_deps(bytes, out)\n }\n@@ -1183,7 +1183,7 @@ pub fn translate_def_id(cdata: Cmd, did: ast::DefId) -> ast::DefId {\n }\n \n pub fn each_impl(cdata: Cmd, callback: |ast::DefId|) {\n-    let impls_doc = reader::get_doc(reader::Doc(cdata.data()), tag_impls);\n+    let impls_doc = reader::get_doc(ebml::Doc::new(cdata.data()), tag_impls);\n     let _ = reader::tagged_docs(impls_doc, tag_impls_impl, |impl_doc| {\n         callback(item_def_id(impl_doc, cdata));\n         true\n@@ -1239,7 +1239,7 @@ pub fn get_trait_of_method(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n \n pub fn get_native_libraries(cdata: Cmd)\n                             -> Vec<(cstore::NativeLibaryKind, String)> {\n-    let libraries = reader::get_doc(reader::Doc(cdata.data()),\n+    let libraries = reader::get_doc(ebml::Doc::new(cdata.data()),\n                                     tag_native_libraries);\n     let mut result = Vec::new();\n     reader::tagged_docs(libraries, tag_native_libraries_lib, |lib_doc| {\n@@ -1255,12 +1255,12 @@ pub fn get_native_libraries(cdata: Cmd)\n }\n \n pub fn get_macro_registrar_fn(data: &[u8]) -> Option<ast::NodeId> {\n-    reader::maybe_get_doc(reader::Doc(data), tag_macro_registrar_fn)\n+    reader::maybe_get_doc(ebml::Doc::new(data), tag_macro_registrar_fn)\n         .map(|doc| FromPrimitive::from_u32(reader::doc_as_u32(doc)).unwrap())\n }\n \n pub fn get_exported_macros(data: &[u8]) -> Vec<String> {\n-    let macros = reader::get_doc(reader::Doc(data),\n+    let macros = reader::get_doc(ebml::Doc::new(data),\n                                  tag_exported_macros);\n     let mut result = Vec::new();\n     reader::tagged_docs(macros, tag_macro_def, |macro_doc| {\n@@ -1273,7 +1273,7 @@ pub fn get_exported_macros(data: &[u8]) -> Vec<String> {\n pub fn get_dylib_dependency_formats(cdata: Cmd)\n     -> Vec<(ast::CrateNum, cstore::LinkagePreference)>\n {\n-    let formats = reader::get_doc(reader::Doc(cdata.data()),\n+    let formats = reader::get_doc(ebml::Doc::new(cdata.data()),\n                                   tag_dylib_dependency_formats);\n     let mut result = Vec::new();\n \n@@ -1299,7 +1299,7 @@ pub fn get_dylib_dependency_formats(cdata: Cmd)\n pub fn get_missing_lang_items(cdata: Cmd)\n     -> Vec<lang_items::LangItem>\n {\n-    let items = reader::get_doc(reader::Doc(cdata.data()), tag_lang_items);\n+    let items = reader::get_doc(ebml::Doc::new(cdata.data()), tag_lang_items);\n     let mut result = Vec::new();\n     reader::tagged_docs(items, tag_lang_items_missing, |missing_doc| {\n         let item: lang_items::LangItem ="}, {"sha": "2295874a1b504033bf4ea3ad4e02dd860b9c3a83", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -1813,7 +1813,7 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n         type_abbrevs: RefCell::new(HashMap::new()),\n      };\n \n-    let mut ebml_w = writer::Encoder(wr);\n+    let mut ebml_w = writer::Encoder::new(wr);\n \n     encode_crate_id(&mut ebml_w, &ecx.link_meta.crateid);\n     encode_crate_triple(&mut ebml_w,"}, {"sha": "b5fc38286239806a8fc27ca354a2d68a75b81894", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -556,7 +556,7 @@ fn parse_type_param_def(st: &mut PState, conv: conv_did) -> ty::TypeParameterDef\n \n fn parse_bounds(st: &mut PState, conv: conv_did) -> ty::ParamBounds {\n     let mut param_bounds = ty::ParamBounds {\n-        builtin_bounds: ty::EmptyBuiltinBounds(),\n+        builtin_bounds: ty::empty_builtin_bounds(),\n         trait_bounds: Vec::new()\n     };\n     loop {"}, {"sha": "aec2507124979e1dba6690afd8f0c1b47ef04492", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -120,7 +120,7 @@ pub fn decode_inlined_item(cdata: &cstore::crate_metadata,\n             path_as_str = Some(s);\n             path_as_str.as_ref().map(|x| x.as_slice())\n         });\n-        let mut ast_dsr = reader::Decoder(ast_doc);\n+        let mut ast_dsr = reader::Decoder::new(ast_doc);\n         let from_id_range = Decodable::decode(&mut ast_dsr).unwrap();\n         let to_id_range = reserve_id_range(&dcx.tcx.sess, from_id_range);\n         let xcx = &ExtendedDecodeContext {\n@@ -349,7 +349,7 @@ fn simplify_ast(ii: e::InlinedItemRef) -> ast::InlinedItem {\n \n fn decode_ast(par_doc: ebml::Doc) -> ast::InlinedItem {\n     let chi_doc = par_doc.get(c::tag_tree as uint);\n-    let mut d = reader::Decoder(chi_doc);\n+    let mut d = reader::Decoder::new(chi_doc);\n     Decodable::decode(&mut d).unwrap()\n }\n \n@@ -395,7 +395,7 @@ fn renumber_and_map_ast(xcx: &ExtendedDecodeContext,\n // Encoding and decoding of ast::def\n \n fn decode_def(xcx: &ExtendedDecodeContext, doc: ebml::Doc) -> ast::Def {\n-    let mut dsr = reader::Decoder(doc);\n+    let mut dsr = reader::Decoder::new(doc);\n     let def: ast::Def = Decodable::decode(&mut dsr).unwrap();\n     def.tr(xcx)\n }\n@@ -1317,7 +1317,7 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n             }\n             Some(value) => {\n                 let val_doc = entry_doc.get(c::tag_table_val as uint);\n-                let mut val_dsr = reader::Decoder(val_doc);\n+                let mut val_dsr = reader::Decoder::new(val_doc);\n                 let val_dsr = &mut val_dsr;\n \n                 match value {\n@@ -1402,7 +1402,7 @@ fn encode_item_ast(ebml_w: &mut Encoder, item: @ast::Item) {\n #[cfg(test)]\n fn decode_item_ast(par_doc: ebml::Doc) -> @ast::Item {\n     let chi_doc = par_doc.get(c::tag_tree as uint);\n-    let mut d = reader::Decoder(chi_doc);\n+    let mut d = reader::Decoder::new(chi_doc);\n     @Decodable::decode(&mut d).unwrap()\n }\n \n@@ -1444,10 +1444,10 @@ fn roundtrip(in_item: Option<@ast::Item>) {\n     let in_item = in_item.unwrap();\n     let mut wr = MemWriter::new();\n     {\n-        let mut ebml_w = writer::Encoder(&mut wr);\n+        let mut ebml_w = writer::Encoder::new(&mut wr);\n         encode_item_ast(&mut ebml_w, in_item);\n     }\n-    let ebml_doc = reader::Doc(wr.get_ref());\n+    let ebml_doc = ebml::Doc::new(wr.get_ref());\n     let out_item = decode_item_ast(ebml_doc);\n \n     assert!(in_item == out_item);"}, {"sha": "b6614d151068e45490c238fa052d11b02e8ba4d9", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -371,7 +371,7 @@ pub fn check_builtin_bounds(cx: &Context,\n                             bounds: ty::BuiltinBounds,\n                             any_missing: |ty::BuiltinBounds|) {\n     let kind = ty::type_contents(cx.tcx, ty);\n-    let mut missing = ty::EmptyBuiltinBounds();\n+    let mut missing = ty::empty_builtin_bounds();\n     for bound in bounds.iter() {\n         if !kind.meets_bound(cx.tcx, bound) {\n             missing.add(bound);\n@@ -565,6 +565,7 @@ pub fn check_cast_for_escaping_regions(\n             }\n         });\n \n+    #[allow(non_snake_case_functions)]\n     fn is_ReScope(r: ty::Region) -> bool {\n         match r {\n             ty::ReScope(..) => true,"}, {"sha": "8cceb16b34fe83809931a3dac897166afe9d0b52", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 67, "deletions": 14, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -83,6 +83,7 @@ pub enum Lint {\n     NonCamelCaseTypes,\n     NonUppercaseStatics,\n     NonUppercasePatternStatics,\n+    NonSnakeCaseFunctions,\n     UppercaseVariables,\n     UnnecessaryParens,\n     TypeLimits,\n@@ -220,6 +221,13 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n          default: Warn\n      }),\n \n+    (\"non_snake_case_functions\",\n+     LintSpec {\n+         lint: NonSnakeCaseFunctions,\n+         desc: \"methods and functions should have snake case names\",\n+         default: Warn\n+     }),\n+\n     (\"uppercase_variables\",\n      LintSpec {\n          lint: UppercaseVariables,\n@@ -1342,6 +1350,30 @@ fn check_item_non_camel_case_types(cx: &Context, it: &ast::Item) {\n     }\n }\n \n+fn check_snake_case(cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n+    fn is_snake_case(ident: ast::Ident) -> bool {\n+        let ident = token::get_ident(ident);\n+        assert!(!ident.get().is_empty());\n+        let ident = ident.get().trim_chars('_');\n+\n+        let mut allow_underscore = true;\n+        ident.chars().all(|c| {\n+            allow_underscore = match c {\n+                c if c.is_lowercase() || c.is_digit() => true,\n+                '_' if allow_underscore => false,\n+                _ => return false,\n+            };\n+            true\n+        })\n+    }\n+\n+    if !is_snake_case(ident) {\n+        cx.span_lint(NonSnakeCaseFunctions, span,\n+                    format!(\"{} `{}` should have a snake case identifier\",\n+                            sort, token::get_ident(ident)).as_slice());\n+    }\n+}\n+\n fn check_item_non_uppercase_statics(cx: &Context, it: &ast::Item) {\n     match it.node {\n         // only check static constants\n@@ -1618,7 +1650,27 @@ fn check_missing_doc_item(cx: &Context, it: &ast::Item) {\n                             desc);\n }\n \n+#[deriving(Eq)]\n+enum MethodContext {\n+    TraitDefaultImpl,\n+    TraitImpl,\n+    PlainImpl\n+}\n+\n fn check_missing_doc_method(cx: &Context, m: &ast::Method) {\n+    // If the method is an impl for a trait, don't doc.\n+    if method_context(cx, m) == TraitImpl { return; }\n+\n+    // Otherwise, doc according to privacy. This will also check\n+    // doc for default methods defined on traits.\n+    check_missing_doc_attrs(cx,\n+                            Some(m.id),\n+                            m.attrs.as_slice(),\n+                            m.span,\n+                            \"a method\");\n+}\n+\n+fn method_context(cx: &Context, m: &ast::Method) -> MethodContext {\n     let did = ast::DefId {\n         krate: ast::LOCAL_CRATE,\n         node: m.id\n@@ -1628,25 +1680,16 @@ fn check_missing_doc_method(cx: &Context, m: &ast::Method) {\n         None => cx.tcx.sess.span_bug(m.span, \"missing method descriptor?!\"),\n         Some(md) => {\n             match md.container {\n-                // Always check default methods defined on traits.\n-                ty::TraitContainer(..) => {}\n-                // For methods defined on impls, it depends on whether\n-                // it is an implementation for a trait or is a plain\n-                // impl.\n+                ty::TraitContainer(..) => TraitDefaultImpl,\n                 ty::ImplContainer(cid) => {\n                     match ty::impl_trait_ref(cx.tcx, cid) {\n-                        Some(..) => return, // impl for trait: don't doc\n-                        None => {} // plain impl: doc according to privacy\n+                        Some(..) => TraitImpl,\n+                        None => PlainImpl\n                     }\n                 }\n             }\n         }\n     }\n-    check_missing_doc_attrs(cx,\n-                            Some(m.id),\n-                            m.attrs.as_slice(),\n-                            m.span,\n-                            \"a method\");\n }\n \n fn check_missing_doc_ty_method(cx: &Context, tm: &ast::TypeMethod) {\n@@ -1889,26 +1932,36 @@ impl<'a> Visitor<()> for Context<'a> {\n         }\n \n         match *fk {\n-            visit::FkMethod(_, _, m) => {\n+            visit::FkMethod(ident, _, m) => {\n                 self.with_lint_attrs(m.attrs.as_slice(), |cx| {\n                     check_missing_doc_method(cx, m);\n                     check_attrs_usage(cx, m.attrs.as_slice());\n \n+                    match method_context(cx, m) {\n+                        PlainImpl => check_snake_case(cx, \"method\", ident, span),\n+                        TraitDefaultImpl => check_snake_case(cx, \"trait method\", ident, span),\n+                        _ => (),\n+                    }\n+\n                     cx.visit_ids(|v| {\n                         v.visit_fn(fk, decl, body, span, id, ());\n                     });\n                     recurse(cx);\n                 })\n+            },\n+            visit::FkItemFn(ident, _, _, _) => {\n+                check_snake_case(self, \"function\", ident, span);\n+                recurse(self);\n             }\n             _ => recurse(self),\n         }\n     }\n \n-\n     fn visit_ty_method(&mut self, t: &ast::TypeMethod, _: ()) {\n         self.with_lint_attrs(t.attrs.as_slice(), |cx| {\n             check_missing_doc_ty_method(cx, t);\n             check_attrs_usage(cx, t.attrs.as_slice());\n+            check_snake_case(cx, \"trait method\", t.ident, t.span);\n \n             visit::walk_ty_method(cx, t, ());\n         })"}, {"sha": "e0d411f9f97bce3536f1b22e0cd7fe8c0c504947", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -177,7 +177,7 @@ impl<'a> Visitor<()> for IrMaps<'a> {\n \n pub fn check_crate(tcx: &ty::ctxt,\n                    krate: &Crate) {\n-    visit::walk_crate(&mut IrMaps(tcx), krate, ());\n+    visit::walk_crate(&mut IrMaps::new(tcx), krate, ());\n     tcx.sess.abort_if_errors();\n }\n \n@@ -260,21 +260,20 @@ struct IrMaps<'a> {\n     lnks: Vec<LiveNodeKind>,\n }\n \n-fn IrMaps<'a>(tcx: &'a ty::ctxt)\n-              -> IrMaps<'a> {\n-    IrMaps {\n-        tcx: tcx,\n-        num_live_nodes: 0,\n-        num_vars: 0,\n-        live_node_map: NodeMap::new(),\n-        variable_map: NodeMap::new(),\n-        capture_info_map: NodeMap::new(),\n-        var_kinds: Vec::new(),\n-        lnks: Vec::new(),\n+impl<'a> IrMaps<'a> {\n+    fn new(tcx: &'a ty::ctxt) -> IrMaps<'a> {\n+        IrMaps {\n+            tcx: tcx,\n+            num_live_nodes: 0,\n+            num_vars: 0,\n+            live_node_map: NodeMap::new(),\n+            variable_map: NodeMap::new(),\n+            capture_info_map: NodeMap::new(),\n+            var_kinds: Vec::new(),\n+            lnks: Vec::new(),\n+        }\n     }\n-}\n \n-impl<'a> IrMaps<'a> {\n     fn add_live_node(&mut self, lnk: LiveNodeKind) -> LiveNode {\n         let ln = LiveNode(self.num_live_nodes);\n         self.lnks.push(lnk);\n@@ -365,7 +364,7 @@ fn visit_fn(ir: &mut IrMaps,\n     let _i = ::util::common::indenter();\n \n     // swap in a new set of IR maps for this function body:\n-    let mut fn_maps = IrMaps(ir.tcx);\n+    let mut fn_maps = IrMaps::new(ir.tcx);\n \n     unsafe {\n         debug!(\"creating fn_maps: {}\", transmute::<&IrMaps, *IrMaps>(&fn_maps));\n@@ -396,7 +395,7 @@ fn visit_fn(ir: &mut IrMaps,\n     };\n \n     // compute liveness\n-    let mut lsets = Liveness(&mut fn_maps, specials);\n+    let mut lsets = Liveness::new(&mut fn_maps, specials);\n     let entry_ln = lsets.compute(decl, body);\n \n     // check for various error conditions\n@@ -584,19 +583,19 @@ struct Liveness<'a> {\n     cont_ln: NodeMap<LiveNode>\n }\n \n-fn Liveness<'a>(ir: &'a mut IrMaps<'a>, specials: Specials) -> Liveness<'a> {\n-    Liveness {\n-        ir: ir,\n-        s: specials,\n-        successors: Vec::from_elem(ir.num_live_nodes, invalid_node()),\n-        users: Vec::from_elem(ir.num_live_nodes * ir.num_vars, invalid_users()),\n-        loop_scope: Vec::new(),\n-        break_ln: NodeMap::new(),\n-        cont_ln: NodeMap::new(),\n+impl<'a> Liveness<'a> {\n+    fn new(ir: &'a mut IrMaps<'a>, specials: Specials) -> Liveness<'a> {\n+        Liveness {\n+            ir: ir,\n+            s: specials,\n+            successors: Vec::from_elem(ir.num_live_nodes, invalid_node()),\n+            users: Vec::from_elem(ir.num_live_nodes * ir.num_vars, invalid_users()),\n+            loop_scope: Vec::new(),\n+            break_ln: NodeMap::new(),\n+            cont_ln: NodeMap::new(),\n+        }\n     }\n-}\n \n-impl<'a> Liveness<'a> {\n     fn live_node(&self, node_id: NodeId, span: Span) -> LiveNode {\n         match self.ir.live_node_map.find(&node_id) {\n           Some(&ln) => ln,"}, {"sha": "077f61a34c6bcfab3fa6627c14405b48ac0a86f6", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 85, "deletions": 90, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -549,6 +549,13 @@ enum TraitReferenceType {\n }\n \n impl NameBindings {\n+    fn new() -> NameBindings {\n+        NameBindings {\n+            type_def: RefCell::new(None),\n+            value_def: RefCell::new(None),\n+        }\n+    }\n+\n     /// Creates a new module in this set of name bindings.\n     fn define_module(&self,\n                      parent_link: ParentLink,\n@@ -749,49 +756,42 @@ impl NameBindings {\n     }\n }\n \n-fn NameBindings() -> NameBindings {\n-    NameBindings {\n-        type_def: RefCell::new(None),\n-        value_def: RefCell::new(None),\n-    }\n-}\n-\n /// Interns the names of the primitive types.\n struct PrimitiveTypeTable {\n     primitive_types: HashMap<Name, PrimTy>,\n }\n \n impl PrimitiveTypeTable {\n+    fn new() -> PrimitiveTypeTable {\n+        let mut table = PrimitiveTypeTable {\n+            primitive_types: HashMap::new()\n+        };\n+\n+        table.intern(\"bool\",    TyBool);\n+        table.intern(\"char\",    TyChar);\n+        table.intern(\"f32\",     TyFloat(TyF32));\n+        table.intern(\"f64\",     TyFloat(TyF64));\n+        table.intern(\"f128\",    TyFloat(TyF128));\n+        table.intern(\"int\",     TyInt(TyI));\n+        table.intern(\"i8\",      TyInt(TyI8));\n+        table.intern(\"i16\",     TyInt(TyI16));\n+        table.intern(\"i32\",     TyInt(TyI32));\n+        table.intern(\"i64\",     TyInt(TyI64));\n+        table.intern(\"str\",     TyStr);\n+        table.intern(\"uint\",    TyUint(TyU));\n+        table.intern(\"u8\",      TyUint(TyU8));\n+        table.intern(\"u16\",     TyUint(TyU16));\n+        table.intern(\"u32\",     TyUint(TyU32));\n+        table.intern(\"u64\",     TyUint(TyU64));\n+\n+        table\n+    }\n+\n     fn intern(&mut self, string: &str, primitive_type: PrimTy) {\n         self.primitive_types.insert(token::intern(string), primitive_type);\n     }\n }\n \n-fn PrimitiveTypeTable() -> PrimitiveTypeTable {\n-    let mut table = PrimitiveTypeTable {\n-        primitive_types: HashMap::new()\n-    };\n-\n-    table.intern(\"bool\",    TyBool);\n-    table.intern(\"char\",    TyChar);\n-    table.intern(\"f32\",     TyFloat(TyF32));\n-    table.intern(\"f64\",     TyFloat(TyF64));\n-    table.intern(\"f128\",    TyFloat(TyF128));\n-    table.intern(\"int\",     TyInt(TyI));\n-    table.intern(\"i8\",      TyInt(TyI8));\n-    table.intern(\"i16\",     TyInt(TyI16));\n-    table.intern(\"i32\",     TyInt(TyI32));\n-    table.intern(\"i64\",     TyInt(TyI64));\n-    table.intern(\"str\",     TyStr);\n-    table.intern(\"uint\",    TyUint(TyU));\n-    table.intern(\"u8\",      TyUint(TyU8));\n-    table.intern(\"u16\",     TyUint(TyU16));\n-    table.intern(\"u32\",     TyUint(TyU32));\n-    table.intern(\"u64\",     TyUint(TyU64));\n-\n-    return table;\n-}\n-\n \n fn namespace_error_to_str(ns: NamespaceError) -> &'static str {\n     match ns {\n@@ -802,62 +802,6 @@ fn namespace_error_to_str(ns: NamespaceError) -> &'static str {\n     }\n }\n \n-fn Resolver<'a>(session: &'a Session,\n-                lang_items: &'a LanguageItems,\n-                crate_span: Span) -> Resolver<'a> {\n-    let graph_root = NameBindings();\n-\n-    graph_root.define_module(NoParentLink,\n-                             Some(DefId { krate: 0, node: 0 }),\n-                             NormalModuleKind,\n-                             false,\n-                             true,\n-                             crate_span);\n-\n-    let current_module = graph_root.get_module();\n-\n-    let this = Resolver {\n-        session: session,\n-        lang_items: lang_items,\n-\n-        // The outermost module has def ID 0; this is not reflected in the\n-        // AST.\n-\n-        graph_root: graph_root,\n-\n-        method_map: RefCell::new(FnvHashMap::new()),\n-        structs: FnvHashMap::new(),\n-\n-        unresolved_imports: 0,\n-\n-        current_module: current_module,\n-        value_ribs: RefCell::new(Vec::new()),\n-        type_ribs: RefCell::new(Vec::new()),\n-        label_ribs: RefCell::new(Vec::new()),\n-\n-        current_trait_ref: None,\n-        current_self_type: None,\n-\n-        self_ident: special_idents::self_,\n-        type_self_ident: special_idents::type_self,\n-\n-        primitive_type_table: PrimitiveTypeTable(),\n-\n-        namespaces: vec!(TypeNS, ValueNS),\n-\n-        def_map: RefCell::new(NodeMap::new()),\n-        export_map2: RefCell::new(NodeMap::new()),\n-        trait_map: NodeMap::new(),\n-        used_imports: HashSet::new(),\n-        external_exports: DefIdSet::new(),\n-        last_private: NodeMap::new(),\n-\n-        emit_errors: true,\n-    };\n-\n-    this\n-}\n-\n /// The main resolver class.\n struct Resolver<'a> {\n     session: &'a Session,\n@@ -957,6 +901,57 @@ impl<'a, 'b> Visitor<()> for UnusedImportCheckVisitor<'a, 'b> {\n }\n \n impl<'a> Resolver<'a> {\n+    fn new(session: &'a Session, lang_items: &'a LanguageItems, crate_span: Span) -> Resolver<'a> {\n+        let graph_root = NameBindings::new();\n+\n+        graph_root.define_module(NoParentLink,\n+                                 Some(DefId { krate: 0, node: 0 }),\n+                                 NormalModuleKind,\n+                                 false,\n+                                 true,\n+                                 crate_span);\n+\n+        let current_module = graph_root.get_module();\n+\n+        Resolver {\n+            session: session,\n+            lang_items: lang_items,\n+\n+            // The outermost module has def ID 0; this is not reflected in the\n+            // AST.\n+\n+            graph_root: graph_root,\n+\n+            method_map: RefCell::new(FnvHashMap::new()),\n+            structs: FnvHashMap::new(),\n+\n+            unresolved_imports: 0,\n+\n+            current_module: current_module,\n+            value_ribs: RefCell::new(Vec::new()),\n+            type_ribs: RefCell::new(Vec::new()),\n+            label_ribs: RefCell::new(Vec::new()),\n+\n+            current_trait_ref: None,\n+            current_self_type: None,\n+\n+            self_ident: special_idents::self_,\n+            type_self_ident: special_idents::type_self,\n+\n+            primitive_type_table: PrimitiveTypeTable::new(),\n+\n+            namespaces: vec!(TypeNS, ValueNS),\n+\n+            def_map: RefCell::new(NodeMap::new()),\n+            export_map2: RefCell::new(NodeMap::new()),\n+            trait_map: NodeMap::new(),\n+            used_imports: HashSet::new(),\n+            external_exports: DefIdSet::new(),\n+            last_private: NodeMap::new(),\n+\n+            emit_errors: true,\n+        }\n+    }\n     /// The main name resolution procedure.\n     fn resolve(&mut self, krate: &ast::Crate) {\n         self.build_reduced_graph(krate);\n@@ -1017,7 +1012,7 @@ impl<'a> Resolver<'a> {\n         let child = module_.children.borrow().find_copy(&name.name);\n         match child {\n             None => {\n-                let child = Rc::new(NameBindings());\n+                let child = Rc::new(NameBindings::new());\n                 module_.children.borrow_mut().insert(name.name, child.clone());\n                 child\n             }\n@@ -5574,7 +5569,7 @@ pub fn resolve_crate(session: &Session,\n                      lang_items: &LanguageItems,\n                      krate: &Crate)\n                   -> CrateMap {\n-    let mut resolver = Resolver(session, lang_items, krate.span);\n+    let mut resolver = Resolver::new(session, lang_items, krate.span);\n     resolver.resolve(krate);\n     let Resolver { def_map, export_map2, trait_map, last_private,\n                    external_exports, .. } = resolver;"}, {"sha": "86ddd5e0e98a12f577f07c601f2331f0a10f0e7b", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -997,7 +997,7 @@ fn match_datum(bcx: &Block,\n      */\n \n     let ty = node_id_type(bcx, pat_id);\n-    Datum(val, ty, Lvalue)\n+    Datum::new(val, ty, Lvalue)\n }\n \n \n@@ -1297,7 +1297,7 @@ fn store_non_ref_bindings<'a>(\n         match binding_info.trmode {\n             TrByValue(lldest) => {\n                 let llval = Load(bcx, binding_info.llmatch); // get a T*\n-                let datum = Datum(llval, binding_info.ty, Lvalue);\n+                let datum = Datum::new(llval, binding_info.ty, Lvalue);\n                 bcx = datum.store_to(bcx, lldest);\n \n                 match opt_cleanup_scope {\n@@ -1334,7 +1334,7 @@ fn insert_lllocals<'a>(bcx: &'a Block<'a>,\n             TrByRef => binding_info.llmatch\n         };\n \n-        let datum = Datum(llval, binding_info.ty, Lvalue);\n+        let datum = Datum::new(llval, binding_info.ty, Lvalue);\n         fcx.schedule_drop_mem(cleanup_scope, llval, binding_info.ty);\n \n         debug!(\"binding {:?} to {}\",\n@@ -2081,7 +2081,7 @@ pub fn store_arg<'a>(mut bcx: &'a Block<'a>,\n                 // we emit extra-debug-info, which requires local allocas :(.\n                 let arg_val = arg.add_clean(bcx.fcx, arg_scope);\n                 bcx.fcx.llargs.borrow_mut()\n-                   .insert(pat.id, Datum(arg_val, arg_ty, Lvalue));\n+                   .insert(pat.id, Datum::new(arg_val, arg_ty, Lvalue));\n                 bcx\n             } else {\n                 mk_binding_alloca(\n@@ -2122,7 +2122,7 @@ fn mk_binding_alloca<'a,A>(bcx: &'a Block<'a>,\n \n     // Now that memory is initialized and has cleanup scheduled,\n     // create the datum and insert into the local variable map.\n-    let datum = Datum(llval, var_ty, Lvalue);\n+    let datum = Datum::new(llval, var_ty, Lvalue);\n     let mut llmap = match binding_mode {\n         BindLocal => bcx.fcx.lllocals.borrow_mut(),\n         BindArgument => bcx.fcx.llargs.borrow_mut()\n@@ -2183,7 +2183,7 @@ fn bind_irrefutable_pat<'a>(\n                             ast::BindByValue(_) => {\n                                 // By value binding: move the value that `val`\n                                 // points at into the binding's stack slot.\n-                                let d = Datum(val, ty, Lvalue);\n+                                let d = Datum::new(val, ty, Lvalue);\n                                 d.store_to(bcx, llval)\n                             }\n "}, {"sha": "7ef6038d715d2627853d04e9d505491071f3dea1", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -70,7 +70,7 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n                                     .connect(\",\")\n                                     .as_slice());\n \n-    let mut clobbers = getClobbers();\n+    let mut clobbers = get_clobbers();\n     if !ia.clobbers.get().is_empty() && !clobbers.is_empty() {\n         clobbers = format!(\"{},{}\", ia.clobbers.get(), clobbers);\n     } else {\n@@ -135,12 +135,12 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n \n #[cfg(target_arch = \"arm\")]\n #[cfg(target_arch = \"mips\")]\n-fn getClobbers() -> String {\n+fn get_clobbers() -> String {\n     \"\".to_string()\n }\n \n #[cfg(target_arch = \"x86\")]\n #[cfg(target_arch = \"x86_64\")]\n-fn getClobbers() -> String {\n+fn get_clobbers() -> String {\n     \"~{dirflag},~{fpsr},~{flags}\".to_string()\n }"}, {"sha": "464e8cff0fa67b9b5a80dcb3d7421bf4101789db", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -1210,7 +1210,7 @@ pub fn create_datums_for_fn_args(fcx: &FunctionContext,\n         let llarg = unsafe {\n             llvm::LLVMGetParam(fcx.llfn, fcx.arg_pos(i) as c_uint)\n         };\n-        datum::Datum(llarg, arg_ty, arg_kind(fcx, arg_ty))\n+        datum::Datum::new(llarg, arg_ty, arg_kind(fcx, arg_ty))\n     }).collect()\n }\n "}, {"sha": "e04454d4a68d0233099381dca4f55ff45c8c0659", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![allow(dead_code)] // FFI wrappers\n+#![allow(non_snake_case_functions)]\n \n use lib::llvm::llvm;\n use lib::llvm::{CallConv, AtomicBinOp, AtomicOrdering, AsmDialect};"}, {"sha": "9ca66f4c3b05663661159010af4ce3958d3b5a9c", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -460,5 +460,5 @@ pub fn make_closure_from_bare_fn<'a>(bcx: &'a Block<'a>,\n     let wrapper = get_wrapper_for_bare_fn(bcx.ccx(), closure_ty, def, fn_ptr, true);\n     fill_fn_pair(bcx, scratch.val, wrapper, C_null(Type::i8p(bcx.ccx())));\n \n-    DatumBlock(bcx, scratch.to_expr_datum())\n+    DatumBlock::new(bcx, scratch.to_expr_datum())\n }"}, {"sha": "0530e2a74630eb9084a1c52b12c34183cdff6d70", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_camel_case_types)]\n+#![allow(non_camel_case_types, non_snake_case_functions)]\n \n //! Code that is useful in various trans modules.\n \n@@ -21,7 +21,6 @@ use middle::lang_items::LangItem;\n use middle::trans::build;\n use middle::trans::cleanup;\n use middle::trans::datum;\n-use middle::trans::datum::{Datum, Lvalue};\n use middle::trans::debuginfo;\n use middle::trans::type_::Type;\n use middle::ty;"}, {"sha": "af9e614a17ef9277c937176be772281b6d53964b", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -71,8 +71,10 @@ pub struct Rvalue {\n     pub mode: RvalueMode\n }\n \n-pub fn Rvalue(m: RvalueMode) -> Rvalue {\n-    Rvalue { mode: m }\n+impl Rvalue {\n+    pub fn new(m: RvalueMode) -> Rvalue {\n+        Rvalue { mode: m }\n+    }\n }\n \n // Make Datum linear for more type safety.\n@@ -89,25 +91,15 @@ pub enum RvalueMode {\n     ByValue,\n }\n \n-pub fn Datum<K:KindOps>(val: ValueRef, ty: ty::t, kind: K) -> Datum<K> {\n-    Datum { val: val, ty: ty, kind: kind }\n-}\n-\n-pub fn DatumBlock<'a, K>(bcx: &'a Block<'a>,\n-                         datum: Datum<K>)\n-                         -> DatumBlock<'a, K> {\n-    DatumBlock { bcx: bcx, datum: datum }\n-}\n-\n pub fn immediate_rvalue(val: ValueRef, ty: ty::t) -> Datum<Rvalue> {\n-    return Datum(val, ty, Rvalue(ByValue));\n+    return Datum::new(val, ty, Rvalue::new(ByValue));\n }\n \n pub fn immediate_rvalue_bcx<'a>(bcx: &'a Block<'a>,\n                                 val: ValueRef,\n                                 ty: ty::t)\n                                 -> DatumBlock<'a, Rvalue> {\n-    return DatumBlock(bcx, immediate_rvalue(val, ty))\n+    return DatumBlock::new(bcx, immediate_rvalue(val, ty))\n }\n \n \n@@ -136,7 +128,7 @@ pub fn lvalue_scratch_datum<'a, A>(bcx: &'a Block<'a>,\n     let bcx = populate(arg, bcx, scratch);\n     bcx.fcx.schedule_drop_mem(scope, scratch, ty);\n \n-    DatumBlock(bcx, Datum(scratch, ty, Lvalue))\n+    DatumBlock::new(bcx, Datum::new(scratch, ty, Lvalue))\n }\n \n pub fn rvalue_scratch_datum(bcx: &Block,\n@@ -155,7 +147,7 @@ pub fn rvalue_scratch_datum(bcx: &Block,\n \n     let llty = type_of::type_of(bcx.ccx(), ty);\n     let scratch = alloca_maybe_zeroed(bcx, llty, name, false);\n-    Datum(scratch, ty, Rvalue(ByRef))\n+    Datum::new(scratch, ty, Rvalue::new(ByRef))\n }\n \n pub fn appropriate_rvalue_mode(ccx: &CrateContext, ty: ty::t) -> RvalueMode {\n@@ -320,7 +312,7 @@ impl Datum<Rvalue> {\n         match self.kind.mode {\n             ByRef => {\n                 add_rvalue_clean(ByRef, fcx, scope, self.val, self.ty);\n-                DatumBlock(bcx, Datum(self.val, self.ty, Lvalue))\n+                DatumBlock::new(bcx, Datum::new(self.val, self.ty, Lvalue))\n             }\n \n             ByValue => {\n@@ -334,11 +326,11 @@ impl Datum<Rvalue> {\n     pub fn to_ref_datum<'a>(self, bcx: &'a Block<'a>) -> DatumBlock<'a, Rvalue> {\n         let mut bcx = bcx;\n         match self.kind.mode {\n-            ByRef => DatumBlock(bcx, self),\n+            ByRef => DatumBlock::new(bcx, self),\n             ByValue => {\n                 let scratch = rvalue_scratch_datum(bcx, self.ty, \"to_ref\");\n                 bcx = self.store_to(bcx, scratch.val);\n-                DatumBlock(bcx, scratch)\n+                DatumBlock::new(bcx, scratch)\n             }\n         }\n     }\n@@ -352,10 +344,10 @@ impl Datum<Rvalue> {\n             }\n             ByValue => {\n                 match self.kind.mode {\n-                    ByValue => DatumBlock(bcx, self),\n+                    ByValue => DatumBlock::new(bcx, self),\n                     ByRef => {\n                         let llval = load(bcx, self.val, self.ty);\n-                        DatumBlock(bcx, Datum(llval, self.ty, Rvalue(ByValue)))\n+                        DatumBlock::new(bcx, Datum::new(llval, self.ty, Rvalue::new(ByValue)))\n                     }\n                 }\n             }\n@@ -378,8 +370,8 @@ impl Datum<Expr> {\n                      -> R {\n         let Datum { val, ty, kind } = self;\n         match kind {\n-            LvalueExpr => if_lvalue(Datum(val, ty, Lvalue)),\n-            RvalueExpr(r) => if_rvalue(Datum(val, ty, r)),\n+            LvalueExpr => if_lvalue(Datum::new(val, ty, Lvalue)),\n+            RvalueExpr(r) => if_rvalue(Datum::new(val, ty, r)),\n         }\n     }\n \n@@ -455,7 +447,7 @@ impl Datum<Expr> {\n                                expr_id: ast::NodeId)\n                                -> DatumBlock<'a, Lvalue> {\n         self.match_kind(\n-            |l| DatumBlock(bcx, l),\n+            |l| DatumBlock::new(bcx, l),\n             |r| {\n                 let scope = cleanup::temporary_scope(bcx.tcx(), expr_id);\n                 r.to_lvalue_datum_in_scope(bcx, name, scope)\n@@ -478,16 +470,16 @@ impl Datum<Expr> {\n                     ByRef => {\n                         let scratch = rvalue_scratch_datum(bcx, l.ty, name);\n                         bcx = l.store_to(bcx, scratch.val);\n-                        DatumBlock(bcx, scratch)\n+                        DatumBlock::new(bcx, scratch)\n                     }\n                     ByValue => {\n                         let v = load(bcx, l.val, l.ty);\n                         bcx = l.kind.post_store(bcx, l.val, l.ty);\n-                        DatumBlock(bcx, Datum(v, l.ty, Rvalue(ByValue)))\n+                        DatumBlock::new(bcx, Datum::new(v, l.ty, Rvalue::new(ByValue)))\n                     }\n                 }\n             },\n-            |r| DatumBlock(bcx, r))\n+            |r| DatumBlock::new(bcx, r))\n     }\n \n }\n@@ -550,6 +542,10 @@ fn load<'a>(bcx: &'a Block<'a>, llptr: ValueRef, ty: ty::t) -> ValueRef {\n  * Generic methods applicable to any sort of datum.\n  */\n impl<K:KindOps> Datum<K> {\n+    pub fn new(val: ValueRef, ty: ty::t, kind: K) -> Datum<K> {\n+        Datum { val: val, ty: ty, kind: kind }\n+    }\n+\n     pub fn to_expr_datum(self) -> Datum<Expr> {\n         let Datum { val, ty, kind } = self;\n         Datum { val: val, ty: ty, kind: kind.to_expr_kind() }\n@@ -663,9 +659,15 @@ impl<K:KindOps> Datum<K> {\n     }\n }\n \n+impl <'a, K> DatumBlock<'a, K> {\n+    pub fn new(bcx: &'a Block<'a>, datum: Datum<K>) -> DatumBlock<'a, K> {\n+        DatumBlock { bcx: bcx, datum: datum }\n+    }\n+}\n+\n impl<'a, K:KindOps> DatumBlock<'a, K> {\n     pub fn to_expr_datumblock(self) -> DatumBlock<'a, Expr> {\n-        DatumBlock(self.bcx, self.datum.to_expr_datum())\n+        DatumBlock::new(self.bcx, self.datum.to_expr_datum())\n     }\n }\n "}, {"sha": "43d0d71154c3fdb82877fd89d3000ffca7451f52", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -941,6 +941,7 @@ fn is_node_local_to_unit(cx: &CrateContext, node_id: ast::NodeId) -> bool\n     !cx.reachable.contains(&node_id)\n }\n \n+#[allow(non_snake_case_functions)]\n fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n     return unsafe {\n         llvm::LLVMDIBuilderGetOrCreateArray(builder, arr.as_ptr(), arr.len() as u32)\n@@ -2487,6 +2488,7 @@ fn debug_context<'a>(cx: &'a CrateContext) -> &'a CrateDebugContext {\n }\n \n #[inline]\n+#[allow(non_snake_case_functions)]\n fn DIB(cx: &CrateContext) -> DIBuilderRef {\n     cx.dbg_cx.get_ref().builder\n }"}, {"sha": "1f997c36c42f0f9f3a77e46ba457a2bd43f3f177", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -152,7 +152,7 @@ pub fn trans<'a>(bcx: &'a Block<'a>,\n     let datum = unpack_datum!(bcx, trans_unadjusted(bcx, expr));\n     let datum = unpack_datum!(bcx, apply_adjustments(bcx, expr, datum));\n     bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, expr.id);\n-    return DatumBlock(bcx, datum);\n+    return DatumBlock::new(bcx, datum);\n }\n \n fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n@@ -168,7 +168,7 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n     let mut datum = datum;\n     let adjustment = match bcx.tcx().adjustments.borrow().find_copy(&expr.id) {\n         None => {\n-            return DatumBlock(bcx, datum);\n+            return DatumBlock::new(bcx, datum);\n         }\n         Some(adj) => { adj }\n     };\n@@ -244,7 +244,7 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n         let scratch = rvalue_scratch_datum(bcx, slice_ty, \"__adjust\");\n         Store(bcx, base, GEPi(bcx, scratch.val, [0u, abi::slice_elt_base]));\n         Store(bcx, len, GEPi(bcx, scratch.val, [0u, abi::slice_elt_len]));\n-        DatumBlock(bcx, scratch.to_expr_datum())\n+        DatumBlock::new(bcx, scratch.to_expr_datum())\n     }\n \n     fn add_env<'a>(bcx: &'a Block<'a>,\n@@ -282,7 +282,7 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n \n         let mut datum = source_datum.to_expr_datum();\n         datum.ty = target_obj_ty;\n-        DatumBlock(bcx, datum)\n+        DatumBlock::new(bcx, datum)\n     }\n }\n \n@@ -357,15 +357,15 @@ fn trans_unadjusted<'a>(bcx: &'a Block<'a>,\n                 let scratch = unpack_datum!(\n                     bcx, scratch.to_appropriate_datum(bcx));\n \n-                DatumBlock(bcx, scratch.to_expr_datum())\n+                DatumBlock::new(bcx, scratch.to_expr_datum())\n             }\n         }\n     };\n \n     fn nil<'a>(bcx: &'a Block<'a>, ty: ty::t) -> DatumBlock<'a, Expr> {\n         let llval = C_undef(type_of::type_of(bcx.ccx(), ty));\n         let datum = immediate_rvalue(llval, ty);\n-        DatumBlock(bcx, datum.to_expr_datum())\n+        DatumBlock::new(bcx, datum.to_expr_datum())\n     }\n }\n \n@@ -394,7 +394,7 @@ fn trans_datum_unadjusted<'a>(bcx: &'a Block<'a>,\n             let datum = unpack_datum!(\n                 bcx, tvec::trans_uniq_vstore(bcx, expr, contents));\n             bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, contents.id);\n-            DatumBlock(bcx, datum)\n+            DatumBlock::new(bcx, datum)\n         }\n         ast::ExprBox(_, contents) => {\n             // Special case for `box T`. (The other case, for GC, is handled\n@@ -494,7 +494,7 @@ fn trans_index<'a>(bcx: &'a Block<'a>,\n         });\n     let elt = InBoundsGEP(bcx, base, [ix_val]);\n     let elt = PointerCast(bcx, elt, vt.llunit_ty.ptr_to());\n-    DatumBlock(bcx, Datum(elt, vt.unit_ty, LvalueExpr))\n+    DatumBlock::new(bcx, Datum::new(elt, vt.unit_ty, LvalueExpr))\n }\n \n fn trans_def<'a>(bcx: &'a Block<'a>,\n@@ -559,10 +559,10 @@ fn trans_def<'a>(bcx: &'a Block<'a>,\n \n             let did = get_did(bcx.ccx(), did);\n             let val = get_val(bcx, did, const_ty);\n-            DatumBlock(bcx, Datum(val, const_ty, LvalueExpr))\n+            DatumBlock::new(bcx, Datum::new(val, const_ty, LvalueExpr))\n         }\n         _ => {\n-            DatumBlock(bcx, trans_local_var(bcx, def).to_expr_datum())\n+            DatumBlock::new(bcx, trans_local_var(bcx, def).to_expr_datum())\n         }\n     }\n }\n@@ -845,7 +845,7 @@ fn trans_def_fn_unadjusted<'a>(bcx: &'a Block<'a>,\n     };\n \n     let fn_ty = expr_ty(bcx, ref_expr);\n-    DatumBlock(bcx, Datum(llfn, fn_ty, RvalueExpr(Rvalue(ByValue))))\n+    DatumBlock::new(bcx, Datum::new(llfn, fn_ty, RvalueExpr(Rvalue::new(ByValue))))\n }\n \n pub fn trans_local_var<'a>(bcx: &'a Block<'a>,\n@@ -863,7 +863,7 @@ pub fn trans_local_var<'a>(bcx: &'a Block<'a>,\n             // Can't move upvars, so this is never a ZeroMemLastUse.\n             let local_ty = node_id_type(bcx, nid);\n             match bcx.fcx.llupvars.borrow().find(&nid) {\n-                Some(&val) => Datum(val, local_ty, Lvalue),\n+                Some(&val) => Datum::new(val, local_ty, Lvalue),\n                 None => {\n                     bcx.sess().bug(format!(\n                         \"trans_local_var: no llval for upvar {:?} found\",\n@@ -1664,7 +1664,7 @@ fn auto_ref<'a>(bcx: &'a Block<'a>,\n     // Construct the resulting datum, using what was the \"by ref\"\n     // ValueRef of type `referent_ty` to be the \"by value\" ValueRef\n     // of type `&referent_ty`.\n-    DatumBlock(bcx, Datum(llref, ptr_ty, RvalueExpr(Rvalue(ByValue))))\n+    DatumBlock::new(bcx, Datum::new(llref, ptr_ty, RvalueExpr(Rvalue::new(ByValue))))\n }\n \n fn deref_multiple<'a>(bcx: &'a Block<'a>,\n@@ -1717,7 +1717,7 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n             let val = unpack_result!(bcx, trans_overloaded_op(bcx, expr, method_call,\n                                                               datum, None, None));\n             let ref_ty = ty::ty_fn_ret(monomorphize_type(bcx, method_ty));\n-            Datum(val, ref_ty, RvalueExpr(Rvalue(ByValue)))\n+            Datum::new(val, ref_ty, RvalueExpr(Rvalue::new(ByValue)))\n         }\n         None => {\n             // Not overloaded. We already have a pointer we know how to deref.\n@@ -1740,7 +1740,7 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n             let llptrref = datum.to_llref();\n             let llptr = Load(bcx, llptrref);\n             let llbody = GEPi(bcx, llptr, [0u, abi::box_field_body]);\n-            DatumBlock(bcx, Datum(llbody, content_ty, LvalueExpr))\n+            DatumBlock::new(bcx, Datum::new(llbody, content_ty, LvalueExpr))\n         }\n \n         ty::ty_ptr(ty::mt { ty: content_ty, .. }) |\n@@ -1758,7 +1758,7 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n                     // rvalue for non-owning pointers like &T or *T, in which\n                     // case cleanup *is* scheduled elsewhere, by the true\n                     // owner (or, in the case of *T, by the user).\n-                    DatumBlock(bcx, Datum(ptr, content_ty, LvalueExpr))\n+                    DatumBlock::new(bcx, Datum::new(ptr, content_ty, LvalueExpr))\n                 }\n             }\n         }\n@@ -1818,10 +1818,10 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n                 (Load(bcx, datum.val), LvalueExpr)\n             }\n             RvalueExpr(Rvalue { mode: ByRef }) => {\n-                (Load(bcx, datum.val), RvalueExpr(Rvalue(ByRef)))\n+                (Load(bcx, datum.val), RvalueExpr(Rvalue::new(ByRef)))\n             }\n             RvalueExpr(Rvalue { mode: ByValue }) => {\n-                (datum.val, RvalueExpr(Rvalue(ByRef)))\n+                (datum.val, RvalueExpr(Rvalue::new(ByRef)))\n             }\n         };\n "}, {"sha": "eea8ce44a9dff72fa38d21c49ce7de2ca1bd7f19", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -309,7 +309,7 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n             let mode = appropriate_rvalue_mode(ccx, tp_ty);\n             let src = Datum {val: get_param(decl, first_real_arg + 1u),\n                              ty: tp_ty,\n-                             kind: Rvalue(mode)};\n+                             kind: Rvalue::new(mode)};\n             bcx = src.store_to(bcx, get_param(decl, first_real_arg));\n             RetVoid(bcx);\n         }"}, {"sha": "a2d460e9162c5dda74a8b5ea0d3be29c6d51617f", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -257,7 +257,7 @@ pub fn trans_uniq_vstore<'a>(bcx: &'a Block<'a>,\n                         alloc_fn,\n                         [ llptrval, llsizeval ],\n                         Some(expr::SaveIn(lldestval.val))).bcx;\n-                    return DatumBlock(bcx, lldestval).to_expr_datumblock();\n+                    return DatumBlock::new(bcx, lldestval).to_expr_datumblock();\n                 }\n                 _ => {}\n             }"}, {"sha": "4dc66427d7f013530fda33a06967976128f29e33", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -840,11 +840,11 @@ pub enum BuiltinBound {\n     BoundShare,\n }\n \n-pub fn EmptyBuiltinBounds() -> BuiltinBounds {\n+pub fn empty_builtin_bounds() -> BuiltinBounds {\n     EnumSet::empty()\n }\n \n-pub fn AllBuiltinBounds() -> BuiltinBounds {\n+pub fn all_builtin_bounds() -> BuiltinBounds {\n     let mut set = EnumSet::empty();\n     set.add(BoundStatic);\n     set.add(BoundSend);\n@@ -2833,7 +2833,7 @@ pub fn adjust_ty(cx: &ctxt,\n                                 ty::ClosureTy {fn_style: b.fn_style,\n                                                onceness: ast::Many,\n                                                store: store,\n-                                               bounds: ty::AllBuiltinBounds(),\n+                                               bounds: ty::all_builtin_bounds(),\n                                                sig: b.sig.clone()})\n                         }\n                         ref b => {\n@@ -4303,7 +4303,7 @@ pub fn visitor_object_ty(tcx: &ctxt,\n                  trait_ref.def_id,\n                  trait_ref.substs.clone(),\n                  RegionTraitStore(region, ast::MutMutable),\n-                 EmptyBuiltinBounds())))\n+                 empty_builtin_bounds())))\n }\n \n pub fn item_variances(tcx: &ctxt, item_id: ast::DefId) -> Rc<ItemVariances> {"}, {"sha": "5323d4468c919e5c911fa82745959df4c5c16de3", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -907,7 +907,7 @@ fn conv_builtin_bounds(tcx: &ty::ctxt, ast_bounds: &Option<OwnedSlice<ast::TyPar\n \n     match (ast_bounds, store) {\n         (&Some(ref bound_vec), _) => {\n-            let mut builtin_bounds = ty::EmptyBuiltinBounds();\n+            let mut builtin_bounds = ty::empty_builtin_bounds();\n             for ast_bound in bound_vec.iter() {\n                 match *ast_bound {\n                     ast::TraitTyParamBound(ref b) => {\n@@ -942,10 +942,10 @@ fn conv_builtin_bounds(tcx: &ty::ctxt, ast_bounds: &Option<OwnedSlice<ast::TyPar\n         },\n         // &'static Trait is sugar for &'static Trait:'static.\n         (&None, ty::RegionTraitStore(ty::ReStatic, _)) => {\n-            let mut set = ty::EmptyBuiltinBounds(); set.add(ty::BoundStatic); set\n+            let mut set = ty::empty_builtin_bounds(); set.add(ty::BoundStatic); set\n         }\n         // No bounds are automatically applied for &'r Trait or ~Trait\n         (&None, ty::RegionTraitStore(..)) |\n-        (&None, ty::UniqTraitStore) => ty::EmptyBuiltinBounds(),\n+        (&None, ty::UniqTraitStore) => ty::empty_builtin_bounds(),\n     }\n }"}, {"sha": "735bec4f4dba98faf449446f41798a34448eee4d", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -274,12 +274,12 @@ fn construct_transformed_self_ty_for_object(\n                     let r = r.subst(tcx, &substs); // handle Early-Bound lifetime\n                     ty::mk_trait(tcx, trait_def_id, substs,\n                                  RegionTraitStore(r, mt.mutbl),\n-                                 ty::EmptyBuiltinBounds())\n+                                 ty::empty_builtin_bounds())\n                 }\n                 ty::ty_uniq(_) => { // must be SelfUniq\n                     ty::mk_trait(tcx, trait_def_id, substs,\n                                  UniqTraitStore,\n-                                 ty::EmptyBuiltinBounds())\n+                                 ty::empty_builtin_bounds())\n                 }\n                 _ => {\n                     tcx.sess.span_bug(span,"}, {"sha": "1987f4b07512d01516d5eab4e90a1f6dca6cba7e", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -2335,7 +2335,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 }\n                 _ => {\n                     // Not an error! Means we're inferring the closure type\n-                    let mut bounds = ty::EmptyBuiltinBounds();\n+                    let mut bounds = ty::empty_builtin_bounds();\n                     let onceness = match expr.node {\n                         ast::ExprProc(..) => {\n                             bounds.add(ty::BoundSend);"}, {"sha": "0d7bbdee3ce4d6f30568486f9f5f112e032b4dda", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -472,7 +472,7 @@ fn fixup_substs(vcx: &VtableContext,\n     let t = ty::mk_trait(tcx,\n                          id, substs,\n                          ty::RegionTraitStore(ty::ReStatic, ast::MutImmutable),\n-                         ty::EmptyBuiltinBounds());\n+                         ty::empty_builtin_bounds());\n     fixup_ty(vcx, span, t, is_early).map(|t_f| {\n         match ty::get(t_f).sty {\n           ty::ty_trait(ref inner) => inner.substs.clone(),\n@@ -574,7 +574,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                       });\n \n                       let param_bounds = ty::ParamBounds {\n-                          builtin_bounds: ty::EmptyBuiltinBounds(),\n+                          builtin_bounds: ty::empty_builtin_bounds(),\n                           trait_bounds: vec!(target_trait_ref)\n                       };\n                       let vtables =\n@@ -766,7 +766,7 @@ pub fn resolve_impl(tcx: &ty::ctxt,\n     // purpose of this is to check for supertrait impls,\n     // but that falls out of doing this.\n     let param_bounds = ty::ParamBounds {\n-        builtin_bounds: ty::EmptyBuiltinBounds(),\n+        builtin_bounds: ty::empty_builtin_bounds(),\n         trait_bounds: vec!(Rc::new(impl_trait_ref))\n     };\n     let t = ty::node_id_to_type(tcx, impl_item.id);"}, {"sha": "4d07d227dc75b316c8860b72dc4dcfaa7a3cc5d9", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -347,7 +347,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n             ident: special_idents::self_,\n             def_id: dummy_defid,\n             bounds: Rc::new(ty::ParamBounds {\n-                builtin_bounds: ty::EmptyBuiltinBounds(),\n+                builtin_bounds: ty::empty_builtin_bounds(),\n                 trait_bounds: vec!(self_trait_ref)\n             }),\n             default: None\n@@ -418,7 +418,7 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n \n     let self_ty = ty::mk_self(ccx.tcx, local_def(id));\n     let mut ty_trait_refs: Vec<Rc<ty::TraitRef>> = Vec::new();\n-    let mut bounds = ty::EmptyBuiltinBounds();\n+    let mut bounds = ty::empty_builtin_bounds();\n     for ast_trait_ref in ast_trait_refs.iter() {\n         let trait_def_id = ty::trait_ref_to_def_id(ccx.tcx, ast_trait_ref);\n         // FIXME(#8559): Need to instantiate the trait_ref whether or not it's a\n@@ -1094,7 +1094,7 @@ fn ty_generics(ccx: &CrateCtxt,\n          */\n \n         let mut param_bounds = ty::ParamBounds {\n-            builtin_bounds: ty::EmptyBuiltinBounds(),\n+            builtin_bounds: ty::empty_builtin_bounds(),\n             trait_bounds: Vec::new()\n         };\n         for ast_bound in ast_bounds.iter() {"}, {"sha": "d560b1c9a99caa4552d52bca6d84f1e108bf4f13", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -22,7 +22,6 @@ pub use middle::typeck::infer::resolve::{resolve_nested_tvar};\n pub use middle::typeck::infer::resolve::{resolve_rvar};\n \n use collections::HashMap;\n-use collections::SmallIntMap;\n use middle::ty::{TyVid, IntVid, FloatVid, RegionVid, Vid};\n use middle::ty;\n use middle::ty_fold;\n@@ -258,27 +257,20 @@ pub fn fixup_err_to_str(f: fixup_err) -> String {\n     }\n }\n \n-fn new_ValsAndBindings<V:Clone,T:Clone>() -> ValsAndBindings<V, T> {\n-    ValsAndBindings {\n-        vals: SmallIntMap::new(),\n-        bindings: Vec::new()\n-    }\n-}\n-\n pub fn new_infer_ctxt<'a>(tcx: &'a ty::ctxt) -> InferCtxt<'a> {\n     InferCtxt {\n         tcx: tcx,\n \n-        ty_var_bindings: RefCell::new(new_ValsAndBindings()),\n+        ty_var_bindings: RefCell::new(ValsAndBindings::new()),\n         ty_var_counter: Cell::new(0),\n \n-        int_var_bindings: RefCell::new(new_ValsAndBindings()),\n+        int_var_bindings: RefCell::new(ValsAndBindings::new()),\n         int_var_counter: Cell::new(0),\n \n-        float_var_bindings: RefCell::new(new_ValsAndBindings()),\n+        float_var_bindings: RefCell::new(ValsAndBindings::new()),\n         float_var_counter: Cell::new(0),\n \n-        region_vars: RegionVarBindings(tcx),\n+        region_vars: RegionVarBindings::new(tcx),\n     }\n }\n \n@@ -679,7 +671,7 @@ impl<'a> InferCtxt<'a> {\n                                   trait_ref.def_id,\n                                   trait_ref.substs.clone(),\n                                   ty::UniqTraitStore,\n-                                  ty::EmptyBuiltinBounds());\n+                                  ty::empty_builtin_bounds());\n         let dummy1 = self.resolve_type_vars_if_possible(dummy0);\n         match ty::get(dummy1).sty {\n             ty::ty_trait(box ty::TyTrait { ref def_id, ref substs, .. }) => {"}, {"sha": "c964530a5f9fe640242162a8f0df0833ceb904e5", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -143,21 +143,21 @@ pub struct RegionVarBindings<'a> {\n     values: RefCell<Option<Vec<VarValue> >>,\n }\n \n-pub fn RegionVarBindings<'a>(tcx: &'a ty::ctxt) -> RegionVarBindings<'a> {\n-    RegionVarBindings {\n-        tcx: tcx,\n-        var_origins: RefCell::new(Vec::new()),\n-        values: RefCell::new(None),\n-        constraints: RefCell::new(HashMap::new()),\n-        lubs: RefCell::new(HashMap::new()),\n-        glbs: RefCell::new(HashMap::new()),\n-        skolemization_count: Cell::new(0),\n-        bound_count: Cell::new(0),\n-        undo_log: RefCell::new(Vec::new())\n+impl<'a> RegionVarBindings<'a> {\n+    pub fn new(tcx: &'a ty::ctxt) -> RegionVarBindings<'a> {\n+        RegionVarBindings {\n+            tcx: tcx,\n+            var_origins: RefCell::new(Vec::new()),\n+            values: RefCell::new(None),\n+            constraints: RefCell::new(HashMap::new()),\n+            lubs: RefCell::new(HashMap::new()),\n+            glbs: RefCell::new(HashMap::new()),\n+            skolemization_count: Cell::new(0),\n+            bound_count: Cell::new(0),\n+            undo_log: RefCell::new(Vec::new())\n+        }\n     }\n-}\n \n-impl<'a> RegionVarBindings<'a> {\n     pub fn in_snapshot(&self) -> bool {\n         self.undo_log.borrow().len() > 0\n     }"}, {"sha": "867e52056a7b1c57d929f2d4bc215e0761bef1dc", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -30,6 +30,15 @@ pub struct ValsAndBindings<V, T> {\n     pub bindings: Vec<(V, VarValue<V, T>)> ,\n }\n \n+impl<V:Clone, T:Clone> ValsAndBindings<V, T> {\n+    pub fn new() -> ValsAndBindings<V, T> {\n+        ValsAndBindings {\n+            vals: SmallIntMap::new(),\n+            bindings: Vec::new()\n+        }\n+    }\n+}\n+\n pub struct Node<V, T> {\n     pub root: V,\n     pub possible_types: T,"}, {"sha": "fea6748660bde2c0e2df962032226a7503a7b6e2", "filename": "src/librustdoc/flock.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustdoc%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustdoc%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fflock.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -141,6 +141,7 @@ mod imp {\n \n     static LOCKFILE_EXCLUSIVE_LOCK: libc::DWORD = 0x00000002;\n \n+    #[allow(non_snake_case_functions)]\n     extern \"system\" {\n         fn LockFileEx(hFile: libc::HANDLE,\n                       dwFlags: libc::DWORD,"}, {"sha": "5bb9c70f04795b38b8994badb1b3a7fa012dafe3", "filename": "src/librustuv/homing.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustuv%2Fhoming.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibrustuv%2Fhoming.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fhoming.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -88,7 +88,7 @@ pub trait HomingIO {\n     /// This function will move tasks to run on their home I/O scheduler. Note\n     /// that this function does *not* pin the task to the I/O scheduler, but\n     /// rather it simply moves it to running on the I/O scheduler.\n-    fn go_to_IO_home(&mut self) -> uint {\n+    fn go_to_io_home(&mut self) -> uint {\n         let _f = ForbidUnwind::new(\"going home\");\n \n         let cur_loop_id = local_id();\n@@ -118,7 +118,7 @@ pub trait HomingIO {\n     /// move the local task to its I/O scheduler and then return an RAII wrapper\n     /// which will return the task home.\n     fn fire_homing_missile(&mut self) -> HomingMissile {\n-        HomingMissile { io_home: self.go_to_IO_home() }\n+        HomingMissile { io_home: self.go_to_io_home() }\n     }\n }\n "}, {"sha": "9ba2c2cd258ed0dc5643a87acd30385b7246b25f", "filename": "src/libserialize/ebml.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibserialize%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibserialize%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Febml.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -26,6 +26,10 @@ pub struct Doc<'a> {\n }\n \n impl<'doc> Doc<'doc> {\n+    pub fn new(data: &'doc [u8]) -> Doc<'doc> {\n+        Doc { data: data, start: 0u, end: data.len() }\n+    }\n+\n     pub fn get<'a>(&'a self, tag: uint) -> Doc<'a> {\n         reader::get_doc(*self, tag)\n     }\n@@ -192,10 +196,6 @@ pub mod reader {\n         }\n     }\n \n-    pub fn Doc<'a>(data: &'a [u8]) -> Doc<'a> {\n-        Doc { data: data, start: 0u, end: data.len() }\n-    }\n-\n     pub fn doc_at<'a>(data: &'a [u8], start: uint) -> DecodeResult<TaggedDoc<'a>> {\n         let elt_tag = try!(vuint_at(data, start));\n         let elt_size = try!(vuint_at(data, elt_tag.next));\n@@ -296,14 +296,14 @@ pub mod reader {\n         pos: uint,\n     }\n \n-    pub fn Decoder<'a>(d: Doc<'a>) -> Decoder<'a> {\n-        Decoder {\n-            parent: d,\n-            pos: d.start\n+    impl<'doc> Decoder<'doc> {\n+        pub fn new(d: Doc<'doc>) -> Decoder<'doc> {\n+            Decoder {\n+                parent: d,\n+                pos: d.start\n+            }\n         }\n-    }\n \n-    impl<'doc> Decoder<'doc> {\n         fn _check_label(&mut self, lbl: &str) -> DecodeResult<()> {\n             if self.pos < self.parent.end {\n                 let TaggedDoc { tag: r_tag, doc: r_doc } =\n@@ -673,15 +673,15 @@ pub mod writer {\n         })\n     }\n \n-    pub fn Encoder<'a, W: Writer + Seek>(w: &'a mut W) -> Encoder<'a, W> {\n-        Encoder {\n-            writer: w,\n-            size_positions: vec!(),\n-        }\n-    }\n-\n     // FIXME (#2741): Provide a function to write the standard ebml header.\n     impl<'a, W: Writer + Seek> Encoder<'a, W> {\n+        pub fn new(w: &'a mut W) -> Encoder<'a, W> {\n+            Encoder {\n+                writer: w,\n+                size_positions: vec!(),\n+            }\n+        }\n+\n         /// FIXME(pcwalton): Workaround for badness in trans. DO NOT USE ME.\n         pub unsafe fn unsafe_clone(&self) -> Encoder<'a, W> {\n             Encoder {\n@@ -1020,6 +1020,7 @@ pub mod writer {\n \n #[cfg(test)]\n mod tests {\n+    use super::Doc;\n     use ebml::reader;\n     use ebml::writer;\n     use {Encodable, Decodable};\n@@ -1081,11 +1082,11 @@ mod tests {\n             debug!(\"v == {}\", v);\n             let mut wr = MemWriter::new();\n             {\n-                let mut ebml_w = writer::Encoder(&mut wr);\n+                let mut ebml_w = writer::Encoder::new(&mut wr);\n                 let _ = v.encode(&mut ebml_w);\n             }\n-            let ebml_doc = reader::Doc(wr.get_ref());\n-            let mut deser = reader::Decoder(ebml_doc);\n+            let ebml_doc = Doc::new(wr.get_ref());\n+            let mut deser = reader::Decoder::new(ebml_doc);\n             let v1 = Decodable::decode(&mut deser).unwrap();\n             debug!(\"v1 == {}\", v1);\n             assert_eq!(v, v1);\n@@ -1099,6 +1100,7 @@ mod tests {\n \n #[cfg(test)]\n mod bench {\n+    #![allow(non_snake_case_functions)]\n     extern crate test;\n     use self::test::Bencher;\n     use ebml::reader;"}, {"sha": "7e6d3c0606f9a40b31b6059cf3adb047f755cbe2", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -27,6 +27,7 @@\n  */\n \n #![allow(missing_doc)]\n+#![allow(non_snake_case_functions)]\n \n use clone::Clone;\n use container::Container;"}, {"sha": "284d41d3208a382ed72974cda74b4adef7538744", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -93,6 +93,7 @@ mod imp {\n     static CRYPT_VERIFYCONTEXT: DWORD = 0xF0000000;\n     static NTE_BAD_SIGNATURE: DWORD = 0x80090006;\n \n+    #[allow(non_snake_case_functions)]\n     extern \"system\" {\n         fn CryptAcquireContextA(phProv: *mut HCRYPTPROV,\n                                 pszContainer: LPCSTR,"}, {"sha": "f21dcdf2a469006afbf91457166dfb79049ab2d0", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -42,11 +42,12 @@ pub fn align(size: uint, align: uint) -> uint {\n pub struct MovePtrAdaptor<V> {\n     inner: V\n }\n-pub fn MovePtrAdaptor<V:TyVisitor + MovePtr>(v: V) -> MovePtrAdaptor<V> {\n-    MovePtrAdaptor { inner: v }\n-}\n \n impl<V:TyVisitor + MovePtr> MovePtrAdaptor<V> {\n+    pub fn new(v: V) -> MovePtrAdaptor<V> {\n+        MovePtrAdaptor { inner: v }\n+    }\n+\n     #[inline]\n     pub fn bump(&mut self, sz: uint) {\n         self.inner.move_ptr(|p| ((p as uint) + sz) as *u8)"}, {"sha": "0621cbf35fe22e78181b2287e2dd41f4caf094c2", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -110,17 +110,6 @@ pub struct ReprVisitor<'a> {\n     last_err: Option<io::IoError>,\n }\n \n-pub fn ReprVisitor<'a>(ptr: *u8,\n-                       writer: &'a mut io::Writer) -> ReprVisitor<'a> {\n-    ReprVisitor {\n-        ptr: ptr,\n-        ptr_stk: vec!(),\n-        var_stk: vec!(),\n-        writer: writer,\n-        last_err: None,\n-    }\n-}\n-\n impl<'a> MovePtr for ReprVisitor<'a> {\n     #[inline]\n     fn move_ptr(&mut self, adjustment: |*u8| -> *u8) {\n@@ -136,6 +125,15 @@ impl<'a> MovePtr for ReprVisitor<'a> {\n \n impl<'a> ReprVisitor<'a> {\n     // Various helpers for the TyVisitor impl\n+    pub fn new(ptr: *u8, writer: &'a mut io::Writer) -> ReprVisitor<'a> {\n+        ReprVisitor {\n+            ptr: ptr,\n+            ptr_stk: vec!(),\n+            var_stk: vec!(),\n+            writer: writer,\n+            last_err: None,\n+        }\n+    }\n \n     #[inline]\n     pub fn get<T>(&mut self, f: |&mut ReprVisitor, &T| -> bool) -> bool {\n@@ -152,16 +150,8 @@ impl<'a> ReprVisitor<'a> {\n     #[inline]\n     pub fn visit_ptr_inner(&mut self, ptr: *u8, inner: *TyDesc) -> bool {\n         unsafe {\n-            // This should call the constructor up above, but due to limiting\n-            // issues we have to recreate it here.\n-            let u = ReprVisitor {\n-                ptr: ptr,\n-                ptr_stk: vec!(),\n-                var_stk: vec!(),\n-                writer: ::mem::transmute_copy(&self.writer),\n-                last_err: None,\n-            };\n-            let mut v = reflect::MovePtrAdaptor(u);\n+            let u = ReprVisitor::new(ptr, ::mem::transmute_copy(&self.writer));\n+            let mut v = reflect::MovePtrAdaptor::new(u);\n             // Obviously this should not be a thing, but blame #8401 for now\n             visit_tydesc(inner, &mut v as &mut TyVisitor);\n             match v.unwrap().last_err {\n@@ -592,8 +582,8 @@ pub fn write_repr<T>(writer: &mut io::Writer, object: &T) -> io::IoResult<()> {\n     unsafe {\n         let ptr = object as *T as *u8;\n         let tydesc = get_tydesc::<T>();\n-        let u = ReprVisitor(ptr, writer);\n-        let mut v = reflect::MovePtrAdaptor(u);\n+        let u = ReprVisitor::new(ptr, writer);\n+        let mut v = reflect::MovePtrAdaptor::new(u);\n         visit_tydesc(tydesc, &mut v as &mut TyVisitor);\n         match v.unwrap().last_err {\n             Some(e) => Err(e),"}, {"sha": "ac421bf78be7edaf277e945524527f1753487ac2", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -518,6 +518,7 @@ mod imp {\n     use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n     use slice::ImmutableVector;\n \n+    #[allow(non_snake_case_functions)]\n     extern \"system\" {\n         fn GetCurrentProcess() -> libc::HANDLE;\n         fn GetCurrentThread() -> libc::HANDLE;"}, {"sha": "00301e71b0d8ba98f0ade45ae0dddba3c344cf02", "filename": "src/libstd/rt/libunwind.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibstd%2Frt%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibstd%2Frt%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flibunwind.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -11,6 +11,7 @@\n //! Unwind library interface\n \n #![allow(non_camel_case_types)]\n+#![allow(non_snake_case_functions)]\n #![allow(dead_code)] // these are just bindings\n \n use libc;"}, {"sha": "81dcf909706dd3263e7e68c77284fd58c553ad30", "filename": "src/libstd/rt/thread.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -199,6 +199,7 @@ mod imp {\n         SwitchToThread();\n     }\n \n+    #[allow(non_snake_case_functions)]\n     extern \"system\" {\n         fn CreateThread(lpThreadAttributes: LPSECURITY_ATTRIBUTES,\n                         dwStackSize: SIZE_T,"}, {"sha": "a3ebcbafff8d32ffa9726173553c1dd6f9cda9e7", "filename": "src/libstd/rt/thread_local_storage.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibstd%2Frt%2Fthread_local_storage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibstd%2Frt%2Fthread_local_storage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread_local_storage.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -86,6 +86,7 @@ pub unsafe fn destroy(key: Key) {\n }\n \n #[cfg(windows)]\n+#[allow(non_snake_case_functions)]\n extern \"system\" {\n     fn TlsAlloc() -> DWORD;\n     fn TlsFree(dwTlsIndex: DWORD) -> BOOL;"}, {"sha": "6c406a7c8472e4e432164487cb4c3b4f7345c694", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -317,6 +317,7 @@ pub mod dl {\n         FreeLibrary(handle as *libc::c_void); ()\n     }\n \n+    #[allow(non_snake_case_functions)]\n     extern \"system\" {\n         fn SetLastError(error: libc::size_t);\n         fn LoadLibraryW(name: *libc::c_void) -> *libc::c_void;"}, {"sha": "4e51e71477757be5665f5ef7633850612e01b585", "filename": "src/libstd/unstable/mutex.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibstd%2Funstable%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibstd%2Funstable%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmutex.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -543,6 +543,7 @@ mod imp {\n         libc::CloseHandle(block);\n     }\n \n+    #[allow(non_snake_case_functions)]\n     extern \"system\" {\n         fn CreateEventA(lpSecurityAttributes: LPSECURITY_ATTRIBUTES,\n                         bManualReset: BOOL,"}, {"sha": "089cd772bb48dc47d110b59b7dd23076e7d5537f", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -159,6 +159,7 @@ impl fmt::Show for Abi {\n     }\n }\n \n+#[allow(non_snake_case_functions)]\n #[test]\n fn lookup_Rust() {\n     let abi = lookup(\"Rust\");"}, {"sha": "656ae80e12d6465bbc2ad7791f50b6587162bec7", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -26,6 +26,7 @@ use serialize::{Encodable, Decodable, Encoder, Decoder};\n /// A pointer abstraction. FIXME(eddyb) #10676 use Rc<T> in the future.\n pub type P<T> = @T;\n \n+#[allow(non_snake_case_functions)]\n /// Construct a P<T> from a T value.\n pub fn P<T: 'static>(value: T) -> P<T> {\n     @value"}, {"sha": "fdaa3b5630ab13d8cb3f1062a59426513e823fb7", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -223,7 +223,7 @@ fn marksof_internal(ctxt: SyntaxContext,\n                 return result;\n             },\n             Mark(mark, tl) => {\n-                xorPush(&mut result, mark);\n+                xor_push(&mut result, mark);\n                 loopvar = tl;\n             },\n             Rename(_,name,tl) => {\n@@ -253,7 +253,7 @@ pub fn outer_mark(ctxt: SyntaxContext) -> Mrk {\n \n // Push a name... unless it matches the one on top, in which\n // case pop and discard (so two of the same marks cancel)\n-fn xorPush(marks: &mut Vec<Mrk>, mark: Mrk) {\n+fn xor_push(marks: &mut Vec<Mrk>, mark: Mrk) {\n     if (marks.len() > 0) && (*marks.last().unwrap() == mark) {\n         marks.pop().unwrap();\n     } else {\n@@ -264,26 +264,27 @@ fn xorPush(marks: &mut Vec<Mrk>, mark: Mrk) {\n #[cfg(test)]\n mod tests {\n     use ast::*;\n-    use super::{resolve, xorPush, new_mark_internal, new_sctable_internal};\n+    use super::{resolve, xor_push, new_mark_internal, new_sctable_internal};\n     use super::{new_rename_internal, marksof_internal, resolve_internal};\n     use super::{SCTable, EmptyCtxt, Mark, Rename, IllegalCtxt};\n     use collections::HashMap;\n \n-    #[test] fn xorpush_test () {\n+    #[test]\n+    fn xorpush_test () {\n         let mut s = Vec::new();\n-        xorPush(&mut s, 14);\n+        xor_push(&mut s, 14);\n         assert_eq!(s.clone(), vec!(14));\n-        xorPush(&mut s, 14);\n+        xor_push(&mut s, 14);\n         assert_eq!(s.clone(), Vec::new());\n-        xorPush(&mut s, 14);\n+        xor_push(&mut s, 14);\n         assert_eq!(s.clone(), vec!(14));\n-        xorPush(&mut s, 15);\n+        xor_push(&mut s, 15);\n         assert_eq!(s.clone(), vec!(14, 15));\n-        xorPush(&mut s, 16);\n+        xor_push(&mut s, 16);\n         assert_eq!(s.clone(), vec!(14, 15, 16));\n-        xorPush(&mut s, 16);\n+        xor_push(&mut s, 16);\n         assert_eq!(s.clone(), vec!(14, 15));\n-        xorPush(&mut s, 15);\n+        xor_push(&mut s, 15);\n         assert_eq!(s.clone(), vec!(14));\n     }\n \n@@ -331,7 +332,8 @@ mod tests {\n         }\n     }\n \n-    #[test] fn test_unfold_refold(){\n+    #[test]\n+    fn test_unfold_refold(){\n         let mut t = new_sctable_internal();\n \n         let test_sc = vec!(M(3),R(id(101,0),14),M(9));\n@@ -364,7 +366,8 @@ mod tests {\n         }\n     }\n \n-    #[test] fn test_marksof () {\n+    #[test]\n+    fn test_marksof () {\n         let stopname = 242;\n         let name1 = 243;\n         let mut t = new_sctable_internal();\n@@ -397,7 +400,8 @@ mod tests {\n     }\n \n \n-    #[test] fn resolve_tests () {\n+    #[test]\n+    fn resolve_tests () {\n         let a = 40;\n         let mut t = new_sctable_internal();\n         let mut rt = HashMap::new();\n@@ -447,13 +451,15 @@ mod tests {\n          assert_eq!(resolve_internal(id(a,a50_to_a51_b),&mut t, &mut rt),50);}\n     }\n \n-    #[test] fn mtwt_resolve_test(){\n+    #[test]\n+    fn mtwt_resolve_test(){\n         let a = 40;\n         assert_eq!(resolve(id(a,EMPTY_CTXT)),a);\n     }\n \n \n-    #[test] fn hashing_tests () {\n+    #[test]\n+    fn hashing_tests () {\n         let mut t = new_sctable_internal();\n         assert_eq!(new_mark_internal(12,EMPTY_CTXT,&mut t),2);\n         assert_eq!(new_mark_internal(13,EMPTY_CTXT,&mut t),3);\n@@ -462,7 +468,8 @@ mod tests {\n         // I'm assuming that the rename table will behave the same....\n     }\n \n-    #[test] fn resolve_table_hashing_tests() {\n+    #[test]\n+    fn resolve_table_hashing_tests() {\n         let mut t = new_sctable_internal();\n         let mut rt = HashMap::new();\n         assert_eq!(rt.len(),0);"}, {"sha": "65733793d6c57844fbf584fe759c98b34ff3c6df", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -402,7 +402,7 @@ pub fn parse(sess: &ParseSess,\n                 }\n                 rdr.next_token();\n             } else /* bb_eis.len() == 1 */ {\n-                let mut rust_parser = Parser(sess, cfg.clone(), box rdr.clone());\n+                let mut rust_parser = Parser::new(sess, cfg.clone(), box rdr.clone());\n \n                 let mut ei = bb_eis.pop().unwrap();\n                 match ei.elts.get(ei.idx).node {"}, {"sha": "0622bf76ab92529966dd2a8dfcc309ab6ed55d64", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -171,7 +171,7 @@ fn generic_extension(cx: &ExtCtxt,\n                 let trncbr = new_tt_reader(&cx.parse_sess().span_diagnostic,\n                                            Some(named_matches),\n                                            rhs);\n-                let p = Parser(cx.parse_sess(), cx.cfg(), box trncbr);\n+                let p = Parser::new(cx.parse_sess(), cx.cfg(), box trncbr);\n                 // Let the context choose how to interpret the result.\n                 // Weird, but useful for X-macros.\n                 return box ParserAnyMacro {"}, {"sha": "3132f91c09b9ed2764b7597e9158004923594247", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -256,7 +256,7 @@ pub fn filemap_to_tts(sess: &ParseSess, filemap: Rc<FileMap>)\n     // parsing tt's probably shouldn't require a parser at all.\n     let cfg = Vec::new();\n     let srdr = lexer::new_string_reader(&sess.span_diagnostic, filemap);\n-    let mut p1 = Parser(sess, cfg, box srdr);\n+    let mut p1 = Parser::new(sess, cfg, box srdr);\n     p1.parse_all_token_trees()\n }\n \n@@ -265,7 +265,7 @@ pub fn tts_to_parser<'a>(sess: &'a ParseSess,\n                          tts: Vec<ast::TokenTree>,\n                          cfg: ast::CrateConfig) -> Parser<'a> {\n     let trdr = lexer::new_tt_reader(&sess.span_diagnostic, None, tts);\n-    Parser(sess, cfg, box trdr)\n+    Parser::new(sess, cfg, box trdr)\n }\n \n // abort if necessary"}, {"sha": "f045a7fe1209377de320a9a3dc06f5918806905f", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -19,7 +19,7 @@ removed.\n \n use ast::{Expr, ExprLit, LitNil};\n use codemap::{Span, respan};\n-use parse::parser::Parser;\n+use parse::parser;\n use parse::token;\n \n /// The specific types of unsupported syntax\n@@ -45,7 +45,7 @@ pub trait ParserObsoleteMethods {\n     fn eat_obsolete_ident(&mut self, ident: &str) -> bool;\n }\n \n-impl<'a> ParserObsoleteMethods for Parser<'a> {\n+impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n     /// Reports an obsolete syntax non-fatal error.\n     fn obsolete(&mut self, sp: Span, kind: ObsoleteSyntax) {\n         let (kind_str, desc) = match kind {"}, {"sha": "00c07ce59f989d07699c65760b0609d2f1f92498", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 37, "deletions": 41, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -278,50 +278,11 @@ struct ParsedItemsAndViewItems {\n     attrs_remaining: Vec<Attribute> ,\n     view_items: Vec<ViewItem> ,\n     items: Vec<@Item> ,\n-    foreign_items: Vec<@ForeignItem> }\n+    foreign_items: Vec<@ForeignItem>\n+}\n \n /* ident is handled by common.rs */\n \n-pub fn Parser<'a>(\n-              sess: &'a ParseSess,\n-              cfg: ast::CrateConfig,\n-              mut rdr: Box<Reader:>)\n-              -> Parser<'a> {\n-    let tok0 = rdr.next_token();\n-    let span = tok0.sp;\n-    let placeholder = TokenAndSpan {\n-        tok: token::UNDERSCORE,\n-        sp: span,\n-    };\n-\n-    Parser {\n-        reader: rdr,\n-        interner: token::get_ident_interner(),\n-        sess: sess,\n-        cfg: cfg,\n-        token: tok0.tok,\n-        span: span,\n-        last_span: span,\n-        last_token: None,\n-        buffer: [\n-            placeholder.clone(),\n-            placeholder.clone(),\n-            placeholder.clone(),\n-            placeholder.clone(),\n-        ],\n-        buffer_start: 0,\n-        buffer_end: 0,\n-        tokens_consumed: 0,\n-        restriction: UNRESTRICTED,\n-        quote_depth: 0,\n-        obsolete_set: HashSet::new(),\n-        mod_path_stack: Vec::new(),\n-        open_braces: Vec::new(),\n-        owns_directory: true,\n-        root_module_name: None,\n-    }\n-}\n-\n pub struct Parser<'a> {\n     pub sess: &'a ParseSess,\n     // the current token:\n@@ -362,6 +323,41 @@ fn is_plain_ident_or_underscore(t: &token::Token) -> bool {\n }\n \n impl<'a> Parser<'a> {\n+    pub fn new(sess: &'a ParseSess, cfg: ast::CrateConfig, mut rdr: Box<Reader:>) -> Parser<'a> {\n+        let tok0 = rdr.next_token();\n+        let span = tok0.sp;\n+        let placeholder = TokenAndSpan {\n+            tok: token::UNDERSCORE,\n+            sp: span,\n+        };\n+\n+        Parser {\n+            reader: rdr,\n+            interner: token::get_ident_interner(),\n+            sess: sess,\n+            cfg: cfg,\n+            token: tok0.tok,\n+            span: span,\n+            last_span: span,\n+            last_token: None,\n+            buffer: [\n+                placeholder.clone(),\n+                placeholder.clone(),\n+                placeholder.clone(),\n+                placeholder.clone(),\n+            ],\n+            buffer_start: 0,\n+            buffer_end: 0,\n+            tokens_consumed: 0,\n+            restriction: UNRESTRICTED,\n+            quote_depth: 0,\n+            obsolete_set: HashSet::new(),\n+            mod_path_stack: Vec::new(),\n+            open_braces: Vec::new(),\n+            owns_directory: true,\n+            root_module_name: None,\n+        }\n+    }\n     // convert a token to a string using self's reader\n     pub fn token_to_str(token: &token::Token) -> String {\n         token::to_str(token)"}, {"sha": "00e90fc3cde64abc3e072d66fcfa546ec15cb42f", "filename": "src/libterm/win.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibterm%2Fwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibterm%2Fwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fwin.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -27,6 +27,7 @@ pub struct WinConsole<T> {\n     background: color::Color,\n }\n \n+#[allow(non_snake_case_functions)]\n #[link(name = \"kernel32\")]\n extern \"system\" {\n     fn SetConsoleTextAttribute(handle: libc::HANDLE, attr: libc::WORD) -> libc::BOOL;"}, {"sha": "c157d83ced13d6bdd7ac776a867891df44376142", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -795,14 +795,16 @@ mod test {\n \n     #[test]\n     fn test_serialize_round_trip() {\n-        use serialize::ebml;\n+        use serialize::ebml::Doc;\n+        use serialize::ebml::writer::Encoder;\n+        use serialize::ebml::reader::Decoder;\n         use serialize::{Encodable, Decodable};\n \n         let u = Uuid::new_v4();\n         let mut wr = MemWriter::new();\n-        let _ = u.encode(&mut ebml::writer::Encoder(&mut wr));\n-        let doc = ebml::reader::Doc(wr.get_ref());\n-        let u2 = Decodable::decode(&mut ebml::reader::Decoder(doc)).unwrap();\n+        let _ = u.encode(&mut Encoder::new(&mut wr));\n+        let doc = Doc::new(wr.get_ref());\n+        let u2 = Decodable::decode(&mut Decoder::new(doc)).unwrap();\n         assert_eq!(u, u2);\n     }\n "}, {"sha": "c038a056569b9918f5108b1dd9a2272092cbb536", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![feature(phase)]\n+#![allow(non_snake_case_functions)]\n #[phase(syntax)] extern crate green;\n extern crate sync;\n "}, {"sha": "c0ea6f8617d87ecadd3a60b9f98c7b52aae01656", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -11,6 +11,7 @@\n // ignore-pretty very bad with line comments\n \n #![feature(managed_boxes)]\n+#![allow(non_snake_case_functions)]\n \n use std::io;\n use std::io::stdio::StdReader;"}, {"sha": "02ab85aff3bdfa22aa0a498f10e9d1e767976eba", "filename": "src/test/compile-fail/lint-non-snake-case-functions.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Ftest%2Fcompile-fail%2Flint-non-snake-case-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Ftest%2Fcompile-fail%2Flint-non-snake-case-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-non-snake-case-functions.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(non_snake_case_functions)]\n+#![allow(dead_code)]\n+\n+struct Foo;\n+\n+impl Foo {\n+    fn Foo_Method() {}\n+    //~^ ERROR method `Foo_Method` should have a snake case identifier\n+\n+    // Don't allow two underscores in a row\n+    fn foo__method(&self) {}\n+    //~^ ERROR method `foo__method` should have a snake case identifier\n+\n+    pub fn xyZ(&mut self) {}\n+    //~^ ERROR method `xyZ` should have a snake case identifier\n+}\n+\n+trait X {\n+    fn ABC();\n+    //~^ ERROR trait method `ABC` should have a snake case identifier\n+\n+    fn a_b_C(&self) {}\n+    //~^ ERROR trait method `a_b_C` should have a snake case identifier\n+\n+    fn something__else(&mut self);\n+    //~^ ERROR trait method `something__else` should have a snake case identifier\n+}\n+\n+impl X for Foo {\n+    // These errors should be caught at the trait definition not the impl\n+    fn ABC() {}\n+    fn something__else(&mut self) {}\n+}\n+\n+fn Cookie() {}\n+//~^ ERROR function `Cookie` should have a snake case identifier\n+\n+pub fn bi_S_Cuit() {}\n+//~^ ERROR function `bi_S_Cuit` should have a snake case identifier\n+\n+fn main() { }"}, {"sha": "217878892d62310e787677d36e28f1bc94732509", "filename": "src/test/run-pass/auto-encode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-encode.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -33,12 +33,12 @@ fn test_ebml<'a, 'b, A:\n     Decodable<EBReader::Decoder<'b>>\n >(a1: &A) {\n     let mut wr = std::io::MemWriter::new();\n-    let mut ebml_w = EBWriter::Encoder(&mut wr);\n+    let mut ebml_w = EBwriter::Encoder::new(&mut wr);\n     a1.encode(&mut ebml_w);\n     let bytes = wr.get_ref();\n \n-    let d: serialize::ebml::Doc<'a> = EBReader::Doc(bytes);\n-    let mut decoder: EBReader::Decoder<'a> = EBReader::Decoder(d);\n+    let d: serialize::ebml::Doc<'a> = EBDoc::new(bytes);\n+    let mut decoder: EBReader::Decoder<'a> = EBreader::Decoder::new(d);\n     let a2: A = Decodable::decode(&mut decoder);\n     assert!(*a1 == a2);\n }"}, {"sha": "2e6b3b8e800b97fbde36c733be9559b7bd755b02", "filename": "src/test/run-pass/deriving-encodable-decodable.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -22,6 +22,7 @@ use std::io::MemWriter;\n use rand::{random, Rand};\n use serialize::{Encodable, Decodable};\n use serialize::ebml;\n+use serialize::ebml::Doc;\n use serialize::ebml::writer::Encoder;\n use serialize::ebml::reader::Decoder;\n \n@@ -58,10 +59,10 @@ fn roundtrip<'a, T: Rand + Eq + Encodable<Encoder<'a>> +\n                     Decodable<Decoder<'a>>>() {\n     let obj: T = random();\n     let mut w = MemWriter::new();\n-    let mut e = Encoder(&mut w);\n+    let mut e = Encoder::new(&mut w);\n     obj.encode(&mut e);\n-    let doc = ebml::reader::Doc(@w.get_ref());\n-    let mut dec = Decoder(doc);\n+    let doc = ebml::Doc::new(@w.get_ref());\n+    let mut dec = Decoder::new(doc);\n     let obj2 = Decodable::decode(&mut dec);\n     assert!(obj == obj2);\n }"}, {"sha": "913e09dd8cb350b8f0ed1a74ddb4cc8571dabc45", "filename": "src/test/run-pass/issue-11881.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24e489f1e1326208aecabf390879c2320f212b7c/src%2Ftest%2Frun-pass%2Fissue-11881.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e489f1e1326208aecabf390879c2320f212b7c/src%2Ftest%2Frun-pass%2Fissue-11881.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11881.rs?ref=24e489f1e1326208aecabf390879c2320f212b7c", "patch": "@@ -43,7 +43,7 @@ fn encode_ebml<'a,\n                T: Encodable<writer::Encoder<'a, MemWriter>,\n                             std::io::IoError>>(val: &T,\n                                                wr: &'a mut MemWriter) {\n-    let mut encoder = writer::Encoder(wr);\n+    let mut encoder = writer::Encoder::new(wr);\n     val.encode(&mut encoder);\n }\n "}]}