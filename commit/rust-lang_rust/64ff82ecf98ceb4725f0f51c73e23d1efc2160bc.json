{"sha": "64ff82ecf98ceb4725f0f51c73e23d1efc2160bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0ZmY4MmVjZjk4Y2ViNDcyNWYwZjUxYzczZTIzZDFlZmMyMTYwYmM=", "commit": {"author": {"name": "Michael Bebenita", "email": "mbebenita@mozilla.com", "date": "2010-08-25T04:06:56Z"}, "committer": {"name": "Michael Bebenita", "email": "mbebenita@mozilla.com", "date": "2010-08-25T04:07:14Z"}, "message": "Implemented an lock free queue based on this paper http://www.cs.rochester.edu/~scott/papers/1996_PODC_queues.pdf, the \"lock free queue\" we had before wasn't lock free at all.", "tree": {"sha": "6a6ae7452066716947c4d262eb72041a6a11cb95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a6ae7452066716947c4d262eb72041a6a11cb95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64ff82ecf98ceb4725f0f51c73e23d1efc2160bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64ff82ecf98ceb4725f0f51c73e23d1efc2160bc", "html_url": "https://github.com/rust-lang/rust/commit/64ff82ecf98ceb4725f0f51c73e23d1efc2160bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64ff82ecf98ceb4725f0f51c73e23d1efc2160bc/comments", "author": {"login": "mbebenita", "id": 311082, "node_id": "MDQ6VXNlcjMxMTA4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/311082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbebenita", "html_url": "https://github.com/mbebenita", "followers_url": "https://api.github.com/users/mbebenita/followers", "following_url": "https://api.github.com/users/mbebenita/following{/other_user}", "gists_url": "https://api.github.com/users/mbebenita/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbebenita/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbebenita/subscriptions", "organizations_url": "https://api.github.com/users/mbebenita/orgs", "repos_url": "https://api.github.com/users/mbebenita/repos", "events_url": "https://api.github.com/users/mbebenita/events{/privacy}", "received_events_url": "https://api.github.com/users/mbebenita/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mbebenita", "id": 311082, "node_id": "MDQ6VXNlcjMxMTA4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/311082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbebenita", "html_url": "https://github.com/mbebenita", "followers_url": "https://api.github.com/users/mbebenita/followers", "following_url": "https://api.github.com/users/mbebenita/following{/other_user}", "gists_url": "https://api.github.com/users/mbebenita/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbebenita/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbebenita/subscriptions", "organizations_url": "https://api.github.com/users/mbebenita/orgs", "repos_url": "https://api.github.com/users/mbebenita/repos", "events_url": "https://api.github.com/users/mbebenita/events{/privacy}", "received_events_url": "https://api.github.com/users/mbebenita/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9fe885ba5e9d67e031389eeb9a14039f9eb5287", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9fe885ba5e9d67e031389eeb9a14039f9eb5287", "html_url": "https://github.com/rust-lang/rust/commit/d9fe885ba5e9d67e031389eeb9a14039f9eb5287"}], "stats": {"total": 429, "additions": 404, "deletions": 25}, "files": [{"sha": "3de9b38ce0fba54ab76d422131415d8004d237cc", "filename": "src/Makefile", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/64ff82ecf98ceb4725f0f51c73e23d1efc2160bc/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/64ff82ecf98ceb4725f0f51c73e23d1efc2160bc/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=64ff82ecf98ceb4725f0f51c73e23d1efc2160bc", "patch": "@@ -34,7 +34,7 @@ DSYMUTIL := true\n ifeq ($(CFG_OSTYPE), Linux)\n   CFG_RUNTIME := librustrt.so\n   CFG_STDLIB := libstd.so\n-  CFG_GCC_CFLAGS += -fPIC\n+  CFG_GCC_CFLAGS += -fPIC -march=i686\n   CFG_GCC_LINK_FLAGS += -shared -fPIC -ldl -lpthread -lrt\n   ifeq ($(CFG_CPUTYPE), x86_64)\n     CFG_GCC_CFLAGS += -m32\n@@ -107,7 +107,7 @@ ifdef CFG_UNIXY\n     endif\n     CFG_OBJ_SUFFIX := .o\n     CFG_EXE_SUFFIX := .exe\n-    CFG_GCC_CFLAGS :=\n+    CFG_GCC_CFLAGS := -march=i686\n     CFG_GCC_LINK_FLAGS := -shared\n     ifeq ($(CFG_CPUTYPE), x86_64)\n       CFG_GCC_CFLAGS += -m32\n@@ -248,7 +248,6 @@ BOOT_CMIS := $(BOOT_MLS:.ml=.cmi)\n RUNTIME_CS := rt/sync/timer.cpp \\\n               rt/sync/sync.cpp \\\n               rt/sync/spin_lock.cpp \\\n-              rt/sync/lock_free_queue.cpp \\\n               rt/sync/condition_variable.cpp \\\n               rt/rust.cpp \\\n               rt/rust_builtin.cpp \\\n@@ -286,6 +285,7 @@ RUNTIME_HDR := rt/globals.h \\\n                rt/util/hash_map.h \\\n                rt/sync/sync.h \\\n                rt/sync/timer.h \\\n+               rt/sync/lock_free_queue.h \\\n                rt/rust_srv.h \\\n                rt/memory_region.h \\\n                rt/memory.h\n@@ -394,7 +394,9 @@ TASK_XFAILS := test/run-pass/acyclic-unwind.rs \\\n                test/run-pass/task-life-0.rs \\\n                test/run-pass/task-comm.rs \\\n                test/run-pass/threads.rs \\\n-               test/run-pass/yield.rs\n+               test/run-pass/yield.rs \\\n+               test/run-pass/task-comm-15.rs \\\n+               test/run-pass/task-life-0.rs\n \n TEST_XFAILS_X86 :=  $(TASK_XFAILS) \\\n                     test/run-pass/child-outlives-parent.rs \\\n@@ -537,6 +539,11 @@ TEST_XFAILS_LLVM := $(TASK_XFAILS) \\\n                       task-comm-9.rs \\\n                       task-comm-10.rs \\\n                       task-comm-11.rs \\\n+                      task-comm-12.rs \\\n+                      task-comm-13.rs \\\n+                      task-comm-13-thread.rs \\\n+                      task-comm-14.rs \\\n+                      task-comm-15.rs \\\n                       task-life-0.rs \\\n                       threads.rs \\\n                       type-sizes.rs \\"}, {"sha": "dc42286da8a07b69385d6a6effcbe724d55ebf2f", "filename": "src/rt/rust_dom.cpp", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/64ff82ecf98ceb4725f0f51c73e23d1efc2160bc/src%2Frt%2Frust_dom.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/64ff82ecf98ceb4725f0f51c73e23d1efc2160bc/src%2Frt%2Frust_dom.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_dom.cpp?ref=64ff82ecf98ceb4725f0f51c73e23d1efc2160bc", "patch": "@@ -301,12 +301,14 @@ void rust_dom::send_message(rust_message *message) {\n /**\n  * Drains and processes incoming pending messages.\n  */\n-void rust_dom::drain_incoming_message_queue() {\n+void rust_dom::drain_incoming_message_queue(bool process) {\n     rust_message *message;\n-    while ((message = (rust_message *) _incoming_message_queue.dequeue())) {\n+    while (_incoming_message_queue.dequeue(&message)) {\n         log(rust_log::COMM, \"<== processing incoming message \\\"%s\\\" 0x%\"\n             PRIxPTR, message->label, message);\n-        message->process();\n+        if (process) {\n+            message->process();\n+        }\n         message->~rust_message();\n         this->synchronized_region.free(message);\n     }\n@@ -454,7 +456,7 @@ rust_dom::start_main_loop()\n     while (n_live_tasks() > 0) {\n         A(this, is_deadlocked() == false, \"deadlock\");\n \n-        drain_incoming_message_queue();\n+        drain_incoming_message_queue(true);\n \n         rust_task *scheduled_task = schedule_task();\n \n@@ -519,7 +521,7 @@ rust_dom::start_main_loop()\n             }\n             sync::yield();\n         } else {\n-            drain_incoming_message_queue();\n+            drain_incoming_message_queue(true);\n         }\n         reap_dead_tasks();\n     }"}, {"sha": "44f56cc41bb005ae48033e8b2af7cd13ed25cdb5", "filename": "src/rt/rust_dom.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64ff82ecf98ceb4725f0f51c73e23d1efc2160bc/src%2Frt%2Frust_dom.h", "raw_url": "https://github.com/rust-lang/rust/raw/64ff82ecf98ceb4725f0f51c73e23d1efc2160bc/src%2Frt%2Frust_dom.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_dom.h?ref=64ff82ecf98ceb4725f0f51c73e23d1efc2160bc", "patch": "@@ -41,7 +41,7 @@ struct rust_dom\n     hash_map<rust_port *, rust_proxy<rust_port> *> _port_proxies;\n \n     // Incoming messages from other domains.\n-    lock_free_queue _incoming_message_queue;\n+    lock_free_queue<rust_message*> _incoming_message_queue;\n \n #ifndef __WIN32__\n     pthread_attr_t attr;\n@@ -71,7 +71,7 @@ struct rust_dom\n     void free(void *mem, memory_region::memory_region_type type);\n \n     void send_message(rust_message *message);\n-    void drain_incoming_message_queue();\n+    void drain_incoming_message_queue(bool process);\n     rust_proxy<rust_task> *get_task_proxy(rust_task *task);\n     void delete_proxies();\n     rust_proxy<rust_port> *get_port_proxy_synchronized(rust_port *port);"}, {"sha": "7aee6d9f6d04d136bad21da7d5357094d27771f7", "filename": "src/rt/rust_message.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64ff82ecf98ceb4725f0f51c73e23d1efc2160bc/src%2Frt%2Frust_message.h", "raw_url": "https://github.com/rust-lang/rust/raw/64ff82ecf98ceb4725f0f51c73e23d1efc2160bc/src%2Frt%2Frust_message.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_message.h?ref=64ff82ecf98ceb4725f0f51c73e23d1efc2160bc", "patch": "@@ -9,7 +9,7 @@\n /**\n  * Abstract base class for all message types.\n  */\n-class rust_message : public lock_free_queue_node {\n+class rust_message {\n public:\n     const char* label;\n private:"}, {"sha": "064b25f17ba2bbfb36a03ef83464eccc50c20449", "filename": "src/rt/sync/interrupt_transparent_queue.cpp", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/64ff82ecf98ceb4725f0f51c73e23d1efc2160bc/src%2Frt%2Fsync%2Finterrupt_transparent_queue.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/64ff82ecf98ceb4725f0f51c73e23d1efc2160bc/src%2Frt%2Fsync%2Finterrupt_transparent_queue.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Finterrupt_transparent_queue.cpp?ref=64ff82ecf98ceb4725f0f51c73e23d1efc2160bc", "patch": "@@ -0,0 +1,56 @@\n+/*\n+ * Interrupt transparent queue, Schoen et. al, \"On Interrupt-Transparent\n+ * Synchronization in an Embedded Object-Oriented Operating System\", 2000.\n+ * enqueue() is allowed to interrupt enqueue() and dequeue(), however,\n+ * dequeue() is not allowed to interrupt itself.\n+ */\n+\n+#include \"../globals.h\"\n+#include \"interrupt_transparent_queue.h\"\n+\n+interrupt_transparent_queue_node::interrupt_transparent_queue_node() :\n+    next(NULL) {\n+\n+}\n+\n+interrupt_transparent_queue::interrupt_transparent_queue() : _tail(this) {\n+\n+}\n+\n+void\n+interrupt_transparent_queue::enqueue(interrupt_transparent_queue_node *item) {\n+    lock.lock();\n+    item->next = (interrupt_transparent_queue_node *) NULL;\n+    interrupt_transparent_queue_node *last = _tail;\n+    _tail = item;\n+    while (last->next) {\n+        last = last->next;\n+    }\n+    last->next = item;\n+    lock.unlock();\n+}\n+\n+interrupt_transparent_queue_node *\n+interrupt_transparent_queue::dequeue() {\n+    lock.lock();\n+    interrupt_transparent_queue_node *item = next;\n+    if (item && !(next = item->next)) {\n+        _tail = (interrupt_transparent_queue_node *) this;\n+        if (item->next) {\n+            interrupt_transparent_queue_node *lost = item->next;\n+            interrupt_transparent_queue_node *help;\n+            do {\n+                help = lost->next;\n+                enqueue(lost);\n+            } while ((lost = help) !=\n+                     (interrupt_transparent_queue_node *) NULL);\n+        }\n+    }\n+    lock.unlock();\n+    return item;\n+}\n+\n+bool\n+interrupt_transparent_queue::is_empty() {\n+    return next == NULL;\n+}"}, {"sha": "7c02d0c83888e4e7269c0a5db59e24e95bbc2107", "filename": "src/rt/sync/interrupt_transparent_queue.h", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/64ff82ecf98ceb4725f0f51c73e23d1efc2160bc/src%2Frt%2Fsync%2Finterrupt_transparent_queue.h", "raw_url": "https://github.com/rust-lang/rust/raw/64ff82ecf98ceb4725f0f51c73e23d1efc2160bc/src%2Frt%2Fsync%2Finterrupt_transparent_queue.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Finterrupt_transparent_queue.h?ref=64ff82ecf98ceb4725f0f51c73e23d1efc2160bc", "patch": "@@ -0,0 +1,22 @@\n+#ifndef INTERRUPT_TRANSPARENT_QUEUE_H\n+#define INTERRUPT_TRANSPARENT_QUEUE_H\n+\n+#include \"spin_lock.h\"\n+\n+class interrupt_transparent_queue_node {\n+public:\n+    interrupt_transparent_queue_node *next;\n+    interrupt_transparent_queue_node();\n+};\n+\n+class interrupt_transparent_queue : interrupt_transparent_queue_node {\n+    spin_lock lock;\n+    interrupt_transparent_queue_node *_tail;\n+public:\n+    interrupt_transparent_queue();\n+    void enqueue(interrupt_transparent_queue_node *item);\n+    interrupt_transparent_queue_node *dequeue();\n+    bool is_empty();\n+};\n+\n+#endif /* INTERRUPT_TRANSPARENT_QUEUE_H */"}, {"sha": "ac0c5b046a00388fa75a0f50a4e1e30fe4620e87", "filename": "src/rt/sync/lock_free_queue.h", "status": "modified", "additions": 201, "deletions": 13, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/64ff82ecf98ceb4725f0f51c73e23d1efc2160bc/src%2Frt%2Fsync%2Flock_free_queue.h", "raw_url": "https://github.com/rust-lang/rust/raw/64ff82ecf98ceb4725f0f51c73e23d1efc2160bc/src%2Frt%2Fsync%2Flock_free_queue.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_free_queue.h?ref=64ff82ecf98ceb4725f0f51c73e23d1efc2160bc", "patch": "@@ -1,22 +1,210 @@\n #ifndef LOCK_FREE_QUEUE_H\n #define LOCK_FREE_QUEUE_H\n \n-#include \"spin_lock.h\"\n+/**\n+ * How and why this lock free queue works:\n+ *\n+ * Adapted from the paper titled \"Simple, Fast, and Practical Non-Blocking\n+ * and Blocking Concurrent Queue Algorithms\" by Maged M. Michael,\n+ * Michael L. Scott.\n+ *\n+ * Safety Properties:\n+ *\n+ * 1. The linked list is always connected.\n+ * 2. Nodes are only inserted after the last node in the linked list.\n+ * 3. Nodes are only deleted from the beginning of the linked list.\n+ * 4. Head always points to the first node in the linked list.\n+ * 5. Tail always points to a node in the linked list.\n+ *\n+ *\n+ * 1. The linked list is always connected because the next pointer is not set\n+ *    to null before the node is freed, and no node is freed until deleted\n+ *    from the linked list.\n+ *\n+ * 2. Nodes are only inserted at the end of the linked list because they are\n+ *    linked through the tail pointer which always points to a node in the\n+ *    linked list (5) and an inserted node is only linked to a node that has\n+ *    a null next pointer, and the only such node is the last one (1).\n+ *\n+ * 3. Nodes are deleted from the beginning of the list because they are\n+ *    deleted only when they are pointed to by head which always points to the\n+ *    first node (4).\n+ *\n+ * 4. Head always points to the first node in the list because it only changes\n+ *    its value to the next node atomically. The new value of head cannot be\n+ *    null because if there is only one node in the list the dequeue operation\n+ *    returns without deleting any nodes.\n+ *\n+ * 5. Tail always points to a node in the linked list because it never lags\n+ *    behind head, so it can never point to a deleted node. Also, when tail\n+ *    changes its value it always swings to the next node in the list and it\n+ *    never tires to change its value if the next pointer is NULL.\n+ */\n \n-class lock_free_queue_node {\n-public:\n-    lock_free_queue_node *next;\n-    lock_free_queue_node();\n-};\n+#include <assert.h>\n+template <class T>\n+class lock_free_queue {\n+\n+    struct node_t;\n+    struct pointer_t {\n+        node_t *node;\n+        uint32_t count;\n+        pointer_t() : node(NULL), count(0) {\n+            // Nop.\n+        }\n+        pointer_t(node_t *node, uint32_t count) {\n+            this->node = node;\n+            this->count = count;\n+        }\n+        bool equals(pointer_t &other) {\n+            return node == other.node && count == other.count;\n+        }\n+    };\n+\n+    struct node_t {\n+        T value;\n+        pointer_t next;\n+\n+        node_t() {\n+            next.node = NULL;\n+            next.count = 0;\n+        }\n+\n+        node_t(pointer_t next, T value) {\n+            this->next = next;\n+            this->value = value;\n+        }\n+    };\n+\n+    // Always points to the first node in the list.\n+    pointer_t head;\n+\n+    // Always points to a node in the list, (not necessarily the last).\n+    pointer_t tail;\n+\n+    // Compare and swap counted pointers, we can only do this if pointr_t is\n+    // 8 bytes or less since that the maximum size CAS can handle.\n+    bool compare_and_swap(pointer_t *address,\n+        pointer_t *oldValue,\n+        pointer_t newValue) {\n+\n+        if (sync::compare_and_swap(\n+                (uint64_t*) address,\n+                *(uint64_t*) oldValue,\n+                *(uint64_t*) &newValue)) {\n+            return true;\n+        }\n+        return false;\n+    }\n \n-class lock_free_queue : lock_free_queue_node {\n-    spin_lock lock;\n-    lock_free_queue_node *_tail;\n public:\n-    lock_free_queue();\n-    void enqueue(lock_free_queue_node *item);\n-    lock_free_queue_node *dequeue();\n-    bool is_empty();\n+    lock_free_queue() {\n+        // We can only handle 64bit CAS for counted pointers, so this will\n+        // not work with 64bit pointers.\n+        assert (sizeof(pointer_t) == sizeof(uint64_t));\n+\n+        // Allocate a dummy node to be used as the first node in the list.\n+        node_t *node = new node_t();\n+\n+        // Head and tail both start out pointing to the dummy node.\n+        head.node = node;\n+        tail.node = node;\n+    }\n+\n+    virtual ~lock_free_queue() {\n+        // Delete dummy node.\n+        delete head.node;\n+    }\n+\n+    bool is_empty() {\n+        return head.node == tail.node;\n+    }\n+\n+    void enqueue(T value) {\n+\n+        // Create a new node to be inserted in the linked list, and set the\n+        // next node to NULL.\n+        node_t *node = new node_t();\n+        node->value = value;\n+        node->next.node = NULL;\n+        pointer_t tail;\n+\n+        // Keep trying until enqueue is done.\n+        while (true) {\n+            // Read the current tail which may either point to the last node\n+            // or to the second to last node (not sure why second to last,\n+            // and not any other node).\n+            tail = this->tail;\n+\n+            // Reads the next node after the tail which will be the last node\n+            // if null.\n+            pointer_t next;\n+            if (tail.node != NULL) {\n+                next = tail.node->next;\n+            }\n+\n+            // Loop if another thread changed the tail since we last read it.\n+            if (tail.equals(this->tail) == false) {\n+                continue;\n+            }\n+\n+            // If next is not pointing to the last node try to swing tail to\n+            // the last node and loop.\n+            if (next.node != NULL) {\n+                compare_and_swap(&this->tail, &tail,\n+                    pointer_t(next.node, tail.count + 1));\n+                continue;\n+            }\n+\n+            // Try to link node at the end of the linked list.\n+            if (compare_and_swap(&tail.node->next, &next,\n+                    pointer_t(node, next.count + 1))) {\n+                // Enqueueing is done.\n+                break;\n+            }\n+        }\n+\n+        // Enqueue is done, try to swing tail to the inserted node.\n+        compare_and_swap(&this->tail, &tail,\n+            pointer_t(node, tail.count + 1));\n+    }\n+\n+    bool dequeue(T *value) {\n+        pointer_t head;\n+\n+        // Keep trying until dequeue is done.\n+        while(true) {\n+            head = this->head;\n+            pointer_t tail = this->tail;\n+            pointer_t next = head.node->next;\n+\n+            if (head.equals(this->head) == false) {\n+                continue;\n+            }\n+\n+            // If queue is empty, or if tail is falling behind.\n+            if (head.node == tail.node) {\n+                // If queue is empty.\n+                if (next.node == NULL) {\n+                    return false;\n+                }\n+                // Tail is falling behind, advance it.\n+                compare_and_swap(&this->tail,\n+                    &tail,\n+                    pointer_t(next.node, tail.count + 1));\n+            } else {\n+                // Read value before CAS, otherwise another\n+                // dequeue might advance it.\n+                *value = next.node->value;\n+                if (compare_and_swap(&this->head, &head,\n+                    pointer_t(next.node, head.count + 1))) {\n+                    break;\n+                }\n+            }\n+        }\n+        delete head.node;\n+        return true;\n+    }\n };\n \n #endif /* LOCK_FREE_QUEUE_H */"}, {"sha": "8c9a13f0f4a9a042fa4ac10c4bdc56fbbd0964fa", "filename": "src/rt/sync/sync.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/64ff82ecf98ceb4725f0f51c73e23d1efc2160bc/src%2Frt%2Fsync%2Fsync.h", "raw_url": "https://github.com/rust-lang/rust/raw/64ff82ecf98ceb4725f0f51c73e23d1efc2160bc/src%2Frt%2Fsync%2Fsync.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Fsync.h?ref=64ff82ecf98ceb4725f0f51c73e23d1efc2160bc", "patch": "@@ -4,6 +4,11 @@\n class sync {\n public:\n     static void yield();\n+    template <class T>\n+    static bool compare_and_swap(T *address,\n+        T oldValue, T newValue) {\n+        return __sync_bool_compare_and_swap(address, oldValue, newValue);\n+    }\n };\n \n #endif /* SYNC_H */"}, {"sha": "f5fa27ac649672433ae07a076611b899032d1cbe", "filename": "src/test/run-fail/task-comm-14.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/64ff82ecf98ceb4725f0f51c73e23d1efc2160bc/src%2Ftest%2Frun-fail%2Ftask-comm-14.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64ff82ecf98ceb4725f0f51c73e23d1efc2160bc/src%2Ftest%2Frun-fail%2Ftask-comm-14.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftask-comm-14.rs?ref=64ff82ecf98ceb4725f0f51c73e23d1efc2160bc", "patch": "@@ -0,0 +1,26 @@\n+io fn main() {\n+    let port[int] po = port();\n+\n+    // Spawn 10 tasks each sending us back one int.\n+    let int i = 10;\n+    while (i > 0) {\n+        log i;\n+        spawn \"child\" child(i, chan(po));\n+        i = i - 1;\n+    }\n+\n+    i = 10;\n+    let int value = 0;\n+    while (i > 0) {\n+        log i;\n+        value <- po;\n+        i = i - 1;\n+    }\n+  \n+    log \"main thread exiting\";\n+}\n+\n+io fn child(int x, chan[int] ch) {\n+    log x;\n+    ch <| x;\n+}"}, {"sha": "ab7c25e8a62e8b2c620a3262ff6d7e553e8d0ec7", "filename": "src/test/run-pass/task-comm-12.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/64ff82ecf98ceb4725f0f51c73e23d1efc2160bc/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64ff82ecf98ceb4725f0f51c73e23d1efc2160bc/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs?ref=64ff82ecf98ceb4725f0f51c73e23d1efc2160bc", "patch": "@@ -0,0 +1,23 @@\n+use std;\n+import std._task;\n+\n+fn main() -> () {\n+    test00();\n+}\n+\n+fn start(int task_number) {\n+    log \"Started / Finished Task.\";\n+}\n+    \n+fn test00() {    \n+    let int i = 0;\n+    let task t = spawn thread start(i);\n+    \n+    // Sleep long enough for the task to finish.\n+    _task.sleep(10000u);\n+    \n+    // Try joining tasks that have already finished.\n+    join t;\n+    \n+    log \"Joined Task.\";\n+}\n\\ No newline at end of file"}, {"sha": "0dab20ed8956c40f210fec8a2586e8369a263a0f", "filename": "src/test/run-pass/task-comm-13-thread.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/64ff82ecf98ceb4725f0f51c73e23d1efc2160bc/src%2Ftest%2Frun-pass%2Ftask-comm-13-thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64ff82ecf98ceb4725f0f51c73e23d1efc2160bc/src%2Ftest%2Frun-pass%2Ftask-comm-13-thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-13-thread.rs?ref=64ff82ecf98ceb4725f0f51c73e23d1efc2160bc", "patch": "@@ -0,0 +1,18 @@\n+use std;\n+import std._task;\n+\n+io fn start(chan[int] c, int start, int number_of_messages) {\n+    let int i = 0;\n+    while (i < number_of_messages) {\n+        c <| start + i;\n+        i += 1;\n+    }    \n+}\n+\n+fn main() -> () {\n+    log \"Check that we don't deadlock.\";\n+    let port[int] p = port();\n+    let task a = spawn thread \"start\" start(chan(p), 0, 10);\n+    join a;\n+    log \"Joined Task\";\n+}\n\\ No newline at end of file"}, {"sha": "97bdcb6ac875bb17035f03e38f3f12b33e9c1e47", "filename": "src/test/run-pass/task-comm-13.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/64ff82ecf98ceb4725f0f51c73e23d1efc2160bc/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64ff82ecf98ceb4725f0f51c73e23d1efc2160bc/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs?ref=64ff82ecf98ceb4725f0f51c73e23d1efc2160bc", "patch": "@@ -0,0 +1,18 @@\n+use std;\n+import std._task;\n+\n+io fn start(chan[int] c, int start, int number_of_messages) {\n+    let int i = 0;\n+    while (i < number_of_messages) {\n+        c <| start + i;\n+        i += 1;\n+    }    \n+}\n+\n+fn main() -> () {\n+    log \"Check that we don't deadlock.\";\n+    let port[int] p = port();\n+    let task a = spawn \"start\" start(chan(p), 0, 10);\n+    join a;\n+    log \"Joined Task\";\n+}\n\\ No newline at end of file"}, {"sha": "8d748f59538c8642a19e9f3af95d88de8a07fc56", "filename": "src/test/run-pass/task-comm-15.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/64ff82ecf98ceb4725f0f51c73e23d1efc2160bc/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64ff82ecf98ceb4725f0f51c73e23d1efc2160bc/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs?ref=64ff82ecf98ceb4725f0f51c73e23d1efc2160bc", "patch": "@@ -0,0 +1,14 @@\n+io fn start(chan[int] c, int n) {\n+    let int i = n;\n+\n+    while(i > 0) {\n+        c <| 0;\n+        i = i - 1;\n+    }\n+}\n+\n+io fn main() {\n+    let port[int] p = port();\n+    auto child = spawn thread \"child\" start(chan(p), 10);\n+    auto c <- p;\n+}\n\\ No newline at end of file"}]}