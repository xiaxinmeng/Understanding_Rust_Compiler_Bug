{"sha": "499484f56d336f4628a6fa016626beb3ef21ba81", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5OTQ4NGY1NmQzMzZmNDYyOGE2ZmEwMTY2MjZiZWIzZWYyMWJhODE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-18T15:54:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-18T15:54:10Z"}, "message": "Auto merge of #35684 - nikomatsakis:incr-comp-metadata-audit-35111, r=mw\n\nRestructure metadata encoder to track deps precisely\n\nThis issue restructures meta-data encoding to track dependencies very precisely. It uses a cute technique I hope to spread elsewhere, where we can guard the data flowing into a new dep-graph task and ensure that it is not \"leaking\" information from the outside, which would result in missing edges. There are no tests because we don't know of any bugs in the old system, but it's clear that there was leaked data.\n\nThe commit series is standalone, but the refactorings are kind of \"windy\". It's a good idea to read the comment in `src/librustc_metadata/index_builder.rs` to get a feeling for the overall strategy I was aiming at.\n\nIn several cases, I wound up adding some extra hashtable lookups, I think primarily for looking up `AdtDef` instances. We could remove these by implementing `DepGraphRead` for an `AdtDef` and then having it register a read to the adt-defs table, I guess, but I doubt it is really noticeable.\n\nEventually I think I'd like to extend this pattern to the dep-graph more generally, since it effectively guarantees that data cannot leak.\n\nFixes #35111.\n\nr? @michaelwoerister", "tree": {"sha": "be3b9ad7e739b3b8db603ebf6d15e8f70fa4fb4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be3b9ad7e739b3b8db603ebf6d15e8f70fa4fb4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/499484f56d336f4628a6fa016626beb3ef21ba81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/499484f56d336f4628a6fa016626beb3ef21ba81", "html_url": "https://github.com/rust-lang/rust/commit/499484f56d336f4628a6fa016626beb3ef21ba81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/499484f56d336f4628a6fa016626beb3ef21ba81/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43c090ed69a624928c03ad61a29a59badf80ff7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/43c090ed69a624928c03ad61a29a59badf80ff7b", "html_url": "https://github.com/rust-lang/rust/commit/43c090ed69a624928c03ad61a29a59badf80ff7b"}, {"sha": "37d974f35327516e337f83be4f38579217660313", "url": "https://api.github.com/repos/rust-lang/rust/commits/37d974f35327516e337f83be4f38579217660313", "html_url": "https://github.com/rust-lang/rust/commit/37d974f35327516e337f83be4f38579217660313"}], "stats": {"total": 2176, "additions": 1217, "deletions": 959}, "files": [{"sha": "d63e0866a9d6b6949b109a88ea52a0ba82cc39ce", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/499484f56d336f4628a6fa016626beb3ef21ba81/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/499484f56d336f4628a6fa016626beb3ef21ba81/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=499484f56d336f4628a6fa016626beb3ef21ba81", "patch": "@@ -240,11 +240,10 @@ fn reexports<'a>(d: rbml::Doc<'a>) -> reader::TaggedDocsIterator<'a> {\n     reader::tagged_docs(d, tag_items_data_item_reexport)\n }\n \n-fn variant_disr_val(d: rbml::Doc) -> Option<u64> {\n-    reader::maybe_get_doc(d, tag_disr_val).and_then(|val_doc| {\n-        reader::with_doc_data(val_doc, |data| {\n-            str::from_utf8(data).ok().and_then(|s| s.parse().ok())\n-        })\n+fn variant_disr_val(d: rbml::Doc) -> u64 {\n+    let val_doc = reader::get_doc(d, tag_disr_val);\n+    reader::with_doc_data(val_doc, |data| {\n+        str::from_utf8(data).unwrap().parse().unwrap()\n     })\n }\n \n@@ -402,17 +401,10 @@ pub fn get_adt_def<'a, 'tcx>(cdata: Cmd,\n         }\n     }\n     fn get_enum_variants<'tcx>(cdata: Cmd, doc: rbml::Doc) -> Vec<ty::VariantDefData<'tcx, 'tcx>> {\n-        let mut disr_val = 0;\n         reader::tagged_docs(doc, tag_items_data_item_variant).map(|p| {\n             let did = translated_def_id(cdata, p);\n             let item = cdata.lookup_item(did.index);\n-\n-            if let Some(disr) = variant_disr_val(item) {\n-                disr_val = disr;\n-            }\n-            let disr = disr_val;\n-            disr_val = disr_val.wrapping_add(1);\n-\n+            let disr = variant_disr_val(item);\n             ty::VariantDefData {\n                 did: did,\n                 name: item_name(item),"}, {"sha": "420dfbc58bf19e95efd5efca1d1908156bb04ea9", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 958, "deletions": 946, "changes": 1904, "blob_url": "https://github.com/rust-lang/rust/blob/499484f56d336f4628a6fa016626beb3ef21ba81/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/499484f56d336f4628a6fa016626beb3ef21ba81/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=499484f56d336f4628a6fa016626beb3ef21ba81", "patch": "@@ -21,14 +21,13 @@ use def_key;\n use tyencode;\n use index::{self, IndexData};\n \n-use middle::cstore::{LOCAL_CRATE, InlinedItemRef, LinkMeta, tls};\n+use middle::cstore::{InlinedItemRef, LinkMeta, tls};\n use rustc::hir::def;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use middle::dependency_format::Linkage;\n-use rustc::dep_graph::{DepGraph, DepNode, DepTask};\n+use rustc::dep_graph::DepNode;\n use rustc::traits::specialization_graph;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::util::IntTypeExt;\n \n use rustc::hir::svh::Svh;\n use rustc::mir::mir_map::MirMap;\n@@ -54,6 +53,8 @@ use rustc::hir::intravisit::Visitor;\n use rustc::hir::intravisit;\n use rustc::hir::map::DefKey;\n \n+use super::index_builder::{FromId, IndexBuilder, ItemContentBuilder, Untracked, XRef};\n+\n pub struct EncodeContext<'a, 'tcx: 'a> {\n     pub diag: &'a Handler,\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -71,35 +72,6 @@ impl<'a, 'tcx> EncodeContext<'a,'tcx> {\n     }\n }\n \n-/// \"interned\" entries referenced by id\n-#[derive(PartialEq, Eq, Hash)]\n-pub enum XRef<'tcx> { Predicate(ty::Predicate<'tcx>) }\n-\n-struct CrateIndex<'a, 'tcx> {\n-    dep_graph: &'a DepGraph,\n-    items: IndexData,\n-    xrefs: FnvHashMap<XRef<'tcx>, u32>, // sequentially-assigned\n-}\n-\n-impl<'a, 'tcx> CrateIndex<'a, 'tcx> {\n-    /// Records that `id` is being emitted at the current offset.\n-    /// This data is later used to construct the item index in the\n-    /// metadata so we can quickly find the data for a given item.\n-    ///\n-    /// Returns a dep-graph task that you should keep live as long as\n-    /// the data for this item is being emitted.\n-    fn record(&mut self, id: DefId, rbml_w: &mut Encoder) -> DepTask<'a> {\n-        let position = rbml_w.mark_stable_position();\n-        self.items.record(id, position);\n-        self.dep_graph.in_task(DepNode::MetaData(id))\n-    }\n-\n-    fn add_xref(&mut self, xref: XRef<'tcx>) -> u32 {\n-        let old_len = self.xrefs.len() as u32;\n-        *self.xrefs.entry(xref).or_insert(old_len)\n-    }\n-}\n-\n fn encode_name(rbml_w: &mut Encoder, name: Name) {\n     rbml_w.wr_tagged_str(tag_paths_data_name, &name.as_str());\n }\n@@ -159,24 +131,20 @@ fn encode_item_variances(rbml_w: &mut Encoder,\n     rbml_w.end_tag();\n }\n \n-fn encode_bounds_and_type_for_item<'a, 'tcx>(rbml_w: &mut Encoder,\n-                                             ecx: &EncodeContext<'a, 'tcx>,\n-                                             index: &mut CrateIndex<'a, 'tcx>,\n-                                             id: NodeId) {\n-    encode_bounds_and_type(rbml_w,\n-                           ecx,\n-                           index,\n-                           &ecx.tcx.lookup_item_type(ecx.tcx.map.local_def_id(id)),\n-                           &ecx.tcx.lookup_predicates(ecx.tcx.map.local_def_id(id)));\n-}\n+impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n+    fn encode_bounds_and_type_for_item(&mut self,\n+                                       id: NodeId) {\n+        let ecx = self.ecx();\n+        self.encode_bounds_and_type(&ecx.tcx.lookup_item_type(ecx.tcx.map.local_def_id(id)),\n+                                    &ecx.tcx.lookup_predicates(ecx.tcx.map.local_def_id(id)));\n+    }\n \n-fn encode_bounds_and_type<'a, 'tcx>(rbml_w: &mut Encoder,\n-                                    ecx: &EncodeContext<'a, 'tcx>,\n-                                    index: &mut CrateIndex<'a, 'tcx>,\n-                                    scheme: &ty::TypeScheme<'tcx>,\n-                                    predicates: &ty::GenericPredicates<'tcx>) {\n-    encode_generics(rbml_w, ecx, index, &scheme.generics, &predicates);\n-    encode_type(ecx, rbml_w, scheme.ty);\n+    fn encode_bounds_and_type(&mut self,\n+                              scheme: &ty::TypeScheme<'tcx>,\n+                              predicates: &ty::GenericPredicates<'tcx>) {\n+        self.encode_generics(&scheme.generics, &predicates);\n+        self.encode_type(scheme.ty);\n+    }\n }\n \n fn encode_variant_id(rbml_w: &mut Encoder, vid: DefId) {\n@@ -192,92 +160,96 @@ fn write_closure_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     rbml_w.mark_stable_position();\n }\n \n-fn encode_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n-                         rbml_w: &mut Encoder,\n-                         typ: Ty<'tcx>) {\n-    rbml_w.start_tag(tag_items_data_item_type);\n-    tyencode::enc_ty(rbml_w.writer, &ecx.ty_str_ctxt(), typ);\n-    rbml_w.mark_stable_position();\n-    rbml_w.end_tag();\n-}\n+impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n+    fn encode_type(&mut self,\n+                   typ: Ty<'tcx>) {\n+        let ecx = self.ecx;\n+        self.rbml_w.start_tag(tag_items_data_item_type);\n+        tyencode::enc_ty(self.rbml_w.writer, &ecx.ty_str_ctxt(), typ);\n+        self.rbml_w.mark_stable_position();\n+        self.rbml_w.end_tag();\n+    }\n \n-fn encode_disr_val(_: &EncodeContext,\n-                   rbml_w: &mut Encoder,\n-                   disr_val: ty::Disr) {\n-    // convert to u64 so just the number is printed, without any type info\n-    rbml_w.wr_tagged_str(tag_disr_val, &disr_val.to_u64_unchecked().to_string());\n-}\n+    fn encode_disr_val(&mut self,\n+                       disr_val: ty::Disr) {\n+        // convert to u64 so just the number is printed, without any type info\n+        self.rbml_w.wr_tagged_str(tag_disr_val, &disr_val.to_u64_unchecked().to_string());\n+    }\n+\n+    fn encode_parent_item(&mut self, id: DefId) {\n+        self.rbml_w.wr_tagged_u64(tag_items_data_parent_item, def_to_u64(id));\n+    }\n \n-fn encode_parent_item(rbml_w: &mut Encoder, id: DefId) {\n-    rbml_w.wr_tagged_u64(tag_items_data_parent_item, def_to_u64(id));\n+    fn encode_struct_fields(&mut self,\n+                            variant: ty::VariantDef) {\n+        for f in &variant.fields {\n+            if variant.kind == ty::VariantKind::Tuple {\n+                self.rbml_w.start_tag(tag_item_unnamed_field);\n+            } else {\n+                self.rbml_w.start_tag(tag_item_field);\n+                encode_name(self.rbml_w, f.name);\n+            }\n+            self.encode_struct_field_family(f.vis);\n+            encode_def_id(self.rbml_w, f.did);\n+            self.rbml_w.end_tag();\n+        }\n+    }\n }\n \n-fn encode_struct_fields(rbml_w: &mut Encoder,\n-                        variant: ty::VariantDef) {\n-    for f in &variant.fields {\n-        if variant.kind == ty::VariantKind::Tuple {\n-            rbml_w.start_tag(tag_item_unnamed_field);\n-        } else {\n-            rbml_w.start_tag(tag_item_field);\n-            encode_name(rbml_w, f.name);\n+impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n+    fn encode_enum_variant_infos(&mut self,\n+                                 enum_did: DefId) {\n+        debug!(\"encode_enum_variant_info(enum_did={:?})\", enum_did);\n+        let ecx = self.ecx();\n+        let def = ecx.tcx.lookup_adt_def(enum_did);\n+        self.encode_fields(enum_did);\n+        for (i, variant) in def.variants.iter().enumerate() {\n+            self.record(variant.did,\n+                        ItemContentBuilder::encode_enum_variant_info,\n+                        (enum_did, Untracked(i)));\n         }\n-        encode_struct_field_family(rbml_w, f.vis);\n-        encode_def_id(rbml_w, f.did);\n-        rbml_w.end_tag();\n     }\n }\n \n-fn encode_enum_variant_info<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n-                                      rbml_w: &mut Encoder,\n-                                      did: DefId,\n-                                      vis: &hir::Visibility,\n-                                      index: &mut CrateIndex<'a, 'tcx>) {\n-    debug!(\"encode_enum_variant_info(did={:?})\", did);\n-    let repr_hints = ecx.tcx.lookup_repr_hints(did);\n-    let repr_type = ecx.tcx.enum_repr_type(repr_hints.get(0));\n-    let mut disr_val = repr_type.initial_discriminant(ecx.tcx);\n-    let def = ecx.tcx.lookup_adt_def(did);\n-    for variant in &def.variants {\n+impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n+    /// Encode data for the given variant of the given ADT. The\n+    /// index of the variant is untracked: this is ok because we\n+    /// will have to lookup the adt-def by its id, and that gives us\n+    /// the right to access any information in the adt-def (including,\n+    /// e.g., the length of the various vectors).\n+    fn encode_enum_variant_info(&mut self,\n+                                (enum_did, Untracked(index)):\n+                                (DefId, Untracked<usize>)) {\n+        let ecx = self.ecx;\n+        let def = ecx.tcx.lookup_adt_def(enum_did);\n+        let variant = &def.variants[index];\n         let vid = variant.did;\n         let variant_node_id = ecx.local_id(vid);\n-\n-        for field in &variant.fields {\n-            encode_field(ecx, rbml_w, field, index);\n-        }\n-\n-        let _task = index.record(vid, rbml_w);\n-        rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id_and_key(ecx, rbml_w, vid);\n-        encode_family(rbml_w, match variant.kind {\n+        encode_def_id_and_key(ecx, self.rbml_w, vid);\n+        encode_family(self.rbml_w, match variant.kind {\n             ty::VariantKind::Struct => 'V',\n             ty::VariantKind::Tuple => 'v',\n             ty::VariantKind::Unit => 'w',\n         });\n-        encode_name(rbml_w, variant.name);\n-        encode_parent_item(rbml_w, did);\n-        encode_visibility(rbml_w, vis);\n+        encode_name(self.rbml_w, variant.name);\n+        self.encode_parent_item(enum_did);\n+\n+        let enum_id = ecx.tcx.map.as_local_node_id(enum_did).unwrap();\n+        let enum_vis = &ecx.tcx.map.expect_item(enum_id).vis;\n+        self.encode_visibility(enum_vis);\n \n         let attrs = ecx.tcx.get_attrs(vid);\n-        encode_attributes(rbml_w, &attrs);\n-        encode_repr_attrs(rbml_w, ecx, &attrs);\n+        encode_attributes(self.rbml_w, &attrs);\n+        self.encode_repr_attrs(&attrs);\n \n         let stab = ecx.tcx.lookup_stability(vid);\n         let depr = ecx.tcx.lookup_deprecation(vid);\n-        encode_stability(rbml_w, stab);\n-        encode_deprecation(rbml_w, depr);\n-\n-        encode_struct_fields(rbml_w, variant);\n-\n-        let specified_disr_val = variant.disr_val;\n-        if specified_disr_val != disr_val {\n-            encode_disr_val(ecx, rbml_w, specified_disr_val);\n-            disr_val = specified_disr_val;\n-        }\n-        encode_bounds_and_type_for_item(rbml_w, ecx, index, variant_node_id);\n-\n-        rbml_w.end_tag();\n+        encode_stability(self.rbml_w, stab);\n+        encode_deprecation(self.rbml_w, depr);\n \n-        disr_val = disr_val.wrap_incr();\n+        self.encode_struct_fields(variant);\n+        self.encode_disr_val(variant.disr_val);\n+        self.encode_bounds_and_type_for_item(variant_node_id);\n     }\n }\n \n@@ -327,57 +299,54 @@ fn encode_reexports(ecx: &EncodeContext,\n     }\n }\n \n-fn encode_info_for_mod(ecx: &EncodeContext,\n-                       rbml_w: &mut Encoder,\n-                       md: &hir::Mod,\n-                       attrs: &[ast::Attribute],\n-                       id: NodeId,\n-                       name: Name,\n-                       vis: &hir::Visibility) {\n-    rbml_w.start_tag(tag_items_data_item);\n-    encode_def_id_and_key(ecx, rbml_w, ecx.tcx.map.local_def_id(id));\n-    encode_family(rbml_w, 'm');\n-    encode_name(rbml_w, name);\n-    debug!(\"(encoding info for module) encoding info for module ID {}\", id);\n-\n-    // Encode info about all the module children.\n-    for item_id in &md.item_ids {\n-        rbml_w.wr_tagged_u64(tag_mod_child,\n-                             def_to_u64(ecx.tcx.map.local_def_id(item_id.id)));\n-\n-        let item = ecx.tcx.map.expect_item(item_id.id);\n-        each_auxiliary_node_id(item, |auxiliary_node_id| {\n-            rbml_w.wr_tagged_u64(tag_mod_child,\n-                                 def_to_u64(ecx.tcx.map.local_def_id(auxiliary_node_id)));\n-            true\n-        });\n-    }\n+impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n+    fn encode_info_for_mod(&mut self,\n+                           FromId(id, (md, attrs, name, vis)):\n+                           FromId<(&hir::Mod, &[ast::Attribute], Name, &hir::Visibility)>) {\n+        let ecx = self.ecx();\n+\n+        encode_def_id_and_key(ecx, self.rbml_w, ecx.tcx.map.local_def_id(id));\n+        encode_family(self.rbml_w, 'm');\n+        encode_name(self.rbml_w, name);\n+        debug!(\"(encoding info for module) encoding info for module ID {}\", id);\n+\n+        // Encode info about all the module children.\n+        for item_id in &md.item_ids {\n+            self.rbml_w.wr_tagged_u64(tag_mod_child,\n+                                 def_to_u64(ecx.tcx.map.local_def_id(item_id.id)));\n+\n+            let item = ecx.tcx.map.expect_item(item_id.id);\n+            each_auxiliary_node_id(item, |auxiliary_node_id| {\n+                self.rbml_w.wr_tagged_u64(tag_mod_child,\n+                                     def_to_u64(ecx.tcx.map.local_def_id(auxiliary_node_id)));\n+                true\n+            });\n+        }\n \n-    encode_visibility(rbml_w, vis);\n+        self.encode_visibility(vis);\n \n-    let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(id));\n-    let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(id));\n-    encode_stability(rbml_w, stab);\n-    encode_deprecation(rbml_w, depr);\n+        let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(id));\n+        let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(id));\n+        encode_stability(self.rbml_w, stab);\n+        encode_deprecation(self.rbml_w, depr);\n \n-    // Encode the reexports of this module, if this module is public.\n-    if *vis == hir::Public {\n-        debug!(\"(encoding info for module) encoding reexports for {}\", id);\n-        encode_reexports(ecx, rbml_w, id);\n+        // Encode the reexports of this module, if this module is public.\n+        if *vis == hir::Public {\n+            debug!(\"(encoding info for module) encoding reexports for {}\", id);\n+            encode_reexports(ecx, self.rbml_w, id);\n+        }\n+        encode_attributes(self.rbml_w, attrs);\n     }\n-    encode_attributes(rbml_w, attrs);\n \n-    rbml_w.end_tag();\n-}\n-\n-fn encode_struct_field_family(rbml_w: &mut Encoder,\n-                              visibility: ty::Visibility) {\n-    encode_family(rbml_w, if visibility.is_public() { 'g' } else { 'N' });\n-}\n+    fn encode_struct_field_family(&mut self,\n+                                  visibility: ty::Visibility) {\n+        encode_family(self.rbml_w, if visibility.is_public() { 'g' } else { 'N' });\n+    }\n \n-fn encode_visibility<T: HasVisibility>(rbml_w: &mut Encoder, visibility: T) {\n-    let ch = if visibility.is_public() { 'y' } else { 'i' };\n-    rbml_w.wr_tagged_u8(tag_items_data_item_visibility, ch as u8);\n+    fn encode_visibility<T: HasVisibility>(&mut self, visibility: T) {\n+        let ch = if visibility.is_public() { 'y' } else { 'i' };\n+        self.rbml_w.wr_tagged_u8(tag_items_data_item_visibility, ch as u8);\n+    }\n }\n \n trait HasVisibility: Sized {\n@@ -448,280 +417,405 @@ fn encode_item_sort(rbml_w: &mut Encoder, sort: char) {\n     rbml_w.wr_tagged_u8(tag_item_trait_item_sort, sort as u8);\n }\n \n-fn encode_field<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n-                          rbml_w: &mut Encoder,\n-                          field: ty::FieldDef<'tcx>,\n-                          index: &mut CrateIndex<'a, 'tcx>) {\n-    let nm = field.name;\n-    let id = ecx.local_id(field.did);\n-\n-    let _task = index.record(field.did, rbml_w);\n-    rbml_w.start_tag(tag_items_data_item);\n-    debug!(\"encode_field: encoding {} {}\", nm, id);\n-    encode_struct_field_family(rbml_w, field.vis);\n-    encode_name(rbml_w, nm);\n-    encode_bounds_and_type_for_item(rbml_w, ecx, index, id);\n-    encode_def_id_and_key(ecx, rbml_w, field.did);\n-\n-    let stab = ecx.tcx.lookup_stability(field.did);\n-    let depr = ecx.tcx.lookup_deprecation(field.did);\n-    encode_stability(rbml_w, stab);\n-    encode_deprecation(rbml_w, depr);\n-\n-    rbml_w.end_tag();\n+impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n+    fn encode_fields(&mut self,\n+                     adt_def_id: DefId) {\n+        let def = self.ecx().tcx.lookup_adt_def(adt_def_id);\n+        for (variant_index, variant) in def.variants.iter().enumerate() {\n+            for (field_index, field) in variant.fields.iter().enumerate() {\n+                self.record(field.did,\n+                            ItemContentBuilder::encode_field,\n+                            (adt_def_id, Untracked((variant_index, field_index))));\n+            }\n+        }\n+    }\n }\n \n-fn encode_info_for_struct_ctor<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n-                                         rbml_w: &mut Encoder,\n-                                         name: Name,\n-                                         struct_def: &hir::VariantData,\n-                                         index: &mut CrateIndex<'a, 'tcx>,\n-                                         struct_id: NodeId) {\n-    let ctor_id = struct_def.id();\n-    let ctor_def_id = ecx.tcx.map.local_def_id(ctor_id);\n-\n-    let _task = index.record(ctor_def_id, rbml_w);\n-    rbml_w.start_tag(tag_items_data_item);\n-    encode_def_id_and_key(ecx, rbml_w, ctor_def_id);\n-    encode_family(rbml_w, match *struct_def {\n-        hir::VariantData::Struct(..) => 'S',\n-        hir::VariantData::Tuple(..) => 's',\n-        hir::VariantData::Unit(..) => 'u',\n-    });\n-    encode_bounds_and_type_for_item(rbml_w, ecx, index, ctor_id);\n-    encode_name(rbml_w, name);\n-    encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(struct_id));\n-\n-    let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(ctor_id));\n-    let depr= ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(ctor_id));\n-    encode_stability(rbml_w, stab);\n-    encode_deprecation(rbml_w, depr);\n-\n-    // indicate that this is a tuple struct ctor, because downstream users will normally want\n-    // the tuple struct definition, but without this there is no way for them to tell that\n-    // they actually have a ctor rather than a normal function\n-    rbml_w.wr_tagged_bytes(tag_items_data_item_is_tuple_struct_ctor, &[]);\n-\n-    rbml_w.end_tag();\n+impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n+    /// Encode data for the given field of the given variant of the\n+    /// given ADT. The indices of the variant/field are untracked:\n+    /// this is ok because we will have to lookup the adt-def by its\n+    /// id, and that gives us the right to access any information in\n+    /// the adt-def (including, e.g., the length of the various\n+    /// vectors).\n+    fn encode_field(&mut self,\n+                    (adt_def_id, Untracked((variant_index, field_index))):\n+                    (DefId, Untracked<(usize, usize)>)) {\n+        let ecx = self.ecx();\n+        let def = ecx.tcx.lookup_adt_def(adt_def_id);\n+        let variant = &def.variants[variant_index];\n+        let field = &variant.fields[field_index];\n+\n+        let nm = field.name;\n+        let id = ecx.local_id(field.did);\n+        debug!(\"encode_field: encoding {} {}\", nm, id);\n+\n+        self.encode_struct_field_family(field.vis);\n+        encode_name(self.rbml_w, nm);\n+        self.encode_bounds_and_type_for_item(id);\n+        encode_def_id_and_key(ecx, self.rbml_w, field.did);\n+\n+        let stab = ecx.tcx.lookup_stability(field.did);\n+        let depr = ecx.tcx.lookup_deprecation(field.did);\n+        encode_stability(self.rbml_w, stab);\n+        encode_deprecation(self.rbml_w, depr);\n+    }\n }\n \n-fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n-                             ecx: &EncodeContext<'a, 'tcx>,\n-                             index: &mut CrateIndex<'a, 'tcx>,\n-                             generics: &ty::Generics<'tcx>,\n-                             predicates: &ty::GenericPredicates<'tcx>)\n-{\n-    rbml_w.start_tag(tag_item_generics);\n-    tyencode::enc_generics(rbml_w.writer, &ecx.ty_str_ctxt(), generics);\n-    rbml_w.mark_stable_position();\n-    rbml_w.end_tag();\n-\n-    encode_predicates(rbml_w, index, predicates, tag_item_predicates);\n+impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n+    fn encode_struct_ctor(&mut self,\n+                          (struct_def_id, struct_node_id, ctor_node_id):\n+                          (DefId, ast::NodeId, ast::NodeId)) {\n+        let ecx = self.ecx();\n+        let def = ecx.tcx.lookup_adt_def(struct_def_id);\n+        let variant = def.struct_variant();\n+        let item = ecx.tcx.map.expect_item(struct_node_id);\n+        let ctor_def_id = ecx.tcx.map.local_def_id(ctor_node_id);\n+        encode_def_id_and_key(ecx, self.rbml_w, ctor_def_id);\n+        encode_family(self.rbml_w, match variant.kind {\n+            ty::VariantKind::Struct => 'S',\n+            ty::VariantKind::Tuple => 's',\n+            ty::VariantKind::Unit => 'u',\n+        });\n+        self.encode_bounds_and_type_for_item(ctor_node_id);\n+        encode_name(self.rbml_w, item.name);\n+        self.encode_parent_item(struct_def_id);\n+\n+        let stab = ecx.tcx.lookup_stability(ctor_def_id);\n+        let depr = ecx.tcx.lookup_deprecation(ctor_def_id);\n+        encode_stability(self.rbml_w, stab);\n+        encode_deprecation(self.rbml_w, depr);\n+\n+        // indicate that this is a tuple struct ctor, because\n+        // downstream users will normally want the tuple struct\n+        // definition, but without this there is no way for them\n+        // to tell that they actually have a ctor rather than a\n+        // normal function\n+        self.rbml_w.wr_tagged_bytes(tag_items_data_item_is_tuple_struct_ctor, &[]);\n+    }\n }\n \n-fn encode_predicates<'a,'tcx>(rbml_w: &mut Encoder,\n-                              index: &mut CrateIndex<'a, 'tcx>,\n-                              predicates: &ty::GenericPredicates<'tcx>,\n-                              tag: usize)\n-{\n-    rbml_w.start_tag(tag);\n-    if let Some(def_id) = predicates.parent {\n-        rbml_w.wr_tagged_u64(tag_items_data_parent_item, def_to_u64(def_id));\n+impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n+    fn encode_generics(&mut self,\n+                       generics: &ty::Generics<'tcx>,\n+                       predicates: &ty::GenericPredicates<'tcx>)\n+    {\n+        let ecx = self.ecx();\n+        self.rbml_w.start_tag(tag_item_generics);\n+        tyencode::enc_generics(self.rbml_w.writer, &ecx.ty_str_ctxt(), generics);\n+        self.rbml_w.mark_stable_position();\n+        self.rbml_w.end_tag();\n+        self.encode_predicates(predicates, tag_item_predicates);\n     }\n-    for predicate in &predicates.predicates {\n-        rbml_w.wr_tagged_u32(tag_predicate,\n-            index.add_xref(XRef::Predicate(predicate.clone())));\n+\n+    fn encode_predicates(&mut self,\n+                         predicates: &ty::GenericPredicates<'tcx>,\n+                         tag: usize) {\n+        self.rbml_w.start_tag(tag);\n+        if let Some(def_id) = predicates.parent {\n+            self.rbml_w.wr_tagged_u64(tag_items_data_parent_item, def_to_u64(def_id));\n+        }\n+        for predicate in &predicates.predicates {\n+            let xref = self.add_xref(XRef::Predicate(predicate.clone()));\n+            self.rbml_w.wr_tagged_u32(tag_predicate, xref);\n+        }\n+        self.rbml_w.end_tag();\n     }\n-    rbml_w.end_tag();\n-}\n \n-fn encode_method_ty_fields<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n-                                     rbml_w: &mut Encoder,\n-                                     index: &mut CrateIndex<'a, 'tcx>,\n-                                     method_ty: &ty::Method<'tcx>) {\n-    encode_def_id_and_key(ecx, rbml_w, method_ty.def_id);\n-    encode_name(rbml_w, method_ty.name);\n-    encode_generics(rbml_w, ecx, index,\n-                    &method_ty.generics, &method_ty.predicates);\n-    encode_visibility(rbml_w, method_ty.vis);\n-    encode_explicit_self(rbml_w, &method_ty.explicit_self);\n-    match method_ty.explicit_self {\n-        ty::ExplicitSelfCategory::Static => {\n-            encode_family(rbml_w, STATIC_METHOD_FAMILY);\n+    fn encode_method_ty_fields(&mut self,\n+                               method_ty: &ty::Method<'tcx>) {\n+        let ecx = self.ecx();\n+        encode_def_id_and_key(ecx, self.rbml_w, method_ty.def_id);\n+        encode_name(self.rbml_w, method_ty.name);\n+        self.encode_generics(&method_ty.generics, &method_ty.predicates);\n+        self.encode_visibility(method_ty.vis);\n+        encode_explicit_self(self.rbml_w, &method_ty.explicit_self);\n+        match method_ty.explicit_self {\n+            ty::ExplicitSelfCategory::Static => {\n+                encode_family(self.rbml_w, STATIC_METHOD_FAMILY);\n+            }\n+            _ => encode_family(self.rbml_w, METHOD_FAMILY)\n         }\n-        _ => encode_family(rbml_w, METHOD_FAMILY)\n     }\n }\n \n-fn encode_info_for_associated_const<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n-                                              rbml_w: &mut Encoder,\n-                                              index: &mut CrateIndex<'a, 'tcx>,\n-                                              associated_const: &ty::AssociatedConst,\n-                                              parent_id: NodeId,\n-                                              impl_item_opt: Option<&hir::ImplItem>) {\n-    debug!(\"encode_info_for_associated_const({:?},{:?})\",\n-           associated_const.def_id,\n-           associated_const.name);\n+impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n+    fn encode_info_for_trait_item(&mut self,\n+                                  (trait_def_id, item_def_id, trait_item):\n+                                  (DefId, DefId, &hir::TraitItem)) {\n+        let ecx = self.ecx;\n+        let tcx = ecx.tcx;\n \n-    let _task = index.record(associated_const.def_id, rbml_w);\n-    rbml_w.start_tag(tag_items_data_item);\n+        self.encode_parent_item(trait_def_id);\n \n-    encode_def_id_and_key(ecx, rbml_w, associated_const.def_id);\n-    encode_name(rbml_w, associated_const.name);\n-    encode_visibility(rbml_w, associated_const.vis);\n-    encode_family(rbml_w, 'C');\n+        let stab = tcx.lookup_stability(item_def_id);\n+        let depr = tcx.lookup_deprecation(item_def_id);\n+        encode_stability(self.rbml_w, stab);\n+        encode_deprecation(self.rbml_w, depr);\n \n-    encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n-    encode_item_sort(rbml_w, 'C');\n+        let trait_item_type =\n+            tcx.impl_or_trait_item(item_def_id);\n+        let is_nonstatic_method;\n+        match trait_item_type {\n+            ty::ConstTraitItem(associated_const) => {\n+                encode_name(self.rbml_w, associated_const.name);\n+                encode_def_id_and_key(ecx, self.rbml_w, associated_const.def_id);\n+                self.encode_visibility(associated_const.vis);\n \n-    encode_bounds_and_type_for_item(rbml_w, ecx, index,\n-                                    ecx.local_id(associated_const.def_id));\n+                encode_family(self.rbml_w, 'C');\n \n-    let stab = ecx.tcx.lookup_stability(associated_const.def_id);\n-    let depr = ecx.tcx.lookup_deprecation(associated_const.def_id);\n-    encode_stability(rbml_w, stab);\n-    encode_deprecation(rbml_w, depr);\n+                self.encode_bounds_and_type_for_item(\n+                    ecx.local_id(associated_const.def_id));\n \n-    if let Some(ii) = impl_item_opt {\n-        encode_attributes(rbml_w, &ii.attrs);\n-        encode_defaultness(rbml_w, ii.defaultness);\n-        encode_inlined_item(ecx,\n-                            rbml_w,\n-                            InlinedItemRef::ImplItem(ecx.tcx.map.local_def_id(parent_id),\n-                                                     ii));\n-        encode_mir(ecx, rbml_w, ii.id);\n-    }\n+                is_nonstatic_method = false;\n+            }\n+            ty::MethodTraitItem(method_ty) => {\n+                let method_def_id = item_def_id;\n \n-    rbml_w.end_tag();\n-}\n+                self.encode_method_ty_fields(&method_ty);\n+\n+                match method_ty.explicit_self {\n+                    ty::ExplicitSelfCategory::Static => {\n+                        encode_family(self.rbml_w,\n+                                      STATIC_METHOD_FAMILY);\n+                    }\n+                    _ => {\n+                        encode_family(self.rbml_w,\n+                                      METHOD_FAMILY);\n+                    }\n+                }\n+                self.encode_bounds_and_type_for_item(ecx.local_id(method_def_id));\n+\n+                is_nonstatic_method = method_ty.explicit_self !=\n+                    ty::ExplicitSelfCategory::Static;\n+            }\n+            ty::TypeTraitItem(associated_type) => {\n+                encode_name(self.rbml_w, associated_type.name);\n+                encode_def_id_and_key(ecx, self.rbml_w, associated_type.def_id);\n+                encode_item_sort(self.rbml_w, 't');\n+                encode_family(self.rbml_w, 'y');\n+\n+                if let Some(ty) = associated_type.ty {\n+                    self.encode_type(ty);\n+                }\n \n-fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n-                                    rbml_w: &mut Encoder,\n-                                    index: &mut CrateIndex<'a, 'tcx>,\n-                                    m: &ty::Method<'tcx>,\n-                                    is_default_impl: bool,\n-                                    parent_id: NodeId,\n-                                    impl_item_opt: Option<&hir::ImplItem>) {\n-\n-    debug!(\"encode_info_for_method: {:?} {:?}\", m.def_id,\n-           m.name);\n-    let _task = index.record(m.def_id, rbml_w);\n-    rbml_w.start_tag(tag_items_data_item);\n-\n-    encode_method_ty_fields(ecx, rbml_w, index, m);\n-    encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n-    encode_item_sort(rbml_w, 'r');\n-\n-    let stab = ecx.tcx.lookup_stability(m.def_id);\n-    let depr = ecx.tcx.lookup_deprecation(m.def_id);\n-    encode_stability(rbml_w, stab);\n-    encode_deprecation(rbml_w, depr);\n-\n-    let m_node_id = ecx.local_id(m.def_id);\n-    encode_bounds_and_type_for_item(rbml_w, ecx, index, m_node_id);\n-\n-    if let Some(impl_item) = impl_item_opt {\n-        if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n-            encode_attributes(rbml_w, &impl_item.attrs);\n-            let generics = ecx.tcx.lookup_generics(m.def_id);\n-            let types = generics.parent_types as usize + generics.types.len();\n-            let needs_inline = types > 0 || is_default_impl ||\n-                               attr::requests_inline(&impl_item.attrs);\n-            if needs_inline || sig.constness == hir::Constness::Const {\n-                encode_inlined_item(ecx,\n-                                    rbml_w,\n-                                    InlinedItemRef::ImplItem(ecx.tcx.map.local_def_id(parent_id),\n-                                                             impl_item));\n-                encode_mir(ecx, rbml_w, impl_item.id);\n+                is_nonstatic_method = false;\n             }\n-            encode_constness(rbml_w, sig.constness);\n-            encode_defaultness(rbml_w, impl_item.defaultness);\n-            encode_method_argument_names(rbml_w, &sig.decl);\n         }\n-    }\n \n-    rbml_w.end_tag();\n-}\n+        encode_attributes(self.rbml_w, &trait_item.attrs);\n+        match trait_item.node {\n+            hir::ConstTraitItem(_, ref default) => {\n+                if default.is_some() {\n+                    encode_item_sort(self.rbml_w, 'C');\n+                } else {\n+                    encode_item_sort(self.rbml_w, 'c');\n+                }\n \n-fn encode_info_for_associated_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n-                                             rbml_w: &mut Encoder,\n-                                             index: &mut CrateIndex<'a, 'tcx>,\n-                                             associated_type: &ty::AssociatedType<'tcx>,\n-                                             parent_id: NodeId,\n-                                             impl_item_opt: Option<&hir::ImplItem>) {\n-    debug!(\"encode_info_for_associated_type({:?},{:?})\",\n-           associated_type.def_id,\n-           associated_type.name);\n+                encode_inlined_item(ecx, self.rbml_w,\n+                                    InlinedItemRef::TraitItem(trait_def_id, trait_item));\n+                self.encode_mir(trait_item.id);\n+            }\n+            hir::MethodTraitItem(ref sig, ref body) => {\n+                // If this is a static method, we've already\n+                // encoded self.\n+                if is_nonstatic_method {\n+                    self.encode_bounds_and_type_for_item(\n+                        ecx.local_id(item_def_id));\n+                }\n \n-    let _task = index.record(associated_type.def_id, rbml_w);\n-    rbml_w.start_tag(tag_items_data_item);\n+                if body.is_some() {\n+                    encode_item_sort(self.rbml_w, 'p');\n+                    encode_inlined_item(ecx,\n+                                        self.rbml_w,\n+                                        InlinedItemRef::TraitItem(\n+                                            trait_def_id,\n+                                            trait_item));\n+                    self.encode_mir(trait_item.id);\n+                } else {\n+                    encode_item_sort(self.rbml_w, 'r');\n+                }\n+                self.encode_method_argument_names(&sig.decl);\n+            }\n \n-    encode_def_id_and_key(ecx, rbml_w, associated_type.def_id);\n-    encode_name(rbml_w, associated_type.name);\n-    encode_visibility(rbml_w, associated_type.vis);\n-    encode_family(rbml_w, 'y');\n-    encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n-    encode_item_sort(rbml_w, 't');\n+            hir::TypeTraitItem(..) => {}\n+        }\n+    }\n \n-    let stab = ecx.tcx.lookup_stability(associated_type.def_id);\n-    let depr = ecx.tcx.lookup_deprecation(associated_type.def_id);\n-    encode_stability(rbml_w, stab);\n-    encode_deprecation(rbml_w, depr);\n+    fn encode_info_for_impl_item(&mut self,\n+                                 (impl_id, impl_item_def_id, ast_item):\n+                                 (NodeId, DefId, Option<&hir::ImplItem>)) {\n+        match self.ecx.tcx.impl_or_trait_item(impl_item_def_id) {\n+            ty::ConstTraitItem(ref associated_const) => {\n+                self.encode_info_for_associated_const(&associated_const,\n+                                                      impl_id,\n+                                                      ast_item)\n+            }\n+            ty::MethodTraitItem(ref method_type) => {\n+                self.encode_info_for_method(&method_type,\n+                                            false,\n+                                            impl_id,\n+                                            ast_item)\n+            }\n+            ty::TypeTraitItem(ref associated_type) => {\n+                self.encode_info_for_associated_type(&associated_type,\n+                                                     impl_id,\n+                                                     ast_item)\n+            }\n+        }\n+    }\n \n-    if let Some(ii) = impl_item_opt {\n-        encode_attributes(rbml_w, &ii.attrs);\n-        encode_defaultness(rbml_w, ii.defaultness);\n-    } else {\n-        encode_predicates(rbml_w, index,\n-                          &ecx.tcx.lookup_predicates(associated_type.def_id),\n-                          tag_item_generics);\n+    fn encode_info_for_associated_const(&mut self,\n+                                        associated_const: &ty::AssociatedConst,\n+                                        parent_id: NodeId,\n+                                        impl_item_opt: Option<&hir::ImplItem>) {\n+        let ecx = self.ecx();\n+        debug!(\"encode_info_for_associated_const({:?},{:?})\",\n+               associated_const.def_id,\n+               associated_const.name);\n+\n+        encode_def_id_and_key(ecx, self.rbml_w, associated_const.def_id);\n+        encode_name(self.rbml_w, associated_const.name);\n+        self.encode_visibility(associated_const.vis);\n+        encode_family(self.rbml_w, 'C');\n+\n+        self.encode_parent_item(ecx.tcx.map.local_def_id(parent_id));\n+        encode_item_sort(self.rbml_w, 'C');\n+\n+        self.encode_bounds_and_type_for_item(ecx.local_id(associated_const.def_id));\n+\n+        let stab = ecx.tcx.lookup_stability(associated_const.def_id);\n+        let depr = ecx.tcx.lookup_deprecation(associated_const.def_id);\n+        encode_stability(self.rbml_w, stab);\n+        encode_deprecation(self.rbml_w, depr);\n+\n+        if let Some(ii) = impl_item_opt {\n+            encode_attributes(self.rbml_w, &ii.attrs);\n+            encode_defaultness(self.rbml_w, ii.defaultness);\n+            encode_inlined_item(ecx,\n+                                self.rbml_w,\n+                                InlinedItemRef::ImplItem(ecx.tcx.map.local_def_id(parent_id),\n+                                                         ii));\n+            self.encode_mir(ii.id);\n+        }\n     }\n \n-    if let Some(ty) = associated_type.ty {\n-        encode_type(ecx, rbml_w, ty);\n+    fn encode_info_for_method(&mut self,\n+                              m: &ty::Method<'tcx>,\n+                              is_default_impl: bool,\n+                              parent_id: NodeId,\n+                              impl_item_opt: Option<&hir::ImplItem>) {\n+        let ecx = self.ecx();\n+\n+        debug!(\"encode_info_for_method: {:?} {:?}\", m.def_id,\n+               m.name);\n+        self.encode_method_ty_fields(m);\n+        self.encode_parent_item(ecx.tcx.map.local_def_id(parent_id));\n+        encode_item_sort(self.rbml_w, 'r');\n+\n+        let stab = ecx.tcx.lookup_stability(m.def_id);\n+        let depr = ecx.tcx.lookup_deprecation(m.def_id);\n+        encode_stability(self.rbml_w, stab);\n+        encode_deprecation(self.rbml_w, depr);\n+\n+        let m_node_id = ecx.local_id(m.def_id);\n+        self.encode_bounds_and_type_for_item(m_node_id);\n+\n+        if let Some(impl_item) = impl_item_opt {\n+            if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n+                encode_attributes(self.rbml_w, &impl_item.attrs);\n+                let generics = ecx.tcx.lookup_generics(m.def_id);\n+                let types = generics.parent_types as usize + generics.types.len();\n+                let needs_inline = types > 0 || is_default_impl ||\n+                    attr::requests_inline(&impl_item.attrs);\n+                if needs_inline || sig.constness == hir::Constness::Const {\n+                    encode_inlined_item(\n+                        ecx,\n+                        self.rbml_w,\n+                        InlinedItemRef::ImplItem(ecx.tcx.map.local_def_id(parent_id),\n+                                                 impl_item));\n+                    self.encode_mir(impl_item.id);\n+                }\n+                encode_constness(self.rbml_w, sig.constness);\n+                encode_defaultness(self.rbml_w, impl_item.defaultness);\n+                self.encode_method_argument_names(&sig.decl);\n+            }\n+        }\n     }\n \n-    rbml_w.end_tag();\n-}\n+    fn encode_info_for_associated_type(&mut self,\n+                                       associated_type: &ty::AssociatedType<'tcx>,\n+                                       parent_id: NodeId,\n+                                       impl_item_opt: Option<&hir::ImplItem>) {\n+        let ecx = self.ecx();\n+        debug!(\"encode_info_for_associated_type({:?},{:?})\",\n+               associated_type.def_id,\n+               associated_type.name);\n+\n+        encode_def_id_and_key(ecx, self.rbml_w, associated_type.def_id);\n+        encode_name(self.rbml_w, associated_type.name);\n+        self.encode_visibility(associated_type.vis);\n+        encode_family(self.rbml_w, 'y');\n+        self.encode_parent_item(ecx.tcx.map.local_def_id(parent_id));\n+        encode_item_sort(self.rbml_w, 't');\n+\n+        let stab = ecx.tcx.lookup_stability(associated_type.def_id);\n+        let depr = ecx.tcx.lookup_deprecation(associated_type.def_id);\n+        encode_stability(self.rbml_w, stab);\n+        encode_deprecation(self.rbml_w, depr);\n+\n+        if let Some(ii) = impl_item_opt {\n+            encode_attributes(self.rbml_w, &ii.attrs);\n+            encode_defaultness(self.rbml_w, ii.defaultness);\n+        }\n \n-fn encode_method_argument_names(rbml_w: &mut Encoder,\n-                                decl: &hir::FnDecl) {\n-    rbml_w.start_tag(tag_method_argument_names);\n-    for arg in &decl.inputs {\n-        let tag = tag_method_argument_name;\n-        if let PatKind::Binding(_, ref path1, _) = arg.pat.node {\n-            let name = path1.node.as_str();\n-            rbml_w.wr_tagged_bytes(tag, name.as_bytes());\n-        } else {\n-            rbml_w.wr_tagged_bytes(tag, &[]);\n+        if let Some(ty) = associated_type.ty {\n+            self.encode_type(ty);\n         }\n     }\n-    rbml_w.end_tag();\n }\n \n-fn encode_repr_attrs(rbml_w: &mut Encoder,\n-                     ecx: &EncodeContext,\n-                     attrs: &[ast::Attribute]) {\n-    let mut repr_attrs = Vec::new();\n-    for attr in attrs {\n-        repr_attrs.extend(attr::find_repr_attrs(ecx.tcx.sess.diagnostic(),\n-                                                attr));\n+impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n+    fn encode_method_argument_names(&mut self,\n+                                    decl: &hir::FnDecl) {\n+        self.rbml_w.start_tag(tag_method_argument_names);\n+        for arg in &decl.inputs {\n+            let tag = tag_method_argument_name;\n+            if let PatKind::Binding(_, ref path1, _) = arg.pat.node {\n+                let name = path1.node.as_str();\n+                self.rbml_w.wr_tagged_bytes(tag, name.as_bytes());\n+            } else {\n+                self.rbml_w.wr_tagged_bytes(tag, &[]);\n+            }\n+        }\n+        self.rbml_w.end_tag();\n     }\n-    rbml_w.start_tag(tag_items_data_item_repr);\n-    repr_attrs.encode(rbml_w);\n-    rbml_w.end_tag();\n-}\n \n-fn encode_mir(ecx: &EncodeContext, rbml_w: &mut Encoder, node_id: NodeId) {\n-    let def_id = ecx.tcx.map.local_def_id(node_id);\n-    if let Some(mir) = ecx.mir_map.map.get(&def_id) {\n-        rbml_w.start_tag(tag_mir as usize);\n-        rbml_w.emit_opaque(|opaque_encoder| {\n-            tls::enter_encoding_context(ecx, opaque_encoder, |_, opaque_encoder| {\n-                Encodable::encode(mir, opaque_encoder)\n-            })\n-        }).unwrap();\n-        rbml_w.end_tag();\n+    fn encode_repr_attrs(&mut self,\n+                         attrs: &[ast::Attribute]) {\n+        let ecx = self.ecx();\n+        let mut repr_attrs = Vec::new();\n+        for attr in attrs {\n+            repr_attrs.extend(attr::find_repr_attrs(ecx.tcx.sess.diagnostic(),\n+                                                    attr));\n+        }\n+        self.rbml_w.start_tag(tag_items_data_item_repr);\n+        repr_attrs.encode(self.rbml_w);\n+        self.rbml_w.end_tag();\n+    }\n+\n+    fn encode_mir(&mut self, node_id: NodeId) {\n+        let ecx = self.ecx();\n+        let def_id = ecx.tcx.map.local_def_id(node_id);\n+        if let Some(mir) = ecx.mir_map.map.get(&def_id) {\n+            self.rbml_w.start_tag(tag_mir as usize);\n+            self.rbml_w.emit_opaque(|opaque_encoder| {\n+                tls::enter_encoding_context(ecx, opaque_encoder, |_, opaque_encoder| {\n+                    Encodable::encode(mir, opaque_encoder)\n+                })\n+            }).unwrap();\n+            self.rbml_w.end_tag();\n+        }\n     }\n }\n \n@@ -789,273 +883,346 @@ fn encode_xrefs<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     rbml_w.end_tag();\n }\n \n-fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n-                                  rbml_w: &mut Encoder,\n-                                  item: &hir::Item,\n-                                  index: &mut CrateIndex<'a, 'tcx>) {\n-    let tcx = ecx.tcx;\n+impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n+    fn encode_info_for_item(&mut self,\n+                            (def_id, item): (DefId, &hir::Item)) {\n+        let ecx = self.ecx();\n+        let tcx = ecx.tcx;\n \n-    debug!(\"encoding info for item at {}\",\n-           tcx.sess.codemap().span_to_string(item.span));\n+        debug!(\"encoding info for item at {}\",\n+               tcx.sess.codemap().span_to_string(item.span));\n \n-    let vis = &item.vis;\n-    let def_id = ecx.tcx.map.local_def_id(item.id);\n-\n-    let (stab, depr) = tcx.dep_graph.with_task(DepNode::MetaData(def_id), || {\n-        (tcx.lookup_stability(ecx.tcx.map.local_def_id(item.id)),\n-         tcx.lookup_deprecation(ecx.tcx.map.local_def_id(item.id)))\n-    });\n+        let vis = &item.vis;\n \n-    match item.node {\n-      hir::ItemStatic(_, m, _) => {\n-        let _task = index.record(def_id, rbml_w);\n-        rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id_and_key(ecx, rbml_w, def_id);\n-        if m == hir::MutMutable {\n-            encode_family(rbml_w, 'b');\n-        } else {\n-            encode_family(rbml_w, 'c');\n-        }\n-        encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n-        encode_name(rbml_w, item.name);\n-        encode_visibility(rbml_w, vis);\n-        encode_stability(rbml_w, stab);\n-        encode_deprecation(rbml_w, depr);\n-        encode_attributes(rbml_w, &item.attrs);\n-        rbml_w.end_tag();\n-      }\n-      hir::ItemConst(_, _) => {\n-        let _task = index.record(def_id, rbml_w);\n-        rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id_and_key(ecx, rbml_w, def_id);\n-        encode_family(rbml_w, 'C');\n-        encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n-        encode_name(rbml_w, item.name);\n-        encode_attributes(rbml_w, &item.attrs);\n-        encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(def_id, item));\n-        encode_mir(ecx, rbml_w, item.id);\n-        encode_visibility(rbml_w, vis);\n-        encode_stability(rbml_w, stab);\n-        encode_deprecation(rbml_w, depr);\n-        rbml_w.end_tag();\n-      }\n-      hir::ItemFn(ref decl, _, constness, _, ref generics, _) => {\n-        let _task = index.record(def_id, rbml_w);\n-        rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id_and_key(ecx, rbml_w, def_id);\n-        encode_family(rbml_w, FN_FAMILY);\n-        let tps_len = generics.ty_params.len();\n-        encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n-        encode_name(rbml_w, item.name);\n-        encode_attributes(rbml_w, &item.attrs);\n-        let needs_inline = tps_len > 0 || attr::requests_inline(&item.attrs);\n-        if needs_inline || constness == hir::Constness::Const {\n-            encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(def_id, item));\n-            encode_mir(ecx, rbml_w, item.id);\n-        }\n-        encode_constness(rbml_w, constness);\n-        encode_visibility(rbml_w, vis);\n-        encode_stability(rbml_w, stab);\n-        encode_deprecation(rbml_w, depr);\n-        encode_method_argument_names(rbml_w, &decl);\n-        rbml_w.end_tag();\n-      }\n-      hir::ItemMod(ref m) => {\n-        let _task = index.record(def_id, rbml_w);\n-        encode_info_for_mod(ecx,\n-                            rbml_w,\n-                            m,\n-                            &item.attrs,\n-                            item.id,\n-                            item.name,\n-                            &item.vis);\n-      }\n-      hir::ItemForeignMod(ref fm) => {\n-        let _task = index.record(def_id, rbml_w);\n-        rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id_and_key(ecx, rbml_w, def_id);\n-        encode_family(rbml_w, 'n');\n-        encode_name(rbml_w, item.name);\n-\n-        // Encode all the items in this module.\n-        for foreign_item in &fm.items {\n-            rbml_w.wr_tagged_u64(tag_mod_child,\n-                                 def_to_u64(ecx.tcx.map.local_def_id(foreign_item.id)));\n-        }\n-        encode_visibility(rbml_w, vis);\n-        encode_stability(rbml_w, stab);\n-        encode_deprecation(rbml_w, depr);\n-        rbml_w.end_tag();\n-      }\n-      hir::ItemTy(..) => {\n-        let _task = index.record(def_id, rbml_w);\n-        rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id_and_key(ecx, rbml_w, def_id);\n-        encode_family(rbml_w, 'y');\n-        encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n-        encode_name(rbml_w, item.name);\n-        encode_visibility(rbml_w, vis);\n-        encode_stability(rbml_w, stab);\n-        encode_deprecation(rbml_w, depr);\n-        rbml_w.end_tag();\n-      }\n-      hir::ItemEnum(ref enum_definition, _) => {\n-        let _task = index.record(def_id, rbml_w);\n-\n-        rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id_and_key(ecx, rbml_w, def_id);\n-        encode_family(rbml_w, 't');\n-        encode_item_variances(rbml_w, ecx, item.id);\n-        encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n-        encode_name(rbml_w, item.name);\n-        encode_attributes(rbml_w, &item.attrs);\n-        encode_repr_attrs(rbml_w, ecx, &item.attrs);\n-        for v in &enum_definition.variants {\n-            encode_variant_id(rbml_w, ecx.tcx.map.local_def_id(v.node.data.id()));\n-        }\n-        encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(def_id, item));\n-        encode_mir(ecx, rbml_w, item.id);\n+        let (stab, depr) = tcx.dep_graph.with_task(DepNode::MetaData(def_id), || {\n+            (tcx.lookup_stability(ecx.tcx.map.local_def_id(item.id)),\n+             tcx.lookup_deprecation(ecx.tcx.map.local_def_id(item.id)))\n+        });\n \n-        // Encode inherent implementations for this enumeration.\n-        encode_inherent_implementations(ecx, rbml_w, def_id);\n+        match item.node {\n+            hir::ItemStatic(_, m, _) => {\n+                encode_def_id_and_key(ecx, self.rbml_w, def_id);\n+                if m == hir::MutMutable {\n+                    encode_family(self.rbml_w, 'b');\n+                } else {\n+                    encode_family(self.rbml_w, 'c');\n+                }\n+                self.encode_bounds_and_type_for_item(item.id);\n+                encode_name(self.rbml_w, item.name);\n+                self.encode_visibility(vis);\n+                encode_stability(self.rbml_w, stab);\n+                encode_deprecation(self.rbml_w, depr);\n+                encode_attributes(self.rbml_w, &item.attrs);\n+            }\n+            hir::ItemConst(_, _) => {\n+                encode_def_id_and_key(ecx, self.rbml_w, def_id);\n+                encode_family(self.rbml_w, 'C');\n+                self.encode_bounds_and_type_for_item(item.id);\n+                encode_name(self.rbml_w, item.name);\n+                encode_attributes(self.rbml_w, &item.attrs);\n+                encode_inlined_item(ecx, self.rbml_w, InlinedItemRef::Item(def_id, item));\n+                self.encode_mir(item.id);\n+                self.encode_visibility(vis);\n+                encode_stability(self.rbml_w, stab);\n+                encode_deprecation(self.rbml_w, depr);\n+            }\n+            hir::ItemFn(ref decl, _, constness, _, ref generics, _) => {\n+                encode_def_id_and_key(ecx, self.rbml_w, def_id);\n+                encode_family(self.rbml_w, FN_FAMILY);\n+                let tps_len = generics.ty_params.len();\n+                self.encode_bounds_and_type_for_item(item.id);\n+                encode_name(self.rbml_w, item.name);\n+                encode_attributes(self.rbml_w, &item.attrs);\n+                let needs_inline = tps_len > 0 || attr::requests_inline(&item.attrs);\n+                if needs_inline || constness == hir::Constness::Const {\n+                    encode_inlined_item(ecx, self.rbml_w, InlinedItemRef::Item(def_id, item));\n+                    self.encode_mir(item.id);\n+                }\n+                encode_constness(self.rbml_w, constness);\n+                self.encode_visibility(vis);\n+                encode_stability(self.rbml_w, stab);\n+                encode_deprecation(self.rbml_w, depr);\n+                self.encode_method_argument_names(&decl);\n+            }\n+            hir::ItemMod(ref m) => {\n+                self.encode_info_for_mod(FromId(item.id, (m, &item.attrs, item.name, &item.vis)));\n+            }\n+            hir::ItemForeignMod(ref fm) => {\n+                encode_def_id_and_key(ecx, self.rbml_w, def_id);\n+                encode_family(self.rbml_w, 'n');\n+                encode_name(self.rbml_w, item.name);\n+\n+                // Encode all the items in self module.\n+                for foreign_item in &fm.items {\n+                    self.rbml_w.wr_tagged_u64(\n+                        tag_mod_child,\n+                        def_to_u64(ecx.tcx.map.local_def_id(foreign_item.id)));\n+                }\n+                self.encode_visibility(vis);\n+                encode_stability(self.rbml_w, stab);\n+                encode_deprecation(self.rbml_w, depr);\n+            }\n+            hir::ItemTy(..) => {\n+                encode_def_id_and_key(ecx, self.rbml_w, def_id);\n+                encode_family(self.rbml_w, 'y');\n+                self.encode_bounds_and_type_for_item(item.id);\n+                encode_name(self.rbml_w, item.name);\n+                self.encode_visibility(vis);\n+                encode_stability(self.rbml_w, stab);\n+                encode_deprecation(self.rbml_w, depr);\n+            }\n+            hir::ItemEnum(ref enum_definition, _) => {\n+                encode_def_id_and_key(ecx, self.rbml_w, def_id);\n+                encode_family(self.rbml_w, 't');\n+                encode_item_variances(self.rbml_w, ecx, item.id);\n+                self.encode_bounds_and_type_for_item(item.id);\n+                encode_name(self.rbml_w, item.name);\n+                encode_attributes(self.rbml_w, &item.attrs);\n+                self.encode_repr_attrs(&item.attrs);\n+                for v in &enum_definition.variants {\n+                    encode_variant_id(self.rbml_w, ecx.tcx.map.local_def_id(v.node.data.id()));\n+                }\n+                encode_inlined_item(ecx, self.rbml_w, InlinedItemRef::Item(def_id, item));\n+                self.encode_mir(item.id);\n \n-        encode_visibility(rbml_w, vis);\n-        encode_stability(rbml_w, stab);\n-        encode_deprecation(rbml_w, depr);\n-        rbml_w.end_tag();\n+                // Encode inherent implementations for self enumeration.\n+                encode_inherent_implementations(ecx, self.rbml_w, def_id);\n \n-        encode_enum_variant_info(ecx,\n-                                 rbml_w,\n-                                 def_id,\n-                                 vis,\n-                                 index);\n-      }\n-      hir::ItemStruct(ref struct_def, _) => {\n-        /* Index the class*/\n-        let _task = index.record(def_id, rbml_w);\n+                self.encode_visibility(vis);\n+                encode_stability(self.rbml_w, stab);\n+                encode_deprecation(self.rbml_w, depr);\n+            }\n+            hir::ItemStruct(ref struct_def, _) => {\n+                /* Index the class*/\n+                let def = ecx.tcx.lookup_adt_def(def_id);\n+                let variant = def.struct_variant();\n+\n+                /* Now, make an item for the class itself */\n+                encode_def_id_and_key(ecx, self.rbml_w, def_id);\n+                encode_family(self.rbml_w, match *struct_def {\n+                    hir::VariantData::Struct(..) => 'S',\n+                    hir::VariantData::Tuple(..) => 's',\n+                    hir::VariantData::Unit(..) => 'u',\n+                });\n+                self.encode_bounds_and_type_for_item(item.id);\n+\n+                encode_item_variances(self.rbml_w, ecx, item.id);\n+                encode_name(self.rbml_w, item.name);\n+                encode_attributes(self.rbml_w, &item.attrs);\n+                encode_stability(self.rbml_w, stab);\n+                encode_deprecation(self.rbml_w, depr);\n+                self.encode_visibility(vis);\n+                self.encode_repr_attrs(&item.attrs);\n+\n+                /* Encode def_ids for each field and method\n+                for methods, write all the stuff get_trait_method\n+                needs to know*/\n+                self.encode_struct_fields(variant);\n+\n+                encode_inlined_item(ecx, self.rbml_w, InlinedItemRef::Item(def_id, item));\n+                self.encode_mir(item.id);\n+\n+                // Encode inherent implementations for self structure.\n+                encode_inherent_implementations(ecx, self.rbml_w, def_id);\n+\n+                if !struct_def.is_struct() {\n+                    let ctor_did = ecx.tcx.map.local_def_id(struct_def.id());\n+                    self.rbml_w.wr_tagged_u64(tag_items_data_item_struct_ctor,\n+                                              def_to_u64(ctor_did));\n+                }\n+            }\n+            hir::ItemDefaultImpl(unsafety, _) => {\n+                encode_def_id_and_key(ecx, self.rbml_w, def_id);\n+                encode_family(self.rbml_w, 'd');\n+                encode_name(self.rbml_w, item.name);\n+                encode_unsafety(self.rbml_w, unsafety);\n+\n+                let trait_ref = tcx.impl_trait_ref(ecx.tcx.map.local_def_id(item.id)).unwrap();\n+                encode_trait_ref(self.rbml_w, ecx, trait_ref, tag_item_trait_ref);\n+            }\n+            hir::ItemImpl(unsafety, polarity, _, _, _, _) => {\n+                // We need to encode information about the default methods we\n+                // have inherited, so we drive self based on the impl structure.\n+                let impl_items = tcx.impl_items.borrow();\n+                let items = &impl_items[&def_id];\n+\n+                encode_def_id_and_key(ecx, self.rbml_w, def_id);\n+                encode_family(self.rbml_w, 'i');\n+                self.encode_bounds_and_type_for_item(item.id);\n+                encode_name(self.rbml_w, item.name);\n+                encode_attributes(self.rbml_w, &item.attrs);\n+                encode_unsafety(self.rbml_w, unsafety);\n+                encode_polarity(self.rbml_w, polarity);\n+\n+                match\n+                    tcx.custom_coerce_unsized_kinds\n+                       .borrow()\n+                       .get(&ecx.tcx.map.local_def_id(item.id))\n+                {\n+                    Some(&kind) => {\n+                        self.rbml_w.start_tag(tag_impl_coerce_unsized_kind);\n+                        kind.encode(self.rbml_w);\n+                        self.rbml_w.end_tag();\n+                    }\n+                    None => {}\n+                }\n \n-        let def = ecx.tcx.lookup_adt_def(def_id);\n-        let variant = def.struct_variant();\n+                for &item_def_id in items {\n+                    self.rbml_w.start_tag(tag_item_impl_item);\n+                    match item_def_id {\n+                        ty::ConstTraitItemId(item_def_id) => {\n+                            encode_def_id(self.rbml_w, item_def_id);\n+                            encode_item_sort(self.rbml_w, 'C');\n+                        }\n+                        ty::MethodTraitItemId(item_def_id) => {\n+                            encode_def_id(self.rbml_w, item_def_id);\n+                            encode_item_sort(self.rbml_w, 'r');\n+                        }\n+                        ty::TypeTraitItemId(item_def_id) => {\n+                            encode_def_id(self.rbml_w, item_def_id);\n+                            encode_item_sort(self.rbml_w, 't');\n+                        }\n+                    }\n+                    self.rbml_w.end_tag();\n+                }\n \n-        /* Now, make an item for the class itself */\n-        rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id_and_key(ecx, rbml_w, def_id);\n-        encode_family(rbml_w, match *struct_def {\n-            hir::VariantData::Struct(..) => 'S',\n-            hir::VariantData::Tuple(..) => 's',\n-            hir::VariantData::Unit(..) => 'u',\n-        });\n-        encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n-\n-        encode_item_variances(rbml_w, ecx, item.id);\n-        encode_name(rbml_w, item.name);\n-        encode_attributes(rbml_w, &item.attrs);\n-        encode_stability(rbml_w, stab);\n-        encode_deprecation(rbml_w, depr);\n-        encode_visibility(rbml_w, vis);\n-        encode_repr_attrs(rbml_w, ecx, &item.attrs);\n-\n-        /* Encode def_ids for each field and method\n-         for methods, write all the stuff get_trait_method\n-        needs to know*/\n-        encode_struct_fields(rbml_w, variant);\n-\n-        encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(def_id, item));\n-        encode_mir(ecx, rbml_w, item.id);\n-\n-        // Encode inherent implementations for this structure.\n-        encode_inherent_implementations(ecx, rbml_w, def_id);\n-\n-        if !struct_def.is_struct() {\n-            let ctor_did = ecx.tcx.map.local_def_id(struct_def.id());\n-            rbml_w.wr_tagged_u64(tag_items_data_item_struct_ctor,\n-                                 def_to_u64(ctor_did));\n-        }\n+                let did = ecx.tcx.map.local_def_id(item.id);\n+                if let Some(trait_ref) = tcx.impl_trait_ref(did) {\n+                    encode_trait_ref(self.rbml_w, ecx, trait_ref, tag_item_trait_ref);\n+\n+                    let trait_def = tcx.lookup_trait_def(trait_ref.def_id);\n+                    let parent = trait_def.ancestors(did)\n+                                          .skip(1)\n+                                          .next()\n+                                          .and_then(|node| match node {\n+                                              specialization_graph::Node::Impl(parent) =>\n+                                                  Some(parent),\n+                                              _ => None,\n+                                          });\n+                    encode_parent_impl(self.rbml_w, parent);\n+                }\n+                encode_stability(self.rbml_w, stab);\n+                encode_deprecation(self.rbml_w, depr);\n+            }\n+            hir::ItemTrait(_, _, _, _) => {\n+                encode_def_id_and_key(ecx, self.rbml_w, def_id);\n+                encode_family(self.rbml_w, 'I');\n+                encode_item_variances(self.rbml_w, ecx, item.id);\n+                let trait_def = tcx.lookup_trait_def(def_id);\n+                let trait_predicates = tcx.lookup_predicates(def_id);\n+                encode_unsafety(self.rbml_w, trait_def.unsafety);\n+                encode_paren_sugar(self.rbml_w, trait_def.paren_sugar);\n+                encode_defaulted(self.rbml_w, tcx.trait_has_default_impl(def_id));\n+                encode_associated_type_names(self.rbml_w, &trait_def.associated_type_names);\n+                self.encode_generics(&trait_def.generics, &trait_predicates);\n+                self.encode_predicates(&tcx.lookup_super_predicates(def_id),\n+                                       tag_item_super_predicates);\n+                encode_trait_ref(self.rbml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n+                encode_name(self.rbml_w, item.name);\n+                encode_attributes(self.rbml_w, &item.attrs);\n+                self.encode_visibility(vis);\n+                encode_stability(self.rbml_w, stab);\n+                encode_deprecation(self.rbml_w, depr);\n+                for &method_def_id in tcx.trait_item_def_ids(def_id).iter() {\n+                    self.rbml_w.start_tag(tag_item_trait_item);\n+                    match method_def_id {\n+                        ty::ConstTraitItemId(const_def_id) => {\n+                            encode_def_id(self.rbml_w, const_def_id);\n+                            encode_item_sort(self.rbml_w, 'C');\n+                        }\n+                        ty::MethodTraitItemId(method_def_id) => {\n+                            encode_def_id(self.rbml_w, method_def_id);\n+                            encode_item_sort(self.rbml_w, 'r');\n+                        }\n+                        ty::TypeTraitItemId(type_def_id) => {\n+                            encode_def_id(self.rbml_w, type_def_id);\n+                            encode_item_sort(self.rbml_w, 't');\n+                        }\n+                    }\n+                    self.rbml_w.end_tag();\n \n-        rbml_w.end_tag();\n+                    self.rbml_w.wr_tagged_u64(tag_mod_child,\n+                                              def_to_u64(method_def_id.def_id()));\n+                }\n \n-        for field in &variant.fields {\n-            encode_field(ecx, rbml_w, field, index);\n+                // Encode inherent implementations for self trait.\n+                encode_inherent_implementations(ecx, self.rbml_w, def_id);\n+            }\n+            hir::ItemExternCrate(_) | hir::ItemUse(_) => {\n+                bug!(\"cannot encode info for item {:?}\", item)\n+            }\n         }\n+    }\n+}\n \n-        // If this is a tuple-like struct, encode the type of the constructor.\n-        if !struct_def.is_struct() {\n-            encode_info_for_struct_ctor(ecx, rbml_w, item.name, struct_def, index, item.id);\n-        }\n-      }\n-      hir::ItemDefaultImpl(unsafety, _) => {\n-          let _task = index.record(def_id, rbml_w);\n-          rbml_w.start_tag(tag_items_data_item);\n-          encode_def_id_and_key(ecx, rbml_w, def_id);\n-          encode_family(rbml_w, 'd');\n-          encode_name(rbml_w, item.name);\n-          encode_unsafety(rbml_w, unsafety);\n-\n-          let trait_ref = tcx.impl_trait_ref(ecx.tcx.map.local_def_id(item.id)).unwrap();\n-          encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n-          rbml_w.end_tag();\n-      }\n-      hir::ItemImpl(unsafety, polarity, _, _, _, ref ast_items) => {\n-        let _task = index.record(def_id, rbml_w);\n-\n-        // We need to encode information about the default methods we\n-        // have inherited, so we drive this based on the impl structure.\n-        let impl_items = tcx.impl_items.borrow();\n-        let items = impl_items.get(&def_id).unwrap();\n-\n-        rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id_and_key(ecx, rbml_w, def_id);\n-        encode_family(rbml_w, 'i');\n-        encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n-        encode_name(rbml_w, item.name);\n-        encode_attributes(rbml_w, &item.attrs);\n-        encode_unsafety(rbml_w, unsafety);\n-        encode_polarity(rbml_w, polarity);\n-\n-        match tcx.custom_coerce_unsized_kinds.borrow().get(&ecx.tcx.map.local_def_id(item.id)) {\n-            Some(&kind) => {\n-                rbml_w.start_tag(tag_impl_coerce_unsized_kind);\n-                kind.encode(rbml_w);\n-                rbml_w.end_tag();\n+impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n+    /// In some cases, along with the item itself, we also\n+    /// encode some sub-items. Usually we want some info from the item\n+    /// so it's easier to do that here then to wait until we would encounter\n+    /// normally in the visitor walk.\n+    fn encode_addl_info_for_item(&mut self,\n+                                 item: &hir::Item) {\n+        let def_id = self.ecx().tcx.map.local_def_id(item.id);\n+        match item.node {\n+            hir::ItemStatic(..) |\n+            hir::ItemConst(..) |\n+            hir::ItemFn(..) |\n+            hir::ItemMod(..) |\n+            hir::ItemForeignMod(..) |\n+            hir::ItemExternCrate(..) |\n+            hir::ItemUse(..) |\n+            hir::ItemDefaultImpl(..) |\n+            hir::ItemTy(..) => {\n+                // no sub-item recording needed in these cases\n+            }\n+            hir::ItemEnum(..) => {\n+                self.encode_enum_variant_infos(def_id);\n+            }\n+            hir::ItemStruct(ref struct_def, _) => {\n+                self.encode_addl_struct_info(def_id, struct_def.id(), item);\n+            }\n+            hir::ItemImpl(_, _, _, _, _, ref ast_items) => {\n+                self.encode_addl_impl_info(def_id, item.id, ast_items);\n+            }\n+            hir::ItemTrait(_, _, _, ref trait_items) => {\n+                self.encode_addl_trait_info(def_id, trait_items);\n             }\n-            None => {}\n         }\n+    }\n \n-        for &item_def_id in items {\n-            rbml_w.start_tag(tag_item_impl_item);\n-            match item_def_id {\n-                ty::ConstTraitItemId(item_def_id) => {\n-                    encode_def_id(rbml_w, item_def_id);\n-                    encode_item_sort(rbml_w, 'C');\n-                }\n-                ty::MethodTraitItemId(item_def_id) => {\n-                    encode_def_id(rbml_w, item_def_id);\n-                    encode_item_sort(rbml_w, 'r');\n-                }\n-                ty::TypeTraitItemId(item_def_id) => {\n-                    encode_def_id(rbml_w, item_def_id);\n-                    encode_item_sort(rbml_w, 't');\n-                }\n+    fn encode_addl_struct_info(&mut self,\n+                               def_id: DefId,\n+                               struct_node_id: ast::NodeId,\n+                               item: &hir::Item) {\n+        let ecx = self.ecx();\n+        let def = ecx.tcx.lookup_adt_def(def_id);\n+        let variant = def.struct_variant();\n+\n+        self.encode_fields(def_id);\n+\n+        // If this is a tuple-like struct, encode the type of the constructor.\n+        match variant.kind {\n+            ty::VariantKind::Struct => {\n+                // no value for structs like struct Foo { ... }\n+            }\n+            ty::VariantKind::Tuple | ty::VariantKind::Unit => {\n+                // there is a value for structs like `struct\n+                // Foo()` and `struct Foo`\n+                let ctor_def_id = ecx.tcx.map.local_def_id(struct_node_id);\n+                self.record(ctor_def_id,\n+                            ItemContentBuilder::encode_struct_ctor,\n+                            (def_id, item.id, struct_node_id));\n             }\n-            rbml_w.end_tag();\n-        }\n-        let did = ecx.tcx.map.local_def_id(item.id);\n-        if let Some(trait_ref) = tcx.impl_trait_ref(did) {\n-            encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n-\n-            let trait_def = tcx.lookup_trait_def(trait_ref.def_id);\n-            let parent = trait_def.ancestors(did)\n-                .skip(1)\n-                .next()\n-                .and_then(|node| match node {\n-                    specialization_graph::Node::Impl(parent) => Some(parent),\n-                    _ => None,\n-                });\n-            encode_parent_impl(rbml_w, parent);\n         }\n-        encode_stability(rbml_w, stab);\n-        encode_deprecation(rbml_w, depr);\n-        rbml_w.end_tag();\n+    }\n+\n+    fn encode_addl_impl_info(&mut self,\n+                             def_id: DefId,\n+                             impl_id: ast::NodeId,\n+                             ast_items: &[hir::ImplItem]) {\n+        let ecx = self.ecx();\n+        let impl_items = ecx.tcx.impl_items.borrow();\n+        let items = &impl_items[&def_id];\n \n         // Iterate down the trait items, emitting them. We rely on the\n         // assumption that all of the actually implemented trait items\n@@ -1069,343 +1236,188 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                 None\n             };\n \n-            match tcx.impl_or_trait_item(trait_item_def_id.def_id()) {\n-                ty::ConstTraitItem(ref associated_const) => {\n-                    encode_info_for_associated_const(ecx,\n-                                                     rbml_w,\n-                                                     index,\n-                                                     &associated_const,\n-                                                     item.id,\n-                                                     ast_item)\n-                }\n-                ty::MethodTraitItem(ref method_type) => {\n-                    encode_info_for_method(ecx,\n-                                           rbml_w,\n-                                           index,\n-                                           &method_type,\n-                                           false,\n-                                           item.id,\n-                                           ast_item)\n-                }\n-                ty::TypeTraitItem(ref associated_type) => {\n-                    encode_info_for_associated_type(ecx,\n-                                                    rbml_w,\n-                                                    index,\n-                                                    &associated_type,\n-                                                    item.id,\n-                                                    ast_item)\n-                }\n-            }\n+            let trait_item_def_id = trait_item_def_id.def_id();\n+            self.record(trait_item_def_id,\n+                        ItemContentBuilder::encode_info_for_impl_item,\n+                        (impl_id, trait_item_def_id, ast_item));\n         }\n-      }\n-      hir::ItemTrait(_, _, _, ref ms) => {\n-        let _task = index.record(def_id, rbml_w);\n-        rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id_and_key(ecx, rbml_w, def_id);\n-        encode_family(rbml_w, 'I');\n-        encode_item_variances(rbml_w, ecx, item.id);\n-        let trait_def = tcx.lookup_trait_def(def_id);\n-        let trait_predicates = tcx.lookup_predicates(def_id);\n-        encode_unsafety(rbml_w, trait_def.unsafety);\n-        encode_paren_sugar(rbml_w, trait_def.paren_sugar);\n-        encode_defaulted(rbml_w, tcx.trait_has_default_impl(def_id));\n-        encode_associated_type_names(rbml_w, &trait_def.associated_type_names);\n-        encode_generics(rbml_w, ecx, index,\n-                        &trait_def.generics, &trait_predicates);\n-        encode_predicates(rbml_w, index,\n-                          &tcx.lookup_super_predicates(def_id),\n-                          tag_item_super_predicates);\n-        encode_trait_ref(rbml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n-        encode_name(rbml_w, item.name);\n-        encode_attributes(rbml_w, &item.attrs);\n-        encode_visibility(rbml_w, vis);\n-        encode_stability(rbml_w, stab);\n-        encode_deprecation(rbml_w, depr);\n-        for &method_def_id in tcx.trait_item_def_ids(def_id).iter() {\n-            rbml_w.start_tag(tag_item_trait_item);\n-            match method_def_id {\n-                ty::ConstTraitItemId(const_def_id) => {\n-                    encode_def_id(rbml_w, const_def_id);\n-                    encode_item_sort(rbml_w, 'C');\n-                }\n-                ty::MethodTraitItemId(method_def_id) => {\n-                    encode_def_id(rbml_w, method_def_id);\n-                    encode_item_sort(rbml_w, 'r');\n-                }\n-                ty::TypeTraitItemId(type_def_id) => {\n-                    encode_def_id(rbml_w, type_def_id);\n-                    encode_item_sort(rbml_w, 't');\n-                }\n-            }\n-            rbml_w.end_tag();\n-\n-            rbml_w.wr_tagged_u64(tag_mod_child,\n-                                 def_to_u64(method_def_id.def_id()));\n-        }\n-\n-        // Encode inherent implementations for this trait.\n-        encode_inherent_implementations(ecx, rbml_w, def_id);\n-\n-        rbml_w.end_tag();\n+    }\n \n+    fn encode_addl_trait_info(&mut self,\n+                              def_id: DefId,\n+                              trait_items: &[hir::TraitItem]) {\n         // Now output the trait item info for each trait item.\n+        let tcx = self.ecx().tcx;\n         let r = tcx.trait_item_def_ids(def_id);\n-        for (i, &item_def_id) in r.iter().enumerate() {\n-            assert_eq!(item_def_id.def_id().krate, LOCAL_CRATE);\n-\n-            let _task = index.record(item_def_id.def_id(), rbml_w);\n-            rbml_w.start_tag(tag_items_data_item);\n-\n-            encode_parent_item(rbml_w, def_id);\n-\n-            let stab = tcx.lookup_stability(item_def_id.def_id());\n-            let depr = tcx.lookup_deprecation(item_def_id.def_id());\n-            encode_stability(rbml_w, stab);\n-            encode_deprecation(rbml_w, depr);\n-\n-            let trait_item_type =\n-                tcx.impl_or_trait_item(item_def_id.def_id());\n-            let is_nonstatic_method;\n-            match trait_item_type {\n-                ty::ConstTraitItem(associated_const) => {\n-                    encode_name(rbml_w, associated_const.name);\n-                    encode_def_id_and_key(ecx, rbml_w, associated_const.def_id);\n-                    encode_visibility(rbml_w, associated_const.vis);\n-\n-                    encode_family(rbml_w, 'C');\n-\n-                    encode_bounds_and_type_for_item(rbml_w, ecx, index,\n-                                                    ecx.local_id(associated_const.def_id));\n-\n-                    is_nonstatic_method = false;\n-                }\n-                ty::MethodTraitItem(method_ty) => {\n-                    let method_def_id = item_def_id.def_id();\n-\n-                    encode_method_ty_fields(ecx, rbml_w, index, &method_ty);\n-\n-                    match method_ty.explicit_self {\n-                        ty::ExplicitSelfCategory::Static => {\n-                            encode_family(rbml_w,\n-                                          STATIC_METHOD_FAMILY);\n-                        }\n-                        _ => {\n-                            encode_family(rbml_w,\n-                                          METHOD_FAMILY);\n-                        }\n-                    }\n-                    encode_bounds_and_type_for_item(rbml_w, ecx, index,\n-                                                    ecx.local_id(method_def_id));\n-\n-                    is_nonstatic_method = method_ty.explicit_self !=\n-                        ty::ExplicitSelfCategory::Static;\n-                }\n-                ty::TypeTraitItem(associated_type) => {\n-                    encode_name(rbml_w, associated_type.name);\n-                    encode_def_id_and_key(ecx, rbml_w, associated_type.def_id);\n-                    encode_item_sort(rbml_w, 't');\n-                    encode_family(rbml_w, 'y');\n-\n-                    if let Some(ty) = associated_type.ty {\n-                        encode_type(ecx, rbml_w, ty);\n-                    }\n+        for (item_def_id, trait_item) in r.iter().zip(trait_items) {\n+            let item_def_id = item_def_id.def_id();\n+            assert!(item_def_id.is_local());\n+            self.record(item_def_id,\n+                        ItemContentBuilder::encode_info_for_trait_item,\n+                        (def_id, item_def_id, trait_item));\n+        }\n+    }\n+}\n \n-                    is_nonstatic_method = false;\n+impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n+    fn encode_info_for_foreign_item(&mut self,\n+                                    (def_id, nitem): (DefId, &hir::ForeignItem)) {\n+        let ecx = self.ecx();\n+\n+        debug!(\"writing foreign item {}\", ecx.tcx.node_path_str(nitem.id));\n+        let abi = ecx.tcx.map.get_foreign_abi(nitem.id);\n+\n+        encode_def_id_and_key(ecx, self.rbml_w, def_id);\n+        let parent_id = ecx.tcx.map.get_parent(nitem.id);\n+        self.encode_parent_item(ecx.tcx.map.local_def_id(parent_id));\n+        self.encode_visibility(&nitem.vis);\n+        match nitem.node {\n+            hir::ForeignItemFn(ref fndecl, _) => {\n+                encode_family(self.rbml_w, FN_FAMILY);\n+                self.encode_bounds_and_type_for_item(nitem.id);\n+                encode_name(self.rbml_w, nitem.name);\n+                if abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n+                    encode_inlined_item(ecx,\n+                                        self.rbml_w,\n+                                        InlinedItemRef::Foreign(def_id, nitem));\n+                    self.encode_mir(nitem.id);\n                 }\n+                encode_attributes(self.rbml_w, &nitem.attrs);\n+                let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(nitem.id));\n+                let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(nitem.id));\n+                encode_stability(self.rbml_w, stab);\n+                encode_deprecation(self.rbml_w, depr);\n+                self.encode_method_argument_names(&fndecl);\n             }\n-\n-            let trait_item = &ms[i];\n-            encode_attributes(rbml_w, &trait_item.attrs);\n-            match trait_item.node {\n-                hir::ConstTraitItem(_, ref default) => {\n-                    if default.is_some() {\n-                        encode_item_sort(rbml_w, 'C');\n-                    } else {\n-                        encode_item_sort(rbml_w, 'c');\n-                    }\n-\n-                    encode_inlined_item(ecx, rbml_w,\n-                                        InlinedItemRef::TraitItem(def_id, trait_item));\n-                    encode_mir(ecx, rbml_w, trait_item.id);\n+            hir::ForeignItemStatic(_, mutbl) => {\n+                if mutbl {\n+                    encode_family(self.rbml_w, 'b');\n+                } else {\n+                    encode_family(self.rbml_w, 'c');\n                 }\n-                hir::MethodTraitItem(ref sig, ref body) => {\n-                    // If this is a static method, we've already\n-                    // encoded this.\n-                    if is_nonstatic_method {\n-                        // FIXME: I feel like there is something funny\n-                        // going on.\n-                        encode_bounds_and_type_for_item(rbml_w, ecx, index,\n-                                                        ecx.local_id(item_def_id.def_id()));\n-                    }\n-\n-                    if body.is_some() {\n-                        encode_item_sort(rbml_w, 'p');\n-                        encode_inlined_item(ecx, rbml_w,\n-                                            InlinedItemRef::TraitItem(def_id, trait_item));\n-                        encode_mir(ecx, rbml_w, trait_item.id);\n-                    } else {\n-                        encode_item_sort(rbml_w, 'r');\n-                    }\n-                    encode_method_argument_names(rbml_w, &sig.decl);\n-                }\n-\n-                hir::TypeTraitItem(..) => {}\n+                self.encode_bounds_and_type_for_item(nitem.id);\n+                encode_attributes(self.rbml_w, &nitem.attrs);\n+                let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(nitem.id));\n+                let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(nitem.id));\n+                encode_stability(self.rbml_w, stab);\n+                encode_deprecation(self.rbml_w, depr);\n+                encode_name(self.rbml_w, nitem.name);\n             }\n-\n-            rbml_w.end_tag();\n         }\n-      }\n-      hir::ItemExternCrate(_) | hir::ItemUse(_) => {\n-        // these are encoded separately\n-      }\n-    }\n-}\n-\n-fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n-                                          rbml_w: &mut Encoder,\n-                                          nitem: &hir::ForeignItem,\n-                                          index: &mut CrateIndex<'a, 'tcx>) {\n-    debug!(\"writing foreign item {}\", ecx.tcx.node_path_str(nitem.id));\n-    let def_id = ecx.tcx.map.local_def_id(nitem.id);\n-    let abi = ecx.tcx.map.get_foreign_abi(nitem.id);\n-\n-    let _task = index.record(def_id, rbml_w);\n-    rbml_w.start_tag(tag_items_data_item);\n-    encode_def_id_and_key(ecx, rbml_w, def_id);\n-    let parent_id = ecx.tcx.map.get_parent(nitem.id);\n-    encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n-    encode_visibility(rbml_w, &nitem.vis);\n-    match nitem.node {\n-      hir::ForeignItemFn(ref fndecl, _) => {\n-        encode_family(rbml_w, FN_FAMILY);\n-        encode_bounds_and_type_for_item(rbml_w, ecx, index, nitem.id);\n-        encode_name(rbml_w, nitem.name);\n-        if abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n-            encode_inlined_item(ecx, rbml_w, InlinedItemRef::Foreign(def_id, nitem));\n-            encode_mir(ecx, rbml_w, nitem.id);\n-        }\n-        encode_attributes(rbml_w, &nitem.attrs);\n-        let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(nitem.id));\n-        let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(nitem.id));\n-        encode_stability(rbml_w, stab);\n-        encode_deprecation(rbml_w, depr);\n-        encode_method_argument_names(rbml_w, &fndecl);\n-      }\n-      hir::ForeignItemStatic(_, mutbl) => {\n-        if mutbl {\n-            encode_family(rbml_w, 'b');\n-        } else {\n-            encode_family(rbml_w, 'c');\n-        }\n-        encode_bounds_and_type_for_item(rbml_w, ecx, index, nitem.id);\n-        encode_attributes(rbml_w, &nitem.attrs);\n-        let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(nitem.id));\n-        let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(nitem.id));\n-        encode_stability(rbml_w, stab);\n-        encode_deprecation(rbml_w, depr);\n-        encode_name(rbml_w, nitem.name);\n-      }\n-    }\n-    rbml_w.end_tag();\n-}\n-\n-fn my_visit_expr(expr: &hir::Expr,\n-                 rbml_w: &mut Encoder,\n-                 ecx: &EncodeContext,\n-                 index: &mut CrateIndex) {\n-    match expr.node {\n-        hir::ExprClosure(..) => {\n-            let def_id = ecx.tcx.map.local_def_id(expr.id);\n-\n-            let _task = index.record(def_id, rbml_w);\n-\n-            rbml_w.start_tag(tag_items_data_item);\n-            encode_def_id_and_key(ecx, rbml_w, def_id);\n-            encode_name(rbml_w, syntax::parse::token::intern(\"<closure>\"));\n-\n-            rbml_w.start_tag(tag_items_closure_ty);\n-            write_closure_type(ecx, rbml_w, &ecx.tcx.tables.borrow().closure_tys[&def_id]);\n-            rbml_w.end_tag();\n-\n-            rbml_w.start_tag(tag_items_closure_kind);\n-            ecx.tcx.closure_kind(def_id).encode(rbml_w).unwrap();\n-            rbml_w.end_tag();\n-\n-            assert!(ecx.mir_map.map.contains_key(&def_id));\n-            encode_mir(ecx, rbml_w, expr.id);\n-\n-            rbml_w.end_tag();\n-        }\n-        _ => { }\n     }\n }\n \n-struct EncodeVisitor<'a, 'b:'a, 'c:'a, 'tcx:'c> {\n-    rbml_w_for_visit_item: &'a mut Encoder<'b>,\n-    ecx: &'a EncodeContext<'c, 'tcx>,\n-    index: &'a mut CrateIndex<'c, 'tcx>,\n+struct EncodeVisitor<'a, 'ecx: 'a, 'tcx: 'ecx, 'encoder: 'ecx> {\n+    index: &'a mut IndexBuilder<'ecx, 'tcx, 'encoder>,\n }\n \n-impl<'a, 'b, 'c, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'c, 'tcx> {\n+impl<'a, 'ecx, 'tcx, 'encoder> Visitor<'tcx> for EncodeVisitor<'a, 'ecx, 'tcx, 'encoder> {\n     fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n         intravisit::walk_expr(self, ex);\n-        my_visit_expr(ex, self.rbml_w_for_visit_item, self.ecx, self.index);\n+        self.index.encode_info_for_expr(ex);\n     }\n-    fn visit_item(&mut self, i: &'tcx hir::Item) {\n-        intravisit::walk_item(self, i);\n-        encode_info_for_item(self.ecx, self.rbml_w_for_visit_item, i, self.index);\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+        intravisit::walk_item(self, item);\n+        let def_id = self.index.ecx().tcx.map.local_def_id(item.id);\n+        match item.node {\n+            hir::ItemExternCrate(_) | hir::ItemUse(_) => (), // ignore these\n+            _ => self.index.record(def_id,\n+                                   ItemContentBuilder::encode_info_for_item,\n+                                   (def_id, item)),\n+        }\n+        self.index.encode_addl_info_for_item(item);\n     }\n     fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem) {\n         intravisit::walk_foreign_item(self, ni);\n-        encode_info_for_foreign_item(self.ecx, self.rbml_w_for_visit_item, ni, self.index);\n+        let def_id = self.index.ecx().tcx.map.local_def_id(ni.id);\n+        self.index.record(def_id,\n+                          ItemContentBuilder::encode_info_for_foreign_item,\n+                          (def_id, ni));\n     }\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         intravisit::walk_ty(self, ty);\n+        self.index.encode_info_for_ty(ty);\n+    }\n+}\n \n+impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n+    fn encode_info_for_ty(&mut self, ty: &hir::Ty) {\n+        let ecx = self.ecx();\n         if let hir::TyImplTrait(_) = ty.node {\n-            let rbml_w = &mut *self.rbml_w_for_visit_item;\n-            let def_id = self.ecx.tcx.map.local_def_id(ty.id);\n-            let _task = self.index.record(def_id, rbml_w);\n-            rbml_w.start_tag(tag_items_data_item);\n-            encode_def_id_and_key(self.ecx, rbml_w, def_id);\n-            encode_family(rbml_w, 'y');\n-            encode_bounds_and_type_for_item(rbml_w, self.ecx, self.index, ty.id);\n-            rbml_w.end_tag();\n+            let def_id = ecx.tcx.map.local_def_id(ty.id);\n+            self.record(def_id,\n+                        ItemContentBuilder::encode_info_for_anon_ty,\n+                        (def_id, ty.id));\n+        }\n+    }\n+\n+    fn encode_info_for_expr(&mut self, expr: &hir::Expr) {\n+        let ecx = self.ecx();\n+\n+        match expr.node {\n+            hir::ExprClosure(..) => {\n+                let def_id = ecx.tcx.map.local_def_id(expr.id);\n+                self.record(def_id,\n+                            ItemContentBuilder::encode_info_for_closure,\n+                            (def_id, expr.id));\n+            }\n+            _ => { }\n         }\n     }\n }\n \n+impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n+    fn encode_info_for_anon_ty(&mut self, (def_id, ty_id): (DefId, NodeId)) {\n+        let ecx = self.ecx;\n+        encode_def_id_and_key(ecx, self.rbml_w, def_id);\n+        encode_family(self.rbml_w, 'y');\n+        self.encode_bounds_and_type_for_item(ty_id);\n+    }\n+\n+    fn encode_info_for_closure(&mut self, (def_id, expr_id): (DefId, NodeId)) {\n+        let ecx = self.ecx;\n+        encode_def_id_and_key(ecx, self.rbml_w, def_id);\n+        encode_name(self.rbml_w, syntax::parse::token::intern(\"<closure>\"));\n+\n+        self.rbml_w.start_tag(tag_items_closure_ty);\n+        write_closure_type(ecx,\n+                           self.rbml_w,\n+                           &ecx.tcx.tables.borrow().closure_tys[&def_id]);\n+        self.rbml_w.end_tag();\n+\n+        self.rbml_w.start_tag(tag_items_closure_kind);\n+        ecx.tcx.closure_kind(def_id).encode(self.rbml_w).unwrap();\n+        self.rbml_w.end_tag();\n+\n+        assert!(ecx.mir_map.map.contains_key(&def_id));\n+        self.encode_mir(expr_id);\n+    }\n+}\n+\n fn encode_info_for_items<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                    rbml_w: &mut Encoder)\n-                                   -> CrateIndex<'a, 'tcx> {\n+                                   -> (IndexData, FnvHashMap<XRef<'tcx>, u32>) {\n     let krate = ecx.tcx.map.krate();\n \n-    let mut index = CrateIndex {\n-        dep_graph: &ecx.tcx.dep_graph,\n-        items: IndexData::new(ecx.tcx.map.num_local_def_ids()),\n-        xrefs: FnvHashMap()\n-    };\n     rbml_w.start_tag(tag_items_data);\n \n-    {\n-        let _task = index.record(DefId::local(CRATE_DEF_INDEX), rbml_w);\n-        encode_info_for_mod(ecx,\n-                            rbml_w,\n-                            &krate.module,\n-                            &[],\n-                            CRATE_NODE_ID,\n-                            syntax::parse::token::intern(&ecx.link_meta.crate_name),\n-                            &hir::Public);\n-    }\n-\n-    krate.visit_all_items(&mut EncodeVisitor {\n-        index: &mut index,\n-        ecx: ecx,\n-        rbml_w_for_visit_item: &mut *rbml_w,\n-    });\n+    let fields = {\n+        let mut index = IndexBuilder::new(ecx, rbml_w);\n+        index.record(DefId::local(CRATE_DEF_INDEX),\n+                     ItemContentBuilder::encode_info_for_mod,\n+                     FromId(CRATE_NODE_ID, (&krate.module,\n+                                            &[],\n+                                            syntax::parse::token::intern(&ecx.link_meta.crate_name),\n+                                            &hir::Public)));\n+        krate.visit_all_items(&mut EncodeVisitor {\n+            index: &mut index,\n+        });\n+        index.into_fields()\n+    };\n \n     rbml_w.end_tag();\n-    index\n+\n+    fields\n }\n \n fn encode_item_index(rbml_w: &mut Encoder, index: IndexData) {\n@@ -1925,16 +1937,16 @@ fn encode_metadata_inner(rbml_w: &mut Encoder,\n     // Encode and index the items.\n     rbml_w.start_tag(tag_items);\n     i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    let index = encode_info_for_items(&ecx, rbml_w);\n+    let (items, xrefs) = encode_info_for_items(&ecx, rbml_w);\n     stats.item_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n     rbml_w.end_tag();\n \n     i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    encode_item_index(rbml_w, index.items);\n+    encode_item_index(rbml_w, items);\n     stats.index_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n     i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    encode_xrefs(&ecx, rbml_w, index.xrefs);\n+    encode_xrefs(&ecx, rbml_w, xrefs);\n     stats.xref_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n     encode_struct_field_attrs(&ecx, rbml_w, krate);"}, {"sha": "1d3d09d6bc2d798871df777ef59f349240e7833f", "filename": "src/librustc_metadata/index_builder.rs", "status": "added", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/499484f56d336f4628a6fa016626beb3ef21ba81/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/499484f56d336f4628a6fa016626beb3ef21ba81/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=499484f56d336f4628a6fa016626beb3ef21ba81", "patch": "@@ -0,0 +1,253 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Builder types for generating the \"item data\" section of the\n+//! metadata. This section winds up looking like this:\n+//!\n+//! ```\n+//! <common::data> // big list of item-like things...\n+//!    <common::data_item> // ...for most def-ids, there is an entry.\n+//!    </common::data_item>\n+//! </common::data>\n+//! ```\n+//!\n+//! As we generate this listing, we collect the offset of each\n+//! `data_item` entry and store it in an index. Then, when we load the\n+//! metadata, we can skip right to the metadata for a particular item.\n+//!\n+//! In addition to the offset, we need to track the data that was used\n+//! to generate the contents of each `data_item`. This is so that we\n+//! can figure out which HIR nodes contributed to that data for\n+//! incremental compilation purposes.\n+//!\n+//! The `IndexBuilder` facilitates both of these. It is created\n+//! with an RBML encoder isntance (`rbml_w`) along with an\n+//! `EncodingContext` (`ecx`), which it encapsulates. It has one main\n+//! method, `record()`. You invoke `record` like so to create a new\n+//! `data_item` element in the list:\n+//!\n+//! ```\n+//! index.record(some_def_id, callback_fn, data)\n+//! ```\n+//!\n+//! What record will do is to (a) record the current offset, (b) emit\n+//! the `common::data_item` tag, and then call `callback_fn` with the\n+//! given data as well as an `ItemContentBuilder`. Once `callback_fn`\n+//! returns, the `common::data_item` tag will be closed.\n+//!\n+//! The `ItemContentBuilder` is another type that just offers access\n+//! to the `ecx` and `rbml_w` that were given in, as well as\n+//! maintaining a list of `xref` instances, which are used to extract\n+//! common data so it is not re-serialized.\n+//!\n+//! `ItemContentBuilder` is a distinct type which does not offer the\n+//! `record` method, so that we can ensure that `common::data_item` elements\n+//! are never nested.\n+//!\n+//! In addition, while the `callback_fn` is executing, we will push a\n+//! task `MetaData(some_def_id)`, which can then observe the\n+//! reads/writes that occur in the task. For this reason, the `data`\n+//! argument that is given to the `callback_fn` must implement the\n+//! trait `DepGraphRead`, which indicates how to register reads on the\n+//! data in this new task (note that many types of data, such as\n+//! `DefId`, do not currently require any reads to be registered,\n+//! since they are not derived from a HIR node). This is also why we\n+//! give a callback fn, rather than taking a closure: it allows us to\n+//! easily control precisely what data is given to that fn.\n+\n+use common::tag_items_data_item;\n+use encoder::EncodeContext;\n+use index::IndexData;\n+use rbml::writer::Encoder;\n+use rustc::dep_graph::DepNode;\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n+use rustc::ty::{self, TyCtxt};\n+use rustc_data_structures::fnv::FnvHashMap;\n+use syntax::ast;\n+\n+/// Builder that can encode new items, adding them into the index.\n+/// Item encoding cannot be nested.\n+pub struct IndexBuilder<'a, 'tcx: 'a, 'encoder: 'a> {\n+    items: IndexData,\n+    builder: ItemContentBuilder<'a, 'tcx, 'encoder>,\n+}\n+\n+/// Builder that can encode the content of items, but can't start a\n+/// new item itself. Most code is attached to here.\n+pub struct ItemContentBuilder<'a, 'tcx: 'a, 'encoder: 'a> {\n+    xrefs: FnvHashMap<XRef<'tcx>, u32>, // sequentially-assigned\n+    pub ecx: &'a EncodeContext<'a, 'tcx>,\n+    pub rbml_w: &'a mut Encoder<'encoder>,\n+}\n+\n+/// \"interned\" entries referenced by id\n+#[derive(PartialEq, Eq, Hash)]\n+pub enum XRef<'tcx> { Predicate(ty::Predicate<'tcx>) }\n+\n+impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n+    pub fn new(ecx: &'a EncodeContext<'a, 'tcx>,\n+               rbml_w: &'a mut Encoder<'encoder>)\n+               -> Self {\n+        IndexBuilder {\n+            items: IndexData::new(ecx.tcx.map.num_local_def_ids()),\n+            builder: ItemContentBuilder {\n+                ecx: ecx,\n+                xrefs: FnvHashMap(),\n+                rbml_w: rbml_w,\n+            },\n+        }\n+    }\n+\n+    pub fn ecx(&self) -> &'a EncodeContext<'a, 'tcx> {\n+        self.builder.ecx()\n+    }\n+\n+    /// Emit the data for a def-id to the metadata. The function to\n+    /// emit the data is `op`, and it will be given `data` as\n+    /// arguments. This `record` function will start/end an RBML tag\n+    /// and record the current offset for use in the index, calling\n+    /// `op` to generate the data in the RBML tag.\n+    ///\n+    /// In addition, it will setup a dep-graph task to track what data\n+    /// `op` accesses to generate the metadata, which is later used by\n+    /// incremental compilation to compute a hash for the metadata and\n+    /// track changes.\n+    ///\n+    /// The reason that `op` is a function pointer, and not a closure,\n+    /// is that we want to be able to completely track all data it has\n+    /// access to, so that we can be sure that `DATA: DepGraphRead`\n+    /// holds, and that it is therefore not gaining \"secret\" access to\n+    /// bits of HIR or other state that would not be trackd by the\n+    /// content system.\n+    pub fn record<DATA>(&mut self,\n+                        id: DefId,\n+                        op: fn(&mut ItemContentBuilder<'a, 'tcx, 'encoder>, DATA),\n+                        data: DATA)\n+        where DATA: DepGraphRead\n+    {\n+        let position = self.builder.rbml_w.mark_stable_position();\n+        self.items.record(id, position);\n+        let _task = self.ecx().tcx.dep_graph.in_task(DepNode::MetaData(id));\n+        self.builder.rbml_w.start_tag(tag_items_data_item).unwrap();\n+        data.read(self.ecx().tcx);\n+        op(&mut self.builder, data);\n+        self.builder.rbml_w.end_tag().unwrap();\n+    }\n+\n+    pub fn into_fields(self) -> (IndexData, FnvHashMap<XRef<'tcx>, u32>) {\n+        (self.items, self.builder.xrefs)\n+    }\n+}\n+\n+impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n+    pub fn ecx(&self) -> &'a EncodeContext<'a, 'tcx> {\n+        self.ecx\n+    }\n+\n+    pub fn add_xref(&mut self, xref: XRef<'tcx>) -> u32 {\n+        let old_len = self.xrefs.len() as u32;\n+        *self.xrefs.entry(xref).or_insert(old_len)\n+    }\n+}\n+\n+/// Trait used for data that can be passed from outside a dep-graph\n+/// task.  The data must either be of some safe type, such as a\n+/// `DefId` index, or implement the `read` method so that it can add\n+/// a read of whatever dep-graph nodes are appropriate.\n+pub trait DepGraphRead {\n+    fn read(&self, tcx: TyCtxt);\n+}\n+\n+impl DepGraphRead for DefId {\n+    fn read(&self, _tcx: TyCtxt) { }\n+}\n+\n+impl DepGraphRead for ast::NodeId {\n+    fn read(&self, _tcx: TyCtxt) { }\n+}\n+\n+impl<T> DepGraphRead for Option<T>\n+    where T: DepGraphRead\n+{\n+    fn read(&self, tcx: TyCtxt) {\n+        match *self {\n+            Some(ref v) => v.read(tcx),\n+            None => (),\n+        }\n+    }\n+}\n+\n+impl<T> DepGraphRead for [T]\n+    where T: DepGraphRead\n+{\n+    fn read(&self, tcx: TyCtxt) {\n+        for i in self {\n+            i.read(tcx);\n+        }\n+    }\n+}\n+\n+macro_rules! read_tuple {\n+    ($($name:ident),*) => {\n+        impl<$($name),*> DepGraphRead for ($($name),*)\n+            where $($name: DepGraphRead),*\n+        {\n+            #[allow(non_snake_case)]\n+            fn read(&self, tcx: TyCtxt) {\n+                let &($(ref $name),*) = self;\n+                $($name.read(tcx);)*\n+            }\n+        }\n+    }\n+}\n+read_tuple!(A,B);\n+read_tuple!(A,B,C);\n+\n+macro_rules! read_hir {\n+    ($t:ty) => {\n+        impl<'tcx> DepGraphRead for &'tcx $t {\n+            fn read(&self, tcx: TyCtxt) {\n+                tcx.map.read(self.id);\n+            }\n+        }\n+    }\n+}\n+read_hir!(hir::Item);\n+read_hir!(hir::ImplItem);\n+read_hir!(hir::TraitItem);\n+read_hir!(hir::ForeignItem);\n+\n+/// Leaks access to a value of type T without any tracking. This is\n+/// suitable for ambiguous types like `usize`, which *could* represent\n+/// tracked data (e.g., if you read it out of a HIR node) or might not\n+/// (e.g., if it's an index). Adding in an `Untracked` is an\n+/// assertion, essentially, that the data does not need to be tracked\n+/// (or that read edges will be added by some other way).\n+///\n+/// A good idea is to add to each use of `Untracked` an explanation of\n+/// why this value is ok.\n+pub struct Untracked<T>(pub T);\n+\n+impl<T> DepGraphRead for Untracked<T> {\n+    fn read(&self, _tcx: TyCtxt) { }\n+}\n+\n+/// Newtype that can be used to package up misc data extracted from a\n+/// HIR node that doesn't carry its own id. This will allow an\n+/// arbitrary `T` to be passed in, but register a read on the given\n+/// node-id.\n+pub struct FromId<T>(pub ast::NodeId, pub T);\n+\n+impl<T> DepGraphRead for FromId<T> {\n+    fn read(&self, tcx: TyCtxt) {\n+        tcx.map.read(self.0);\n+    }\n+}"}, {"sha": "a96fa8a006d8967bb4039147d0104c255c1d0993", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/499484f56d336f4628a6fa016626beb3ef21ba81/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/499484f56d336f4628a6fa016626beb3ef21ba81/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=499484f56d336f4628a6fa016626beb3ef21ba81", "patch": "@@ -54,6 +54,7 @@ pub mod def_key;\n pub mod tyencode;\n pub mod tydecode;\n pub mod encoder;\n+mod index_builder;\n pub mod decoder;\n pub mod creader;\n pub mod csearch;"}]}