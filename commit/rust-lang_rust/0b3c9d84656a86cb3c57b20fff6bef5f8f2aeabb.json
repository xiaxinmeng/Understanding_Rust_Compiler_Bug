{"sha": "0b3c9d84656a86cb3c57b20fff6bef5f8f2aeabb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiM2M5ZDg0NjU2YTg2Y2IzYzU3YjIwZmZmNmJlZjVmOGYyYWVhYmI=", "commit": {"author": {"name": "LinkTed", "email": "LinkTed@users.noreply.github.com", "date": "2020-08-21T12:52:10Z"}, "committer": {"name": "LinkTed", "email": "LinkTed@users.noreply.github.com", "date": "2020-10-10T13:19:11Z"}, "message": "unix: Extend UnixStream and UnixDatagram to send and receive file descriptors\n\nAdd the functions `recv_vectored_fds` and `send_vectored_fds` to send and receive file descriptors, by using `recvmsg` and `sendmsg` system call.", "tree": {"sha": "207a6b906cc54da6e01bfc7b83715cd7ffb5c406", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/207a6b906cc54da6e01bfc7b83715cd7ffb5c406"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b3c9d84656a86cb3c57b20fff6bef5f8f2aeabb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b3c9d84656a86cb3c57b20fff6bef5f8f2aeabb", "html_url": "https://github.com/rust-lang/rust/commit/0b3c9d84656a86cb3c57b20fff6bef5f8f2aeabb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b3c9d84656a86cb3c57b20fff6bef5f8f2aeabb/comments", "author": {"login": "LinkTed", "id": 6806266, "node_id": "MDQ6VXNlcjY4MDYyNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/6806266?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LinkTed", "html_url": "https://github.com/LinkTed", "followers_url": "https://api.github.com/users/LinkTed/followers", "following_url": "https://api.github.com/users/LinkTed/following{/other_user}", "gists_url": "https://api.github.com/users/LinkTed/gists{/gist_id}", "starred_url": "https://api.github.com/users/LinkTed/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LinkTed/subscriptions", "organizations_url": "https://api.github.com/users/LinkTed/orgs", "repos_url": "https://api.github.com/users/LinkTed/repos", "events_url": "https://api.github.com/users/LinkTed/events{/privacy}", "received_events_url": "https://api.github.com/users/LinkTed/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LinkTed", "id": 6806266, "node_id": "MDQ6VXNlcjY4MDYyNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/6806266?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LinkTed", "html_url": "https://github.com/LinkTed", "followers_url": "https://api.github.com/users/LinkTed/followers", "following_url": "https://api.github.com/users/LinkTed/following{/other_user}", "gists_url": "https://api.github.com/users/LinkTed/gists{/gist_id}", "starred_url": "https://api.github.com/users/LinkTed/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LinkTed/subscriptions", "organizations_url": "https://api.github.com/users/LinkTed/orgs", "repos_url": "https://api.github.com/users/LinkTed/repos", "events_url": "https://api.github.com/users/LinkTed/events{/privacy}", "received_events_url": "https://api.github.com/users/LinkTed/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7477d445c8b2e942f5cc745fae0e3233494e7460", "url": "https://api.github.com/repos/rust-lang/rust/commits/7477d445c8b2e942f5cc745fae0e3233494e7460", "html_url": "https://github.com/rust-lang/rust/commit/7477d445c8b2e942f5cc745fae0e3233494e7460"}], "stats": {"total": 1111, "additions": 1111, "deletions": 0}, "files": [{"sha": "c72800b5d573ac8a4fb1d5b223f23fcfa4c1f6dd", "filename": "library/std/src/sys/unix/ext/net.rs", "status": "modified", "additions": 867, "deletions": 0, "changes": 867, "blob_url": "https://github.com/rust-lang/rust/blob/0b3c9d84656a86cb3c57b20fff6bef5f8f2aeabb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3c9d84656a86cb3c57b20fff6bef5f8f2aeabb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet.rs?ref=0b3c9d84656a86cb3c57b20fff6bef5f8f2aeabb", "patch": "@@ -25,7 +25,10 @@ use crate::net::{self, Shutdown};\n use crate::os::unix::ffi::OsStrExt;\n use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n use crate::path::Path;\n+use crate::ptr::null_mut;\n+use crate::slice::from_raw_parts;\n use crate::sys::net::Socket;\n+use crate::sys::unix::net::{add_to_ancillary_data, AncillaryDataIter};\n use crate::sys::{self, cvt};\n use crate::sys_common::{self, AsInner, FromInner, IntoInner};\n use crate::time::Duration;\n@@ -114,6 +117,62 @@ unsafe fn sockaddr_un(path: &Path) -> io::Result<(libc::sockaddr_un, libc::sockl\n     Ok((addr, len as libc::socklen_t))\n }\n \n+fn recv_vectored_with_ancillary_from(\n+    socket: &Socket,\n+    bufs: &mut [IoSliceMut<'_>],\n+    ancillary: &mut SocketAncillary<'_>,\n+) -> io::Result<(usize, bool, io::Result<SocketAddr>)> {\n+    unsafe {\n+        let mut msg_name: libc::sockaddr_un = mem::zeroed();\n+\n+        let mut msg = libc::msghdr {\n+            msg_name: &mut msg_name as *mut _ as *mut _,\n+            msg_namelen: mem::size_of::<libc::sockaddr_un>() as libc::socklen_t,\n+            msg_iov: bufs.as_mut_ptr().cast(),\n+            msg_iovlen: bufs.len(),\n+            msg_control: ancillary.buffer.as_mut_ptr().cast(),\n+            msg_controllen: ancillary.buffer.len(),\n+            msg_flags: 0,\n+        };\n+\n+        let count = socket.recv_msg(&mut msg)?;\n+\n+        ancillary.length = msg.msg_controllen;\n+        ancillary.truncated = msg.msg_flags & libc::MSG_CTRUNC == libc::MSG_CTRUNC;\n+\n+        let truncated = msg.msg_flags & libc::MSG_TRUNC == libc::MSG_TRUNC;\n+        let addr = SocketAddr::from_parts(msg_name, msg.msg_namelen);\n+\n+        Ok((count, truncated, addr))\n+    }\n+}\n+\n+fn send_vectored_with_ancillary_to(\n+    socket: &Socket,\n+    path: Option<&Path>,\n+    bufs: &mut [IoSliceMut<'_>],\n+    ancillary: &mut SocketAncillary<'_>,\n+) -> io::Result<usize> {\n+    unsafe {\n+        let (mut msg_name, msg_namelen) =\n+            if let Some(path) = path { sockaddr_un(path)? } else { (mem::zeroed(), 0) };\n+\n+        let mut msg = libc::msghdr {\n+            msg_name: &mut msg_name as *mut _ as *mut _,\n+            msg_namelen,\n+            msg_iov: bufs.as_mut_ptr().cast(),\n+            msg_iovlen: bufs.len(),\n+            msg_control: ancillary.buffer.as_mut_ptr().cast(),\n+            msg_controllen: ancillary.length,\n+            msg_flags: 0,\n+        };\n+\n+        ancillary.truncated = false;\n+\n+        socket.send_msg(&mut msg)\n+    }\n+}\n+\n enum AddressKind<'a> {\n     Unnamed,\n     Pathname(&'a Path),\n@@ -269,6 +328,556 @@ impl fmt::Debug for SocketAddr {\n     }\n }\n \n+#[cfg(any(\n+    target_os = \"haiku\",\n+    target_os = \"solaris\",\n+    target_os = \"illumos\",\n+    target_os = \"macos\",\n+    target_os = \"ios\",\n+    target_os = \"freebsd\",\n+    target_os = \"dragonfly\",\n+    target_os = \"openbsd\",\n+    target_os = \"netbsd\",\n+    target_os = \"linux\",\n+    target_os = \"android\",\n+    target_os = \"emscripten\",\n+    target_os = \"fuchsia\",\n+    target_env = \"uclibc\",\n+))]\n+#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+pub struct ScmRights<'a>(AncillaryDataIter<'a, RawFd>);\n+\n+#[cfg(any(\n+    target_os = \"haiku\",\n+    target_os = \"solaris\",\n+    target_os = \"illumos\",\n+    target_os = \"macos\",\n+    target_os = \"ios\",\n+    target_os = \"freebsd\",\n+    target_os = \"dragonfly\",\n+    target_os = \"openbsd\",\n+    target_os = \"netbsd\",\n+    target_os = \"linux\",\n+    target_os = \"android\",\n+    target_os = \"emscripten\",\n+    target_os = \"fuchsia\",\n+    target_env = \"uclibc\",\n+))]\n+#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+impl<'a> Iterator for ScmRights<'a> {\n+    type Item = RawFd;\n+\n+    fn next(&mut self) -> Option<RawFd> {\n+        self.0.next()\n+    }\n+}\n+\n+#[cfg(any(\n+    target_os = \"netbsd\",\n+    target_os = \"openbsd\",\n+    target_os = \"freebsd\",\n+    target_os = \"dragonfly\",\n+    target_os = \"macos\",\n+    target_os = \"ios\",\n+    target_os = \"linux\",\n+    target_os = \"android\",\n+    target_os = \"emscripten\",\n+    target_os = \"fuchsia\",\n+    target_env = \"uclibc\",\n+))]\n+#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+pub struct ScmCredentials<'a>(AncillaryDataIter<'a, libc::ucred>);\n+\n+#[cfg(any(\n+    target_os = \"netbsd\",\n+    target_os = \"openbsd\",\n+    target_os = \"freebsd\",\n+    target_os = \"dragonfly\",\n+    target_os = \"macos\",\n+    target_os = \"ios\",\n+    target_os = \"linux\",\n+    target_os = \"android\",\n+    target_os = \"emscripten\",\n+    target_os = \"fuchsia\",\n+    target_env = \"uclibc\",\n+))]\n+#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+impl<'a> Iterator for ScmCredentials<'a> {\n+    type Item = libc::ucred;\n+\n+    fn next(&mut self) -> Option<libc::ucred> {\n+        self.0.next()\n+    }\n+}\n+\n+#[cfg(any(\n+    target_os = \"haiku\",\n+    target_os = \"solaris\",\n+    target_os = \"illumos\",\n+    target_os = \"macos\",\n+    target_os = \"ios\",\n+    target_os = \"freebsd\",\n+    target_os = \"dragonfly\",\n+    target_os = \"openbsd\",\n+    target_os = \"netbsd\",\n+    target_os = \"linux\",\n+    target_os = \"android\",\n+    target_os = \"emscripten\",\n+    target_os = \"fuchsia\",\n+    target_env = \"uclibc\",\n+))]\n+#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+pub enum AncillaryData<'a> {\n+    ScmRights(ScmRights<'a>),\n+    #[cfg(any(\n+        target_os = \"netbsd\",\n+        target_os = \"openbsd\",\n+        target_os = \"freebsd\",\n+        target_os = \"dragonfly\",\n+        target_os = \"macos\",\n+        target_os = \"ios\",\n+        target_os = \"linux\",\n+        target_os = \"android\",\n+        target_os = \"emscripten\",\n+        target_os = \"fuchsia\",\n+        target_env = \"uclibc\",\n+    ))]\n+    ScmCredentials(ScmCredentials<'a>),\n+}\n+\n+impl<'a> AncillaryData<'a> {\n+    #[cfg(any(\n+        target_os = \"haiku\",\n+        target_os = \"solaris\",\n+        target_os = \"illumos\",\n+        target_os = \"macos\",\n+        target_os = \"ios\",\n+        target_os = \"freebsd\",\n+        target_os = \"dragonfly\",\n+        target_os = \"openbsd\",\n+        target_os = \"netbsd\",\n+        target_os = \"linux\",\n+        target_os = \"android\",\n+        target_os = \"emscripten\",\n+        target_os = \"fuchsia\",\n+        target_env = \"uclibc\",\n+    ))]\n+    fn as_rights(data: &'a [u8]) -> Self {\n+        let ancillary_data_iter = AncillaryDataIter::new(data);\n+        let scm_rights = ScmRights(ancillary_data_iter);\n+        AncillaryData::ScmRights(scm_rights)\n+    }\n+\n+    #[cfg(any(\n+        target_os = \"netbsd\",\n+        target_os = \"openbsd\",\n+        target_os = \"freebsd\",\n+        target_os = \"dragonfly\",\n+        target_os = \"macos\",\n+        target_os = \"ios\",\n+        target_os = \"linux\",\n+        target_os = \"android\",\n+        target_os = \"emscripten\",\n+        target_os = \"fuchsia\",\n+        target_env = \"uclibc\",\n+    ))]\n+    fn as_credentials(data: &'a [u8]) -> Self {\n+        let ancillary_data_iter = AncillaryDataIter::new(data);\n+        let scm_credentials = ScmCredentials(ancillary_data_iter);\n+        AncillaryData::ScmCredentials(scm_credentials)\n+    }\n+}\n+\n+#[cfg(any(\n+    target_os = \"haiku\",\n+    target_os = \"solaris\",\n+    target_os = \"illumos\",\n+    target_os = \"macos\",\n+    target_os = \"ios\",\n+    target_os = \"freebsd\",\n+    target_os = \"dragonfly\",\n+    target_os = \"openbsd\",\n+    target_os = \"netbsd\",\n+    target_os = \"linux\",\n+    target_os = \"android\",\n+    target_os = \"emscripten\",\n+    target_os = \"fuchsia\",\n+    target_env = \"uclibc\",\n+))]\n+#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+impl<'a> AncillaryData<'a> {\n+    fn from(cmsg: &'a libc::cmsghdr) -> Self {\n+        unsafe {\n+            let cmsg_len_zero = libc::CMSG_LEN(0) as usize;\n+            let data_len = (*cmsg).cmsg_len - cmsg_len_zero;\n+            let data = libc::CMSG_DATA(cmsg).cast();\n+            let data = from_raw_parts(data, data_len);\n+\n+            if (*cmsg).cmsg_level == libc::SOL_SOCKET {\n+                match (*cmsg).cmsg_type {\n+                    libc::SCM_RIGHTS => AncillaryData::as_rights(data),\n+                    #[cfg(any(\n+                        target_os = \"linux\",\n+                        target_os = \"android\",\n+                        target_os = \"emscripten\",\n+                        target_os = \"fuchsia\",\n+                        target_env = \"uclibc\",\n+                    ))]\n+                    libc::SCM_CREDENTIALS => AncillaryData::as_credentials(data),\n+                    #[cfg(any(\n+                        target_os = \"netbsd\",\n+                        target_os = \"openbsd\",\n+                        target_os = \"freebsd\",\n+                        target_os = \"dragonfly\",\n+                        target_os = \"macos\",\n+                        target_os = \"ios\",\n+                    ))]\n+                    libc::SCM_CREDS => AncillaryData::as_credentials(data),\n+                    _ => panic!(\"Unknown cmsg type\"),\n+                }\n+            } else {\n+                panic!(\"Unknown cmsg level\");\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(any(\n+    target_os = \"haiku\",\n+    target_os = \"solaris\",\n+    target_os = \"illumos\",\n+    target_os = \"macos\",\n+    target_os = \"ios\",\n+    target_os = \"freebsd\",\n+    target_os = \"dragonfly\",\n+    target_os = \"openbsd\",\n+    target_os = \"netbsd\",\n+    target_os = \"linux\",\n+    target_os = \"android\",\n+    target_os = \"emscripten\",\n+    target_os = \"fuchsia\",\n+    target_env = \"uclibc\",\n+))]\n+#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+pub struct Messages<'a> {\n+    buffer: &'a [u8],\n+    current: Option<&'a libc::cmsghdr>,\n+}\n+\n+#[cfg(any(\n+    target_os = \"haiku\",\n+    target_os = \"solaris\",\n+    target_os = \"illumos\",\n+    target_os = \"macos\",\n+    target_os = \"ios\",\n+    target_os = \"freebsd\",\n+    target_os = \"dragonfly\",\n+    target_os = \"openbsd\",\n+    target_os = \"netbsd\",\n+    target_os = \"linux\",\n+    target_os = \"android\",\n+    target_os = \"emscripten\",\n+    target_os = \"fuchsia\",\n+    target_env = \"uclibc\",\n+))]\n+#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+impl<'a> Iterator for Messages<'a> {\n+    type Item = AncillaryData<'a>;\n+\n+    fn next(&mut self) -> Option<AncillaryData<'a>> {\n+        unsafe {\n+            let msg = libc::msghdr {\n+                msg_name: null_mut(),\n+                msg_namelen: 0,\n+                msg_iov: null_mut(),\n+                msg_iovlen: 0,\n+                msg_control: self.buffer.as_ptr() as *mut _,\n+                msg_controllen: self.buffer.len(),\n+                msg_flags: 0,\n+            };\n+\n+            let cmsg = if let Some(current) = self.current {\n+                libc::CMSG_NXTHDR(&msg, current)\n+            } else {\n+                libc::CMSG_FIRSTHDR(&msg)\n+            };\n+\n+            let cmsg = cmsg.as_ref()?;\n+            self.current = Some(cmsg);\n+            let ancillary_data = AncillaryData::from(cmsg);\n+            Some(ancillary_data)\n+        }\n+    }\n+}\n+\n+/// A Unix socket Ancillary data struct.\n+///\n+/// # Example\n+/// ```no_run\n+/// #![feature(unix_socket_ancillary_data)]\n+/// use std::os::unix::net::{UnixStream, SocketAncillary, AncillaryData};\n+/// use std::io::IoSliceMut;\n+///\n+/// fn main() -> std::io::Result<()> {\n+///     let sock = UnixStream::connect(\"/tmp/sock\")?;\n+///\n+///     let mut fds = [0; 8];\n+///     let mut ancillary_buffer = [0; 128];\n+///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n+///\n+///     let mut buf = [1; 8];\n+///     let mut bufs = &mut [IoSliceMut::new(&mut buf[..])][..];\n+///     sock.recv_vectored_with_ancillary(bufs, &mut ancillary)?;\n+///\n+///     for ancillary_data in ancillary.messages() {\n+///         if let AncillaryData::ScmRights(scm_rights) = ancillary_data {\n+///             for fd in scm_rights {\n+///                 println!(\"receive file descriptor: {}\", fd);\n+///             }\n+///         }\n+///     }\n+///     Ok(())\n+/// }\n+/// ```\n+#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+#[derive(Debug)]\n+pub struct SocketAncillary<'a> {\n+    buffer: &'a mut [u8],\n+    length: usize,\n+    truncated: bool,\n+}\n+\n+impl<'a> SocketAncillary<'a> {\n+    /// Create an ancillary data with the given buffer.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```no_run\n+    /// # #![allow(unused_mut)]\n+    /// #![feature(unix_socket_ancillary_data)]\n+    /// use std::os::unix::net::SocketAncillary;\n+    /// let mut ancillary_buffer = [0; 128];\n+    /// let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n+    /// ```\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+    pub fn new(buffer: &'a mut [u8]) -> Self {\n+        SocketAncillary { buffer, length: 0, truncated: false }\n+    }\n+\n+    /// Returns the capacity of the buffer.\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+    pub fn capacity(&self) -> usize {\n+        self.buffer.len()\n+    }\n+\n+    /// Returns the number of used bytes.\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+    pub fn len(&self) -> usize {\n+        self.length\n+    }\n+\n+    #[cfg(any(\n+        target_os = \"haiku\",\n+        target_os = \"solaris\",\n+        target_os = \"illumos\",\n+        target_os = \"macos\",\n+        target_os = \"ios\",\n+        target_os = \"freebsd\",\n+        target_os = \"dragonfly\",\n+        target_os = \"openbsd\",\n+        target_os = \"netbsd\",\n+        target_os = \"linux\",\n+        target_os = \"android\",\n+        target_os = \"emscripten\",\n+        target_os = \"fuchsia\",\n+        target_env = \"uclibc\",\n+    ))]\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+    pub fn messages(&'a self) -> Messages<'a> {\n+        Messages { buffer: &self.buffer[..self.length], current: None }\n+    }\n+\n+    /// Is `true` if during a recv operation the ancillary was truncated.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_ancillary_data)]\n+    /// use std::os::unix::net::{UnixStream, SocketAncillary};\n+    /// use std::io::IoSliceMut;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixStream::connect(\"/tmp/sock\")?;\n+    ///\n+    ///     let mut ancillary_buffer = [0; 128];\n+    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n+    ///\n+    ///     let mut buf = [1; 8];\n+    ///     let mut bufs = &mut [IoSliceMut::new(&mut buf[..])][..];\n+    ///     sock.recv_vectored_with_ancillary(bufs, &mut ancillary)?;\n+    ///\n+    ///     println!(\"Is truncated: {}\", ancillary.truncated());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+    pub fn truncated(&self) -> bool {\n+        self.truncated\n+    }\n+\n+    /// Add file descriptors to the ancillary data.\n+    ///\n+    /// The function returns `true` if there was enough space in the buffer.\n+    /// If there was not enough space then no file descriptors was appended.\n+    /// Technically, that means this operation adds a control message with the level `SOL_SOCKET`\n+    /// and type `SCM_RIGHTS`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_ancillary_data)]\n+    /// use std::os::unix::net::{UnixStream, SocketAncillary};\n+    /// use std::os::unix::io::AsRawFd;\n+    /// use std::io::IoSliceMut;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixStream::connect(\"/tmp/sock\")?;\n+    ///\n+    ///     let mut ancillary_buffer = [0; 128];\n+    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n+    ///     ancillary.add_fds(&[sock.as_raw_fd()][..]);\n+    ///\n+    ///     let mut buf = [1; 8];\n+    ///     let mut bufs = &mut [IoSliceMut::new(&mut buf[..])][..];\n+    ///     sock.send_vectored_with_ancillary(bufs, &mut ancillary)?;\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[cfg(any(\n+        target_os = \"haiku\",\n+        target_os = \"solaris\",\n+        target_os = \"illumos\",\n+        target_os = \"macos\",\n+        target_os = \"ios\",\n+        target_os = \"freebsd\",\n+        target_os = \"dragonfly\",\n+        target_os = \"openbsd\",\n+        target_os = \"netbsd\",\n+        target_os = \"linux\",\n+        target_os = \"android\",\n+        target_os = \"emscripten\",\n+        target_os = \"fuchsia\",\n+        target_env = \"uclibc\",\n+    ))]\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+    pub fn add_fds(&mut self, fds: &[RawFd]) -> bool {\n+        self.truncated = false;\n+        add_to_ancillary_data(\n+            &mut self.buffer,\n+            &mut self.length,\n+            fds,\n+            libc::SOL_SOCKET,\n+            libc::SCM_RIGHTS,\n+        )\n+    }\n+\n+    /// Add credentials to the ancillary data.\n+    ///\n+    /// The function returns `true` if there was enough space in the buffer.\n+    /// If there was not enough space then no credentials was appended.\n+    /// Technically, that means this operation adds a control message with the level `SOL_SOCKET`\n+    /// and type `SCM_CREDENTIALS`.\n+    ///\n+    #[cfg(any(\n+        target_os = \"netbsd\",\n+        target_os = \"openbsd\",\n+        target_os = \"freebsd\",\n+        target_os = \"dragonfly\",\n+        target_os = \"macos\",\n+        target_os = \"ios\",\n+        target_os = \"linux\",\n+        target_os = \"android\",\n+        target_os = \"emscripten\",\n+        target_os = \"fuchsia\",\n+        target_env = \"uclibc\",\n+    ))]\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+    pub fn add_creds(&mut self, creds: &[libc::ucred]) -> bool {\n+        self.truncated = false;\n+        add_to_ancillary_data(\n+            &mut self.buffer,\n+            &mut self.length,\n+            creds,\n+            libc::SOL_SOCKET,\n+            #[cfg(any(\n+                target_os = \"linux\",\n+                target_os = \"android\",\n+                target_os = \"emscripten\",\n+                target_os = \"fuchsia\",\n+                target_env = \"uclibc\",\n+            ))]\n+            libc::SCM_CREDENTIALS,\n+            #[cfg(any(\n+                target_os = \"netbsd\",\n+                target_os = \"openbsd\",\n+                target_os = \"freebsd\",\n+                target_os = \"dragonfly\",\n+                target_os = \"macos\",\n+                target_os = \"ios\",\n+            ))]\n+            libc::SCM_CREDS,\n+        )\n+    }\n+\n+    /// Clears the ancillary data, removing all values.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_ancillary_data)]\n+    /// use std::os::unix::net::{UnixStream, SocketAncillary, AncillaryData};\n+    /// use std::io::IoSliceMut;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixStream::connect(\"/tmp/sock\")?;\n+    ///\n+    ///     let mut fds1 = [0; 8];\n+    ///     let mut fds2 = [0; 8];\n+    ///     let mut ancillary_buffer = [0; 128];\n+    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n+    ///\n+    ///     let mut buf = [1; 8];\n+    ///     let mut bufs = &mut [IoSliceMut::new(&mut buf[..])][..];\n+    ///\n+    ///     sock.recv_vectored_with_ancillary(bufs, &mut ancillary)?;\n+    ///     for ancillary_data in ancillary.messages() {\n+    ///         if let AncillaryData::ScmRights(scm_rights) = ancillary_data {\n+    ///             for fd in scm_rights {\n+    ///                 println!(\"receive file descriptor: {}\", fd);\n+    ///             }\n+    ///         }\n+    ///     }\n+    ///\n+    ///     ancillary.clear();\n+    ///\n+    ///     sock.recv_vectored_with_ancillary(bufs, &mut ancillary)?;\n+    ///     for ancillary_data in ancillary.messages() {\n+    ///         if let AncillaryData::ScmRights(scm_rights) = ancillary_data {\n+    ///             for fd in scm_rights {\n+    ///                 println!(\"receive file descriptor: {}\", fd);\n+    ///             }\n+    ///         }\n+    ///     }\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+    pub fn clear(&mut self) {\n+        self.length = 0;\n+        self.truncated = false;\n+    }\n+}\n+\n struct AsciiEscaped<'a>(&'a [u8]);\n \n impl<'a> fmt::Display for AsciiEscaped<'a> {\n@@ -646,6 +1255,91 @@ impl UnixStream {\n         self.0.shutdown(how)\n     }\n \n+    /// Receives data and ancillary data from socket.\n+    ///\n+    /// On success, returns the number of bytes read.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_ancillary_data)]\n+    /// use std::os::unix::net::{UnixStream, SocketAncillary, AncillaryData};\n+    /// use std::io::IoSliceMut;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     let mut buf1 = [1; 8];\n+    ///     let mut buf2 = [2; 16];\n+    ///     let mut buf3 = [3; 8];\n+    ///     let mut bufs = &mut [\n+    ///         IoSliceMut::new(&mut buf1),\n+    ///         IoSliceMut::new(&mut buf2),\n+    ///         IoSliceMut::new(&mut buf3),\n+    ///     ][..];\n+    ///     let mut fds = [0; 8];\n+    ///     let mut ancillary_buffer = [0; 128];\n+    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n+    ///     let size = socket.recv_vectored_with_ancillary(bufs, &mut ancillary)?;\n+    ///     println!(\"received {}\", size);\n+    ///     for ancillary_data in ancillary.messages() {\n+    ///         if let AncillaryData::ScmRights(scm_rights) = ancillary_data {\n+    ///             for fd in scm_rights {\n+    ///                 println!(\"receive file descriptor: {}\", fd);\n+    ///             }\n+    ///         }\n+    ///     }\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+    pub fn recv_vectored_with_ancillary(\n+        &self,\n+        bufs: &mut [IoSliceMut<'_>],\n+        ancillary: &mut SocketAncillary<'_>,\n+    ) -> io::Result<usize> {\n+        let (count, _, _) = recv_vectored_with_ancillary_from(&self.0, bufs, ancillary)?;\n+\n+        Ok(count)\n+    }\n+\n+    /// Sends data and ancillary data on the socket.\n+    ///\n+    /// On success, returns the number of bytes written.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_ancillary_data)]\n+    /// use std::os::unix::net::{UnixStream, SocketAncillary};\n+    /// use std::io::IoSliceMut;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     let mut buf1 = [1; 8];\n+    ///     let mut buf2 = [2; 16];\n+    ///     let mut buf3 = [3; 8];\n+    ///     let mut bufs = &mut [\n+    ///         IoSliceMut::new(&mut buf1),\n+    ///         IoSliceMut::new(&mut buf2),\n+    ///         IoSliceMut::new(&mut buf3),\n+    ///     ][..];\n+    ///     let fds = [0, 1, 2];\n+    ///     let mut ancillary_buffer = [0; 128];\n+    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n+    ///     ancillary.add_fds(&fds[..]);\n+    ///     socket.send_vectored_with_ancillary(bufs, &mut ancillary).expect(\"send_vectored_with_ancillary function failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+    pub fn send_vectored_with_ancillary(\n+        &self,\n+        bufs: &mut [IoSliceMut<'_>],\n+        ancillary: &mut SocketAncillary<'_>,\n+    ) -> io::Result<usize> {\n+        send_vectored_with_ancillary_to(&self.0, None, bufs, ancillary)\n+    }\n+\n     /// Receives data on the socket from the remote address to which it is\n     /// connected, without removing that data from the queue. On success,\n     /// returns the number of bytes peeked.\n@@ -1439,6 +2133,102 @@ impl UnixDatagram {\n         self.0.read(buf)\n     }\n \n+    /// Receives data and ancillary data from socket.\n+    ///\n+    /// On success, returns the number of bytes read, if the data was truncated and the address from whence the msg came.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_ancillary_data)]\n+    /// use std::os::unix::net::{UnixDatagram, SocketAncillary, AncillaryData};\n+    /// use std::io::IoSliceMut;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     let mut buf1 = [1; 8];\n+    ///     let mut buf2 = [2; 16];\n+    ///     let mut buf3 = [3; 8];\n+    ///     let mut bufs = &mut [\n+    ///         IoSliceMut::new(&mut buf1),\n+    ///         IoSliceMut::new(&mut buf2),\n+    ///         IoSliceMut::new(&mut buf3),\n+    ///     ][..];\n+    ///     let mut fds = [0; 8];\n+    ///     let mut ancillary_buffer = [0; 128];\n+    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n+    ///     let (size, _truncated, sender) = sock.recv_vectored_with_ancillary_from(bufs, &mut ancillary)?;\n+    ///     println!(\"received {}\", size);\n+    ///     for ancillary_data in ancillary.messages() {\n+    ///         if let AncillaryData::ScmRights(scm_rights) = ancillary_data {\n+    ///             for fd in scm_rights {\n+    ///                 println!(\"receive file descriptor: {}\", fd);\n+    ///             }\n+    ///         }\n+    ///     }\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+    pub fn recv_vectored_with_ancillary_from(\n+        &self,\n+        bufs: &mut [IoSliceMut<'_>],\n+        ancillary: &mut SocketAncillary<'_>,\n+    ) -> io::Result<(usize, bool, SocketAddr)> {\n+        let (count, truncated, addr) = recv_vectored_with_ancillary_from(&self.0, bufs, ancillary)?;\n+        let addr = addr?;\n+\n+        Ok((count, truncated, addr))\n+    }\n+\n+    /// Receives data and ancillary data from socket.\n+    ///\n+    /// On success, returns the number of bytes read and if the data was truncated.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_ancillary_data)]\n+    /// use std::os::unix::net::{UnixDatagram, SocketAncillary, AncillaryData};\n+    /// use std::io::IoSliceMut;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     let mut buf1 = [1; 8];\n+    ///     let mut buf2 = [2; 16];\n+    ///     let mut buf3 = [3; 8];\n+    ///     let mut bufs = &mut [\n+    ///         IoSliceMut::new(&mut buf1),\n+    ///         IoSliceMut::new(&mut buf2),\n+    ///         IoSliceMut::new(&mut buf3),\n+    ///     ][..];\n+    ///     let mut fds = [0; 8];\n+    ///     let mut ancillary_buffer = [0; 128];\n+    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n+    ///     let (size, _truncated) = sock.recv_vectored_with_ancillary(bufs, &mut ancillary)?;\n+    ///     println!(\"received {}\", size);\n+    ///     for ancillary_data in ancillary.messages() {\n+    ///         if let AncillaryData::ScmRights(scm_rights) = ancillary_data {\n+    ///             for fd in scm_rights {\n+    ///                 println!(\"receive file descriptor: {}\", fd);\n+    ///             }\n+    ///         }\n+    ///     }\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+    pub fn recv_vectored_with_ancillary(\n+        &self,\n+        bufs: &mut [IoSliceMut<'_>],\n+        ancillary: &mut SocketAncillary<'_>,\n+    ) -> io::Result<(usize, bool)> {\n+        let (count, truncated, addr) = recv_vectored_with_ancillary_from(&self.0, bufs, ancillary)?;\n+        addr?;\n+\n+        Ok((count, truncated))\n+    }\n+\n     /// Sends data on the socket to the specified address.\n     ///\n     /// On success, returns the number of bytes written.\n@@ -1498,6 +2288,83 @@ impl UnixDatagram {\n         self.0.write(buf)\n     }\n \n+    /// Sends data and ancillary data on the socket to the specified address.\n+    ///\n+    /// On success, returns the number of bytes written.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_ancillary_data)]\n+    /// use std::os::unix::net::{UnixDatagram, SocketAncillary};\n+    /// use std::io::IoSliceMut;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     let mut buf1 = [1; 8];\n+    ///     let mut buf2 = [2; 16];\n+    ///     let mut buf3 = [3; 8];\n+    ///     let mut bufs = &mut [\n+    ///         IoSliceMut::new(&mut buf1),\n+    ///         IoSliceMut::new(&mut buf2),\n+    ///         IoSliceMut::new(&mut buf3),\n+    ///     ][..];\n+    ///     let fds = [0, 1, 2];\n+    ///     let mut ancillary_buffer = [0; 128];\n+    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n+    ///     ancillary.add_fds(&fds[..]);\n+    ///     sock.send_vectored_with_ancillary_to(bufs, &mut ancillary, \"/some/sock\").expect(\"send_vectored_with_ancillary_to function failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+    pub fn send_vectored_with_ancillary_to<P: AsRef<Path>>(\n+        &self,\n+        bufs: &mut [IoSliceMut<'_>],\n+        ancillary: &mut SocketAncillary<'_>,\n+        path: P,\n+    ) -> io::Result<usize> {\n+        send_vectored_with_ancillary_to(&self.0, Some(path.as_ref()), bufs, ancillary)\n+    }\n+\n+    /// Sends data and ancillary data on the socket.\n+    ///\n+    /// On success, returns the number of bytes written.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_ancillary_data)]\n+    /// use std::os::unix::net::{UnixDatagram, SocketAncillary};\n+    /// use std::io::IoSliceMut;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     let mut buf1 = [1; 8];\n+    ///     let mut buf2 = [2; 16];\n+    ///     let mut buf3 = [3; 8];\n+    ///     let mut bufs = &mut [\n+    ///         IoSliceMut::new(&mut buf1),\n+    ///         IoSliceMut::new(&mut buf2),\n+    ///         IoSliceMut::new(&mut buf3),\n+    ///     ][..];\n+    ///     let fds = [0, 1, 2];\n+    ///     let mut ancillary_buffer = [0; 128];\n+    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n+    ///     ancillary.add_fds(&fds[..]);\n+    ///     sock.send_vectored_with_ancillary(bufs, &mut ancillary).expect(\"send_vectored_with_ancillary function failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+    pub fn send_vectored_with_ancillary(\n+        &self,\n+        bufs: &mut [IoSliceMut<'_>],\n+        ancillary: &mut SocketAncillary<'_>,\n+    ) -> io::Result<usize> {\n+        send_vectored_with_ancillary_to(&self.0, None, bufs, ancillary)\n+    }\n+\n     /// Sets the read timeout for the socket.\n     ///\n     /// If the provided value is [`None`], then [`recv`] and [`recv_from`] calls will"}, {"sha": "a4ca81c1c22e08c1dde014ad6f813bd71a9f95cf", "filename": "library/std/src/sys/unix/ext/net/tests.rs", "status": "modified", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/0b3c9d84656a86cb3c57b20fff6bef5f8f2aeabb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3c9d84656a86cb3c57b20fff6bef5f8f2aeabb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Ftests.rs?ref=0b3c9d84656a86cb3c57b20fff6bef5f8f2aeabb", "patch": "@@ -452,3 +452,155 @@ fn test_unix_datagram_peek_from() {\n     assert_eq!(size, 11);\n     assert_eq!(msg, &buf[..]);\n }\n+\n+#[test]\n+fn test_send_vectored_fds_unix_stream() {\n+    let (s1, s2) = or_panic!(UnixStream::pair());\n+\n+    let mut buf1 = [1; 8];\n+    let mut bufs_send = &mut [IoSliceMut::new(&mut buf1[..])][..];\n+\n+    let mut ancillary1_buffer = [0; 128];\n+    let mut ancillary1 = SocketAncillary::new(&mut ancillary1_buffer[..]);\n+    assert!(ancillary1.add_fds(&[s1.as_raw_fd()][..]));\n+\n+    let usize = or_panic!(s1.send_vectored_with_ancillary(&mut bufs_send, &mut ancillary1));\n+    assert_eq!(usize, 8);\n+\n+    let mut buf2 = [0; 8];\n+    let mut bufs_recv = &mut [IoSliceMut::new(&mut buf2[..])][..];\n+\n+    let mut ancillary2_buffer = [0; 128];\n+    let mut ancillary2 = SocketAncillary::new(&mut ancillary2_buffer[..]);\n+\n+    let usize = or_panic!(s2.recv_vectored_with_ancillary(&mut bufs_recv, &mut ancillary2));\n+    assert_eq!(usize, 8);\n+    assert_eq!(buf1, buf2);\n+\n+    let mut ancillary_data_vec = Vec::from_iter(ancillary2.messages());\n+    assert_eq!(ancillary_data_vec.len(), 1);\n+    if let AncillaryData::ScmRights(scm_rights) = ancillary_data_vec.pop().unwrap() {\n+        let fd_vec = Vec::from_iter(scm_rights);\n+        assert_eq!(fd_vec.len(), 1);\n+        unsafe {\n+            libc::close(fd_vec[0]);\n+        }\n+    } else {\n+        assert!(false);\n+    }\n+}\n+\n+#[test]\n+fn test_send_vectored_with_ancillary_to_unix_datagram() {\n+    fn getpid() -> libc::pid_t {\n+        unsafe { libc::getpid() }\n+    }\n+\n+    fn getuid() -> libc::uid_t {\n+        unsafe { libc::getuid() }\n+    }\n+\n+    fn getgid() -> libc::gid_t {\n+        unsafe { libc::getgid() }\n+    }\n+\n+    let dir = tmpdir();\n+    let path1 = dir.path().join(\"sock1\");\n+    let path2 = dir.path().join(\"sock2\");\n+\n+    let bsock1 = or_panic!(UnixDatagram::bind(&path1));\n+    let bsock2 = or_panic!(UnixDatagram::bind(&path2));\n+\n+    unsafe {\n+        let optval: libc::c_int = 1;\n+        libc::setsockopt(\n+            bsock2.as_raw_fd(),\n+            libc::SOL_SOCKET,\n+            libc::SO_PASSCRED,\n+            &optval as *const _ as *const _,\n+            mem::size_of::<libc::c_int>() as u32,\n+        );\n+    }\n+\n+    let mut buf1 = [1; 8];\n+    let mut bufs_send = &mut [IoSliceMut::new(&mut buf1[..])][..];\n+\n+    let mut ancillary1_buffer = [0; 128];\n+    let mut ancillary1 = SocketAncillary::new(&mut ancillary1_buffer[..]);\n+    let cred1 = libc::ucred { pid: getpid(), uid: getuid(), gid: getgid() };\n+    assert!(ancillary1.add_creds(&[cred1][..]));\n+\n+    let usize =\n+        or_panic!(bsock1.send_vectored_with_ancillary_to(&mut bufs_send, &mut ancillary1, &path2));\n+    assert_eq!(usize, 8);\n+\n+    let mut buf2 = [0; 8];\n+    let mut bufs_recv = &mut [IoSliceMut::new(&mut buf2[..])][..];\n+\n+    let mut ancillary2_buffer = [0; 128];\n+    let mut ancillary2 = SocketAncillary::new(&mut ancillary2_buffer[..]);\n+\n+    let (usize, truncated, _addr) =\n+        or_panic!(bsock2.recv_vectored_with_ancillary_from(&mut bufs_recv, &mut ancillary2));\n+    assert_eq!(ancillary2.truncated(), false);\n+    assert_eq!(usize, 8);\n+    assert_eq!(truncated, false);\n+    assert_eq!(buf1, buf2);\n+\n+    let mut ancillary_data_vec = Vec::from_iter(ancillary2.messages());\n+    assert_eq!(ancillary_data_vec.len(), 1);\n+    if let AncillaryData::ScmCredentials(scm_credentials) = ancillary_data_vec.pop().unwrap() {\n+        let cred_vec = Vec::from_iter(scm_credentials);\n+        assert_eq!(cred_vec.len(), 1);\n+        assert_eq!(cred1.pid, cred_vec[0].pid);\n+        assert_eq!(cred1.uid, cred_vec[0].uid);\n+        assert_eq!(cred1.gid, cred_vec[0].gid);\n+    } else {\n+        assert!(false);\n+    }\n+}\n+\n+#[test]\n+fn test_send_vectored_with_ancillary_unix_datagram() {\n+    let dir = tmpdir();\n+    let path1 = dir.path().join(\"sock1\");\n+    let path2 = dir.path().join(\"sock2\");\n+\n+    let bsock1 = or_panic!(UnixDatagram::bind(&path1));\n+    let bsock2 = or_panic!(UnixDatagram::bind(&path2));\n+\n+    let mut buf1 = [1; 8];\n+    let mut bufs_send = &mut [IoSliceMut::new(&mut buf1[..])][..];\n+\n+    let mut ancillary1_buffer = [0; 128];\n+    let mut ancillary1 = SocketAncillary::new(&mut ancillary1_buffer[..]);\n+    assert!(ancillary1.add_fds(&[bsock1.as_raw_fd()][..]));\n+\n+    or_panic!(bsock1.connect(&path2));\n+    let usize = or_panic!(bsock1.send_vectored_with_ancillary(&mut bufs_send, &mut ancillary1));\n+    assert_eq!(usize, 8);\n+\n+    let mut buf2 = [0; 8];\n+    let mut bufs_recv = &mut [IoSliceMut::new(&mut buf2[..])][..];\n+\n+    let mut ancillary2_buffer = [0; 128];\n+    let mut ancillary2 = SocketAncillary::new(&mut ancillary2_buffer[..]);\n+\n+    let (usize, truncated) =\n+        or_panic!(bsock2.recv_vectored_with_ancillary(&mut bufs_recv, &mut ancillary2));\n+    assert_eq!(usize, 8);\n+    assert_eq!(truncated, false);\n+    assert_eq!(buf1, buf2);\n+\n+    let mut ancillary_data_vec = Vec::from_iter(ancillary2.messages());\n+    assert_eq!(ancillary_data_vec.len(), 1);\n+    if let AncillaryData::ScmRights(scm_rights) = ancillary_data_vec.pop().unwrap() {\n+        let fd_vec = Vec::from_iter(scm_rights);\n+        assert_eq!(fd_vec.len(), 1);\n+        unsafe {\n+            libc::close(fd_vec[0]);\n+        }\n+    } else {\n+        assert!(false);\n+    }\n+}"}, {"sha": "e067edd3774291e080381ccafd8a3f147ec1c0d5", "filename": "library/std/src/sys/unix/net.rs", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/0b3c9d84656a86cb3c57b20fff6bef5f8f2aeabb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3c9d84656a86cb3c57b20fff6bef5f8f2aeabb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs?ref=0b3c9d84656a86cb3c57b20fff6bef5f8f2aeabb", "patch": "@@ -1,8 +1,10 @@\n use crate::cmp;\n use crate::ffi::CStr;\n use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::marker::PhantomData;\n use crate::mem;\n use crate::net::{Shutdown, SocketAddr};\n+use crate::ptr::null_mut;\n use crate::str;\n use crate::sys::fd::FileDesc;\n use crate::sys_common::net::{getsockopt, setsockopt, sockaddr_to_addr};\n@@ -18,6 +20,86 @@ pub extern crate libc as netc;\n \n pub type wrlen_t = size_t;\n \n+pub struct AncillaryDataIter<'a, T> {\n+    data: &'a [u8],\n+    phantom: crate::marker::PhantomData<T>,\n+}\n+\n+impl<'a, T> AncillaryDataIter<'a, T> {\n+    pub fn new(data: &'a [u8]) -> AncillaryDataIter<'a, T> {\n+        AncillaryDataIter { data, phantom: PhantomData }\n+    }\n+}\n+\n+impl<'a, T> Iterator for AncillaryDataIter<'a, T> {\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        unsafe {\n+            let mut unit = mem::zeroed();\n+            if mem::size_of::<T>() <= self.data.len() {\n+                let unit_ptr: *mut T = &mut unit;\n+                libc::memcpy(unit_ptr.cast(), self.data.as_ptr().cast(), mem::size_of::<T>());\n+                self.data = &self.data[mem::size_of::<T>()..];\n+                Some(unit)\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+}\n+\n+pub fn add_to_ancillary_data<T: core::clone::Clone>(\n+    buffer: &mut [u8],\n+    length: &mut usize,\n+    source: &[T],\n+    cmsg_level: libc::c_int,\n+    cmsg_type: libc::c_int,\n+) -> bool {\n+    let len = (source.len() * mem::size_of::<T>()) as u32;\n+\n+    unsafe {\n+        let additional_space = libc::CMSG_SPACE(len) as usize;\n+        if *length + additional_space > buffer.len() {\n+            return false;\n+        }\n+\n+        libc::memset(buffer[*length..].as_mut_ptr().cast(), 0, additional_space);\n+\n+        *length += additional_space;\n+\n+        let msg = libc::msghdr {\n+            msg_name: null_mut(),\n+            msg_namelen: 0,\n+            msg_iov: null_mut(),\n+            msg_iovlen: 0,\n+            msg_control: buffer.as_mut_ptr().cast(),\n+            msg_controllen: *length,\n+            msg_flags: 0,\n+        };\n+\n+        let mut cmsg = libc::CMSG_FIRSTHDR(&msg);\n+        let mut previous_cmsg = cmsg;\n+        while !cmsg.is_null() {\n+            previous_cmsg = cmsg;\n+            cmsg = libc::CMSG_NXTHDR(&msg, cmsg);\n+        }\n+\n+        if previous_cmsg.is_null() {\n+            return false;\n+        }\n+\n+        (*previous_cmsg).cmsg_level = cmsg_level;\n+        (*previous_cmsg).cmsg_type = cmsg_type;\n+        (*previous_cmsg).cmsg_len = libc::CMSG_LEN(len) as usize;\n+\n+        let data = libc::CMSG_DATA(previous_cmsg).cast();\n+\n+        libc::memcpy(data, source.as_ptr().cast(), len as usize);\n+    }\n+    true\n+}\n+\n pub struct Socket(FileDesc);\n \n pub fn init() {}\n@@ -237,6 +319,11 @@ impl Socket {\n         self.recv_from_with_flags(buf, 0)\n     }\n \n+    pub fn recv_msg(&self, msg: &mut libc::msghdr) -> io::Result<usize> {\n+        let n = cvt(unsafe { libc::recvmsg(self.0.raw(), msg, libc::MSG_CMSG_CLOEXEC) })?;\n+        Ok(n as usize)\n+    }\n+\n     pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n         self.recv_from_with_flags(buf, MSG_PEEK)\n     }\n@@ -254,6 +341,11 @@ impl Socket {\n         self.0.is_write_vectored()\n     }\n \n+    pub fn send_msg(&self, msg: &mut libc::msghdr) -> io::Result<usize> {\n+        let n = cvt(unsafe { libc::sendmsg(self.0.raw(), msg, 0) })?;\n+        Ok(n as usize)\n+    }\n+\n     pub fn set_timeout(&self, dur: Option<Duration>, kind: libc::c_int) -> io::Result<()> {\n         let timeout = match dur {\n             Some(dur) => {"}]}