{"sha": "a62680d108b4045608bee4b7cf0e7f60c5337778", "node_id": "C_kwDOAAsO6NoAKGE2MjY4MGQxMDhiNDA0NTYwOGJlZTRiN2NmMGU3ZjYwYzUzMzc3Nzg", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-02-13T00:54:13Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-04-23T07:56:15Z"}, "message": "Drop vis in FieldDef.", "tree": {"sha": "78e002147fb6e449baf530a40b7818c5d3c99a96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78e002147fb6e449baf530a40b7818c5d3c99a96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a62680d108b4045608bee4b7cf0e7f60c5337778", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a62680d108b4045608bee4b7cf0e7f60c5337778", "html_url": "https://github.com/rust-lang/rust/commit/a62680d108b4045608bee4b7cf0e7f60c5337778", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a62680d108b4045608bee4b7cf0e7f60c5337778/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e8046f67ad688ae1deb30922e08a224d9964b1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e8046f67ad688ae1deb30922e08a224d9964b1e", "html_url": "https://github.com/rust-lang/rust/commit/4e8046f67ad688ae1deb30922e08a224d9964b1e"}], "stats": {"total": 142, "additions": 80, "deletions": 62}, "files": [{"sha": "15c2913c75469588d5224d5ca31d9dbbbe809f31", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a62680d108b4045608bee4b7cf0e7f60c5337778/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a62680d108b4045608bee4b7cf0e7f60c5337778/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=a62680d108b4045608bee4b7cf0e7f60c5337778", "patch": "@@ -851,7 +851,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // FIXME(jseyfried): positional field hygiene.\n                 None => Ident::new(sym::integer(index), self.lower_span(f.span)),\n             },\n-            vis: self.lower_visibility(&f.vis),\n+            vis_span: self.lower_span(f.vis.span),\n             ty,\n         }\n     }"}, {"sha": "d5ca81ef5960d9058bc05d1d8c92565fa7b5ceef", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a62680d108b4045608bee4b7cf0e7f60c5337778/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a62680d108b4045608bee4b7cf0e7f60c5337778/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=a62680d108b4045608bee4b7cf0e7f60c5337778", "patch": "@@ -2671,8 +2671,8 @@ impl VisibilityKind<'_> {\n #[derive(Debug, HashStable_Generic)]\n pub struct FieldDef<'hir> {\n     pub span: Span,\n+    pub vis_span: Span,\n     pub ident: Ident,\n-    pub vis: Visibility<'hir>,\n     pub hir_id: HirId,\n     pub ty: &'hir Ty<'hir>,\n }"}, {"sha": "99c0d50e27ad6db0e6ae35cf7be9e34a795494ac", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 36, "deletions": 39, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/a62680d108b4045608bee4b7cf0e7f60c5337778/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a62680d108b4045608bee4b7cf0e7f60c5337778/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=a62680d108b4045608bee4b7cf0e7f60c5337778", "patch": "@@ -1384,66 +1384,63 @@ impl UnreachablePub {\n         cx: &LateContext<'_>,\n         what: &str,\n         def_id: LocalDefId,\n-        vis: &hir::Visibility<'_>,\n-        span: Span,\n+        vis_span: Span,\n         exportable: bool,\n     ) {\n         let mut applicability = Applicability::MachineApplicable;\n-        match vis.node {\n-            hir::VisibilityKind::Public if !cx.access_levels.is_reachable(def_id) => {\n-                if span.from_expansion() {\n-                    applicability = Applicability::MaybeIncorrect;\n+        if !cx.access_levels.is_reachable(def_id) {\n+            if vis_span.from_expansion() {\n+                applicability = Applicability::MaybeIncorrect;\n+            }\n+            let def_span = cx.tcx.def_span(def_id);\n+            cx.struct_span_lint(UNREACHABLE_PUB, def_span, |lint| {\n+                let mut err = lint.build(&format!(\"unreachable `pub` {}\", what));\n+                let replacement = if cx.tcx.features().crate_visibility_modifier {\n+                    \"crate\"\n+                } else {\n+                    \"pub(crate)\"\n                 }\n-                let def_span = cx.tcx.sess.source_map().guess_head_span(span);\n-                cx.struct_span_lint(UNREACHABLE_PUB, def_span, |lint| {\n-                    let mut err = lint.build(&format!(\"unreachable `pub` {}\", what));\n-                    let replacement = if cx.tcx.features().crate_visibility_modifier {\n-                        \"crate\"\n-                    } else {\n-                        \"pub(crate)\"\n-                    }\n-                    .to_owned();\n+                .to_owned();\n \n-                    err.span_suggestion(\n-                        vis.span,\n-                        \"consider restricting its visibility\",\n-                        replacement,\n-                        applicability,\n-                    );\n-                    if exportable {\n-                        err.help(\"or consider exporting it for use by other crates\");\n-                    }\n-                    err.emit();\n-                });\n-            }\n-            _ => {}\n+                err.span_suggestion(\n+                    vis_span,\n+                    \"consider restricting its visibility\",\n+                    replacement,\n+                    applicability,\n+                );\n+                if exportable {\n+                    err.help(\"or consider exporting it for use by other crates\");\n+                }\n+                err.emit();\n+            });\n         }\n     }\n }\n \n impl<'tcx> LateLintPass<'tcx> for UnreachablePub {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-        self.perform_lint(cx, \"item\", item.def_id, &item.vis, item.span, true);\n+        if cx.tcx.visibility(item.def_id).is_public() {\n+            self.perform_lint(cx, \"item\", item.def_id, item.vis.span, true);\n+        }\n     }\n \n     fn check_foreign_item(&mut self, cx: &LateContext<'_>, foreign_item: &hir::ForeignItem<'tcx>) {\n-        self.perform_lint(\n-            cx,\n-            \"item\",\n-            foreign_item.def_id,\n-            &foreign_item.vis,\n-            foreign_item.span,\n-            true,\n-        );\n+        if cx.tcx.visibility(foreign_item.def_id).is_public() {\n+            self.perform_lint(cx, \"item\", foreign_item.def_id, foreign_item.vis.span, true);\n+        }\n     }\n \n     fn check_field_def(&mut self, cx: &LateContext<'_>, field: &hir::FieldDef<'_>) {\n         let def_id = cx.tcx.hir().local_def_id(field.hir_id);\n-        self.perform_lint(cx, \"field\", def_id, &field.vis, field.span, false);\n+        if cx.tcx.visibility(def_id).is_public() {\n+            self.perform_lint(cx, \"field\", def_id, field.vis_span, false);\n+        }\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'_>, impl_item: &hir::ImplItem<'_>) {\n-        self.perform_lint(cx, \"item\", impl_item.def_id, &impl_item.vis, impl_item.span, false);\n+        if cx.tcx.visibility(impl_item.def_id).is_public() {\n+            self.perform_lint(cx, \"item\", impl_item.def_id, impl_item.vis.span, false);\n+        }\n     }\n }\n "}, {"sha": "52583d5c2b2daf9b8bb6c444eed6745af34858a4", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a62680d108b4045608bee4b7cf0e7f60c5337778/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a62680d108b4045608bee4b7cf0e7f60c5337778/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=a62680d108b4045608bee4b7cf0e7f60c5337778", "patch": "@@ -354,14 +354,24 @@ impl<'tcx> Visitor<'tcx> for MarkSymbolVisitor<'tcx> {\n         _: hir::HirId,\n         _: rustc_span::Span,\n     ) {\n+        let tcx = self.tcx;\n         let has_repr_c = self.repr_has_repr_c;\n         let inherited_pub_visibility = self.inherited_pub_visibility;\n         let pub_visibility = self.pub_visibility;\n-        let live_fields = def.fields().iter().filter(|f| {\n-            has_repr_c || (pub_visibility && (inherited_pub_visibility || f.vis.node.is_pub()))\n+        let live_fields = def.fields().iter().filter_map(|f| {\n+            let def_id = tcx.hir().local_def_id(f.hir_id);\n+            if has_repr_c {\n+                return Some(def_id);\n+            }\n+            if !pub_visibility {\n+                return None;\n+            }\n+            if inherited_pub_visibility {\n+                return Some(def_id);\n+            }\n+            if tcx.visibility(def_id).is_public() { Some(def_id) } else { None }\n         });\n-        let hir = self.tcx.hir();\n-        self.live_symbols.extend(live_fields.map(|f| hir.local_def_id(f.hir_id)));\n+        self.live_symbols.extend(live_fields);\n \n         intravisit::walk_struct_def(self, def);\n     }"}, {"sha": "d2329d1779f0ab1eebc3b01d800bfc7a596863fa", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a62680d108b4045608bee4b7cf0e7f60c5337778/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a62680d108b4045608bee4b7cf0e7f60c5337778/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=a62680d108b4045608bee4b7cf0e7f60c5337778", "patch": "@@ -660,7 +660,9 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     self.update_with_hir_id(ctor_hir_id, item_level);\n                 }\n                 for field in def.fields() {\n-                    if field.vis.node.is_pub() {\n+                    let def_id = self.tcx.hir().local_def_id(field.hir_id);\n+                    let vis = self.tcx.visibility(def_id);\n+                    if vis.is_public() {\n                         self.update_with_hir_id(field.hir_id, item_level);\n                     }\n                 }\n@@ -1633,7 +1635,9 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_field_def(&mut self, s: &'tcx hir::FieldDef<'tcx>) {\n-        if s.vis.node.is_pub() || self.in_variant {\n+        let def_id = self.tcx.hir().local_def_id(s.hir_id);\n+        let vis = self.tcx.visibility(def_id);\n+        if vis.is_public() || self.in_variant {\n             intravisit::walk_field_def(self, s);\n         }\n     }"}, {"sha": "faf3c7cbcf7a8598b457605d3ef102d17a1c0bf1", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a62680d108b4045608bee4b7cf0e7f60c5337778/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a62680d108b4045608bee4b7cf0e7f60c5337778/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=a62680d108b4045608bee4b7cf0e7f60c5337778", "patch": "@@ -57,9 +57,9 @@ macro_rules! down_cast_data {\n }\n \n macro_rules! access_from {\n-    ($save_ctxt:expr, $item:expr, $id:expr) => {\n+    ($save_ctxt:expr, $id:expr) => {\n         Access {\n-            public: $item.vis.node.is_pub(),\n+            public: $save_ctxt.tcx.visibility($id).is_public(),\n             reachable: $save_ctxt.access_levels.is_reachable($id),\n         }\n     };\n@@ -302,7 +302,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         let field_data = self.save_ctxt.get_field_data(field, parent_id);\n         if let Some(field_data) = field_data {\n             self.dumper.dump_def(\n-                &access_from!(self.save_ctxt, field, self.tcx.hir().local_def_id(field.hir_id)),\n+                &access_from!(self.save_ctxt, self.tcx.hir().local_def_id(field.hir_id)),\n                 field_data,\n             );\n         }\n@@ -369,7 +369,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 v.process_formals(body.params, &fn_data.qualname);\n                 v.process_generic_params(ty_params, &fn_data.qualname, item.hir_id());\n \n-                v.dumper.dump_def(&access_from!(v.save_ctxt, item, item.def_id), fn_data);\n+                v.dumper.dump_def(&access_from!(v.save_ctxt, item.def_id), fn_data);\n             }\n \n             for arg in decl.inputs {\n@@ -393,7 +393,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         self.nest_typeck_results(item.def_id, |v| {\n             if let Some(var_data) = v.save_ctxt.get_item_data(item) {\n                 down_cast_data!(var_data, DefData, item.span);\n-                v.dumper.dump_def(&access_from!(v.save_ctxt, item, item.def_id), var_data);\n+                v.dumper.dump_def(&access_from!(v.save_ctxt, item.def_id), var_data);\n             }\n             v.visit_ty(&typ);\n             v.visit_expr(expr);\n@@ -469,7 +469,11 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 let fields_str = fields\n                     .iter()\n                     .filter_map(|f| {\n-                        if include_priv_fields || f.vis.node.is_pub() {\n+                        if include_priv_fields {\n+                            return Some(f.ident.to_string());\n+                        }\n+                        let def_id = self.save_ctxt.tcx.hir().local_def_id(f.hir_id);\n+                        if self.save_ctxt.tcx.visibility(def_id).is_public() {\n                             Some(f.ident.to_string())\n                         } else {\n                             None\n@@ -487,7 +491,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n             let span = self.span_from_span(item.ident.span);\n             let attrs = self.tcx.hir().attrs(item.hir_id());\n             self.dumper.dump_def(\n-                &access_from!(self.save_ctxt, item, item.def_id),\n+                &access_from!(self.save_ctxt, item.def_id),\n                 Def {\n                     kind,\n                     id: id_from_def_id(item.def_id.to_def_id()),\n@@ -527,7 +531,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         };\n         down_cast_data!(enum_data, DefData, item.span);\n \n-        let access = access_from!(self.save_ctxt, item, item.def_id);\n+        let access = access_from!(self.save_ctxt, item.def_id);\n \n         for variant in enum_definition.variants {\n             let name = variant.ident.name.to_string();\n@@ -662,7 +666,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 methods.iter().map(|i| id_from_def_id(i.id.def_id.to_def_id())).collect();\n             let attrs = self.tcx.hir().attrs(item.hir_id());\n             self.dumper.dump_def(\n-                &access_from!(self.save_ctxt, item, item.def_id),\n+                &access_from!(self.save_ctxt, item.def_id),\n                 Def {\n                     kind: DefKind::Trait,\n                     id,\n@@ -724,7 +728,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n     fn process_mod(&mut self, item: &'tcx hir::Item<'tcx>) {\n         if let Some(mod_data) = self.save_ctxt.get_item_data(item) {\n             down_cast_data!(mod_data, DefData, item.span);\n-            self.dumper.dump_def(&access_from!(self.save_ctxt, item, item.def_id), mod_data);\n+            self.dumper.dump_def(&access_from!(self.save_ctxt, item.def_id), mod_data);\n         }\n     }\n \n@@ -1147,7 +1151,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n             hir::ItemKind::Use(path, hir::UseKind::Single) => {\n                 let sub_span = path.segments.last().unwrap().ident.span;\n                 if !self.span.filter_generated(sub_span) {\n-                    let access = access_from!(self.save_ctxt, item, item.def_id);\n+                    let access = access_from!(self.save_ctxt, item.def_id);\n                     let ref_id = self.lookup_def_id(item.hir_id()).map(id_from_def_id);\n                     let span = self.span_from_span(sub_span);\n                     let parent =\n@@ -1176,7 +1180,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n                 // we don't want to track anyway, since it's probably macro-internal `use`\n                 if let Some(sub_span) = self.span.sub_span_of_star(item.span) {\n                     if !self.span.filter_generated(item.span) {\n-                        let access = access_from!(self.save_ctxt, item, item.def_id);\n+                        let access = access_from!(self.save_ctxt, item.def_id);\n                         let span = self.span_from_span(sub_span);\n                         let parent =\n                             self.save_ctxt.tcx.parent(item.def_id.to_def_id()).map(id_from_def_id);\n@@ -1249,7 +1253,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n                     let attrs = self.tcx.hir().attrs(item.hir_id());\n \n                     self.dumper.dump_def(\n-                        &access_from!(self.save_ctxt, item, item.def_id),\n+                        &access_from!(self.save_ctxt, item.def_id),\n                         Def {\n                             kind: DefKind::Type,\n                             id,\n@@ -1443,7 +1447,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n-        let access = access_from!(self.save_ctxt, item, item.def_id);\n+        let access = access_from!(self.save_ctxt, item.def_id);\n \n         match item.kind {\n             hir::ForeignItemKind::Fn(decl, _, ref generics) => {"}, {"sha": "173d41b4b05060b7794a9cbac5432ace09c817c0", "filename": "src/tools/clippy/clippy_lints/src/exhaustive_items.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a62680d108b4045608bee4b7cf0e7f60c5337778/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexhaustive_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a62680d108b4045608bee4b7cf0e7f60c5337778/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexhaustive_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexhaustive_items.rs?ref=a62680d108b4045608bee4b7cf0e7f60c5337778", "patch": "@@ -78,7 +78,10 @@ impl LateLintPass<'_> for ExhaustiveItems {\n             if !attrs.iter().any(|a| a.has_name(sym::non_exhaustive));\n             then {\n                 let (lint, msg) = if let ItemKind::Struct(ref v, ..) = item.kind {\n-                    if v.fields().iter().any(|f| !f.vis.node.is_pub()) {\n+                    if v.fields().iter().any(|f| {\n+                        let def_id = cx.tcx.hir().local_def_id(f.hir_id);\n+                        !cx.tcx.visibility(def_id).is_public()\n+                    }) {\n                         // skip structs with private fields\n                         return;\n                     }"}]}