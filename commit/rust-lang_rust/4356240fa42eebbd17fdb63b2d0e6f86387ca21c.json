{"sha": "4356240fa42eebbd17fdb63b2d0e6f86387ca21c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzNTYyNDBmYTQyZWViYmQxN2ZkYjYzYjJkMGU2Zjg2Mzg3Y2EyMWM=", "commit": {"author": {"name": "darksv", "email": "darek969-12@o2.pl", "date": "2018-09-13T21:25:05Z"}, "committer": {"name": "darksv", "email": "darek969-12@o2.pl", "date": "2018-09-13T21:25:05Z"}, "message": "Incremental reparsing for single tokens (WHITESPACE, COMMENT, DOC_COMMENT, IDENT, STRING, RAW_STRING)", "tree": {"sha": "96785c930199eac49a9f48cd1d9c67f0f7c1dc4f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96785c930199eac49a9f48cd1d9c67f0f7c1dc4f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4356240fa42eebbd17fdb63b2d0e6f86387ca21c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4356240fa42eebbd17fdb63b2d0e6f86387ca21c", "html_url": "https://github.com/rust-lang/rust/commit/4356240fa42eebbd17fdb63b2d0e6f86387ca21c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4356240fa42eebbd17fdb63b2d0e6f86387ca21c/comments", "author": {"login": "darksv", "id": 6718130, "node_id": "MDQ6VXNlcjY3MTgxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/6718130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/darksv", "html_url": "https://github.com/darksv", "followers_url": "https://api.github.com/users/darksv/followers", "following_url": "https://api.github.com/users/darksv/following{/other_user}", "gists_url": "https://api.github.com/users/darksv/gists{/gist_id}", "starred_url": "https://api.github.com/users/darksv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/darksv/subscriptions", "organizations_url": "https://api.github.com/users/darksv/orgs", "repos_url": "https://api.github.com/users/darksv/repos", "events_url": "https://api.github.com/users/darksv/events{/privacy}", "received_events_url": "https://api.github.com/users/darksv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "darksv", "id": 6718130, "node_id": "MDQ6VXNlcjY3MTgxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/6718130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/darksv", "html_url": "https://github.com/darksv", "followers_url": "https://api.github.com/users/darksv/followers", "following_url": "https://api.github.com/users/darksv/following{/other_user}", "gists_url": "https://api.github.com/users/darksv/gists{/gist_id}", "starred_url": "https://api.github.com/users/darksv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/darksv/subscriptions", "organizations_url": "https://api.github.com/users/darksv/orgs", "repos_url": "https://api.github.com/users/darksv/repos", "events_url": "https://api.github.com/users/darksv/events{/privacy}", "received_events_url": "https://api.github.com/users/darksv/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6f8037a6f8fbcb4f127e1d2b518279650b1f5ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6f8037a6f8fbcb4f127e1d2b518279650b1f5ea", "html_url": "https://github.com/rust-lang/rust/commit/b6f8037a6f8fbcb4f127e1d2b518279650b1f5ea"}], "stats": {"total": 136, "additions": 122, "deletions": 14}, "files": [{"sha": "bae685fb44178e942ca91b1ac42ab0a0e6e5872d", "filename": "crates/libsyntax2/src/lib.rs", "status": "modified", "additions": 67, "deletions": 13, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/4356240fa42eebbd17fdb63b2d0e6f86387ca21c/crates%2Flibsyntax2%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4356240fa42eebbd17fdb63b2d0e6f86387ca21c/crates%2Flibsyntax2%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Flib.rs?ref=4356240fa42eebbd17fdb63b2d0e6f86387ca21c", "patch": "@@ -82,22 +82,68 @@ impl File {\n         self.incremental_reparse(edit).unwrap_or_else(|| self.full_reparse(edit))\n     }\n     pub fn incremental_reparse(&self, edit: &AtomEdit) -> Option<File> {\n+        let (node, green, new_errors) =\n+            self.reparse_leaf(&edit).or_else(|| self.reparse_block(&edit))?;\n+\n+        let green_root = node.replace_with(green);\n+        let errors = merge_errors(self.errors(), new_errors, node, edit);\n+        Some(File::new(green_root, errors))\n+    }\n+    fn reparse_leaf(&self, edit: &AtomEdit) -> Option<(SyntaxNodeRef, GreenNode, Vec<SyntaxError>)> {\n+        let node = algo::find_covering_node(self.syntax(), edit.delete);\n+        match node.kind() {\n+            | WHITESPACE\n+            | COMMENT\n+            | DOC_COMMENT\n+            | IDENT\n+            | STRING\n+            | RAW_STRING => {\n+                let text = get_text_after_edit(node, &edit);\n+                let tokens = tokenize(&text);\n+                if tokens.len() != 1 || tokens[0].kind != node.kind() {\n+                    return None;\n+                }\n+\n+                let reparser: fn(&mut Parser) = if node.kind().is_trivia() {\n+                    // since trivia is omitted by parser when it doesn't have a parent, \\\n+                    // we need to create one for it\n+                    |p| {\n+                        p.start().complete(p, ROOT);\n+                    }\n+                } else {\n+                    |p| {\n+                        p.bump();\n+                    }\n+                };\n+\n+                let (green, new_errors) =\n+                    parser_impl::parse_with::<yellow::GreenBuilder>(\n+                        &text, &tokens, reparser,\n+                    );\n+\n+                let green = if node.kind().is_trivia() {\n+                    green.children().first().cloned().unwrap()\n+                } else {\n+                    green\n+                };\n+\n+                Some((node, green, new_errors))\n+            },\n+            _ => None,\n+        }\n+    }\n+    fn reparse_block(&self, edit: &AtomEdit) -> Option<(SyntaxNodeRef, GreenNode, Vec<SyntaxError>)> {\n         let (node, reparser) = find_reparsable_node(self.syntax(), edit.delete)?;\n-        let text = replace_range(\n-            node.text().to_string(),\n-            edit.delete - node.range().start(),\n-            &edit.insert,\n-        );\n+        let text = get_text_after_edit(node, &edit);\n         let tokens = tokenize(&text);\n         if !is_balanced(&tokens) {\n             return None;\n         }\n-        let (green, new_errors) = parser_impl::parse_with::<yellow::GreenBuilder>(\n-            &text, &tokens, reparser,\n-        );\n-        let green_root = node.replace_with(green);\n-        let errors = merge_errors(self.errors(), new_errors, node, edit);\n-        Some(File::new(green_root, errors))\n+        let (green, new_errors) =\n+            parser_impl::parse_with::<yellow::GreenBuilder>(\n+                &text, &tokens, reparser,\n+            );\n+        Some((node, green, new_errors))\n     }\n     fn full_reparse(&self, edit: &AtomEdit) -> File {\n         let text = replace_range(self.syntax().text().to_string(), edit.delete, &edit.insert);\n@@ -134,6 +180,14 @@ impl AtomEdit {\n     }\n }\n \n+fn get_text_after_edit(node: SyntaxNodeRef, edit: &AtomEdit) -> String {\n+    replace_range(\n+        node.text().to_string(),\n+        edit.delete - node.range().start(),\n+        &edit.insert,\n+    )\n+}\n+\n fn find_reparsable_node(node: SyntaxNodeRef, range: TextRange) -> Option<(SyntaxNodeRef, fn(&mut Parser))> {\n     let node = algo::find_covering_node(node, range);\n     return algo::ancestors(node)\n@@ -200,9 +254,9 @@ fn merge_errors(\n ) -> Vec<SyntaxError> {\n     let mut res = Vec::new();\n     for e in old_errors {\n-        if e.offset < old_node.range().start() {\n+        if e.offset <= old_node.range().start() {\n             res.push(e)\n-        } else if e.offset > old_node.range().end() {\n+        } else if e.offset >= old_node.range().end() {\n             res.push(SyntaxError {\n                 msg: e.msg,\n                 offset: e.offset + TextUnit::of_str(&edit.insert) - edit.delete.len(),"}, {"sha": "ce7e075f8683238c3c8cfd867e2bbc8d4eccc48a", "filename": "crates/libsyntax2/tests/test/main.rs", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/4356240fa42eebbd17fdb63b2d0e6f86387ca21c/crates%2Flibsyntax2%2Ftests%2Ftest%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4356240fa42eebbd17fdb63b2d0e6f86387ca21c/crates%2Flibsyntax2%2Ftests%2Ftest%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Ftests%2Ftest%2Fmain.rs?ref=4356240fa42eebbd17fdb63b2d0e6f86387ca21c", "patch": "@@ -33,7 +33,7 @@ fn reparse_test() {\n         let incrementally_reparsed = {\n             let f = File::parse(&before);\n             let edit = AtomEdit { delete: range, insert: replace_with.to_string() };\n-            f.incremental_reparse(&edit).unwrap()\n+            f.incremental_reparse(&edit).expect(\"cannot incrementally reparse\")\n         };\n         assert_eq_text!(\n             &dump_tree(fully_reparsed.syntax()),\n@@ -45,6 +45,11 @@ fn reparse_test() {\n fn foo() {\n     let x = foo + <|>bar<|>\n }\n+\", \"baz\");\n+    do_check(r\"\n+fn foo() {\n+    let x = foo<|> + bar<|>\n+}\n \", \"baz\");\n     do_check(r\"\n struct Foo {\n@@ -67,6 +72,11 @@ mod foo {\n trait Foo {\n     type <|>Foo<|>;\n }\n+\", \"Output\");\n+    do_check(r\"\n+trait Foo {\n+    type<|> Foo<|>;\n+}\n \", \"Output\");\n     do_check(r\"\n impl IntoIterator<Item=i32> for Foo {\n@@ -94,6 +104,50 @@ extern {\n     fn<|>;<|>\n }\n \", \" exit(code: c_int)\");\n+do_check(r\"<|><|>\n+fn foo() -> i32 {\n+    1\n+}\n+\", \"\\n\\n\\n   \\n\");\n+    do_check(r\"\n+fn foo() -> <|><|> {}\n+\", \"  \\n\");\n+    do_check(r\"\n+fn <|>foo<|>() -> i32 {\n+    1\n+}\n+\", \"bar\");\n+do_check(r\"\n+fn aa<|><|>bb() {\n+\n+}\n+\", \"foofoo\");\n+    do_check(r\"\n+fn aabb /* <|><|> */ () {\n+\n+}\n+\", \"some comment\");\n+    do_check(r\"\n+fn aabb <|><|> () {\n+\n+}\n+\", \"    \\t\\t\\n\\n\");\n+    do_check(r\"\n+trait foo {\n+// comment <|><|>\n+}\n+\", \"\\n\");\n+    do_check(r\"\n+/// good <|><|>omment\n+mod {\n+}\n+\", \"c\");\n+    do_check(r#\"\n+fn -> &str { \"Hello<|><|>\" }\n+\"#, \", world\");\n+    do_check(r#\"\n+fn -> &str { // \"Hello<|><|>\"\n+\"#, \", world\");\n }\n \n #[test]"}]}