{"sha": "b75b21cb9b187a6f836da61769a8110354fd6dad", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3NWIyMWNiOWIxODdhNmY4MzZkYTYxNzY5YTgxMTAzNTRmZDZkYWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-06T19:49:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-06T19:49:31Z"}, "message": "Auto merge of #21926 - mzabaluev:raw-lifetime, r=alexcrichton\n\nNew functions, `slice::from_raw_parts` and `slice::from_raw_parts_mut`,\r\nare added to implement the lifetime convention as agreed in rust-lang/rfcs#556.\r\nThe functions `slice::from_raw_buf` and `slice::from_raw_mut_buf` are\r\nleft deprecated for the time being.\r\n\r\nHolding back on changing the signature of `std::ffi::c_str_to_bytes` as consensus in rust-lang/rfcs#592 is building to replace it with a composition of other functions.\r\n\r\nContribution to #21923.", "tree": {"sha": "06731acb2c054b0d541b8dbdfe39bdffad7dfc47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06731acb2c054b0d541b8dbdfe39bdffad7dfc47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b75b21cb9b187a6f836da61769a8110354fd6dad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b75b21cb9b187a6f836da61769a8110354fd6dad", "html_url": "https://github.com/rust-lang/rust/commit/b75b21cb9b187a6f836da61769a8110354fd6dad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b75b21cb9b187a6f836da61769a8110354fd6dad/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7884eb8e2ff8f0796a95aa0216e69241934ce14f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7884eb8e2ff8f0796a95aa0216e69241934ce14f", "html_url": "https://github.com/rust-lang/rust/commit/7884eb8e2ff8f0796a95aa0216e69241934ce14f"}, {"sha": "fb6b970bf8d12182a69b1e7ae222f3e2ebbb9003", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb6b970bf8d12182a69b1e7ae222f3e2ebbb9003", "html_url": "https://github.com/rust-lang/rust/commit/fb6b970bf8d12182a69b1e7ae222f3e2ebbb9003"}], "stats": {"total": 114, "additions": 82, "deletions": 32}, "files": [{"sha": "1bfa07afce3176ee2d6c6c8405fedfdfa3067f3f", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b75b21cb9b187a6f836da61769a8110354fd6dad/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b21cb9b187a6f836da61769a8110354fd6dad/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=b75b21cb9b187a6f836da61769a8110354fd6dad", "patch": "@@ -113,6 +113,7 @@ pub use core::slice::{Iter, IterMut};\n pub use core::slice::{IntSliceExt, SplitMut, ChunksMut, Split};\n pub use core::slice::{SplitN, RSplitN, SplitNMut, RSplitNMut};\n pub use core::slice::{bytes, mut_ref_slice, ref_slice};\n+pub use core::slice::{from_raw_parts, from_raw_parts_mut};\n pub use core::slice::{from_raw_buf, from_raw_mut_buf};\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "c622baa0cc22dbedef32747ddf377002cf74e63e", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 52, "deletions": 4, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b75b21cb9b187a6f836da61769a8110354fd6dad/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b21cb9b187a6f836da61769a8110354fd6dad/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=b75b21cb9b187a6f836da61769a8110354fd6dad", "patch": "@@ -1357,6 +1357,52 @@ pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n     }\n }\n \n+/// Forms a slice from a pointer and a length.\n+///\n+/// The `len` argument is the number of **elements**, not the number of bytes.\n+///\n+/// This function is unsafe as there is no guarantee that the given pointer is\n+/// valid for `len` elements, nor whether the lifetime inferred is a suitable\n+/// lifetime for the returned slice.\n+///\n+/// # Caveat\n+///\n+/// The lifetime for the returned slice is inferred from its usage. To\n+/// prevent accidental misuse, it's suggested to tie the lifetime to whichever\n+/// source lifetime is safe in the context, such as by providing a helper\n+/// function taking the lifetime of a host value for the slice, or by explicit\n+/// annotation.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::slice;\n+///\n+/// // manifest a slice out of thin air!\n+/// let ptr = 0x1234 as *const uint;\n+/// let amt = 10;\n+/// unsafe {\n+///     let slice = slice::from_raw_parts(ptr, amt);\n+/// }\n+/// ```\n+#[inline]\n+#[unstable(feature = \"core\")]\n+pub unsafe fn from_raw_parts<'a, T>(p: *const T, len: uint) -> &'a [T] {\n+    transmute(RawSlice { data: p, len: len })\n+}\n+\n+/// Performs the same functionality as `from_raw_parts`, except that a mutable\n+/// slice is returned.\n+///\n+/// This function is unsafe for the same reasons as `from_raw_parts`, as well\n+/// as not being able to provide a non-aliasing guarantee of the returned\n+/// mutable slice.\n+#[inline]\n+#[unstable(feature = \"core\")]\n+pub unsafe fn from_raw_parts_mut<'a, T>(p: *mut T, len: uint) -> &'a mut [T] {\n+    transmute(RawSlice { data: p, len: len })\n+}\n+\n /// Forms a slice from a pointer and a length.\n ///\n /// The pointer given is actually a reference to the base of the slice. This\n@@ -1383,8 +1429,9 @@ pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n /// }\n /// ```\n #[inline]\n-#[unstable(feature = \"core\",\n-           reason = \"should be renamed to from_raw_parts\")]\n+#[unstable(feature = \"core\")]\n+#[deprecated(since = \"1.0.0\",\n+             reason = \"use from_raw_parts\")]\n pub unsafe fn from_raw_buf<'a, T>(p: &'a *const T, len: uint) -> &'a [T] {\n     transmute(RawSlice { data: *p, len: len })\n }\n@@ -1396,8 +1443,9 @@ pub unsafe fn from_raw_buf<'a, T>(p: &'a *const T, len: uint) -> &'a [T] {\n /// not being able to provide a non-aliasing guarantee of the returned mutable\n /// slice.\n #[inline]\n-#[unstable(feature = \"core\",\n-           reason = \"should be renamed to from_raw_parts_mut\")]\n+#[unstable(feature = \"core\")]\n+#[deprecated(since = \"1.0.0\",\n+             reason = \"use from_raw_parts_mut\")]\n pub unsafe fn from_raw_mut_buf<'a, T>(p: &'a *mut T, len: uint) -> &'a mut [T] {\n     transmute(RawSlice { data: *p, len: len })\n }"}, {"sha": "a81b8777af40281197e7732a225918f72c99cfa1", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b21cb9b187a6f836da61769a8110354fd6dad/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b21cb9b187a6f836da61769a8110354fd6dad/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=b75b21cb9b187a6f836da61769a8110354fd6dad", "patch": "@@ -45,7 +45,7 @@ pub struct Bytes {\n impl Deref for Bytes {\n     type Target = [u8];\n     fn deref(&self) -> &[u8] {\n-        unsafe { slice::from_raw_mut_buf(&self.ptr.0, self.len) }\n+        unsafe { slice::from_raw_parts_mut(self.ptr.0, self.len) }\n     }\n }\n "}, {"sha": "f15523fc010b61118d77eaac322844de6cdb5d6b", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b75b21cb9b187a6f836da61769a8110354fd6dad/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b21cb9b187a6f836da61769a8110354fd6dad/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=b75b21cb9b187a6f836da61769a8110354fd6dad", "patch": "@@ -246,7 +246,7 @@ impl Rand for IsaacRng {\n         unsafe {\n             let ptr = ret.rsl.as_mut_ptr() as *mut u8;\n \n-            let slice = slice::from_raw_mut_buf(&ptr, (RAND_SIZE * 4) as uint);\n+            let slice = slice::from_raw_parts_mut(ptr, (RAND_SIZE * 4) as uint);\n             other.fill_bytes(slice);\n         }\n         ret.cnt = 0;\n@@ -489,7 +489,7 @@ impl Rand for Isaac64Rng {\n         unsafe {\n             let ptr = ret.rsl.as_mut_ptr() as *mut u8;\n \n-            let slice = slice::from_raw_mut_buf(&ptr, (RAND_SIZE_64 * 8) as uint);\n+            let slice = slice::from_raw_parts_mut(ptr, (RAND_SIZE_64 * 8) as uint);\n             other.fill_bytes(slice);\n         }\n         ret.cnt = 0;"}, {"sha": "206cdf6c5e30891ed958e03b1f4282f91b9a7510", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b75b21cb9b187a6f836da61769a8110354fd6dad/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b21cb9b187a6f836da61769a8110354fd6dad/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=b75b21cb9b187a6f836da61769a8110354fd6dad", "patch": "@@ -744,8 +744,8 @@ fn get_metadata_section_imp(is_osx: bool, filename: &Path) -> Result<MetadataBlo\n         while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n             let mut name_buf = ptr::null();\n             let name_len = llvm::LLVMRustGetSectionName(si.llsi, &mut name_buf);\n-            let name = slice::from_raw_buf(&(name_buf as *const u8),\n-                                           name_len as uint).to_vec();\n+            let name = slice::from_raw_parts(name_buf as *const u8,\n+                                             name_len as uint).to_vec();\n             let name = String::from_utf8(name).unwrap();\n             debug!(\"get_metadata_section: name {}\", name);\n             if read_meta_section_name(is_osx) == name {\n@@ -756,7 +756,7 @@ fn get_metadata_section_imp(is_osx: bool, filename: &Path) -> Result<MetadataBlo\n                 debug!(\"checking {} bytes of metadata-version stamp\",\n                        vlen);\n                 let minsz = cmp::min(vlen, csz);\n-                let buf0 = slice::from_raw_buf(&cvbuf, minsz);\n+                let buf0 = slice::from_raw_parts(cvbuf, minsz);\n                 let version_ok = buf0 == encoder::metadata_encoding_version;\n                 if !version_ok {\n                     return Err((format!(\"incompatible metadata version found: '{}'\",\n@@ -766,7 +766,7 @@ fn get_metadata_section_imp(is_osx: bool, filename: &Path) -> Result<MetadataBlo\n                 let cvbuf1 = cvbuf.offset(vlen as int);\n                 debug!(\"inflating {} bytes of compressed metadata\",\n                        csz - vlen);\n-                let bytes = slice::from_raw_buf(&cvbuf1, csz-vlen);\n+                let bytes = slice::from_raw_parts(cvbuf1, csz - vlen);\n                 match flate::inflate_bytes(bytes) {\n                     Some(inflated) => return Ok(MetadataVec(inflated)),\n                     None => {}"}, {"sha": "c513fe2e8eb3cf2b44056a6d1395cf5669aa1cd2", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b75b21cb9b187a6f836da61769a8110354fd6dad/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b21cb9b187a6f836da61769a8110354fd6dad/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=b75b21cb9b187a6f836da61769a8110354fd6dad", "patch": "@@ -165,6 +165,13 @@ extern {\n \n }\n \n+// hoedown_buffer helpers\n+impl hoedown_buffer {\n+    fn as_bytes(&self) -> &[u8] {\n+        unsafe { slice::from_raw_parts(self.data, self.size as usize) }\n+    }\n+}\n+\n /// Returns Some(code) if `s` is a line that should be stripped from\n /// documentation but used in example code. `code` is the portion of\n /// `s` that should be used in tests. (None for lines that should be\n@@ -194,15 +201,13 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n \n             let opaque = opaque as *mut hoedown_html_renderer_state;\n             let my_opaque: &MyOpaque = &*((*opaque).opaque as *const MyOpaque);\n-            let text = slice::from_raw_buf(&(*orig_text).data,\n-                                           (*orig_text).size as uint);\n+            let text = (*orig_text).as_bytes();\n             let origtext = str::from_utf8(text).unwrap();\n             debug!(\"docblock: ==============\\n{:?}\\n=======\", text);\n             let rendered = if lang.is_null() {\n                 false\n             } else {\n-                let rlang = slice::from_raw_buf(&(*lang).data,\n-                                                (*lang).size as uint);\n+                let rlang = (*lang).as_bytes();\n                 let rlang = str::from_utf8(rlang).unwrap();\n                 if !LangString::parse(rlang).rust {\n                     (my_opaque.dfltblk)(ob, orig_text, lang,\n@@ -246,9 +251,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n         let s = if text.is_null() {\n             \"\".to_string()\n         } else {\n-            let s = unsafe {\n-                slice::from_raw_buf(&(*text).data, (*text).size as uint)\n-            };\n+            let s = unsafe { (*text).as_bytes() };\n             str::from_utf8(s).unwrap().to_string()\n         };\n \n@@ -321,7 +324,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n         };\n \n         if ret.is_ok() {\n-            let buf = slice::from_raw_buf(&(*ob).data, (*ob).size as uint);\n+            let buf = (*ob).as_bytes();\n             ret = w.write_str(str::from_utf8(buf).unwrap());\n         }\n         hoedown_buffer_free(ob);\n@@ -339,13 +342,12 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n             let block_info = if lang.is_null() {\n                 LangString::all_false()\n             } else {\n-                let lang = slice::from_raw_buf(&(*lang).data,\n-                                               (*lang).size as uint);\n+                let lang = (*lang).as_bytes();\n                 let s = str::from_utf8(lang).unwrap();\n                 LangString::parse(s)\n             };\n             if !block_info.rust { return }\n-            let text = slice::from_raw_buf(&(*text).data, (*text).size as uint);\n+            let text = (*text).as_bytes();\n             let opaque = opaque as *mut hoedown_html_renderer_state;\n             let tests = &mut *((*opaque).opaque as *mut ::test::Collector);\n             let text = str::from_utf8(text).unwrap();\n@@ -368,7 +370,7 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n             if text.is_null() {\n                 tests.register_header(\"\", level as u32);\n             } else {\n-                let text = slice::from_raw_buf(&(*text).data, (*text).size as uint);\n+                let text = (*text).as_bytes();\n                 let text = str::from_utf8(text).unwrap();\n                 tests.register_header(text, level as u32);\n             }\n@@ -508,7 +510,7 @@ pub fn plain_summary_line(md: &str) -> String {\n         hoedown_document_render(document, ob, md.as_ptr(),\n                                 md.len() as libc::size_t);\n         hoedown_document_free(document);\n-        let plain_slice = slice::from_raw_buf(&(*ob).data, (*ob).size as uint);\n+        let plain_slice = (*ob).as_bytes();\n         let plain = match str::from_utf8(plain_slice) {\n             Ok(s) => s.to_string(),\n             Err(_) => \"\".to_string(),"}, {"sha": "45089176cba961b97e285456ad2346e2e4787b9d", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b75b21cb9b187a6f836da61769a8110354fd6dad/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b21cb9b187a6f836da61769a8110354fd6dad/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=b75b21cb9b187a6f836da61769a8110354fd6dad", "patch": "@@ -162,7 +162,7 @@ impl fmt::Debug for CString {\n /// ```\n pub unsafe fn c_str_to_bytes<'a>(raw: &'a *const libc::c_char) -> &'a [u8] {\n     let len = libc::strlen(*raw);\n-    slice::from_raw_buf(&*(raw as *const _ as *const *const u8), len as uint)\n+    slice::from_raw_parts(*(raw as *const _ as *const *const u8), len as usize)\n }\n \n /// Interpret a C string as a byte slice with the nul terminator.\n@@ -171,7 +171,7 @@ pub unsafe fn c_str_to_bytes<'a>(raw: &'a *const libc::c_char) -> &'a [u8] {\n /// will include the nul terminator of the string.\n pub unsafe fn c_str_to_bytes_with_nul<'a>(raw: &'a *const libc::c_char) -> &'a [u8] {\n     let len = libc::strlen(*raw) + 1;\n-    slice::from_raw_buf(&*(raw as *const _ as *const *const u8), len as uint)\n+    slice::from_raw_parts(*(raw as *const _ as *const *const u8), len as usize)\n }\n \n #[cfg(test)]"}, {"sha": "419bee1a624d3446b5724b1836b1d21157f089ba", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b75b21cb9b187a6f836da61769a8110354fd6dad/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b21cb9b187a6f836da61769a8110354fd6dad/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=b75b21cb9b187a6f836da61769a8110354fd6dad", "patch": "@@ -24,7 +24,6 @@ use error::Error as StdError;\n use fmt;\n use iter::Iterator;\n use marker::Sized;\n-use mem;\n use ops::{Drop, FnOnce};\n use option::Option::{self, Some, None};\n use ptr::PtrExt;\n@@ -69,8 +68,8 @@ fn with_end_to_cap<F>(v: &mut Vec<u8>, f: F) -> Result<usize>\n     unsafe {\n         let n = try!(f({\n             let base = v.as_mut_ptr().offset(v.len() as isize);\n-            black_box(slice::from_raw_mut_buf(mem::copy_lifetime(v, &base),\n-                                              v.capacity() - v.len()))\n+            black_box(slice::from_raw_parts_mut(base,\n+                                                v.capacity() - v.len()))\n         }));\n \n         // If the closure (typically a `read` implementation) reported that it"}, {"sha": "093a0695f62e593260a207a27aa7d48d387d0779", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b21cb9b187a6f836da61769a8110354fd6dad/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b21cb9b187a6f836da61769a8110354fd6dad/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=b75b21cb9b187a6f836da61769a8110354fd6dad", "patch": "@@ -671,7 +671,7 @@ fn real_args() -> Vec<String> {\n \n         // Push it onto the list.\n         let ptr = ptr as *const u16;\n-        let buf = slice::from_raw_buf(&ptr, len);\n+        let buf = slice::from_raw_parts(ptr, len);\n         let opt_s = String::from_utf16(sys::truncate_utf16_at_nul(buf));\n         opt_s.ok().expect(\"CommandLineToArgvW returned invalid UTF-16\")\n     }).collect();"}, {"sha": "d8e3e6981df76e3f4a2299825afdd40a3c72305e", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b75b21cb9b187a6f836da61769a8110354fd6dad/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b21cb9b187a6f836da61769a8110354fd6dad/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=b75b21cb9b187a6f836da61769a8110354fd6dad", "patch": "@@ -109,7 +109,7 @@ impl Iterator for Env {\n                 len += 1;\n             }\n             let p = p as *const u16;\n-            let s = slice::from_raw_buf(&p, len as usize);\n+            let s = slice::from_raw_parts(p, len as usize);\n             self.cur = self.cur.offset(len + 1);\n \n             let (k, v) = match s.iter().position(|&b| b == '=' as u16) {\n@@ -296,7 +296,7 @@ impl Iterator for Args {\n \n             // Push it onto the list.\n             let ptr = ptr as *const u16;\n-            let buf = slice::from_raw_buf(&ptr, len as usize);\n+            let buf = slice::from_raw_parts(ptr, len as usize);\n             OsStringExt::from_wide(buf)\n         })\n     }"}]}