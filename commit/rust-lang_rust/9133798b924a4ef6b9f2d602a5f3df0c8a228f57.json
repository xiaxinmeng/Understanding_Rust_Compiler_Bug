{"sha": "9133798b924a4ef6b9f2d602a5f3df0c8a228f57", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxMzM3OThiOTI0YTRlZjZiOWYyZDYwMmE1ZjNkZjBjOGEyMjhmNTc=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2018-12-16T13:08:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-12-16T13:08:19Z"}, "message": "Rollup merge of #56648 - RalfJung:btree, r=sfackler\n\nFix BTreeMap UB\n\nBTreeMap currently causes UB by created a shared reference to a too-small allocation.  This PR fixes that by introducing a `NodeHeader` type and using that until we really need access to the key/value arrays.  Avoiding run-time checks in `into_key_slice` was somewhat tricky, see the comments embedded in the code.\n\nI also adjusted `as_leaf_mut` to return a raw pointer, because creating a mutable reference asserts that there are no aliases to the pointee, but that's not always correct: We use `as_leaf_mut` twice to create two mutable slices for keys and values; the second call overlaps with the first slice and hence is not a unique pointer.\n\nFixes https://github.com/rust-lang/rust/issues/54957\n\nCc @nikomatsakis @Gankro", "tree": {"sha": "71f0e8002920d0c6b75bfb712ebdc696536e5e1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71f0e8002920d0c6b75bfb712ebdc696536e5e1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9133798b924a4ef6b9f2d602a5f3df0c8a228f57", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcFk5DCRBK7hj4Ov3rIwAAdHIIAAse2RoJpJKq6r4N+MN0h9Jp\nlMPoa1ZInUyGb8f2w7r4vT8EC5WTd13Zr6aaMCsbscx1ZevVwhF7Pj6lVxnN0tSj\nM5ax26xzZkxckl201ZvKpsUP6P6Cwafv8EWCefhpIL50SpzAcD0rB9zIfhRUY4oT\nNviXjvcwa+GJbOYW5UH+XaDesjGQmAWyqo/aV9G8AcfUheVfRp20jb9fHc8xgBJU\nvbB6fQVOfxfGdGSwQorvtakWC+MphKuXYobfLC1Ei1W5Qqrb7qnsT6dWQ1yP7+eB\nujnZFM8OFNlIlgDfsI2ZieaSLFcukaffR+sJbA7p8TPtsdF/nQqnJdKQCOEcEKM=\n=ciwQ\n-----END PGP SIGNATURE-----\n", "payload": "tree 71f0e8002920d0c6b75bfb712ebdc696536e5e1b\nparent 32f922e526aeac4006df19bc2e1cacf8d0acfaab\nparent d9c64e50a07dec062c273f4ec4c8f5985af13273\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1544965699 +0100\ncommitter GitHub <noreply@github.com> 1544965699 +0100\n\nRollup merge of #56648 - RalfJung:btree, r=sfackler\n\nFix BTreeMap UB\n\nBTreeMap currently causes UB by created a shared reference to a too-small allocation.  This PR fixes that by introducing a `NodeHeader` type and using that until we really need access to the key/value arrays.  Avoiding run-time checks in `into_key_slice` was somewhat tricky, see the comments embedded in the code.\n\nI also adjusted `as_leaf_mut` to return a raw pointer, because creating a mutable reference asserts that there are no aliases to the pointee, but that's not always correct: We use `as_leaf_mut` twice to create two mutable slices for keys and values; the second call overlaps with the first slice and hence is not a unique pointer.\n\nFixes https://github.com/rust-lang/rust/issues/54957\n\nCc @nikomatsakis @Gankro\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9133798b924a4ef6b9f2d602a5f3df0c8a228f57", "html_url": "https://github.com/rust-lang/rust/commit/9133798b924a4ef6b9f2d602a5f3df0c8a228f57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9133798b924a4ef6b9f2d602a5f3df0c8a228f57/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32f922e526aeac4006df19bc2e1cacf8d0acfaab", "url": "https://api.github.com/repos/rust-lang/rust/commits/32f922e526aeac4006df19bc2e1cacf8d0acfaab", "html_url": "https://github.com/rust-lang/rust/commit/32f922e526aeac4006df19bc2e1cacf8d0acfaab"}, {"sha": "d9c64e50a07dec062c273f4ec4c8f5985af13273", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9c64e50a07dec062c273f4ec4c8f5985af13273", "html_url": "https://github.com/rust-lang/rust/commit/d9c64e50a07dec062c273f4ec4c8f5985af13273"}], "stats": {"total": 174, "additions": 117, "deletions": 57}, "files": [{"sha": "a2d2d3c74be9dd261813b56a42eaa19f8527df2a", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 117, "deletions": 57, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/9133798b924a4ef6b9f2d602a5f3df0c8a228f57/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9133798b924a4ef6b9f2d602a5f3df0c8a228f57/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=9133798b924a4ef6b9f2d602a5f3df0c8a228f57", "patch": "@@ -58,9 +58,34 @@ pub const CAPACITY: usize = 2 * B - 1;\n /// these should always be put behind pointers, and specifically behind `BoxedNode` in the owned\n /// case.\n ///\n-/// We put the metadata first so that its position is the same for every `K` and `V`, in order\n-/// to statically allocate a single dummy node to avoid allocations. This struct is `repr(C)` to\n-/// prevent them from being reordered.\n+/// We have a separate type for the header and rely on it matching the prefix of `LeafNode`, in\n+/// order to statically allocate a single dummy node to avoid allocations. This struct is\n+/// `repr(C)` to prevent them from being reordered.  `LeafNode` does not just contain a\n+/// `NodeHeader` because we do not want unnecessary padding between `len` and the keys.\n+/// Crucially, `NodeHeader` can be safely transmuted to different K and V.  (This is exploited\n+/// by `as_header`.)\n+/// See `into_key_slice` for an explanation of K2.  K2 cannot be safely transmuted around\n+/// because the size of `NodeHeader` depends on its alignment!\n+#[repr(C)]\n+struct NodeHeader<K, V, K2 = ()> {\n+    /// We use `*const` as opposed to `*mut` so as to be covariant in `K` and `V`.\n+    /// This either points to an actual node or is null.\n+    parent: *const InternalNode<K, V>,\n+\n+    /// This node's index into the parent node's `edges` array.\n+    /// `*node.parent.edges[node.parent_idx]` should be the same thing as `node`.\n+    /// This is only guaranteed to be initialized when `parent` is non-null.\n+    parent_idx: MaybeUninit<u16>,\n+\n+    /// The number of keys and values this node stores.\n+    ///\n+    /// This next to `parent_idx` to encourage the compiler to join `len` and\n+    /// `parent_idx` into the same 32-bit word, reducing space overhead.\n+    len: u16,\n+\n+    /// See `into_key_slice`.\n+    keys_start: [K2; 0],\n+}\n #[repr(C)]\n struct LeafNode<K, V> {\n     /// We use `*const` as opposed to `*mut` so as to be covariant in `K` and `V`.\n@@ -98,24 +123,25 @@ impl<K, V> LeafNode<K, V> {\n             len: 0\n         }\n     }\n+}\n \n+impl<K, V> NodeHeader<K, V> {\n     fn is_shared_root(&self) -> bool {\n         ptr::eq(self, &EMPTY_ROOT_NODE as *const _ as *const _)\n     }\n }\n \n // We need to implement Sync here in order to make a static instance.\n-unsafe impl Sync for LeafNode<(), ()> {}\n+unsafe impl Sync for NodeHeader<(), ()> {}\n \n // An empty node used as a placeholder for the root node, to avoid allocations.\n-// We use () in order to save space, since no operation on an empty tree will\n+// We use just a header in order to save space, since no operation on an empty tree will\n // ever take a pointer past the first key.\n-static EMPTY_ROOT_NODE: LeafNode<(), ()> = LeafNode {\n+static EMPTY_ROOT_NODE: NodeHeader<(), ()> = NodeHeader {\n     parent: ptr::null(),\n     parent_idx: MaybeUninit::uninitialized(),\n     len: 0,\n-    keys: MaybeUninit::uninitialized(),\n-    vals: MaybeUninit::uninitialized(),\n+    keys_start: [],\n };\n \n /// The underlying representation of internal nodes. As with `LeafNode`s, these should be hidden\n@@ -281,7 +307,7 @@ impl<K, V> Root<K, V> {\n                                     .node)\n         };\n         self.height -= 1;\n-        self.as_mut().as_leaf_mut().parent = ptr::null();\n+        unsafe { (*self.as_mut().as_leaf_mut()).parent = ptr::null(); }\n \n         unsafe {\n             Global.dealloc(NonNull::from(top).cast(), Layout::new::<InternalNode<K, V>>());\n@@ -306,6 +332,11 @@ impl<K, V> Root<K, V> {\n ///   `Leaf`, the `NodeRef` points to a leaf node, when this is `Internal` the\n ///   `NodeRef` points to an internal node, and when this is `LeafOrInternal` the\n ///   `NodeRef` could be pointing to either type of node.\n+///   Note that in case of a leaf node, this might still be the shared root!  Only turn\n+///   this into a `LeafNode` reference if you know it is not a root!  Shared references\n+///   must be dereferencable *for the entire size of their pointee*, so `&InternalNode`\n+///   pointing to the shared root is UB.\n+///   Turning this into a `NodeHeader` is always safe.\n pub struct NodeRef<BorrowType, K, V, Type> {\n     height: usize,\n     node: NonNull<LeafNode<K, V>>,\n@@ -352,7 +383,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     /// Finds the length of the node. This is the number of keys or values. In an\n     /// internal node, the number of edges is `len() + 1`.\n     pub fn len(&self) -> usize {\n-        self.as_leaf().len as usize\n+        self.as_header().len as usize\n     }\n \n     /// Returns the height of this node in the whole tree. Zero height denotes the\n@@ -382,14 +413,19 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         }\n     }\n \n-    fn as_leaf(&self) -> &LeafNode<K, V> {\n+    /// Assert that this is indeed a proper leaf node, and not the shared root.\n+    unsafe fn as_leaf(&self) -> &LeafNode<K, V> {\n+        self.node.as_ref()\n+    }\n+\n+    fn as_header(&self) -> &NodeHeader<K, V> {\n         unsafe {\n-            self.node.as_ref()\n+            &*(self.node.as_ptr() as *const NodeHeader<K, V>)\n         }\n     }\n \n     pub fn is_shared_root(&self) -> bool {\n-        self.as_leaf().is_shared_root()\n+        self.as_header().is_shared_root()\n     }\n \n     pub fn keys(&self) -> &[K] {\n@@ -418,7 +454,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         >,\n         Self\n     > {\n-        let parent_as_leaf = self.as_leaf().parent as *const LeafNode<K, V>;\n+        let parent_as_leaf = self.as_header().parent as *const LeafNode<K, V>;\n         if let Some(non_zero) = NonNull::new(parent_as_leaf as *mut _) {\n             Ok(Handle {\n                 node: NodeRef {\n@@ -427,7 +463,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n                     root: self.root,\n                     _marker: PhantomData\n                 },\n-                idx: unsafe { usize::from(*self.as_leaf().parent_idx.get_ref()) },\n+                idx: unsafe { usize::from(*self.as_header().parent_idx.get_ref()) },\n                 _marker: PhantomData\n             })\n         } else {\n@@ -534,10 +570,10 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         }\n     }\n \n-    fn as_leaf_mut(&mut self) -> &mut LeafNode<K, V> {\n-        unsafe {\n-            self.node.as_mut()\n-        }\n+    /// Returns a raw ptr to avoid asserting exclusive access to the entire node.\n+    fn as_leaf_mut(&mut self) -> *mut LeafNode<K, V> {\n+        // We are mutable, so we cannot be the root, so accessing this as a leaf is okay.\n+        self.node.as_ptr()\n     }\n \n     fn keys_mut(&mut self) -> &mut [K] {\n@@ -551,28 +587,50 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n     fn into_key_slice(self) -> &'a [K] {\n-        // When taking a pointer to the keys, if our key has a stricter\n-        // alignment requirement than the shared root does, then the pointer\n-        // would be out of bounds, which LLVM assumes will not happen. If the\n-        // alignment is more strict, we need to make an empty slice that doesn't\n-        // use an out of bounds pointer.\n+        // We have to be careful here because we might be pointing to the shared root.\n+        // In that case, we must not create an `&LeafNode`.  We could just return\n+        // an empty slice whenever the length is 0 (this includes the shared root),\n+        // but we want to avoid that run-time check.\n+        // Instead, we create a slice pointing into the node whenever possible.\n+        // We can sometimes do this even for the shared root, as the slice will be\n+        // empty.  We cannot *always* do this because if the type is too highly\n+        // aligned, the offset of `keys` in a \"full node\" might be outside the bounds\n+        // of the header!  So we do an alignment check first, that will be\n+        // evaluated at compile-time, and only do any run-time check in the rare case\n+        // that the alignment is very big.\n         if mem::align_of::<K>() > mem::align_of::<LeafNode<(), ()>>() && self.is_shared_root() {\n             &[]\n         } else {\n-            // Here either it's not the root, or the alignment is less strict,\n-            // in which case the keys pointer will point \"one-past-the-end\" of\n-            // the node, which is allowed by LLVM.\n+            // Thanks to the alignment check above, we know that `keys` will be\n+            // in-bounds of some allocation even if this is the shared root!\n+            // (We might be one-past-the-end, but that is allowed by LLVM.)\n+            // Getting the pointer is tricky though.  `NodeHeader` does not have a `keys`\n+            // field because we want its size to not depend on the alignment of `K`\n+            // (needed becuase `as_header` should be safe).  We cannot call `as_leaf`\n+            // because we might be the shared root.\n+            // For this reason, `NodeHeader` has this `K2` parameter (that's usually `()`\n+            // and hence just adds a size-0-align-1 field, not affecting layout).\n+            // We know that we can transmute `NodeHeader<K, V, ()>` to `NodeHeader<K, V, K>`\n+            // because we did the alignment check above, and hence `NodeHeader<K, V, K>`\n+            // is not bigger than `NodeHeader<K, V, ()>`!  Then we can use `NodeHeader<K, V, K>`\n+            // to compute the pointer where the keys start.\n+            // This entire hack will become unnecessary once\n+            // <https://github.com/rust-lang/rfcs/pull/2582> lands, then we can just take a raw\n+            // pointer to the `keys` field of `*const InternalNode<K, V>`.\n+\n+            // This is a non-debug-assert because it can be completely compile-time evaluated.\n+            assert!(mem::size_of::<NodeHeader<K, V>>() == mem::size_of::<NodeHeader<K, V, K>>());\n+            let header = self.as_header() as *const _ as *const NodeHeader<K, V, K>;\n+            let keys = unsafe { &(*header).keys_start as *const _ as *const K };\n             unsafe {\n-                slice::from_raw_parts(\n-                    self.as_leaf().keys.as_ptr() as *const K,\n-                    self.len()\n-                )\n+                slice::from_raw_parts(keys, self.len())\n             }\n         }\n     }\n \n     fn into_val_slice(self) -> &'a [V] {\n         debug_assert!(!self.is_shared_root());\n+        // We cannot be the root, so `as_leaf` is okay\n         unsafe {\n             slice::from_raw_parts(\n                 self.as_leaf().vals.as_ptr() as *const V,\n@@ -602,7 +660,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         } else {\n             unsafe {\n                 slice::from_raw_parts_mut(\n-                    self.as_leaf_mut().keys.as_mut_ptr() as *mut K,\n+                    (*self.as_leaf_mut()).keys.as_mut_ptr() as *mut K,\n                     self.len()\n                 )\n             }\n@@ -613,7 +671,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         debug_assert!(!self.is_shared_root());\n         unsafe {\n             slice::from_raw_parts_mut(\n-                self.as_leaf_mut().vals.as_mut_ptr() as *mut V,\n+                (*self.as_leaf_mut()).vals.as_mut_ptr() as *mut V,\n                 self.len()\n             )\n         }\n@@ -637,9 +695,9 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n         unsafe {\n             ptr::write(self.keys_mut().get_unchecked_mut(idx), key);\n             ptr::write(self.vals_mut().get_unchecked_mut(idx), val);\n-        }\n \n-        self.as_leaf_mut().len += 1;\n+            (*self.as_leaf_mut()).len += 1;\n+        }\n     }\n \n     /// Adds a key/value pair to the beginning of the node.\n@@ -651,9 +709,9 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n         unsafe {\n             slice_insert(self.keys_mut(), 0, key);\n             slice_insert(self.vals_mut(), 0, val);\n-        }\n \n-        self.as_leaf_mut().len += 1;\n+            (*self.as_leaf_mut()).len += 1;\n+        }\n     }\n }\n \n@@ -672,7 +730,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n             ptr::write(self.vals_mut().get_unchecked_mut(idx), val);\n             ptr::write(self.as_internal_mut().edges.get_unchecked_mut(idx + 1), edge.node);\n \n-            self.as_leaf_mut().len += 1;\n+            (*self.as_leaf_mut()).len += 1;\n \n             Handle::new_edge(self.reborrow_mut(), idx + 1).correct_parent_link();\n         }\n@@ -708,7 +766,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n                 edge.node\n             );\n \n-            self.as_leaf_mut().len += 1;\n+            (*self.as_leaf_mut()).len += 1;\n \n             self.correct_all_childrens_parent_links();\n         }\n@@ -732,12 +790,12 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n                 ForceResult::Internal(internal) => {\n                     let edge = ptr::read(internal.as_internal().edges.get_unchecked(idx + 1));\n                     let mut new_root = Root { node: edge, height: internal.height - 1 };\n-                    new_root.as_mut().as_leaf_mut().parent = ptr::null();\n+                    (*new_root.as_mut().as_leaf_mut()).parent = ptr::null();\n                     Some(new_root)\n                 }\n             };\n \n-            self.as_leaf_mut().len -= 1;\n+            (*self.as_leaf_mut()).len -= 1;\n             (key, val, edge)\n         }\n     }\n@@ -765,7 +823,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n                     );\n \n                     let mut new_root = Root { node: edge, height: internal.height - 1 };\n-                    new_root.as_mut().as_leaf_mut().parent = ptr::null();\n+                    (*new_root.as_mut().as_leaf_mut()).parent = ptr::null();\n \n                     for i in 0..old_len {\n                         Handle::new_edge(internal.reborrow_mut(), i).correct_parent_link();\n@@ -775,7 +833,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n                 }\n             };\n \n-            self.as_leaf_mut().len -= 1;\n+            (*self.as_leaf_mut()).len -= 1;\n \n             (key, val, edge)\n         }\n@@ -966,7 +1024,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n             slice_insert(self.node.keys_mut(), self.idx, key);\n             slice_insert(self.node.vals_mut(), self.idx, val);\n \n-            self.node.as_leaf_mut().len += 1;\n+            (*self.node.as_leaf_mut()).len += 1;\n \n             self.node.vals_mut().get_unchecked_mut(self.idx)\n         }\n@@ -1009,8 +1067,10 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         let idx = self.idx as u16;\n         let ptr = self.node.as_internal_mut() as *mut _;\n         let mut child = self.descend();\n-        child.as_leaf_mut().parent = ptr;\n-        child.as_leaf_mut().parent_idx.set(idx);\n+        unsafe {\n+            (*child.as_leaf_mut()).parent = ptr;\n+            (*child.as_leaf_mut()).parent_idx.set(idx);\n+        }\n     }\n \n     /// Unsafely asserts to the compiler some static information about whether the underlying\n@@ -1158,7 +1218,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n                 new_len\n             );\n \n-            self.node.as_leaf_mut().len = self.idx as u16;\n+            (*self.node.as_leaf_mut()).len = self.idx as u16;\n             new_node.len = new_len as u16;\n \n             (\n@@ -1180,7 +1240,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n         unsafe {\n             let k = slice_remove(self.node.keys_mut(), self.idx);\n             let v = slice_remove(self.node.vals_mut(), self.idx);\n-            self.node.as_leaf_mut().len -= 1;\n+            (*self.node.as_leaf_mut()).len -= 1;\n             (self.left_edge(), k, v)\n         }\n     }\n@@ -1221,7 +1281,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                 new_len + 1\n             );\n \n-            self.node.as_leaf_mut().len = self.idx as u16;\n+            (*self.node.as_leaf_mut()).len = self.idx as u16;\n             new_node.data.len = new_len as u16;\n \n             let mut new_root = Root {\n@@ -1295,9 +1355,9 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n             for i in self.idx+1..self.node.len() {\n                 Handle::new_edge(self.node.reborrow_mut(), i).correct_parent_link();\n             }\n-            self.node.as_leaf_mut().len -= 1;\n+            (*self.node.as_leaf_mut()).len -= 1;\n \n-            left_node.as_leaf_mut().len += right_len as u16 + 1;\n+            (*left_node.as_leaf_mut()).len += right_len as u16 + 1;\n \n             if self.node.height > 1 {\n                 ptr::copy_nonoverlapping(\n@@ -1407,8 +1467,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                 move_kv(left_kv, new_left_len, parent_kv, 0, 1);\n             }\n \n-            left_node.reborrow_mut().as_leaf_mut().len -= count as u16;\n-            right_node.reborrow_mut().as_leaf_mut().len += count as u16;\n+            (*left_node.reborrow_mut().as_leaf_mut()).len -= count as u16;\n+            (*right_node.reborrow_mut().as_leaf_mut()).len += count as u16;\n \n             match (left_node.force(), right_node.force()) {\n                 (ForceResult::Internal(left), ForceResult::Internal(mut right)) => {\n@@ -1468,8 +1528,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                           new_right_len);\n             }\n \n-            left_node.reborrow_mut().as_leaf_mut().len += count as u16;\n-            right_node.reborrow_mut().as_leaf_mut().len -= count as u16;\n+            (*left_node.reborrow_mut().as_leaf_mut()).len += count as u16;\n+            (*right_node.reborrow_mut().as_leaf_mut()).len -= count as u16;\n \n             match (left_node.force(), right_node.force()) {\n                 (ForceResult::Internal(left), ForceResult::Internal(mut right)) => {\n@@ -1560,8 +1620,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, ma\n \n             move_kv(left_kv, left_new_len, right_kv, 0, right_new_len);\n \n-            left_node.reborrow_mut().as_leaf_mut().len = left_new_len as u16;\n-            right_node.reborrow_mut().as_leaf_mut().len = right_new_len as u16;\n+            (*left_node.reborrow_mut().as_leaf_mut()).len = left_new_len as u16;\n+            (*right_node.reborrow_mut().as_leaf_mut()).len = right_new_len as u16;\n \n             match (left_node.force(), right_node.force()) {\n                 (ForceResult::Internal(left), ForceResult::Internal(right)) => {"}]}