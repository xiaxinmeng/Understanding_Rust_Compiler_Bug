{"sha": "4ae91e2961ac7be50a346a6b0d724601878a9cd0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhZTkxZTI5NjFhYzdiZTUwYTM0NmE2YjBkNzI0NjAxODc4YTljZDA=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-26T14:35:36Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-27T04:48:11Z"}, "message": "libsyntax: add explicit copies", "tree": {"sha": "90cb8dd7634d786c2ff6c7253dc1dc742c4f925e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90cb8dd7634d786c2ff6c7253dc1dc742c4f925e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ae91e2961ac7be50a346a6b0d724601878a9cd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ae91e2961ac7be50a346a6b0d724601878a9cd0", "html_url": "https://github.com/rust-lang/rust/commit/4ae91e2961ac7be50a346a6b0d724601878a9cd0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ae91e2961ac7be50a346a6b0d724601878a9cd0/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d239a256d39eb2527ddd40e34d14a2e1801fb61", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d239a256d39eb2527ddd40e34d14a2e1801fb61", "html_url": "https://github.com/rust-lang/rust/commit/8d239a256d39eb2527ddd40e34d14a2e1801fb61"}], "stats": {"total": 162, "additions": 101, "deletions": 61}, "files": [{"sha": "a52a9f3ba5e9343fbb013a95c164326640075ab4", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4ae91e2961ac7be50a346a6b0d724601878a9cd0/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ae91e2961ac7be50a346a6b0d724601878a9cd0/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=4ae91e2961ac7be50a346a6b0d724601878a9cd0", "patch": "@@ -46,7 +46,10 @@ impl parser_attr for Parser {\n               }\n               token::DOC_COMMENT(s) => {\n                 let attr = ::attr::mk_sugared_doc_attr(\n-                        *self.id_to_str(s), self.span.lo, self.span.hi);\n+                    copy *self.id_to_str(s),\n+                    self.span.lo,\n+                    self.span.hi\n+                );\n                 if attr.node.style != ast::attr_outer {\n                   self.fatal(~\"expected outer comment\");\n                 }\n@@ -113,7 +116,10 @@ impl parser_attr for Parser {\n               }\n               token::DOC_COMMENT(s) => {\n                 let attr = ::attr::mk_sugared_doc_attr(\n-                        *self.id_to_str(s), self.span.lo, self.span.hi);\n+                    copy *self.id_to_str(s),\n+                    self.span.lo,\n+                    self.span.hi\n+                );\n                 self.bump();\n                 if attr.node.style == ast::attr_inner {\n                   inner_attrs += ~[attr];\n@@ -151,7 +157,7 @@ impl parser_attr for Parser {\n     }\n \n     fn parse_meta_seq() -> ~[@ast::meta_item] {\n-        self.parse_seq(\n+        copy self.parse_seq(\n             &token::LPAREN,\n             &token::RPAREN,\n             seq_sep_trailing_disallowed(token::COMMA),"}, {"sha": "714ae9a0fd520065db98e00f0b1e08658c0e2d29", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4ae91e2961ac7be50a346a6b0d724601878a9cd0/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ae91e2961ac7be50a346a6b0d724601878a9cd0/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=4ae91e2961ac7be50a346a6b0d724601878a9cd0", "patch": "@@ -221,7 +221,7 @@ fn trim_whitespace_prefix_and_push_line(lines: &mut ~[~str],\n         if col < len {\n             s1 = str::slice(s, col, len);\n         } else { s1 = ~\"\"; }\n-    } else { s1 = s; }\n+    } else { s1 = /*bad*/ copy s; }\n     log(debug, ~\"pushing line: \" + s1);\n     lines.push(s1);\n }\n@@ -321,7 +321,7 @@ pub struct lit {\n }\n \n pub fn gather_comments_and_literals(span_diagnostic: diagnostic::span_handler,\n-                                    path: ~str,\n+                                    +path: ~str,\n                                     srdr: io::Reader) -> (~[cmnt], ~[lit]) {\n     let src = @str::from_bytes(srdr.read_whole_stream());\n     let itr = parse::token::mk_fake_ident_interner();\n@@ -356,10 +356,10 @@ pub fn gather_comments_and_literals(span_diagnostic: diagnostic::span_handler,\n         let TokenAndSpan {tok: tok, sp: sp} = rdr.peek();\n         if token::is_lit(&tok) {\n             let s = get_str_from(rdr, bstart);\n-            literals.push(lit {lit: s, pos: sp.lo});\n-            log(debug, ~\"tok lit: \" + s);\n+            literals.push(lit {lit: /*bad*/ copy s, pos: sp.lo});\n+            debug!(\"tok lit: %s\", s);\n         } else {\n-            log(debug, ~\"tok: \" + token::to_str(rdr.interner, &tok));\n+            debug!(\"tok: %s\", token::to_str(rdr.interner, &tok));\n         }\n         first_read = false;\n     }"}, {"sha": "cf5cb847018ac13e65e90ecc3c1ec430fe662470", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4ae91e2961ac7be50a346a6b0d724601878a9cd0/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ae91e2961ac7be50a346a6b0d724601878a9cd0/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=4ae91e2961ac7be50a346a6b0d724601878a9cd0", "patch": "@@ -92,7 +92,7 @@ pub fn parse_crate_from_source_str(name: ~str,\n                                    source: @~str,\n                                    cfg: ast::crate_cfg,\n                                    sess: @mut ParseSess) -> @ast::crate {\n-    let p = new_parser_from_source_str(sess, cfg, name,\n+    let p = new_parser_from_source_str(sess, cfg, /*bad*/ copy name,\n                                        codemap::FssNone, source);\n     let r = p.parse_crate_mod(cfg);\n     p.abort_if_errors();\n@@ -103,7 +103,7 @@ pub fn parse_expr_from_source_str(name: ~str,\n                                   source: @~str,\n                                   cfg: ast::crate_cfg,\n                                   sess: @mut ParseSess) -> @ast::expr {\n-    let p = new_parser_from_source_str(sess, cfg, name,\n+    let p = new_parser_from_source_str(sess, cfg, /*bad*/ copy name,\n                                        codemap::FssNone, source);\n     let r = p.parse_expr();\n     p.abort_if_errors();\n@@ -116,7 +116,7 @@ pub fn parse_item_from_source_str(name: ~str,\n                                   +attrs: ~[ast::attribute],\n                                   sess: @mut ParseSess)\n                                -> Option<@ast::item> {\n-    let p = new_parser_from_source_str(sess, cfg, name,\n+    let p = new_parser_from_source_str(sess, cfg, /*bad*/ copy name,\n                                        codemap::FssNone, source);\n     let r = p.parse_item(attrs);\n     p.abort_if_errors();\n@@ -128,7 +128,7 @@ pub fn parse_stmt_from_source_str(name: ~str,\n                                   cfg: ast::crate_cfg,\n                                   +attrs: ~[ast::attribute],\n                                   sess: @mut ParseSess) -> @ast::stmt {\n-    let p = new_parser_from_source_str(sess, cfg, name,\n+    let p = new_parser_from_source_str(sess, cfg, /*bad*/ copy name,\n                                        codemap::FssNone, source);\n     let r = p.parse_stmt(attrs);\n     p.abort_if_errors();\n@@ -139,7 +139,7 @@ pub fn parse_tts_from_source_str(name: ~str,\n                                  source: @~str,\n                                  cfg: ast::crate_cfg,\n                                  sess: @mut ParseSess) -> ~[ast::token_tree] {\n-    let p = new_parser_from_source_str(sess, cfg, name,\n+    let p = new_parser_from_source_str(sess, cfg, /*bad*/ copy name,\n                                        codemap::FssNone, source);\n     *p.quote_depth += 1u;\n     let r = p.parse_all_token_trees();\n@@ -153,8 +153,13 @@ pub fn parse_from_source_str<T>(f: fn (p: Parser) -> T,\n                             sess: @mut ParseSess)\n     -> T\n {\n-    let p = new_parser_from_source_str(sess, cfg, name, ss,\n-                                       source);\n+    let p = new_parser_from_source_str(\n+        sess,\n+        cfg,\n+        /*bad*/ copy name,\n+        /*bad*/ copy ss,\n+        source\n+    );\n     let r = f(p);\n     if !p.reader.is_eof() {\n         p.reader.fatal(~\"expected end-of-string\");\n@@ -226,7 +231,7 @@ pub fn new_sub_parser_from_file(sess: @mut ParseSess, cfg: ast::crate_cfg,\n }\n \n pub fn new_parser_from_tts(sess: @mut ParseSess, cfg: ast::crate_cfg,\n-                       tts: ~[ast::token_tree]) -> Parser {\n+                           +tts: ~[ast::token_tree]) -> Parser {\n     let trdr = lexer::new_tt_reader(copy sess.span_diagnostic, sess.interner,\n                                     None, tts);\n     return Parser(sess, cfg, trdr as reader)"}, {"sha": "2c7947090c243a7c004658e6e7bd64bcc2a62a2c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 67, "deletions": 38, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/4ae91e2961ac7be50a346a6b0d724601878a9cd0/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ae91e2961ac7be50a346a6b0d724601878a9cd0/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=4ae91e2961ac7be50a346a6b0d724601878a9cd0", "patch": "@@ -147,16 +147,25 @@ macro_rules! maybe_whole_expr (\n )\n \n macro_rules! maybe_whole (\n-    ($p:expr, $constructor:ident) => ( match *$p.token {\n-      INTERPOLATED(token::$constructor(x)) => { $p.bump(); return x; }\n+    ($p:expr, $constructor:ident) => ( match copy *$p.token {\n+      INTERPOLATED(token::$constructor(x)) => {\n+        $p.bump();\n+        return x;\n+      }\n       _ => ()\n     }) ;\n-    (deref $p:expr, $constructor:ident) => ( match *$p.token {\n-      INTERPOLATED(token::$constructor(x)) => { $p.bump(); return *x; }\n+    (deref $p:expr, $constructor:ident) => ( match copy *$p.token {\n+      INTERPOLATED(token::$constructor(x)) => {\n+        $p.bump();\n+        return copy *x;\n+      }\n       _ => ()\n     }) ;\n-    (Some $p:expr, $constructor:ident) => ( match *$p.token {\n-      INTERPOLATED(token::$constructor(x)) => { $p.bump(); return Some(x); }\n+    (Some $p:expr, $constructor:ident) => ( match copy *$p.token {\n+      INTERPOLATED(token::$constructor(x)) => {\n+        $p.bump();\n+        return Some(x);\n+      }\n       _ => ()\n     }) ;\n     (iovi $p:expr, $constructor:ident) => ( match *$p.token {\n@@ -166,9 +175,10 @@ macro_rules! maybe_whole (\n       }\n       _ => ()\n     }) ;\n-    (pair_empty $p:expr, $constructor:ident) => ( match *$p.token {\n+    (pair_empty $p:expr, $constructor:ident) => ( match copy *$p.token {\n       INTERPOLATED(token::$constructor(x)) => {\n-        $p.bump(); return (~[], x);\n+        $p.bump();\n+        return (~[], x);\n       }\n       _ => ()\n     })\n@@ -612,8 +622,11 @@ pub impl Parser {\n                         one_tuple = true;\n                     }\n                 }\n-                let t = if ts.len() == 1 && !one_tuple { ts[0].node }\n-                else { ty_tup(ts) };\n+                let t = if ts.len() == 1 && !one_tuple {\n+                    copy ts[0].node\n+                } else {\n+                    ty_tup(ts)\n+                };\n                 self.expect(&token::RPAREN);\n                 t\n             }\n@@ -972,7 +985,7 @@ pub impl Parser {\n         @ast::path { span: mk_sp(lo, hi),\n                      rp: rp,\n                      types: tps,\n-                     .. *path }\n+                     .. copy *path }\n     }\n \n     fn parse_opt_lifetime() -> Option<ast::Lifetime> {\n@@ -1440,7 +1453,12 @@ pub impl Parser {\n                         |p| p.parse_token_tree()\n                     );\n                     let (s, z) = p.parse_sep_and_zerok();\n-                    tt_seq(mk_sp(sp.lo ,p.span.hi), seq.node, s, z)\n+                    tt_seq(\n+                        mk_sp(sp.lo ,p.span.hi),\n+                        /*bad*/ copy seq.node,\n+                        s,\n+                        z\n+                    )\n                 } else {\n                     tt_nonterminal(sp, p.parse_ident())\n                 }\n@@ -1453,7 +1471,7 @@ pub impl Parser {\n \n         // turn the next token into a tt_tok:\n         fn parse_any_tt_tok(p: &Parser) -> token_tree{\n-            let res = tt_tok(*p.span, *p.token);\n+            let res = tt_tok(*p.span, copy *p.token);\n             p.bump();\n             res\n         }\n@@ -1562,7 +1580,7 @@ pub impl Parser {\n                 m\n             }\n         } else {\n-            let m = match_tok(*self.token);\n+            let m = match_tok(copy *self.token);\n             self.bump();\n             m\n         };\n@@ -1665,7 +1683,7 @@ pub impl Parser {\n     fn parse_more_binops(lhs: @expr, min_prec: uint) ->\n         @expr {\n         if self.expr_is_complete(lhs) { return lhs; }\n-        let peeked = *self.token;\n+        let peeked = copy *self.token;\n         if peeked == token::BINOP(token::OR) &&\n             (*self.restriction == RESTRICT_NO_BAR_OP ||\n              *self.restriction == RESTRICT_NO_BAR_OR_DOUBLEBAR_OP) {\n@@ -1859,7 +1877,7 @@ pub impl Parser {\n         // Turn on the restriction to stop at | or || so we can parse\n         // them as the lambda arguments\n         let e = self.parse_expr_res(RESTRICT_NO_BAR_OR_DOUBLEBAR_OP);\n-        match e.node {\n+        match /*bad*/ copy e.node {\n             expr_call(f, args, NoSugar) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n@@ -2441,7 +2459,7 @@ pub impl Parser {\n     fn parse_stmt(+first_item_attrs: ~[attribute]) -> @stmt {\n         maybe_whole!(self, nt_stmt);\n \n-        fn check_expected_item(p: &Parser, current_attrs: ~[attribute]) {\n+        fn check_expected_item(p: &Parser, current_attrs: &[attribute]) {\n             // If we have attributes then we should have an item\n             if !current_attrs.is_empty() {\n                 p.fatal(~\"expected item after attrs\");\n@@ -2497,7 +2515,7 @@ pub impl Parser {\n             let item_attrs = vec::append(first_item_attrs,\n                                          self.parse_outer_attributes());\n \n-            match self.parse_item_or_view_item(item_attrs,\n+            match self.parse_item_or_view_item(/*bad*/ copy item_attrs,\n                                                true, false, false) {\n               iovi_item(i) => {\n                 let mut hi = i.span.hi;\n@@ -2614,7 +2632,7 @@ pub impl Parser {\n                                     self.bump();\n                                     stmts.push(@codemap::spanned {\n                                         node: stmt_semi(e, stmt_id),\n-                                        .. *stmt});\n+                                        .. copy *stmt});\n                                 }\n                                 token::RBRACE => {\n                                     expr = Some(e);\n@@ -2640,16 +2658,16 @@ pub impl Parser {\n                                 token::SEMI => {\n                                     self.bump();\n                                     stmts.push(@codemap::spanned {\n-                                        node: stmt_mac((*m), true),\n-                                        .. *stmt});\n+                                        node: stmt_mac(copy *m, true),\n+                                        .. copy *stmt});\n                                 }\n                                 token::RBRACE => {\n                                     // if a block ends in `m!(arg)` without\n                                     // a `;`, it must be an expr\n                                     expr = Some(\n                                         self.mk_mac_expr(stmt.span.lo,\n                                                          stmt.span.hi,\n-                                                         (*m).node));\n+                                                         copy m.node));\n                                 }\n                                 _ => { stmts.push(stmt); }\n                             }\n@@ -2990,6 +3008,7 @@ pub impl Parser {\n         let self_ty = if is_static { static_sty} else { self_ty };\n \n         let (inner_attrs, body) = self.parse_inner_attrs_and_block(true);\n+        let hi = body.span.hi;\n         let attrs = vec::append(attrs, inner_attrs);\n         @ast::method {\n             ident: ident,\n@@ -3000,7 +3019,7 @@ pub impl Parser {\n             decl: decl,\n             body: body,\n             id: self.get_id(),\n-            span: mk_sp(lo, body.span.hi),\n+            span: mk_sp(lo, hi),\n             self_id: self.get_id(),\n             vis: visa,\n         }\n@@ -3161,7 +3180,7 @@ pub impl Parser {\n                                                           declared here\");\n                         }\n                         None => {\n-                          the_dtor = Some(((*blk), (*attrs), s));\n+                          the_dtor = Some((copy *blk, copy *attrs, s));\n                         }\n                       }\n                   }\n@@ -3205,7 +3224,7 @@ pub impl Parser {\n         }\n \n         let actual_dtor = do the_dtor.map |dtor| {\n-            let (d_body, d_attrs, d_s) = *dtor;\n+            let (d_body, d_attrs, d_s) = copy *dtor;\n             codemap::spanned { node: ast::struct_dtor_ { id: self.get_id(),\n                                                      attrs: d_attrs,\n                                                      self_id: self.get_id(),\n@@ -3257,7 +3276,7 @@ pub impl Parser {\n         a_var\n     }\n \n-    fn parse_dtor(attrs: ~[attribute]) -> class_contents {\n+    fn parse_dtor(+attrs: ~[attribute]) -> class_contents {\n         let lo = self.last_span.lo;\n         let body = self.parse_block();\n         dtor_decl(body, attrs, mk_sp(lo, self.last_span.hi))\n@@ -3323,12 +3342,17 @@ pub impl Parser {\n         while *self.token != term {\n             let mut attrs = self.parse_outer_attributes();\n             if first {\n-                attrs = vec::append(attrs_remaining, attrs);\n+                attrs = vec::append(/*bad*/ copy attrs_remaining, attrs);\n                 first = false;\n             }\n             debug!(\"parse_mod_items: parse_item_or_view_item(attrs=%?)\",\n                    attrs);\n-            match self.parse_item_or_view_item(attrs, true, false, true) {\n+            match self.parse_item_or_view_item(\n+                /*bad*/ copy attrs,\n+                true,\n+                false,\n+                true\n+            ) {\n               iovi_item(item) => items.push(item),\n               iovi_view_item(view_item) => {\n                 self.span_fatal(view_item.span, ~\"view items must be \\\n@@ -3456,7 +3480,7 @@ pub impl Parser {\n                                     outer_attrs, id_sp)\n     }\n \n-    fn eval_src_mod_from_path(prefix: Path, path: Path,\n+    fn eval_src_mod_from_path(prefix: Path, +path: Path,\n                               outer_attrs: ~[ast::attribute],\n                               id_sp: span\n                              ) -> (ast::item_, ~[ast::attribute]) {\n@@ -3471,12 +3495,15 @@ pub impl Parser {\n             new_sub_parser_from_file(self.sess, self.cfg,\n                                      &full_path, id_sp);\n         let (inner, next) = p0.parse_inner_attrs_and_next();\n-        let mod_attrs = vec::append(outer_attrs, inner);\n+        let mod_attrs = vec::append(\n+            /*bad*/ copy outer_attrs,\n+            inner\n+        );\n         let first_item_outer_attrs = next;\n         let m0 = p0.parse_mod_items(token::EOF, first_item_outer_attrs);\n         return (ast::item_mod(m0), mod_attrs);\n \n-        fn cdir_path_opt(default: ~str, attrs: ~[ast::attribute]) -> ~str {\n+        fn cdir_path_opt(+default: ~str, attrs: ~[ast::attribute]) -> ~str {\n             match ::attr::first_attr_value_str_by_name(attrs, ~\"path\") {\n                 Some(d) => copy *d,\n                 None => default\n@@ -3631,8 +3658,9 @@ pub impl Parser {\n             self.expect(&token::RBRACE);\n \n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident,\n-                                     item_foreign_mod(m), visibility,\n-                                     maybe_append(attrs, Some(inner))));\n+                                          item_foreign_mod(m), visibility,\n+                                          maybe_append(/*bad*/ copy attrs,\n+                                                       Some(inner))));\n         }\n \n         match abi_opt {\n@@ -3648,7 +3676,7 @@ pub impl Parser {\n         self.expect(&token::SEMI);\n         iovi_view_item(@ast::view_item {\n             node: view_item_extern_mod(ident, metadata, self.get_id()),\n-            attrs: attrs,\n+            attrs: copy attrs,\n             vis: visibility,\n             span: mk_sp(lo, self.last_span.hi)\n         })\n@@ -3691,7 +3719,7 @@ pub impl Parser {\n                                               declared here\");\n                         }\n                         None => {\n-                            the_dtor = Some(((*blk), (*attrs), s));\n+                            the_dtor = Some((copy *blk, copy *attrs, s));\n                         }\n                     }\n                 }\n@@ -3704,7 +3732,7 @@ pub impl Parser {\n         }\n         self.bump();\n         let mut actual_dtor = do the_dtor.map |dtor| {\n-            let (d_body, d_attrs, d_s) = *dtor;\n+            let (d_body, d_attrs, d_s) = copy *dtor;\n             codemap::spanned { node: ast::struct_dtor_ { id: self.get_id(),\n                                                      attrs: d_attrs,\n                                                      self_id: self.get_id(),\n@@ -4216,7 +4244,8 @@ pub impl Parser {\n \n         let mut (view_items, items, foreign_items) = (~[], ~[], ~[]);\n         loop {\n-            match self.parse_item_or_view_item(attrs, items_allowed,\n+            match self.parse_item_or_view_item(/*bad*/ copy attrs,\n+                                               items_allowed,\n                                                foreign_items_allowed,\n                                                macros_allowed) {\n                 iovi_none =>\n@@ -4265,7 +4294,7 @@ pub impl Parser {\n         @spanned(lo, self.span.lo,\n                  ast::crate_ { module: m,\n                                attrs: inner,\n-                               config: self.cfg })\n+                               config: copy self.cfg })\n     }\n \n     fn parse_str() -> @~str {"}, {"sha": "8b063314c9b075f1bcc7c8996047149911f2c381", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4ae91e2961ac7be50a346a6b0d724601878a9cd0/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ae91e2961ac7be50a346a6b0d724601878a9cd0/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=4ae91e2961ac7be50a346a6b0d724601878a9cd0", "patch": "@@ -179,14 +179,14 @@ pub fn to_str(in: @ident_interner, t: &Token) -> ~str {\n       }\n       LIT_INT_UNSUFFIXED(i) => { i.to_str() }\n       LIT_FLOAT(s, t) => {\n-        let mut body = *in.get(s);\n+        let mut body = copy *in.get(s);\n         if body.ends_with(~\".\") {\n             body = body + ~\"0\";  // `10.f` is not a float literal\n         }\n         body + ast_util::float_ty_to_str(t)\n       }\n       LIT_FLOAT_UNSUFFIXED(s) => {\n-        let mut body = *in.get(s);\n+        let mut body = copy *in.get(s);\n         if body.ends_with(~\".\") {\n             body = body + ~\"0\";  // `10.f` is not a float literal\n         }\n@@ -195,12 +195,12 @@ pub fn to_str(in: @ident_interner, t: &Token) -> ~str {\n       LIT_STR(s) => { ~\"\\\"\" + str::escape_default(*in.get(s)) + ~\"\\\"\" }\n \n       /* Name components */\n-      IDENT(s, _) => *in.get(s),\n+      IDENT(s, _) => copy *in.get(s),\n       LIFETIME(s) => fmt!(\"'%s\", *in.get(s)),\n       UNDERSCORE => ~\"_\",\n \n       /* Other */\n-      DOC_COMMENT(s) => *in.get(s),\n+      DOC_COMMENT(s) => copy *in.get(s),\n       EOF => ~\"<eof>\",\n       INTERPOLATED(ref nt) => {\n         match nt {\n@@ -476,7 +476,7 @@ pub fn temporary_keyword_table() -> HashMap<~str, ()> {\n         ~\"self\", ~\"static\",\n     ];\n     for keys.each |word| {\n-        words.insert(*word, ());\n+        words.insert(copy *word, ());\n     }\n     words\n }\n@@ -503,7 +503,7 @@ pub fn strict_keyword_table() -> HashMap<~str, ()> {\n         ~\"while\"\n     ];\n     for keys.each |word| {\n-        words.insert(*word, ());\n+        words.insert(copy *word, ());\n     }\n     words\n }\n@@ -514,7 +514,7 @@ pub fn reserved_keyword_table() -> HashMap<~str, ()> {\n         ~\"be\"\n     ];\n     for keys.each |word| {\n-        words.insert(*word, ());\n+        words.insert(copy *word, ());\n     }\n     words\n }"}]}