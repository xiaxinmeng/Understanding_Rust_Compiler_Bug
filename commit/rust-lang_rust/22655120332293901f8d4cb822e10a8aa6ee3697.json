{"sha": "22655120332293901f8d4cb822e10a8aa6ee3697", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyNjU1MTIwMzMyMjkzOTAxZjhkNGNiODIyZTEwYThhYTZlZTM2OTc=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2014-03-17T07:26:36Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-18T20:49:13Z"}, "message": "closes #12967 fix [en|de]coding of HashMap<K,V> where K is a numeric type\n\nserialize: ref #12697 minor adj. to last char check + prettyencode test", "tree": {"sha": "710ca452892f7bcb8231d92ca9fca47671d3bdaa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/710ca452892f7bcb8231d92ca9fca47671d3bdaa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22655120332293901f8d4cb822e10a8aa6ee3697", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22655120332293901f8d4cb822e10a8aa6ee3697", "html_url": "https://github.com/rust-lang/rust/commit/22655120332293901f8d4cb822e10a8aa6ee3697", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22655120332293901f8d4cb822e10a8aa6ee3697/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20e178c5821b32d7a7deab70af90bf50f9d39df3", "url": "https://api.github.com/repos/rust-lang/rust/commits/20e178c5821b32d7a7deab70af90bf50f9d39df3", "html_url": "https://github.com/rust-lang/rust/commit/20e178c5821b32d7a7deab70af90bf50f9d39df3"}], "stats": {"total": 85, "additions": 84, "deletions": 1}, "files": [{"sha": "9b93a62304c8832daa96e4ab51c91a4891caccd0", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 84, "deletions": 1, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/22655120332293901f8d4cb822e10a8aa6ee3697/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22655120332293901f8d4cb822e10a8aa6ee3697/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=22655120332293901f8d4cb822e10a8aa6ee3697", "patch": "@@ -464,8 +464,20 @@ impl<'a> ::Encoder for Encoder<'a> {\n     }\n \n     fn emit_map_elt_key(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n+        use std::str::from_utf8;\n         if idx != 0 { try!(write!(self.wr, \",\")) }\n-        f(self)\n+        // ref #12967, make sure to wrap a key in double quotes,\n+        // in the event that its of a type that omits them (eg numbers)\n+        let mut buf = MemWriter::new();\n+        let mut check_encoder = Encoder::new(&mut buf);\n+        f(&mut check_encoder);\n+        let buf = buf.unwrap();\n+        let out = from_utf8(buf).unwrap();\n+        let needs_wrapping = out.char_at(0) != '\"' &&\n+            out.char_at_reverse(out.len()) != '\"';\n+        if needs_wrapping { try!(write!(self.wr, \"\\\"\")); }\n+        f(self);\n+        if needs_wrapping { try!(write!(self.wr, \"\\\"\")); }\n     }\n \n     fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut Encoder<'a>|) {\n@@ -659,13 +671,25 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n     }\n \n     fn emit_map_elt_key(&mut self, idx: uint, f: |&mut PrettyEncoder<'a>|) {\n+        use std::str::from_utf8;\n         if idx == 0 {\n             try!(write!(self.wr, \"\\n\"));\n         } else {\n             try!(write!(self.wr, \",\\n\"));\n         }\n         try!(write!(self.wr, \"{}\", spaces(self.indent)));\n+        // ref #12967, make sure to wrap a key in double quotes,\n+        // in the event that its of a type that omits them (eg numbers)\n+        let mut buf = MemWriter::new();\n+        let mut check_encoder = PrettyEncoder::new(&mut buf);\n+        f(&mut check_encoder);\n+        let buf = buf.unwrap();\n+        let out = from_utf8(buf).unwrap();\n+        let needs_wrapping = out.char_at(0) != '\"' &&\n+            out.char_at_reverse(out.len()) != '\"';\n+        if needs_wrapping { try!(write!(self.wr, \"\\\"\")); }\n         f(self);\n+        if needs_wrapping { try!(write!(self.wr, \"\\\"\")); }\n     }\n \n     fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut PrettyEncoder<'a>|) {\n@@ -1306,9 +1330,15 @@ impl ::Decoder for Decoder {\n     }\n \n     fn read_f64(&mut self) -> f64 {\n+        use std::from_str::FromStr;\n         debug!(\"read_f64\");\n         match self.stack.pop().unwrap() {\n             Number(f) => f,\n+            String(s) => {\n+                // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n+                // is going to have a string here, as per JSON spec..\n+                FromStr::from_str(s).unwrap()\n+            },\n             value => self.expected(\"number\", &value)\n         }\n     }\n@@ -2519,4 +2549,57 @@ mod tests {\n         let expected_null = ();\n         assert!(json_null.is_some() && json_null.unwrap() == expected_null);\n     }\n+\n+    #[test]\n+    fn test_encode_hashmap_with_numeric_key() {\n+        use std::str::from_utf8;\n+        use std::io::Writer;\n+        use std::io::MemWriter;\n+        use collections::HashMap;\n+        let mut hm: HashMap<uint, bool> = HashMap::new();\n+        hm.insert(1, true);\n+        let mut mem_buf = MemWriter::new();\n+        {\n+            let mut encoder = Encoder::new(&mut mem_buf as &mut io::Writer);\n+            hm.encode(&mut encoder)\n+        }\n+        let bytes = mem_buf.unwrap();\n+        let json_str = from_utf8(bytes).unwrap();\n+        match from_str(json_str) {\n+            Err(_) => fail!(\"Unable to parse json_str: {:?}\", json_str),\n+            _ => {} // it parsed and we are good to go\n+        }\n+    }\n+    #[test]\n+    fn test_prettyencode_hashmap_with_numeric_key() {\n+        use std::str::from_utf8;\n+        use std::io::Writer;\n+        use std::io::MemWriter;\n+        use collections::HashMap;\n+        let mut hm: HashMap<uint, bool> = HashMap::new();\n+        hm.insert(1, true);\n+        let mut mem_buf = MemWriter::new();\n+        {\n+            let mut encoder = PrettyEncoder::new(&mut mem_buf as &mut io::Writer);\n+            hm.encode(&mut encoder)\n+        }\n+        let bytes = mem_buf.unwrap();\n+        let json_str = from_utf8(bytes).unwrap();\n+        match from_str(json_str) {\n+            Err(_) => fail!(\"Unable to parse json_str: {:?}\", json_str),\n+            _ => {} // it parsed and we are good to go\n+        }\n+    }\n+    #[test]\n+    fn test_hashmap_with_numeric_key_can_handle_double_quote_delimited_key() {\n+        use collections::HashMap;\n+        use Decodable;\n+        let json_str = \"{\\\"1\\\":true}\";\n+        let json_obj = match from_str(json_str) {\n+            Err(_) => fail!(\"Unable to parse json_str: {:?}\", json_str),\n+            Ok(o) => o\n+        };\n+        let mut decoder = Decoder::new(json_obj);\n+        let hm: HashMap<uint, bool> = Decodable::decode(&mut decoder);\n+    }\n }"}]}