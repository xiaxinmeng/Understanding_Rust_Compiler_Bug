{"sha": "56ece46f7de9d1703dd39f952afac9bed22633b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2ZWNlNDZmN2RlOWQxNzAzZGQzOWY5NTJhZmFjOWJlZDIyNjMzYjY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-12-04T18:50:00Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-12-04T22:19:19Z"}, "message": "librustc: Remove all legacy pattern bindings from libsyntax and librustc. rs=refactoring", "tree": {"sha": "ede7f9ee4631628cc8603e692a0a3c1c5a00577e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ede7f9ee4631628cc8603e692a0a3c1c5a00577e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56ece46f7de9d1703dd39f952afac9bed22633b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56ece46f7de9d1703dd39f952afac9bed22633b6", "html_url": "https://github.com/rust-lang/rust/commit/56ece46f7de9d1703dd39f952afac9bed22633b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56ece46f7de9d1703dd39f952afac9bed22633b6/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94be14516968501306f1ed95774a3f227956e809", "url": "https://api.github.com/repos/rust-lang/rust/commits/94be14516968501306f1ed95774a3f227956e809", "html_url": "https://github.com/rust-lang/rust/commit/94be14516968501306f1ed95774a3f227956e809"}], "stats": {"total": 1860, "additions": 937, "deletions": 923}, "files": [{"sha": "52b94b76fe614f0ff43f5d60218a0370d9576ac6", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -412,12 +412,12 @@ fn build_link_meta(sess: Session, c: ast::crate, output: &Path,\n         for linkage_metas.each |meta| {\n             if attr::get_meta_item_name(*meta) == ~\"name\" {\n                 match attr::get_meta_item_value_str(*meta) {\n-                  Some(v) => { name = Some(v); }\n+                  Some(ref v) => { name = Some((*v)); }\n                   None => cmh_items.push(*meta)\n                 }\n             } else if attr::get_meta_item_name(*meta) == ~\"vers\" {\n                 match attr::get_meta_item_value_str(*meta) {\n-                  Some(v) => { vers = Some(v); }\n+                  Some(ref v) => { vers = Some((*v)); }\n                   None => cmh_items.push(*meta)\n                 }\n             } else { cmh_items.push(*meta); }\n@@ -443,12 +443,12 @@ fn build_link_meta(sess: Session, c: ast::crate, output: &Path,\n         symbol_hasher.reset();\n         for cmh_items.each |m| {\n             match m.node {\n-              ast::meta_name_value(key, value) => {\n-                symbol_hasher.write_str(len_and_str(key));\n+              ast::meta_name_value(ref key, value) => {\n+                symbol_hasher.write_str(len_and_str((*key)));\n                 symbol_hasher.write_str(len_and_str_lit(value));\n               }\n-              ast::meta_word(name) => {\n-                symbol_hasher.write_str(len_and_str(name));\n+              ast::meta_word(ref name) => {\n+                symbol_hasher.write_str(len_and_str((*name)));\n               }\n               ast::meta_list(_, _) => {\n                 // FIXME (#607): Implement this\n@@ -473,13 +473,13 @@ fn build_link_meta(sess: Session, c: ast::crate, output: &Path,\n     fn crate_meta_name(sess: Session, _crate: ast::crate,\n                        output: &Path, metas: provided_metas) -> ~str {\n         return match metas.name {\n-              Some(v) => v,\n+              Some(ref v) => (*v),\n               None => {\n                 let name = match output.filestem() {\n                   None => sess.fatal(fmt!(\"output file name `%s` doesn't\\\n                                            appear to have a stem\",\n                                           output.to_str())),\n-                  Some(s) => s\n+                  Some(ref s) => (*s)\n                 };\n                 warn_missing(sess, ~\"name\", name);\n                 name\n@@ -490,7 +490,7 @@ fn build_link_meta(sess: Session, c: ast::crate, output: &Path,\n     fn crate_meta_vers(sess: Session, _crate: ast::crate,\n                        metas: provided_metas) -> ~str {\n         return match metas.vers {\n-              Some(v) => v,\n+              Some(ref v) => (*v),\n               None => {\n                 let vers = ~\"0.0\";\n                 warn_missing(sess, ~\"vers\", vers);\n@@ -534,7 +534,7 @@ fn symbol_hash(tcx: ty::ctxt, symbol_hasher: &hash::State, t: ty::t,\n \n fn get_symbol_hash(ccx: @crate_ctxt, t: ty::t) -> ~str {\n     match ccx.type_hashcodes.find(t) {\n-      Some(h) => return h,\n+      Some(ref h) => return (*h),\n       None => {\n         let hash = symbol_hash(ccx.tcx, ccx.symbol_hasher, t, ccx.link_meta);\n         ccx.type_hashcodes.insert(t, hash);"}, {"sha": "a131386ba16b0ad0e2fa5caeaedae5391920663e", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -39,7 +39,7 @@ fn anon_src() -> ~str { ~\"<anon>\" }\n \n fn source_name(input: input) -> ~str {\n     match input {\n-      file_input(ifile) => ifile.to_str(),\n+      file_input(ref ifile) => (*ifile).to_str(),\n       str_input(_) => anon_src()\n     }\n }\n@@ -121,13 +121,13 @@ enum input {\n fn parse_input(sess: Session, cfg: ast::crate_cfg, input: input)\n     -> @ast::crate {\n     match input {\n-      file_input(file) => {\n-        parse::parse_crate_from_file(&file, cfg, sess.parse_sess)\n+      file_input(ref file) => {\n+        parse::parse_crate_from_file(&(*file), cfg, sess.parse_sess)\n       }\n-      str_input(src) => {\n+      str_input(ref src) => {\n         // FIXME (#2319): Don't really want to box the source string\n         parse::parse_crate_from_source_str(\n-            anon_src(), @src, cfg, sess.parse_sess)\n+            anon_src(), @(*src), cfg, sess.parse_sess)\n       }\n     }\n }\n@@ -337,10 +337,10 @@ fn pretty_print_input(sess: Session, cfg: ast::crate_cfg, input: input,\n             pp::space(s.s);\n             pprust::synth_comment(s, int::to_str(item.id, 10u));\n           }\n-          pprust::node_block(s, blk) => {\n+          pprust::node_block(s, ref blk) => {\n             pp::space(s.s);\n             pprust::synth_comment(s,\n-                                  ~\"block \" + int::to_str(blk.node.id, 10u));\n+                                  ~\"block \" + int::to_str((*blk).node.id, 10u));\n           }\n           pprust::node_expr(s, expr) => {\n             pp::space(s.s);\n@@ -563,7 +563,7 @@ fn build_session_options(binary: ~str,\n     let target =\n         match target_opt {\n             None => host_triple(),\n-            Some(s) => s\n+            Some(ref s) => (*s)\n         };\n \n     let addl_lib_search_paths =\n@@ -743,15 +743,15 @@ fn build_output_filenames(input: input,\n         // have to make up a name\n         // We want to toss everything after the final '.'\n         let dirpath = match *odir {\n-          Some(d) => d,\n+          Some(ref d) => (*d),\n           None => match input {\n             str_input(_) => os::getcwd(),\n-            file_input(ifile) => ifile.dir_path()\n+            file_input(ref ifile) => (*ifile).dir_path()\n           }\n         };\n \n         let stem = match input {\n-          file_input(ifile) => ifile.filestem().get(),\n+          file_input(ref ifile) => (*ifile).filestem().get(),\n           str_input(_) => ~\"rust_out\"\n         };\n \n@@ -764,12 +764,12 @@ fn build_output_filenames(input: input,\n         }\n       }\n \n-      Some(out_file) => {\n-        out_path = out_file;\n+      Some(ref out_file) => {\n+        out_path = (*out_file);\n         obj_path = if stop_after_codegen {\n-            out_file\n+            (*out_file)\n         } else {\n-            out_file.with_filetype(obj_suffix)\n+            (*out_file).with_filetype(obj_suffix)\n         };\n \n         if sess.building_library {"}, {"sha": "3f24d28043799b684a8a925d3823ecc5a083fcca", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -1086,7 +1086,7 @@ fn type_to_str(names: type_names, ty: TypeRef) -> ~str {\n fn type_to_str_inner(names: type_names, outer0: ~[TypeRef], ty: TypeRef) ->\n    ~str {\n     match type_has_name(names, ty) {\n-      option::Some(n) => return n,\n+      option::Some(ref n) => return (*n),\n       _ => {}\n     }\n "}, {"sha": "9c734f8e69873223ab02d4edb3850d5a3aed768b", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -125,7 +125,7 @@ fn visit_item(e: env, i: @ast::item) {\n             if abi != ast::foreign_abi_cdecl &&\n                abi != ast::foreign_abi_stdcall { return; }\n           }\n-          either::Left(msg) => e.diag.span_fatal(i.span, msg)\n+          either::Left(ref msg) => e.diag.span_fatal(i.span, (*msg))\n         }\n \n         let cstore = e.cstore;\n@@ -137,13 +137,13 @@ fn visit_item(e: env, i: @ast::item) {\n             let foreign_name =\n                match attr::first_attr_value_str_by_name(i.attrs,\n                                                         ~\"link_name\") {\n-                 Some(nn) => {\n-                   if nn == ~\"\" {\n+                 Some(ref nn) => {\n+                   if (*nn) == ~\"\" {\n                       e.diag.span_fatal(\n                           i.span,\n                           ~\"empty #[link_name] not allowed; use #[nolink].\");\n                    }\n-                   nn\n+                   (*nn)\n                  }\n                 None => *e.intr.get(i.ident)\n             };\n@@ -161,8 +161,8 @@ fn visit_item(e: env, i: @ast::item) {\n \n         for link_args.each |a| {\n             match attr::get_meta_item_value_str(attr::attr_meta(*a)) {\n-              Some(linkarg) => {\n-                cstore::add_used_link_args(cstore, linkarg);\n+              Some(ref linkarg) => {\n+                cstore::add_used_link_args(cstore, (*linkarg));\n               }\n               None => {/* fallthrough */ }\n             }\n@@ -236,7 +236,7 @@ fn resolve_crate(e: env, ident: ast::ident, metas: ~[@ast::meta_item],\n \n         let cname =\n             match attr::last_meta_item_value_str_by_name(metas, ~\"name\") {\n-              option::Some(v) => v,\n+              option::Some(ref v) => (*v),\n               option::None => *e.intr.get(ident)\n             };\n         let cmeta = @{name: cname, data: cdata,"}, {"sha": "d1c71b95191be1e25d573bde8d587b25ad934cc8", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -603,15 +603,15 @@ fn maybe_get_item_ast(intr: @ident_interner, cdata: cmd, tcx: ty::ctxt,\n     let item_doc = lookup_item(id, cdata.data);\n     let path = vec::init(item_path(intr, item_doc));\n     match decode_inlined_item(cdata, tcx, path, item_doc) {\n-      Some(ii) => csearch::found(ii),\n+      Some(ref ii) => csearch::found((*ii)),\n       None => {\n         match item_parent_item(item_doc) {\n           Some(did) => {\n             let did = translate_def_id(cdata, did);\n             let parent_item = lookup_item(did.node, cdata.data);\n             match decode_inlined_item(cdata, tcx, path,\n                                                parent_item) {\n-              Some(ii) => csearch::found_parent(did, ii),\n+              Some(ref ii) => csearch::found_parent(did, (*ii)),\n               None => csearch::not_found\n             }\n           }\n@@ -635,7 +635,7 @@ fn get_enum_variants(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n                                 tcx, cdata);\n         let name = item_name(intr, item);\n         let arg_tys = match ty::get(ctor_ty).sty {\n-          ty::ty_fn(f) => f.sig.inputs.map(|a| a.ty),\n+          ty::ty_fn(ref f) => (*f).sig.inputs.map(|a| a.ty),\n \n           // Nullary enum variant.\n           _ => ~[],\n@@ -750,7 +750,7 @@ fn get_trait_methods(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n         let ty = doc_type(mth, tcx, cdata);\n         let def_id = item_def_id(mth, cdata);\n         let fty = match ty::get(ty).sty {\n-          ty::ty_fn(f) => f,\n+          ty::ty_fn(ref f) => (*f),\n           _ => {\n             tcx.diag.handler().bug(\n                 ~\"get_trait_methods: id has non-function type\");\n@@ -781,7 +781,7 @@ fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n \n         let fty;\n         match ty::get(ty).sty {\n-            ty::ty_fn(f) => fty = f,\n+            ty::ty_fn(ref f) => fty = (*f),\n             _ => {\n                 tcx.diag.handler().bug(~\"get_provided_trait_methods(): id \\\n                                          has non-function type\");\n@@ -1104,7 +1104,7 @@ fn get_crate_vers(data: @~[u8]) -> ~str {\n     let attrs = decoder::get_crate_attributes(data);\n     return match attr::last_meta_item_value_str_by_name(\n         attr::find_linkage_metas(attrs), ~\"vers\") {\n-      Some(ver) => ver,\n+      Some(ref ver) => (*ver),\n       None => ~\"0.0\"\n     };\n }"}, {"sha": "f48cdea64d04eb79af8571385d89279ad22c0ee3", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -218,7 +218,7 @@ fn encode_type(ecx: @encode_ctxt, ebml_w: Writer::Serializer, typ: ty::t) {\n fn encode_symbol(ecx: @encode_ctxt, ebml_w: Writer::Serializer, id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     let sym = match ecx.item_symbols.find(id) {\n-      Some(x) => x,\n+      Some(ref x) => (*x),\n       None => {\n         ecx.diag.handler().bug(\n             fmt!(\"encode_symbol: id not found %d\", id));\n@@ -341,9 +341,9 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n     // Encode the reexports of this module.\n     debug!(\"(encoding info for module) encoding reexports for %d\", id);\n     match ecx.reexports2.find(id) {\n-        Some(exports) => {\n+        Some(ref exports) => {\n             debug!(\"(encoding info for module) found reexports for %d\", id);\n-            for exports.each |exp| {\n+            for (*exports).each |exp| {\n                 debug!(\"(encoding info for module) reexport '%s' for %d\",\n                        exp.name, id);\n                 ebml_w.start_tag(tag_items_data_item_reexport);\n@@ -483,8 +483,8 @@ fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n         encode_type(ecx, ebml_w, its_ty);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(ident));\n         match item {\n-           Some(it) => {\n-             (ecx.encode_inlined_item)(ecx, ebml_w, path, it);\n+           Some(ref it) => {\n+             (ecx.encode_inlined_item)(ecx, ebml_w, path, (*it));\n            }\n            None => {\n              encode_symbol(ecx, ebml_w, id);\n@@ -622,23 +622,23 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n         encode_region_param(ecx, ebml_w, item);\n         ebml_w.end_tag();\n       }\n-      item_enum(enum_definition, tps) => {\n+      item_enum(ref enum_definition, tps) => {\n         add_to_index();\n         do ebml_w.wr_tag(tag_items_data_item) {\n             encode_def_id(ebml_w, local_def(item.id));\n             encode_family(ebml_w, 't');\n             encode_type_param_bounds(ebml_w, ecx, tps);\n             encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n             encode_name(ecx, ebml_w, item.ident);\n-            for enum_definition.variants.each |v| {\n+            for (*enum_definition).variants.each |v| {\n                 encode_variant_id(ebml_w, local_def(v.node.id));\n             }\n             (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n             encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n             encode_region_param(ecx, ebml_w, item);\n         }\n         encode_enum_variant_info(ecx, ebml_w, item.id,\n-                                 enum_definition.variants, path, index, tps);\n+                                 (*enum_definition).variants, path, index, tps);\n       }\n       item_class(struct_def, tps) => {\n         /* First, encode the fields and methods\n@@ -764,7 +764,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n                                    vec::append(tps, m.tps));\n         }\n       }\n-      item_trait(tps, traits, ms) => {\n+      item_trait(tps, traits, ref ms) => {\n         let provided_methods = dvec::DVec();\n \n         add_to_index();\n@@ -778,12 +778,12 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n         encode_attributes(ebml_w, item.attrs);\n         let mut i = 0u;\n         for vec::each(*ty::trait_methods(tcx, local_def(item.id))) |mty| {\n-            match ms[i] {\n-              required(ty_m) => {\n+            match (*ms)[i] {\n+              required(ref ty_m) => {\n                 ebml_w.start_tag(tag_item_trait_method);\n-                encode_def_id(ebml_w, local_def(ty_m.id));\n+                encode_def_id(ebml_w, local_def((*ty_m).id));\n                 encode_name(ecx, ebml_w, mty.ident);\n-                encode_type_param_bounds(ebml_w, ecx, ty_m.tps);\n+                encode_type_param_bounds(ebml_w, ecx, (*ty_m).tps);\n                 encode_type(ecx, ebml_w, ty::mk_fn(tcx, mty.fty));\n                 encode_family(ebml_w, purity_fn_family(mty.fty.meta.purity));\n                 encode_self_type(ebml_w, mty.self_ty);\n@@ -816,7 +816,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: Writer::Serializer,\n         // method info, we output static methods with type signatures as\n         // written. Here, we output the *real* type signatures. I feel like\n         // maybe we should only ever handle the real type signatures.\n-        for vec::each(ms) |m| {\n+        for vec::each((*ms)) |m| {\n             let ty_m = ast_util::trait_method_to_ty_method(*m);\n             if ty_m.self_ty.node != ast::sty_static { loop; }\n \n@@ -971,19 +971,19 @@ fn write_int(writer: io::Writer, &&n: int) {\n \n fn encode_meta_item(ebml_w: Writer::Serializer, mi: meta_item) {\n     match mi.node {\n-      meta_word(name) => {\n+      meta_word(ref name) => {\n         ebml_w.start_tag(tag_meta_item_word);\n         ebml_w.start_tag(tag_meta_item_name);\n-        ebml_w.writer.write(str::to_bytes(name));\n+        ebml_w.writer.write(str::to_bytes((*name)));\n         ebml_w.end_tag();\n         ebml_w.end_tag();\n       }\n-      meta_name_value(name, value) => {\n+      meta_name_value(ref name, value) => {\n         match value.node {\n           lit_str(value) => {\n             ebml_w.start_tag(tag_meta_item_name_value);\n             ebml_w.start_tag(tag_meta_item_name);\n-            ebml_w.writer.write(str::to_bytes(name));\n+            ebml_w.writer.write(str::to_bytes((*name)));\n             ebml_w.end_tag();\n             ebml_w.start_tag(tag_meta_item_value);\n             ebml_w.writer.write(str::to_bytes(*value));\n@@ -993,10 +993,10 @@ fn encode_meta_item(ebml_w: Writer::Serializer, mi: meta_item) {\n           _ => {/* FIXME (#623): encode other variants */ }\n         }\n       }\n-      meta_list(name, items) => {\n+      meta_list(ref name, items) => {\n         ebml_w.start_tag(tag_meta_item_list);\n         ebml_w.start_tag(tag_meta_item_name);\n-        ebml_w.writer.write(str::to_bytes(name));\n+        ebml_w.writer.write(str::to_bytes((*name)));\n         ebml_w.end_tag();\n         for items.each |inner_item| {\n             encode_meta_item(ebml_w, **inner_item);"}, {"sha": "be4968636f158aa03d2d4b2e1a990df252ebcce2", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -53,11 +53,11 @@ fn mk_filesearch(maybe_sysroot: Option<Path>,\n                 make_target_lib_path(&self.sysroot,\n                                      self.target_triple));\n             match get_cargo_lib_path_nearest() {\n-              result::Ok(p) => paths.push(p),\n+              result::Ok(ref p) => paths.push((*p)),\n               result::Err(_) => ()\n             }\n             match get_cargo_lib_path() {\n-              result::Ok(p) => paths.push(p),\n+              result::Ok(ref p) => paths.push((*p)),\n               result::Err(_) => ()\n             }\n             paths\n@@ -110,14 +110,14 @@ fn make_target_lib_path(sysroot: &Path,\n \n fn get_default_sysroot() -> Path {\n     match os::self_exe_path() {\n-      option::Some(p) => p.pop(),\n+      option::Some(ref p) => (*p).pop(),\n       option::None => fail ~\"can't determine value for sysroot\"\n     }\n }\n \n fn get_sysroot(maybe_sysroot: Option<Path>) -> Path {\n     match maybe_sysroot {\n-      option::Some(sr) => sr,\n+      option::Some(ref sr) => (*sr),\n       option::None => get_default_sysroot()\n     }\n }\n@@ -128,9 +128,9 @@ fn get_cargo_sysroot() -> Result<Path, ~str> {\n \n fn get_cargo_root() -> Result<Path, ~str> {\n     match os::getenv(~\"CARGO_ROOT\") {\n-        Some(_p) => result::Ok(Path(_p)),\n+        Some(ref _p) => result::Ok(Path((*_p))),\n         None => match os::homedir() {\n-          Some(_q) => result::Ok(_q.push(\".cargo\")),\n+          Some(ref _q) => result::Ok((*_q).push(\".cargo\")),\n           None => result::Err(~\"no CARGO_ROOT or home directory\")\n         }\n     }"}, {"sha": "b1a4fcc24cd5481940ae506bf36d56cee3916493", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -50,7 +50,7 @@ type ctxt = {\n \n fn load_library_crate(cx: ctxt) -> {ident: ~str, data: @~[u8]} {\n     match find_library_crate(cx) {\n-      Some(t) => return t,\n+      Some(ref t) => return (*t),\n       None => {\n         cx.diag.span_fatal(\n             cx.span, fmt!(\"can't find crate for `%s`\",\n@@ -135,7 +135,7 @@ fn crate_name_from_metas(metas: ~[@ast::meta_item]) -> ~str {\n     match vec::last_opt(name_items) {\n       Some(i) => {\n         match attr::get_meta_item_value_str(i) {\n-          Some(n) => n,\n+          Some(ref n) => (*n),\n           // FIXME (#2406): Probably want a warning here since the user\n           // is using the wrong type of meta item.\n           _ => fail"}, {"sha": "a928d2d55bb3f72bbf1dcd337ae40c1820511eb1", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -118,11 +118,11 @@ fn enc_mt(w: io::Writer, cx: @ctxt, mt: ty::mt) {\n }\n \n fn enc_opt<T>(w: io::Writer, t: Option<T>, enc_f: fn(T)) {\n-    match t {\n-      None => w.write_char('n'),\n-      Some(v) => {\n+    match &t {\n+      &None => w.write_char('n'),\n+      &Some(ref v) => {\n         w.write_char('s');\n-        enc_f(v);\n+        enc_f((*v));\n       }\n     }\n }\n@@ -237,18 +237,18 @@ fn enc_sty(w: io::Writer, cx: @ctxt, st: ty::sty) {\n           ty_f64 => w.write_str(&\"MF\"),\n         }\n       }\n-      ty::ty_enum(def, substs) => {\n+      ty::ty_enum(def, ref substs) => {\n         w.write_str(&\"t[\");\n         w.write_str((cx.ds)(def));\n         w.write_char('|');\n-        enc_substs(w, cx, substs);\n+        enc_substs(w, cx, (*substs));\n         w.write_char(']');\n       }\n-      ty::ty_trait(def, substs, vstore) => {\n+      ty::ty_trait(def, ref substs, vstore) => {\n         w.write_str(&\"x[\");\n         w.write_str((cx.ds)(def));\n         w.write_char('|');\n-        enc_substs(w, cx, substs);\n+        enc_substs(w, cx, (*substs));\n         enc_vstore(w, cx, vstore);\n         w.write_char(']');\n       }\n@@ -284,8 +284,8 @@ fn enc_sty(w: io::Writer, cx: @ctxt, st: ty::sty) {\n         }\n         w.write_char(']');\n       }\n-      ty::ty_fn(f) => {\n-        enc_ty_fn(w, cx, f);\n+      ty::ty_fn(ref f) => {\n+        enc_ty_fn(w, cx, (*f));\n       }\n       ty::ty_infer(ty::TyVar(id)) => {\n         w.write_char('X');\n@@ -316,15 +316,15 @@ fn enc_sty(w: io::Writer, cx: @ctxt, st: ty::sty) {\n           enc_proto(w, p);\n       }\n       ty::ty_opaque_box => w.write_char('B'),\n-      ty::ty_class(def, substs) => {\n+      ty::ty_class(def, ref substs) => {\n           debug!(\"~~~~ %s\", ~\"a[\");\n           w.write_str(&\"a[\");\n           let s = (cx.ds)(def);\n           debug!(\"~~~~ %s\", s);\n           w.write_str(s);\n           debug!(\"~~~~ %s\", ~\"|\");\n           w.write_char('|');\n-          enc_substs(w, cx, substs);\n+          enc_substs(w, cx, (*substs));\n           debug!(\"~~~~ %s\", ~\"]\");\n           w.write_char(']');\n       }"}, {"sha": "87d7710a28918706dcd0dc25a3c3af6d039c3056", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -282,11 +282,11 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n       ast::ii_foreign(i) => {\n         ast::ii_foreign(fld.fold_foreign_item(i))\n       }\n-      ast::ii_dtor(dtor, nm, tps, parent_id) => {\n-        let dtor_body = fld.fold_block(dtor.node.body);\n+      ast::ii_dtor(ref dtor, nm, tps, parent_id) => {\n+        let dtor_body = fld.fold_block((*dtor).node.body);\n         ast::ii_dtor({node: {body: dtor_body,\n-                              .. dtor.node},\n-            .. dtor}, nm, tps, parent_id)\n+                              .. (*dtor).node},\n+            .. (*dtor)}, nm, tps, parent_id)\n       }\n     }\n }\n@@ -315,16 +315,16 @@ fn renumber_ast(xcx: extended_decode_ctxt, ii: ast::inlined_item)\n       ast::ii_foreign(i) => {\n         ast::ii_foreign(fld.fold_foreign_item(i))\n       }\n-      ast::ii_dtor(dtor, nm, tps, parent_id) => {\n-        let dtor_body = fld.fold_block(dtor.node.body);\n-        let dtor_attrs = fld.fold_attributes(dtor.node.attrs);\n+      ast::ii_dtor(ref dtor, nm, tps, parent_id) => {\n+        let dtor_body = fld.fold_block((*dtor).node.body);\n+        let dtor_attrs = fld.fold_attributes((*dtor).node.attrs);\n         let new_params = fold::fold_ty_params(tps, fld);\n-        let dtor_id = fld.new_id(dtor.node.id);\n+        let dtor_id = fld.new_id((*dtor).node.id);\n         let new_parent = xcx.tr_def_id(parent_id);\n-        let new_self = fld.new_id(dtor.node.self_id);\n+        let new_self = fld.new_id((*dtor).node.self_id);\n         ast::ii_dtor({node: {id: dtor_id, attrs: dtor_attrs,\n                 self_id: new_self, body: dtor_body},\n-                        .. dtor},\n+                        .. (*dtor)},\n           nm, new_params, new_parent)\n       }\n      }\n@@ -497,8 +497,8 @@ impl method_origin: tr {\n           typeck::method_static(did) => {\n             typeck::method_static(did.tr(xcx))\n           }\n-          typeck::method_param(mp) => {\n-            typeck::method_param({trait_id:mp.trait_id.tr(xcx),.. mp})\n+          typeck::method_param(ref mp) => {\n+            typeck::method_param({trait_id:(*mp).trait_id.tr(xcx),.. (*mp)})\n           }\n           typeck::method_trait(did, m, vstore) => {\n             typeck::method_trait(did.tr(xcx), m, vstore)"}, {"sha": "7ff7c48f54a1923e2a525b8f8b3800cfa1837245", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -51,9 +51,9 @@ impl purity_cause : cmp::Eq {\n                     _ => false\n                 }\n             }\n-            pc_cmt(e0a) => {\n+            pc_cmt(ref e0a) => {\n                 match (*other) {\n-                    pc_cmt(e0b) => e0a == e0b,\n+                    pc_cmt(ref e0b) => (*e0a) == (*e0b),\n                     _ => false\n                 }\n             }\n@@ -131,7 +131,7 @@ impl check_loan_ctxt {\n         loop {\n             match pure_map.find(scope_id) {\n               None => (),\n-              Some(e) => return Some(pc_cmt(e))\n+              Some(ref e) => return Some(pc_cmt((*e)))\n             }\n \n             match region_map.find(scope_id) {\n@@ -224,14 +224,14 @@ impl check_loan_ctxt {\n \n         let callee_ty = ty::node_id_to_type(tcx, callee_id);\n         match ty::get(callee_ty).sty {\n-          ty::ty_fn(fn_ty) => {\n-            match fn_ty.meta.purity {\n+          ty::ty_fn(ref fn_ty) => {\n+            match (*fn_ty).meta.purity {\n               ast::pure_fn => return, // case (c) above\n               ast::impure_fn | ast::unsafe_fn | ast::extern_fn => {\n                 self.report_purity_error(\n                     pc, callee_span,\n                     fmt!(\"access to %s function\",\n-                         pprust::purity_to_str(fn_ty.meta.purity)));\n+                         pprust::purity_to_str((*fn_ty).meta.purity)));\n               }\n             }\n           }\n@@ -369,15 +369,17 @@ impl check_loan_ctxt {\n         // is not visible from the outside\n         match self.purity(ex.id) {\n           None => (),\n-          Some(pc @ pc_cmt(_)) => {\n+          Some(pc_cmt(_)) => {\n             // Subtle: Issue #3162.  If we are enforcing purity\n             // because there is a reference to aliasable, mutable data\n             // that we require to be immutable, we can't allow writes\n             // even to data owned by the current stack frame.  This is\n             // because that aliasable data might have been located on\n             // the current stack frame, we don't know.\n             self.report_purity_error(\n-                pc, ex.span, at.ing_form(self.bccx.cmt_to_str(cmt)));\n+                self.purity(ex.id).get(),\n+                ex.span,\n+                at.ing_form(self.bccx.cmt_to_str(cmt)));\n           }\n           Some(pc_pure_fn) => {\n             if cmt.lp.is_none() {\n@@ -446,13 +448,13 @@ impl check_loan_ctxt {\n                 sp,\n                 fmt!(\"%s prohibited in pure context\", msg));\n           }\n-          pc_cmt(e) => {\n-            if self.reported.insert(e.cmt.id, ()) {\n+          pc_cmt(ref e) => {\n+            if self.reported.insert((*e).cmt.id, ()) {\n                 self.tcx().sess.span_err(\n-                    e.cmt.span,\n+                    (*e).cmt.span,\n                     fmt!(\"illegal borrow unless pure: %s\",\n-                         self.bccx.bckerr_to_str(e)));\n-                self.bccx.note_and_explain_bckerr(e);\n+                         self.bccx.bckerr_to_str((*e))));\n+                self.bccx.note_and_explain_bckerr((*e));\n                 self.tcx().sess.span_note(\n                     sp,\n                     fmt!(\"impure due to %s\", msg));\n@@ -538,12 +540,12 @@ impl check_loan_ctxt {\n                   args: ~[@ast::expr]) {\n         match self.purity(expr.id) {\n           None => {}\n-          Some(pc) => {\n+          Some(ref pc) => {\n             self.check_pure_callee_or_arg(\n-                pc, callee, callee_id, callee_span);\n+                (*pc), callee, callee_id, callee_span);\n             for args.each |arg| {\n                 self.check_pure_callee_or_arg(\n-                    pc, Some(*arg), arg.id, arg.span);\n+                    (*pc), Some(*arg), arg.id, arg.span);\n             }\n           }\n         }"}, {"sha": "3320414ee0fa6a913998043dd833f0daacafd339", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -150,8 +150,8 @@ fn req_loans_in_expr(ex: @ast::expr,\n         }\n \n         match self.bccx.method_map.find(ex.id) {\n-            Some(method_map_entry) => {\n-                match method_map_entry.explicit_self {\n+            Some(ref method_map_entry) => {\n+                match (*method_map_entry).explicit_self {\n                     ast::sty_by_ref => {\n                         let rcvr_cmt = self.bccx.cat_expr(rcvr);\n                         self.guarantee_valid(rcvr_cmt, m_imm, scope_r);\n@@ -167,9 +167,9 @@ fn req_loans_in_expr(ex: @ast::expr,\n         visit::visit_expr(ex, self, vt);\n       }\n \n-      ast::expr_match(ex_v, arms) => {\n+      ast::expr_match(ex_v, ref arms) => {\n         let cmt = self.bccx.cat_expr(ex_v);\n-        for arms.each |arm| {\n+        for (*arms).each |arm| {\n             for arm.pats.each |pat| {\n                 self.gather_pat(cmt, *pat, arm.body.node.id, ex.id);\n             }\n@@ -228,19 +228,19 @@ fn req_loans_in_expr(ex: @ast::expr,\n       }\n \n       // see explanation attached to the `root_ub` field:\n-      ast::expr_while(cond, body) => {\n+      ast::expr_while(cond, ref body) => {\n         // during the condition, can only root for the condition\n         self.root_ub = cond.id;\n         (vt.visit_expr)(cond, self, vt);\n \n         // during body, can only root for the body\n-        self.root_ub = body.node.id;\n-        (vt.visit_block)(body, self, vt);\n+        self.root_ub = (*body).node.id;\n+        (vt.visit_block)((*body), self, vt);\n       }\n \n       // see explanation attached to the `root_ub` field:\n-      ast::expr_loop(body, _) => {\n-        self.root_ub = body.node.id;\n+      ast::expr_loop(ref body, _) => {\n+        self.root_ub = (*body).node.id;\n         visit::visit_expr(ex, self, vt);\n       }\n \n@@ -331,7 +331,7 @@ impl gather_loan_ctxt {\n           // error will be reported.\n           Some(_) => {\n               match self.bccx.loan(cmt, scope_r, req_mutbl) {\n-                  Err(e) => { self.bccx.report(e); }\n+                  Err(ref e) => { self.bccx.report((*e)); }\n                   Ok(move loans) => {\n                       self.add_loans(cmt, req_mutbl, scope_r, move loans);\n                   }\n@@ -364,8 +364,8 @@ impl gather_loan_ctxt {\n                     // rooted.  good.\n                     self.bccx.stable_paths += 1;\n                 }\n-                Ok(pc_if_pure(e)) => {\n-                    debug!(\"result of preserve: %?\", pc_if_pure(e));\n+                Ok(pc_if_pure(ref e)) => {\n+                    debug!(\"result of preserve: %?\", pc_if_pure((*e)));\n \n                     // we are only able to guarantee the validity if\n                     // the scope is pure\n@@ -374,7 +374,7 @@ impl gather_loan_ctxt {\n                             // if the scope is some block/expr in the\n                             // fn, then just require that this scope\n                             // be pure\n-                            self.req_maps.pure_map.insert(pure_id, e);\n+                            self.req_maps.pure_map.insert(pure_id, (*e));\n                             self.bccx.req_pure_paths += 1;\n \n                             debug!(\"requiring purity for scope %?\",\n@@ -390,14 +390,14 @@ impl gather_loan_ctxt {\n                             // otherwise, we can't enforce purity for\n                             // that scope, so give up and report an\n                             // error\n-                            self.bccx.report(e);\n+                            self.bccx.report((*e));\n                         }\n                     }\n                 }\n-                Err(e) => {\n+                Err(ref e) => {\n                     // we cannot guarantee the validity of this pointer\n                     debug!(\"result of preserve: error\");\n-                    self.bccx.report(e);\n+                    self.bccx.report((*e));\n                 }\n             }\n           }"}, {"sha": "7dc68fa0b4b1318c8ab7ea88842605afb737ebe6", "filename": "src/librustc/middle/borrowck/loan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -25,7 +25,7 @@ impl borrowck_ctxt {\n             loans: ~[]\n         };\n         match lc.loan(cmt, mutbl) {\n-          Err(e) => Err(e),\n+          Err(ref e) => Err((*e)),\n           Ok(()) => {\n               let LoanContext {loans, _} = move lc;\n               Ok(loans)"}, {"sha": "c5a02c978f96a67089e7ee1709fe5f2adbe37a68", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -500,7 +500,7 @@ impl borrowck_ctxt {\n     fn report_if_err(bres: bckres<()>) {\n         match bres {\n           Ok(()) => (),\n-          Err(e) => self.report(e)\n+          Err(ref e) => self.report((*e))\n         }\n     }\n "}, {"sha": "1243b9baf5f13ac72c0d8d36c429cd9f279a8b27", "filename": "src/librustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -178,9 +178,9 @@ priv impl &preserve_ctxt {\n                     debug!(\"must root @T, otherwise purity req'd\");\n                     self.attempt_root(cmt, base, derefs)\n                   }\n-                  Err(e) => {\n+                  Err(ref e) => {\n                     debug!(\"must root @T, err: %s\",\n-                           self.bccx.bckerr_to_str(e));\n+                           self.bccx.bckerr_to_str((*e)));\n                     self.attempt_root(cmt, base, derefs)\n                   }\n                 }\n@@ -274,13 +274,13 @@ priv impl &preserve_ctxt {\n           }\n \n           // the base requires purity too, that's fine\n-          Ok(pc_if_pure(e)) => {\n-            Ok(pc_if_pure(e))\n+          Ok(pc_if_pure(ref e)) => {\n+            Ok(pc_if_pure((*e)))\n           }\n \n           // base is not stable, doesn't matter\n-          Err(e) => {\n-            Err(e)\n+          Err(ref e) => {\n+            Err((*e))\n           }\n         }\n     }"}, {"sha": "bb50597dab750995bdf6585736762230476739b3", "filename": "src/librustc/middle/check_alt.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_alt.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -35,13 +35,13 @@ fn check_crate(tcx: ty::ctxt, crate: @crate) {\n fn check_expr(tcx: ty::ctxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n     visit::visit_expr(ex, s, v);\n     match ex.node {\n-      expr_match(scrut, arms) => {\n-        check_arms(tcx, arms);\n+      expr_match(scrut, ref arms) => {\n+        check_arms(tcx, (*arms));\n         /* Check for exhaustiveness */\n          // Check for empty enum, because is_useful only works on inhabited\n          // types.\n        let pat_ty = node_id_to_type(tcx, scrut.id);\n-       if arms.is_empty() {\n+       if (*arms).is_empty() {\n            if !type_is_empty(tcx, pat_ty) {\n                // We know the type is inhabited, so this must be wrong\n                tcx.sess.span_err(ex.span, fmt!(\"non-exhaustive patterns: \\\n@@ -52,14 +52,14 @@ fn check_expr(tcx: ty::ctxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n        }\n        match ty::get(pat_ty).sty {\n           ty_enum(did, _) => {\n-              if (*enum_variants(tcx, did)).is_empty() && arms.is_empty() {\n+              if (*enum_variants(tcx, did)).is_empty() && (*arms).is_empty() {\n \n                return;\n             }\n           }\n           _ => { /* We assume only enum types can be uninhabited */ }\n        }\n-       let arms = vec::concat(vec::filter_map(arms, unguarded_pat));\n+       let arms = vec::concat(vec::filter_map((*arms), unguarded_pat));\n        check_exhaustive(tcx, ex.span, arms);\n      }\n      _ => ()\n@@ -95,17 +95,17 @@ fn check_exhaustive(tcx: ty::ctxt, sp: span, pats: ~[@pat]) {\n     let ext = match is_useful(tcx, vec::map(pats, |p| ~[*p]), ~[wild()]) {\n       not_useful => return, // This is good, wildcard pattern isn't reachable\n       useful_ => None,\n-      useful(ty, ctor) => {\n+      useful(ty, ref ctor) => {\n         match ty::get(ty).sty {\n           ty::ty_bool => {\n-            match ctor {\n+            match (*ctor) {\n               val(const_bool(true)) => Some(~\"true\"),\n               val(const_bool(false)) => Some(~\"false\"),\n               _ => None\n             }\n           }\n           ty::ty_enum(id, _) => {\n-              let vid = match ctor { variant(id) => id,\n+              let vid = match (*ctor) { variant(id) => id,\n               _ => fail ~\"check_exhaustive: non-variant ctor\" };\n             match vec::find(*ty::enum_variants(tcx, id),\n                                 |v| v.id == vid) {\n@@ -118,7 +118,7 @@ fn check_exhaustive(tcx: ty::ctxt, sp: span, pats: ~[@pat]) {\n       }\n     };\n     let msg = ~\"non-exhaustive patterns\" + match ext {\n-      Some(s) => ~\": \" + s + ~\" not covered\",\n+      Some(ref s) => ~\": \" + (*s) + ~\" not covered\",\n       None => ~\"\"\n     };\n     tcx.sess.span_err(sp, msg);\n@@ -140,9 +140,9 @@ impl ctor : cmp::Eq {\n         match ((*self), (*other)) {\n             (single, single) => true,\n             (variant(did_self), variant(did_other)) => did_self == did_other,\n-            (val(cv_self), val(cv_other)) => cv_self == cv_other,\n-            (range(cv0_self, cv1_self), range(cv0_other, cv1_other)) => {\n-                cv0_self == cv0_other && cv1_self == cv1_other\n+            (val(ref cv_self), val(ref cv_other)) => (*cv_self) == (*cv_other),\n+            (range(ref cv0_self, ref cv1_self), range(ref cv0_other, ref cv1_other)) => {\n+                (*cv0_self) == (*cv0_other) && (*cv1_self) == (*cv1_other)\n             }\n             (single, _) | (variant(_), _) | (val(_), _) | (range(*), _) => {\n                 false\n@@ -186,15 +186,15 @@ fn is_useful(tcx: ty::ctxt, m: matrix, v: ~[@pat]) -> useful {\n                     is_useful_specialized(tcx, m, v, val(const_bool(false)),\n                                           0u, left_ty)\n                   }\n-                  u => u\n+                  ref u => (*u)\n                 }\n               }\n               ty::ty_enum(eid, _) => {\n                 for (*ty::enum_variants(tcx, eid)).each |va| {\n                     match is_useful_specialized(tcx, m, v, variant(va.id),\n                                               va.args.len(), left_ty) {\n                       not_useful => (),\n-                      u => return u\n+                      ref u => return (*u)\n                     }\n                 }\n                 not_useful\n@@ -205,18 +205,18 @@ fn is_useful(tcx: ty::ctxt, m: matrix, v: ~[@pat]) -> useful {\n               }\n             }\n           }\n-          Some(ctor) => {\n+          Some(ref ctor) => {\n             match is_useful(tcx, vec::filter_map(m, |r| default(tcx, *r) ),\n                           vec::tail(v)) {\n-              useful_ => useful(left_ty, ctor),\n-              u => u\n+              useful_ => useful(left_ty, (*ctor)),\n+              ref u => (*u)\n             }\n           }\n         }\n       }\n-      Some(v0_ctor) => {\n-        let arity = ctor_arity(tcx, v0_ctor, left_ty);\n-        is_useful_specialized(tcx, m, v, v0_ctor, arity, left_ty)\n+      Some(ref v0_ctor) => {\n+        let arity = ctor_arity(tcx, (*v0_ctor), left_ty);\n+        is_useful_specialized(tcx, m, v, (*v0_ctor), arity, left_ty)\n       }\n     }\n }\n@@ -228,7 +228,7 @@ fn is_useful_specialized(tcx: ty::ctxt, m: matrix, v: ~[@pat], ctor: ctor,\n         tcx, ms, specialize(tcx, v, ctor, arity, lty).get());\n     match could_be_useful {\n       useful_ => useful(lty, ctor),\n-      u => u\n+      ref u => (*u)\n     }\n }\n \n@@ -362,10 +362,10 @@ fn specialize(tcx: ty::ctxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n             let const_expr = lookup_const_by_id(tcx, did).get();\n             let e_v = eval_const_expr(tcx, const_expr);\n             let match_ = match ctor_id {\n-                val(v) => compare_const_vals(e_v, v) == 0,\n-                range(c_lo, c_hi) => {\n-                    compare_const_vals(c_lo, e_v) >= 0 &&\n-                        compare_const_vals(c_hi, e_v) <= 0\n+                val(ref v) => compare_const_vals(e_v, (*v)) == 0,\n+                range(ref c_lo, ref c_hi) => {\n+                    compare_const_vals((*c_lo), e_v) >= 0 &&\n+                        compare_const_vals((*c_hi), e_v) <= 0\n                 }\n                 single => true,\n                 _ => fail ~\"type error\"\n@@ -456,10 +456,10 @@ fn specialize(tcx: ty::ctxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n       pat_lit(expr) => {\n         let e_v = eval_const_expr(tcx, expr);\n         let match_ = match ctor_id {\n-          val(v) => compare_const_vals(e_v, v) == 0,\n-          range(c_lo, c_hi) => {\n-            compare_const_vals(c_lo, e_v) >= 0 &&\n-                compare_const_vals(c_hi, e_v) <= 0\n+          val(ref v) => compare_const_vals(e_v, (*v)) == 0,\n+          range(ref c_lo, ref c_hi) => {\n+            compare_const_vals((*c_lo), e_v) >= 0 &&\n+                compare_const_vals((*c_hi), e_v) <= 0\n           }\n           single => true,\n           _ => fail ~\"type error\"\n@@ -468,8 +468,8 @@ fn specialize(tcx: ty::ctxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n       }\n       pat_range(lo, hi) => {\n         let (c_lo, c_hi) = match ctor_id {\n-          val(v) => (v, v),\n-          range(lo, hi) => (lo, hi),\n+          val(ref v) => ((*v), (*v)),\n+          range(ref lo, ref hi) => ((*lo), (*hi)),\n           single => return Some(vec::tail(r)),\n           _ => fail ~\"type error\"\n         };"}, {"sha": "4639c1f31f38f7dd3069a8facc31da976e90dabc", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -35,8 +35,8 @@ fn check_item(sess: Session, ast_map: ast_map::map,\n         (v.visit_expr)(ex, true, v);\n         check_item_recursion(sess, ast_map, def_map, it);\n       }\n-      item_enum(enum_definition, _) => {\n-        for enum_definition.variants.each |var| {\n+      item_enum(ref enum_definition, _) => {\n+        for (*enum_definition).variants.each |var| {\n             do option::iter(&var.node.disr_expr) |ex| {\n                 (v.visit_expr)(*ex, true, v);\n             }"}, {"sha": "5ff186126fb0c96ce1d159dc982ebddf8156d3ef", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -22,23 +22,23 @@ fn check_crate(tcx: ty::ctxt, crate: @crate) {\n         },\n         visit_expr: |e: @expr, cx: ctx, v: visit::vt<ctx>| {\n             match e.node {\n-              expr_while(e, b) => {\n+              expr_while(e, ref b) => {\n                 (v.visit_expr)(e, cx, v);\n-                (v.visit_block)(b, {in_loop: true,.. cx}, v);\n+                (v.visit_block)((*b), {in_loop: true,.. cx}, v);\n               }\n-              expr_loop(b, _) => {\n-                (v.visit_block)(b, {in_loop: true,.. cx}, v);\n+              expr_loop(ref b, _) => {\n+                (v.visit_block)((*b), {in_loop: true,.. cx}, v);\n               }\n               expr_fn(_, _, _, _) => {\n                 visit::visit_expr(e, {in_loop: false, can_ret: true}, v);\n               }\n-              expr_fn_block(_, b, _) => {\n-                (v.visit_block)(b, {in_loop: false, can_ret: false}, v);\n+              expr_fn_block(_, ref b, _) => {\n+                (v.visit_block)((*b), {in_loop: false, can_ret: false}, v);\n               }\n-              expr_loop_body(@{node: expr_fn_block(_, b, _), _}) => {\n+              expr_loop_body(@{node: expr_fn_block(_, ref b, _), _}) => {\n                 let proto = ty::ty_fn_proto(ty::expr_ty(tcx, e));\n                 let blk = (proto == ProtoBorrowed);\n-                (v.visit_block)(b, {in_loop: true, can_ret: blk}, v);\n+                (v.visit_block)((*b), {in_loop: true, can_ret: blk}, v);\n               }\n               expr_break(_) => {\n                 if !cx.in_loop {"}, {"sha": "5b3eb1e7266cda73a4a86d4ed649badfa9ab3880", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -107,9 +107,9 @@ fn classify(e: @expr,\n                   }\n               }\n \n-              ast::expr_struct(_, fs, None) |\n-              ast::expr_rec(fs, None) => {\n-                let cs = do vec::map(fs) |f| {\n+              ast::expr_struct(_, ref fs, None) |\n+              ast::expr_rec(ref fs, None) => {\n+                let cs = do vec::map((*fs)) |f| {\n                     if f.node.mutbl == ast::m_imm {\n                         classify(f.node.expr, def_map, tcx)\n                     } else {\n@@ -222,7 +222,7 @@ impl const_val : cmp::Eq {\n             (const_float(a), const_float(b)) => a == b,\n             (const_int(a), const_int(b)) => a == b,\n             (const_uint(a), const_uint(b)) => a == b,\n-            (const_str(a), const_str(b)) => a == b,\n+            (const_str(ref a), const_str(ref b)) => (*a) == (*b),\n             (const_bool(a), const_bool(b)) => a == b,\n             (const_float(_), _) | (const_int(_), _) | (const_uint(_), _) |\n             (const_str(_), _) | (const_bool(_), _) => false\n@@ -233,8 +233,8 @@ impl const_val : cmp::Eq {\n \n fn eval_const_expr(tcx: middle::ty::ctxt, e: @expr) -> const_val {\n     match eval_const_expr_partial(tcx, e) {\n-        Ok(r) => r,\n-        Err(s) => fail s\n+        Ok(ref r) => (*r),\n+        Err(ref s) => fail (*s)\n     }\n }\n \n@@ -250,7 +250,7 @@ fn eval_const_expr_partial(tcx: middle::ty::ctxt, e: @expr)\n           Ok(const_uint(i)) => Ok(const_uint(-i)),\n           Ok(const_str(_)) => Err(~\"Negate on string\"),\n           Ok(const_bool(_)) => Err(~\"Negate on boolean\"),\n-          err => err\n+          ref err => (*err)\n         }\n       }\n       expr_unary(not, inner) => {\n@@ -438,10 +438,10 @@ fn compare_const_vals(a: const_val, b: const_val) -> int {\n             1\n         }\n     }\n-    (const_str(a), const_str(b)) => {\n-        if a == b {\n+    (const_str(ref a), const_str(ref b)) => {\n+        if (*a) == (*b) {\n             0\n-        } else if a < b {\n+        } else if (*a) < (*b) {\n             -1\n         } else {\n             1"}, {"sha": "443c72864108d75a265c2b371ec6f92c4947d0e5", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -308,8 +308,8 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n         check_copy_ex(cx, ls, false, reason);\n         check_copy_ex(cx, rs, false, reason);\n       }\n-      expr_rec(fields, def) | expr_struct(_, fields, def) => {\n-        for fields.each |field| { maybe_copy(cx, field.node.expr,\n+      expr_rec(ref fields, def) | expr_struct(_, ref fields, def) => {\n+        for (*fields).each |field| { maybe_copy(cx, field.node.expr,\n                                    Some((\"record or struct fields require \\\n                                           copyable arguments\", \"\"))); }\n         match def {\n@@ -318,13 +318,13 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n             let t = ty::expr_ty(cx.tcx, ex);\n             let ty_fields = match ty::get(t).sty {\n               ty::ty_rec(f) => f,\n-              ty::ty_class(did, substs) =>\n-                  ty::class_items_as_fields(cx.tcx, did, &substs),\n+              ty::ty_class(did, ref substs) =>\n+                  ty::class_items_as_fields(cx.tcx, did, &(*substs)),\n               _ => cx.tcx.sess.span_bug(ex.span,\n                                         ~\"bad base expr type in record\")\n             };\n             for ty_fields.each |tf| {\n-                if !vec::any(fields, |f| f.node.ident == tf.ident ) &&\n+                if !vec::any((*fields), |f| f.node.ident == tf.ident ) &&\n                     !ty::kind_can_be_copied(ty::type_kind(cx.tcx, tf.mt.ty)) {\n                     cx.tcx.sess.span_err(e.span,\n                                          ~\"copying a noncopyable value\");\n@@ -593,7 +593,7 @@ fn check_cast_for_escaping_regions(\n     // worries.\n     let target_ty = ty::expr_ty(cx.tcx, target);\n     let target_substs = match ty::get(target_ty).sty {\n-      ty::ty_trait(_, substs, _) => {substs}\n+      ty::ty_trait(_, ref substs, _) => {(*substs)}\n       _ => { return; /* not a cast to a trait */ }\n     };\n "}, {"sha": "919d24035f8c25f85ccf913c44863d76141d357b", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -153,10 +153,10 @@ impl LanguageItemCollector {\n     fn match_and_collect_meta_item(item_def_id: def_id,\n                                    meta_item: meta_item) {\n         match meta_item.node {\n-            meta_name_value(key, literal) => {\n+            meta_name_value(ref key, literal) => {\n                 match literal.node {\n                     lit_str(value) => {\n-                        self.match_and_collect_item(item_def_id, key, *value);\n+                        self.match_and_collect_item(item_def_id, (*key), *value);\n                     }\n                     _ => {} // Skip.\n                 }"}, {"sha": "e290add25e9cc5fbea0aef072cdb835194eaaebb", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -303,8 +303,8 @@ impl ctxt {\n                   ast::meta_list(_, metas) => {\n                     for metas.each |meta| {\n                         match meta.node {\n-                          ast::meta_word(lintname) => {\n-                            triples.push((*meta, *level, lintname));\n+                          ast::meta_word(ref lintname) => {\n+                            triples.push((*meta, *level, *lintname));\n                           }\n                           _ => {\n                             self.sess.span_err(\n@@ -547,9 +547,9 @@ fn check_item_type_limits(cx: ty::ctxt, it: @ast::item) {\n     let visit = item_stopping_visitor(visit::mk_simple_visitor(@{\n         visit_expr: fn@(e: @ast::expr) {\n             match e.node {\n-                ast::expr_binary(binop, @l, @r) => {\n-                    if is_comparison(binop)\n-                       && !check_limits(cx, binop, &l, &r) {\n+                ast::expr_binary(ref binop, @ref l, @ref r) => {\n+                    if is_comparison(*binop)\n+                       && !check_limits(cx, *binop, l, r) {\n                         cx.sess.span_lint(\n                             type_limits, e.id, it.id, e.span,\n                             ~\"comparison is useless due to type limits\");\n@@ -756,7 +756,7 @@ fn check_item_non_camel_case_types(cx: ty::ctxt, it: @ast::item) {\n       ast::item_trait(*) => {\n         check_case(cx, it.ident, it.id, it.id, it.span)\n       }\n-      ast::item_enum(enum_definition, _) => {\n+      ast::item_enum(ref enum_definition, _) => {\n         check_case(cx, it.ident, it.id, it.id, it.span);\n         for enum_definition.variants.each |variant| {\n             check_case(cx, variant.node.name,\n@@ -782,6 +782,7 @@ fn check_pat(tcx: ty::ctxt, pat: @ast::pat) {\n                     span,\n                     fmt!(\"binding `%s` should use ref or copy mode\",\n                          tcx.sess.str_of(path_to_ident(path))));\n+                tcx.bad_bindings.insert(id, ());\n             }\n           }\n         }\n@@ -806,7 +807,7 @@ fn check_fn(tcx: ty::ctxt, fk: visit::fn_kind, decl: ast::fn_decl,\n fn check_fn_deprecated_modes(tcx: ty::ctxt, fn_ty: ty::t, decl: ast::fn_decl,\n                              span: span, id: ast::node_id) {\n     match ty::get(fn_ty).sty {\n-        ty::ty_fn(fn_ty) => {\n+        ty::ty_fn(ref fn_ty) => {\n             let mut counter = 0;\n             for vec::each2(fn_ty.sig.inputs, decl.inputs) |arg_ty, arg_ast| {\n                 counter += 1;"}, {"sha": "c24c267bc36d1deffbd88c809347fab1a013b972", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -1058,15 +1058,15 @@ impl Liveness {\n               self.propagate_through_expr(e, succ)\n           }\n \n-          expr_fn(_, _, blk, _) | expr_fn_block(_, blk, _) => {\n+          expr_fn(_, _, ref blk, _) | expr_fn_block(_, ref blk, _) => {\n               debug!(\"%s is an expr_fn or expr_fn_block\",\n                    expr_to_str(expr, self.tcx.sess.intr()));\n \n               /*\n               The next-node for a break is the successor of the entire\n               loop. The next-node for a continue is the top of this loop.\n               */\n-              self.with_loop_nodes(blk.node.id, succ,\n+              self.with_loop_nodes((*blk).node.id, succ,\n                   self.live_node(expr.id, expr.span), || {\n \n                  // the construction of a closure itself is not important,\n@@ -1081,7 +1081,7 @@ impl Liveness {\n               })\n           }\n \n-          expr_if(cond, then, els) => {\n+          expr_if(cond, ref then, els) => {\n             //\n             //     (cond)\n             //       |\n@@ -1096,24 +1096,24 @@ impl Liveness {\n             //   (  succ  )\n             //\n             let else_ln = self.propagate_through_opt_expr(els, succ);\n-            let then_ln = self.propagate_through_block(then, succ);\n+            let then_ln = self.propagate_through_block((*then), succ);\n             let ln = self.live_node(expr.id, expr.span);\n             self.init_from_succ(ln, else_ln);\n             self.merge_from_succ(ln, then_ln, false);\n             self.propagate_through_expr(cond, ln)\n           }\n \n-          expr_while(cond, blk) => {\n-            self.propagate_through_loop(expr, Some(cond), blk, succ)\n+          expr_while(cond, ref blk) => {\n+            self.propagate_through_loop(expr, Some(cond), (*blk), succ)\n           }\n \n           // Note that labels have been resolved, so we don't need to look\n           // at the label ident\n-          expr_loop(blk, _) => {\n-            self.propagate_through_loop(expr, None, blk, succ)\n+          expr_loop(ref blk, _) => {\n+            self.propagate_through_loop(expr, None, (*blk), succ)\n           }\n \n-          expr_match(e, arms) => {\n+          expr_match(e, ref arms) => {\n             //\n             //      (e)\n             //       |\n@@ -1131,7 +1131,7 @@ impl Liveness {\n             let ln = self.live_node(expr.id, expr.span);\n             self.init_empty(ln, succ);\n             let mut first_merge = true;\n-            for arms.each |arm| {\n+            for (*arms).each |arm| {\n                 let body_succ =\n                     self.propagate_through_block(arm.body, succ);\n                 let guard_succ =\n@@ -1223,16 +1223,16 @@ impl Liveness {\n             self.propagate_through_expr(element, succ)\n           }\n \n-          expr_rec(fields, with_expr) => {\n+          expr_rec(ref fields, with_expr) => {\n             let succ = self.propagate_through_opt_expr(with_expr, succ);\n-            do fields.foldr(succ) |field, succ| {\n+            do (*fields).foldr(succ) |field, succ| {\n                 self.propagate_through_expr(field.node.expr, succ)\n             }\n           }\n \n-          expr_struct(_, fields, with_expr) => {\n+          expr_struct(_, ref fields, with_expr) => {\n             let succ = self.propagate_through_opt_expr(with_expr, succ);\n-            do fields.foldr(succ) |field, succ| {\n+            do (*fields).foldr(succ) |field, succ| {\n                 self.propagate_through_expr(field.node.expr, succ)\n             }\n           }\n@@ -1294,8 +1294,8 @@ impl Liveness {\n             succ\n           }\n \n-          expr_block(blk) => {\n-            self.propagate_through_block(blk, succ)\n+          expr_block(ref blk) => {\n+            self.propagate_through_block((*blk), succ)\n           }\n \n           expr_mac(*) => {"}, {"sha": "f202a81f049104d5e9a44a4939c4de12bf6acf92", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -315,7 +315,7 @@ fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n         Some(deref_ptr(uniq_ptr))\n       }\n \n-      ty::ty_fn(f) if f.meta.proto == ast::ProtoUniq => {\n+      ty::ty_fn(ref f) if (*f).meta.proto == ast::ProtoUniq => {\n         Some(deref_ptr(uniq_ptr))\n       }\n \n@@ -325,8 +325,8 @@ fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n         Some(deref_ptr(region_ptr(r)))\n       }\n \n-      ty::ty_fn(f) if f.meta.proto == ast::ProtoBorrowed => {\n-        Some(deref_ptr(region_ptr(f.meta.region)))\n+      ty::ty_fn(ref f) if (*f).meta.proto == ast::ProtoBorrowed => {\n+        Some(deref_ptr(region_ptr((*f).meta.region)))\n       }\n \n       ty::ty_box(*) |\n@@ -335,7 +335,7 @@ fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n         Some(deref_ptr(gc_ptr))\n       }\n \n-      ty::ty_fn(f) if f.meta.proto == ast::ProtoBox => {\n+      ty::ty_fn(ref f) if (*f).meta.proto == ast::ProtoBox => {\n         Some(deref_ptr(gc_ptr))\n       }\n "}, {"sha": "e2f95cd270f24487ec65d7351f86b136b3e84dbd", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -131,14 +131,14 @@ fn check_crate(tcx: ty::ctxt, method_map: &method_map, crate: @ast::crate) {\n                     match tcx.items.find(trait_id.node) {\n                         Some(node_item(item, _)) => {\n                             match item.node {\n-                                item_trait(_, _, methods) => {\n-                                    if method_num >= methods.len() {\n+                                item_trait(_, _, ref methods) => {\n+                                    if method_num >= (*methods).len() {\n                                         tcx.sess.span_bug(span, ~\"method \\\n                                                                   number \\\n                                                                   out of \\\n                                                                   range?!\");\n                                     }\n-                                    match methods[method_num] {\n+                                    match (*methods)[method_num] {\n                                         provided(method)\n                                              if method.vis == private &&\n                                              !privileged_items\n@@ -212,10 +212,10 @@ fn check_crate(tcx: ty::ctxt, method_map: &method_map, crate: @ast::crate) {\n                                             field access\");\n                                     check_field(expr.span, id, ident);\n                                 }\n-                                Some(entry) => {\n+                                Some(ref entry) => {\n                                     debug!(\"(privacy checking) checking \\\n                                             impl method\");\n-                                    check_method(expr.span, &entry.origin);\n+                                    check_method(expr.span, &(*entry).origin);\n                                 }\n                             }\n                         }\n@@ -233,22 +233,22 @@ fn check_crate(tcx: ty::ctxt, method_map: &method_map, crate: @ast::crate) {\n                                                       ~\"method call not in \\\n                                                         method map\");\n                                 }\n-                                Some(entry) => {\n+                                Some(ref entry) => {\n                                     debug!(\"(privacy checking) checking \\\n                                             impl method\");\n-                                    check_method(expr.span, &entry.origin);\n+                                    check_method(expr.span, &(*entry).origin);\n                                 }\n                             }\n                         }\n                         _ => {}\n                     }\n                 }\n-                expr_struct(_, fields, _) => {\n+                expr_struct(_, ref fields, _) => {\n                     match ty::get(ty::expr_ty(tcx, expr)).sty {\n                         ty_class(id, _) => {\n                             if id.crate != local_crate ||\n                                     !privileged_items.contains(&(id.node)) {\n-                                for fields.each |field| {\n+                                for (*fields).each |field| {\n                                         debug!(\"(privacy checking) checking \\\n                                                 field in struct literal\");\n                                     check_field(expr.span, id,\n@@ -261,7 +261,7 @@ fn check_crate(tcx: ty::ctxt, method_map: &method_map, crate: @ast::crate) {\n                                     !privileged_items.contains(&(id.node)) {\n                                 match tcx.def_map.get(expr.id) {\n                                     def_variant(_, variant_id) => {\n-                                        for fields.each |field| {\n+                                        for (*fields).each |field| {\n                                                 debug!(\"(privacy checking) \\\n                                                         checking field in \\\n                                                         struct variant \\"}, {"sha": "a1e5a98915ad52089fa019125e5969635750ce52", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -697,8 +697,8 @@ fn determine_rp_in_ty(ty: @ast::Ty,\n         visit_mt(mt, cx, visitor);\n       }\n \n-      ast::ty_rec(fields) => {\n-        for fields.each |field| {\n+      ast::ty_rec(ref fields) => {\n+        for (*fields).each |field| {\n             visit_mt(field.node.mt, cx, visitor);\n         }\n       }"}, {"sha": "aeefbef64eee81bb25a9cfc1e8ef2e6e8d0c9efd", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -635,7 +635,7 @@ impl NameBindings {\n     /// Returns the module node if applicable.\n     fn get_module_if_available() -> Option<@Module> {\n         match self.type_def {\n-            Some(type_def) => type_def.module_def,\n+            Some(ref type_def) => (*type_def).module_def,\n             None => None\n         }\n     }\n@@ -666,14 +666,14 @@ impl NameBindings {\n             TypeNS => {\n                 match self.type_def {\n                     None => None,\n-                    Some(type_def) => {\n+                    Some(ref type_def) => {\n                         // FIXME (#3784): This is reallllly questionable.\n                         // Perhaps the right thing to do is to merge def_mod\n                         // and def_ty.\n-                        match type_def.type_def {\n+                        match (*type_def).type_def {\n                             Some(type_def) => Some(type_def),\n                             None => {\n-                                match type_def.module_def {\n+                                match (*type_def).module_def {\n                                     Some(module_def) => {\n                                         module_def.def_id.map(|def_id|\n                                             def_mod(*def_id))\n@@ -699,7 +699,7 @@ impl NameBindings {\n             TypeNS => {\n                 match self.type_def {\n                     None => None,\n-                    Some(type_def) => Some(type_def.privacy)\n+                    Some(ref type_def) => Some((*type_def).privacy)\n                 }\n             }\n             ValueNS => {\n@@ -1166,14 +1166,14 @@ impl Resolver {\n                     (privacy, def_ty(local_def(item.id)), sp);\n             }\n \n-            item_enum(enum_definition, _) => {\n+            item_enum(ref enum_definition, _) => {\n                 let (name_bindings, new_parent) =\n                     self.add_child(ident, parent, ForbidDuplicateTypes, sp);\n \n                 (*name_bindings).define_type\n                     (privacy, def_ty(local_def(item.id)), sp);\n \n-                for enum_definition.variants.each |variant| {\n+                for (*enum_definition).variants.each |variant| {\n                     self.build_reduced_graph_for_variant(*variant,\n                         local_def(item.id),\n                         // inherited => privacy of the enum item\n@@ -1277,7 +1277,7 @@ impl Resolver {\n                 visit_item(item, parent, visitor);\n             }\n \n-            item_trait(_, _, methods) => {\n+            item_trait(_, _, ref methods) => {\n                 let (name_bindings, new_parent) =\n                     self.add_child(ident, parent, ForbidDuplicateTypes, sp);\n \n@@ -1287,7 +1287,7 @@ impl Resolver {\n                 // We only need to create the module if the trait has static\n                 // methods, so check that first.\n                 let mut has_static_methods = false;\n-                for methods.each |method| {\n+                for (*methods).each |method| {\n                     let ty_m = trait_method_to_ty_method(*method);\n                     match ty_m.self_ty.node {\n                         sty_static => {\n@@ -1315,7 +1315,7 @@ impl Resolver {\n \n                 // Add the names of all the methods to the trait info.\n                 let method_names = @HashMap();\n-                for methods.each |method| {\n+                for (*methods).each |method| {\n                     let ty_m = trait_method_to_ty_method(*method);\n \n                     let ident = ty_m.ident;\n@@ -1403,11 +1403,11 @@ impl Resolver {\n                                      variant.span);\n                 self.structs.insert(local_def(variant.node.id), ());\n             }\n-            enum_variant_kind(enum_definition) => {\n+            enum_variant_kind(ref enum_definition) => {\n                 (*child).define_type(privacy,\n                                      def_ty(local_def(variant.node.id)),\n                                      variant.span);\n-                for enum_definition.variants.each |variant| {\n+                for (*enum_definition).variants.each |variant| {\n                     self.build_reduced_graph_for_variant(*variant, item_id,\n                                                          parent_privacy,\n                                                          parent, visitor);\n@@ -1475,8 +1475,8 @@ impl Resolver {\n                                                         subclass,\n                                                         view_path.span);\n                         }\n-                        view_path_list(_, source_idents, _) => {\n-                            for source_idents.each |source_ident| {\n+                        view_path_list(_, ref source_idents, _) => {\n+                            for (*source_idents).each |source_ident| {\n                                 let name = source_ident.node.name;\n                                 let subclass = @SingleImport(name,\n                                                              name,\n@@ -1527,9 +1527,9 @@ impl Resolver {\n                                                    unsupported\");\n                         }\n \n-                        view_path_list(path, path_list_idents, _) => {\n+                        view_path_list(path, ref path_list_idents, _) => {\n                             if path.idents.len() == 1u &&\n-                                    path_list_idents.len() == 0 {\n+                                    (*path_list_idents).len() == 0 {\n \n                                 self.session.span_warn(view_item.span,\n                                                        ~\"this syntax for \\\n@@ -1546,7 +1546,7 @@ impl Resolver {\n                                                            in this module\");\n                                 }\n \n-                                for path_list_idents.each |path_list_ident| {\n+                                for (*path_list_idents).each |path_list_ident| {\n                                     let ident = path_list_ident.node.name;\n                                     let id = path_list_ident.node.id;\n                                     module_.exported_names.insert(ident, id);\n@@ -2838,8 +2838,8 @@ impl Resolver {\n         match self.resolve_item_in_lexical_scope(module_, name, TypeNS) {\n             Success(target) => {\n                 match target.bindings.type_def {\n-                    Some(type_def) => {\n-                        match type_def.module_def {\n+                    Some(ref type_def) => {\n+                        match (*type_def).module_def {\n                             None => {\n                                 error!(\"!!! (resolving module in lexical \\\n                                         scope) module wasn't actually a \\\n@@ -3541,9 +3541,9 @@ impl Resolver {\n \n             // enum item: resolve all the variants' discrs,\n             // then resolve the ty params\n-            item_enum(enum_def, type_parameters) => {\n+            item_enum(ref enum_def, type_parameters) => {\n \n-                for enum_def.variants.each() |variant| {\n+                for (*enum_def).variants.each() |variant| {\n                     do variant.node.disr_expr.iter() |dis_expr| {\n                         // resolve the discriminator expr\n                         // as a constant\n@@ -3588,7 +3588,7 @@ impl Resolver {\n                                             visitor);\n             }\n \n-            item_trait(type_parameters, traits, methods) => {\n+            item_trait(type_parameters, traits, ref methods) => {\n                 // Create a new rib for the self type.\n                 let self_type_rib = @Rib(NormalRibKind);\n                 (*self.type_ribs).push(self_type_rib);\n@@ -3623,30 +3623,30 @@ impl Resolver {\n                         }\n                     }\n \n-                    for methods.each |method| {\n+                    for (*methods).each |method| {\n                         // Create a new rib for the method-specific type\n                         // parameters.\n                         //\n                         // XXX: Do we need a node ID here?\n \n                         match *method {\n-                          required(ty_m) => {\n+                          required(ref ty_m) => {\n                             do self.with_type_parameter_rib\n-                                (HasTypeParameters(&ty_m.tps,\n+                                (HasTypeParameters(&(*ty_m).tps,\n                                                    item.id,\n                                                    type_parameters.len(),\n                                         MethodRibKind(item.id, Required))) {\n \n                                 // Resolve the method-specific type\n                                 // parameters.\n-                                self.resolve_type_parameters(ty_m.tps,\n+                                self.resolve_type_parameters((*ty_m).tps,\n                                                              visitor);\n \n-                                for ty_m.decl.inputs.each |argument| {\n+                                for (*ty_m).decl.inputs.each |argument| {\n                                     self.resolve_type(argument.ty, visitor);\n                                 }\n \n-                                self.resolve_type(ty_m.decl.output, visitor);\n+                                self.resolve_type((*ty_m).decl.output, visitor);\n                             }\n                           }\n                           provided(m) => {\n@@ -3705,7 +3705,7 @@ impl Resolver {\n                 }\n             }\n \n-            item_fn(fn_decl, _, ty_params, block) => {\n+            item_fn(fn_decl, _, ty_params, ref block) => {\n                 // If this is the main function, we must record it in the\n                 // session.\n                 //\n@@ -3726,7 +3726,7 @@ impl Resolver {\n                                          item.id,\n                                          0,\n                                          OpaqueFunctionRibKind),\n-                                      block,\n+                                      (*block),\n                                       NoSelfBinding,\n                                       NoCaptureClause,\n                                       visitor);\n@@ -3966,13 +3966,13 @@ impl Resolver {\n                 None => {\n                     // Nothing to do.\n                 }\n-                Some(destructor) => {\n+                Some(ref destructor) => {\n                     self.resolve_function(NormalRibKind,\n                                           None,\n                                           NoTypeParameters,\n-                                          destructor.node.body,\n+                                          (*destructor).node.body,\n                                           HasSelfBinding\n-                                            (destructor.node.self_id),\n+                                            ((*destructor).node.self_id),\n                                           NoCaptureClause,\n                                           visitor);\n                 }\n@@ -4892,12 +4892,12 @@ impl Resolver {\n                 visit_expr(expr, (), visitor);\n             }\n \n-            expr_fn(_, fn_decl, block, capture_clause) |\n-            expr_fn_block(fn_decl, block, capture_clause) => {\n-                self.resolve_function(FunctionRibKind(expr.id, block.node.id),\n+            expr_fn(_, fn_decl, ref block, capture_clause) |\n+            expr_fn_block(fn_decl, ref block, capture_clause) => {\n+                self.resolve_function(FunctionRibKind(expr.id, (*block).node.id),\n                                       Some(@fn_decl),\n                                       NoTypeParameters,\n-                                      block,\n+                                      (*block),\n                                       NoSelfBinding,\n                                       HasCaptureClause(capture_clause),\n                                       visitor);"}, {"sha": "90ac9a9ce3c5aafeb9cc1d1b4858ade6235adbd5", "filename": "src/librustc/middle/trans/alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Falt.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -765,7 +765,7 @@ fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n     let _icx = bcx.insn_ctxt(\"alt::extract_variant_args\");\n     let ccx = bcx.fcx.ccx;\n     let enum_ty_substs = match ty::get(node_id_type(bcx, pat_id)).sty {\n-      ty::ty_enum(id, substs) => { assert id == vdefs.enm; substs.tps }\n+      ty::ty_enum(id, ref substs) => { assert id == vdefs.enm; (*substs).tps }\n       _ => bcx.sess().bug(~\"extract_variant_args: pattern has non-enum type\")\n     };\n     let mut blobptr = val;"}, {"sha": "e5f1ae5d0b8622138cbef853a29bb9c0f0d5bd4a", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -576,14 +576,14 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n             cx = f(cx, llfld_a, *arg);\n         }\n       }\n-      ty::ty_enum(tid, substs) => {\n+      ty::ty_enum(tid, ref substs) => {\n         let variants = ty::enum_variants(cx.tcx(), tid);\n         let n_variants = (*variants).len();\n \n         // Cast the enums to types we can GEP into.\n         if n_variants == 1u {\n             return iter_variant(cx, av, variants[0],\n-                             substs.tps, tid, f);\n+                             (*substs).tps, tid, f);\n         }\n \n         let ccx = cx.ccx();\n@@ -608,7 +608,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n             AddCase(llswitch, C_int(ccx, variant.disr_val), variant_cx.llbb);\n             let variant_cx =\n                 iter_variant(variant_cx, llunion_a_ptr, *variant,\n-                             substs.tps, tid, f);\n+                             (*substs).tps, tid, f);\n             Br(variant_cx, next_cx.llbb);\n         }\n         return next_cx;\n@@ -754,8 +754,8 @@ fn need_invoke(bcx: block) -> bool {\n     let mut cur = bcx;\n     loop {\n         match cur.kind {\n-          block_scope(inf) => {\n-            for vec::each(inf.cleanups) |cleanup| {\n+          block_scope(ref inf) => {\n+            for vec::each((*inf).cleanups) |cleanup| {\n                 match *cleanup {\n                   clean(_, cleanup_type) | clean_temp(_, _, cleanup_type) => {\n                     if cleanup_type == normal_exit_and_unwind {\n@@ -789,9 +789,9 @@ fn in_lpad_scope_cx(bcx: block, f: fn(scope_info)) {\n     let mut bcx = bcx;\n     loop {\n         match bcx.kind {\n-          block_scope(inf) => {\n-            if inf.cleanups.len() > 0u || bcx.parent.is_none() {\n-                f(inf); return;\n+          block_scope(ref inf) => {\n+            if (*inf).cleanups.len() > 0u || bcx.parent.is_none() {\n+                f((*inf)); return;\n             }\n           }\n           _ => ()\n@@ -1159,15 +1159,15 @@ fn cleanup_and_leave(bcx: block, upto: Option<BasicBlockRef>,\n         }\n \n         match cur.kind {\n-          block_scope(inf) if inf.cleanups.len() > 0u => {\n-            for vec::find(inf.cleanup_paths,\n+          block_scope(ref inf) if (*inf).cleanups.len() > 0u => {\n+            for vec::find((*inf).cleanup_paths,\n                           |cp| cp.target == leave).each |cp| {\n                 Br(bcx, cp.dest);\n                 return;\n             }\n             let sub_cx = sub_block(bcx, ~\"cleanup\");\n             Br(bcx, sub_cx.llbb);\n-            inf.cleanup_paths.push({target: leave, dest: sub_cx.llbb});\n+            (*inf).cleanup_paths.push({target: leave, dest: sub_cx.llbb});\n             bcx = trans_block_cleanups_(sub_cx, block_cleanups(cur), is_lpad);\n           }\n           _ => ()\n@@ -1831,8 +1831,8 @@ fn trans_enum_def(ccx: @crate_ctxt, enum_definition: ast::enum_def,\n                 trans_struct_def(ccx, struct_def, tps, path,\n                                  variant.node.name, variant.node.id);\n             }\n-            ast::enum_variant_kind(enum_definition) => {\n-                trans_enum_def(ccx, enum_definition, id, tps, degen, path, vi,\n+            ast::enum_variant_kind(ref enum_definition) => {\n+                trans_enum_def(ccx, (*enum_definition), id, tps, degen, path, vi,\n                                i);\n             }\n         }\n@@ -1847,21 +1847,21 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n         _ => fail ~\"trans_item\",\n     };\n     match item.node {\n-      ast::item_fn(decl, purity, tps, body) => {\n+      ast::item_fn(decl, purity, tps, ref body) => {\n         if purity == ast::extern_fn  {\n             let llfndecl = get_item_val(ccx, item.id);\n             foreign::trans_foreign_fn(ccx,\n                                      vec::append(\n                                          *path,\n                                          ~[path_name(item.ident)]),\n-                                     decl, body, llfndecl, item.id);\n+                                     decl, (*body), llfndecl, item.id);\n         } else if tps.is_empty() {\n             let llfndecl = get_item_val(ccx, item.id);\n             trans_fn(ccx,\n                      vec::append(*path, ~[path_name(item.ident)]),\n-                     decl, body, llfndecl, no_self, None, item.id, None);\n+                     decl, (*body), llfndecl, no_self, None, item.id, None);\n         } else {\n-            for vec::each(body.node.stmts) |stmt| {\n+            for vec::each((*body).node.stmts) |stmt| {\n                 match stmt.node {\n                   ast::stmt_decl(@{node: ast::decl_item(i), _}, _) => {\n                     trans_item(ccx, *i);\n@@ -1882,20 +1882,20 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n       ast::item_mod(m) => {\n         trans_mod(ccx, m);\n       }\n-      ast::item_enum(enum_definition, tps) => {\n+      ast::item_enum(ref enum_definition, tps) => {\n         if tps.len() == 0u {\n-            let degen = enum_definition.variants.len() == 1u;\n+            let degen = (*enum_definition).variants.len() == 1u;\n             let vi = ty::enum_variants(ccx.tcx, local_def(item.id));\n             let mut i = 0;\n-            trans_enum_def(ccx, enum_definition, item.id, tps, degen, path,\n+            trans_enum_def(ccx, (*enum_definition), item.id, tps, degen, path,\n                            vi, &mut i);\n         }\n       }\n       ast::item_const(_, expr) => consts::trans_const(ccx, expr, item.id),\n       ast::item_foreign_mod(foreign_mod) => {\n         let abi = match attr::foreign_abi(item.attrs) {\n           either::Right(abi_) => abi_,\n-          either::Left(msg) => ccx.sess.span_fatal(item.span, msg)\n+          either::Left(ref msg) => ccx.sess.span_fatal(item.span, (*msg))\n         };\n         foreign::trans_foreign_mod(ccx, foreign_mod, abi);\n       }\n@@ -2073,7 +2073,7 @@ fn get_dtor_symbol(ccx: @crate_ctxt, path: path, id: ast::node_id,\n                    substs: Option<param_substs>) -> ~str {\n   let t = ty::node_id_to_type(ccx.tcx, id);\n   match ccx.item_symbols.find(id) {\n-     Some(s) => s,\n+     Some(ref s) => (*s),\n      None if substs.is_none() => {\n        let s = mangle_exported_name(\n            ccx,\n@@ -2205,17 +2205,17 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n             llfn\n           }\n \n-          ast_map::node_variant(v, enm, pth) => {\n+          ast_map::node_variant(ref v, enm, pth) => {\n             let llfn;\n-            match v.node.kind {\n+            match (*v).node.kind {\n                 ast::tuple_variant_kind(args) => {\n                     assert args.len() != 0u;\n                     let pth = vec::append(*pth,\n                                           ~[path_name(enm.ident),\n-                                            path_name(v.node.name)]);\n+                                            path_name((*v).node.name)]);\n                     llfn = match enm.node {\n                       ast::item_enum(_, _) => {\n-                        register_fn(ccx, v.span, pth, id)\n+                        register_fn(ccx, (*v).span, pth, id)\n                       }\n                       _ => fail ~\"node_variant, shouldn't happen\"\n                     };\n@@ -2302,12 +2302,12 @@ fn register_deriving_method(ccx: @crate_ctxt,\n fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n     let _icx = ccx.insn_ctxt(\"trans_constant\");\n     match it.node {\n-      ast::item_enum(enum_definition, _) => {\n+      ast::item_enum(ref enum_definition, _) => {\n         let vi = ty::enum_variants(ccx.tcx, {crate: ast::local_crate,\n                                              node: it.id});\n         let mut i = 0;\n         let path = item_path(ccx, it);\n-        for vec::each(enum_definition.variants) |variant| {\n+        for vec::each((*enum_definition).variants) |variant| {\n             let p = vec::append(path, ~[path_name(variant.node.name),\n                                         path_name(special_idents::descrim)]);\n             let s = mangle_exported_name(ccx, p, ty::mk_int(ccx.tcx));"}, {"sha": "7c98f2e6a640fb63e9852d3d8f0bc025ea5a2d1e", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -62,9 +62,9 @@ fn trans(bcx: block, expr: @ast::expr) -> Callee {\n         }\n         ast::expr_field(base, _, _) => {\n             match bcx.ccx().maps.method_map.find(expr.id) {\n-                Some(origin) => { // An impl method\n+                Some(ref origin) => { // An impl method\n                     return meth::trans_method_callee(bcx, expr.id,\n-                                                     base, origin);\n+                                                     base, (*origin));\n                 }\n                 None => {} // not a method, just a field\n             }\n@@ -316,11 +316,11 @@ fn trans_method_call(in_cx: block,\n         expr_ty(in_cx, call_ex),\n         |cx| {\n             match cx.ccx().maps.method_map.find(call_ex.id) {\n-                Some(origin) => {\n+                Some(ref origin) => {\n                     meth::trans_method_callee(cx,\n                                               call_ex.callee_id,\n                                               rcvr,\n-                                              origin)\n+                                              (*origin))\n                 }\n                 None => {\n                     cx.tcx().sess.span_bug(call_ex.span,\n@@ -427,9 +427,9 @@ fn trans_call_inner(\n           ArgExprs(args) => {\n             args.len() > 0u && match vec::last(args).node {\n               ast::expr_loop_body(@{\n-                node: ast::expr_fn_block(_, body, _),\n+                node: ast::expr_fn_block(_, ref body, _),\n                 _\n-              }) =>  body_contains_ret(body),\n+              }) =>  body_contains_ret((*body)),\n               _ => false\n             }\n           }\n@@ -622,14 +622,14 @@ fn trans_arg_expr(bcx: block,\n         Some(_) => {\n             match arg_expr.node {\n                 ast::expr_loop_body(\n-                    blk @ @{node:ast::expr_fn_block(decl, body, cap), _}) =>\n+                    blk @ @{node:ast::expr_fn_block(decl, ref body, cap), _}) =>\n                 {\n                     let scratch_ty = expr_ty(bcx, blk);\n                     let scratch = alloc_ty(bcx, scratch_ty);\n                     let arg_ty = expr_ty(bcx, arg_expr);\n                     let proto = ty::ty_fn_proto(arg_ty);\n                     let bcx = closure::trans_expr_fn(\n-                        bcx, proto, decl, body, blk.id,\n+                        bcx, proto, decl, (*body), blk.id,\n                         cap, Some(ret_flag), expr::SaveIn(scratch));\n                     DatumBlock {bcx: bcx,\n                                 datum: Datum {val: scratch,"}, {"sha": "25cd169c403f22837ad9cfc323a039cfa11aadec", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -444,7 +444,7 @@ fn revoke_clean(cx: block, val: ValueRef) {\n fn block_cleanups(bcx: block) -> ~[cleanup] {\n     match bcx.kind {\n        block_non_scope  => ~[],\n-       block_scope(inf) => inf.cleanups\n+       block_scope(ref inf) => (*inf).cleanups\n     }\n }\n \n@@ -601,10 +601,10 @@ fn in_scope_cx(cx: block, f: fn(scope_info)) {\n     let mut cur = cx;\n     loop {\n         match cur.kind {\n-          block_scope(inf) => {\n+          block_scope(ref inf) => {\n               debug!(\"in_scope_cx: selected cur=%s (cx=%s)\",\n                      cur.to_str(), cx.to_str());\n-              f(inf);\n+              f((*inf));\n               return;\n           }\n           _ => ()"}, {"sha": "b85e45d0c52942591019d72a11945add16f394f4", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -323,9 +323,9 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n       ast::expr_tup(es) => {\n         C_struct(es.map(|e| const_expr(cx, *e)))\n       }\n-      ast::expr_rec(fs, None) => {\n+      ast::expr_rec(ref fs, None) => {\n           C_struct([C_struct(\n-              fs.map(|f| const_expr(cx, f.node.expr)))])\n+              (*fs).map(|f| const_expr(cx, f.node.expr)))])\n       }\n       ast::expr_struct(_, ref fs, _) => {\n           let ety = ty::expr_ty(cx.tcx, e);\n@@ -334,7 +334,7 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n                                            None) |_hd, field_tys| {\n               field_tys.map(|field_ty| {\n                   match fs.find(|f| field_ty.ident == f.node.ident) {\n-                      Some(f) => const_expr(cx, f.node.expr),\n+                      Some(ref f) => const_expr(cx, (*f).node.expr),\n                       None => {\n                           cx.tcx.sess.span_bug(\n                               e.span, ~\"missing struct field\");"}, {"sha": "e7d3c8a207c4ee233929af63402f89fd96ca6fcb", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -75,8 +75,8 @@ fn trans_if(bcx: block,\n             let elseif_blk = ast_util::block_from_expr(elexpr);\n             trans_block(else_bcx_in, elseif_blk, dest)\n           }\n-          ast::expr_block(blk) => {\n-            trans_block(else_bcx_in, blk, dest)\n+          ast::expr_block(ref blk) => {\n+            trans_block(else_bcx_in, (*blk), dest)\n           }\n           // would be nice to have a constraint on ifs\n           _ => bcx.tcx().sess.bug(~\"strange alternative in if\")"}, {"sha": "4e9e155612414d431407737271c172e039a2c599", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -452,11 +452,11 @@ fn trans_rvalue_stmt_unadjusted(bcx: block, expr: @ast::expr) -> block {\n         ast::expr_assert(a) => {\n             return controlflow::trans_check_expr(bcx, expr, a, ~\"Assertion\");\n         }\n-        ast::expr_while(cond, body) => {\n-            return controlflow::trans_while(bcx, cond, body);\n+        ast::expr_while(cond, ref body) => {\n+            return controlflow::trans_while(bcx, cond, (*body));\n         }\n-        ast::expr_loop(body, opt_label) => {\n-            return controlflow::trans_loop(bcx, body, opt_label);\n+        ast::expr_loop(ref body, opt_label) => {\n+            return controlflow::trans_loop(bcx, (*body), opt_label);\n         }\n         ast::expr_assign(dst, src) => {\n             let src_datum = unpack_datum!(bcx, trans_to_datum(bcx, src));\n@@ -504,20 +504,20 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n             return trans_def_dps_unadjusted(bcx, expr,\n                                             bcx.def(expr.id), dest);\n         }\n-        ast::expr_if(cond, thn, els) => {\n-            return controlflow::trans_if(bcx, cond, thn, els, dest);\n+        ast::expr_if(cond, ref thn, els) => {\n+            return controlflow::trans_if(bcx, cond, (*thn), els, dest);\n         }\n-        ast::expr_match(discr, arms) => {\n-            return alt::trans_alt(bcx, expr, discr, arms, dest);\n+        ast::expr_match(discr, ref arms) => {\n+            return alt::trans_alt(bcx, expr, discr, (*arms), dest);\n         }\n-        ast::expr_block(blk) => {\n-            return do base::with_scope(bcx, blk.info(),\n+        ast::expr_block(ref blk) => {\n+            return do base::with_scope(bcx, (*blk).info(),\n                                        ~\"block-expr body\") |bcx| {\n-                controlflow::trans_block(bcx, blk, dest)\n+                controlflow::trans_block(bcx, (*blk), dest)\n             };\n         }\n-        ast::expr_rec(fields, base) | ast::expr_struct(_, fields, base) => {\n-            return trans_rec_or_struct(bcx, fields, base, expr.id, dest);\n+        ast::expr_rec(ref fields, base) | ast::expr_struct(_, ref fields, base) => {\n+            return trans_rec_or_struct(bcx, (*fields), base, expr.id, dest);\n         }\n         ast::expr_tup(args) => {\n             return trans_tup(bcx, args, dest);\n@@ -534,22 +534,22 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n         ast::expr_vec(*) | ast::expr_repeat(*) => {\n             return tvec::trans_fixed_vstore(bcx, expr, expr, dest);\n         }\n-        ast::expr_fn(proto, decl, body, cap_clause) => {\n+        ast::expr_fn(proto, decl, ref body, cap_clause) => {\n             // Don't use this function for anything real. Use the one in\n             // astconv instead.\n             return closure::trans_expr_fn(bcx, proto,\n-                                          decl, body, expr.id, cap_clause,\n+                                          decl, (*body), expr.id, cap_clause,\n                                           None, dest);\n         }\n-        ast::expr_fn_block(decl, body, cap_clause) => {\n+        ast::expr_fn_block(decl, ref body, cap_clause) => {\n             let expr_ty = expr_ty(bcx, expr);\n             match ty::get(expr_ty).sty {\n                 ty::ty_fn(ref fn_ty) => {\n                     debug!(\"translating fn_block %s with type %s\",\n                            expr_to_str(expr, tcx.sess.intr()),\n                            ty_to_str(tcx, expr_ty));\n                     return closure::trans_expr_fn(\n-                        bcx, fn_ty.meta.proto, decl, body,\n+                        bcx, fn_ty.meta.proto, decl, (*body),\n                         expr.id, cap_clause, None,\n                         dest);\n                 }\n@@ -563,9 +563,9 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n             match ty::get(expr_ty(bcx, expr)).sty {\n                 ty::ty_fn(ref fn_ty) => {\n                     match blk.node {\n-                        ast::expr_fn_block(decl, body, cap) => {\n+                        ast::expr_fn_block(decl, ref body, cap) => {\n                             return closure::trans_expr_fn(\n-                                bcx, fn_ty.meta.proto, decl, body, blk.id,\n+                                bcx, fn_ty.meta.proto, decl, (*body), blk.id,\n                                 cap, Some(None), dest);\n                         }\n                         _ => {"}, {"sha": "ba9b065901e052417fab57eabc6f50a2a74bd888", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -435,7 +435,7 @@ fn decl_x86_64_fn(tys: x86_64_tys,\n fn link_name(ccx: @crate_ctxt, i: @ast::foreign_item) -> ~str {\n     match attr::first_attr_value_str_by_name(i.attrs, ~\"link_name\") {\n         None => ccx.sess.str_of(i.ident),\n-        option::Some(ln) => ln\n+        option::Some(ref ln) => (*ln)\n     }\n }\n \n@@ -608,10 +608,10 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n             let n = vec::len(tys.arg_tys);\n \n             match tys.x86_64_tys {\n-                Some(x86_64) => {\n-                    let mut atys = x86_64.arg_tys;\n-                    let mut attrs = x86_64.attrs;\n-                    if x86_64.sret {\n+                Some(ref x86_64) => {\n+                    let mut atys = (*x86_64).arg_tys;\n+                    let mut attrs = (*x86_64).attrs;\n+                    if (*x86_64).sret {\n                         let llretptr = GEPi(bcx, llargbundle, [0u, n]);\n                         let llretloc = Load(bcx, llretptr);\n                         llargvals = ~[llretloc];\n@@ -649,8 +649,8 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n                      llargbundle: ValueRef, llretval: ValueRef)  {\n             let _icx = bcx.insn_ctxt(\"foreign::shim::build_ret\");\n             match tys.x86_64_tys {\n-                Some(x86_64) => {\n-                  for vec::eachi(x86_64.attrs) |i, a| {\n+                Some(ref x86_64) => {\n+                  for vec::eachi((*x86_64).attrs) |i, a| {\n                         match *a {\n                             Some(attr) => {\n                                 llvm::LLVMAddInstrAttribute(\n@@ -660,15 +660,15 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n                             _ => ()\n                         }\n                     }\n-                    if x86_64.sret || !tys.ret_def {\n+                    if (*x86_64).sret || !tys.ret_def {\n                         return;\n                     }\n                     let n = vec::len(tys.arg_tys);\n                     let llretptr = GEPi(bcx, llargbundle, [0u, n]);\n                     let llretloc = Load(bcx, llretptr);\n-                    if x86_64.ret_ty.cast {\n+                    if (*x86_64).ret_ty.cast {\n                         let tmp_ptr = BitCast(bcx, llretloc,\n-                                                   T_ptr(x86_64.ret_ty.ty));\n+                                                   T_ptr((*x86_64).ret_ty.ty));\n                         Store(bcx, llretval, tmp_ptr);\n                     } else {\n                         Store(bcx, llretval, llretloc);\n@@ -700,8 +700,8 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n                cc: lib::llvm::CallConv) -> ValueRef {\n         // Declare the \"prototype\" for the base function F:\n         match tys.x86_64_tys {\n-          Some(x86_64) => {\n-            do decl_x86_64_fn(x86_64) |fnty| {\n+          Some(ref x86_64) => {\n+            do decl_x86_64_fn((*x86_64)) |fnty| {\n                 decl_fn(ccx.llmod, lname, cc, fnty)\n             }\n           }\n@@ -1110,17 +1110,17 @@ fn trans_foreign_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n                       llwrapfn: ValueRef, llargbundle: ValueRef) {\n             let _icx = bcx.insn_ctxt(\"foreign::foreign::wrap::build_args\");\n             match tys.x86_64_tys {\n-                option::Some(x86_64) => {\n-                    let mut atys = x86_64.arg_tys;\n-                    let mut attrs = x86_64.attrs;\n+                option::Some(ref x86_64) => {\n+                    let mut atys = (*x86_64).arg_tys;\n+                    let mut attrs = (*x86_64).attrs;\n                     let mut j = 0u;\n-                    let llretptr = if x86_64.sret {\n+                    let llretptr = if (*x86_64).sret {\n                         atys = vec::tail(atys);\n                         attrs = vec::tail(attrs);\n                         j = 1u;\n                         get_param(llwrapfn, 0u)\n-                    } else if x86_64.ret_ty.cast {\n-                        let retptr = alloca(bcx, x86_64.ret_ty.ty);\n+                    } else if (*x86_64).ret_ty.cast {\n+                        let retptr = alloca(bcx, (*x86_64).ret_ty.ty);\n                         BitCast(bcx, retptr, T_ptr(tys.ret_ty))\n                     } else {\n                         alloca(bcx, tys.ret_ty)\n@@ -1164,16 +1164,16 @@ fn trans_foreign_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n                      llargbundle: ValueRef) {\n             let _icx = bcx.insn_ctxt(\"foreign::foreign::wrap::build_ret\");\n             match tys.x86_64_tys {\n-                option::Some(x86_64) => {\n-                    if x86_64.sret || !tys.ret_def {\n+                option::Some(ref x86_64) => {\n+                    if (*x86_64).sret || !tys.ret_def {\n                         RetVoid(bcx);\n                         return;\n                     }\n                     let n = vec::len(tys.arg_tys);\n                     let llretval = load_inbounds(bcx, llargbundle, ~[0u, n]);\n-                    let llretval = if x86_64.ret_ty.cast {\n+                    let llretval = if (*x86_64).ret_ty.cast {\n                         let retptr = BitCast(bcx, llretval,\n-                                                  T_ptr(x86_64.ret_ty.ty));\n+                                                  T_ptr((*x86_64).ret_ty.ty));\n                         Load(bcx, retptr)\n                     } else {\n                         Load(bcx, llretval)\n@@ -1233,7 +1233,7 @@ fn abi_of_foreign_fn(ccx: @crate_ctxt, i: @ast::foreign_item)\n       },\n       Some(_) => match attr::foreign_abi(i.attrs) {\n         either::Right(abi) => abi,\n-        either::Left(msg) => ccx.sess.span_fatal(i.span, msg)\n+        either::Left(ref msg) => ccx.sess.span_fatal(i.span, (*msg))\n       }\n     }\n }"}, {"sha": "1bdcefb08d7f99b19b55e3a601adcee0dd07661a", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -103,9 +103,9 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id,\n             }\n             local_def(mth.id)\n           }\n-          csearch::found(ast::ii_dtor(dtor, _, _, _)) => {\n-              ccx.external.insert(fn_id, Some(dtor.node.id));\n-              local_def(dtor.node.id)\n+          csearch::found(ast::ii_dtor(ref dtor, _, _, _)) => {\n+              ccx.external.insert(fn_id, Some((*dtor).node.id));\n+              local_def((*dtor).node.id)\n           }\n         }\n       }"}, {"sha": "86c571086c6284a4680b5527203694393eb6da33", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -73,7 +73,7 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n     // Get the path so that we can create a symbol\n     let (pt, name, span) = match map_node {\n       ast_map::node_item(i, pt) => (pt, i.ident, i.span),\n-      ast_map::node_variant(v, enm, pt) => (pt, v.node.name, enm.span),\n+      ast_map::node_variant(ref v, enm, pt) => (pt, (*v).node.name, enm.span),\n       ast_map::node_method(m, _, pt) => (pt, m.ident, m.span),\n       ast_map::node_foreign_item(i, ast::foreign_abi_rust_intrinsic, pt)\n       => (pt, i.ident, i.span),\n@@ -152,10 +152,10 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n     });\n \n     let lldecl = match map_node {\n-      ast_map::node_item(i@@{node: ast::item_fn(decl, _, _, body), _}, _) => {\n+      ast_map::node_item(i@@{node: ast::item_fn(decl, _, _, ref body), _}, _) => {\n         let d = mk_lldecl();\n         set_inline_hint_if_appr(i.attrs, d);\n-        trans_fn(ccx, pt, decl, body, d, no_self, psubsts, fn_id.node, None);\n+        trans_fn(ccx, pt, decl, (*body), d, no_self, psubsts, fn_id.node, None);\n         d\n       }\n       ast_map::node_item(*) => {\n@@ -167,15 +167,15 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n                                 ref_id);\n           d\n       }\n-      ast_map::node_variant(v, enum_item, _) => {\n+      ast_map::node_variant(ref v, enum_item, _) => {\n         let tvs = ty::enum_variants(ccx.tcx, local_def(enum_item.id));\n         let this_tv = option::get(vec::find(*tvs, |tv| {\n             tv.id.node == fn_id.node}));\n         let d = mk_lldecl();\n         set_inline_hint(d);\n-        match v.node.kind {\n+        match (*v).node.kind {\n             ast::tuple_variant_kind(args) => {\n-                trans_enum_variant(ccx, enum_item.id, v, args,\n+                trans_enum_variant(ccx, enum_item.id, (*v), args,\n                                    this_tv.disr_val, (*tvs).len() == 1u,\n                                    psubsts, d);\n             }"}, {"sha": "c5e6753a97dd195d94763f2cd24d5a19e771dbd3", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -45,8 +45,8 @@ fn find_reachable(crate_mod: _mod, exp_map2: resolve::ExportMap2,\n fn traverse_exports(cx: ctx, mod_id: node_id) -> bool {\n     let mut found_export = false;\n     match cx.exp_map2.find(mod_id) {\n-      Some(exp2s) => {\n-        for exp2s.each |e2| {\n+      Some(ref exp2s) => {\n+        for (*exp2s).each |e2| {\n             found_export = true;\n             traverse_def_id(cx, e2.def_id)\n         };\n@@ -60,15 +60,15 @@ fn traverse_def_id(cx: ctx, did: def_id) {\n     if did.crate != local_crate { return; }\n     let n = match cx.tcx.items.find(did.node) {\n         None => return, // This can happen for self, for example\n-        Some(n) => n\n+        Some(ref n) => (*n)\n     };\n     match n {\n       ast_map::node_item(item, _) => traverse_public_item(cx, item),\n       ast_map::node_method(_, impl_id, _) => traverse_def_id(cx, impl_id),\n       ast_map::node_foreign_item(item, _, _) => {\n         cx.rmap.insert(item.id, ());\n       }\n-      ast_map::node_variant(v, _, _) => { cx.rmap.insert(v.node.id, ()); }\n+      ast_map::node_variant(ref v, _, _) => { cx.rmap.insert((*v).node.id, ()); }\n       _ => ()\n     }\n }\n@@ -94,10 +94,10 @@ fn traverse_public_item(cx: ctx, item: @item) {\n               }\n           }\n       }\n-      item_fn(_, _, tps, blk) => {\n+      item_fn(_, _, tps, ref blk) => {\n         if tps.len() > 0u ||\n            attr::find_inline_attr(item.attrs) != attr::ia_none {\n-            traverse_inline_body(cx, blk);\n+            traverse_inline_body(cx, (*blk));\n         }\n       }\n       item_impl(tps, _, _, ms) => {"}, {"sha": "a1dfd383893dc3ec14b0ba9fe08fa87235aa3a98", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -113,13 +113,13 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n       ty::ty_estr(ty::vstore_uniq) => {\n         T_unique_ptr(T_unique(cx, T_vec(cx, T_i8())))\n       }\n-      ty::ty_enum(did, substs) => {\n+      ty::ty_enum(did, ref substs) => {\n         // Only create the named struct, but don't fill it in. We\n         // fill it in *after* placing it into the type cache. This\n         // avoids creating more than one copy of the enum when one\n         // of the enum's variants refers to the enum itself.\n \n-        common::T_named_struct(llvm_type_name(cx, an_enum, did, substs.tps))\n+        common::T_named_struct(llvm_type_name(cx, an_enum, did, (*substs).tps))\n       }\n       ty::ty_estr(ty::vstore_box) => {\n         T_box_ptr(T_box(cx, T_vec(cx, T_i8())))\n@@ -179,12 +179,12 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n         T_struct(tys)\n       }\n       ty::ty_opaque_closure_ptr(_) => T_opaque_box_ptr(cx),\n-      ty::ty_class(did, substs) => {\n+      ty::ty_class(did, ref substs) => {\n         // Only create the named struct, but don't fill it in. We fill it\n         // in *after* placing it into the type cache. This prevents\n         // infinite recursion with recursive class types.\n \n-        common::T_named_struct(llvm_type_name(cx, a_class, did, substs.tps))\n+        common::T_named_struct(llvm_type_name(cx, a_class, did, (*substs).tps))\n       }\n       ty::ty_self => cx.tcx.sess.unimpl(~\"type_of: ty_self\"),\n       ty::ty_infer(*) => cx.tcx.sess.bug(~\"type_of with ty_infer\"),"}, {"sha": "367f10f76459d4611b31f323dc088b5744b54f36", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -80,14 +80,14 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n         return uses;\n     }\n     let map_node = match ccx.tcx.items.find(fn_id_loc.node) {\n-        Some(x) => x,\n+        Some(ref x) => (*x),\n         None    => ccx.sess.bug(fmt!(\"type_uses_for: unbound item ID %?\",\n                                      fn_id_loc))\n     };\n     match map_node {\n-      ast_map::node_item(@{node: item_fn(_, _, _, body), _}, _) |\n-      ast_map::node_method(@{body, _}, _, _) => {\n-        handle_body(cx, body);\n+      ast_map::node_item(@{node: item_fn(_, _, _, ref body), _}, _) |\n+      ast_map::node_method(@{body: ref body, _}, _, _) => {\n+        handle_body(cx, (*body));\n       }\n       ast_map::node_trait_method(*) => {\n         // This will be a static trait method. For now, we just assume\n@@ -157,12 +157,12 @@ fn type_needs_inner(cx: ctx, use_: uint, ty: ty::t,\n                  */\n               ty::ty_fn(_) | ty::ty_ptr(_) | ty::ty_rptr(_, _)\n                | ty::ty_trait(_, _, _) => false,\n-              ty::ty_enum(did, substs) => {\n+              ty::ty_enum(did, ref substs) => {\n                 if option::is_none(&list::find(enums_seen, |id| *id == did)) {\n                     let seen = @Cons(did, enums_seen);\n                     for vec::each(*ty::enum_variants(cx.ccx.tcx, did)) |v| {\n                         for vec::each(v.args) |aty| {\n-                            let t = ty::subst(cx.ccx.tcx, &substs, *aty);\n+                            let t = ty::subst(cx.ccx.tcx, &(*substs), *aty);\n                             type_needs_inner(cx, use_, t, seen);\n                         }\n                     }"}, {"sha": "d6fd351b2dfbe49ea316be7d505d53e73af7f7ee", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 46, "deletions": 42, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -429,7 +429,10 @@ type ctxt =\n       destructor_for_type: HashMap<ast::def_id, ast::def_id>,\n \n       // A method will be in this list if and only if it is a destructor.\n-      destructors: HashMap<ast::def_id, ()>\n+      destructors: HashMap<ast::def_id, ()>,\n+\n+      // Records the value mode (read, copy, or move) for every value.\n+      value_modes: HashMap<ast::node_id, ValueMode>,\n       };\n \n enum tbox_flag {\n@@ -918,7 +921,7 @@ fn mk_ctxt(s: session::Session,\n     let mut legacy_modes = false;\n     for crate.node.attrs.each |attribute| {\n         match attribute.node.value.node {\n-            ast::meta_word(w) if w == ~\"legacy_modes\" => {\n+            ast::meta_word(ref w) if (*w) == ~\"legacy_modes\" => {\n                 legacy_modes = true;\n                 break;\n             }\n@@ -968,7 +971,8 @@ fn mk_ctxt(s: session::Session,\n       automatically_derived_methods: HashMap(),\n       automatically_derived_methods_for_impl: HashMap(),\n       destructor_for_type: HashMap(),\n-      destructors: HashMap()}\n+      destructors: HashMap(),\n+      value_modes: HashMap()}\n }\n \n \n@@ -1182,7 +1186,7 @@ pure fn mach_sty(cfg: @session::config, t: t) -> sty {\n       ty_int(ast::ty_i) => ty_int(cfg.int_type),\n       ty_uint(ast::ty_u) => ty_uint(cfg.uint_type),\n       ty_float(ast::ty_f) => ty_float(cfg.float_type),\n-      s => s\n+      ref s => (*s)\n     }\n }\n \n@@ -1255,9 +1259,9 @@ fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n       ty_ptr(tm) | ty_rptr(_, tm) => {\n         maybe_walk_ty(tm.ty, f);\n       }\n-      ty_enum(_, substs) | ty_class(_, substs) |\n-      ty_trait(_, substs, _) => {\n-        for substs.tps.each |subty| { maybe_walk_ty(*subty, f); }\n+      ty_enum(_, ref substs) | ty_class(_, ref substs) |\n+      ty_trait(_, ref substs, _) => {\n+        for (*substs).tps.each |subty| { maybe_walk_ty(*subty, f); }\n       }\n       ty_rec(fields) => {\n         for fields.each |fl| { maybe_walk_ty(fl.mt.ty, f); }\n@@ -2913,7 +2917,7 @@ fn is_fn_ty(fty: t) -> bool {\n fn ty_region(ty: t) -> Region {\n     match get(ty).sty {\n       ty_rptr(r, _) => r,\n-      s => fail fmt!(\"ty_region() invoked on non-rptr: %?\", s)\n+      ref s => fail fmt!(\"ty_region() invoked on non-rptr: %?\", (*s))\n     }\n }\n \n@@ -3246,10 +3250,10 @@ fn canon<T:Copy cmp::Eq>(tbl: HashMap<ast::node_id, ast::inferable<T>>,\n     match m0 {\n       ast::infer(id) => match tbl.find(id) {\n         None => m0,\n-        Some(m1) => {\n-            let cm1 = canon(tbl, m1);\n+        Some(ref m1) => {\n+            let cm1 = canon(tbl, (*m1));\n             // path compression:\n-            if cm1 != m1 { tbl.insert(id, cm1); }\n+            if cm1 != (*m1) { tbl.insert(id, cm1); }\n             cm1\n         }\n       },\n@@ -3440,11 +3444,11 @@ fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n                   but found bound lifetime parameter %s\",\n                  bound_region_to_str(cx, br))\n         }\n-        terr_vstores_differ(k, values) => {\n+        terr_vstores_differ(k, ref values) => {\n             fmt!(\"%s storage differs: expected %s but found %s\",\n                  terr_vstore_kind_to_str(k),\n-                 vstore_to_str(cx, values.expected),\n-                 vstore_to_str(cx, values.found))\n+                 vstore_to_str(cx, (*values).expected),\n+                 vstore_to_str(cx, (*values).found))\n         }\n         terr_in_field(err, fname) => {\n             fmt!(\"in field `%s`, %s\", cx.sess.str_of(fname),\n@@ -3515,8 +3519,8 @@ fn store_trait_methods(cx: ctxt, id: ast::node_id, ms: @~[method]) {\n fn provided_trait_methods(cx: ctxt, id: ast::def_id) -> ~[ast::ident] {\n     if is_local(id) {\n         match cx.items.find(id.node) {\n-            Some(ast_map::node_item(@{node: item_trait(_, _, ms),_}, _)) =>\n-                match ast_util::split_trait_methods(ms) {\n+            Some(ast_map::node_item(@{node: item_trait(_, _, ref ms),_}, _)) =>\n+                match ast_util::split_trait_methods((*ms)) {\n                    (_, p) => p.map(|method| method.ident)\n                 },\n             _ => cx.sess.bug(fmt!(\"provided_trait_methods: %? is not a trait\",\n@@ -3543,10 +3547,10 @@ fn trait_supertraits(cx: ctxt, id: ast::def_id) -> @~[InstantiatedTraitRef] {\n     let result = dvec::DVec();\n     for csearch::get_supertraits(cx, id).each |trait_type| {\n         match get(*trait_type).sty {\n-            ty_trait(def_id, substs, _) => {\n+            ty_trait(def_id, ref substs, _) => {\n                 result.push(InstantiatedTraitRef {\n                     def_id: def_id,\n-                    tpt: { substs: substs, ty: *trait_type }\n+                    tpt: { substs: (*substs), ty: *trait_type }\n                 });\n             }\n             _ => cx.sess.bug(~\"trait_supertraits: trait ref wasn't a trait\")\n@@ -3583,7 +3587,7 @@ fn impl_traits(cx: ctxt, id: ast::def_id, vstore: vstore) -> ~[t] {\n     fn vstoreify(cx: ctxt, ty: t, vstore: vstore) -> t {\n         match ty::get(ty).sty {\n             ty::ty_trait(_, _, trait_vstore) if vstore == trait_vstore => ty,\n-            ty::ty_trait(did, substs, _) => mk_trait(cx, did, substs, vstore),\n+            ty::ty_trait(did, ref substs, _) => mk_trait(cx, did, (*substs), vstore),\n             _ => cx.sess.bug(~\"impl_traits: not a trait\")\n         }\n     }\n@@ -3706,10 +3710,10 @@ fn ty_dtor(cx: ctxt, class_id: def_id) -> DtorKind {\n     if is_local(class_id) {\n        match cx.items.find(class_id.node) {\n            Some(ast_map::node_item(@{\n-               node: ast::item_class(@{ dtor: Some(dtor), _ }, _),\n+               node: ast::item_class(@{ dtor: Some(ref dtor), _ }, _),\n                _\n            }, _)) =>\n-               LegacyDtor(local_def(dtor.node.id)),\n+               LegacyDtor(local_def((*dtor).node.id)),\n            _ =>\n                NoDtor\n        }\n@@ -3756,9 +3760,9 @@ fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n             vec::append_one(*path, ast_map::path_name(method.ident))\n           }\n \n-          ast_map::node_variant(variant, _, path) => {\n+          ast_map::node_variant(ref variant, _, path) => {\n             vec::append_one(vec::init(*path),\n-                            ast_map::path_name(variant.node.name))\n+                            ast_map::path_name((*variant).node.name))\n           }\n \n           ast_map::node_dtor(_, _, _, path) => {\n@@ -3805,9 +3809,9 @@ fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[VariantInfo] {\n           expr, since check_enum_variants also updates the enum_var_cache\n          */\n         match cx.items.get(id.node) {\n-          ast_map::node_item(@{node: ast::item_enum(enum_definition, _), _},\n+          ast_map::node_item(@{node: ast::item_enum(ref enum_definition, _), _},\n                              _) => {\n-            let variants = enum_definition.variants;\n+            let variants = (*enum_definition).variants;\n             let mut disr_val = -1;\n             @vec::map(variants, |variant| {\n                 match variant.node.kind {\n@@ -3921,8 +3925,8 @@ fn lookup_class_fields(cx: ctxt, did: ast::def_id) -> ~[field_ty] {\n             _ => cx.sess.bug(~\"class ID bound to non-class\")\n          }\n        }\n-       Some(ast_map::node_variant(variant, _, _)) => {\n-          match variant.node.kind {\n+       Some(ast_map::node_variant(ref variant, _, _)) => {\n+          match (*variant).node.kind {\n             ast::struct_variant_kind(struct_def) => {\n               class_field_tys(struct_def.fields)\n             }\n@@ -4180,24 +4184,24 @@ fn normalize_ty(cx: ctxt, t: t) -> t {\n             })\n         }\n \n-        ty_enum(did, r) =>\n-            match r.self_r {\n+        ty_enum(did, ref r) =>\n+            match (*r).self_r {\n                 Some(_) =>\n                     // Use re_static since trans doesn't care about regions\n                     mk_enum(cx, did,\n                      {self_r: Some(ty::re_static),\n                       self_ty: None,\n-                      tps: r.tps}),\n+                      tps: (*r).tps}),\n                 None =>\n                     t\n             },\n \n-        ty_class(did, r) =>\n-            match r.self_r {\n+        ty_class(did, ref r) =>\n+            match (*r).self_r {\n               Some(_) =>\n                 // Ditto.\n                 mk_class(cx, did, {self_r: Some(ty::re_static), self_ty: None,\n-                                   tps: r.tps}),\n+                                   tps: (*r).tps}),\n               None =>\n                 t\n             },\n@@ -4544,9 +4548,9 @@ impl sty : cmp::Eq {\n                     _ => false\n                 }\n             }\n-            ty_enum(e0a, e1a) => {\n+            ty_enum(e0a, ref e1a) => {\n                 match (*other) {\n-                    ty_enum(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    ty_enum(e0b, ref e1b) => e0a == e0b && (*e1a) == (*e1b),\n                     _ => false\n                 }\n             }\n@@ -4586,22 +4590,22 @@ impl sty : cmp::Eq {\n                     _ => false\n                 }\n             }\n-            ty_fn(e0a) => {\n+            ty_fn(ref e0a) => {\n                 match (*other) {\n-                    ty_fn(e0b) => e0a == e0b,\n+                    ty_fn(ref e0b) => (*e0a) == (*e0b),\n                     _ => false\n                 }\n             }\n-            ty_trait(e0a, e1a, e2a) => {\n+            ty_trait(e0a, ref e1a, e2a) => {\n                 match (*other) {\n-                    ty_trait(e0b, e1b, e2b) =>\n-                        e0a == e0b && e1a == e1b && e2a == e2b,\n+                    ty_trait(e0b, ref e1b, e2b) =>\n+                        e0a == e0b && (*e1a) == (*e1b) && e2a == e2b,\n                     _ => false\n                 }\n             }\n-            ty_class(e0a, e1a) => {\n+            ty_class(e0a, ref e1a) => {\n                 match (*other) {\n-                    ty_class(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    ty_class(e0b, ref e1b) => e0a == e0b && (*e1a) == (*e1b),\n                     _ => false\n                 }\n             }"}, {"sha": "34a5deea3e289761c15b2ae0a9e900394138b2de", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -72,8 +72,8 @@ fn get_region_reporting_err(tcx: ty::ctxt,\n \n     match res {\n       result::Ok(r) => r,\n-      result::Err(e) => {\n-        tcx.sess.span_err(span, e);\n+      result::Err(ref e) => {\n+        tcx.sess.span_err(span, (*e));\n         ty::re_static\n       }\n     }\n@@ -204,7 +204,7 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Owned>(\n                             self, rscope,\n                             type_def_id, path);\n                         match ty::get(result.ty).sty {\n-                            ty::ty_trait(trait_def_id, substs, _) => {\n+                            ty::ty_trait(trait_def_id, ref substs, _) => {\n                                 match vst {\n                                     ty::vstore_box | ty::vstore_slice(*) |\n                                     ty::vstore_uniq => {}\n@@ -218,7 +218,7 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Owned>(\n                                     }\n                                 }\n                                 return ty::mk_trait(tcx, trait_def_id,\n-                                                    substs, vst);\n+                                                    (*substs), vst);\n \n                             }\n                             _ => {}\n@@ -297,8 +297,8 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Owned>(\n         let flds = vec::map(fields, |t| ast_ty_to_ty(self, rscope, *t));\n         ty::mk_tup(tcx, flds)\n       }\n-      ast::ty_rec(fields) => {\n-        let flds = do fields.map |f| {\n+      ast::ty_rec(ref fields) => {\n+        let flds = do (*fields).map |f| {\n             let tm = ast_mt_to_mt(self, rscope, f.node.mt);\n             {ident: f.node.ident, mt: tm}\n         };"}, {"sha": "cb8eb07aafcc17777da56f20266ef1e64cdebe0f", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -347,7 +347,7 @@ impl LookupContext {\n \n \n             let bound_substs = match ty::get(bound_trait_ty).sty {\n-                ty::ty_trait(_, substs, _) => substs,\n+                ty::ty_trait(_, ref substs, _) => (*substs),\n                 _ => {\n                     self.bug(fmt!(\"add_candidates_from_param: \\\n                                    non-trait bound %s\",\n@@ -882,10 +882,10 @@ impl LookupContext {\n                        candidate_a, candidate_b);\n                 let candidates_same = match (&candidate_a.origin,\n                                              &candidate_b.origin) {\n-                    (&method_param(p1), &method_param(p2)) => {\n-                        let same_trait = p1.trait_id == p2.trait_id;\n-                        let same_method = p1.method_num == p2.method_num;\n-                        let same_param = p1.param_num == p2.param_num;\n+                    (&method_param(ref p1), &method_param(ref p2)) => {\n+                        let same_trait = (*p1).trait_id == (*p2).trait_id;\n+                        let same_method = (*p1).method_num == (*p2).method_num;\n+                        let same_param = (*p1).param_num == (*p2).param_num;\n                         // The bound number may be different because\n                         // multiple bounds may lead to the same trait\n                         // impl\n@@ -1059,8 +1059,8 @@ impl LookupContext {\n             method_static(impl_did) => {\n                 self.report_static_candidate(idx, impl_did)\n             }\n-            method_param(mp) => {\n-                self.report_param_candidate(idx, mp.trait_id)\n+            method_param(ref mp) => {\n+                self.report_param_candidate(idx, (*mp).trait_id)\n             }\n             method_trait(trait_did, _, _) | method_self(trait_did, _) => {\n                 self.report_param_candidate(idx, trait_did)"}, {"sha": "d28f871c71587e651f99bb49892fa7049b961941", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -230,7 +230,7 @@ fn check_fn(ccx: @crate_ctxt,\n     // types with free ones.  The free region references will be bound\n     // the node_id of the body block.\n \n-    let {isr, self_info, fn_ty} = {\n+    let {isr: isr, self_info: self_info, fn_ty: fn_ty} = {\n         let old_isr = option::map_default(&old_fcx, @Nil,\n                                          |fcx| fcx.in_scope_regions);\n         replace_bound_regions_in_fn_ty(tcx, old_isr, self_info, fn_ty,\n@@ -495,11 +495,11 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n \n     match it.node {\n       ast::item_const(_, e) => check_const(ccx, it.span, e, it.id),\n-      ast::item_enum(enum_definition, _) => {\n-        check_enum_variants(ccx, it.span, enum_definition.variants, it.id);\n+      ast::item_enum(ref enum_definition, _) => {\n+        check_enum_variants(ccx, it.span, (*enum_definition).variants, it.id);\n       }\n-      ast::item_fn(decl, _, _, body) => {\n-        check_bare_fn(ccx, decl, body, it.id, None);\n+      ast::item_fn(decl, _, _, ref body) => {\n+        check_bare_fn(ccx, decl, (*body), it.id, None);\n       }\n       ast::item_impl(_, _, ty, ms) => {\n         let rp = ccx.tcx.region_paramd_items.find(it.id);\n@@ -510,8 +510,8 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n             check_method(ccx, *m, self_ty, local_def(it.id));\n         }\n       }\n-      ast::item_trait(_, _, trait_methods) => {\n-        for trait_methods.each |trait_method| {\n+      ast::item_trait(_, _, ref trait_methods) => {\n+        for (*trait_methods).each |trait_method| {\n             match *trait_method {\n               required(*) => {\n                 // Nothing to do, since required methods don't have\n@@ -531,8 +531,8 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n         check_bounds_are_used(ccx, t.span, tps, tpt_ty);\n         // If this is a record ty, check for duplicate fields\n         match t.node {\n-            ast::ty_rec(fields) => {\n-              check_no_duplicate_fields(ccx.tcx, fields.map(|f|\n+            ast::ty_rec(ref fields) => {\n+              check_no_duplicate_fields(ccx.tcx, (*fields).map(|f|\n                                               (f.node.ident, f.span)));\n             }\n             _ => ()\n@@ -690,7 +690,7 @@ impl @fn_ctxt {\n     }\n     fn node_ty_substs(id: ast::node_id) -> ty::substs {\n         match self.inh.node_type_substs.find(id) {\n-            Some(ts) => ts,\n+            Some(ref ts) => (*ts),\n             None => {\n                 self.tcx().sess.bug(\n                     fmt!(\"no type substs for node %d: %s in fcx %s\",\n@@ -720,7 +720,7 @@ impl @fn_ctxt {\n     {\n         match infer::mk_assignty(self.infcx(), false, expr.span, sub, sup) {\n             Ok(None) => result::Ok(()),\n-            Err(e) => result::Err(e),\n+            Err(ref e) => result::Err((*e)),\n             Ok(Some(adjustment)) => {\n                 self.write_adjustment(expr.id, adjustment);\n                 Ok(())\n@@ -1191,8 +1191,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                              expr_t,\n                              tps,\n                              DontDerefArgs) {\n-            Some(entry) => {\n-                fcx.ccx.method_map.insert(expr.id, entry);\n+            Some(ref entry) => {\n+                fcx.ccx.method_map.insert(expr.id, (*entry));\n             }\n             None => {\n                 fcx.type_error_message(expr.span,\n@@ -1267,13 +1267,13 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         match method::lookup(fcx, op_ex, self_ex,\n                              op_ex.callee_id, opname, self_t, ~[],\n                              deref_args) {\n-          Some(origin) => {\n+          Some(ref origin) => {\n             let {fty: method_ty, bot: bot} = {\n                 let method_ty = fcx.node_ty(op_ex.callee_id);\n                 check_call_inner(fcx, op_ex.span, op_ex.id,\n                                  method_ty, op_ex, args, deref_args)\n             };\n-            fcx.ccx.method_map.insert(op_ex.id, origin);\n+            fcx.ccx.method_map.insert(op_ex.id, (*origin));\n             Some((ty::ty_fn_ret(method_ty), bot))\n           }\n           _ => None\n@@ -1341,9 +1341,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n     {\n         let tcx = fcx.ccx.tcx;\n         match ast_util::binop_to_method_name(op) {\n-          Some(name) => {\n+          Some(ref name) => {\n             match lookup_op_method(fcx, ex, lhs_expr, lhs_resolved_t,\n-                                   fcx.tcx().sess.ident_of(name),\n+                                   fcx.tcx().sess.ident_of((*name)),\n                                    ~[rhs], DoDerefArgs) {\n               Some(pair) => return pair,\n               _ => ()\n@@ -1434,7 +1434,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             match expected_sty {\n                 Some(ty::ty_fn(ref fn_ty)) => {\n                     let id = expr.id;\n-                    let {fn_ty, _} =\n+                    let {fn_ty: fn_ty, _} =\n                         replace_bound_regions_in_fn_ty(\n                             tcx, @Nil, None, fn_ty,\n                             |br| ty::re_bound(ty::br_cap_avoid(id, @br)));\n@@ -1506,7 +1506,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                     _ => ()\n                 }\n             }\n-            ty::ty_class(base_id, substs) => {\n+            ty::ty_class(base_id, ref substs) => {\n                 // This is just for fields -- the same code handles\n                 // methods in both classes and traits\n \n@@ -1515,7 +1515,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                 debug!(\"class named %s\", ty_to_str(tcx, base_t));\n                 let cls_items = ty::lookup_class_fields(tcx, base_id);\n                 match lookup_field_ty(tcx, base_id, cls_items,\n-                                      field, &substs) {\n+                                      field, &(*substs)) {\n                     Some(field_ty) => {\n                         // (2) look up what field's type is, and return it\n                         fcx.write_ty(expr.id, field_ty);\n@@ -1532,8 +1532,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n         match method::lookup(fcx, expr, base, expr.id,\n                              field, expr_t, tps, DontDerefArgs) {\n-            Some(entry) => {\n-                fcx.ccx.method_map.insert(expr.id, entry);\n+            Some(ref entry) => {\n+                fcx.ccx.method_map.insert(expr.id, (*entry));\n \n                 // If we have resolved to a method but this is not in\n                 // a callee position, error\n@@ -2020,32 +2020,32 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       ast::expr_swap(lhs, rhs) => {\n         bot = check_assignment(fcx, lhs, rhs, id);\n       }\n-      ast::expr_if(cond, thn, elsopt) => {\n+      ast::expr_if(cond, ref thn, elsopt) => {\n         bot = check_expr_with(fcx, cond, ty::mk_bool(tcx)) |\n-            check_then_else(fcx, thn, elsopt, id, expr.span);\n+            check_then_else(fcx, (*thn), elsopt, id, expr.span);\n       }\n-      ast::expr_while(cond, body) => {\n+      ast::expr_while(cond, ref body) => {\n         bot = check_expr_with(fcx, cond, ty::mk_bool(tcx));\n-        check_block_no_value(fcx, body);\n+        check_block_no_value(fcx, (*body));\n         fcx.write_ty(id, ty::mk_nil(tcx));\n       }\n-      ast::expr_loop(body, _) => {\n-        check_block_no_value(fcx, body);\n+      ast::expr_loop(ref body, _) => {\n+        check_block_no_value(fcx, (*body));\n         fcx.write_ty(id, ty::mk_nil(tcx));\n-        bot = !may_break(tcx, expr.id, body);\n+        bot = !may_break(tcx, expr.id, (*body));\n       }\n-      ast::expr_match(discrim, arms) => {\n-        bot = alt::check_alt(fcx, expr, discrim, arms);\n+      ast::expr_match(discrim, ref arms) => {\n+        bot = alt::check_alt(fcx, expr, discrim, (*arms));\n       }\n-      ast::expr_fn(proto, decl, body, cap_clause) => {\n+      ast::expr_fn(proto, decl, ref body, cap_clause) => {\n         check_expr_fn(fcx, expr, Some(proto),\n-                      decl, body, false,\n+                      decl, (*body), false,\n                       expected);\n         capture::check_capture_clause(tcx, expr.id, cap_clause);\n       }\n-      ast::expr_fn_block(decl, body, cap_clause) => {\n+      ast::expr_fn_block(decl, ref body, cap_clause) => {\n         check_expr_fn(fcx, expr, None,\n-                      decl, body, false,\n+                      decl, (*body), false,\n                       expected);\n         capture::check_capture_clause(tcx, expr.id, cap_clause);\n       }\n@@ -2058,25 +2058,25 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // 2. the closure that was given returns unit\n         let expected_sty = unpack_expected(fcx, expected, |x| Some(x));\n         let inner_ty = match expected_sty {\n-          Some(ty::ty_fn(fty)) => {\n+          Some(ty::ty_fn(ref fty)) => {\n             match fcx.mk_subty(false, expr.span,\n-                               fty.sig.output, ty::mk_bool(tcx)) {\n+                               (*fty).sig.output, ty::mk_bool(tcx)) {\n               result::Ok(_) => (),\n               result::Err(_) => {\n                    fcx.type_error_message(expr.span,\n                       |actual| {\n                           fmt!(\"a `loop` function's last argument \\\n                                 should return `bool`, not `%s`\", actual)\n                       },\n-                      fty.sig.output, None);\n+                      (*fty).sig.output, None);\n                 fcx.write_ty(id, ty::mk_err(tcx));\n                 return true;\n               }\n             }\n             ty::mk_fn(tcx, FnTyBase {\n-                meta: fty.meta,\n+                meta: (*fty).meta,\n                 sig: FnSig {output: ty::mk_nil(tcx),\n-                            ..fty.sig}\n+                            ..(*fty).sig}\n             })\n           }\n           _ =>\n@@ -2097,9 +2097,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               }\n         };\n         match b.node {\n-          ast::expr_fn_block(decl, body, cap_clause) => {\n+          ast::expr_fn_block(decl, ref body, cap_clause) => {\n             check_expr_fn(fcx, b, None,\n-                          decl, body, true,\n+                          decl, (*body), true,\n                           Some(inner_ty));\n             demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n             capture::check_capture_clause(tcx, b.id, cap_clause);\n@@ -2110,11 +2110,11 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let block_ty = structurally_resolved_type(\n             fcx, expr.span, fcx.node_ty(b.id));\n         match ty::get(block_ty).sty {\n-          ty::ty_fn(fty) => {\n+          ty::ty_fn(ref fty) => {\n             fcx.write_ty(expr.id, ty::mk_fn(tcx, FnTyBase {\n-                meta: fty.meta,\n+                meta: (*fty).meta,\n                 sig: FnSig {output: ty::mk_bool(tcx),\n-                            ..fty.sig}\n+                            ..(*fty).sig}\n             }))\n           }\n           _ => fail ~\"expected fn type\"\n@@ -2123,8 +2123,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       ast::expr_do_body(b) => {\n         let expected_sty = unpack_expected(fcx, expected, |x| Some(x));\n         let inner_ty = match expected_sty {\n-          Some(ty::ty_fn(fty)) => {\n-              ty::mk_fn(tcx, fty)\n+          Some(ty::ty_fn(ref fty)) => {\n+              ty::mk_fn(tcx, (*fty))\n           }\n           _ => match expected {\n                   Some(expected_t) => {\n@@ -2141,9 +2141,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               }\n         };\n         match b.node {\n-          ast::expr_fn_block(decl, body, cap_clause) => {\n+          ast::expr_fn_block(decl, ref body, cap_clause) => {\n             check_expr_fn(fcx, b, None,\n-                          decl, body, true,\n+                          decl, (*body), true,\n                           Some(inner_ty));\n             demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n             capture::check_capture_clause(tcx, b.id, cap_clause);\n@@ -2154,17 +2154,17 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let block_ty = structurally_resolved_type(\n             fcx, expr.span, fcx.node_ty(b.id));\n         match ty::get(block_ty).sty {\n-          ty::ty_fn(fty) => {\n-            fcx.write_ty(expr.id, ty::mk_fn(tcx, fty));\n+          ty::ty_fn(ref fty) => {\n+            fcx.write_ty(expr.id, ty::mk_fn(tcx, (*fty)));\n           }\n           _ => fail ~\"expected fn ty\"\n         }\n       }\n-      ast::expr_block(b) => {\n+      ast::expr_block(ref b) => {\n         // If this is an unchecked block, turn off purity-checking\n-        bot = check_block(fcx, b);\n+        bot = check_block(fcx, (*b));\n         let typ =\n-            match b.node.expr {\n+            match (*b).node.expr {\n               Some(expr) => fcx.expr_ty(expr),\n               None => ty::mk_nil(tcx)\n             };\n@@ -2246,15 +2246,15 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let typ = ty::mk_tup(tcx, elt_ts);\n         fcx.write_ty(id, typ);\n       }\n-      ast::expr_rec(fields, base) => {\n+      ast::expr_rec(ref fields, base) => {\n         option::iter(&base, |b| { check_expr(fcx, *b, expected); });\n         let expected = if expected.is_none() && base.is_some() {\n             Some(fcx.expr_ty(base.get()))\n         } else { expected };\n         let flds = unpack_expected(fcx, expected, |sty|\n             match sty { ty::ty_rec(flds) => Some(flds), _ => None }\n         );\n-        let fields_t = vec::map(fields, |f| {\n+        let fields_t = vec::map((*fields), |f| {\n             bot |= check_expr(fcx, f.node.expr, flds.chain_ref(|flds|\n                 vec::find(*flds, |tf| tf.ident == f.node.ident)\n             ).map(|tf| tf.mt.ty));\n@@ -2274,7 +2274,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                that we're extending a record we know has no dup fields, and\n                it would be ill-typed anyway if we duplicated one of its\n                fields */\n-            check_no_duplicate_fields(tcx, fields.map(|f|\n+            check_no_duplicate_fields(tcx, (*fields).map(|f|\n                                                     (f.node.ident, f.span)));\n           }\n           Some(bexpr) => {\n@@ -2309,16 +2309,16 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           }\n         }\n       }\n-      ast::expr_struct(path, fields, base_expr) => {\n+      ast::expr_struct(path, ref fields, base_expr) => {\n         // Resolve the path.\n         match tcx.def_map.find(id) {\n             Some(ast::def_class(type_def_id)) => {\n                 check_struct_constructor(fcx, id, expr.span, type_def_id,\n-                                         fields, base_expr);\n+                                         (*fields), base_expr);\n             }\n             Some(ast::def_variant(enum_id, variant_id)) => {\n                 check_struct_enum_variant(fcx, id, expr.span, enum_id,\n-                                          variant_id, fields);\n+                                          variant_id, (*fields));\n             }\n             _ => {\n                 tcx.sess.span_bug(path.span, ~\"structure constructor does \\\n@@ -2571,9 +2571,9 @@ fn check_enum_variants(ccx: @crate_ctxt,\n                     ccx.tcx.sess.span_err(e.span, ~\"expected signed integer \\\n                                                     constant\");\n                   }\n-                  Err(err) => {\n+                  Err(ref err) => {\n                     ccx.tcx.sess.span_err(e.span,\n-                     fmt!(\"expected constant: %s\", err));\n+                     fmt!(\"expected constant: %s\", (*err)));\n \n                   }\n                 }\n@@ -2977,9 +2977,9 @@ fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n       ~\"morestack_addr\" => {\n         (0u, ~[], ty::mk_nil_ptr(tcx))\n       }\n-      other => {\n+      ref other => {\n         tcx.sess.span_err(it.span, ~\"unrecognized intrinsic function: `\" +\n-                          other + ~\"`\");\n+                          (*other) + ~\"`\");\n         return;\n       }\n     };"}, {"sha": "8431c175eff53045a7ee2ffbb3a57cdfe6ba5573", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -26,7 +26,7 @@ fn replace_bound_regions_in_fn_ty(\n     // Take self_info apart; the self_ty part is the only one we want\n     // to update here.\n     let (self_ty, rebuild_self_info) = match self_info {\n-      Some(s) => (Some(s.self_ty), |t| Some({self_ty: t,.. s})),\n+      Some(copy s) => (Some(s.self_ty), |t| Some({self_ty: t,.. s})),\n       None => (None, |_t| None)\n     };\n \n@@ -76,7 +76,7 @@ fn replace_bound_regions_in_fn_ty(\n \n     return {isr: isr,\n          self_info: new_self_info,\n-         fn_ty: match ty::get(t_fn).sty { ty::ty_fn(o) => o,\n+         fn_ty: match ty::get(t_fn).sty { ty::ty_fn(ref o) => (*o),\n           _ => tcx.sess.bug(~\"replace_bound_regions_in_fn_ty: impossible\")}};\n \n "}, {"sha": "0494f1563cf99bd56b8c0112c022aab39946667e", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -125,7 +125,7 @@ fn fixup_substs(vcx: &VtableContext, location_info: &LocationInfo,\n     let t = ty::mk_trait(tcx, id, substs, ty::vstore_slice(ty::re_static));\n     do fixup_ty(vcx, location_info, t, is_early).map |t_f| {\n         match ty::get(*t_f).sty {\n-          ty::ty_trait(_, substs_f, _) => substs_f,\n+          ty::ty_trait(_, ref substs_f, _) => (*substs_f),\n           _ => fail ~\"t_f should be a trait\"\n         }\n     }\n@@ -151,7 +151,7 @@ fn lookup_vtable(vcx: &VtableContext,\n \n     let tcx = vcx.tcx();\n     let (trait_id, trait_substs, trait_vstore) = match ty::get(trait_ty).sty {\n-        ty::ty_trait(did, substs, vstore) => (did, substs, vstore),\n+        ty::ty_trait(did, ref substs, vstore) => (did, (*substs), vstore),\n         _ => tcx.sess.impossible_case(location_info.span,\n                                       \"lookup_vtable: \\\n                                        don't know how to handle a non-trait\")\n@@ -203,7 +203,7 @@ fn lookup_vtable(vcx: &VtableContext,\n             }\n         }\n \n-        ty::ty_trait(did, substs, _) if trait_id == did => {\n+        ty::ty_trait(did, ref substs, _) if trait_id == did => {\n             debug!(\"(checking vtable) @1 relating ty to trait ty with did %?\",\n                    did);\n \n@@ -224,7 +224,7 @@ fn lookup_vtable(vcx: &VtableContext,\n                     }\n                 }\n             }\n-            return Some(vtable_trait(did, substs.tps));\n+            return Some(vtable_trait(did, (*substs).tps));\n         }\n \n         _ => {\n@@ -357,7 +357,7 @@ fn lookup_vtable(vcx: &VtableContext,\n                                                               trait_id,\n                                                               substs,\n                                                               is_early) {\n-                                Some(substs) => substs,\n+                                Some(ref substs) => (*substs),\n                                 None => {\n                                     assert is_early;\n                                     // Bail out with a bogus answer\n@@ -468,8 +468,8 @@ fn connect_trait_tps(vcx: &VtableContext,\n     debug!(\"(connect trait tps) trait type is %?, impl did is %?\",\n            ty::get(trait_ty).sty, impl_did);\n     match ty::get(trait_ty).sty {\n-     ty::ty_trait(_, substs, _) => {\n-         for vec::each2(substs.tps, trait_tys) |a, b| {\n+     ty::ty_trait(_, ref substs, _) => {\n+         for vec::each2((*substs).tps, trait_tys) |a, b| {\n             demand_suptype(vcx, location_info.span, *a, *b);\n          }\n       }"}, {"sha": "12d8f06a3f61044102377f2c0b0faed6c0b096d6", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -100,9 +100,9 @@ fn resolve_type_vars_for_node(wbcx: wb_ctxt, sp: span, id: ast::node_id)\n                id, ty_to_str(tcx, n_ty), ty_to_str(tcx, t));\n         write_ty_to_tcx(tcx, id, t);\n         match fcx.opt_node_ty_substs(id) {\n-          Some(substs) => {\n+          Some(ref substs) => {\n             let mut new_tps = ~[];\n-            for substs.tps.each |subst| {\n+            for (*substs).tps.each |subst| {\n                 match resolve_type_vars_in_type(fcx, sp, *subst) {\n                   Some(t) => new_tps.push(t),\n                   None => { wbcx.success = false; return None; }"}, {"sha": "c1517d11f73ad9081718a1e07f129eecc4b2d3cc", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -627,8 +627,8 @@ impl CoherenceChecker {\n             match self.crate_context.tcx.items.find(method_def_id.node) {\n                 Some(ast_map::node_trait_method(trait_method, _, _)) => {\n                     match *trait_method {\n-                        ast::required(ty_method) => {\n-                            attr::attrs_contains_name(ty_method.attrs,\n+                        ast::required(ref ty_method) => {\n+                            attr::attrs_contains_name((*ty_method).attrs,\n                                                       ~\"derivable\")\n                         }\n                         ast::provided(method) => {\n@@ -1028,8 +1028,8 @@ impl CoherenceChecker {\n                     // Destructors only work on nominal types.\n                     if impl_info.did.crate == ast::local_crate {\n                         match tcx.items.find(impl_info.did.node) {\n-                            Some(ast_map::node_item(@item, _)) => {\n-                                tcx.sess.span_err(item.span,\n+                            Some(ast_map::node_item(@ref item, _)) => {\n+                                tcx.sess.span_err((*item).span,\n                                                   ~\"the Drop trait may only \\\n                                                     be implemented on \\\n                                                     structures\");"}, {"sha": "c29ec88957b5e2e888d1043168e85369cc6fa12e", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -108,9 +108,9 @@ impl @crate_ctxt: ast_conv {\n               Some(ast_map::node_foreign_item(foreign_item, _, _)) => {\n                 ty_of_foreign_item(self, foreign_item)\n               }\n-              x => {\n+              ref x => {\n                 self.tcx.sess.bug(fmt!(\"unexpected sort of item \\\n-                                        in get_item_ty(): %?\", x));\n+                                        in get_item_ty(): %?\", (*x)));\n               }\n             }\n         }\n@@ -164,8 +164,8 @@ fn get_enum_variant_types(ccx: @crate_ctxt,\n                 convert_struct(\n                     ccx, rp, struct_def, ty_params, tpt, variant.node.id);\n             }\n-            ast::enum_variant_kind(enum_definition) => {\n-                get_enum_variant_types(ccx, enum_ty, enum_definition.variants,\n+            ast::enum_variant_kind(ref enum_definition) => {\n+                get_enum_variant_types(ccx, enum_ty, (*enum_definition).variants,\n                                        ty_params, rp);\n                 result_ty = None;\n             }\n@@ -232,11 +232,11 @@ fn ensure_trait_methods(ccx: @crate_ctxt, id: ast::node_id, trait_ty: ty::t) {\n     let tcx = ccx.tcx;\n     let region_paramd = tcx.region_paramd_items.find(id);\n     match tcx.items.get(id) {\n-      ast_map::node_item(@{node: ast::item_trait(params, _, ms), _}, _) => {\n-        store_methods::<ast::trait_method>(ccx, id, ms, |m| {\n+      ast_map::node_item(@{node: ast::item_trait(params, _, ref ms), _}, _) => {\n+        store_methods::<ast::trait_method>(ccx, id, (*ms), |m| {\n             let def_id;\n             match *m {\n-                ast::required(ty_method) => def_id = local_def(ty_method.id),\n+                ast::required(ref ty_method) => def_id = local_def((*ty_method).id),\n                 ast::provided(method) => def_id = local_def(method.id)\n             }\n \n@@ -550,10 +550,10 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n     match it.node {\n       // These don't define types.\n       ast::item_foreign_mod(_) | ast::item_mod(_) => {}\n-      ast::item_enum(enum_definition, ty_params) => {\n+      ast::item_enum(ref enum_definition, ty_params) => {\n         let tpt = ty_of_item(ccx, it);\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n-        get_enum_variant_types(ccx, tpt.ty, enum_definition.variants,\n+        get_enum_variant_types(ccx, tpt.ty, (*enum_definition).variants,\n                                ty_params, rp);\n       }\n       ast::item_impl(tps, trait_ref, selfty, ms) => {\n@@ -570,15 +570,15 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n             check_methods_against_trait(ccx, tps, rp, selfty, *t, cms);\n         }\n       }\n-      ast::item_trait(tps, supertraits, trait_methods) => {\n+      ast::item_trait(tps, supertraits, ref trait_methods) => {\n         let tpt = ty_of_item(ccx, it);\n         debug!(\"item_trait(it.id=%d, tpt.ty=%s)\",\n                it.id, ty_to_str(tcx, tpt.ty));\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n         ensure_trait_methods(ccx, it.id, tpt.ty);\n         ensure_supertraits(ccx, it.id, it.span, rp, supertraits);\n \n-        let (_, provided_methods) = split_trait_methods(trait_methods);\n+        let (_, provided_methods) = split_trait_methods((*trait_methods));\n         let {bounds, _} = mk_substs(ccx, tps, rp);\n         let _cms = convert_methods(ccx, provided_methods, rp, bounds);\n         // FIXME (#2616): something like this, when we start having\n@@ -634,7 +634,7 @@ fn convert_struct(ccx: @crate_ctxt,\n     for struct_def.fields.each |f| {\n        convert_field(ccx, rp, tpt.bounds, *f);\n     }\n-    let {bounds, substs} = mk_substs(ccx, tps, rp);\n+    let {bounds: bounds, substs: substs} = mk_substs(ccx, tps, rp);\n     let selfty = ty::mk_class(tcx, local_def(id), substs);\n     let cms = convert_methods(ccx, struct_def.methods, rp, bounds);\n     for struct_def.traits.each |trait_ref| {\n@@ -813,7 +813,7 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n       }\n       ast::item_enum(_, tps) => {\n         // Create a new generic polytype.\n-        let {bounds, substs} = mk_substs(ccx, tps, rp);\n+        let {bounds: bounds, substs: substs} = mk_substs(ccx, tps, rp);\n         let t = ty::mk_enum(tcx, local_def(it.id), substs);\n         let tpt = {bounds: bounds,\n                    region_param: rp,\n@@ -822,7 +822,7 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n         return tpt;\n       }\n       ast::item_trait(tps, _, _) => {\n-        let {bounds, substs} = mk_substs(ccx, tps, rp);\n+        let {bounds: bounds, substs: substs} = mk_substs(ccx, tps, rp);\n         let t = ty::mk_trait(tcx, local_def(it.id), substs, ty::vstore_box);\n         let tpt = {bounds: bounds,\n                    region_param: rp,\n@@ -831,7 +831,7 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n         return tpt;\n       }\n       ast::item_class(_, tps) => {\n-          let {bounds,substs} = mk_substs(ccx, tps, rp);\n+          let {bounds: bounds, substs: substs} = mk_substs(ccx, tps, rp);\n           let t = ty::mk_class(tcx, local_def(it.id), substs);\n           let tpt = {bounds: bounds,\n                      region_param: rp,"}, {"sha": "2ceff545eb73a17f74f5aea44b9a159d475931f5", "filename": "src/librustc/middle/typeck/infer/assignment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -64,7 +64,7 @@ use combine::combine_fields;\n fn to_ares(+c: cres<ty::t>) -> ares {\n     match c {\n         Ok(_) => Ok(None),\n-        Err(e) => Err(e)\n+        Err(ref e) => Err((*e))\n     }\n }\n \n@@ -198,7 +198,7 @@ priv impl Assign {\n                     (ty::ty_rptr(_, ref a_t), ty::ty_ptr(ref b_t)) => {\n                         match Sub(*self).mts(*a_t, *b_t) {\n                             Ok(_) => Ok(None),\n-                            Err(e) => Err(e)\n+                            Err(ref e) => Err((*e))\n                         }\n                     }\n "}, {"sha": "0d0a1d761cc1452ca21dfa557e581027d3944642", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -521,8 +521,8 @@ trait ToUres {\n impl<T> cres<T>: ToUres {\n     fn to_ures() -> ures {\n         match self {\n-          Ok(_v) => Ok(()),\n-          Err(e) => Err(e)\n+          Ok(ref _v) => Ok(()),\n+          Err(ref e) => Err((*e))\n         }\n     }\n }\n@@ -761,7 +761,7 @@ impl infer_ctxt {\n         &self, span: span,\n         fty: &ty::FnTy) -> (ty::FnTy, isr_alist)\n     {\n-        let {fn_ty, isr, _} =\n+        let {fn_ty: fn_ty, isr: isr, _} =\n             replace_bound_regions_in_fn_ty(self.tcx, @Nil, None, fty, |br| {\n                 // N.B.: The name of the bound region doesn't have anything to\n                 // do with the region variable that's created for it.  The"}, {"sha": "f49d1740018693df2bad1859dda1b66efcd4dbb0", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -620,8 +620,8 @@ impl RegionVarBindings {\n               AddConstraint(constraint) => {\n                 self.constraints.remove(constraint);\n               }\n-              AddCombination(map, regions) => {\n-                map.remove(regions);\n+              AddCombination(map, ref regions) => {\n+                map.remove((*regions));\n               }\n             }\n         }"}, {"sha": "b7769ac876d1bc01cbd8d463e329deacf5311169", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -48,7 +48,7 @@ impl Sub: combine {\n         do indent {\n             match self.infcx.region_vars.make_subregion(self.span, a, b) {\n               Ok(()) => Ok(a),\n-              Err(e) => Err(e)\n+              Err(ref e) => Err((*e))\n             }\n         }\n     }"}, {"sha": "a882f20c04b422d5acba108fe2316144bb0105b1", "filename": "src/librustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -43,7 +43,7 @@ impl ty::FnTy: ToStr {\n impl<V:Copy ToStr> bound<V>: ToStr {\n     fn to_str(cx: infer_ctxt) -> ~str {\n         match self {\n-          Some(v) => v.to_str(cx),\n+          Some(ref v) => (*v).to_str(cx),\n           None => ~\"none\"\n         }\n     }\n@@ -76,8 +76,8 @@ impl float_ty_set: ToStr {\n impl<V:Copy vid, T:Copy ToStr> var_value<V, T>: ToStr {\n     fn to_str(cx: infer_ctxt) -> ~str {\n         match self {\n-          redirect(vid) => fmt!(\"redirect(%s)\", vid.to_str()),\n-          root(pt, rk) => fmt!(\"root(%s, %s)\", pt.to_str(cx),\n+          redirect(ref vid) => fmt!(\"redirect(%s)\", (*vid).to_str()),\n+          root(ref pt, rk) => fmt!(\"root(%s, %s)\", (*pt).to_str(cx),\n                                uint::to_str(rk, 10u))\n         }\n     }"}, {"sha": "5fa4acecdc84f2000feddf7238777dd7c70a0c5a", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -39,18 +39,18 @@ impl infer_ctxt {\n           None => {\n             self.tcx.sess.bug(fmt!(\"failed lookup of vid `%u`\", vid_u));\n           }\n-          Some(var_val) => {\n-            match var_val {\n-              redirect(vid) => {\n-                let node = self.get(vb, vid);\n-                if node.root != vid {\n+          Some(ref var_val) => {\n+            match (*var_val) {\n+              redirect(ref vid) => {\n+                let node = self.get(vb, (*vid));\n+                if node.root != (*vid) {\n                     // Path compression\n-                    vb.vals.insert(vid.to_uint(), redirect(node.root));\n+                    vb.vals.insert((*vid).to_uint(), redirect(node.root));\n                 }\n                 node\n               }\n-              root(pt, rk) => {\n-                node {root: vid, possible_types: pt, rank: rk}\n+              root(ref pt, rk) => {\n+                node {root: vid, possible_types: (*pt), rank: rk}\n               }\n             }\n           }"}, {"sha": "f9f3ac2d45cdbe63b6096e04e23d95a357e40814", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -332,7 +332,7 @@ fn check_main_fn_ty(ccx: @crate_ctxt,\n     let tcx = ccx.tcx;\n     let main_t = ty::node_id_to_type(tcx, main_id);\n     match ty::get(main_t).sty {\n-        ty::ty_fn(fn_ty) => {\n+        ty::ty_fn(ref fn_ty) => {\n             match tcx.items.find(main_id) {\n                 Some(ast_map::node_item(it,_)) => {\n                     match it.node {\n@@ -348,8 +348,8 @@ fn check_main_fn_ty(ccx: @crate_ctxt,\n                 }\n                 _ => ()\n             }\n-            let mut ok = ty::type_is_nil(fn_ty.sig.output);\n-            let num_args = vec::len(fn_ty.sig.inputs);\n+            let mut ok = ty::type_is_nil((*fn_ty).sig.output);\n+            let num_args = vec::len((*fn_ty).sig.inputs);\n             ok &= num_args == 0u;\n             if !ok {\n                 tcx.sess.span_err("}, {"sha": "01e50f7cf83ea2d94a9b8d483e7e3a6491392cdd", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -27,7 +27,7 @@\n #[allow(vecs_implicitly_copyable)];\n #[allow(non_camel_case_types)];\n #[allow(deprecated_mode)];\n-#[allow(deprecated_pattern)];\n+#[warn(deprecated_pattern)];\n \n extern mod core(vers = \"0.5\");\n extern mod std(vers = \"0.5\");\n@@ -334,9 +334,9 @@ fn run_compiler(args: &~[~str], demitter: diagnostic::emitter) {\n \n     let matches =\n         &match getopts::groups::getopts(args, optgroups()) {\n-          Ok(m) => m,\n-          Err(f) => {\n-            early_error(demitter, getopts::fail_str(f))\n+          Ok(ref m) => (*m),\n+          Err(ref f) => {\n+            early_error(demitter, getopts::fail_str((*f)))\n           }\n         };\n \n@@ -396,8 +396,8 @@ fn run_compiler(args: &~[~str], demitter: diagnostic::emitter) {\n     let ls = opt_present(matches, ~\"ls\");\n     if ls {\n         match input {\n-          file_input(ifile) => {\n-            list_metadata(sess, &ifile, io::stdout());\n+          file_input(ref ifile) => {\n+            list_metadata(sess, &(*ifile), io::stdout());\n           }\n           str_input(_) => {\n             early_error(demitter, ~\"can not list metadata for stdin\");"}, {"sha": "6e08c22971c127caa288eea3fcc9382357e96005", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -39,14 +39,14 @@ fn note_and_explain_region(cx: ctxt,\n                            region: ty::Region,\n                            suffix: ~str) {\n     match explain_region_and_span(cx, region) {\n-      (str, Some(span)) => {\n+      (ref str, Some(span)) => {\n         cx.sess.span_note(\n             span,\n-            fmt!(\"%s%s%s\", prefix, str, suffix));\n+            fmt!(\"%s%s%s\", prefix, (*str), suffix));\n       }\n-      (str, None) => {\n+      (ref str, None) => {\n         cx.sess.note(\n-            fmt!(\"%s%s%s\", prefix, str, suffix));\n+            fmt!(\"%s%s%s\", prefix, (*str), suffix));\n       }\n     }\n }\n@@ -65,8 +65,8 @@ fn explain_region_and_span(cx: ctxt, region: ty::Region)\n     return match region {\n       re_scope(node_id) => {\n         match cx.items.find(node_id) {\n-          Some(ast_map::node_block(blk)) => {\n-            explain_span(cx, ~\"block\", blk.span)\n+          Some(ast_map::node_block(ref blk)) => {\n+            explain_span(cx, ~\"block\", (*blk).span)\n           }\n           Some(ast_map::node_expr(expr)) => {\n             match expr.node {\n@@ -95,8 +95,8 @@ fn explain_region_and_span(cx: ctxt, region: ty::Region)\n         };\n \n         match cx.items.find(id) {\n-          Some(ast_map::node_block(blk)) => {\n-            let (msg, opt_span) = explain_span(cx, ~\"block\", blk.span);\n+          Some(ast_map::node_block(ref blk)) => {\n+            let (msg, opt_span) = explain_span(cx, ~\"block\", (*blk).span);\n             (fmt!(\"%s %s\", prefix, msg), opt_span)\n           }\n           Some(_) | None => {\n@@ -143,9 +143,9 @@ fn bound_region_to_str_adorned(cx: ctxt, prefix: ~str,\n \n fn re_scope_id_to_str(cx: ctxt, node_id: ast::node_id) -> ~str {\n     match cx.items.find(node_id) {\n-      Some(ast_map::node_block(blk)) => {\n+      Some(ast_map::node_block(ref blk)) => {\n         fmt!(\"<block at %s>\",\n-             cx.sess.codemap.span_to_str(blk.span))\n+             cx.sess.codemap.span_to_str((*blk).span))\n       }\n       Some(ast_map::node_expr(expr)) => {\n         match expr.node {\n@@ -408,15 +408,15 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         ~\"'\" + str::from_bytes(~[('a' as u8) + (id as u8)])\n       }\n       ty_self => ~\"self\",\n-      ty_enum(did, substs) | ty_class(did, substs) => {\n+      ty_enum(did, ref substs) | ty_class(did, ref substs) => {\n         let path = ty::item_path(cx, did);\n         let base = ast_map::path_to_str(path, cx.sess.intr());\n-        parameterized(cx, base, substs.self_r, substs.tps)\n+        parameterized(cx, base, (*substs).self_r, (*substs).tps)\n       }\n-      ty_trait(did, substs, vs) => {\n+      ty_trait(did, ref substs, vs) => {\n         let path = ty::item_path(cx, did);\n         let base = ast_map::path_to_str(path, cx.sess.intr());\n-        let result = parameterized(cx, base, substs.self_r, substs.tps);\n+        let result = parameterized(cx, base, (*substs).self_r, (*substs).tps);\n         vstore_ty_to_str(cx, result, vs)\n       }\n       ty_evec(mt, vs) => {"}, {"sha": "1e7e427a384154861d3e0769207e966a2dad1cc4", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -555,9 +555,9 @@ impl<T: to_bytes::IterBytes> inferable<T> : to_bytes::IterBytes {\n impl<T:cmp::Eq> inferable<T> : cmp::Eq {\n     pure fn eq(&self, other: &inferable<T>) -> bool {\n         match (*self) {\n-            expl(e0a) => {\n+            expl(ref e0a) => {\n                 match (*other) {\n-                    expl(e0b) => e0a == e0b,\n+                    expl(ref e0b) => (*e0a) == (*e0b),\n                     _ => false\n                 }\n             }"}, {"sha": "d04447e8d73b31ea7abd40c0d22264b99109d7d9", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -163,8 +163,8 @@ fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n         cx.local_id += 1u;\n     }\n     match fk {\n-      visit::fk_dtor(tps, attrs, self_id, parent_id) => {\n-          let dt = @{node: {id: id, attrs: attrs, self_id: self_id,\n+      visit::fk_dtor(tps, ref attrs, self_id, parent_id) => {\n+          let dt = @{node: {id: id, attrs: (*attrs), self_id: self_id,\n                      body: /* FIXME (#2543) */ copy body}, span: sp};\n           cx.map.insert(id, node_dtor(/* FIXME (#2543) */ copy tps, dt,\n                                       parent_id,\n@@ -219,16 +219,16 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n             map_method(impl_did, extend(cx, i.ident), *m, cx);\n         }\n       }\n-      item_enum(enum_definition, _) => {\n-        for enum_definition.variants.each |v| {\n+      item_enum(ref enum_definition, _) => {\n+        for (*enum_definition).variants.each |v| {\n             cx.map.insert(v.node.id, node_variant(\n                 /* FIXME (#2543) */ copy *v, i,\n                 extend(cx, i.ident)));\n         }\n       }\n       item_foreign_mod(nm) => {\n         let abi = match attr::foreign_abi(i.attrs) {\n-          either::Left(msg) => cx.diag.span_fatal(i.span, msg),\n+          either::Left(ref msg) => cx.diag.span_fatal(i.span, (*msg)),\n           either::Right(abi) => abi\n         };\n         for nm.items.each |nitem| {\n@@ -249,7 +249,7 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n         map_struct_def(struct_def, node_item(i, item_path), i.ident, i.id, cx,\n                        v);\n       }\n-      item_trait(_, traits, methods) => {\n+      item_trait(_, traits, ref methods) => {\n         // Map trait refs to their parent classes. This is\n         // so we can find the self_ty\n         for traits.each |p| {\n@@ -258,7 +258,7 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n             // encoding/decoding\n             cx.map.insert(p.impl_id, node_item(i, item_path));\n         }\n-        for methods.each |tm| {\n+        for (*methods).each |tm| {\n             let id = ast_util::trait_method_to_ty_method(*tm).id;\n             let d_id = ast_util::local_def(i.id);\n             cx.map.insert(id, node_trait_method(@*tm, d_id, item_path));\n@@ -368,9 +368,9 @@ fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n         fmt!(\"method %s in %s (id=%?)\",\n              *itr.get(m.ident), path_to_str(*path, itr), id)\n       }\n-      Some(node_variant(variant, _, path)) => {\n+      Some(node_variant(ref variant, _, path)) => {\n         fmt!(\"variant %s in %s (id=%?)\",\n-             *itr.get(variant.node.name), path_to_str(*path, itr), id)\n+             *itr.get((*variant).node.name), path_to_str(*path, itr), id)\n       }\n       Some(node_expr(expr)) => {\n         fmt!(\"expr %s (id=%?)\", pprust::expr_to_str(expr, itr), id)"}, {"sha": "7365ad12ba99f0f6a8a8864bd7a6bcc965b61df2", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -205,8 +205,8 @@ fn is_exported(i: ident, m: _mod) -> bool {\n     for m.items.each |it| {\n         if it.ident == i { local = true; }\n         match it.node {\n-          item_enum(enum_definition, _) =>\n-            for enum_definition.variants.each |v| {\n+          item_enum(ref enum_definition, _) =>\n+            for (*enum_definition).variants.each |v| {\n                 if v.node.name == i {\n                     local = true;\n                     parent_enum = Some(/* FIXME (#2543) */ copy it.ident);\n@@ -233,10 +233,10 @@ fn is_exported(i: ident, m: _mod) -> bool {\n                     }\n                   }\n \n-                  ast::view_path_list(path, ids, _) => {\n+                  ast::view_path_list(path, ref ids, _) => {\n                     if vec::len(path.idents) == 1u {\n                         if i == path.idents[0] { return true; }\n-                        for ids.each |id| {\n+                        for (*ids).each |id| {\n                             if id.node.name == i { return true; }\n                         }\n                     } else {\n@@ -314,7 +314,7 @@ fn public_methods(ms: ~[@method]) -> ~[@method] {\n // a default, pull out the useful fields to make a ty_method\n fn trait_method_to_ty_method(method: trait_method) -> ty_method {\n     match method {\n-      required(m) => m,\n+      required(ref m) => (*m),\n       provided(m) => {\n         {ident: m.ident, attrs: m.attrs,\n          purity: m.purity, decl: m.decl,\n@@ -329,7 +329,7 @@ fn split_trait_methods(trait_methods: ~[trait_method])\n     let mut reqd = ~[], provd = ~[];\n     for trait_methods.each |trt_method| {\n         match *trt_method {\n-          required(tm) => reqd.push(tm),\n+          required(ref tm) => reqd.push((*tm)),\n           provided(m) => provd.push(m)\n         }\n     };\n@@ -364,7 +364,7 @@ impl inlined_item: inlined_item_utils {\n           ii_item(i) => i.id,\n           ii_foreign(i) => i.id,\n           ii_method(_, m) => m.id,\n-          ii_dtor(dtor, _, _, _) => dtor.node.id\n+          ii_dtor(ref dtor, _, _, _) => (*dtor).node.id\n         }\n     }\n \n@@ -373,8 +373,8 @@ impl inlined_item: inlined_item_utils {\n           ii_item(i) => (v.visit_item)(i, e, v),\n           ii_foreign(i) => (v.visit_foreign_item)(i, e, v),\n           ii_method(_, m) => visit::visit_method_helper(m, e, v),\n-          ii_dtor(dtor, _, tps, parent_id) => {\n-              visit::visit_class_dtor_helper(dtor, tps, parent_id, e, v);\n+          ii_dtor(ref dtor, _, tps, parent_id) => {\n+              visit::visit_class_dtor_helper((*dtor), tps, parent_id, e, v);\n           }\n         }\n     }\n@@ -453,8 +453,8 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n         visit_item: fn@(i: @item) {\n             vfn(i.id);\n             match i.node {\n-              item_enum(enum_definition, _) =>\n-                for enum_definition.variants.each |v| { vfn(v.node.id); },\n+              item_enum(ref enum_definition, _) =>\n+                for (*enum_definition).variants.each |v| { vfn(v.node.id); },\n               _ => ()\n             }\n         },\n@@ -643,7 +643,7 @@ impl Privacy : cmp::Eq {\n fn has_legacy_export_attr(attrs: &[attribute]) -> bool {\n     for attrs.each |attribute| {\n         match attribute.node.value.node {\n-          meta_word(w) if w == ~\"legacy_exports\" => {\n+          meta_word(ref w) if (*w) == ~\"legacy_exports\" => {\n             return true;\n           }\n           _ => {}"}, {"sha": "79f78079784e653089b553ce4a1530fd17174069", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -124,9 +124,9 @@ fn get_attr_name(attr: ast::attribute) -> ~str {\n \n fn get_meta_item_name(meta: @ast::meta_item) -> ~str {\n     match meta.node {\n-      ast::meta_word(n) => n,\n-      ast::meta_name_value(n, _) => n,\n-      ast::meta_list(n, _) => n\n+      ast::meta_word(ref n) => (*n),\n+      ast::meta_name_value(ref n, _) => (*n),\n+      ast::meta_list(ref n, _) => (*n)\n     }\n }\n \n@@ -158,9 +158,9 @@ fn get_meta_item_list(meta: @ast::meta_item) -> Option<~[@ast::meta_item]> {\n  */\n fn get_name_value_str_pair(item: @ast::meta_item) -> Option<(~str, ~str)> {\n     match attr::get_meta_item_value_str(item) {\n-      Some(value) => {\n+      Some(ref value) => {\n         let name = attr::get_meta_item_name(item);\n-        Some((name, value))\n+        Some((name, (*value)))\n       }\n       None => None\n     }\n@@ -206,12 +206,12 @@ fn contains(haystack: ~[@ast::meta_item], needle: @ast::meta_item) -> bool {\n \n fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n     return match a.node {\n-          ast::meta_word(na) => match b.node {\n-            ast::meta_word(nb) => na == nb,\n+          ast::meta_word(ref na) => match b.node {\n+            ast::meta_word(ref nb) => (*na) == (*nb),\n             _ => false\n           },\n-          ast::meta_name_value(na, va) => match b.node {\n-            ast::meta_name_value(nb, vb) => na == nb && va.node == vb.node,\n+          ast::meta_name_value(ref na, va) => match b.node {\n+            ast::meta_name_value(ref nb, vb) => (*na) == (*nb) && va.node == vb.node,\n             _ => false\n           },\n           ast::meta_list(*) => {\n@@ -256,7 +256,7 @@ fn last_meta_item_value_str_by_name(items: ~[@ast::meta_item], name: ~str)\n \n     match last_meta_item_by_name(items, name) {\n       Some(item) => match attr::get_meta_item_value_str(item) {\n-        Some(value) => Some(value),\n+        Some(ref value) => Some((*value)),\n         None => None\n       },\n       None => None\n@@ -281,9 +281,9 @@ fn sort_meta_items(+items: ~[@ast::meta_item]) -> ~[@ast::meta_item] {\n     pure fn lteq(ma: &@ast::meta_item, mb: &@ast::meta_item) -> bool {\n         pure fn key(m: &ast::meta_item) -> ~str {\n             match m.node {\n-              ast::meta_word(name) => name,\n-              ast::meta_name_value(name, _) => name,\n-              ast::meta_list(name, _) => name\n+              ast::meta_word(ref name) => (*name),\n+              ast::meta_name_value(ref name, _) => (*name),\n+              ast::meta_list(ref name, _) => (*name)\n             }\n         }\n         key(*ma) <= key(*mb)\n@@ -334,8 +334,8 @@ fn foreign_abi(attrs: ~[ast::attribute]) -> Either<~str, ast::foreign_abi> {\n       option::Some(~\"stdcall\") => {\n         either::Right(ast::foreign_abi_stdcall)\n       }\n-      option::Some(t) => {\n-        either::Left(~\"unsupported abi: \" + t)\n+      option::Some(ref t) => {\n+        either::Left(~\"unsupported abi: \" + (*t))\n       }\n     };\n }"}, {"sha": "5218a753ae069b932df9ef114992190e78ef4bd2", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -308,10 +308,10 @@ pub impl CodeMap {\n                 self.lookup_char_pos_adj(\n                     sp.lo + (pos - loc.file.start_pos))\n             }\n-            FssExternal(eloc) => {\n-                {filename: /* FIXME (#2543) */ copy eloc.filename,\n-                 line: eloc.line + loc.line - 1u,\n-                 col: if loc.line == 1u {eloc.col + loc.col} else {loc.col},\n+            FssExternal(ref eloc) => {\n+                {filename: /* FIXME (#2543) */ copy (*eloc).filename,\n+                 line: (*eloc).line + loc.line - 1u,\n+                 col: if loc.line == 1u {(*eloc).col + loc.col} else {loc.col},\n                  file: None}\n             }\n         }"}, {"sha": "e42bb00c2129d1b429390d3ba745d1d9a0a78bd6", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -285,7 +285,7 @@ fn print_macro_backtrace(cm: @codemap::CodeMap, sp: span) {\n fn expect<T: Copy>(diag: span_handler,\n                    opt: Option<T>, msg: fn() -> ~str) -> T {\n     match opt {\n-       Some(t) => t,\n+       Some(ref t) => (*t),\n        None => diag.handler().bug(msg())\n     }\n }"}, {"sha": "a42a51fd302ba5854eba0c805581cc1eabbf8e8c", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -120,12 +120,12 @@ fn expand_auto_serialize(\n     do vec::flat_map(in_items) |item| {\n         if item.attrs.any(is_auto_serialize) {\n             match item.node {\n-                ast::item_ty(@{node: ast::ty_rec(fields), _}, tps) => {\n+                ast::item_ty(@{node: ast::ty_rec(ref fields), _}, tps) => {\n                     let ser_impl = mk_rec_ser_impl(\n                         cx,\n                         item.span,\n                         item.ident,\n-                        fields,\n+                        (*fields),\n                         tps\n                     );\n \n@@ -142,12 +142,12 @@ fn expand_auto_serialize(\n \n                     ~[filter_attrs(*item), ser_impl]\n                 },\n-                ast::item_enum(enum_def, tps) => {\n+                ast::item_enum(ref enum_def, tps) => {\n                     let ser_impl = mk_enum_ser_impl(\n                         cx,\n                         item.span,\n                         item.ident,\n-                        enum_def,\n+                        (*enum_def),\n                         tps\n                     );\n \n@@ -184,12 +184,12 @@ fn expand_auto_deserialize(\n     do vec::flat_map(in_items) |item| {\n         if item.attrs.any(is_auto_deserialize) {\n             match item.node {\n-                ast::item_ty(@{node: ast::ty_rec(fields), _}, tps) => {\n+                ast::item_ty(@{node: ast::ty_rec(ref fields), _}, tps) => {\n                     let deser_impl = mk_rec_deser_impl(\n                         cx,\n                         item.span,\n                         item.ident,\n-                        fields,\n+                        (*fields),\n                         tps\n                     );\n \n@@ -206,12 +206,12 @@ fn expand_auto_deserialize(\n \n                     ~[filter_attrs(*item), deser_impl]\n                 },\n-                ast::item_enum(enum_def, tps) => {\n+                ast::item_enum(ref enum_def, tps) => {\n                     let deser_impl = mk_enum_deser_impl(\n                         cx,\n                         item.span,\n                         item.ident,\n-                        enum_def,\n+                        (*enum_def),\n                         tps\n                     );\n "}, {"sha": "630ba3b8749bab43323d46d12afd9914294c0a49", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -202,12 +202,12 @@ fn mk_ctxt(parse_sess: parse::parse_sess,\n         fn mod_path() -> ~[ast::ident] { return self.mod_path; }\n         fn bt_push(ei: codemap::ExpnInfo) {\n             match ei {\n-              ExpandedFrom({call_site: cs, callie: callie}) => {\n+              ExpandedFrom({call_site: cs, callie: ref callie}) => {\n                 self.backtrace =\n                     Some(@ExpandedFrom({\n                         call_site: span {lo: cs.lo, hi: cs.hi,\n                                          expn_info: self.backtrace},\n-                        callie: callie}));\n+                        callie: (*callie)}));\n               }\n             }\n         }"}, {"sha": "51db63c819aeff88fc810b776e577c38803c690c", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -28,7 +28,7 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n     let var = expr_to_str(cx, args[0], ~\"env! requires a string\");\n     match os::getenv(var) {\n       option::None => return mk_uniq_str(cx, sp, ~\"\"),\n-      option::Some(s) => return mk_uniq_str(cx, sp, s)\n+      option::Some(ref s) => return mk_uniq_str(cx, sp, (*s))\n     }\n }\n "}, {"sha": "6efca050fa50e412626f1a8f384621084c243e48", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -29,9 +29,9 @@ fn expand_expr(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n     return match e {\n       // expr_mac should really be expr_ext or something; it's the\n       // entry-point for all syntax extensions.\n-          expr_mac(mac) => {\n+          expr_mac(ref mac) => {\n \n-            match mac.node {\n+            match (*mac).node {\n               // Old-style macros. For compatibility, will erase this whole\n               // block once we've transitioned.\n               mac_invoc(pth, args, body) => {\n@@ -50,7 +50,7 @@ fn expand_expr(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n                         fmt!(\"%s can only be used as a decorator\", *extname));\n                   }\n                   Some(normal({expander: exp, span: exp_sp})) => {\n-                    let expanded = exp(cx, mac.span, args, body);\n+                    let expanded = exp(cx, (*mac).span, args, body);\n \n                     cx.bt_push(ExpandedFrom({call_site: s,\n                                 callie: {name: *extname, span: exp_sp}}));\n@@ -61,7 +61,7 @@ fn expand_expr(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n                     (fully_expanded, s)\n                   }\n                   Some(macro_defining(ext)) => {\n-                    let named_extension = ext(cx, mac.span, args, body);\n+                    let named_extension = ext(cx, (*mac).span, args, body);\n                     exts.insert(named_extension.name, named_extension.ext);\n                     (ast::expr_rec(~[], None), s)\n                   }\n@@ -79,7 +79,7 @@ fn expand_expr(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n \n               // Token-tree macros, these will be the only case when we're\n               // finished transitioning.\n-              mac_invoc_tt(pth, tts) => {\n+              mac_invoc_tt(pth, ref tts) => {\n                 assert (vec::len(pth.idents) == 1u);\n                 /* using idents and token::special_idents would make the\n                 the macro names be hygienic */\n@@ -90,7 +90,7 @@ fn expand_expr(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n                                   fmt!(\"macro undefined: '%s'\", *extname))\n                   }\n                   Some(normal_tt({expander: exp, span: exp_sp})) => {\n-                    let expanded = match exp(cx, mac.span, tts) {\n+                    let expanded = match exp(cx, (*mac).span, (*tts)) {\n                       mr_expr(e) => e,\n                       mr_any(expr_maker,_,_) => expr_maker(),\n                       _ => cx.span_fatal(\n@@ -109,8 +109,8 @@ fn expand_expr(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n                   Some(normal({expander: exp, span: exp_sp})) => {\n                     //convert the new-style invoc for the old-style macro\n                     let arg = base::tt_args_to_original_flavor(cx, pth.span,\n-                                                               tts);\n-                    let expanded = exp(cx, mac.span, arg, None);\n+                                                               (*tts));\n+                    let expanded = exp(cx, (*mac).span, arg, None);\n \n                     cx.bt_push(ExpandedFrom({call_site: s,\n                                 callie: {name: *extname, span: exp_sp}}));\n@@ -128,7 +128,7 @@ fn expand_expr(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n \n                 }\n               }\n-              _ => cx.span_bug(mac.span, ~\"naked syntactic bit\")\n+              _ => cx.span_bug((*mac).span, ~\"naked syntactic bit\")\n             }\n           }\n           _ => orig(e, s, fld)\n@@ -158,9 +158,9 @@ fn expand_mod_items(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n     let new_items = do vec::flat_map(module_.items) |item| {\n         do vec::foldr(item.attrs, ~[*item]) |attr, items| {\n             let mname = match attr.node.value.node {\n-              ast::meta_word(n) => n,\n-              ast::meta_name_value(n, _) => n,\n-              ast::meta_list(n, _) => n\n+              ast::meta_word(ref n) => (*n),\n+              ast::meta_name_value(ref n, _) => (*n),\n+              ast::meta_list(ref n, _) => (*n)\n             };\n             match exts.find(mname) {\n               None | Some(normal(_)) | Some(macro_defining(_))\n@@ -227,33 +227,33 @@ fn expand_item_mac(exts: HashMap<~str, syntax_extension>,\n                    cx: ext_ctxt, &&it: @ast::item,\n                    fld: ast_fold) -> Option<@ast::item> {\n     let (pth, tts) = biased_match!(\n-        (it.node) ~ (item_mac({node: mac_invoc_tt(pth, tts), _})) else {\n+        (it.node) ~ (item_mac({node: mac_invoc_tt(pth, ref tts), _})) else {\n             cx.span_bug(it.span, ~\"invalid item macro invocation\")\n         };\n-        => (pth, tts)\n+        => (pth, (*tts))\n     );\n \n     let extname = cx.parse_sess().interner.get(pth.idents[0]);\n     let (expanded, ex_span) = match exts.find(*extname) {\n         None => cx.span_fatal(pth.span,\n                               fmt!(\"macro undefined: '%s!'\", *extname)),\n \n-        Some(normal_tt(expand)) => {\n+        Some(normal_tt(ref expand)) => {\n             if it.ident != parse::token::special_idents::invalid {\n                 cx.span_fatal(pth.span,\n                               fmt!(\"macro %s! expects no ident argument, \\\n                                     given '%s'\", *extname,\n                                    *cx.parse_sess().interner.get(it.ident)));\n             }\n-            ((expand.expander)(cx, it.span, tts), expand.span)\n+            (((*expand).expander)(cx, it.span, tts), (*expand).span)\n         }\n-        Some(item_tt(expand)) => {\n+        Some(item_tt(ref expand)) => {\n             if it.ident == parse::token::special_idents::invalid {\n                 cx.span_fatal(pth.span,\n                               fmt!(\"macro %s! expects an ident argument\",\n                                    *extname));\n             }\n-            ((expand.expander)(cx, it.span, it.ident, tts), expand.span)\n+            (((*expand).expander)(cx, it.span, it.ident, tts), (*expand).span)\n         }\n         _ => cx.span_fatal(\n             it.span, fmt!(\"%s! is not legal in item position\", *extname))\n@@ -268,8 +268,8 @@ fn expand_item_mac(exts: HashMap<~str, syntax_extension>,\n                                     + *extname),\n         mr_any(_, item_maker, _) =>\n             option::chain(item_maker(), |i| {fld.fold_item(i)}),\n-        mr_def(mdef) => {\n-            exts.insert(mdef.name, mdef.ext);\n+        mr_def(ref mdef) => {\n+            exts.insert((*mdef).name, (*mdef).ext);\n             None\n         }\n     };\n@@ -283,11 +283,11 @@ fn expand_stmt(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n     -> (stmt_, span)\n {\n     let (mac, pth, tts, semi) = biased_match! (\n-        (s)        ~ (stmt_mac(mac, semi))    else return orig(s, sp, fld);\n-        (mac.node) ~ (mac_invoc_tt(pth, tts)) else {\n-            cx.span_bug(mac.span, ~\"naked syntactic bit\")\n+        (s)        ~ (stmt_mac(ref mac, semi))    else return orig(s, sp, fld);\n+        ((*mac).node) ~ (mac_invoc_tt(pth, ref tts)) else {\n+            cx.span_bug((*mac).span, ~\"naked syntactic bit\")\n         };\n-        => (mac, pth, tts, semi));\n+        => ((*mac), pth, (*tts), semi));\n \n     assert(vec::len(pth.idents) == 1u);\n     let extname = cx.parse_sess().interner.get(pth.idents[0]);"}, {"sha": "e0d3bd03f42a4d66b896965e8eaab16a98fd5635", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -255,8 +255,8 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n     let nargs = args.len();\n     for pieces.each |pc| {\n         match *pc {\n-          PieceString(s) => {\n-            piece_exprs.push(mk_uniq_str(cx, fmt_sp, s))\n+          PieceString(ref s) => {\n+            piece_exprs.push(mk_uniq_str(cx, fmt_sp, (*s)))\n           }\n           PieceConv(conv) => {\n             n += 1u;"}, {"sha": "cd76655fef66fd3c60b1712953daf8fce1c6a852", "filename": "src/libsyntax/ext/pipes/check.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -50,18 +50,18 @@ impl ext_ctxt: proto::visitor<(), (), ()>  {\n     fn visit_message(name: ~str, _span: span, _tys: &[@ast::Ty],\n                      this: state, next: next_state) {\n         match next {\n-          Some({state: next, tys: next_tys}) => {\n+          Some({state: ref next, tys: next_tys}) => {\n             let proto = this.proto;\n-            if !proto.has_state(next) {\n+            if !proto.has_state((*next)) {\n                 // This should be a span fatal, but then we need to\n                 // track span information.\n                 self.span_err(\n-                    proto.get_state(next).span,\n+                    proto.get_state((*next)).span,\n                     fmt!(\"message %s steps to undefined state, %s\",\n-                         name, next));\n+                         name, (*next)));\n             }\n             else {\n-                let next = proto.get_state(next);\n+                let next = proto.get_state((*next));\n \n                 if next.ty_params.len() != next_tys.len() {\n                     self.span_err("}, {"sha": "1c4dd197105b6b639a9567f37116dbc46e337061", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -55,10 +55,10 @@ impl message: gen_send {\n     fn gen_send(cx: ext_ctxt, try: bool) -> @ast::item {\n         debug!(\"pipec: gen_send\");\n         match self {\n-          message(_id, span, tys, this,\n-                  Some({state: next, tys: next_tys})) => {\n+          message(ref _id, span, tys, this,\n+                  Some({state: ref next, tys: next_tys})) => {\n             debug!(\"pipec: next state exists\");\n-            let next = this.proto.get_state(next);\n+            let next = this.proto.get_state((*next));\n             assert next_tys.len() == next.ty_params.len();\n             let arg_names = tys.mapi(|i, _ty| cx.ident_of(~\"x_\"+i.to_str()));\n \n@@ -139,7 +139,7 @@ impl message: gen_send {\n                             cx.expr_block(body))\n           }\n \n-            message(_id, span, tys, this, None) => {\n+            message(ref _id, span, tys, this, None) => {\n                 debug!(\"pipec: no next state\");\n                 let arg_names = tys.mapi(|i, _ty| (~\"x_\" + i.to_str()));\n \n@@ -220,8 +220,8 @@ impl state: to_type_decls {\n             let message(name, span, tys, this, next) = *m;\n \n             let tys = match next {\n-              Some({state: next, tys: next_tys}) => {\n-                let next = this.proto.get_state(next);\n+              Some({state: ref next, tys: next_tys}) => {\n+                let next = this.proto.get_state((*next));\n                 let next_name = cx.str_of(next.data_name());\n \n                 let dir = match this.dir {"}, {"sha": "af75c9e71dcf0b306357b59e9ab28fa3472fa856", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -55,7 +55,7 @@ enum message {\n impl message {\n     fn name() -> ~str {\n         match self {\n-          message(id, _, _, _, _) => id\n+          message(ref id, _, _, _, _) => (*id)\n         }\n     }\n \n@@ -113,8 +113,8 @@ impl state {\n     fn reachable(f: fn(state) -> bool) {\n         for self.messages.each |m| {\n             match *m {\n-              message(_, _, _, _, Some({state: id, _})) => {\n-                let state = self.proto.get_state(id);\n+              message(_, _, _, _, Some({state: ref id, _})) => {\n+                let state = self.proto.get_state((*id));\n                 if !f(state) { break }\n               }\n               _ => ()"}, {"sha": "e13dfe750b790484dcf5b38282b42e81ef3dd37a", "filename": "src/libsyntax/ext/qquote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -69,7 +69,7 @@ impl @ast::expr: qq_helper {\n     fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_expr(self, cx, v);}\n     fn extract_mac() -> Option<ast::mac_> {\n         match (self.node) {\n-          ast::expr_mac({node: mac, _}) => Some(mac),\n+          ast::expr_mac({node: ref mac, _}) => Some((*mac)),\n           _ => None\n         }\n     }\n@@ -84,7 +84,7 @@ impl @ast::Ty: qq_helper {\n     fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_ty(self, cx, v);}\n     fn extract_mac() -> Option<ast::mac_> {\n         match (self.node) {\n-          ast::ty_mac({node: mac, _}) => Some(mac),\n+          ast::ty_mac({node: ref mac, _}) => Some((*mac)),\n           _ => None\n         }\n     }"}, {"sha": "b2e651c7e3330ab26139f10ebb57bc9f268a02a4", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -104,15 +104,15 @@ fn mk_span(cx: ext_ctxt, qsp: span, sp: span) -> @ast::expr {\n \n     let e_expn_info = match sp.expn_info {\n         None => build::mk_path(cx, qsp, ids_ext(cx, ~[~\"None\"])),\n-        Some(@codemap::ExpandedFrom(cr)) => {\n+        Some(@codemap::ExpandedFrom(ref cr)) => {\n             let e_callee =\n                 build::mk_rec_e(\n                     cx, qsp,\n                     ~[{ident: id_ext(cx, ~\"name\"),\n                        ex: build::mk_uniq_str(cx, qsp,\n-                                              cr.callie.name)},\n+                                              (*cr).callie.name)},\n                       {ident: id_ext(cx, ~\"span\"),\n-                       ex: mk_option_span(cx, qsp, cr.callie.span)}]);\n+                       ex: mk_option_span(cx, qsp, (*cr).callie.span)}]);\n \n             let e_expn_info_ =\n                 build::mk_call(\n@@ -121,7 +121,7 @@ fn mk_span(cx: ext_ctxt, qsp: span, sp: span) -> @ast::expr {\n                     ~[build::mk_rec_e(\n                         cx, qsp,\n                         ~[{ident: id_ext(cx, ~\"call_site\"),\n-                           ex: mk_span(cx, qsp, cr.call_site)},\n+                           ex: mk_span(cx, qsp, (*cr).call_site)},\n                           {ident: id_ext(cx, ~\"callie\"),\n                            ex: e_callee}])]);\n \n@@ -327,20 +327,20 @@ fn mk_token(cx: ext_ctxt, sp: span, tok: token::Token) -> @ast::expr {\n \n fn mk_tt(cx: ext_ctxt, sp: span, tt: &ast::token_tree) -> @ast::expr {\n     match *tt {\n-        ast::tt_tok(sp, tok) => {\n+        ast::tt_tok(sp, ref tok) => {\n             let e_tok =\n                 build::mk_call(cx, sp,\n                                ids_ext(cx, ~[~\"tt_tok\"]),\n                                ~[mk_span(cx, sp, sp),\n-                                 mk_token(cx, sp, tok)]);\n+                                 mk_token(cx, sp, (*tok))]);\n             build::mk_uniq_vec_e(cx, sp, ~[e_tok])\n         }\n \n-        ast::tt_delim(tts) => {\n+        ast::tt_delim(ref tts) => {\n             let e_delim =\n                 build::mk_call(cx, sp,\n                                ids_ext(cx, ~[~\"tt_delim\"]),\n-                               ~[mk_tts(cx, sp, tts)]);\n+                               ~[mk_tts(cx, sp, (*tts))]);\n             build::mk_uniq_vec_e(cx, sp, ~[e_delim])\n         }\n "}, {"sha": "1bf24670aabdd7b195d65abd8cea8608cd87c497", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -55,8 +55,8 @@ fn match_error(cx: ext_ctxt, m: matchable, expected: ~str) -> ! {\n           x.span, ~\"this argument is an ident, expected \" + expected),\n       match_ty(x) => cx.span_fatal(\n           x.span, ~\"this argument is a type, expected \" + expected),\n-      match_block(x) => cx.span_fatal(\n-          x.span, ~\"this argument is a block, expected \" + expected),\n+      match_block(ref x) => cx.span_fatal(\n+          (*x).span, ~\"this argument is a block, expected \" + expected),\n       match_exact => cx.bug(~\"what is a match_exact doing in a bindings?\")\n     }\n }\n@@ -76,10 +76,10 @@ fn elts_to_ell(cx: ext_ctxt, elts: ~[@expr]) ->\n     let mut res = None;\n     for elts.each |elt| {\n         match elt.node {\n-          expr_mac(m) => match m.node {\n+          expr_mac(ref m) => match (*m).node {\n             ast::mac_ellipsis => {\n                 if res.is_some() {\n-                    cx.span_fatal(m.span, ~\"only one ellipsis allowed\");\n+                    cx.span_fatal((*m).span, ~\"only one ellipsis allowed\");\n                 }\n                 res =\n                     Some({pre: vec::slice(elts, 0u, idx - 1u),\n@@ -104,15 +104,15 @@ fn option_flatten_map<T: Copy, U: Copy>(f: fn@(T) -> Option<U>, v: ~[T]) ->\n     for v.each |elem| {\n         match f(*elem) {\n           None => return None,\n-          Some(fv) => res.push(fv)\n+          Some(ref fv) => res.push((*fv))\n         }\n     }\n     return Some(res);\n }\n \n fn a_d_map(ad: arb_depth<matchable>, f: selector) -> match_result {\n     match ad {\n-      leaf(x) => return f(x),\n+      leaf(ref x) => return f((*x)),\n       seq(ads, span) => match option_flatten_map(|x| a_d_map(x, f), *ads) {\n         None => return None,\n         Some(ts) => return Some(seq(@ts, span))\n@@ -124,7 +124,7 @@ fn compose_sels(s1: selector, s2: selector) -> selector {\n     fn scomp(s1: selector, s2: selector, m: matchable) -> match_result {\n         return match s1(m) {\n               None => None,\n-              Some(matches) => a_d_map(matches, s2)\n+              Some(ref matches) => a_d_map((*matches), s2)\n             }\n     }\n     return { |x| scomp(s1, s2, x) };\n@@ -172,7 +172,7 @@ fn use_selectors_to_bind(b: binders, e: @expr) -> Option<bindings> {\n     for b.real_binders.each |key, val| {\n         match val(match_expr(e)) {\n           None => never_mind = true,\n-          Some(mtc) => { res.insert(key, mtc); }\n+          Some(ref mtc) => { res.insert(key, (*mtc)); }\n         }\n     };\n     //HACK: `ret` doesn't work in `for each`\n@@ -231,14 +231,14 @@ fn follow_for_trans(cx: ext_ctxt, mmaybe: Option<arb_depth<matchable>>,\n                     idx_path: @mut ~[uint]) -> Option<matchable> {\n     match mmaybe {\n       None => return None,\n-      Some(m) => {\n-        return match follow(m, *idx_path) {\n+      Some(ref m) => {\n+        return match follow((*m), *idx_path) {\n               seq(_, sp) => {\n                 cx.span_fatal(sp,\n                               ~\"syntax matched under ... but not \" +\n                                   ~\"used that way.\")\n               }\n-              leaf(m) => return Some(m)\n+              leaf(ref m) => return Some((*m))\n             }\n       }\n     }\n@@ -337,7 +337,7 @@ fn transcribe_ident(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n                     &&i: ident, _fld: ast_fold) -> ident {\n     return match follow_for_trans(cx, b.find(i), idx_path) {\n           Some(match_ident(a_id)) => a_id.node,\n-          Some(m) => match_error(cx, m, ~\"an identifier\"),\n+          Some(ref m) => match_error(cx, (*m), ~\"an identifier\"),\n           None => i\n         }\n }\n@@ -353,7 +353,7 @@ fn transcribe_path(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n          rp: None, types: ~[]}\n       }\n       Some(match_path(a_pth)) => *a_pth,\n-      Some(m) => match_error(cx, m, ~\"a path\"),\n+      Some(ref m) => match_error(cx, (*m), ~\"a path\"),\n       None => p\n     }\n }\n@@ -380,7 +380,7 @@ fn transcribe_expr(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n               }\n               Some(match_path(a_pth)) => (expr_path(a_pth), s),\n               Some(match_expr(a_exp)) => (a_exp.node, a_exp.span),\n-              Some(m) => match_error(cx, m, ~\"an expression\"),\n+              Some(ref m) => match_error(cx, (*m), ~\"an expression\"),\n               None => orig(e, s, fld)\n             }\n           }\n@@ -399,7 +399,7 @@ fn transcribe_type(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n               Some(id) => {\n                 match follow_for_trans(cx, b.find(id), idx_path) {\n                   Some(match_ty(ty)) => (ty.node, ty.span),\n-                  Some(m) => match_error(cx, m, ~\"a type\"),\n+                  Some(ref m) => match_error(cx, (*m), ~\"a type\"),\n                   None => orig(t, s, fld)\n                 }\n               }\n@@ -422,10 +422,10 @@ fn transcribe_block(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n     return match block_to_ident(blk) {\n           Some(id) => {\n             match follow_for_trans(cx, b.find(id), idx_path) {\n-              Some(match_block(new_blk)) => (new_blk.node, new_blk.span),\n+              Some(match_block(ref new_blk)) => ((*new_blk).node, (*new_blk).span),\n \n               // possibly allow promotion of ident/path/expr to blocks?\n-              Some(m) => match_error(cx, m, ~\"a block\"),\n+              Some(ref m) => match_error(cx, (*m), ~\"a block\"),\n               None => orig(blk, s, fld)\n             }\n           }\n@@ -468,8 +468,8 @@ fn p_t_s_rec(cx: ext_ctxt, m: matchable, s: selector, b: binders) {\n             }\n           }\n           /* FIXME (#2251): handle embedded types and blocks, at least */\n-          expr_mac(mac) => {\n-            p_t_s_r_mac(cx, mac, s, b);\n+          expr_mac(ref mac) => {\n+            p_t_s_r_mac(cx, (*mac), s, b);\n           }\n           _ => {\n             fn select(cx: ext_ctxt, m: matchable, pat: @expr) ->\n@@ -548,7 +548,7 @@ fn p_t_s_r_mac(cx: ext_ctxt, mac: ast::mac, _s: selector, _b: binders) {\n                    fn_m: fn(ast::mac) -> match_result) -> match_result {\n         return match m {\n               match_expr(e) => match e.node {\n-                expr_mac(mac) => fn_m(mac),\n+                expr_mac(ref mac) => fn_m((*mac)),\n                 _ => None\n               },\n               _ => cx.bug(~\"broken traversal in p_t_s_r\")\n@@ -659,15 +659,15 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n \n \n             match elts[0u].node {\n-              expr_mac(mac) => {\n-                match mac.node {\n+              expr_mac(ref mac) => {\n+                match (*mac).node {\n                   mac_invoc(pth, invoc_arg, _) => {\n                     match path_to_ident(pth) {\n                       Some(id) => {\n                         let id_str = cx.str_of(id);\n                         match macro_name {\n                           None => macro_name = Some(id_str),\n-                          Some(other_id) => if id_str != other_id {\n+                          Some(ref other_id) => if id_str != (*other_id) {\n                             cx.span_fatal(pth.span,\n                                           ~\"macro name must be \" +\n                                           ~\"consistent\");\n@@ -679,7 +679,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                     }\n                     let arg = match invoc_arg {\n                       Some(arg) => arg,\n-                      None => cx.span_fatal(mac.span,\n+                      None => cx.span_fatal((*mac).span,\n                                            ~\"macro must have arguments\")\n                     };\n                     clauses.push(@{params: pattern_to_selectors(cx, arg),\n@@ -689,7 +689,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                     // the macro arg situation)\n                   }\n                   _ => {\n-                      cx.span_bug(mac.span, ~\"undocumented invariant in \\\n+                      cx.span_bug((*mac).span, ~\"undocumented invariant in \\\n                          add_extension\");\n                   }\n                 }\n@@ -712,7 +712,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n \n     return {name:\n              match macro_name {\n-               Some(id) => id,\n+               Some(ref id) => (*id),\n                None => cx.span_fatal(sp, ~\"macro definition must have \" +\n                                      ~\"at least one clause\")\n              },"}, {"sha": "aa97646c054299753d06ba35cc3cfc493225708b", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -83,8 +83,8 @@ fn expand_include_str(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n     let res = io::read_whole_file_str(&res_rel_file(cx, sp, &Path(file)));\n     match res {\n       result::Ok(_) => { /* Continue. */ }\n-      result::Err(e) => {\n-        cx.parse_sess().span_diagnostic.handler().fatal(e);\n+      result::Err(ref e) => {\n+        cx.parse_sess().span_diagnostic.handler().fatal((*e));\n       }\n     }\n \n@@ -104,8 +104,8 @@ fn expand_include_bin(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n         });\n         return mk_base_vec_e(cx, sp, u8_exprs);\n       }\n-      result::Err(e) => {\n-        cx.parse_sess().span_diagnostic.handler().fatal(e)\n+      result::Err(ref e) => {\n+        cx.parse_sess().span_diagnostic.handler().fatal((*e))\n       }\n     }\n }"}, {"sha": "e51800b8a61feb702a30395935c9101b6acc43da", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -117,8 +117,8 @@ type matcher_pos = ~{\n };\n \n fn copy_up(&& mpu: matcher_pos_up) -> matcher_pos {\n-    match mpu {\n-      matcher_pos_up(Some(mp)) => copy mp,\n+    match &mpu {\n+      &matcher_pos_up(Some(ref mp)) => copy (*mp),\n       _ => fail\n     }\n }\n@@ -127,7 +127,7 @@ fn count_names(ms: &[matcher]) -> uint {\n     vec::foldl(0u, ms, |ct, m| {\n         ct + match m.node {\n           match_tok(_) => 0u,\n-          match_seq(more_ms, _, _, _, _) => count_names(more_ms),\n+          match_seq(ref more_ms, _, _, _, _) => count_names((*more_ms)),\n           match_nonterminal(_,_,_) => 1u\n         }})\n }\n@@ -184,8 +184,8 @@ fn nameize(p_s: parse_sess, ms: ~[matcher], res: ~[@named_match])\n              ret_val: HashMap<ident, @named_match>) {\n         match m {\n           {node: match_tok(_), span: _} => (),\n-          {node: match_seq(more_ms, _, _, _, _), span: _} => {\n-            for more_ms.each() |next_m| { n_rec(p_s, *next_m, res, ret_val) };\n+          {node: match_seq(ref more_ms, _, _, _, _), span: _} => {\n+            for (*more_ms).each() |next_m| { n_rec(p_s, *next_m, res, ret_val) };\n           }\n           {node: match_nonterminal(bind_name, _, idx), span: sp} => {\n             if ret_val.contains_key(bind_name) {\n@@ -211,8 +211,8 @@ fn parse_or_else(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader,\n                  ms: ~[matcher]) -> HashMap<ident, @named_match> {\n     match parse(sess, cfg, rdr, ms) {\n       success(m) => m,\n-      failure(sp, str) => sess.span_diagnostic.span_fatal(sp, str),\n-      error(sp, str) => sess.span_diagnostic.span_fatal(sp, str)\n+      failure(sp, ref str) => sess.span_diagnostic.span_fatal(sp, (*str)),\n+      error(sp, ref str) => sess.span_diagnostic.span_fatal(sp, (*str))\n     }\n }\n \n@@ -274,8 +274,8 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n \n                     // the *_t vars are workarounds for the lack of unary move\n                     match copy ei.sep {\n-                      Some(t) if idx == len => { // we need a separator\n-                        if tok == t { //pass the separator\n+                      Some(ref t) if idx == len => { // we need a separator\n+                        if tok == (*t) { //pass the separator\n                             let ei_t = move ei;\n                             ei_t.idx += 1;\n                             next_eis.push(move ei_t);\n@@ -293,7 +293,7 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n             } else {\n                 match copy ei.elts[idx].node {\n                   /* need to descend into sequence */\n-                  match_seq(matchers, sep, zero_ok,\n+                  match_seq(ref matchers, ref sep, zero_ok,\n                             match_idx_lo, match_idx_hi) => {\n                     if zero_ok {\n                         let new_ei = copy ei;\n@@ -310,17 +310,17 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n                                            |_m| DVec::<@named_match>());\n                     let ei_t = move ei;\n                     cur_eis.push(~{\n-                        elts: matchers, sep: sep, mut idx: 0u,\n+                        elts: (*matchers), sep: (*sep), mut idx: 0u,\n                         mut up: matcher_pos_up(Some(move ei_t)),\n                         matches: move matches,\n                         match_lo: match_idx_lo, match_hi: match_idx_hi,\n                         sp_lo: sp.lo\n                     });\n                   }\n                   match_nonterminal(_,_,_) => { bb_eis.push(move ei) }\n-                  match_tok(t) => {\n+                  match_tok(ref t) => {\n                     let ei_t = move ei;\n-                    if t == tok {\n+                    if (*t) == tok {\n                         ei_t.idx += 1;\n                         next_eis.push(move ei_t);\n                     }"}, {"sha": "0941570326016654d176c5f7afc55a3066107c3d", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -84,17 +84,17 @@ fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n \n         for lhses.eachi() |i, lhs| { // try each arm's matchers\n             match *lhs {\n-              @matched_nonterminal(nt_matchers(mtcs)) => {\n+              @matched_nonterminal(nt_matchers(ref mtcs)) => {\n                 // `none` is because we're not interpolating\n                 let arg_rdr = new_tt_reader(s_d, itr, None, arg) as reader;\n-                match parse(cx.parse_sess(), cx.cfg(), arg_rdr, mtcs) {\n+                match parse(cx.parse_sess(), cx.cfg(), arg_rdr, (*mtcs)) {\n                   success(named_matches) => {\n                     let rhs = match rhses[i] {\n                         // okay, what's your transcriber?\n-                        @matched_nonterminal(nt_tt(@tt)) => {\n-                            match tt {\n+                        @matched_nonterminal(nt_tt(@ref tt)) => {\n+                            match (*tt) {\n                                 // cut off delimiters; don't parse 'em\n-                                tt_delim(tts) => tts.slice(1u,tts.len()-1u),\n+                                tt_delim(ref tts) => (*tts).slice(1u,(*tts).len()-1u),\n                                 _ => cx.span_fatal(\n                                     sp, ~\"macro rhs must be delimited\")\n                             }\n@@ -113,11 +113,11 @@ fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n                                   || p.parse_item(~[/* no attrs*/]),\n                                   || p.parse_stmt(~[/* no attrs*/]));\n                   }\n-                  failure(sp, msg) => if sp.lo >= best_fail_spot.lo {\n+                  failure(sp, ref msg) => if sp.lo >= best_fail_spot.lo {\n                     best_fail_spot = sp;\n-                    best_fail_msg = msg;\n+                    best_fail_msg = (*msg);\n                   },\n-                  error(sp, msg) => cx.span_fatal(sp, msg)\n+                  error(sp, ref msg) => cx.span_fatal(sp, (*msg))\n                 }\n               }\n               _ => cx.bug(~\"non-matcher found in parsed lhses\")"}, {"sha": "3d90103918835a33001e97f751888d076e0f1362", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -130,8 +130,8 @@ fn lockstep_iter_size(t: token_tree, r: tt_reader) -> lis {\n         }\n     }\n     match t {\n-      tt_delim(tts) | tt_seq(_, tts, _, _) => {\n-        vec::foldl(lis_unconstrained, tts, |lis, tt|\n+      tt_delim(ref tts) | tt_seq(_, ref tts, _, _) => {\n+        vec::foldl(lis_unconstrained, (*tts), |lis, tt|\n             lis_merge(lis, lockstep_iter_size(*tt, r), r))\n       }\n       tt_tok(*) => lis_unconstrained,\n@@ -170,8 +170,8 @@ fn tt_next_token(&&r: tt_reader) -> {tok: Token, sp: span} {\n             r.cur.idx = 0u;\n             r.repeat_idx[r.repeat_idx.len() - 1u] += 1u;\n             match r.cur.sep {\n-              Some(tk) => {\n-                r.cur_tok = tk; /* repeat same span, I guess */\n+              Some(ref tk) => {\n+                r.cur_tok = (*tk); /* repeat same span, I guess */\n                 return ret_val;\n               }\n               None => ()\n@@ -181,27 +181,27 @@ fn tt_next_token(&&r: tt_reader) -> {tok: Token, sp: span} {\n     loop { /* because it's easiest, this handles `tt_delim` not starting\n     with a `tt_tok`, even though it won't happen */\n         match r.cur.readme[r.cur.idx] {\n-          tt_delim(tts) => {\n-            r.cur = @{readme: tts, mut idx: 0u, dotdotdoted: false,\n+          tt_delim(ref tts) => {\n+            r.cur = @{readme: (*tts), mut idx: 0u, dotdotdoted: false,\n                       sep: None, up: tt_frame_up(option::Some(r.cur)) };\n             // if this could be 0-length, we'd need to potentially recur here\n           }\n-          tt_tok(sp, tok) => {\n-            r.cur_span = sp; r.cur_tok = tok;\n+          tt_tok(sp, ref tok) => {\n+            r.cur_span = sp; r.cur_tok = (*tok);\n             r.cur.idx += 1u;\n             return ret_val;\n           }\n-          tt_seq(sp, tts, sep, zerok) => {\n-            match lockstep_iter_size(tt_seq(sp, tts, sep, zerok), r) {\n+          tt_seq(sp, ref tts, ref sep, zerok) => {\n+            match lockstep_iter_size(tt_seq(sp, (*tts), (*sep), zerok), r) {\n               lis_unconstrained => {\n                 r.sp_diag.span_fatal(\n                     sp, /* blame macro writer */\n                     ~\"attempted to repeat an expression containing no syntax \\\n                      variables matched as repeating at this depth\");\n               }\n-              lis_contradiction(msg) => { /* FIXME #2887 blame macro invoker\n+              lis_contradiction(ref msg) => { /* FIXME #2887 blame macro invoker\n                                           instead*/\n-                r.sp_diag.span_fatal(sp, msg);\n+                r.sp_diag.span_fatal(sp, (*msg));\n               }\n               lis_constraint(len, _) => {\n                 if len == 0 {\n@@ -217,8 +217,8 @@ fn tt_next_token(&&r: tt_reader) -> {tok: Token, sp: span} {\n                 } else {\n                     r.repeat_len.push(len);\n                     r.repeat_idx.push(0u);\n-                    r.cur = @{readme: tts, mut idx: 0u, dotdotdoted: true,\n-                              sep: sep, up: tt_frame_up(option::Some(r.cur))};\n+                    r.cur = @{readme: (*tts), mut idx: 0u, dotdotdoted: true,\n+                              sep: (*sep), up: tt_frame_up(option::Some(r.cur))};\n                 }\n               }\n             }\n@@ -234,8 +234,8 @@ fn tt_next_token(&&r: tt_reader) -> {tok: Token, sp: span} {\n                 r.cur.idx += 1u;\n                 return ret_val;\n               }\n-              matched_nonterminal(other_whole_nt) => {\n-                r.cur_span = sp; r.cur_tok = INTERPOLATED(other_whole_nt);\n+              matched_nonterminal(ref other_whole_nt) => {\n+                r.cur_span = sp; r.cur_tok = INTERPOLATED((*other_whole_nt));\n                 r.cur.idx += 1u;\n                 return ret_val;\n               }"}, {"sha": "39da8531da88b74386570d3b40cc94c88f452a4b", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -89,14 +89,14 @@ type ast_fold_precursor = @{\n fn fold_meta_item_(&&mi: @meta_item, fld: ast_fold) -> @meta_item {\n     return @{node:\n               match mi.node {\n-                meta_word(id) => meta_word(id),\n-                meta_list(id, mis) => {\n+                meta_word(ref id) => meta_word((*id)),\n+                meta_list(ref id, mis) => {\n                   let fold_meta_item = |x|fold_meta_item_(x, fld);\n-                  meta_list(/* FIXME: (#2543) */ copy id,\n+                  meta_list(/* FIXME: (#2543) */ copy (*id),\n                             vec::map(mis, |e| fold_meta_item(*e)))\n                 }\n-                meta_name_value(id, s) => {\n-                  meta_name_value(id, /* FIXME (#2543) */ copy s)\n+                meta_name_value(ref id, s) => {\n+                  meta_name_value((*id), /* FIXME (#2543) */ copy s)\n                 }\n               },\n           span: fld.new_span(mi.span)};\n@@ -216,21 +216,21 @@ fn noop_fold_struct_field(&&sf: @struct_field, fld: ast_fold)\n fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n     return match i {\n           item_const(t, e) => item_const(fld.fold_ty(t), fld.fold_expr(e)),\n-          item_fn(decl, purity, typms, body) => {\n+          item_fn(decl, purity, typms, ref body) => {\n               item_fn(fold_fn_decl(decl, fld),\n                       purity,\n                       fold_ty_params(typms, fld),\n-                      fld.fold_block(body))\n+                      fld.fold_block((*body)))\n           }\n           item_mod(m) => item_mod(fld.fold_mod(m)),\n           item_foreign_mod(nm) => item_foreign_mod(fld.fold_foreign_mod(nm)),\n           item_ty(t, typms) => item_ty(fld.fold_ty(t),\n                                        fold_ty_params(typms, fld)),\n-          item_enum(enum_definition, typms) => {\n+          item_enum(ref enum_definition, typms) => {\n             item_enum(ast::enum_def({\n-                variants: vec::map(enum_definition.variants,\n+                variants: vec::map((*enum_definition).variants,\n                                    |x| fld.fold_variant(*x)),\n-                common: option::map(&enum_definition.common,\n+                common: option::map(&(*enum_definition).common,\n                                     |x| fold_struct_def(*x, fld))\n             }), fold_ty_params(typms, fld))\n           }\n@@ -244,8 +244,8 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n                         fld.fold_ty(ty),\n                         vec::map(*methods, |x| fld.fold_method(*x)))\n           }\n-          item_trait(tps, traits, methods) => {\n-              let methods = do methods.map |method| {\n+          item_trait(tps, traits, ref methods) => {\n+              let methods = do (*methods).map |method| {\n                   match *method {\n                       required(*) => copy *method,\n                       provided(method) => provided(fld.fold_method(method))\n@@ -255,9 +255,9 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n                        vec::map(traits, |p| fold_trait_ref(*p, fld)),\n                        move methods)\n           }\n-      item_mac(m) => {\n+      item_mac(ref m) => {\n         // FIXME #2888: we might actually want to do something here.\n-        item_mac(m)\n+        item_mac((*m))\n       }\n         };\n }\n@@ -320,7 +320,7 @@ fn noop_fold_stmt(s: stmt_, fld: ast_fold) -> stmt_ {\n       stmt_decl(d, nid) => stmt_decl(fld.fold_decl(d), fld.new_id(nid)),\n       stmt_expr(e, nid) => stmt_expr(fld.fold_expr(e), fld.new_id(nid)),\n       stmt_semi(e, nid) => stmt_semi(fld.fold_expr(e), fld.new_id(nid)),\n-      stmt_mac(mac, semi) => stmt_mac(fold_mac(mac), semi)\n+      stmt_mac(ref mac, semi) => stmt_mac(fold_mac((*mac)), semi)\n     };\n }\n \n@@ -409,8 +409,8 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n           }\n           expr_repeat(expr, count, mutt) =>\n             expr_repeat(fld.fold_expr(expr), fld.fold_expr(count), mutt),\n-          expr_rec(fields, maybe_expr) => {\n-            expr_rec(vec::map(fields, |x| fold_field(*x)),\n+          expr_rec(ref fields, maybe_expr) => {\n+            expr_rec(vec::map((*fields), |x| fold_field(*x)),\n                      option::map(&maybe_expr, |x| fld.fold_expr(*x)))\n           }\n           expr_tup(elts) => expr_tup(vec::map(elts, |x| fld.fold_expr(*x))),\n@@ -435,35 +435,35 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n           expr_lit(_) => copy e,\n           expr_cast(expr, ty) => expr_cast(fld.fold_expr(expr), ty),\n           expr_addr_of(m, ohs) => expr_addr_of(m, fld.fold_expr(ohs)),\n-          expr_if(cond, tr, fl) => {\n-            expr_if(fld.fold_expr(cond), fld.fold_block(tr),\n+          expr_if(cond, ref tr, fl) => {\n+            expr_if(fld.fold_expr(cond), fld.fold_block((*tr)),\n                     option::map(&fl, |x| fld.fold_expr(*x)))\n           }\n-          expr_while(cond, body) => {\n-            expr_while(fld.fold_expr(cond), fld.fold_block(body))\n+          expr_while(cond, ref body) => {\n+            expr_while(fld.fold_expr(cond), fld.fold_block((*body)))\n           }\n-          expr_loop(body, opt_ident) => {\n-              expr_loop(fld.fold_block(body),\n+          expr_loop(ref body, opt_ident) => {\n+              expr_loop(fld.fold_block((*body)),\n                         option::map(&opt_ident, |x| fld.fold_ident(*x)))\n           }\n-          expr_match(expr, arms) => {\n+          expr_match(expr, ref arms) => {\n             expr_match(fld.fold_expr(expr),\n-                     vec::map(arms, |x| fld.fold_arm(*x)))\n+                     vec::map((*arms), |x| fld.fold_arm(*x)))\n           }\n-          expr_fn(proto, decl, body, captures) => {\n+          expr_fn(proto, decl, ref body, captures) => {\n             expr_fn(proto, fold_fn_decl(decl, fld),\n-                    fld.fold_block(body),\n+                    fld.fold_block((*body)),\n                     @((*captures).map(|cap_item| {\n                         @({id: fld.new_id(cap_item.id),\n                            ..**cap_item})})))\n           }\n-          expr_fn_block(decl, body, captures) => {\n-            expr_fn_block(fold_fn_decl(decl, fld), fld.fold_block(body),\n+          expr_fn_block(decl, ref body, captures) => {\n+            expr_fn_block(fold_fn_decl(decl, fld), fld.fold_block((*body)),\n                           @((*captures).map(|cap_item| {\n                               @({id: fld.new_id(cap_item.id),\n                                  ..**cap_item})})))\n           }\n-          expr_block(blk) => expr_block(fld.fold_block(blk)),\n+          expr_block(ref blk) => expr_block(fld.fold_block((*blk))),\n           expr_copy(e) => expr_copy(fld.fold_expr(e)),\n           expr_unary_move(e) => expr_unary_move(fld.fold_expr(e)),\n           expr_assign(el, er) => {\n@@ -492,10 +492,10 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n           expr_log(i, lv, e) => expr_log(i, fld.fold_expr(lv),\n                                          fld.fold_expr(e)),\n           expr_assert(e) => expr_assert(fld.fold_expr(e)),\n-          expr_mac(mac) => expr_mac(fold_mac(mac)),\n-          expr_struct(path, fields, maybe_expr) => {\n+          expr_mac(ref mac) => expr_mac(fold_mac((*mac))),\n+          expr_struct(path, ref fields, maybe_expr) => {\n             expr_struct(fld.fold_path(path),\n-                        vec::map(fields, |x| fold_field(*x)),\n+                        vec::map((*fields), |x| fold_field(*x)),\n                         option::map(&maybe_expr, |x| fld.fold_expr(*x)))\n           },\n           expr_paren(ex) => expr_paren(fld.fold_expr(ex))\n@@ -519,7 +519,7 @@ fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n       ty_vec(mt) => ty_vec(fold_mt(mt, fld)),\n       ty_ptr(mt) => ty_ptr(fold_mt(mt, fld)),\n       ty_rptr(region, mt) => ty_rptr(region, fold_mt(mt, fld)),\n-      ty_rec(fields) => ty_rec(vec::map(fields, |f| fold_field(*f, fld))),\n+      ty_rec(ref fields) => ty_rec(vec::map((*fields), |f| fold_field(*f, fld))),\n       ty_fn(f) =>\n         ty_fn(@TyFn {\n             proto: f.proto,\n@@ -533,7 +533,7 @@ fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n       ty_path(path, id) => ty_path(fld.fold_path(path), fld.new_id(id)),\n       ty_fixed_length_vec(mt, vs) =>\n         ty_fixed_length_vec(fold_mt(mt, fld), vs),\n-      ty_mac(mac) => ty_mac(fold_mac(mac))\n+      ty_mac(ref mac) => ty_mac(fold_mac((*mac)))\n     }\n }\n \n@@ -579,10 +579,10 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n             })\n         }\n \n-        enum_variant_kind(enum_definition) => {\n-            let variants = vec::map(enum_definition.variants,\n+        enum_variant_kind(ref enum_definition) => {\n+            let variants = vec::map((*enum_definition).variants,\n                                     |x| fld.fold_variant(*x));\n-            let common = option::map(&enum_definition.common,\n+            let common = option::map(&(*enum_definition).common,\n                                      |x| fold_struct_def(*x, fld));\n             kind = enum_variant_kind(ast::enum_def({ variants: variants,\n                                                      common: common }));"}, {"sha": "a48e33c94059c42b1969b7c7b97940baa904b4e0", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -199,9 +199,9 @@ impl Parser {\n         while self.token != token::GT\n             && self.token != token::BINOP(token::SHR) {\n             match sep {\n-              Some(t) => {\n+              Some(ref t) => {\n                 if first { first = false; }\n-                else { self.expect(t); }\n+                else { self.expect((*t)); }\n               }\n               _ => ()\n             }\n@@ -243,9 +243,9 @@ impl Parser {\n         let mut v: ~[T] = ~[];\n         while self.token != ket {\n             match sep.sep {\n-              Some(t) => {\n+              Some(ref t) => {\n                 if first { first = false; }\n-                else { self.expect(t); }\n+                else { self.expect((*t)); }\n               }\n               _ => ()\n             }"}, {"sha": "3763a74b9d24d7f136f7e33ca93509dec62822f1", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -406,9 +406,9 @@ fn scan_number(c: char, rdr: string_reader) -> token::Token {\n         num_str += ~\".\" + dec_part;\n     }\n     match scan_exponent(rdr) {\n-      Some(s) => {\n+      Some(ref s) => {\n         is_float = true;\n-        num_str += s;\n+        num_str += (*s);\n       }\n       None => ()\n     }"}, {"sha": "bebced8f38aea0469236d988b4d121142697473e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -136,7 +136,7 @@ macro_rules! maybe_whole_expr (\n \n macro_rules! maybe_whole (\n     ($p:expr, $constructor:ident) => ( match copy $p.token {\n-      INTERPOLATED(token::$constructor(x)) => { $p.bump(); return x; }\n+      INTERPOLATED(token::$constructor(ref x)) => { $p.bump(); return (*x); }\n       _ => ()\n     }) ;\n     (deref $p:expr, $constructor:ident) => ( match copy $p.token {\n@@ -155,7 +155,7 @@ macro_rules! maybe_whole (\n       _ => ()\n     }) ;\n     (pair_empty $p:expr, $constructor:ident) => ( match copy $p.token {\n-      INTERPOLATED(token::$constructor(x)) => { $p.bump(); return (~[], x); }\n+      INTERPOLATED(token::$constructor(ref x)) => { $p.bump(); return (~[], (*x)); }\n       _ => ()\n     })\n \n@@ -166,7 +166,7 @@ pure fn maybe_append(+lhs: ~[attribute], rhs: Option<~[attribute]>)\n                   -> ~[attribute] {\n     match rhs {\n         None => lhs,\n-        Some(attrs) => vec::append(lhs, attrs)\n+        Some(ref attrs) => vec::append(lhs, (*attrs))\n     }\n }\n \n@@ -510,9 +510,9 @@ impl Parser {\n         let lo = self.span.lo;\n \n         match self.maybe_parse_dollar_mac() {\n-          Some(e) => {\n+          Some(ref e) => {\n             return @{id: self.get_id(),\n-                  node: ty_mac(spanned(lo, self.span.hi, e)),\n+                  node: ty_mac(spanned(lo, self.span.hi, (*e))),\n                   span: mk_sp(lo, self.span.hi)};\n           }\n           None => ()\n@@ -928,7 +928,7 @@ impl Parser {\n         let mut ex: expr_;\n \n         match self.maybe_parse_dollar_mac() {\n-          Some(x) => return self.mk_mac_expr(lo, self.span.hi, x),\n+          Some(ref x) => return self.mk_mac_expr(lo, self.span.hi, (*x)),\n           _ => ()\n         }\n \n@@ -2022,7 +2022,7 @@ impl Parser {\n                 pat = pat_tup(fields);\n             }\n           }\n-          tok => {\n+          copy tok => {\n             if !is_ident_or_path(tok)\n                 || self.is_keyword(~\"true\")\n                 || self.is_keyword(~\"false\")\n@@ -2284,7 +2284,7 @@ impl Parser {\n             let mut item_attrs;\n             match self.parse_outer_attrs_or_ext(first_item_attrs) {\n               None => item_attrs = ~[],\n-              Some(Left(attrs)) => item_attrs = attrs,\n+              Some(Left(ref attrs)) => item_attrs = (*attrs),\n               Some(Right(ext)) => {\n                 return @spanned(lo, ext.span.hi,\n                                 stmt_expr(ext, self.get_id()));\n@@ -2346,8 +2346,8 @@ impl Parser {\n         let lo = self.span.lo;\n         let us = self.eat_keyword(~\"unsafe\");\n         self.expect(token::LBRACE);\n-        let {inner, next} = maybe_parse_inner_attrs_and_next(self,\n-                                                             parse_attrs);\n+        let {inner: move inner, next: move next} =\n+            maybe_parse_inner_attrs_and_next(self, parse_attrs);\n         let blk_check_mode = if us { unsafe_blk } else { default_blk };\n         return (inner, self.parse_block_tail_(lo, blk_check_mode, next));\n     }\n@@ -2372,7 +2372,9 @@ impl Parser {\n         let mut stmts = ~[];\n         let mut expr = None;\n \n-        let {attrs_remaining, view_items, items: items, _} =\n+        let {attrs_remaining: move attrs_remaining,\n+             view_items: move view_items,\n+             items: items, _} =\n             self.parse_items_and_view_items(first_item_attrs,\n                                             IMPORTS_AND_ITEMS_ALLOWED, false);\n \n@@ -2408,7 +2410,7 @@ impl Parser {\n                                 token::RBRACE => {\n                                     expr = Some(e);\n                                 }\n-                                t => {\n+                                copy t => {\n                                     if classify::stmt_ends_with_semi(*stmt) {\n                                         self.fatal(\n                                             ~\"expected `;` or `}` after \\\n@@ -2421,12 +2423,12 @@ impl Parser {\n                             }\n                         }\n \n-                        stmt_mac(m, _) => {\n+                        stmt_mac(ref m, _) => {\n                             // Statement macro; might be an expr\n                             match self.token {\n                                 token::SEMI => {\n                                     self.bump();\n-                                    stmts.push(@{node: stmt_mac(m, true),\n+                                    stmts.push(@{node: stmt_mac((*m), true),\n                                                  ..*stmt});\n                                 }\n                                 token::RBRACE => {\n@@ -2435,7 +2437,7 @@ impl Parser {\n                                     expr = Some(\n                                         self.mk_mac_expr(stmt.span.lo,\n                                                          stmt.span.hi,\n-                                                         m.node));\n+                                                         (*m).node));\n                                 }\n                                 _ => { stmts.push(stmt); }\n                             }\n@@ -2847,7 +2849,7 @@ impl Parser {\n             fields = ~[];\n             while self.token != token::RBRACE {\n                 match self.parse_class_item() {\n-                  dtor_decl(blk, attrs, s) => {\n+                  dtor_decl(ref blk, ref attrs, s) => {\n                       match the_dtor {\n                         Some((_, _, s_first)) => {\n                           self.span_note(s, fmt!(\"Duplicate destructor \\\n@@ -2857,7 +2859,7 @@ impl Parser {\n                                                           declared here\");\n                         }\n                         None => {\n-                          the_dtor = Some((blk, attrs, s));\n+                          the_dtor = Some(((*blk), (*attrs), s));\n                         }\n                       }\n                   }\n@@ -3007,7 +3009,9 @@ impl Parser {\n     fn parse_mod_items(term: token::Token,\n                        +first_item_attrs: ~[attribute]) -> _mod {\n         // Shouldn't be any view items since we've already parsed an item attr\n-        let {attrs_remaining, view_items, items: starting_items, _} =\n+        let {attrs_remaining: move attrs_remaining,\n+             view_items: move view_items,\n+             items: starting_items, _} =\n             self.parse_items_and_view_items(first_item_attrs,\n                                             VIEW_ITEMS_AND_ITEMS_ALLOWED,\n                                             true);\n@@ -3076,11 +3080,11 @@ impl Parser {\n         // on the mod, then we'll go and suck in another file and merge\n         // its contents\n         match ::attr::first_attr_value_str_by_name(outer_attrs, ~\"merge\") {\n-            Some(path) => {\n+            Some(ref path) => {\n                 let prefix = Path(\n                     self.sess.cm.span_to_filename(copy self.span));\n                 let prefix = prefix.dir_path();\n-                let path = Path(path);\n+                let path = Path((*path));\n                 let (new_mod_item, new_attrs) = self.eval_src_mod_from_path(\n                     prefix, path, ~[], id_span);\n \n@@ -3113,7 +3117,7 @@ impl Parser {\n         let file_path = match ::attr::first_attr_value_str_by_name(\n             outer_attrs, ~\"path\") {\n \n-            Some(d) => d,\n+            Some(ref d) => (*d),\n             None => default_path\n         };\n \n@@ -3143,7 +3147,7 @@ impl Parser {\n \n         fn cdir_path_opt(default: ~str, attrs: ~[ast::attribute]) -> ~str {\n             match ::attr::first_attr_value_str_by_name(attrs, ~\"path\") {\n-                Some(d) => d,\n+                Some(ref d) => (*d),\n                 None => default\n             }\n         }\n@@ -3208,7 +3212,10 @@ impl Parser {\n                                +first_item_attrs: ~[attribute])\n                             -> foreign_mod {\n         // Shouldn't be any view items since we've already parsed an item attr\n-        let {attrs_remaining, view_items, items: _, foreign_items} =\n+        let {attrs_remaining: move attrs_remaining,\n+             view_items: move view_items,\n+             items: _,\n+             foreign_items: move foreign_items} =\n             self.parse_items_and_view_items(first_item_attrs,\n                                          VIEW_ITEMS_AND_FOREIGN_ITEMS_ALLOWED,\n                                             true);\n@@ -3341,7 +3348,7 @@ impl Parser {\n         let mut methods: ~[@method] = ~[];\n         while self.token != token::RBRACE {\n             match self.parse_class_item() {\n-                dtor_decl(blk, attrs, s) => {\n+                dtor_decl(ref blk, ref attrs, s) => {\n                     match the_dtor {\n                         Some((_, _, s_first)) => {\n                             self.span_note(s, ~\"duplicate destructor \\\n@@ -3351,7 +3358,7 @@ impl Parser {\n                                               declared here\");\n                         }\n                         None => {\n-                            the_dtor = Some((blk, attrs, s));\n+                            the_dtor = Some(((*blk), (*attrs), s));\n                         }\n                     }\n                 }"}, {"sha": "a0aecd0375ebaf07b9ff8b487efc2cdaf832fe5b", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -190,9 +190,9 @@ fn to_str(in: @ident_interner, t: Token) -> ~str {\n       /* Other */\n       DOC_COMMENT(s) => *in.get(s),\n       EOF => ~\"<eof>\",\n-      INTERPOLATED(nt) => {\n+      INTERPOLATED(ref nt) => {\n         ~\"an interpolated \" +\n-            match nt {\n+            match (*nt) {\n               nt_item(*) => ~\"item\",\n               nt_block(*) => ~\"block\",\n               nt_stmt(*) => ~\"statement\","}, {"sha": "547f0141d33b9f38dabba134802aec99564f3933", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -387,7 +387,7 @@ fn print_type_ex(s: ps, &&ty: @ast::Ty, print_colons: bool) {\n           print_region(s, ~\"&\", region, ~\"/\");\n           print_mt(s, mt);\n       }\n-      ast::ty_rec(fields) => {\n+      ast::ty_rec(ref fields) => {\n         word(s.s, ~\"{\");\n         fn print_field(s: ps, f: ast::ty_field) {\n             cbox(s, indent_unit);\n@@ -398,7 +398,7 @@ fn print_type_ex(s: ps, &&ty: @ast::Ty, print_colons: bool) {\n             end(s);\n         }\n         fn get_span(f: ast::ty_field) -> codemap::span { return f.span; }\n-        commasep_cmnt(s, consistent, fields, print_field, get_span);\n+        commasep_cmnt(s, consistent, (*fields), print_field, get_span);\n         word(s.s, ~\",}\");\n       }\n       ast::ty_tup(elts) => {\n@@ -479,11 +479,11 @@ fn print_item(s: ps, &&item: @ast::item) {\n         end(s); // end the outer cbox\n \n       }\n-      ast::item_fn(decl, purity, typarams, body) => {\n+      ast::item_fn(decl, purity, typarams, ref body) => {\n         print_fn(s, decl, Some(purity), item.ident, typarams, None,\n                  item.vis);\n         word(s.s, ~\" \");\n-        print_block_with_attrs(s, body, item.attrs);\n+        print_block_with_attrs(s, (*body), item.attrs);\n       }\n       ast::item_mod(_mod) => {\n         head(s, visibility_qualified(item.vis, ~\"mod\"));\n@@ -522,8 +522,8 @@ fn print_item(s: ps, &&item: @ast::item) {\n         word(s.s, ~\";\");\n         end(s); // end the outer ibox\n       }\n-      ast::item_enum(enum_definition, params) => {\n-        print_enum_def(s, enum_definition, params, item.ident,\n+      ast::item_enum(ref enum_definition, params) => {\n+        print_enum_def(s, (*enum_definition), params, item.ident,\n                        item.span, item.vis);\n       }\n       ast::item_class(struct_def, tps) => {\n@@ -558,7 +558,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n             bclose(s, item.span);\n         }\n       }\n-      ast::item_trait(tps, traits, methods) => {\n+      ast::item_trait(tps, traits, ref methods) => {\n         head(s, visibility_qualified(item.vis, ~\"trait\"));\n         print_ident(s, item.ident);\n         print_type_params(s, tps);\n@@ -569,19 +569,19 @@ fn print_item(s: ps, &&item: @ast::item) {\n         }\n         word(s.s, ~\" \");\n         bopen(s);\n-        for methods.each |meth| {\n+        for (*methods).each |meth| {\n             print_trait_method(s, *meth);\n         }\n         bclose(s, item.span);\n       }\n-      ast::item_mac({node: ast::mac_invoc_tt(pth, tts), _}) => {\n+      ast::item_mac({node: ast::mac_invoc_tt(pth, ref tts), _}) => {\n         print_visibility(s, item.vis);\n         print_path(s, pth, false);\n         word(s.s, ~\"! \");\n         print_ident(s, item.ident);\n         cbox(s, indent_unit);\n         popen(s);\n-        for tts.each |tt| {\n+        for (*tts).each |tt| {\n             print_tt(s, *tt);\n         }\n         pclose(s);\n@@ -744,23 +744,23 @@ fn print_struct(s: ps, struct_def: @ast::struct_def, tps: ~[ast::ty_param],\n /// expression arguments as expressions). It can be done! I think.\n fn print_tt(s: ps, tt: ast::token_tree) {\n     match tt {\n-      ast::tt_delim(tts) => for tts.each() |tt_elt| { print_tt(s, *tt_elt); },\n-      ast::tt_tok(_, tk) => {\n-        match tk {\n+      ast::tt_delim(ref tts) => for (*tts).each() |tt_elt| { print_tt(s, *tt_elt); },\n+      ast::tt_tok(_, ref tk) => {\n+        match (*tk) {\n           parse::token::IDENT(*) => { // don't let idents run together\n             if s.s.token_tree_last_was_ident { word(s.s, ~\" \") }\n             s.s.token_tree_last_was_ident = true;\n           }\n           _ => { s.s.token_tree_last_was_ident = false; }\n         }\n-        word(s.s, parse::token::to_str(s.intr, tk));\n+        word(s.s, parse::token::to_str(s.intr, (*tk)));\n       }\n-      ast::tt_seq(_, tts, sep, zerok) => {\n+      ast::tt_seq(_, ref tts, ref sep, zerok) => {\n         word(s.s, ~\"$(\");\n-        for tts.each() |tt_elt| { print_tt(s, *tt_elt); }\n+        for (*tts).each() |tt_elt| { print_tt(s, *tt_elt); }\n         word(s.s, ~\")\");\n-        match sep {\n-          Some(tk) => word(s.s, parse::token::to_str(s.intr, tk)),\n+        match (*sep) {\n+          Some(ref tk) => word(s.s, parse::token::to_str(s.intr, (*tk))),\n           None => ()\n         }\n         word(s.s, if zerok { ~\"*\" } else { ~\"+\" });\n@@ -792,8 +792,8 @@ fn print_variant(s: ps, v: ast::variant) {\n             head(s, ~\"\");\n             print_struct(s, struct_def, ~[], v.node.name, v.span);\n         }\n-        ast::enum_variant_kind(enum_definition) => {\n-            print_variants(s, enum_definition.variants, v.span);\n+        ast::enum_variant_kind(ref enum_definition) => {\n+            print_variants(s, (*enum_definition).variants, v.span);\n         }\n     }\n     match v.node.disr_expr {\n@@ -818,7 +818,7 @@ fn print_ty_method(s: ps, m: ast::ty_method) {\n \n fn print_trait_method(s: ps, m: ast::trait_method) {\n     match m {\n-      required(ty_m) => print_ty_method(s, ty_m),\n+      required(ref ty_m) => print_ty_method(s, (*ty_m)),\n       provided(m)    => print_method(s, m)\n     }\n }\n@@ -892,9 +892,9 @@ fn print_stmt(s: ps, st: ast::stmt) {\n         print_expr(s, expr);\n         word(s.s, ~\";\");\n       }\n-      ast::stmt_mac(mac, semi) => {\n+      ast::stmt_mac(ref mac, semi) => {\n         space_if_not_bol(s);\n-        print_mac(s, mac);\n+        print_mac(s, (*mac));\n         if semi { word(s.s, ~\";\"); }\n       }\n     }\n@@ -974,21 +974,21 @@ fn print_if(s: ps, test: @ast::expr, blk: ast::blk,\n           Some(_else) => {\n             match _else.node {\n               // \"another else-if\"\n-              ast::expr_if(i, t, e) => {\n+              ast::expr_if(i, ref t, e) => {\n                 cbox(s, indent_unit - 1u);\n                 ibox(s, 0u);\n                 word(s.s, ~\" else if \");\n                 print_expr(s, i);\n                 space(s.s);\n-                print_block(s, t);\n+                print_block(s, (*t));\n                 do_else(s, e);\n               }\n               // \"final else\"\n-              ast::expr_block(b) => {\n+              ast::expr_block(ref b) => {\n                 cbox(s, indent_unit - 1u);\n                 ibox(s, 0u);\n                 word(s.s, ~\" else \");\n-                print_block(s, b);\n+                print_block(s, (*b));\n               }\n               // BLEAH, constraints would be great here\n               _ => {\n@@ -1014,11 +1014,11 @@ fn print_mac(s: ps, m: ast::mac) {\n         arg.iter(|a| print_expr(s, *a));\n         // FIXME: extension 'body' (#2339)\n       }\n-      ast::mac_invoc_tt(pth, tts) => {\n+      ast::mac_invoc_tt(pth, ref tts) => {\n         print_path(s, pth, false);\n         word(s.s, ~\"!\");\n         popen(s);\n-        for tts.each() |tt| { print_tt(s, *tt); }\n+        for (*tts).each() |tt| { print_tt(s, *tt); }\n         pclose(s);\n       }\n       ast::mac_ellipsis => word(s.s, ~\"...\"),\n@@ -1149,9 +1149,9 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         end(s);\n       }\n \n-      ast::expr_rec(fields, wth) => {\n+      ast::expr_rec(ref fields, wth) => {\n         word(s.s, ~\"{\");\n-        commasep_cmnt(s, consistent, fields, print_field, get_span);\n+        commasep_cmnt(s, consistent, (*fields), print_field, get_span);\n         match wth {\n           Some(expr) => {\n             ibox(s, indent_unit);\n@@ -1165,13 +1165,13 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         }\n         word(s.s, ~\"}\");\n       }\n-      ast::expr_struct(path, fields, wth) => {\n+      ast::expr_struct(path, ref fields, wth) => {\n         print_path(s, path, true);\n         word(s.s, ~\"{\");\n-        commasep_cmnt(s, consistent, fields, print_field, get_span);\n+        commasep_cmnt(s, consistent, (*fields), print_field, get_span);\n         match wth {\n             Some(expr) => {\n-                if vec::len(fields) > 0u { space(s.s); }\n+                if vec::len((*fields)) > 0u { space(s.s); }\n                 ibox(s, indent_unit);\n                 word(s.s, ~\",\");\n                 space(s.s);\n@@ -1229,33 +1229,33 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         word_space(s, ~\"as\");\n         print_type_ex(s, ty, true);\n       }\n-      ast::expr_if(test, blk, elseopt) => {\n-        print_if(s, test, blk, elseopt, false);\n+      ast::expr_if(test, ref blk, elseopt) => {\n+        print_if(s, test, (*blk), elseopt, false);\n       }\n-      ast::expr_while(test, blk) => {\n+      ast::expr_while(test, ref blk) => {\n         head(s, ~\"while\");\n         print_expr(s, test);\n         space(s.s);\n-        print_block(s, blk);\n+        print_block(s, (*blk));\n       }\n-      ast::expr_loop(blk, opt_ident) => {\n+      ast::expr_loop(ref blk, opt_ident) => {\n         head(s, ~\"loop\");\n         space(s.s);\n         opt_ident.iter(|ident| {\n             print_ident(s, *ident);\n             word_space(s, ~\":\");\n         });\n-        print_block(s, blk);\n+        print_block(s, (*blk));\n       }\n-      ast::expr_match(expr, arms) => {\n+      ast::expr_match(expr, ref arms) => {\n         cbox(s, alt_indent_unit);\n         ibox(s, 4);\n         word_nbsp(s, ~\"match\");\n         print_expr(s, expr);\n         space(s.s);\n         bopen(s);\n-        let len = arms.len();\n-        for arms.eachi |i, arm| {\n+        let len = (*arms).len();\n+        for (*arms).eachi |i, arm| {\n             space(s.s);\n             cbox(s, alt_indent_unit);\n             ibox(s, 0u);\n@@ -1287,10 +1287,10 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n                 match arm.body.node.expr {\n                     Some(expr) => {\n                         match expr.node {\n-                            ast::expr_block(blk) => {\n+                            ast::expr_block(ref blk) => {\n                                 // the block will close the pattern's ibox\n                                 print_block_unclosed_indent(\n-                                    s, blk, alt_indent_unit);\n+                                    s, (*blk), alt_indent_unit);\n                             }\n                             _ => {\n                                 end(s); // close the ibox for the pattern\n@@ -1312,7 +1312,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         }\n         bclose_(s, expr.span, alt_indent_unit);\n       }\n-      ast::expr_fn(proto, decl, body, cap_clause) => {\n+      ast::expr_fn(proto, decl, ref body, cap_clause) => {\n         // containing cbox, will be closed by print-block at }\n         cbox(s, indent_unit);\n         // head-box, will be closed by print-block at start\n@@ -1321,9 +1321,9 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n                              Some(proto), ast::inherited);\n         print_fn_args_and_ret(s, decl, *cap_clause, None);\n         space(s.s);\n-        print_block(s, body);\n+        print_block(s, (*body));\n       }\n-      ast::expr_fn_block(decl, body, cap_clause) => {\n+      ast::expr_fn_block(decl, ref body, cap_clause) => {\n         // in do/for blocks we don't want to show an empty\n         // argument list, but at this point we don't know which\n         // we are inside.\n@@ -1332,16 +1332,16 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         print_fn_block_args(s, decl, *cap_clause);\n         space(s.s);\n         // }\n-        assert body.node.stmts.is_empty();\n-        assert body.node.expr.is_some();\n+        assert (*body).node.stmts.is_empty();\n+        assert (*body).node.expr.is_some();\n         // we extract the block, so as not to create another set of boxes\n-        match body.node.expr.get().node {\n-            ast::expr_block(blk) => {\n-                print_block_unclosed(s, blk);\n+        match (*body).node.expr.get().node {\n+            ast::expr_block(ref blk) => {\n+                print_block_unclosed(s, (*blk));\n             }\n             _ => {\n                 // this is a bare expression\n-                print_expr(s, body.node.expr.get());\n+                print_expr(s, (*body).node.expr.get());\n                 end(s); // need to close a box\n             }\n         }\n@@ -1356,12 +1356,12 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n       ast::expr_do_body(body) => {\n         print_expr(s, body);\n       }\n-      ast::expr_block(blk) => {\n+      ast::expr_block(ref blk) => {\n         // containing cbox, will be closed by print-block at }\n         cbox(s, indent_unit);\n         // head-box, will be closed by print-block after {\n         ibox(s, 0u);\n-        print_block(s, blk);\n+        print_block(s, (*blk));\n       }\n       ast::expr_copy(e) => { word_space(s, ~\"copy\"); print_expr(s, e); }\n       ast::expr_unary_move(e) => {\n@@ -1447,7 +1447,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         word_nbsp(s, ~\"assert\");\n         print_expr(s, expr);\n       }\n-      ast::expr_mac(m) => print_mac(s, m),\n+      ast::expr_mac(ref m) => print_mac(s, (*m)),\n       ast::expr_paren(e) => {\n           popen(s);\n           print_expr(s, e);\n@@ -1768,14 +1768,14 @@ fn print_type_params(s: ps, &&params: ~[ast::ty_param]) {\n fn print_meta_item(s: ps, &&item: @ast::meta_item) {\n     ibox(s, indent_unit);\n     match item.node {\n-      ast::meta_word(name) => word(s.s, name),\n-      ast::meta_name_value(name, value) => {\n-        word_space(s, name);\n+      ast::meta_word(ref name) => word(s.s, (*name)),\n+      ast::meta_name_value(ref name, value) => {\n+        word_space(s, (*name));\n         word_space(s, ~\"=\");\n         print_literal(s, @value);\n       }\n-      ast::meta_list(name, items) => {\n-        word(s.s, name);\n+      ast::meta_list(ref name, items) => {\n+        word(s.s, (*name));\n         popen(s);\n         commasep(s, consistent, items, print_meta_item);\n         pclose(s);\n@@ -1803,10 +1803,10 @@ fn print_view_path(s: ps, &&vp: @ast::view_path) {\n         word(s.s, ~\"::*\");\n       }\n \n-      ast::view_path_list(path, idents, _) => {\n+      ast::view_path_list(path, ref idents, _) => {\n         print_path(s, path, false);\n         word(s.s, ~\"::{\");\n-        do commasep(s, inconsistent, idents) |s, w| {\n+        do commasep(s, inconsistent, (*idents)) |s, w| {\n             print_ident(s, w.node.name);\n         }\n         word(s.s, ~\"}\");\n@@ -1948,15 +1948,15 @@ fn maybe_print_trailing_comment(s: ps, span: codemap::span,\n     let mut cm;\n     match s.cm { Some(ccm) => cm = ccm, _ => return }\n     match next_comment(s) {\n-      Some(cmnt) => {\n-        if cmnt.style != comments::trailing { return; }\n+      Some(ref cmnt) => {\n+        if (*cmnt).style != comments::trailing { return; }\n         let span_line = cm.lookup_char_pos(span.hi);\n-        let comment_line = cm.lookup_char_pos(cmnt.pos);\n-        let mut next = cmnt.pos + BytePos(1u);\n+        let comment_line = cm.lookup_char_pos((*cmnt).pos);\n+        let mut next = (*cmnt).pos + BytePos(1u);\n         match next_pos { None => (), Some(p) => next = p }\n-        if span.hi < cmnt.pos && cmnt.pos < next &&\n+        if span.hi < (*cmnt).pos && (*cmnt).pos < next &&\n                span_line.line == comment_line.line {\n-            print_comment(s, cmnt);\n+            print_comment(s, (*cmnt));\n             s.cur_cmnt += 1u;\n         }\n       }\n@@ -1970,7 +1970,7 @@ fn print_remaining_comments(s: ps) {\n     if next_comment(s).is_none() { hardbreak(s.s); }\n     loop {\n         match next_comment(s) {\n-          Some(cmnt) => { print_comment(s, cmnt); s.cur_cmnt += 1u; }\n+          Some(ref cmnt) => { print_comment(s, (*cmnt)); s.cur_cmnt += 1u; }\n           _ => break\n         }\n     }\n@@ -1979,8 +1979,8 @@ fn print_remaining_comments(s: ps) {\n fn print_literal(s: ps, &&lit: @ast::lit) {\n     maybe_print_comment(s, lit.span.lo);\n     match next_lit(s, lit.span.lo) {\n-      Some(ltrl) => {\n-        word(s.s, ltrl.lit);\n+      Some(ref ltrl) => {\n+        word(s.s, (*ltrl).lit);\n         return;\n       }\n       _ => ()\n@@ -2030,9 +2030,9 @@ fn lit_to_str(l: @ast::lit) -> ~str {\n \n fn next_lit(s: ps, pos: BytePos) -> Option<comments::lit> {\n     match s.literals {\n-      Some(lits) => {\n-        while s.cur_lit < vec::len(lits) {\n-            let ltrl = lits[s.cur_lit];\n+      Some(ref lits) => {\n+        while s.cur_lit < vec::len((*lits)) {\n+            let ltrl = (*lits)[s.cur_lit];\n             if ltrl.pos > pos { return None; }\n             s.cur_lit += 1u;\n             if ltrl.pos == pos { return Some(ltrl); }\n@@ -2046,9 +2046,9 @@ fn next_lit(s: ps, pos: BytePos) -> Option<comments::lit> {\n fn maybe_print_comment(s: ps, pos: BytePos) {\n     loop {\n         match next_comment(s) {\n-          Some(cmnt) => {\n-            if cmnt.pos < pos {\n-                print_comment(s, cmnt);\n+          Some(ref cmnt) => {\n+            if (*cmnt).pos < pos {\n+                print_comment(s, (*cmnt));\n                 s.cur_cmnt += 1u;\n             } else { break; }\n           }\n@@ -2117,9 +2117,9 @@ fn to_str<T>(t: T, f: fn@(ps, T), intr: @ident_interner) -> ~str {\n \n fn next_comment(s: ps) -> Option<comments::cmnt> {\n     match s.comments {\n-      Some(cmnts) => {\n-        if s.cur_cmnt < vec::len(cmnts) {\n-            return Some(cmnts[s.cur_cmnt]);\n+      Some(ref cmnts) => {\n+        if s.cur_cmnt < vec::len((*cmnts)) {\n+            return Some((*cmnts)[s.cur_cmnt]);\n         } else { return None::<comments::cmnt>; }\n       }\n       _ => return None::<comments::cmnt>"}, {"sha": "66052767bd4d7c39129a5db452ab3b571103a5af", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -24,7 +24,7 @@\n #[allow(vecs_implicitly_copyable)];\n #[allow(non_camel_case_types)];\n #[allow(deprecated_mode)];\n-#[allow(deprecated_pattern)];\n+#[warn(deprecated_pattern)];\n \n extern mod core(vers = \"0.5\");\n extern mod std(vers = \"0.5\");"}, {"sha": "4a399c5a0dd4403f2b64cd200fa61a19e77a6b43", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ece46f7de9d1703dd39f952afac9bed22633b6/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=56ece46f7de9d1703dd39f952afac9bed22633b6", "patch": "@@ -125,10 +125,10 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n         (v.visit_ty)(t, e, v);\n         (v.visit_expr)(ex, e, v);\n       }\n-      item_fn(decl, purity, tp, body) => {\n+      item_fn(decl, purity, tp, ref body) => {\n         (v.visit_fn)(fk_item_fn(/* FIXME (#2543) */ copy i.ident,\n                               /* FIXME (#2543) */ copy tp,\n-                              purity), decl, body,\n+                              purity), decl, (*body),\n                    i.span, i.id, e, v);\n       }\n       item_mod(m) => (v.visit_mod)(m, i.span, i.id, e, v),\n@@ -140,9 +140,9 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n         (v.visit_ty)(t, e, v);\n         (v.visit_ty_params)(tps, e, v);\n       }\n-      item_enum(enum_definition, tps) => {\n+      item_enum(ref enum_definition, tps) => {\n         (v.visit_ty_params)(tps, e, v);\n-        visit_enum_def(enum_definition, tps, e, v);\n+        visit_enum_def((*enum_definition), tps, e, v);\n       }\n       item_impl(tps, traits, ty, methods) => {\n         (v.visit_ty_params)(tps, e, v);\n@@ -158,14 +158,14 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n         (v.visit_ty_params)(tps, e, v);\n         (v.visit_struct_def)(struct_def, i.ident, tps, i.id, e, v);\n       }\n-      item_trait(tps, traits, methods) => {\n+      item_trait(tps, traits, ref methods) => {\n         (v.visit_ty_params)(tps, e, v);\n         for traits.each |p| { visit_path(p.path, e, v); }\n-        for methods.each |m| {\n+        for (*methods).each |m| {\n             (v.visit_trait_method)(*m, e, v);\n         }\n       }\n-      item_mac(m) => visit_mac(m, e, v)\n+      item_mac(ref m) => visit_mac((*m), e, v)\n     }\n }\n \n@@ -180,8 +180,8 @@ fn visit_enum_def<E>(enum_definition: ast::enum_def, tps: ~[ast::ty_param],\n                 (v.visit_struct_def)(struct_def, vr.node.name, tps,\n                                    vr.node.id, e, v);\n             }\n-            enum_variant_kind(enum_definition) => {\n-                visit_enum_def(enum_definition, tps, e, v);\n+            enum_variant_kind(ref enum_definition) => {\n+                visit_enum_def((*enum_definition), tps, e, v);\n             }\n         }\n         // Visit the disr expr if it exists\n@@ -197,7 +197,7 @@ fn visit_ty<E>(t: @Ty, e: E, v: vt<E>) {\n       ty_vec(mt) | ty_ptr(mt) | ty_rptr(_, mt) => {\n         (v.visit_ty)(mt.ty, e, v);\n       }\n-      ty_rec(flds) => for flds.each |f| {\n+      ty_rec(ref flds) => for (*flds).each |f| {\n         (v.visit_ty)(f.node.mt.ty, e, v);\n       },\n       ty_tup(ts) => for ts.each |tt| {\n@@ -320,7 +320,7 @@ fn visit_ty_method<E>(m: ty_method, e: E, v: vt<E>) {\n \n fn visit_trait_method<E>(m: trait_method, e: E, v: vt<E>) {\n     match m {\n-      required(ty_m) => (v.visit_ty_method)(ty_m, e, v),\n+      required(ref ty_m) => (v.visit_ty_method)((*ty_m), e, v),\n       provided(m) => visit_method_helper(m, e, v)\n     }\n }\n@@ -364,7 +364,7 @@ fn visit_stmt<E>(s: @stmt, e: E, v: vt<E>) {\n       stmt_decl(d, _) => (v.visit_decl)(d, e, v),\n       stmt_expr(ex, _) => (v.visit_expr)(ex, e, v),\n       stmt_semi(ex, _) => (v.visit_expr)(ex, e, v),\n-      stmt_mac(mac, _) => visit_mac(mac, e, v)\n+      stmt_mac(ref mac, _) => visit_mac((*mac), e, v)\n     }\n }\n \n@@ -404,13 +404,13 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n         (v.visit_expr)(element, e, v);\n         (v.visit_expr)(count, e, v);\n       }\n-      expr_rec(flds, base) => {\n-        for flds.each |f| { (v.visit_expr)(f.node.expr, e, v); }\n+      expr_rec(ref flds, base) => {\n+        for (*flds).each |f| { (v.visit_expr)(f.node.expr, e, v); }\n         visit_expr_opt(base, e, v);\n       }\n-      expr_struct(p, flds, base) => {\n+      expr_struct(p, ref flds, base) => {\n         visit_path(p, e, v);\n-        for flds.each |f| { (v.visit_expr)(f.node.expr, e, v); }\n+        for (*flds).each |f| { (v.visit_expr)(f.node.expr, e, v); }\n         visit_expr_opt(base, e, v);\n       }\n       expr_tup(elts) => for elts.each |el| { (v.visit_expr)(*el, e, v); },\n@@ -431,29 +431,29 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n       expr_assert(x) => (v.visit_expr)(x, e, v),\n       expr_lit(_) => (),\n       expr_cast(x, t) => { (v.visit_expr)(x, e, v); (v.visit_ty)(t, e, v); }\n-      expr_if(x, b, eo) => {\n+      expr_if(x, ref b, eo) => {\n         (v.visit_expr)(x, e, v);\n-        (v.visit_block)(b, e, v);\n+        (v.visit_block)((*b), e, v);\n         visit_expr_opt(eo, e, v);\n       }\n-      expr_while(x, b) => {\n+      expr_while(x, ref b) => {\n         (v.visit_expr)(x, e, v);\n-        (v.visit_block)(b, e, v);\n+        (v.visit_block)((*b), e, v);\n       }\n-      expr_loop(b, _) => (v.visit_block)(b, e, v),\n-      expr_match(x, arms) => {\n+      expr_loop(ref b, _) => (v.visit_block)((*b), e, v),\n+      expr_match(x, ref arms) => {\n         (v.visit_expr)(x, e, v);\n-        for arms.each |a| { (v.visit_arm)(*a, e, v); }\n+        for (*arms).each |a| { (v.visit_arm)(*a, e, v); }\n       }\n-      expr_fn(proto, decl, body, cap_clause) => {\n-        (v.visit_fn)(fk_anon(proto, cap_clause), decl, body,\n+      expr_fn(proto, decl, ref body, cap_clause) => {\n+        (v.visit_fn)(fk_anon(proto, cap_clause), decl, (*body),\n                      ex.span, ex.id, e, v);\n       }\n-      expr_fn_block(decl, body, cap_clause) => {\n-        (v.visit_fn)(fk_fn_block(cap_clause), decl, body,\n+      expr_fn_block(decl, ref body, cap_clause) => {\n+        (v.visit_fn)(fk_fn_block(cap_clause), decl, (*body),\n                      ex.span, ex.id, e, v);\n       }\n-      expr_block(b) => (v.visit_block)(b, e, v),\n+      expr_block(ref b) => (v.visit_block)((*b), e, v),\n       expr_assign(a, b) => {\n         (v.visit_expr)(b, e, v);\n         (v.visit_expr)(a, e, v);\n@@ -482,7 +482,7 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n         (v.visit_expr)(lv, e, v);\n         (v.visit_expr)(x, e, v);\n       }\n-      expr_mac(mac) => visit_mac(mac, e, v),\n+      expr_mac(ref mac) => visit_mac((*mac), e, v),\n       expr_paren(x) => (v.visit_expr)(x, e, v),\n     }\n     (v.visit_expr_post)(ex, e, v);"}]}