{"sha": "8f7eb3b058f78bffe5406776eb31080615799ce7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmN2ViM2IwNThmNzhiZmZlNTQwNjc3NmViMzEwODA2MTU3OTljZTc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-10T20:23:17Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-14T17:14:19Z"}, "message": "core: Update all Result docs", "tree": {"sha": "ce60bfa51beb1dc9dc4df7b26003ffec7ba5b6cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce60bfa51beb1dc9dc4df7b26003ffec7ba5b6cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f7eb3b058f78bffe5406776eb31080615799ce7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f7eb3b058f78bffe5406776eb31080615799ce7", "html_url": "https://github.com/rust-lang/rust/commit/8f7eb3b058f78bffe5406776eb31080615799ce7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f7eb3b058f78bffe5406776eb31080615799ce7/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b53319a5bb86806d5b97ba0482b0cb260ea6c246", "url": "https://api.github.com/repos/rust-lang/rust/commits/b53319a5bb86806d5b97ba0482b0cb260ea6c246", "html_url": "https://github.com/rust-lang/rust/commit/b53319a5bb86806d5b97ba0482b0cb260ea6c246"}], "stats": {"total": 122, "additions": 52, "deletions": 70}, "files": [{"sha": "66c6863149146cafd8e518b545bf40b42e1da604", "filename": "src/libcore/result.rs", "status": "modified", "additions": 52, "deletions": 70, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/8f7eb3b058f78bffe5406776eb31080615799ce7/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f7eb3b058f78bffe5406776eb31080615799ce7/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=8f7eb3b058f78bffe5406776eb31080615799ce7", "patch": "@@ -85,35 +85,32 @@\n //! functions that may encounter errors but don't otherwise return a\n //! useful value.\n //!\n-//! Consider the `write_line` method defined for I/O types\n-//! by the [`Writer`](../old_io/trait.Writer.html) trait:\n+//! Consider the `write_all` method defined for I/O types\n+//! by the [`Write`](../io/trait.Write.html) trait:\n //!\n //! ```\n-//! # #![feature(old_io)]\n-//! use std::old_io::IoError;\n+//! use std::io;\n //!\n //! trait Writer {\n-//!     fn write_line(&mut self, s: &str) -> Result<(), IoError>;\n+//!     fn write_all(&mut self, bytes: &[u8]) -> Result<(), io::Error>;\n //! }\n //! ```\n //!\n-//! *Note: The actual definition of `Writer` uses `IoResult`, which\n-//! is just a synonym for `Result<T, IoError>`.*\n+//! *Note: The actual definition of `Write` uses `io::Result`, which\n+//! is just a synonym for `Result<T, io::Error>`.*\n //!\n //! This method doesn't produce a value, but the write may\n //! fail. It's crucial to handle the error case, and *not* write\n //! something like this:\n //!\n-//! ```{.ignore}\n-//! # #![feature(old_io)]\n-//! use std::old_io::*;\n-//! use std::old_path::Path;\n+//! ```no_run\n+//! use std::fs::File;\n+//! use std::io::prelude::*;\n //!\n-//! let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n-//! // If `write_line` errors, then we'll never know, because the return\n+//! let mut file = File::create(\"valuable_data.txt\").unwrap();\n+//! // If `write_all` errors, then we'll never know, because the return\n //! // value is ignored.\n-//! file.write_line(\"important message\");\n-//! drop(file);\n+//! file.write_all(b\"important message\");\n //! ```\n //!\n //! If you *do* write that in Rust, the compiler will give you a\n@@ -125,37 +122,31 @@\n //! a marginally useful message indicating why:\n //!\n //! ```{.no_run}\n-//! # #![feature(old_io, old_path)]\n-//! use std::old_io::*;\n-//! use std::old_path::Path;\n+//! use std::fs::File;\n+//! use std::io::prelude::*;\n //!\n-//! let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n-//! file.write_line(\"important message\").ok().expect(\"failed to write message\");\n-//! drop(file);\n+//! let mut file = File::create(\"valuable_data.txt\").unwrap();\n+//! file.write_all(b\"important message\").ok().expect(\"failed to write message\");\n //! ```\n //!\n //! You might also simply assert success:\n //!\n //! ```{.no_run}\n-//! # #![feature(old_io, old_path)]\n-//! # use std::old_io::*;\n-//! # use std::old_path::Path;\n-//!\n-//! # let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n-//! assert!(file.write_line(\"important message\").is_ok());\n-//! # drop(file);\n+//! # use std::fs::File;\n+//! # use std::io::prelude::*;\n+//! # let mut file = File::create(\"valuable_data.txt\").unwrap();\n+//! assert!(file.write_all(b\"important message\").is_ok());\n //! ```\n //!\n //! Or propagate the error up the call stack with `try!`:\n //!\n //! ```\n-//! # #![feature(old_io, old_path)]\n-//! # use std::old_io::*;\n-//! # use std::old_path::Path;\n-//! fn write_message() -> Result<(), IoError> {\n-//!     let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n-//!     try!(file.write_line(\"important message\"));\n-//!     drop(file);\n+//! # use std::fs::File;\n+//! # use std::io::prelude::*;\n+//! # use std::io;\n+//! fn write_message() -> io::Result<()> {\n+//!     let mut file = try!(File::create(\"valuable_data.txt\"));\n+//!     try!(file.write_all(b\"important message\"));\n //!     Ok(())\n //! }\n //! ```\n@@ -170,48 +161,51 @@\n //! It replaces this:\n //!\n //! ```\n-//! # #![feature(old_io, old_path)]\n-//! use std::old_io::*;\n-//! use std::old_path::Path;\n+//! use std::fs::File;\n+//! use std::io::prelude::*;\n+//! use std::io;\n //!\n //! struct Info {\n //!     name: String,\n //!     age: i32,\n //!     rating: i32,\n //! }\n //!\n-//! fn write_info(info: &Info) -> Result<(), IoError> {\n-//!     let mut file = File::open_mode(&Path::new(\"my_best_friends.txt\"), Open, Write);\n+//! fn write_info(info: &Info) -> io::Result<()> {\n+//!     let mut file = try!(File::create(\"my_best_friends.txt\"));\n //!     // Early return on error\n-//!     if let Err(e) = file.write_line(&format!(\"name: {}\", info.name)) {\n+//!     if let Err(e) = file.write_all(format!(\"name: {}\\n\", info.name).as_bytes()) {\n+//!         return Err(e)\n+//!     }\n+//!     if let Err(e) = file.write_all(format!(\"age: {}\\n\", info.age).as_bytes()) {\n //!         return Err(e)\n //!     }\n-//!     if let Err(e) = file.write_line(&format!(\"age: {}\", info.age)) {\n+//!     if let Err(e) = file.write_all(format!(\"rating: {}\\n\", info.rating).as_bytes()) {\n //!         return Err(e)\n //!     }\n-//!     file.write_line(&format!(\"rating: {}\", info.rating))\n+//!     Ok(())\n //! }\n //! ```\n //!\n //! With this:\n //!\n //! ```\n-//! # #![feature(old_io, old_path)]\n-//! use std::old_io::*;\n-//! use std::old_path::Path;\n+//! use std::fs::File;\n+//! use std::io::prelude::*;\n+//! use std::io;\n //!\n //! struct Info {\n //!     name: String,\n //!     age: i32,\n //!     rating: i32,\n //! }\n //!\n-//! fn write_info(info: &Info) -> Result<(), IoError> {\n-//!     let mut file = File::open_mode(&Path::new(\"my_best_friends.txt\"), Open, Write);\n+//! fn write_info(info: &Info) -> io::Result<()> {\n+//!     let mut file = try!(File::create(\"my_best_friends.txt\"));\n //!     // Early return on error\n-//!     try!(file.write_line(&format!(\"name: {}\", info.name)));\n-//!     try!(file.write_line(&format!(\"age: {}\", info.age)));\n-//!     try!(file.write_line(&format!(\"rating: {}\", info.rating)));\n+//!     try!(file.write_all(format!(\"name: {}\\n\", info.name).as_bytes()));\n+//!     try!(file.write_all(format!(\"age: {}\\n\", info.age).as_bytes()));\n+//!     try!(file.write_all(format!(\"rating: {}\\n\", info.rating).as_bytes()));\n //!     Ok(())\n //! }\n //! ```\n@@ -464,29 +458,17 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n-    /// Sum the lines of a buffer by mapping strings to numbers,\n-    /// ignoring I/O and parse errors:\n+    /// Print the numbers on each line of a string multiplied by two.\n     ///\n     /// ```\n-    /// # #![feature(old_io)]\n-    /// use std::old_io::*;\n+    /// let line = \"1\\n2\\n3\\n4\\n\";\n     ///\n-    /// let mut buffer: &[u8] = b\"1\\n2\\n3\\n4\\n\";\n-    /// let mut buffer = &mut buffer;\n-    ///\n-    /// let mut sum = 0;\n-    ///\n-    /// while !buffer.is_empty() {\n-    ///     let line: IoResult<String> = buffer.read_line();\n-    ///     // Convert the string line to a number using `map` and `from_str`\n-    ///     let val: IoResult<i32> = line.map(|line| {\n-    ///         line.trim_right().parse::<i32>().unwrap_or(0)\n-    ///     });\n-    ///     // Add the value if there were no errors, otherwise add 0\n-    ///     sum += val.unwrap_or(0);\n+    /// for num in line.lines() {\n+    ///     match num.parse::<i32>().map(|i| i * 2) {\n+    ///         Ok(n) => println!(\"{}\", n),\n+    ///         Err(..) => {}\n+    ///     }\n     /// }\n-    ///\n-    /// assert!(sum == 10);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}]}