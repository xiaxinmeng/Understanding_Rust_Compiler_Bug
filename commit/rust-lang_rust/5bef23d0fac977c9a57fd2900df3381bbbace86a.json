{"sha": "5bef23d0fac977c9a57fd2900df3381bbbace86a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViZWYyM2QwZmFjOTc3YzlhNTdmZDI5MDBkZjMzODFiYmJhY2U4NmE=", "commit": {"author": {"name": "Erik Desjardins", "email": "erikdesjardins@users.noreply.github.com", "date": "2021-08-14T17:54:35Z"}, "committer": {"name": "Erik Desjardins", "email": "erikdesjardins@users.noreply.github.com", "date": "2021-08-25T21:49:28Z"}, "message": "add comments", "tree": {"sha": "bc93763ef9c89e29d0010197d770209de7afddde", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc93763ef9c89e29d0010197d770209de7afddde"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5bef23d0fac977c9a57fd2900df3381bbbace86a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5bef23d0fac977c9a57fd2900df3381bbbace86a", "html_url": "https://github.com/rust-lang/rust/commit/5bef23d0fac977c9a57fd2900df3381bbbace86a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5bef23d0fac977c9a57fd2900df3381bbbace86a/comments", "author": {"login": "erikdesjardins", "id": 7673145, "node_id": "MDQ6VXNlcjc2NzMxNDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7673145?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erikdesjardins", "html_url": "https://github.com/erikdesjardins", "followers_url": "https://api.github.com/users/erikdesjardins/followers", "following_url": "https://api.github.com/users/erikdesjardins/following{/other_user}", "gists_url": "https://api.github.com/users/erikdesjardins/gists{/gist_id}", "starred_url": "https://api.github.com/users/erikdesjardins/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erikdesjardins/subscriptions", "organizations_url": "https://api.github.com/users/erikdesjardins/orgs", "repos_url": "https://api.github.com/users/erikdesjardins/repos", "events_url": "https://api.github.com/users/erikdesjardins/events{/privacy}", "received_events_url": "https://api.github.com/users/erikdesjardins/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erikdesjardins", "id": 7673145, "node_id": "MDQ6VXNlcjc2NzMxNDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7673145?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erikdesjardins", "html_url": "https://github.com/erikdesjardins", "followers_url": "https://api.github.com/users/erikdesjardins/followers", "following_url": "https://api.github.com/users/erikdesjardins/following{/other_user}", "gists_url": "https://api.github.com/users/erikdesjardins/gists{/gist_id}", "starred_url": "https://api.github.com/users/erikdesjardins/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erikdesjardins/subscriptions", "organizations_url": "https://api.github.com/users/erikdesjardins/orgs", "repos_url": "https://api.github.com/users/erikdesjardins/repos", "events_url": "https://api.github.com/users/erikdesjardins/events{/privacy}", "received_events_url": "https://api.github.com/users/erikdesjardins/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c2b706da60f3a2d2e5421ac1a7e137a50b18a25", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c2b706da60f3a2d2e5421ac1a7e137a50b18a25", "html_url": "https://github.com/rust-lang/rust/commit/3c2b706da60f3a2d2e5421ac1a7e137a50b18a25"}], "stats": {"total": 138, "additions": 119, "deletions": 19}, "files": [{"sha": "e636d7612b4327891a188d20dcaf1cc569ab8fbd", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 119, "deletions": 19, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/5bef23d0fac977c9a57fd2900df3381bbbace86a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bef23d0fac977c9a57fd2900df3381bbbace86a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=5bef23d0fac977c9a57fd2900df3381bbbace86a", "patch": "@@ -548,6 +548,9 @@ impl InitMaskCompressed {\n /// Transferring the initialization mask to other allocations.\n impl<Tag, Extra> Allocation<Tag, Extra> {\n     /// Creates a run-length encoding of the initialization mask.\n+    ///\n+    /// This is essentially a more space-efficient version of\n+    /// `InitMask::range_as_init_chunks(...).collect::<Vec<_>>()`.\n     pub fn compress_uninit_range(&self, range: AllocRange) -> InitMaskCompressed {\n         // Since we are copying `size` bytes from `src` to `dest + i * size` (`for i in 0..repeat`),\n         // a naive initialization mask copying algorithm would repeatedly have to read the initialization mask from\n@@ -723,6 +726,12 @@ impl InitMask {\n \n     /// Returns an iterator, yielding a range of byte indexes for each contiguous region\n     /// of initialized or uninitialized bytes inside the range `start..end` (end-exclusive).\n+    ///\n+    /// The iterator guarantees the following:\n+    /// - Chunks are nonempty.\n+    /// - Chunks are adjacent (each range's start is equal to the previous range's end).\n+    /// - Chunks span exactly `start..end` (the first starts at `start`, the last ends at `end`).\n+    /// - Chunks alternate between [`InitChunk::Init`] and [`InitChunk::Uninit`].\n     #[inline]\n     pub fn range_as_init_chunks(&self, start: Size, end: Size) -> InitChunkIter<'_> {\n         InitChunkIter::new(self, start, end)\n@@ -839,7 +848,7 @@ impl InitChunk {\n /// Yields [`InitChunk`]s. See [`InitMask::range_as_init_chunks`].\n pub struct InitChunkIter<'a> {\n     init_mask: &'a InitMask,\n-    /// Whether the last chunk was initialized.\n+    /// Whether the next chunk we will return is initialized.\n     is_init: bool,\n     /// The current byte index into `init_mask`.\n     start: Size,\n@@ -884,18 +893,45 @@ impl<'a> Iterator for InitChunkIter<'a> {\n \n /// Returns the index of the first bit in `start..end` (end-exclusive) that is equal to is_init.\n fn find_bit(init_mask: &InitMask, start: Size, end: Size, is_init: bool) -> Option<Size> {\n+    /// A fast implementation of `find_bit`,\n+    /// which skips over an entire block at a time if it's all 0s (resp. 1s),\n+    /// and finds the first 1 (resp. 0) bit inside a block using `trailing_zeros` instead of a loop.\n+    ///\n+    /// Note that all examples below are written with 8 (instead of 64) bit blocks for simplicity,\n+    /// and with the least significant bit (and lowest block) first:\n+    ///\n+    ///          00000000|00000000\n+    ///          ^      ^ ^      ^\n+    ///   index: 0      7 8      15\n+    ///\n+    /// Also, if not stated, assume that `is_init = true`, that is, we are searching for the first 1 bit.\n     fn find_bit_fast(init_mask: &InitMask, start: Size, end: Size, is_init: bool) -> Option<Size> {\n+        /// Search one block, returning the index of the first bit equal to `is_init`.\n         fn search_block(\n             bits: Block,\n             block: usize,\n             start_bit: usize,\n             is_init: bool,\n         ) -> Option<Size> {\n-            // invert bits so we're always looking for the first set bit\n+            // For the following examples, assume this function was called with:\n+            //   bits = 11011100\n+            //   start_bit = 3\n+            //   is_init = false\n+            // Note again that the least significant bit is written first,\n+            // which is backwards compared to how we normally write numbers.\n+\n+            // Invert bits so we're always looking for the first set bit.\n+            //        ! 11011100\n+            //   bits = 00100011\n             let bits = if is_init { bits } else { !bits };\n-            // mask off unused start bits\n+            // Mask off unused start bits.\n+            //          00100011\n+            //        & 00011111\n+            //   bits = 00000011\n             let bits = bits & (!0 << start_bit);\n-            // find set bit, if any\n+            // Find set bit, if any.\n+            //   bit = trailing_zeros(00000011)\n+            //   bit = 6\n             if bits == 0 {\n                 None\n             } else {\n@@ -908,39 +944,103 @@ fn find_bit(init_mask: &InitMask, start: Size, end: Size, is_init: bool) -> Opti\n             return None;\n         }\n \n+        // Convert `start` and `end` to block indexes and bit indexes within each block.\n+        // We must convert `end` to an inclusive bound to handle block boundaries correctly.\n+        //\n+        // For example:\n+        //\n+        //   (a) 00000000|00000000    (b) 00000000|\n+        //       ^~~~~~~~~~~^             ^~~~~~~~~^\n+        //     start       end          start     end\n+        //\n+        // In both cases, the block index of `end` is 1.\n+        // But we do want to search block 1 in (a), and we don't in (b).\n+        //\n+        // If we subtract 1 from both end positions to make them inclusive:\n+        //\n+        //   (a) 00000000|00000000    (b) 00000000|\n+        //       ^~~~~~~~~~^              ^~~~~~~^\n+        //     start    end_inclusive   start end_inclusive\n+        //\n+        // For (a), the block index of `end_inclusive` is 1, and for (b), it's 0.\n+        // This provides the desired behavior of searching blocks 0 and 1 for (a),\n+        // and searching only block 0 for (b).\n         let (start_block, start_bit) = bit_index(start);\n-        let (end_block, end_bit) = bit_index(end);\n-\n-        // handle first block: need to skip `start_bit` bits\n+        let end_inclusive = Size::from_bytes(end.bytes() - 1);\n+        let (end_block_inclusive, _) = bit_index(end_inclusive);\n+\n+        // Handle first block: need to skip `start_bit` bits.\n+        //\n+        // We need to handle the first block separately,\n+        // because there may be bits earlier in the block that should be ignored,\n+        // such as the bit marked (1) in this example:\n+        //\n+        //       (1)\n+        //       -|------\n+        //   (c) 01000000|00000000|00000001\n+        //          ^~~~~~~~~~~~~~~~~~^\n+        //        start              end\n         if let Some(i) =\n             search_block(init_mask.blocks[start_block], start_block, start_bit, is_init)\n         {\n             if i < end {\n                 return Some(i);\n             } else {\n-                // if the range is less than a block, we may find a matching bit after `end`\n+                // If the range is less than a block, we may find a matching bit after `end`.\n+                //\n+                // For example, we shouldn't successfully find bit (2), because it's after `end`:\n+                //\n+                //             (2)\n+                //       -------|\n+                //   (d) 00000001|00000000|00000001\n+                //        ^~~~~^\n+                //      start end\n+                //\n+                // An alternative would be to mask off end bits in the same way as we do for start bits,\n+                // but performing this check afterwards is faster and simpler to implement.\n                 return None;\n             }\n         }\n \n-        let one_block_past_the_end = if end_bit > 0 {\n-            // if `end_bit` > 0, then the range overlaps `end_block`\n-            end_block + 1\n-        } else {\n-            end_block\n-        };\n-\n-        // handle remaining blocks\n-        if start_block < one_block_past_the_end {\n-            for (&bits, block) in init_mask.blocks[start_block + 1..one_block_past_the_end]\n+        // Handle remaining blocks.\n+        //\n+        // We can skip over an entire block at once if it's all 0s (resp. 1s).\n+        // The block marked (3) in this example is the first block that will be handled by this loop,\n+        // and it will be skipped for that reason:\n+        //\n+        //                   (3)\n+        //                --------\n+        //   (e) 01000000|00000000|00000001\n+        //          ^~~~~~~~~~~~~~~~~~^\n+        //        start              end\n+        if start_block < end_block_inclusive {\n+            // This loop is written in a specific way for performance.\n+            // Notably: `..end_block_inclusive + 1` is used for an inclusive range instead of `..=end_block_inclusive`,\n+            // and `.zip(start_block + 1..)` is used to track the index instead of `.enumerate().skip().take()`,\n+            // because both alternatives result in significantly worse codegen.\n+            // `end_block_inclusive + 1` is guaranteed not to wrap, because `end_block_inclusive <= end / BLOCK_SIZE`,\n+            // and `BLOCK_SIZE` (the number of bits per block) will always be at least 8 (1 byte).\n+            for (&bits, block) in init_mask.blocks[start_block + 1..end_block_inclusive + 1]\n                 .iter()\n                 .zip(start_block + 1..)\n             {\n                 if let Some(i) = search_block(bits, block, 0, is_init) {\n                     if i < end {\n                         return Some(i);\n                     } else {\n-                        // if this is the last block, we may find a matching bit after `end`\n+                        // If this is the last block, we may find a matching bit after `end`.\n+                        //\n+                        // For example, we shouldn't successfully find bit (4), because it's after `end`:\n+                        //\n+                        //                               (4)\n+                        //                         -------|\n+                        //   (f) 00000001|00000000|00000001\n+                        //          ^~~~~~~~~~~~~~~~~~^\n+                        //        start              end\n+                        //\n+                        // As above with example (d), we could handle the end block separately and mask off end bits,\n+                        // but unconditionally searching an entire block at once and performing this check afterwards\n+                        // is faster and much simpler to implement.\n                         return None;\n                     }\n                 }"}]}