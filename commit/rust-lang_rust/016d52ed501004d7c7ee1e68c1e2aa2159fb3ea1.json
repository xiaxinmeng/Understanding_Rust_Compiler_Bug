{"sha": "016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxNmQ1MmVkNTAxMDA0ZDdjN2VlMWU2OGMxZTJhYTIxNTlmYjNlYTE=", "commit": {"author": {"name": "Luis de Bethencourt", "email": "luis@debethencourt.com", "date": "2013-12-28T20:24:15Z"}, "committer": {"name": "Luis de Bethencourt", "email": "luis@debethencourt.com", "date": "2013-12-29T20:25:37Z"}, "message": "Rename uses of PkgId to CrateId in librustpkg", "tree": {"sha": "01c9808b01b4ca58a8caf71caceaa7744b656a6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01c9808b01b4ca58a8caf71caceaa7744b656a6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1", "html_url": "https://github.com/rust-lang/rust/commit/016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1/comments", "author": {"login": "luisbg", "id": 303663, "node_id": "MDQ6VXNlcjMwMzY2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/303663?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luisbg", "html_url": "https://github.com/luisbg", "followers_url": "https://api.github.com/users/luisbg/followers", "following_url": "https://api.github.com/users/luisbg/following{/other_user}", "gists_url": "https://api.github.com/users/luisbg/gists{/gist_id}", "starred_url": "https://api.github.com/users/luisbg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luisbg/subscriptions", "organizations_url": "https://api.github.com/users/luisbg/orgs", "repos_url": "https://api.github.com/users/luisbg/repos", "events_url": "https://api.github.com/users/luisbg/events{/privacy}", "received_events_url": "https://api.github.com/users/luisbg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luisbg", "id": 303663, "node_id": "MDQ6VXNlcjMwMzY2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/303663?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luisbg", "html_url": "https://github.com/luisbg", "followers_url": "https://api.github.com/users/luisbg/followers", "following_url": "https://api.github.com/users/luisbg/following{/other_user}", "gists_url": "https://api.github.com/users/luisbg/gists{/gist_id}", "starred_url": "https://api.github.com/users/luisbg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luisbg/subscriptions", "organizations_url": "https://api.github.com/users/luisbg/orgs", "repos_url": "https://api.github.com/users/luisbg/repos", "events_url": "https://api.github.com/users/luisbg/events{/privacy}", "received_events_url": "https://api.github.com/users/luisbg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f872c472788ca00a88d56ec5d6b3ff73a8dcc005", "url": "https://api.github.com/repos/rust-lang/rust/commits/f872c472788ca00a88d56ec5d6b3ff73a8dcc005", "html_url": "https://github.com/rust-lang/rust/commit/f872c472788ca00a88d56ec5d6b3ff73a8dcc005"}], "stats": {"total": 600, "additions": 301, "deletions": 299}, "files": [{"sha": "e87187abbcbf4d25c524432444cb04b8341bc03d", "filename": "src/etc/combine-tests.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1/src%2Fetc%2Fcombine-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1/src%2Fetc%2Fcombine-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcombine-tests.py?ref=016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1", "patch": "@@ -45,7 +45,7 @@ def scrub(b):\n \"\"\"\n // AUTO-GENERATED FILE: DO NOT EDIT\n #[crate_id=\\\"run_pass_stage2#0.1\\\"];\n-#[pkgid=\\\"run_pass_stage2#0.1\\\"];\n+#[crate_id=\\\"run_pass_stage2#0.1\\\"];\n #[feature(globs, macro_rules, struct_variant, managed_boxes)];\n #[allow(warnings)];\n \"\"\""}, {"sha": "0730a6fc3a210d35ce2ab7ac2b0ac3ade4798e92", "filename": "src/librustpkg/api.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1", "patch": "@@ -10,7 +10,7 @@\n \n use context::*;\n use crate::*;\n-use package_id::*;\n+use crate_id::*;\n use package_source::*;\n use path_util::{platform_library_name, target_build_dir};\n use target::*;\n@@ -92,7 +92,7 @@ pub fn build_lib_with_cfgs(sysroot: Path, root: Path, name: ~str,\n         build_in_destination: false,\n         destination_workspace: root.clone(),\n         start_dir: root.join_many([\"src\", name.as_slice()]),\n-        id: PkgId{ version: version, ..PkgId::new(name)},\n+        id: CrateId{ version: version, ..CrateId::new(name)},\n         // n.b. This assumes the package only has one crate\n         libs: ~[mk_crate(lib)],\n         mains: ~[],\n@@ -115,7 +115,7 @@ pub fn build_exe_with_cfgs(sysroot: Path, root: Path, name: ~str,\n         build_in_destination: false,\n         destination_workspace: root.clone(),\n         start_dir: root.join_many([\"src\", name.as_slice()]),\n-        id: PkgId{ version: version, ..PkgId::new(name)},\n+        id: CrateId{ version: version, ..CrateId::new(name)},\n         libs: ~[],\n         // n.b. This assumes the package only has one crate\n         mains: ~[mk_crate(main)],\n@@ -132,8 +132,8 @@ pub fn install_pkg(cx: &BuildContext,\n                    version: Version,\n                    // For now, these inputs are assumed to be inputs to each of the crates\n                    more_inputs: ~[(~str, Path)]) { // pairs of Kind and Path\n-    let pkgid = PkgId{ version: version, ..PkgId::new(name)};\n-    cx.install(PkgSrc::new(workspace.clone(), workspace, false, pkgid),\n+    let crateid = CrateId{ version: version, ..CrateId::new(name)};\n+    cx.install(PkgSrc::new(workspace.clone(), workspace, false, crateid),\n                &WhatToBuild{ build_type: Inferred,\n                              inputs_to_discover: more_inputs,\n                              sources: Everything });\n@@ -157,10 +157,10 @@ pub fn build_library_in_workspace(exec: &mut workcache::Exec,\n     let out_name = workspace_build_dir.join_many([package_name.to_str(),\n                                                   platform_library_name(output)]);\n     // make paths absolute\n-    let pkgid = PkgId::new(package_name);\n+    let crateid = CrateId::new(package_name);\n     let absolute_paths = paths.map(|s| {\n             let whatever = workspace.join_many([~\"src\",\n-                                pkgid.to_str(),\n+                                crateid.to_str(),\n                                 s.to_owned()]);\n             whatever.as_str().unwrap().to_owned()\n         });\n@@ -190,8 +190,8 @@ pub fn my_workspace(context: &Context, package_name: &str) -> Path {\n     use bad_pkg_id     = conditions::bad_pkg_id::cond;\n \n     // (this assumes no particular version is requested)\n-    let pkgid = PkgId::new(package_name);\n-    let workspaces = pkg_parent_workspaces(context, &pkgid);\n+    let crateid = CrateId::new(package_name);\n+    let workspaces = pkg_parent_workspaces(context, &crateid);\n     if workspaces.is_empty() {\n         bad_pkg_id.raise((Path::new(package_name), package_name.to_owned()));\n     }"}, {"sha": "6c38d63a518019a90990c8b1265e154e5be80ceb", "filename": "src/librustpkg/conditions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1/src%2Flibrustpkg%2Fconditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1/src%2Flibrustpkg%2Fconditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fconditions.rs?ref=016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1", "patch": "@@ -10,7 +10,7 @@\n \n // Useful conditions\n \n-pub use package_id::PkgId;\n+pub use crate_id::CrateId;\n pub use std::io::FileStat;\n pub use std::io::process::ProcessExit;\n pub use std::path::Path;\n@@ -20,15 +20,15 @@ condition! {\n }\n \n condition! {\n-    pub nonexistent_package: (PkgId, ~str) -> Path;\n+    pub nonexistent_package: (CrateId, ~str) -> Path;\n }\n \n condition! {\n-    pub missing_pkg_files: (PkgId) -> ();\n+    pub missing_pkg_files: (CrateId) -> ();\n }\n \n condition! {\n-    pub bad_pkg_id: (Path, ~str) -> PkgId;\n+    pub bad_pkg_id: (Path, ~str) -> CrateId;\n }\n \n condition! {"}, {"sha": "7ff8417f23c7861a28c783a42a4089ece984bc2a", "filename": "src/librustpkg/crate_id.rs", "status": "renamed", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1/src%2Flibrustpkg%2Fcrate_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1/src%2Flibrustpkg%2Fcrate_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcrate_id.rs?ref=016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1", "patch": "@@ -17,7 +17,7 @@ use std::hash;\n /// 'github.com/graydon/test'; path must be a relative\n /// path with >=1 component.\n #[deriving(Clone)]\n-pub struct PkgId {\n+pub struct CrateId {\n     /// This is a path, on the local filesystem, referring to where the\n     /// files for this package live. For example:\n     /// github.com/mozilla/quux-whatever (it's assumed that if we're\n@@ -35,14 +35,14 @@ pub struct PkgId {\n     version: Version\n }\n \n-impl Eq for PkgId {\n-    fn eq(&self, other: &PkgId) -> bool {\n+impl Eq for CrateId {\n+    fn eq(&self, other: &CrateId) -> bool {\n         self.path == other.path && self.version == other.version\n     }\n }\n \n-impl PkgId {\n-    pub fn new(s: &str) -> PkgId {\n+impl CrateId {\n+    pub fn new(s: &str) -> CrateId {\n         use conditions::bad_pkg_id::cond;\n \n         let mut given_version = None;\n@@ -60,10 +60,10 @@ impl PkgId {\n \n         let path = Path::new(s);\n         if !path.is_relative() {\n-            return cond.raise((path, ~\"absolute pkgid\"));\n+            return cond.raise((path, ~\"absolute crate_id\"));\n         }\n         if path.filename().is_none() {\n-            return cond.raise((path, ~\"0-length pkgid\"));\n+            return cond.raise((path, ~\"0-length crate_id\"));\n         }\n         let short_name = path.filestem_str().expect(format!(\"Strange path! {}\", s));\n \n@@ -78,7 +78,7 @@ impl PkgId {\n             }\n         };\n \n-        PkgId {\n+        CrateId {\n             path: path.clone(),\n             short_name: short_name.to_owned(),\n             version: version\n@@ -142,7 +142,7 @@ impl Iterator<(Path, Path)> for Prefixes {\n     }\n }\n \n-impl ToStr for PkgId {\n+impl ToStr for CrateId {\n     fn to_str(&self) -> ~str {\n         // should probably use the filestem and not the whole path\n         format!(\"{}-{}\", self.path.as_str().unwrap(), self.version.to_str())", "previous_filename": "src/librustpkg/package_id.rs"}, {"sha": "67ba5d2b8e83f822ed2cdd7c0dc59db3179875ad", "filename": "src/librustpkg/installed_packages.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1/src%2Flibrustpkg%2Finstalled_packages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1/src%2Flibrustpkg%2Finstalled_packages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Finstalled_packages.rs?ref=016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1", "patch": "@@ -16,7 +16,7 @@ use std::os;\n use std::io;\n use std::io::fs;\n \n-pub fn list_installed_packages(f: |&PkgId| -> bool) -> bool  {\n+pub fn list_installed_packages(f: |&CrateId| -> bool) -> bool  {\n     let workspaces = rust_path();\n     for p in workspaces.iter() {\n         let binfiles = {\n@@ -28,7 +28,7 @@ pub fn list_installed_packages(f: |&PkgId| -> bool) -> bool  {\n             match exec.filestem_str() {\n                 None => (),\n                 Some(exec_path) => {\n-                    if !f(&PkgId::new(exec_path)) {\n+                    if !f(&CrateId::new(exec_path)) {\n                         return false;\n                     }\n                 }\n@@ -50,7 +50,7 @@ pub fn list_installed_packages(f: |&PkgId| -> bool) -> bool  {\n                     let rel_path = rel_p.join(basename);\n                     rel_path.display().with_str(|s| {\n                         debug!(\"Rel name: {}\", s);\n-                        f(&PkgId::new(s));\n+                        f(&CrateId::new(s));\n                     });\n                 }\n                 None => ()\n@@ -78,7 +78,7 @@ pub fn has_library(p: &Path) -> Option<~str> {\n     None\n }\n \n-pub fn package_is_installed(p: &PkgId) -> bool {\n+pub fn package_is_installed(p: &CrateId) -> bool {\n     let mut is_installed = false;\n     list_installed_packages(|installed| {\n         if installed == p {"}, {"sha": "2b54a6d6f1c150da6187a108bbdf6dae882f835a", "filename": "src/librustpkg/lib.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1/src%2Flibrustpkg%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1/src%2Flibrustpkg%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Flib.rs?ref=016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1", "patch": "@@ -45,7 +45,7 @@ use workspace::determine_destination;\n use context::{Context, BuildContext,\n                        RustcFlags, Trans, Link, Nothing, Pretty, Analysis, Assemble,\n                        LLVMAssemble, LLVMCompileBitcode};\n-use package_id::PkgId;\n+use crate_id::CrateId;\n use package_source::PkgSrc;\n use target::{WhatToBuild, Everything, is_lib, is_main, is_test, is_bench};\n use target::{Main, Tests, MaybeCustom, Inferred, JustOne};\n@@ -59,7 +59,7 @@ mod crate;\n pub mod exit_codes;\n mod installed_packages;\n mod messages;\n-pub mod package_id;\n+pub mod crate_id;\n pub mod package_source;\n mod path_util;\n mod source_control;\n@@ -78,7 +78,7 @@ pub mod usage;\n /// an explicit package script.\n struct PkgScript<'a> {\n     /// Uniquely identifies this package\n-    id: &'a PkgId,\n+    id: &'a CrateId,\n     /// File path for the package script\n     input: Path,\n     /// The session to use *only* for compiling the custom\n@@ -99,7 +99,7 @@ impl<'a> PkgScript<'a> {\n     fn parse<'a>(sysroot: Path,\n                  script: Path,\n                  workspace: &Path,\n-                 id: &'a PkgId) -> PkgScript<'a> {\n+                 id: &'a CrateId) -> PkgScript<'a> {\n         // Get the executable name that was invoked\n         let binary = os::args()[0].to_managed();\n         // Build the rustc session data structures to pass\n@@ -208,10 +208,10 @@ pub trait CtxMethods {\n     fn run(&self, cmd: &str, args: ~[~str]);\n     fn do_cmd(&self, _cmd: &str, _pkgname: &str);\n     /// Returns a pair of the selected package ID, and the destination workspace\n-    fn build_args(&self, args: ~[~str], what: &WhatToBuild) -> Option<(PkgId, Path)>;\n+    fn build_args(&self, args: ~[~str], what: &WhatToBuild) -> Option<(CrateId, Path)>;\n     /// Returns the destination workspace\n     fn build(&self, pkg_src: &mut PkgSrc, what: &WhatToBuild);\n-    fn clean(&self, workspace: &Path, id: &PkgId);\n+    fn clean(&self, workspace: &Path, id: &CrateId);\n     fn info(&self);\n     /// Returns a pair. First component is a list of installed paths,\n     /// second is a list of declared and discovered inputs\n@@ -221,24 +221,24 @@ pub trait CtxMethods {\n                         build_workspace: &Path,\n                         build_inputs: &[Path],\n                         target_workspace: &Path,\n-                        id: &PkgId) -> ~[~str];\n+                        id: &CrateId) -> ~[~str];\n     fn prefer(&self, _id: &str, _vers: Option<~str>);\n-    fn test(&self, id: &PkgId, workspace: &Path);\n+    fn test(&self, id: &CrateId, workspace: &Path);\n     fn uninstall(&self, _id: &str, _vers: Option<~str>);\n     fn unprefer(&self, _id: &str, _vers: Option<~str>);\n     fn init(&self);\n }\n \n impl CtxMethods for BuildContext {\n-    fn build_args(&self, args: ~[~str], what: &WhatToBuild) -> Option<(PkgId, Path)> {\n+    fn build_args(&self, args: ~[~str], what: &WhatToBuild) -> Option<(CrateId, Path)> {\n         let cwd = os::getcwd();\n \n         if args.len() < 1 {\n             match cwd_to_workspace() {\n                 None  if dir_has_crate_file(&cwd) => {\n                     // FIXME (#9639): This needs to handle non-utf8 paths\n-                    let pkgid = PkgId::new(cwd.filename_str().unwrap());\n-                    let mut pkg_src = PkgSrc::new(cwd, default_workspace(), true, pkgid);\n+                    let crateid = CrateId::new(cwd.filename_str().unwrap());\n+                    let mut pkg_src = PkgSrc::new(cwd, default_workspace(), true, crateid);\n                     self.build(&mut pkg_src, what);\n                     match pkg_src {\n                         PkgSrc { destination_workspace: ws,\n@@ -248,8 +248,8 @@ impl CtxMethods for BuildContext {\n                     }\n                 }\n                 None => { usage::build(); None }\n-                Some((ws, pkgid)) => {\n-                    let mut pkg_src = PkgSrc::new(ws.clone(), ws, false, pkgid);\n+                Some((ws, crateid)) => {\n+                    let mut pkg_src = PkgSrc::new(ws.clone(), ws, false, crateid);\n                     self.build(&mut pkg_src, what);\n                     match pkg_src {\n                         PkgSrc { destination_workspace: ws,\n@@ -262,23 +262,23 @@ impl CtxMethods for BuildContext {\n         } else {\n             // The package id is presumed to be the first command-line\n             // argument\n-            let pkgid = PkgId::new(args[0].clone());\n+            let crateid = CrateId::new(args[0].clone());\n             let mut dest_ws = default_workspace();\n-            each_pkg_parent_workspace(&self.context, &pkgid, |workspace| {\n+            each_pkg_parent_workspace(&self.context, &crateid, |workspace| {\n                 debug!(\"found pkg {} in workspace {}, trying to build\",\n-                       pkgid.to_str(), workspace.display());\n+                       crateid.to_str(), workspace.display());\n                 dest_ws = determine_destination(os::getcwd(),\n                                                 self.context.use_rust_path_hack,\n                                                 workspace);\n                 let mut pkg_src = PkgSrc::new(workspace.clone(), dest_ws.clone(),\n-                                              false, pkgid.clone());\n+                                              false, crateid.clone());\n                 self.build(&mut pkg_src, what);\n                 true\n             });\n             // n.b. If this builds multiple packages, it only returns the workspace for\n             // the last one. The whole building-multiple-packages-with-the-same-ID is weird\n             // anyway and there are no tests for it, so maybe take it out\n-            Some((pkgid, dest_ws))\n+            Some((crateid, dest_ws))\n         }\n     }\n     fn run(&self, cmd: &str, args: ~[~str]) {\n@@ -293,15 +293,15 @@ impl CtxMethods for BuildContext {\n                         None => { usage::clean(); return }\n                         // tjc: Maybe clean should clean all the packages in the\n                         // current workspace, though?\n-                        Some((ws, pkgid)) => self.clean(&ws, &pkgid)\n+                        Some((ws, crateid)) => self.clean(&ws, &crateid)\n                     }\n \n                 }\n                 else {\n                     // The package id is presumed to be the first command-line\n                     // argument\n-                    let pkgid = PkgId::new(args[0].clone());\n-                    self.clean(&cwd, &pkgid); // tjc: should use workspace, not cwd\n+                    let crateid = CrateId::new(args[0].clone());\n+                    self.clean(&cwd, &crateid); // tjc: should use workspace, not cwd\n                 }\n             }\n             \"do\" => {\n@@ -320,15 +320,15 @@ impl CtxMethods for BuildContext {\n                         None if dir_has_crate_file(&cwd) => {\n                             // FIXME (#9639): This needs to handle non-utf8 paths\n \n-                            let inferred_pkgid =\n-                                PkgId::new(cwd.filename_str().unwrap());\n+                            let inferred_crateid =\n+                                CrateId::new(cwd.filename_str().unwrap());\n                             self.install(PkgSrc::new(cwd, default_workspace(),\n-                                                     true, inferred_pkgid),\n+                                                     true, inferred_crateid),\n                                          &WhatToBuild::new(MaybeCustom, Everything));\n                         }\n                         None  => { usage::install(); return; }\n-                        Some((ws, pkgid))                => {\n-                            let pkg_src = PkgSrc::new(ws.clone(), ws.clone(), false, pkgid);\n+                        Some((ws, crateid))                => {\n+                            let pkg_src = PkgSrc::new(ws.clone(), ws.clone(), false, crateid);\n                             self.install(pkg_src, &WhatToBuild::new(MaybeCustom,\n                                                                     Everything));\n                       }\n@@ -337,13 +337,13 @@ impl CtxMethods for BuildContext {\n                 else {\n                     // The package id is presumed to be the first command-line\n                     // argument\n-                    let pkgid = PkgId::new(args[0]);\n-                    let workspaces = pkg_parent_workspaces(&self.context, &pkgid);\n+                    let crateid = CrateId::new(args[0]);\n+                    let workspaces = pkg_parent_workspaces(&self.context, &crateid);\n                     debug!(\"package ID = {}, found it in {:?} workspaces\",\n-                           pkgid.to_str(), workspaces.len());\n+                           crateid.to_str(), workspaces.len());\n                     if workspaces.is_empty() {\n                         let d = default_workspace();\n-                        let src = PkgSrc::new(d.clone(), d, false, pkgid.clone());\n+                        let src = PkgSrc::new(d.clone(), d, false, crateid.clone());\n                         self.install(src, &WhatToBuild::new(MaybeCustom, Everything));\n                     }\n                     else {\n@@ -354,7 +354,7 @@ impl CtxMethods for BuildContext {\n                             let src = PkgSrc::new(workspace.clone(),\n                                                   dest,\n                                                   self.context.use_rust_path_hack,\n-                                                  pkgid.clone());\n+                                                  crateid.clone());\n                             self.install(src, &WhatToBuild::new(MaybeCustom, Everything));\n                         };\n                     }\n@@ -400,19 +400,19 @@ impl CtxMethods for BuildContext {\n                     return usage::uninstall();\n                 }\n \n-                let pkgid = PkgId::new(args[0]);\n-                if !installed_packages::package_is_installed(&pkgid) {\n+                let crateid = CrateId::new(args[0]);\n+                if !installed_packages::package_is_installed(&crateid) {\n                     warn(format!(\"Package {} doesn't seem to be installed! \\\n                                   Doing nothing.\", args[0]));\n                     return;\n                 }\n                 else {\n                     let rp = rust_path();\n                     assert!(!rp.is_empty());\n-                    each_pkg_parent_workspace(&self.context, &pkgid, |workspace| {\n-                        path_util::uninstall_package_from(workspace, &pkgid);\n+                    each_pkg_parent_workspace(&self.context, &crateid, |workspace| {\n+                        path_util::uninstall_package_from(workspace, &crateid);\n                         note(format!(\"Uninstalled package {} (was installed in {})\",\n-                                  pkgid.to_str(), workspace.display()));\n+                                  crateid.to_str(), workspace.display()));\n                         true\n                     });\n                 }\n@@ -437,34 +437,34 @@ impl CtxMethods for BuildContext {\n         use conditions::git_checkout_failed::cond;\n \n         let workspace = pkg_src.source_workspace.clone();\n-        let pkgid = pkg_src.id.clone();\n+        let crateid = pkg_src.id.clone();\n \n         debug!(\"build: workspace = {} (in Rust path? {:?} is git dir? {:?} \\\n-                pkgid = {} pkgsrc start_dir = {}\", workspace.display(),\n-               in_rust_path(&workspace), is_git_dir(&workspace.join(&pkgid.path)),\n-               pkgid.to_str(), pkg_src.start_dir.display());\n+                crateid = {} pkgsrc start_dir = {}\", workspace.display(),\n+               in_rust_path(&workspace), is_git_dir(&workspace.join(&crateid.path)),\n+               crateid.to_str(), pkg_src.start_dir.display());\n         debug!(\"build: what to build = {:?}\", what_to_build);\n \n         // If workspace isn't in the RUST_PATH, and it's a git repo,\n         // then clone it into the first entry in RUST_PATH, and repeat\n-        if !in_rust_path(&workspace) && is_git_dir(&workspace.join(&pkgid.path)) {\n+        if !in_rust_path(&workspace) && is_git_dir(&workspace.join(&crateid.path)) {\n             let mut out_dir = default_workspace().join(\"src\");\n-            out_dir.push(&pkgid.path);\n-            let git_result = source_control::safe_git_clone(&workspace.join(&pkgid.path),\n-                                                            &pkgid.version,\n+            out_dir.push(&crateid.path);\n+            let git_result = source_control::safe_git_clone(&workspace.join(&crateid.path),\n+                                                            &crateid.version,\n                                                             &out_dir);\n             match git_result {\n                 CheckedOutSources => make_read_only(&out_dir),\n                 // FIXME (#9639): This needs to handle non-utf8 paths\n-                _ => cond.raise((pkgid.path.as_str().unwrap().to_owned(), out_dir.clone()))\n+                _ => cond.raise((crateid.path.as_str().unwrap().to_owned(), out_dir.clone()))\n             };\n             let default_ws = default_workspace();\n             debug!(\"Calling build recursively with {:?} and {:?}\", default_ws.display(),\n-                   pkgid.to_str());\n+                   crateid.to_str());\n             return self.build(&mut PkgSrc::new(default_ws.clone(),\n                                                default_ws,\n                                                false,\n-                                               pkgid.clone()), what_to_build);\n+                                               crateid.clone()), what_to_build);\n         }\n \n         // Is there custom build logic? If so, use it\n@@ -482,7 +482,7 @@ impl CtxMethods for BuildContext {\n                     let subsysroot = sysroot.clone();\n                     let psp = package_script_path.clone();\n                     let ws = workspace.clone();\n-                    let pid = pkgid.clone();\n+                    let pid = crateid.clone();\n                     prep.exec(proc(exec) {\n                         let mut pscript = PkgScript::parse(subsysroot.clone(),\n                                                            psp.clone(),\n@@ -550,7 +550,7 @@ impl CtxMethods for BuildContext {\n         }\n     }\n \n-    fn clean(&self, workspace: &Path, id: &PkgId)  {\n+    fn clean(&self, workspace: &Path, id: &CrateId)  {\n         // Could also support a custom build hook in the pkg\n         // script for cleaning files rustpkg doesn't know about.\n         // Do something reasonable for now\n@@ -616,7 +616,7 @@ impl CtxMethods for BuildContext {\n                         build_workspace: &Path,\n                         build_inputs: &[Path],\n                         target_workspace: &Path,\n-                        id: &PkgId) -> ~[~str] {\n+                        id: &CrateId) -> ~[~str] {\n \n         debug!(\"install_no_build: assuming {} comes from {} with target {}\",\n                id.to_str(), build_workspace.display(), target_workspace.display());\n@@ -705,8 +705,8 @@ impl CtxMethods for BuildContext {\n         fail!(\"prefer not yet implemented\");\n     }\n \n-    fn test(&self, pkgid: &PkgId, workspace: &Path)  {\n-        match built_test_in_workspace(pkgid, workspace) {\n+    fn test(&self, crateid: &CrateId, workspace: &Path)  {\n+        match built_test_in_workspace(crateid, workspace) {\n             Some(test_exec) => {\n                 debug!(\"test: test_exec = {}\", test_exec.display());\n                 // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -723,7 +723,7 @@ impl CtxMethods for BuildContext {\n             None => {\n                 error(format!(\"Internal error: test executable for package ID {} in workspace {} \\\n                            wasn't built! Please report this as a bug.\",\n-                           pkgid.to_str(), workspace.display()));\n+                           crateid.to_str(), workspace.display()));\n             }\n         }\n     }"}, {"sha": "651d64aa9d32f50bd214912c4ad6c116077133be", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1", "patch": "@@ -11,7 +11,7 @@\n extern mod extra;\n \n use target::*;\n-use package_id::PkgId;\n+use crate_id::CrateId;\n use std::io;\n use std::io::fs;\n use std::os;\n@@ -49,7 +49,7 @@ pub struct PkgSrc {\n     // Directory to start looking in for packages -- normally\n     // this is workspace/src/id but it may be just workspace\n     start_dir: Path,\n-    id: PkgId,\n+    id: CrateId,\n     libs: ~[Crate],\n     mains: ~[Crate],\n     tests: ~[Crate],\n@@ -77,7 +77,7 @@ impl PkgSrc {\n     pub fn new(mut source_workspace: Path,\n                destination_workspace: Path,\n                use_rust_path_hack: bool,\n-               id: PkgId) -> PkgSrc {\n+               id: CrateId) -> PkgSrc {\n         use conditions::nonexistent_package::cond;\n \n         debug!(\"Checking package source for package ID {}, \\\n@@ -133,14 +133,14 @@ impl PkgSrc {\n                 // See if any of the prefixes of this package ID form a valid package ID\n                 // That is, is this a package ID that points into the middle of a workspace?\n                 for (prefix, suffix) in id.prefixes() {\n-                    let package_id = PkgId::new(prefix.as_str().unwrap());\n-                    let path = build_dir.join(&package_id.path);\n+                    let crate_id = CrateId::new(prefix.as_str().unwrap());\n+                    let path = build_dir.join(&crate_id.path);\n                     debug!(\"in loop: checking if {} is a directory\", path.display());\n                     if path.is_dir() {\n                         let ps = PkgSrc::new(source_workspace,\n                                              destination_workspace,\n                                              use_rust_path_hack,\n-                                             package_id);\n+                                             crate_id);\n                         match ps {\n                             PkgSrc {\n                                 source_workspace: source,\n@@ -264,36 +264,36 @@ impl PkgSrc {\n     /// if this was successful, None otherwise. Similarly, if the package id\n     /// refers to a git repo on the local version, also check it out.\n     /// (right now we only support git)\n-    pub fn fetch_git(local: &Path, pkgid: &PkgId) -> Option<Path> {\n+    pub fn fetch_git(local: &Path, crateid: &CrateId) -> Option<Path> {\n         use conditions::git_checkout_failed::cond;\n \n         let cwd = os::getcwd();\n         debug!(\"Checking whether {} (path = {}) exists locally. Cwd = {}, does it? {:?}\",\n-                pkgid.to_str(), pkgid.path.display(),\n+                crateid.to_str(), crateid.path.display(),\n                 cwd.display(),\n-                pkgid.path.exists());\n+                crateid.path.exists());\n \n-        match safe_git_clone(&pkgid.path, &pkgid.version, local) {\n+        match safe_git_clone(&crateid.path, &crateid.version, local) {\n             CheckedOutSources => {\n                 make_read_only(local);\n                 Some(local.clone())\n             }\n             DirToUse(clone_target) => {\n-                if pkgid.path.components().nth(1).is_none() {\n+                if crateid.path.components().nth(1).is_none() {\n                     // If a non-URL, don't bother trying to fetch\n                     return None;\n                 }\n \n                 // FIXME (#9639): This needs to handle non-utf8 paths\n-                let url = format!(\"https://{}\", pkgid.path.as_str().unwrap());\n+                let url = format!(\"https://{}\", crateid.path.as_str().unwrap());\n                 debug!(\"Fetching package: git clone {} {} [version={}]\",\n-                        url, clone_target.display(), pkgid.version.to_str());\n+                        url, clone_target.display(), crateid.version.to_str());\n \n                 let mut failed = false;\n \n                 cond.trap(|_| {\n                     failed = true;\n-                }).inside(|| git_clone_url(url, &clone_target, &pkgid.version));\n+                }).inside(|| git_clone_url(url, &clone_target, &crateid.version));\n \n                 if failed {\n                     return None;"}, {"sha": "1b8a988ab2c5a570fa493aa400a15ccf4548e0fe", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 54, "deletions": 53, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1", "patch": "@@ -12,7 +12,7 @@\n \n #[allow(dead_code)];\n \n-pub use package_id::PkgId;\n+pub use crate_id::CrateId;\n pub use target::{OutputType, Main, Lib, Test, Bench, Target, Build, Install};\n pub use version::{Version, NoVersion, split_version_general, try_parsing_version};\n pub use rustc::metadata::filesearch::rust_path;\n@@ -59,12 +59,12 @@ pub fn make_dir_rwx_recursive(p: &Path) -> bool {\n // now. Should fix that.\n \n /// True if there's a directory in <workspace> with\n-/// pkgid's short name\n-pub fn workspace_contains_package_id(pkgid: &PkgId, workspace: &Path) -> bool {\n-    workspace_contains_package_id_(pkgid, workspace, |p| p.join(\"src\")).is_some()\n+/// crateid's short name\n+pub fn workspace_contains_crate_id(crateid: &CrateId, workspace: &Path) -> bool {\n+    workspace_contains_crate_id_(crateid, workspace, |p| p.join(\"src\")).is_some()\n }\n \n-pub fn workspace_contains_package_id_(pkgid: &PkgId, workspace: &Path,\n+pub fn workspace_contains_crate_id_(crateid: &CrateId, workspace: &Path,\n // Returns the directory it was actually found in\n              workspace_to_src_dir: |&Path| -> Path) -> Option<Path> {\n     if !workspace.is_dir() {\n@@ -77,14 +77,14 @@ pub fn workspace_contains_package_id_(pkgid: &PkgId, workspace: &Path,\n     let mut found = None;\n     for p in fs::walk_dir(&src_dir) {\n         if p.is_dir() {\n-            if p == src_dir.join(&pkgid.path) || {\n+            if p == src_dir.join(&crateid.path) || {\n                 let pf = p.filename_str();\n                 pf.iter().any(|&g| {\n                     match split_version_general(g, '-') {\n                         None => false,\n                         Some((ref might_match, ref vers)) => {\n-                            *might_match == pkgid.short_name\n-                                && (pkgid.version == *vers || pkgid.version == NoVersion)\n+                            *might_match == crateid.short_name\n+                                && (crateid.version == *vers || crateid.version == NoVersion)\n                         }\n                     }\n                 })\n@@ -96,9 +96,9 @@ pub fn workspace_contains_package_id_(pkgid: &PkgId, workspace: &Path,\n     }\n \n     if found.is_some() {\n-        debug!(\"Found {} in {}\", pkgid.to_str(), workspace.display());\n+        debug!(\"Found {} in {}\", crateid.to_str(), workspace.display());\n     } else {\n-        debug!(\"Didn't find {} in {}\", pkgid.to_str(), workspace.display());\n+        debug!(\"Didn't find {} in {}\", crateid.to_str(), workspace.display());\n     }\n     found\n }\n@@ -126,11 +126,11 @@ fn target_bin_dir(workspace: &Path) -> Path {\n     workspace.join(\"bin\")\n }\n \n-/// Figure out what the executable name for <pkgid> in <workspace>'s build\n+/// Figure out what the executable name for <crateid> in <workspace>'s build\n /// directory is, and if the file exists, return it.\n-pub fn built_executable_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n+pub fn built_executable_in_workspace(crateid: &CrateId, workspace: &Path) -> Option<Path> {\n     let mut result = target_build_dir(workspace);\n-    result = mk_output_path(Main, Build, pkgid, result);\n+    result = mk_output_path(Main, Build, crateid, result);\n     debug!(\"built_executable_in_workspace: checking whether {} exists\",\n            result.display());\n     if result.exists() {\n@@ -142,22 +142,22 @@ pub fn built_executable_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<\n     }\n }\n \n-/// Figure out what the test name for <pkgid> in <workspace>'s build\n+/// Figure out what the test name for <crateid> in <workspace>'s build\n /// directory is, and if the file exists, return it.\n-pub fn built_test_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n-    output_in_workspace(pkgid, workspace, Test)\n+pub fn built_test_in_workspace(crateid: &CrateId, workspace: &Path) -> Option<Path> {\n+    output_in_workspace(crateid, workspace, Test)\n }\n \n-/// Figure out what the test name for <pkgid> in <workspace>'s build\n+/// Figure out what the test name for <crateid> in <workspace>'s build\n /// directory is, and if the file exists, return it.\n-pub fn built_bench_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n-    output_in_workspace(pkgid, workspace, Bench)\n+pub fn built_bench_in_workspace(crateid: &CrateId, workspace: &Path) -> Option<Path> {\n+    output_in_workspace(crateid, workspace, Bench)\n }\n \n-fn output_in_workspace(pkgid: &PkgId, workspace: &Path, what: OutputType) -> Option<Path> {\n+fn output_in_workspace(crateid: &CrateId, workspace: &Path, what: OutputType) -> Option<Path> {\n     let mut result = target_build_dir(workspace);\n     // should use a target-specific subdirectory\n-    result = mk_output_path(what, Build, pkgid, result);\n+    result = mk_output_path(what, Build, crateid, result);\n     debug!(\"output_in_workspace: checking whether {} exists\",\n            result.display());\n     if result.exists() {\n@@ -169,10 +169,11 @@ fn output_in_workspace(pkgid: &PkgId, workspace: &Path, what: OutputType) -> Opt\n     }\n }\n \n-/// Figure out what the library name for <pkgid> in <workspace>'s build\n+/// Figure out what the library name for <crateid> in <workspace>'s build\n /// directory is, and if the file exists, return it.\n-pub fn built_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n-    library_in_workspace(&pkgid.path, pkgid.short_name, Build, workspace, \"build\", &pkgid.version)\n+pub fn built_library_in_workspace(crateid: &CrateId, workspace: &Path) -> Option<Path> {\n+    library_in_workspace(&crateid.path, crateid.short_name, Build, workspace, \"build\",\n+                         &crateid.version)\n }\n \n /// Does the actual searching stuff\n@@ -292,45 +293,45 @@ fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Opti\n     abs_path\n }\n \n-/// Returns the executable that would be installed for <pkgid>\n+/// Returns the executable that would be installed for <crateid>\n /// in <workspace>\n /// As a side effect, creates the bin-dir if it doesn't exist\n-pub fn target_executable_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n-    target_file_in_workspace(pkgid, workspace, Main, Install)\n+pub fn target_executable_in_workspace(crateid: &CrateId, workspace: &Path) -> Path {\n+    target_file_in_workspace(crateid, workspace, Main, Install)\n }\n \n \n-/// Returns the executable that would be installed for <pkgid>\n+/// Returns the executable that would be installed for <crateid>\n /// in <workspace>\n /// As a side effect, creates the lib-dir if it doesn't exist\n-pub fn target_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n+pub fn target_library_in_workspace(crateid: &CrateId, workspace: &Path) -> Path {\n     use conditions::bad_path::cond;\n     if !workspace.is_dir() {\n         cond.raise(((*workspace).clone(),\n                     format!(\"Workspace supplied to target_library_in_workspace \\\n                              is not a directory! {}\", workspace.display())));\n     }\n-    target_file_in_workspace(pkgid, workspace, Lib, Install)\n+    target_file_in_workspace(crateid, workspace, Lib, Install)\n }\n \n-/// Returns the test executable that would be installed for <pkgid>\n+/// Returns the test executable that would be installed for <crateid>\n /// in <workspace>\n /// note that we *don't* install test executables, so this is just for unit testing\n-pub fn target_test_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n-    target_file_in_workspace(pkgid, workspace, Test, Install)\n+pub fn target_test_in_workspace(crateid: &CrateId, workspace: &Path) -> Path {\n+    target_file_in_workspace(crateid, workspace, Test, Install)\n }\n \n-/// Returns the bench executable that would be installed for <pkgid>\n+/// Returns the bench executable that would be installed for <crateid>\n /// in <workspace>\n /// note that we *don't* install bench executables, so this is just for unit testing\n-pub fn target_bench_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n-    target_file_in_workspace(pkgid, workspace, Bench, Install)\n+pub fn target_bench_in_workspace(crateid: &CrateId, workspace: &Path) -> Path {\n+    target_file_in_workspace(crateid, workspace, Bench, Install)\n }\n \n \n-/// Returns the path that pkgid `pkgid` would have if placed `where`\n+/// Returns the path that crateid `crateid` would have if placed `where`\n /// in `workspace`\n-fn target_file_in_workspace(pkgid: &PkgId, workspace: &Path,\n+fn target_file_in_workspace(crateid: &CrateId, workspace: &Path,\n                             what: OutputType, where: Target) -> Path {\n     use conditions::bad_path::cond;\n \n@@ -340,33 +341,33 @@ fn target_file_in_workspace(pkgid: &PkgId, workspace: &Path,\n     // Artifacts in the build directory live in a package-ID-specific subdirectory,\n     // but installed ones don't.\n     let result = match (where, what) {\n-                (Build, _)      => target_build_dir(workspace).join(&pkgid.path),\n+                (Build, _)      => target_build_dir(workspace).join(&crateid.path),\n                 (Install, Lib)  => target_lib_dir(workspace),\n                 (Install, _)    => target_bin_dir(workspace)\n     };\n     if io::result(|| fs::mkdir_recursive(&result, io::UserRWX)).is_err() {\n         cond.raise((result.clone(), format!(\"target_file_in_workspace couldn't \\\n-            create the {} dir (pkgid={}, workspace={}, what={:?}, where={:?}\",\n-            subdir, pkgid.to_str(), workspace.display(), what, where)));\n+            create the {} dir (crateid={}, workspace={}, what={:?}, where={:?}\",\n+            subdir, crateid.to_str(), workspace.display(), what, where)));\n     }\n-    mk_output_path(what, where, pkgid, result)\n+    mk_output_path(what, where, crateid, result)\n }\n \n-/// Return the directory for <pkgid>'s build artifacts in <workspace>.\n+/// Return the directory for <crateid>'s build artifacts in <workspace>.\n /// Creates it if it doesn't exist.\n-pub fn build_pkg_id_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n+pub fn build_pkg_id_in_workspace(crateid: &CrateId, workspace: &Path) -> Path {\n     let mut result = target_build_dir(workspace);\n-    result.push(&pkgid.path);\n+    result.push(&crateid.path);\n     debug!(\"Creating build dir {} for package id {}\", result.display(),\n-           pkgid.to_str());\n+           crateid.to_str());\n     fs::mkdir_recursive(&result, io::UserRWX);\n     return result;\n }\n \n /// Return the output file for a given directory name,\n /// given whether we're building a library and whether we're building tests\n pub fn mk_output_path(what: OutputType, where: Target,\n-                      pkg_id: &PkgId, workspace: Path) -> Path {\n+                      pkg_id: &CrateId, workspace: Path) -> Path {\n     let short_name_with_version = format!(\"{}-{}\", pkg_id.short_name,\n                                           pkg_id.version.to_str());\n     // Not local_path.dir_path()! For package foo/bar/blat/, we want\n@@ -399,22 +400,22 @@ pub fn mk_output_path(what: OutputType, where: Target,\n     output_path\n }\n \n-/// Removes files for the package `pkgid`, assuming it's installed in workspace `workspace`\n-pub fn uninstall_package_from(workspace: &Path, pkgid: &PkgId) {\n+/// Removes files for the package `crateid`, assuming it's installed in workspace `workspace`\n+pub fn uninstall_package_from(workspace: &Path, crateid: &CrateId) {\n     let mut did_something = false;\n-    let installed_bin = target_executable_in_workspace(pkgid, workspace);\n+    let installed_bin = target_executable_in_workspace(crateid, workspace);\n     if installed_bin.exists() {\n         fs::unlink(&installed_bin);\n         did_something = true;\n     }\n-    let installed_lib = target_library_in_workspace(pkgid, workspace);\n+    let installed_lib = target_library_in_workspace(crateid, workspace);\n     if installed_lib.exists() {\n         fs::unlink(&installed_lib);\n         did_something = true;\n     }\n     if !did_something {\n         warn(format!(\"Warning: there don't seem to be any files for {} installed in {}\",\n-             pkgid.to_str(), workspace.display()));\n+             crateid.to_str(), workspace.display()));\n     }\n \n }\n@@ -429,7 +430,7 @@ fn dir_has_file(dir: &Path, file: &str) -> bool {\n     dir.join(file).exists()\n }\n \n-pub fn find_dir_using_rust_path_hack(p: &PkgId) -> Option<Path> {\n+pub fn find_dir_using_rust_path_hack(p: &CrateId) -> Option<Path> {\n     let rp = rust_path();\n     for dir in rp.iter() {\n         // Require that the parent directory match the package ID"}, {"sha": "7f6342dba5c794eb47159475f01ff8d61d9de68c", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 124, "deletions": 123, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1", "patch": "@@ -24,7 +24,7 @@ use extra::treemap::TreeMap;\n use extra::getopts::groups::getopts;\n use std::run::ProcessOutput;\n use installed_packages::list_installed_packages;\n-use package_id::{PkgId};\n+use crate_id::{CrateId};\n use version::{ExactRevision, NoVersion, Version, Tagged};\n use path_util::{target_executable_in_workspace, target_test_in_workspace,\n                target_bench_in_workspace, make_dir_rwx,\n@@ -59,25 +59,25 @@ fn fake_ctxt(sysroot: Path, workspace: &Path) -> BuildContext {\n     }\n }\n \n-fn fake_pkg() -> PkgId {\n+fn fake_pkg() -> CrateId {\n     let sn = ~\"bogus\";\n-    PkgId {\n+    CrateId {\n         path: Path::new(sn.as_slice()),\n         short_name: sn,\n         version: NoVersion\n     }\n }\n \n-fn git_repo_pkg() -> PkgId {\n-    PkgId {\n+fn git_repo_pkg() -> CrateId {\n+    CrateId {\n         path: Path::new(\"mockgithub.com/catamorphism/test-pkg\"),\n         short_name: ~\"test-pkg\",\n         version: NoVersion\n     }\n }\n \n-fn git_repo_pkg_with_tag(a_tag: ~str) -> PkgId {\n-    PkgId {\n+fn git_repo_pkg_with_tag(a_tag: ~str) -> CrateId {\n+    CrateId {\n         path: Path::new(\"mockgithub.com/catamorphism/test-pkg\"),\n         short_name: ~\"test-pkg\",\n         version: Tagged(a_tag)\n@@ -302,15 +302,16 @@ fn command_line_test_with_env(args: &[~str], cwd: &Path, env: Option<~[(~str, ~s\n     }\n }\n \n-fn create_local_package(pkgid: &PkgId) -> TempDir {\n-    let (workspace, parent_dir) = mk_temp_workspace(&pkgid.path, &pkgid.version);\n-    debug!(\"Created empty package dir for {}, returning {}\", pkgid.to_str(), parent_dir.display());\n+fn create_local_package(crateid: &CrateId) -> TempDir {\n+    let (workspace, parent_dir) = mk_temp_workspace(&crateid.path, &crateid.version);\n+    debug!(\"Created empty package dir for {}, returning {}\", crateid.to_str(),\n+           parent_dir.display());\n     workspace\n }\n \n-fn create_local_package_in(pkgid: &PkgId, pkgdir: &Path) -> Path {\n+fn create_local_package_in(crateid: &CrateId, pkgdir: &Path) -> Path {\n \n-    let package_dir = pkgdir.join_many([~\"src\", pkgid.to_str()]);\n+    let package_dir = pkgdir.join_many([~\"src\", crateid.to_str()]);\n \n     // Create main, lib, test, and bench files\n     fs::mkdir_recursive(&package_dir, io::UserRWX);\n@@ -329,29 +330,29 @@ fn create_local_package_in(pkgid: &PkgId, pkgdir: &Path) -> Path {\n     package_dir\n }\n \n-fn create_local_package_with_test(pkgid: &PkgId) -> TempDir {\n-    debug!(\"Dry run -- would create package {:?} with test\", pkgid);\n-    create_local_package(pkgid) // Already has tests???\n+fn create_local_package_with_test(crateid: &CrateId) -> TempDir {\n+    debug!(\"Dry run -- would create package {:?} with test\", crateid);\n+    create_local_package(crateid) // Already has tests???\n }\n \n-fn create_local_package_with_dep(pkgid: &PkgId, subord_pkgid: &PkgId) -> TempDir {\n-    let package_dir = create_local_package(pkgid);\n-    create_local_package_in(subord_pkgid, package_dir.path());\n-    // Write a main.rs file into pkgid that references subord_pkgid\n-    writeFile(&package_dir.path().join_many([~\"src\", pkgid.to_str(), ~\"main.rs\"]),\n+fn create_local_package_with_dep(crateid: &CrateId, subord_crateid: &CrateId) -> TempDir {\n+    let package_dir = create_local_package(crateid);\n+    create_local_package_in(subord_crateid, package_dir.path());\n+    // Write a main.rs file into crateid that references subord_crateid\n+    writeFile(&package_dir.path().join_many([~\"src\", crateid.to_str(), ~\"main.rs\"]),\n               format!(\"extern mod {};\\nfn main() \\\\{\\\\}\",\n-                   subord_pkgid.short_name));\n-    // Write a lib.rs file into subord_pkgid that has something in it\n-    writeFile(&package_dir.path().join_many([~\"src\", subord_pkgid.to_str(), ~\"lib.rs\"]),\n+                   subord_crateid.short_name));\n+    // Write a lib.rs file into subord_crateid that has something in it\n+    writeFile(&package_dir.path().join_many([~\"src\", subord_crateid.to_str(), ~\"lib.rs\"]),\n               \"pub fn f() {}\");\n     package_dir\n }\n \n-fn create_local_package_with_custom_build_hook(pkgid: &PkgId,\n+fn create_local_package_with_custom_build_hook(crateid: &CrateId,\n                                                custom_build_hook: &str) -> TempDir {\n     debug!(\"Dry run -- would create package {} with custom build hook {}\",\n-           pkgid.to_str(), custom_build_hook);\n-    create_local_package(pkgid)\n+           crateid.to_str(), custom_build_hook);\n+    create_local_package(crateid)\n     // actually write the pkg.rs with the custom build hook\n \n }\n@@ -376,18 +377,18 @@ fn assert_executable_exists(repo: &Path, short_name: &str) {\n \n fn executable_exists(repo: &Path, short_name: &str) -> bool {\n     debug!(\"executable_exists: repo = {}, short_name = {}\", repo.display(), short_name);\n-    let exec = target_executable_in_workspace(&PkgId::new(short_name), repo);\n+    let exec = target_executable_in_workspace(&CrateId::new(short_name), repo);\n     exec.exists() && is_rwx(&exec)\n }\n \n fn test_executable_exists(repo: &Path, short_name: &str) -> bool {\n     debug!(\"test_executable_exists: repo = {}, short_name = {}\", repo.display(), short_name);\n-    let exec = built_test_in_workspace(&PkgId::new(short_name), repo);\n+    let exec = built_test_in_workspace(&CrateId::new(short_name), repo);\n     exec.map_default(false, |exec| exec.exists() && is_rwx(&exec))\n }\n \n-fn remove_executable_file(p: &PkgId, workspace: &Path) {\n-    let exec = target_executable_in_workspace(&PkgId::new(p.short_name), workspace);\n+fn remove_executable_file(p: &CrateId, workspace: &Path) {\n+    let exec = target_executable_in_workspace(&CrateId::new(p.short_name), workspace);\n     if exec.exists() {\n         fs::unlink(&exec);\n     }\n@@ -400,15 +401,15 @@ fn assert_built_executable_exists(repo: &Path, short_name: &str) {\n fn built_executable_exists(repo: &Path, short_name: &str) -> bool {\n     debug!(\"assert_built_executable_exists: repo = {}, short_name = {}\",\n             repo.display(), short_name);\n-    let exec = built_executable_in_workspace(&PkgId::new(short_name), repo);\n+    let exec = built_executable_in_workspace(&CrateId::new(short_name), repo);\n     exec.is_some() && {\n        let execname = exec.get_ref();\n        execname.exists() && is_rwx(execname)\n     }\n }\n \n-fn remove_built_executable_file(p: &PkgId, workspace: &Path) {\n-    let exec = built_executable_in_workspace(&PkgId::new(p.short_name), workspace);\n+fn remove_built_executable_file(p: &CrateId, workspace: &Path) {\n+    let exec = built_executable_in_workspace(&CrateId::new(p.short_name), workspace);\n     match exec {\n         Some(r) => fs::unlink(&r),\n         None    => ()\n@@ -443,7 +444,7 @@ fn assert_built_library_exists(repo: &Path, short_name: &str) {\n \n fn built_library_exists(repo: &Path, short_name: &str) -> bool {\n     debug!(\"assert_built_library_exists: repo = {}, short_name = {}\", repo.display(), short_name);\n-    let lib = built_library_in_workspace(&PkgId::new(short_name), repo);\n+    let lib = built_library_in_workspace(&CrateId::new(short_name), repo);\n     lib.is_some() && {\n         let libname = lib.get_ref();\n         libname.exists() && is_rwx(libname)\n@@ -493,9 +494,9 @@ fn output_file_name(workspace: &Path, short_name: ~str) -> Path {\n }\n \n #[cfg(target_os = \"linux\")]\n-fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n+fn touch_source_file(workspace: &Path, crateid: &CrateId) {\n     use conditions::bad_path::cond;\n-    let pkg_src_dir = workspace.join_many([~\"src\", pkgid.to_str()]);\n+    let pkg_src_dir = workspace.join_many([~\"src\", crateid.to_str()]);\n     let contents = fs::readdir(&pkg_src_dir);\n     for p in contents.iter() {\n         if p.extension_str() == Some(\"rs\") {\n@@ -513,9 +514,9 @@ fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n }\n \n #[cfg(not(target_os = \"linux\"))]\n-fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n+fn touch_source_file(workspace: &Path, crateid: &CrateId) {\n     use conditions::bad_path::cond;\n-    let pkg_src_dir = workspace.join_many([~\"src\", pkgid.to_str()]);\n+    let pkg_src_dir = workspace.join_many([~\"src\", crateid.to_str()]);\n     let contents = fs::readdir(&pkg_src_dir);\n     for p in contents.iter() {\n         if p.extension_str() == Some(\"rs\") {\n@@ -532,9 +533,9 @@ fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n }\n \n /// Add a comment at the end\n-fn frob_source_file(workspace: &Path, pkgid: &PkgId, filename: &str) {\n+fn frob_source_file(workspace: &Path, crateid: &CrateId, filename: &str) {\n     use conditions::bad_path::cond;\n-    let pkg_src_dir = workspace.join_many([~\"src\", pkgid.to_str()]);\n+    let pkg_src_dir = workspace.join_many([~\"src\", crateid.to_str()]);\n     let mut maybe_p = None;\n     let maybe_file = pkg_src_dir.join(filename);\n     debug!(\"Trying to frob {} -- {}\", pkg_src_dir.display(), filename);\n@@ -618,7 +619,7 @@ fn test_install_valid() {\n #[ignore]\n fn test_install_invalid() {\n     let sysroot = test_sysroot();\n-    let pkgid = fake_pkg();\n+    let crateid = fake_pkg();\n     let temp_workspace = TempDir::new(\"test\").expect(\"couldn't create temp dir\");\n     let temp_workspace = temp_workspace.path().clone();\n     let ctxt = fake_ctxt(sysroot, &temp_workspace);\n@@ -628,7 +629,7 @@ fn test_install_invalid() {\n         let pkg_src = PkgSrc::new(temp_workspace.clone(),\n                                   temp_workspace.clone(),\n                                   false,\n-                                  pkgid.clone());\n+                                  crateid.clone());\n         ctxt.install(pkg_src, &WhatToBuild::new(MaybeCustom, Everything));\n     };\n     assert!(result.unwrap_err()\n@@ -637,7 +638,7 @@ fn test_install_invalid() {\n \n #[test]\n fn test_install_valid_external() {\n-    let temp_pkg_id = PkgId::new(\"foo\");\n+    let temp_pkg_id = CrateId::new(\"foo\");\n     let (tempdir, _) = mk_temp_workspace(&temp_pkg_id.path,\n                                          &temp_pkg_id.version);\n     let temp_workspace = tempdir.path();\n@@ -724,7 +725,7 @@ fn test_install_git() {\n }\n \n #[test]\n-fn test_package_ids_must_be_relative_path_like() {\n+fn test_crate_ids_must_be_relative_path_like() {\n     use conditions::bad_pkg_id::cond;\n \n     /*\n@@ -738,30 +739,30 @@ fn test_package_ids_must_be_relative_path_like() {\n \n     */\n \n-    let whatever = PkgId::new(\"foo\");\n+    let whatever = CrateId::new(\"foo\");\n \n     assert_eq!(~\"foo-0.0\", whatever.to_str());\n     assert!(\"github.com/catamorphism/test-pkg-0.0\" ==\n-            PkgId::new(\"github.com/catamorphism/test-pkg\").to_str());\n+            CrateId::new(\"github.com/catamorphism/test-pkg\").to_str());\n \n     cond.trap(|(p, e)| {\n         assert!(p.filename().is_none())\n-        assert!(\"0-length pkgid\" == e);\n+        assert!(\"0-length crate_id\" == e);\n         whatever.clone()\n     }).inside(|| {\n-        let x = PkgId::new(\"\");\n+        let x = CrateId::new(\"\");\n         assert_eq!(~\"foo-0.0\", x.to_str());\n     });\n \n     cond.trap(|(p, e)| {\n         let abs = os::make_absolute(&Path::new(\"foo/bar/quux\"));\n         assert_eq!(p, abs);\n-        assert!(\"absolute pkgid\" == e);\n+        assert!(\"absolute crate_id\" == e);\n         whatever.clone()\n     }).inside(|| {\n         let zp = os::make_absolute(&Path::new(\"foo/bar/quux\"));\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        let z = PkgId::new(zp.as_str().unwrap());\n+        let z = CrateId::new(zp.as_str().unwrap());\n         assert_eq!(~\"foo-0.0\", z.to_str());\n     })\n }\n@@ -785,7 +786,7 @@ fn test_package_version() {\n     add_git_tag(&repo_subdir, ~\"0.4\");\n \n     // It won't pick up the 0.4 version because the dir isn't in the RUST_PATH, but...\n-    let temp_pkg_id = PkgId::new(\"mockgithub.com/catamorphism/test_pkg_version\");\n+    let temp_pkg_id = CrateId::new(\"mockgithub.com/catamorphism/test_pkg_version\");\n     // This should look at the prefix, clone into a workspace, then build.\n     command_line_test([~\"install\", ~\"mockgithub.com/catamorphism/test_pkg_version\"],\n                       repo);\n@@ -837,7 +838,7 @@ fn test_package_request_version() {\n         }\n         None    => false\n     });\n-    let temp_pkg_id = PkgId::new(\"mockgithub.com/catamorphism/test_pkg_version#0.3\");\n+    let temp_pkg_id = CrateId::new(\"mockgithub.com/catamorphism/test_pkg_version#0.3\");\n     assert!(target_executable_in_workspace(&temp_pkg_id, &repo.join(\".rust\"))\n             == repo.join_many([\".rust\", \"bin\", \"test_pkg_version\"]));\n \n@@ -880,15 +881,15 @@ fn rustpkg_library_target() {\n \n #[test]\n fn rustpkg_local_pkg() {\n-    let dir = create_local_package(&PkgId::new(\"foo\"));\n+    let dir = create_local_package(&CrateId::new(\"foo\"));\n     command_line_test([~\"install\", ~\"foo\"], dir.path());\n     assert_executable_exists(dir.path(), \"foo\");\n }\n \n #[test]\n #[ignore(reason=\"busted\")]\n fn package_script_with_default_build() {\n-    let dir = create_local_package(&PkgId::new(\"fancy-lib\"));\n+    let dir = create_local_package(&CrateId::new(\"fancy-lib\"));\n     let dir = dir.path();\n     debug!(\"dir = {}\", dir.display());\n     let mut source = test_sysroot().dir_path();\n@@ -945,7 +946,7 @@ fn rustpkg_clean_no_arg() {\n     command_line_test([~\"build\"], &package_dir);\n     assert_built_executable_exists(&tmp, \"foo\");\n     command_line_test([~\"clean\"], &package_dir);\n-    let res = built_executable_in_workspace(&PkgId::new(\"foo\"), &tmp);\n+    let res = built_executable_in_workspace(&CrateId::new(\"foo\"), &tmp);\n     assert!(!res.as_ref().map_default(false, |m| m.exists()));\n }\n \n@@ -1003,11 +1004,11 @@ fn rust_path_parse() {\n fn test_list() {\n     let dir = TempDir::new(\"test_list\").expect(\"test_list failed\");\n     let dir = dir.path();\n-    let foo = PkgId::new(\"foo\");\n+    let foo = CrateId::new(\"foo\");\n     create_local_package_in(&foo, dir);\n-    let bar = PkgId::new(\"bar\");\n+    let bar = CrateId::new(\"bar\");\n     create_local_package_in(&bar, dir);\n-    let quux = PkgId::new(\"quux\");\n+    let quux = CrateId::new(\"quux\");\n     create_local_package_in(&quux, dir);\n \n // list doesn't output very much right now...\n@@ -1033,9 +1034,9 @@ fn test_list() {\n fn install_remove() {\n     let dir = TempDir::new(\"install_remove\").expect(\"install_remove\");\n     let dir = dir.path();\n-    let foo = PkgId::new(\"foo\");\n-    let bar = PkgId::new(\"bar\");\n-    let quux = PkgId::new(\"quux\");\n+    let foo = CrateId::new(\"foo\");\n+    let bar = CrateId::new(\"bar\");\n+    let quux = CrateId::new(\"quux\");\n     create_local_package_in(&foo, dir);\n     create_local_package_in(&bar, dir);\n     create_local_package_in(&quux, dir);\n@@ -1062,13 +1063,13 @@ fn install_check_duplicates() {\n     // check invariant that there are no dups in the pkg database\n     let dir = TempDir::new(\"install_remove\").expect(\"install_remove\");\n     let dir = dir.path();\n-    let foo = PkgId::new(\"foo\");\n+    let foo = CrateId::new(\"foo\");\n     create_local_package_in(&foo, dir);\n \n     command_line_test([~\"install\", ~\"foo\"], dir);\n     command_line_test([~\"install\", ~\"foo\"], dir);\n     let mut contents = ~[];\n-    let check_dups = |p: &PkgId| {\n+    let check_dups = |p: &CrateId| {\n         if contents.contains(p) {\n             fail!(\"package {} appears in `list` output more than once\", p.path.display());\n         }\n@@ -1082,7 +1083,7 @@ fn install_check_duplicates() {\n \n #[test]\n fn no_rebuilding() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n@@ -1103,7 +1104,7 @@ fn no_rebuilding() {\n #[test]\n #[ignore]\n fn no_recopying() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     command_line_test([~\"install\", ~\"foo\"], workspace);\n@@ -1122,8 +1123,8 @@ fn no_recopying() {\n \n #[test]\n fn no_rebuilding_dep() {\n-    let p_id = PkgId::new(\"foo\");\n-    let dep_id = PkgId::new(\"bar\");\n+    let p_id = CrateId::new(\"foo\");\n+    let dep_id = CrateId::new(\"bar\");\n     let workspace = create_local_package_with_dep(&p_id, &dep_id);\n     let workspace = workspace.path();\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n@@ -1141,8 +1142,8 @@ fn no_rebuilding_dep() {\n \n #[test]\n fn do_rebuild_dep_dates_change() {\n-    let p_id = PkgId::new(\"foo\");\n-    let dep_id = PkgId::new(\"bar\");\n+    let p_id = CrateId::new(\"foo\");\n+    let dep_id = CrateId::new(\"bar\");\n     let workspace = create_local_package_with_dep(&p_id, &dep_id);\n     let workspace = workspace.path();\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n@@ -1161,8 +1162,8 @@ fn do_rebuild_dep_dates_change() {\n \n #[test]\n fn do_rebuild_dep_only_contents_change() {\n-    let p_id = PkgId::new(\"foo\");\n-    let dep_id = PkgId::new(\"bar\");\n+    let p_id = CrateId::new(\"foo\");\n+    let dep_id = CrateId::new(\"bar\");\n     let workspace = create_local_package_with_dep(&p_id, &dep_id);\n     let workspace = workspace.path();\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n@@ -1182,8 +1183,8 @@ fn do_rebuild_dep_only_contents_change() {\n \n #[test]\n fn test_versions() {\n-    let workspace = create_local_package(&PkgId::new(\"foo#0.1\"));\n-    let _other_workspace = create_local_package(&PkgId::new(\"foo#0.2\"));\n+    let workspace = create_local_package(&CrateId::new(\"foo#0.1\"));\n+    let _other_workspace = create_local_package(&CrateId::new(\"foo#0.2\"));\n     command_line_test([~\"install\", ~\"foo#0.1\"], workspace.path());\n     let output = command_line_test_output([~\"list\"]);\n     // make sure output includes versions\n@@ -1193,7 +1194,7 @@ fn test_versions() {\n #[test]\n #[ignore(reason = \"do not yet implemented\")]\n fn test_build_hooks() {\n-    let workspace = create_local_package_with_custom_build_hook(&PkgId::new(\"foo\"),\n+    let workspace = create_local_package_with_custom_build_hook(&CrateId::new(\"foo\"),\n                                                                 \"frob\");\n     command_line_test([~\"do\", ~\"foo\", ~\"frob\"], workspace.path());\n }\n@@ -1203,14 +1204,14 @@ fn test_build_hooks() {\n #[ignore(reason = \"info not yet implemented\")]\n fn test_info() {\n     let expected_info = ~\"package foo\"; // fill in\n-    let workspace = create_local_package(&PkgId::new(\"foo\"));\n+    let workspace = create_local_package(&CrateId::new(\"foo\"));\n     let output = command_line_test([~\"info\", ~\"foo\"], workspace.path());\n     assert_eq!(str::from_utf8_owned(output.output), expected_info);\n }\n \n #[test]\n fn test_uninstall() {\n-    let workspace = create_local_package(&PkgId::new(\"foo\"));\n+    let workspace = create_local_package(&CrateId::new(\"foo\"));\n     command_line_test([~\"uninstall\", ~\"foo\"], workspace.path());\n     let output = command_line_test([~\"list\"], workspace.path());\n     assert!(!str::from_utf8(output.output).contains(\"foo\"));\n@@ -1346,7 +1347,7 @@ fn test_extern_mod_simpler() {\n \n #[test]\n fn test_import_rustpkg() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     writeFile(&workspace.join_many([\"src\", \"foo-0.0\", \"pkg.rs\"]),\n@@ -1359,7 +1360,7 @@ fn test_import_rustpkg() {\n \n #[test]\n fn test_macro_pkg_script() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     writeFile(&workspace.join_many([\"src\", \"foo-0.0\", \"pkg.rs\"]),\n@@ -1386,7 +1387,7 @@ fn multiple_workspaces() {\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let env = Some(~[(~\"RUST_PATH\", format!(\"{}:{}\", a_loc.as_str().unwrap(),\n                                             b_loc.as_str().unwrap()))]);\n-    let c_loc = create_local_package_with_dep(&PkgId::new(\"bar\"), &PkgId::new(\"foo\"));\n+    let c_loc = create_local_package_with_dep(&CrateId::new(\"bar\"), &CrateId::new(\"foo\"));\n     command_line_test_with_env([~\"install\", ~\"bar\"], c_loc.path(), env);\n }\n \n@@ -1399,7 +1400,7 @@ fn rust_path_hack_test(hack_flag: bool) {\n       make sure built files for foo are in B\n       make sure nothing gets built into A or A/../build[lib,bin]\n */\n-   let p_id = PkgId::new(\"foo\");\n+   let p_id = CrateId::new(\"foo\");\n    let workspace = create_local_package(&p_id);\n    let workspace = workspace.path();\n    let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n@@ -1524,8 +1525,8 @@ fn rust_path_hack_build_no_arg() {\n \n #[test]\n fn rust_path_hack_build_with_dependency() {\n-    let foo_id = PkgId::new(\"foo\");\n-    let dep_id = PkgId::new(\"dep\");\n+    let foo_id = CrateId::new(\"foo\");\n+    let dep_id = CrateId::new(\"dep\");\n     // Tests that when --rust-path-hack is in effect, dependencies get built\n     // into the destination workspace and not the source directory\n     let work_dir = create_local_package(&foo_id);\n@@ -1573,7 +1574,7 @@ fn rust_path_install_target() {\n \n #[test]\n fn sysroot_flag() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     // no-op sysroot setting; I'm not sure how else to test this\n@@ -1589,7 +1590,7 @@ fn sysroot_flag() {\n \n #[test]\n fn compile_flag_build() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1606,7 +1607,7 @@ fn compile_flag_build() {\n #[test]\n fn compile_flag_fail() {\n     // --no-link shouldn't be accepted for install\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1622,7 +1623,7 @@ fn compile_flag_fail() {\n \n #[test]\n fn notrans_flag_build() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let flags_to_test = [~\"--no-trans\", ~\"--parse-only\",\n@@ -1647,7 +1648,7 @@ fn notrans_flag_build() {\n #[test]\n fn notrans_flag_fail() {\n     // --no-trans shouldn't be accepted for install\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let flags_to_test = [~\"--no-trans\", ~\"--parse-only\",\n@@ -1668,7 +1669,7 @@ fn notrans_flag_fail() {\n \n #[test]\n fn dash_S() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1685,7 +1686,7 @@ fn dash_S() {\n \n #[test]\n fn dash_S_fail() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1702,7 +1703,7 @@ fn dash_S_fail() {\n \n #[test]\n fn test_cfg_build() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     // If the cfg flag gets messed up, this won't compile\n@@ -1721,7 +1722,7 @@ fn test_cfg_build() {\n \n #[test]\n fn test_cfg_fail() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     writeFile(&workspace.join_many([\"src\", \"foo-0.0\", \"main.rs\"]),\n@@ -1740,7 +1741,7 @@ fn test_cfg_fail() {\n \n #[test]\n fn test_emit_llvm_S_build() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1758,7 +1759,7 @@ fn test_emit_llvm_S_build() {\n \n #[test]\n fn test_emit_llvm_S_fail() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1778,7 +1779,7 @@ fn test_emit_llvm_S_fail() {\n \n #[test]\n fn test_emit_llvm_build() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1797,7 +1798,7 @@ fn test_emit_llvm_build() {\n \n #[test]\n fn test_emit_llvm_fail() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1818,7 +1819,7 @@ fn test_emit_llvm_fail() {\n \n #[test]\n fn test_linker_build() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let matches = getopts([], optgroups());\n@@ -1863,7 +1864,7 @@ fn test_build_install_flags_fail() {\n \n #[test]\n fn test_optimized_build() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1877,7 +1878,7 @@ fn test_optimized_build() {\n }\n \n #[test]\n-fn pkgid_pointing_to_subdir() {\n+fn crateid_pointing_to_subdir() {\n     // The actual repo is mockgithub.com/mozilla/some_repo\n     // rustpkg should recognize that and treat the part after some_repo/ as a subdir\n     let workspace = TempDir::new(\"parent_repo\").expect(\"Couldn't create temp dir\");\n@@ -1913,9 +1914,9 @@ fn pkgid_pointing_to_subdir() {\n \n #[test]\n fn test_recursive_deps() {\n-    let a_id = PkgId::new(\"a\");\n-    let b_id = PkgId::new(\"b\");\n-    let c_id = PkgId::new(\"c\");\n+    let a_id = CrateId::new(\"a\");\n+    let b_id = CrateId::new(\"b\");\n+    let c_id = CrateId::new(\"c\");\n     let b_workspace = create_local_package_with_dep(&b_id, &c_id);\n     let b_workspace = b_workspace.path();\n     writeFile(&b_workspace.join_many([\"src\", \"c-0.0\", \"lib.rs\"]),\n@@ -1939,7 +1940,7 @@ fn test_recursive_deps() {\n \n #[test]\n fn test_install_to_rust_path() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let second_workspace = create_local_package(&p_id);\n     let second_workspace = second_workspace.path();\n     let first_workspace = mk_empty_workspace(&Path::new(\"p\"), &NoVersion, \"dest\");\n@@ -1963,7 +1964,7 @@ fn test_install_to_rust_path() {\n \n #[test]\n fn test_target_specific_build_dir() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1979,7 +1980,7 @@ fn test_target_specific_build_dir() {\n \n #[test]\n fn test_target_specific_install_dir() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1998,7 +1999,7 @@ fn test_target_specific_install_dir() {\n #[test]\n #[ignore(reason = \"See #7240\")]\n fn test_dependencies_terminate() {\n-    let b_id = PkgId::new(\"b\");\n+    let b_id = CrateId::new(\"b\");\n     let workspace = create_local_package(&b_id);\n     let workspace = workspace.path();\n     let b_dir = workspace.join_many([\"src\", \"b-0.0\"]);\n@@ -2011,7 +2012,7 @@ fn test_dependencies_terminate() {\n \n #[test]\n fn install_after_build() {\n-    let b_id = PkgId::new(\"b\");\n+    let b_id = CrateId::new(\"b\");\n     let workspace = create_local_package(&b_id);\n     let workspace = workspace.path();\n     command_line_test([~\"build\", ~\"b\"], workspace);\n@@ -2022,7 +2023,7 @@ fn install_after_build() {\n \n #[test]\n fn reinstall() {\n-    let b = PkgId::new(\"b\");\n+    let b = CrateId::new(\"b\");\n     let workspace = create_local_package(&b);\n     let workspace = workspace.path();\n     // 1. Install, then remove executable file, then install again,\n@@ -2061,8 +2062,8 @@ fn correct_package_name_with_rust_path_hack() {\n     */\n \n     // Set RUST_PATH to something containing only the sources for foo\n-    let foo_id = PkgId::new(\"foo\");\n-    let bar_id = PkgId::new(\"bar\");\n+    let foo_id = CrateId::new(\"foo\");\n+    let bar_id = CrateId::new(\"bar\");\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n     let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n@@ -2091,7 +2092,7 @@ fn correct_package_name_with_rust_path_hack() {\n \n #[test]\n fn test_rustpkg_test_creates_exec() {\n-    let foo_id = PkgId::new(\"foo\");\n+    let foo_id = CrateId::new(\"foo\");\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n     writeFile(&foo_workspace.join_many([\"src\", \"foo-0.0\", \"test.rs\"]),\n@@ -2102,7 +2103,7 @@ fn test_rustpkg_test_creates_exec() {\n \n #[test]\n fn test_rustpkg_test_output() {\n-    let workspace = create_local_package_with_test(&PkgId::new(\"foo\"));\n+    let workspace = create_local_package_with_test(&CrateId::new(\"foo\"));\n     let output = command_line_test([~\"test\", ~\"foo\"], workspace.path());\n     let output_str = str::from_utf8(output.output);\n     // The first two assertions are separate because test output may\n@@ -2114,7 +2115,7 @@ fn test_rustpkg_test_output() {\n \n #[test]\n fn test_rustpkg_test_failure_exit_status() {\n-    let foo_id = PkgId::new(\"foo\");\n+    let foo_id = CrateId::new(\"foo\");\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n     writeFile(&foo_workspace.join_many([\"src\", \"foo-0.0\", \"test.rs\"]),\n@@ -2128,7 +2129,7 @@ fn test_rustpkg_test_failure_exit_status() {\n \n #[test]\n fn test_rustpkg_test_cfg() {\n-    let foo_id = PkgId::new(\"foo\");\n+    let foo_id = CrateId::new(\"foo\");\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n     writeFile(&foo_workspace.join_many([\"src\", \"foo-0.0\", \"test.rs\"]),\n@@ -2141,7 +2142,7 @@ fn test_rustpkg_test_cfg() {\n \n #[test]\n fn test_rebuild_when_needed() {\n-    let foo_id = PkgId::new(\"foo\");\n+    let foo_id = CrateId::new(\"foo\");\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n     let test_crate = foo_workspace.join_many([\"src\", \"foo-0.0\", \"test.rs\"]);\n@@ -2162,7 +2163,7 @@ fn test_rebuild_when_needed() {\n #[test]\n #[ignore] // FIXME (#10257): This doesn't work as is since a read only file can't execute\n fn test_no_rebuilding() {\n-    let foo_id = PkgId::new(\"foo\");\n+    let foo_id = CrateId::new(\"foo\");\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n     let test_crate = foo_workspace.join_many([\"src\", \"foo-0.0\", \"test.rs\"]);\n@@ -2196,7 +2197,7 @@ fn test_installed_read_only() {\n     writeFile(&repo_subdir.join(\"lib.rs\"),\n               \"pub fn f() { let _x = (); }\");\n     add_git_tag(&repo_subdir, ~\"0.1\"); // this has the effect of committing the files\n-    // update pkgid to what will be auto-detected\n+    // update crateid to what will be auto-detected\n     temp_pkg_id.version = ExactRevision(~\"0.1\");\n \n     // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -2281,7 +2282,7 @@ fn test_installed_local_changes() {\n \n #[test]\n fn test_7402() {\n-    let dir = create_local_package(&PkgId::new(\"foo\"));\n+    let dir = create_local_package(&CrateId::new(\"foo\"));\n     let dest_workspace = TempDir::new(\"more_rust\").expect(\"test_7402\");\n     let dest_workspace = dest_workspace.path();\n     // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -2295,7 +2296,7 @@ fn test_7402() {\n \n #[test]\n fn test_compile_error() {\n-    let foo_id = PkgId::new(\"foo\");\n+    let foo_id = CrateId::new(\"foo\");\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n     let main_crate = foo_workspace.join_many([\"src\", \"foo-0.0\", \"main.rs\"]);\n@@ -2329,7 +2330,7 @@ fn test_c_dependency_ok() {\n     // registers a hook to build it if it's not fresh\n     // After running `build`, test that the C library built\n \n-    let dir = create_local_package(&PkgId::new(\"cdep\"));\n+    let dir = create_local_package(&CrateId::new(\"cdep\"));\n     let dir = dir.path();\n     writeFile(&dir.join_many([\"src\", \"cdep-0.0\", \"main.rs\"]),\n               \"#[link_args = \\\"-lfoo\\\"]\\nextern { fn f(); } \\\n@@ -2352,7 +2353,7 @@ fn test_c_dependency_ok() {\n #[test]\n #[ignore(reason=\"busted\")]\n fn test_c_dependency_no_rebuilding() {\n-    let dir = create_local_package(&PkgId::new(\"cdep\"));\n+    let dir = create_local_package(&CrateId::new(\"cdep\"));\n     let dir = dir.path();\n     writeFile(&dir.join_many([\"src\", \"cdep-0.0\", \"main.rs\"]),\n               \"#[link_args = \\\"-lfoo\\\"]\\nextern { fn f(); } \\\n@@ -2386,7 +2387,7 @@ fn test_c_dependency_no_rebuilding() {\n #[test]\n #[ignore(reason=\"busted\")]\n fn test_c_dependency_yes_rebuilding() {\n-    let dir = create_local_package(&PkgId::new(\"cdep\"));\n+    let dir = create_local_package(&CrateId::new(\"cdep\"));\n     let dir = dir.path();\n     writeFile(&dir.join_many([\"src\", \"cdep-0.0\", \"main.rs\"]),\n               \"#[link_args = \\\"-lfoo\\\"]\\nextern { fn f(); } \\\n@@ -2407,7 +2408,7 @@ fn test_c_dependency_yes_rebuilding() {\n     assert!(c_library_path.exists());\n \n     // Now, make the Rust library read-only so rebuilding will fail\n-    match built_library_in_workspace(&PkgId::new(\"cdep\"), dir) {\n+    match built_library_in_workspace(&CrateId::new(\"cdep\"), dir) {\n         Some(ref pth) => assert!(chmod_read_only(pth)),\n         None => assert_built_library_exists(dir, \"cdep\")\n     }\n@@ -2425,7 +2426,7 @@ fn test_c_dependency_yes_rebuilding() {\n fn correct_error_dependency() {\n     // Supposing a package we're trying to install via a dependency doesn't\n     // exist, we should throw a condition, and not ICE\n-    let workspace_dir = create_local_package(&PkgId::new(\"badpkg\"));\n+    let workspace_dir = create_local_package(&CrateId::new(\"badpkg\"));\n \n     let dir = workspace_dir.path();\n     let main_rs = dir.join_many([\"src\", \"badpkg-0.0\", \"main.rs\"]);"}, {"sha": "2bb252c362cabdbf90a2ce79a315987f8377107e", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1", "patch": "@@ -29,7 +29,7 @@ use syntax::util::small_vector::SmallVector;\n use rustc::back::link::output_type_exe;\n use rustc::back::link;\n use context::{in_target, StopBefore, Link, Assemble, BuildContext};\n-use package_id::PkgId;\n+use crate_id::CrateId;\n use package_source::PkgSrc;\n use workspace::pkg_parent_workspaces;\n use path_util::{system_library, target_build_dir};\n@@ -52,7 +52,7 @@ static COMMANDS: &'static [&'static str] =\n pub type ExitCode = int; // For now\n \n pub struct Pkg {\n-    id: PkgId,\n+    id: CrateId,\n     bins: ~[~str],\n     libs: ~[~str],\n }\n@@ -170,7 +170,7 @@ pub fn ready_crate(sess: session::Session,\n \n pub fn compile_input(context: &BuildContext,\n                      exec: &mut workcache::Exec,\n-                     pkg_id: &PkgId,\n+                     pkg_id: &CrateId,\n                      in_file: &Path,\n                      workspace: &Path,\n                      deps: &mut DepMap,\n@@ -303,17 +303,17 @@ pub fn compile_input(context: &BuildContext,\n                                       addl_lib_search_paths.get().insert(p);\n                                   });\n \n-    // Inject the pkgid attribute so we get the right package name and version\n+    // Inject the crate_id attribute so we get the right package name and version\n     if !attr::contains_name(crate.attrs, \"crate_id\") {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        let pkgid_attr =\n+        let crateid_attr =\n             attr::mk_name_value_item_str(@\"crate_id\",\n                                          format!(\"{}\\\\#{}\",\n                                                  pkg_id.path.as_str().unwrap(),\n                                                  pkg_id.version.to_str()).to_managed());\n \n-        debug!(\"pkgid attr: {:?}\", pkgid_attr);\n-        crate.attrs.push(attr::mk_attr(pkgid_attr));\n+        debug!(\"crateid attr: {:?}\", crateid_attr);\n+        crate.attrs.push(attr::mk_attr(crateid_attr));\n     }\n \n     debug!(\"calling compile_crate_from_input, workspace = {},\n@@ -428,7 +428,7 @@ pub fn exe_suffix() -> ~str { ~\"\" }\n // Called by build_crates\n pub fn compile_crate(ctxt: &BuildContext,\n                      exec: &mut workcache::Exec,\n-                     pkg_id: &PkgId,\n+                     pkg_id: &CrateId,\n                      crate: &Path,\n                      workspace: &Path,\n                      deps: &mut DepMap,\n@@ -446,7 +446,7 @@ pub fn compile_crate(ctxt: &BuildContext,\n \n struct ViewItemVisitor<'a> {\n     context: &'a BuildContext,\n-    parent: &'a PkgId,\n+    parent: &'a CrateId,\n     parent_crate: &'a Path,\n     sess: session::Session,\n     exec: &'a mut workcache::Exec,\n@@ -491,7 +491,7 @@ impl<'a> Visitor<()> for ViewItemVisitor<'a> {\n                         debug!(\"Trying to install library {}, rebuilding it\",\n                                lib_name.to_str());\n                         // Try to install it\n-                        let pkg_id = PkgId::new(lib_name);\n+                        let pkg_id = CrateId::new(lib_name);\n                         // Find all the workspaces in the RUST_PATH that contain this package.\n                         let workspaces = pkg_parent_workspaces(&self.context.context,\n                                                                &pkg_id);\n@@ -607,7 +607,7 @@ impl<'a> Visitor<()> for ViewItemVisitor<'a> {\n /// try to install their targets, failing if any target\n /// can't be found.\n pub fn find_and_install_dependencies(context: &BuildContext,\n-                                     parent: &PkgId,\n+                                     parent: &CrateId,\n                                      parent_crate: &Path,\n                                      sess: session::Session,\n                                      exec: &mut workcache::Exec,"}, {"sha": "d6e617d2d5071fbdc9fa1b7a042d28ab24328f6c", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1", "patch": "@@ -13,23 +13,23 @@\n use std::os;\n use std::path::Path;\n use context::Context;\n-use path_util::{workspace_contains_package_id, find_dir_using_rust_path_hack, default_workspace};\n+use path_util::{workspace_contains_crate_id, find_dir_using_rust_path_hack, default_workspace};\n use path_util::rust_path;\n use util::option_to_vec;\n-use package_id::PkgId;\n+use crate_id::CrateId;\n \n pub fn each_pkg_parent_workspace(cx: &Context,\n-                                 pkgid: &PkgId,\n+                                 crateid: &CrateId,\n                                  action: |&Path| -> bool)\n                                  -> bool {\n     // Using the RUST_PATH, find workspaces that contain\n     // this package ID\n-    let workspaces = pkg_parent_workspaces(cx, pkgid);\n+    let workspaces = pkg_parent_workspaces(cx, crateid);\n     if workspaces.is_empty() {\n         // tjc: make this a condition\n         fail!(\"Package {} not found in any of \\\n                     the following workspaces: {}\",\n-                   pkgid.path.display(),\n+                   crateid.path.display(),\n                    rust_path().map(|p| p.display().to_str()).to_str());\n     }\n     for ws in workspaces.iter() {\n@@ -42,12 +42,12 @@ pub fn each_pkg_parent_workspace(cx: &Context,\n \n /// Given a package ID, return a vector of all of the workspaces in\n /// the RUST_PATH that contain it\n-pub fn pkg_parent_workspaces(cx: &Context, pkgid: &PkgId) -> ~[Path] {\n+pub fn pkg_parent_workspaces(cx: &Context, crateid: &CrateId) -> ~[Path] {\n     let rs: ~[Path] = rust_path().move_iter()\n-        .filter(|ws| workspace_contains_package_id(pkgid, ws))\n+        .filter(|ws| workspace_contains_crate_id(crateid, ws))\n         .collect();\n     if cx.use_rust_path_hack {\n-        rs + option_to_vec(find_dir_using_rust_path_hack(pkgid))\n+        rs + option_to_vec(find_dir_using_rust_path_hack(crateid))\n     }\n     else {\n         rs\n@@ -56,15 +56,15 @@ pub fn pkg_parent_workspaces(cx: &Context, pkgid: &PkgId) -> ~[Path] {\n \n /// Construct a workspace and package-ID name based on the current directory.\n /// This gets used when rustpkg gets invoked without a package-ID argument.\n-pub fn cwd_to_workspace() -> Option<(Path, PkgId)> {\n+pub fn cwd_to_workspace() -> Option<(Path, CrateId)> {\n     let cwd = os::getcwd();\n     for path in rust_path().move_iter() {\n         let srcpath = path.join(\"src\");\n         if srcpath.is_ancestor_of(&cwd) {\n             let rel = cwd.path_relative_from(&srcpath);\n             let rel_s = rel.as_ref().and_then(|p|p.as_str());\n             if rel_s.is_some() {\n-                return Some((path, PkgId::new(rel_s.unwrap())));\n+                return Some((path, CrateId::new(rel_s.unwrap())));\n             }\n         }\n     }"}, {"sha": "3b8eda8f78388ee69aa2ae5d251d433d5ea6b25a", "filename": "src/test/compile-fail/issue-7573.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1/src%2Ftest%2Fcompile-fail%2Fissue-7573.rs", "raw_url": "https://github.com/rust-lang/rust/raw/016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1/src%2Ftest%2Fcompile-fail%2Fissue-7573.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7573.rs?ref=016d52ed501004d7c7ee1e68c1e2aa2159fb3ea1", "patch": "@@ -8,23 +8,23 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub struct PkgId {\n+pub struct CrateId {\n     local_path: ~str,\n     junk: ~str\n }\n \n-impl PkgId {\n-    fn new(s: &str) -> PkgId {\n-        PkgId {\n+impl CrateId {\n+    fn new(s: &str) -> CrateId {\n+        CrateId {\n             local_path: s.to_owned(),\n             junk: ~\"wutevs\"\n         }\n     }\n }\n \n pub fn remove_package_from_database() {\n-    let mut lines_to_use: ~[&PkgId] = ~[]; //~ ERROR cannot infer an appropriate lifetime\n-    let push_id = |installed_id: &PkgId| {\n+    let mut lines_to_use: ~[&CrateId] = ~[]; //~ ERROR cannot infer an appropriate lifetime\n+    let push_id = |installed_id: &CrateId| {\n         lines_to_use.push(installed_id);\n     };\n     list_database(push_id);\n@@ -35,11 +35,11 @@ pub fn remove_package_from_database() {\n \n }\n \n-pub fn list_database(f: |&PkgId|) {\n+pub fn list_database(f: |&CrateId|) {\n     let stuff = [\"foo\", \"bar\"];\n \n     for l in stuff.iter() {\n-        f(&PkgId::new(*l));\n+        f(&CrateId::new(*l));\n     }\n }\n "}]}