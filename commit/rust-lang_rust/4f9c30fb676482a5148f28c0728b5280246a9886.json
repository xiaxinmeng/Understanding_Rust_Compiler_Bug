{"sha": "4f9c30fb676482a5148f28c0728b5280246a9886", "node_id": "C_kwDOAAsO6NoAKDRmOWMzMGZiNjc2NDgyYTUxNDhmMjhjMDcyOGI1MjgwMjQ2YTk4ODY", "commit": {"author": {"name": "Jannis Christopher K\u00f6hl", "email": "mail@koehl.dev", "date": "2022-08-25T16:43:46Z"}, "committer": {"name": "Jannis Christopher K\u00f6hl", "email": "mail@koehl.dev", "date": "2022-11-07T09:35:08Z"}, "message": "Add initial version of value analysis and dataflow constant propagation", "tree": {"sha": "55564521204033dbfceb6cffcdc04dfeac266546", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55564521204033dbfceb6cffcdc04dfeac266546"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f9c30fb676482a5148f28c0728b5280246a9886", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f9c30fb676482a5148f28c0728b5280246a9886", "html_url": "https://github.com/rust-lang/rust/commit/4f9c30fb676482a5148f28c0728b5280246a9886", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f9c30fb676482a5148f28c0728b5280246a9886/comments", "author": {"login": "jachris", "id": 30163784, "node_id": "MDQ6VXNlcjMwMTYzNzg0", "avatar_url": "https://avatars.githubusercontent.com/u/30163784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jachris", "html_url": "https://github.com/jachris", "followers_url": "https://api.github.com/users/jachris/followers", "following_url": "https://api.github.com/users/jachris/following{/other_user}", "gists_url": "https://api.github.com/users/jachris/gists{/gist_id}", "starred_url": "https://api.github.com/users/jachris/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jachris/subscriptions", "organizations_url": "https://api.github.com/users/jachris/orgs", "repos_url": "https://api.github.com/users/jachris/repos", "events_url": "https://api.github.com/users/jachris/events{/privacy}", "received_events_url": "https://api.github.com/users/jachris/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jachris", "id": 30163784, "node_id": "MDQ6VXNlcjMwMTYzNzg0", "avatar_url": "https://avatars.githubusercontent.com/u/30163784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jachris", "html_url": "https://github.com/jachris", "followers_url": "https://api.github.com/users/jachris/followers", "following_url": "https://api.github.com/users/jachris/following{/other_user}", "gists_url": "https://api.github.com/users/jachris/gists{/gist_id}", "starred_url": "https://api.github.com/users/jachris/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jachris/subscriptions", "organizations_url": "https://api.github.com/users/jachris/orgs", "repos_url": "https://api.github.com/users/jachris/repos", "events_url": "https://api.github.com/users/jachris/events{/privacy}", "received_events_url": "https://api.github.com/users/jachris/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b735a7132acd58b3bd34c084e9ca5b4ca7450a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b735a7132acd58b3bd34c084e9ca5b4ca7450a2", "html_url": "https://github.com/rust-lang/rust/commit/9b735a7132acd58b3bd34c084e9ca5b4ca7450a2"}], "stats": {"total": 1950, "additions": 1948, "deletions": 2}, "files": [{"sha": "401d3f6689c99e7ae4cb072a0c5d35032396e0f1", "filename": "compiler/rustc_graphviz/src/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c30fb676482a5148f28c0728b5280246a9886/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c30fb676482a5148f28c0728b5280246a9886/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs?ref=4f9c30fb676482a5148f28c0728b5280246a9886", "patch": "@@ -471,7 +471,11 @@ pub trait Labeller<'a> {\n /// Escape tags in such a way that it is suitable for inclusion in a\n /// Graphviz HTML label.\n pub fn escape_html(s: &str) -> String {\n-    s.replace('&', \"&amp;\").replace('\\\"', \"&quot;\").replace('<', \"&lt;\").replace('>', \"&gt;\")\n+    s.replace('&', \"&amp;\")\n+        .replace('\\\"', \"&quot;\")\n+        .replace('<', \"&lt;\")\n+        .replace('>', \"&gt;\")\n+        .replace('\\n', \"<br align=\\\"left\\\"/>\")\n }\n \n impl<'a> LabelText<'a> {"}, {"sha": "c9d5601f2074c958ca160a56bd7925ae48bb94a0", "filename": "compiler/rustc_mir_dataflow/src/framework/graphviz.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c30fb676482a5148f28c0728b5280246a9886/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c30fb676482a5148f28c0728b5280246a9886/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fgraphviz.rs?ref=4f9c30fb676482a5148f28c0728b5280246a9886", "patch": "@@ -475,7 +475,10 @@ where\n                 r#\"<td colspan=\"{colspan}\" {fmt} align=\"left\">{state}</td>\"#,\n                 colspan = this.style.num_state_columns(),\n                 fmt = fmt,\n-                state = format!(\"{:?}\", DebugWithAdapter { this: state, ctxt: analysis }),\n+                state = dot::escape_html(&format!(\n+                    \"{:?}\",\n+                    DebugWithAdapter { this: state, ctxt: analysis }\n+                )),\n             )\n         })\n     }"}, {"sha": "7f40cfca32fff3ccfb456134b80be301832d9a4b", "filename": "compiler/rustc_mir_dataflow/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c30fb676482a5148f28c0728b5280246a9886/compiler%2Frustc_mir_dataflow%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c30fb676482a5148f28c0728b5280246a9886/compiler%2Frustc_mir_dataflow%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Flib.rs?ref=4f9c30fb676482a5148f28c0728b5280246a9886", "patch": "@@ -41,6 +41,7 @@ pub mod move_paths;\n pub mod rustc_peek;\n pub mod storage;\n pub mod un_derefer;\n+pub mod value_analysis;\n \n pub(crate) mod indexes {\n     pub(crate) use super::move_paths::MovePathIndex;"}, {"sha": "1dcea430a0f6794fbf14f900be9e7f41eb74fe30", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "added", "additions": 677, "deletions": 0, "changes": 677, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c30fb676482a5148f28c0728b5280246a9886/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c30fb676482a5148f28c0728b5280246a9886/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=4f9c30fb676482a5148f28c0728b5280246a9886", "patch": "@@ -0,0 +1,677 @@\n+//! This module provides a framework on top of the normal MIR dataflow framework to simplify the\n+//! implementation of analyses that track the values stored in places of interest.\n+//!\n+//! The default methods of [`ValueAnalysis`] (prefixed with `super_` instead of `handle_`)\n+//! provide some behavior that should be valid for all abstract domains that are based only on the\n+//! value stored in a certain place. On top of these default rules, an implementation should\n+//! override some of the `handle_` methods. For an example, see `ConstAnalysis`.\n+//!\n+//! An implementation must also provide a [`Map`]. Before the anaylsis begins, all places that\n+//! should be tracked during the analysis must be registered. The set of tracked places cannot be\n+//! changed during the analysis.\n+\n+use std::fmt::{Debug, Formatter};\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::mir::*;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_target::abi::VariantIdx;\n+\n+use crate::{\n+    fmt::DebugWithContext, lattice::FlatSet, Analysis, AnalysisDomain, CallReturnPlaces,\n+    JoinSemiLattice, SwitchIntEdgeEffects,\n+};\n+\n+pub trait ValueAnalysis<'tcx> {\n+    /// For each place of interest, the analysis tracks a value of the given type.\n+    type Value: Clone + JoinSemiLattice + HasBottom + HasTop;\n+\n+    const NAME: &'static str;\n+\n+    fn map(&self) -> &Map;\n+\n+    fn handle_statement(&self, statement: &Statement<'tcx>, state: &mut State<Self::Value>) {\n+        self.super_statement(statement, state)\n+    }\n+\n+    fn super_statement(&self, statement: &Statement<'tcx>, state: &mut State<Self::Value>) {\n+        match &statement.kind {\n+            StatementKind::Assign(box (place, rvalue)) => {\n+                self.handle_assign(*place, rvalue, state);\n+            }\n+            StatementKind::SetDiscriminant { .. } => {\n+                // Could tread this as writing a constant to a pseudo-place.\n+            }\n+            StatementKind::CopyNonOverlapping(..) => {\n+                // FIXME: What to do here?\n+            }\n+            StatementKind::StorageLive(..)\n+            | StatementKind::StorageDead(..)\n+            | StatementKind::Deinit(_) => {\n+                // Could perhaps use these.\n+            }\n+            StatementKind::Nop\n+            | StatementKind::Retag(..)\n+            | StatementKind::FakeRead(..)\n+            | StatementKind::Coverage(..)\n+            | StatementKind::AscribeUserType(..) => (),\n+        }\n+    }\n+\n+    fn handle_assign(\n+        &self,\n+        target: Place<'tcx>,\n+        rvalue: &Rvalue<'tcx>,\n+        state: &mut State<Self::Value>,\n+    ) {\n+        self.super_assign(target, rvalue, state)\n+    }\n+\n+    fn super_assign(\n+        &self,\n+        target: Place<'tcx>,\n+        rvalue: &Rvalue<'tcx>,\n+        state: &mut State<Self::Value>,\n+    ) {\n+        match rvalue {\n+            Rvalue::Ref(_, BorrowKind::Shared, place) => {\n+                let target_deref = self\n+                    .map()\n+                    .find(target.as_ref())\n+                    .and_then(|target| self.map().apply_elem(target, ProjElem::Deref));\n+                let place = self.map().find(place.as_ref());\n+                match (target_deref, place) {\n+                    (Some(target_deref), Some(place)) => {\n+                        state.assign_idx(target_deref, ValueOrPlace::Place(place), self.map())\n+                    }\n+                    _ => (),\n+                }\n+            }\n+            Rvalue::Ref(_, _, place) | Rvalue::AddressOf(_, place) => {\n+                state.flood(place.as_ref(), self.map(), Self::Value::top());\n+            }\n+            _ => {\n+                let result = self.handle_rvalue(rvalue, state);\n+                state.assign(target.as_ref(), result, self.map());\n+            }\n+        }\n+    }\n+\n+    fn handle_rvalue(\n+        &self,\n+        rvalue: &Rvalue<'tcx>,\n+        state: &mut State<Self::Value>,\n+    ) -> ValueOrPlace<Self::Value> {\n+        self.super_rvalue(rvalue, state)\n+    }\n+\n+    fn super_rvalue(\n+        &self,\n+        rvalue: &Rvalue<'tcx>,\n+        state: &mut State<Self::Value>,\n+    ) -> ValueOrPlace<Self::Value> {\n+        match rvalue {\n+            Rvalue::Use(operand) => self.handle_operand(operand, state),\n+            Rvalue::CopyForDeref(place) => self.handle_operand(&Operand::Copy(*place), state),\n+            Rvalue::Ref(..) | Rvalue::AddressOf(..) => {\n+                bug!(\"this rvalue must be handled by handle_assign() or super_assign()\")\n+            }\n+            _ => {\n+                // FIXME: Check that other Rvalues really have no side-effect.\n+                ValueOrPlace::Unknown\n+            }\n+        }\n+    }\n+\n+    fn handle_operand(\n+        &self,\n+        operand: &Operand<'tcx>,\n+        state: &mut State<Self::Value>,\n+    ) -> ValueOrPlace<Self::Value> {\n+        self.super_operand(operand, state)\n+    }\n+\n+    fn super_operand(\n+        &self,\n+        operand: &Operand<'tcx>,\n+        state: &mut State<Self::Value>,\n+    ) -> ValueOrPlace<Self::Value> {\n+        match operand {\n+            Operand::Constant(box constant) => {\n+                ValueOrPlace::Value(self.handle_constant(constant, state))\n+            }\n+            Operand::Copy(place) | Operand::Move(place) => {\n+                // Do want want to handle moves different? Could flood place with bottom.\n+                self.map()\n+                    .find(place.as_ref())\n+                    .map(ValueOrPlace::Place)\n+                    .unwrap_or(ValueOrPlace::Unknown)\n+            }\n+        }\n+    }\n+\n+    fn handle_constant(\n+        &self,\n+        constant: &Constant<'tcx>,\n+        state: &mut State<Self::Value>,\n+    ) -> Self::Value {\n+        self.super_constant(constant, state)\n+    }\n+\n+    fn super_constant(\n+        &self,\n+        _constant: &Constant<'tcx>,\n+        _state: &mut State<Self::Value>,\n+    ) -> Self::Value {\n+        Self::Value::top()\n+    }\n+\n+    fn handle_terminator(&self, terminator: &Terminator<'tcx>, state: &mut State<Self::Value>) {\n+        self.super_terminator(terminator, state)\n+    }\n+\n+    fn super_terminator(&self, _terminator: &Terminator<'tcx>, _state: &mut State<Self::Value>) {}\n+\n+    fn handle_call_return(\n+        &self,\n+        return_places: CallReturnPlaces<'_, 'tcx>,\n+        state: &mut State<Self::Value>,\n+    ) {\n+        self.super_call_return(return_places, state)\n+    }\n+\n+    fn super_call_return(\n+        &self,\n+        return_places: CallReturnPlaces<'_, 'tcx>,\n+        state: &mut State<Self::Value>,\n+    ) {\n+        return_places.for_each(|place| {\n+            state.flood(place.as_ref(), self.map(), Self::Value::top());\n+        })\n+    }\n+\n+    fn handle_switch_int(\n+        &self,\n+        discr: &Operand<'tcx>,\n+        apply_edge_effects: &mut impl SwitchIntEdgeEffects<State<Self::Value>>,\n+    ) {\n+        self.super_switch_int(discr, apply_edge_effects)\n+    }\n+\n+    fn super_switch_int(\n+        &self,\n+        _discr: &Operand<'tcx>,\n+        _apply_edge_effects: &mut impl SwitchIntEdgeEffects<State<Self::Value>>,\n+    ) {\n+    }\n+\n+    fn wrap(self) -> ValueAnalysisWrapper<Self>\n+    where\n+        Self: Sized,\n+    {\n+        ValueAnalysisWrapper(self)\n+    }\n+}\n+\n+pub struct ValueAnalysisWrapper<T>(pub T);\n+\n+impl<'tcx, T: ValueAnalysis<'tcx>> AnalysisDomain<'tcx> for ValueAnalysisWrapper<T> {\n+    type Domain = State<T::Value>;\n+\n+    type Direction = crate::Forward;\n+\n+    const NAME: &'static str = T::NAME;\n+\n+    fn bottom_value(&self, _body: &Body<'tcx>) -> Self::Domain {\n+        State(IndexVec::from_elem_n(T::Value::bottom(), self.0.map().value_count))\n+    }\n+\n+    fn initialize_start_block(&self, body: &Body<'tcx>, state: &mut Self::Domain) {\n+        for arg in body.args_iter() {\n+            state.flood(PlaceRef { local: arg, projection: &[] }, self.0.map(), T::Value::top());\n+        }\n+    }\n+}\n+\n+impl<'tcx, T> Analysis<'tcx> for ValueAnalysisWrapper<T>\n+where\n+    T: ValueAnalysis<'tcx>,\n+{\n+    fn apply_statement_effect(\n+        &self,\n+        state: &mut Self::Domain,\n+        statement: &Statement<'tcx>,\n+        _location: Location,\n+    ) {\n+        self.0.handle_statement(statement, state);\n+    }\n+\n+    fn apply_terminator_effect(\n+        &self,\n+        state: &mut Self::Domain,\n+        terminator: &Terminator<'tcx>,\n+        _location: Location,\n+    ) {\n+        self.0.handle_terminator(terminator, state);\n+    }\n+\n+    fn apply_call_return_effect(\n+        &self,\n+        state: &mut Self::Domain,\n+        _block: BasicBlock,\n+        return_places: crate::CallReturnPlaces<'_, 'tcx>,\n+    ) {\n+        self.0.handle_call_return(return_places, state)\n+    }\n+\n+    fn apply_switch_int_edge_effects(\n+        &self,\n+        _block: BasicBlock,\n+        discr: &Operand<'tcx>,\n+        apply_edge_effects: &mut impl SwitchIntEdgeEffects<Self::Domain>,\n+    ) {\n+        self.0.handle_switch_int(discr, apply_edge_effects)\n+    }\n+}\n+\n+rustc_index::newtype_index!(\n+    pub struct PlaceIndex {}\n+);\n+\n+rustc_index::newtype_index!(\n+    struct ValueIndex {}\n+);\n+\n+#[derive(PartialEq, Eq, Clone, Debug)]\n+pub struct State<V>(IndexVec<ValueIndex, V>);\n+\n+impl<V: Clone + HasTop> State<V> {\n+    pub fn flood_all(&mut self, value: V) {\n+        self.0.raw.fill(value);\n+    }\n+\n+    pub fn flood(&mut self, place: PlaceRef<'_>, map: &Map, value: V) {\n+        if let Some(root) = map.find(place) {\n+            self.flood_idx(root, map, value);\n+        }\n+    }\n+\n+    pub fn flood_idx(&mut self, place: PlaceIndex, map: &Map, value: V) {\n+        map.preorder_invoke(place, &mut |place| {\n+            if let Some(vi) = map.places[place].value_index {\n+                self.0[vi] = value.clone();\n+            }\n+        });\n+    }\n+\n+    pub fn assign_place_idx(&mut self, target: PlaceIndex, source: PlaceIndex, map: &Map) {\n+        if let Some(target_value) = map.places[target].value_index {\n+            if let Some(source_value) = map.places[source].value_index {\n+                self.0[target_value] = self.0[source_value].clone();\n+            } else {\n+                self.0[target_value] = V::top();\n+            }\n+        }\n+        for target_child in map.children(target) {\n+            // Try to find corresponding child in source.\n+            let projection = map.places[target_child].proj_elem.unwrap();\n+            if let Some(source_child) = map.projections.get(&(source, projection)) {\n+                self.assign_place_idx(target_child, *source_child, map);\n+            } else {\n+                self.flood_idx(target_child, map, V::top());\n+            }\n+        }\n+    }\n+\n+    pub fn assign(&mut self, target: PlaceRef<'_>, result: ValueOrPlace<V>, map: &Map) {\n+        if let Some(target) = map.find(target) {\n+            self.assign_idx(target, result, map);\n+        }\n+    }\n+\n+    pub fn assign_idx(&mut self, target: PlaceIndex, result: ValueOrPlace<V>, map: &Map) {\n+        match result {\n+            ValueOrPlace::Value(value) => {\n+                // FIXME: What if not all tracked projections are overwritten? Can this happen?\n+                if let Some(value_index) = map.places[target].value_index {\n+                    self.0[value_index] = value;\n+                }\n+            }\n+            ValueOrPlace::Place(source) => self.assign_place_idx(target, source, map),\n+            ValueOrPlace::Unknown => {\n+                self.flood_idx(target, map, V::top());\n+            }\n+        }\n+    }\n+\n+    pub fn get(&self, place: PlaceRef<'_>, map: &Map) -> V {\n+        map.find(place).map(|place| self.get_idx(place, map)).unwrap_or(V::top())\n+    }\n+\n+    pub fn get_idx(&self, place: PlaceIndex, map: &Map) -> V {\n+        map.places[place].value_index.map(|v| self.0[v].clone()).unwrap_or(V::top())\n+    }\n+}\n+\n+impl<V: JoinSemiLattice> JoinSemiLattice for State<V> {\n+    fn join(&mut self, other: &Self) -> bool {\n+        self.0.join(&other.0)\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct Map {\n+    locals: IndexVec<Local, Option<PlaceIndex>>,\n+    projections: FxHashMap<(PlaceIndex, ProjElem), PlaceIndex>,\n+    places: IndexVec<PlaceIndex, PlaceInfo>,\n+    value_count: usize,\n+}\n+\n+impl Map {\n+    pub fn new() -> Self {\n+        Self {\n+            locals: IndexVec::new(),\n+            projections: FxHashMap::default(),\n+            places: IndexVec::new(),\n+            value_count: 0,\n+        }\n+    }\n+\n+    /// Register all places with suitable types up to a certain derefence depth (to prevent cycles).\n+    pub fn register_with_filter<'tcx>(\n+        &mut self,\n+        tcx: TyCtxt<'tcx>,\n+        source: &impl HasLocalDecls<'tcx>,\n+        max_derefs: u32,\n+        mut filter: impl FnMut(Ty<'tcx>) -> bool,\n+    ) {\n+        let mut projection = Vec::new();\n+        for (local, decl) in source.local_decls().iter_enumerated() {\n+            self.register_with_filter_rec(\n+                tcx,\n+                max_derefs,\n+                local,\n+                &mut projection,\n+                decl.ty,\n+                &mut filter,\n+            );\n+        }\n+    }\n+\n+    fn register_with_filter_rec<'tcx>(\n+        &mut self,\n+        tcx: TyCtxt<'tcx>,\n+        max_derefs: u32,\n+        local: Local,\n+        projection: &mut Vec<PlaceElem<'tcx>>,\n+        ty: Ty<'tcx>,\n+        filter: &mut impl FnMut(Ty<'tcx>) -> bool,\n+    ) {\n+        if filter(ty) {\n+            self.register(local, projection)\n+                .expect(\"projection should only contain convertible elements\");\n+        }\n+        if max_derefs > 0 {\n+            if let Some(ty::TypeAndMut { ty, .. }) = ty.builtin_deref(false) {\n+                projection.push(PlaceElem::Deref);\n+                self.register_with_filter_rec(tcx, max_derefs - 1, local, projection, ty, filter);\n+                projection.pop();\n+            }\n+        }\n+        iter_fields(ty, tcx, |variant, field, ty| {\n+            if let Some(variant) = variant {\n+                projection.push(PlaceElem::Downcast(None, variant));\n+            }\n+            projection.push(PlaceElem::Field(field, ty));\n+            self.register_with_filter_rec(tcx, max_derefs, local, projection, ty, filter);\n+            projection.pop();\n+            if variant.is_some() {\n+                projection.pop();\n+            }\n+        });\n+    }\n+\n+    pub fn register<'tcx>(\n+        &mut self,\n+        local: Local,\n+        projection: &[PlaceElem<'tcx>],\n+    ) -> Result<(), ()> {\n+        // Get the base index of the local.\n+        let mut index =\n+            *self.locals.get_or_insert_with(local, || self.places.push(PlaceInfo::new(None)));\n+\n+        // Apply the projection.\n+        for &elem in projection {\n+            let elem = elem.try_into()?;\n+            index = *self.projections.entry((index, elem)).or_insert_with(|| {\n+                // Prepend new child to the linked list.\n+                let next = self.places.push(PlaceInfo::new(Some(elem)));\n+                self.places[next].next_sibling = self.places[index].first_child;\n+                self.places[index].first_child = Some(next);\n+                next\n+            });\n+        }\n+\n+        // Allocate a value slot if it doesn't have one.\n+        if self.places[index].value_index.is_none() {\n+            self.places[index].value_index = Some(self.value_count.into());\n+            self.value_count += 1;\n+        }\n+\n+        Ok(())\n+    }\n+\n+    pub fn apply_elem(&self, place: PlaceIndex, elem: ProjElem) -> Option<PlaceIndex> {\n+        self.projections.get(&(place, elem)).copied()\n+    }\n+\n+    pub fn find(&self, place: PlaceRef<'_>) -> Option<PlaceIndex> {\n+        let mut index = *self.locals.get(place.local)?.as_ref()?;\n+\n+        for &elem in place.projection {\n+            index = self.apply_elem(index, elem.try_into().ok()?)?;\n+        }\n+\n+        Some(index)\n+    }\n+\n+    pub fn children(&self, parent: PlaceIndex) -> impl Iterator<Item = PlaceIndex> + '_ {\n+        Children::new(self, parent)\n+    }\n+\n+    pub fn preorder_invoke(&self, root: PlaceIndex, f: &mut impl FnMut(PlaceIndex)) {\n+        f(root);\n+        for child in self.children(root) {\n+            self.preorder_invoke(child, f);\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct PlaceInfo {\n+    next_sibling: Option<PlaceIndex>,\n+    first_child: Option<PlaceIndex>,\n+    /// The projection used to go from parent to this node (only None for root).\n+    proj_elem: Option<ProjElem>,\n+    value_index: Option<ValueIndex>,\n+}\n+\n+impl PlaceInfo {\n+    fn new(proj_elem: Option<ProjElem>) -> Self {\n+        Self { next_sibling: None, first_child: None, proj_elem, value_index: None }\n+    }\n+}\n+\n+struct Children<'a> {\n+    map: &'a Map,\n+    next: Option<PlaceIndex>,\n+}\n+\n+impl<'a> Children<'a> {\n+    fn new(map: &'a Map, parent: PlaceIndex) -> Self {\n+        Self { map, next: map.places[parent].first_child }\n+    }\n+}\n+\n+impl<'a> Iterator for Children<'a> {\n+    type Item = PlaceIndex;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        match self.next {\n+            Some(child) => {\n+                self.next = self.map.places[child].next_sibling;\n+                Some(child)\n+            }\n+            None => None,\n+        }\n+    }\n+}\n+\n+// FIXME: See if we can get rid of `Unknown`.\n+pub enum ValueOrPlace<V> {\n+    Value(V),\n+    Place(PlaceIndex),\n+    Unknown,\n+}\n+\n+pub trait HasBottom {\n+    fn bottom() -> Self;\n+}\n+\n+pub trait HasTop {\n+    fn top() -> Self;\n+}\n+\n+impl<V> HasBottom for FlatSet<V> {\n+    fn bottom() -> Self {\n+        Self::Bottom\n+    }\n+}\n+\n+impl<V> HasTop for FlatSet<V> {\n+    fn top() -> Self {\n+        Self::Top\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum ProjElem {\n+    Deref,\n+    Field(Field),\n+    Downcast(VariantIdx),\n+}\n+\n+impl<V, T> TryFrom<ProjectionElem<V, T>> for ProjElem {\n+    type Error = ();\n+\n+    fn try_from(value: ProjectionElem<V, T>) -> Result<Self, Self::Error> {\n+        match value {\n+            ProjectionElem::Deref => Ok(ProjElem::Deref),\n+            ProjectionElem::Field(field, _) => Ok(ProjElem::Field(field)),\n+            ProjectionElem::Downcast(_, variant) => Ok(ProjElem::Downcast(variant)),\n+            _ => Err(()),\n+        }\n+    }\n+}\n+\n+fn iter_fields<'tcx>(\n+    ty: Ty<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    mut f: impl FnMut(Option<VariantIdx>, Field, Ty<'tcx>),\n+) {\n+    match ty.kind() {\n+        ty::Tuple(list) => {\n+            for (field, ty) in list.iter().enumerate() {\n+                f(None, field.into(), ty);\n+            }\n+        }\n+        ty::Adt(def, substs) => {\n+            for (v_index, v_def) in def.variants().iter_enumerated() {\n+                for (f_index, f_def) in v_def.fields.iter().enumerate() {\n+                    let field_ty = tcx.normalize_erasing_regions(\n+                        ty::ParamEnv::reveal_all(),\n+                        f_def.ty(tcx, substs),\n+                    );\n+                    f(Some(v_index), f_index.into(), field_ty);\n+                }\n+            }\n+        }\n+        ty::Closure(_, substs) => {\n+            iter_fields(substs.as_closure().tupled_upvars_ty(), tcx, f);\n+        }\n+        _ => (),\n+    }\n+}\n+\n+fn debug_with_context_rec<V: Debug + Eq>(\n+    place: PlaceIndex,\n+    place_str: &str,\n+    new: &State<V>,\n+    old: Option<&State<V>>,\n+    map: &Map,\n+    f: &mut Formatter<'_>,\n+) -> std::fmt::Result {\n+    if let Some(value) = map.places[place].value_index {\n+        match old {\n+            None => writeln!(f, \"{}: {:?}\", place_str, new.0[value])?,\n+            Some(old) => {\n+                if new.0[value] != old.0[value] {\n+                    writeln!(f, \"\\u{001f}-{}: {:?}\", place_str, old.0[value])?;\n+                    writeln!(f, \"\\u{001f}+{}: {:?}\", place_str, new.0[value])?;\n+                }\n+            }\n+        }\n+    }\n+\n+    for child in map.children(place) {\n+        let info_elem = map.places[child].proj_elem.unwrap();\n+        let child_place_str = match info_elem {\n+            ProjElem::Deref => format!(\"*{}\", place_str),\n+            ProjElem::Field(field) => {\n+                if place_str.starts_with(\"*\") {\n+                    format!(\"({}).{}\", place_str, field.index())\n+                } else {\n+                    format!(\"{}.{}\", place_str, field.index())\n+                }\n+            }\n+            ProjElem::Downcast(variant) => format!(\"({} as #{})\", place_str, variant.index()),\n+        };\n+        debug_with_context_rec(child, &child_place_str, new, old, map, f)?;\n+    }\n+\n+    Ok(())\n+}\n+\n+fn debug_with_context<V: Debug + Eq>(\n+    new: &State<V>,\n+    old: Option<&State<V>>,\n+    map: &Map,\n+    f: &mut Formatter<'_>,\n+) -> std::fmt::Result {\n+    for (local, place) in map.locals.iter_enumerated() {\n+        if let Some(place) = place {\n+            debug_with_context_rec(*place, &format!(\"{:?}\", local), new, old, map, f)?;\n+        }\n+    }\n+    Ok(())\n+}\n+\n+impl<'tcx, T> DebugWithContext<ValueAnalysisWrapper<T>> for State<T::Value>\n+where\n+    T: ValueAnalysis<'tcx>,\n+    T::Value: Debug,\n+{\n+    fn fmt_with(&self, ctxt: &ValueAnalysisWrapper<T>, f: &mut Formatter<'_>) -> std::fmt::Result {\n+        debug_with_context(self, None, ctxt.0.map(), f)\n+    }\n+\n+    fn fmt_diff_with(\n+        &self,\n+        old: &Self,\n+        ctxt: &ValueAnalysisWrapper<T>,\n+        f: &mut Formatter<'_>,\n+    ) -> std::fmt::Result {\n+        debug_with_context(self, Some(old), ctxt.0.map(), f)\n+    }\n+}"}, {"sha": "f1220f634acf2639db4fe8bcd5512ffc10aeea4f", "filename": "compiler/rustc_mir_transform/src/dataflow_const_prop.rs", "status": "added", "additions": 490, "deletions": 0, "changes": 490, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c30fb676482a5148f28c0728b5280246a9886/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c30fb676482a5148f28c0728b5280246a9886/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs?ref=4f9c30fb676482a5148f28c0728b5280246a9886", "patch": "@@ -0,0 +1,490 @@\n+use rustc_const_eval::interpret::{ConstValue, ImmTy, Immediate, InterpCx, Scalar};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_middle::mir::visit::{MutVisitor, Visitor};\n+use rustc_middle::mir::*;\n+use rustc_middle::ty::{self, ScalarInt, Ty, TyCtxt};\n+use rustc_mir_dataflow::value_analysis::{Map, ProjElem, State, ValueAnalysis, ValueOrPlace};\n+use rustc_mir_dataflow::{lattice::FlatSet, Analysis, ResultsVisitor, SwitchIntEdgeEffects};\n+use rustc_span::DUMMY_SP;\n+\n+use crate::MirPass;\n+\n+pub struct DataflowConstProp;\n+\n+impl<'tcx> MirPass<'tcx> for DataflowConstProp {\n+    fn is_enabled(&self, sess: &rustc_session::Session) -> bool {\n+        // Choose different minimum level?\n+        sess.mir_opt_level() >= 4\n+    }\n+\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        // Decide which places to track during the analysis.\n+        let mut map = Map::new();\n+        map.register_with_filter(tcx, body, 3, |ty| ty.is_scalar() && !ty.is_unsafe_ptr());\n+\n+        // Perform the actual dataflow analysis.\n+        let analysis = ConstAnalysis::new(tcx, body, map);\n+        let results = analysis.wrap().into_engine(tcx, body).iterate_to_fixpoint();\n+\n+        // Collect results and patch the body afterwards.\n+        let mut visitor = CollectAndPatch::new(tcx, &results.analysis.0.map);\n+        results.visit_reachable_with(body, &mut visitor);\n+        visitor.visit_body(body);\n+    }\n+}\n+\n+// FIXME: Consider support for discriminants, mutable references, arrays and slices.\n+struct ConstAnalysis<'tcx> {\n+    map: Map,\n+    tcx: TyCtxt<'tcx>,\n+    ecx: InterpCx<'tcx, 'tcx, DummyMachine>,\n+    param_env: ty::ParamEnv<'tcx>,\n+}\n+\n+impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'tcx> {\n+    type Value = FlatSet<Const<'tcx>>;\n+\n+    const NAME: &'static str = \"ConstAnalysis\";\n+\n+    fn map(&self) -> &Map {\n+        &self.map\n+    }\n+\n+    fn handle_assign(\n+        &self,\n+        target: Place<'tcx>,\n+        rvalue: &Rvalue<'tcx>,\n+        state: &mut State<Self::Value>,\n+    ) {\n+        match rvalue {\n+            Rvalue::CheckedBinaryOp(op, box (left, right)) => {\n+                let target = self.map().find(target.as_ref());\n+                let value_target = target.and_then(|target| {\n+                    self.map().apply_elem(target, ProjElem::Field(0_u32.into()))\n+                });\n+                let overflow_target = target.and_then(|target| {\n+                    self.map().apply_elem(target, ProjElem::Field(1_u32.into()))\n+                });\n+\n+                if value_target.is_some() || overflow_target.is_some() {\n+                    let (val, overflow) = self.binary_op(state, *op, left, right);\n+\n+                    if let Some(value_target) = value_target {\n+                        state.assign_idx(value_target, ValueOrPlace::Value(val), self.map());\n+                    }\n+                    if let Some(overflow_target) = overflow_target {\n+                        state.assign_idx(\n+                            overflow_target,\n+                            ValueOrPlace::Value(overflow),\n+                            self.map(),\n+                        );\n+                    }\n+                }\n+            }\n+            _ => self.super_assign(target, rvalue, state),\n+        }\n+    }\n+\n+    fn handle_rvalue(\n+        &self,\n+        rvalue: &Rvalue<'tcx>,\n+        state: &mut State<Self::Value>,\n+    ) -> ValueOrPlace<Self::Value> {\n+        match rvalue {\n+            Rvalue::Cast(CastKind::Misc, operand, ty) => {\n+                let operand = self.eval_operand(operand, state);\n+                match operand {\n+                    FlatSet::Elem(operand) => self\n+                        .ecx\n+                        .misc_cast(&operand, *ty)\n+                        .map(|result| ValueOrPlace::Value(self.wrap_immediate(result, *ty)))\n+                        .unwrap_or(ValueOrPlace::Unknown),\n+                    _ => ValueOrPlace::Unknown,\n+                }\n+            }\n+            Rvalue::BinaryOp(op, box (left, right)) => {\n+                let (val, _overflow) = self.binary_op(state, *op, left, right);\n+                // FIXME: Just ignore overflow here?\n+                ValueOrPlace::Value(val)\n+            }\n+            Rvalue::UnaryOp(op, operand) => match self.eval_operand(operand, state) {\n+                FlatSet::Elem(value) => self\n+                    .ecx\n+                    .unary_op(*op, &value)\n+                    .map(|val| ValueOrPlace::Value(self.wrap_immty(val)))\n+                    .unwrap_or(ValueOrPlace::Value(FlatSet::Top)),\n+                FlatSet::Bottom => ValueOrPlace::Value(FlatSet::Bottom),\n+                FlatSet::Top => ValueOrPlace::Value(FlatSet::Top),\n+            },\n+            _ => self.super_rvalue(rvalue, state),\n+        }\n+    }\n+\n+    fn handle_constant(\n+        &self,\n+        constant: &Constant<'tcx>,\n+        _state: &mut State<Self::Value>,\n+    ) -> Self::Value {\n+        constant\n+            .literal\n+            .eval(self.tcx, self.param_env)\n+            .try_to_scalar()\n+            .and_then(|scalar| scalar.try_to_int().ok())\n+            .map(|value| FlatSet::Elem(Const::Scalar(value, constant.ty())))\n+            .unwrap_or(FlatSet::Top)\n+    }\n+\n+    fn handle_switch_int(\n+        &self,\n+        discr: &Operand<'tcx>,\n+        apply_edge_effects: &mut impl SwitchIntEdgeEffects<State<Self::Value>>,\n+    ) {\n+        // FIXME: The dataflow framework only provides the state if we call `apply()`, which makes\n+        // this more inefficient than it has to be.\n+        // FIXME: Perhaps we rather need a proper unreachability flag for every block.\n+        let mut discr_value = None;\n+        let mut handled = false;\n+        apply_edge_effects.apply(|state, target| {\n+            let discr_value = match discr_value {\n+                Some(value) => value,\n+                None => {\n+                    let value = match self.handle_operand(discr, state) {\n+                        ValueOrPlace::Value(value) => value,\n+                        ValueOrPlace::Place(place) => state.get_idx(place, self.map()),\n+                        ValueOrPlace::Unknown => FlatSet::Top,\n+                    };\n+                    let result = match value {\n+                        FlatSet::Top => FlatSet::Top,\n+                        FlatSet::Elem(Const::Scalar(scalar, _)) => {\n+                            FlatSet::Elem(scalar.assert_bits(scalar.size()))\n+                        }\n+                        FlatSet::Bottom => FlatSet::Bottom,\n+                    };\n+                    discr_value = Some(result);\n+                    result\n+                }\n+            };\n+\n+            let FlatSet::Elem(choice) = discr_value else {\n+                // Do nothing if we don't know which branch will be taken.\n+                return\n+            };\n+\n+            if target.value.map(|n| n == choice).unwrap_or(!handled) {\n+                // Branch is taken. Has no effect on state.\n+                handled = true;\n+            } else {\n+                // Branch is not taken, we can flood everything.\n+                state.flood_all(FlatSet::Bottom);\n+            }\n+        })\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq)]\n+enum Const<'tcx> {\n+    // FIXME: If there won't be any other cases, make it a struct.\n+    Scalar(ScalarInt, Ty<'tcx>),\n+}\n+\n+impl<'tcx> std::fmt::Debug for Const<'tcx> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match *self {\n+            Self::Scalar(scalar, ty) => {\n+                std::fmt::Display::fmt(&ConstantKind::Val(ConstValue::Scalar(scalar.into()), ty), f)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> ConstAnalysis<'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, map: Map) -> Self {\n+        Self {\n+            map,\n+            tcx,\n+            ecx: InterpCx::new(tcx, DUMMY_SP, ty::ParamEnv::empty(), DummyMachine),\n+            param_env: tcx.param_env(body.source.def_id()),\n+        }\n+    }\n+\n+    fn binary_op(\n+        &self,\n+        state: &mut State<FlatSet<Const<'tcx>>>,\n+        op: BinOp,\n+        left: &Operand<'tcx>,\n+        right: &Operand<'tcx>,\n+    ) -> (FlatSet<Const<'tcx>>, FlatSet<Const<'tcx>>) {\n+        let left = self.eval_operand(left, state);\n+        let right = self.eval_operand(right, state);\n+        match (left, right) {\n+            (FlatSet::Elem(left), FlatSet::Elem(right)) => {\n+                match self.ecx.overflowing_binary_op(op, &left, &right) {\n+                    Ok((val, overflow, ty)) => {\n+                        let val = val\n+                            .try_to_int()\n+                            .ok()\n+                            .map(|val| self.wrap_scalar(val, ty))\n+                            .unwrap_or(FlatSet::Top);\n+                        let overflow = self.wrap_scalar(overflow.into(), self.tcx.types.bool);\n+                        (val, overflow)\n+                    }\n+                    _ => (FlatSet::Top, FlatSet::Top),\n+                }\n+            }\n+            (FlatSet::Bottom, _) | (_, FlatSet::Bottom) => (FlatSet::Bottom, FlatSet::Bottom),\n+            (_, _) => {\n+                // Could attempt some algebraic simplifcations here.\n+                (FlatSet::Top, FlatSet::Top)\n+            }\n+        }\n+    }\n+\n+    fn eval_operand(\n+        &self,\n+        op: &Operand<'tcx>,\n+        state: &mut State<FlatSet<Const<'tcx>>>,\n+    ) -> FlatSet<ImmTy<'tcx>> {\n+        let value = match self.handle_operand(op, state) {\n+            ValueOrPlace::Value(value) => value,\n+            ValueOrPlace::Place(place) => state.get_idx(place, &self.map),\n+            ValueOrPlace::Unknown => FlatSet::Top,\n+        };\n+        match value {\n+            FlatSet::Top => FlatSet::Top,\n+            FlatSet::Elem(Const::Scalar(value, ty)) => {\n+                let layout = self\n+                    .tcx\n+                    .layout_of(ty::ParamEnv::empty().and(ty))\n+                    .expect(\"this should not happen\"); // FIXME\n+                FlatSet::Elem(ImmTy::from_scalar(value.into(), layout))\n+            }\n+            FlatSet::Bottom => FlatSet::Bottom,\n+        }\n+    }\n+\n+    fn wrap_scalar(&self, scalar: ScalarInt, ty: Ty<'tcx>) -> FlatSet<Const<'tcx>> {\n+        FlatSet::Elem(Const::Scalar(scalar, ty))\n+    }\n+\n+    fn wrap_immediate(&self, imm: Immediate, ty: Ty<'tcx>) -> FlatSet<Const<'tcx>> {\n+        match imm {\n+            Immediate::Scalar(Scalar::Int(scalar)) => self.wrap_scalar(scalar, ty),\n+            _ => FlatSet::Top,\n+        }\n+    }\n+\n+    fn wrap_immty(&self, val: ImmTy<'tcx>) -> FlatSet<Const<'tcx>> {\n+        self.wrap_immediate(*val, val.layout.ty)\n+    }\n+}\n+\n+struct CollectAndPatch<'tcx, 'map> {\n+    tcx: TyCtxt<'tcx>,\n+    map: &'map Map,\n+    before_effect: FxHashMap<(Location, Place<'tcx>), Const<'tcx>>,\n+    assignments: FxHashMap<Location, Const<'tcx>>,\n+}\n+\n+impl<'tcx, 'map> CollectAndPatch<'tcx, 'map> {\n+    fn new(tcx: TyCtxt<'tcx>, map: &'map Map) -> Self {\n+        Self { tcx, map, before_effect: FxHashMap::default(), assignments: FxHashMap::default() }\n+    }\n+\n+    fn make_operand(&self, constant: Const<'tcx>) -> Operand<'tcx> {\n+        let Const::Scalar(scalar, ty) = constant;\n+        Operand::Constant(Box::new(Constant {\n+            span: DUMMY_SP,\n+            user_ty: None,\n+            literal: ConstantKind::Val(ConstValue::Scalar(scalar.into()), ty),\n+        }))\n+    }\n+}\n+\n+impl<'mir, 'tcx, 'map> ResultsVisitor<'mir, 'tcx> for CollectAndPatch<'tcx, 'map> {\n+    type FlowState = State<FlatSet<Const<'tcx>>>;\n+\n+    fn visit_statement_before_primary_effect(\n+        &mut self,\n+        state: &Self::FlowState,\n+        statement: &'mir Statement<'tcx>,\n+        location: Location,\n+    ) {\n+        match &statement.kind {\n+            StatementKind::Assign(box (_, rvalue)) => {\n+                OperandCollector { state, visitor: self }.visit_rvalue(rvalue, location);\n+            }\n+            _ => (),\n+        }\n+    }\n+\n+    fn visit_statement_after_primary_effect(\n+        &mut self,\n+        state: &Self::FlowState,\n+        statement: &'mir Statement<'tcx>,\n+        location: Location,\n+    ) {\n+        match statement.kind {\n+            StatementKind::Assign(box (place, _)) => match state.get(place.as_ref(), self.map) {\n+                FlatSet::Top => (),\n+                FlatSet::Elem(value) => {\n+                    self.assignments.insert(location, value);\n+                }\n+                FlatSet::Bottom => {\n+                    // This statement is not reachable. Do nothing, it will (hopefully) be removed.\n+                }\n+            },\n+            _ => (),\n+        }\n+    }\n+\n+    fn visit_terminator_before_primary_effect(\n+        &mut self,\n+        state: &Self::FlowState,\n+        terminator: &'mir Terminator<'tcx>,\n+        location: Location,\n+    ) {\n+        OperandCollector { state, visitor: self }.visit_terminator(terminator, location);\n+    }\n+}\n+\n+impl<'tcx, 'map> MutVisitor<'tcx> for CollectAndPatch<'tcx, 'map> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn visit_statement(&mut self, statement: &mut Statement<'tcx>, location: Location) {\n+        if let Some(value) = self.assignments.get(&location) {\n+            match &mut statement.kind {\n+                StatementKind::Assign(box (_, rvalue)) => {\n+                    *rvalue = Rvalue::Use(self.make_operand(value.clone()));\n+                }\n+                _ => bug!(\"found assignment info for non-assign statement\"),\n+            }\n+        } else {\n+            self.super_statement(statement, location);\n+        }\n+    }\n+\n+    fn visit_operand(&mut self, operand: &mut Operand<'tcx>, location: Location) {\n+        match operand {\n+            Operand::Copy(place) | Operand::Move(place) => {\n+                if let Some(value) = self.before_effect.get(&(location, *place)) {\n+                    *operand = self.make_operand(value.clone());\n+                }\n+            }\n+            _ => (),\n+        }\n+    }\n+}\n+\n+struct OperandCollector<'tcx, 'map, 'a> {\n+    state: &'a State<FlatSet<Const<'tcx>>>,\n+    visitor: &'a mut CollectAndPatch<'tcx, 'map>,\n+}\n+\n+impl<'tcx, 'map, 'a> Visitor<'tcx> for OperandCollector<'tcx, 'map, 'a> {\n+    fn visit_operand(&mut self, operand: &Operand<'tcx>, location: Location) {\n+        match operand {\n+            Operand::Copy(place) | Operand::Move(place) => {\n+                match self.state.get(place.as_ref(), self.visitor.map) {\n+                    FlatSet::Top => (),\n+                    FlatSet::Elem(value) => {\n+                        self.visitor.before_effect.insert((location, *place), value);\n+                    }\n+                    FlatSet::Bottom => {\n+                        // This only happens if this location is unreachable.\n+                    }\n+                }\n+            }\n+            _ => (),\n+        }\n+    }\n+}\n+\n+struct DummyMachine;\n+\n+impl<'mir, 'tcx> rustc_const_eval::interpret::Machine<'mir, 'tcx> for DummyMachine {\n+    rustc_const_eval::interpret::compile_time_machine!(<'mir, 'tcx>);\n+    type MemoryKind = !;\n+    const PANIC_ON_ALLOC_FAIL: bool = true;\n+\n+    fn enforce_alignment(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n+        unimplemented!()\n+    }\n+\n+    fn enforce_validity(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n+        unimplemented!()\n+    }\n+\n+    fn find_mir_or_eval_fn(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _instance: ty::Instance<'tcx>,\n+        _abi: rustc_target::spec::abi::Abi,\n+        _args: &[rustc_const_eval::interpret::OpTy<'tcx, Self::Provenance>],\n+        _destination: &rustc_const_eval::interpret::PlaceTy<'tcx, Self::Provenance>,\n+        _target: Option<BasicBlock>,\n+        _unwind: rustc_const_eval::interpret::StackPopUnwind,\n+    ) -> interpret::InterpResult<'tcx, Option<(&'mir Body<'tcx>, ty::Instance<'tcx>)>> {\n+        unimplemented!()\n+    }\n+\n+    fn call_intrinsic(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _instance: ty::Instance<'tcx>,\n+        _args: &[rustc_const_eval::interpret::OpTy<'tcx, Self::Provenance>],\n+        _destination: &rustc_const_eval::interpret::PlaceTy<'tcx, Self::Provenance>,\n+        _target: Option<BasicBlock>,\n+        _unwind: rustc_const_eval::interpret::StackPopUnwind,\n+    ) -> interpret::InterpResult<'tcx> {\n+        unimplemented!()\n+    }\n+\n+    fn assert_panic(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _msg: &rustc_middle::mir::AssertMessage<'tcx>,\n+        _unwind: Option<BasicBlock>,\n+    ) -> interpret::InterpResult<'tcx> {\n+        unimplemented!()\n+    }\n+\n+    fn binary_ptr_op(\n+        _ecx: &InterpCx<'mir, 'tcx, Self>,\n+        _bin_op: BinOp,\n+        _left: &rustc_const_eval::interpret::ImmTy<'tcx, Self::Provenance>,\n+        _right: &rustc_const_eval::interpret::ImmTy<'tcx, Self::Provenance>,\n+    ) -> interpret::InterpResult<'tcx, (interpret::Scalar<Self::Provenance>, bool, Ty<'tcx>)> {\n+        unimplemented!()\n+    }\n+\n+    fn expose_ptr(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _ptr: interpret::Pointer<Self::Provenance>,\n+    ) -> interpret::InterpResult<'tcx> {\n+        unimplemented!()\n+    }\n+\n+    fn init_frame_extra(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _frame: rustc_const_eval::interpret::Frame<'mir, 'tcx, Self::Provenance>,\n+    ) -> interpret::InterpResult<\n+        'tcx,\n+        rustc_const_eval::interpret::Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>,\n+    > {\n+        unimplemented!()\n+    }\n+\n+    fn stack<'a>(\n+        _ecx: &'a InterpCx<'mir, 'tcx, Self>,\n+    ) -> &'a [rustc_const_eval::interpret::Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>]\n+    {\n+        unimplemented!()\n+    }\n+\n+    fn stack_mut<'a>(\n+        _ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n+    ) -> &'a mut Vec<\n+        rustc_const_eval::interpret::Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>,\n+    > {\n+        unimplemented!()\n+    }\n+}"}, {"sha": "692eeddfb98578da5f02f4c1133e6b3461bfa77a", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c30fb676482a5148f28c0728b5280246a9886/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c30fb676482a5148f28c0728b5280246a9886/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=4f9c30fb676482a5148f28c0728b5280246a9886", "patch": "@@ -54,6 +54,7 @@ mod const_goto;\n mod const_prop;\n mod const_prop_lint;\n mod coverage;\n+mod dataflow_const_prop;\n mod dead_store_elimination;\n mod deaggregator;\n mod deduce_param_attrs;\n@@ -569,6 +570,7 @@ fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n             //\n             // FIXME(#70073): This pass is responsible for both optimization as well as some lints.\n             &const_prop::ConstProp,\n+            &dataflow_const_prop::DataflowConstProp,\n             //\n             // Const-prop runs unconditionally, but doesn't mutate the MIR at mir-opt-level=0.\n             &const_debuginfo::ConstDebugInfo,"}, {"sha": "950b0518e0bb2407f671f0c2920630a3a1f91c92", "filename": "src/test/mir-opt/dataflow-const-prop/cast.main.DataflowConstProp.diff", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fcast.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fcast.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fcast.main.DataflowConstProp.diff?ref=4f9c30fb676482a5148f28c0728b5280246a9886", "patch": "@@ -0,0 +1,41 @@\n+- // MIR for `main` before DataflowConstProp\n++ // MIR for `main` after DataflowConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/cast.rs:+0:11: +0:11\n+      let _1: i32;                         // in scope 0 at $DIR/cast.rs:+1:9: +1:10\n+      let mut _3: u8;                      // in scope 0 at $DIR/cast.rs:+2:13: +2:22\n+      let mut _4: i32;                     // in scope 0 at $DIR/cast.rs:+2:13: +2:16\n+      let mut _5: &i32;                    // in scope 0 at $DIR/cast.rs:+2:14: +2:16\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/cast.rs:+1:9: +1:10\n+          let _2: u8;                      // in scope 1 at $DIR/cast.rs:+2:9: +2:10\n+          scope 2 {\n+              debug b => _2;               // in scope 2 at $DIR/cast.rs:+2:9: +2:10\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/cast.rs:+1:9: +1:10\n+          _1 = const 257_i32;              // scope 0 at $DIR/cast.rs:+1:13: +1:16\n+          StorageLive(_2);                 // scope 1 at $DIR/cast.rs:+2:9: +2:10\n+          StorageLive(_3);                 // scope 1 at $DIR/cast.rs:+2:13: +2:22\n+          StorageLive(_4);                 // scope 1 at $DIR/cast.rs:+2:13: +2:16\n+          StorageLive(_5);                 // scope 1 at $DIR/cast.rs:+2:14: +2:16\n+          _5 = &_1;                        // scope 1 at $DIR/cast.rs:+2:14: +2:16\n+-         _4 = (*_5);                      // scope 1 at $DIR/cast.rs:+2:13: +2:16\n+-         _3 = move _4 as u8 (Misc);       // scope 1 at $DIR/cast.rs:+2:13: +2:22\n++         _4 = const 257_i32;              // scope 1 at $DIR/cast.rs:+2:13: +2:16\n++         _3 = const 1_u8;                 // scope 1 at $DIR/cast.rs:+2:13: +2:22\n+          StorageDead(_4);                 // scope 1 at $DIR/cast.rs:+2:21: +2:22\n+-         _2 = Add(move _3, const 1_u8);   // scope 1 at $DIR/cast.rs:+2:13: +2:26\n++         _2 = const 2_u8;                 // scope 1 at $DIR/cast.rs:+2:13: +2:26\n+          StorageDead(_3);                 // scope 1 at $DIR/cast.rs:+2:25: +2:26\n+          StorageDead(_5);                 // scope 1 at $DIR/cast.rs:+2:26: +2:27\n+          _0 = const ();                   // scope 0 at $DIR/cast.rs:+0:11: +3:2\n+          StorageDead(_2);                 // scope 1 at $DIR/cast.rs:+3:1: +3:2\n+          StorageDead(_1);                 // scope 0 at $DIR/cast.rs:+3:1: +3:2\n+          return;                          // scope 0 at $DIR/cast.rs:+3:2: +3:2\n+      }\n+  }\n+  "}, {"sha": "bf5838cb89dd1db62c955c5fefd12d4a5c6f8669", "filename": "src/test/mir-opt/dataflow-const-prop/cast.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fcast.rs?ref=4f9c30fb676482a5148f28c0728b5280246a9886", "patch": "@@ -0,0 +1,7 @@\n+// unit-test: DataflowConstProp\n+\n+// EMIT_MIR cast.main.DataflowConstProp.diff\n+fn main() {\n+    let a = 257;\n+    let b = *&a as u8 + 1;\n+}"}, {"sha": "e947f084970684a62454a8b2d2892e84e11b1a12", "filename": "src/test/mir-opt/dataflow-const-prop/cell.main.DataflowConstProp.diff", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fcell.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fcell.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fcell.main.DataflowConstProp.diff?ref=4f9c30fb676482a5148f28c0728b5280246a9886", "patch": "@@ -0,0 +1,12 @@\n+- // MIR for `main` before DataflowConstProp\n++ // MIR for `main` after DataflowConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/cell.rs:+0:11: +0:11\n+  \n+      bb0: {\n+          _0 = const ();                   // scope 0 at $DIR/cell.rs:+0:11: +2:2\n+          return;                          // scope 0 at $DIR/cell.rs:+2:2: +2:2\n+      }\n+  }\n+  "}, {"sha": "82a4c3465959b1b6f0dcc4189b22d0f9049e0dc3", "filename": "src/test/mir-opt/dataflow-const-prop/cell.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fcell.rs?ref=4f9c30fb676482a5148f28c0728b5280246a9886", "patch": "@@ -0,0 +1,6 @@\n+// unit-test: DataflowConstProp\n+\n+// EMIT_MIR cell.main.DataflowConstProp.diff\n+fn main() {\n+    // FIXME: Is it possible to build something with UnsafeCell?\n+}"}, {"sha": "39bc506adaceabb539cefbaaee298c572d4c25e1", "filename": "src/test/mir-opt/dataflow-const-prop/checked.main.DataflowConstProp.diff", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fchecked.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fchecked.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fchecked.main.DataflowConstProp.diff?ref=4f9c30fb676482a5148f28c0728b5280246a9886", "patch": "@@ -0,0 +1,81 @@\n+- // MIR for `main` before DataflowConstProp\n++ // MIR for `main` after DataflowConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/checked.rs:+0:11: +0:11\n+      let _1: i32;                         // in scope 0 at $DIR/checked.rs:+1:9: +1:10\n+      let mut _4: i32;                     // in scope 0 at $DIR/checked.rs:+3:13: +3:14\n+      let mut _5: i32;                     // in scope 0 at $DIR/checked.rs:+3:17: +3:18\n+      let mut _6: (i32, bool);             // in scope 0 at $DIR/checked.rs:+3:13: +3:18\n+      let mut _9: i32;                     // in scope 0 at $DIR/checked.rs:+6:13: +6:14\n+      let mut _10: (i32, bool);            // in scope 0 at $DIR/checked.rs:+6:13: +6:18\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/checked.rs:+1:9: +1:10\n+          let _2: i32;                     // in scope 1 at $DIR/checked.rs:+2:9: +2:10\n+          scope 2 {\n+              debug b => _2;               // in scope 2 at $DIR/checked.rs:+2:9: +2:10\n+              let _3: i32;                 // in scope 2 at $DIR/checked.rs:+3:9: +3:10\n+              scope 3 {\n+                  debug c => _3;           // in scope 3 at $DIR/checked.rs:+3:9: +3:10\n+                  let _7: i32;             // in scope 3 at $DIR/checked.rs:+5:9: +5:10\n+                  scope 4 {\n+                      debug d => _7;       // in scope 4 at $DIR/checked.rs:+5:9: +5:10\n+                      let _8: i32;         // in scope 4 at $DIR/checked.rs:+6:9: +6:10\n+                      scope 5 {\n+                          debug e => _8;   // in scope 5 at $DIR/checked.rs:+6:9: +6:10\n+                      }\n+                  }\n+              }\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/checked.rs:+1:9: +1:10\n+          _1 = const 1_i32;                // scope 0 at $DIR/checked.rs:+1:13: +1:14\n+          StorageLive(_2);                 // scope 1 at $DIR/checked.rs:+2:9: +2:10\n+          _2 = const 2_i32;                // scope 1 at $DIR/checked.rs:+2:13: +2:14\n+          StorageLive(_3);                 // scope 2 at $DIR/checked.rs:+3:9: +3:10\n+          StorageLive(_4);                 // scope 2 at $DIR/checked.rs:+3:13: +3:14\n+-         _4 = _1;                         // scope 2 at $DIR/checked.rs:+3:13: +3:14\n++         _4 = const 1_i32;                // scope 2 at $DIR/checked.rs:+3:13: +3:14\n+          StorageLive(_5);                 // scope 2 at $DIR/checked.rs:+3:17: +3:18\n+-         _5 = _2;                         // scope 2 at $DIR/checked.rs:+3:17: +3:18\n+-         _6 = CheckedAdd(_4, _5);         // scope 2 at $DIR/checked.rs:+3:13: +3:18\n+-         assert(!move (_6.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _4, move _5) -> bb1; // scope 2 at $DIR/checked.rs:+3:13: +3:18\n++         _5 = const 2_i32;                // scope 2 at $DIR/checked.rs:+3:17: +3:18\n++         _6 = CheckedAdd(const 1_i32, const 2_i32); // scope 2 at $DIR/checked.rs:+3:13: +3:18\n++         assert(!const false, \"attempt to compute `{} + {}`, which would overflow\", const 1_i32, const 2_i32) -> bb1; // scope 2 at $DIR/checked.rs:+3:13: +3:18\n+      }\n+  \n+      bb1: {\n+-         _3 = move (_6.0: i32);           // scope 2 at $DIR/checked.rs:+3:13: +3:18\n++         _3 = const 3_i32;                // scope 2 at $DIR/checked.rs:+3:13: +3:18\n+          StorageDead(_5);                 // scope 2 at $DIR/checked.rs:+3:17: +3:18\n+          StorageDead(_4);                 // scope 2 at $DIR/checked.rs:+3:17: +3:18\n+          StorageLive(_7);                 // scope 3 at $DIR/checked.rs:+5:9: +5:10\n+-         _7 = const core::num::<impl i32>::MAX; // scope 3 at $DIR/checked.rs:+5:13: +5:21\n++         _7 = const i32::MAX;             // scope 3 at $DIR/checked.rs:+5:13: +5:21\n+          StorageLive(_8);                 // scope 4 at $DIR/checked.rs:+6:9: +6:10\n+          StorageLive(_9);                 // scope 4 at $DIR/checked.rs:+6:13: +6:14\n+-         _9 = _7;                         // scope 4 at $DIR/checked.rs:+6:13: +6:14\n+-         _10 = CheckedAdd(_9, const 1_i32); // scope 4 at $DIR/checked.rs:+6:13: +6:18\n+-         assert(!move (_10.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _9, const 1_i32) -> bb2; // scope 4 at $DIR/checked.rs:+6:13: +6:18\n++         _9 = const i32::MAX;             // scope 4 at $DIR/checked.rs:+6:13: +6:14\n++         _10 = CheckedAdd(const i32::MAX, const 1_i32); // scope 4 at $DIR/checked.rs:+6:13: +6:18\n++         assert(!const true, \"attempt to compute `{} + {}`, which would overflow\", const i32::MAX, const 1_i32) -> bb2; // scope 4 at $DIR/checked.rs:+6:13: +6:18\n+      }\n+  \n+      bb2: {\n+-         _8 = move (_10.0: i32);          // scope 4 at $DIR/checked.rs:+6:13: +6:18\n++         _8 = const i32::MIN;             // scope 4 at $DIR/checked.rs:+6:13: +6:18\n+          StorageDead(_9);                 // scope 4 at $DIR/checked.rs:+6:17: +6:18\n+          _0 = const ();                   // scope 0 at $DIR/checked.rs:+0:11: +7:2\n+          StorageDead(_8);                 // scope 4 at $DIR/checked.rs:+7:1: +7:2\n+          StorageDead(_7);                 // scope 3 at $DIR/checked.rs:+7:1: +7:2\n+          StorageDead(_3);                 // scope 2 at $DIR/checked.rs:+7:1: +7:2\n+          StorageDead(_2);                 // scope 1 at $DIR/checked.rs:+7:1: +7:2\n+          StorageDead(_1);                 // scope 0 at $DIR/checked.rs:+7:1: +7:2\n+          return;                          // scope 0 at $DIR/checked.rs:+7:2: +7:2\n+      }\n+  }\n+  "}, {"sha": "ae457af72c0663c6b027aa275b2e8395e793db2f", "filename": "src/test/mir-opt/dataflow-const-prop/checked.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fchecked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fchecked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fchecked.rs?ref=4f9c30fb676482a5148f28c0728b5280246a9886", "patch": "@@ -0,0 +1,13 @@\n+// unit-test: DataflowConstProp\n+// compile-flags: -C overflow-checks=on\n+\n+// EMIT_MIR checked.main.DataflowConstProp.diff\n+#[allow(arithmetic_overflow)]\n+fn main() {\n+    let a = 1;\n+    let b = 2;\n+    let c = a + b;\n+\n+    let d = i32::MAX;\n+    let e = d + 1;\n+}"}, {"sha": "951e5c5b9ad4e0b8fe5c30582464a80a7979f3a7", "filename": "src/test/mir-opt/dataflow-const-prop/if.main.DataflowConstProp.diff", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fif.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fif.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fif.main.DataflowConstProp.diff?ref=4f9c30fb676482a5148f28c0728b5280246a9886", "patch": "@@ -0,0 +1,118 @@\n+- // MIR for `main` before DataflowConstProp\n++ // MIR for `main` after DataflowConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/if.rs:+0:11: +0:11\n+      let _1: i32;                         // in scope 0 at $DIR/if.rs:+2:9: +2:10\n+      let mut _3: bool;                    // in scope 0 at $DIR/if.rs:+3:16: +3:24\n+      let mut _4: i32;                     // in scope 0 at $DIR/if.rs:+3:16: +3:19\n+      let mut _5: &i32;                    // in scope 0 at $DIR/if.rs:+3:17: +3:19\n+      let mut _7: i32;                     // in scope 0 at $DIR/if.rs:+4:13: +4:14\n+      let mut _9: bool;                    // in scope 0 at $DIR/if.rs:+6:16: +6:24\n+      let mut _10: i32;                    // in scope 0 at $DIR/if.rs:+6:16: +6:19\n+      let mut _11: &i32;                   // in scope 0 at $DIR/if.rs:+6:17: +6:19\n+      let mut _12: i32;                    // in scope 0 at $DIR/if.rs:+6:38: +6:39\n+      let mut _14: i32;                    // in scope 0 at $DIR/if.rs:+7:13: +7:14\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/if.rs:+2:9: +2:10\n+          let _2: i32;                     // in scope 1 at $DIR/if.rs:+3:9: +3:10\n+          scope 2 {\n+              debug b => _2;               // in scope 2 at $DIR/if.rs:+3:9: +3:10\n+              let _6: i32;                 // in scope 2 at $DIR/if.rs:+4:9: +4:10\n+              scope 3 {\n+                  debug c => _6;           // in scope 3 at $DIR/if.rs:+4:9: +4:10\n+                  let _8: i32;             // in scope 3 at $DIR/if.rs:+6:9: +6:10\n+                  scope 4 {\n+                      debug d => _8;       // in scope 4 at $DIR/if.rs:+6:9: +6:10\n+                      let _13: i32;        // in scope 4 at $DIR/if.rs:+7:9: +7:10\n+                      scope 5 {\n+                          debug e => _13;  // in scope 5 at $DIR/if.rs:+7:9: +7:10\n+                      }\n+                  }\n+              }\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/if.rs:+2:9: +2:10\n+          _1 = const 1_i32;                // scope 0 at $DIR/if.rs:+2:13: +2:14\n+          StorageLive(_2);                 // scope 1 at $DIR/if.rs:+3:9: +3:10\n+          StorageLive(_3);                 // scope 1 at $DIR/if.rs:+3:16: +3:24\n+          StorageLive(_4);                 // scope 1 at $DIR/if.rs:+3:16: +3:19\n+          StorageLive(_5);                 // scope 1 at $DIR/if.rs:+3:17: +3:19\n+          _5 = &_1;                        // scope 1 at $DIR/if.rs:+3:17: +3:19\n+-         _4 = (*_5);                      // scope 1 at $DIR/if.rs:+3:16: +3:19\n+-         _3 = Eq(move _4, const 1_i32);   // scope 1 at $DIR/if.rs:+3:16: +3:24\n++         _4 = const 1_i32;                // scope 1 at $DIR/if.rs:+3:16: +3:19\n++         _3 = const true;                 // scope 1 at $DIR/if.rs:+3:16: +3:24\n+          StorageDead(_5);                 // scope 1 at $DIR/if.rs:+3:23: +3:24\n+          StorageDead(_4);                 // scope 1 at $DIR/if.rs:+3:23: +3:24\n+-         switchInt(move _3) -> [false: bb2, otherwise: bb1]; // scope 1 at $DIR/if.rs:+3:16: +3:24\n++         switchInt(const true) -> [false: bb2, otherwise: bb1]; // scope 1 at $DIR/if.rs:+3:16: +3:24\n+      }\n+  \n+      bb1: {\n+          _2 = const 2_i32;                // scope 1 at $DIR/if.rs:+3:27: +3:28\n+          goto -> bb3;                     // scope 1 at $DIR/if.rs:+3:13: +3:41\n+      }\n+  \n+      bb2: {\n+          _2 = const 3_i32;                // scope 1 at $DIR/if.rs:+3:38: +3:39\n+          goto -> bb3;                     // scope 1 at $DIR/if.rs:+3:13: +3:41\n+      }\n+  \n+      bb3: {\n+          StorageDead(_3);                 // scope 1 at $DIR/if.rs:+3:40: +3:41\n+          StorageLive(_6);                 // scope 2 at $DIR/if.rs:+4:9: +4:10\n+          StorageLive(_7);                 // scope 2 at $DIR/if.rs:+4:13: +4:14\n+          _7 = _2;                         // scope 2 at $DIR/if.rs:+4:13: +4:14\n+          _6 = Add(move _7, const 1_i32);  // scope 2 at $DIR/if.rs:+4:13: +4:18\n+          StorageDead(_7);                 // scope 2 at $DIR/if.rs:+4:17: +4:18\n+          StorageLive(_8);                 // scope 3 at $DIR/if.rs:+6:9: +6:10\n+          StorageLive(_9);                 // scope 3 at $DIR/if.rs:+6:16: +6:24\n+          StorageLive(_10);                // scope 3 at $DIR/if.rs:+6:16: +6:19\n+          StorageLive(_11);                // scope 3 at $DIR/if.rs:+6:17: +6:19\n+          _11 = &_1;                       // scope 3 at $DIR/if.rs:+6:17: +6:19\n+-         _10 = (*_11);                    // scope 3 at $DIR/if.rs:+6:16: +6:19\n+-         _9 = Eq(move _10, const 1_i32);  // scope 3 at $DIR/if.rs:+6:16: +6:24\n++         _10 = const 1_i32;               // scope 3 at $DIR/if.rs:+6:16: +6:19\n++         _9 = const true;                 // scope 3 at $DIR/if.rs:+6:16: +6:24\n+          StorageDead(_11);                // scope 3 at $DIR/if.rs:+6:23: +6:24\n+          StorageDead(_10);                // scope 3 at $DIR/if.rs:+6:23: +6:24\n+-         switchInt(move _9) -> [false: bb5, otherwise: bb4]; // scope 3 at $DIR/if.rs:+6:16: +6:24\n++         switchInt(const true) -> [false: bb5, otherwise: bb4]; // scope 3 at $DIR/if.rs:+6:16: +6:24\n+      }\n+  \n+      bb4: {\n+-         _8 = _1;                         // scope 3 at $DIR/if.rs:+6:27: +6:28\n++         _8 = const 1_i32;                // scope 3 at $DIR/if.rs:+6:27: +6:28\n+          goto -> bb6;                     // scope 3 at $DIR/if.rs:+6:13: +6:45\n+      }\n+  \n+      bb5: {\n+          StorageLive(_12);                // scope 3 at $DIR/if.rs:+6:38: +6:39\n+          _12 = _1;                        // scope 3 at $DIR/if.rs:+6:38: +6:39\n+          _8 = Add(move _12, const 1_i32); // scope 3 at $DIR/if.rs:+6:38: +6:43\n+          StorageDead(_12);                // scope 3 at $DIR/if.rs:+6:42: +6:43\n+          goto -> bb6;                     // scope 3 at $DIR/if.rs:+6:13: +6:45\n+      }\n+  \n+      bb6: {\n+          StorageDead(_9);                 // scope 3 at $DIR/if.rs:+6:44: +6:45\n+          StorageLive(_13);                // scope 4 at $DIR/if.rs:+7:9: +7:10\n+          StorageLive(_14);                // scope 4 at $DIR/if.rs:+7:13: +7:14\n+-         _14 = _8;                        // scope 4 at $DIR/if.rs:+7:13: +7:14\n+-         _13 = Add(move _14, const 1_i32); // scope 4 at $DIR/if.rs:+7:13: +7:18\n++         _14 = const 1_i32;               // scope 4 at $DIR/if.rs:+7:13: +7:14\n++         _13 = const 2_i32;               // scope 4 at $DIR/if.rs:+7:13: +7:18\n+          StorageDead(_14);                // scope 4 at $DIR/if.rs:+7:17: +7:18\n+          _0 = const ();                   // scope 0 at $DIR/if.rs:+0:11: +8:2\n+          StorageDead(_13);                // scope 4 at $DIR/if.rs:+8:1: +8:2\n+          StorageDead(_8);                 // scope 3 at $DIR/if.rs:+8:1: +8:2\n+          StorageDead(_6);                 // scope 2 at $DIR/if.rs:+8:1: +8:2\n+          StorageDead(_2);                 // scope 1 at $DIR/if.rs:+8:1: +8:2\n+          StorageDead(_1);                 // scope 0 at $DIR/if.rs:+8:1: +8:2\n+          return;                          // scope 0 at $DIR/if.rs:+8:2: +8:2\n+      }\n+  }\n+  "}, {"sha": "8df8908047797d087530ed875d658054d9dbec5f", "filename": "src/test/mir-opt/dataflow-const-prop/if.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fif.rs?ref=4f9c30fb676482a5148f28c0728b5280246a9886", "patch": "@@ -0,0 +1,12 @@\n+// unit-test: DataflowConstProp\n+\n+// EMIT_MIR if.main.DataflowConstProp.diff\n+fn main() {\n+    // This does not work (yet). Needs perhaps additional state to track unreachability.\n+    let a = 1;\n+    let b = if *&a == 1 { 2 } else { 3 };\n+    let c = b + 1;\n+\n+    let d = if *&a == 1 { a } else { a + 1 };\n+    let e = d + 1;\n+}"}, {"sha": "d5a17d08356166073b1d00ae87f978c0ba373c7a", "filename": "src/test/mir-opt/dataflow-const-prop/promoted.main.DataflowConstProp.diff", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fpromoted.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fpromoted.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fpromoted.main.DataflowConstProp.diff?ref=4f9c30fb676482a5148f28c0728b5280246a9886", "patch": "@@ -0,0 +1,29 @@\n+- // MIR for `main` before DataflowConstProp\n++ // MIR for `main` after DataflowConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/promoted.rs:+0:11: +0:11\n+      let _1: i32;                         // in scope 0 at $DIR/promoted.rs:+2:9: +2:10\n+      let mut _2: &i32;                    // in scope 0 at $DIR/promoted.rs:+2:14: +2:17\n+      let _3: i32;                         // in scope 0 at $DIR/promoted.rs:+2:15: +2:17\n+      let mut _4: &i32;                    // in scope 0 at $DIR/promoted.rs:+2:14: +2:17\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/promoted.rs:+2:9: +2:10\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/promoted.rs:+2:9: +2:10\n+          StorageLive(_2);                 // scope 0 at $DIR/promoted.rs:+2:14: +2:17\n+          _4 = const main::promoted[0];    // scope 0 at $DIR/promoted.rs:+2:14: +2:17\n+                                           // mir::Constant\n+                                           // + span: $DIR/promoted.rs:6:14: 6:17\n+                                           // + literal: Const { ty: &i32, val: Unevaluated(main, [], Some(promoted[0])) }\n+          _2 = &(*_4);                     // scope 0 at $DIR/promoted.rs:+2:14: +2:17\n+          _1 = (*_2);                      // scope 0 at $DIR/promoted.rs:+2:13: +2:17\n+          StorageDead(_2);                 // scope 0 at $DIR/promoted.rs:+2:17: +2:18\n+          _0 = const ();                   // scope 0 at $DIR/promoted.rs:+0:11: +3:2\n+          StorageDead(_1);                 // scope 0 at $DIR/promoted.rs:+3:1: +3:2\n+          return;                          // scope 0 at $DIR/promoted.rs:+3:2: +3:2\n+      }\n+  }\n+  "}, {"sha": "1653cf3334408eb9db4a5a951e80567cd6b6d9d3", "filename": "src/test/mir-opt/dataflow-const-prop/promoted.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fpromoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fpromoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fpromoted.rs?ref=4f9c30fb676482a5148f28c0728b5280246a9886", "patch": "@@ -0,0 +1,7 @@\n+// unit-test: DataflowConstProp\n+\n+// EMIT_MIR promoted.main.DataflowConstProp.diff\n+fn main() {\n+    // This does not work because `&42` gets promoted.\n+    let a = *&42;\n+}"}, {"sha": "953628cff06f9f2ffd0b03a4a635721888ee9dcc", "filename": "src/test/mir-opt/dataflow-const-prop/recursive.main.DataflowConstProp.diff", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Frecursive.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Frecursive.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Frecursive.main.DataflowConstProp.diff?ref=4f9c30fb676482a5148f28c0728b5280246a9886", "patch": "@@ -0,0 +1,133 @@\n+- // MIR for `main` before DataflowConstProp\n++ // MIR for `main` after DataflowConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/recursive.rs:+0:11: +0:11\n+      let _1: S;                           // in scope 0 at $DIR/recursive.rs:+1:9: +1:10\n+      let mut _3: &S;                      // in scope 0 at $DIR/recursive.rs:+2:20: +2:22\n+      let _4: &S;                          // in scope 0 at $DIR/recursive.rs:+2:20: +2:22\n+      let mut _6: &S;                      // in scope 0 at $DIR/recursive.rs:+3:20: +3:22\n+      let _7: &S;                          // in scope 0 at $DIR/recursive.rs:+3:20: +3:22\n+      let mut _9: isize;                   // in scope 0 at $DIR/recursive.rs:+5:9: +5:18\n+      let mut _11: isize;                  // in scope 0 at $DIR/recursive.rs:+6:13: +6:22\n+      let mut _13: isize;                  // in scope 0 at $DIR/recursive.rs:+7:17: +7:28\n+      let mut _15: !;                      // in scope 0 at $DIR/recursive.rs:+8:22: +8:43\n+      let mut _16: !;                      // in scope 0 at $DIR/recursive.rs:+10:18: +10:39\n+      let mut _17: !;                      // in scope 0 at $DIR/recursive.rs:+12:14: +12:35\n+      let mut _18: &S;                     // in scope 0 at $DIR/recursive.rs:+6:20: +6:21\n+      let mut _19: &S;                     // in scope 0 at $DIR/recursive.rs:+6:20: +6:21\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/recursive.rs:+1:9: +1:10\n+          let _2: S;                       // in scope 1 at $DIR/recursive.rs:+2:9: +2:10\n+          scope 2 {\n+              debug b => _2;               // in scope 2 at $DIR/recursive.rs:+2:9: +2:10\n+              let _5: S;                   // in scope 2 at $DIR/recursive.rs:+3:9: +3:10\n+              scope 3 {\n+                  debug c => _5;           // in scope 3 at $DIR/recursive.rs:+3:9: +3:10\n+                  let _8: u32;             // in scope 3 at $DIR/recursive.rs:+4:9: +4:10\n+                  let _10: &S;             // in scope 3 at $DIR/recursive.rs:+5:16: +5:17\n+                  scope 4 {\n+                      debug d => _8;       // in scope 4 at $DIR/recursive.rs:+4:9: +4:10\n+                  }\n+                  scope 5 {\n+                      debug b => _10;      // in scope 5 at $DIR/recursive.rs:+5:16: +5:17\n+                      let _12: &&S;        // in scope 5 at $DIR/recursive.rs:+6:20: +6:21\n+                      scope 6 {\n+                          debug a => _12;  // in scope 6 at $DIR/recursive.rs:+6:20: +6:21\n+                          let _14: &u32;   // in scope 6 at $DIR/recursive.rs:+7:24: +7:27\n+                          scope 7 {\n+                              debug num => _14; // in scope 7 at $DIR/recursive.rs:+7:24: +7:27\n+                          }\n+                      }\n+                  }\n+              }\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/recursive.rs:+1:9: +1:10\n+          Deinit(_1);                      // scope 0 at $DIR/recursive.rs:+1:13: +1:22\n+          ((_1 as Num).0: u32) = const 0_u32; // scope 0 at $DIR/recursive.rs:+1:13: +1:22\n+          discriminant(_1) = 1;            // scope 0 at $DIR/recursive.rs:+1:13: +1:22\n+          StorageLive(_2);                 // scope 1 at $DIR/recursive.rs:+2:9: +2:10\n+          StorageLive(_3);                 // scope 1 at $DIR/recursive.rs:+2:20: +2:22\n+          StorageLive(_4);                 // scope 1 at $DIR/recursive.rs:+2:20: +2:22\n+          _4 = &_1;                        // scope 1 at $DIR/recursive.rs:+2:20: +2:22\n+          _3 = &(*_4);                     // scope 1 at $DIR/recursive.rs:+2:20: +2:22\n+          Deinit(_2);                      // scope 1 at $DIR/recursive.rs:+2:13: +2:23\n+          ((_2 as Rec).0: &S) = move _3;   // scope 1 at $DIR/recursive.rs:+2:13: +2:23\n+          discriminant(_2) = 0;            // scope 1 at $DIR/recursive.rs:+2:13: +2:23\n+          StorageDead(_3);                 // scope 1 at $DIR/recursive.rs:+2:22: +2:23\n+          StorageDead(_4);                 // scope 1 at $DIR/recursive.rs:+2:23: +2:24\n+          StorageLive(_5);                 // scope 2 at $DIR/recursive.rs:+3:9: +3:10\n+          StorageLive(_6);                 // scope 2 at $DIR/recursive.rs:+3:20: +3:22\n+          StorageLive(_7);                 // scope 2 at $DIR/recursive.rs:+3:20: +3:22\n+          _7 = &_2;                        // scope 2 at $DIR/recursive.rs:+3:20: +3:22\n+          _6 = &(*_7);                     // scope 2 at $DIR/recursive.rs:+3:20: +3:22\n+          Deinit(_5);                      // scope 2 at $DIR/recursive.rs:+3:13: +3:23\n+          ((_5 as Rec).0: &S) = move _6;   // scope 2 at $DIR/recursive.rs:+3:13: +3:23\n+          discriminant(_5) = 0;            // scope 2 at $DIR/recursive.rs:+3:13: +3:23\n+          StorageDead(_6);                 // scope 2 at $DIR/recursive.rs:+3:22: +3:23\n+          StorageDead(_7);                 // scope 2 at $DIR/recursive.rs:+3:23: +3:24\n+          StorageLive(_8);                 // scope 3 at $DIR/recursive.rs:+4:9: +4:10\n+          _9 = discriminant(_5);           // scope 3 at $DIR/recursive.rs:+4:19: +4:20\n+          switchInt(move _9) -> [0_isize: bb2, otherwise: bb1]; // scope 3 at $DIR/recursive.rs:+4:13: +4:20\n+      }\n+  \n+      bb1: {\n+          StorageLive(_17);                // scope 3 at $DIR/recursive.rs:+12:14: +12:35\n+          _17 = exit(const 0_i32);         // scope 3 at $DIR/recursive.rs:+12:14: +12:35\n+                                           // mir::Constant\n+                                           // + span: $DIR/recursive.rs:21:14: 21:32\n+                                           // + literal: Const { ty: fn(i32) -> ! {exit}, val: Value(<ZST>) }\n+      }\n+  \n+      bb2: {\n+          StorageLive(_10);                // scope 3 at $DIR/recursive.rs:+5:16: +5:17\n+          _10 = ((_5 as Rec).0: &S);       // scope 3 at $DIR/recursive.rs:+5:16: +5:17\n+          _11 = discriminant((*_10));      // scope 5 at $DIR/recursive.rs:+5:28: +5:29\n+          switchInt(move _11) -> [0_isize: bb4, otherwise: bb3]; // scope 5 at $DIR/recursive.rs:+5:22: +5:29\n+      }\n+  \n+      bb3: {\n+          StorageLive(_16);                // scope 5 at $DIR/recursive.rs:+10:18: +10:39\n+          _16 = exit(const 0_i32);         // scope 5 at $DIR/recursive.rs:+10:18: +10:39\n+                                           // mir::Constant\n+                                           // + span: $DIR/recursive.rs:19:18: 19:36\n+                                           // + literal: Const { ty: fn(i32) -> ! {exit}, val: Value(<ZST>) }\n+      }\n+  \n+      bb4: {\n+          StorageLive(_12);                // scope 5 at $DIR/recursive.rs:+6:20: +6:21\n+          _12 = &(((*_10) as Rec).0: &S);  // scope 5 at $DIR/recursive.rs:+6:20: +6:21\n+          _18 = deref_copy (*_12);         // scope 6 at $DIR/recursive.rs:+6:32: +6:33\n+          _13 = discriminant((*_18));      // scope 6 at $DIR/recursive.rs:+6:32: +6:33\n+          switchInt(move _13) -> [1_isize: bb6, otherwise: bb5]; // scope 6 at $DIR/recursive.rs:+6:26: +6:33\n+      }\n+  \n+      bb5: {\n+          StorageLive(_15);                // scope 6 at $DIR/recursive.rs:+8:22: +8:43\n+          _15 = exit(const 0_i32);         // scope 6 at $DIR/recursive.rs:+8:22: +8:43\n+                                           // mir::Constant\n+                                           // + span: $DIR/recursive.rs:17:22: 17:40\n+                                           // + literal: Const { ty: fn(i32) -> ! {exit}, val: Value(<ZST>) }\n+      }\n+  \n+      bb6: {\n+          StorageLive(_14);                // scope 6 at $DIR/recursive.rs:+7:24: +7:27\n+          _19 = deref_copy (*_12);         // scope 6 at $DIR/recursive.rs:+7:24: +7:27\n+          _14 = &(((*_19) as Num).0: u32); // scope 6 at $DIR/recursive.rs:+7:24: +7:27\n+-         _8 = (*_14);                     // scope 7 at $DIR/recursive.rs:+7:32: +7:36\n++         _8 = const 0_u32;                // scope 7 at $DIR/recursive.rs:+7:32: +7:36\n+          StorageDead(_14);                // scope 6 at $DIR/recursive.rs:+7:35: +7:36\n+          StorageDead(_12);                // scope 5 at $DIR/recursive.rs:+9:13: +9:14\n+          StorageDead(_10);                // scope 3 at $DIR/recursive.rs:+11:9: +11:10\n+          _0 = const ();                   // scope 0 at $DIR/recursive.rs:+0:11: +14:2\n+          StorageDead(_8);                 // scope 3 at $DIR/recursive.rs:+14:1: +14:2\n+          StorageDead(_5);                 // scope 2 at $DIR/recursive.rs:+14:1: +14:2\n+          StorageDead(_2);                 // scope 1 at $DIR/recursive.rs:+14:1: +14:2\n+          StorageDead(_1);                 // scope 0 at $DIR/recursive.rs:+14:1: +14:2\n+          return;                          // scope 0 at $DIR/recursive.rs:+14:2: +14:2\n+      }\n+  }\n+  "}, {"sha": "0eda1239ecd05c5644a0d84f31b0c989cf7a0386", "filename": "src/test/mir-opt/dataflow-const-prop/recursive.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Frecursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Frecursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Frecursive.rs?ref=4f9c30fb676482a5148f28c0728b5280246a9886", "patch": "@@ -0,0 +1,23 @@\n+// unit-test: DataflowConstProp\n+\n+enum S<'a> {\n+    Rec(&'a S<'a>),\n+    Num(u32),\n+}\n+\n+// EMIT_MIR recursive.main.DataflowConstProp.diff\n+fn main() {\n+    let a = S::Num(0);\n+    let b = S::Rec(&a);\n+    let c = S::Rec(&b);\n+    let d = match c {\n+        S::Rec(b) => match b {\n+            S::Rec(a) => match a {\n+                S::Num(num) => *num,\n+                _ => std::process::exit(0),\n+            },\n+            _ => std::process::exit(0),\n+        },\n+        _ => std::process::exit(0),\n+    };\n+}"}, {"sha": "6af381617f9ac9cb1e2d9415006c246902ff412a", "filename": "src/test/mir-opt/dataflow-const-prop/ref.main.DataflowConstProp.diff", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fref.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fref.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fref.main.DataflowConstProp.diff?ref=4f9c30fb676482a5148f28c0728b5280246a9886", "patch": "@@ -0,0 +1,89 @@\n+- // MIR for `main` before DataflowConstProp\n++ // MIR for `main` after DataflowConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/ref.rs:+0:11: +0:11\n+      let _1: i32;                         // in scope 0 at $DIR/ref.rs:+1:9: +1:10\n+      let mut _4: bool;                    // in scope 0 at $DIR/ref.rs:+3:16: +3:43\n+      let mut _5: u32;                     // in scope 0 at $DIR/ref.rs:+3:16: +3:38\n+      let mut _6: u32;                     // in scope 0 at $DIR/ref.rs:+3:16: +3:34\n+      let mut _7: bool;                    // in scope 0 at $DIR/ref.rs:+3:16: +3:38\n+      let _8: &i32;                        // in scope 0 at $DIR/ref.rs:+3:58: +3:60\n+      let mut _10: i32;                    // in scope 0 at $DIR/ref.rs:+4:13: +4:15\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/ref.rs:+1:9: +1:10\n+          let _2: i32;                     // in scope 1 at $DIR/ref.rs:+2:9: +2:10\n+          scope 2 {\n+              debug b => _2;               // in scope 2 at $DIR/ref.rs:+2:9: +2:10\n+              let _3: &i32;                // in scope 2 at $DIR/ref.rs:+3:9: +3:10\n+              scope 3 {\n+                  debug c => _3;           // in scope 3 at $DIR/ref.rs:+3:9: +3:10\n+                  let _9: i32;             // in scope 3 at $DIR/ref.rs:+4:9: +4:10\n+                  scope 4 {\n+                      debug d => _9;       // in scope 4 at $DIR/ref.rs:+4:9: +4:10\n+                  }\n+              }\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/ref.rs:+1:9: +1:10\n+          _1 = const 0_i32;                // scope 0 at $DIR/ref.rs:+1:13: +1:14\n+          StorageLive(_2);                 // scope 1 at $DIR/ref.rs:+2:9: +2:10\n+          _2 = const 0_i32;                // scope 1 at $DIR/ref.rs:+2:13: +2:14\n+          StorageLive(_3);                 // scope 2 at $DIR/ref.rs:+3:9: +3:10\n+          StorageLive(_4);                 // scope 2 at $DIR/ref.rs:+3:16: +3:43\n+          StorageLive(_5);                 // scope 2 at $DIR/ref.rs:+3:16: +3:38\n+          StorageLive(_6);                 // scope 2 at $DIR/ref.rs:+3:16: +3:34\n+          _6 = id() -> bb1;                // scope 2 at $DIR/ref.rs:+3:16: +3:34\n+                                           // mir::Constant\n+                                           // + span: $DIR/ref.rs:7:16: 7:32\n+                                           // + literal: Const { ty: fn() -> u32 {id}, val: Value(<ZST>) }\n+      }\n+  \n+      bb1: {\n+-         _7 = Eq(const 2_u32, const 0_u32); // scope 2 at $DIR/ref.rs:+3:16: +3:38\n+-         assert(!move _7, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _6) -> bb2; // scope 2 at $DIR/ref.rs:+3:16: +3:38\n++         _7 = const false;                // scope 2 at $DIR/ref.rs:+3:16: +3:38\n++         assert(!const false, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _6) -> bb2; // scope 2 at $DIR/ref.rs:+3:16: +3:38\n+      }\n+  \n+      bb2: {\n+          _5 = Rem(move _6, const 2_u32);  // scope 2 at $DIR/ref.rs:+3:16: +3:38\n+          StorageDead(_6);                 // scope 2 at $DIR/ref.rs:+3:37: +3:38\n+          _4 = Eq(move _5, const 0_u32);   // scope 2 at $DIR/ref.rs:+3:16: +3:43\n+          StorageDead(_5);                 // scope 2 at $DIR/ref.rs:+3:42: +3:43\n+          switchInt(move _4) -> [false: bb4, otherwise: bb3]; // scope 2 at $DIR/ref.rs:+3:16: +3:43\n+      }\n+  \n+      bb3: {\n+          _3 = &_1;                        // scope 2 at $DIR/ref.rs:+3:46: +3:48\n+          goto -> bb5;                     // scope 2 at $DIR/ref.rs:+3:13: +3:62\n+      }\n+  \n+      bb4: {\n+          StorageLive(_8);                 // scope 2 at $DIR/ref.rs:+3:58: +3:60\n+          _8 = &_2;                        // scope 2 at $DIR/ref.rs:+3:58: +3:60\n+          _3 = &(*_8);                     // scope 2 at $DIR/ref.rs:+3:58: +3:60\n+          StorageDead(_8);                 // scope 2 at $DIR/ref.rs:+3:61: +3:62\n+          goto -> bb5;                     // scope 2 at $DIR/ref.rs:+3:13: +3:62\n+      }\n+  \n+      bb5: {\n+          StorageDead(_4);                 // scope 2 at $DIR/ref.rs:+3:61: +3:62\n+          StorageLive(_9);                 // scope 3 at $DIR/ref.rs:+4:9: +4:10\n+          StorageLive(_10);                // scope 3 at $DIR/ref.rs:+4:13: +4:15\n+-         _10 = (*_3);                     // scope 3 at $DIR/ref.rs:+4:13: +4:15\n+-         _9 = Add(move _10, const 1_i32); // scope 3 at $DIR/ref.rs:+4:13: +4:19\n++         _10 = const 0_i32;               // scope 3 at $DIR/ref.rs:+4:13: +4:15\n++         _9 = const 1_i32;                // scope 3 at $DIR/ref.rs:+4:13: +4:19\n+          StorageDead(_10);                // scope 3 at $DIR/ref.rs:+4:18: +4:19\n+          _0 = const ();                   // scope 0 at $DIR/ref.rs:+0:11: +5:2\n+          StorageDead(_9);                 // scope 3 at $DIR/ref.rs:+5:1: +5:2\n+          StorageDead(_3);                 // scope 2 at $DIR/ref.rs:+5:1: +5:2\n+          StorageDead(_2);                 // scope 1 at $DIR/ref.rs:+5:1: +5:2\n+          StorageDead(_1);                 // scope 0 at $DIR/ref.rs:+5:1: +5:2\n+          return;                          // scope 0 at $DIR/ref.rs:+5:2: +5:2\n+      }\n+  }\n+  "}, {"sha": "6da613fc51632fd5a75346072e40d5ed106bc853", "filename": "src/test/mir-opt/dataflow-const-prop/ref.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fref.rs?ref=4f9c30fb676482a5148f28c0728b5280246a9886", "patch": "@@ -0,0 +1,9 @@\n+// unit-test: DataflowConstProp\n+\n+// EMIT_MIR ref.main.DataflowConstProp.diff\n+fn main() {\n+    let a = 0;\n+    let b = 0;\n+    let c = if std::process::id() % 2 == 0 { &a } else { &b };\n+    let d = *c + 1;\n+}"}, {"sha": "fe5bdd07d4a02b9e53614af9cc636ceae2f07fa5", "filename": "src/test/mir-opt/dataflow-const-prop/ref_mut.main.DataflowConstProp.diff", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fref_mut.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fref_mut.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fref_mut.main.DataflowConstProp.diff?ref=4f9c30fb676482a5148f28c0728b5280246a9886", "patch": "@@ -0,0 +1,77 @@\n+- // MIR for `main` before DataflowConstProp\n++ // MIR for `main` after DataflowConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/ref_mut.rs:+0:11: +0:11\n+      let mut _1: i32;                     // in scope 0 at $DIR/ref_mut.rs:+1:9: +1:14\n+      let mut _7: &i32;                    // in scope 0 at $DIR/ref_mut.rs:+9:10: +9:12\n+      let _8: &i32;                        // in scope 0 at $DIR/ref_mut.rs:+9:10: +9:12\n+      let _9: i32;                         // in scope 0 at $DIR/ref_mut.rs:+9:11: +9:12\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/ref_mut.rs:+1:9: +1:14\n+          let _2: &mut i32;                // in scope 1 at $DIR/ref_mut.rs:+2:9: +2:10\n+          scope 2 {\n+              debug b => _2;               // in scope 2 at $DIR/ref_mut.rs:+2:9: +2:10\n+              let _3: i32;                 // in scope 2 at $DIR/ref_mut.rs:+4:9: +4:10\n+              scope 3 {\n+                  debug c => _3;           // in scope 3 at $DIR/ref_mut.rs:+4:9: +4:10\n+                  let _4: i32;             // in scope 3 at $DIR/ref_mut.rs:+6:9: +6:10\n+                  scope 4 {\n+                      debug d => _4;       // in scope 4 at $DIR/ref_mut.rs:+6:9: +6:10\n+                      let mut _5: &i32;    // in scope 4 at $DIR/ref_mut.rs:+7:9: +7:14\n+                      scope 5 {\n+                          debug e => _5;   // in scope 5 at $DIR/ref_mut.rs:+7:9: +7:14\n+                          let _6: &mut &i32; // in scope 5 at $DIR/ref_mut.rs:+8:9: +8:10\n+                          scope 6 {\n+                              debug f => _6; // in scope 6 at $DIR/ref_mut.rs:+8:9: +8:10\n+                              let _10: i32; // in scope 6 at $DIR/ref_mut.rs:+10:9: +10:10\n+                              let mut _11: &i32; // in scope 6 at $DIR/ref_mut.rs:+9:10: +9:12\n+                              scope 7 {\n+                                  debug g => _10; // in scope 7 at $DIR/ref_mut.rs:+10:9: +10:10\n+                              }\n+                          }\n+                      }\n+                  }\n+              }\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/ref_mut.rs:+1:9: +1:14\n+          _1 = const 0_i32;                // scope 0 at $DIR/ref_mut.rs:+1:17: +1:18\n+          StorageLive(_2);                 // scope 1 at $DIR/ref_mut.rs:+2:9: +2:10\n+          _2 = &mut _1;                    // scope 1 at $DIR/ref_mut.rs:+2:13: +2:19\n+          (*_2) = const 1_i32;             // scope 2 at $DIR/ref_mut.rs:+3:5: +3:11\n+          StorageLive(_3);                 // scope 2 at $DIR/ref_mut.rs:+4:9: +4:10\n+          _3 = _1;                         // scope 2 at $DIR/ref_mut.rs:+4:13: +4:14\n+          StorageLive(_4);                 // scope 3 at $DIR/ref_mut.rs:+6:9: +6:10\n+          _4 = const 0_i32;                // scope 3 at $DIR/ref_mut.rs:+6:13: +6:14\n+          StorageLive(_5);                 // scope 4 at $DIR/ref_mut.rs:+7:9: +7:14\n+          _5 = &_4;                        // scope 4 at $DIR/ref_mut.rs:+7:17: +7:19\n+          StorageLive(_6);                 // scope 5 at $DIR/ref_mut.rs:+8:9: +8:10\n+          _6 = &mut _5;                    // scope 5 at $DIR/ref_mut.rs:+8:13: +8:19\n+          StorageLive(_7);                 // scope 6 at $DIR/ref_mut.rs:+9:10: +9:12\n+          StorageLive(_8);                 // scope 6 at $DIR/ref_mut.rs:+9:10: +9:12\n+          _11 = const main::promoted[0];   // scope 6 at $DIR/ref_mut.rs:+9:10: +9:12\n+                                           // mir::Constant\n+                                           // + span: $DIR/ref_mut.rs:13:10: 13:12\n+                                           // + literal: Const { ty: &i32, val: Unevaluated(main, [], Some(promoted[0])) }\n+          _8 = &(*_11);                    // scope 6 at $DIR/ref_mut.rs:+9:10: +9:12\n+          _7 = &(*_8);                     // scope 6 at $DIR/ref_mut.rs:+9:10: +9:12\n+          (*_6) = move _7;                 // scope 6 at $DIR/ref_mut.rs:+9:5: +9:12\n+          StorageDead(_7);                 // scope 6 at $DIR/ref_mut.rs:+9:11: +9:12\n+          StorageDead(_8);                 // scope 6 at $DIR/ref_mut.rs:+9:12: +9:13\n+          StorageLive(_10);                // scope 6 at $DIR/ref_mut.rs:+10:9: +10:10\n+          _10 = (*_5);                     // scope 6 at $DIR/ref_mut.rs:+10:13: +10:15\n+          _0 = const ();                   // scope 0 at $DIR/ref_mut.rs:+0:11: +11:2\n+          StorageDead(_10);                // scope 6 at $DIR/ref_mut.rs:+11:1: +11:2\n+          StorageDead(_6);                 // scope 5 at $DIR/ref_mut.rs:+11:1: +11:2\n+          StorageDead(_5);                 // scope 4 at $DIR/ref_mut.rs:+11:1: +11:2\n+          StorageDead(_4);                 // scope 3 at $DIR/ref_mut.rs:+11:1: +11:2\n+          StorageDead(_3);                 // scope 2 at $DIR/ref_mut.rs:+11:1: +11:2\n+          StorageDead(_2);                 // scope 1 at $DIR/ref_mut.rs:+11:1: +11:2\n+          StorageDead(_1);                 // scope 0 at $DIR/ref_mut.rs:+11:1: +11:2\n+          return;                          // scope 0 at $DIR/ref_mut.rs:+11:2: +11:2\n+      }\n+  }\n+  "}, {"sha": "8b2baf7676df9d8be6404595f3f39375675d8408", "filename": "src/test/mir-opt/dataflow-const-prop/ref_mut.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fref_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fref_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fref_mut.rs?ref=4f9c30fb676482a5148f28c0728b5280246a9886", "patch": "@@ -0,0 +1,15 @@\n+// unit-test: DataflowConstProp\n+\n+// EMIT_MIR ref_mut.main.DataflowConstProp.diff\n+fn main() {\n+    let mut a = 0;\n+    let b = &mut a;\n+    *b = 1;\n+    let c = a;\n+\n+    let d = 0;\n+    let mut e = &d;\n+    let f = &mut e;\n+    *f = &1;\n+    let g = *e;\n+}"}, {"sha": "1d01d4fd2e77554185a5e24a88ea1946c4c12026", "filename": "src/test/mir-opt/dataflow-const-prop/terminator.main.DataflowConstProp.diff", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fterminator.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fterminator.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fterminator.main.DataflowConstProp.diff?ref=4f9c30fb676482a5148f28c0728b5280246a9886", "patch": "@@ -0,0 +1,40 @@\n+- // MIR for `main` before DataflowConstProp\n++ // MIR for `main` after DataflowConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/terminator.rs:+0:11: +0:11\n+      let _1: i32;                         // in scope 0 at $DIR/terminator.rs:+1:9: +1:10\n+      let _2: ();                          // in scope 0 at $DIR/terminator.rs:+2:5: +2:15\n+      let mut _3: i32;                     // in scope 0 at $DIR/terminator.rs:+2:9: +2:14\n+      let mut _4: i32;                     // in scope 0 at $DIR/terminator.rs:+2:9: +2:10\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/terminator.rs:+1:9: +1:10\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/terminator.rs:+1:9: +1:10\n+          _1 = const 1_i32;                // scope 0 at $DIR/terminator.rs:+1:13: +1:14\n+          StorageLive(_2);                 // scope 1 at $DIR/terminator.rs:+2:5: +2:15\n+          StorageLive(_3);                 // scope 1 at $DIR/terminator.rs:+2:9: +2:14\n+          StorageLive(_4);                 // scope 1 at $DIR/terminator.rs:+2:9: +2:10\n+-         _4 = _1;                         // scope 1 at $DIR/terminator.rs:+2:9: +2:10\n+-         _3 = Add(move _4, const 1_i32);  // scope 1 at $DIR/terminator.rs:+2:9: +2:14\n++         _4 = const 1_i32;                // scope 1 at $DIR/terminator.rs:+2:9: +2:10\n++         _3 = const 2_i32;                // scope 1 at $DIR/terminator.rs:+2:9: +2:14\n+          StorageDead(_4);                 // scope 1 at $DIR/terminator.rs:+2:13: +2:14\n+-         _2 = foo(move _3) -> bb1;        // scope 1 at $DIR/terminator.rs:+2:5: +2:15\n++         _2 = foo(const 2_i32) -> bb1;    // scope 1 at $DIR/terminator.rs:+2:5: +2:15\n+                                           // mir::Constant\n+                                           // + span: $DIR/terminator.rs:8:5: 8:8\n+                                           // + literal: Const { ty: fn(i32) {foo}, val: Value(<ZST>) }\n+      }\n+  \n+      bb1: {\n+          StorageDead(_3);                 // scope 1 at $DIR/terminator.rs:+2:14: +2:15\n+          StorageDead(_2);                 // scope 1 at $DIR/terminator.rs:+2:15: +2:16\n+          _0 = const ();                   // scope 0 at $DIR/terminator.rs:+0:11: +3:2\n+          StorageDead(_1);                 // scope 0 at $DIR/terminator.rs:+3:1: +3:2\n+          return;                          // scope 0 at $DIR/terminator.rs:+3:2: +3:2\n+      }\n+  }\n+  "}, {"sha": "e96b25de63ccce94fc4cbec24f1240689015f1e1", "filename": "src/test/mir-opt/dataflow-const-prop/terminator.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fterminator.rs?ref=4f9c30fb676482a5148f28c0728b5280246a9886", "patch": "@@ -0,0 +1,9 @@\n+// unit-test: DataflowConstProp\n+\n+fn foo(n: i32) {}\n+\n+// EMIT_MIR terminator.main.DataflowConstProp.diff\n+fn main() {\n+    let a = 1;\n+    foo(a + 1);\n+}"}, {"sha": "684c661fc1185f9478d8387cc6e4f666acb5af18", "filename": "src/test/mir-opt/dataflow-const-prop/unnamed.main.DataflowConstProp.diff", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Funnamed.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Funnamed.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Funnamed.main.DataflowConstProp.diff?ref=4f9c30fb676482a5148f28c0728b5280246a9886", "patch": "@@ -0,0 +1,38 @@\n+- // MIR for `main` before DataflowConstProp\n++ // MIR for `main` after DataflowConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/unnamed.rs:+0:11: +0:11\n+      let mut _1: i32;                     // in scope 0 at $DIR/unnamed.rs:+1:9: +1:14\n+      let mut _2: i32;                     // in scope 0 at $DIR/unnamed.rs:+3:10: +3:11\n+      let mut _3: &i32;                    // in scope 0 at $DIR/unnamed.rs:+3:10: +3:11\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/unnamed.rs:+1:9: +1:14\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/unnamed.rs:+1:9: +1:14\n+          _1 = const 0_i32;                // scope 0 at $DIR/unnamed.rs:+1:17: +1:18\n+-         _1 = Add(_1, const 1_i32);       // scope 1 at $DIR/unnamed.rs:+2:5: +2:11\n++         _1 = const 1_i32;                // scope 1 at $DIR/unnamed.rs:+2:5: +2:11\n+          StorageLive(_2);                 // scope 1 at $DIR/unnamed.rs:+3:10: +3:11\n+          StorageLive(_3);                 // scope 1 at $DIR/unnamed.rs:+3:10: +3:11\n+          _3 = const {alloc1: &i32};       // scope 1 at $DIR/unnamed.rs:+3:10: +3:11\n+                                           // mir::Constant\n+                                           // + span: $DIR/unnamed.rs:9:10: 9:11\n+                                           // + literal: Const { ty: &i32, val: Value(Scalar(alloc1)) }\n+          _2 = (*_3);                      // scope 1 at $DIR/unnamed.rs:+3:10: +3:11\n+-         _1 = Add(_1, move _2);           // scope 1 at $DIR/unnamed.rs:+3:5: +3:11\n++         _1 = Add(const 1_i32, move _2);  // scope 1 at $DIR/unnamed.rs:+3:5: +3:11\n+          StorageDead(_2);                 // scope 1 at $DIR/unnamed.rs:+3:10: +3:11\n+          StorageDead(_3);                 // scope 1 at $DIR/unnamed.rs:+3:11: +3:12\n+          _0 = const ();                   // scope 0 at $DIR/unnamed.rs:+0:11: +4:2\n+          StorageDead(_1);                 // scope 0 at $DIR/unnamed.rs:+4:1: +4:2\n+          return;                          // scope 0 at $DIR/unnamed.rs:+4:2: +4:2\n+      }\n+  }\n+  \n+  alloc1 (static: g, size: 4, align: 4) {\n+      02 00 00 00                                     \u2502 ....\n+  }\n+  "}, {"sha": "91f5a9e1c12d1b652921c23ffcbedd36aa7aa219", "filename": "src/test/mir-opt/dataflow-const-prop/unnamed.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Funnamed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c30fb676482a5148f28c0728b5280246a9886/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Funnamed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Funnamed.rs?ref=4f9c30fb676482a5148f28c0728b5280246a9886", "patch": "@@ -0,0 +1,10 @@\n+// unit-test: DataflowConstProp\n+\n+static g: i32 = 2;\n+\n+// EMIT_MIR unnamed.main.DataflowConstProp.diff\n+fn main() {\n+    let mut a = 0;\n+    a += 1;\n+    a += g;\n+}"}]}