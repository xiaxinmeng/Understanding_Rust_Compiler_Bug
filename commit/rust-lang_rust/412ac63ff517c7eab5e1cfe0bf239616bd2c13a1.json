{"sha": "412ac63ff517c7eab5e1cfe0bf239616bd2c13a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxMmFjNjNmZjUxN2M3ZWFiNWUxY2ZlMGJmMjM5NjE2YmQyYzEzYTE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-21T12:24:42Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-21T12:24:42Z"}, "message": "docs", "tree": {"sha": "945fd6597aa73ec1b887f0d60b5bc9d7ac59f2cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/945fd6597aa73ec1b887f0d60b5bc9d7ac59f2cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/412ac63ff517c7eab5e1cfe0bf239616bd2c13a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/412ac63ff517c7eab5e1cfe0bf239616bd2c13a1", "html_url": "https://github.com/rust-lang/rust/commit/412ac63ff517c7eab5e1cfe0bf239616bd2c13a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/412ac63ff517c7eab5e1cfe0bf239616bd2c13a1/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2fa2805887e734647aabebc1f533ec76c48f538a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fa2805887e734647aabebc1f533ec76c48f538a", "html_url": "https://github.com/rust-lang/rust/commit/2fa2805887e734647aabebc1f533ec76c48f538a"}], "stats": {"total": 241, "additions": 143, "deletions": 98}, "files": [{"sha": "6361d5d868773d264ae23c36c37129f22dedb329", "filename": "crates/ra_parser/src/event.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/412ac63ff517c7eab5e1cfe0bf239616bd2c13a1/crates%2Fra_parser%2Fsrc%2Fevent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412ac63ff517c7eab5e1cfe0bf239616bd2c13a1/crates%2Fra_parser%2Fsrc%2Fevent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fevent.rs?ref=412ac63ff517c7eab5e1cfe0bf239616bd2c13a1", "patch": "@@ -113,12 +113,11 @@ pub(super) fn process(sink: &mut dyn TreeSink, mut events: Vec<Event>) {\n                     // append `B`'s forward_parent `C` in the next stage.\n                 }\n \n-                for (j, kind) in forward_parents.drain(..).rev().enumerate() {\n-                    let is_root_node = i == 0 && j == 0;\n-                    sink.start_branch(kind, is_root_node);\n+                for kind in forward_parents.drain(..).rev() {\n+                    sink.start_branch(kind);\n                 }\n             }\n-            Event::Finish => sink.finish_branch(i == events.len() - 1),\n+            Event::Finish => sink.finish_branch(),\n             Event::Token { kind, n_raw_tokens } => {\n                 sink.leaf(kind, n_raw_tokens);\n             }"}, {"sha": "ddc08e4628e3130ddd1dab40a01b29c24f61d0fb", "filename": "crates/ra_parser/src/lib.rs", "status": "modified", "additions": 35, "deletions": 11, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/412ac63ff517c7eab5e1cfe0bf239616bd2c13a1/crates%2Fra_parser%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412ac63ff517c7eab5e1cfe0bf239616bd2c13a1/crates%2Fra_parser%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Flib.rs?ref=412ac63ff517c7eab5e1cfe0bf239616bd2c13a1", "patch": "@@ -1,3 +1,17 @@\n+//! The Rust parser.\n+//!\n+//! The parser doesn't know about concrete representation of tokens and syntax\n+//! trees. Abstract `TokenSource` and `TreeSink` traits are used instead. As a\n+//! consequence, this crates does not contain a lexer.\n+//!\n+//! The `Parser` struct from the `parser` module is a cursor into the sequence\n+//! of tokens. Parsing routines use `Parser` to inspect current state and\n+//! advance the parsing.\n+//!\n+//! The actual parsing happens in the `grammar` module.\n+//!\n+//! Tests for this crate live in `ra_syntax` crate.\n+\n #[macro_use]\n mod token_set;\n mod syntax_kind;\n@@ -12,40 +26,46 @@ pub use syntax_kind::SyntaxKind;\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ParseError(pub String);\n \n+/// `TokenSource` abstracts the source of the tokens parser operates one.\n+///\n+/// Hopefully this will allow us to treat text and token trees in the same way!\n+pub trait TokenSource {\n+    /// What is the current token?\n+    fn token_kind(&self, pos: usize) -> SyntaxKind;\n+    /// Is the current token joined to the next one (`> >` vs `>>`).\n+    fn is_token_joint_to_next(&self, pos: usize) -> bool;\n+    /// Is the current token a specified keyword?\n+    fn is_keyword(&self, pos: usize, kw: &str) -> bool;\n+}\n+\n /// `TreeSink` abstracts details of a particular syntax tree implementation.\n pub trait TreeSink {\n     /// Adds new leaf to the current branch.\n     fn leaf(&mut self, kind: SyntaxKind, n_tokens: u8);\n \n     /// Start new branch and make it current.\n-    fn start_branch(&mut self, kind: SyntaxKind, root: bool);\n+    fn start_branch(&mut self, kind: SyntaxKind);\n \n     /// Finish current branch and restore previous\n     /// branch as current.\n-    fn finish_branch(&mut self, root: bool);\n+    fn finish_branch(&mut self);\n \n     fn error(&mut self, error: ParseError);\n }\n \n-/// `TokenSource` abstracts the source of the tokens parser operates one.\n-///\n-/// Hopefully this will allow us to treat text and token trees in the same way!\n-pub trait TokenSource {\n-    fn token_kind(&self, pos: usize) -> SyntaxKind;\n-    fn is_token_joint_to_next(&self, pos: usize) -> bool;\n-    fn is_keyword(&self, pos: usize, kw: &str) -> bool;\n-}\n-\n+/// Parse given tokens into the given sink as a rust file.\n pub fn parse(token_source: &dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n     let mut p = parser::Parser::new(token_source);\n     grammar::root(&mut p);\n     let events = p.finish();\n     event::process(tree_sink, events);\n }\n \n+/// A parsing function for a specific braced-block.\n pub struct Reparser(fn(&mut parser::Parser));\n \n impl Reparser {\n+    /// If the node is a braced block, return the corresponding `Reparser`.\n     pub fn for_node(\n         node: SyntaxKind,\n         first_child: Option<SyntaxKind>,\n@@ -54,6 +74,10 @@ impl Reparser {\n         grammar::reparser(node, first_child, parent).map(Reparser)\n     }\n \n+    /// Re-parse given tokens using this `Reparser`.\n+    ///\n+    /// Tokens must start with `{`, end with `}` and form a valid brace\n+    /// sequence.\n     pub fn parse(self, token_source: &dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n         let Reparser(r) = self;\n         let mut p = parser::Parser::new(token_source);"}, {"sha": "79121b35f2ad1c1aa1fe6b432fdef9b60bbef1df", "filename": "crates/ra_parser/src/token_set.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/412ac63ff517c7eab5e1cfe0bf239616bd2c13a1/crates%2Fra_parser%2Fsrc%2Ftoken_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412ac63ff517c7eab5e1cfe0bf239616bd2c13a1/crates%2Fra_parser%2Fsrc%2Ftoken_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Ftoken_set.rs?ref=412ac63ff517c7eab5e1cfe0bf239616bd2c13a1", "patch": "@@ -1,5 +1,6 @@\n use crate::SyntaxKind;\n \n+/// A bit-set of `SyntaxKind`s\n #[derive(Clone, Copy)]\n pub(crate) struct TokenSet(u128);\n "}, {"sha": "e8cf0d4b53e809d1a518fc0eea23579b81818a15", "filename": "crates/ra_syntax/src/algo.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/412ac63ff517c7eab5e1cfe0bf239616bd2c13a1/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412ac63ff517c7eab5e1cfe0bf239616bd2c13a1/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo.rs?ref=412ac63ff517c7eab5e1cfe0bf239616bd2c13a1", "patch": "@@ -33,6 +33,7 @@ pub fn find_covering_node(root: &SyntaxNode, range: TextRange) -> &SyntaxNode {\n     SyntaxNode::from_repr(root.0.covering_node(range))\n }\n \n+// Replace with `std::iter::successors` in `1.34.0`\n pub fn generate<T>(seed: Option<T>, step: impl Fn(&T) -> Option<T>) -> impl Iterator<Item = T> {\n     ::itertools::unfold(seed, move |slot| {\n         slot.take().map(|curr| {"}, {"sha": "20e0a68562768ae069ed748e9dbb0526f32aee93", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/412ac63ff517c7eab5e1cfe0bf239616bd2c13a1/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412ac63ff517c7eab5e1cfe0bf239616bd2c13a1/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=412ac63ff517c7eab5e1cfe0bf239616bd2c13a1", "patch": "@@ -1,3 +1,4 @@\n+//! Abstract Syntax Tree, layered on top of untyped `SyntaxNode`s\n mod generated;\n \n use std::marker::PhantomData;"}, {"sha": "6982b98150f7263bbc8a1433885a849180235c4a", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/412ac63ff517c7eab5e1cfe0bf239616bd2c13a1/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412ac63ff517c7eab5e1cfe0bf239616bd2c13a1/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=412ac63ff517c7eab5e1cfe0bf239616bd2c13a1", "patch": "@@ -1,20 +1,21 @@\n-//! An experimental implementation of [Rust RFC#2256 libsyntax2.0][rfc#2256].\n+//! Syntax Tree library used throughout the rust analyzer.\n //!\n-//! The intent is to be an IDE-ready parser, i.e. one that offers\n+//! Properties:\n+//!   - easy and fast incremental re-parsing\n+//!   - graceful handling of errors\n+//!   - full-fidelity representation (*any* text can be precisely represented as\n+//!     a syntax tree)\n //!\n-//! - easy and fast incremental re-parsing,\n-//! - graceful handling of errors, and\n-//! - maintains all information in the source file.\n+//! For more information, see the [RFC]. Current implementation is inspired by\n+//! the [Swift] one.\n //!\n-//! For more information, see [the RFC][rfc#2265], or [the working draft][RFC.md].\n+//! The most interesting modules here are `syntax_node` (which defines concrete\n+//! syntax tree) and `ast` (which defines abstract syntax tree on top of the\n+//! CST). The actual parser live in a separate `ra_parser` crate, thought the\n+//! lexer lives in this crate.\n //!\n-//!   [rfc#2256]: <https://github.com/rust-lang/rfcs/pull/2256>\n-//!   [RFC.md]: <https://github.com/matklad/libsyntax2/blob/master/docs/RFC.md>\n-\n-#![forbid(missing_debug_implementations, unconditional_recursion, future_incompatible)]\n-#![deny(bad_style, missing_docs)]\n-#![allow(missing_docs)]\n-//#![warn(unreachable_pub)] // rust-lang/rust#47816\n+//! [RFC]: <https://github.com/rust-lang/rfcs/pull/2256>\n+//! [Swift]: <https://github.com/apple/swift/blob/13d593df6f359d0cb2fc81cfaac273297c539455/lib/Syntax/README.md>\n \n mod syntax_node;\n mod syntax_text;"}, {"sha": "cf573801cb3813f686d584a58fa07486ff003c64", "filename": "crates/ra_syntax/src/parsing.rs", "status": "modified", "additions": 7, "deletions": 37, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/412ac63ff517c7eab5e1cfe0bf239616bd2c13a1/crates%2Fra_syntax%2Fsrc%2Fparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412ac63ff517c7eab5e1cfe0bf239616bd2c13a1/crates%2Fra_syntax%2Fsrc%2Fparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing.rs?ref=412ac63ff517c7eab5e1cfe0bf239616bd2c13a1", "patch": "@@ -1,17 +1,18 @@\n-mod builder;\n+//! Lexing, bridging to ra_parser (which does the actual parsing) and\n+//! incremental reparsing.\n+\n mod lexer;\n mod input;\n+mod builder;\n mod reparsing;\n \n-use ra_parser::{parse, ParseError};\n-\n use crate::{\n-    SyntaxKind, SyntaxError,\n+    SyntaxError,\n+    syntax_node::GreenNode,\n     parsing::{\n         builder::TreeBuilder,\n         input::ParserInput,\n     },\n-    syntax_node::GreenNode,\n };\n \n pub use self::lexer::{tokenize, Token};\n@@ -22,37 +23,6 @@ pub(crate) fn parse_text(text: &str) -> (GreenNode, Vec<SyntaxError>) {\n     let tokens = tokenize(&text);\n     let token_source = ParserInput::new(text, &tokens);\n     let mut tree_sink = TreeBuilder::new(text, &tokens);\n-    parse(&token_source, &mut tree_sink);\n+    ra_parser::parse(&token_source, &mut tree_sink);\n     tree_sink.finish()\n }\n-\n-/// `TreeSink` abstracts details of a particular syntax tree implementation.\n-trait TreeSink {\n-    type Tree;\n-\n-    /// Adds new leaf to the current branch.\n-    fn leaf(&mut self, kind: SyntaxKind, n_tokens: u8);\n-\n-    /// Start new branch and make it current.\n-    fn start_branch(&mut self, kind: SyntaxKind, root: bool);\n-\n-    /// Finish current branch and restore previous\n-    /// branch as current.\n-    fn finish_branch(&mut self, root: bool);\n-\n-    fn error(&mut self, error: ParseError);\n-\n-    /// Complete tree building. Make sure that\n-    /// `start_branch` and `finish_branch` calls\n-    /// are paired!\n-    fn finish(self) -> Self::Tree;\n-}\n-\n-/// `TokenSource` abstracts the source of the tokens parser operates one.\n-///\n-/// Hopefully this will allow us to treat text and token trees in the same way!\n-trait TokenSource {\n-    fn token_kind(&self, pos: usize) -> SyntaxKind;\n-    fn is_token_joint_to_next(&self, pos: usize) -> bool;\n-    fn is_keyword(&self, pos: usize, kw: &str) -> bool;\n-}"}, {"sha": "cfe3139b81b9c68d133faf0c351eb366f8555ab7", "filename": "crates/ra_syntax/src/parsing/builder.rs", "status": "modified", "additions": 44, "deletions": 11, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/412ac63ff517c7eab5e1cfe0bf239616bd2c13a1/crates%2Fra_syntax%2Fsrc%2Fparsing%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412ac63ff517c7eab5e1cfe0bf239616bd2c13a1/crates%2Fra_syntax%2Fsrc%2Fparsing%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Fbuilder.rs?ref=412ac63ff517c7eab5e1cfe0bf239616bd2c13a1", "patch": "@@ -1,4 +1,7 @@\n+use std::mem;\n+\n use ra_parser::{TreeSink, ParseError};\n+use rowan::GreenNodeBuilder;\n \n use crate::{\n     SmolStr, SyntaxError, SyntaxErrorKind, TextUnit, TextRange,\n@@ -7,19 +10,32 @@ use crate::{\n     syntax_node::{GreenNode, RaTypes},\n };\n \n-use rowan::GreenNodeBuilder;\n-\n+/// Bridges the parser with our specific syntax tree representation.\n+///\n+/// `TreeBuilder` also handles attachment of trivia (whitespace) to nodes.\n pub(crate) struct TreeBuilder<'a> {\n     text: &'a str,\n     tokens: &'a [Token],\n     text_pos: TextUnit,\n     token_pos: usize,\n+    state: State,\n     errors: Vec<SyntaxError>,\n     inner: GreenNodeBuilder<RaTypes>,\n }\n \n+enum State {\n+    PendingStart,\n+    Normal,\n+    PendingFinish,\n+}\n+\n impl<'a> TreeSink for TreeBuilder<'a> {\n     fn leaf(&mut self, kind: SyntaxKind, n_tokens: u8) {\n+        match mem::replace(&mut self.state, State::Normal) {\n+            State::PendingStart => unreachable!(),\n+            State::PendingFinish => self.inner.finish_internal(),\n+            State::Normal => (),\n+        }\n         self.eat_trivias();\n         let n_tokens = n_tokens as usize;\n         let len = self.tokens[self.token_pos..self.token_pos + n_tokens]\n@@ -29,11 +45,18 @@ impl<'a> TreeSink for TreeBuilder<'a> {\n         self.do_leaf(kind, len, n_tokens);\n     }\n \n-    fn start_branch(&mut self, kind: SyntaxKind, root: bool) {\n-        if root {\n-            self.inner.start_internal(kind);\n-            return;\n+    fn start_branch(&mut self, kind: SyntaxKind) {\n+        match mem::replace(&mut self.state, State::Normal) {\n+            State::PendingStart => {\n+                self.inner.start_internal(kind);\n+                // No need to attach trivias to previous node: there is no\n+                // previous node.\n+                return;\n+            }\n+            State::PendingFinish => self.inner.finish_internal(),\n+            State::Normal => (),\n         }\n+\n         let n_trivias =\n             self.tokens[self.token_pos..].iter().take_while(|it| it.kind.is_trivia()).count();\n         let leading_trivias = &self.tokens[self.token_pos..self.token_pos + n_trivias];\n@@ -54,11 +77,12 @@ impl<'a> TreeSink for TreeBuilder<'a> {\n         self.eat_n_trivias(n_attached_trivias);\n     }\n \n-    fn finish_branch(&mut self, root: bool) {\n-        if root {\n-            self.eat_trivias()\n+    fn finish_branch(&mut self) {\n+        match mem::replace(&mut self.state, State::PendingFinish) {\n+            State::PendingStart => unreachable!(),\n+            State::PendingFinish => self.inner.finish_internal(),\n+            State::Normal => (),\n         }\n-        self.inner.finish_internal();\n     }\n \n     fn error(&mut self, error: ParseError) {\n@@ -74,12 +98,21 @@ impl<'a> TreeBuilder<'a> {\n             tokens,\n             text_pos: 0.into(),\n             token_pos: 0,\n+            state: State::PendingStart,\n             errors: Vec::new(),\n             inner: GreenNodeBuilder::new(),\n         }\n     }\n \n-    pub(super) fn finish(self) -> (GreenNode, Vec<SyntaxError>) {\n+    pub(super) fn finish(mut self) -> (GreenNode, Vec<SyntaxError>) {\n+        match mem::replace(&mut self.state, State::Normal) {\n+            State::PendingFinish => {\n+                self.eat_trivias();\n+                self.inner.finish_internal()\n+            }\n+            State::PendingStart | State::Normal => unreachable!(),\n+        }\n+\n         (self.inner.finish(), self.errors)\n     }\n "}, {"sha": "31c6a3b9bc2774cfa375f68b2e89fdbc9d104fc6", "filename": "crates/ra_syntax/src/parsing/input.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/412ac63ff517c7eab5e1cfe0bf239616bd2c13a1/crates%2Fra_syntax%2Fsrc%2Fparsing%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412ac63ff517c7eab5e1cfe0bf239616bd2c13a1/crates%2Fra_syntax%2Fsrc%2Fparsing%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Finput.rs?ref=412ac63ff517c7eab5e1cfe0bf239616bd2c13a1", "patch": "@@ -5,6 +5,26 @@ use crate::{\n     parsing::lexer::Token,\n };\n \n+pub(crate) struct ParserInput<'t> {\n+    text: &'t str,\n+    /// start position of each token(expect whitespace and comment)\n+    /// ```non-rust\n+    ///  struct Foo;\n+    /// ^------^---\n+    /// |      |  ^-\n+    /// 0      7  10\n+    /// ```\n+    /// (token, start_offset): `[(struct, 0), (Foo, 7), (;, 10)]`\n+    start_offsets: Vec<TextUnit>,\n+    /// non-whitespace/comment tokens\n+    /// ```non-rust\n+    /// struct Foo {}\n+    /// ^^^^^^ ^^^ ^^\n+    /// ```\n+    /// tokens: `[struct, Foo, {, }]`\n+    tokens: Vec<Token>,\n+}\n+\n impl<'t> TokenSource for ParserInput<'t> {\n     fn token_kind(&self, pos: usize) -> SyntaxKind {\n         if !(pos < self.tokens.len()) {\n@@ -28,26 +48,6 @@ impl<'t> TokenSource for ParserInput<'t> {\n     }\n }\n \n-pub(crate) struct ParserInput<'t> {\n-    text: &'t str,\n-    /// start position of each token(expect whitespace and comment)\n-    /// ```non-rust\n-    ///  struct Foo;\n-    /// ^------^---\n-    /// |      |  ^-\n-    /// 0      7  10\n-    /// ```\n-    /// (token, start_offset): `[(struct, 0), (Foo, 7), (;, 10)]`\n-    start_offsets: Vec<TextUnit>,\n-    /// non-whitespace/comment tokens\n-    /// ```non-rust\n-    /// struct Foo {}\n-    /// ^^^^^^ ^^^ ^^\n-    /// ```\n-    /// tokens: `[struct, Foo, {, }]`\n-    tokens: Vec<Token>,\n-}\n-\n impl<'t> ParserInput<'t> {\n     /// Generate input from tokens(expect comment and whitespace).\n     pub fn new(text: &'t str, raw_tokens: &'t [Token]) -> ParserInput<'t> {"}, {"sha": "6957c26c0e984cca66f285c0c8e9bf95e205e257", "filename": "crates/ra_syntax/src/parsing/reparsing.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/412ac63ff517c7eab5e1cfe0bf239616bd2c13a1/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412ac63ff517c7eab5e1cfe0bf239616bd2c13a1/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs?ref=412ac63ff517c7eab5e1cfe0bf239616bd2c13a1", "patch": "@@ -1,11 +1,18 @@\n+//! Implementation of incremental re-parsing.\n+//!\n+//! We use two simple strategies for this:\n+//!   - if the edit modifies only a single token (like changing an identifier's\n+//!     letter), we replace only this token.\n+//!   - otherwise, we search for the nearest `{}` block which contains the edit\n+//!     and try to parse only this block.\n+\n use ra_text_edit::AtomTextEdit;\n use ra_parser::Reparser;\n \n use crate::{\n-    SyntaxKind::*, TextRange, TextUnit,\n+    SyntaxKind::*, TextRange, TextUnit, SyntaxError,\n     algo,\n     syntax_node::{GreenNode, SyntaxNode},\n-    syntax_error::SyntaxError,\n     parsing::{\n         input::ParserInput,\n         builder::TreeBuilder,"}, {"sha": "a1bc0b499465f398ac744247bcd96b6bf494b9c6", "filename": "crates/ra_syntax/src/syntax_node.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/412ac63ff517c7eab5e1cfe0bf239616bd2c13a1/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412ac63ff517c7eab5e1cfe0bf239616bd2c13a1/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs?ref=412ac63ff517c7eab5e1cfe0bf239616bd2c13a1", "patch": "@@ -1,3 +1,11 @@\n+//! This module defines Concrete Syntax Tree (CST), used by rust-analyzer.\n+//!\n+//! The CST includes comments and whitespace, provides a single node type,\n+//! `SyntaxNode`, and a basic traversal API (parent, children, siblings).\n+//!\n+//! The *real* implementation is in the (language-agnostic) `rowan` crate, this\n+//! modules just wraps its API.\n+\n use std::{fmt, borrow::Borrow};\n \n use rowan::{Types, TransparentNewType};"}]}