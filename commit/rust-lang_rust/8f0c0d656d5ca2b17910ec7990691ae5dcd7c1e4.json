{"sha": "8f0c0d656d5ca2b17910ec7990691ae5dcd7c1e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmMGMwZDY1NmQ1Y2EyYjE3OTEwZWM3OTkwNjkxYWU1ZGNkN2MxZTQ=", "commit": {"author": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-09-26T21:07:00Z"}, "committer": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-11-11T01:58:54Z"}, "message": "Initial work for doing minimum capture analysis for RFC-2229\n\nCo-authored-by: Chris Pardy <chrispardy36@gmail.com>\nCo-authored-by: Logan Mosier <logmosier@gmail.com>", "tree": {"sha": "c8570263c3ccde2ce0eb345c75eee5ca001d38a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8570263c3ccde2ce0eb345c75eee5ca001d38a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f0c0d656d5ca2b17910ec7990691ae5dcd7c1e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f0c0d656d5ca2b17910ec7990691ae5dcd7c1e4", "html_url": "https://github.com/rust-lang/rust/commit/8f0c0d656d5ca2b17910ec7990691ae5dcd7c1e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f0c0d656d5ca2b17910ec7990691ae5dcd7c1e4/comments", "author": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "145312075f02bf4303f5b638f4c6187f43900f1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/145312075f02bf4303f5b638f4c6187f43900f1c", "html_url": "https://github.com/rust-lang/rust/commit/145312075f02bf4303f5b638f4c6187f43900f1c"}], "stats": {"total": 489, "additions": 374, "deletions": 115}, "files": [{"sha": "76ca0c51ce1c3b59c24ffbe936fa0a28889ecdec", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8f0c0d656d5ca2b17910ec7990691ae5dcd7c1e4/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f0c0d656d5ca2b17910ec7990691ae5dcd7c1e4/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=8f0c0d656d5ca2b17910ec7990691ae5dcd7c1e4", "patch": "@@ -415,9 +415,10 @@ pub struct TypeckResults<'tcx> {\n     /// entire variable.\n     pub closure_captures: ty::UpvarListMap,\n \n-    /// Given the closure ID this map provides the list of\n-    /// `Place`s and how/why are they captured by the closure.\n-    pub closure_capture_information: ty::CaptureInformationMap<'tcx>,\n+    /// Given the closure DefId this map provides a map of\n+    /// root variables to minimum set of `Place`s (and how) that need to be tracked\n+    /// to support all captures of that closure.\n+    pub closure_min_captures: ty::MinCaptureInformationMap<'tcx>,\n \n     /// Stores the type, expression, span and optional scope span of all types\n     /// that are live across the yield of this generator (if a generator).\n@@ -446,7 +447,7 @@ impl<'tcx> TypeckResults<'tcx> {\n             tainted_by_errors: None,\n             concrete_opaque_types: Default::default(),\n             closure_captures: Default::default(),\n-            closure_capture_information: Default::default(),\n+            closure_min_captures: Default::default(),\n             generator_interior_types: Default::default(),\n         }\n     }\n@@ -681,7 +682,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckResults<'tcx> {\n             tainted_by_errors,\n             ref concrete_opaque_types,\n             ref closure_captures,\n-            ref closure_capture_information,\n+            ref closure_min_captures,\n             ref generator_interior_types,\n         } = *self;\n \n@@ -715,7 +716,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckResults<'tcx> {\n             tainted_by_errors.hash_stable(hcx, hasher);\n             concrete_opaque_types.hash_stable(hcx, hasher);\n             closure_captures.hash_stable(hcx, hasher);\n-            closure_capture_information.hash_stable(hcx, hasher);\n+            closure_min_captures.hash_stable(hcx, hasher);\n             generator_interior_types.hash_stable(hcx, hasher);\n         })\n     }"}, {"sha": "c41463d18448dbd1256c224ec7fcb05c435846b5", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8f0c0d656d5ca2b17910ec7990691ae5dcd7c1e4/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f0c0d656d5ca2b17910ec7990691ae5dcd7c1e4/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=8f0c0d656d5ca2b17910ec7990691ae5dcd7c1e4", "patch": "@@ -788,30 +788,18 @@ pub struct CaptureInfo<'tcx> {\n     pub capture_kind: UpvarCapture<'tcx>,\n }\n \n+#[derive(PartialEq, Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n+pub struct CapturedPlace<'tcx> {\n+    pub place: HirPlace<'tcx>,\n+    pub info: CaptureInfo<'tcx>,\n+}\n+\n pub type UpvarListMap = FxHashMap<DefId, FxIndexMap<hir::HirId, UpvarId>>;\n pub type UpvarCaptureMap<'tcx> = FxHashMap<UpvarId, UpvarCapture<'tcx>>;\n \n-/// Consider closure where s.str1 is captured via an ImmutableBorrow and s.str2 via a MutableBorrow\n-///\n-/// ```rust\n-/// // Assume that thte HirId for the variable definition is `V1`\n-/// let mut s = SomeStruct { str1: format!(\"s1\"), str2: format!(\"s2\") }\n-///\n-/// let fix_s = |new_s2| {\n-///     // Assume that the HirId for the expression `s.str1` is `E1`\n-///     println!(\"Updating SomeStruct with str1=\", s.str1);\n-///     // Assume that the HirId for the expression `*s.str2` is `E2`\n-///     s.str2 = new_s2;\n-/// }\n-/// ```\n-///\n-/// For closure `fix_s`, (at a high level) the IndexMap will contain:\n-///\n-/// Place { V1, [ProjectionKind::Field(Index=0, Variant=0)] } : CaptureKind { E1, ImmutableBorrow }\n-/// Place { V1, [ProjectionKind::Field(Index=1, Variant=0)] } : CaptureKind { E2, MutableBorrow }\n-///\n-pub type CaptureInformationMap<'tcx> =\n-    FxHashMap<DefId, FxIndexMap<HirPlace<'tcx>, CaptureInfo<'tcx>>>;\n+pub type MinCaptureList<'tcx> = Vec<CapturedPlace<'tcx>>;\n+pub type RootVariableMinCaptureList<'tcx> = FxIndexMap<hir::HirId, MinCaptureList<'tcx>>;\n+pub type MinCaptureInformationMap<'tcx> = FxHashMap<DefId, RootVariableMinCaptureList<'tcx>>;\n \n #[derive(Clone, Copy, PartialEq, Eq)]\n pub enum IntVarValue {"}, {"sha": "41f3edaa413800b965ca105e963fab6c78575c3e", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8f0c0d656d5ca2b17910ec7990691ae5dcd7c1e4/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f0c0d656d5ca2b17910ec7990691ae5dcd7c1e4/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=8f0c0d656d5ca2b17910ec7990691ae5dcd7c1e4", "patch": "@@ -383,16 +383,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     self.describe_field_from_ty(&ty, field, variant_index)\n                 }\n                 ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n-                    // `tcx.upvars_mentioned(def_id)` returns an `Option`, which is `None` in case\n-                    // the closure comes from another crate. But in that case we wouldn't\n-                    // be borrowck'ing it, so we can just unwrap:\n-                    let (&var_id, _) = self\n-                        .infcx\n-                        .tcx\n-                        .upvars_mentioned(def_id)\n-                        .unwrap()\n-                        .get_index(field.index())\n-                        .unwrap();\n+                    // We won't be borrowck'ing here if the closure came from another crate,\n+                    // so it's safe to call `expect_local`.\n+                    //\n+                    // We know the field exists so it's safe to call operator[] and `unwrap` here.\n+                    let (&var_id, _) =\n+                        self.infcx.tcx.typeck(def_id.expect_local()).closure_captures[&def_id]\n+                            .get_index(field.index())\n+                            .unwrap();\n \n                     self.infcx.tcx.hir().name(var_id).to_string()\n                 }\n@@ -967,9 +965,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let expr = &self.infcx.tcx.hir().expect_expr(hir_id).kind;\n         debug!(\"closure_span: hir_id={:?} expr={:?}\", hir_id, expr);\n         if let hir::ExprKind::Closure(.., body_id, args_span, _) = expr {\n-            for ((upvar_hir_id, upvar), place) in\n-                self.infcx.tcx.upvars_mentioned(def_id)?.iter().zip(places)\n+            for (upvar_hir_id, place) in\n+                self.infcx.tcx.typeck(def_id.expect_local()).closure_captures[&def_id]\n+                    .keys()\n+                    .zip(places)\n             {\n+                let span = self.infcx.tcx.upvars_mentioned(local_did)?[upvar_hir_id].span;\n                 match place {\n                     Operand::Copy(place) | Operand::Move(place)\n                         if target_place == place.as_ref() =>\n@@ -991,7 +992,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         let usage_span =\n                             match self.infcx.tcx.typeck(local_did).upvar_capture(upvar_id) {\n                                 ty::UpvarCapture::ByValue(Some(span)) => span,\n-                                _ => upvar.span,\n+                                _ => span,\n                             };\n                         return Some((*args_span, generator_kind, usage_span));\n                     }"}, {"sha": "4b6d10357ef1171acd05ba106022ea83bb88bf31", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 283, "deletions": 35, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/8f0c0d656d5ca2b17910ec7990691ae5dcd7c1e4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f0c0d656d5ca2b17910ec7990691ae5dcd7c1e4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=8f0c0d656d5ca2b17910ec7990691ae5dcd7c1e4", "patch": "@@ -39,11 +39,13 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_infer::infer::UpvarRegion;\n-use rustc_middle::hir::place::{Place, PlaceBase, PlaceWithHirId};\n+use rustc_middle::hir::place::{Place, PlaceBase, PlaceWithHirId, ProjectionKind};\n use rustc_middle::ty::{self, Ty, TyCtxt, UpvarSubsts};\n use rustc_span::sym;\n use rustc_span::{Span, Symbol};\n \n+use std::env;\n+\n macro_rules! log_capture_analysis {\n     ($fcx:expr, $closure_def_id:expr, $fmt:literal) => {\n         if $fcx.should_log_capture_analysis($closure_def_id) {\n@@ -60,6 +62,17 @@ macro_rules! log_capture_analysis {\n     };\n }\n \n+/// Describe the relationship between the paths of two places\n+/// eg:\n+/// - foo is ancestor of foo.bar.baz\n+/// - foo.bar.baz is an descendant of foo.bar,\n+/// - foo.bar and foo.baz are divergent\n+enum PlaceAncestryRelation {\n+    Ancestor,\n+    Descendant,\n+    Divergent,\n+}\n+\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn closure_analyze(&self, body: &'tcx hir::Body<'tcx>) {\n         InferBorrowKindVisitor { fcx: self }.visit_body(body);\n@@ -130,7 +143,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let local_def_id = closure_def_id.expect_local();\n \n         let mut capture_information = FxIndexMap::<Place<'tcx>, ty::CaptureInfo<'tcx>>::default();\n-        if self.tcx.features().capture_disjoint_fields {\n+        if self.tcx.features().capture_disjoint_fields || matches!(env::var(\"SG_NEW\"), Ok(_)) {\n             log_capture_analysis!(self, closure_def_id, \"Using new-style capture analysis\");\n         } else {\n             log_capture_analysis!(self, closure_def_id, \"Using old-style capture analysis\");\n@@ -192,12 +205,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n-        self.set_closure_captures(closure_def_id, &delegate);\n-\n-        self.typeck_results\n-            .borrow_mut()\n-            .closure_capture_information\n-            .insert(closure_def_id, delegate.capture_information);\n+        self.compute_min_captures(closure_def_id, delegate);\n+        self.set_closure_captures(closure_def_id);\n \n         // Now that we've analyzed the closure, we know how each\n         // variable is borrowed, and we know what traits the closure\n@@ -266,43 +275,221 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .collect()\n     }\n \n-    fn set_closure_captures(\n+    /// Bridge for closure analysis\n+    /// ----------------------------\n+    ///\n+    /// For closure with DefId `c`, the bridge converts structures required for supporting RFC 2229,\n+    /// to structures currently used in the compiler for handling closure captures.\n+    ///\n+    /// For example the following structure will be converted:\n+    ///\n+    /// closure_min_captures\n+    /// foo -> [ {foo.x, ImmBorrow}, {foo.y, MutBorrow} ]\n+    /// bar -> [ {bar.z, ByValue}, {bar.q, MutBorrow} ]\n+    ///\n+    /// to\n+    ///\n+    /// 1. closure_captures\n+    /// foo -> UpvarId(foo, c), bar -> UpvarId(bar, c)\n+    ///\n+    /// 2. upvar_capture_map\n+    /// UpvarId(foo,c) -> MutBorrow, UpvarId(bar, c) -> ByValue\n+\n+    fn set_closure_captures(&self, closure_def_id: DefId) {\n+        let mut closure_captures: FxIndexMap<hir::HirId, ty::UpvarId> = Default::default();\n+        let mut upvar_capture_map = ty::UpvarCaptureMap::default();\n+\n+        if let Some(min_captures) =\n+            self.typeck_results.borrow().closure_min_captures.get(&closure_def_id)\n+        {\n+            for (var_hir_id, min_list) in min_captures.iter() {\n+                for captured_place in min_list {\n+                    let place = &captured_place.place;\n+                    let capture_info = captured_place.info;\n+\n+                    let upvar_id = match place.base {\n+                        PlaceBase::Upvar(upvar_id) => upvar_id,\n+                        base => bug!(\"Expected upvar, found={:?}\", base),\n+                    };\n+\n+                    assert_eq!(upvar_id.var_path.hir_id, *var_hir_id);\n+                    assert_eq!(upvar_id.closure_expr_id, closure_def_id.expect_local());\n+\n+                    closure_captures.insert(*var_hir_id, upvar_id);\n+\n+                    let new_capture_kind = if let Some(capture_kind) =\n+                        upvar_capture_map.get(&upvar_id)\n+                    {\n+                        // upvar_capture_map only stores the UpvarCapture (CaptureKind),\n+                        // so we create a fake capture info with no expression.\n+                        let fake_capture_info =\n+                            ty::CaptureInfo { expr_id: None, capture_kind: capture_kind.clone() };\n+                        self.determine_capture_info(fake_capture_info, capture_info.clone())\n+                            .capture_kind\n+                    } else {\n+                        capture_info.capture_kind\n+                    };\n+                    upvar_capture_map.insert(upvar_id, new_capture_kind);\n+                }\n+            }\n+        }\n+        debug!(\n+            \"For closure_def_id={:?}, set_closure_captures={:#?}\",\n+            closure_def_id, closure_captures\n+        );\n+        debug!(\n+            \"For closure_def_id={:?}, upvar_capture_map={:#?}\",\n+            closure_def_id, upvar_capture_map\n+        );\n+\n+        if !closure_captures.is_empty() {\n+            self.typeck_results\n+                .borrow_mut()\n+                .closure_captures\n+                .insert(closure_def_id, closure_captures);\n+\n+            self.typeck_results.borrow_mut().upvar_capture_map.extend(upvar_capture_map);\n+        }\n+    }\n+\n+    /// Analyses the information collected by InferBorrowKind to compute the min number of\n+    /// Places (and corresponding capture kind) that we need to keep track of to support all\n+    /// the required captured paths.\n+    ///\n+    /// Eg:\n+    /// ```rust\n+    /// struct Point { x: i32, y: i32 }\n+    ///\n+    /// let s: String;  // hir_id_s\n+    /// let mut p: Point; // his_id_p\n+    /// let c = || {\n+    ///        println!(\"{}\", s);  // L1\n+    ///        p.x += 10;  // L2\n+    ///        println!(\"{}\" , p.y) // L3\n+    ///        println!(\"{}\", p) // L4\n+    ///        drop(s);   // L5\n+    /// };\n+    /// ```\n+    /// and let hir_id_L1..5 be the expressions pointing to use of a captured variable on\n+    /// the lines L1..5 respectively.\n+    ///\n+    /// InferBorrowKind results in a structure like this:\n+    ///\n+    /// ```\n+    /// {\n+    ///       Place(base: hir_id_s, projections: [], ....) -> (hir_id_L5, ByValue),\n+    ///       Place(base: hir_id_p, projections: [Field(0, 0)], ...) -> (hir_id_L2, ByRef(MutBorrow))\n+    ///       Place(base: hir_id_p, projections: [Field(1, 0)], ...) -> (hir_id_L3, ByRef(ImmutBorrow))\n+    ///       Place(base: hir_id_p, projections: [], ...) -> (hir_id_L4, ByRef(ImmutBorrow))\n+    /// ```\n+    ///\n+    /// After the min capture analysis, we get:\n+    /// ```\n+    /// {\n+    ///       hir_id_s -> [\n+    ///            Place(base: hir_id_s, projections: [], ....) -> (hir_id_L4, ByValue)\n+    ///       ],\n+    ///       hir_id_p -> [\n+    ///            Place(base: hir_id_p, projections: [], ...) -> (hir_id_L2, ByRef(MutBorrow)),\n+    ///       ],\n+    /// ```\n+    fn compute_min_captures(\n         &self,\n         closure_def_id: DefId,\n-        inferred_info: &InferBorrowKind<'_, 'tcx>,\n+        inferred_info: InferBorrowKind<'_, 'tcx>,\n     ) {\n-        let mut closure_captures: FxIndexMap<hir::HirId, ty::UpvarId> = Default::default();\n+        let mut root_var_min_capture_list: ty::RootVariableMinCaptureList<'_> = Default::default();\n \n-        for (place, capture_info) in inferred_info.capture_information.iter() {\n-            let upvar_id = match place.base {\n-                PlaceBase::Upvar(upvar_id) => upvar_id,\n+        for (place, capture_info) in inferred_info.capture_information.into_iter() {\n+            let var_hir_id = match place.base {\n+                PlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n                 base => bug!(\"Expected upvar, found={:?}\", base),\n             };\n \n-            assert_eq!(upvar_id.closure_expr_id, closure_def_id.expect_local());\n-\n-            let var_hir_id = upvar_id.var_path.hir_id;\n-            closure_captures.insert(var_hir_id, upvar_id);\n-\n-            let new_capture_kind = if let Some(capture_kind) =\n-                self.typeck_results.borrow_mut().upvar_capture_map.get(&upvar_id)\n-            {\n-                // upvar_capture_map only stores the UpvarCapture (CaptureKind),\n-                // so we create a fake capture info with no expression.\n-                let fake_capture_info =\n-                    ty::CaptureInfo { expr_id: None, capture_kind: capture_kind.clone() };\n-                self.determine_capture_info(fake_capture_info, capture_info.clone()).capture_kind\n-            } else {\n-                capture_info.capture_kind\n+            // Arrays are captured in entirety, drop Index projections and projections\n+            // after Index projections.\n+            let first_index_projection =\n+                place.projections.split(|proj| ProjectionKind::Index == proj.kind).next();\n+            let place = Place {\n+                base_ty: place.base_ty,\n+                base: place.base,\n+                projections: first_index_projection.map_or(Vec::new(), |p| p.to_vec()),\n+            };\n+\n+            let min_cap_list = match root_var_min_capture_list.get_mut(&var_hir_id) {\n+                None => {\n+                    let min_cap_list = vec![ty::CapturedPlace { place: place, info: capture_info }];\n+                    root_var_min_capture_list.insert(var_hir_id, min_cap_list);\n+                    continue;\n+                }\n+                Some(min_cap_list) => min_cap_list,\n             };\n-            self.typeck_results.borrow_mut().upvar_capture_map.insert(upvar_id, new_capture_kind);\n+\n+            // Go through each entry in the current list of min_captures\n+            // - if ancestor is found, update it's capture kind to account for current place's\n+            // capture information.\n+            //\n+            // - if descendant is found, remove it from the list, and update the current place's\n+            // capture information to account for the descendants's capture kind.\n+            //\n+            // We can never be in a case where the list contains both an ancestor and a descendant\n+            // Also there can only be ancestor but in case of descendants there might be\n+            // multiple.\n+\n+            let mut descendant_found = false;\n+            let mut updated_capture_info = capture_info;\n+            min_cap_list.retain(|possible_descendant| {\n+                match determine_place_ancestry_relation(&place, &possible_descendant.place) {\n+                    // current place is ancestor of possible_descendant\n+                    PlaceAncestryRelation::Ancestor => {\n+                        descendant_found = true;\n+                        updated_capture_info = self\n+                            .determine_capture_info(updated_capture_info, possible_descendant.info);\n+                        false\n+                    }\n+\n+                    _ => true,\n+                }\n+            });\n+\n+            let mut ancestor_found = false;\n+            if !descendant_found {\n+                for possible_ancestor in min_cap_list.iter_mut() {\n+                    match determine_place_ancestry_relation(&place, &possible_ancestor.place) {\n+                        // current place is descendant of possible_ancestor\n+                        PlaceAncestryRelation::Descendant => {\n+                            ancestor_found = true;\n+                            possible_ancestor.info =\n+                                self.determine_capture_info(possible_ancestor.info, capture_info);\n+\n+                            // Only one ancestor of the current place will be in the list.\n+                            break;\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+\n+            // Only need to insert when we don't have an ancestor in the existing min capture list\n+            if !ancestor_found {\n+                let captured_place =\n+                    ty::CapturedPlace { place: place.clone(), info: updated_capture_info };\n+                min_cap_list.push(captured_place);\n+            }\n         }\n \n-        if !closure_captures.is_empty() {\n+        log_capture_analysis!(\n+            self,\n+            closure_def_id,\n+            \"min_captures={:#?}\",\n+            root_var_min_capture_list\n+        );\n+\n+        if !root_var_min_capture_list.is_empty() {\n             self.typeck_results\n                 .borrow_mut()\n-                .closure_captures\n-                .insert(closure_def_id, closure_captures);\n+                .closure_min_captures\n+                .insert(closure_def_id, root_var_min_capture_list);\n         }\n     }\n \n@@ -418,8 +605,27 @@ struct InferBorrowKind<'a, 'tcx> {\n     // variable access that caused us to do so.\n     current_origin: Option<(Span, Symbol)>,\n \n-    // For each upvar that we access, we track the minimal kind of\n-    // access we need (ref, ref mut, move, etc).\n+    /// For each Place that we access, we track the minimal kind of\n+    /// access we need (ref, ref mut, move, etc) and the expression that resulted in such access.\n+    /// Consider closure where s.str1 is captured via an ImmutableBorrow and\n+    /// s.str2 via a MutableBorrow\n+    ///\n+    /// ```rust\n+    /// // Assume that the HirId for the variable definition is `V1`\n+    /// let mut s = SomeStruct { str1: format!(\"s1\"), str2: format!(\"s2\") }\n+    ///\n+    /// let fix_s = |new_s2| {\n+    ///     // Assume that the HirId for the expression `s.str1` is `E1`\n+    ///     println!(\"Updating SomeStruct with str1=\", s.str1);\n+    ///     // Assume that the HirId for the expression `*s.str2` is `E2`\n+    ///     s.str2 = new_s2;\n+    /// }\n+    /// ```\n+    ///\n+    /// For closure `fix_s`, (at a high level) the map contains\n+    ///\n+    /// Place { V1, [ProjectionKind::Field(Index=0, Variant=0)] } : CaptureKind { E1, ImmutableBorrow }\n+    /// Place { V1, [ProjectionKind::Field(Index=1, Variant=0)] } : CaptureKind { E2, MutableBorrow }\n     capture_information: FxIndexMap<Place<'tcx>, ty::CaptureInfo<'tcx>>,\n }\n \n@@ -714,3 +920,45 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n fn var_name(tcx: TyCtxt<'_>, var_hir_id: hir::HirId) -> Symbol {\n     tcx.hir().name(var_hir_id)\n }\n+\n+/// Determines the Ancestry relationship of Place A relative to Place B\n+///\n+/// `PlaceAncestryRelation::Ancestor` implies Place A is ancestor of Place B\n+/// `PlaceAncestryRelation::Descendant` implies Place A is descendant of Place B\n+/// `PlaceAncestryRelation::Divergent` implies neither of them is the ancestor of the other.\n+fn determine_place_ancestry_relation(\n+    place_a: &Place<'tcx>,\n+    place_b: &Place<'tcx>,\n+) -> PlaceAncestryRelation {\n+    // If Place A and Place B, don't start off from the same root variable, they are divergent.\n+    if place_a.base != place_b.base {\n+        return PlaceAncestryRelation::Divergent;\n+    }\n+\n+    // Assume of length of projections_a = n\n+    let projections_a = &place_a.projections;\n+\n+    // Assume of length of projections_b = m\n+    let projections_b = &place_b.projections;\n+\n+    let mut same_initial_projections = true;\n+\n+    for (proj_a, proj_b) in projections_a.iter().zip(projections_b.iter()) {\n+        if proj_a != proj_b {\n+            same_initial_projections = false;\n+            break;\n+        }\n+    }\n+\n+    if same_initial_projections {\n+        // First min(n, m) projections are the same\n+        // Select Ancestor/Descendant\n+        if projections_b.len() >= projections_a.len() {\n+            PlaceAncestryRelation::Ancestor\n+        } else {\n+            PlaceAncestryRelation::Descendant\n+        }\n+    } else {\n+        PlaceAncestryRelation::Divergent\n+    }\n+}"}, {"sha": "83cc1da69851f428bba762e50b4af3aaa1657ef4", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 61, "deletions": 40, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/8f0c0d656d5ca2b17910ec7990691ae5dcd7c1e4/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f0c0d656d5ca2b17910ec7990691ae5dcd7c1e4/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=8f0c0d656d5ca2b17910ec7990691ae5dcd7c1e4", "patch": "@@ -18,7 +18,6 @@ use rustc_middle::ty::{self, adjustment, TyCtxt};\n use rustc_target::abi::VariantIdx;\n \n use crate::mem_categorization as mc;\n-use rustc_span::Span;\n \n ///////////////////////////////////////////////////////////////////////////\n // The Delegate trait\n@@ -331,8 +330,8 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 self.consume_expr(base);\n             }\n \n-            hir::ExprKind::Closure(_, _, _, fn_decl_span, _) => {\n-                self.walk_captures(expr, fn_decl_span);\n+            hir::ExprKind::Closure(..) => {\n+                self.walk_captures(expr);\n             }\n \n             hir::ExprKind::Box(ref base) => {\n@@ -571,51 +570,73 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         }));\n     }\n \n-    // FIXME(arora-aman):  fix the fn_decl_span\n-    fn walk_captures(&mut self, closure_expr: &hir::Expr<'_>, _fn_decl_span: Span) {\n+    /// Handle the case where the current body contains a closure.\n+    ///\n+    /// When the current body being handled is a closure, then we must make sure that\n+    /// - The parent closure only captures Places from the nested closure that are not local to it.\n+    ///\n+    /// In the following example the closures `c` only captures `p.x`` even though `incr`\n+    /// is a capture of the nested closure\n+    ///\n+    /// ```rust\n+    /// let p = ..;\n+    /// let c = || {\n+    ///    let incr = 10;\n+    ///    let nested = || p.x += incr;\n+    /// }\n+    /// ```\n+    ///\n+    /// - When reporting the Place back to the Delegate, ensure that the UpvarId uses the enclosing\n+    /// closure as the DefId.\n+    fn walk_captures(&mut self, closure_expr: &hir::Expr<'_>) {\n         debug!(\"walk_captures({:?})\", closure_expr);\n \n-        // We are currently walking a closure that is within a given body\n-        // We need to process all the captures for this closure.\n         let closure_def_id = self.tcx().hir().local_def_id(closure_expr.hir_id).to_def_id();\n         let upvars = self.tcx().upvars_mentioned(self.body_owner);\n-        if let Some(closure_capture_information) =\n-            self.mc.typeck_results.closure_capture_information.get(&closure_def_id)\n-        {\n-            for (place, capture_info) in closure_capture_information.iter() {\n-                let var_hir_id = if let PlaceBase::Upvar(upvar_id) = place.base {\n-                    upvar_id.var_path.hir_id\n-                } else {\n-                    continue;\n-                    // FIXME(arora-aman): throw err?\n-                };\n \n-                if !upvars.map_or(false, |upvars| upvars.contains_key(&var_hir_id)) {\n-                    // The nested closure might be capturing our local variables\n-                    // Since for the current body these aren't captures, we will ignore them.\n+        // For purposes of this function, generator and closures are equivalent.\n+        let body_owner_is_closure = match self.tcx().type_of(self.body_owner.to_def_id()).kind() {\n+            ty::Closure(..) | ty::Generator(..) => true,\n+            _ => false,\n+        };\n+\n+        if let Some(min_captures) = self.mc.typeck_results.closure_min_captures.get(&closure_def_id)\n+        {\n+            for (var_hir_id, min_list) in min_captures.iter() {\n+                if upvars.map_or(body_owner_is_closure, |upvars| !upvars.contains_key(var_hir_id)) {\n+                    // The nested closure might be capturing the current (enclosing) closure's local variables.\n+                    // We check if the root variable is ever mentioned within the enclosing closure, if not\n+                    // then for the current body (if it's a closure) these aren't captures, we will ignore them.\n                     continue;\n                 }\n+                for captured_place in min_list {\n+                    let place = &captured_place.place;\n+                    let capture_info = captured_place.info;\n \n-                // The place is being captured by the enclosing closure\n-                // FIXME(arora-aman) Make sure this is valid to do when called from clippy.\n-                let upvar_id = ty::UpvarId::new(var_hir_id, self.body_owner);\n-                let place_with_id = PlaceWithHirId::new(\n-                    capture_info.expr_id.unwrap_or(closure_expr.hir_id),\n-                    place.base_ty,\n-                    PlaceBase::Upvar(upvar_id),\n-                    place.projections.clone(),\n-                );\n-                match capture_info.capture_kind {\n-                    ty::UpvarCapture::ByValue(_) => {\n-                        let mode = copy_or_move(&self.mc, &place_with_id);\n-                        self.delegate.consume(&place_with_id, place_with_id.hir_id, mode);\n-                    }\n-                    ty::UpvarCapture::ByRef(upvar_borrow) => {\n-                        self.delegate.borrow(\n-                            &place_with_id,\n-                            place_with_id.hir_id,\n-                            upvar_borrow.kind,\n-                        );\n+                    let upvar_id = if body_owner_is_closure {\n+                        // Mark the place to be captured by the enclosing closure\n+                        ty::UpvarId::new(*var_hir_id, self.body_owner)\n+                    } else {\n+                        ty::UpvarId::new(*var_hir_id, closure_def_id.expect_local())\n+                    };\n+                    let place_with_id = PlaceWithHirId::new(\n+                        capture_info.expr_id.unwrap_or(closure_expr.hir_id),\n+                        place.base_ty,\n+                        PlaceBase::Upvar(upvar_id),\n+                        place.projections.clone(),\n+                    );\n+                    match capture_info.capture_kind {\n+                        ty::UpvarCapture::ByValue(_) => {\n+                            let mode = copy_or_move(&self.mc, &place_with_id);\n+                            self.delegate.consume(&place_with_id, place_with_id.hir_id, mode);\n+                        }\n+                        ty::UpvarCapture::ByRef(upvar_borrow) => {\n+                            self.delegate.borrow(\n+                                &place_with_id,\n+                                place_with_id.hir_id,\n+                                upvar_borrow.kind,\n+                            );\n+                        }\n                     }\n                 }\n             }"}]}