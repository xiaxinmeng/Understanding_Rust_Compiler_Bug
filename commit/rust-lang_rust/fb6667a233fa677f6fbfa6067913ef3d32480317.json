{"sha": "fb6667a233fa677f6fbfa6067913ef3d32480317", "node_id": "C_kwDOAAsO6NoAKGZiNjY2N2EyMzNmYTY3N2Y2ZmJmYTYwNjc5MTNlZjNkMzI0ODAzMTc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-12T23:29:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-12T23:29:11Z"}, "message": "Auto merge of #103311 - petrochenkov:pblfix, r=bjorn3\n\nlinker: Refactoring and fixes to native library linking\n\nThis PR contains a bunch of code cleanup and comment rearrangements + 2 fixes for `-Zpacked-bundled-libs`.\nIt's better to look at individual commits.", "tree": {"sha": "848f96751b19f8d34867f08c4af85c73a19132c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/848f96751b19f8d34867f08c4af85c73a19132c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb6667a233fa677f6fbfa6067913ef3d32480317", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb6667a233fa677f6fbfa6067913ef3d32480317", "html_url": "https://github.com/rust-lang/rust/commit/fb6667a233fa677f6fbfa6067913ef3d32480317", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb6667a233fa677f6fbfa6067913ef3d32480317/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6284998a2677d7e3e8420db783f3aa4fd80d7423", "url": "https://api.github.com/repos/rust-lang/rust/commits/6284998a2677d7e3e8420db783f3aa4fd80d7423", "html_url": "https://github.com/rust-lang/rust/commit/6284998a2677d7e3e8420db783f3aa4fd80d7423"}, {"sha": "c2358a15f31b35971a59c4bda138409c527fe4fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2358a15f31b35971a59c4bda138409c527fe4fc", "html_url": "https://github.com/rust-lang/rust/commit/c2358a15f31b35971a59c4bda138409c527fe4fc"}], "stats": {"total": 736, "additions": 349, "deletions": 387}, "files": [{"sha": "2bd9023395dbdde765922bce927f3e353ba6826c", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 332, "deletions": 380, "changes": 712, "blob_url": "https://github.com/rust-lang/rust/blob/fb6667a233fa677f6fbfa6067913ef3d32480317/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb6667a233fa677f6fbfa6067913ef3d32480317/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=fb6667a233fa677f6fbfa6067913ef3d32480317", "patch": "@@ -6,7 +6,7 @@ use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::temp_dir::MaybeTempDir;\n use rustc_errors::{ErrorGuaranteed, Handler};\n use rustc_fs_util::fix_windows_verbatim_for_gcc;\n-use rustc_hir::def_id::CrateNum;\n+use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_metadata::find_native_static_library;\n use rustc_metadata::fs::{emit_metadata, METADATA_FILENAME};\n use rustc_middle::middle::dependency_format::Linkage;\n@@ -24,7 +24,7 @@ use rustc_span::symbol::Symbol;\n use rustc_span::DebuggerVisualizerFile;\n use rustc_target::spec::crt_objects::{CrtObjects, LinkSelfContainedDefault};\n use rustc_target::spec::{Cc, LinkOutputKind, LinkerFlavor, LinkerFlavorCli, Lld, PanicStrategy};\n-use rustc_target::spec::{RelocModel, RelroLevel, SanitizerSet, SplitDebuginfo, Target};\n+use rustc_target::spec::{RelocModel, RelroLevel, SanitizerSet, SplitDebuginfo};\n \n use super::archive::{ArchiveBuilder, ArchiveBuilderBuilder};\n use super::command::Command;\n@@ -2007,15 +2007,9 @@ fn linker_with_args<'a>(\n     cmd.add_as_needed();\n \n     // Local native libraries of all kinds.\n-    //\n-    // If `-Zlink-native-libraries=false` is set, then the assumption is that an\n-    // external build system already has the native dependencies defined, and it\n-    // will provide them to the linker itself.\n-    if sess.opts.unstable_opts.link_native_libraries {\n-        add_local_native_libraries(cmd, sess, codegen_results);\n-    }\n+    add_local_native_libraries(cmd, sess, archive_builder_builder, codegen_results, tmpdir);\n \n-    // Upstream rust libraries and their (possibly bundled) static native libraries.\n+    // Upstream rust crates and their non-dynamic native libraries.\n     add_upstream_rust_crates(\n         cmd,\n         sess,\n@@ -2026,13 +2020,7 @@ fn linker_with_args<'a>(\n     );\n \n     // Dynamic native libraries from upstream crates.\n-    //\n-    // FIXME: Merge this to `add_upstream_rust_crates` so that all native libraries are linked\n-    // together with their respective upstream crates, and in their originally specified order.\n-    // This may be slightly breaking due to our use of `--as-needed` and needs a crater run.\n-    if sess.opts.unstable_opts.link_native_libraries {\n-        add_upstream_native_libraries(cmd, sess, codegen_results);\n-    }\n+    add_upstream_native_libraries(cmd, sess, archive_builder_builder, codegen_results, tmpdir);\n \n     // Link with the import library generated for any raw-dylib functions.\n     for (raw_dylib_name, raw_dylib_imports) in\n@@ -2276,42 +2264,46 @@ fn collect_natvis_visualizers(\n     visualizer_paths\n }\n \n-/// # Native library linking\n-///\n-/// User-supplied library search paths (-L on the command line). These are the same paths used to\n-/// find Rust crates, so some of them may have been added already by the previous crate linking\n-/// code. This only allows them to be found at compile time so it is still entirely up to outside\n-/// forces to make sure that library can be found at runtime.\n-///\n-/// Also note that the native libraries linked here are only the ones located in the current crate.\n-/// Upstream crates with native library dependencies may have their native library pulled in above.\n-fn add_local_native_libraries(\n+fn add_native_libs_from_crate(\n     cmd: &mut dyn Linker,\n     sess: &Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n     codegen_results: &CodegenResults,\n+    tmpdir: &Path,\n+    search_paths: &OnceCell<Vec<PathBuf>>,\n+    bundled_libs: &FxHashSet<Symbol>,\n+    cnum: CrateNum,\n+    link_static: bool,\n+    link_dynamic: bool,\n ) {\n-    let filesearch = sess.target_filesearch(PathKind::All);\n-    for search_path in filesearch.search_paths() {\n-        match search_path.kind {\n-            PathKind::Framework => {\n-                cmd.framework_path(&search_path.dir);\n-            }\n-            _ => {\n-                cmd.include_path(&fix_windows_verbatim_for_gcc(&search_path.dir));\n-            }\n-        }\n+    if !sess.opts.unstable_opts.link_native_libraries {\n+        // If `-Zlink-native-libraries=false` is set, then the assumption is that an\n+        // external build system already has the native dependencies defined, and it\n+        // will provide them to the linker itself.\n+        return;\n     }\n \n-    let relevant_libs =\n-        codegen_results.crate_info.used_libraries.iter().filter(|l| relevant_lib(sess, l));\n+    if link_static && cnum != LOCAL_CRATE && !bundled_libs.is_empty() {\n+        // If rlib contains native libs as archives, unpack them to tmpdir.\n+        let rlib = &codegen_results.crate_info.used_crate_source[&cnum].rlib.as_ref().unwrap().0;\n+        archive_builder_builder\n+            .extract_bundled_libs(rlib, tmpdir, &bundled_libs)\n+            .unwrap_or_else(|e| sess.emit_fatal(e));\n+    }\n+\n+    let native_libs = match cnum {\n+        LOCAL_CRATE => &codegen_results.crate_info.used_libraries,\n+        _ => &codegen_results.crate_info.native_libraries[&cnum],\n+    };\n \n-    let search_path = OnceCell::new();\n     let mut last = (None, NativeLibKind::Unspecified, None);\n-    for lib in relevant_libs {\n+    for lib in native_libs {\n         let Some(name) = lib.name else {\n             continue;\n         };\n-        let name = name.as_str();\n+        if !relevant_lib(sess, lib) {\n+            continue;\n+        }\n \n         // Skip if this library is the same as the last.\n         last = if (lib.name, lib.kind, lib.verbatim) == last {\n@@ -2320,46 +2312,119 @@ fn add_local_native_libraries(\n             (lib.name, lib.kind, lib.verbatim)\n         };\n \n+        let name = name.as_str();\n         let verbatim = lib.verbatim.unwrap_or(false);\n         match lib.kind {\n+            NativeLibKind::Static { bundle, whole_archive } => {\n+                if link_static {\n+                    let bundle = bundle.unwrap_or(true);\n+                    let whole_archive = whole_archive == Some(true)\n+                        // Backward compatibility case: this can be a rlib (so `+whole-archive`\n+                        // cannot be added explicitly if necessary, see the error in `fn link_rlib`)\n+                        // compiled as an executable due to `--test`. Use whole-archive implicitly,\n+                        // like before the introduction of native lib modifiers.\n+                        || (whole_archive == None\n+                            && bundle\n+                            && cnum == LOCAL_CRATE\n+                            && sess.opts.test);\n+\n+                    if bundle && cnum != LOCAL_CRATE {\n+                        if let Some(filename) = lib.filename {\n+                            // If rlib contains native libs as archives, they are unpacked to tmpdir.\n+                            let path = tmpdir.join(filename.as_str());\n+                            if whole_archive {\n+                                cmd.link_whole_rlib(&path);\n+                            } else {\n+                                cmd.link_rlib(&path);\n+                            }\n+                        }\n+                    } else {\n+                        if whole_archive {\n+                            cmd.link_whole_staticlib(\n+                                name,\n+                                verbatim,\n+                                &search_paths.get_or_init(|| archive_search_paths(sess)),\n+                            );\n+                        } else {\n+                            // HACK/FIXME: Fixup a circular dependency between libgcc and libc\n+                            // with glibc. This logic should be moved to the libc crate.\n+                            if cnum != LOCAL_CRATE\n+                                && sess.target.os == \"linux\"\n+                                && sess.target.env == \"gnu\"\n+                                && name == \"c\"\n+                            {\n+                                cmd.link_staticlib(\"gcc\", false);\n+                            }\n+                            cmd.link_staticlib(name, verbatim)\n+                        }\n+                    }\n+                }\n+            }\n             NativeLibKind::Dylib { as_needed } => {\n-                cmd.link_dylib(name, verbatim, as_needed.unwrap_or(true))\n+                if link_dynamic {\n+                    cmd.link_dylib(name, verbatim, as_needed.unwrap_or(true))\n+                }\n             }\n-            NativeLibKind::Unspecified => cmd.link_dylib(name, verbatim, true),\n-            NativeLibKind::Framework { as_needed } => {\n-                cmd.link_framework(name, as_needed.unwrap_or(true))\n+            NativeLibKind::Unspecified => {\n+                if link_dynamic {\n+                    cmd.link_dylib(name, verbatim, true);\n+                }\n             }\n-            NativeLibKind::Static { whole_archive, bundle, .. } => {\n-                if whole_archive == Some(true)\n-                    // Backward compatibility case: this can be a rlib (so `+whole-archive` cannot\n-                    // be added explicitly if necessary, see the error in `fn link_rlib`) compiled\n-                    // as an executable due to `--test`. Use whole-archive implicitly, like before\n-                    // the introduction of native lib modifiers.\n-                    || (whole_archive == None && bundle != Some(false) && sess.opts.test)\n-                {\n-                    cmd.link_whole_staticlib(\n-                        name,\n-                        verbatim,\n-                        &search_path.get_or_init(|| archive_search_paths(sess)),\n-                    );\n-                } else {\n-                    cmd.link_staticlib(name, verbatim)\n+            NativeLibKind::Framework { as_needed } => {\n+                if link_dynamic {\n+                    cmd.link_framework(name, as_needed.unwrap_or(true))\n                 }\n             }\n             NativeLibKind::RawDylib => {\n-                // Ignore RawDylib here, they are handled separately in linker_with_args().\n+                // Handled separately in `linker_with_args`.\n             }\n             NativeLibKind::LinkArg => {\n-                cmd.arg(name);\n+                if link_static {\n+                    cmd.arg(name);\n+                }\n             }\n         }\n     }\n }\n \n-/// # Linking Rust crates and their non-bundled static libraries\n-///\n-/// Rust crates are not considered at all when creating an rlib output. All dependencies will be\n-/// linked when producing the final output (instead of the intermediate rlib version).\n+fn add_local_native_libraries(\n+    cmd: &mut dyn Linker,\n+    sess: &Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n+    codegen_results: &CodegenResults,\n+    tmpdir: &Path,\n+) {\n+    if sess.opts.unstable_opts.link_native_libraries {\n+        // User-supplied library search paths (-L on the command line). These are the same paths\n+        // used to find Rust crates, so some of them may have been added already by the previous\n+        // crate linking code. This only allows them to be found at compile time so it is still\n+        // entirely up to outside forces to make sure that library can be found at runtime.\n+        for search_path in sess.target_filesearch(PathKind::All).search_paths() {\n+            match search_path.kind {\n+                PathKind::Framework => cmd.framework_path(&search_path.dir),\n+                _ => cmd.include_path(&fix_windows_verbatim_for_gcc(&search_path.dir)),\n+            }\n+        }\n+    }\n+\n+    let search_paths = OnceCell::new();\n+    // All static and dynamic native library dependencies are linked to the local crate.\n+    let link_static = true;\n+    let link_dynamic = true;\n+    add_native_libs_from_crate(\n+        cmd,\n+        sess,\n+        archive_builder_builder,\n+        codegen_results,\n+        tmpdir,\n+        &search_paths,\n+        &Default::default(),\n+        LOCAL_CRATE,\n+        link_static,\n+        link_dynamic,\n+    );\n+}\n+\n fn add_upstream_rust_crates<'a>(\n     cmd: &mut dyn Linker,\n     sess: &'a Session,\n@@ -2375,354 +2440,241 @@ fn add_upstream_rust_crates<'a>(\n     // Linking to a rlib involves just passing it to the linker (the linker\n     // will slurp up the object files inside), and linking to a dynamic library\n     // involves just passing the right -l flag.\n-\n     let (_, data) = codegen_results\n         .crate_info\n         .dependency_formats\n         .iter()\n         .find(|(ty, _)| *ty == crate_type)\n         .expect(\"failed to find crate type in dependency format list\");\n \n-    // Invoke get_used_crates to ensure that we get a topological sorting of\n-    // crates.\n-    let deps = &codegen_results.crate_info.used_crates;\n-\n-    let mut compiler_builtins = None;\n-    let search_path = OnceCell::new();\n-\n-    for &cnum in deps.iter() {\n-        // We may not pass all crates through to the linker. Some crates may\n-        // appear statically in an existing dylib, meaning we'll pick up all the\n-        // symbols from the dylib.\n-        let src = &codegen_results.crate_info.used_crate_source[&cnum];\n-        match data[cnum.as_usize() - 1] {\n-            _ if codegen_results.crate_info.profiler_runtime == Some(cnum) => {\n-                add_static_crate(\n-                    cmd,\n-                    sess,\n-                    archive_builder_builder,\n-                    codegen_results,\n-                    tmpdir,\n-                    cnum,\n-                    &Default::default(),\n-                );\n-            }\n-            // compiler-builtins are always placed last to ensure that they're\n-            // linked correctly.\n-            _ if codegen_results.crate_info.compiler_builtins == Some(cnum) => {\n-                assert!(compiler_builtins.is_none());\n-                compiler_builtins = Some(cnum);\n-            }\n-            Linkage::NotLinked | Linkage::IncludedFromDylib => {}\n-            Linkage::Static => {\n-                let bundled_libs = if sess.opts.unstable_opts.packed_bundled_libs {\n-                    codegen_results.crate_info.native_libraries[&cnum]\n+    let search_paths = OnceCell::new();\n+    for &cnum in &codegen_results.crate_info.used_crates {\n+        // We may not pass all crates through to the linker. Some crates may appear statically in\n+        // an existing dylib, meaning we'll pick up all the symbols from the dylib.\n+        // We must always link crates `compiler_builtins` and `profiler_builtins` statically.\n+        // Even if they were already included into a dylib\n+        // (e.g. `libstd` when `-C prefer-dynamic` is used).\n+        // FIXME: `dependency_formats` can report `profiler_builtins` as `NotLinked` for some\n+        // reason, it shouldn't do that because `profiler_builtins` should indeed be linked.\n+        let linkage = data[cnum.as_usize() - 1];\n+        let link_static_crate = linkage == Linkage::Static\n+            || (linkage == Linkage::IncludedFromDylib || linkage == Linkage::NotLinked)\n+                && (codegen_results.crate_info.compiler_builtins == Some(cnum)\n+                    || codegen_results.crate_info.profiler_runtime == Some(cnum));\n+\n+        let mut bundled_libs = Default::default();\n+        match linkage {\n+            Linkage::Static | Linkage::IncludedFromDylib | Linkage::NotLinked => {\n+                if link_static_crate {\n+                    bundled_libs = codegen_results.crate_info.native_libraries[&cnum]\n                         .iter()\n                         .filter_map(|lib| lib.filename)\n-                        .collect::<FxHashSet<_>>()\n-                } else {\n-                    Default::default()\n-                };\n-                add_static_crate(\n-                    cmd,\n-                    sess,\n-                    archive_builder_builder,\n-                    codegen_results,\n-                    tmpdir,\n-                    cnum,\n-                    &bundled_libs,\n-                );\n-\n-                // Link static native libs with \"-bundle\" modifier only if the crate they originate from\n-                // is being linked statically to the current crate.  If it's linked dynamically\n-                // or is an rlib already included via some other dylib crate, the symbols from\n-                // native libs will have already been included in that dylib.\n-                //\n-                // If `-Zlink-native-libraries=false` is set, then the assumption is that an\n-                // external build system already has the native dependencies defined, and it\n-                // will provide them to the linker itself.\n-                if sess.opts.unstable_opts.link_native_libraries {\n-                    if sess.opts.unstable_opts.packed_bundled_libs {\n-                        // If rlib contains native libs as archives, unpack them to tmpdir.\n-                        let rlib = &src.rlib.as_ref().unwrap().0;\n-                        archive_builder_builder\n-                            .extract_bundled_libs(rlib, tmpdir, &bundled_libs)\n-                            .unwrap_or_else(|e| sess.emit_fatal(e));\n-                    }\n-\n-                    let mut last = (None, NativeLibKind::Unspecified, None);\n-                    for lib in &codegen_results.crate_info.native_libraries[&cnum] {\n-                        let Some(name) = lib.name else {\n-                            continue;\n-                        };\n-                        let name = name.as_str();\n-                        if !relevant_lib(sess, lib) {\n-                            continue;\n-                        }\n-\n-                        // Skip if this library is the same as the last.\n-                        last = if (lib.name, lib.kind, lib.verbatim) == last {\n-                            continue;\n-                        } else {\n-                            (lib.name, lib.kind, lib.verbatim)\n-                        };\n-\n-                        match lib.kind {\n-                            NativeLibKind::Static {\n-                                bundle: Some(false),\n-                                whole_archive: Some(true),\n-                            } => {\n-                                cmd.link_whole_staticlib(\n-                                    name,\n-                                    lib.verbatim.unwrap_or(false),\n-                                    search_path.get_or_init(|| archive_search_paths(sess)),\n-                                );\n-                            }\n-                            NativeLibKind::Static {\n-                                bundle: Some(false),\n-                                whole_archive: Some(false) | None,\n-                            } => {\n-                                // HACK/FIXME: Fixup a circular dependency between libgcc and libc\n-                                // with glibc. This logic should be moved to the libc crate.\n-                                if sess.target.os == \"linux\"\n-                                    && sess.target.env == \"gnu\"\n-                                    && name == \"c\"\n-                                {\n-                                    cmd.link_staticlib(\"gcc\", false);\n-                                }\n-                                cmd.link_staticlib(name, lib.verbatim.unwrap_or(false));\n-                            }\n-                            NativeLibKind::LinkArg => {\n-                                cmd.arg(name);\n-                            }\n-                            NativeLibKind::Dylib { .. }\n-                            | NativeLibKind::Framework { .. }\n-                            | NativeLibKind::Unspecified\n-                            | NativeLibKind::RawDylib => {}\n-                            NativeLibKind::Static { bundle: Some(true) | None, whole_archive } => {\n-                                if sess.opts.unstable_opts.packed_bundled_libs {\n-                                    // If rlib contains native libs as archives, they are unpacked to tmpdir.\n-                                    let path = tmpdir.join(lib.filename.unwrap().as_str());\n-                                    if whole_archive == Some(true) {\n-                                        cmd.link_whole_rlib(&path);\n-                                    } else {\n-                                        cmd.link_rlib(&path);\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n+                        .collect();\n+                    add_static_crate(\n+                        cmd,\n+                        sess,\n+                        archive_builder_builder,\n+                        codegen_results,\n+                        tmpdir,\n+                        cnum,\n+                        &bundled_libs,\n+                    );\n                 }\n             }\n-            Linkage::Dynamic => add_dynamic_crate(cmd, sess, &src.dylib.as_ref().unwrap().0),\n+            Linkage::Dynamic => {\n+                let src = &codegen_results.crate_info.used_crate_source[&cnum];\n+                add_dynamic_crate(cmd, sess, &src.dylib.as_ref().unwrap().0);\n+            }\n         }\n-    }\n \n-    // compiler-builtins are always placed last to ensure that they're\n-    // linked correctly.\n-    // We must always link the `compiler_builtins` crate statically. Even if it\n-    // was already \"included\" in a dylib (e.g., `libstd` when `-C prefer-dynamic`\n-    // is used)\n-    if let Some(cnum) = compiler_builtins {\n-        add_static_crate(\n+        // Static libraries are linked for a subset of linked upstream crates.\n+        // 1. If the upstream crate is a directly linked rlib then we must link the native library\n+        // because the rlib is just an archive.\n+        // 2. If the upstream crate is a dylib or a rlib linked through dylib, then we do not link\n+        // the native library because it is already linked into the dylib, and even if\n+        // inline/const/generic functions from the dylib can refer to symbols from the native\n+        // library, those symbols should be exported and available from the dylib anyway.\n+        // 3. Libraries bundled into `(compiler,profiler)_builtins` are special, see above.\n+        let link_static = link_static_crate;\n+        // Dynamic libraries are not linked here, see the FIXME in `add_upstream_native_libraries`.\n+        let link_dynamic = false;\n+        add_native_libs_from_crate(\n             cmd,\n             sess,\n             archive_builder_builder,\n             codegen_results,\n             tmpdir,\n+            &search_paths,\n+            &bundled_libs,\n             cnum,\n-            &Default::default(),\n+            link_static,\n+            link_dynamic,\n         );\n     }\n+}\n \n-    // Converts a library file-stem into a cc -l argument\n-    fn unlib<'a>(target: &Target, stem: &'a str) -> &'a str {\n-        if stem.starts_with(\"lib\") && !target.is_like_windows { &stem[3..] } else { stem }\n+fn add_upstream_native_libraries(\n+    cmd: &mut dyn Linker,\n+    sess: &Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n+    codegen_results: &CodegenResults,\n+    tmpdir: &Path,\n+) {\n+    let search_path = OnceCell::new();\n+    for &cnum in &codegen_results.crate_info.used_crates {\n+        // Static libraries are not linked here, they are linked in `add_upstream_rust_crates`.\n+        // FIXME: Merge this function to `add_upstream_rust_crates` so that all native libraries\n+        // are linked together with their respective upstream crates, and in their originally\n+        // specified order. This is slightly breaking due to our use of `--as-needed` (see crater\n+        // results in https://github.com/rust-lang/rust/pull/102832#issuecomment-1279772306).\n+        let link_static = false;\n+        // Dynamic libraries are linked for all linked upstream crates.\n+        // 1. If the upstream crate is a directly linked rlib then we must link the native library\n+        // because the rlib is just an archive.\n+        // 2. If the upstream crate is a dylib or a rlib linked through dylib, then we have to link\n+        // the native library too because inline/const/generic functions from the dylib can refer\n+        // to symbols from the native library, so the native library providing those symbols should\n+        // be available when linking our final binary.\n+        let link_dynamic = true;\n+        add_native_libs_from_crate(\n+            cmd,\n+            sess,\n+            archive_builder_builder,\n+            codegen_results,\n+            tmpdir,\n+            &search_path,\n+            &Default::default(),\n+            cnum,\n+            link_static,\n+            link_dynamic,\n+        );\n     }\n+}\n \n-    // Adds the static \"rlib\" versions of all crates to the command line.\n-    // There's a bit of magic which happens here specifically related to LTO,\n-    // namely that we remove upstream object files.\n-    //\n-    // When performing LTO, almost(*) all of the bytecode from the upstream\n-    // libraries has already been included in our object file output. As a\n-    // result we need to remove the object files in the upstream libraries so\n-    // the linker doesn't try to include them twice (or whine about duplicate\n-    // symbols). We must continue to include the rest of the rlib, however, as\n-    // it may contain static native libraries which must be linked in.\n-    //\n-    // (*) Crates marked with `#![no_builtins]` don't participate in LTO and\n-    // their bytecode wasn't included. The object files in those libraries must\n-    // still be passed to the linker.\n-    //\n-    // Note, however, that if we're not doing LTO we can just pass the rlib\n-    // blindly to the linker (fast) because it's fine if it's not actually\n-    // included as we're at the end of the dependency chain.\n-    fn add_static_crate<'a>(\n-        cmd: &mut dyn Linker,\n-        sess: &'a Session,\n-        archive_builder_builder: &dyn ArchiveBuilderBuilder,\n-        codegen_results: &CodegenResults,\n-        tmpdir: &Path,\n-        cnum: CrateNum,\n-        bundled_lib_file_names: &FxHashSet<Symbol>,\n-    ) {\n-        let src = &codegen_results.crate_info.used_crate_source[&cnum];\n-        let cratepath = &src.rlib.as_ref().unwrap().0;\n-\n-        let mut link_upstream = |path: &Path| {\n-            cmd.link_rlib(&fix_windows_verbatim_for_gcc(path));\n-        };\n-\n-        // See the comment above in `link_staticlib` and `link_rlib` for why if\n-        // there's a static library that's not relevant we skip all object\n-        // files.\n-        let native_libs = &codegen_results.crate_info.native_libraries[&cnum];\n-        let skip_native = native_libs.iter().any(|lib| {\n-            matches!(lib.kind, NativeLibKind::Static { bundle: None | Some(true), .. })\n-                && !relevant_lib(sess, lib)\n-        });\n-\n-        if (!are_upstream_rust_objects_already_included(sess)\n-            || ignored_for_lto(sess, &codegen_results.crate_info, cnum))\n-            && !skip_native\n-        {\n-            link_upstream(cratepath);\n-            return;\n-        }\n-\n-        let dst = tmpdir.join(cratepath.file_name().unwrap());\n-        let name = cratepath.file_name().unwrap().to_str().unwrap();\n-        let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n-        let bundled_lib_file_names = bundled_lib_file_names.clone();\n-\n-        sess.prof.generic_activity_with_arg(\"link_altering_rlib\", name).run(|| {\n-            let canonical_name = name.replace('-', \"_\");\n-            let upstream_rust_objects_already_included =\n-                are_upstream_rust_objects_already_included(sess);\n-            let is_builtins = sess.target.no_builtins\n-                || !codegen_results.crate_info.is_no_builtins.contains(&cnum);\n-\n-            let mut archive = archive_builder_builder.new_archive_builder(sess);\n-            if let Err(error) = archive.add_archive(\n-                cratepath,\n-                Box::new(move |f| {\n-                    if f == METADATA_FILENAME {\n-                        return true;\n-                    }\n+// Adds the static \"rlib\" versions of all crates to the command line.\n+// There's a bit of magic which happens here specifically related to LTO,\n+// namely that we remove upstream object files.\n+//\n+// When performing LTO, almost(*) all of the bytecode from the upstream\n+// libraries has already been included in our object file output. As a\n+// result we need to remove the object files in the upstream libraries so\n+// the linker doesn't try to include them twice (or whine about duplicate\n+// symbols). We must continue to include the rest of the rlib, however, as\n+// it may contain static native libraries which must be linked in.\n+//\n+// (*) Crates marked with `#![no_builtins]` don't participate in LTO and\n+// their bytecode wasn't included. The object files in those libraries must\n+// still be passed to the linker.\n+//\n+// Note, however, that if we're not doing LTO we can just pass the rlib\n+// blindly to the linker (fast) because it's fine if it's not actually\n+// included as we're at the end of the dependency chain.\n+fn add_static_crate<'a>(\n+    cmd: &mut dyn Linker,\n+    sess: &'a Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n+    codegen_results: &CodegenResults,\n+    tmpdir: &Path,\n+    cnum: CrateNum,\n+    bundled_lib_file_names: &FxHashSet<Symbol>,\n+) {\n+    let src = &codegen_results.crate_info.used_crate_source[&cnum];\n+    let cratepath = &src.rlib.as_ref().unwrap().0;\n \n-                    let canonical = f.replace('-', \"_\");\n-\n-                    let is_rust_object =\n-                        canonical.starts_with(&canonical_name) && looks_like_rust_object_file(&f);\n-\n-                    // If we've been requested to skip all native object files\n-                    // (those not generated by the rust compiler) then we can skip\n-                    // this file. See above for why we may want to do this.\n-                    let skip_because_cfg_say_so = skip_native && !is_rust_object;\n-\n-                    // If we're performing LTO and this is a rust-generated object\n-                    // file, then we don't need the object file as it's part of the\n-                    // LTO module. Note that `#![no_builtins]` is excluded from LTO,\n-                    // though, so we let that object file slide.\n-                    let skip_because_lto =\n-                        upstream_rust_objects_already_included && is_rust_object && is_builtins;\n-\n-                    // We skip native libraries because:\n-                    // 1. This native libraries won't be used from the generated rlib,\n-                    //    so we can throw them away to avoid the copying work.\n-                    // 2. We can't allow it to be a single remaining entry in archive\n-                    //    as some linkers may complain on that.\n-                    if bundled_lib_file_names.contains(&Symbol::intern(f)) {\n-                        return true;\n-                    }\n+    let mut link_upstream = |path: &Path| {\n+        cmd.link_rlib(&fix_windows_verbatim_for_gcc(path));\n+    };\n \n-                    if skip_because_cfg_say_so || skip_because_lto {\n-                        return true;\n-                    }\n+    // See the comment above in `link_staticlib` and `link_rlib` for why if\n+    // there's a static library that's not relevant we skip all object\n+    // files.\n+    let native_libs = &codegen_results.crate_info.native_libraries[&cnum];\n+    let skip_native = native_libs.iter().any(|lib| {\n+        matches!(lib.kind, NativeLibKind::Static { bundle: None | Some(true), .. })\n+            && !relevant_lib(sess, lib)\n+    });\n \n-                    false\n-                }),\n-            ) {\n-                sess.emit_fatal(errors::RlibArchiveBuildFailure { error });\n-            }\n-            if archive.build(&dst) {\n-                link_upstream(&dst);\n-            }\n-        });\n+    if (!are_upstream_rust_objects_already_included(sess)\n+        || ignored_for_lto(sess, &codegen_results.crate_info, cnum))\n+        && !skip_native\n+    {\n+        link_upstream(cratepath);\n+        return;\n     }\n \n-    // Same thing as above, but for dynamic crates instead of static crates.\n-    fn add_dynamic_crate(cmd: &mut dyn Linker, sess: &Session, cratepath: &Path) {\n-        // Just need to tell the linker about where the library lives and\n-        // what its name is\n-        let parent = cratepath.parent();\n-        if let Some(dir) = parent {\n-            cmd.include_path(&fix_windows_verbatim_for_gcc(dir));\n-        }\n-        let filestem = cratepath.file_stem().unwrap().to_str().unwrap();\n-        cmd.link_rust_dylib(\n-            &unlib(&sess.target, filestem),\n-            parent.unwrap_or_else(|| Path::new(\"\")),\n-        );\n-    }\n-}\n+    let dst = tmpdir.join(cratepath.file_name().unwrap());\n+    let name = cratepath.file_name().unwrap().to_str().unwrap();\n+    let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n+    let bundled_lib_file_names = bundled_lib_file_names.clone();\n \n-/// Link in all of our upstream crates' native dependencies. Remember that all of these upstream\n-/// native dependencies are all non-static dependencies. We've got two cases then:\n-///\n-/// 1. The upstream crate is an rlib. In this case we *must* link in the native dependency because\n-/// the rlib is just an archive.\n-///\n-/// 2. The upstream crate is a dylib. In order to use the dylib, we have to have the dependency\n-/// present on the system somewhere. Thus, we don't gain a whole lot from not linking in the\n-/// dynamic dependency to this crate as well.\n-///\n-/// The use case for this is a little subtle. In theory the native dependencies of a crate are\n-/// purely an implementation detail of the crate itself, but the problem arises with generic and\n-/// inlined functions. If a generic function calls a native function, then the generic function\n-/// must be instantiated in the target crate, meaning that the native symbol must also be resolved\n-/// in the target crate.\n-fn add_upstream_native_libraries(\n-    cmd: &mut dyn Linker,\n-    sess: &Session,\n-    codegen_results: &CodegenResults,\n-) {\n-    let mut last = (None, NativeLibKind::Unspecified, None);\n-    for &cnum in &codegen_results.crate_info.used_crates {\n-        for lib in codegen_results.crate_info.native_libraries[&cnum].iter() {\n-            let Some(name) = lib.name else {\n-                continue;\n-            };\n-            let name = name.as_str();\n-            if !relevant_lib(sess, &lib) {\n-                continue;\n-            }\n+    sess.prof.generic_activity_with_arg(\"link_altering_rlib\", name).run(|| {\n+        let canonical_name = name.replace('-', \"_\");\n+        let upstream_rust_objects_already_included =\n+            are_upstream_rust_objects_already_included(sess);\n+        let is_builtins =\n+            sess.target.no_builtins || !codegen_results.crate_info.is_no_builtins.contains(&cnum);\n \n-            // Skip if this library is the same as the last.\n-            last = if (lib.name, lib.kind, lib.verbatim) == last {\n-                continue;\n-            } else {\n-                (lib.name, lib.kind, lib.verbatim)\n-            };\n+        let mut archive = archive_builder_builder.new_archive_builder(sess);\n+        if let Err(e) = archive.add_archive(\n+            cratepath,\n+            Box::new(move |f| {\n+                if f == METADATA_FILENAME {\n+                    return true;\n+                }\n \n-            let verbatim = lib.verbatim.unwrap_or(false);\n-            match lib.kind {\n-                NativeLibKind::Dylib { as_needed } => {\n-                    cmd.link_dylib(name, verbatim, as_needed.unwrap_or(true))\n+                let canonical = f.replace('-', \"_\");\n+\n+                let is_rust_object =\n+                    canonical.starts_with(&canonical_name) && looks_like_rust_object_file(&f);\n+\n+                // If we've been requested to skip all native object files\n+                // (those not generated by the rust compiler) then we can skip\n+                // this file. See above for why we may want to do this.\n+                let skip_because_cfg_say_so = skip_native && !is_rust_object;\n+\n+                // If we're performing LTO and this is a rust-generated object\n+                // file, then we don't need the object file as it's part of the\n+                // LTO module. Note that `#![no_builtins]` is excluded from LTO,\n+                // though, so we let that object file slide.\n+                let skip_because_lto =\n+                    upstream_rust_objects_already_included && is_rust_object && is_builtins;\n+\n+                // We skip native libraries because:\n+                // 1. This native libraries won't be used from the generated rlib,\n+                //    so we can throw them away to avoid the copying work.\n+                // 2. We can't allow it to be a single remaining entry in archive\n+                //    as some linkers may complain on that.\n+                if bundled_lib_file_names.contains(&Symbol::intern(f)) {\n+                    return true;\n                 }\n-                NativeLibKind::Unspecified => cmd.link_dylib(name, verbatim, true),\n-                NativeLibKind::Framework { as_needed } => {\n-                    cmd.link_framework(name, as_needed.unwrap_or(true))\n+\n+                if skip_because_cfg_say_so || skip_because_lto {\n+                    return true;\n                 }\n-                // ignore static native libraries here as we've\n-                // already included them in add_local_native_libraries and\n-                // add_upstream_rust_crates\n-                NativeLibKind::Static { .. } => {}\n-                NativeLibKind::RawDylib | NativeLibKind::LinkArg => {}\n-            }\n+\n+                false\n+            }),\n+        ) {\n+            sess.fatal(&format!(\"failed to build archive from rlib: {}\", e));\n         }\n-    }\n+        if archive.build(&dst) {\n+            link_upstream(&dst);\n+        }\n+    });\n+}\n+\n+// Same thing as above, but for dynamic crates instead of static crates.\n+fn add_dynamic_crate(cmd: &mut dyn Linker, sess: &Session, cratepath: &Path) {\n+    // Just need to tell the linker about where the library lives and\n+    // what its name is\n+    let parent = cratepath.parent();\n+    if let Some(dir) = parent {\n+        cmd.include_path(&fix_windows_verbatim_for_gcc(dir));\n+    }\n+    let stem = cratepath.file_stem().unwrap().to_str().unwrap();\n+    // Convert library file-stem into a cc -l argument.\n+    let prefix = if stem.starts_with(\"lib\") && !sess.target.is_like_windows { 3 } else { 0 };\n+    cmd.link_rust_dylib(&stem[prefix..], parent.unwrap_or_else(|| Path::new(\"\")));\n }\n \n fn relevant_lib(sess: &Session, lib: &NativeLib) -> bool {"}, {"sha": "4f396e970ad70969228cae3756eec5273af4a483", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fb6667a233fa677f6fbfa6067913ef3d32480317/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb6667a233fa677f6fbfa6067913ef3d32480317/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=fb6667a233fa677f6fbfa6067913ef3d32480317", "patch": "@@ -833,20 +833,30 @@ impl CrateInfo {\n         //\n         // In order to get this left-to-right dependency ordering, we use the reverse\n         // postorder of all crates putting the leaves at the right-most positions.\n-        let used_crates = tcx\n+        let mut compiler_builtins = None;\n+        let mut used_crates: Vec<_> = tcx\n             .postorder_cnums(())\n             .iter()\n             .rev()\n             .copied()\n-            .filter(|&cnum| !tcx.dep_kind(cnum).macros_only())\n+            .filter(|&cnum| {\n+                let link = !tcx.dep_kind(cnum).macros_only();\n+                if link && tcx.is_compiler_builtins(cnum) {\n+                    compiler_builtins = Some(cnum);\n+                    return false;\n+                }\n+                link\n+            })\n             .collect();\n+        // `compiler_builtins` are always placed last to ensure that they're linked correctly.\n+        used_crates.extend(compiler_builtins);\n \n         let mut info = CrateInfo {\n             target_cpu,\n             exported_symbols,\n             linked_symbols,\n             local_crate_name,\n-            compiler_builtins: None,\n+            compiler_builtins,\n             profiler_runtime: None,\n             is_no_builtins: Default::default(),\n             native_libraries: Default::default(),\n@@ -872,9 +882,6 @@ impl CrateInfo {\n \n             let used_crate_source = tcx.used_crate_source(cnum);\n             info.used_crate_source.insert(cnum, used_crate_source.clone());\n-            if tcx.is_compiler_builtins(cnum) {\n-                info.compiler_builtins = Some(cnum);\n-            }\n             if tcx.is_profiler_runtime(cnum) {\n                 info.profiler_runtime = Some(cnum);\n             }"}, {"sha": "eff18ab48ab4f216f2e08207b8fef693608ab898", "filename": "src/test/run-make-fulldeps/link-dedup/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb6667a233fa677f6fbfa6067913ef3d32480317/src%2Ftest%2Frun-make-fulldeps%2Flink-dedup%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/fb6667a233fa677f6fbfa6067913ef3d32480317/src%2Ftest%2Frun-make-fulldeps%2Flink-dedup%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Flink-dedup%2FMakefile?ref=fb6667a233fa677f6fbfa6067913ef3d32480317", "patch": "@@ -9,4 +9,4 @@ all:\n \t$(RUSTC) empty.rs --cfg bar 2>&1 | $(CGREP) '\"-ltesta\" \"-ltestb\" \"-ltesta\"'\n \t$(RUSTC) empty.rs 2>&1 | $(CGREP) '\"-ltesta\"'\n \t$(RUSTC) empty.rs 2>&1 | $(CGREP) -v '\"-ltestb\"'\n-\t$(RUSTC) empty.rs 2>&1 | $(CGREP) -v '\"-ltesta\" \"-ltesta\"'\n+\t$(RUSTC) empty.rs 2>&1 | $(CGREP) -v '\"-ltesta\" \"-ltesta\" \"-ltesta\"'"}, {"sha": "19178c5bd49573296acba514aa1a2c3b2fe9d5a3", "filename": "src/test/run-make-fulldeps/link-dedup/depa.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb6667a233fa677f6fbfa6067913ef3d32480317/src%2Ftest%2Frun-make-fulldeps%2Flink-dedup%2Fdepa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb6667a233fa677f6fbfa6067913ef3d32480317/src%2Ftest%2Frun-make-fulldeps%2Flink-dedup%2Fdepa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Flink-dedup%2Fdepa.rs?ref=fb6667a233fa677f6fbfa6067913ef3d32480317", "patch": "@@ -5,3 +5,6 @@ extern \"C\" {}\n \n #[link(name = \"testa\")]\n extern \"C\" {}\n+\n+#[link(name = \"testa\")]\n+extern \"C\" {}"}]}