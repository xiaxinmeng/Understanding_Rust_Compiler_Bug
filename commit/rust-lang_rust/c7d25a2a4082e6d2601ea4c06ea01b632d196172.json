{"sha": "c7d25a2a4082e6d2601ea4c06ea01b632d196172", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3ZDI1YTJhNDA4MmU2ZDI2MDFlYTRjMDZlYTAxYjYzMmQxOTYxNzI=", "commit": {"author": {"name": "Alexis Hunt", "email": "lexer@google.com", "date": "2019-01-14T13:10:45Z"}, "committer": {"name": "Alexis Hunt", "email": "lexer@google.com", "date": "2019-01-19T09:16:05Z"}, "message": "Make `str` indexing generic on `SliceIndex`.", "tree": {"sha": "9dc0b9be6ea693c1df656b7a4a6caed1178b98cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9dc0b9be6ea693c1df656b7a4a6caed1178b98cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7d25a2a4082e6d2601ea4c06ea01b632d196172", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7d25a2a4082e6d2601ea4c06ea01b632d196172", "html_url": "https://github.com/rust-lang/rust/commit/c7d25a2a4082e6d2601ea4c06ea01b632d196172", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7d25a2a4082e6d2601ea4c06ea01b632d196172/comments", "author": null, "committer": null, "parents": [{"sha": "af73e64423a450d887df32e2998b8831d7ec653e", "url": "https://api.github.com/repos/rust-lang/rust/commits/af73e64423a450d887df32e2998b8831d7ec653e", "html_url": "https://github.com/rust-lang/rust/commit/af73e64423a450d887df32e2998b8831d7ec653e"}], "stats": {"total": 474, "additions": 239, "deletions": 235}, "files": [{"sha": "d4ed86142768d418bf83ea28c5de10be0527f09d", "filename": "src/libcore/ops/index.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c7d25a2a4082e6d2601ea4c06ea01b632d196172/src%2Flibcore%2Fops%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7d25a2a4082e6d2601ea4c06ea01b632d196172/src%2Flibcore%2Fops%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Findex.rs?ref=c7d25a2a4082e6d2601ea4c06ea01b632d196172", "patch": "@@ -51,21 +51,6 @@\n /// ```\n #[lang = \"index\"]\n #[rustc_on_unimplemented(\n-    on(\n-        _Self=\"&str\",\n-        note=\"you can use `.chars().nth()` or `.bytes().nth()`\n-see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"\n-    ),\n-    on(\n-        _Self=\"str\",\n-        note=\"you can use `.chars().nth()` or `.bytes().nth()`\n-see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"\n-    ),\n-    on(\n-        _Self=\"std::string::String\",\n-        note=\"you can use `.chars().nth()` or `.bytes().nth()`\n-see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"\n-    ),\n     message=\"the type `{Self}` cannot be indexed by `{Idx}`\",\n     label=\"`{Self}` cannot be indexed by `{Idx}`\",\n )]"}, {"sha": "2245d48f889e06006b935203cdc748bac5a66957", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c7d25a2a4082e6d2601ea4c06ea01b632d196172/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7d25a2a4082e6d2601ea4c06ea01b632d196172/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=c7d25a2a4082e6d2601ea4c06ea01b632d196172", "patch": "@@ -2312,7 +2312,6 @@ impl [u8] {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"slice indices are of type `usize` or ranges of `usize`\"]\n impl<T, I> ops::Index<I> for [T]\n     where I: SliceIndex<[T]>\n {\n@@ -2325,7 +2324,6 @@ impl<T, I> ops::Index<I> for [T]\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"slice indices are of type `usize` or ranges of `usize`\"]\n impl<T, I> ops::IndexMut<I> for [T]\n     where I: SliceIndex<[T]>\n {\n@@ -2376,7 +2374,19 @@ mod private_slice_index {\n \n /// A helper trait used for indexing operations.\n #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n-#[rustc_on_unimplemented = \"slice indices are of type `usize` or ranges of `usize`\"]\n+#[rustc_on_unimplemented(\n+    on(\n+        T = \"str\",\n+        label = \"string indices are ranges of `usize`\",\n+    ),\n+    on(\n+        all(any(T = \"str\", T = \"&str\", T = \"std::string::String\"), _Self=\"{integer}\"),\n+        note=\"you can use `.chars().nth()` or `.bytes().nth()`\n+see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"\n+    ),\n+    message = \"the type `{T}` cannot be indexed by `{Self}`\",\n+    label = \"slice indices are of type `usize` or ranges of `usize`\",\n+)]\n pub trait SliceIndex<T: ?Sized>: private_slice_index::Sealed {\n     /// The output type returned by methods.\n     #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]"}, {"sha": "1ee8b7735c17d19fcb85b82555dab48fcca784fe", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 119, "deletions": 177, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/c7d25a2a4082e6d2601ea4c06ea01b632d196172/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7d25a2a4082e6d2601ea4c06ea01b632d196172/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=c7d25a2a4082e6d2601ea4c06ea01b632d196172", "patch": "@@ -1621,190 +1621,26 @@ mod traits {\n         }\n     }\n \n-    /// Implements substring slicing with syntax `&self[begin .. end]`.\n-    ///\n-    /// Returns a slice of the given string from the byte range\n-    /// [`begin`..`end`).\n-    ///\n-    /// This operation is `O(1)`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `begin` or `end` does not point to the starting\n-    /// byte offset of a character (as defined by `is_char_boundary`).\n-    /// Requires that `begin <= end` and `end <= len` where `len` is the\n-    /// length of the string.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// assert_eq!(&s[0 .. 1], \"L\");\n-    ///\n-    /// assert_eq!(&s[1 .. 9], \"\u00f6we \u8001\");\n-    ///\n-    /// // these will panic:\n-    /// // byte 2 lies within `\u00f6`:\n-    /// // &s[2 ..3];\n-    ///\n-    /// // byte 8 lies within `\u8001`\n-    /// // &s[1 .. 8];\n-    ///\n-    /// // byte 100 is outside the string\n-    /// // &s[3 .. 100];\n-    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl ops::Index<ops::Range<usize>> for str {\n-        type Output = str;\n-        #[inline]\n-        fn index(&self, index: ops::Range<usize>) -> &str {\n-            index.index(self)\n-        }\n-    }\n-\n-    /// Implements mutable substring slicing with syntax\n-    /// `&mut self[begin .. end]`.\n-    ///\n-    /// Returns a mutable slice of the given string from the byte range\n-    /// [`begin`..`end`).\n-    ///\n-    /// This operation is `O(1)`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `begin` or `end` does not point to the starting\n-    /// byte offset of a character (as defined by `is_char_boundary`).\n-    /// Requires that `begin <= end` and `end <= len` where `len` is the\n-    /// length of the string.\n-    #[stable(feature = \"derefmut_for_string\", since = \"1.3.0\")]\n-    impl ops::IndexMut<ops::Range<usize>> for str {\n-        #[inline]\n-        fn index_mut(&mut self, index: ops::Range<usize>) -> &mut str {\n-            index.index_mut(self)\n-        }\n-    }\n-\n-    /// Implements substring slicing with syntax `&self[.. end]`.\n-    ///\n-    /// Returns a slice of the string from the beginning to byte offset\n-    /// `end`.\n-    ///\n-    /// Equivalent to `&self[0 .. end]`.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl ops::Index<ops::RangeTo<usize>> for str {\n-        type Output = str;\n-\n-        #[inline]\n-        fn index(&self, index: ops::RangeTo<usize>) -> &str {\n-            index.index(self)\n-        }\n-    }\n-\n-    /// Implements mutable substring slicing with syntax `&mut self[.. end]`.\n-    ///\n-    /// Returns a mutable slice of the string from the beginning to byte offset\n-    /// `end`.\n-    ///\n-    /// Equivalent to `&mut self[0 .. end]`.\n-    #[stable(feature = \"derefmut_for_string\", since = \"1.3.0\")]\n-    impl ops::IndexMut<ops::RangeTo<usize>> for str {\n-        #[inline]\n-        fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut str {\n-            index.index_mut(self)\n-        }\n-    }\n-\n-    /// Implements substring slicing with syntax `&self[begin ..]`.\n-    ///\n-    /// Returns a slice of the string from byte offset `begin`\n-    /// to the end of the string.\n-    ///\n-    /// Equivalent to `&self[begin .. len]`.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl ops::Index<ops::RangeFrom<usize>> for str {\n-        type Output = str;\n+    impl<I> ops::Index<I> for str\n+    where\n+        I: SliceIndex<str>,\n+    {\n+        type Output = I::Output;\n \n         #[inline]\n-        fn index(&self, index: ops::RangeFrom<usize>) -> &str {\n+        fn index(&self, index: I) -> &I::Output {\n             index.index(self)\n         }\n     }\n \n-    /// Implements mutable substring slicing with syntax `&mut self[begin ..]`.\n-    ///\n-    /// Returns a mutable slice of the string from byte offset `begin`\n-    /// to the end of the string.\n-    ///\n-    /// Equivalent to `&mut self[begin .. len]`.\n-    #[stable(feature = \"derefmut_for_string\", since = \"1.3.0\")]\n-    impl ops::IndexMut<ops::RangeFrom<usize>> for str {\n-        #[inline]\n-        fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut str {\n-            index.index_mut(self)\n-        }\n-    }\n-\n-    /// Implements substring slicing with syntax `&self[..]`.\n-    ///\n-    /// Returns a slice of the whole string. This operation can\n-    /// never panic.\n-    ///\n-    /// Equivalent to `&self[0 .. len]`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl ops::Index<ops::RangeFull> for str {\n-        type Output = str;\n-\n-        #[inline]\n-        fn index(&self, _index: ops::RangeFull) -> &str {\n-            self\n-        }\n-    }\n-\n-    /// Implements mutable substring slicing with syntax `&mut self[..]`.\n-    ///\n-    /// Returns a mutable slice of the whole string. This operation can\n-    /// never panic.\n-    ///\n-    /// Equivalent to `&mut self[0 .. len]`.\n-    #[stable(feature = \"derefmut_for_string\", since = \"1.3.0\")]\n-    impl ops::IndexMut<ops::RangeFull> for str {\n-        #[inline]\n-        fn index_mut(&mut self, _index: ops::RangeFull) -> &mut str {\n-            self\n-        }\n-    }\n-\n-    #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-    impl ops::Index<ops::RangeInclusive<usize>> for str {\n-        type Output = str;\n-\n-        #[inline]\n-        fn index(&self, index: ops::RangeInclusive<usize>) -> &str {\n-            index.index(self)\n-        }\n-    }\n-\n-    #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-    impl ops::Index<ops::RangeToInclusive<usize>> for str {\n-        type Output = str;\n-\n-        #[inline]\n-        fn index(&self, index: ops::RangeToInclusive<usize>) -> &str {\n-            index.index(self)\n-        }\n-    }\n-\n-    #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-    impl ops::IndexMut<ops::RangeInclusive<usize>> for str {\n-        #[inline]\n-        fn index_mut(&mut self, index: ops::RangeInclusive<usize>) -> &mut str {\n-            index.index_mut(self)\n-        }\n-    }\n-    #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-    impl ops::IndexMut<ops::RangeToInclusive<usize>> for str {\n+    impl<I> ops::IndexMut<I> for str\n+    where\n+        I: SliceIndex<str>,\n+    {\n         #[inline]\n-        fn index_mut(&mut self, index: ops::RangeToInclusive<usize>) -> &mut str {\n+        fn index_mut(&mut self, index: I) -> &mut I::Output {\n             index.index_mut(self)\n         }\n     }\n@@ -1815,6 +1651,18 @@ mod traits {\n         panic!(\"attempted to index str up to maximum usize\");\n     }\n \n+    /// Implements substring slicing with syntax `&self[..]` or `&mut self[..]`.\n+    ///\n+    /// Returns a slice of the whole string, i.e., returns `&self` or `&mut\n+    /// self`. Equivalent to `&self[0 .. len]` or `&mut self[0 .. len]`. Unlike\n+    /// other indexing operations, this can never panic.\n+    ///\n+    /// This operation is `O(1)`.\n+    ///\n+    /// Prior to 1.20.0, these indexing operations were still supported by\n+    /// direct implementation of `Index` and `IndexMut`.\n+    ///\n+    /// Equivalent to `&self[0 .. len]` or `&mut self[0 .. len]`.\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     impl SliceIndex<str> for ops::RangeFull {\n         type Output = str;\n@@ -1844,6 +1692,41 @@ mod traits {\n         }\n     }\n \n+    /// Implements substring slicing with syntax `&self[begin .. end]` or `&mut\n+    /// self[begin .. end]`.\n+    ///\n+    /// Returns a slice of the given string from the byte range\n+    /// [`begin`, `end`).\n+    ///\n+    /// This operation is `O(1)`.\n+    ///\n+    /// Prior to 1.20.0, these indexing operations were still supported by\n+    /// direct implementation of `Index` and `IndexMut`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `begin` or `end` does not point to the starting byte offset of\n+    /// a character (as defined by `is_char_boundary`), if `begin > end`, or if\n+    /// `end > len`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// assert_eq!(&s[0 .. 1], \"L\");\n+    ///\n+    /// assert_eq!(&s[1 .. 9], \"\u00f6we \u8001\");\n+    ///\n+    /// // these will panic:\n+    /// // byte 2 lies within `\u00f6`:\n+    /// // &s[2 ..3];\n+    ///\n+    /// // byte 8 lies within `\u8001`\n+    /// // &s[1 .. 8];\n+    ///\n+    /// // byte 100 is outside the string\n+    /// // &s[3 .. 100];\n+    /// ```\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     impl SliceIndex<str> for ops::Range<usize> {\n         type Output = str;\n@@ -1898,6 +1781,21 @@ mod traits {\n         }\n     }\n \n+    /// Implements substring slicing with syntax `&self[.. end]` or `&mut\n+    /// self[.. end]`.\n+    ///\n+    /// Returns a slice of the given string from the byte range [`0`, `end`).\n+    /// Equivalent to `&self[0 .. end]` or `&mut self[0 .. end]`.\n+    ///\n+    /// This operation is `O(1)`.\n+    ///\n+    /// Prior to 1.20.0, these indexing operations were still supported by\n+    /// direct implementation of `Index` and `IndexMut`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `end` does not point to the starting byte offset of a\n+    /// character (as defined by `is_char_boundary`), or if `end > len`.\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     impl SliceIndex<str> for ops::RangeTo<usize> {\n         type Output = str;\n@@ -1943,6 +1841,22 @@ mod traits {\n         }\n     }\n \n+    /// Implements substring slicing with syntax `&self[begin ..]` or `&mut\n+    /// self[begin ..]`.\n+    ///\n+    /// Returns a slice of the given string from the byte range [`begin`,\n+    /// `len`). Equivalent to `&self[begin .. len]` or `&mut self[begin ..\n+    /// len]`.\n+    ///\n+    /// This operation is `O(1)`.\n+    ///\n+    /// Prior to 1.20.0, these indexing operations were still supported by\n+    /// direct implementation of `Index` and `IndexMut`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `begin` does not point to the starting byte offset of\n+    /// a character (as defined by `is_char_boundary`), or if `begin >= len`.\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     impl SliceIndex<str> for ops::RangeFrom<usize> {\n         type Output = str;\n@@ -1990,6 +1904,22 @@ mod traits {\n         }\n     }\n \n+    /// Implements substring slicing with syntax `&self[begin ..= end]` or `&mut\n+    /// self[begin ..= end]`.\n+    ///\n+    /// Returns a slice of the given string from the byte range\n+    /// [`begin`, `end`]. Equivalent to `&self [begin .. end + 1]` or `&mut\n+    /// self[begin .. end + 1]`, except if `end` has the maximum value for\n+    /// `usize`.\n+    ///\n+    /// This operation is `O(1)`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `begin` does not point to the starting byte offset of\n+    /// a character (as defined by `is_char_boundary`), if `end` does not point\n+    /// to the ending byte offset of a character (`end + 1` is either a starting\n+    /// byte offset or equal to `len`), if `begin > end`, or if `end >= len`.\n     #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n     impl SliceIndex<str> for ops::RangeInclusive<usize> {\n         type Output = str;\n@@ -2023,8 +1953,20 @@ mod traits {\n         }\n     }\n \n-\n-\n+    /// Implements substring slicing with syntax `&self[..= end]` or `&mut\n+    /// self[..= end]`.\n+    ///\n+    /// Returns a slice of the given string from the byte range [0, `end`].\n+    /// Equivalent to `&self [0 .. end + 1]`, except if `end` has the maximum\n+    /// value for `usize`.\n+    ///\n+    /// This operation is `O(1)`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `end` does not point to the ending byte offset of a character\n+    /// (`end + 1` is either a starting byte offset as defined by\n+    /// `is_char_boundary`, or equal to `len`), or if `end >= len`.\n     #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n     impl SliceIndex<str> for ops::RangeToInclusive<usize> {\n         type Output = str;"}, {"sha": "4c585a958c14bcd0955d6cdda49e01993dba70a5", "filename": "src/test/ui/index-help.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7d25a2a4082e6d2601ea4c06ea01b632d196172/src%2Ftest%2Fui%2Findex-help.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7d25a2a4082e6d2601ea4c06ea01b632d196172/src%2Ftest%2Fui%2Findex-help.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Findex-help.stderr?ref=c7d25a2a4082e6d2601ea4c06ea01b632d196172", "patch": "@@ -1,4 +1,4 @@\n-error[E0277]: the trait bound `i32: std::slice::SliceIndex<[{integer}]>` is not satisfied\n+error[E0277]: the type `[{integer}]` cannot be indexed by `i32`\n   --> $DIR/index-help.rs:3:5\n    |\n LL |     x[0i32]; //~ ERROR E0277"}, {"sha": "dbe9b44a13890b8b09289cd91d385f7ea97f3c44", "filename": "src/test/ui/indexing-requires-a-uint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7d25a2a4082e6d2601ea4c06ea01b632d196172/src%2Ftest%2Fui%2Findexing-requires-a-uint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7d25a2a4082e6d2601ea4c06ea01b632d196172/src%2Ftest%2Fui%2Findexing-requires-a-uint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Findexing-requires-a-uint.rs?ref=c7d25a2a4082e6d2601ea4c06ea01b632d196172", "patch": "@@ -3,7 +3,7 @@\n \n fn main() {\n     fn bar<T>(_: T) {}\n-    [0][0u8]; //~ ERROR: the trait bound `u8: std::slice::SliceIndex<[{integer}]>` is not satisfied\n+    [0][0u8]; //~ ERROR: the type `[{integer}]` cannot be indexed by `u8`\n \n     [0][0]; // should infer to be a usize\n "}, {"sha": "363c3d0d45853e7fea18fdbb8bf96339702b2239", "filename": "src/test/ui/indexing-requires-a-uint.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7d25a2a4082e6d2601ea4c06ea01b632d196172/src%2Ftest%2Fui%2Findexing-requires-a-uint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7d25a2a4082e6d2601ea4c06ea01b632d196172/src%2Ftest%2Fui%2Findexing-requires-a-uint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Findexing-requires-a-uint.stderr?ref=c7d25a2a4082e6d2601ea4c06ea01b632d196172", "patch": "@@ -1,7 +1,7 @@\n-error[E0277]: the trait bound `u8: std::slice::SliceIndex<[{integer}]>` is not satisfied\n+error[E0277]: the type `[{integer}]` cannot be indexed by `u8`\n   --> $DIR/indexing-requires-a-uint.rs:6:5\n    |\n-LL |     [0][0u8]; //~ ERROR: the trait bound `u8: std::slice::SliceIndex<[{integer}]>` is not satisfied\n+LL |     [0][0u8]; //~ ERROR: the type `[{integer}]` cannot be indexed by `u8`\n    |     ^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n    |\n    = help: the trait `std::slice::SliceIndex<[{integer}]>` is not implemented for `u8`"}, {"sha": "f076dfcb0a42c039febb89f54ab94a26c596f9c9", "filename": "src/test/ui/integral-indexing.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c7d25a2a4082e6d2601ea4c06ea01b632d196172/src%2Ftest%2Fui%2Fintegral-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7d25a2a4082e6d2601ea4c06ea01b632d196172/src%2Ftest%2Fui%2Fintegral-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintegral-indexing.rs?ref=c7d25a2a4082e6d2601ea4c06ea01b632d196172", "patch": "@@ -3,14 +3,14 @@ pub fn main() {\n     let s: String = \"abcdef\".to_string();\n     v[3_usize];\n     v[3];\n-    v[3u8];  //~ERROR : std::slice::SliceIndex<[isize]>` is not satisfied\n-    v[3i8];  //~ERROR : std::slice::SliceIndex<[isize]>` is not satisfied\n-    v[3u32]; //~ERROR : std::slice::SliceIndex<[isize]>` is not satisfied\n-    v[3i32]; //~ERROR : std::slice::SliceIndex<[isize]>` is not satisfied\n+    v[3u8];  //~ERROR : the type `[isize]` cannot be indexed by `u8`\n+    v[3i8];  //~ERROR : the type `[isize]` cannot be indexed by `i8`\n+    v[3u32]; //~ERROR : the type `[isize]` cannot be indexed by `u32`\n+    v[3i32]; //~ERROR : the type `[isize]` cannot be indexed by `i32`\n     s.as_bytes()[3_usize];\n     s.as_bytes()[3];\n-    s.as_bytes()[3u8];  //~ERROR : std::slice::SliceIndex<[u8]>` is not satisfied\n-    s.as_bytes()[3i8];  //~ERROR : std::slice::SliceIndex<[u8]>` is not satisfied\n-    s.as_bytes()[3u32]; //~ERROR : std::slice::SliceIndex<[u8]>` is not satisfied\n-    s.as_bytes()[3i32]; //~ERROR : std::slice::SliceIndex<[u8]>` is not satisfied\n+    s.as_bytes()[3u8];  //~ERROR : the type `[u8]` cannot be indexed by `u8`\n+    s.as_bytes()[3i8];  //~ERROR : the type `[u8]` cannot be indexed by `i8`\n+    s.as_bytes()[3u32]; //~ERROR : the type `[u8]` cannot be indexed by `u32`\n+    s.as_bytes()[3i32]; //~ERROR : the type `[u8]` cannot be indexed by `i32`\n }"}, {"sha": "efbad86c4d31b3126546cba841a2e98afcaca9f0", "filename": "src/test/ui/integral-indexing.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c7d25a2a4082e6d2601ea4c06ea01b632d196172/src%2Ftest%2Fui%2Fintegral-indexing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7d25a2a4082e6d2601ea4c06ea01b632d196172/src%2Ftest%2Fui%2Fintegral-indexing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintegral-indexing.stderr?ref=c7d25a2a4082e6d2601ea4c06ea01b632d196172", "patch": "@@ -1,70 +1,70 @@\n-error[E0277]: the trait bound `u8: std::slice::SliceIndex<[isize]>` is not satisfied\n+error[E0277]: the type `[isize]` cannot be indexed by `u8`\n   --> $DIR/integral-indexing.rs:6:5\n    |\n-LL |     v[3u8];  //~ERROR : std::slice::SliceIndex<[isize]>` is not satisfied\n+LL |     v[3u8];  //~ERROR : the type `[isize]` cannot be indexed by `u8`\n    |     ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n    |\n    = help: the trait `std::slice::SliceIndex<[isize]>` is not implemented for `u8`\n    = note: required because of the requirements on the impl of `std::ops::Index<u8>` for `std::vec::Vec<isize>`\n \n-error[E0277]: the trait bound `i8: std::slice::SliceIndex<[isize]>` is not satisfied\n+error[E0277]: the type `[isize]` cannot be indexed by `i8`\n   --> $DIR/integral-indexing.rs:7:5\n    |\n-LL |     v[3i8];  //~ERROR : std::slice::SliceIndex<[isize]>` is not satisfied\n+LL |     v[3i8];  //~ERROR : the type `[isize]` cannot be indexed by `i8`\n    |     ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n    |\n    = help: the trait `std::slice::SliceIndex<[isize]>` is not implemented for `i8`\n    = note: required because of the requirements on the impl of `std::ops::Index<i8>` for `std::vec::Vec<isize>`\n \n-error[E0277]: the trait bound `u32: std::slice::SliceIndex<[isize]>` is not satisfied\n+error[E0277]: the type `[isize]` cannot be indexed by `u32`\n   --> $DIR/integral-indexing.rs:8:5\n    |\n-LL |     v[3u32]; //~ERROR : std::slice::SliceIndex<[isize]>` is not satisfied\n+LL |     v[3u32]; //~ERROR : the type `[isize]` cannot be indexed by `u32`\n    |     ^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n    |\n    = help: the trait `std::slice::SliceIndex<[isize]>` is not implemented for `u32`\n    = note: required because of the requirements on the impl of `std::ops::Index<u32>` for `std::vec::Vec<isize>`\n \n-error[E0277]: the trait bound `i32: std::slice::SliceIndex<[isize]>` is not satisfied\n+error[E0277]: the type `[isize]` cannot be indexed by `i32`\n   --> $DIR/integral-indexing.rs:9:5\n    |\n-LL |     v[3i32]; //~ERROR : std::slice::SliceIndex<[isize]>` is not satisfied\n+LL |     v[3i32]; //~ERROR : the type `[isize]` cannot be indexed by `i32`\n    |     ^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n    |\n    = help: the trait `std::slice::SliceIndex<[isize]>` is not implemented for `i32`\n    = note: required because of the requirements on the impl of `std::ops::Index<i32>` for `std::vec::Vec<isize>`\n \n-error[E0277]: the trait bound `u8: std::slice::SliceIndex<[u8]>` is not satisfied\n+error[E0277]: the type `[u8]` cannot be indexed by `u8`\n   --> $DIR/integral-indexing.rs:12:5\n    |\n-LL |     s.as_bytes()[3u8];  //~ERROR : std::slice::SliceIndex<[u8]>` is not satisfied\n+LL |     s.as_bytes()[3u8];  //~ERROR : the type `[u8]` cannot be indexed by `u8`\n    |     ^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n    |\n    = help: the trait `std::slice::SliceIndex<[u8]>` is not implemented for `u8`\n    = note: required because of the requirements on the impl of `std::ops::Index<u8>` for `[u8]`\n \n-error[E0277]: the trait bound `i8: std::slice::SliceIndex<[u8]>` is not satisfied\n+error[E0277]: the type `[u8]` cannot be indexed by `i8`\n   --> $DIR/integral-indexing.rs:13:5\n    |\n-LL |     s.as_bytes()[3i8];  //~ERROR : std::slice::SliceIndex<[u8]>` is not satisfied\n+LL |     s.as_bytes()[3i8];  //~ERROR : the type `[u8]` cannot be indexed by `i8`\n    |     ^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n    |\n    = help: the trait `std::slice::SliceIndex<[u8]>` is not implemented for `i8`\n    = note: required because of the requirements on the impl of `std::ops::Index<i8>` for `[u8]`\n \n-error[E0277]: the trait bound `u32: std::slice::SliceIndex<[u8]>` is not satisfied\n+error[E0277]: the type `[u8]` cannot be indexed by `u32`\n   --> $DIR/integral-indexing.rs:14:5\n    |\n-LL |     s.as_bytes()[3u32]; //~ERROR : std::slice::SliceIndex<[u8]>` is not satisfied\n+LL |     s.as_bytes()[3u32]; //~ERROR : the type `[u8]` cannot be indexed by `u32`\n    |     ^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n    |\n    = help: the trait `std::slice::SliceIndex<[u8]>` is not implemented for `u32`\n    = note: required because of the requirements on the impl of `std::ops::Index<u32>` for `[u8]`\n \n-error[E0277]: the trait bound `i32: std::slice::SliceIndex<[u8]>` is not satisfied\n+error[E0277]: the type `[u8]` cannot be indexed by `i32`\n   --> $DIR/integral-indexing.rs:15:5\n    |\n-LL |     s.as_bytes()[3i32]; //~ERROR : std::slice::SliceIndex<[u8]>` is not satisfied\n+LL |     s.as_bytes()[3i32]; //~ERROR : the type `[u8]` cannot be indexed by `i32`\n    |     ^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n    |\n    = help: the trait `std::slice::SliceIndex<[u8]>` is not implemented for `i32`"}, {"sha": "7b45d848c97b7a3e1406f287154084728cd879e1", "filename": "src/test/ui/on-unimplemented/slice-index.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7d25a2a4082e6d2601ea4c06ea01b632d196172/src%2Ftest%2Fui%2Fon-unimplemented%2Fslice-index.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7d25a2a4082e6d2601ea4c06ea01b632d196172/src%2Ftest%2Fui%2Fon-unimplemented%2Fslice-index.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fon-unimplemented%2Fslice-index.stderr?ref=c7d25a2a4082e6d2601ea4c06ea01b632d196172", "patch": "@@ -1,4 +1,4 @@\n-error[E0277]: the trait bound `i32: std::slice::SliceIndex<[i32]>` is not satisfied\n+error[E0277]: the type `[i32]` cannot be indexed by `i32`\n   --> $DIR/slice-index.rs:11:5\n    |\n LL |     x[1i32]; //~ ERROR E0277\n@@ -7,7 +7,7 @@ LL |     x[1i32]; //~ ERROR E0277\n    = help: the trait `std::slice::SliceIndex<[i32]>` is not implemented for `i32`\n    = note: required because of the requirements on the impl of `std::ops::Index<i32>` for `[i32]`\n \n-error[E0277]: the trait bound `std::ops::RangeTo<i32>: std::slice::SliceIndex<[i32]>` is not satisfied\n+error[E0277]: the type `[i32]` cannot be indexed by `std::ops::RangeTo<i32>`\n   --> $DIR/slice-index.rs:12:5\n    |\n LL |     x[..1i32]; //~ ERROR E0277"}, {"sha": "1b32ed5533d35279bb086b1851e65477c3610a98", "filename": "src/test/ui/str/str-idx.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c7d25a2a4082e6d2601ea4c06ea01b632d196172/src%2Ftest%2Fui%2Fstr%2Fstr-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7d25a2a4082e6d2601ea4c06ea01b632d196172/src%2Ftest%2Fui%2Fstr%2Fstr-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstr%2Fstr-idx.rs?ref=c7d25a2a4082e6d2601ea4c06ea01b632d196172", "patch": "@@ -1,4 +1,7 @@\n pub fn main() {\n     let s: &str = \"hello\";\n-    let c: u8 = s[4]; //~ ERROR the type `str` cannot be indexed by `{integer}`\n+    let _: u8 = s[4]; //~ ERROR the type `str` cannot be indexed by `{integer}`\n+    let _ = s.get(4); //~ ERROR the type `str` cannot be indexed by `{integer}`\n+    let _ = s.get_unchecked(4); //~ ERROR the type `str` cannot be indexed by `{integer}`\n+    let _: u8 = s['c']; //~ ERROR the type `str` cannot be indexed by `char`\n }"}, {"sha": "99df85d92fd9662085e4d7d76bd2e2e340ae849e", "filename": "src/test/ui/str/str-idx.stderr", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c7d25a2a4082e6d2601ea4c06ea01b632d196172/src%2Ftest%2Fui%2Fstr%2Fstr-idx.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7d25a2a4082e6d2601ea4c06ea01b632d196172/src%2Ftest%2Fui%2Fstr%2Fstr-idx.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstr%2Fstr-idx.stderr?ref=c7d25a2a4082e6d2601ea4c06ea01b632d196172", "patch": "@@ -1,13 +1,43 @@\n error[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> $DIR/str-idx.rs:3:17\n    |\n-LL |     let c: u8 = s[4]; //~ ERROR the type `str` cannot be indexed by `{integer}`\n-   |                 ^^^^ `str` cannot be indexed by `{integer}`\n+LL |     let _: u8 = s[4]; //~ ERROR the type `str` cannot be indexed by `{integer}`\n+   |                 ^^^^ string indices are ranges of `usize`\n    |\n-   = help: the trait `std::ops::Index<{integer}>` is not implemented for `str`\n+   = help: the trait `std::slice::SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n+   = note: required because of the requirements on the impl of `std::ops::Index<{integer}>` for `str`\n \n-error: aborting due to previous error\n+error[E0277]: the type `str` cannot be indexed by `{integer}`\n+  --> $DIR/str-idx.rs:4:15\n+   |\n+LL |     let _ = s.get(4); //~ ERROR the type `str` cannot be indexed by `{integer}`\n+   |               ^^^ string indices are ranges of `usize`\n+   |\n+   = help: the trait `std::slice::SliceIndex<str>` is not implemented for `{integer}`\n+   = note: you can use `.chars().nth()` or `.bytes().nth()`\n+           see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n+\n+error[E0277]: the type `str` cannot be indexed by `{integer}`\n+  --> $DIR/str-idx.rs:5:15\n+   |\n+LL |     let _ = s.get_unchecked(4); //~ ERROR the type `str` cannot be indexed by `{integer}`\n+   |               ^^^^^^^^^^^^^ string indices are ranges of `usize`\n+   |\n+   = help: the trait `std::slice::SliceIndex<str>` is not implemented for `{integer}`\n+   = note: you can use `.chars().nth()` or `.bytes().nth()`\n+           see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n+\n+error[E0277]: the type `str` cannot be indexed by `char`\n+  --> $DIR/str-idx.rs:6:17\n+   |\n+LL |     let _: u8 = s['c']; //~ ERROR the type `str` cannot be indexed by `char`\n+   |                 ^^^^^^ string indices are ranges of `usize`\n+   |\n+   = help: the trait `std::slice::SliceIndex<str>` is not implemented for `char`\n+   = note: required because of the requirements on the impl of `std::ops::Index<char>` for `str`\n+\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "575a9eae859465788d447044a07034685e21434d", "filename": "src/test/ui/str/str-mut-idx.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7d25a2a4082e6d2601ea4c06ea01b632d196172/src%2Ftest%2Fui%2Fstr%2Fstr-mut-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7d25a2a4082e6d2601ea4c06ea01b632d196172/src%2Ftest%2Fui%2Fstr%2Fstr-mut-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstr%2Fstr-mut-idx.rs?ref=c7d25a2a4082e6d2601ea4c06ea01b632d196172", "patch": "@@ -5,7 +5,13 @@ fn mutate(s: &mut str) {\n     //~^ ERROR the size for values of type\n     //~| ERROR the size for values of type\n     s[1usize] = bot();\n-    //~^ ERROR the type `str` cannot be mutably indexed by `usize`\n+    //~^ ERROR the type `str` cannot be indexed by `usize`\n+    s.get_mut(1);\n+    //~^ ERROR the type `str` cannot be indexed by `{integer}`\n+    s.get_unchecked_mut(1);\n+    //~^ ERROR the type `str` cannot be indexed by `{integer}`\n+    s['c'];\n+    //~^ ERROR the type `str` cannot be indexed by `char`\n }\n \n pub fn main() {}"}, {"sha": "beb227245236343c7e7fcfc0b5c06bf22f48a17c", "filename": "src/test/ui/str/str-mut-idx.stderr", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c7d25a2a4082e6d2601ea4c06ea01b632d196172/src%2Ftest%2Fui%2Fstr%2Fstr-mut-idx.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7d25a2a4082e6d2601ea4c06ea01b632d196172/src%2Ftest%2Fui%2Fstr%2Fstr-mut-idx.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstr%2Fstr-mut-idx.stderr?ref=c7d25a2a4082e6d2601ea4c06ea01b632d196172", "patch": "@@ -22,16 +22,44 @@ LL |     s[1..2] = bot();\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: the left-hand-side of an assignment must have a statically known size\n \n-error[E0277]: the type `str` cannot be mutably indexed by `usize`\n+error[E0277]: the type `str` cannot be indexed by `usize`\n   --> $DIR/str-mut-idx.rs:7:5\n    |\n LL |     s[1usize] = bot();\n-   |     ^^^^^^^^^ `str` cannot be mutably indexed by `usize`\n+   |     ^^^^^^^^^ string indices are ranges of `usize`\n    |\n-   = help: the trait `std::ops::IndexMut<usize>` is not implemented for `str`\n+   = help: the trait `std::slice::SliceIndex<str>` is not implemented for `usize`\n+   = note: required because of the requirements on the impl of `std::ops::Index<usize>` for `str`\n+\n+error[E0277]: the type `str` cannot be indexed by `{integer}`\n+  --> $DIR/str-mut-idx.rs:9:7\n+   |\n+LL |     s.get_mut(1);\n+   |       ^^^^^^^ string indices are ranges of `usize`\n+   |\n+   = help: the trait `std::slice::SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n \n-error: aborting due to 3 previous errors\n+error[E0277]: the type `str` cannot be indexed by `{integer}`\n+  --> $DIR/str-mut-idx.rs:11:7\n+   |\n+LL |     s.get_unchecked_mut(1);\n+   |       ^^^^^^^^^^^^^^^^^ string indices are ranges of `usize`\n+   |\n+   = help: the trait `std::slice::SliceIndex<str>` is not implemented for `{integer}`\n+   = note: you can use `.chars().nth()` or `.bytes().nth()`\n+           see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n+\n+error[E0277]: the type `str` cannot be indexed by `char`\n+  --> $DIR/str-mut-idx.rs:13:5\n+   |\n+LL |     s['c'];\n+   |     ^^^^^^ string indices are ranges of `usize`\n+   |\n+   = help: the trait `std::slice::SliceIndex<str>` is not implemented for `char`\n+   = note: required because of the requirements on the impl of `std::ops::Index<char>` for `str`\n+\n+error: aborting due to 6 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}]}