{"sha": "b8fad79a07ef287a80959ec8c4f82e7e6803b053", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4ZmFkNzlhMDdlZjI4N2E4MDk1OWVjOGM0ZjgyZTdlNjgwM2IwNTM=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-01-23T05:44:38Z"}, "committer": {"name": "ggomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-05-11T11:22:01Z"}, "message": "Improve error message for Index trait on slices", "tree": {"sha": "e774b9770c39f14f2d6e6fe6451f6f18e6c70d58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e774b9770c39f14f2d6e6fe6451f6f18e6c70d58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8fad79a07ef287a80959ec8c4f82e7e6803b053", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8fad79a07ef287a80959ec8c4f82e7e6803b053", "html_url": "https://github.com/rust-lang/rust/commit/b8fad79a07ef287a80959ec8c4f82e7e6803b053", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8fad79a07ef287a80959ec8c4f82e7e6803b053/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9797d4be51e1118773877a078859f997c4191b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9797d4be51e1118773877a078859f997c4191b2", "html_url": "https://github.com/rust-lang/rust/commit/e9797d4be51e1118773877a078859f997c4191b2"}], "stats": {"total": 157, "additions": 129, "deletions": 28}, "files": [{"sha": "e4b98ed6445c7775d1db38e683956f70ee15463e", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8fad79a07ef287a80959ec8c4f82e7e6803b053/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fad79a07ef287a80959ec8c4f82e7e6803b053/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=b8fad79a07ef287a80959ec8c4f82e7e6803b053", "patch": "@@ -523,6 +523,8 @@ impl<T> SliceExt for [T] {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(unused_attributes)]\n+#[rustc_on_unimplemented = \"a usize is required to index into a slice\"]\n impl<T> ops::Index<usize> for [T] {\n     type Output = T;\n \n@@ -533,6 +535,8 @@ impl<T> ops::Index<usize> for [T] {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(unused_attributes)]\n+#[rustc_on_unimplemented = \"a usize is required to index into a slice\"]\n impl<T> ops::IndexMut<usize> for [T] {\n     #[inline]\n     fn index_mut(&mut self, index: usize) -> &mut T {"}, {"sha": "88502e2b6ffbedacb3589b7c4958632cfa9fed8a", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 79, "deletions": 28, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/b8fad79a07ef287a80959ec8c4f82e7e6803b053/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fad79a07ef287a80959ec8c4f82e7e6803b053/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=b8fad79a07ef287a80959ec8c4f82e7e6803b053", "patch": "@@ -29,8 +29,8 @@ use hir::def_id::DefId;\n use infer::{self, InferCtxt, TypeOrigin};\n use ty::{self, ToPredicate, ToPolyTraitRef, TraitRef, Ty, TyCtxt, TypeFoldable};\n use ty::fast_reject;\n-use ty::fold::{TypeFoldable, TypeFolder};\n-use ty::::subst::{self, Subst};\n+use ty::fold::TypeFolder;\n+use ty::subst::{self, Subst};\n use util::nodemap::{FnvHashMap, FnvHashSet};\n \n use std::cmp;\n@@ -62,7 +62,7 @@ impl<'a, 'gcx, 'tcx> TraitErrorKey<'tcx> {\n     }\n }\n \n-fn impl_self_ty<'a, 'tcx>(fcx: &InferCtxt<'a, 'tcx>,\n+fn impl_substs<'a, 'tcx>(fcx: &InferCtxt<'a, 'tcx>,\n                           did: DefId,\n                           obligation: PredicateObligation<'tcx>)\n                           -> subst::Substs<'tcx> {\n@@ -82,35 +82,74 @@ fn impl_self_ty<'a, 'tcx>(fcx: &InferCtxt<'a, 'tcx>,\n     substs\n }\n \n+/*fn check_type_parameters<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                   trait_substs: &subst::Substs<'tcx>,\n+                                   impl_substs: &subst::Substs<'tcx>,\n+                                   obligation: &PredicateObligation<'tcx>) -> bool {\n+    let trait_types = trait_substs.types.as_slice();\n+    let impl_types = impl_substs.types.as_slice();\n+\n+    let mut failed = 0;\n+    for index_to_ignore in 0..trait_types.len() {\n+        for (index, (trait_type, impl_type)) in trait_types.iter()\n+                                                           .zip(impl_types.iter())\n+                                                           .enumerate() {\n+            if index_to_ignore != index &&\n+                infer::mk_eqty(infcx, true,\n+                               TypeOrigin::Misc(obligation.cause.span),\n+                               trait_type,\n+                               impl_type).is_err() {\n+                failed += 1;\n+                break;\n+            }\n+        }\n+    }\n+    failed == trait_types.len() - 1\n+}*/\n+\n fn get_current_failing_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                       trait_ref: &TraitRef<'tcx>,\n                                       obligation: &PredicateObligation<'tcx>)\n-                                     -> Option<DefId> {\n+                                     -> Option<(DefId, subst::Substs<'tcx>)> {\n+    println!(\"1\");\n     let simp = fast_reject::simplify_type(infcx.tcx,\n                                           trait_ref.self_ty(),\n                                           true);\n     let trait_def = infcx.tcx.lookup_trait_def(trait_ref.def_id);\n \n     match simp {\n         Some(_) => {\n-            let mut ret = None;\n+            println!(\"2\");\n+            let mut matching_impls = Vec::new();\n             trait_def.for_each_impl(infcx.tcx, |def_id| {\n                 let imp = infcx.tcx.impl_trait_ref(def_id).unwrap();\n-                let imp = imp.subst(infcx.tcx, &impl_self_ty(infcx, def_id, obligation.clone()));\n-                if ret.is_none() {\n-                    for error in infcx.reported_trait_errors.borrow().iter() {\n-                        if let ty::Predicate::Trait(ref t) = error.predicate {\n-                            if infer::mk_eqty(infcx, true, TypeOrigin::Misc(obligation.cause.span),\n-                                              t.skip_binder().trait_ref.self_ty(),\n-                                              imp.self_ty()).is_ok() {\n-                                ret = Some(def_id);\n-                                break;\n-                            }\n-                        }\n-                    }\n+                let substs = impl_substs(infcx, def_id, obligation.clone());\n+                let imp = imp.subst(infcx.tcx, &substs);\n+\n+                if infer::mk_eqty(infcx, true,\n+                                  TypeOrigin::Misc(obligation.cause.span),\n+                                  trait_ref.self_ty(),\n+                                  imp.self_ty()).is_ok() {\n+                    //if check_type_parameters(infcx, &trait_ref.substs, &imp.substs, obligation) {\n+                        matching_impls.push((def_id, imp.substs.clone()));\n+                    //}\n                 }\n+                println!(\"=> {:?} /// {:?}\", def_id, imp.substs);\n             });\n-            ret\n+            if matching_impls.len() == 0 {\n+                println!(\"3\");\n+                None\n+            } else if matching_impls.len() == 1 {\n+                println!(\"4\");\n+                Some(matching_impls[0].clone())\n+            } else {\n+                println!(\"5\");\n+                // we need to determine which type is the good one!\n+                for &(ref m, ref n) in matching_impls.iter() {\n+                    println!(\"=> {:?} /// {:?}\", m, n);\n+                }\n+                Some(matching_impls[0].clone())\n+            }\n         },\n         None => None,\n     }\n@@ -128,19 +167,21 @@ fn find_attr<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     None\n }\n \n-fn report_on_unimplemented<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                     trait_ref: &TraitRef<'tcx>,\n-                                     obligation: &PredicateObligation<'tcx>)\n-                                    -> Option<String> {\n+fn on_unimplemented_note<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                   trait_ref: ty::PolyTraitRef<'tcx>,\n+                                   obligation: &PredicateObligation<'tcx>) -> Option<String> {\n+    let trait_ref = trait_ref.skip_binder();\n+    //let def_id = trait_ref.def_id;\n+    let mut report = None;\n     let def_id = match get_current_failing_impl(infcx, trait_ref, obligation) {\n-        Some(def_id) => {\n+        Some((def_id, _)) => {\n             if let Some(_) = find_attr(infcx, def_id, \"rustc_on_unimplemented\") {\n                 def_id\n             } else {\n                 trait_ref.def_id\n             }\n         },\n-        None         => trait_ref.def_id,\n+        None => trait_ref.def_id,\n     };\n     let span = obligation.cause.span;\n     let mut report = None;\n@@ -572,11 +613,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                 //     \"the type `T` can't be frobnicated\"\n                                 // which is somewhat confusing.\n                                 err.help(&format!(\"consider adding a `where {}` bound\",\n-                                    trait_ref.to_predicate()));\n+                                                  trait_ref.to_predicate()));\n                             } else if let Some(s) = on_unimplemented_note(infcx, trait_ref,\n-                                                                          obligation.cause.span) {\n-                                // Otherwise, if there is an on-unimplemented note,\n-                                // display it.\n+                                                                          obligation) {\n+                                // If it has a custom \"#[rustc_on_unimplemented]\"\n+                                // error message, let's display it!\n                                 err.note(&s);\n                             } else {\n                                 let trait_ref = trait_predicate.to_poly_trait_ref();\n@@ -624,6 +665,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                 }\n                                 err\n                             }\n+                            // Check if it has a custom \"#[rustc_on_unimplemented]\"\n+                            // error message, report with that message if it does\n+                            /*let custom_note = report_on_unimplemented(infcx, &trait_ref.0,\n+                                                                      obligation);\n+                            if let Some(s) = custom_note {\n+                                err.fileline_note(obligation.cause.span, &s);\n+                            } else {\n+                                note_obligation_cause(infcx, &mut err, obligation);\n+                            }*/\n+                            err.emit();\n                         }\n \n                         ty::Predicate::Equate(ref predicate) => {"}, {"sha": "beba3bd04c12a3523703abd71e8b9bab07347faf", "filename": "src/test/compile-fail/on_unimplemented.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b8fad79a07ef287a80959ec8c4f82e7e6803b053/src%2Ftest%2Fcompile-fail%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fad79a07ef287a80959ec8c4f82e7e6803b053/src%2Ftest%2Fcompile-fail%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fon_unimplemented.rs?ref=b8fad79a07ef287a80959ec8c4f82e7e6803b053", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test if the on_unimplemented message override works\n+\n+#![feature(on_unimplemented)]\n+#![feature(rustc_attrs)]\n+\n+#[rustc_on_unimplemented = \"invalid\"]\n+trait Index<Idx: ?Sized> {\n+    type Output: ?Sized;\n+    fn index(&self, index: Idx) -> &Self::Output;\n+}\n+\n+struct Foo {\n+    i: usize,\n+}\n+\n+#[rustc_on_unimplemented = \"a Foo is required to index into a slice\"]\n+impl Index<Foo> for [i32] {\n+    type Output = i32;\n+    fn index(&self, index: Foo) -> &i32 {\n+        &self[index.i]\n+    }\n+}\n+\n+#[rustc_on_unimplemented = \"a usize is required to index into a slice\"]\n+impl Index<usize> for [i32] {\n+    type Output = i32;\n+    fn index(&self, index: usize) -> &i32 {\n+        &self[index]\n+    }\n+}\n+\n+#[rustc_error]\n+fn main() {\n+    Index::<u32>::index(&[1, 2, 3] as &[i32], 2u32); //~ ERROR E0277\n+                                                     //~| NOTE a usize is required\n+}"}]}