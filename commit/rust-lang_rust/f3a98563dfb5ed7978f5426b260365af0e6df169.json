{"sha": "f3a98563dfb5ed7978f5426b260365af0e6df169", "node_id": "C_kwDOAAsO6NoAKGYzYTk4NTYzZGZiNWVkNzk3OGY1NDI2YjI2MDM2NWFmMGU2ZGYxNjk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-08T13:08:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-08T13:08:08Z"}, "message": "Auto merge of #2058 - RalfJung:variadic, r=RalfJung\n\nFor variadic functions, accept arbitrary trailing arguments\n\nHowever, make sure that if we use argument N we check the size of all arguments before that, because otherwise this might not work properly depending on how varargs are implemented. This caught bugs in our futex tests. ;)\n\nI couldn't find a good way to systematically ensure this, so it is just something we have to be on the look for during review. (This generally applies also for fixed-arg shims: we should check the size of each parameter.)\n\nAlso treat prctl like a variadic function, Cc `@saethlin.`", "tree": {"sha": "22d6bd34acc680939082106a0e02f810fd71d235", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22d6bd34acc680939082106a0e02f810fd71d235"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3a98563dfb5ed7978f5426b260365af0e6df169", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3a98563dfb5ed7978f5426b260365af0e6df169", "html_url": "https://github.com/rust-lang/rust/commit/f3a98563dfb5ed7978f5426b260365af0e6df169", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3a98563dfb5ed7978f5426b260365af0e6df169/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8acc9b2799f5587f5f29dfce487ec3aa94964dfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/8acc9b2799f5587f5f29dfce487ec3aa94964dfe", "html_url": "https://github.com/rust-lang/rust/commit/8acc9b2799f5587f5f29dfce487ec3aa94964dfe"}, {"sha": "cac48dd734434ff3f9a53f78b54eebd9020f2a18", "url": "https://api.github.com/repos/rust-lang/rust/commits/cac48dd734434ff3f9a53f78b54eebd9020f2a18", "html_url": "https://github.com/rust-lang/rust/commit/cac48dd734434ff3f9a53f78b54eebd9020f2a18"}], "stats": {"total": 162, "additions": 81, "deletions": 81}, "files": [{"sha": "5395d0f0bf1123db321f9b3b07fc3a81eb609e08", "filename": "src/shims/posix/fs.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f3a98563dfb5ed7978f5426b260365af0e6df169/src%2Fshims%2Fposix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a98563dfb5ed7978f5426b260365af0e6df169/src%2Fshims%2Fposix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Ffs.rs?ref=f3a98563dfb5ed7978f5426b260365af0e6df169", "patch": "@@ -15,7 +15,6 @@ use rustc_middle::ty::{self, layout::LayoutOf};\n use rustc_target::abi::{Align, Size};\n \n use crate::*;\n-use helpers::check_arg_count;\n use shims::os_str::os_str_to_bytes;\n use shims::time::system_time_to_duration;\n \n@@ -479,16 +478,16 @@ fn maybe_sync_file(\n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     fn open(&mut self, args: &[OpTy<'tcx, Tag>]) -> InterpResult<'tcx, i32> {\n-        if args.len() < 2 || args.len() > 3 {\n+        if args.len() < 2 {\n             throw_ub_format!(\n-                \"incorrect number of arguments for `open`: got {}, expected 2 or 3\",\n+                \"incorrect number of arguments for `open`: got {}, expected at least 2\",\n                 args.len()\n             );\n         }\n \n         let this = self.eval_context_mut();\n \n-        let path_op = &args[0];\n+        let path = this.read_pointer(&args[0])?;\n         let flag = this.read_scalar(&args[1])?.to_i32()?;\n \n         let mut options = OpenOptions::new();\n@@ -541,7 +540,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.read_scalar(arg)?.to_u32()?\n             } else {\n                 throw_ub_format!(\n-                    \"incorrect number of arguments for `open` with `O_CREAT`: got {}, expected 3\",\n+                    \"incorrect number of arguments for `open` with `O_CREAT`: got {}, expected at least 3\",\n                     args.len()\n                 );\n             };\n@@ -572,7 +571,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             throw_unsup_format!(\"unsupported flags {:#x}\", flag & !mirror);\n         }\n \n-        let path = this.read_path_from_c_str(this.read_pointer(path_op)?)?;\n+        let path = this.read_path_from_c_str(path)?;\n \n         // Reject if isolation is enabled.\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n@@ -614,7 +613,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // `FD_CLOEXEC` value without checking if the flag is set for the file because `std`\n             // always sets this flag when opening a file. However we still need to check that the\n             // file itself is open.\n-            let &[_, _] = check_arg_count(args)?;\n             if this.machine.file_handler.handles.contains_key(&fd) {\n                 Ok(this.eval_libc_i32(\"FD_CLOEXEC\")?)\n             } else {\n@@ -627,8 +625,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // because exec() isn't supported. The F_DUPFD and F_DUPFD_CLOEXEC commands only\n             // differ in whether the FD_CLOEXEC flag is pre-set on the new file descriptor,\n             // thus they can share the same implementation here.\n-            let &[_, _, ref start] = check_arg_count(args)?;\n-            let start = this.read_scalar(start)?.to_i32()?;\n+            if args.len() < 3 {\n+                throw_ub_format!(\n+                    \"incorrect number of arguments for fcntl with cmd=`F_DUPFD`/`F_DUPFD_CLOEXEC`: got {}, expected at least 3\",\n+                    args.len()\n+                );\n+            }\n+            let start = this.read_scalar(&args[2])?.to_i32()?;\n \n             let fh = &mut this.machine.file_handler;\n \n@@ -646,7 +649,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 None => return this.handle_not_found(),\n             }\n         } else if this.tcx.sess.target.os == \"macos\" && cmd == this.eval_libc_i32(\"F_FULLFSYNC\")? {\n-            let &[_, _] = check_arg_count(args)?;\n             if let Some(file_descriptor) = this.machine.file_handler.handles.get(&fd) {\n                 // FIXME: Support fullfsync for all FDs\n                 let FileHandle { file, writable } = file_descriptor.as_file_handle()?;\n@@ -919,15 +921,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         dirfd_op: &OpTy<'tcx, Tag>,    // Should be an `int`\n         pathname_op: &OpTy<'tcx, Tag>, // Should be a `const char *`\n         flags_op: &OpTy<'tcx, Tag>,    // Should be an `int`\n-        _mask_op: &OpTy<'tcx, Tag>,    // Should be an `unsigned int`\n+        mask_op: &OpTy<'tcx, Tag>,     // Should be an `unsigned int`\n         statxbuf_op: &OpTy<'tcx, Tag>, // Should be a `struct statx *`\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         this.assert_target_os(\"linux\", \"statx\");\n \n-        let statxbuf_ptr = this.read_pointer(statxbuf_op)?;\n+        let dirfd = this.read_scalar(dirfd_op)?.to_i32()?;\n         let pathname_ptr = this.read_pointer(pathname_op)?;\n+        let flags = this.read_scalar(flags_op)?.to_i32()?;\n+        let _mask = this.read_scalar(mask_op)?.to_u32()?;\n+        let statxbuf_ptr = this.read_pointer(statxbuf_op)?;\n \n         // If the statxbuf or pathname pointers are null, the function fails with `EFAULT`.\n         if this.ptr_is_null(statxbuf_ptr)? || this.ptr_is_null(pathname_ptr)? {\n@@ -953,9 +958,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let path = this.read_path_from_c_str(pathname_ptr)?.into_owned();\n         // See <https://github.com/rust-lang/rust/pull/79196> for a discussion of argument sizes.\n-        let flags = this.read_scalar(flags_op)?.to_i32()?;\n         let empty_path_flag = flags & this.eval_libc(\"AT_EMPTY_PATH\")?.to_i32()? != 0;\n-        let dirfd = this.read_scalar(dirfd_op)?.to_i32()?;\n         // We only support:\n         // * interpreting `path` as an absolute directory,\n         // * interpreting `path` as a path relative to `dirfd` when the latter is `AT_FDCWD`, or"}, {"sha": "339fb04dae337b8931f136ca1dfcf59b891ec9b2", "filename": "src/shims/posix/linux/foreign_items.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f3a98563dfb5ed7978f5426b260365af0e6df169/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a98563dfb5ed7978f5426b260365af0e6df169/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs?ref=f3a98563dfb5ed7978f5426b260365af0e6df169", "patch": "@@ -106,9 +106,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Threading\n             \"prctl\" => {\n-                let &[ref option, ref arg2, ref arg3, ref arg4, ref arg5] =\n-                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                let result = this.prctl(option, arg2, arg3, arg4, arg5)?;\n+                // prctl is variadic. (It is not documented like that in the manpage, but defined like that in the libc crate.)\n+                this.check_abi_and_shim_symbol_clash(abi, Abi::C { unwind: false }, link_name)?;\n+                let result = this.prctl(args)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_condattr_setclock\" => {\n@@ -130,16 +130,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // count is checked bellow.\n                 this.check_abi_and_shim_symbol_clash(abi, Abi::C { unwind: false }, link_name)?;\n                 // The syscall variadic function is legal to call with more arguments than needed,\n-                // extra arguments are simply ignored. However, all arguments need to be scalars;\n-                // other types might be treated differently by the calling convention.\n-                for arg in args {\n-                    if !matches!(arg.layout.abi, rustc_target::abi::Abi::Scalar(_)) {\n-                        throw_ub_format!(\n-                            \"`syscall` arguments must all have scalar layout, but {} does not\",\n-                            arg.layout.ty\n-                        );\n-                    }\n-                }\n+                // extra arguments are simply ignored. The important check is that when we use an\n+                // argument, we have to also check all arguments *before* it to ensure that they\n+                // have the right type.\n \n                 let sys_getrandom = this.eval_libc(\"SYS_getrandom\")?.to_machine_usize(this)?;\n \n@@ -181,7 +174,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     }\n                     // `futex` is used by some synchonization primitives.\n                     id if id == sys_futex => {\n-                        futex(this, args, dest)?;\n+                        futex(this, &args[1..], dest)?;\n                     }\n                     id => {\n                         this.handle_unsupported(format!(\"can't execute syscall with ID {}\", id))?;"}, {"sha": "362373bb7d3b3df66e15c9e1238f45956a04c8e4", "filename": "src/shims/posix/linux/sync.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f3a98563dfb5ed7978f5426b260365af0e6df169/src%2Fshims%2Fposix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a98563dfb5ed7978f5426b260365af0e6df169/src%2Fshims%2Fposix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fsync.rs?ref=f3a98563dfb5ed7978f5426b260365af0e6df169", "patch": "@@ -4,6 +4,7 @@ use rustc_target::abi::{Align, Size};\n use std::time::{Instant, SystemTime};\n \n /// Implementation of the SYS_futex syscall.\n+/// `args` is the arguments *after* the syscall number.\n pub fn futex<'tcx>(\n     this: &mut MiriEvalContext<'_, 'tcx>,\n     args: &[OpTy<'tcx, Tag>],\n@@ -17,22 +18,23 @@ pub fn futex<'tcx>(\n     // may or may not be left out from the `syscall()` call.\n     // Therefore we don't use `check_arg_count` here, but only check for the\n     // number of arguments to fall within a range.\n-    if args.len() < 4 {\n+    if args.len() < 3 {\n         throw_ub_format!(\n-            \"incorrect number of arguments for `futex` syscall: got {}, expected at least 4\",\n+            \"incorrect number of arguments for `futex` syscall: got {}, expected at least 3\",\n             args.len()\n         );\n     }\n \n     // The first three arguments (after the syscall number itself) are the same to all futex operations:\n     //     (int *addr, int op, int val).\n     // We checked above that these definitely exist.\n-    let addr = this.read_immediate(&args[1])?;\n-    let op = this.read_scalar(&args[2])?.to_i32()?;\n-    let val = this.read_scalar(&args[3])?.to_i32()?;\n+    let addr = this.read_immediate(&args[0])?;\n+    let op = this.read_scalar(&args[1])?.to_i32()?;\n+    let val = this.read_scalar(&args[2])?.to_i32()?;\n \n     let thread = this.get_active_thread();\n     let addr_scalar = addr.to_scalar()?;\n+    let addr_usize = addr_scalar.to_machine_usize(this)?;\n \n     let futex_private = this.eval_libc_i32(\"FUTEX_PRIVATE_FLAG\")?;\n     let futex_wait = this.eval_libc_i32(\"FUTEX_WAIT\")?;\n@@ -56,17 +58,19 @@ pub fn futex<'tcx>(\n             let wait_bitset = op & !futex_realtime == futex_wait_bitset;\n \n             let bitset = if wait_bitset {\n-                if args.len() != 7 {\n+                if args.len() < 6 {\n                     throw_ub_format!(\n-                        \"incorrect number of arguments for `futex` syscall with `op=FUTEX_WAIT_BITSET`: got {}, expected 7\",\n+                        \"incorrect number of arguments for `futex` syscall with `op=FUTEX_WAIT_BITSET`: got {}, expected at least 6\",\n                         args.len()\n                     );\n                 }\n-                this.read_scalar(&args[6])?.to_u32()?\n+                let _timeout = this.read_pointer(&args[3])?;\n+                let _uaddr2 = this.read_pointer(&args[4])?;\n+                this.read_scalar(&args[5])?.to_u32()?\n             } else {\n-                if args.len() < 5 {\n+                if args.len() < 4 {\n                     throw_ub_format!(\n-                        \"incorrect number of arguments for `futex` syscall with `op=FUTEX_WAIT`: got {}, expected at least 5\",\n+                        \"incorrect number of arguments for `futex` syscall with `op=FUTEX_WAIT`: got {}, expected at least 4\",\n                         args.len()\n                     );\n                 }\n@@ -81,7 +85,7 @@ pub fn futex<'tcx>(\n             }\n \n             // `deref_operand` but not actually dereferencing the ptr yet (it might be NULL!).\n-            let timeout = this.ref_to_mplace(&this.read_immediate(&args[4])?)?;\n+            let timeout = this.ref_to_mplace(&this.read_immediate(&args[3])?)?;\n             let timeout_time = if this.ptr_is_null(timeout.ptr)? {\n                 None\n             } else {\n@@ -145,7 +149,7 @@ pub fn futex<'tcx>(\n             if val == futex_val {\n                 // The value still matches, so we block the trait make it wait for FUTEX_WAKE.\n                 this.block_thread(thread);\n-                this.futex_wait(addr_scalar.to_machine_usize(this)?, thread, bitset);\n+                this.futex_wait(addr_usize, thread, bitset);\n                 // Succesfully waking up from FUTEX_WAIT always returns zero.\n                 this.write_scalar(Scalar::from_machine_isize(0, this), dest)?;\n                 // Register a timeout callback if a timeout was specified.\n@@ -157,7 +161,7 @@ pub fn futex<'tcx>(\n                         timeout_time,\n                         Box::new(move |this| {\n                             this.unblock_thread(thread);\n-                            this.futex_remove_waiter(addr_scalar.to_machine_usize(this)?, thread);\n+                            this.futex_remove_waiter(addr_usize, thread);\n                             let etimedout = this.eval_libc(\"ETIMEDOUT\")?;\n                             this.set_last_error(etimedout)?;\n                             this.write_scalar(Scalar::from_machine_isize(-1, this), &dest)?;\n@@ -181,13 +185,15 @@ pub fn futex<'tcx>(\n         // Same as FUTEX_WAKE, but allows you to specify a bitset to select which threads to wake up.\n         op if op == futex_wake || op == futex_wake_bitset => {\n             let bitset = if op == futex_wake_bitset {\n-                if args.len() != 7 {\n+                if args.len() < 6 {\n                     throw_ub_format!(\n-                        \"incorrect number of arguments for `futex` syscall with `op=FUTEX_WAKE_BITSET`: got {}, expected 7\",\n+                        \"incorrect number of arguments for `futex` syscall with `op=FUTEX_WAKE_BITSET`: got {}, expected at least 6\",\n                         args.len()\n                     );\n                 }\n-                this.read_scalar(&args[6])?.to_u32()?\n+                let _timeout = this.read_pointer(&args[3])?;\n+                let _uaddr2 = this.read_pointer(&args[4])?;\n+                this.read_scalar(&args[5])?.to_u32()?\n             } else {\n                 u32::MAX\n             };\n@@ -199,7 +205,7 @@ pub fn futex<'tcx>(\n             }\n             let mut n = 0;\n             for _ in 0..val {\n-                if let Some(thread) = this.futex_wake(addr_scalar.to_machine_usize(this)?, bitset) {\n+                if let Some(thread) = this.futex_wake(addr_usize, bitset) {\n                     this.unblock_thread(thread);\n                     this.unregister_timeout_callback_if_exists(thread);\n                     n += 1;"}, {"sha": "69875a9ffc44b994f9b841dfb54ab3da01d0ea59", "filename": "src/shims/posix/thread.rs", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f3a98563dfb5ed7978f5426b260365af0e6df169/src%2Fshims%2Fposix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a98563dfb5ed7978f5426b260365af0e6df169/src%2Fshims%2Fposix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fthread.rs?ref=f3a98563dfb5ed7978f5426b260365af0e6df169", "patch": "@@ -97,28 +97,42 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.write_scalar(Scalar::from_uint(thread_id.to_u32(), dest.layout.size), dest)\n     }\n \n-    fn prctl(\n-        &mut self,\n-        option: &OpTy<'tcx, Tag>,\n-        arg2: &OpTy<'tcx, Tag>,\n-        _arg3: &OpTy<'tcx, Tag>,\n-        _arg4: &OpTy<'tcx, Tag>,\n-        _arg5: &OpTy<'tcx, Tag>,\n-    ) -> InterpResult<'tcx, i32> {\n+    fn prctl(&mut self, args: &[OpTy<'tcx, Tag>]) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"linux\", \"prctl\");\n \n-        let option = this.read_scalar(option)?.to_i32()?;\n+        if args.len() < 1 {\n+            throw_ub_format!(\n+                \"incorrect number of arguments for `prctl`: got {}, expected at least 1\",\n+                args.len()\n+            );\n+        }\n+\n+        let option = this.read_scalar(&args[0])?.to_i32()?;\n         if option == this.eval_libc_i32(\"PR_SET_NAME\")? {\n-            let address = this.read_pointer(arg2)?;\n+            if args.len() < 2 {\n+                throw_ub_format!(\n+                    \"incorrect number of arguments for `prctl` with `PR_SET_NAME`: got {}, expected at least 2\",\n+                    args.len()\n+                );\n+            }\n+\n+            let address = this.read_pointer(&args[1])?;\n             let mut name = this.read_c_str(address)?.to_owned();\n             // The name should be no more than 16 bytes, including the null\n             // byte. Since `read_c_str` returns the string without the null\n             // byte, we need to truncate to 15.\n             name.truncate(15);\n             this.set_active_thread_name(name);\n         } else if option == this.eval_libc_i32(\"PR_GET_NAME\")? {\n-            let address = this.read_pointer(arg2)?;\n+            if args.len() < 2 {\n+                throw_ub_format!(\n+                    \"incorrect number of arguments for `prctl` with `PR_SET_NAME`: got {}, expected at least 2\",\n+                    args.len()\n+                );\n+            }\n+\n+            let address = this.read_pointer(&args[1])?;\n             let mut name = this.get_active_thread_name().to_vec();\n             name.push(0u8);\n             assert!(name.len() <= 16);"}, {"sha": "bd2ae6094be18bd42ee79e5dc97654811df36d57", "filename": "tests/compile-fail/fs/unix_open_missing_required_mode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3a98563dfb5ed7978f5426b260365af0e6df169/tests%2Fcompile-fail%2Ffs%2Funix_open_missing_required_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a98563dfb5ed7978f5426b260365af0e6df169/tests%2Fcompile-fail%2Ffs%2Funix_open_missing_required_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffs%2Funix_open_missing_required_mode.rs?ref=f3a98563dfb5ed7978f5426b260365af0e6df169", "patch": "@@ -12,5 +12,5 @@ fn main() {\n fn test_file_open_missing_needed_mode() {\n     let name = b\"missing_arg.txt\\0\";\n     let name_ptr = name.as_ptr().cast::<libc::c_char>();\n-    let _fd = unsafe { libc::open(name_ptr, libc::O_CREAT) }; //~ ERROR Undefined Behavior: incorrect number of arguments for `open` with `O_CREAT`: got 2, expected 3\n+    let _fd = unsafe { libc::open(name_ptr, libc::O_CREAT) }; //~ ERROR Undefined Behavior: incorrect number of arguments for `open` with `O_CREAT`: got 2, expected at least 3\n }"}, {"sha": "9df7415d3133a9fe94e3efbe96d86017ca308bb0", "filename": "tests/compile-fail/fs/unix_open_too_many_args.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8acc9b2799f5587f5f29dfce487ec3aa94964dfe/tests%2Fcompile-fail%2Ffs%2Funix_open_too_many_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8acc9b2799f5587f5f29dfce487ec3aa94964dfe/tests%2Fcompile-fail%2Ffs%2Funix_open_too_many_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffs%2Funix_open_too_many_args.rs?ref=8acc9b2799f5587f5f29dfce487ec3aa94964dfe", "patch": "@@ -1,16 +0,0 @@\n-// ignore-windows: No libc on Windows\n-// compile-flags: -Zmiri-disable-isolation\n-\n-#![feature(rustc_private)]\n-\n-extern crate libc;\n-\n-fn main() {\n-    test_open_too_many_args();\n-}\n-\n-fn test_open_too_many_args() {\n-    let name = b\"too_many_args.txt\\0\";\n-    let name_ptr = name.as_ptr().cast::<libc::c_char>();\n-    let _fd = unsafe { libc::open(name_ptr, libc::O_RDONLY, 0, 0) }; //~ ERROR Undefined Behavior: incorrect number of arguments for `open`: got 4, expected 2 or 3\n-}"}, {"sha": "4ac928398e238e340dfa1419386d0580f3f7c37b", "filename": "tests/run-pass/concurrency/linux-futex.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f3a98563dfb5ed7978f5426b260365af0e6df169/tests%2Frun-pass%2Fconcurrency%2Flinux-futex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a98563dfb5ed7978f5426b260365af0e6df169/tests%2Frun-pass%2Fconcurrency%2Flinux-futex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Flinux-futex.rs?ref=f3a98563dfb5ed7978f5426b260365af0e6df169", "patch": "@@ -32,8 +32,8 @@ fn wake_nobody() {\n             &futex as *const i32,\n             libc::FUTEX_WAKE,\n             1,\n-            0,\n-            0,\n+            ptr::null::<libc::timespec>(),\n+            0usize,\n             0,\n         ), 0);\n     }\n@@ -121,7 +121,7 @@ fn wait_absolute_timeout() {\n             libc::FUTEX_WAIT_BITSET,\n             123,\n             &timeout,\n-            0,\n+            0usize,\n             u32::MAX,\n         ), -1);\n         assert_eq!(*libc::__errno_location(), libc::ETIMEDOUT);\n@@ -173,8 +173,8 @@ fn wait_wake_bitset() {\n                 &FUTEX as *const i32,\n                 libc::FUTEX_WAKE_BITSET,\n                 10, // Wake up at most 10 threads.\n-                0,\n-                0,\n+                ptr::null::<libc::timespec>(),\n+                0usize,\n                 0b1001, // bitset\n             ), 0); // Didn't match any thread.\n         }\n@@ -185,8 +185,8 @@ fn wait_wake_bitset() {\n                 &FUTEX as *const i32,\n                 libc::FUTEX_WAKE_BITSET,\n                 10, // Wake up at most 10 threads.\n-                0,\n-                0,\n+                ptr::null::<libc::timespec>(),\n+                0usize,\n                 0b0110, // bitset\n             ), 1); // Woken up one thread.\n         }\n@@ -199,7 +199,7 @@ fn wait_wake_bitset() {\n             libc::FUTEX_WAIT_BITSET,\n             0,\n             ptr::null::<libc::timespec>(),\n-            0,\n+            0usize,\n             0b0100, // bitset\n         ), 0);\n     }"}]}