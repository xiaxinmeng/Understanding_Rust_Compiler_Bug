{"sha": "6aa875aa9629b985638984b32a8adfb46da9ee66", "node_id": "C_kwDOAAsO6NoAKDZhYTg3NWFhOTYyOWI5ODU2Mzg5ODRiMzJhOGFkZmI0NmRhOWVlNjY", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-04-12T21:16:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-12T21:16:58Z"}, "message": "Rollup merge of #95914 - c410-f3r:meta-vars, r=petrochenkov\n\nImplement tuples using recursion\n\nBecause it is c00l3r\u2122, requires less repetition and can be used as a reference for external people.\n\nThis change is non-essential and I am not sure about potential performance impacts so feel free to close this PR if desired.\n\nr? `@petrochenkov`", "tree": {"sha": "48f8fd3776314f81322c6aea023fd07851e23b36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48f8fd3776314f81322c6aea023fd07851e23b36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6aa875aa9629b985638984b32a8adfb46da9ee66", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiVexKCRBK7hj4Ov3rIwAAqTUIAKK+6vMbZnwPJtSfP07jcNCT\nbQ6VRxv58IJjU87DQhtmcjVg9sxP3RtOFkjBMcuiMwYcAjG533iovnBzNMN+qt8F\n4PQPfEIXn2/4cQvxt/foJG+R7r5roS+WNPzeIeX8/S0ffHoGT2s238La2Wbh+fi4\nQfPXI4cb6JtIbxtN8NPufD9S3om0XxPqupXnZEiYs+1bEMOASkbLB/yWaO3hhS8Z\n3QUZUaygLOLoy4vpsEiSl4ZQx1IxkE8XqqB6KGSMdZjgTMQ5RLGXMFgOS+dFYDL8\ni8HwcXOOPwcqHv8THpJdM5kU5yPNLQb+UPQtAlK88FxWszICY+xydy+txXoAqGo=\n=BZ8M\n-----END PGP SIGNATURE-----\n", "payload": "tree 48f8fd3776314f81322c6aea023fd07851e23b36\nparent 2743c13de071a637c28fc22fba34947aa29bcc17\nparent 23bf9777589f07ac4a30f7eccd818eecd8fa5b7d\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1649798218 +0200\ncommitter GitHub <noreply@github.com> 1649798218 +0200\n\nRollup merge of #95914 - c410-f3r:meta-vars, r=petrochenkov\n\nImplement tuples using recursion\n\nBecause it is c00l3r\u2122, requires less repetition and can be used as a reference for external people.\n\nThis change is non-essential and I am not sure about potential performance impacts so feel free to close this PR if desired.\n\nr? `@petrochenkov`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6aa875aa9629b985638984b32a8adfb46da9ee66", "html_url": "https://github.com/rust-lang/rust/commit/6aa875aa9629b985638984b32a8adfb46da9ee66", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6aa875aa9629b985638984b32a8adfb46da9ee66/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2743c13de071a637c28fc22fba34947aa29bcc17", "url": "https://api.github.com/repos/rust-lang/rust/commits/2743c13de071a637c28fc22fba34947aa29bcc17", "html_url": "https://github.com/rust-lang/rust/commit/2743c13de071a637c28fc22fba34947aa29bcc17"}, {"sha": "23bf9777589f07ac4a30f7eccd818eecd8fa5b7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/23bf9777589f07ac4a30f7eccd818eecd8fa5b7d", "html_url": "https://github.com/rust-lang/rust/commit/23bf9777589f07ac4a30f7eccd818eecd8fa5b7d"}], "stats": {"total": 141, "additions": 74, "deletions": 67}, "files": [{"sha": "181717f35bd25dd3de4f763b032a624f349b5108", "filename": "library/core/src/tuple.rs", "status": "modified", "additions": 74, "deletions": 67, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/6aa875aa9629b985638984b32a8adfb46da9ee66/library%2Fcore%2Fsrc%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa875aa9629b985638984b32a8adfb46da9ee66/library%2Fcore%2Fsrc%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftuple.rs?ref=6aa875aa9629b985638984b32a8adfb46da9ee66", "patch": "@@ -3,68 +3,88 @@\n use crate::cmp::Ordering::*;\n use crate::cmp::*;\n \n-// macro for implementing n-ary tuple functions and operations\n+// Recursive macro for implementing n-ary tuple functions and operations\n+//\n+// Also provides implementations for tuples with lesser arity. For example, tuple_impls!(A B C)\n+// will implement everything for (A, B, C), (A, B) and (A,).\n macro_rules! tuple_impls {\n-    ( $( ( $( $T:ident )+ ) )+ ) => {\n-        $(\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<$($T:PartialEq),+> PartialEq for ($($T,)+) where last_type!($($T,)+): ?Sized {\n-                #[inline]\n-                fn eq(&self, other: &($($T,)+)) -> bool {\n-                    $( ${ignore(T)} self.${index()} == other.${index()} )&&+\n-                }\n-                #[inline]\n-                fn ne(&self, other: &($($T,)+)) -> bool {\n-                    $( ${ignore(T)} self.${index()} != other.${index()} )||+\n-                }\n+    // Stopping criteria (1-ary tuple)\n+    ($T:ident) => {\n+        tuple_impls!(@impl $T);\n+    };\n+    // Running criteria (n-ary tuple, with n >= 2)\n+    ($T:ident $( $U:ident )+) => {\n+        tuple_impls!($( $U )+);\n+        tuple_impls!(@impl $T $( $U )+);\n+    };\n+    // \"Private\" internal implementation\n+    (@impl $( $T:ident )+) => {\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl<$($T:PartialEq),+> PartialEq for ($($T,)+)\n+        where\n+            last_type!($($T,)+): ?Sized\n+        {\n+            #[inline]\n+            fn eq(&self, other: &($($T,)+)) -> bool {\n+                $( ${ignore(T)} self.${index()} == other.${index()} )&&+\n+            }\n+            #[inline]\n+            fn ne(&self, other: &($($T,)+)) -> bool {\n+                $( ${ignore(T)} self.${index()} != other.${index()} )||+\n             }\n+        }\n \n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<$($T:Eq),+> Eq for ($($T,)+) where last_type!($($T,)+): ?Sized {}\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl<$($T:Eq),+> Eq for ($($T,)+)\n+        where\n+            last_type!($($T,)+): ?Sized\n+        {}\n \n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<$($T:PartialOrd + PartialEq),+> PartialOrd for ($($T,)+)\n-            where\n-                last_type!($($T,)+): ?Sized\n-            {\n-                #[inline]\n-                fn partial_cmp(&self, other: &($($T,)+)) -> Option<Ordering> {\n-                    lexical_partial_cmp!($( ${ignore(T)} self.${index()}, other.${index()} ),+)\n-                }\n-                #[inline]\n-                fn lt(&self, other: &($($T,)+)) -> bool {\n-                    lexical_ord!(lt, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n-                }\n-                #[inline]\n-                fn le(&self, other: &($($T,)+)) -> bool {\n-                    lexical_ord!(le, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n-                }\n-                #[inline]\n-                fn ge(&self, other: &($($T,)+)) -> bool {\n-                    lexical_ord!(ge, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n-                }\n-                #[inline]\n-                fn gt(&self, other: &($($T,)+)) -> bool {\n-                    lexical_ord!(gt, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n-                }\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl<$($T:PartialOrd + PartialEq),+> PartialOrd for ($($T,)+)\n+        where\n+            last_type!($($T,)+): ?Sized\n+        {\n+            #[inline]\n+            fn partial_cmp(&self, other: &($($T,)+)) -> Option<Ordering> {\n+                lexical_partial_cmp!($( ${ignore(T)} self.${index()}, other.${index()} ),+)\n+            }\n+            #[inline]\n+            fn lt(&self, other: &($($T,)+)) -> bool {\n+                lexical_ord!(lt, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n+            }\n+            #[inline]\n+            fn le(&self, other: &($($T,)+)) -> bool {\n+                lexical_ord!(le, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n             }\n+            #[inline]\n+            fn ge(&self, other: &($($T,)+)) -> bool {\n+                lexical_ord!(ge, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n+            }\n+            #[inline]\n+            fn gt(&self, other: &($($T,)+)) -> bool {\n+                lexical_ord!(gt, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n+            }\n+        }\n \n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<$($T:Ord),+> Ord for ($($T,)+) where last_type!($($T,)+): ?Sized {\n-                #[inline]\n-                fn cmp(&self, other: &($($T,)+)) -> Ordering {\n-                    lexical_cmp!($( ${ignore(T)} self.${index()}, other.${index()} ),+)\n-                }\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl<$($T:Ord),+> Ord for ($($T,)+)\n+        where\n+            last_type!($($T,)+): ?Sized\n+        {\n+            #[inline]\n+            fn cmp(&self, other: &($($T,)+)) -> Ordering {\n+                lexical_cmp!($( ${ignore(T)} self.${index()}, other.${index()} ),+)\n             }\n+        }\n \n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<$($T:Default),+> Default for ($($T,)+) {\n-                #[inline]\n-                fn default() -> ($($T,)+) {\n-                    ($({ let x: $T = Default::default(); x},)+)\n-                }\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl<$($T:Default),+> Default for ($($T,)+) {\n+            #[inline]\n+            fn default() -> ($($T,)+) {\n+                ($({ let x: $T = Default::default(); x},)+)\n             }\n-        )+\n+        }\n     }\n }\n \n@@ -105,17 +125,4 @@ macro_rules! last_type {\n     ($a:ident, $($rest_a:ident,)+) => { last_type!($($rest_a,)+) };\n }\n \n-tuple_impls! {\n-    (A)\n-    (A B)\n-    (A B C)\n-    (A B C D)\n-    (A B C D E)\n-    (A B C D E F)\n-    (A B C D E F G)\n-    (A B C D E F G H)\n-    (A B C D E F G H I)\n-    (A B C D E F G H I J)\n-    (A B C D E F G H I J K)\n-    (A B C D E F G H I J K L)\n-}\n+tuple_impls!(A B C D E F G H I J K L);"}]}