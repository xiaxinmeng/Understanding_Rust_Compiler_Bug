{"sha": "538ec1122baeccd85ab672fd0a9f1186d2171058", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzOGVjMTEyMmJhZWNjZDg1YWI2NzJmZDBhOWYxMTg2ZDIxNzEwNTg=", "commit": {"author": {"name": "Alexander Andreev", "email": "andreevlex.as@gmail.com", "date": "2019-07-29T06:54:40Z"}, "committer": {"name": "Alexander Andreev", "email": "andreevlex.as@gmail.com", "date": "2019-07-29T06:54:40Z"}, "message": "Added resolve modules inside inline module\n\n#1510", "tree": {"sha": "bd678af17b28232a43ac8c563d019d8a736641b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd678af17b28232a43ac8c563d019d8a736641b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/538ec1122baeccd85ab672fd0a9f1186d2171058", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/538ec1122baeccd85ab672fd0a9f1186d2171058", "html_url": "https://github.com/rust-lang/rust/commit/538ec1122baeccd85ab672fd0a9f1186d2171058", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/538ec1122baeccd85ab672fd0a9f1186d2171058/comments", "author": {"login": "ava57r", "id": 20382553, "node_id": "MDQ6VXNlcjIwMzgyNTUz", "avatar_url": "https://avatars.githubusercontent.com/u/20382553?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ava57r", "html_url": "https://github.com/ava57r", "followers_url": "https://api.github.com/users/ava57r/followers", "following_url": "https://api.github.com/users/ava57r/following{/other_user}", "gists_url": "https://api.github.com/users/ava57r/gists{/gist_id}", "starred_url": "https://api.github.com/users/ava57r/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ava57r/subscriptions", "organizations_url": "https://api.github.com/users/ava57r/orgs", "repos_url": "https://api.github.com/users/ava57r/repos", "events_url": "https://api.github.com/users/ava57r/events{/privacy}", "received_events_url": "https://api.github.com/users/ava57r/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ava57r", "id": 20382553, "node_id": "MDQ6VXNlcjIwMzgyNTUz", "avatar_url": "https://avatars.githubusercontent.com/u/20382553?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ava57r", "html_url": "https://github.com/ava57r", "followers_url": "https://api.github.com/users/ava57r/followers", "following_url": "https://api.github.com/users/ava57r/following{/other_user}", "gists_url": "https://api.github.com/users/ava57r/gists{/gist_id}", "starred_url": "https://api.github.com/users/ava57r/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ava57r/subscriptions", "organizations_url": "https://api.github.com/users/ava57r/orgs", "repos_url": "https://api.github.com/users/ava57r/repos", "events_url": "https://api.github.com/users/ava57r/events{/privacy}", "received_events_url": "https://api.github.com/users/ava57r/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de278d164906d6d29974790c5a4db28303692484", "url": "https://api.github.com/repos/rust-lang/rust/commits/de278d164906d6d29974790c5a4db28303692484", "html_url": "https://github.com/rust-lang/rust/commit/de278d164906d6d29974790c5a4db28303692484"}], "stats": {"total": 201, "additions": 147, "deletions": 54}, "files": [{"sha": "80b71e2d96a4f4df688865d475008e3d59ba7ce4", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 109, "deletions": 39, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/538ec1122baeccd85ab672fd0a9f1186d2171058/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/538ec1122baeccd85ab672fd0a9f1186d2171058/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=538ec1122baeccd85ab672fd0a9f1186d2171058", "patch": "@@ -1,7 +1,7 @@\n use std::borrow::Cow;\n+use std::sync::Arc;\n \n-use arrayvec::ArrayVec;\n-use ra_db::FileId;\n+use ra_db::{FileId, SourceRoot};\n use ra_syntax::{ast, SmolStr};\n use relative_path::RelativePathBuf;\n use rustc_hash::FxHashMap;\n@@ -106,7 +106,7 @@ where\n             file_id: file_id.into(),\n             raw_items: &raw_items,\n         }\n-        .collect(raw_items.items());\n+        .collect(None, raw_items.items());\n \n         // main name resolution fixed-point loop.\n         let mut i = 0;\n@@ -456,7 +456,7 @@ where\n             let file_id: HirFileId = macro_call_id.as_file(MacroFileKind::Items);\n             let raw_items = self.db.raw_items(file_id);\n             ModCollector { def_collector: &mut *self, file_id, module_id, raw_items: &raw_items }\n-                .collect(raw_items.items());\n+                .collect(None, raw_items.items());\n         } else {\n             log::error!(\"Too deep macro expansion: {:?}\", macro_call_id);\n             self.def_map.poison_macros.insert(macro_def_id);\n@@ -482,10 +482,10 @@ impl<DB> ModCollector<'_, &'_ mut DefCollector<&'_ DB>>\n where\n     DB: DefDatabase,\n {\n-    fn collect(&mut self, items: &[raw::RawItem]) {\n+    fn collect(&mut self, parent_module: Option<&Name>, items: &[raw::RawItem]) {\n         for item in items {\n             match *item {\n-                raw::RawItem::Module(m) => self.collect_module(&self.raw_items[m]),\n+                raw::RawItem::Module(m) => self.collect_module(parent_module, &self.raw_items[m]),\n                 raw::RawItem::Import(import) => self.def_collector.unresolved_imports.push((\n                     self.module_id,\n                     import,\n@@ -497,7 +497,7 @@ where\n         }\n     }\n \n-    fn collect_module(&mut self, module: &raw::ModuleData) {\n+    fn collect_module(&mut self, _module: Option<&Name>, module: &raw::ModuleData) {\n         match module {\n             // inline module, just recurse\n             raw::ModuleData::Definition { name, items, ast_id } => {\n@@ -509,7 +509,7 @@ where\n                     file_id: self.file_id,\n                     raw_items: self.raw_items,\n                 }\n-                .collect(&*items);\n+                .collect(Some(name), &*items);\n             }\n             // out of line module, resolve, parse and recurse\n             raw::ModuleData::Declaration { name, ast_id, attr_path } => {\n@@ -521,6 +521,7 @@ where\n                     name,\n                     is_root,\n                     attr_path.as_ref(),\n+                    _module,\n                 ) {\n                     Ok(file_id) => {\n                         let module_id = self.push_child_module(name.clone(), ast_id, Some(file_id));\n@@ -531,7 +532,7 @@ where\n                             file_id: file_id.into(),\n                             raw_items: &raw_items,\n                         }\n-                        .collect(raw_items.items())\n+                        .collect(None, raw_items.items())\n                     }\n                     Err(candidate) => self.def_collector.def_map.diagnostics.push(\n                         DefDiagnostic::UnresolvedModule {\n@@ -636,46 +637,47 @@ fn resolve_submodule(\n     name: &Name,\n     is_root: bool,\n     attr_path: Option<&SmolStr>,\n+    parent_module: Option<&Name>,\n ) -> Result<FileId, RelativePathBuf> {\n-    // FIXME: handle submodules of inline modules properly\n     let file_id = file_id.original_file(db);\n     let source_root_id = db.file_source_root(file_id);\n     let path = db.file_relative_path(file_id);\n     let root = RelativePathBuf::default();\n     let dir_path = path.parent().unwrap_or(&root);\n     let mod_name = path.file_stem().unwrap_or(\"unknown\");\n-    let is_dir_owner = is_root || mod_name == \"mod\";\n-\n-    let file_mod = dir_path.join(format!(\"{}.rs\", name));\n-    let dir_mod = dir_path.join(format!(\"{}/mod.rs\", name));\n-    let file_dir_mod = dir_path.join(format!(\"{}/{}.rs\", mod_name, name));\n-    let mut candidates = ArrayVec::<[_; 3]>::new();\n-    let file_attr_mod = attr_path.map(|file_path| {\n-        let file_path = normalize_attribute_path(file_path);\n-        let file_attr_mod = dir_path.join(file_path.as_ref()).normalize();\n-        candidates.push(file_attr_mod.clone());\n-\n-        file_attr_mod\n-    });\n-    if is_dir_owner {\n-        candidates.push(file_mod.clone());\n-        candidates.push(dir_mod);\n-    } else {\n-        candidates.push(file_dir_mod.clone());\n-    };\n-    let sr = db.source_root(source_root_id);\n-    let mut points_to = candidates.into_iter().filter_map(|path| sr.files.get(&path)).copied();\n-    // FIXME: handle ambiguity\n-    match points_to.next() {\n-        Some(file_id) => Ok(file_id),\n-        None => {\n-            if let Some(file_attr_mod) = file_attr_mod {\n-                Err(file_attr_mod)\n+\n+    let resolve_mode = match (attr_path.filter(|p| !p.is_empty()), parent_module) {\n+        (Some(file_path), Some(parent_name)) => {\n+            let file_path = normalize_attribute_path(file_path);\n+            let path = dir_path.join(format!(\"{}/{}\", parent_name, file_path)).normalize();\n+            ResolutionMode::InsideInlineModule(InsideInlineModuleMode::WithAttributePath(path))\n+        }\n+        (Some(file_path), None) => {\n+            let file_path = normalize_attribute_path(file_path);\n+            let path = dir_path.join(file_path.as_ref()).normalize();\n+            ResolutionMode::OutOfLine(OutOfLineMode::WithAttributePath(path))\n+        }\n+        (None, Some(parent_name)) => {\n+            let path = dir_path.join(format!(\"{}/{}.rs\", parent_name, name));\n+            ResolutionMode::InsideInlineModule(InsideInlineModuleMode::File(path))\n+        }\n+        _ => {\n+            let is_dir_owner = is_root || mod_name == \"mod\";\n+            if is_dir_owner {\n+                let file_mod = dir_path.join(format!(\"{}.rs\", name));\n+                let dir_mod = dir_path.join(format!(\"{}/mod.rs\", name));\n+                ResolutionMode::OutOfLine(OutOfLineMode::RootOrModRs {\n+                    file: file_mod,\n+                    directory: dir_mod,\n+                })\n             } else {\n-                Err(if is_dir_owner { file_mod } else { file_dir_mod })\n+                let path = dir_path.join(format!(\"{}/{}.rs\", mod_name, name));\n+                ResolutionMode::OutOfLine(OutOfLineMode::FileInDirectory(path))\n             }\n         }\n-    }\n+    };\n+\n+    resolve_mode.resolve(db.source_root(source_root_id))\n }\n \n fn normalize_attribute_path(file_path: &SmolStr) -> Cow<str> {\n@@ -693,6 +695,74 @@ fn normalize_attribute_path(file_path: &SmolStr) -> Cow<str> {\n     }\n }\n \n+enum OutOfLineMode {\n+    RootOrModRs { file: RelativePathBuf, directory: RelativePathBuf },\n+    FileInDirectory(RelativePathBuf),\n+    WithAttributePath(RelativePathBuf),\n+}\n+\n+impl OutOfLineMode {\n+    pub fn resolve(&self, source_root: Arc<SourceRoot>) -> Result<FileId, RelativePathBuf> {\n+        match self {\n+            OutOfLineMode::RootOrModRs { file, directory } => match source_root.files.get(file) {\n+                None => resolve_simple_path(source_root, directory).map_err(|_| file.clone()),\n+                file_id => resolve_find_result(file_id, file),\n+            },\n+            OutOfLineMode::FileInDirectory(path) => resolve_simple_path(source_root, path),\n+            OutOfLineMode::WithAttributePath(path) => resolve_simple_path(source_root, path),\n+        }\n+    }\n+}\n+\n+enum InsideInlineModuleMode {\n+    File(RelativePathBuf),\n+    WithAttributePath(RelativePathBuf),\n+}\n+\n+impl InsideInlineModuleMode {\n+    pub fn resolve(&self, source_root: Arc<SourceRoot>) -> Result<FileId, RelativePathBuf> {\n+        match self {\n+            InsideInlineModuleMode::File(path) => resolve_simple_path(source_root, path),\n+            InsideInlineModuleMode::WithAttributePath(path) => {\n+                resolve_simple_path(source_root, path)\n+            }\n+        }\n+    }\n+}\n+\n+enum ResolutionMode {\n+    OutOfLine(OutOfLineMode),\n+    InsideInlineModule(InsideInlineModuleMode),\n+}\n+\n+impl ResolutionMode {\n+    pub fn resolve(&self, source_root: Arc<SourceRoot>) -> Result<FileId, RelativePathBuf> {\n+        use self::ResolutionMode::*;\n+\n+        match self {\n+            OutOfLine(mode) => mode.resolve(source_root),\n+            InsideInlineModule(mode) => mode.resolve(source_root),\n+        }\n+    }\n+}\n+\n+fn resolve_simple_path(\n+    source_root: Arc<SourceRoot>,\n+    path: &RelativePathBuf,\n+) -> Result<FileId, RelativePathBuf> {\n+    resolve_find_result(source_root.files.get(path), path)\n+}\n+\n+fn resolve_find_result(\n+    file_id: Option<&FileId>,\n+    path: &RelativePathBuf,\n+) -> Result<FileId, RelativePathBuf> {\n+    match file_id {\n+        Some(file_id) => Ok(file_id.clone()),\n+        None => Err(path.clone()),\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use ra_db::SourceDatabase;"}, {"sha": "38272814992c0bf3e6173dc301d362d0d5f0d583", "filename": "crates/ra_hir/src/nameres/tests/mods.rs", "status": "modified", "additions": 38, "deletions": 15, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/538ec1122baeccd85ab672fd0a9f1186d2171058/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/538ec1122baeccd85ab672fd0a9f1186d2171058/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmods.rs?ref=538ec1122baeccd85ab672fd0a9f1186d2171058", "patch": "@@ -336,10 +336,10 @@ fn module_resolution_explicit_path_mod_rs_with_win_separator() {\n     \"###);\n }\n \n-// FIXME: issue #1510. not support out-of-line modules inside inline.\n+// FIXME: issue #1529. not support out-of-line modules inside inline.\n #[test]\n #[ignore]\n-fn module_resolution_decl_inside_inline_module() {\n+fn module_resolution_decl_inside_inline_module_with_path_attribute() {\n     let map = def_map_with_crate_graph(\n         r###\"\n         //- /main.rs\n@@ -368,10 +368,39 @@ fn module_resolution_decl_inside_inline_module() {\n     \"###);\n }\n \n-// FIXME: issue #1510. not support out-of-line modules inside inline.\n+#[test]\n+fn module_resolution_decl_inside_inline_module() {\n+    let map = def_map_with_crate_graph(\n+        r###\"\n+        //- /main.rs\n+        mod foo {\n+            mod bar;\n+        }\n+\n+        //- /foo/bar.rs\n+        pub struct Baz;\n+        \"###,\n+        crate_graph! {\n+            \"main\": (\"/main.rs\", []),\n+        },\n+    );\n+\n+    assert_snapshot_matches!(map, @r###\"\n+        \u22eecrate\n+        \u22eefoo: t\n+        \u22ee\n+        \u22eecrate::foo\n+        \u22eebar: t\n+        \u22ee\n+        \u22eecrate::foo::bar\n+        \u22eeBaz: t v\n+    \"###);\n+}\n+\n+// FIXME: issue #1529. not support out-of-line modules inside inline.\n #[test]\n #[ignore]\n-fn module_resolution_decl_inside_inline_module_2() {\n+fn module_resolution_decl_inside_inline_module_2_with_path_attribute() {\n     let map = def_map_with_crate_graph(\n         r###\"\n         //- /main.rs\n@@ -400,7 +429,7 @@ fn module_resolution_decl_inside_inline_module_2() {\n     \"###);\n }\n \n-// FIXME: issue #1510. not support out-of-line modules inside inline.\n+// FIXME: issue #1529. not support out-of-line modules inside inline.\n #[test]\n #[ignore]\n fn module_resolution_decl_inside_inline_module_3() {\n@@ -433,7 +462,7 @@ fn module_resolution_decl_inside_inline_module_3() {\n     \"###);\n }\n \n-// FIXME: issue #1510. not support out-of-line modules inside inline.\n+// FIXME: issue #1529. not support out-of-line modules inside inline.\n #[test]\n #[ignore]\n fn module_resolution_decl_inside_inline_module_empty_path() {\n@@ -491,7 +520,7 @@ fn module_resolution_decl_empty_path() {\n     \"###);\n }\n \n-// FIXME: issue #1510. not support out-of-line modules inside inline.\n+// FIXME: issue #1529. not support out-of-line modules inside inline.\n #[test]\n #[ignore]\n fn module_resolution_decl_inside_inline_module_relative_path() {\n@@ -523,9 +552,7 @@ fn module_resolution_decl_inside_inline_module_relative_path() {\n     \"###);\n }\n \n-// FIXME: issue #1510. not support out-of-line modules inside inline.\n #[test]\n-#[ignore]\n fn module_resolution_decl_inside_inline_module_in_crate_root() {\n     let map = def_map_with_crate_graph(\n         r###\"\n@@ -557,9 +584,7 @@ fn module_resolution_decl_inside_inline_module_in_crate_root() {\n     \"###);\n }\n \n-// FIXME: issue #1510. not support out-of-line modules inside inline.\n #[test]\n-#[ignore]\n fn module_resolution_decl_inside_inline_module_in_mod_rs() {\n     let map = def_map_with_crate_graph(\n         r###\"\n@@ -597,9 +622,7 @@ fn module_resolution_decl_inside_inline_module_in_mod_rs() {\n     \"###);\n }\n \n-// FIXME: issue #1510. not support out-of-line modules inside inline.\n #[test]\n-#[ignore]\n fn module_resolution_decl_inside_inline_module_in_non_crate_root() {\n     let map = def_map_with_crate_graph(\n         r###\"\n@@ -613,7 +636,7 @@ fn module_resolution_decl_inside_inline_module_in_non_crate_root() {\n         }\n         use self::bar::baz::Baz;\n \n-        //- /foo/bar/qwe.rs\n+        //- /bar/qwe.rs\n         pub struct Baz;\n         \"###,\n         crate_graph! {\n@@ -637,7 +660,7 @@ fn module_resolution_decl_inside_inline_module_in_non_crate_root() {\n     \"###);\n }\n \n-// FIXME: issue #1510. not support out-of-line modules inside inline.\n+// FIXME: issue #1529. not support out-of-line modules inside inline.\n #[test]\n #[ignore]\n fn module_resolution_decl_inside_inline_module_in_non_crate_root_2() {"}]}