{"sha": "8128d0d1a95f5d77b672558c202cbf37d595fba3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxMjhkMGQxYTk1ZjVkNzdiNjcyNTU4YzIwMmNiZjM3ZDU5NWZiYTM=", "commit": {"author": {"name": "Nikita Popov", "email": "nikita.ppv@gmail.com", "date": "2018-12-04T15:24:20Z"}, "committer": {"name": "Nikita Popov", "email": "nikita.ppv@gmail.com", "date": "2018-12-04T15:24:20Z"}, "message": "Serialize modules into ThinBuffer after initial optimization\n\nInstead of keeping all modules in memory until thin LTO and only\nserializing them then, serialize the module immediately after\nit finishes optimizing.", "tree": {"sha": "2a63a69c33a1211b7059d3c4025c38484596dad6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a63a69c33a1211b7059d3c4025c38484596dad6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8128d0d1a95f5d77b672558c202cbf37d595fba3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8128d0d1a95f5d77b672558c202cbf37d595fba3", "html_url": "https://github.com/rust-lang/rust/commit/8128d0d1a95f5d77b672558c202cbf37d595fba3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8128d0d1a95f5d77b672558c202cbf37d595fba3/comments", "author": {"login": "nikic", "id": 216080, "node_id": "MDQ6VXNlcjIxNjA4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/216080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikic", "html_url": "https://github.com/nikic", "followers_url": "https://api.github.com/users/nikic/followers", "following_url": "https://api.github.com/users/nikic/following{/other_user}", "gists_url": "https://api.github.com/users/nikic/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikic/subscriptions", "organizations_url": "https://api.github.com/users/nikic/orgs", "repos_url": "https://api.github.com/users/nikic/repos", "events_url": "https://api.github.com/users/nikic/events{/privacy}", "received_events_url": "https://api.github.com/users/nikic/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikic", "id": 216080, "node_id": "MDQ6VXNlcjIxNjA4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/216080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikic", "html_url": "https://github.com/nikic", "followers_url": "https://api.github.com/users/nikic/followers", "following_url": "https://api.github.com/users/nikic/following{/other_user}", "gists_url": "https://api.github.com/users/nikic/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikic/subscriptions", "organizations_url": "https://api.github.com/users/nikic/orgs", "repos_url": "https://api.github.com/users/nikic/repos", "events_url": "https://api.github.com/users/nikic/events{/privacy}", "received_events_url": "https://api.github.com/users/nikic/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc2db43b9e85c3aeaec021b7d70701233930711f", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc2db43b9e85c3aeaec021b7d70701233930711f", "html_url": "https://github.com/rust-lang/rust/commit/bc2db43b9e85c3aeaec021b7d70701233930711f"}], "stats": {"total": 113, "additions": 64, "deletions": 49}, "files": [{"sha": "bddb45da10b004c914169a4f550877552e93b09b", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/8128d0d1a95f5d77b672558c202cbf37d595fba3/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8128d0d1a95f5d77b672558c202cbf37d595fba3/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=8128d0d1a95f5d77b672558c202cbf37d595fba3", "patch": "@@ -159,7 +159,7 @@ pub(crate) fn run_fat(cgcx: &CodegenContext<LlvmCodegenBackend>,\n /// lists, one of the modules that need optimization and another for modules that\n /// can simply be copied over from the incr. comp. cache.\n pub(crate) fn run_thin(cgcx: &CodegenContext<LlvmCodegenBackend>,\n-                       modules: Vec<ModuleCodegen<ModuleLlvm>>,\n+                       modules: Vec<(String, ThinBuffer)>,\n                        cached_modules: Vec<(SerializedModule<ModuleBuffer>, WorkProduct)>,\n                        timeline: &mut Timeline)\n     -> Result<(Vec<LtoModuleCodegen<LlvmCodegenBackend>>, Vec<WorkProduct>), FatalError>\n@@ -182,6 +182,31 @@ pub(crate) fn run_thin(cgcx: &CodegenContext<LlvmCodegenBackend>,\n              timeline)\n }\n \n+pub(crate) fn prepare_thin(\n+    cgcx: &CodegenContext<LlvmCodegenBackend>,\n+    module: ModuleCodegen<ModuleLlvm>\n+) -> (String, ThinBuffer) {\n+    let name = module.name.clone();\n+    let buffer = ThinBuffer::new(module.module_llvm.llmod());\n+\n+    // We emit the module after having serialized it into a ThinBuffer\n+    // because only then it will contain the ThinLTO module summary.\n+    if let Some(ref incr_comp_session_dir) = cgcx.incr_comp_session_dir {\n+        if cgcx.config(module.kind).emit_pre_thin_lto_bc {\n+            let path = incr_comp_session_dir\n+                .join(pre_lto_bitcode_filename(&name));\n+\n+            fs::write(&path, buffer.data()).unwrap_or_else(|e| {\n+                panic!(\"Error writing pre-lto-bitcode file `{}`: {}\",\n+                       path.display(),\n+                       e);\n+            });\n+        }\n+    }\n+\n+    (name, buffer)\n+}\n+\n fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n            diag_handler: &Handler,\n            mut modules: Vec<ModuleCodegen<ModuleLlvm>>,\n@@ -341,7 +366,7 @@ impl Drop for Linker<'a> {\n /// they all go out of scope.\n fn thin_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n             diag_handler: &Handler,\n-            modules: Vec<ModuleCodegen<ModuleLlvm>>,\n+            modules: Vec<(String, ThinBuffer)>,\n             serialized_modules: Vec<(SerializedModule<ModuleBuffer>, CString)>,\n             cached_modules: Vec<(SerializedModule<ModuleBuffer>, WorkProduct)>,\n             symbol_white_list: &[*const libc::c_char],\n@@ -361,41 +386,17 @@ fn thin_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         let mut module_names = Vec::with_capacity(full_scope_len);\n         let mut thin_modules = Vec::with_capacity(full_scope_len);\n \n-        // FIXME: right now, like with fat LTO, we serialize all in-memory\n-        //        modules before working with them and ThinLTO. We really\n-        //        shouldn't do this, however, and instead figure out how to\n-        //        extract a summary from an in-memory module and then merge that\n-        //        into the global index. It turns out that this loop is by far\n-        //        the most expensive portion of this small bit of global\n-        //        analysis!\n-        for (i, module) in modules.into_iter().enumerate() {\n-            info!(\"local module: {} - {}\", i, module.name);\n-            let name = CString::new(module.name.clone()).unwrap();\n-            let buffer = ThinBuffer::new(module.module_llvm.llmod());\n-\n-            // We emit the module after having serialized it into a ThinBuffer\n-            // because only then it will contain the ThinLTO module summary.\n-            if let Some(ref incr_comp_session_dir) = cgcx.incr_comp_session_dir {\n-                if cgcx.config(module.kind).emit_pre_thin_lto_bc {\n-                    let path = incr_comp_session_dir\n-                        .join(pre_lto_bitcode_filename(&module.name));\n-\n-                    fs::write(&path, buffer.data()).unwrap_or_else(|e| {\n-                        panic!(\"Error writing pre-lto-bitcode file `{}`: {}\",\n-                               path.display(),\n-                               e);\n-                    });\n-                }\n-            }\n-\n+        for (i, (name, buffer)) in modules.into_iter().enumerate() {\n+            info!(\"local module: {} - {}\", i, name);\n+            let cname = CString::new(name.clone()).unwrap();\n             thin_modules.push(llvm::ThinLTOModule {\n-                identifier: name.as_ptr(),\n+                identifier: cname.as_ptr(),\n                 data: buffer.data().as_ptr(),\n                 len: buffer.data().len(),\n             });\n             thin_buffers.push(buffer);\n-            module_names.push(name);\n-            timeline.record(&module.name);\n+            module_names.push(cname);\n+            timeline.record(&name);\n         }\n \n         // FIXME: All upstream crates are deserialized internally in the"}, {"sha": "ff06d3759bd940e86bc98b2f039510a374f20a75", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8128d0d1a95f5d77b672558c202cbf37d595fba3/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8128d0d1a95f5d77b672558c202cbf37d595fba3/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=8128d0d1a95f5d77b672558c202cbf37d595fba3", "patch": "@@ -185,7 +185,7 @@ impl WriteBackendMethods for LlvmCodegenBackend {\n     }\n     fn run_thin_lto(\n         cgcx: &CodegenContext<Self>,\n-        modules: Vec<ModuleCodegen<Self::Module>>,\n+        modules: Vec<(String, Self::ThinBuffer)>,\n         cached_modules: Vec<(SerializedModule<Self::ModuleBuffer>, WorkProduct)>,\n         timeline: &mut Timeline\n     ) -> Result<(Vec<LtoModuleCodegen<Self>>, Vec<WorkProduct>), FatalError> {\n@@ -216,6 +216,12 @@ impl WriteBackendMethods for LlvmCodegenBackend {\n     ) -> Result<CompiledModule, FatalError> {\n         back::write::codegen(cgcx, diag_handler, module, config, timeline)\n     }\n+    fn prepare_thin(\n+        cgcx: &CodegenContext<Self>,\n+        module: ModuleCodegen<Self::Module>\n+    ) -> (String, Self::ThinBuffer) {\n+        back::lto::prepare_thin(cgcx, module)\n+    }\n     fn run_lto_pass_manager(\n         cgcx: &CodegenContext<Self>,\n         module: &ModuleCodegen<Self::Module>,"}, {"sha": "59955ce77cde4ec385666e04ffdbf61343a32399", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8128d0d1a95f5d77b672558c202cbf37d595fba3/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8128d0d1a95f5d77b672558c202cbf37d595fba3/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=8128d0d1a95f5d77b672558c202cbf37d595fba3", "patch": "@@ -253,7 +253,7 @@ impl<B: WriteBackendMethods> CodegenContext<B> {\n fn generate_lto_work<B: ExtraBackendMethods>(\n     cgcx: &CodegenContext<B>,\n     needs_fat_lto: Vec<ModuleCodegen<B::Module>>,\n-    needs_thin_lto: Vec<ModuleCodegen<B::Module>>,\n+    needs_thin_lto: Vec<(String, B::ThinBuffer)>,\n     import_only_modules: Vec<(SerializedModule<B::ModuleBuffer>, WorkProduct)>\n ) -> Vec<(WorkItem<B>, u64)> {\n     let mut timeline = cgcx.time_graph.as_ref().map(|tg| {\n@@ -678,17 +678,17 @@ impl<B: WriteBackendMethods> WorkItem<B> {\n     }\n }\n \n-enum WorkItemResult<M> {\n+enum WorkItemResult<B: WriteBackendMethods> {\n     Compiled(CompiledModule),\n-    NeedsFatLTO(ModuleCodegen<M>),\n-    NeedsThinLTO(ModuleCodegen<M>),\n+    NeedsFatLTO(ModuleCodegen<B::Module>),\n+    NeedsThinLTO(String, B::ThinBuffer),\n }\n \n fn execute_work_item<B: ExtraBackendMethods>(\n     cgcx: &CodegenContext<B>,\n     work_item: WorkItem<B>,\n     timeline: &mut Timeline\n-) -> Result<WorkItemResult<B::Module>, FatalError> {\n+) -> Result<WorkItemResult<B>, FatalError> {\n     let module_config = cgcx.config(work_item.module_kind());\n \n     match work_item {\n@@ -716,7 +716,7 @@ fn execute_optimize_work_item<B: ExtraBackendMethods>(\n     module: ModuleCodegen<B::Module>,\n     module_config: &ModuleConfig,\n     timeline: &mut Timeline\n-) -> Result<WorkItemResult<B::Module>, FatalError> {\n+) -> Result<WorkItemResult<B>, FatalError> {\n     let diag_handler = cgcx.create_diag_handler();\n \n     unsafe {\n@@ -772,7 +772,10 @@ fn execute_optimize_work_item<B: ExtraBackendMethods>(\n             };\n             WorkItemResult::Compiled(module)\n         }\n-        ComputedLtoType::Thin => WorkItemResult::NeedsThinLTO(module),\n+        ComputedLtoType::Thin => {\n+            let (name, thin_buffer) = B::prepare_thin(cgcx, module);\n+            WorkItemResult::NeedsThinLTO(name, thin_buffer)\n+        }\n         ComputedLtoType::Fat => WorkItemResult::NeedsFatLTO(module),\n     })\n }\n@@ -782,7 +785,7 @@ fn execute_copy_from_cache_work_item<B: ExtraBackendMethods>(\n     module: CachedModuleCodegen,\n     module_config: &ModuleConfig,\n     _: &mut Timeline\n-) -> Result<WorkItemResult<B::Module>, FatalError> {\n+) -> Result<WorkItemResult<B>, FatalError> {\n     let incr_comp_session_dir = cgcx.incr_comp_session_dir\n                                     .as_ref()\n                                     .unwrap();\n@@ -844,7 +847,7 @@ fn execute_lto_work_item<B: ExtraBackendMethods>(\n     mut module: lto::LtoModuleCodegen<B>,\n     module_config: &ModuleConfig,\n     timeline: &mut Timeline\n-) -> Result<WorkItemResult<B::Module>, FatalError> {\n+) -> Result<WorkItemResult<B>, FatalError> {\n     let diag_handler = cgcx.create_diag_handler();\n \n     unsafe {\n@@ -861,7 +864,8 @@ pub enum Message<B: WriteBackendMethods> {\n         worker_id: usize,\n     },\n     NeedsThinLTO {\n-        result: ModuleCodegen<B::Module>,\n+        name: String,\n+        thin_buffer: B::ThinBuffer,\n         worker_id: usize,\n     },\n     Done {\n@@ -1423,10 +1427,10 @@ fn start_executing_work<B: ExtraBackendMethods>(\n                     free_worker(worker_id);\n                     needs_fat_lto.push(result);\n                 }\n-                Message::NeedsThinLTO { result, worker_id } => {\n+                Message::NeedsThinLTO { name, thin_buffer, worker_id } => {\n                     assert!(!started_lto);\n                     free_worker(worker_id);\n-                    needs_thin_lto.push(result);\n+                    needs_thin_lto.push((name, thin_buffer));\n                 }\n                 Message::AddImportOnlyModule { module_data, work_product } => {\n                     assert!(!started_lto);\n@@ -1514,7 +1518,7 @@ fn spawn_work<B: ExtraBackendMethods>(\n         // we exit.\n         struct Bomb<B: ExtraBackendMethods> {\n             coordinator_send: Sender<Box<dyn Any + Send>>,\n-            result: Option<WorkItemResult<B::Module>>,\n+            result: Option<WorkItemResult<B>>,\n             worker_id: usize,\n         }\n         impl<B: ExtraBackendMethods> Drop for Bomb<B> {\n@@ -1527,8 +1531,8 @@ fn spawn_work<B: ExtraBackendMethods>(\n                     Some(WorkItemResult::NeedsFatLTO(m)) => {\n                         Message::NeedsFatLTO::<B> { result: m, worker_id }\n                     }\n-                    Some(WorkItemResult::NeedsThinLTO(m)) => {\n-                        Message::NeedsThinLTO::<B> { result: m, worker_id }\n+                    Some(WorkItemResult::NeedsThinLTO(name, thin_buffer)) => {\n+                        Message::NeedsThinLTO::<B> { name, thin_buffer, worker_id }\n                     }\n                     None => Message::Done::<B> { result: Err(()), worker_id }\n                 };"}, {"sha": "edc5c2717bc4f39fb039de28ef9d095ff5dcd0b8", "filename": "src/librustc_codegen_ssa/traits/write.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8128d0d1a95f5d77b672558c202cbf37d595fba3/src%2Flibrustc_codegen_ssa%2Ftraits%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8128d0d1a95f5d77b672558c202cbf37d595fba3/src%2Flibrustc_codegen_ssa%2Ftraits%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fwrite.rs?ref=8128d0d1a95f5d77b672558c202cbf37d595fba3", "patch": "@@ -36,7 +36,7 @@ pub trait WriteBackendMethods: 'static + Sized + Clone {\n     /// can simply be copied over from the incr. comp. cache.\n     fn run_thin_lto(\n         cgcx: &CodegenContext<Self>,\n-        modules: Vec<ModuleCodegen<Self::Module>>,\n+        modules: Vec<(String, Self::ThinBuffer)>,\n         cached_modules: Vec<(SerializedModule<Self::ModuleBuffer>, WorkProduct)>,\n         timeline: &mut Timeline,\n     ) -> Result<(Vec<LtoModuleCodegen<Self>>, Vec<WorkProduct>), FatalError>;\n@@ -60,6 +60,10 @@ pub trait WriteBackendMethods: 'static + Sized + Clone {\n         config: &ModuleConfig,\n         timeline: &mut Timeline,\n     ) -> Result<CompiledModule, FatalError>;\n+    fn prepare_thin(\n+        cgcx: &CodegenContext<Self>,\n+        module: ModuleCodegen<Self::Module>\n+    ) -> (String, Self::ThinBuffer);\n     fn run_lto_pass_manager(\n         cgcx: &CodegenContext<Self>,\n         llmod: &ModuleCodegen<Self::Module>,"}]}