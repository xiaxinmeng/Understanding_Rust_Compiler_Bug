{"sha": "a8c1812f365c3b7466536f57d4eb745a90ca31e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4YzE4MTJmMzY1YzNiNzQ2NjUzNmY1N2Q0ZWI3NDVhOTBjYTMxZTk=", "commit": {"author": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-12-05T18:07:38Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-12-05T18:07:38Z"}, "message": "rollup merge of #19503: lifthrasiir/xenophobic-rustdoc\n\nThis series of commits deals with broken links to the source code. It also refactors some repetitive codes from Rustdoc. The most important commit, 1cb1f00d40f000ac7633b62a603db4fcea835ca6, describes the rationale; this will fix a half of #16289. Other commits are reasonably independent to each other and can be made into indiviudal PRs at the request.\n\n### Notes on the broken source links\n\nAs of bda97e8557820cc4ec13645dbdf976e5ccaa0ce1 (I've used this to check the PR works as intended), there are 281 (!) such broken links. They can be further classified as follows:\n\n* 178 links to incorrect item types. This is the first half of #16289, and this PR fixes all of them.\n* 89 links to redirect pages. They are not technically \"broken\" but still doesn't give a source code. I have a fix for this in mind, which would make a redirect page slightly *fat*.\n* 14 links to incorrect `DefId` in the `gotosrc` parameter. This is #15309, and affects many `liballoc` reexports in `libstd` but *nothing else* (curiously). I'm yet to track this down; might be a metadata bug (not sure).\n* 0 links to the crate reexported as a different name. This is the second half of #16289, and seems not hard to fix but I'm running out of time.\n\nPrevalence of this kind of bugs calls for a full link verifier integrated into the testing process. :S", "tree": {"sha": "c7d08d3fcbb298e97a0661da87e098862d464584", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7d08d3fcbb298e97a0661da87e098862d464584"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8c1812f365c3b7466536f57d4eb745a90ca31e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8c1812f365c3b7466536f57d4eb745a90ca31e9", "html_url": "https://github.com/rust-lang/rust/commit/a8c1812f365c3b7466536f57d4eb745a90ca31e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8c1812f365c3b7466536f57d4eb745a90ca31e9/comments", "author": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fdb395626bc1180e1b643e43e8b9344c43fa6c0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/fdb395626bc1180e1b643e43e8b9344c43fa6c0f", "html_url": "https://github.com/rust-lang/rust/commit/fdb395626bc1180e1b643e43e8b9344c43fa6c0f"}, {"sha": "1068855925581d7f6d4a177c5f55ac3d5da8afd7", "url": "https://api.github.com/repos/rust-lang/rust/commits/1068855925581d7f6d4a177c5f55ac3d5da8afd7", "html_url": "https://github.com/rust-lang/rust/commit/1068855925581d7f6d4a177c5f55ac3d5da8afd7"}], "stats": {"total": 257, "additions": 132, "deletions": 125}, "files": [{"sha": "9861d18ce51f0b245f52f5785487c47a0280db36", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8c1812f365c3b7466536f57d4eb745a90ca31e9/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c1812f365c3b7466536f57d4eb745a90ca31e9/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=a8c1812f365c3b7466536f57d4eb745a90ca31e9", "patch": "@@ -23,7 +23,6 @@ use syntax::ast_util;\n \n use clean;\n use stability_summary::ModuleSummary;\n-use html::item_type;\n use html::item_type::ItemType;\n use html::render;\n use html::render::{cache, CURRENT_LOCATION_KEY};\n@@ -283,7 +282,7 @@ fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n                 url.push_str(\"/\");\n             }\n             match shortty {\n-                item_type::Module => {\n+                ItemType::Module => {\n                     url.push_str(fqp.last().unwrap().as_slice());\n                     url.push_str(\"/index.html\");\n                 }"}, {"sha": "0ad12b957ba8f868793ae5261a5078035325ce2f", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 55, "deletions": 46, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/a8c1812f365c3b7466536f57d4eb745a90ca31e9/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c1812f365c3b7466536f57d4eb745a90ca31e9/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=a8c1812f365c3b7466536f57d4eb745a90ca31e9", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n //! Item types.\n-pub use self::ItemType::*;\n \n use std::fmt;\n use clean;\n@@ -35,36 +34,70 @@ pub enum ItemType {\n     Method          = 10,\n     StructField     = 11,\n     Variant         = 12,\n-    ForeignFunction = 13,\n-    ForeignStatic   = 14,\n+    // we used to have ForeignFunction and ForeignStatic. they are retired now.\n     Macro           = 15,\n     Primitive       = 16,\n     AssociatedType  = 17,\n     Constant        = 18,\n }\n \n impl ItemType {\n+    pub fn from_item(item: &clean::Item) -> ItemType {\n+        match item.inner {\n+            clean::ModuleItem(..)          => ItemType::Module,\n+            clean::StructItem(..)          => ItemType::Struct,\n+            clean::EnumItem(..)            => ItemType::Enum,\n+            clean::FunctionItem(..)        => ItemType::Function,\n+            clean::TypedefItem(..)         => ItemType::Typedef,\n+            clean::StaticItem(..)          => ItemType::Static,\n+            clean::ConstantItem(..)        => ItemType::Constant,\n+            clean::TraitItem(..)           => ItemType::Trait,\n+            clean::ImplItem(..)            => ItemType::Impl,\n+            clean::ViewItemItem(..)        => ItemType::ViewItem,\n+            clean::TyMethodItem(..)        => ItemType::TyMethod,\n+            clean::MethodItem(..)          => ItemType::Method,\n+            clean::StructFieldItem(..)     => ItemType::StructField,\n+            clean::VariantItem(..)         => ItemType::Variant,\n+            clean::ForeignFunctionItem(..) => ItemType::Function, // no ForeignFunction\n+            clean::ForeignStaticItem(..)   => ItemType::Static, // no ForeignStatic\n+            clean::MacroItem(..)           => ItemType::Macro,\n+            clean::PrimitiveItem(..)       => ItemType::Primitive,\n+            clean::AssociatedTypeItem(..)  => ItemType::AssociatedType,\n+        }\n+    }\n+\n+    pub fn from_type_kind(kind: clean::TypeKind) -> ItemType {\n+        match kind {\n+            clean::TypeStruct   => ItemType::Struct,\n+            clean::TypeEnum     => ItemType::Enum,\n+            clean::TypeFunction => ItemType::Function,\n+            clean::TypeTrait    => ItemType::Trait,\n+            clean::TypeModule   => ItemType::Module,\n+            clean::TypeStatic   => ItemType::Static,\n+            clean::TypeVariant  => ItemType::Variant,\n+            clean::TypeTypedef  => ItemType::Typedef,\n+        }\n+    }\n+\n     pub fn to_static_str(&self) -> &'static str {\n         match *self {\n-            Module          => \"mod\",\n-            Struct          => \"struct\",\n-            Enum            => \"enum\",\n-            Function        => \"fn\",\n-            Typedef         => \"type\",\n-            Static          => \"static\",\n-            Trait           => \"trait\",\n-            Impl            => \"impl\",\n-            ViewItem        => \"viewitem\",\n-            TyMethod        => \"tymethod\",\n-            Method          => \"method\",\n-            StructField     => \"structfield\",\n-            Variant         => \"variant\",\n-            ForeignFunction => \"ffi\",\n-            ForeignStatic   => \"ffs\",\n-            Macro           => \"macro\",\n-            Primitive       => \"primitive\",\n-            AssociatedType  => \"associatedtype\",\n-            Constant        => \"constant\",\n+            ItemType::Module          => \"mod\",\n+            ItemType::Struct          => \"struct\",\n+            ItemType::Enum            => \"enum\",\n+            ItemType::Function        => \"fn\",\n+            ItemType::Typedef         => \"type\",\n+            ItemType::Static          => \"static\",\n+            ItemType::Trait           => \"trait\",\n+            ItemType::Impl            => \"impl\",\n+            ItemType::ViewItem        => \"viewitem\",\n+            ItemType::TyMethod        => \"tymethod\",\n+            ItemType::Method          => \"method\",\n+            ItemType::StructField     => \"structfield\",\n+            ItemType::Variant         => \"variant\",\n+            ItemType::Macro           => \"macro\",\n+            ItemType::Primitive       => \"primitive\",\n+            ItemType::AssociatedType  => \"associatedtype\",\n+            ItemType::Constant        => \"constant\",\n         }\n     }\n }\n@@ -75,27 +108,3 @@ impl fmt::Show for ItemType {\n     }\n }\n \n-pub fn shortty(item: &clean::Item) -> ItemType {\n-    match item.inner {\n-        clean::ModuleItem(..)          => Module,\n-        clean::StructItem(..)          => Struct,\n-        clean::EnumItem(..)            => Enum,\n-        clean::FunctionItem(..)        => Function,\n-        clean::TypedefItem(..)         => Typedef,\n-        clean::StaticItem(..)          => Static,\n-        clean::ConstantItem(..)        => Constant,\n-        clean::TraitItem(..)           => Trait,\n-        clean::ImplItem(..)            => Impl,\n-        clean::ViewItemItem(..)        => ViewItem,\n-        clean::TyMethodItem(..)        => TyMethod,\n-        clean::MethodItem(..)          => Method,\n-        clean::StructFieldItem(..)     => StructField,\n-        clean::VariantItem(..)         => Variant,\n-        clean::ForeignFunctionItem(..) => ForeignFunction,\n-        clean::ForeignStaticItem(..)   => ForeignStatic,\n-        clean::MacroItem(..)           => Macro,\n-        clean::PrimitiveItem(..)       => Primitive,\n-        clean::AssociatedTypeItem(..)  => AssociatedType,\n-    }\n-}\n-"}, {"sha": "9eee8e04f0c2bf505d61406d2eaede7f1a3e0ea0", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 74, "deletions": 75, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/a8c1812f365c3b7466536f57d4eb745a90ca31e9/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c1812f365c3b7466536f57d4eb745a90ca31e9/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=a8c1812f365c3b7466536f57d4eb745a90ca31e9", "patch": "@@ -61,8 +61,7 @@ use fold::DocFolder;\n use html::format::{VisSpace, Method, FnStyleSpace, MutableSpace, Stability};\n use html::format::{ConciseStability, TyParamBounds, WhereClause};\n use html::highlight;\n-use html::item_type::{ItemType, shortty};\n-use html::item_type;\n+use html::item_type::ItemType;\n use html::layout;\n use html::markdown::Markdown;\n use html::markdown;\n@@ -314,19 +313,8 @@ pub fn run(mut krate: clean::Crate,\n     let paths: HashMap<ast::DefId, (Vec<String>, ItemType)> =\n       analysis.as_ref().map(|a| {\n         let paths = a.external_paths.borrow_mut().take().unwrap();\n-        paths.into_iter().map(|(k, (v, t))| {\n-            (k, (v, match t {\n-                clean::TypeStruct => item_type::Struct,\n-                clean::TypeEnum => item_type::Enum,\n-                clean::TypeFunction => item_type::Function,\n-                clean::TypeTrait => item_type::Trait,\n-                clean::TypeModule => item_type::Module,\n-                clean::TypeStatic => item_type::Static,\n-                clean::TypeVariant => item_type::Variant,\n-                clean::TypeTypedef => item_type::Typedef,\n-            }))\n-        }).collect()\n-    }).unwrap_or(HashMap::new());\n+        paths.into_iter().map(|(k, (v, t))| (k, (v, ItemType::from_type_kind(t)))).collect()\n+      }).unwrap_or(HashMap::new());\n     let mut cache = Cache {\n         impls: HashMap::new(),\n         external_paths: paths.iter().map(|(&k, v)| (k, v.ref0().clone()))\n@@ -359,7 +347,7 @@ pub fn run(mut krate: clean::Crate,\n     for &(n, ref e) in krate.externs.iter() {\n         cache.extern_locations.insert(n, extern_location(e, &cx.dst));\n         let did = ast::DefId { krate: n, node: ast::CRATE_NODE_ID };\n-        cache.paths.insert(did, (vec![e.name.to_string()], item_type::Module));\n+        cache.paths.insert(did, (vec![e.name.to_string()], ItemType::Module));\n     }\n \n     // Cache where all known primitives have their documentation located.\n@@ -642,6 +630,11 @@ fn mkdir(path: &Path) -> io::IoResult<()> {\n     }\n }\n \n+/// Returns a documentation-level item type from the item.\n+fn shortty(item: &clean::Item) -> ItemType {\n+    ItemType::from_item(item)\n+}\n+\n /// Takes a path to a source file and cleans the path to it. This canonicalizes\n /// things like \"..\" to components which preserve the \"top down\" hierarchy of a\n /// static HTML tree.\n@@ -855,13 +848,13 @@ impl DocFolder for Cache {\n                         let last = self.parent_stack.last().unwrap();\n                         let did = *last;\n                         let path = match self.paths.get(&did) {\n-                            Some(&(_, item_type::Trait)) =>\n+                            Some(&(_, ItemType::Trait)) =>\n                                 Some(self.stack[..self.stack.len() - 1]),\n                             // The current stack not necessarily has correlation for\n                             // where the type was defined. On the other hand,\n                             // `paths` always has the right information if present.\n-                            Some(&(ref fqp, item_type::Struct)) |\n-                            Some(&(ref fqp, item_type::Enum)) =>\n+                            Some(&(ref fqp, ItemType::Struct)) |\n+                            Some(&(ref fqp, ItemType::Enum)) =>\n                                 Some(fqp[..fqp.len() - 1]),\n                             Some(..) => Some(self.stack.as_slice()),\n                             None => None\n@@ -929,7 +922,7 @@ impl DocFolder for Cache {\n             clean::VariantItem(..) if !self.privmod => {\n                 let mut stack = self.stack.clone();\n                 stack.pop();\n-                self.paths.insert(item.def_id, (stack, item_type::Enum));\n+                self.paths.insert(item.def_id, (stack, ItemType::Enum));\n             }\n \n             clean::PrimitiveItem(..) if item.visibility.is_some() => {\n@@ -1251,6 +1244,10 @@ impl Context {\n         for item in m.items.iter() {\n             if self.ignore_private_item(item) { continue }\n \n+            // avoid putting foreign items to the sidebar.\n+            if let &clean::ForeignFunctionItem(..) = &item.inner { continue }\n+            if let &clean::ForeignStaticItem(..) = &item.inner { continue }\n+\n             let short = shortty(item).to_static_str();\n             let myname = match item.name {\n                 None => continue,\n@@ -1435,7 +1432,8 @@ impl<'a> fmt::Show for Item<'a> {\n             clean::TypedefItem(ref t) => item_typedef(fmt, self.item, t),\n             clean::MacroItem(ref m) => item_macro(fmt, self.item, m),\n             clean::PrimitiveItem(ref p) => item_primitive(fmt, self.item, p),\n-            clean::StaticItem(ref i) => item_static(fmt, self.item, i),\n+            clean::StaticItem(ref i) | clean::ForeignStaticItem(ref i) =>\n+                item_static(fmt, self.item, i),\n             clean::ConstantItem(ref c) => item_constant(fmt, self.item, c),\n             _ => Ok(())\n         }\n@@ -1490,45 +1488,48 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n         !cx.ignore_private_item(&items[*i])\n     }).collect::<Vec<uint>>();\n \n+    // the order of item types in the listing\n+    fn reorder(ty: ItemType) -> u8 {\n+        match ty {\n+            ItemType::ViewItem        => 0,\n+            ItemType::Primitive       => 1,\n+            ItemType::Module          => 2,\n+            ItemType::Macro           => 3,\n+            ItemType::Struct          => 4,\n+            ItemType::Enum            => 5,\n+            ItemType::Constant        => 6,\n+            ItemType::Static          => 7,\n+            ItemType::Trait           => 8,\n+            ItemType::Function        => 9,\n+            ItemType::Typedef         => 10,\n+            _                         => 11 + ty as u8,\n+        }\n+    }\n+\n     fn cmp(i1: &clean::Item, i2: &clean::Item, idx1: uint, idx2: uint) -> Ordering {\n-        if shortty(i1) == shortty(i2) {\n+        let ty1 = shortty(i1);\n+        let ty2 = shortty(i2);\n+        if ty1 == ty2 {\n             return i1.name.cmp(&i2.name);\n         }\n-        match (&i1.inner, &i2.inner) {\n-            (&clean::ViewItemItem(ref a), &clean::ViewItemItem(ref b)) => {\n-                match (&a.inner, &b.inner) {\n-                    (&clean::ExternCrate(..), _) => Less,\n-                    (_, &clean::ExternCrate(..)) => Greater,\n-                    _ => idx1.cmp(&idx2),\n+\n+        let tycmp = reorder(ty1).cmp(&reorder(ty2));\n+        if let Equal = tycmp {\n+            // for reexports, `extern crate` takes precedence.\n+            match (&i1.inner, &i2.inner) {\n+                (&clean::ViewItemItem(ref a), &clean::ViewItemItem(ref b)) => {\n+                    match (&a.inner, &b.inner) {\n+                        (&clean::ExternCrate(..), _) => return Less,\n+                        (_, &clean::ExternCrate(..)) => return Greater,\n+                        _ => {}\n+                    }\n                 }\n+                (_, _) => {}\n             }\n-            (&clean::ViewItemItem(..), _) => Less,\n-            (_, &clean::ViewItemItem(..)) => Greater,\n-            (&clean::PrimitiveItem(..), _) => Less,\n-            (_, &clean::PrimitiveItem(..)) => Greater,\n-            (&clean::ModuleItem(..), _) => Less,\n-            (_, &clean::ModuleItem(..)) => Greater,\n-            (&clean::MacroItem(..), _) => Less,\n-            (_, &clean::MacroItem(..)) => Greater,\n-            (&clean::StructItem(..), _) => Less,\n-            (_, &clean::StructItem(..)) => Greater,\n-            (&clean::EnumItem(..), _) => Less,\n-            (_, &clean::EnumItem(..)) => Greater,\n-            (&clean::ConstantItem(..), _) => Less,\n-            (_, &clean::ConstantItem(..)) => Greater,\n-            (&clean::StaticItem(..), _) => Less,\n-            (_, &clean::StaticItem(..)) => Greater,\n-            (&clean::ForeignFunctionItem(..), _) => Less,\n-            (_, &clean::ForeignFunctionItem(..)) => Greater,\n-            (&clean::ForeignStaticItem(..), _) => Less,\n-            (_, &clean::ForeignStaticItem(..)) => Greater,\n-            (&clean::TraitItem(..), _) => Less,\n-            (_, &clean::TraitItem(..)) => Greater,\n-            (&clean::FunctionItem(..), _) => Less,\n-            (_, &clean::FunctionItem(..)) => Greater,\n-            (&clean::TypedefItem(..), _) => Less,\n-            (_, &clean::TypedefItem(..)) => Greater,\n-            _ => idx1.cmp(&idx2),\n+\n+            idx1.cmp(&idx2)\n+        } else {\n+            tycmp\n         }\n     }\n \n@@ -1545,26 +1546,24 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 try!(write!(w, \"</table>\"));\n             }\n             curty = myty;\n-            let (short, name) = match myitem.inner {\n-                clean::ModuleItem(..)          => (\"modules\", \"Modules\"),\n-                clean::StructItem(..)          => (\"structs\", \"Structs\"),\n-                clean::EnumItem(..)            => (\"enums\", \"Enums\"),\n-                clean::FunctionItem(..)        => (\"functions\", \"Functions\"),\n-                clean::TypedefItem(..)         => (\"types\", \"Type Definitions\"),\n-                clean::StaticItem(..)          => (\"statics\", \"Statics\"),\n-                clean::ConstantItem(..)        => (\"constants\", \"Constants\"),\n-                clean::TraitItem(..)           => (\"traits\", \"Traits\"),\n-                clean::ImplItem(..)            => (\"impls\", \"Implementations\"),\n-                clean::ViewItemItem(..)        => (\"reexports\", \"Reexports\"),\n-                clean::TyMethodItem(..)        => (\"tymethods\", \"Type Methods\"),\n-                clean::MethodItem(..)          => (\"methods\", \"Methods\"),\n-                clean::StructFieldItem(..)     => (\"fields\", \"Struct Fields\"),\n-                clean::VariantItem(..)         => (\"variants\", \"Variants\"),\n-                clean::ForeignFunctionItem(..) => (\"ffi-fns\", \"Foreign Functions\"),\n-                clean::ForeignStaticItem(..)   => (\"ffi-statics\", \"Foreign Statics\"),\n-                clean::MacroItem(..)           => (\"macros\", \"Macros\"),\n-                clean::PrimitiveItem(..)       => (\"primitives\", \"Primitive Types\"),\n-                clean::AssociatedTypeItem(..)  => (\"associated-types\", \"Associated Types\"),\n+            let (short, name) = match myty.unwrap() {\n+                ItemType::Module          => (\"modules\", \"Modules\"),\n+                ItemType::Struct          => (\"structs\", \"Structs\"),\n+                ItemType::Enum            => (\"enums\", \"Enums\"),\n+                ItemType::Function        => (\"functions\", \"Functions\"),\n+                ItemType::Typedef         => (\"types\", \"Type Definitions\"),\n+                ItemType::Static          => (\"statics\", \"Statics\"),\n+                ItemType::Constant        => (\"constants\", \"Constants\"),\n+                ItemType::Trait           => (\"traits\", \"Traits\"),\n+                ItemType::Impl            => (\"impls\", \"Implementations\"),\n+                ItemType::ViewItem        => (\"reexports\", \"Reexports\"),\n+                ItemType::TyMethod        => (\"tymethods\", \"Type Methods\"),\n+                ItemType::Method          => (\"methods\", \"Methods\"),\n+                ItemType::StructField     => (\"fields\", \"Struct Fields\"),\n+                ItemType::Variant         => (\"variants\", \"Variants\"),\n+                ItemType::Macro           => (\"macros\", \"Macros\"),\n+                ItemType::Primitive       => (\"primitives\", \"Primitive Types\"),\n+                ItemType::AssociatedType  => (\"associated-types\", \"Associated Types\"),\n             };\n             try!(write!(w,\n                         \"<h2 id='{id}' class='section-header'>\\"}, {"sha": "74d1ac928c4eef26a34800453b9afbc23547b473", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8c1812f365c3b7466536f57d4eb745a90ca31e9/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/a8c1812f365c3b7466536f57d4eb745a90ca31e9/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=a8c1812f365c3b7466536f57d4eb745a90ca31e9", "patch": "@@ -566,8 +566,8 @@\n                          \"method\",\n                          \"structfield\",\n                          \"variant\",\n-                         \"ffi\",\n-                         \"ffs\",\n+                         \"ffi\", // retained for backward compatibility\n+                         \"ffs\", // retained for backward compatibility\n                          \"macro\",\n                          \"primitive\",\n                          \"associatedtype\","}]}