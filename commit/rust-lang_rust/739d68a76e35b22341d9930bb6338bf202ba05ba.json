{"sha": "739d68a76e35b22341d9930bb6338bf202ba05ba", "node_id": "C_kwDOAAsO6NoAKDczOWQ2OGE3NmUzNWIyMjM0MWQ5OTMwYmI2MzM4YmYyMDJiYTA1YmE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-27T20:54:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-27T20:54:06Z"}, "message": "Auto merge of #106193 - compiler-errors:rollup-0l54wka, r=compiler-errors\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #103718 (More inference-friendly API for lazy)\n - #105765 (Detect likely `.` -> `..` typo in method calls)\n - #105852 (Suggest rewriting a malformed hex literal if we expect a float)\n - #105965 (Provide local extern function arg names)\n - #106064 (Partially fix `explicit_outlives_requirements` lint in macros)\n - #106179 (Fix a formatting error in Iterator::for_each docs)\n - #106181 (Fix doc comment parsing description in book)\n - #106187 (Update the documentation of `Vec` to use `extend(array)` instead of `extend(array.iter().copied())`)\n - #106189 (Fix UnsafeCell Documentation Spelling Error)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "b21bfb378d7c73b255f8dbb35d4115ebaaf69662", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b21bfb378d7c73b255f8dbb35d4115ebaaf69662"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/739d68a76e35b22341d9930bb6338bf202ba05ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/739d68a76e35b22341d9930bb6338bf202ba05ba", "html_url": "https://github.com/rust-lang/rust/commit/739d68a76e35b22341d9930bb6338bf202ba05ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/739d68a76e35b22341d9930bb6338bf202ba05ba/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92c1937a90e5b6f20fa6e87016d6869da363972e", "url": "https://api.github.com/repos/rust-lang/rust/commits/92c1937a90e5b6f20fa6e87016d6869da363972e", "html_url": "https://github.com/rust-lang/rust/commit/92c1937a90e5b6f20fa6e87016d6869da363972e"}, {"sha": "49d43468a8182e4e0fda4a15e969266ceba86809", "url": "https://api.github.com/repos/rust-lang/rust/commits/49d43468a8182e4e0fda4a15e969266ceba86809", "html_url": "https://github.com/rust-lang/rust/commit/49d43468a8182e4e0fda4a15e969266ceba86809"}], "stats": {"total": 889, "additions": 781, "deletions": 108}, "files": [{"sha": "b6b242bfc27fcc371e6bb19e93bbcd91d1e7faec", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/739d68a76e35b22341d9930bb6338bf202ba05ba/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/739d68a76e35b22341d9930bb6338bf202ba05ba/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=739d68a76e35b22341d9930bb6338bf202ba05ba", "patch": "@@ -1316,6 +1316,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 param.id,\n                 &param.kind,\n                 &param.bounds,\n+                param.colon_span,\n+                generics.span,\n                 itctx,\n                 PredicateOrigin::GenericParam,\n             )\n@@ -1365,6 +1367,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         id: NodeId,\n         kind: &GenericParamKind,\n         bounds: &[GenericBound],\n+        colon_span: Option<Span>,\n+        parent_span: Span,\n         itctx: &ImplTraitContext,\n         origin: PredicateOrigin,\n     ) -> Option<hir::WherePredicate<'hir>> {\n@@ -1377,21 +1381,17 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         let ident = self.lower_ident(ident);\n         let param_span = ident.span;\n-        let span = bounds\n-            .iter()\n-            .fold(Some(param_span.shrink_to_hi()), |span: Option<Span>, bound| {\n-                let bound_span = bound.span();\n-                // We include bounds that come from a `#[derive(_)]` but point at the user's code,\n-                // as we use this method to get a span appropriate for suggestions.\n-                if !bound_span.can_be_used_for_suggestions() {\n-                    None\n-                } else if let Some(span) = span {\n-                    Some(span.to(bound_span))\n-                } else {\n-                    Some(bound_span)\n-                }\n-            })\n-            .unwrap_or(param_span.shrink_to_hi());\n+\n+        // Reconstruct the span of the entire predicate from the individual generic bounds.\n+        let span_start = colon_span.unwrap_or_else(|| param_span.shrink_to_hi());\n+        let span = bounds.iter().fold(span_start, |span_accum, bound| {\n+            match bound.span().find_ancestor_inside(parent_span) {\n+                Some(bound_span) => span_accum.to(bound_span),\n+                None => span_accum,\n+            }\n+        });\n+        let span = self.lower_span(span);\n+\n         match kind {\n             GenericParamKind::Const { .. } => None,\n             GenericParamKind::Type { .. } => {"}, {"sha": "1fbc45a58e5687917a14a2e0a655aeeaaf6b571b", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/739d68a76e35b22341d9930bb6338bf202ba05ba/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/739d68a76e35b22341d9930bb6338bf202ba05ba/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=739d68a76e35b22341d9930bb6338bf202ba05ba", "patch": "@@ -2245,14 +2245,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     ) -> (hir::GenericParam<'hir>, Option<hir::WherePredicate<'hir>>, hir::TyKind<'hir>) {\n         // Add a definition for the in-band `Param`.\n         let def_id = self.local_def_id(node_id);\n+        let span = self.lower_span(span);\n \n         // Set the name to `impl Bound1 + Bound2`.\n         let param = hir::GenericParam {\n             hir_id: self.lower_node_id(node_id),\n             def_id,\n             name: ParamName::Plain(self.lower_ident(ident)),\n             pure_wrt_drop: false,\n-            span: self.lower_span(span),\n+            span,\n             kind: hir::GenericParamKind::Type { default: None, synthetic: true },\n             colon_span: None,\n         };\n@@ -2262,6 +2263,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             node_id,\n             &GenericParamKind::Type { default: None },\n             bounds,\n+            /* colon_span */ None,\n+            span,\n             &ImplTraitContext::Universal,\n             hir::PredicateOrigin::ImplTrait,\n         );\n@@ -2271,7 +2274,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let ty = hir::TyKind::Path(hir::QPath::Resolved(\n             None,\n             self.arena.alloc(hir::Path {\n-                span: self.lower_span(span),\n+                span,\n                 res,\n                 segments:\n                     arena_vec![self; hir::PathSegment::new(self.lower_ident(ident), hir_id, res)],"}, {"sha": "1360383a75a958d80ca77a32a80c5d3700f6af65", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/739d68a76e35b22341d9930bb6338bf202ba05ba/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/739d68a76e35b22341d9930bb6338bf202ba05ba/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=739d68a76e35b22341d9930bb6338bf202ba05ba", "patch": "@@ -74,6 +74,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.note_type_is_not_clone(err, expected, expr_ty, expr);\n         self.note_need_for_fn_pointer(err, expected, expr_ty);\n         self.note_internal_mutation_in_method(err, expr, expected, expr_ty);\n+        self.check_for_range_as_method_call(err, expr, expr_ty, expected);\n     }\n \n     /// Requires that the two types unify, and prints an error message if\n@@ -1607,4 +1608,69 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             _ => false,\n         }\n     }\n+\n+    /// Identify when the user has written `foo..bar()` instead of `foo.bar()`.\n+    pub fn check_for_range_as_method_call(\n+        &self,\n+        err: &mut Diagnostic,\n+        expr: &hir::Expr<'_>,\n+        checked_ty: Ty<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+    ) {\n+        if !hir::is_range_literal(expr) {\n+            return;\n+        }\n+        let hir::ExprKind::Struct(\n+            hir::QPath::LangItem(LangItem::Range, ..),\n+            [start, end],\n+            _,\n+        ) = expr.kind else { return; };\n+        let parent = self.tcx.hir().get_parent_node(expr.hir_id);\n+        if let Some(hir::Node::ExprField(_)) = self.tcx.hir().find(parent) {\n+            // Ignore `Foo { field: a..Default::default() }`\n+            return;\n+        }\n+        let mut expr = end.expr;\n+        while let hir::ExprKind::MethodCall(_, rcvr, ..) = expr.kind {\n+            // Getting to the root receiver and asserting it is a fn call let's us ignore cases in\n+            // `src/test/ui/methods/issues/issue-90315.stderr`.\n+            expr = rcvr;\n+        }\n+        let hir::ExprKind::Call(method_name, _) = expr.kind else { return; };\n+        let ty::Adt(adt, _) = checked_ty.kind() else { return; };\n+        if self.tcx.lang_items().range_struct() != Some(adt.did()) {\n+            return;\n+        }\n+        if let ty::Adt(adt, _) = expected_ty.kind()\n+            && self.tcx.lang_items().range_struct() == Some(adt.did())\n+        {\n+            return;\n+        }\n+        // Check if start has method named end.\n+        let hir::ExprKind::Path(hir::QPath::Resolved(None, p)) = method_name.kind else { return; };\n+        let [hir::PathSegment { ident, .. }] = p.segments else { return; };\n+        let self_ty = self.typeck_results.borrow().expr_ty(start.expr);\n+        let Ok(_pick) = self.probe_for_name(\n+            probe::Mode::MethodCall,\n+            *ident,\n+            probe::IsSuggestion(true),\n+            self_ty,\n+            expr.hir_id,\n+            probe::ProbeScope::AllTraits,\n+        ) else { return; };\n+        let mut sugg = \".\";\n+        let mut span = start.expr.span.between(end.expr.span);\n+        if span.lo() + BytePos(2) == span.hi() {\n+            // There's no space between the start, the range op and the end, suggest removal which\n+            // will be more noticeable than the replacement of `..` with `.`.\n+            span = span.with_lo(span.lo() + BytePos(1));\n+            sugg = \"\";\n+        }\n+        err.span_suggestion_verbose(\n+            span,\n+            \"you likely meant to write a method call instead of a range\",\n+            sugg,\n+            Applicability::MachineApplicable,\n+        );\n+    }\n }"}, {"sha": "e38d1bccc10657199fcc4ff2515c2136867a19d2", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/739d68a76e35b22341d9930bb6338bf202ba05ba/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/739d68a76e35b22341d9930bb6338bf202ba05ba/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=739d68a76e35b22341d9930bb6338bf202ba05ba", "patch": "@@ -19,6 +19,7 @@ use rustc_middle::ty::{\n     TypeVisitable,\n };\n use rustc_session::errors::ExprParenthesesNeeded;\n+use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::{Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt;\n@@ -1259,6 +1260,31 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 );\n                 true\n             }\n+            ExprKind::Lit(Spanned {\n+                node: rustc_ast::LitKind::Int(lit, rustc_ast::LitIntType::Unsuffixed),\n+                span,\n+            }) => {\n+                let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) else { return false; };\n+                if !(snippet.starts_with(\"0x\") || snippet.starts_with(\"0X\")) {\n+                    return false;\n+                }\n+                if snippet.len() <= 5 || !snippet.is_char_boundary(snippet.len() - 3) {\n+                    return false;\n+                }\n+                let (_, suffix) = snippet.split_at(snippet.len() - 3);\n+                let value = match suffix {\n+                    \"f32\" => (lit - 0xf32) / (16 * 16 * 16),\n+                    \"f64\" => (lit - 0xf64) / (16 * 16 * 16),\n+                    _ => return false,\n+                };\n+                err.span_suggestions(\n+                    expr.span,\n+                    \"rewrite this as a decimal floating point literal, or use `as` to turn a hex literal into a float\",\n+                    [format!(\"0x{value:X} as {suffix}\"), format!(\"{value}_{suffix}\")],\n+                    Applicability::MaybeIncorrect,\n+                );\n+                true\n+            }\n             _ => false,\n         }\n     }"}, {"sha": "cdb901b7f8603b65329e31ff6e14e7385db6c222", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 85, "deletions": 63, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/739d68a76e35b22341d9930bb6338bf202ba05ba/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/739d68a76e35b22341d9930bb6338bf202ba05ba/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=739d68a76e35b22341d9930bb6338bf202ba05ba", "patch": "@@ -2184,30 +2184,36 @@ impl ExplicitOutlivesRequirements {\n         tcx: TyCtxt<'tcx>,\n         bounds: &hir::GenericBounds<'_>,\n         inferred_outlives: &[ty::Region<'tcx>],\n+        predicate_span: Span,\n     ) -> Vec<(usize, Span)> {\n         use rustc_middle::middle::resolve_lifetime::Region;\n \n         bounds\n             .iter()\n             .enumerate()\n             .filter_map(|(i, bound)| {\n-                if let hir::GenericBound::Outlives(lifetime) = bound {\n-                    let is_inferred = match tcx.named_region(lifetime.hir_id) {\n-                        Some(Region::EarlyBound(def_id)) => inferred_outlives.iter().any(|r| {\n-                            if let ty::ReEarlyBound(ebr) = **r {\n-                                ebr.def_id == def_id\n-                            } else {\n-                                false\n-                            }\n-                        }),\n-                        _ => false,\n-                    };\n-                    is_inferred.then_some((i, bound.span()))\n-                } else {\n-                    None\n+                let hir::GenericBound::Outlives(lifetime) = bound else {\n+                    return None;\n+                };\n+\n+                let is_inferred = match tcx.named_region(lifetime.hir_id) {\n+                    Some(Region::EarlyBound(def_id)) => inferred_outlives\n+                        .iter()\n+                        .any(|r| matches!(**r, ty::ReEarlyBound(ebr) if { ebr.def_id == def_id })),\n+                    _ => false,\n+                };\n+\n+                if !is_inferred {\n+                    return None;\n                 }\n+\n+                let span = bound.span().find_ancestor_inside(predicate_span)?;\n+                if in_external_macro(tcx.sess, span) {\n+                    return None;\n+                }\n+\n+                Some((i, span))\n             })\n-            .filter(|(_, span)| !in_external_macro(tcx.sess, *span))\n             .collect()\n     }\n \n@@ -2273,9 +2279,9 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n         use rustc_middle::middle::resolve_lifetime::Region;\n \n         let def_id = item.owner_id.def_id;\n-        if let hir::ItemKind::Struct(_, ref hir_generics)\n-        | hir::ItemKind::Enum(_, ref hir_generics)\n-        | hir::ItemKind::Union(_, ref hir_generics) = item.kind\n+        if let hir::ItemKind::Struct(_, hir_generics)\n+        | hir::ItemKind::Enum(_, hir_generics)\n+        | hir::ItemKind::Union(_, hir_generics) = item.kind\n         {\n             let inferred_outlives = cx.tcx.inferred_outlives_of(def_id);\n             if inferred_outlives.is_empty() {\n@@ -2290,53 +2296,58 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n             let mut dropped_predicate_count = 0;\n             let num_predicates = hir_generics.predicates.len();\n             for (i, where_predicate) in hir_generics.predicates.iter().enumerate() {\n-                let (relevant_lifetimes, bounds, span, in_where_clause) = match where_predicate {\n-                    hir::WherePredicate::RegionPredicate(predicate) => {\n-                        if let Some(Region::EarlyBound(region_def_id)) =\n-                            cx.tcx.named_region(predicate.lifetime.hir_id)\n-                        {\n-                            (\n-                                Self::lifetimes_outliving_lifetime(\n-                                    inferred_outlives,\n-                                    region_def_id,\n-                                ),\n-                                &predicate.bounds,\n-                                predicate.span,\n-                                predicate.in_where_clause,\n-                            )\n-                        } else {\n-                            continue;\n-                        }\n-                    }\n-                    hir::WherePredicate::BoundPredicate(predicate) => {\n-                        // FIXME we can also infer bounds on associated types,\n-                        // and should check for them here.\n-                        match predicate.bounded_ty.kind {\n-                            hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => {\n-                                let Res::Def(DefKind::TyParam, def_id) = path.res else {\n-                                    continue\n-                                };\n-                                let index = ty_generics.param_def_id_to_index[&def_id];\n+                let (relevant_lifetimes, bounds, predicate_span, in_where_clause) =\n+                    match where_predicate {\n+                        hir::WherePredicate::RegionPredicate(predicate) => {\n+                            if let Some(Region::EarlyBound(region_def_id)) =\n+                                cx.tcx.named_region(predicate.lifetime.hir_id)\n+                            {\n                                 (\n-                                    Self::lifetimes_outliving_type(inferred_outlives, index),\n+                                    Self::lifetimes_outliving_lifetime(\n+                                        inferred_outlives,\n+                                        region_def_id,\n+                                    ),\n                                     &predicate.bounds,\n                                     predicate.span,\n-                                    predicate.origin == PredicateOrigin::WhereClause,\n+                                    predicate.in_where_clause,\n                                 )\n-                            }\n-                            _ => {\n+                            } else {\n                                 continue;\n                             }\n                         }\n-                    }\n-                    _ => continue,\n-                };\n+                        hir::WherePredicate::BoundPredicate(predicate) => {\n+                            // FIXME we can also infer bounds on associated types,\n+                            // and should check for them here.\n+                            match predicate.bounded_ty.kind {\n+                                hir::TyKind::Path(hir::QPath::Resolved(None, path)) => {\n+                                    let Res::Def(DefKind::TyParam, def_id) = path.res else {\n+                                    continue;\n+                                };\n+                                    let index = ty_generics.param_def_id_to_index[&def_id];\n+                                    (\n+                                        Self::lifetimes_outliving_type(inferred_outlives, index),\n+                                        &predicate.bounds,\n+                                        predicate.span,\n+                                        predicate.origin == PredicateOrigin::WhereClause,\n+                                    )\n+                                }\n+                                _ => {\n+                                    continue;\n+                                }\n+                            }\n+                        }\n+                        _ => continue,\n+                    };\n                 if relevant_lifetimes.is_empty() {\n                     continue;\n                 }\n \n-                let bound_spans =\n-                    self.collect_outlives_bound_spans(cx.tcx, bounds, &relevant_lifetimes);\n+                let bound_spans = self.collect_outlives_bound_spans(\n+                    cx.tcx,\n+                    bounds,\n+                    &relevant_lifetimes,\n+                    predicate_span,\n+                );\n                 bound_count += bound_spans.len();\n \n                 let drop_predicate = bound_spans.len() == bounds.len();\n@@ -2345,15 +2356,15 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                 }\n \n                 if drop_predicate && !in_where_clause {\n-                    lint_spans.push(span);\n+                    lint_spans.push(predicate_span);\n                 } else if drop_predicate && i + 1 < num_predicates {\n                     // If all the bounds on a predicate were inferable and there are\n                     // further predicates, we want to eat the trailing comma.\n                     let next_predicate_span = hir_generics.predicates[i + 1].span();\n-                    where_lint_spans.push(span.to(next_predicate_span.shrink_to_lo()));\n+                    where_lint_spans.push(predicate_span.to(next_predicate_span.shrink_to_lo()));\n                 } else {\n                     where_lint_spans.extend(self.consolidate_outlives_bound_spans(\n-                        span.shrink_to_lo(),\n+                        predicate_span.shrink_to_lo(),\n                         bounds,\n                         bound_spans,\n                     ));\n@@ -2374,24 +2385,35 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                     } else {\n                         hir_generics.span.shrink_to_hi().to(where_span)\n                     };\n-                lint_spans.push(full_where_span);\n+\n+                // Due to macro expansions, the `full_where_span` might not actually contain all predicates.\n+                if where_lint_spans.iter().all(|&sp| full_where_span.contains(sp)) {\n+                    lint_spans.push(full_where_span);\n+                } else {\n+                    lint_spans.extend(where_lint_spans);\n+                }\n             } else {\n                 lint_spans.extend(where_lint_spans);\n             }\n \n             if !lint_spans.is_empty() {\n+                // Do not automatically delete outlives requirements from macros.\n+                let applicability = if lint_spans.iter().all(|sp| sp.can_be_used_for_suggestions())\n+                {\n+                    Applicability::MachineApplicable\n+                } else {\n+                    Applicability::MaybeIncorrect\n+                };\n+\n                 cx.struct_span_lint(\n                     EXPLICIT_OUTLIVES_REQUIREMENTS,\n                     lint_spans.clone(),\n                     fluent::lint_builtin_explicit_outlives,\n                     |lint| {\n                         lint.set_arg(\"count\", bound_count).multipart_suggestion(\n                             fluent::suggestion,\n-                            lint_spans\n-                                .into_iter()\n-                                .map(|span| (span, String::new()))\n-                                .collect::<Vec<_>>(),\n-                            Applicability::MachineApplicable,\n+                            lint_spans.into_iter().map(|span| (span, String::new())).collect(),\n+                            applicability,\n                         )\n                     },\n                 );"}, {"sha": "a633201e3d9ae82091808f6684ebee834eb5434a", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/739d68a76e35b22341d9930bb6338bf202ba05ba/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/739d68a76e35b22341d9930bb6338bf202ba05ba/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=739d68a76e35b22341d9930bb6338bf202ba05ba", "patch": "@@ -160,9 +160,13 @@ pub fn provide(providers: &mut Providers) {\n         } else if let Node::TraitItem(&TraitItem {\n             kind: TraitItemKind::Fn(_, TraitFn::Required(idents)),\n             ..\n+        })\n+        | Node::ForeignItem(&ForeignItem {\n+            kind: ForeignItemKind::Fn(_, idents, _),\n+            ..\n         }) = hir.get(hir_id)\n         {\n-            tcx.arena.alloc_slice(idents)\n+            idents\n         } else {\n             span_bug!(hir.span(hir_id), \"fn_arg_names: unexpected item {:?}\", id);\n         }"}, {"sha": "49e069f58c979040d202ab131e729fd152a875f8", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/739d68a76e35b22341d9930bb6338bf202ba05ba/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/739d68a76e35b22341d9930bb6338bf202ba05ba/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=739d68a76e35b22341d9930bb6338bf202ba05ba", "patch": "@@ -16,7 +16,7 @@ use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, AssocCtxt, BoundKind, FnCtxt, FnKind, Visitor};\n use rustc_ast::*;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n-use rustc_errors::{DiagnosticArgValue, DiagnosticId, IntoDiagnosticArg};\n+use rustc_errors::{Applicability, DiagnosticArgValue, DiagnosticId, IntoDiagnosticArg};\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, DefKind, LifetimeRes, PartialRes, PerNS};\n use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n@@ -536,6 +536,9 @@ struct DiagnosticMetadata<'ast> {\n     in_assignment: Option<&'ast Expr>,\n     is_assign_rhs: bool,\n \n+    /// Used to detect possible `.` -> `..` typo when calling methods.\n+    in_range: Option<(&'ast Expr, &'ast Expr)>,\n+\n     /// If we are currently in a trait object definition. Used to point at the bounds when\n     /// encountering a struct or enum.\n     current_trait_object: Option<&'ast [ast::GenericBound]>,\n@@ -3320,17 +3323,14 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         );\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn smart_resolve_path_fragment(\n         &mut self,\n         qself: &Option<P<QSelf>>,\n         path: &[Segment],\n         source: PathSource<'ast>,\n         finalize: Finalize,\n     ) -> PartialRes {\n-        debug!(\n-            \"smart_resolve_path_fragment(qself={:?}, path={:?}, finalize={:?})\",\n-            qself, path, finalize,\n-        );\n         let ns = source.namespace();\n \n         let Finalize { node_id, path_span, .. } = finalize;\n@@ -3341,8 +3341,28 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n                 let def_id = this.parent_scope.module.nearest_parent_mod();\n                 let instead = res.is_some();\n-                let suggestion =\n-                    if res.is_none() { this.report_missing_type_error(path) } else { None };\n+                let suggestion = if let Some((start, end)) = this.diagnostic_metadata.in_range\n+                    && path[0].ident.span.lo() == end.span.lo()\n+                {\n+                    let mut sugg = \".\";\n+                    let mut span = start.span.between(end.span);\n+                    if span.lo() + BytePos(2) == span.hi() {\n+                        // There's no space between the start, the range op and the end, suggest\n+                        // removal which will look better.\n+                        span = span.with_lo(span.lo() + BytePos(1));\n+                        sugg = \"\";\n+                    }\n+                    Some((\n+                        span,\n+                        \"you might have meant to write `.` instead of `..`\",\n+                        sugg.to_string(),\n+                        Applicability::MaybeIncorrect,\n+                    ))\n+                } else if res.is_none() {\n+                    this.report_missing_type_error(path)\n+                } else {\n+                    None\n+                };\n \n                 this.r.use_injections.push(UseError {\n                     err,\n@@ -4005,6 +4025,12 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 self.visit_expr(rhs);\n                 self.diagnostic_metadata.is_assign_rhs = false;\n             }\n+            ExprKind::Range(Some(ref start), Some(ref end), RangeLimits::HalfOpen) => {\n+                self.diagnostic_metadata.in_range = Some((start, end));\n+                self.resolve_expr(start, Some(expr));\n+                self.resolve_expr(end, Some(expr));\n+                self.diagnostic_metadata.in_range = None;\n+            }\n             _ => {\n                 visit::walk_expr(self, expr);\n             }"}, {"sha": "bee4b0a2332b55022ef570f0a6cb102b93de9b92", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/739d68a76e35b22341d9930bb6338bf202ba05ba/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/739d68a76e35b22341d9930bb6338bf202ba05ba/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=739d68a76e35b22341d9930bb6338bf202ba05ba", "patch": "@@ -796,6 +796,9 @@ impl Span {\n \n     /// Returns a `Span` that would enclose both `self` and `end`.\n     ///\n+    /// Note that this can also be used to extend the span \"backwards\":\n+    /// `start.to(end)` and `end.to(start)` return the same `Span`.\n+    ///\n     /// ```text\n     ///     ____             ___\n     ///     self lorem ipsum end"}, {"sha": "1028bb981b9b59ad915873ee1b287fa1399a8faf", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/739d68a76e35b22341d9930bb6338bf202ba05ba/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/739d68a76e35b22341d9930bb6338bf202ba05ba/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=739d68a76e35b22341d9930bb6338bf202ba05ba", "patch": "@@ -166,7 +166,7 @@ mod spec_extend;\n /// vec[0] = 7;\n /// assert_eq!(vec[0], 7);\n ///\n-/// vec.extend([1, 2, 3].iter().copied());\n+/// vec.extend([1, 2, 3]);\n ///\n /// for x in &vec {\n ///     println!(\"{x}\");"}, {"sha": "ba93165cf53a2d3d989c13f2fa88664ea2257856", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/739d68a76e35b22341d9930bb6338bf202ba05ba/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/739d68a76e35b22341d9930bb6338bf202ba05ba/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=739d68a76e35b22341d9930bb6338bf202ba05ba", "patch": "@@ -1783,7 +1783,7 @@ impl<T: ?Sized + fmt::Display> fmt::Display for RefMut<'_, T> {\n /// until the reference expires. As a special exception, given an `&T`, any part of it that is\n /// inside an `UnsafeCell<_>` may be deallocated during the lifetime of the reference, after the\n /// last time the reference is used (dereferenced or reborrowed). Since you cannot deallocate a part\n-/// of what a reference points to, this means the memory an `&T` points to can be deallocted only if\n+/// of what a reference points to, this means the memory an `&T` points to can be deallocated only if\n /// *every part of it* (including padding) is inside an `UnsafeCell`.\n ///\n ///     However, whenever a `&UnsafeCell<T>` is constructed or dereferenced, it must still point to"}, {"sha": "19f80daef1d3bc99c162d5ad00d396c6d181b4ce", "filename": "library/core/src/cell/lazy.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/739d68a76e35b22341d9930bb6338bf202ba05ba/library%2Fcore%2Fsrc%2Fcell%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/739d68a76e35b22341d9930bb6338bf202ba05ba/library%2Fcore%2Fsrc%2Fcell%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell%2Flazy.rs?ref=739d68a76e35b22341d9930bb6338bf202ba05ba", "patch": "@@ -35,7 +35,7 @@ pub struct LazyCell<T, F = fn() -> T> {\n     init: Cell<Option<F>>,\n }\n \n-impl<T, F> LazyCell<T, F> {\n+impl<T, F: FnOnce() -> T> LazyCell<T, F> {\n     /// Creates a new lazy value with the given initializing function.\n     ///\n     /// # Examples\n@@ -55,9 +55,7 @@ impl<T, F> LazyCell<T, F> {\n     pub const fn new(init: F) -> LazyCell<T, F> {\n         LazyCell { cell: OnceCell::new(), init: Cell::new(Some(init)) }\n     }\n-}\n \n-impl<T, F: FnOnce() -> T> LazyCell<T, F> {\n     /// Forces the evaluation of this lazy value and returns a reference to\n     /// the result.\n     ///"}, {"sha": "08abb0b0d924b5dadcdafaa4bc685a70b47abe46", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/739d68a76e35b22341d9930bb6338bf202ba05ba/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/739d68a76e35b22341d9930bb6338bf202ba05ba/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=739d68a76e35b22341d9930bb6338bf202ba05ba", "patch": "@@ -803,7 +803,7 @@ pub trait Iterator {\n     /// (0..5).map(|x| x * 2 + 1)\n     ///       .for_each(move |x| tx.send(x).unwrap());\n     ///\n-    /// let v: Vec<_> =  rx.iter().collect();\n+    /// let v: Vec<_> = rx.iter().collect();\n     /// assert_eq!(v, vec![1, 3, 5, 7, 9]);\n     /// ```\n     ///"}, {"sha": "c7c3c479b71db92af495eaa0407940efcdd622e9", "filename": "library/core/tests/lazy.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/739d68a76e35b22341d9930bb6338bf202ba05ba/library%2Fcore%2Ftests%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/739d68a76e35b22341d9930bb6338bf202ba05ba/library%2Fcore%2Ftests%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flazy.rs?ref=739d68a76e35b22341d9930bb6338bf202ba05ba", "patch": "@@ -106,6 +106,12 @@ fn lazy_new() {\n     assert_eq!(called.get(), 1);\n }\n \n+// Check that we can infer `T` from closure's type.\n+#[test]\n+fn lazy_type_inference() {\n+    let _ = LazyCell::new(|| ());\n+}\n+\n #[test]\n fn aliasing_in_get() {\n     let x = OnceCell::new();"}, {"sha": "bf5a716fa03898dd344a31c46a89a2d643dcf226", "filename": "library/std/src/sync/lazy_lock.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/739d68a76e35b22341d9930bb6338bf202ba05ba/library%2Fstd%2Fsrc%2Fsync%2Flazy_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/739d68a76e35b22341d9930bb6338bf202ba05ba/library%2Fstd%2Fsrc%2Fsync%2Flazy_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Flazy_lock.rs?ref=739d68a76e35b22341d9930bb6338bf202ba05ba", "patch": "@@ -46,17 +46,14 @@ pub struct LazyLock<T, F = fn() -> T> {\n     cell: OnceLock<T>,\n     init: Cell<Option<F>>,\n }\n-\n-impl<T, F> LazyLock<T, F> {\n+impl<T, F: FnOnce() -> T> LazyLock<T, F> {\n     /// Creates a new lazy value with the given initializing\n     /// function.\n     #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub const fn new(f: F) -> LazyLock<T, F> {\n         LazyLock { cell: OnceLock::new(), init: Cell::new(Some(f)) }\n     }\n-}\n \n-impl<T, F: FnOnce() -> T> LazyLock<T, F> {\n     /// Forces the evaluation of this lazy value and\n     /// returns a reference to result. This is equivalent\n     /// to the `Deref` impl, but is explicit."}, {"sha": "a5d4e25c5962a77885dcc906e5a7e8ae4babbc45", "filename": "library/std/src/sync/lazy_lock/tests.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/739d68a76e35b22341d9930bb6338bf202ba05ba/library%2Fstd%2Fsrc%2Fsync%2Flazy_lock%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/739d68a76e35b22341d9930bb6338bf202ba05ba/library%2Fstd%2Fsrc%2Fsync%2Flazy_lock%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Flazy_lock%2Ftests.rs?ref=739d68a76e35b22341d9930bb6338bf202ba05ba", "patch": "@@ -136,6 +136,12 @@ fn sync_lazy_poisoning() {\n     }\n }\n \n+// Check that we can infer `T` from closure's type.\n+#[test]\n+fn lazy_type_inference() {\n+    let _ = LazyCell::new(|| ());\n+}\n+\n #[test]\n fn is_sync_send() {\n     fn assert_traits<T: Send + Sync>() {}"}, {"sha": "8ecf05f0e121f7316fc9301b59f5227239f0436a", "filename": "src/doc/rustdoc/src/write-documentation/the-doc-attribute.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/739d68a76e35b22341d9930bb6338bf202ba05ba/src%2Fdoc%2Frustdoc%2Fsrc%2Fwrite-documentation%2Fthe-doc-attribute.md", "raw_url": "https://github.com/rust-lang/rust/raw/739d68a76e35b22341d9930bb6338bf202ba05ba/src%2Fdoc%2Frustdoc%2Fsrc%2Fwrite-documentation%2Fthe-doc-attribute.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fwrite-documentation%2Fthe-doc-attribute.md?ref=739d68a76e35b22341d9930bb6338bf202ba05ba", "patch": "@@ -9,11 +9,11 @@ are the same:\n \n ```rust,no_run\n /// This is a doc comment.\n-#[doc = \" This is a doc comment.\"]\n+#[doc = r\" This is a doc comment.\"]\n # fn f() {}\n ```\n \n-(Note the leading space in the attribute version.)\n+(Note the leading space and the raw string literal in the attribute version.)\n \n In most cases, `///` is easier to use than `#[doc]`. One case where the latter is easier is\n when generating documentation in macros; the `collapse-docs` pass will combine multiple"}, {"sha": "6c925a3d653c776f4e39c970d822d9ba069ba8a4", "filename": "src/test/ui/argument-suggestions/extern-fn-arg-names.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/739d68a76e35b22341d9930bb6338bf202ba05ba/src%2Ftest%2Fui%2Fargument-suggestions%2Fextern-fn-arg-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/739d68a76e35b22341d9930bb6338bf202ba05ba/src%2Ftest%2Fui%2Fargument-suggestions%2Fextern-fn-arg-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fargument-suggestions%2Fextern-fn-arg-names.rs?ref=739d68a76e35b22341d9930bb6338bf202ba05ba", "patch": "@@ -0,0 +1,9 @@\n+extern \"Rust\" {\n+    fn dstfn(src: i32, dst: err);\n+    //~^ ERROR cannot find type `err` in this scope\n+}\n+\n+fn main() {\n+    dstfn(1);\n+    //~^ ERROR this function takes 2 arguments but 1 argument was supplied\n+}"}, {"sha": "f6bc84c1203ad65f36ce3ddd39a895e74dd12bcd", "filename": "src/test/ui/argument-suggestions/extern-fn-arg-names.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/739d68a76e35b22341d9930bb6338bf202ba05ba/src%2Ftest%2Fui%2Fargument-suggestions%2Fextern-fn-arg-names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/739d68a76e35b22341d9930bb6338bf202ba05ba/src%2Ftest%2Fui%2Fargument-suggestions%2Fextern-fn-arg-names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fargument-suggestions%2Fextern-fn-arg-names.stderr?ref=739d68a76e35b22341d9930bb6338bf202ba05ba", "patch": "@@ -0,0 +1,26 @@\n+error[E0412]: cannot find type `err` in this scope\n+  --> $DIR/extern-fn-arg-names.rs:2:29\n+   |\n+LL |     fn dstfn(src: i32, dst: err);\n+   |                             ^^^ not found in this scope\n+\n+error[E0061]: this function takes 2 arguments but 1 argument was supplied\n+  --> $DIR/extern-fn-arg-names.rs:7:5\n+   |\n+LL |     dstfn(1);\n+   |     ^^^^^--- an argument is missing\n+   |\n+note: function defined here\n+  --> $DIR/extern-fn-arg-names.rs:2:8\n+   |\n+LL |     fn dstfn(src: i32, dst: err);\n+   |        ^^^^^\n+help: provide the argument\n+   |\n+LL |     dstfn(1, /* dst */);\n+   |          ~~~~~~~~~~~~~~\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0061, E0412.\n+For more information about an error, try `rustc --explain E0061`."}, {"sha": "8cdb08e81b907510778ca216879214f4a7df3990", "filename": "src/test/ui/rust-2018/edition-lint-infer-outlives-macro.fixed", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/739d68a76e35b22341d9930bb6338bf202ba05ba/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/739d68a76e35b22341d9930bb6338bf202ba05ba/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.fixed?ref=739d68a76e35b22341d9930bb6338bf202ba05ba", "patch": "@@ -0,0 +1,137 @@\n+// edition:2018\n+// aux-build:edition-lint-infer-outlives-macro.rs\n+// run-rustfix\n+\n+#![deny(explicit_outlives_requirements)]\n+#![allow(dead_code)]\n+\n+#[macro_use]\n+extern crate edition_lint_infer_outlives_macro;\n+\n+// Test that the lint does not fire if the predicate is from the local crate,\n+// but all the bounds are from an external macro.\n+macro_rules! make_foo {\n+    ($a:tt) => {\n+        struct Foo<$a, 'b: $a> {\n+            foo: &$a &'b (),\n+        }\n+\n+        struct FooWhere<$a, 'b> where 'b: $a {\n+            foo: &$a &'b (),\n+        }\n+    }\n+}\n+\n+gimme_a! {make_foo!}\n+\n+struct Bar<'a, 'b> {\n+    //~^ ERROR: outlives requirements can be inferred\n+    bar: &'a &'b (),\n+}\n+\n+struct BarWhere<'a, 'b> {\n+    //~^ ERROR: outlives requirements can be inferred\n+    bar: &'a &'b (),\n+}\n+\n+// Test that the lint *does* fire if the predicate is contained in a local macro.\n+mod everything_inside {\n+    macro_rules! m {\n+        ('b: 'a) => {\n+            struct Foo<'a, 'b>(&'a &'b ());\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Bar<'a, 'b>(&'a &'b ()) ;\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Baz<'a, 'b>(&'a &'b ()) where (): Sized, ;\n+            //~^ ERROR: outlives requirements can be inferred\n+        };\n+    }\n+    m!('b: 'a);\n+}\n+\n+mod inner_lifetime_outside_colon_inside {\n+    macro_rules! m {\n+        ($b:lifetime: 'a) => {\n+            struct Foo<'a, $b>(&'a &$b ());\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Bar<'a, $b>(&'a &$b ()) ;\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Baz<'a, $b>(&'a &$b ()) where (): Sized, ;\n+            //~^ ERROR: outlives requirements can be inferred\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+mod outer_lifetime_outside_colon_inside {\n+    macro_rules! m {\n+        ('b: $a:lifetime) => {\n+            struct Foo<$a, 'b: $a>(&$a &'b ());\n+            struct Bar<$a, 'b>(&$a &'b ()) where 'b: $a;\n+            struct Baz<$a, 'b>(&$a &'b ()) where (): Sized, 'b: $a;\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+mod both_lifetimes_outside_colon_inside {\n+    macro_rules! m {\n+        ($b:lifetime: $a:lifetime) => {\n+            struct Foo<$a, $b: $a>(&$a &$b ());\n+            struct Bar<$a, $b>(&$a &$b ()) where $b: $a;\n+            struct Baz<$a, $b>(&$a &$b ()) where (): Sized, $b: $a;\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+mod everything_outside {\n+    macro_rules! m {\n+        ($b:lifetime $colon:tt $a:lifetime) => {\n+            struct Foo<$a, $b $colon $a>(&$a &$b ());\n+            struct Bar<$a, $b>(&$a &$b ()) where $b $colon $a;\n+            struct Baz<$a, $b>(&$a &$b ()) where (): Sized, $b $colon $a;\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+mod everything_outside_with_tt_inner {\n+    macro_rules! m {\n+        ($b:tt $colon:tt $a:lifetime) => {\n+            struct Foo<$a, $b $colon $a>(&$a &$b ());\n+            struct Bar<$a, $b>(&$a &$b ()) where $b $colon $a;\n+            struct Baz<$a, $b>(&$a &$b ()) where (): Sized, $b $colon $a;\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+// FIXME: These should be consistent.\n+mod everything_outside_with_tt_outer {\n+    macro_rules! m {\n+        ($b:lifetime $colon:tt $a:tt) => {\n+            struct Foo<$a, $b >(&$a &$b ());\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Bar<$a, $b>(&$a &$b ()) where $b $colon $a;\n+            struct Baz<$a, $b>(&$a &$b ()) where (): Sized, $b $colon $a;\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+mod everything_outside_with_tt_both {\n+    macro_rules! m {\n+        ($b:tt $colon:tt $a:tt) => {\n+            struct Foo<$a, $b >(&$a &$b ());\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Bar<$a, $b>(&$a &$b ()) where ;\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Baz<$a, $b>(&$a &$b ()) where (): Sized, ;\n+            //~^ ERROR: outlives requirements can be inferred\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+fn main() {}"}, {"sha": "647906c2dc228366e713dc40217f98e907d5a8b1", "filename": "src/test/ui/rust-2018/edition-lint-infer-outlives-macro.rs", "status": "modified", "additions": 114, "deletions": 5, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/739d68a76e35b22341d9930bb6338bf202ba05ba/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/739d68a76e35b22341d9930bb6338bf202ba05ba/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.rs?ref=739d68a76e35b22341d9930bb6338bf202ba05ba", "patch": "@@ -1,18 +1,22 @@\n // edition:2018\n // aux-build:edition-lint-infer-outlives-macro.rs\n-\n-// Test that the lint does not fire if the where predicate\n-// is from the local crate, but all the bounds are from an\n-// external macro.\n+// run-rustfix\n \n #![deny(explicit_outlives_requirements)]\n+#![allow(dead_code)]\n \n #[macro_use]\n extern crate edition_lint_infer_outlives_macro;\n \n+// Test that the lint does not fire if the predicate is from the local crate,\n+// but all the bounds are from an external macro.\n macro_rules! make_foo {\n     ($a:tt) => {\n-        struct Foo<$a, 'b> where 'b: $a {\n+        struct Foo<$a, 'b: $a> {\n+            foo: &$a &'b (),\n+        }\n+\n+        struct FooWhere<$a, 'b> where 'b: $a {\n             foo: &$a &'b (),\n         }\n     }\n@@ -25,4 +29,109 @@ struct Bar<'a, 'b: 'a> {\n     bar: &'a &'b (),\n }\n \n+struct BarWhere<'a, 'b> where 'b: 'a {\n+    //~^ ERROR: outlives requirements can be inferred\n+    bar: &'a &'b (),\n+}\n+\n+// Test that the lint *does* fire if the predicate is contained in a local macro.\n+mod everything_inside {\n+    macro_rules! m {\n+        ('b: 'a) => {\n+            struct Foo<'a, 'b: 'a>(&'a &'b ());\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Bar<'a, 'b>(&'a &'b ()) where 'b: 'a;\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Baz<'a, 'b>(&'a &'b ()) where (): Sized, 'b: 'a;\n+            //~^ ERROR: outlives requirements can be inferred\n+        };\n+    }\n+    m!('b: 'a);\n+}\n+\n+mod inner_lifetime_outside_colon_inside {\n+    macro_rules! m {\n+        ($b:lifetime: 'a) => {\n+            struct Foo<'a, $b: 'a>(&'a &$b ());\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Bar<'a, $b>(&'a &$b ()) where $b: 'a;\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Baz<'a, $b>(&'a &$b ()) where (): Sized, $b: 'a;\n+            //~^ ERROR: outlives requirements can be inferred\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+mod outer_lifetime_outside_colon_inside {\n+    macro_rules! m {\n+        ('b: $a:lifetime) => {\n+            struct Foo<$a, 'b: $a>(&$a &'b ());\n+            struct Bar<$a, 'b>(&$a &'b ()) where 'b: $a;\n+            struct Baz<$a, 'b>(&$a &'b ()) where (): Sized, 'b: $a;\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+mod both_lifetimes_outside_colon_inside {\n+    macro_rules! m {\n+        ($b:lifetime: $a:lifetime) => {\n+            struct Foo<$a, $b: $a>(&$a &$b ());\n+            struct Bar<$a, $b>(&$a &$b ()) where $b: $a;\n+            struct Baz<$a, $b>(&$a &$b ()) where (): Sized, $b: $a;\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+mod everything_outside {\n+    macro_rules! m {\n+        ($b:lifetime $colon:tt $a:lifetime) => {\n+            struct Foo<$a, $b $colon $a>(&$a &$b ());\n+            struct Bar<$a, $b>(&$a &$b ()) where $b $colon $a;\n+            struct Baz<$a, $b>(&$a &$b ()) where (): Sized, $b $colon $a;\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+mod everything_outside_with_tt_inner {\n+    macro_rules! m {\n+        ($b:tt $colon:tt $a:lifetime) => {\n+            struct Foo<$a, $b $colon $a>(&$a &$b ());\n+            struct Bar<$a, $b>(&$a &$b ()) where $b $colon $a;\n+            struct Baz<$a, $b>(&$a &$b ()) where (): Sized, $b $colon $a;\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+// FIXME: These should be consistent.\n+mod everything_outside_with_tt_outer {\n+    macro_rules! m {\n+        ($b:lifetime $colon:tt $a:tt) => {\n+            struct Foo<$a, $b $colon $a>(&$a &$b ());\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Bar<$a, $b>(&$a &$b ()) where $b $colon $a;\n+            struct Baz<$a, $b>(&$a &$b ()) where (): Sized, $b $colon $a;\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+mod everything_outside_with_tt_both {\n+    macro_rules! m {\n+        ($b:tt $colon:tt $a:tt) => {\n+            struct Foo<$a, $b $colon $a>(&$a &$b ());\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Bar<$a, $b>(&$a &$b ()) where $b $colon $a;\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Baz<$a, $b>(&$a &$b ()) where (): Sized, $b $colon $a;\n+            //~^ ERROR: outlives requirements can be inferred\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n fn main() {}"}, {"sha": "734ae687978936e022a177b7be164aee75d60f4a", "filename": "src/test/ui/rust-2018/edition-lint-infer-outlives-macro.stderr", "status": "modified", "additions": 99, "deletions": 3, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/739d68a76e35b22341d9930bb6338bf202ba05ba/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/739d68a76e35b22341d9930bb6338bf202ba05ba/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.stderr?ref=739d68a76e35b22341d9930bb6338bf202ba05ba", "patch": "@@ -1,14 +1,110 @@\n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives-macro.rs:23:18\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:27:18\n    |\n LL | struct Bar<'a, 'b: 'a> {\n    |                  ^^^^ help: remove this bound\n    |\n note: the lint level is defined here\n-  --> $DIR/edition-lint-infer-outlives-macro.rs:8:9\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:5:9\n    |\n LL | #![deny(explicit_outlives_requirements)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:32:24\n+   |\n+LL | struct BarWhere<'a, 'b> where 'b: 'a {\n+   |                        ^^^^^^^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:41:30\n+   |\n+LL |             struct Foo<'a, 'b: 'a>(&'a &'b ());\n+   |                              ^^^^ help: remove this bound\n+...\n+LL |     m!('b: 'a);\n+   |     ---------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `m` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:43:44\n+   |\n+LL |             struct Bar<'a, 'b>(&'a &'b ()) where 'b: 'a;\n+   |                                            ^^^^^^^^^^^^ help: remove this bound\n+...\n+LL |     m!('b: 'a);\n+   |     ---------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `m` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:45:61\n+   |\n+LL |             struct Baz<'a, 'b>(&'a &'b ()) where (): Sized, 'b: 'a;\n+   |                                                             ^^^^^^ help: remove this bound\n+...\n+LL |     m!('b: 'a);\n+   |     ---------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `m` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:55:30\n+   |\n+LL |             struct Foo<'a, $b: 'a>(&'a &$b ());\n+   |                              ^^^^ help: remove this bound\n+...\n+LL |     m!('b: 'a);\n+   |     ---------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `m` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:57:44\n+   |\n+LL |             struct Bar<'a, $b>(&'a &$b ()) where $b: 'a;\n+   |                                            ^^^^^^^^^^^^ help: remove this bound\n+...\n+LL |     m!('b: 'a);\n+   |     ---------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `m` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:59:61\n+   |\n+LL |             struct Baz<'a, $b>(&'a &$b ()) where (): Sized, $b: 'a;\n+   |                                                             ^^^^^^ help: remove this bound\n+...\n+LL |     m!('b: 'a);\n+   |     ---------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `m` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:114:31\n+   |\n+LL |             struct Foo<$a, $b $colon $a>(&$a &$b ());\n+   |                               ^^^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:126:31\n+   |\n+LL |             struct Foo<$a, $b $colon $a>(&$a &$b ());\n+   |                               ^^^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:128:50\n+   |\n+LL |             struct Bar<$a, $b>(&$a &$b ()) where $b $colon $a;\n+   |                                                  ^^^^^^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:130:61\n+   |\n+LL |             struct Baz<$a, $b>(&$a &$b ()) where (): Sized, $b $colon $a;\n+   |                                                             ^^^^^^^^^^^^ help: remove this bound\n+\n+error: aborting due to 12 previous errors\n "}, {"sha": "cd6fdbde96c0c2d5519485a7d1dba7f7fc35457f", "filename": "src/test/ui/suggestions/bad-hex-float-lit.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/739d68a76e35b22341d9930bb6338bf202ba05ba/src%2Ftest%2Fui%2Fsuggestions%2Fbad-hex-float-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/739d68a76e35b22341d9930bb6338bf202ba05ba/src%2Ftest%2Fui%2Fsuggestions%2Fbad-hex-float-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fbad-hex-float-lit.rs?ref=739d68a76e35b22341d9930bb6338bf202ba05ba", "patch": "@@ -0,0 +1,13 @@\n+fn main() {\n+    let _f: f32 = 0xAAf32;\n+    //~^ ERROR mismatched types\n+    //~| HELP rewrite this\n+\n+    let _f: f32 = 0xAB_f32;\n+    //~^ ERROR mismatched types\n+    //~| HELP rewrite this\n+\n+    let _f: f64 = 0xFF_f64;\n+    //~^ ERROR mismatched types\n+    //~| HELP rewrite this\n+}"}, {"sha": "bc09abb1a5671732978059f89b91e7fdf2c93d03", "filename": "src/test/ui/suggestions/bad-hex-float-lit.stderr", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/739d68a76e35b22341d9930bb6338bf202ba05ba/src%2Ftest%2Fui%2Fsuggestions%2Fbad-hex-float-lit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/739d68a76e35b22341d9930bb6338bf202ba05ba/src%2Ftest%2Fui%2Fsuggestions%2Fbad-hex-float-lit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fbad-hex-float-lit.stderr?ref=739d68a76e35b22341d9930bb6338bf202ba05ba", "patch": "@@ -0,0 +1,48 @@\n+error[E0308]: mismatched types\n+  --> $DIR/bad-hex-float-lit.rs:2:19\n+   |\n+LL |     let _f: f32 = 0xAAf32;\n+   |             ---   ^^^^^^^ expected `f32`, found integer\n+   |             |\n+   |             expected due to this\n+   |\n+help: rewrite this as a decimal floating point literal, or use `as` to turn a hex literal into a float\n+   |\n+LL |     let _f: f32 = 0xAA as f32;\n+   |                   ~~~~~~~~~~~\n+LL |     let _f: f32 = 170_f32;\n+   |                   ~~~~~~~\n+\n+error[E0308]: mismatched types\n+  --> $DIR/bad-hex-float-lit.rs:6:19\n+   |\n+LL |     let _f: f32 = 0xAB_f32;\n+   |             ---   ^^^^^^^^ expected `f32`, found integer\n+   |             |\n+   |             expected due to this\n+   |\n+help: rewrite this as a decimal floating point literal, or use `as` to turn a hex literal into a float\n+   |\n+LL |     let _f: f32 = 0xAB as f32;\n+   |                   ~~~~~~~~~~~\n+LL |     let _f: f32 = 171_f32;\n+   |                   ~~~~~~~\n+\n+error[E0308]: mismatched types\n+  --> $DIR/bad-hex-float-lit.rs:10:19\n+   |\n+LL |     let _f: f64 = 0xFF_f64;\n+   |             ---   ^^^^^^^^ expected `f64`, found integer\n+   |             |\n+   |             expected due to this\n+   |\n+help: rewrite this as a decimal floating point literal, or use `as` to turn a hex literal into a float\n+   |\n+LL |     let _f: f64 = 0xFF as f64;\n+   |                   ~~~~~~~~~~~\n+LL |     let _f: f64 = 255_f64;\n+   |                   ~~~~~~~\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "ac662edafe6b010d3c10a81524a2920ab48b0986", "filename": "src/test/ui/suggestions/method-access-to-range-literal-typo.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/739d68a76e35b22341d9930bb6338bf202ba05ba/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-access-to-range-literal-typo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/739d68a76e35b22341d9930bb6338bf202ba05ba/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-access-to-range-literal-typo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-access-to-range-literal-typo.rs?ref=739d68a76e35b22341d9930bb6338bf202ba05ba", "patch": "@@ -0,0 +1,30 @@\n+fn as_ref() -> Option<Vec<u8>> {\n+    None\n+}\n+struct Type {\n+    option: Option<Vec<u8>>\n+}\n+trait Trait {\n+    fn foo(&self) -> Vec<u8>;\n+}\n+impl Trait for Option<Vec<u8>> {\n+    fn foo(&self) -> Vec<u8> {\n+        vec![1, 2, 3]\n+    }\n+}\n+\n+impl Type {\n+    fn method(&self) -> Option<Vec<u8>> {\n+        self.option..as_ref().map(|x| x)\n+        //~^ ERROR E0308\n+    }\n+    fn method2(&self) -> &u8 {\n+        self.option..foo().get(0)\n+        //~^ ERROR E0425\n+        //~| ERROR E0308\n+    }\n+}\n+\n+fn main() {\n+    let _ = Type { option: None }.method();\n+}"}, {"sha": "c84f94678914f5917bbeda9709bbd93f65c6bbfe", "filename": "src/test/ui/suggestions/method-access-to-range-literal-typo.stderr", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/739d68a76e35b22341d9930bb6338bf202ba05ba/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-access-to-range-literal-typo.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/739d68a76e35b22341d9930bb6338bf202ba05ba/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-access-to-range-literal-typo.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-access-to-range-literal-typo.stderr?ref=739d68a76e35b22341d9930bb6338bf202ba05ba", "patch": "@@ -0,0 +1,48 @@\n+error[E0425]: cannot find function `foo` in this scope\n+  --> $DIR/method-access-to-range-literal-typo.rs:22:22\n+   |\n+LL |         self.option..foo().get(0)\n+   |                      ^^^ not found in this scope\n+   |\n+help: you might have meant to write `.` instead of `..`\n+   |\n+LL -         self.option..foo().get(0)\n+LL +         self.option.foo().get(0)\n+   |\n+\n+error[E0308]: mismatched types\n+  --> $DIR/method-access-to-range-literal-typo.rs:18:9\n+   |\n+LL |     fn method(&self) -> Option<Vec<u8>> {\n+   |                         --------------- expected `Option<Vec<u8>>` because of return type\n+LL |         self.option..as_ref().map(|x| x)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found struct `Range`\n+   |\n+   = note: expected enum `Option<_>`\n+            found struct `std::ops::Range<Option<_>>`\n+help: you likely meant to write a method call instead of a range\n+   |\n+LL -         self.option..as_ref().map(|x| x)\n+LL +         self.option.as_ref().map(|x| x)\n+   |\n+\n+error[E0308]: mismatched types\n+  --> $DIR/method-access-to-range-literal-typo.rs:22:9\n+   |\n+LL |     fn method2(&self) -> &u8 {\n+   |                          --- expected `&u8` because of return type\n+LL |         self.option..foo().get(0)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&u8`, found struct `Range`\n+   |\n+   = note: expected reference `&u8`\n+                 found struct `std::ops::Range<Option<Vec<u8>>>`\n+help: you likely meant to write a method call instead of a range\n+   |\n+LL -         self.option..foo().get(0)\n+LL +         self.option.foo().get(0)\n+   |\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0308, E0425.\n+For more information about an error, try `rustc --explain E0308`."}]}