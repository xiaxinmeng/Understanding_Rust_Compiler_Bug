{"sha": "42a3acfdb189cea6c19e6cbc7f1e0786986fecc5", "node_id": "C_kwDOAAsO6NoAKDQyYTNhY2ZkYjE4OWNlYTZjMTllNmNiYzdmMWUwNzg2OTg2ZmVjYzU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-05T10:26:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-05T10:26:07Z"}, "message": "Rollup merge of #92517 - ChrisDenton:explicit-path, r=dtolnay\n\nExplicitly pass `PATH` to the Windows exe resolver\n\nThis allows for testing different `PATH`s without using the actual environment.", "tree": {"sha": "761825bf38aac76684b9e0a0a554443bf527e18d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/761825bf38aac76684b9e0a0a554443bf527e18d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42a3acfdb189cea6c19e6cbc7f1e0786986fecc5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh1XI/CRBK7hj4Ov3rIwAAQk4IAB7WCA5XXsWPxYZCRpEhq5wt\nrnKqwHChHAhf1oDs3wse8Mc8YELBjwuT4qkyKA3Qx6dp7DYPxmns671pheHcvv7A\n0T0U55Xq5vN7SPA3B8uKj3vs2yONC71EpTYW8FHpaDugmG6TOSna01Hg7/zzOmu5\nXZO6LYY9vxuiHtBkNRLxYTzlcJega94zHiuRltxmAx1fR/mzUO8LlncCOEpfSzFr\n80fwPI/Pbv1DmBuNXBXULNXyKGBc3BBV/PJwQFP+Jo+6sMF04Ry//Pldla4NB5Th\nd3UJc3KIcFw13vUUdgLhpmtlkKJL/blDV7R61QGRpUKi9wncFO+dwcj8bQXV2eo=\n=SHrw\n-----END PGP SIGNATURE-----\n", "payload": "tree 761825bf38aac76684b9e0a0a554443bf527e18d\nparent 5bf321f9a42dd0d6492d6a14e46d6c68a29d2e4e\nparent 4145877731e9f38a4640d2dfeed7b123d81d061a\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1641378367 +0100\ncommitter GitHub <noreply@github.com> 1641378367 +0100\n\nRollup merge of #92517 - ChrisDenton:explicit-path, r=dtolnay\n\nExplicitly pass `PATH` to the Windows exe resolver\n\nThis allows for testing different `PATH`s without using the actual environment.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42a3acfdb189cea6c19e6cbc7f1e0786986fecc5", "html_url": "https://github.com/rust-lang/rust/commit/42a3acfdb189cea6c19e6cbc7f1e0786986fecc5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42a3acfdb189cea6c19e6cbc7f1e0786986fecc5/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bf321f9a42dd0d6492d6a14e46d6c68a29d2e4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bf321f9a42dd0d6492d6a14e46d6c68a29d2e4e", "html_url": "https://github.com/rust-lang/rust/commit/5bf321f9a42dd0d6492d6a14e46d6c68a29d2e4e"}, {"sha": "4145877731e9f38a4640d2dfeed7b123d81d061a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4145877731e9f38a4640d2dfeed7b123d81d061a", "html_url": "https://github.com/rust-lang/rust/commit/4145877731e9f38a4640d2dfeed7b123d81d061a"}], "stats": {"total": 70, "additions": 37, "deletions": 33}, "files": [{"sha": "5ad570427978e5244b0d8d9f4af8c9ae3488d77b", "filename": "library/std/src/sys/windows/process.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/42a3acfdb189cea6c19e6cbc7f1e0786986fecc5/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a3acfdb189cea6c19e6cbc7f1e0786986fecc5/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs?ref=42a3acfdb189cea6c19e6cbc7f1e0786986fecc5", "patch": "@@ -268,7 +268,7 @@ impl Command {\n         } else {\n             None\n         };\n-        let program = resolve_exe(&self.program, child_paths)?;\n+        let program = resolve_exe(&self.program, || env::var_os(\"PATH\"), child_paths)?;\n         let mut cmd_str =\n             make_command_line(program.as_os_str(), &self.args, self.force_quotes_enabled)?;\n         cmd_str.push(0); // add null terminator\n@@ -362,7 +362,11 @@ impl fmt::Debug for Command {\n // Therefore this functions first assumes `.exe` was intended.\n // It falls back to the plain file name if a full path is given and the extension is omitted\n // or if only a file name is given and it already contains an extension.\n-fn resolve_exe<'a>(exe_path: &'a OsStr, child_paths: Option<&OsStr>) -> io::Result<PathBuf> {\n+fn resolve_exe<'a>(\n+    exe_path: &'a OsStr,\n+    parent_paths: impl FnOnce() -> Option<OsString>,\n+    child_paths: Option<&OsStr>,\n+) -> io::Result<PathBuf> {\n     // Early return if there is no filename.\n     if exe_path.is_empty() || path::has_trailing_slash(exe_path) {\n         return Err(io::Error::new_const(\n@@ -406,7 +410,7 @@ fn resolve_exe<'a>(exe_path: &'a OsStr, child_paths: Option<&OsStr>) -> io::Resu\n         let has_extension = exe_path.bytes().contains(&b'.');\n \n         // Search the directories given by `search_paths`.\n-        let result = search_paths(child_paths, |mut path| {\n+        let result = search_paths(parent_paths, child_paths, |mut path| {\n             path.push(&exe_path);\n             if !has_extension {\n                 path.set_extension(EXE_EXTENSION);\n@@ -423,15 +427,20 @@ fn resolve_exe<'a>(exe_path: &'a OsStr, child_paths: Option<&OsStr>) -> io::Resu\n \n // Calls `f` for every path that should be used to find an executable.\n // Returns once `f` returns the path to an executable or all paths have been searched.\n-fn search_paths<F>(child_paths: Option<&OsStr>, mut f: F) -> Option<PathBuf>\n+fn search_paths<Paths, Exists>(\n+    parent_paths: Paths,\n+    child_paths: Option<&OsStr>,\n+    mut exists: Exists,\n+) -> Option<PathBuf>\n where\n-    F: FnMut(PathBuf) -> Option<PathBuf>,\n+    Paths: FnOnce() -> Option<OsString>,\n+    Exists: FnMut(PathBuf) -> Option<PathBuf>,\n {\n     // 1. Child paths\n     // This is for consistency with Rust's historic behaviour.\n     if let Some(paths) = child_paths {\n         for path in env::split_paths(paths).filter(|p| !p.as_os_str().is_empty()) {\n-            if let Some(path) = f(path) {\n+            if let Some(path) = exists(path) {\n                 return Some(path);\n             }\n         }\n@@ -440,7 +449,7 @@ where\n     // 2. Application path\n     if let Ok(mut app_path) = env::current_exe() {\n         app_path.pop();\n-        if let Some(path) = f(app_path) {\n+        if let Some(path) = exists(app_path) {\n             return Some(path);\n         }\n     }\n@@ -450,25 +459,25 @@ where\n     unsafe {\n         if let Ok(Some(path)) = super::fill_utf16_buf(\n             |buf, size| c::GetSystemDirectoryW(buf, size),\n-            |buf| f(PathBuf::from(OsString::from_wide(buf))),\n+            |buf| exists(PathBuf::from(OsString::from_wide(buf))),\n         ) {\n             return Some(path);\n         }\n         #[cfg(not(target_vendor = \"uwp\"))]\n         {\n             if let Ok(Some(path)) = super::fill_utf16_buf(\n                 |buf, size| c::GetWindowsDirectoryW(buf, size),\n-                |buf| f(PathBuf::from(OsString::from_wide(buf))),\n+                |buf| exists(PathBuf::from(OsString::from_wide(buf))),\n             ) {\n                 return Some(path);\n             }\n         }\n     }\n \n     // 5. Parent paths\n-    if let Some(parent_paths) = env::var_os(\"PATH\") {\n+    if let Some(parent_paths) = parent_paths() {\n         for path in env::split_paths(&parent_paths).filter(|p| !p.as_os_str().is_empty()) {\n-            if let Some(path) = f(path) {\n+            if let Some(path) = exists(path) {\n                 return Some(path);\n             }\n         }"}, {"sha": "f1221767af30e56d43581d5d48183b27d057e7d3", "filename": "library/std/src/sys/windows/process/tests.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/42a3acfdb189cea6c19e6cbc7f1e0786986fecc5/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a3acfdb189cea6c19e6cbc7f1e0786986fecc5/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess%2Ftests.rs?ref=42a3acfdb189cea6c19e6cbc7f1e0786986fecc5", "patch": "@@ -136,51 +136,46 @@ fn windows_exe_resolver() {\n     use super::resolve_exe;\n     use crate::io;\n \n+    let env_paths = || env::var_os(\"PATH\");\n+\n     // Test a full path, with and without the `exe` extension.\n     let mut current_exe = env::current_exe().unwrap();\n-    assert!(resolve_exe(current_exe.as_ref(), None).is_ok());\n+    assert!(resolve_exe(current_exe.as_ref(), env_paths, None).is_ok());\n     current_exe.set_extension(\"\");\n-    assert!(resolve_exe(current_exe.as_ref(), None).is_ok());\n+    assert!(resolve_exe(current_exe.as_ref(), env_paths, None).is_ok());\n \n     // Test lone file names.\n-    assert!(resolve_exe(OsStr::new(\"cmd\"), None).is_ok());\n-    assert!(resolve_exe(OsStr::new(\"cmd.exe\"), None).is_ok());\n-    assert!(resolve_exe(OsStr::new(\"cmd.EXE\"), None).is_ok());\n-    assert!(resolve_exe(OsStr::new(\"fc\"), None).is_ok());\n+    assert!(resolve_exe(OsStr::new(\"cmd\"), env_paths, None).is_ok());\n+    assert!(resolve_exe(OsStr::new(\"cmd.exe\"), env_paths, None).is_ok());\n+    assert!(resolve_exe(OsStr::new(\"cmd.EXE\"), env_paths, None).is_ok());\n+    assert!(resolve_exe(OsStr::new(\"fc\"), env_paths, None).is_ok());\n \n     // Invalid file names should return InvalidInput.\n-    assert_eq!(resolve_exe(OsStr::new(\"\"), None).unwrap_err().kind(), io::ErrorKind::InvalidInput);\n     assert_eq!(\n-        resolve_exe(OsStr::new(\"\\0\"), None).unwrap_err().kind(),\n+        resolve_exe(OsStr::new(\"\"), env_paths, None).unwrap_err().kind(),\n+        io::ErrorKind::InvalidInput\n+    );\n+    assert_eq!(\n+        resolve_exe(OsStr::new(\"\\0\"), env_paths, None).unwrap_err().kind(),\n         io::ErrorKind::InvalidInput\n     );\n     // Trailing slash, therefore there's no file name component.\n     assert_eq!(\n-        resolve_exe(OsStr::new(r\"C:\\Path\\to\\\"), None).unwrap_err().kind(),\n+        resolve_exe(OsStr::new(r\"C:\\Path\\to\\\"), env_paths, None).unwrap_err().kind(),\n         io::ErrorKind::InvalidInput\n     );\n \n-    /* FIXME: fix and re-enable these tests before making changes to the resolver.\n-\n     /*\n     Some of the following tests may need to be changed if you are deliberately\n     changing the behaviour of `resolve_exe`.\n     */\n \n-    let paths = env::var_os(\"PATH\").unwrap();\n-    env::set_var(\"PATH\", \"\");\n-\n-    assert_eq!(resolve_exe(OsStr::new(\"rustc\"), None).unwrap_err().kind(), io::ErrorKind::NotFound);\n-\n-    let child_paths = Some(paths.as_os_str());\n-    assert!(resolve_exe(OsStr::new(\"rustc\"), child_paths).is_ok());\n+    let empty_paths = || None;\n \n     // The resolver looks in system directories even when `PATH` is empty.\n-    assert!(resolve_exe(OsStr::new(\"cmd.exe\"), None).is_ok());\n+    assert!(resolve_exe(OsStr::new(\"cmd.exe\"), empty_paths, None).is_ok());\n \n     // The application's directory is also searched.\n     let current_exe = env::current_exe().unwrap();\n-    assert!(resolve_exe(current_exe.file_name().unwrap().as_ref(), None).is_ok());\n-\n-    */\n+    assert!(resolve_exe(current_exe.file_name().unwrap().as_ref(), empty_paths, None).is_ok());\n }"}]}