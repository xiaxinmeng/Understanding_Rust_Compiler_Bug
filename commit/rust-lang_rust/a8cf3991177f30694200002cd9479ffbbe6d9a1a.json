{"sha": "a8cf3991177f30694200002cd9479ffbbe6d9a1a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4Y2YzOTkxMTc3ZjMwNjk0MjAwMDAyY2Q5NDc5ZmZiYmU2ZDlhMWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-21T17:10:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-21T17:10:09Z"}, "message": "Auto merge of #72936 - jackh726:chalk-more, r=nikomatsakis\n\nUpgrade Chalk\n\nThings done in this PR:\n- Upgrade Chalk to `0.11.0`\n- Added compare-mode=chalk\n- Bump rustc-hash in `librustc_data_structures` to `1.1.0` to match Chalk\n- Removed `RustDefId` since the builtin type support is there\n- Add a few more `FIXME(chalk)`s for problem spots I hit when running all tests with chalk\n- Added some more implementation code for some newer builtin Chalk types (e.g. `FnDef`, `Array`)\n- Lower `RegionOutlives` and `ObjectSafe` predicates\n- Lower `Dyn` without the region\n- Handle `Int`/`Float` `CanonicalVarKind`s\n- Uncomment some Chalk tests that actually work now\n- Remove the revisions in `src/test/ui/coherence/coherence-subtyping.rs` since they aren't doing anything different\n\nr? @nikomatsakis", "tree": {"sha": "f6b483650a05ed5c3f25b19e82cab033b522f0e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6b483650a05ed5c3f25b19e82cab033b522f0e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8cf3991177f30694200002cd9479ffbbe6d9a1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8cf3991177f30694200002cd9479ffbbe6d9a1a", "html_url": "https://github.com/rust-lang/rust/commit/a8cf3991177f30694200002cd9479ffbbe6d9a1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8cf3991177f30694200002cd9479ffbbe6d9a1a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "349f6bfb11d73ebb6a272f9a3d00883484f8218c", "url": "https://api.github.com/repos/rust-lang/rust/commits/349f6bfb11d73ebb6a272f9a3d00883484f8218c", "html_url": "https://github.com/rust-lang/rust/commit/349f6bfb11d73ebb6a272f9a3d00883484f8218c"}, {"sha": "d63195b0bc581837f77a22f46f2aa2303b911e56", "url": "https://api.github.com/repos/rust-lang/rust/commits/d63195b0bc581837f77a22f46f2aa2303b911e56", "html_url": "https://github.com/rust-lang/rust/commit/d63195b0bc581837f77a22f46f2aa2303b911e56"}], "stats": {"total": 1049, "additions": 550, "deletions": 499}, "files": [{"sha": "0c1c533f39579129d205c6475beb8da085966ef6", "filename": "Cargo.lock", "status": "modified", "additions": 20, "deletions": 62, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/a8cf3991177f30694200002cd9479ffbbe6d9a1a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a8cf3991177f30694200002cd9479ffbbe6d9a1a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a8cf3991177f30694200002cd9479ffbbe6d9a1a", "patch": "@@ -434,9 +434,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-derive\"\n-version = \"0.10.0\"\n+version = \"0.11.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8d4620afad4d4d9e63f915cfa10c930b7a3c9c3ca5cd88dd771ff8e5bf04ea10\"\n+checksum = \"5b9bd01eab87277d973183a1d2e56bace1c11f8242c52c20636fb7dddf343ac9\"\n dependencies = [\n  \"proc-macro2 1.0.3\",\n  \"quote 1.0.2\",\n@@ -446,58 +446,35 @@ dependencies = [\n \n [[package]]\n name = \"chalk-engine\"\n-version = \"0.10.0\"\n+version = \"0.11.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6ca6e5cef10197789da0b4ec310eda58da4c55530613b2323432642a97372735\"\n+checksum = \"6c7a637c3d17ed555aef16e16952a5d1e127bd55178cc30be22afeb92da90c7d\"\n dependencies = [\n- \"chalk-macros\",\n+ \"chalk-derive\",\n+ \"chalk-ir\",\n  \"rustc-hash\",\n ]\n \n [[package]]\n name = \"chalk-ir\"\n-version = \"0.10.0\"\n+version = \"0.11.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d45df5fb6328527f976e8a32c9e1c9970084d937ebe93d0d34f5bbf4231cb956\"\n+checksum = \"595e5735ded16c3f3dc348f7b15bbb2521a0080b1863cac38ad5271589944670\"\n dependencies = [\n  \"chalk-derive\",\n- \"chalk-engine\",\n- \"chalk-macros\",\n-]\n-\n-[[package]]\n-name = \"chalk-macros\"\n-version = \"0.10.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9e4782d108e420a1fcf94d8a919cf248db33c5071678e87d9c2d4f20ed1feb32\"\n-dependencies = [\n  \"lazy_static\",\n ]\n \n-[[package]]\n-name = \"chalk-rust-ir\"\n-version = \"0.10.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a0ec96dbe0ab5fdbadfca4179ec2e1d35f0439c3b53a74988b1aec239c63eb08\"\n-dependencies = [\n- \"chalk-derive\",\n- \"chalk-engine\",\n- \"chalk-ir\",\n- \"chalk-macros\",\n-]\n-\n [[package]]\n name = \"chalk-solve\"\n-version = \"0.10.0\"\n+version = \"0.11.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dfb99fa9530f0e101475fb60adc931f51bdea05b4642a48928b814d7f0141a6b\"\n+checksum = \"5d9d938139db425867a30cc0cfec0269406d8238d0571d829041eaa7a8455d11\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-engine\",\n  \"chalk-ir\",\n- \"chalk-macros\",\n- \"chalk-rust-ir\",\n- \"ena 0.13.1\",\n+ \"ena\",\n  \"itertools 0.9.0\",\n  \"petgraph\",\n  \"rustc-hash\",\n@@ -1061,15 +1038,6 @@ dependencies = [\n  \"strum_macros\",\n ]\n \n-[[package]]\n-name = \"ena\"\n-version = \"0.13.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8944dc8fa28ce4a38f778bd46bf7d923fe73eed5a439398507246c8e017e6f36\"\n-dependencies = [\n- \"log\",\n-]\n-\n [[package]]\n name = \"ena\"\n version = \"0.14.0\"\n@@ -1181,9 +1149,9 @@ dependencies = [\n \n [[package]]\n name = \"fixedbitset\"\n-version = \"0.1.9\"\n+version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"86d4de0081402f5e88cdac65c8dcdcc73118c1a7a465e2a05f0da05843a8ea33\"\n+checksum = \"37ab347416e802de484e4d03c7316c48f1ecb56574dfd4a46a80f173ce1de04d\"\n \n [[package]]\n name = \"flate2\"\n@@ -2370,12 +2338,6 @@ dependencies = [\n  \"vcpkg\",\n ]\n \n-[[package]]\n-name = \"ordermap\"\n-version = \"0.3.5\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a86ed3f5f244b372d6b1a00b72ef7f8876d0bc6a78a4c9985c53614041512063\"\n-\n [[package]]\n name = \"ordslice\"\n version = \"0.3.0\"\n@@ -2546,12 +2508,12 @@ dependencies = [\n \n [[package]]\n name = \"petgraph\"\n-version = \"0.4.13\"\n+version = \"0.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9c3659d1ee90221741f65dd128d9998311b0e40c5d3c23a62445938214abce4f\"\n+checksum = \"467d164a6de56270bd7c4d070df81d07beace25012d5103ced4e9ff08d6afdb7\"\n dependencies = [\n  \"fixedbitset\",\n- \"ordermap\",\n+ \"indexmap\",\n ]\n \n [[package]]\n@@ -3292,7 +3254,7 @@ dependencies = [\n  \"bitflags\",\n  \"cfg-if\",\n  \"crossbeam-utils 0.7.2\",\n- \"ena 0.14.0\",\n+ \"ena\",\n  \"indexmap\",\n  \"jobserver\",\n  \"lazy_static\",\n@@ -3501,12 +3463,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-hash\"\n-version = \"1.0.1\"\n+version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7540fc8b0c49f096ee9c961cda096467dce8084bec6bdca2fc83895fd9b28cb8\"\n-dependencies = [\n- \"byteorder\",\n-]\n+checksum = \"08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2\"\n \n [[package]]\n name = \"rustc-main\"\n@@ -3757,7 +3716,7 @@ dependencies = [\n  \"bitflags\",\n  \"cfg-if\",\n  \"crossbeam-utils 0.7.2\",\n- \"ena 0.14.0\",\n+ \"ena\",\n  \"indexmap\",\n  \"jobserver\",\n  \"lazy_static\",\n@@ -4376,7 +4335,6 @@ name = \"rustc_traits\"\n version = \"0.0.0\"\n dependencies = [\n  \"chalk-ir\",\n- \"chalk-rust-ir\",\n  \"chalk-solve\",\n  \"log\",\n  \"rustc_ast\","}, {"sha": "1c2fb90b2d8b47da9f92ee54dee4451087dbd383", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=a8cf3991177f30694200002cd9479ffbbe6d9a1a", "patch": "@@ -23,7 +23,7 @@ crossbeam-utils = { version = \"0.7\", features = [\"nightly\"] }\n stable_deref_trait = \"1.0.0\"\n rayon = { version = \"0.3.0\", package = \"rustc-rayon\" }\n rayon-core = { version = \"0.3.0\", package = \"rustc-rayon-core\" }\n-rustc-hash = \"1.0.1\"\n+rustc-hash = \"1.1.0\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n rustc_index = { path = \"../librustc_index\", package = \"rustc_index\" }\n bitflags = \"1.2.1\""}, {"sha": "21d0b102a4a66dd8e285563a8fc4800d8e945dce", "filename": "src/librustc_middle/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Flibrustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Flibrustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2FCargo.toml?ref=a8cf3991177f30694200002cd9479ffbbe6d9a1a", "patch": "@@ -30,7 +30,7 @@ rustc_serialize = { path = \"../librustc_serialize\" }\n rustc_ast = { path = \"../librustc_ast\" }\n rustc_span = { path = \"../librustc_span\" }\n byteorder = { version = \"1.3\" }\n-chalk-ir = \"0.10.0\"\n+chalk-ir = \"0.11.0\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n measureme = \"0.7.1\"\n rustc_session = { path = \"../librustc_session\" }"}, {"sha": "a49a0045812b051763d8a0c5e581cbbb7c77b029", "filename": "src/librustc_middle/traits/chalk.rs", "status": "modified", "additions": 44, "deletions": 50, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Flibrustc_middle%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Flibrustc_middle%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fchalk.rs?ref=a8cf3991177f30694200002cd9479ffbbe6d9a1a", "patch": "@@ -5,11 +5,9 @@\n //! its name suggest, is to provide an abstraction boundary for creating\n //! interned Chalk types.\n \n-use chalk_ir::{GoalData, Parameter};\n-\n-use rustc_middle::mir::Mutability;\n+use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt};\n \n use rustc_hir::def_id::DefId;\n \n@@ -19,27 +17,6 @@ use std::cmp::Ordering;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n \n-/// Since Chalk doesn't have full support for all Rust builtin types yet, we\n-/// need to use an enum here, rather than just `DefId`.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n-pub enum RustDefId {\n-    Adt(DefId),\n-    Str,\n-    Never,\n-    Slice,\n-    Array,\n-    Ref(Mutability),\n-    RawPtr,\n-\n-    Trait(DefId),\n-\n-    Impl(DefId),\n-\n-    FnDef(DefId),\n-\n-    AssocTy(DefId),\n-}\n-\n #[derive(Copy, Clone)]\n pub struct RustInterner<'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n@@ -86,16 +63,19 @@ impl fmt::Debug for RustInterner<'_> {\n impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n     type InternedType = Box<chalk_ir::TyData<Self>>;\n     type InternedLifetime = Box<chalk_ir::LifetimeData<Self>>;\n-    type InternedParameter = Box<chalk_ir::ParameterData<Self>>;\n+    type InternedConst = Box<chalk_ir::ConstData<Self>>;\n+    type InternedConcreteConst = ConstValue<'tcx>;\n+    type InternedGenericArg = Box<chalk_ir::GenericArgData<Self>>;\n     type InternedGoal = Box<chalk_ir::GoalData<Self>>;\n     type InternedGoals = Vec<chalk_ir::Goal<Self>>;\n-    type InternedSubstitution = Vec<chalk_ir::Parameter<Self>>;\n+    type InternedSubstitution = Vec<chalk_ir::GenericArg<Self>>;\n     type InternedProgramClause = Box<chalk_ir::ProgramClauseData<Self>>;\n     type InternedProgramClauses = Vec<chalk_ir::ProgramClause<Self>>;\n     type InternedQuantifiedWhereClauses = Vec<chalk_ir::QuantifiedWhereClause<Self>>;\n-    type InternedParameterKinds = Vec<chalk_ir::ParameterKind<()>>;\n-    type InternedCanonicalVarKinds = Vec<chalk_ir::ParameterKind<chalk_ir::UniverseIndex>>;\n-    type DefId = RustDefId;\n+    type InternedVariableKinds = Vec<chalk_ir::VariableKind<Self>>;\n+    type InternedCanonicalVarKinds = Vec<chalk_ir::CanonicalVarKind<Self>>;\n+    type DefId = DefId;\n+    type InternedAdtId = &'tcx AdtDef;\n     type Identifier = ();\n \n     fn debug_program_clause_implication(\n@@ -209,25 +189,39 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n         &lifetime\n     }\n \n-    fn intern_parameter(\n+    fn intern_const(&self, constant: chalk_ir::ConstData<Self>) -> Self::InternedConst {\n+        Box::new(constant)\n+    }\n+\n+    fn const_data<'a>(&self, constant: &'a Self::InternedConst) -> &'a chalk_ir::ConstData<Self> {\n+        &constant\n+    }\n+\n+    fn const_eq(\n         &self,\n-        parameter: chalk_ir::ParameterData<Self>,\n-    ) -> Self::InternedParameter {\n-        Box::new(parameter)\n+        _ty: &Self::InternedType,\n+        c1: &Self::InternedConcreteConst,\n+        c2: &Self::InternedConcreteConst,\n+    ) -> bool {\n+        c1 == c2\n+    }\n+\n+    fn intern_generic_arg(&self, data: chalk_ir::GenericArgData<Self>) -> Self::InternedGenericArg {\n+        Box::new(data)\n     }\n \n-    fn parameter_data<'a>(\n+    fn generic_arg_data<'a>(\n         &self,\n-        parameter: &'a Self::InternedParameter,\n-    ) -> &'a chalk_ir::ParameterData<Self> {\n-        &parameter\n+        data: &'a Self::InternedGenericArg,\n+    ) -> &'a chalk_ir::GenericArgData<Self> {\n+        &data\n     }\n \n-    fn intern_goal(&self, goal: GoalData<Self>) -> Self::InternedGoal {\n+    fn intern_goal(&self, goal: chalk_ir::GoalData<Self>) -> Self::InternedGoal {\n         Box::new(goal)\n     }\n \n-    fn goal_data<'a>(&self, goal: &'a Self::InternedGoal) -> &'a GoalData<Self> {\n+    fn goal_data<'a>(&self, goal: &'a Self::InternedGoal) -> &'a chalk_ir::GoalData<Self> {\n         &goal\n     }\n \n@@ -244,15 +238,15 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n \n     fn intern_substitution<E>(\n         &self,\n-        data: impl IntoIterator<Item = Result<chalk_ir::Parameter<Self>, E>>,\n+        data: impl IntoIterator<Item = Result<chalk_ir::GenericArg<Self>, E>>,\n     ) -> Result<Self::InternedSubstitution, E> {\n         data.into_iter().collect::<Result<Vec<_>, _>>()\n     }\n \n     fn substitution_data<'a>(\n         &self,\n         substitution: &'a Self::InternedSubstitution,\n-    ) -> &'a [Parameter<Self>] {\n+    ) -> &'a [chalk_ir::GenericArg<Self>] {\n         substitution\n     }\n \n@@ -298,31 +292,31 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n         clauses\n     }\n \n-    fn intern_parameter_kinds<E>(\n+    fn intern_generic_arg_kinds<E>(\n         &self,\n-        data: impl IntoIterator<Item = Result<chalk_ir::ParameterKind<()>, E>>,\n-    ) -> Result<Self::InternedParameterKinds, E> {\n+        data: impl IntoIterator<Item = Result<chalk_ir::VariableKind<Self>, E>>,\n+    ) -> Result<Self::InternedVariableKinds, E> {\n         data.into_iter().collect::<Result<Vec<_>, _>>()\n     }\n \n-    fn parameter_kinds_data<'a>(\n+    fn variable_kinds_data<'a>(\n         &self,\n-        parameter_kinds: &'a Self::InternedParameterKinds,\n-    ) -> &'a [chalk_ir::ParameterKind<()>] {\n+        parameter_kinds: &'a Self::InternedVariableKinds,\n+    ) -> &'a [chalk_ir::VariableKind<Self>] {\n         parameter_kinds\n     }\n \n     fn intern_canonical_var_kinds<E>(\n         &self,\n-        data: impl IntoIterator<Item = Result<chalk_ir::ParameterKind<chalk_ir::UniverseIndex>, E>>,\n+        data: impl IntoIterator<Item = Result<chalk_ir::CanonicalVarKind<Self>, E>>,\n     ) -> Result<Self::InternedCanonicalVarKinds, E> {\n         data.into_iter().collect::<Result<Vec<_>, _>>()\n     }\n \n     fn canonical_var_kinds_data<'a>(\n         &self,\n         canonical_var_kinds: &'a Self::InternedCanonicalVarKinds,\n-    ) -> &'a [chalk_ir::ParameterKind<chalk_ir::UniverseIndex>] {\n+    ) -> &'a [chalk_ir::CanonicalVarKind<Self>] {\n         canonical_var_kinds\n     }\n }"}, {"sha": "fc37cb2504daaceff8bb7539ff2fb27239a754cf", "filename": "src/librustc_middle/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Flibrustc_middle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Flibrustc_middle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fmod.rs?ref=a8cf3991177f30694200002cd9479ffbbe6d9a1a", "patch": "@@ -33,8 +33,7 @@ pub use self::ObligationCauseCode::*;\n pub use self::SelectionError::*;\n \n pub use self::chalk::{\n-    ChalkEnvironmentAndGoal, ChalkEnvironmentClause, RustDefId as ChalkRustDefId,\n-    RustInterner as ChalkRustInterner,\n+    ChalkEnvironmentAndGoal, ChalkEnvironmentClause, RustInterner as ChalkRustInterner,\n };\n \n /// Depending on the stage of compilation, we want projection to be"}, {"sha": "cbbff82d35f731892f1a2caad37039f8171d1230", "filename": "src/librustc_trait_selection/traits/chalk_fulfill.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Flibrustc_trait_selection%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Flibrustc_trait_selection%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fchalk_fulfill.rs?ref=a8cf3991177f30694200002cd9479ffbbe6d9a1a", "patch": "@@ -87,7 +87,9 @@ fn environment<'tcx>(\n         NodeKind::TraitImpl => {\n             let trait_ref = tcx.impl_trait_ref(def_id).expect(\"not an impl\");\n \n-            inputs.extend(trait_ref.substs.iter().flat_map(|arg| arg.walk()));\n+            // FIXME(chalk): this has problems because of late-bound regions\n+            //inputs.extend(trait_ref.substs.iter().flat_map(|arg| arg.walk()));\n+            inputs.extend(trait_ref.substs.iter());\n         }\n \n         // In an inherent impl, we assume that the receiver type and all its\n@@ -136,6 +138,8 @@ fn in_environment(\n     let environment = match obligation.param_env.def_id {\n         Some(def_id) => environment(infcx.tcx, def_id),\n         None if obligation.param_env.caller_bounds.is_empty() => ty::List::empty(),\n+        // FIXME(chalk): this is hit in ui/where-clauses/where-clause-constraints-are-local-for-trait-impl\n+        // and ui/generics/generic-static-methods\n         _ => bug!(\"non-empty `ParamEnv` with no def-id\"),\n     };\n "}, {"sha": "8def98a9603d89da81945417e3548d0928b314da", "filename": "src/librustc_traits/Cargo.toml", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Flibrustc_traits%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Flibrustc_traits%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2FCargo.toml?ref=a8cf3991177f30694200002cd9479ffbbe6d9a1a", "patch": "@@ -16,9 +16,8 @@ rustc_hir = { path = \"../librustc_hir\" }\n rustc_index = { path = \"../librustc_index\" }\n rustc_ast = { path = \"../librustc_ast\" }\n rustc_span = { path = \"../librustc_span\" }\n-chalk-ir = \"0.10.0\"\n-chalk-rust-ir = \"0.10.0\"\n-chalk-solve = \"0.10.0\"\n+chalk-ir = \"0.11.0\"\n+chalk-solve = \"0.11.0\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n rustc_infer = { path = \"../librustc_infer\" }\n rustc_trait_selection = { path = \"../librustc_trait_selection\" }"}, {"sha": "235497d374098995407ca27bba055c9485b886eb", "filename": "src/librustc_traits/chalk/db.rs", "status": "modified", "additions": 183, "deletions": 224, "changes": 407, "blob_url": "https://github.com/rust-lang/rust/blob/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Flibrustc_traits%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Flibrustc_traits%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk%2Fdb.rs?ref=a8cf3991177f30694200002cd9479ffbbe6d9a1a", "patch": "@@ -6,9 +6,9 @@\n //! either the `TyCtxt` (for information about types) or\n //! `crate::chalk::lowering` (to lower rustc types into Chalk types).\n \n-use rustc_middle::traits::{ChalkRustDefId as RustDefId, ChalkRustInterner as RustInterner};\n+use rustc_middle::traits::ChalkRustInterner as RustInterner;\n use rustc_middle::ty::subst::{InternalSubsts, Subst, SubstsRef};\n-use rustc_middle::ty::{self, AssocItemContainer, AssocKind, TyCtxt};\n+use rustc_middle::ty::{self, AssocItemContainer, AssocKind, Binder, TyCtxt};\n \n use rustc_hir::def_id::DefId;\n \n@@ -38,11 +38,8 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n     fn associated_ty_data(\n         &self,\n         assoc_type_id: chalk_ir::AssocTypeId<RustInterner<'tcx>>,\n-    ) -> Arc<chalk_rust_ir::AssociatedTyDatum<RustInterner<'tcx>>> {\n-        let def_id = match assoc_type_id.0 {\n-            RustDefId::AssocTy(def_id) => def_id,\n-            _ => bug!(\"Did not use `AssocTy` variant when expecting associated type.\"),\n-        };\n+    ) -> Arc<chalk_solve::rust_ir::AssociatedTyDatum<RustInterner<'tcx>>> {\n+        let def_id = assoc_type_id.0;\n         let assoc_item = self.tcx.associated_item(def_id);\n         let trait_def_id = match assoc_item.container {\n             AssocItemContainer::TraitContainer(def_id) => def_id,\n@@ -63,25 +60,22 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n             .map(|(wc, _)| wc.subst(self.tcx, &bound_vars))\n             .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect();\n \n-        Arc::new(chalk_rust_ir::AssociatedTyDatum {\n-            trait_id: chalk_ir::TraitId(RustDefId::Trait(trait_def_id)),\n+        Arc::new(chalk_solve::rust_ir::AssociatedTyDatum {\n+            trait_id: chalk_ir::TraitId(trait_def_id),\n             id: assoc_type_id,\n             name: (),\n             binders: chalk_ir::Binders::new(\n                 binders,\n-                chalk_rust_ir::AssociatedTyDatumBound { bounds: vec![], where_clauses },\n+                chalk_solve::rust_ir::AssociatedTyDatumBound { bounds: vec![], where_clauses },\n             ),\n         })\n     }\n \n     fn trait_datum(\n         &self,\n         trait_id: chalk_ir::TraitId<RustInterner<'tcx>>,\n-    ) -> Arc<chalk_rust_ir::TraitDatum<RustInterner<'tcx>>> {\n-        let def_id = match trait_id.0 {\n-            RustDefId::Trait(def_id) => def_id,\n-            _ => bug!(\"Did not use `Trait` variant when expecting trait.\"),\n-        };\n+    ) -> Arc<chalk_solve::rust_ir::TraitDatum<RustInterner<'tcx>>> {\n+        let def_id = trait_id.0;\n         let trait_def = self.tcx.trait_def(def_id);\n \n         let bound_vars = bound_vars_for_item(self.tcx, def_id);\n@@ -94,21 +88,21 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n \n         let well_known =\n             if self.tcx.lang_items().sized_trait().map(|t| def_id == t).unwrap_or(false) {\n-                Some(chalk_rust_ir::WellKnownTrait::SizedTrait)\n+                Some(chalk_solve::rust_ir::WellKnownTrait::SizedTrait)\n             } else if self.tcx.lang_items().copy_trait().map(|t| def_id == t).unwrap_or(false) {\n-                Some(chalk_rust_ir::WellKnownTrait::CopyTrait)\n+                Some(chalk_solve::rust_ir::WellKnownTrait::CopyTrait)\n             } else if self.tcx.lang_items().clone_trait().map(|t| def_id == t).unwrap_or(false) {\n-                Some(chalk_rust_ir::WellKnownTrait::CloneTrait)\n+                Some(chalk_solve::rust_ir::WellKnownTrait::CloneTrait)\n             } else {\n                 None\n             };\n-        Arc::new(chalk_rust_ir::TraitDatum {\n+        Arc::new(chalk_solve::rust_ir::TraitDatum {\n             id: trait_id,\n             binders: chalk_ir::Binders::new(\n                 binders,\n-                chalk_rust_ir::TraitDatumBound { where_clauses },\n+                chalk_solve::rust_ir::TraitDatumBound { where_clauses },\n             ),\n-            flags: chalk_rust_ir::TraitFlags {\n+            flags: chalk_solve::rust_ir::TraitFlags {\n                 auto: trait_def.has_auto_impl,\n                 marker: trait_def.is_marker,\n                 upstream: !def_id.is_local(),\n@@ -121,101 +115,98 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         })\n     }\n \n-    fn struct_datum(\n+    fn adt_datum(\n         &self,\n-        struct_id: chalk_ir::StructId<RustInterner<'tcx>>,\n-    ) -> Arc<chalk_rust_ir::StructDatum<RustInterner<'tcx>>> {\n-        match struct_id.0 {\n-            RustDefId::Adt(adt_def_id) => {\n-                let adt_def = self.tcx.adt_def(adt_def_id);\n+        adt_id: chalk_ir::AdtId<RustInterner<'tcx>>,\n+    ) -> Arc<chalk_solve::rust_ir::AdtDatum<RustInterner<'tcx>>> {\n+        let adt_def = adt_id.0;\n \n-                let bound_vars = bound_vars_for_item(self.tcx, adt_def_id);\n-                let binders = binders_for(&self.interner, bound_vars);\n+        let bound_vars = bound_vars_for_item(self.tcx, adt_def.did);\n+        let binders = binders_for(&self.interner, bound_vars);\n \n-                let predicates = self.tcx.predicates_of(adt_def_id).predicates;\n-                let where_clauses: Vec<_> = predicates\n+        let predicates = self.tcx.predicates_of(adt_def.did).predicates;\n+        let where_clauses: Vec<_> = predicates\n+            .into_iter()\n+            .map(|(wc, _)| wc.subst(self.tcx, bound_vars))\n+            .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner))\n+            .collect();\n+        let fields = match adt_def.adt_kind() {\n+            ty::AdtKind::Struct | ty::AdtKind::Union => {\n+                let variant = adt_def.non_enum_variant();\n+                variant\n+                    .fields\n                     .iter()\n-                    .map(|(wc, _)| wc.subst(self.tcx, bound_vars))\n-                    .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner))\n-                    .collect();\n-                let fields = match adt_def.adt_kind() {\n-                    ty::AdtKind::Struct | ty::AdtKind::Union => {\n-                        let variant = adt_def.non_enum_variant();\n-                        variant\n-                            .fields\n-                            .iter()\n-                            .map(|field| {\n-                                self.tcx\n-                                    .type_of(field.did)\n-                                    .subst(self.tcx, bound_vars)\n-                                    .lower_into(&self.interner)\n-                            })\n-                            .collect()\n-                    }\n-                    // FIXME(chalk): handle enums; force_impl_for requires this\n-                    ty::AdtKind::Enum => vec![],\n-                };\n-                let struct_datum = Arc::new(chalk_rust_ir::StructDatum {\n-                    id: struct_id,\n-                    binders: chalk_ir::Binders::new(\n-                        binders,\n-                        chalk_rust_ir::StructDatumBound { fields, where_clauses },\n-                    ),\n-                    flags: chalk_rust_ir::StructFlags {\n-                        upstream: !adt_def_id.is_local(),\n-                        fundamental: adt_def.is_fundamental(),\n-                    },\n-                });\n-                struct_datum\n-            }\n-            RustDefId::Ref(_) => Arc::new(chalk_rust_ir::StructDatum {\n-                id: struct_id,\n-                binders: chalk_ir::Binders::new(\n-                    chalk_ir::ParameterKinds::from(\n-                        &self.interner,\n-                        vec![\n-                            chalk_ir::ParameterKind::Lifetime(()),\n-                            chalk_ir::ParameterKind::Ty(()),\n-                        ],\n-                    ),\n-                    chalk_rust_ir::StructDatumBound { fields: vec![], where_clauses: vec![] },\n-                ),\n-                flags: chalk_rust_ir::StructFlags { upstream: false, fundamental: false },\n-            }),\n-            RustDefId::Array | RustDefId::Slice => Arc::new(chalk_rust_ir::StructDatum {\n-                id: struct_id,\n-                binders: chalk_ir::Binders::new(\n-                    chalk_ir::ParameterKinds::from(\n-                        &self.interner,\n-                        Some(chalk_ir::ParameterKind::Ty(())),\n-                    ),\n-                    chalk_rust_ir::StructDatumBound { fields: vec![], where_clauses: vec![] },\n-                ),\n-                flags: chalk_rust_ir::StructFlags { upstream: false, fundamental: false },\n-            }),\n-            RustDefId::Str | RustDefId::Never | RustDefId::FnDef(_) => {\n-                Arc::new(chalk_rust_ir::StructDatum {\n-                    id: struct_id,\n-                    binders: chalk_ir::Binders::new(\n-                        chalk_ir::ParameterKinds::new(&self.interner),\n-                        chalk_rust_ir::StructDatumBound { fields: vec![], where_clauses: vec![] },\n-                    ),\n-                    flags: chalk_rust_ir::StructFlags { upstream: false, fundamental: false },\n-                })\n+                    .map(|field| {\n+                        self.tcx\n+                            .type_of(field.did)\n+                            .subst(self.tcx, bound_vars)\n+                            .lower_into(&self.interner)\n+                    })\n+                    .collect()\n             }\n+            // FIXME(chalk): handle enums; force_impl_for requires this\n+            ty::AdtKind::Enum => vec![],\n+        };\n+        let struct_datum = Arc::new(chalk_solve::rust_ir::AdtDatum {\n+            id: adt_id,\n+            binders: chalk_ir::Binders::new(\n+                binders,\n+                chalk_solve::rust_ir::AdtDatumBound { fields, where_clauses },\n+            ),\n+            flags: chalk_solve::rust_ir::AdtFlags {\n+                upstream: !adt_def.did.is_local(),\n+                fundamental: adt_def.is_fundamental(),\n+            },\n+        });\n+        return struct_datum;\n+    }\n \n-            _ => bug!(\"Used not struct variant when expecting struct variant.\"),\n-        }\n+    fn fn_def_datum(\n+        &self,\n+        fn_def_id: chalk_ir::FnDefId<RustInterner<'tcx>>,\n+    ) -> Arc<chalk_solve::rust_ir::FnDefDatum<RustInterner<'tcx>>> {\n+        let def_id = fn_def_id.0;\n+        let bound_vars = bound_vars_for_item(self.tcx, def_id);\n+        let binders = binders_for(&self.interner, bound_vars);\n+\n+        let predicates = self.tcx.predicates_defined_on(def_id).predicates;\n+        let where_clauses: Vec<_> = predicates\n+            .into_iter()\n+            .map(|(wc, _)| wc.subst(self.tcx, &bound_vars))\n+            .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect();\n+\n+        let sig = self.tcx.fn_sig(def_id);\n+        // FIXME(chalk): collect into an intermediate SmallVec here since\n+        // we need `TypeFoldable` for `no_bound_vars`\n+        let argument_types: Binder<Vec<_>> =\n+            sig.map_bound(|i| i.inputs().iter().copied().collect());\n+        let argument_types = argument_types\n+            .no_bound_vars()\n+            .expect(\"FIXME(chalk): late-bound fn parameters not supported in chalk\")\n+            .iter()\n+            .map(|t| t.subst(self.tcx, &bound_vars).lower_into(&self.interner))\n+            .collect();\n+\n+        let return_type = sig\n+            .output()\n+            .no_bound_vars()\n+            .expect(\"FIXME(chalk): late-bound fn parameters not supported in chalk\")\n+            .subst(self.tcx, &bound_vars)\n+            .lower_into(&self.interner);\n+\n+        let bound =\n+            chalk_solve::rust_ir::FnDefDatumBound { argument_types, where_clauses, return_type };\n+        Arc::new(chalk_solve::rust_ir::FnDefDatum {\n+            id: fn_def_id,\n+            binders: chalk_ir::Binders::new(binders, bound),\n+        })\n     }\n \n     fn impl_datum(\n         &self,\n         impl_id: chalk_ir::ImplId<RustInterner<'tcx>>,\n-    ) -> Arc<chalk_rust_ir::ImplDatum<RustInterner<'tcx>>> {\n-        let def_id = match impl_id.0 {\n-            RustDefId::Impl(def_id) => def_id,\n-            _ => bug!(\"Did not use `Impl` variant when expecting impl.\"),\n-        };\n+    ) -> Arc<chalk_solve::rust_ir::ImplDatum<RustInterner<'tcx>>> {\n+        let def_id = impl_id.0;\n         let bound_vars = bound_vars_for_item(self.tcx, def_id);\n         let binders = binders_for(&self.interner, bound_vars);\n \n@@ -228,28 +219,25 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n             .map(|(wc, _)| wc.subst(self.tcx, bound_vars))\n             .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect();\n \n-        let value = chalk_rust_ir::ImplDatumBound {\n+        let value = chalk_solve::rust_ir::ImplDatumBound {\n             trait_ref: trait_ref.lower_into(&self.interner),\n             where_clauses,\n         };\n \n-        Arc::new(chalk_rust_ir::ImplDatum {\n-            polarity: chalk_rust_ir::Polarity::Positive,\n+        Arc::new(chalk_solve::rust_ir::ImplDatum {\n+            polarity: chalk_solve::rust_ir::Polarity::Positive,\n             binders: chalk_ir::Binders::new(binders, value),\n-            impl_type: chalk_rust_ir::ImplType::Local,\n+            impl_type: chalk_solve::rust_ir::ImplType::Local,\n             associated_ty_value_ids: vec![],\n         })\n     }\n \n     fn impls_for_trait(\n         &self,\n         trait_id: chalk_ir::TraitId<RustInterner<'tcx>>,\n-        parameters: &[chalk_ir::Parameter<RustInterner<'tcx>>],\n+        parameters: &[chalk_ir::GenericArg<RustInterner<'tcx>>],\n     ) -> Vec<chalk_ir::ImplId<RustInterner<'tcx>>> {\n-        let def_id: DefId = match trait_id.0 {\n-            RustDefId::Trait(def_id) => def_id,\n-            _ => bug!(\"Did not use `Trait` variant when expecting trait.\"),\n-        };\n+        let def_id = trait_id.0;\n \n         // FIXME(chalk): use TraitDef::for_each_relevant_impl, but that will\n         // require us to be able to interconvert `Ty<'tcx>`, and we're\n@@ -268,32 +256,24 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n             parameters[0].assert_ty_ref(&self.interner).could_match(&self.interner, &lowered_ty)\n         });\n \n-        let impls = matched_impls\n-            .map(|matched_impl| chalk_ir::ImplId(RustDefId::Impl(matched_impl)))\n-            .collect();\n+        let impls = matched_impls.map(|matched_impl| chalk_ir::ImplId(matched_impl)).collect();\n         impls\n     }\n \n     fn impl_provided_for(\n         &self,\n         auto_trait_id: chalk_ir::TraitId<RustInterner<'tcx>>,\n-        struct_id: chalk_ir::StructId<RustInterner<'tcx>>,\n+        adt_id: chalk_ir::AdtId<RustInterner<'tcx>>,\n     ) -> bool {\n-        let trait_def_id: DefId = match auto_trait_id.0 {\n-            RustDefId::Trait(def_id) => def_id,\n-            _ => bug!(\"Did not use `Trait` variant when expecting trait.\"),\n-        };\n-        let adt_def_id: DefId = match struct_id.0 {\n-            RustDefId::Adt(def_id) => def_id,\n-            _ => bug!(\"Did not use `Adt` variant when expecting adt.\"),\n-        };\n+        let trait_def_id = auto_trait_id.0;\n+        let adt_def = adt_id.0;\n         let all_impls = self.tcx.all_impls(trait_def_id);\n         for impl_def_id in all_impls {\n             let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n             let self_ty = trait_ref.self_ty();\n             match self_ty.kind {\n-                ty::Adt(adt_def, _) => {\n-                    if adt_def.did == adt_def_id {\n+                ty::Adt(impl_adt_def, _) => {\n+                    if impl_adt_def == adt_def {\n                         return true;\n                     }\n                 }\n@@ -305,12 +285,9 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n \n     fn associated_ty_value(\n         &self,\n-        associated_ty_id: chalk_rust_ir::AssociatedTyValueId<RustInterner<'tcx>>,\n-    ) -> Arc<chalk_rust_ir::AssociatedTyValue<RustInterner<'tcx>>> {\n-        let def_id = match associated_ty_id.0 {\n-            RustDefId::AssocTy(def_id) => def_id,\n-            _ => bug!(\"Did not use `AssocTy` variant when expecting associated type.\"),\n-        };\n+        associated_ty_id: chalk_solve::rust_ir::AssociatedTyValueId<RustInterner<'tcx>>,\n+    ) -> Arc<chalk_solve::rust_ir::AssociatedTyValue<RustInterner<'tcx>>> {\n+        let def_id = associated_ty_id.0;\n         let assoc_item = self.tcx.associated_item(def_id);\n         let impl_id = match assoc_item.container {\n             AssocItemContainer::TraitContainer(def_id) => def_id,\n@@ -324,12 +301,12 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         let binders = binders_for(&self.interner, bound_vars);\n         let ty = self.tcx.type_of(def_id);\n \n-        Arc::new(chalk_rust_ir::AssociatedTyValue {\n-            impl_id: chalk_ir::ImplId(RustDefId::Impl(impl_id)),\n-            associated_ty_id: chalk_ir::AssocTypeId(RustDefId::AssocTy(def_id)),\n+        Arc::new(chalk_solve::rust_ir::AssociatedTyValue {\n+            impl_id: chalk_ir::ImplId(impl_id),\n+            associated_ty_id: chalk_ir::AssocTypeId(def_id),\n             value: chalk_ir::Binders::new(\n                 binders,\n-                chalk_rust_ir::AssociatedTyValueBound { ty: ty.lower_into(&self.interner) },\n+                chalk_solve::rust_ir::AssociatedTyValueBound { ty: ty.lower_into(&self.interner) },\n             ),\n         })\n     }\n@@ -347,84 +324,66 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n \n     fn opaque_ty_data(\n         &self,\n-        _id: chalk_ir::OpaqueTyId<RustInterner<'tcx>>,\n-    ) -> Arc<chalk_rust_ir::OpaqueTyDatum<RustInterner<'tcx>>> {\n-        unimplemented!()\n+        opaque_ty_id: chalk_ir::OpaqueTyId<RustInterner<'tcx>>,\n+    ) -> Arc<chalk_solve::rust_ir::OpaqueTyDatum<RustInterner<'tcx>>> {\n+        // FIXME(chalk): actually lower opaque ty\n+        let value = chalk_solve::rust_ir::OpaqueTyDatumBound {\n+            bounds: chalk_ir::Binders::new(chalk_ir::VariableKinds::new(&self.interner), vec![]),\n+        };\n+        Arc::new(chalk_solve::rust_ir::OpaqueTyDatum {\n+            opaque_ty_id,\n+            bound: chalk_ir::Binders::new(chalk_ir::VariableKinds::new(&self.interner), value),\n+        })\n     }\n \n     /// Since Chalk can't handle all Rust types currently, we have to handle\n     /// some specially for now. Over time, these `Some` returns will change to\n     /// `None` and eventually this function will be removed.\n     fn force_impl_for(\n         &self,\n-        well_known: chalk_rust_ir::WellKnownTrait,\n+        well_known: chalk_solve::rust_ir::WellKnownTrait,\n         ty: &chalk_ir::TyData<RustInterner<'tcx>>,\n     ) -> Option<bool> {\n         use chalk_ir::TyData::*;\n         match well_known {\n-            chalk_rust_ir::WellKnownTrait::SizedTrait => match ty {\n+            chalk_solve::rust_ir::WellKnownTrait::SizedTrait => match ty {\n                 Apply(apply) => match apply.name {\n-                    chalk_ir::TypeName::Struct(chalk_ir::StructId(rust_def_id)) => {\n-                        use rustc_middle::traits::ChalkRustDefId::*;\n-                        match rust_def_id {\n-                            Never | Array | RawPtr | FnDef(_) | Ref(_) => Some(true),\n-\n-                            Adt(adt_def_id) => {\n-                                let adt_def = self.tcx.adt_def(adt_def_id);\n-                                match adt_def.adt_kind() {\n-                                    ty::AdtKind::Struct | ty::AdtKind::Union => None,\n-                                    ty::AdtKind::Enum => {\n-                                        let constraint = self.tcx.adt_sized_constraint(adt_def_id);\n-                                        if !constraint.0.is_empty() {\n-                                            unimplemented!()\n-                                        } else {\n-                                            Some(true)\n-                                        }\n-                                    }\n-                                }\n-                            }\n-\n-                            Str | Slice => Some(false),\n-\n-                            Trait(_) | Impl(_) | AssocTy(_) => panic!(),\n+                    chalk_ir::TypeName::Adt(chalk_ir::AdtId(adt_def)) => match adt_def.adt_kind() {\n+                        ty::AdtKind::Struct | ty::AdtKind::Union => None,\n+                        ty::AdtKind::Enum => {\n+                            let constraint = self.tcx.adt_sized_constraint(adt_def.did);\n+                            if constraint.0.len() > 0 { unimplemented!() } else { Some(true) }\n                         }\n-                    }\n+                    },\n                     _ => None,\n                 },\n-                Dyn(_) | Alias(_) | Placeholder(_) | Function(_) | InferenceVar(_)\n+                Dyn(_)\n+                | Alias(_)\n+                | Placeholder(_)\n+                | Function(_)\n+                | InferenceVar(_, _)\n                 | BoundVar(_) => None,\n             },\n-            chalk_rust_ir::WellKnownTrait::CopyTrait\n-            | chalk_rust_ir::WellKnownTrait::CloneTrait => match ty {\n+            chalk_solve::rust_ir::WellKnownTrait::CopyTrait\n+            | chalk_solve::rust_ir::WellKnownTrait::CloneTrait => match ty {\n                 Apply(apply) => match apply.name {\n-                    chalk_ir::TypeName::Struct(chalk_ir::StructId(rust_def_id)) => {\n-                        use rustc_middle::traits::ChalkRustDefId::*;\n-                        match rust_def_id {\n-                            Never | RawPtr | Ref(_) | Str | Slice => Some(false),\n-                            FnDef(_) | Array => Some(true),\n-                            Adt(adt_def_id) => {\n-                                let adt_def = self.tcx.adt_def(adt_def_id);\n-                                match adt_def.adt_kind() {\n-                                    ty::AdtKind::Struct | ty::AdtKind::Union => None,\n-                                    ty::AdtKind::Enum => {\n-                                        let constraint = self.tcx.adt_sized_constraint(adt_def_id);\n-                                        if !constraint.0.is_empty() {\n-                                            unimplemented!()\n-                                        } else {\n-                                            Some(true)\n-                                        }\n-                                    }\n-                                }\n-                            }\n-                            Trait(_) | Impl(_) | AssocTy(_) => panic!(),\n+                    chalk_ir::TypeName::Adt(chalk_ir::AdtId(adt_def)) => match adt_def.adt_kind() {\n+                        ty::AdtKind::Struct | ty::AdtKind::Union => None,\n+                        ty::AdtKind::Enum => {\n+                            let constraint = self.tcx.adt_sized_constraint(adt_def.did);\n+                            if constraint.0.len() > 0 { unimplemented!() } else { Some(true) }\n                         }\n-                    }\n+                    },\n                     _ => None,\n                 },\n-                Dyn(_) | Alias(_) | Placeholder(_) | Function(_) | InferenceVar(_)\n+                Dyn(_)\n+                | Alias(_)\n+                | Placeholder(_)\n+                | Function(_)\n+                | InferenceVar(_, _)\n                 | BoundVar(_) => None,\n             },\n-            chalk_rust_ir::WellKnownTrait::DropTrait => None,\n+            chalk_solve::rust_ir::WellKnownTrait::DropTrait => None,\n         }\n     }\n \n@@ -437,37 +396,33 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n \n     fn well_known_trait_id(\n         &self,\n-        well_known_trait: chalk_rust_ir::WellKnownTrait,\n+        well_known_trait: chalk_solve::rust_ir::WellKnownTrait,\n     ) -> Option<chalk_ir::TraitId<RustInterner<'tcx>>> {\n-        use chalk_rust_ir::WellKnownTrait::*;\n+        use chalk_solve::rust_ir::WellKnownTrait::*;\n         let t = match well_known_trait {\n-            SizedTrait => self\n-                .tcx\n-                .lang_items()\n-                .sized_trait()\n-                .map(|t| chalk_ir::TraitId(RustDefId::Trait(t)))\n-                .unwrap(),\n-            CopyTrait => self\n-                .tcx\n-                .lang_items()\n-                .copy_trait()\n-                .map(|t| chalk_ir::TraitId(RustDefId::Trait(t)))\n-                .unwrap(),\n-            CloneTrait => self\n-                .tcx\n-                .lang_items()\n-                .clone_trait()\n-                .map(|t| chalk_ir::TraitId(RustDefId::Trait(t)))\n-                .unwrap(),\n-            DropTrait => self\n-                .tcx\n-                .lang_items()\n-                .drop_trait()\n-                .map(|t| chalk_ir::TraitId(RustDefId::Trait(t)))\n-                .unwrap(),\n+            SizedTrait => {\n+                self.tcx.lang_items().sized_trait().map(|t| chalk_ir::TraitId(t)).unwrap()\n+            }\n+            CopyTrait => self.tcx.lang_items().copy_trait().map(|t| chalk_ir::TraitId(t)).unwrap(),\n+            CloneTrait => {\n+                self.tcx.lang_items().clone_trait().map(|t| chalk_ir::TraitId(t)).unwrap()\n+            }\n+            DropTrait => self.tcx.lang_items().drop_trait().map(|t| chalk_ir::TraitId(t)).unwrap(),\n         };\n         Some(t)\n     }\n+\n+    fn is_object_safe(&self, trait_id: chalk_ir::TraitId<RustInterner<'tcx>>) -> bool {\n+        self.tcx.is_object_safe(trait_id.0)\n+    }\n+\n+    fn hidden_opaque_type(\n+        &self,\n+        _id: chalk_ir::OpaqueTyId<RustInterner<'tcx>>,\n+    ) -> chalk_ir::Ty<RustInterner<'tcx>> {\n+        // FIXME(chalk): actually get hidden ty\n+        self.tcx.mk_ty(ty::Tuple(self.tcx.intern_substs(&[]))).lower_into(&self.interner)\n+    }\n }\n \n /// Creates a `InternalSubsts` that maps each generic parameter to a higher-ranked\n@@ -505,13 +460,17 @@ fn bound_vars_for_item(tcx: TyCtxt<'tcx>, def_id: DefId) -> SubstsRef<'tcx> {\n fn binders_for<'tcx>(\n     interner: &RustInterner<'tcx>,\n     bound_vars: SubstsRef<'tcx>,\n-) -> chalk_ir::ParameterKinds<RustInterner<'tcx>> {\n-    chalk_ir::ParameterKinds::from(\n+) -> chalk_ir::VariableKinds<RustInterner<'tcx>> {\n+    chalk_ir::VariableKinds::from(\n         interner,\n         bound_vars.iter().map(|arg| match arg.unpack() {\n-            ty::subst::GenericArgKind::Lifetime(_re) => chalk_ir::ParameterKind::Lifetime(()),\n-            ty::subst::GenericArgKind::Type(_ty) => chalk_ir::ParameterKind::Ty(()),\n-            ty::subst::GenericArgKind::Const(_const) => chalk_ir::ParameterKind::Ty(()),\n+            ty::subst::GenericArgKind::Lifetime(_re) => chalk_ir::VariableKind::Lifetime,\n+            ty::subst::GenericArgKind::Type(_ty) => {\n+                chalk_ir::VariableKind::Ty(chalk_ir::TyKind::General)\n+            }\n+            ty::subst::GenericArgKind::Const(c) => {\n+                chalk_ir::VariableKind::Const(c.ty.lower_into(interner))\n+            }\n         }),\n     )\n }"}, {"sha": "5546a8db53395b484ff5a3b2b510de566632f513", "filename": "src/librustc_traits/chalk/lowering.rs", "status": "modified", "additions": 199, "deletions": 77, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk%2Flowering.rs?ref=a8cf3991177f30694200002cd9479ffbbe6d9a1a", "patch": "@@ -32,8 +32,7 @@\n //! variables from the current `Binder`.\n \n use rustc_middle::traits::{\n-    ChalkEnvironmentAndGoal, ChalkEnvironmentClause, ChalkRustDefId as RustDefId,\n-    ChalkRustInterner as RustInterner,\n+    ChalkEnvironmentAndGoal, ChalkEnvironmentClause, ChalkRustInterner as RustInterner,\n };\n use rustc_middle::ty::fold::TypeFolder;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, SubstsRef};\n@@ -62,7 +61,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Substitution<RustInterner<'tcx>>> for Subst\n impl<'tcx> LowerInto<'tcx, chalk_ir::AliasTy<RustInterner<'tcx>>> for ty::ProjectionTy<'tcx> {\n     fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::AliasTy<RustInterner<'tcx>> {\n         chalk_ir::AliasTy::Projection(chalk_ir::ProjectionTy {\n-            associated_ty_id: chalk_ir::AssocTypeId(RustDefId::AssocTy(self.item_def_id)),\n+            associated_ty_id: chalk_ir::AssocTypeId(self.item_def_id),\n             substitution: self.substs.lower_into(interner),\n         })\n     }\n@@ -98,8 +97,30 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                             .intern(interner),\n                         )\n                     }\n-                    // FIXME(chalk): need to add RegionOutlives/TypeOutlives\n-                    ty::PredicateKind::RegionOutlives(_) => None,\n+                    ty::PredicateKind::RegionOutlives(predicate) => {\n+                        let (predicate, binders, _named_regions) =\n+                            collect_bound_vars(interner, interner.tcx, predicate);\n+\n+                        Some(\n+                            chalk_ir::ProgramClauseData::ForAll(chalk_ir::Binders::new(\n+                                binders,\n+                                chalk_ir::ProgramClauseImplication {\n+                                    consequence: chalk_ir::DomainGoal::Holds(\n+                                        chalk_ir::WhereClause::LifetimeOutlives(\n+                                            chalk_ir::LifetimeOutlives {\n+                                                a: predicate.0.lower_into(interner),\n+                                                b: predicate.1.lower_into(interner),\n+                                            },\n+                                        ),\n+                                    ),\n+                                    conditions: chalk_ir::Goals::new(interner),\n+                                    priority: chalk_ir::ClausePriority::High,\n+                                },\n+                            ))\n+                            .intern(interner),\n+                        )\n+                    }\n+                    // FIXME(chalk): need to add TypeOutlives\n                     ty::PredicateKind::TypeOutlives(_) => None,\n                     ty::PredicateKind::Projection(predicate) => {\n                         let (predicate, binders, _named_regions) =\n@@ -157,30 +178,36 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n     fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::GoalData<RustInterner<'tcx>> {\n         match self.kind() {\n             ty::PredicateKind::Trait(predicate, _) => predicate.lower_into(interner),\n-            // FIXME(chalk): we need to register constraints.\n-            ty::PredicateKind::RegionOutlives(_predicate) => {\n-                chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n+            ty::PredicateKind::RegionOutlives(predicate) => {\n+                let (predicate, binders, _named_regions) =\n+                    collect_bound_vars(interner, interner.tcx, predicate);\n+\n+                chalk_ir::GoalData::Quantified(\n+                    chalk_ir::QuantifierKind::ForAll,\n+                    chalk_ir::Binders::new(\n+                        binders,\n+                        chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::Holds(\n+                            chalk_ir::WhereClause::LifetimeOutlives(chalk_ir::LifetimeOutlives {\n+                                a: predicate.0.lower_into(interner),\n+                                b: predicate.1.lower_into(interner),\n+                            }),\n+                        ))\n+                        .intern(interner),\n+                    ),\n+                )\n             }\n+            // FIXME(chalk): TypeOutlives\n             ty::PredicateKind::TypeOutlives(_predicate) => {\n                 chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n             }\n             ty::PredicateKind::Projection(predicate) => predicate.lower_into(interner),\n             ty::PredicateKind::WellFormed(arg) => match arg.unpack() {\n                 GenericArgKind::Type(ty) => match ty.kind {\n-                    // These types are always WF.\n-                    ty::Str | ty::Placeholder(..) | ty::Error(_) | ty::Never => {\n-                        chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n-                    }\n+                    // FIXME(chalk): In Chalk, a placeholder is WellFormed if it\n+                    // `FromEnv`. However, when we \"lower\" Params, we don't update\n+                    // the environment.\n+                    ty::Placeholder(..) => chalk_ir::GoalData::All(chalk_ir::Goals::new(interner)),\n \n-                    // FIXME(chalk): Well-formed only if ref lifetime outlives type\n-                    ty::Ref(..) => chalk_ir::GoalData::All(chalk_ir::Goals::new(interner)),\n-\n-                    ty::Param(..) => panic!(\"No Params expected.\"),\n-\n-                    // FIXME(chalk) -- ultimately I think this is what we\n-                    // want to do, and we just have rules for how to prove\n-                    // `WellFormed` for everything above, instead of\n-                    // inlining a bit the rules of the proof here.\n                     _ => chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::WellFormed(\n                         chalk_ir::WellFormed::Ty(ty.lower_into(interner)),\n                     )),\n@@ -192,12 +219,15 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n                 GenericArgKind::Lifetime(lt) => bug!(\"unexpect well formed predicate: {:?}\", lt),\n             },\n \n+            ty::PredicateKind::ObjectSafe(t) => chalk_ir::GoalData::DomainGoal(\n+                chalk_ir::DomainGoal::ObjectSafe(chalk_ir::TraitId(*t)),\n+            ),\n+\n             // FIXME(chalk): other predicates\n             //\n             // We can defer this, but ultimately we'll want to express\n             // some of these in terms of chalk operations.\n-            ty::PredicateKind::ObjectSafe(..)\n-            | ty::PredicateKind::ClosureKind(..)\n+            ty::PredicateKind::ClosureKind(..)\n             | ty::PredicateKind::Subtype(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::ConstEquate(..) => {\n@@ -212,7 +242,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::TraitRef<RustInterner<'tcx>>>\n {\n     fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::TraitRef<RustInterner<'tcx>> {\n         chalk_ir::TraitRef {\n-            trait_id: chalk_ir::TraitId(RustDefId::Trait(self.def_id)),\n+            trait_id: chalk_ir::TraitId(self.def_id),\n             substitution: self.substs.lower_into(interner),\n         }\n     }\n@@ -274,7 +304,8 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n         use TyKind::*;\n \n         let empty = || chalk_ir::Substitution::empty(interner);\n-        let struct_ty = |def_id| chalk_ir::TypeName::Struct(chalk_ir::StructId(def_id));\n+        let struct_ty =\n+            |def_id| chalk_ir::TypeName::Adt(chalk_ir::AdtId(interner.tcx.adt_def(def_id)));\n         let apply = |name, substitution| {\n             TyData::Apply(chalk_ir::ApplicationTy { name, substitution }).intern(interner)\n         };\n@@ -305,39 +336,72 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n                 ast::FloatTy::F32 => float(chalk_ir::FloatTy::F32),\n                 ast::FloatTy::F64 => float(chalk_ir::FloatTy::F64),\n             },\n-            Adt(def, substs) => {\n-                apply(struct_ty(RustDefId::Adt(def.did)), substs.lower_into(interner))\n-            }\n+            Adt(def, substs) => apply(struct_ty(def.did), substs.lower_into(interner)),\n             Foreign(_def_id) => unimplemented!(),\n-            Str => apply(struct_ty(RustDefId::Str), empty()),\n-            Array(ty, _) => apply(\n-                struct_ty(RustDefId::Array),\n-                chalk_ir::Substitution::from1(\n-                    interner,\n-                    chalk_ir::ParameterKind::Ty(ty.lower_into(interner)).intern(interner),\n-                ),\n-            ),\n+            Str => apply(chalk_ir::TypeName::Str, empty()),\n+            Array(ty, len) => {\n+                let value = match len.val {\n+                    ty::ConstKind::Value(val) => {\n+                        chalk_ir::ConstValue::Concrete(chalk_ir::ConcreteConst { interned: val })\n+                    }\n+                    ty::ConstKind::Bound(db, bound) => {\n+                        chalk_ir::ConstValue::BoundVar(chalk_ir::BoundVar::new(\n+                            chalk_ir::DebruijnIndex::new(db.as_u32()),\n+                            bound.index(),\n+                        ))\n+                    }\n+                    _ => unimplemented!(\"Const not implemented. {:?}\", len.val),\n+                };\n+                apply(\n+                    chalk_ir::TypeName::Array,\n+                    chalk_ir::Substitution::from(\n+                        interner,\n+                        &[\n+                            chalk_ir::GenericArgData::Ty(ty.lower_into(interner)).intern(interner),\n+                            chalk_ir::GenericArgData::Const(\n+                                chalk_ir::ConstData { ty: len.ty.lower_into(interner), value }\n+                                    .intern(interner),\n+                            )\n+                            .intern(interner),\n+                        ],\n+                    ),\n+                )\n+            }\n             Slice(ty) => apply(\n-                struct_ty(RustDefId::Slice),\n+                chalk_ir::TypeName::Slice,\n                 chalk_ir::Substitution::from1(\n                     interner,\n-                    chalk_ir::ParameterKind::Ty(ty.lower_into(interner)).intern(interner),\n+                    chalk_ir::GenericArgData::Ty(ty.lower_into(interner)).intern(interner),\n                 ),\n             ),\n-            RawPtr(_) => apply(struct_ty(RustDefId::RawPtr), empty()),\n-            Ref(region, ty, mutability) => apply(\n-                struct_ty(RustDefId::Ref(mutability)),\n-                chalk_ir::Substitution::from(\n-                    interner,\n-                    [\n-                        chalk_ir::ParameterKind::Lifetime(region.lower_into(interner))\n-                            .intern(interner),\n-                        chalk_ir::ParameterKind::Ty(ty.lower_into(interner)).intern(interner),\n-                    ]\n-                    .iter(),\n-                ),\n+            RawPtr(ptr) => {\n+                let name = match ptr.mutbl {\n+                    ast::Mutability::Mut => chalk_ir::TypeName::Raw(chalk_ir::Mutability::Mut),\n+                    ast::Mutability::Not => chalk_ir::TypeName::Raw(chalk_ir::Mutability::Not),\n+                };\n+                apply(name, chalk_ir::Substitution::from1(interner, ptr.ty.lower_into(interner)))\n+            }\n+            Ref(region, ty, mutability) => {\n+                let name = match mutability {\n+                    ast::Mutability::Mut => chalk_ir::TypeName::Ref(chalk_ir::Mutability::Mut),\n+                    ast::Mutability::Not => chalk_ir::TypeName::Ref(chalk_ir::Mutability::Not),\n+                };\n+                apply(\n+                    name,\n+                    chalk_ir::Substitution::from(\n+                        interner,\n+                        &[\n+                            chalk_ir::GenericArgData::Lifetime(region.lower_into(interner))\n+                                .intern(interner),\n+                            chalk_ir::GenericArgData::Ty(ty.lower_into(interner)).intern(interner),\n+                        ],\n+                    ),\n+                )\n+            }\n+            FnDef(def_id, substs) => apply(\n+                chalk_ir::TypeName::FnDef(chalk_ir::FnDefId(def_id)),\n+                substs.lower_into(interner),\n             ),\n-            FnDef(def_id, _) => apply(struct_ty(RustDefId::FnDef(def_id)), empty()),\n             FnPtr(sig) => {\n                 let (inputs_and_outputs, binders, _named_regions) =\n                     collect_bound_vars(interner, interner.tcx, &sig.inputs_and_output());\n@@ -346,22 +410,32 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n                     substitution: chalk_ir::Substitution::from(\n                         interner,\n                         inputs_and_outputs.iter().map(|ty| {\n-                            chalk_ir::ParameterKind::Ty(ty.lower_into(interner)).intern(interner)\n+                            chalk_ir::GenericArgData::Ty(ty.lower_into(interner)).intern(interner)\n                         }),\n                     ),\n                 })\n                 .intern(interner)\n             }\n-            Dynamic(_, _) => unimplemented!(),\n+            // FIXME(chalk): add region\n+            Dynamic(predicates, _region) => {\n+                TyData::Dyn(chalk_ir::DynTy { bounds: predicates.lower_into(interner) })\n+                    .intern(interner)\n+            }\n             Closure(_def_id, _) => unimplemented!(),\n             Generator(_def_id, _substs, _) => unimplemented!(),\n             GeneratorWitness(_) => unimplemented!(),\n-            Never => apply(struct_ty(RustDefId::Never), empty()),\n+            Never => apply(chalk_ir::TypeName::Never, empty()),\n             Tuple(substs) => {\n                 apply(chalk_ir::TypeName::Tuple(substs.len()), substs.lower_into(interner))\n             }\n             Projection(proj) => TyData::Alias(proj.lower_into(interner)).intern(interner),\n-            Opaque(_def_id, _substs) => unimplemented!(),\n+            Opaque(def_id, substs) => {\n+                TyData::Alias(chalk_ir::AliasTy::Opaque(chalk_ir::OpaqueTy {\n+                    opaque_ty_id: chalk_ir::OpaqueTyId(def_id),\n+                    substitution: substs.lower_into(interner),\n+                }))\n+                .intern(interner)\n+            }\n             // This should have been done eagerly prior to this, and all Params\n             // should have been substituted to placeholders\n             Param(_) => panic!(\"Lowering Param when not expected.\"),\n@@ -376,7 +450,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n             })\n             .intern(interner),\n             Infer(_infer) => unimplemented!(),\n-            Error(_) => unimplemented!(),\n+            Error(_) => apply(chalk_ir::TypeName::Error, empty()),\n         }\n     }\n }\n@@ -401,6 +475,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Lifetime<RustInterner<'tcx>>> for Region<'t\n                 ty::BrEnv => unimplemented!(),\n             },\n             ReFree(_) => unimplemented!(),\n+            // FIXME(chalk): need to handle ReStatic\n             ReStatic => unimplemented!(),\n             ReVar(_) => unimplemented!(),\n             RePlaceholder(placeholder_region) => {\n@@ -411,21 +486,22 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Lifetime<RustInterner<'tcx>>> for Region<'t\n                 .intern(interner)\n             }\n             ReEmpty(_) => unimplemented!(),\n+            // FIXME(chalk): need to handle ReErased\n             ReErased => unimplemented!(),\n         }\n     }\n }\n \n-impl<'tcx> LowerInto<'tcx, chalk_ir::Parameter<RustInterner<'tcx>>> for GenericArg<'tcx> {\n-    fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::Parameter<RustInterner<'tcx>> {\n+impl<'tcx> LowerInto<'tcx, chalk_ir::GenericArg<RustInterner<'tcx>>> for GenericArg<'tcx> {\n+    fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::GenericArg<RustInterner<'tcx>> {\n         match self.unpack() {\n             ty::subst::GenericArgKind::Type(ty) => {\n-                chalk_ir::ParameterKind::Ty(ty.lower_into(interner))\n+                chalk_ir::GenericArgData::Ty(ty.lower_into(interner))\n             }\n             ty::subst::GenericArgKind::Lifetime(lifetime) => {\n-                chalk_ir::ParameterKind::Lifetime(lifetime.lower_into(interner))\n+                chalk_ir::GenericArgData::Lifetime(lifetime.lower_into(interner))\n             }\n-            ty::subst::GenericArgKind::Const(_) => chalk_ir::ParameterKind::Ty(\n+            ty::subst::GenericArgKind::Const(_) => chalk_ir::GenericArgData::Ty(\n                 chalk_ir::TyData::Apply(chalk_ir::ApplicationTy {\n                     name: chalk_ir::TypeName::Tuple(0),\n                     substitution: chalk_ir::Substitution::empty(interner),\n@@ -458,7 +534,18 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n                     chalk_ir::WhereClause::Implemented(predicate.trait_ref.lower_into(interner)),\n                 ))\n             }\n-            ty::PredicateKind::RegionOutlives(_predicate) => None,\n+            ty::PredicateKind::RegionOutlives(predicate) => {\n+                let (predicate, binders, _named_regions) =\n+                    collect_bound_vars(interner, interner.tcx, predicate);\n+\n+                Some(chalk_ir::Binders::new(\n+                    binders,\n+                    chalk_ir::WhereClause::LifetimeOutlives(chalk_ir::LifetimeOutlives {\n+                        a: predicate.0.lower_into(interner),\n+                        b: predicate.1.lower_into(interner),\n+                    }),\n+                ))\n+            }\n             ty::PredicateKind::TypeOutlives(_predicate) => None,\n             ty::PredicateKind::Projection(_predicate) => None,\n             ty::PredicateKind::WellFormed(_ty) => None,\n@@ -472,6 +559,39 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n     }\n }\n \n+impl<'tcx> LowerInto<'tcx, chalk_ir::Binders<chalk_ir::QuantifiedWhereClauses<RustInterner<'tcx>>>>\n+    for Binder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>\n+{\n+    fn lower_into(\n+        self,\n+        interner: &RustInterner<'tcx>,\n+    ) -> chalk_ir::Binders<chalk_ir::QuantifiedWhereClauses<RustInterner<'tcx>>> {\n+        let (predicates, binders, _named_regions) =\n+            collect_bound_vars(interner, interner.tcx, &self);\n+        let where_clauses = predicates.into_iter().map(|predicate| match predicate {\n+            ty::ExistentialPredicate::Trait(ty::ExistentialTraitRef { def_id, substs }) => {\n+                chalk_ir::Binders::new(\n+                    chalk_ir::VariableKinds::new(interner),\n+                    chalk_ir::WhereClause::Implemented(chalk_ir::TraitRef {\n+                        trait_id: chalk_ir::TraitId(def_id),\n+                        substitution: substs.lower_into(interner),\n+                    }),\n+                )\n+            }\n+            ty::ExistentialPredicate::Projection(_predicate) => unimplemented!(),\n+            ty::ExistentialPredicate::AutoTrait(def_id) => chalk_ir::Binders::new(\n+                chalk_ir::VariableKinds::new(interner),\n+                chalk_ir::WhereClause::Implemented(chalk_ir::TraitRef {\n+                    trait_id: chalk_ir::TraitId(def_id),\n+                    substitution: chalk_ir::Substitution::empty(interner),\n+                }),\n+            ),\n+        });\n+        let value = chalk_ir::QuantifiedWhereClauses::from(interner, where_clauses);\n+        chalk_ir::Binders::new(binders, value)\n+    }\n+}\n+\n /// To collect bound vars, we have to do two passes. In the first pass, we\n /// collect all `BoundRegion`s and `ty::Bound`s. In the second pass, we then\n /// replace `BrNamed` into `BrAnon`. The two separate passes are important,\n@@ -485,7 +605,7 @@ crate fn collect_bound_vars<'a, 'tcx, T: TypeFoldable<'tcx>>(\n     interner: &RustInterner<'tcx>,\n     tcx: TyCtxt<'tcx>,\n     ty: &'a Binder<T>,\n-) -> (T, chalk_ir::ParameterKinds<RustInterner<'tcx>>, BTreeMap<DefId, u32>) {\n+) -> (T, chalk_ir::VariableKinds<RustInterner<'tcx>>, BTreeMap<DefId, u32>) {\n     let mut bound_vars_collector = BoundVarsCollector::new();\n     ty.skip_binder().visit_with(&mut bound_vars_collector);\n     let mut parameters = bound_vars_collector.parameters;\n@@ -500,25 +620,25 @@ crate fn collect_bound_vars<'a, 'tcx, T: TypeFoldable<'tcx>>(\n     let new_ty = ty.skip_binder().fold_with(&mut bound_var_substitutor);\n \n     for var in named_parameters.values() {\n-        parameters.insert(*var, chalk_ir::ParameterKind::Lifetime(()));\n+        parameters.insert(*var, chalk_ir::VariableKind::Lifetime);\n     }\n \n     (0..parameters.len()).for_each(|i| {\n         parameters.get(&(i as u32)).expect(\"Skipped bound var index.\");\n     });\n \n-    let binders = chalk_ir::ParameterKinds::from(interner, parameters.into_iter().map(|(_, v)| v));\n+    let binders = chalk_ir::VariableKinds::from(interner, parameters.into_iter().map(|(_, v)| v));\n \n     (new_ty, binders, named_parameters)\n }\n \n-crate struct BoundVarsCollector {\n+crate struct BoundVarsCollector<'tcx> {\n     binder_index: ty::DebruijnIndex,\n-    crate parameters: BTreeMap<u32, chalk_ir::ParameterKind<()>>,\n+    crate parameters: BTreeMap<u32, chalk_ir::VariableKind<RustInterner<'tcx>>>,\n     crate named_parameters: Vec<DefId>,\n }\n \n-impl BoundVarsCollector {\n+impl<'tcx> BoundVarsCollector<'tcx> {\n     crate fn new() -> Self {\n         BoundVarsCollector {\n             binder_index: ty::INNERMOST,\n@@ -528,7 +648,7 @@ impl BoundVarsCollector {\n     }\n }\n \n-impl<'tcx> TypeVisitor<'tcx> for BoundVarsCollector {\n+impl<'tcx> TypeVisitor<'tcx> for BoundVarsCollector<'tcx> {\n     fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> bool {\n         self.binder_index.shift_in(1);\n         let result = t.super_visit_with(self);\n@@ -541,11 +661,12 @@ impl<'tcx> TypeVisitor<'tcx> for BoundVarsCollector {\n             ty::Bound(debruijn, bound_ty) if debruijn == self.binder_index => {\n                 match self.parameters.entry(bound_ty.var.as_u32()) {\n                     Entry::Vacant(entry) => {\n-                        entry.insert(chalk_ir::ParameterKind::Ty(()));\n-                    }\n-                    Entry::Occupied(entry) => {\n-                        entry.get().assert_ty_ref();\n+                        entry.insert(chalk_ir::VariableKind::Ty(chalk_ir::TyKind::General));\n                     }\n+                    Entry::Occupied(entry) => match entry.get() {\n+                        chalk_ir::VariableKind::Ty(_) => {}\n+                        _ => panic!(),\n+                    },\n                 }\n             }\n \n@@ -566,11 +687,12 @@ impl<'tcx> TypeVisitor<'tcx> for BoundVarsCollector {\n \n                 ty::BoundRegion::BrAnon(var) => match self.parameters.entry(*var) {\n                     Entry::Vacant(entry) => {\n-                        entry.insert(chalk_ir::ParameterKind::Lifetime(()));\n-                    }\n-                    Entry::Occupied(entry) => {\n-                        entry.get().assert_lifetime_ref();\n+                        entry.insert(chalk_ir::VariableKind::Lifetime);\n                     }\n+                    Entry::Occupied(entry) => match entry.get() {\n+                        chalk_ir::VariableKind::Lifetime => {}\n+                        _ => panic!(),\n+                    },\n                 },\n \n                 ty::BrEnv => unimplemented!(),"}, {"sha": "6f657be0908b45848e3d815d25447b66884edbbc", "filename": "src/librustc_traits/chalk/mod.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Flibrustc_traits%2Fchalk%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Flibrustc_traits%2Fchalk%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk%2Fmod.rs?ref=a8cf3991177f30694200002cd9479ffbbe6d9a1a", "patch": "@@ -22,7 +22,7 @@ use rustc_middle::ty::{\n use rustc_infer::infer::canonical::{\n     Canonical, CanonicalVarValues, Certainty, QueryRegionConstraints, QueryResponse,\n };\n-use rustc_infer::traits::{self, ChalkCanonicalGoal, ChalkRustDefId as RustDefId};\n+use rustc_infer::traits::{self, ChalkCanonicalGoal};\n \n use crate::chalk::db::RustIrDatabase as ChalkRustIrDatabase;\n use crate::chalk::lowering::{LowerInto, ParamsSubstitutor};\n@@ -55,25 +55,23 @@ crate fn evaluate_goal<'tcx>(\n                     CanonicalVarKind::PlaceholderTy(_ty) => unimplemented!(),\n                     CanonicalVarKind::PlaceholderRegion(_ui) => unimplemented!(),\n                     CanonicalVarKind::Ty(ty) => match ty {\n-                        CanonicalTyVarKind::General(ui) => {\n-                            chalk_ir::ParameterKind::Ty(chalk_ir::UniverseIndex {\n-                                counter: ui.index(),\n-                            })\n-                        }\n-                        CanonicalTyVarKind::Int | CanonicalTyVarKind::Float => {\n-                            // FIXME(chalk) - this is actually really important\n-                            // These variable kinds put some limits on the\n-                            // types that can be substituted (floats or ints).\n-                            // While it's unclear exactly the design here, we\n-                            // probably want some way to \"register\" these.\n-                            chalk_ir::ParameterKind::Ty(chalk_ir::UniverseIndex::root())\n-                        }\n+                        CanonicalTyVarKind::General(ui) => chalk_ir::WithKind::new(\n+                            chalk_ir::VariableKind::Ty(chalk_ir::TyKind::General),\n+                            chalk_ir::UniverseIndex { counter: ui.index() },\n+                        ),\n+                        CanonicalTyVarKind::Int => chalk_ir::WithKind::new(\n+                            chalk_ir::VariableKind::Ty(chalk_ir::TyKind::Integer),\n+                            chalk_ir::UniverseIndex::root(),\n+                        ),\n+                        CanonicalTyVarKind::Float => chalk_ir::WithKind::new(\n+                            chalk_ir::VariableKind::Ty(chalk_ir::TyKind::Float),\n+                            chalk_ir::UniverseIndex::root(),\n+                        ),\n                     },\n-                    CanonicalVarKind::Region(ui) => {\n-                        chalk_ir::ParameterKind::Lifetime(chalk_ir::UniverseIndex {\n-                            counter: ui.index(),\n-                        })\n-                    }\n+                    CanonicalVarKind::Region(ui) => chalk_ir::WithKind::new(\n+                        chalk_ir::VariableKind::Lifetime,\n+                        chalk_ir::UniverseIndex { counter: ui.index() },\n+                    ),\n                     CanonicalVarKind::Const(_ui) => unimplemented!(),\n                     CanonicalVarKind::PlaceholderConst(_pc) => unimplemented!(),\n                 }),\n@@ -101,18 +99,14 @@ crate fn evaluate_goal<'tcx>(\n             // essentially inverse of lowering a `GenericArg`.\n             let _data = p.data(&interner);\n             match _data {\n-                chalk_ir::ParameterKind::Ty(_t) => {\n+                chalk_ir::GenericArgData::Ty(_t) => {\n                     use chalk_ir::TyData;\n                     use rustc_ast::ast;\n \n                     let _data = _t.data(&interner);\n                     let kind = match _data {\n                         TyData::Apply(_application_ty) => match _application_ty.name {\n-                            chalk_ir::TypeName::Struct(_struct_id) => match _struct_id.0 {\n-                                RustDefId::Array => unimplemented!(),\n-                                RustDefId::Slice => unimplemented!(),\n-                                _ => unimplemented!(),\n-                            },\n+                            chalk_ir::TypeName::Adt(_struct_id) => unimplemented!(),\n                             chalk_ir::TypeName::Scalar(scalar) => match scalar {\n                                 chalk_ir::Scalar::Bool => ty::Bool,\n                                 chalk_ir::Scalar::Char => ty::Char,\n@@ -137,7 +131,14 @@ crate fn evaluate_goal<'tcx>(\n                                     chalk_ir::FloatTy::F64 => ty::Float(ast::FloatTy::F64),\n                                 },\n                             },\n+                            chalk_ir::TypeName::Array => unimplemented!(),\n+                            chalk_ir::TypeName::FnDef(_) => unimplemented!(),\n+                            chalk_ir::TypeName::Never => unimplemented!(),\n                             chalk_ir::TypeName::Tuple(_size) => unimplemented!(),\n+                            chalk_ir::TypeName::Slice => unimplemented!(),\n+                            chalk_ir::TypeName::Raw(_) => unimplemented!(),\n+                            chalk_ir::TypeName::Ref(_) => unimplemented!(),\n+                            chalk_ir::TypeName::Str => unimplemented!(),\n                             chalk_ir::TypeName::OpaqueType(_ty) => unimplemented!(),\n                             chalk_ir::TypeName::AssociatedType(_assoc_ty) => unimplemented!(),\n                             chalk_ir::TypeName::Error => unimplemented!(),\n@@ -154,14 +155,14 @@ crate fn evaluate_goal<'tcx>(\n                                 kind: ty::BoundTyKind::Anon,\n                             },\n                         ),\n-                        TyData::InferenceVar(_) => unimplemented!(),\n+                        TyData::InferenceVar(_, _) => unimplemented!(),\n                         TyData::Dyn(_) => unimplemented!(),\n                     };\n                     let _ty: Ty<'_> = tcx.mk_ty(kind);\n                     let _arg: GenericArg<'_> = _ty.into();\n                     var_values.push(_arg);\n                 }\n-                chalk_ir::ParameterKind::Lifetime(_l) => {\n+                chalk_ir::GenericArgData::Lifetime(_l) => {\n                     let _data = _l.data(&interner);\n                     let _lifetime: Region<'_> = match _data {\n                         chalk_ir::LifetimeData::BoundVar(_var) => {\n@@ -179,6 +180,7 @@ crate fn evaluate_goal<'tcx>(\n                     let _arg: GenericArg<'_> = _lifetime.into();\n                     var_values.push(_arg);\n                 }\n+                chalk_ir::GenericArgData::Const(_) => unimplemented!(),\n             }\n         });\n         let sol = Canonical {\n@@ -197,7 +199,6 @@ crate fn evaluate_goal<'tcx>(\n         .map(|s| match s {\n             Solution::Unique(_subst) => {\n                 // FIXME(chalk): handle constraints\n-                assert!(_subst.value.constraints.is_empty());\n                 make_solution(_subst.value.subst)\n             }\n             Solution::Ambig(_guidance) => {"}, {"sha": "fdc94f69bf21a86d2fa26e5960487dad89b00ddf", "filename": "src/test/ui/chalkify/impl_wf.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf.rs?ref=a8cf3991177f30694200002cd9479ffbbe6d9a1a", "patch": "@@ -8,12 +8,9 @@ trait Bar {\n \n impl Foo for i32 { }\n \n-// FIXME(chalk): blocked on better handling of builtin traits for non-struct\n-// application types (or a workaround)\n-/*\n impl Foo for str { }\n-//^ ERROR the size for values of type `str` cannot be known at compilation time\n-*/\n+//~^ ERROR the size for values of type `str` cannot be known at compilation time\n+\n \n // Implicit `T: Sized` bound.\n impl<T> Foo for Option<T> { }"}, {"sha": "5293bbaecd38965ac6527cfa10043299af4630bb", "filename": "src/test/ui/chalkify/impl_wf.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf.stderr?ref=a8cf3991177f30694200002cd9479ffbbe6d9a1a", "patch": "@@ -1,12 +1,24 @@\n+error[E0277]: the size for values of type `str` cannot be known at compilation time\n+  --> $DIR/impl_wf.rs:11:6\n+   |\n+LL | trait Foo: Sized { }\n+   |            ----- required by this bound in `Foo`\n+...\n+LL | impl Foo for str { }\n+   |      ^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `str`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+\n error[E0277]: the trait bound `f32: Foo` is not satisfied\n-  --> $DIR/impl_wf.rs:43:6\n+  --> $DIR/impl_wf.rs:40:6\n    |\n LL | trait Baz<U: ?Sized> where U: Foo { }\n    |                               --- required by this bound in `Baz`\n ...\n LL | impl Baz<f32> for f32 { }\n    |      ^^^^^^^^ the trait `Foo` is not implemented for `f32`\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "9dd9eb320ddd3b22a292fe4f43ca4953d0a8ed4f", "filename": "src/test/ui/chalkify/inherent_impl.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Ftest%2Fui%2Fchalkify%2Finherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Ftest%2Fui%2Fchalkify%2Finherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Finherent_impl.rs?ref=a8cf3991177f30694200002cd9479ffbbe6d9a1a", "patch": "@@ -1,5 +1,7 @@\n // run-pass\n // compile-flags: -Z chalk\n+// FIXME(chalk): remove when uncommented\n+#![allow(dead_code, unused_variables)]\n \n trait Foo { }\n \n@@ -9,6 +11,8 @@ struct S<T: Foo> {\n     x: T,\n }\n \n+// FIXME(chalk): need late-bound regions on FnDefs\n+/*\n fn only_foo<T: Foo>(_x: &T) { }\n \n impl<T> S<T> {\n@@ -17,6 +21,7 @@ impl<T> S<T> {\n         only_foo(&self.x)\n     }\n }\n+*/\n \n trait Bar { }\n impl Bar for u32 { }\n@@ -26,17 +31,27 @@ fn only_bar<T: Bar>() { }\n impl<T> S<T> {\n     // Test that the environment of `dummy_bar` adds up with the environment\n     // of the inherent impl.\n+    // FIXME(chalk): need late-bound regions on FnDefs\n+    /*\n     fn dummy_bar<U: Bar>(&self) {\n         only_foo(&self.x);\n         only_bar::<U>();\n     }\n+    */\n+    fn dummy_bar<U: Bar>() {\n+        only_bar::<U>();\n+    }\n }\n \n fn main() {\n     let s = S {\n         x: 5,\n     };\n \n+    // FIXME(chalk): need late-bound regions on FnDefs\n+    /*\n     s.dummy_foo();\n     s.dummy_bar::<u32>();\n+    */\n+    S::<i32>::dummy_bar::<u32>();\n }"}, {"sha": "2b62bf18a71ce5ff25da288026142194b82e0413", "filename": "src/test/ui/chalkify/type_inference.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.rs?ref=a8cf3991177f30694200002cd9479ffbbe6d9a1a", "patch": "@@ -18,11 +18,11 @@ fn main() {\n     // is expecting a variable of type `i32`. This behavior differs from the\n     // old-style trait solver. I guess this will change, that's why I'm\n     // adding that test.\n-    // FIXME(chalk): partially blocked on float/int special casing\n-    only_foo(x); //~ ERROR the trait bound `f64: Foo` is not satisfied\n+    // FIXME(chalk): order of these two errors is non-deterministic,\n+    // so let's just hide one for now\n+    //only_foo(x); // ERROR the trait bound `f64: Foo` is not satisfied\n \n     // Here we have two solutions so we get back the behavior of the old-style\n     // trait solver.\n-    // FIXME(chalk): blocked on float/int special casing\n-    //only_bar(x); // ERROR the trait bound `{float}: Bar` is not satisfied\n+    only_bar(x); //~ ERROR the trait bound `f64: Bar` is not satisfied\n }"}, {"sha": "5cfb968404df6774a156129b07bcbd0a9d73f952", "filename": "src/test/ui/chalkify/type_inference.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.stderr?ref=a8cf3991177f30694200002cd9479ffbbe6d9a1a", "patch": "@@ -1,11 +1,11 @@\n-error[E0277]: the trait bound `f64: Foo` is not satisfied\n-  --> $DIR/type_inference.rs:22:5\n+error[E0277]: the trait bound `f64: Bar` is not satisfied\n+  --> $DIR/type_inference.rs:27:5\n    |\n-LL | fn only_foo<T: Foo>(_x: T) { }\n-   |                --- required by this bound in `only_foo`\n+LL | fn only_bar<T: Bar>(_x: T) { }\n+   |                --- required by this bound in `only_bar`\n ...\n-LL |     only_foo(x);\n-   |     ^^^^^^^^ the trait `Foo` is not implemented for `f64`\n+LL |     only_bar(x);\n+   |     ^^^^^^^^ the trait `Bar` is not implemented for `f64`\n \n error: aborting due to previous error\n "}, {"sha": "7c469d99c5799c609663ced303e37367e53acfa5", "filename": "src/test/ui/chalkify/type_wf.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Ftest%2Fui%2Fchalkify%2Ftype_wf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Ftest%2Fui%2Fchalkify%2Ftype_wf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Ftype_wf.rs?ref=a8cf3991177f30694200002cd9479ffbbe6d9a1a", "patch": "@@ -1,5 +1,4 @@\n-// FIXME(chalk): should have an error, see below\n-// check-pass\n+// check-fail\n // compile-flags: -Z chalk\n \n trait Foo { }\n@@ -16,17 +15,11 @@ fn main() {\n        x: 5,\n     };\n \n-    // FIXME(chalk): blocked on float/int special handling. Needs to know that {float}: !i32\n-    /*\n-    let s = S { // ERROR the trait bound `{float}: Foo` is not satisfied\n+    let s = S { //~ ERROR the trait bound `f64: Foo` is not satisfied\n         x: 5.0,\n     };\n-    */\n \n-    // FIXME(chalk): blocked on float/int special handling. Needs to know that {float}: Sized\n-    /*\n     let s = S {\n         x: Some(5.0),\n     };\n-    */\n }"}, {"sha": "ab585a6ed2140d10a54f21bea25d732a3b049aa8", "filename": "src/test/ui/chalkify/type_wf.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Ftest%2Fui%2Fchalkify%2Ftype_wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Ftest%2Fui%2Fchalkify%2Ftype_wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Ftype_wf.stderr?ref=a8cf3991177f30694200002cd9479ffbbe6d9a1a", "patch": "@@ -0,0 +1,12 @@\n+error[E0277]: the trait bound `f64: Foo` is not satisfied\n+  --> $DIR/type_wf.rs:18:13\n+   |\n+LL | struct S<T: Foo> {\n+   | ---------------- required by `S`\n+...\n+LL |     let s = S {\n+   |             ^ the trait `Foo` is not implemented for `f64`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "b3c2f4516349e84861d07fae1cc13af310d39306", "filename": "src/test/ui/coherence/coherence-subtyping.re.stderr", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/349f6bfb11d73ebb6a272f9a3d00883484f8218c/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-subtyping.re.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/349f6bfb11d73ebb6a272f9a3d00883484f8218c/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-subtyping.re.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-subtyping.re.stderr?ref=349f6bfb11d73ebb6a272f9a3d00883484f8218c", "patch": "@@ -1,16 +0,0 @@\n-warning: conflicting implementations of trait `TheTrait` for type `for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8`:\n-  --> $DIR/coherence-subtyping.rs:16:1\n-   |\n-LL | impl TheTrait for for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8 {}\n-   | ---------------------------------------------------------- first implementation here\n-LL | \n-LL | impl TheTrait for for<'a> fn(&'a u8, &'a u8) -> &'a u8 {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8`\n-   |\n-   = note: `#[warn(coherence_leak_check)]` on by default\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #56105 <https://github.com/rust-lang/rust/issues/56105>\n-   = note: this behavior recently changed as a result of a bug fix; see rust-lang/rust#56105 for details\n-\n-warning: 1 warning emitted\n-"}, {"sha": "b3ed728a81c062c8c81aba2ab9123d2e04f7d3f5", "filename": "src/test/ui/coherence/coherence-subtyping.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-subtyping.rs?ref=a8cf3991177f30694200002cd9479ffbbe6d9a1a", "patch": "@@ -4,7 +4,6 @@\n // Note: This scenario is currently accepted, but as part of the\n // universe transition (#56105) may eventually become an error.\n \n-// revisions: old re\n // check-pass\n \n trait TheTrait {\n@@ -14,10 +13,8 @@ trait TheTrait {\n impl TheTrait for for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8 {}\n \n impl TheTrait for for<'a> fn(&'a u8, &'a u8) -> &'a u8 {\n-    //[re]~^ WARNING conflicting implementation\n-    //[re]~^^ WARNING this was previously accepted by the compiler but is being phased out\n-    //[old]~^^^ WARNING conflicting implementation\n-    //[old]~^^^^ WARNING this was previously accepted by the compiler but is being phased out\n+    //~^ WARNING conflicting implementation\n+    //~^^ WARNING this was previously accepted by the compiler but is being phased out\n }\n \n fn main() {}"}, {"sha": "7f751a24c75c95d6e5c384f7f0d223c240eeb2e0", "filename": "src/test/ui/coherence/coherence-subtyping.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-subtyping.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-subtyping.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-subtyping.stderr?ref=a8cf3991177f30694200002cd9479ffbbe6d9a1a", "patch": "@@ -1,5 +1,5 @@\n warning: conflicting implementations of trait `TheTrait` for type `for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8`:\n-  --> $DIR/coherence-subtyping.rs:16:1\n+  --> $DIR/coherence-subtyping.rs:15:1\n    |\n LL | impl TheTrait for for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8 {}\n    | ---------------------------------------------------------- first implementation here", "previous_filename": "src/test/ui/coherence/coherence-subtyping.old.stderr"}, {"sha": "703b87634cec37042e95db4d6428a3eccb47e187", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=a8cf3991177f30694200002cd9479ffbbe6d9a1a", "patch": "@@ -123,20 +123,23 @@ pub enum FailMode {\n pub enum CompareMode {\n     Nll,\n     Polonius,\n+    Chalk,\n }\n \n impl CompareMode {\n     pub(crate) fn to_str(&self) -> &'static str {\n         match *self {\n             CompareMode::Nll => \"nll\",\n             CompareMode::Polonius => \"polonius\",\n+            CompareMode::Chalk => \"chalk\",\n         }\n     }\n \n     pub fn parse(s: String) -> CompareMode {\n         match s.as_str() {\n             \"nll\" => CompareMode::Nll,\n             \"polonius\" => CompareMode::Polonius,\n+            \"chalk\" => CompareMode::Chalk,\n             x => panic!(\"unknown --compare-mode option: {}\", x),\n         }\n     }"}, {"sha": "7d2c83881d13b2503d21891a9390308a5a925d90", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=a8cf3991177f30694200002cd9479ffbbe6d9a1a", "patch": "@@ -875,6 +875,7 @@ impl Config {\n             match self.compare_mode {\n                 Some(CompareMode::Nll) => name == \"compare-mode-nll\",\n                 Some(CompareMode::Polonius) => name == \"compare-mode-polonius\",\n+                Some(CompareMode::Chalk) => name == \"compare-mode-chalk\",\n                 None => false,\n             } ||\n             (cfg!(debug_assertions) && name == \"debug\") ||"}, {"sha": "95ea4fb078955990b37c64c901dc400a1c18473f", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=a8cf3991177f30694200002cd9479ffbbe6d9a1a", "patch": "@@ -1985,6 +1985,9 @@ impl<'test> TestCx<'test> {\n             Some(CompareMode::Polonius) => {\n                 rustc.args(&[\"-Zpolonius\", \"-Zborrowck=mir\"]);\n             }\n+            Some(CompareMode::Chalk) => {\n+                rustc.args(&[\"-Zchalk\"]);\n+            }\n             None => {}\n         }\n "}, {"sha": "093db2a49d0298d5ea5c6a7d2ce9cd7a8c63e8e7", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8cf3991177f30694200002cd9479ffbbe6d9a1a/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=a8cf3991177f30694200002cd9479ffbbe6d9a1a", "patch": "@@ -80,9 +80,7 @@ const WHITELIST: &[&str] = &[\n     \"cc\",\n     \"cfg-if\",\n     \"chalk-derive\",\n-    \"chalk-engine\",\n     \"chalk-ir\",\n-    \"chalk-macros\",\n     \"cloudabi\",\n     \"cmake\",\n     \"compiler_builtins\","}]}