{"sha": "db88e5a498ff8a4c7aa6951095e2d217822b11bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiODhlNWE0OThmZjhhNGM3YWE2OTUxMDk1ZTJkMjE3ODIyYjExYmY=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-04-28T08:06:23Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-04-30T12:27:53Z"}, "message": "dropck: Rejectways trait bounds can indirectly access borrowed data.\n\nNamely, we need to catch cases like `trait Child : Parent { }` where\n`Parent` itself defines methods.", "tree": {"sha": "6d6a2043f42f74569ebeffdceefa1170b65eb61c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d6a2043f42f74569ebeffdceefa1170b65eb61c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db88e5a498ff8a4c7aa6951095e2d217822b11bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db88e5a498ff8a4c7aa6951095e2d217822b11bf", "html_url": "https://github.com/rust-lang/rust/commit/db88e5a498ff8a4c7aa6951095e2d217822b11bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db88e5a498ff8a4c7aa6951095e2d217822b11bf/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c76d66e9238840d96b1910ba57a839ef7902485c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c76d66e9238840d96b1910ba57a839ef7902485c", "html_url": "https://github.com/rust-lang/rust/commit/c76d66e9238840d96b1910ba57a839ef7902485c"}], "stats": {"total": 80, "additions": 48, "deletions": 32}, "files": [{"sha": "8545e73c4f932e67238f38cf8a84c2b31d020294", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 48, "deletions": 32, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/db88e5a498ff8a4c7aa6951095e2d217822b11bf/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db88e5a498ff8a4c7aa6951095e2d217822b11bf/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=db88e5a498ff8a4c7aa6951095e2d217822b11bf", "patch": "@@ -450,41 +450,57 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n \n             let dtor_typescheme = ty::lookup_item_type(rcx.tcx(), impl_did);\n             let dtor_generics = dtor_typescheme.generics;\n-            let dtor_predicates = ty::lookup_predicates(rcx.tcx(), impl_did);\n-\n-            let has_pred_of_interest = dtor_predicates.predicates.iter().any(|pred| {\n-                // In `impl<T> Drop where ...`, assume most predicates\n-                // represent capability on `T` via which a destructor\n-                // could access borrowed data. But some bounds (Sized,\n-                // Copy, etc), have no items, i.e. no added capabilty\n-                // for such type-specific access.\n-\n-                let result = match *pred {\n-                    ty::Predicate::Trait(ty::Binder(ref t_pred)) => {\n-                        let def_id = t_pred.trait_ref.def_id;\n-                        // A OIBIT (or even a normal builtin) trait\n-                        // defines no associated items, and is\n-                        // uninteresting from point of view of dropck.\n-                        ty::trait_items(rcx.tcx(), def_id).len() != 0\n-                    }\n-                    ty::Predicate::Equate(..) |\n-                    ty::Predicate::RegionOutlives(..) |\n-                    ty::Predicate::TypeOutlives(..) |\n-                    ty::Predicate::Projection(..) => {\n-                        // for now, assume all other where-clauses may\n-                        // give the drop implementation the capabilty\n-                        // to access borrowed data.\n-                        true\n-                    }\n-                };\n \n-                if result {\n-                    debug!(\"typ: {} has interesting dtor due to generic preds, e.g. {}\",\n-                           typ.repr(rcx.tcx()), pred.repr(rcx.tcx()));\n+            let mut has_pred_of_interest = false;\n+\n+            let mut seen_items = Vec::new();\n+            let mut items_to_inspect = vec![impl_did];\n+            'items: while let Some(item_def_id) = items_to_inspect.pop() {\n+                if seen_items.contains(&item_def_id) {\n+                    continue;\n+                }\n+\n+                for pred in ty::lookup_predicates(rcx.tcx(), item_def_id).predicates {\n+                    let result = match pred {\n+                        ty::Predicate::Equate(..) |\n+                        ty::Predicate::RegionOutlives(..) |\n+                        ty::Predicate::TypeOutlives(..) |\n+                        ty::Predicate::Projection(..) => {\n+                            // For now, assume all these where-clauses\n+                            // may give drop implementation capabilty\n+                            // to access borrowed data.\n+                            true\n+                        }\n+\n+                        ty::Predicate::Trait(ty::Binder(ref t_pred)) => {\n+                            let def_id = t_pred.trait_ref.def_id;\n+                            if ty::trait_items(rcx.tcx(), def_id).len() != 0 {\n+                                // If trait has items, assume it adds\n+                                // capability to access borrowed data.\n+                                true\n+                            } else {\n+                                // Trait without items is itself\n+                                // uninteresting from POV of dropck.\n+                                //\n+                                // However, may have parent w/ items;\n+                                // so schedule checking of predicates,\n+                                items_to_inspect.push(def_id);\n+                                // and say \"no capability found\" for now.\n+                                false\n+                            }\n+                        }\n+                    };\n+\n+                    if result {\n+                        has_pred_of_interest = true;\n+                        debug!(\"typ: {} has interesting dtor due to generic preds, e.g. {}\",\n+                               typ.repr(rcx.tcx()), pred.repr(rcx.tcx()));\n+                        break 'items;\n+                    }\n                 }\n \n-                result\n-            });\n+                seen_items.push(item_def_id);\n+            }\n \n             // In `impl<'a> Drop ...`, we automatically assume\n             // `'a` is meaningful and thus represents a bound"}]}