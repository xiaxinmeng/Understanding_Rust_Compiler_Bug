{"sha": "e3150564f889a3bad01795d9fcb31d4f14d58a99", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzMTUwNTY0Zjg4OWEzYmFkMDE3OTVkOWZjYjMxZDRmMTRkNThhOTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-17T08:29:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-17T08:29:11Z"}, "message": "Auto merge of #50400 - ehuss:compiletest-revisions, r=alexcrichton\n\n compiletest: Run revisions as independent tests.\n\nFixes #47604.\n\n- The output of each test is now in its own directory.\n- \"auxiliary\" output is now under the respective test directory.\n- `stage_id` removed from filenames, and instead placed in the stamp file as a hash.  This helps keep path lengths down for Windows.\n\nIn brief, the new layout looks like this:\n```\n<build_base>/<relative_dir>/<testname>.<revision>.<mode>/\n    stamp\n    <testname>.err\n    <testname>.out\n    a (binary)\n    auxiliary/lib<auxname>.dylib\n    auxiliary/<auxname>/<auxname>.err\n    auxiliary/<auxname>/<auxname>.out\n```\n(revision and mode are optional)", "tree": {"sha": "f1a42616dc7df76565d37b9bc364b87653b3bbee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1a42616dc7df76565d37b9bc364b87653b3bbee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3150564f889a3bad01795d9fcb31d4f14d58a99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3150564f889a3bad01795d9fcb31d4f14d58a99", "html_url": "https://github.com/rust-lang/rust/commit/e3150564f889a3bad01795d9fcb31d4f14d58a99", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3150564f889a3bad01795d9fcb31d4f14d58a99/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed9a29a976f8b73f3fc91a10d0b5addd86a394c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed9a29a976f8b73f3fc91a10d0b5addd86a394c7", "html_url": "https://github.com/rust-lang/rust/commit/ed9a29a976f8b73f3fc91a10d0b5addd86a394c7"}, {"sha": "b8473de7b9309b750fdfafa8f40f3e7302e056f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8473de7b9309b750fdfafa8f40f3e7302e056f3", "html_url": "https://github.com/rust-lang/rust/commit/b8473de7b9309b750fdfafa8f40f3e7302e056f3"}], "stats": {"total": 863, "additions": 473, "deletions": 390}, "files": [{"sha": "48e7ec8c25a22d01b2e8ed4744dd30162c07501e", "filename": "src/test/ui-fulldeps/update-references.sh", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e3150564f889a3bad01795d9fcb31d4f14d58a99/src%2Ftest%2Fui-fulldeps%2Fupdate-references.sh", "raw_url": "https://github.com/rust-lang/rust/raw/e3150564f889a3bad01795d9fcb31d4f14d58a99/src%2Ftest%2Fui-fulldeps%2Fupdate-references.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fupdate-references.sh?ref=e3150564f889a3bad01795d9fcb31d4f14d58a99", "patch": "@@ -31,18 +31,18 @@ MYDIR=$(dirname $0)\n BUILD_DIR=\"$1\"\n shift\n \n+shopt -s nullglob\n+\n while [[ \"$1\" != \"\" ]]; do\n-    STDERR_NAME=\"${1/%.rs/.stderr}\"\n-    STDOUT_NAME=\"${1/%.rs/.stdout}\"\n+    for EXT in \"stderr\" \"stdout\"; do\n+        for OUT_NAME in $BUILD_DIR/${1%.rs}*/*$EXT; do\n+            OUT_DIR=`dirname \"$1\"`\n+            OUT_BASE=`basename \"$OUT_NAME\"`\n+            if ! (diff $OUT_NAME $MYDIR/$OUT_DIR/$OUT_BASE >& /dev/null); then\n+                echo updating $MYDIR/$OUT_DIR/$OUT_BASE\n+                cp $OUT_NAME $MYDIR/$OUT_DIR\n+            fi\n+        done\n+    done\n     shift\n-    if [ -f $BUILD_DIR/$STDOUT_NAME ] && \\\n-           ! (diff $BUILD_DIR/$STDOUT_NAME $MYDIR/$STDOUT_NAME >& /dev/null); then\n-        echo updating $MYDIR/$STDOUT_NAME\n-        cp $BUILD_DIR/$STDOUT_NAME $MYDIR/$STDOUT_NAME\n-    fi\n-    if [ -f $BUILD_DIR/$STDERR_NAME ] && \\\n-           ! (diff $BUILD_DIR/$STDERR_NAME $MYDIR/$STDERR_NAME >& /dev/null); then\n-        echo updating $MYDIR/$STDERR_NAME\n-        cp $BUILD_DIR/$STDERR_NAME $MYDIR/$STDERR_NAME\n-    fi\n done"}, {"sha": "f3c5997fc3f5309dfb4cffc753b3f2cdee73f6fd", "filename": "src/test/ui/update-references.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3150564f889a3bad01795d9fcb31d4f14d58a99/src%2Ftest%2Fui%2Fupdate-references.sh", "raw_url": "https://github.com/rust-lang/rust/raw/e3150564f889a3bad01795d9fcb31d4f14d58a99/src%2Ftest%2Fui%2Fupdate-references.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fupdate-references.sh?ref=e3150564f889a3bad01795d9fcb31d4f14d58a99", "patch": "@@ -35,7 +35,7 @@ shopt -s nullglob\n \n while [[ \"$1\" != \"\" ]]; do\n     for EXT in \"stderr\" \"stdout\" \"fixed\"; do\n-        for OUT_NAME in $BUILD_DIR/${1%.rs}.*$EXT; do\n+        for OUT_NAME in $BUILD_DIR/${1%.rs}*/*$EXT; do\n             OUT_DIR=`dirname \"$1\"`\n             OUT_BASE=`basename \"$OUT_NAME\"`\n             if ! (diff $OUT_NAME $MYDIR/$OUT_DIR/$OUT_BASE >& /dev/null); then"}, {"sha": "812e9c5f39d87f9142eae517dd46ee893c21888c", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 51, "deletions": 11, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e3150564f889a3bad01795d9fcb31d4f14d58a99/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3150564f889a3bad01795d9fcb31d4f14d58a99/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=e3150564f889a3bad01795d9fcb31d4f14d58a99", "patch": "@@ -10,10 +10,11 @@\n pub use self::Mode::*;\n \n use std::fmt;\n+use std::path::{Path, PathBuf};\n use std::str::FromStr;\n-use std::path::PathBuf;\n \n use test::ColorConfig;\n+use util::PathBufExt;\n \n #[derive(Clone, Copy, PartialEq, Debug)]\n pub enum Mode {\n@@ -103,7 +104,7 @@ pub enum CompareMode {\n impl CompareMode {\n     pub(crate) fn to_str(&self) -> &'static str {\n         match *self {\n-            CompareMode::Nll => \"nll\"\n+            CompareMode::Nll => \"nll\",\n         }\n     }\n \n@@ -245,24 +246,28 @@ pub struct Config {\n     pub nodejs: Option<String>,\n }\n \n-#[derive(Clone)]\n+#[derive(Debug, Clone)]\n pub struct TestPaths {\n     pub file: PathBuf,         // e.g., compile-test/foo/bar/baz.rs\n-    pub base: PathBuf,         // e.g., compile-test, auxiliary\n     pub relative_dir: PathBuf, // e.g., foo/bar\n }\n \n /// Used by `ui` tests to generate things like `foo.stderr` from `foo.rs`.\n-pub fn expected_output_path(testpaths: &TestPaths,\n-                            revision: Option<&str>,\n-                            compare_mode: &Option<CompareMode>,\n-                            kind: &str) -> PathBuf {\n-\n+pub fn expected_output_path(\n+    testpaths: &TestPaths,\n+    revision: Option<&str>,\n+    compare_mode: &Option<CompareMode>,\n+    kind: &str,\n+) -> PathBuf {\n     assert!(UI_EXTENSIONS.contains(&kind));\n     let mut parts = Vec::new();\n \n-    if let Some(x) = revision { parts.push(x); }\n-    if let Some(ref x) = *compare_mode { parts.push(x.to_str()); }\n+    if let Some(x) = revision {\n+        parts.push(x);\n+    }\n+    if let Some(ref x) = *compare_mode {\n+        parts.push(x.to_str());\n+    }\n     parts.push(kind);\n \n     let extension = parts.join(\".\");\n@@ -273,3 +278,38 @@ pub const UI_EXTENSIONS: &[&str] = &[UI_STDERR, UI_STDOUT, UI_FIXED];\n pub const UI_STDERR: &str = \"stderr\";\n pub const UI_STDOUT: &str = \"stdout\";\n pub const UI_FIXED: &str = \"fixed\";\n+\n+/// Absolute path to the directory where all output for all tests in the given\n+/// `relative_dir` group should reside. Example:\n+///   /path/to/build/host-triple/test/ui/relative/\n+/// This is created early when tests are collected to avoid race conditions.\n+pub fn output_relative_path(config: &Config, relative_dir: &Path) -> PathBuf {\n+    config.build_base.join(relative_dir)\n+}\n+\n+/// Generates a unique name for the test, such as `testname.revision.mode`.\n+pub fn output_testname_unique(\n+    config: &Config,\n+    testpaths: &TestPaths,\n+    revision: Option<&str>,\n+) -> PathBuf {\n+    let mode = config.compare_mode.as_ref().map_or(\"\", |m| m.to_str());\n+    PathBuf::from(&testpaths.file.file_stem().unwrap())\n+        .with_extra_extension(revision.unwrap_or(\"\"))\n+        .with_extra_extension(mode)\n+}\n+\n+/// Absolute path to the directory where all output for the given\n+/// test/revision should reside.  Example:\n+///   /path/to/build/host-triple/test/ui/relative/testname.revision.mode/\n+pub fn output_base_dir(config: &Config, testpaths: &TestPaths, revision: Option<&str>) -> PathBuf {\n+    output_relative_path(config, &testpaths.relative_dir)\n+        .join(output_testname_unique(config, testpaths, revision))\n+}\n+\n+/// Absolute path to the base filename used as output for the given\n+/// test/revision.  Example:\n+///   /path/to/build/host-triple/test/ui/relative/testname.revision.mode/testname\n+pub fn output_base_name(config: &Config, testpaths: &TestPaths, revision: Option<&str>) -> PathBuf {\n+    output_base_dir(config, testpaths, revision).join(testpaths.file.file_stem().unwrap())\n+}"}, {"sha": "dd2e5557c16d48190f8839b2ee87c0311460fc63", "filename": "src/tools/compiletest/src/errors.rs", "status": "modified", "additions": 41, "deletions": 29, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/e3150564f889a3bad01795d9fcb31d4f14d58a99/src%2Ftools%2Fcompiletest%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3150564f889a3bad01795d9fcb31d4f14d58a99/src%2Ftools%2Fcompiletest%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Ferrors.rs?ref=e3150564f889a3bad01795d9fcb31d4f14d58a99", "patch": "@@ -11,8 +11,8 @@ use self::WhichLine::*;\n \n use std::fmt;\n use std::fs::File;\n-use std::io::BufReader;\n use std::io::prelude::*;\n+use std::io::BufReader;\n use std::path::Path;\n use std::str::FromStr;\n \n@@ -35,8 +35,7 @@ impl FromStr for ErrorKind {\n             \"ERROR\" => Ok(ErrorKind::Error),\n             \"NOTE\" => Ok(ErrorKind::Note),\n             \"SUGGESTION\" => Ok(ErrorKind::Suggestion),\n-            \"WARN\" |\n-            \"WARNING\" => Ok(ErrorKind::Warning),\n+            \"WARN\" | \"WARNING\" => Ok(ErrorKind::Warning),\n             _ => Err(()),\n         }\n     }\n@@ -101,61 +100,74 @@ pub fn load_errors(testfile: &Path, cfg: Option<&str>) -> Vec<Error> {\n     rdr.lines()\n         .enumerate()\n         .filter_map(|(line_num, line)| {\n-            parse_expected(last_nonfollow_error, line_num + 1, &line.unwrap(), &tag)\n-                .map(|(which, error)| {\n+            parse_expected(last_nonfollow_error, line_num + 1, &line.unwrap(), &tag).map(\n+                |(which, error)| {\n                     match which {\n                         FollowPrevious(_) => {}\n                         _ => last_nonfollow_error = Some(error.line_num),\n                     }\n                     error\n-                })\n+                },\n+            )\n         })\n         .collect()\n }\n \n-fn parse_expected(last_nonfollow_error: Option<usize>,\n-                  line_num: usize,\n-                  line: &str,\n-                  tag: &str)\n-                  -> Option<(WhichLine, Error)> {\n+fn parse_expected(\n+    last_nonfollow_error: Option<usize>,\n+    line_num: usize,\n+    line: &str,\n+    tag: &str,\n+) -> Option<(WhichLine, Error)> {\n     let start = match line.find(tag) {\n         Some(i) => i,\n         None => return None,\n     };\n     let (follow, adjusts) = if line[start + tag.len()..].chars().next().unwrap() == '|' {\n         (true, 0)\n     } else {\n-        (false, line[start + tag.len()..].chars().take_while(|c| *c == '^').count())\n+        (\n+            false,\n+            line[start + tag.len()..]\n+                .chars()\n+                .take_while(|c| *c == '^')\n+                .count(),\n+        )\n     };\n     let kind_start = start + tag.len() + adjusts + (follow as usize);\n     let (kind, msg);\n     match line[kind_start..]\n         .split_whitespace()\n         .next()\n         .expect(\"Encountered unexpected empty comment\")\n-        .parse::<ErrorKind>() {\n+        .parse::<ErrorKind>()\n+    {\n         Ok(k) => {\n             // If we find `//~ ERROR foo` or something like that:\n             kind = Some(k);\n             let letters = line[kind_start..].chars();\n-            msg = letters.skip_while(|c| c.is_whitespace())\n+            msg = letters\n+                .skip_while(|c| c.is_whitespace())\n                 .skip_while(|c| !c.is_whitespace())\n                 .collect::<String>();\n         }\n         Err(_) => {\n             // Otherwise we found `//~ foo`:\n             kind = None;\n             let letters = line[kind_start..].chars();\n-            msg = letters.skip_while(|c| c.is_whitespace())\n+            msg = letters\n+                .skip_while(|c| c.is_whitespace())\n                 .collect::<String>();\n         }\n     }\n     let msg = msg.trim().to_owned();\n \n     let (which, line_num) = if follow {\n         assert_eq!(adjusts, 0, \"use either //~| or //~^, not both.\");\n-        let line_num = last_nonfollow_error.expect(\"encountered //~| without \\\n-                                                    preceding //~^ line.\");\n+        let line_num = last_nonfollow_error.expect(\n+            \"encountered //~| without \\\n+             preceding //~^ line.\",\n+        );\n         (FollowPrevious(line_num), line_num)\n     } else {\n         let which = if adjusts > 0 {\n@@ -167,16 +179,16 @@ fn parse_expected(last_nonfollow_error: Option<usize>,\n         (which, line_num)\n     };\n \n-    debug!(\"line={} tag={:?} which={:?} kind={:?} msg={:?}\",\n-           line_num,\n-           tag,\n-           which,\n-           kind,\n-           msg);\n-    Some((which,\n-          Error {\n-        line_num,\n-        kind,\n-        msg,\n-    }))\n+    debug!(\n+        \"line={} tag={:?} which={:?} kind={:?} msg={:?}\",\n+        line_num, tag, which, kind, msg\n+    );\n+    Some((\n+        which,\n+        Error {\n+            line_num,\n+            kind,\n+            msg,\n+        },\n+    ))\n }"}, {"sha": "06ec9e893f0685b7147911834f02010317323998", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 29, "deletions": 42, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/e3150564f889a3bad01795d9fcb31d4f14d58a99/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3150564f889a3bad01795d9fcb31d4f14d58a99/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=e3150564f889a3bad01795d9fcb31d4f14d58a99", "patch": "@@ -10,12 +10,12 @@\n \n use std::env;\n use std::fs::File;\n-use std::io::BufReader;\n use std::io::prelude::*;\n+use std::io::BufReader;\n use std::path::{Path, PathBuf};\n \n-use common::Config;\n use common;\n+use common::Config;\n use util;\n \n use extract_gdb_version;\n@@ -38,19 +38,14 @@ impl EarlyProps {\n             revisions: vec![],\n         };\n \n-        iter_header(testfile,\n-                    None,\n-                    &mut |ln| {\n+        iter_header(testfile, None, &mut |ln| {\n             // we should check if any only-<platform> exists and if it exists\n             // and does not matches the current platform, skip the test\n-            props.ignore =\n-                props.ignore ||\n-                config.parse_cfg_name_directive(ln, \"ignore\") ||\n-                (config.has_cfg_prefix(ln, \"only\") &&\n-                !config.parse_cfg_name_directive(ln, \"only\")) ||\n-                ignore_gdb(config, ln) ||\n-                ignore_lldb(config, ln) ||\n-                ignore_llvm(config, ln);\n+            props.ignore = props.ignore || config.parse_cfg_name_directive(ln, \"ignore\")\n+                || (config.has_cfg_prefix(ln, \"only\")\n+                    && !config.parse_cfg_name_directive(ln, \"only\"))\n+                || ignore_gdb(config, ln) || ignore_lldb(config, ln)\n+                || ignore_llvm(config, ln);\n \n             if let Some(s) = config.parse_aux_build(ln) {\n                 props.aux.push(s);\n@@ -149,7 +144,7 @@ impl EarlyProps {\n \n         fn ignore_llvm(config: &Config, line: &str) -> bool {\n             if config.system_llvm && line.starts_with(\"no-system-llvm\") {\n-                    return true;\n+                return true;\n             }\n             if let Some(ref actual_version) = config.llvm_version {\n                 if line.starts_with(\"min-llvm-version\") {\n@@ -272,11 +267,7 @@ impl TestProps {\n         }\n     }\n \n-    pub fn from_aux_file(&self,\n-                         testfile: &Path,\n-                         cfg: Option<&str>,\n-                         config: &Config)\n-                         -> Self {\n+    pub fn from_aux_file(&self, testfile: &Path, cfg: Option<&str>, config: &Config) -> Self {\n         let mut props = TestProps::new();\n \n         // copy over select properties to the aux build:\n@@ -296,20 +287,15 @@ impl TestProps {\n     /// tied to a particular revision `foo` (indicated by writing\n     /// `//[foo]`), then the property is ignored unless `cfg` is\n     /// `Some(\"foo\")`.\n-    fn load_from(&mut self,\n-                 testfile: &Path,\n-                 cfg: Option<&str>,\n-                 config: &Config) {\n-        iter_header(testfile,\n-                    cfg,\n-                    &mut |ln| {\n+    fn load_from(&mut self, testfile: &Path, cfg: Option<&str>, config: &Config) {\n+        iter_header(testfile, cfg, &mut |ln| {\n             if let Some(ep) = config.parse_error_pattern(ln) {\n                 self.error_patterns.push(ep);\n             }\n \n             if let Some(flags) = config.parse_compile_flags(ln) {\n-                self.compile_flags.extend(flags.split_whitespace()\n-                    .map(|s| s.to_owned()));\n+                self.compile_flags\n+                    .extend(flags.split_whitespace().map(|s| s.to_owned()));\n             }\n \n             if let Some(r) = config.parse_revisions(ln) {\n@@ -382,8 +368,7 @@ impl TestProps {\n \n             if !self.compile_pass {\n                 // run-pass implies must_compile_sucessfully\n-                self.compile_pass =\n-                    config.parse_compile_pass(ln) || self.run_pass;\n+                self.compile_pass = config.parse_compile_pass(ln) || self.run_pass;\n             }\n \n                         if !self.skip_trans {\n@@ -453,7 +438,7 @@ fn iter_header(testfile: &Path, cfg: Option<&str>, it: &mut FnMut(&str)) {\n                     None => false,\n                 };\n                 if matches {\n-                    it(ln[(close_brace + 1) ..].trim_left());\n+                    it(ln[(close_brace + 1)..].trim_left());\n                 }\n             } else {\n                 panic!(\"malformed condition directive: expected `{}foo]`, found `{}`\",\n@@ -554,9 +539,7 @@ impl Config {\n     fn parse_env(&self, line: &str, name: &str) -> Option<(String, String)> {\n         self.parse_name_value_directive(line, name).map(|nv| {\n             // nv is either FOO or FOO=BAR\n-            let mut strs: Vec<String> = nv.splitn(2, '=')\n-                .map(str::to_owned)\n-                .collect();\n+            let mut strs: Vec<String> = nv.splitn(2, '=').map(str::to_owned).collect();\n \n             match strs.len() {\n                 1 => (strs.pop().unwrap(), \"\".to_owned()),\n@@ -599,7 +582,10 @@ impl Config {\n     /// or `normalize-stderr-32bit`. Returns `true` if the line matches it.\n     fn parse_cfg_name_directive(&self, line: &str, prefix: &str) -> bool {\n         if line.starts_with(prefix) && line.as_bytes().get(prefix.len()) == Some(&b'-') {\n-            let name = line[prefix.len()+1 ..].split(&[':', ' '][..]).next().unwrap();\n+            let name = line[prefix.len() + 1..]\n+                .split(&[':', ' '][..])\n+                .next()\n+                .unwrap();\n \n             name == \"test\" ||\n                 util::matches_os(&self.target, name) ||             // target\n@@ -612,8 +598,7 @@ impl Config {\n                     common::DebugInfoLldb => name == \"lldb\",\n                     common::Pretty => name == \"pretty\",\n                     _ => false,\n-                } ||\n-                (self.target != self.host && name == \"cross-compile\")\n+                } || (self.target != self.host && name == \"cross-compile\")\n         } else {\n             false\n         }\n@@ -631,14 +616,14 @@ impl Config {\n         // the line says \"ignore-x86_64\".\n         line.starts_with(directive) && match line.as_bytes().get(directive.len()) {\n             None | Some(&b' ') | Some(&b':') => true,\n-            _ => false\n+            _ => false,\n         }\n     }\n \n     pub fn parse_name_value_directive(&self, line: &str, directive: &str) -> Option<String> {\n         let colon = directive.len();\n         if line.starts_with(directive) && line.as_bytes().get(colon) == Some(&b':') {\n-            let value = line[(colon + 1) ..].to_owned();\n+            let value = line[(colon + 1)..].to_owned();\n             debug!(\"{}: {}\", directive, value);\n             Some(expand_variables(value, self))\n         } else {\n@@ -665,8 +650,10 @@ impl Config {\n }\n \n pub fn lldb_version_to_int(version_string: &str) -> isize {\n-    let error_string = format!(\"Encountered LLDB version string with unexpected format: {}\",\n-                               version_string);\n+    let error_string = format!(\n+        \"Encountered LLDB version string with unexpected format: {}\",\n+        version_string\n+    );\n     version_string.parse().expect(&error_string)\n }\n \n@@ -713,6 +700,6 @@ fn parse_normalization_string(line: &mut &str) -> Option<String> {\n         None => return None,\n     };\n     let result = line[begin..end].to_owned();\n-    *line = &line[end+1..];\n+    *line = &line[end + 1..];\n     Some(result)\n }"}, {"sha": "165f2914ae246d7eba8bf24b964b24d5f7fed0b9", "filename": "src/tools/compiletest/src/json.rs", "status": "modified", "additions": 41, "deletions": 30, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/e3150564f889a3bad01795d9fcb31d4f14d58a99/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3150564f889a3bad01795d9fcb31d4f14d58a99/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs?ref=e3150564f889a3bad01795d9fcb31d4f14d58a99", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n use errors::{Error, ErrorKind};\n+use runtest::ProcRes;\n use serde_json;\n-use std::str::FromStr;\n use std::path::Path;\n-use runtest::ProcRes;\n+use std::str::FromStr;\n \n // These structs are a subset of the ones found in\n // `syntax::json`.\n@@ -58,26 +58,30 @@ struct DiagnosticCode {\n }\n \n pub fn extract_rendered(output: &str, proc_res: &ProcRes) -> String {\n-    output.lines()\n-        .filter_map(|line| if line.starts_with('{') {\n-            match serde_json::from_str::<Diagnostic>(line) {\n-                Ok(diagnostic) => diagnostic.rendered,\n-                Err(error) => {\n-                    proc_res.fatal(Some(&format!(\"failed to decode compiler output as json: \\\n-                                                  `{}`\\noutput: {}\\nline: {}\",\n-                                                 error,\n-                                                 line,\n-                                                 output)));\n+    output\n+        .lines()\n+        .filter_map(|line| {\n+            if line.starts_with('{') {\n+                match serde_json::from_str::<Diagnostic>(line) {\n+                    Ok(diagnostic) => diagnostic.rendered,\n+                    Err(error) => {\n+                        proc_res.fatal(Some(&format!(\n+                            \"failed to decode compiler output as json: \\\n+                             `{}`\\noutput: {}\\nline: {}\",\n+                            error, line, output\n+                        )));\n+                    }\n                 }\n+            } else {\n+                None\n             }\n-        } else {\n-            None\n         })\n         .collect()\n }\n \n pub fn parse_output(file_name: &str, output: &str, proc_res: &ProcRes) -> Vec<Error> {\n-    output.lines()\n+    output\n+        .lines()\n         .flat_map(|line| parse_line(file_name, line, output, proc_res))\n         .collect()\n }\n@@ -93,23 +97,26 @@ fn parse_line(file_name: &str, line: &str, output: &str, proc_res: &ProcRes) ->\n                 expected_errors\n             }\n             Err(error) => {\n-                proc_res.fatal(Some(&format!(\"failed to decode compiler output as json: \\\n-                                              `{}`\\noutput: {}\\nline: {}\",\n-                                             error,\n-                                             line,\n-                                             output)));\n+                proc_res.fatal(Some(&format!(\n+                    \"failed to decode compiler output as json: \\\n+                     `{}`\\noutput: {}\\nline: {}\",\n+                    error, line, output\n+                )));\n             }\n         }\n     } else {\n         vec![]\n     }\n }\n \n-fn push_expected_errors(expected_errors: &mut Vec<Error>,\n-                        diagnostic: &Diagnostic,\n-                        default_spans: &[&DiagnosticSpan],\n-                        file_name: &str) {\n-    let spans_in_this_file: Vec<_> = diagnostic.spans\n+fn push_expected_errors(\n+    expected_errors: &mut Vec<Error>,\n+    diagnostic: &Diagnostic,\n+    default_spans: &[&DiagnosticSpan],\n+    file_name: &str,\n+) {\n+    let spans_in_this_file: Vec<_> = diagnostic\n+        .spans\n         .iter()\n         .filter(|span| Path::new(&span.file_name) == Path::new(&file_name))\n         .collect();\n@@ -204,8 +211,10 @@ fn push_expected_errors(expected_errors: &mut Vec<Error>,\n     }\n \n     // Add notes for any labels that appear in the message.\n-    for span in spans_in_this_file.iter()\n-        .filter(|span| span.label.is_some()) {\n+    for span in spans_in_this_file\n+        .iter()\n+        .filter(|span| span.label.is_some())\n+    {\n         expected_errors.push(Error {\n             line_num: span.line_start,\n             kind: Some(ErrorKind::Note),\n@@ -219,9 +228,11 @@ fn push_expected_errors(expected_errors: &mut Vec<Error>,\n     }\n }\n \n-fn push_backtrace(expected_errors: &mut Vec<Error>,\n-                  expansion: &DiagnosticSpanMacroExpansion,\n-                  file_name: &str) {\n+fn push_backtrace(\n+    expected_errors: &mut Vec<Error>,\n+    expansion: &DiagnosticSpanMacroExpansion,\n+    file_name: &str,\n+) {\n     if Path::new(&expansion.span.file_name) == Path::new(&file_name) {\n         expected_errors.push(Error {\n             line_num: expansion.span.line_start,"}, {"sha": "42a2cdfa55b5ad9ee78a913d1195402ecd54b7be", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 101, "deletions": 80, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/e3150564f889a3bad01795d9fcb31d4f14d58a99/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3150564f889a3bad01795d9fcb31d4f14d58a99/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=e3150564f889a3bad01795d9fcb31d4f14d58a99", "patch": "@@ -31,31 +31,31 @@ extern crate serde_json;\n extern crate test;\n extern crate rustfix;\n \n+use common::CompareMode;\n+use common::{expected_output_path, output_base_dir, output_relative_path, UI_EXTENSIONS};\n+use common::{Config, TestPaths};\n+use common::{DebugInfoGdb, DebugInfoLldb, Mode, Pretty};\n+use filetime::FileTime;\n+use getopts::Options;\n use std::env;\n use std::ffi::OsString;\n use std::fs;\n-use std::io;\n+use std::io::{self, Read};\n use std::path::{Path, PathBuf};\n use std::process::Command;\n-use filetime::FileTime;\n-use getopts::Options;\n-use common::{Config, TestPaths};\n-use common::{DebugInfoGdb, DebugInfoLldb, Mode, Pretty};\n-use common::{expected_output_path, UI_EXTENSIONS};\n-use common::CompareMode;\n use test::ColorConfig;\n use util::logv;\n \n use self::header::EarlyProps;\n \n-pub mod util;\n-mod json;\n-pub mod header;\n-pub mod runtest;\n pub mod common;\n pub mod errors;\n+pub mod header;\n+mod json;\n mod raise_fd_limit;\n mod read2;\n+pub mod runtest;\n+pub mod util;\n \n fn main() {\n     env_logger::init();\n@@ -236,7 +236,7 @@ pub fn parse_config(args: Vec<String>) -> Config {\n             \"\",\n             \"compare-mode\",\n             \"mode describing what file the actual ui output will be compared to\",\n-            \"COMPARE MODE\"\n+            \"COMPARE MODE\",\n         )\n         .optflag(\"h\", \"help\", \"show this message\");\n \n@@ -501,7 +501,11 @@ pub fn test_opts(config: &Config) -> test::TestOpts {\n         filter: config.filter.clone(),\n         filter_exact: config.filter_exact,\n         run_ignored: config.run_ignored,\n-        format: if config.quiet { test::OutputFormat::Terse } else { test::OutputFormat::Pretty },\n+        format: if config.quiet {\n+            test::OutputFormat::Terse\n+        } else {\n+            test::OutputFormat::Pretty\n+        },\n         logfile: config.logfile.clone(),\n         run_tests: true,\n         bench_benchmarks: true,\n@@ -548,10 +552,9 @@ fn collect_tests_from_dir(\n         if name == *\"Makefile\" && config.mode == Mode::RunMake {\n             let paths = TestPaths {\n                 file: dir.to_path_buf(),\n-                base: base.to_path_buf(),\n                 relative_dir: relative_dir_path.parent().unwrap().to_path_buf(),\n             };\n-            tests.push(make_test(config, &paths));\n+            tests.extend(make_test(config, &paths));\n             return Ok(());\n         }\n     }\n@@ -562,7 +565,7 @@ fn collect_tests_from_dir(\n     // sequential loop because otherwise, if we do it in the\n     // tests themselves, they race for the privilege of\n     // creating the directories and sometimes fail randomly.\n-    let build_dir = config.build_base.join(&relative_dir_path);\n+    let build_dir = output_relative_path(config, relative_dir_path);\n     fs::create_dir_all(&build_dir).unwrap();\n \n     // Add each `.rs` file as a test, and recurse further on any\n@@ -576,21 +579,12 @@ fn collect_tests_from_dir(\n             debug!(\"found test file: {:?}\", file_path.display());\n             let paths = TestPaths {\n                 file: file_path,\n-                base: base.to_path_buf(),\n                 relative_dir: relative_dir_path.to_path_buf(),\n             };\n-            tests.push(make_test(config, &paths))\n+            tests.extend(make_test(config, &paths))\n         } else if file_path.is_dir() {\n             let relative_file_path = relative_dir_path.join(file.file_name());\n-            if &file_name == \"auxiliary\" {\n-                // `aux` directories contain other crates used for\n-                // cross-crate tests. Don't search them for tests, but\n-                // do create a directory in the build dir for them,\n-                // since we will dump intermediate output in there\n-                // sometimes.\n-                let build_dir = config.build_base.join(&relative_file_path);\n-                fs::create_dir_all(&build_dir).unwrap();\n-            } else {\n+            if &file_name != \"auxiliary\" {\n                 debug!(\"found directory: {:?}\", file_path.display());\n                 collect_tests_from_dir(config, base, &file_path, &relative_file_path, tests)?;\n             }\n@@ -613,7 +607,7 @@ pub fn is_test(file_name: &OsString) -> bool {\n     !invalid_prefixes.iter().any(|p| file_name.starts_with(p))\n }\n \n-pub fn make_test(config: &Config, testpaths: &TestPaths) -> test::TestDescAndFn {\n+pub fn make_test(config: &Config, testpaths: &TestPaths) -> Vec<test::TestDescAndFn> {\n     let early_props = if config.mode == Mode::RunMake {\n         // Allow `ignore` directives to be in the Makefile.\n         EarlyProps::from_file(config, &testpaths.file.join(\"Makefile\"))\n@@ -633,47 +627,68 @@ pub fn make_test(config: &Config, testpaths: &TestPaths) -> test::TestDescAndFn\n         },\n     };\n \n-    // Debugging emscripten code doesn't make sense today\n-    let ignore = early_props.ignore\n-        || !up_to_date(config, testpaths, &early_props)\n-        || (config.mode == DebugInfoGdb || config.mode == DebugInfoLldb)\n-            && config.target.contains(\"emscripten\");\n-\n-    test::TestDescAndFn {\n-        desc: test::TestDesc {\n-            name: make_test_name(config, testpaths),\n-            ignore,\n-            should_panic,\n-            allow_fail: false,\n-        },\n-        testfn: make_test_closure(config, testpaths),\n-    }\n+    // Incremental tests are special, they inherently cannot be run in parallel.\n+    // `runtest::run` will be responsible for iterating over revisions.\n+    let revisions = if early_props.revisions.is_empty() || config.mode == Mode::Incremental {\n+        vec![None]\n+    } else {\n+        early_props.revisions.iter().map(|r| Some(r)).collect()\n+    };\n+    revisions\n+        .into_iter()\n+        .map(|revision| {\n+            // Debugging emscripten code doesn't make sense today\n+            let ignore = early_props.ignore\n+                || !up_to_date(\n+                    config,\n+                    testpaths,\n+                    &early_props,\n+                    revision.map(|s| s.as_str()),\n+                )\n+                || (config.mode == DebugInfoGdb || config.mode == DebugInfoLldb)\n+                    && config.target.contains(\"emscripten\");\n+            test::TestDescAndFn {\n+                desc: test::TestDesc {\n+                    name: make_test_name(config, testpaths, revision),\n+                    ignore,\n+                    should_panic,\n+                    allow_fail: false,\n+                },\n+                testfn: make_test_closure(config, testpaths, revision),\n+            }\n+        })\n+        .collect()\n }\n \n-fn stamp(config: &Config, testpaths: &TestPaths) -> PathBuf {\n-    let mode_suffix = match config.compare_mode {\n-        Some(ref mode) => format!(\"-{}\", mode.to_str()),\n-        None => format!(\"\"),\n-    };\n-    let stamp_name = format!(\n-        \"{}-{}{}.stamp\",\n-        testpaths.file.file_name().unwrap().to_str().unwrap(),\n-        config.stage_id,\n-        mode_suffix\n-    );\n-    config\n-        .build_base\n-        .canonicalize()\n-        .unwrap_or_else(|_| config.build_base.clone())\n-        .join(&testpaths.relative_dir)\n-        .join(stamp_name)\n+fn stamp(config: &Config, testpaths: &TestPaths, revision: Option<&str>) -> PathBuf {\n+    output_base_dir(config, testpaths, revision).join(\"stamp\")\n }\n \n-fn up_to_date(config: &Config, testpaths: &TestPaths, props: &EarlyProps) -> bool {\n+fn up_to_date(\n+    config: &Config,\n+    testpaths: &TestPaths,\n+    props: &EarlyProps,\n+    revision: Option<&str>,\n+) -> bool {\n+    let stamp_name = stamp(config, testpaths, revision);\n+    // Check hash.\n+    let mut f = match fs::File::open(&stamp_name) {\n+        Ok(f) => f,\n+        Err(_) => return true,\n+    };\n+    let mut contents = String::new();\n+    f.read_to_string(&mut contents)\n+        .expect(\"Can't read stamp contents\");\n+    let expected_hash = runtest::compute_stamp_hash(config);\n+    if contents != expected_hash {\n+        return true;\n+    }\n+\n+    // Check timestamps.\n     let rust_src_dir = config\n         .find_rust_src_root()\n         .expect(\"Could not find Rust source root\");\n-    let stamp = mtime(&stamp(config, testpaths));\n+    let stamp = mtime(&stamp_name);\n     let mut inputs = vec![mtime(&testpaths.file), mtime(&config.rustc_path)];\n     for aux in props.aux.iter() {\n         inputs.push(mtime(&testpaths\n@@ -694,8 +709,7 @@ fn up_to_date(config: &Config, testpaths: &TestPaths, props: &EarlyProps) -> boo\n     for pretty_printer_file in &pretty_printer_files {\n         inputs.push(mtime(&rust_src_dir.join(pretty_printer_file)));\n     }\n-    let mut entries = config.run_lib_path.read_dir().unwrap()\n-        .collect::<Vec<_>>();\n+    let mut entries = config.run_lib_path.read_dir().unwrap().collect::<Vec<_>>();\n     while let Some(entry) = entries.pop() {\n         let entry = entry.unwrap();\n         let path = entry.path();\n@@ -712,18 +726,8 @@ fn up_to_date(config: &Config, testpaths: &TestPaths, props: &EarlyProps) -> boo\n \n     // UI test files.\n     for extension in UI_EXTENSIONS {\n-        for revision in &props.revisions {\n-            let path = &expected_output_path(testpaths,\n-                                             Some(revision),\n-                                             &config.compare_mode,\n-                                             extension);\n-            inputs.push(mtime(path));\n-        }\n-\n-        if props.revisions.is_empty() {\n-            let path = &expected_output_path(testpaths, None, &config.compare_mode, extension);\n-            inputs.push(mtime(path));\n-        }\n+        let path = &expected_output_path(testpaths, revision, &config.compare_mode, extension);\n+        inputs.push(mtime(path));\n     }\n \n     inputs.iter().any(|input| *input > stamp)\n@@ -735,7 +739,11 @@ fn mtime(path: &Path) -> FileTime {\n         .unwrap_or_else(|_| FileTime::zero())\n }\n \n-pub fn make_test_name(config: &Config, testpaths: &TestPaths) -> test::TestName {\n+fn make_test_name(\n+    config: &Config,\n+    testpaths: &TestPaths,\n+    revision: Option<&String>,\n+) -> test::TestName {\n     // Convert a complete path to something like\n     //\n     //    run-pass/foo/bar/baz.rs\n@@ -746,13 +754,26 @@ pub fn make_test_name(config: &Config, testpaths: &TestPaths) -> test::TestName\n         Some(ref mode) => format!(\" ({})\", mode.to_str()),\n         None => format!(\"\"),\n     };\n-    test::DynTestName(format!(\"[{}{}] {}\", config.mode, mode_suffix, path.display()))\n+    test::DynTestName(format!(\n+        \"[{}{}] {}{}\",\n+        config.mode,\n+        mode_suffix,\n+        path.display(),\n+        revision.map_or(\"\".to_string(), |rev| format!(\"#{}\", rev))\n+    ))\n }\n \n-pub fn make_test_closure(config: &Config, testpaths: &TestPaths) -> test::TestFn {\n+fn make_test_closure(\n+    config: &Config,\n+    testpaths: &TestPaths,\n+    revision: Option<&String>,\n+) -> test::TestFn {\n     let config = config.clone();\n     let testpaths = testpaths.clone();\n-    test::DynTestFn(Box::new(move || runtest::run(config, &testpaths)))\n+    let revision = revision.cloned();\n+    test::DynTestFn(Box::new(move || {\n+        runtest::run(config, &testpaths, revision.as_ref().map(|s| s.as_str()))\n+    }))\n }\n \n /// Returns (Path to GDB, GDB Version, GDB has Rust Support)"}, {"sha": "220082799a8b081430a128853a63d10482ebb520", "filename": "src/tools/compiletest/src/raise_fd_limit.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e3150564f889a3bad01795d9fcb31d4f14d58a99/src%2Ftools%2Fcompiletest%2Fsrc%2Fraise_fd_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3150564f889a3bad01795d9fcb31d4f14d58a99/src%2Ftools%2Fcompiletest%2Fsrc%2Fraise_fd_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fraise_fd_limit.rs?ref=e3150564f889a3bad01795d9fcb31d4f14d58a99", "patch": "@@ -34,12 +34,15 @@ pub unsafe fn raise_fd_limit() {\n     let mut mib: [libc::c_int; 2] = [CTL_KERN, KERN_MAXFILESPERPROC];\n     let mut maxfiles: libc::c_int = 0;\n     let mut size: libc::size_t = size_of_val(&maxfiles) as libc::size_t;\n-    if libc::sysctl(&mut mib[0],\n-                    2,\n-                    &mut maxfiles as *mut _ as *mut _,\n-                    &mut size,\n-                    null_mut(),\n-                    0) != 0 {\n+    if libc::sysctl(\n+        &mut mib[0],\n+        2,\n+        &mut maxfiles as *mut _ as *mut _,\n+        &mut size,\n+        null_mut(),\n+        0,\n+    ) != 0\n+    {\n         let err = io::Error::last_os_error();\n         panic!(\"raise_fd_limit: error calling sysctl: {}\", err);\n     }"}, {"sha": "5bf898f5f1bafc3a637a59fb734e76ff123422a6", "filename": "src/tools/compiletest/src/read2.rs", "status": "modified", "additions": 33, "deletions": 27, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e3150564f889a3bad01795d9fcb31d4f14d58a99/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3150564f889a3bad01795d9fcb31d4f14d58a99/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs?ref=e3150564f889a3bad01795d9fcb31d4f14d58a99", "patch": "@@ -16,11 +16,13 @@ pub use self::imp::read2;\n #[cfg(not(any(unix, windows)))]\n mod imp {\n     use std::io::{self, Read};\n-    use std::process::{ChildStdout, ChildStderr};\n+    use std::process::{ChildStderr, ChildStdout};\n \n-    pub fn read2(out_pipe: ChildStdout,\n-                 err_pipe: ChildStderr,\n-                 data: &mut FnMut(bool, &mut Vec<u8>, bool)) -> io::Result<()> {\n+    pub fn read2(\n+        out_pipe: ChildStdout,\n+        err_pipe: ChildStderr,\n+        data: &mut FnMut(bool, &mut Vec<u8>, bool),\n+    ) -> io::Result<()> {\n         let mut buffer = Vec::new();\n         out_pipe.read_to_end(&mut buffer)?;\n         data(true, &mut buffer, true);\n@@ -33,16 +35,18 @@ mod imp {\n \n #[cfg(unix)]\n mod imp {\n-    use std::io::prelude::*;\n+    use libc;\n     use std::io;\n+    use std::io::prelude::*;\n     use std::mem;\n     use std::os::unix::prelude::*;\n-    use std::process::{ChildStdout, ChildStderr};\n-    use libc;\n+    use std::process::{ChildStderr, ChildStdout};\n \n-    pub fn read2(mut out_pipe: ChildStdout,\n-                 mut err_pipe: ChildStderr,\n-                 data: &mut FnMut(bool, &mut Vec<u8>, bool)) -> io::Result<()> {\n+    pub fn read2(\n+        mut out_pipe: ChildStdout,\n+        mut err_pipe: ChildStderr,\n+        data: &mut FnMut(bool, &mut Vec<u8>, bool),\n+    ) -> io::Result<()> {\n         unsafe {\n             libc::fcntl(out_pipe.as_raw_fd(), libc::F_SETFL, libc::O_NONBLOCK);\n             libc::fcntl(err_pipe.as_raw_fd(), libc::F_SETFL, libc::O_NONBLOCK);\n@@ -67,25 +71,23 @@ mod imp {\n             if r == -1 {\n                 let err = io::Error::last_os_error();\n                 if err.kind() == io::ErrorKind::Interrupted {\n-                    continue\n+                    continue;\n                 }\n-                return Err(err)\n+                return Err(err);\n             }\n \n             // Read as much as we can from each pipe, ignoring EWOULDBLOCK or\n             // EAGAIN. If we hit EOF, then this will happen because the underlying\n             // reader will return Ok(0), in which case we'll see `Ok` ourselves. In\n             // this case we flip the other fd back into blocking mode and read\n             // whatever's leftover on that file descriptor.\n-            let handle = |res: io::Result<_>| {\n-                match res {\n-                    Ok(_) => Ok(true),\n-                    Err(e) => {\n-                        if e.kind() == io::ErrorKind::WouldBlock {\n-                            Ok(false)\n-                        } else {\n-                            Err(e)\n-                        }\n+            let handle = |res: io::Result<_>| match res {\n+                Ok(_) => Ok(true),\n+                Err(e) => {\n+                    if e.kind() == io::ErrorKind::WouldBlock {\n+                        Ok(false)\n+                    } else {\n+                        Err(e)\n                     }\n                 }\n             };\n@@ -113,7 +115,7 @@ mod imp {\n \n     use std::io;\n     use std::os::windows::prelude::*;\n-    use std::process::{ChildStdout, ChildStderr};\n+    use std::process::{ChildStderr, ChildStdout};\n     use std::slice;\n \n     use self::miow::iocp::{CompletionPort, CompletionStatus};\n@@ -128,9 +130,11 @@ mod imp {\n         done: bool,\n     }\n \n-    pub fn read2(out_pipe: ChildStdout,\n-                 err_pipe: ChildStderr,\n-                 data: &mut FnMut(bool, &mut Vec<u8>, bool)) -> io::Result<()> {\n+    pub fn read2(\n+        out_pipe: ChildStdout,\n+        err_pipe: ChildStderr,\n+        data: &mut FnMut(bool, &mut Vec<u8>, bool),\n+    ) -> io::Result<()> {\n         let mut out = Vec::new();\n         let mut err = Vec::new();\n \n@@ -206,7 +210,9 @@ mod imp {\n         if v.capacity() == v.len() {\n             v.reserve(1);\n         }\n-        slice::from_raw_parts_mut(v.as_mut_ptr().offset(v.len() as isize),\n-                                  v.capacity() - v.len())\n+        slice::from_raw_parts_mut(\n+            v.as_mut_ptr().offset(v.len() as isize),\n+            v.capacity() - v.len(),\n+        )\n     }\n }"}, {"sha": "59d94e1fa51e1eeea457674c862d46d7dfb075ef", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 132, "deletions": 151, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/e3150564f889a3bad01795d9fcb31d4f14d58a99/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3150564f889a3bad01795d9fcb31d4f14d58a99/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=e3150564f889a3bad01795d9fcb31d4f14d58a99", "patch": "@@ -8,28 +8,29 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use common::{Config, TestPaths};\n-use common::{CompileFail, ParseFail, Pretty, RunFail, RunPass, RunPassValgrind};\n+use common::CompareMode;\n+use common::{expected_output_path, UI_STDERR, UI_STDOUT, UI_FIXED};\n+use common::{output_base_dir, output_base_name, output_testname_unique};\n use common::{Codegen, CodegenUnits, DebugInfoGdb, DebugInfoLldb, Rustdoc};\n+use common::{CompileFail, ParseFail, Pretty, RunFail, RunPass, RunPassValgrind};\n+use common::{Config, TestPaths};\n use common::{Incremental, MirOpt, RunMake, Ui};\n-use common::{expected_output_path, UI_STDERR, UI_STDOUT, UI_FIXED};\n-use common::CompareMode;\n use diff;\n use errors::{self, Error, ErrorKind};\n use filetime::FileTime;\n-use json;\n use header::TestProps;\n-use util::logv;\n+use json;\n use regex::Regex;\n use rustfix::{apply_suggestions, get_suggestions_from_json};\n+use util::{logv, PathBufExt};\n \n-use std::collections::VecDeque;\n-use std::collections::HashMap;\n-use std::collections::HashSet;\n+use std::collections::{HashMap, HashSet, VecDeque};\n+use std::collections::hash_map::DefaultHasher;\n use std::env;\n-use std::ffi::{OsStr, OsString};\n-use std::fs::{self, create_dir_all, File};\n+use std::ffi::OsString;\n use std::fmt;\n+use std::fs::{self, create_dir_all, File};\n+use std::hash::{Hash, Hasher};\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n use std::path::{Path, PathBuf};\n@@ -106,26 +107,6 @@ impl Mismatch {\n     }\n }\n \n-trait PathBufExt {\n-    /// Append an extension to the path, even if it already has one.\n-    fn with_extra_extension<S: AsRef<OsStr>>(&self, extension: S) -> PathBuf;\n-}\n-\n-impl PathBufExt for PathBuf {\n-    fn with_extra_extension<S: AsRef<OsStr>>(&self, extension: S) -> PathBuf {\n-        if extension.as_ref().len() == 0 {\n-            self.clone()\n-        } else {\n-            let mut fname = self.file_name().unwrap().to_os_string();\n-            if !extension.as_ref().to_str().unwrap().starts_with(\".\") {\n-                fname.push(\".\");\n-            }\n-            fname.push(extension);\n-            self.with_file_name(fname)\n-        }\n-    }\n-}\n-\n // Produces a diff between the expected output and actual output.\n pub fn make_diff(expected: &str, actual: &str, context_size: usize) -> Vec<Mismatch> {\n     let mut line_number = 1;\n@@ -186,7 +167,7 @@ pub fn make_diff(expected: &str, actual: &str, context_size: usize) -> Vec<Misma\n     results\n }\n \n-pub fn run(config: Config, testpaths: &TestPaths) {\n+pub fn run(config: Config, testpaths: &TestPaths, revision: Option<&str>) {\n     match &*config.target {\n         \"arm-linux-androideabi\" | \"armv7-linux-androideabi\" | \"aarch64-linux-android\" => {\n             if !config.adb_device_status {\n@@ -207,20 +188,25 @@ pub fn run(config: Config, testpaths: &TestPaths) {\n         print!(\"\\n\\n\");\n     }\n     debug!(\"running {:?}\", testpaths.file.display());\n-    let base_props = TestProps::from_file(&testpaths.file, None, &config);\n+    let props = TestProps::from_file(&testpaths.file, revision, &config);\n \n-    let base_cx = TestCx {\n+    let cx = TestCx {\n         config: &config,\n-        props: &base_props,\n+        props: &props,\n         testpaths,\n-        revision: None,\n+        revision: revision,\n     };\n-    base_cx.init_all();\n+    create_dir_all(&cx.output_base_dir()).unwrap();\n \n-    if base_props.revisions.is_empty() {\n-        base_cx.run_revision()\n-    } else {\n-        for revision in &base_props.revisions {\n+    if config.mode == Incremental {\n+        // Incremental tests are special because they cannot be run in\n+        // parallel.\n+        assert!(\n+            !props.revisions.is_empty(),\n+            \"Incremental tests require revisions.\"\n+        );\n+        cx.init_incremental_test();\n+        for revision in &props.revisions {\n             let revision_props = TestProps::from_file(&testpaths.file, Some(revision), &config);\n             let rev_cx = TestCx {\n                 config: &config,\n@@ -230,11 +216,17 @@ pub fn run(config: Config, testpaths: &TestPaths) {\n             };\n             rev_cx.run_revision();\n         }\n+    } else {\n+        cx.run_revision();\n     }\n \n-    base_cx.complete_all();\n+    cx.create_stamp();\n+}\n \n-    File::create(::stamp(&config, testpaths)).unwrap();\n+pub fn compute_stamp_hash(config: &Config) -> String {\n+    let mut hash = DefaultHasher::new();\n+    config.stage_id.hash(&mut hash);\n+    format!(\"{:x}\", hash.finish())\n }\n \n struct TestCx<'test> {\n@@ -251,14 +243,6 @@ struct DebuggerCommands {\n }\n \n impl<'test> TestCx<'test> {\n-    /// invoked once before any revisions have been processed\n-    fn init_all(&self) {\n-        assert!(self.revision.is_none(), \"init_all invoked for a revision\");\n-        if let Incremental = self.config.mode {\n-            self.init_incremental_test()\n-        }\n-    }\n-\n     /// Code executed for each revision in turn (or, if there are no\n     /// revisions, exactly once, with revision == None).\n     fn run_revision(&self) {\n@@ -280,11 +264,6 @@ impl<'test> TestCx<'test> {\n         }\n     }\n \n-    /// Invoked after all revisions have executed.\n-    fn complete_all(&self) {\n-        assert!(self.revision.is_none(), \"init_all invoked for a revision\");\n-    }\n-\n     fn check_if_test_should_compile(&self, proc_res: &ProcRes) {\n         if self.props.compile_pass {\n             if !proc_res.status.success() {\n@@ -355,9 +334,10 @@ impl<'test> TestCx<'test> {\n \n         if expected_status != received_status {\n             self.fatal_proc_rec(\n-                &format!(\"Error: expected failure status ({:?}) but received status {:?}.\",\n-                         expected_status,\n-                         received_status),\n+                &format!(\n+                    \"Error: expected failure status ({:?}) but received status {:?}.\",\n+                    expected_status, received_status\n+                ),\n                 proc_res,\n             );\n         }\n@@ -440,8 +420,7 @@ impl<'test> TestCx<'test> {\n                 self.config,\n                 format!(\n                     \"pretty-printing round {} revision {:?}\",\n-                    round,\n-                    self.revision\n+                    round, self.revision\n                 ),\n             );\n             let proc_res = self.print_source(srcs[round].to_owned(), &self.props.pretty_mode);\n@@ -450,8 +429,7 @@ impl<'test> TestCx<'test> {\n                 self.fatal_proc_rec(\n                     &format!(\n                         \"pretty-printing failed in round {} revision {:?}\",\n-                        round,\n-                        self.revision\n+                        round, self.revision\n                     ),\n                     &proc_res,\n                 );\n@@ -555,8 +533,7 @@ impl<'test> TestCx<'test> {\n                  {}\\n\\\n                  ------------------------------------------\\n\\\n                  \\n\",\n-                expected,\n-                actual\n+                expected, actual\n             );\n         }\n     }\n@@ -661,8 +638,7 @@ impl<'test> TestCx<'test> {\n                 script_str.push_str(&format!(\n                     \"set solib-search-path \\\n                      ./{}/stage2/lib/rustlib/{}/lib/\\n\",\n-                    self.config.host,\n-                    self.config.target\n+                    self.config.host, self.config.target\n                 ));\n                 for line in &breakpoint_lines {\n                     script_str.push_str(\n@@ -881,7 +857,6 @@ impl<'test> TestCx<'test> {\n             ..self.config.clone()\n         };\n \n-\n         let test_cx = TestCx {\n             config: &config,\n             ..*self\n@@ -952,8 +927,7 @@ impl<'test> TestCx<'test> {\n         for line in &breakpoint_lines {\n             script_str.push_str(&format!(\n                 \"breakpoint set --file '{}' --line {}\\n\",\n-                source_file_name,\n-                line\n+                source_file_name, line\n             ));\n         }\n \n@@ -1028,9 +1002,7 @@ impl<'test> TestCx<'test> {\n     fn parse_debugger_commands(&self, debugger_prefixes: &[&str]) -> DebuggerCommands {\n         let directives = debugger_prefixes\n             .iter()\n-            .map(|prefix| {\n-                (format!(\"{}-command\", prefix), format!(\"{}-check\", prefix))\n-            })\n+            .map(|prefix| (format!(\"{}-command\", prefix), format!(\"{}-check\", prefix)))\n             .collect::<Vec<_>>();\n \n         let mut breakpoint_lines = vec![];\n@@ -1041,12 +1013,11 @@ impl<'test> TestCx<'test> {\n         for line in reader.lines() {\n             match line {\n                 Ok(line) => {\n-                    let line =\n-                        if line.starts_with(\"//\") {\n-                            line[2..].trim_left()\n-                        } else {\n-                            line.as_str()\n-                        };\n+                    let line = if line.starts_with(\"//\") {\n+                        line[2..].trim_left()\n+                    } else {\n+                        line.as_str()\n+                    };\n \n                     if line.contains(\"#break\") {\n                         breakpoint_lines.push(counter);\n@@ -1369,6 +1340,8 @@ impl<'test> TestCx<'test> {\n                     testpaths: &aux_testpaths,\n                     revision: self.revision,\n                 };\n+                // Create the directory for the stdout/stderr files.\n+                create_dir_all(aux_cx.output_base_dir()).unwrap();\n                 let auxres = aux_cx.document(out_dir);\n                 if !auxres.status.success() {\n                     return auxres;\n@@ -1453,7 +1426,7 @@ impl<'test> TestCx<'test> {\n                 let mut program = Command::new(&prog);\n                 program\n                     .args(args)\n-                    .current_dir(&self.output_base_name().parent().unwrap())\n+                    .current_dir(&self.output_base_dir())\n                     .envs(env.clone());\n                 self.compose_and_run(\n                     program,\n@@ -1491,9 +1464,9 @@ impl<'test> TestCx<'test> {\n \n         TestPaths {\n             file: test_ab,\n-            base: self.testpaths.base.clone(),\n             relative_dir: self.testpaths\n                 .relative_dir\n+                .join(self.output_testname_unique())\n                 .join(\"auxiliary\")\n                 .join(rel_ab)\n                 .parent()\n@@ -1503,28 +1476,27 @@ impl<'test> TestCx<'test> {\n     }\n \n     fn compose_and_run_compiler(&self, mut rustc: Command, input: Option<String>) -> ProcRes {\n+        let aux_dir = self.aux_output_dir_name();\n+\n         if !self.props.aux_builds.is_empty() {\n-            create_dir_all(&self.aux_output_dir_name()).unwrap();\n+            let _ = fs::remove_dir_all(&aux_dir);\n+            create_dir_all(&aux_dir).unwrap();\n         }\n \n-        let aux_dir = self.aux_output_dir_name();\n-\n         for rel_ab in &self.props.aux_builds {\n             let aux_testpaths = self.compute_aux_test_paths(rel_ab);\n             let aux_props =\n                 self.props\n                     .from_aux_file(&aux_testpaths.file, self.revision, self.config);\n-            let aux_output = {\n-                let f = self.make_lib_name(&self.testpaths.file);\n-                let parent = f.parent().unwrap();\n-                TargetLocation::ThisDirectory(parent.to_path_buf())\n-            };\n+            let aux_output = TargetLocation::ThisDirectory(self.aux_output_dir_name());\n             let aux_cx = TestCx {\n                 config: self.config,\n                 props: &aux_props,\n                 testpaths: &aux_testpaths,\n                 revision: self.revision,\n             };\n+            // Create the directory for the stdout/stderr files.\n+            create_dir_all(aux_cx.output_base_dir()).unwrap();\n             let mut aux_rustc = aux_cx.make_compile_args(&aux_testpaths.file, aux_output);\n \n             let crate_type = if aux_props.no_prefer_dynamic {\n@@ -1645,9 +1617,13 @@ impl<'test> TestCx<'test> {\n         let mut rustc = if !is_rustdoc {\n             Command::new(&self.config.rustc_path)\n         } else {\n-            Command::new(&self.config.rustdoc_path.clone().expect(\"no rustdoc built yet\"))\n+            Command::new(&self.config\n+                .rustdoc_path\n+                .clone()\n+                .expect(\"no rustdoc built yet\"))\n         };\n-        rustc.arg(input_file).arg(\"-L\").arg(&self.config.build_base);\n+        // FIXME Why is -L here?\n+        rustc.arg(input_file);//.arg(\"-L\").arg(&self.config.build_base);\n \n         // Optionally prevent default --target if specified in test compile-flags.\n         let custom_target = self.props\n@@ -1671,10 +1647,7 @@ impl<'test> TestCx<'test> {\n \n         if !is_rustdoc {\n             if let Some(ref incremental_dir) = self.props.incremental_dir {\n-                rustc.args(&[\n-                    \"-C\",\n-                    &format!(\"incremental={}\", incremental_dir.display()),\n-                ]);\n+                rustc.args(&[\"-C\", &format!(\"incremental={}\", incremental_dir.display())]);\n                 rustc.args(&[\"-Z\", \"incremental-verify-ich\"]);\n                 rustc.args(&[\"-Z\", \"incremental-queries\"]);\n             }\n@@ -1697,7 +1670,11 @@ impl<'test> TestCx<'test> {\n                 }\n             }\n             Ui => {\n-                if !self.props.compile_flags.iter().any(|s| s.starts_with(\"--error-format\")) {\n+                if !self.props\n+                    .compile_flags\n+                    .iter()\n+                    .any(|s| s.starts_with(\"--error-format\"))\n+                {\n                     rustc.args(&[\"--error-format\", \"json\"]);\n                 }\n                 if !self.props.disable_ui_testing_normalization {\n@@ -1720,16 +1697,8 @@ impl<'test> TestCx<'test> {\n \n                 rustc.arg(dir_opt);\n             }\n-            RunPass |\n-            RunFail |\n-            RunPassValgrind |\n-            Pretty |\n-            DebugInfoGdb |\n-            DebugInfoLldb |\n-            Codegen |\n-            Rustdoc |\n-            RunMake |\n-            CodegenUnits => {\n+            RunPass | RunFail | RunPassValgrind | Pretty | DebugInfoGdb | DebugInfoLldb\n+            | Codegen | Rustdoc | RunMake | CodegenUnits => {\n                 // do not use JSON output\n             }\n         }\n@@ -1759,8 +1728,8 @@ impl<'test> TestCx<'test> {\n         match self.config.compare_mode {\n             Some(CompareMode::Nll) => {\n                 rustc.args(&[\"-Zborrowck=mir\", \"-Ztwo-phase-borrows\"]);\n-            },\n-            None => {},\n+            }\n+            None => {}\n         }\n \n         if self.props.force_host {\n@@ -1779,15 +1748,12 @@ impl<'test> TestCx<'test> {\n         rustc\n     }\n \n-    fn make_lib_name(&self, auxfile: &Path) -> PathBuf {\n-        // what we return here is not particularly important, as it\n-        // happens; rustc ignores everything except for the directory.\n-        let auxname = self.output_testname(auxfile);\n-        self.aux_output_dir_name().join(&auxname)\n-    }\n-\n     fn make_exe_name(&self) -> PathBuf {\n-        let mut f = self.output_base_name_stage();\n+        // Using a single letter here to keep the path length down for\n+        // Windows.  Some test names get very long.  rustc creates `rcgu`\n+        // files with the module name appended to it which can more than\n+        // double the length.\n+        let mut f = self.output_base_dir().join(\"a\");\n         // FIXME: This is using the host architecture exe suffix, not target!\n         if self.config.target.contains(\"emscripten\") {\n             f = f.with_extra_extension(\"js\");\n@@ -1897,33 +1863,47 @@ impl<'test> TestCx<'test> {\n             .unwrap();\n     }\n \n+    /// Create a filename for output with the given extension.  Example:\n+    ///   /.../testname.revision.mode/testname.extension\n     fn make_out_name(&self, extension: &str) -> PathBuf {\n         self.output_base_name().with_extension(extension)\n     }\n \n+    /// Directory where auxiliary files are written.  Example:\n+    ///   /.../testname.revision.mode/auxiliary/\n     fn aux_output_dir_name(&self) -> PathBuf {\n-        self.output_base_name_stage()\n+        self.output_base_dir()\n+            .join(\"auxiliary\")\n             .with_extra_extension(self.config.mode.disambiguator())\n-            .with_extra_extension(\".aux\")\n     }\n \n-    fn output_testname(&self, filepath: &Path) -> PathBuf {\n-        PathBuf::from(filepath.file_stem().unwrap())\n+    /// Generates a unique name for the test, such as `testname.revision.mode`.\n+    fn output_testname_unique(&self) -> PathBuf {\n+        output_testname_unique(self.config, self.testpaths, self.safe_revision())\n     }\n \n-    /// Given a test path like `compile-fail/foo/bar.rs` returns a name like\n-    /// `/path/to/build/<triple>/test/compile-fail/foo/bar`.\n-    fn output_base_name(&self) -> PathBuf {\n-        let dir = self.config.build_base.join(&self.testpaths.relative_dir);\n+    /// The revision, ignored for Incremental since it wants all revisions in\n+    /// the same directory.\n+    fn safe_revision(&self) -> Option<&str> {\n+        if self.config.mode == Incremental {\n+            None\n+        } else {\n+            self.revision\n+        }\n+    }\n \n-        // Note: The directory `dir` is created during `collect_tests_from_dir`\n-        dir.join(&self.output_testname(&self.testpaths.file))\n+    /// Absolute path to the directory where all output for the given\n+    /// test/revision should reside.  Example:\n+    ///   /path/to/build/host-triple/test/ui/relative/testname.revision.mode/\n+    fn output_base_dir(&self) -> PathBuf {\n+        output_base_dir(self.config, self.testpaths, self.safe_revision())\n     }\n \n-    /// Same as `output_base_name`, but includes the stage ID as an extension,\n-    /// such as: `.../compile-fail/foo/bar.stage1-<triple>`\n-    fn output_base_name_stage(&self) -> PathBuf {\n-        self.output_base_name().with_extension(&self.config.stage_id)\n+    /// Absolute path to the base filename used as output for the given\n+    /// test/revision.  Example:\n+    ///   /.../relative/testname.revision.mode/testname\n+    fn output_base_name(&self) -> PathBuf {\n+        output_base_name(self.config, self.testpaths, self.safe_revision())\n     }\n \n     fn maybe_dump_to_stdout(&self, out: &str, err: &str) {\n@@ -1998,8 +1978,7 @@ impl<'test> TestCx<'test> {\n     fn compile_test_and_save_ir(&self) -> ProcRes {\n         let aux_dir = self.aux_output_dir_name();\n \n-        let output_file =\n-            TargetLocation::ThisDirectory(self.output_base_name().parent().unwrap().to_path_buf());\n+        let output_file = TargetLocation::ThisDirectory(self.output_base_dir());\n         let mut rustc = self.make_compile_args(&self.testpaths.file, output_file);\n         rustc.arg(\"-L\").arg(aux_dir).arg(\"--emit=llvm-ir\");\n \n@@ -2048,7 +2027,7 @@ impl<'test> TestCx<'test> {\n     fn run_rustdoc_test(&self) {\n         assert!(self.revision.is_none(), \"revisions not relevant here\");\n \n-        let out_dir = self.output_base_name_stage();\n+        let out_dir = self.output_base_dir();\n         let _ = fs::remove_dir_all(&out_dir);\n         create_dir_all(&out_dir).unwrap();\n \n@@ -2376,7 +2355,7 @@ impl<'test> TestCx<'test> {\n     fn run_incremental_test(&self) {\n         // Basic plan for a test incremental/foo/bar.rs:\n         // - load list of revisions rpass1, cfail2, rpass3\n-        //   - each should begin with `rpass`, `cfail`, or `cfail`\n+        //   - each should begin with `rpass`, `cfail`, or `rfail`\n         //   - if `rpass`, expect compile and execution to succeed\n         //   - if `cfail`, expect compilation to fail\n         //   - if `rfail`, expect execution to fail\n@@ -2417,8 +2396,7 @@ impl<'test> TestCx<'test> {\n         if self.config.verbose {\n             print!(\n                 \"revision={:?} revision_props={:#?}\",\n-                revision,\n-                revision_props\n+                revision, revision_props\n             );\n         }\n \n@@ -2450,7 +2428,7 @@ impl<'test> TestCx<'test> {\n             .unwrap();\n         let src_root = cwd.join(&src_root);\n \n-        let tmpdir = cwd.join(self.output_base_name_stage());\n+        let tmpdir = cwd.join(self.output_base_name());\n         if tmpdir.exists() {\n             self.aggressive_rm_rf(&tmpdir).unwrap();\n         }\n@@ -2731,8 +2709,7 @@ impl<'test> TestCx<'test> {\n         if source_time > output_time {\n             debug!(\n                 \"source file time: {:?} output file time: {:?}\",\n-                source_time,\n-                output_time\n+                source_time, output_time\n             );\n             panic!(\n                 \"test source file `{}` is newer than potentially stale output file `{}`.\",\n@@ -2906,10 +2883,12 @@ impl<'test> TestCx<'test> {\n     }\n \n     fn expected_output_path(&self, kind: &str) -> PathBuf {\n-        let mut path = expected_output_path(&self.testpaths,\n-                                            self.revision,\n-                                            &self.config.compare_mode,\n-                                            kind);\n+        let mut path = expected_output_path(\n+            &self.testpaths,\n+            self.revision,\n+            &self.config.compare_mode,\n+            kind,\n+        );\n         if !path.exists() && self.config.compare_mode.is_some() {\n             // fallback!\n             path = expected_output_path(&self.testpaths, self.revision, &None, kind);\n@@ -2959,14 +2938,14 @@ impl<'test> TestCx<'test> {\n                         DiffLine::Expected(e) => {\n                             println!(\"-\\t{}\", e);\n                             line_number += 1;\n-                        },\n+                        }\n                         DiffLine::Context(c) => {\n                             println!(\"{}\\t{}\", line_number, c);\n                             line_number += 1;\n-                        },\n+                        }\n                         DiffLine::Resulting(r) => {\n                             println!(\"+\\t{}\", r);\n-                        },\n+                        }\n                     }\n                 }\n                 println!(\"\");\n@@ -2993,6 +2972,11 @@ impl<'test> TestCx<'test> {\n         println!(\"Actual {} saved to {}\", kind, output_file.display());\n         1\n     }\n+\n+    fn create_stamp(&self) {\n+        let mut f = File::create(::stamp(&self.config, self.testpaths, self.revision)).unwrap();\n+        f.write_all(compute_stamp_hash(&self.config).as_bytes()).unwrap();\n+    }\n }\n \n struct ProcArgs {\n@@ -3025,10 +3009,7 @@ impl ProcRes {\n              {}\\n\\\n              ------------------------------------------\\n\\\n              \\n\",\n-            self.status,\n-            self.cmdline,\n-            self.stdout,\n-            self.stderr\n+            self.status, self.cmdline, self.stdout, self.stderr\n         );\n         panic!();\n     }\n@@ -3072,8 +3053,8 @@ fn nocomment_mir_line(line: &str) -> &str {\n }\n \n fn read2_abbreviated(mut child: Child) -> io::Result<Output> {\n-    use std::mem::replace;\n     use read2::read2;\n+    use std::mem::replace;\n \n     const HEAD_LEN: usize = 160 * 1024;\n     const TAIL_LEN: usize = 256 * 1024;"}, {"sha": "91e7399f1f492288cc5184d006fc850074b6abc6", "filename": "src/tools/compiletest/src/util.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e3150564f889a3bad01795d9fcb31d4f14d58a99/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3150564f889a3bad01795d9fcb31d4f14d58a99/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs?ref=e3150564f889a3bad01795d9fcb31d4f14d58a99", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::ffi::OsStr;\n use std::env;\n+use std::path::PathBuf;\n use common::Config;\n \n /// Conversion table from triple OS name to Rust SYSNAME\n@@ -73,7 +75,7 @@ pub fn matches_os(triple: &str, name: &str) -> bool {\n     // For the wasm32 bare target we ignore anything also ignored on emscripten\n     // and then we also recognize `wasm32-bare` as the os for the target\n     if triple == \"wasm32-unknown-unknown\" {\n-        return name == \"emscripten\" || name == \"wasm32-bare\"\n+        return name == \"emscripten\" || name == \"wasm32-bare\";\n     }\n     let triple: Vec<_> = triple.split('-').collect();\n     for &(triple_os, os) in OS_TABLE {\n@@ -128,3 +130,23 @@ pub fn logv(config: &Config, s: String) {\n         println!(\"{}\", s);\n     }\n }\n+\n+pub trait PathBufExt {\n+    /// Append an extension to the path, even if it already has one.\n+    fn with_extra_extension<S: AsRef<OsStr>>(&self, extension: S) -> PathBuf;\n+}\n+\n+impl PathBufExt for PathBuf {\n+    fn with_extra_extension<S: AsRef<OsStr>>(&self, extension: S) -> PathBuf {\n+        if extension.as_ref().len() == 0 {\n+            self.clone()\n+        } else {\n+            let mut fname = self.file_name().unwrap().to_os_string();\n+            if !extension.as_ref().to_str().unwrap().starts_with(\".\") {\n+                fname.push(\".\");\n+            }\n+            fname.push(extension);\n+            self.with_file_name(fname)\n+        }\n+    }\n+}"}]}