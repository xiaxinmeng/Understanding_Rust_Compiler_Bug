{"sha": "022dff47e3fecbd7355a88355b0ecf4943065074", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyMmRmZjQ3ZTNmZWNiZDczNTVhODgzNTViMGVjZjQ5NDMwNjUwNzQ=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-04-25T22:49:52Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-05-12T23:28:20Z"}, "message": "Add a Rayon thread pool", "tree": {"sha": "054859c79e611a51478059857f1798e7dbeff1dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/054859c79e611a51478059857f1798e7dbeff1dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/022dff47e3fecbd7355a88355b0ecf4943065074", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/022dff47e3fecbd7355a88355b0ecf4943065074", "html_url": "https://github.com/rust-lang/rust/commit/022dff47e3fecbd7355a88355b0ecf4943065074", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/022dff47e3fecbd7355a88355b0ecf4943065074/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3df199680a34b28b8eeb023a4e26dd6b40c3f9df", "url": "https://api.github.com/repos/rust-lang/rust/commits/3df199680a34b28b8eeb023a4e26dd6b40c3f9df", "html_url": "https://github.com/rust-lang/rust/commit/3df199680a34b28b8eeb023a4e26dd6b40c3f9df"}], "stats": {"total": 776, "additions": 431, "deletions": 345}, "files": [{"sha": "bbf873290a928f76a277fb5ef8213fc7b8adb831", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/022dff47e3fecbd7355a88355b0ecf4943065074/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022dff47e3fecbd7355a88355b0ecf4943065074/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=022dff47e3fecbd7355a88355b0ecf4943065074", "patch": "@@ -869,10 +869,16 @@ impl Session {\n         ret\n     }\n \n+    /// Returns the number of query threads that should be used for this\n+    /// compilation\n+    pub fn query_threads_from_opts(opts: &config::Options) -> usize {\n+        opts.debugging_opts.query_threads.unwrap_or(1)\n+    }\n+\n     /// Returns the number of query threads that should be used for this\n     /// compilation\n     pub fn query_threads(&self) -> usize {\n-        self.opts.debugging_opts.query_threads.unwrap_or(1)\n+        Self::query_threads_from_opts(&self.opts)\n     }\n \n     /// Returns the number of codegen units that should be used for this"}, {"sha": "dcd20465fbb9a1537954f701501564de942c0a43", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/022dff47e3fecbd7355a88355b0ecf4943065074/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022dff47e3fecbd7355a88355b0ecf4943065074/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=022dff47e3fecbd7355a88355b0ecf4943065074", "patch": "@@ -1800,9 +1800,11 @@ pub mod tls {\n     /// in librustc otherwise. It is used to when diagnostic messages are\n     /// emitted and stores them in the current query, if there is one.\n     fn track_diagnostic(diagnostic: &Diagnostic) {\n-        with_context(|context| {\n-            if let Some(ref query) = context.query {\n-                query.diagnostics.lock().push(diagnostic.clone());\n+        with_context_opt(|icx| {\n+            if let Some(icx) = icx {\n+                if let Some(ref query) = icx.query {\n+                    query.diagnostics.lock().push(diagnostic.clone());\n+                }\n             }\n         })\n     }"}, {"sha": "1827533f0acb5977be80b10f24c89e85f7291980", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022dff47e3fecbd7355a88355b0ecf4943065074/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/022dff47e3fecbd7355a88355b0ecf4943065074/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=022dff47e3fecbd7355a88355b0ecf4943065074", "patch": "@@ -13,6 +13,8 @@ arena = { path = \"../libarena\" }\n graphviz = { path = \"../libgraphviz\" }\n log = \"0.4\"\n env_logger = { version = \"0.5\", default-features = false }\n+rustc-rayon = \"0.1.0\"\n+scoped-tls = { version = \"0.1.1\", features = [\"nightly\"] }\n rustc = { path = \"../librustc\" }\n rustc_allocator = { path = \"../librustc_allocator\" }\n rustc_target = { path = \"../librustc_target\" }"}, {"sha": "62b3accc46f18e6bfc85600df45e1def21ef59c2", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/022dff47e3fecbd7355a88355b0ecf4943065074/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022dff47e3fecbd7355a88355b0ecf4943065074/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=022dff47e3fecbd7355a88355b0ecf4943065074", "patch": "@@ -49,7 +49,7 @@ use std::fs;\n use std::io::{self, Write};\n use std::iter;\n use std::path::{Path, PathBuf};\n-use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::sync::{self, Lrc};\n use std::sync::mpsc;\n use syntax::{self, ast, attr, diagnostics, visit};\n use syntax::ext::base::ExtCtxt;\n@@ -64,6 +64,51 @@ use pretty::ReplaceBodyWithLoop;\n \n use profile;\n \n+#[cfg(not(parallel_queries))]\n+pub fn spawn_thread_pool<F: FnOnce(config::Options) -> R + sync::Send, R: sync::Send>(\n+    opts: config::Options,\n+    f: F\n+) -> R {\n+    f(opts)\n+}\n+\n+#[cfg(parallel_queries)]\n+pub fn spawn_thread_pool<F: FnOnce(config::Options) -> R + sync::Send, R: sync::Send>(\n+    opts: config::Options,\n+    f: F\n+) -> R {\n+    use syntax;\n+    use syntax_pos;\n+    use rayon::{ThreadPoolBuilder, ThreadPool};\n+\n+    let config = ThreadPoolBuilder::new().num_threads(Session::query_threads_from_opts(&opts))\n+                                         .stack_size(16 * 1024 * 1024);\n+\n+    let with_pool = move |pool: &ThreadPool| {\n+        pool.install(move || f(opts))\n+    };\n+\n+    syntax::GLOBALS.with(|syntax_globals| {\n+        syntax_pos::GLOBALS.with(|syntax_pos_globals| {\n+            // The main handler run for each Rayon worker thread and sets up\n+            // the thread local rustc uses. syntax_globals and syntax_pos_globals are\n+            // captured and set on the new threads. ty::tls::with_thread_locals sets up\n+            // thread local callbacks from libsyntax\n+            let main_handler = move |worker: &mut FnMut()| {\n+                syntax::GLOBALS.set(syntax_globals, || {\n+                    syntax_pos::GLOBALS.set(syntax_pos_globals, || {\n+                        ty::tls::with_thread_locals(|| {\n+                            worker()\n+                        })\n+                    })\n+                })\n+            };\n+\n+            ThreadPool::scoped_pool(config, main_handler, with_pool).unwrap()\n+        })\n+    })\n+}\n+\n pub fn compile_input(\n     trans: Box<TransCrate>,\n     sess: &Session,"}, {"sha": "148fbd73e9bd8ffc7d1e9cafea1c8cf684c0b684", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/022dff47e3fecbd7355a88355b0ecf4943065074/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022dff47e3fecbd7355a88355b0ecf4943065074/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=022dff47e3fecbd7355a88355b0ecf4943065074", "patch": "@@ -35,6 +35,7 @@ extern crate graphviz;\n extern crate env_logger;\n #[cfg(unix)]\n extern crate libc;\n+extern crate rustc_rayon as rayon;\n extern crate rustc;\n extern crate rustc_allocator;\n extern crate rustc_target;\n@@ -53,6 +54,7 @@ extern crate rustc_save_analysis;\n extern crate rustc_traits;\n extern crate rustc_trans_utils;\n extern crate rustc_typeck;\n+extern crate scoped_tls;\n extern crate serialize;\n #[macro_use]\n extern crate log;\n@@ -66,7 +68,7 @@ use pretty::{PpMode, UserIdentifiedItem};\n use rustc_resolve as resolve;\n use rustc_save_analysis as save;\n use rustc_save_analysis::DumpHandler;\n-use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::sync::{self, Lrc};\n use rustc_data_structures::OnDrop;\n use rustc::session::{self, config, Session, build_session, CompileResult};\n use rustc::session::CompileIncomplete;\n@@ -450,36 +452,40 @@ fn get_trans_sysroot(backend_name: &str) -> fn() -> Box<TransCrate> {\n // See comments on CompilerCalls below for details about the callbacks argument.\n // The FileLoader provides a way to load files from sources other than the file system.\n pub fn run_compiler<'a>(args: &[String],\n-                        callbacks: &mut CompilerCalls<'a>,\n+                        callbacks: &mut (CompilerCalls<'a> + sync::Send),\n                         file_loader: Option<Box<FileLoader + Send + Sync + 'static>>,\n                         emitter_dest: Option<Box<Write + Send>>)\n                         -> (CompileResult, Option<Session>)\n {\n     syntax::with_globals(|| {\n-        run_compiler_impl(args, callbacks, file_loader, emitter_dest)\n+        let matches = match handle_options(args) {\n+            Some(matches) => matches,\n+            None => return (Ok(()), None),\n+        };\n+\n+        let (sopts, cfg) = config::build_session_options_and_crate_config(&matches);\n+\n+        driver::spawn_thread_pool(sopts, |sopts| {\n+            run_compiler_with_pool(matches, sopts, cfg, callbacks, file_loader, emitter_dest)\n+        })\n     })\n }\n \n-fn run_compiler_impl<'a>(args: &[String],\n-                         callbacks: &mut CompilerCalls<'a>,\n-                         file_loader: Option<Box<FileLoader + Send + Sync + 'static>>,\n-                         emitter_dest: Option<Box<Write + Send>>)\n-                         -> (CompileResult, Option<Session>)\n-{\n+fn run_compiler_with_pool<'a>(\n+    matches: getopts::Matches,\n+    sopts: config::Options,\n+    cfg: ast::CrateConfig,\n+    callbacks: &mut (CompilerCalls<'a> + sync::Send),\n+    file_loader: Option<Box<FileLoader + Send + Sync + 'static>>,\n+    emitter_dest: Option<Box<Write + Send>>\n+) -> (CompileResult, Option<Session>) {\n     macro_rules! do_or_return {($expr: expr, $sess: expr) => {\n         match $expr {\n             Compilation::Stop => return (Ok(()), $sess),\n             Compilation::Continue => {}\n         }\n     }}\n \n-    let matches = match handle_options(args) {\n-        Some(matches) => matches,\n-        None => return (Ok(()), None),\n-    };\n-\n-    let (sopts, cfg) = config::build_session_options_and_crate_config(&matches);\n-\n     let descriptions = diagnostics_registry();\n \n     do_or_return!(callbacks.early_callback(&matches,"}, {"sha": "7ae26e9e9798e72c15b8f64e70d1459c0b90e6c5", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/022dff47e3fecbd7355a88355b0ecf4943065074/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022dff47e3fecbd7355a88355b0ecf4943065074/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=022dff47e3fecbd7355a88355b0ecf4943065074", "patch": "@@ -99,20 +99,25 @@ fn test_env<F>(source_string: &str,\n     where F: FnOnce(Env)\n {\n     syntax::with_globals(|| {\n-        test_env_impl(source_string, args, body)\n+        let mut options = config::basic_options();\n+        options.debugging_opts.verbose = true;\n+        options.unstable_features = UnstableFeatures::Allow;\n+\n+        driver::spawn_thread_pool(options, |options| {\n+            test_env_with_pool(options, source_string, args, body)\n+        })\n     });\n }\n \n-fn test_env_impl<F>(source_string: &str,\n-                    (emitter, expected_err_count): (Box<Emitter + sync::Send>, usize),\n-                    body: F)\n+fn test_env_with_pool<F>(\n+    options: config::Options,\n+    source_string: &str,\n+    (emitter, expected_err_count): (Box<Emitter + sync::Send>, usize),\n+    body: F\n+)\n     where F: FnOnce(Env)\n {\n-    let mut options = config::basic_options();\n-    options.debugging_opts.verbose = true;\n-    options.unstable_features = UnstableFeatures::Allow;\n     let diagnostic_handler = errors::Handler::with_emitter(true, false, emitter);\n-\n     let sess = session::build_session_(options,\n                                        None,\n                                        diagnostic_handler,"}, {"sha": "7d3ba792829382c75d6f613225f906aa1882dc9a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/022dff47e3fecbd7355a88355b0ecf4943065074/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022dff47e3fecbd7355a88355b0ecf4943065074/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=022dff47e3fecbd7355a88355b0ecf4943065074", "patch": "@@ -697,7 +697,7 @@ impl<'a> FromIterator<&'a DocFragment> for String {\n pub struct Attributes {\n     pub doc_strings: Vec<DocFragment>,\n     pub other_attrs: Vec<ast::Attribute>,\n-    pub cfg: Option<Rc<Cfg>>,\n+    pub cfg: Option<Arc<Cfg>>,\n     pub span: Option<syntax_pos::Span>,\n     /// map from Rust paths to resolved defs and potential URL fragments\n     pub links: Vec<(String, Option<DefId>, Option<String>)>,\n@@ -848,7 +848,7 @@ impl Attributes {\n         Attributes {\n             doc_strings,\n             other_attrs,\n-            cfg: if cfg == Cfg::True { None } else { Some(Rc::new(cfg)) },\n+            cfg: if cfg == Cfg::True { None } else { Some(Arc::new(cfg)) },\n             span: sp,\n             links: vec![],\n         }"}, {"sha": "6222edd5450f05cc1facd4fe4271816daab71d5a", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 153, "deletions": 152, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/022dff47e3fecbd7355a88355b0ecf4943065074/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022dff47e3fecbd7355a88355b0ecf4943065074/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=022dff47e3fecbd7355a88355b0ecf4943065074", "patch": "@@ -161,161 +161,162 @@ pub fn run_core(search_paths: SearchPaths,\n         edition,\n         ..config::basic_options().clone()\n     };\n-\n-    let codemap = Lrc::new(codemap::CodeMap::new(sessopts.file_path_mapping()));\n-    let emitter: Box<dyn Emitter + sync::Send> = match error_format {\n-        ErrorOutputType::HumanReadable(color_config) => Box::new(\n-            EmitterWriter::stderr(\n-                color_config,\n-                Some(codemap.clone()),\n-                false,\n-                sessopts.debugging_opts.teach,\n-            ).ui_testing(sessopts.debugging_opts.ui_testing)\n-        ),\n-        ErrorOutputType::Json(pretty) => Box::new(\n-            JsonEmitter::stderr(\n-                None,\n-                codemap.clone(),\n-                pretty,\n-                sessopts.debugging_opts.suggestion_applicability,\n-            ).ui_testing(sessopts.debugging_opts.ui_testing)\n-        ),\n-        ErrorOutputType::Short(color_config) => Box::new(\n-            EmitterWriter::stderr(color_config, Some(codemap.clone()), true, false)\n-        ),\n-    };\n-\n-    let diagnostic_handler = errors::Handler::with_emitter_and_flags(\n-        emitter,\n-        errors::HandlerFlags {\n-            can_emit_warnings: true,\n-            treat_err_as_bug: false,\n-            external_macro_backtrace: false,\n-            ..Default::default()\n-        },\n-    );\n-\n-    let mut sess = session::build_session_(\n-        sessopts, cpath, diagnostic_handler, codemap,\n-    );\n-    let trans = rustc_driver::get_trans(&sess);\n-    let cstore = Rc::new(CStore::new(trans.metadata_loader()));\n-    rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n-\n-    let mut cfg = config::build_configuration(&sess, config::parse_cfgspecs(cfgs));\n-    target_features::add_configuration(&mut cfg, &sess, &*trans);\n-    sess.parse_sess.config = cfg;\n-\n-    let control = &driver::CompileController::basic();\n-\n-    let krate = panictry!(driver::phase_1_parse_input(control, &sess, &input));\n-\n-    let name = ::rustc_trans_utils::link::find_crate_name(Some(&sess), &krate.attrs, &input);\n-\n-    let mut crate_loader = CrateLoader::new(&sess, &cstore, &name);\n-\n-    let resolver_arenas = resolve::Resolver::arenas();\n-    let result = driver::phase_2_configure_and_expand_inner(&sess,\n-                                                      &cstore,\n-                                                      krate,\n-                                                      None,\n-                                                      &name,\n-                                                      None,\n-                                                      resolve::MakeGlobMap::No,\n-                                                      &resolver_arenas,\n-                                                      &mut crate_loader,\n-                                                      |_| Ok(()));\n-    let driver::InnerExpansionResult {\n-        mut hir_forest,\n-        resolver,\n-        ..\n-    } = abort_on_err(result, &sess);\n-\n-    // We need to hold on to the complete resolver, so we clone everything\n-    // for the analysis passes to use. Suboptimal, but necessary in the\n-    // current architecture.\n-    let defs = resolver.definitions.clone();\n-    let resolutions = ty::Resolutions {\n-        freevars: resolver.freevars.clone(),\n-        export_map: resolver.export_map.clone(),\n-        trait_map: resolver.trait_map.clone(),\n-        maybe_unused_trait_imports: resolver.maybe_unused_trait_imports.clone(),\n-        maybe_unused_extern_crates: resolver.maybe_unused_extern_crates.clone(),\n-    };\n-    let analysis = ty::CrateAnalysis {\n-        access_levels: Lrc::new(AccessLevels::default()),\n-        name: name.to_string(),\n-        glob_map: if resolver.make_glob_map { Some(resolver.glob_map.clone()) } else { None },\n-    };\n-\n-    let arenas = AllArenas::new();\n-    let hir_map = hir_map::map_crate(&sess, &*cstore, &mut hir_forest, &defs);\n-    let output_filenames = driver::build_output_filenames(&input,\n-                                                          &None,\n-                                                          &None,\n-                                                          &[],\n-                                                          &sess);\n-\n-    let resolver = RefCell::new(resolver);\n-\n-    abort_on_err(driver::phase_3_run_analysis_passes(&*trans,\n-                                                     control,\n-                                                     &sess,\n-                                                     &*cstore,\n-                                                     hir_map,\n-                                                     analysis,\n-                                                     resolutions,\n-                                                     &arenas,\n-                                                     &name,\n-                                                     &output_filenames,\n-                                                     |tcx, analysis, _, result| {\n-        if let Err(_) = result {\n-            sess.fatal(\"Compilation failed, aborting rustdoc\");\n-        }\n-\n-        let ty::CrateAnalysis { access_levels, .. } = analysis;\n-\n-        // Convert from a NodeId set to a DefId set since we don't always have easy access\n-        // to the map from defid -> nodeid\n-        let access_levels = AccessLevels {\n-            map: access_levels.map.iter()\n-                                  .map(|(&k, &v)| (tcx.hir.local_def_id(k), v))\n-                                  .collect()\n+    driver::spawn_thread_pool(sessopts, move |sessopts| {\n+        let codemap = Lrc::new(codemap::CodeMap::new(sessopts.file_path_mapping()));\n+        let emitter: Box<dyn Emitter + sync::Send> = match error_format {\n+            ErrorOutputType::HumanReadable(color_config) => Box::new(\n+                EmitterWriter::stderr(\n+                    color_config,\n+                    Some(codemap.clone()),\n+                    false,\n+                    sessopts.debugging_opts.teach,\n+                ).ui_testing(sessopts.debugging_opts.ui_testing)\n+            ),\n+            ErrorOutputType::Json(pretty) => Box::new(\n+                JsonEmitter::stderr(\n+                    None,\n+                    codemap.clone(),\n+                    pretty,\n+                    sessopts.debugging_opts.suggestion_applicability,\n+                ).ui_testing(sessopts.debugging_opts.ui_testing)\n+            ),\n+            ErrorOutputType::Short(color_config) => Box::new(\n+                EmitterWriter::stderr(color_config, Some(codemap.clone()), true, false)\n+            ),\n         };\n \n-        let send_trait = if crate_name == Some(\"core\".to_string()) {\n-            clean::get_trait_def_id(&tcx, &[\"marker\", \"Send\"], true)\n-        } else {\n-            clean::get_trait_def_id(&tcx, &[\"core\", \"marker\", \"Send\"], false)\n+        let diagnostic_handler = errors::Handler::with_emitter_and_flags(\n+            emitter,\n+            errors::HandlerFlags {\n+                can_emit_warnings: true,\n+                treat_err_as_bug: false,\n+                external_macro_backtrace: false,\n+                ..Default::default()\n+            },\n+        );\n+\n+        let mut sess = session::build_session_(\n+            sessopts, cpath, diagnostic_handler, codemap,\n+        );\n+        let trans = rustc_driver::get_trans(&sess);\n+        let cstore = Rc::new(CStore::new(trans.metadata_loader()));\n+        rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n+\n+        let mut cfg = config::build_configuration(&sess, config::parse_cfgspecs(cfgs));\n+        target_features::add_configuration(&mut cfg, &sess, &*trans);\n+        sess.parse_sess.config = cfg;\n+\n+        let control = &driver::CompileController::basic();\n+\n+        let krate = panictry!(driver::phase_1_parse_input(control, &sess, &input));\n+\n+        let name = ::rustc_trans_utils::link::find_crate_name(Some(&sess), &krate.attrs, &input);\n+\n+        let mut crate_loader = CrateLoader::new(&sess, &cstore, &name);\n+\n+        let resolver_arenas = resolve::Resolver::arenas();\n+        let result = driver::phase_2_configure_and_expand_inner(&sess,\n+                                                        &cstore,\n+                                                        krate,\n+                                                        None,\n+                                                        &name,\n+                                                        None,\n+                                                        resolve::MakeGlobMap::No,\n+                                                        &resolver_arenas,\n+                                                        &mut crate_loader,\n+                                                        |_| Ok(()));\n+        let driver::InnerExpansionResult {\n+            mut hir_forest,\n+            resolver,\n+            ..\n+        } = abort_on_err(result, &sess);\n+\n+        // We need to hold on to the complete resolver, so we clone everything\n+        // for the analysis passes to use. Suboptimal, but necessary in the\n+        // current architecture.\n+        let defs = resolver.definitions.clone();\n+        let resolutions = ty::Resolutions {\n+            freevars: resolver.freevars.clone(),\n+            export_map: resolver.export_map.clone(),\n+            trait_map: resolver.trait_map.clone(),\n+            maybe_unused_trait_imports: resolver.maybe_unused_trait_imports.clone(),\n+            maybe_unused_extern_crates: resolver.maybe_unused_extern_crates.clone(),\n         };\n-\n-        let ctxt = DocContext {\n-            tcx,\n-            resolver: &resolver,\n-            crate_name,\n-            cstore: cstore.clone(),\n-            populated_all_crate_impls: Cell::new(false),\n-            access_levels: RefCell::new(access_levels),\n-            external_traits: Default::default(),\n-            active_extern_traits: Default::default(),\n-            renderinfo: Default::default(),\n-            ty_substs: Default::default(),\n-            lt_substs: Default::default(),\n-            impl_trait_bounds: Default::default(),\n-            mod_ids: Default::default(),\n-            send_trait: send_trait,\n-            fake_def_ids: RefCell::new(FxHashMap()),\n-            all_fake_def_ids: RefCell::new(FxHashSet()),\n-            generated_synthetics: RefCell::new(FxHashSet()),\n-        };\n-        debug!(\"crate: {:?}\", tcx.hir.krate());\n-\n-        let krate = {\n-            let mut v = RustdocVisitor::new(&*cstore, &ctxt);\n-            v.visit(tcx.hir.krate());\n-            v.clean(&ctxt)\n+        let analysis = ty::CrateAnalysis {\n+            access_levels: Lrc::new(AccessLevels::default()),\n+            name: name.to_string(),\n+            glob_map: if resolver.make_glob_map { Some(resolver.glob_map.clone()) } else { None },\n         };\n \n-        (krate, ctxt.renderinfo.into_inner())\n-    }), &sess)\n+        let arenas = AllArenas::new();\n+        let hir_map = hir_map::map_crate(&sess, &*cstore, &mut hir_forest, &defs);\n+        let output_filenames = driver::build_output_filenames(&input,\n+                                                            &None,\n+                                                            &None,\n+                                                            &[],\n+                                                            &sess);\n+\n+        let resolver = RefCell::new(resolver);\n+\n+        abort_on_err(driver::phase_3_run_analysis_passes(&*trans,\n+                                                        control,\n+                                                        &sess,\n+                                                        &*cstore,\n+                                                        hir_map,\n+                                                        analysis,\n+                                                        resolutions,\n+                                                        &arenas,\n+                                                        &name,\n+                                                        &output_filenames,\n+                                                        |tcx, analysis, _, result| {\n+            if let Err(_) = result {\n+                sess.fatal(\"Compilation failed, aborting rustdoc\");\n+            }\n+\n+            let ty::CrateAnalysis { access_levels, .. } = analysis;\n+\n+            // Convert from a NodeId set to a DefId set since we don't always have easy access\n+            // to the map from defid -> nodeid\n+            let access_levels = AccessLevels {\n+                map: access_levels.map.iter()\n+                                    .map(|(&k, &v)| (tcx.hir.local_def_id(k), v))\n+                                    .collect()\n+            };\n+\n+            let send_trait = if crate_name == Some(\"core\".to_string()) {\n+                clean::get_trait_def_id(&tcx, &[\"marker\", \"Send\"], true)\n+            } else {\n+                clean::get_trait_def_id(&tcx, &[\"core\", \"marker\", \"Send\"], false)\n+            };\n+\n+            let ctxt = DocContext {\n+                tcx,\n+                resolver: &resolver,\n+                crate_name,\n+                cstore: cstore.clone(),\n+                populated_all_crate_impls: Cell::new(false),\n+                access_levels: RefCell::new(access_levels),\n+                external_traits: Default::default(),\n+                active_extern_traits: Default::default(),\n+                renderinfo: Default::default(),\n+                ty_substs: Default::default(),\n+                lt_substs: Default::default(),\n+                impl_trait_bounds: Default::default(),\n+                mod_ids: Default::default(),\n+                send_trait: send_trait,\n+                fake_def_ids: RefCell::new(FxHashMap()),\n+                all_fake_def_ids: RefCell::new(FxHashSet()),\n+                generated_synthetics: RefCell::new(FxHashSet()),\n+            };\n+            debug!(\"crate: {:?}\", tcx.hir.krate());\n+\n+            let krate = {\n+                let mut v = RustdocVisitor::new(&*cstore, &ctxt);\n+                v.visit(tcx.hir.krate());\n+                v.clean(&ctxt)\n+            };\n+\n+            (krate, ctxt.renderinfo.into_inner())\n+        }), &sess)\n+    })\n }"}, {"sha": "f2da09e16036ea05f9b56ca87c2645de6fd95bbe", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022dff47e3fecbd7355a88355b0ecf4943065074/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022dff47e3fecbd7355a88355b0ecf4943065074/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=022dff47e3fecbd7355a88355b0ecf4943065074", "patch": "@@ -26,6 +26,8 @@\n #![feature(vec_remove_item)]\n #![feature(entry_and_modify)]\n \n+#![recursion_limit=\"256\"]\n+\n extern crate arena;\n extern crate getopts;\n extern crate env_logger;"}, {"sha": "fc8abafd4d89b549cb71e4b139f1a8532abec4d0", "filename": "src/librustdoc/passes/propagate_doc_cfg.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/022dff47e3fecbd7355a88355b0ecf4943065074/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022dff47e3fecbd7355a88355b0ecf4943065074/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs?ref=022dff47e3fecbd7355a88355b0ecf4943065074", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::rc::Rc;\n+use std::sync::Arc;\n \n use clean::{Crate, Item};\n use clean::cfg::Cfg;\n@@ -20,7 +20,7 @@ pub fn propagate_doc_cfg(cr: Crate) -> PluginResult {\n }\n \n struct CfgPropagator {\n-    parent_cfg: Option<Rc<Cfg>>,\n+    parent_cfg: Option<Arc<Cfg>>,\n }\n \n impl DocFolder for CfgPropagator {\n@@ -31,8 +31,8 @@ impl DocFolder for CfgPropagator {\n             (None, None) => None,\n             (Some(rc), None) | (None, Some(rc)) => Some(rc),\n             (Some(mut a), Some(b)) => {\n-                let b = Rc::try_unwrap(b).unwrap_or_else(|rc| Cfg::clone(&rc));\n-                *Rc::make_mut(&mut a) &= b;\n+                let b = Arc::try_unwrap(b).unwrap_or_else(|rc| Cfg::clone(&rc));\n+                *Arc::make_mut(&mut a) &= b;\n                 Some(a)\n             }\n         };"}, {"sha": "7be7ce313fcffcbc738bde5667ed6c7a1b31efdf", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 163, "deletions": 156, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/022dff47e3fecbd7355a88355b0ecf4943065074/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022dff47e3fecbd7355a88355b0ecf4943065074/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=022dff47e3fecbd7355a88355b0ecf4943065074", "patch": "@@ -85,77 +85,80 @@ pub fn run(input_path: &Path,\n         edition,\n         ..config::basic_options().clone()\n     };\n-\n-    let codemap = Lrc::new(CodeMap::new(sessopts.file_path_mapping()));\n-    let handler =\n-        errors::Handler::with_tty_emitter(ColorConfig::Auto,\n-                                          true, false,\n-                                          Some(codemap.clone()));\n-\n-    let mut sess = session::build_session_(\n-        sessopts, Some(input_path.to_owned()), handler, codemap.clone(),\n-    );\n-    let trans = rustc_driver::get_trans(&sess);\n-    let cstore = CStore::new(trans.metadata_loader());\n-    rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n-\n-    let mut cfg = config::build_configuration(&sess, config::parse_cfgspecs(cfgs.clone()));\n-    target_features::add_configuration(&mut cfg, &sess, &*trans);\n-    sess.parse_sess.config = cfg;\n-\n-    let krate = panictry!(driver::phase_1_parse_input(&driver::CompileController::basic(),\n-                                                      &sess,\n-                                                      &input));\n-    let driver::ExpansionResult { defs, mut hir_forest, .. } = {\n-        phase_2_configure_and_expand(\n-            &sess,\n-            &cstore,\n-            krate,\n-            None,\n-            \"rustdoc-test\",\n-            None,\n-            MakeGlobMap::No,\n-            |_| Ok(()),\n-        ).expect(\"phase_2_configure_and_expand aborted in rustdoc!\")\n-    };\n-\n-    let crate_name = crate_name.unwrap_or_else(|| {\n-        ::rustc_trans_utils::link::find_crate_name(None, &hir_forest.krate().attrs, &input)\n-    });\n-    let mut opts = scrape_test_config(hir_forest.krate());\n-    opts.display_warnings |= display_warnings;\n-    let mut collector = Collector::new(crate_name,\n-                                       cfgs,\n-                                       libs,\n-                                       cg,\n-                                       externs,\n-                                       false,\n-                                       opts,\n-                                       maybe_sysroot,\n-                                       Some(codemap),\n-                                       None,\n-                                       linker,\n-                                       edition);\n-\n-    {\n-        let map = hir::map::map_crate(&sess, &cstore, &mut hir_forest, &defs);\n-        let krate = map.krate();\n-        let mut hir_collector = HirCollector {\n-            sess: &sess,\n-            collector: &mut collector,\n-            map: &map\n+    driver::spawn_thread_pool(sessopts, |sessopts| {\n+        let codemap = Lrc::new(CodeMap::new(sessopts.file_path_mapping()));\n+        let handler =\n+            errors::Handler::with_tty_emitter(ColorConfig::Auto,\n+                                            true, false,\n+                                            Some(codemap.clone()));\n+\n+        let mut sess = session::build_session_(\n+            sessopts, Some(input_path.to_owned()), handler, codemap.clone(),\n+        );\n+        let trans = rustc_driver::get_trans(&sess);\n+        let cstore = CStore::new(trans.metadata_loader());\n+        rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n+\n+        let mut cfg = config::build_configuration(&sess, config::parse_cfgspecs(cfgs.clone()));\n+        target_features::add_configuration(&mut cfg, &sess, &*trans);\n+        sess.parse_sess.config = cfg;\n+\n+        let krate = panictry!(driver::phase_1_parse_input(&driver::CompileController::basic(),\n+                                                        &sess,\n+                                                        &input));\n+        let driver::ExpansionResult { defs, mut hir_forest, .. } = {\n+            phase_2_configure_and_expand(\n+                &sess,\n+                &cstore,\n+                krate,\n+                None,\n+                \"rustdoc-test\",\n+                None,\n+                MakeGlobMap::No,\n+                |_| Ok(()),\n+            ).expect(\"phase_2_configure_and_expand aborted in rustdoc!\")\n         };\n-        hir_collector.visit_testable(\"\".to_string(), &krate.attrs, |this| {\n-            intravisit::walk_crate(this, krate);\n+\n+        let crate_name = crate_name.unwrap_or_else(|| {\n+            ::rustc_trans_utils::link::find_crate_name(None, &hir_forest.krate().attrs, &input)\n         });\n-    }\n+        let mut opts = scrape_test_config(hir_forest.krate());\n+        opts.display_warnings |= display_warnings;\n+        let mut collector = Collector::new(\n+            crate_name,\n+            cfgs,\n+            libs,\n+            cg,\n+            externs,\n+            false,\n+            opts,\n+            maybe_sysroot,\n+            Some(codemap),\n+             None,\n+            linker,\n+            edition\n+        );\n+\n+        {\n+            let map = hir::map::map_crate(&sess, &cstore, &mut hir_forest, &defs);\n+            let krate = map.krate();\n+            let mut hir_collector = HirCollector {\n+                sess: &sess,\n+                collector: &mut collector,\n+                map: &map\n+            };\n+            hir_collector.visit_testable(\"\".to_string(), &krate.attrs, |this| {\n+                intravisit::walk_crate(this, krate);\n+            });\n+        }\n \n-    test_args.insert(0, \"rustdoctest\".to_string());\n+        test_args.insert(0, \"rustdoctest\".to_string());\n \n-    testing::test_main(&test_args,\n-                       collector.tests.into_iter().collect(),\n-                       testing::Options::new().display_output(display_warnings));\n-    0\n+        testing::test_main(&test_args,\n+                        collector.tests.into_iter().collect(),\n+                        testing::Options::new().display_output(display_warnings));\n+        0\n+    })\n }\n \n // Look for #![doc(test(no_crate_inject))], used by crates in the std facade\n@@ -229,102 +232,106 @@ fn run_test(test: &str, cratename: &str, filename: &FileName, line: usize,\n         ..config::basic_options().clone()\n     };\n \n-    // Shuffle around a few input and output handles here. We're going to pass\n-    // an explicit handle into rustc to collect output messages, but we also\n-    // want to catch the error message that rustc prints when it fails.\n-    //\n-    // We take our thread-local stderr (likely set by the test runner) and replace\n-    // it with a sink that is also passed to rustc itself. When this function\n-    // returns the output of the sink is copied onto the output of our own thread.\n-    //\n-    // The basic idea is to not use a default Handler for rustc, and then also\n-    // not print things by default to the actual stderr.\n-    struct Sink(Arc<Mutex<Vec<u8>>>);\n-    impl Write for Sink {\n-        fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-            Write::write(&mut *self.0.lock().unwrap(), data)\n+    let (libdir, outdir) = driver::spawn_thread_pool(sessopts, |sessopts| {\n+        // Shuffle around a few input and output handles here. We're going to pass\n+        // an explicit handle into rustc to collect output messages, but we also\n+        // want to catch the error message that rustc prints when it fails.\n+        //\n+        // We take our thread-local stderr (likely set by the test runner) and replace\n+        // it with a sink that is also passed to rustc itself. When this function\n+        // returns the output of the sink is copied onto the output of our own thread.\n+        //\n+        // The basic idea is to not use a default Handler for rustc, and then also\n+        // not print things by default to the actual stderr.\n+        struct Sink(Arc<Mutex<Vec<u8>>>);\n+        impl Write for Sink {\n+            fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+                Write::write(&mut *self.0.lock().unwrap(), data)\n+            }\n+            fn flush(&mut self) -> io::Result<()> { Ok(()) }\n         }\n-        fn flush(&mut self) -> io::Result<()> { Ok(()) }\n-    }\n-    struct Bomb(Arc<Mutex<Vec<u8>>>, Box<Write+Send>);\n-    impl Drop for Bomb {\n-        fn drop(&mut self) {\n-            let _ = self.1.write_all(&self.0.lock().unwrap());\n+        struct Bomb(Arc<Mutex<Vec<u8>>>, Box<Write+Send>);\n+        impl Drop for Bomb {\n+            fn drop(&mut self) {\n+                let _ = self.1.write_all(&self.0.lock().unwrap());\n+            }\n         }\n-    }\n-    let data = Arc::new(Mutex::new(Vec::new()));\n-    let codemap = Lrc::new(CodeMap::new_doctest(\n-        sessopts.file_path_mapping(), filename.clone(), line as isize - line_offset as isize\n-    ));\n-    let emitter = errors::emitter::EmitterWriter::new(box Sink(data.clone()),\n-                                                      Some(codemap.clone()),\n-                                                      false,\n-                                                      false);\n-    let old = io::set_panic(Some(box Sink(data.clone())));\n-    let _bomb = Bomb(data.clone(), old.unwrap_or(box io::stdout()));\n-\n-    // Compile the code\n-    let diagnostic_handler = errors::Handler::with_emitter(true, false, box emitter);\n-\n-    let mut sess = session::build_session_(\n-        sessopts, None, diagnostic_handler, codemap,\n-    );\n-    let trans = rustc_driver::get_trans(&sess);\n-    let cstore = CStore::new(trans.metadata_loader());\n-    rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n-\n-    let outdir = Mutex::new(TempDir::new(\"rustdoctest\").ok().expect(\"rustdoc needs a tempdir\"));\n-    let libdir = sess.target_filesearch(PathKind::All).get_lib_path();\n-    let mut control = driver::CompileController::basic();\n-\n-    let mut cfg = config::build_configuration(&sess, config::parse_cfgspecs(cfgs.clone()));\n-    target_features::add_configuration(&mut cfg, &sess, &*trans);\n-    sess.parse_sess.config = cfg;\n-\n-    let out = Some(outdir.lock().unwrap().path().to_path_buf());\n-\n-    if no_run {\n-        control.after_analysis.stop = Compilation::Stop;\n-    }\n-\n-    let res = panic::catch_unwind(AssertUnwindSafe(|| {\n-        driver::compile_input(\n-            trans,\n-            &sess,\n-            &cstore,\n-            &None,\n-            &input,\n-            &out,\n-            &None,\n-            None,\n-            &control\n-        )\n-    }));\n-\n-    let compile_result = match res {\n-        Ok(Ok(())) | Ok(Err(CompileIncomplete::Stopped)) => Ok(()),\n-        Err(_) | Ok(Err(CompileIncomplete::Errored(_))) => Err(())\n-    };\n-\n-    match (compile_result, compile_fail) {\n-        (Ok(()), true) => {\n-            panic!(\"test compiled while it wasn't supposed to\")\n+        let data = Arc::new(Mutex::new(Vec::new()));\n+        let codemap = Lrc::new(CodeMap::new_doctest(\n+            sessopts.file_path_mapping(), filename.clone(), line as isize - line_offset as isize\n+        ));\n+        let emitter = errors::emitter::EmitterWriter::new(box Sink(data.clone()),\n+                                                        Some(codemap.clone()),\n+                                                        false,\n+                                                        false);\n+        let old = io::set_panic(Some(box Sink(data.clone())));\n+        let _bomb = Bomb(data.clone(), old.unwrap_or(box io::stdout()));\n+\n+        // Compile the code\n+        let diagnostic_handler = errors::Handler::with_emitter(true, false, box emitter);\n+\n+        let mut sess = session::build_session_(\n+            sessopts, None, diagnostic_handler, codemap,\n+        );\n+        let trans = rustc_driver::get_trans(&sess);\n+        let cstore = CStore::new(trans.metadata_loader());\n+        rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n+\n+        let outdir = Mutex::new(TempDir::new(\"rustdoctest\").ok().expect(\"rustdoc needs a tempdir\"));\n+        let libdir = sess.target_filesearch(PathKind::All).get_lib_path();\n+        let mut control = driver::CompileController::basic();\n+\n+        let mut cfg = config::build_configuration(&sess, config::parse_cfgspecs(cfgs.clone()));\n+        target_features::add_configuration(&mut cfg, &sess, &*trans);\n+        sess.parse_sess.config = cfg;\n+\n+        let out = Some(outdir.lock().unwrap().path().to_path_buf());\n+\n+        if no_run {\n+            control.after_analysis.stop = Compilation::Stop;\n         }\n-        (Ok(()), false) => {}\n-        (Err(()), true) => {\n-            if error_codes.len() > 0 {\n-                let out = String::from_utf8(data.lock().unwrap().to_vec()).unwrap();\n-                error_codes.retain(|err| !out.contains(err));\n+\n+        let res = panic::catch_unwind(AssertUnwindSafe(|| {\n+            driver::compile_input(\n+                trans,\n+                &sess,\n+                &cstore,\n+                &None,\n+                &input,\n+                &out,\n+                &None,\n+                None,\n+                &control\n+            )\n+        }));\n+\n+        let compile_result = match res {\n+            Ok(Ok(())) | Ok(Err(CompileIncomplete::Stopped)) => Ok(()),\n+            Err(_) | Ok(Err(CompileIncomplete::Errored(_))) => Err(())\n+        };\n+\n+        match (compile_result, compile_fail) {\n+            (Ok(()), true) => {\n+                panic!(\"test compiled while it wasn't supposed to\")\n+            }\n+            (Ok(()), false) => {}\n+            (Err(()), true) => {\n+                if error_codes.len() > 0 {\n+                    let out = String::from_utf8(data.lock().unwrap().to_vec()).unwrap();\n+                    error_codes.retain(|err| !out.contains(err));\n+                }\n+            }\n+            (Err(()), false) => {\n+                panic!(\"couldn't compile the test\")\n             }\n         }\n-        (Err(()), false) => {\n-            panic!(\"couldn't compile the test\")\n+\n+        if error_codes.len() > 0 {\n+            panic!(\"Some expected error codes were not found: {:?}\", error_codes);\n         }\n-    }\n \n-    if error_codes.len() > 0 {\n-        panic!(\"Some expected error codes were not found: {:?}\", error_codes);\n-    }\n+        (libdir, outdir)\n+    });\n \n     if no_run { return }\n "}, {"sha": "90af3ba51ecadcff1a3d7fdf58c90099df2c14b4", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/022dff47e3fecbd7355a88355b0ecf4943065074/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022dff47e3fecbd7355a88355b0ecf4943065074/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=022dff47e3fecbd7355a88355b0ecf4943065074", "patch": "@@ -73,7 +73,7 @@ macro_rules! unwrap_or {\n     }\n }\n \n-struct Globals {\n+pub struct Globals {\n     used_attrs: Lock<Vec<u64>>,\n     known_attrs: Lock<Vec<u64>>,\n     syntax_pos_globals: syntax_pos::Globals,\n@@ -98,7 +98,7 @@ pub fn with_globals<F, R>(f: F) -> R\n     })\n }\n \n-scoped_thread_local!(static GLOBALS: Globals);\n+scoped_thread_local!(pub static GLOBALS: Globals);\n \n #[macro_use]\n pub mod diagnostics {"}, {"sha": "c34cf1bd5ec09691c5993f0ae2facee2205c2eb0", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/022dff47e3fecbd7355a88355b0ecf4943065074/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022dff47e3fecbd7355a88355b0ecf4943065074/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=022dff47e3fecbd7355a88355b0ecf4943065074", "patch": "@@ -59,6 +59,7 @@ static WHITELIST_CRATES: &'static [CrateVersion] = &[\n static WHITELIST: &'static [Crate] = &[\n     Crate(\"aho-corasick\"),\n     Crate(\"ar\"),\n+    Crate(\"arrayvec\"),\n     Crate(\"atty\"),\n     Crate(\"backtrace\"),\n     Crate(\"backtrace-sys\"),\n@@ -67,6 +68,10 @@ static WHITELIST: &'static [Crate] = &[\n     Crate(\"cc\"),\n     Crate(\"cfg-if\"),\n     Crate(\"cmake\"),\n+    Crate(\"crossbeam-deque\"),\n+    Crate(\"crossbeam-epoch\"),\n+    Crate(\"crossbeam-utils\"),\n+    Crate(\"either\"),\n     Crate(\"ena\"),\n     Crate(\"env_logger\"),\n     Crate(\"filetime\"),\n@@ -82,7 +87,9 @@ static WHITELIST: &'static [Crate] = &[\n     Crate(\"log\"),\n     Crate(\"log_settings\"),\n     Crate(\"memchr\"),\n+    Crate(\"memoffset\"),\n     Crate(\"miniz-sys\"),\n+    Crate(\"nodrop\"),\n     Crate(\"num_cpus\"),\n     Crate(\"owning_ref\"),\n     Crate(\"parking_lot\"),\n@@ -95,7 +102,10 @@ static WHITELIST: &'static [Crate] = &[\n     Crate(\"regex-syntax\"),\n     Crate(\"remove_dir_all\"),\n     Crate(\"rustc-demangle\"),\n+    Crate(\"rustc-rayon\"),\n+    Crate(\"rustc-rayon-core\"),\n     Crate(\"scoped-tls\"),\n+    Crate(\"scopeguard\"),\n     Crate(\"smallvec\"),\n     Crate(\"stable_deref_trait\"),\n     Crate(\"tempdir\"),"}]}