{"sha": "7a6b6ed0a5311cabee9d68a89100aed46523243b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhNmI2ZWQwYTUzMTFjYWJlZTlkNjhhODkxMDBhZWQ0NjUyMzI0M2I=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-12-08T11:24:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-08T11:24:44Z"}, "message": "Merge #2498\n\n2498: Drop some unused methods r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "e0a20bb1f63f0aaa9e0c335a28ccb1172e9e2c77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0a20bb1f63f0aaa9e0c335a28ccb1172e9e2c77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a6b6ed0a5311cabee9d68a89100aed46523243b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd7N18CRBK7hj4Ov3rIwAAdHIIAHrNYWgABbjzjPhSlB0CTXfw\nLYgI64JzJGVUfjfBLM8zZe/DE6eD3ba9Z8Iv77PRpZ37YJ0vBGAQhxrHWYlu2sy5\nWjADPISv1lAjHwRyKNeMzRzyLYuidOuPjxyY2Zasit/MujejEquexEnigILejBcV\nRt1xpkldaMlpYufzYA91DMFUh/0UDML2NyHcr/+FlKGTcnSFET6/Swf+ZXNZYEbh\nPx3Pdsch33wH46TB/2PiW9zEF1XivB7jOk/03NDc0ZL5B3Z8S4LiNSXC8z4rlRcV\nUHqeqmLM+BSooOip9CSrC+56OUCMtdGMW8ySRI9Yf2k5uPEjsao1K0toHOlot3A=\n=bShS\n-----END PGP SIGNATURE-----\n", "payload": "tree e0a20bb1f63f0aaa9e0c335a28ccb1172e9e2c77\nparent b236f6aa499f98985acd07a34eb0c0d147bf8d5f\nparent 7aacf9a19739f53a45840df2d08b5f3cca761192\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1575804284 +0000\ncommitter GitHub <noreply@github.com> 1575804284 +0000\n\nMerge #2498\n\n2498: Drop some unused methods r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a6b6ed0a5311cabee9d68a89100aed46523243b", "html_url": "https://github.com/rust-lang/rust/commit/7a6b6ed0a5311cabee9d68a89100aed46523243b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a6b6ed0a5311cabee9d68a89100aed46523243b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b236f6aa499f98985acd07a34eb0c0d147bf8d5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b236f6aa499f98985acd07a34eb0c0d147bf8d5f", "html_url": "https://github.com/rust-lang/rust/commit/b236f6aa499f98985acd07a34eb0c0d147bf8d5f"}, {"sha": "7aacf9a19739f53a45840df2d08b5f3cca761192", "url": "https://api.github.com/repos/rust-lang/rust/commits/7aacf9a19739f53a45840df2d08b5f3cca761192", "html_url": "https://github.com/rust-lang/rust/commit/7aacf9a19739f53a45840df2d08b5f3cca761192"}], "stats": {"total": 201, "additions": 94, "deletions": 107}, "files": [{"sha": "9cbea024a75e529fdc7b377b088485891fe56f52", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 53, "deletions": 74, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/7a6b6ed0a5311cabee9d68a89100aed46523243b/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6b6ed0a5311cabee9d68a89100aed46523243b/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=7a6b6ed0a5311cabee9d68a89100aed46523243b", "patch": "@@ -25,7 +25,7 @@ use hir_expand::{\n     MacroDefId,\n };\n use hir_ty::expr::ExprValidator;\n-use ra_db::{CrateId, Edition};\n+use ra_db::{CrateId, Edition, FileId};\n use ra_syntax::ast;\n \n use crate::{\n@@ -40,7 +40,7 @@ use crate::{\n /// root module.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Crate {\n-    pub(crate) crate_id: CrateId,\n+    pub(crate) id: CrateId,\n }\n \n #[derive(Debug)]\n@@ -50,33 +50,47 @@ pub struct CrateDependency {\n }\n \n impl Crate {\n-    pub fn crate_id(self) -> CrateId {\n-        self.crate_id\n-    }\n-\n     pub fn dependencies(self, db: &impl DefDatabase) -> Vec<CrateDependency> {\n         db.crate_graph()\n-            .dependencies(self.crate_id)\n+            .dependencies(self.id)\n             .map(|dep| {\n-                let krate = Crate { crate_id: dep.crate_id() };\n+                let krate = Crate { id: dep.crate_id() };\n                 let name = dep.as_name();\n                 CrateDependency { krate, name }\n             })\n             .collect()\n     }\n \n+    // FIXME: add `transitive_reverse_dependencies`.\n+    pub fn reverse_dependencies(self, db: &impl DefDatabase) -> Vec<Crate> {\n+        let crate_graph = db.crate_graph();\n+        crate_graph\n+            .iter()\n+            .filter(|&krate| crate_graph.dependencies(krate).any(|it| it.crate_id == self.id))\n+            .map(|id| Crate { id })\n+            .collect()\n+    }\n+\n     pub fn root_module(self, db: &impl DefDatabase) -> Option<Module> {\n-        let module_id = db.crate_def_map(self.crate_id).root;\n+        let module_id = db.crate_def_map(self.id).root;\n         Some(Module::new(self, module_id))\n     }\n \n+    pub fn root_file(self, db: &impl DefDatabase) -> FileId {\n+        db.crate_graph().crate_root(self.id)\n+    }\n+\n     pub fn edition(self, db: &impl DefDatabase) -> Edition {\n         let crate_graph = db.crate_graph();\n-        crate_graph.edition(self.crate_id)\n+        crate_graph.edition(self.id)\n     }\n \n     pub fn all(db: &impl DefDatabase) -> Vec<Crate> {\n-        db.crate_graph().iter().map(|crate_id| Crate { crate_id }).collect()\n+        db.crate_graph().iter().map(|id| Crate { id }).collect()\n+    }\n+\n+    pub fn crate_id(self) -> CrateId {\n+        self.id\n     }\n }\n \n@@ -115,7 +129,7 @@ pub use hir_def::attr::Attrs;\n \n impl Module {\n     pub(crate) fn new(krate: Crate, crate_module_id: LocalModuleId) -> Module {\n-        Module { id: ModuleId { krate: krate.crate_id, local_id: crate_module_id } }\n+        Module { id: ModuleId { krate: krate.id, local_id: crate_module_id } }\n     }\n \n     /// Name of this module.\n@@ -133,7 +147,7 @@ impl Module {\n \n     /// Returns the crate this module is part of.\n     pub fn krate(self) -> Crate {\n-        Crate { crate_id: self.id.krate }\n+        Crate { id: self.id.krate }\n     }\n \n     /// Topmost parent of this module. Every module has a `crate_root`, but some\n@@ -144,13 +158,6 @@ impl Module {\n         self.with_module_id(def_map.root)\n     }\n \n-    /// Finds a child module with the specified name.\n-    pub fn child(self, db: &impl DefDatabase, name: &Name) -> Option<Module> {\n-        let def_map = db.crate_def_map(self.id.krate);\n-        let child_id = def_map[self.id.local_id].children.get(name)?;\n-        Some(self.with_module_id(*child_id))\n-    }\n-\n     /// Iterates over all child modules.\n     pub fn children(self, db: &impl DefDatabase) -> impl Iterator<Item = Module> {\n         let def_map = db.crate_def_map(self.id.krate);\n@@ -224,7 +231,7 @@ impl Module {\n         def_map[self.id.local_id].impls.iter().copied().map(ImplBlock::from).collect()\n     }\n \n-    fn with_module_id(self, module_id: LocalModuleId) -> Module {\n+    pub(crate) fn with_module_id(self, module_id: LocalModuleId) -> Module {\n         Module::new(self.krate(), module_id)\n     }\n }\n@@ -251,8 +258,10 @@ impl StructField {\n         self.parent.variant_data(db).fields()[self.id].name.clone()\n     }\n \n-    pub fn ty(&self, db: &impl HirDatabase) -> Ty {\n-        db.field_types(self.parent.into())[self.id].clone()\n+    pub fn ty(&self, db: &impl HirDatabase) -> Type {\n+        let var_id = self.parent.into();\n+        let ty = db.field_types(var_id)[self.id].clone();\n+        Type::new(db, self.parent.module(db).id.krate.into(), var_id, ty)\n     }\n \n     pub fn parent_def(&self, _db: &impl HirDatabase) -> VariantDef {\n@@ -287,23 +296,10 @@ impl Struct {\n             .collect()\n     }\n \n-    pub fn field(self, db: &impl HirDatabase, name: &Name) -> Option<StructField> {\n-        db.struct_data(self.id.into())\n-            .variant_data\n-            .fields()\n-            .iter()\n-            .find(|(_id, data)| data.name == *name)\n-            .map(|(id, _)| StructField { parent: self.into(), id })\n-    }\n-\n     pub fn ty(self, db: &impl HirDatabase) -> Type {\n         Type::from_def(db, self.id.module(db).krate, self.id)\n     }\n \n-    pub fn constructor_ty(self, db: &impl HirDatabase) -> Ty {\n-        db.value_ty(self.id.into())\n-    }\n-\n     fn variant_data(self, db: &impl DefDatabase) -> Arc<VariantData> {\n         db.struct_data(self.id.into()).variant_data.clone()\n     }\n@@ -336,15 +332,6 @@ impl Union {\n             .collect()\n     }\n \n-    pub fn field(self, db: &impl HirDatabase, name: &Name) -> Option<StructField> {\n-        db.union_data(self.id)\n-            .variant_data\n-            .fields()\n-            .iter()\n-            .find(|(_id, data)| data.name == *name)\n-            .map(|(id, _)| StructField { parent: self.into(), id })\n-    }\n-\n     fn variant_data(self, db: &impl DefDatabase) -> Arc<VariantData> {\n         db.union_data(self.id).variant_data.clone()\n     }\n@@ -376,11 +363,6 @@ impl Enum {\n             .collect()\n     }\n \n-    pub fn variant(self, db: &impl DefDatabase, name: &Name) -> Option<EnumVariant> {\n-        let id = db.enum_data(self.id).variant(name)?;\n-        Some(EnumVariant { parent: self, id })\n-    }\n-\n     pub fn ty(self, db: &impl HirDatabase) -> Type {\n         Type::from_def(db, self.id.module(db).krate, self.id)\n     }\n@@ -412,14 +394,6 @@ impl EnumVariant {\n             .collect()\n     }\n \n-    pub fn field(self, db: &impl HirDatabase, name: &Name) -> Option<StructField> {\n-        self.variant_data(db)\n-            .fields()\n-            .iter()\n-            .find(|(_id, data)| data.name == *name)\n-            .map(|(id, _)| StructField { parent: self.into(), id })\n-    }\n-\n     pub(crate) fn variant_data(self, db: &impl DefDatabase) -> Arc<VariantData> {\n         db.enum_data(self.parent.id).variants[self.id].variant_data.clone()\n     }\n@@ -545,10 +519,6 @@ impl Function {\n         db.body(self.id.into())\n     }\n \n-    pub fn ty(self, db: &impl HirDatabase) -> Ty {\n-        db.value_ty(self.id.into())\n-    }\n-\n     pub fn infer(self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n         db.infer(self.id.into())\n     }\n@@ -878,11 +848,11 @@ pub struct ImplBlock {\n \n impl ImplBlock {\n     pub fn all_in_crate(db: &impl HirDatabase, krate: Crate) -> Vec<ImplBlock> {\n-        let impls = db.impls_in_crate(krate.crate_id);\n+        let impls = db.impls_in_crate(krate.id);\n         impls.all_impls().map(Self::from).collect()\n     }\n     pub fn for_trait(db: &impl HirDatabase, krate: Crate, trait_: Trait) -> Vec<ImplBlock> {\n-        let impls = db.impls_in_crate(krate.crate_id);\n+        let impls = db.impls_in_crate(krate.id);\n         impls.lookup_impl_blocks_for_trait(trait_.id).map(Self::from).collect()\n     }\n \n@@ -915,7 +885,7 @@ impl ImplBlock {\n     }\n \n     pub fn krate(&self, db: &impl DefDatabase) -> Crate {\n-        Crate { crate_id: self.module(db).id.krate }\n+        Crate { id: self.module(db).id.krate }\n     }\n }\n \n@@ -926,15 +896,19 @@ pub struct Type {\n }\n \n impl Type {\n+    fn new(db: &impl HirDatabase, krate: CrateId, lexical_env: impl HasResolver, ty: Ty) -> Type {\n+        let resolver = lexical_env.resolver(db);\n+        let environment = TraitEnvironment::lower(db, &resolver);\n+        Type { krate, ty: InEnvironment { value: ty, environment } }\n+    }\n+\n     fn from_def(\n         db: &impl HirDatabase,\n         krate: CrateId,\n         def: impl HasResolver + Into<TyDefId>,\n     ) -> Type {\n-        let resolver = def.resolver(db);\n-        let environment = TraitEnvironment::lower(db, &resolver);\n         let ty = db.ty(def.into());\n-        Type { krate, ty: InEnvironment { value: ty, environment } }\n+        Type::new(db, krate, def, ty)\n     }\n \n     pub fn is_bool(&self) -> bool {\n@@ -1025,11 +999,16 @@ impl Type {\n     ) -> Vec<(StructField, Type)> {\n         // FIXME: check that ty and def match\n         match &self.ty.value {\n-            Ty::Apply(a_ty) => def\n-                .fields(db)\n-                .into_iter()\n-                .map(|it| (it, self.derived(it.ty(db).subst(&a_ty.parameters))))\n-                .collect(),\n+            Ty::Apply(a_ty) => {\n+                let field_types = db.field_types(def.into());\n+                def.fields(db)\n+                    .into_iter()\n+                    .map(|it| {\n+                        let ty = field_types[it.id].clone().subst(&a_ty.parameters);\n+                        (it, self.derived(ty))\n+                    })\n+                    .collect()\n+            }\n             _ => Vec::new(),\n         }\n     }\n@@ -1053,7 +1032,7 @@ impl Type {\n         krate: Crate,\n         mut callback: impl FnMut(AssocItem) -> Option<T>,\n     ) -> Option<T> {\n-        for krate in self.ty.value.def_crates(db, krate.crate_id)? {\n+        for krate in self.ty.value.def_crates(db, krate.id)? {\n             let impls = db.impls_in_crate(krate);\n \n             for impl_block in impls.lookup_impl_blocks(&self.ty.value) {"}, {"sha": "6cd5c8cb97edad2ec17b6540536d66871e108d51", "filename": "crates/ra_hir/src/debug.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a6b6ed0a5311cabee9d68a89100aed46523243b/crates%2Fra_hir%2Fsrc%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6b6ed0a5311cabee9d68a89100aed46523243b/crates%2Fra_hir%2Fsrc%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdebug.rs?ref=7a6b6ed0a5311cabee9d68a89100aed46523243b", "patch": "@@ -57,9 +57,9 @@ pub trait HirDebugDatabase {\n impl<DB: HirDebugHelper> HirDebugDatabase for DB {\n     fn debug_crate(&self, krate: Crate, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut builder = fmt.debug_tuple(\"Crate\");\n-        match self.crate_name(krate.crate_id) {\n+        match self.crate_name(krate.id) {\n             Some(name) => builder.field(&name),\n-            None => builder.field(&krate.crate_id),\n+            None => builder.field(&krate.id),\n         }\n         .finish()\n     }"}, {"sha": "0398d0ee6b67a65b6df5dc149db634f1aae2077e", "filename": "crates/ra_hir/src/from_id.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a6b6ed0a5311cabee9d68a89100aed46523243b/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6b6ed0a5311cabee9d68a89100aed46523243b/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs?ref=7a6b6ed0a5311cabee9d68a89100aed46523243b", "patch": "@@ -14,8 +14,8 @@ use crate::{\n };\n \n impl From<ra_db::CrateId> for Crate {\n-    fn from(crate_id: ra_db::CrateId) -> Self {\n-        Crate { crate_id }\n+    fn from(id: ra_db::CrateId) -> Self {\n+        Crate { id }\n     }\n }\n "}, {"sha": "307f3d5bfff743634dd26472d4dfae00a3672d1c", "filename": "crates/ra_hir/src/from_source.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a6b6ed0a5311cabee9d68a89100aed46523243b/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6b6ed0a5311cabee9d68a89100aed46523243b/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs?ref=7a6b6ed0a5311cabee9d68a89100aed46523243b", "patch": "@@ -95,7 +95,7 @@ impl FromSource for MacroDef {\n \n         let module_src = ModuleSource::from_child_node(db, src.as_ref().map(|it| it.syntax()));\n         let module = Module::from_definition(db, InFile::new(src.file_id, module_src))?;\n-        let krate = Some(module.krate().crate_id());\n+        let krate = Some(module.krate().id);\n \n         let ast_id = Some(AstId::new(src.file_id, db.ast_id_map(src.file_id).ast_id(&src.value)));\n \n@@ -216,8 +216,10 @@ impl Module {\n             }\n         }?;\n \n-        let child_name = src.value.name()?;\n-        parent_module.child(db, &child_name.as_name())\n+        let child_name = src.value.name()?.as_name();\n+        let def_map = db.crate_def_map(parent_module.id.krate);\n+        let child_id = def_map[parent_module.id.local_id].children.get(&child_name)?;\n+        Some(parent_module.with_module_id(*child_id))\n     }\n \n     pub fn from_definition(db: &impl DefDatabase, src: InFile<ModuleSource>) -> Option<Self> {"}, {"sha": "9484a61d5372913b877c353cb964d77cec7435e0", "filename": "crates/ra_hir_def/src/resolver.rs", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7a6b6ed0a5311cabee9d68a89100aed46523243b/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6b6ed0a5311cabee9d68a89100aed46523243b/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs?ref=7a6b6ed0a5311cabee9d68a89100aed46523243b", "patch": "@@ -19,7 +19,7 @@ use crate::{\n     per_ns::PerNs,\n     AdtId, AstItemDef, ConstId, ContainerId, DefWithBodyId, EnumId, EnumVariantId, FunctionId,\n     GenericDefId, HasModule, ImplId, LocalModuleId, Lookup, ModuleDefId, ModuleId, StaticId,\n-    StructId, TraitId, TypeAliasId, TypeParamId,\n+    StructId, TraitId, TypeAliasId, TypeParamId, VariantId,\n };\n \n #[derive(Debug, Clone, Default)]\n@@ -544,16 +544,6 @@ impl HasResolver for FunctionId {\n     }\n }\n \n-impl HasResolver for DefWithBodyId {\n-    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n-        match self {\n-            DefWithBodyId::ConstId(c) => c.resolver(db),\n-            DefWithBodyId::FunctionId(f) => f.resolver(db),\n-            DefWithBodyId::StaticId(s) => s.resolver(db),\n-        }\n-    }\n-}\n-\n impl HasResolver for ConstId {\n     fn resolver(self, db: &impl DefDatabase) -> Resolver {\n         self.lookup(db).container.resolver(db)\n@@ -572,6 +562,25 @@ impl HasResolver for TypeAliasId {\n     }\n }\n \n+impl HasResolver for ImplId {\n+    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+        self.module(db)\n+            .resolver(db)\n+            .push_generic_params_scope(db, self.into())\n+            .push_impl_block_scope(self)\n+    }\n+}\n+\n+impl HasResolver for DefWithBodyId {\n+    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+        match self {\n+            DefWithBodyId::ConstId(c) => c.resolver(db),\n+            DefWithBodyId::FunctionId(f) => f.resolver(db),\n+            DefWithBodyId::StaticId(s) => s.resolver(db),\n+        }\n+    }\n+}\n+\n impl HasResolver for ContainerId {\n     fn resolver(self, db: &impl DefDatabase) -> Resolver {\n         match self {\n@@ -596,11 +605,12 @@ impl HasResolver for GenericDefId {\n     }\n }\n \n-impl HasResolver for ImplId {\n+impl HasResolver for VariantId {\n     fn resolver(self, db: &impl DefDatabase) -> Resolver {\n-        self.module(db)\n-            .resolver(db)\n-            .push_generic_params_scope(db, self.into())\n-            .push_impl_block_scope(self)\n+        match self {\n+            VariantId::EnumVariantId(it) => it.parent.resolver(db),\n+            VariantId::StructId(it) => it.resolver(db),\n+            VariantId::UnionId(it) => it.resolver(db),\n+        }\n     }\n }"}, {"sha": "241dd358f9a61d134d5bc7c3ac36c6d326e6c0b1", "filename": "crates/ra_ide/src/references/search_scope.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7a6b6ed0a5311cabee9d68a89100aed46523243b/crates%2Fra_ide%2Fsrc%2Freferences%2Fsearch_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6b6ed0a5311cabee9d68a89100aed46523243b/crates%2Fra_ide%2Fsrc%2Freferences%2Fsearch_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Fsearch_scope.rs?ref=7a6b6ed0a5311cabee9d68a89100aed46523243b", "patch": "@@ -5,7 +5,7 @@\n use std::mem;\n \n use hir::{DefWithBody, HasSource, ModuleSource};\n-use ra_db::{FileId, SourceDatabase, SourceDatabaseExt};\n+use ra_db::{FileId, SourceDatabaseExt};\n use ra_prof::profile;\n use ra_syntax::{AstNode, TextRange};\n use rustc_hash::FxHashMap;\n@@ -120,15 +120,11 @@ impl NameDefinition {\n             }\n             if vis.as_str() == \"pub\" {\n                 let krate = self.container.krate();\n-                let crate_graph = db.crate_graph();\n-                for crate_id in crate_graph.iter() {\n-                    let mut crate_deps = crate_graph.dependencies(crate_id);\n-                    if crate_deps.any(|dep| dep.crate_id() == krate.crate_id()) {\n-                        let root_file = crate_graph.crate_root(crate_id);\n-                        let source_root_id = db.file_source_root(root_file);\n-                        let source_root = db.source_root(source_root_id);\n-                        res.extend(source_root.walk().map(|id| (id, None)));\n-                    }\n+                for rev_dep in krate.reverse_dependencies(db) {\n+                    let root_file = rev_dep.root_file(db);\n+                    let source_root_id = db.file_source_root(root_file);\n+                    let source_root = db.source_root(source_root_id);\n+                    res.extend(source_root.walk().map(|id| (id, None)));\n                 }\n                 return SearchScope::new(res);\n             }"}]}