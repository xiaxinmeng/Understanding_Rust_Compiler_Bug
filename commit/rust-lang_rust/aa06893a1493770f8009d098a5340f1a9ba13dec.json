{"sha": "aa06893a1493770f8009d098a5340f1a9ba13dec", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhMDY4OTNhMTQ5Mzc3MGY4MDA5ZDA5OGE1MzQwZjFhOWJhMTNkZWM=", "commit": {"author": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2019-01-25T23:30:56Z"}, "committer": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2019-01-27T16:59:21Z"}, "message": "Add type params to FnSignature", "tree": {"sha": "aebdb8ce81e007be4c45ee7b051df97e9ecb8280", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aebdb8ce81e007be4c45ee7b051df97e9ecb8280"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa06893a1493770f8009d098a5340f1a9ba13dec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa06893a1493770f8009d098a5340f1a9ba13dec", "html_url": "https://github.com/rust-lang/rust/commit/aa06893a1493770f8009d098a5340f1a9ba13dec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa06893a1493770f8009d098a5340f1a9ba13dec/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67e40e431aa966a76b6a247b19505e22b620a0c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/67e40e431aa966a76b6a247b19505e22b620a0c7", "html_url": "https://github.com/rust-lang/rust/commit/67e40e431aa966a76b6a247b19505e22b620a0c7"}], "stats": {"total": 244, "additions": 107, "deletions": 137}, "files": [{"sha": "a13da58d2aef3f56cab0fba3a5a23c4d99a00f57", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aa06893a1493770f8009d098a5340f1a9ba13dec/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa06893a1493770f8009d098a5340f1a9ba13dec/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=aa06893a1493770f8009d098a5340f1a9ba13dec", "patch": "@@ -388,6 +388,7 @@ pub use crate::code_model_impl::function::ScopeEntryWithSyntax;\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct FnSignature {\n     pub(crate) name: Name,\n+    pub(crate) type_params: Arc<GenericParams>,\n     pub(crate) args: Vec<TypeRef>,\n     pub(crate) ret_type: TypeRef,\n     /// True if the first param is `self`. This is relevant to decide whether this\n@@ -413,6 +414,10 @@ impl FnSignature {\n     pub fn has_self_param(&self) -> bool {\n         self.has_self_param\n     }\n+\n+    pub fn generics(&self) -> &GenericParams {\n+        &self.type_params\n+    }\n }\n \n impl Function {"}, {"sha": "f4beab6ae85a05c5de5edf75954395c5d51e4f4a", "filename": "crates/ra_hir/src/code_model_impl/function.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa06893a1493770f8009d098a5340f1a9ba13dec/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa06893a1493770f8009d098a5340f1a9ba13dec/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs?ref=aa06893a1493770f8009d098a5340f1a9ba13dec", "patch": "@@ -58,6 +58,7 @@ impl FnSignature {\n                 args.push(type_ref);\n             }\n         }\n+        let type_params = db.generic_params(func.into());\n         let ret_type = if let Some(type_ref) = node.ret_type().and_then(|rt| rt.type_ref()) {\n             TypeRef::from_ast(type_ref)\n         } else {\n@@ -66,6 +67,7 @@ impl FnSignature {\n \n         let sig = FnSignature {\n             name,\n+            type_params,\n             args,\n             ret_type,\n             has_self_param,"}, {"sha": "64c20a462229342f7f678799cea13ad9b5b0c711", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aa06893a1493770f8009d098a5340f1a9ba13dec/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa06893a1493770f8009d098a5340f1a9ba13dec/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=aa06893a1493770f8009d098a5340f1a9ba13dec", "patch": "@@ -49,8 +49,7 @@ impl GenericParams {\n         Arc::new(generics)\n     }\n \n-    // FIXME: probably shouldnt be pub(crate)\n-    pub(crate) fn fill(&mut self, node: &impl TypeParamsOwner) {\n+    fn fill(&mut self, node: &impl TypeParamsOwner) {\n         if let Some(params) = node.type_param_list() {\n             self.fill_params(params)\n         }"}, {"sha": "43181ffc9c8177f85602f56b44ffe7c6b7b8c0b6", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 45, "deletions": 81, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/aa06893a1493770f8009d098a5340f1a9ba13dec/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa06893a1493770f8009d098a5340f1a9ba13dec/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=aa06893a1493770f8009d098a5340f1a9ba13dec", "patch": "@@ -20,6 +20,7 @@ mod tests;\n pub(crate) mod method_resolution;\n \n use std::borrow::Cow;\n+use std::iter::repeat;\n use std::ops::Index;\n use std::sync::Arc;\n use std::{fmt, mem};\n@@ -225,7 +226,7 @@ pub enum Ty {\n         /// For display\n         name: Name,\n         /// Substitutions for the generic parameters of the type\n-        substs: Substs\n+        substs: Substs,\n     },\n \n     /// A pointer to a function.  Written as `fn() -> i32`.\n@@ -543,11 +544,7 @@ impl Ty {\n                 name,\n                 substs,\n             },\n-            Ty::FnDef { def, name, .. } => Ty::FnDef {\n-                def,\n-                name,\n-                substs,\n-            },\n+            Ty::FnDef { def, name, .. } => Ty::FnDef { def, name, substs },\n             _ => self,\n         }\n     }\n@@ -651,30 +648,10 @@ fn type_for_fn(db: &impl HirDatabase, f: Function) -> Ty {\n     Ty::FnDef {\n         def: f.into(),\n         name,\n-        substs\n+        substs,\n     }\n }\n \n-fn get_func_sig(db: &impl HirDatabase, f: Function) -> FnSig {\n-    let signature = f.signature(db);\n-    let module = f.module(db);\n-    let impl_block = f.impl_block(db);\n-    let generics = f.generic_params(db);\n-    let input = signature\n-        .args()\n-        .iter()\n-        .map(|tr| Ty::from_hir(db, &module, impl_block.as_ref(), &generics, tr))\n-        .collect::<Vec<_>>();\n-    let output = Ty::from_hir(\n-        db,\n-        &module,\n-        impl_block.as_ref(),\n-        &generics,\n-        signature.ret_type(),\n-    );\n-    FnSig { input, output }\n-}\n-\n fn make_substs(generics: &GenericParams) -> Substs {\n     Substs(\n         generics\n@@ -946,9 +923,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.type_of_pat.insert(pat, ty);\n     }\n \n-    fn make_ty(&mut self, type_ref: &TypeRef) -> Ty {\n-        // TODO provide generics of function\n-        let generics = GenericParams::default();\n+    fn make_ty(&mut self, type_ref: &TypeRef, generics: &GenericParams) -> Ty {\n         let ty = Ty::from_hir(\n             self.db,\n             &self.module,\n@@ -1249,9 +1224,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     Ty::Tuple(ref tuple_args) => &**tuple_args,\n                     _ => &[],\n                 };\n-                let expectations_iter = expectations\n-                    .into_iter()\n-                    .chain(std::iter::repeat(&Ty::Unknown));\n+                let expectations_iter = expectations.into_iter().chain(repeat(&Ty::Unknown));\n \n                 let inner_tys = args\n                     .iter()\n@@ -1370,7 +1343,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n                 for (arg_pat, arg_type) in args.iter().zip(arg_types.iter()) {\n                     let expected = if let Some(type_ref) = arg_type {\n-                        let ty = self.make_ty(type_ref);\n+                        let ty = self.make_ty(type_ref, &GenericParams::default());\n                         ty\n                     } else {\n                         Ty::Unknown\n@@ -1386,34 +1359,31 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 // TODO: we should use turbofish hints like this:\n                 // f::<u32>(x)\n                 let callee_ty = self.infer_expr(*callee, &Expectation::none());\n-                // FIXME: so manu unnecessary clones\n                 let (param_tys, ret_ty) = match &callee_ty {\n                     Ty::FnPtr(sig) => (sig.input.clone(), sig.output.clone()),\n                     Ty::FnDef { def, substs, .. } => {\n                         let fn_sig = def.signature(self.db);\n-                        // TODO: get input and return types from the fn_sig.\n-                        // it contains typerefs which we can make into proper tys\n-\n-                        let sig = get_func_sig(self.db, *def);\n-                        (\n-                            sig.input\n-                                .iter()\n-                                .map(|ty| ty.clone().subst(&substs))\n-                                .collect(),\n-                            sig.output.clone().subst(&substs),\n-                        )\n+                        let ret_ty = self\n+                            .make_ty(fn_sig.ret_type(), fn_sig.generics())\n+                            .subst(&substs);\n+                        let param_tys = fn_sig\n+                            .args()\n+                            .iter()\n+                            .map(|type_ref| {\n+                                self.make_ty(type_ref, fn_sig.generics()).subst(&substs)\n+                            })\n+                            .collect();\n+                        (param_tys, ret_ty)\n                     }\n                     _ => {\n                         // not callable\n                         // TODO report an error?\n                         (Vec::new(), Ty::Unknown)\n                     }\n                 };\n-                for (i, arg) in args.iter().enumerate() {\n-                    self.infer_expr(\n-                        *arg,\n-                        &Expectation::has_type(param_tys.get(i).cloned().unwrap_or(Ty::Unknown)),\n-                    );\n+                let param_iter = param_tys.into_iter().chain(repeat(Ty::Unknown));\n+                for (arg, param) in args.iter().zip(param_iter) {\n+                    self.infer_expr(*arg, &Expectation::has_type(param));\n                 }\n                 ret_ty\n             }\n@@ -1435,46 +1405,39 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let (expected_receiver_ty, param_tys, ret_ty) = match &method_ty {\n                     Ty::FnPtr(sig) => {\n                         if sig.input.len() > 0 {\n-                            (sig.input[0].clone(), sig.input[1..].iter().cloned().collect(), sig.output.clone())\n+                            (\n+                                sig.input[0].clone(),\n+                                sig.input[1..].iter().cloned().collect(),\n+                                sig.output.clone(),\n+                            )\n                         } else {\n                             (Ty::Unknown, Vec::new(), sig.output.clone())\n                         }\n                     }\n                     Ty::FnDef { def, substs, .. } => {\n-                        // TODO: fix deduplication with Expr::Call block above\n-                        // TODO: fix the ridiculous number of clones\n                         let fn_sig = def.signature(self.db);\n-                        // TODO: get input and return types from the fn_sig.\n-                        // it contains typerefs which we can make into proper tys\n-\n-                        // check that len > 0\n-                        let sig = get_func_sig(self.db, *def);\n-                        if sig.input.len() > 0 {\n-                            (\n-                                sig.input[0].clone().subst(&substs),\n-                                sig.input[1..]\n-                                    .iter()\n-                                    .map(|ty| ty.clone().subst(&substs))\n-                                    .collect(),\n-                                sig.output.clone().subst(&substs),\n-                            )\n+                        let ret_ty = self\n+                            .make_ty(fn_sig.ret_type(), fn_sig.generics())\n+                            .subst(&substs);\n+\n+                        if fn_sig.args().len() > 0 {\n+                            let mut arg_iter = fn_sig.args().iter().map(|type_ref| {\n+                                self.make_ty(type_ref, fn_sig.generics()).subst(&substs)\n+                            });\n+                            let receiver_ty = arg_iter.next().unwrap();\n+                            (receiver_ty, arg_iter.collect(), ret_ty)\n                         } else {\n-                            (Ty::Unknown, Vec::new(), sig.output.clone())\n+                            (Ty::Unknown, Vec::new(), ret_ty)\n                         }\n                     }\n                     _ => (Ty::Unknown, Vec::new(), Ty::Unknown),\n                 };\n                 // TODO we would have to apply the autoderef/autoref steps here\n                 // to get the correct receiver type to unify...\n-                // \n-                // TODO: zip param_tys.chain(iter::repeat(Ty::Unknown)) above then its not so bad\n-                // that we clone\n                 self.unify(&expected_receiver_ty, &receiver_ty);\n-                for (i, arg) in args.iter().enumerate() {\n-                    self.infer_expr(\n-                        *arg,\n-                        &Expectation::has_type(param_tys.get(i).cloned().unwrap_or(Ty::Unknown)),\n-                    );\n+                let param_iter = param_tys.into_iter().chain(repeat(Ty::Unknown));\n+                for (arg, param) in args.iter().zip(param_iter) {\n+                    self.infer_expr(*arg, &Expectation::has_type(param));\n                 }\n                 ret_ty\n             }\n@@ -1558,7 +1521,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n             Expr::Cast { expr, type_ref } => {\n                 let _inner_ty = self.infer_expr(*expr, &Expectation::none());\n-                let cast_ty = self.make_ty(type_ref);\n+                let cast_ty = self.make_ty(type_ref, &GenericParams::default());\n                 // TODO check the cast...\n                 cast_ty\n             }\n@@ -1672,7 +1635,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 } => {\n                     let decl_ty = type_ref\n                         .as_ref()\n-                        .map(|tr| self.make_ty(tr))\n+                        .map(|tr| self.make_ty(tr, &GenericParams::default()))\n                         .unwrap_or(Ty::Unknown);\n                     let decl_ty = self.insert_type_vars(decl_ty);\n                     let ty = if let Some(expr) = initializer {\n@@ -1699,12 +1662,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n     fn collect_fn_signature(&mut self, signature: &FnSignature) {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n+        let generics = signature.generics();\n         for (type_ref, pat) in signature.args().iter().zip(body.params()) {\n-            let ty = self.make_ty(type_ref);\n+            let ty = self.make_ty(type_ref, generics);\n \n             self.infer_pat(*pat, &ty);\n         }\n-        self.return_ty = self.make_ty(signature.ret_type());\n+        self.return_ty = self.make_ty(signature.ret_type(), generics);\n     }\n \n     fn infer_body(&mut self) {"}, {"sha": "e6b39f1510dced88f9df3c85b8a5ab7a94fba991", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_backwards.snap", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa06893a1493770f8009d098a5340f1a9ba13dec/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_backwards.snap", "raw_url": "https://github.com/rust-lang/rust/raw/aa06893a1493770f8009d098a5340f1a9ba13dec/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_backwards.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_backwards.snap?ref=aa06893a1493770f8009d098a5340f1a9ba13dec", "patch": "@@ -1,16 +1,16 @@\n ---\n-created: \"2019-01-22T14:44:59.880187500+00:00\"\n-creator: insta@0.4.0\n+created: \"2019-01-25T23:18:54.943309491+00:00\"\n+creator: insta@0.5.2\n expression: \"&result\"\n-source: \"crates\\\\ra_hir\\\\src\\\\ty\\\\tests.rs\"\n+source: crates/ra_hir/src/ty/tests.rs\n ---\n [14; 15) 'x': u32\n [22; 24) '{}': ()\n [78; 231) '{     ...t &c }': &mut &f64\n [88; 89) 'a': u32\n [92; 108) 'unknow...nction': [unknown]\n [92; 110) 'unknow...tion()': u32\n-[116; 125) 'takes_u32': fn(u32) -> ()\n+[116; 125) 'takes_u32': fn takes_u32\n [116; 128) 'takes_u32(a)': ()\n [126; 127) 'a': u32\n [138; 139) 'b': i32"}, {"sha": "895c13ae60beff479786ddfbe8f637407099351b", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_binary_op.snap", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa06893a1493770f8009d098a5340f1a9ba13dec/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_binary_op.snap", "raw_url": "https://github.com/rust-lang/rust/raw/aa06893a1493770f8009d098a5340f1a9ba13dec/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_binary_op.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_binary_op.snap?ref=aa06893a1493770f8009d098a5340f1a9ba13dec", "patch": "@@ -1,8 +1,8 @@\n ---\n-created: \"2019-01-22T14:44:59.880187500+00:00\"\n-creator: insta@0.4.0\n+created: \"2019-01-25T23:18:54.949540810+00:00\"\n+creator: insta@0.5.2\n expression: \"&result\"\n-source: \"crates\\\\ra_hir\\\\src\\\\ty\\\\tests.rs\"\n+source: crates/ra_hir/src/ty/tests.rs\n ---\n [6; 7) 'x': bool\n [22; 34) '{     0i32 }': i32\n@@ -28,7 +28,7 @@ source: \"crates\\\\ra_hir\\\\src\\\\ty\\\\tests.rs\"\n [174; 196) 'minus_...ONST_2': bool\n [189; 196) 'CONST_2': isize\n [206; 207) 'c': i32\n-[210; 211) 'f': fn(bool) -> i32\n+[210; 211) 'f': fn f\n [210; 219) 'f(z || y)': i32\n [210; 223) 'f(z || y) + 5': i32\n [212; 213) 'z': bool"}, {"sha": "efe0e7adf9faff0d323114f2e2851f8b83569f57", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_function_generics.snap", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/aa06893a1493770f8009d098a5340f1a9ba13dec/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_function_generics.snap", "raw_url": "https://github.com/rust-lang/rust/raw/aa06893a1493770f8009d098a5340f1a9ba13dec/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_function_generics.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_function_generics.snap?ref=aa06893a1493770f8009d098a5340f1a9ba13dec", "patch": "@@ -1,21 +1,21 @@\n ---\n-created: \"2019-01-22T14:44:59.954958500+00:00\"\n-creator: insta@0.4.0\n+created: \"2019-01-25T23:18:54.962273460+00:00\"\n+creator: insta@0.5.2\n expression: \"&result\"\n-source: \"crates\\\\ra_hir\\\\src\\\\ty\\\\tests.rs\"\n+source: crates/ra_hir/src/ty/tests.rs\n ---\n-[10; 11) 't': [unknown]\n-[21; 26) '{ t }': [unknown]\n-[23; 24) 't': [unknown]\n+[10; 11) 't': T\n+[21; 26) '{ t }': T\n+[23; 24) 't': T\n [38; 98) '{     ...(1); }': ()\n-[44; 46) 'id': fn(T) -> T\n-[44; 52) 'id(1u32)': T\n+[44; 46) 'id': fn id<u32>\n+[44; 52) 'id(1u32)': u32\n [47; 51) '1u32': u32\n-[58; 68) 'id::<i128>': fn(T) -> T\n-[58; 71) 'id::<i128>(1)': T\n-[69; 70) '1': T\n-[81; 82) 'x': T\n-[90; 92) 'id': fn(T) -> T\n-[90; 95) 'id(1)': T\n-[93; 94) '1': T\n+[58; 68) 'id::<i128>': fn id<i32>\n+[58; 71) 'id::<i128>(1)': i32\n+[69; 70) '1': i32\n+[81; 82) 'x': u64\n+[90; 92) 'id': fn id<u64>\n+[90; 95) 'id(1)': u64\n+[93; 94) '1': u64\n "}, {"sha": "aaf8ccea58e242a37a82c744bf11102e3e82e49a", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_generic_chain.snap", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/aa06893a1493770f8009d098a5340f1a9ba13dec/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_generic_chain.snap", "raw_url": "https://github.com/rust-lang/rust/raw/aa06893a1493770f8009d098a5340f1a9ba13dec/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_generic_chain.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_generic_chain.snap?ref=aa06893a1493770f8009d098a5340f1a9ba13dec", "patch": "@@ -1,36 +1,36 @@\n ---\n-created: \"2019-01-22T14:44:59.961936900+00:00\"\n-creator: insta@0.4.0\n+created: \"2019-01-25T23:18:54.978506051+00:00\"\n+creator: insta@0.5.2\n expression: \"&result\"\n-source: \"crates\\\\ra_hir\\\\src\\\\ty\\\\tests.rs\"\n+source: crates/ra_hir/src/ty/tests.rs\n ---\n [53; 57) 'self': A<[unknown]>\n [65; 87) '{     ...     }': [unknown]\n [75; 79) 'self': A<[unknown]>\n [75; 81) 'self.x': [unknown]\n-[99; 100) 't': [unknown]\n-[110; 115) '{ t }': [unknown]\n-[112; 113) 't': [unknown]\n+[99; 100) 't': T\n+[110; 115) '{ t }': T\n+[112; 113) 't': T\n [135; 261) '{     ....x() }': i128\n-[146; 147) 'x': T\n-[150; 151) '1': T\n-[162; 163) 'y': T\n-[166; 168) 'id': fn(T) -> T\n-[166; 171) 'id(x)': T\n-[169; 170) 'x': T\n-[182; 183) 'a': A<T>\n-[186; 200) 'A { x: id(y) }': A<T>\n-[193; 195) 'id': fn(T) -> T\n-[193; 198) 'id(y)': T\n-[196; 197) 'y': T\n-[211; 212) 'z': T\n-[215; 217) 'id': fn(T) -> T\n-[215; 222) 'id(a.x)': T\n-[218; 219) 'a': A<T>\n-[218; 221) 'a.x': T\n-[233; 234) 'b': A<T>\n-[237; 247) 'A { x: z }': A<T>\n-[244; 245) 'z': T\n-[254; 255) 'b': A<T>\n+[146; 147) 'x': i32\n+[150; 151) '1': i32\n+[162; 163) 'y': i32\n+[166; 168) 'id': fn id<i32>\n+[166; 171) 'id(x)': i32\n+[169; 170) 'x': i32\n+[182; 183) 'a': A<i32>\n+[186; 200) 'A { x: id(y) }': A<i32>\n+[193; 195) 'id': fn id<i32>\n+[193; 198) 'id(y)': i32\n+[196; 197) 'y': i32\n+[211; 212) 'z': i32\n+[215; 217) 'id': fn id<i32>\n+[215; 222) 'id(a.x)': i32\n+[218; 219) 'a': A<i32>\n+[218; 221) 'a.x': i32\n+[233; 234) 'b': A<i32>\n+[237; 247) 'A { x: z }': A<i32>\n+[244; 245) 'z': i32\n+[254; 255) 'b': A<i32>\n [254; 259) 'b.x()': i128\n "}, {"sha": "efca360587563f899bb99ea50b48ffb888c24602", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_paths.snap", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa06893a1493770f8009d098a5340f1a9ba13dec/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_paths.snap", "raw_url": "https://github.com/rust-lang/rust/raw/aa06893a1493770f8009d098a5340f1a9ba13dec/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_paths.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_paths.snap?ref=aa06893a1493770f8009d098a5340f1a9ba13dec", "patch": "@@ -1,16 +1,16 @@\n ---\n-created: \"2019-01-22T14:44:59.975899500+00:00\"\n-creator: insta@0.4.0\n+created: \"2019-01-25T23:18:54.985011010+00:00\"\n+creator: insta@0.5.2\n expression: \"&result\"\n-source: \"crates\\\\ra_hir\\\\src\\\\ty\\\\tests.rs\"\n+source: crates/ra_hir/src/ty/tests.rs\n ---\n [15; 20) '{ 1 }': u32\n [17; 18) '1': u32\n [48; 53) '{ 1 }': u32\n [50; 51) '1': u32\n [67; 91) '{     ...c(); }': ()\n-[73; 74) 'a': fn() -> u32\n+[73; 74) 'a': fn a\n [73; 76) 'a()': u32\n-[82; 86) 'b::c': fn() -> u32\n+[82; 86) 'b::c': fn c\n [82; 88) 'b::c()': u32\n "}]}