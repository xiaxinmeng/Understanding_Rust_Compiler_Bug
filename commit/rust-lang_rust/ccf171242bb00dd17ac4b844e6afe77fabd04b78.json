{"sha": "ccf171242bb00dd17ac4b844e6afe77fabd04b78", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjZjE3MTI0MmJiMDBkZDE3YWM0Yjg0NGU2YWZlNzdmYWJkMDRiNzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-22T15:36:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-22T15:36:27Z"}, "message": "Auto merge of #77704 - AnthonyMikh:slice_index_with_ops_bound_pair, r=m-ou-se\n\nImplement indexing slices with pairs of core::ops::Bound<usize>\n\nCloses #49976.\n\nI am not sure about code duplication between `check_range` and `into_maybe_range`. Should be former implemented in terms of the latter? Also this PR doesn't address code duplication between `impl SliceIndex for Range*`.", "tree": {"sha": "d9571fc94be41f4ce3ccb1ee6b3decd5e097828e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9571fc94be41f4ce3ccb1ee6b3decd5e097828e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ccf171242bb00dd17ac4b844e6afe77fabd04b78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ccf171242bb00dd17ac4b844e6afe77fabd04b78", "html_url": "https://github.com/rust-lang/rust/commit/ccf171242bb00dd17ac4b844e6afe77fabd04b78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ccf171242bb00dd17ac4b844e6afe77fabd04b78/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25c15cdbe070f49d708f34750df2632e38bd4846", "url": "https://api.github.com/repos/rust-lang/rust/commits/25c15cdbe070f49d708f34750df2632e38bd4846", "html_url": "https://github.com/rust-lang/rust/commit/25c15cdbe070f49d708f34750df2632e38bd4846"}, {"sha": "6763a40eff7221fc23f22cdac453e2843344a357", "url": "https://api.github.com/repos/rust-lang/rust/commits/6763a40eff7221fc23f22cdac453e2843344a357", "html_url": "https://github.com/rust-lang/rust/commit/6763a40eff7221fc23f22cdac453e2843344a357"}], "stats": {"total": 155, "additions": 155, "deletions": 0}, "files": [{"sha": "f722430354991961f314ba0091a414b2b6d9dbe8", "filename": "library/core/src/slice/index.rs", "status": "modified", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/ccf171242bb00dd17ac4b844e6afe77fabd04b78/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf171242bb00dd17ac4b844e6afe77fabd04b78/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Findex.rs?ref=ccf171242bb00dd17ac4b844e6afe77fabd04b78", "patch": "@@ -81,6 +81,8 @@ mod private_slice_index {\n     impl Sealed for ops::RangeInclusive<usize> {}\n     #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n     impl Sealed for ops::RangeToInclusive<usize> {}\n+    #[stable(feature = \"slice_index_with_ops_bound_pair\", since = \"1.53.0\")]\n+    impl Sealed for (ops::Bound<usize>, ops::Bound<usize>) {}\n }\n \n /// A helper trait used for indexing operations.\n@@ -546,3 +548,113 @@ where\n \n     ops::Range { start, end }\n }\n+\n+/// Convert pair of `ops::Bound`s into `ops::Range` without performing any bounds checking and (in debug) overflow checking\n+fn into_range_unchecked(\n+    len: usize,\n+    (start, end): (ops::Bound<usize>, ops::Bound<usize>),\n+) -> ops::Range<usize> {\n+    use ops::Bound;\n+    let start = match start {\n+        Bound::Included(i) => i,\n+        Bound::Excluded(i) => i + 1,\n+        Bound::Unbounded => 0,\n+    };\n+    let end = match end {\n+        Bound::Included(i) => i + 1,\n+        Bound::Excluded(i) => i,\n+        Bound::Unbounded => len,\n+    };\n+    start..end\n+}\n+\n+/// Convert pair of `ops::Bound`s into `ops::Range`.\n+/// Returns `None` on overflowing indices.\n+fn into_range(\n+    len: usize,\n+    (start, end): (ops::Bound<usize>, ops::Bound<usize>),\n+) -> Option<ops::Range<usize>> {\n+    use ops::Bound;\n+    let start = match start {\n+        Bound::Included(start) => start,\n+        Bound::Excluded(start) => start.checked_add(1)?,\n+        Bound::Unbounded => 0,\n+    };\n+\n+    let end = match end {\n+        Bound::Included(end) => end.checked_add(1)?,\n+        Bound::Excluded(end) => end,\n+        Bound::Unbounded => len,\n+    };\n+\n+    // Don't bother with checking `start < end` and `end <= len`\n+    // since these checks are handled by `Range` impls\n+\n+    Some(start..end)\n+}\n+\n+/// Convert pair of `ops::Bound`s into `ops::Range`.\n+/// Panics on overflowing indices.\n+fn into_slice_range(\n+    len: usize,\n+    (start, end): (ops::Bound<usize>, ops::Bound<usize>),\n+) -> ops::Range<usize> {\n+    use ops::Bound;\n+    let start = match start {\n+        Bound::Included(start) => start,\n+        Bound::Excluded(start) => {\n+            start.checked_add(1).unwrap_or_else(|| slice_start_index_overflow_fail())\n+        }\n+        Bound::Unbounded => 0,\n+    };\n+\n+    let end = match end {\n+        Bound::Included(end) => {\n+            end.checked_add(1).unwrap_or_else(|| slice_end_index_overflow_fail())\n+        }\n+        Bound::Excluded(end) => end,\n+        Bound::Unbounded => len,\n+    };\n+\n+    // Don't bother with checking `start < end` and `end <= len`\n+    // since these checks are handled by `Range` impls\n+\n+    start..end\n+}\n+\n+#[stable(feature = \"slice_index_with_ops_bound_pair\", since = \"1.53.0\")]\n+unsafe impl<T> SliceIndex<[T]> for (ops::Bound<usize>, ops::Bound<usize>) {\n+    type Output = [T];\n+\n+    #[inline]\n+    fn get(self, slice: &[T]) -> Option<&Self::Output> {\n+        into_range(slice.len(), self)?.get(slice)\n+    }\n+\n+    #[inline]\n+    fn get_mut(self, slice: &mut [T]) -> Option<&mut Self::Output> {\n+        into_range(slice.len(), self)?.get_mut(slice)\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const Self::Output {\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n+        unsafe { into_range_unchecked(slice.len(), self).get_unchecked(slice) }\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut Self::Output {\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { into_range_unchecked(slice.len(), self).get_unchecked_mut(slice) }\n+    }\n+\n+    #[inline]\n+    fn index(self, slice: &[T]) -> &Self::Output {\n+        into_slice_range(slice.len(), self).index(slice)\n+    }\n+\n+    #[inline]\n+    fn index_mut(self, slice: &mut [T]) -> &mut Self::Output {\n+        into_slice_range(slice.len(), self).index_mut(slice)\n+    }\n+}"}, {"sha": "3a98cd9d2ee91be6c98e58c65acf05694956b95c", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ccf171242bb00dd17ac4b844e6afe77fabd04b78/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf171242bb00dd17ac4b844e6afe77fabd04b78/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=ccf171242bb00dd17ac4b844e6afe77fabd04b78", "patch": "@@ -1280,6 +1280,9 @@ mod slice_index {\n             }\n         )*) => {$(\n             mod $case_name {\n+                #[allow(unused_imports)]\n+                use core::ops::Bound;\n+\n                 #[test]\n                 fn pass() {\n                     let mut v = $data;\n@@ -1376,6 +1379,24 @@ mod slice_index {\n             bad: data[7..=6];\n             message: \"out of range\";\n         }\n+\n+        in mod boundpair_len {\n+            data: [0, 1, 2, 3, 4, 5];\n+\n+            good: data[(Bound::Included(6), Bound::Unbounded)] == [];\n+            good: data[(Bound::Unbounded, Bound::Included(5))] == [0, 1, 2, 3, 4, 5];\n+            good: data[(Bound::Unbounded, Bound::Excluded(6))] == [0, 1, 2, 3, 4, 5];\n+            good: data[(Bound::Included(0), Bound::Included(5))] == [0, 1, 2, 3, 4, 5];\n+            good: data[(Bound::Included(0), Bound::Excluded(6))] == [0, 1, 2, 3, 4, 5];\n+            good: data[(Bound::Included(2), Bound::Excluded(4))] == [2, 3];\n+            good: data[(Bound::Excluded(1), Bound::Included(4))] == [2, 3, 4];\n+            good: data[(Bound::Excluded(5), Bound::Excluded(6))] == [];\n+            good: data[(Bound::Included(6), Bound::Excluded(6))] == [];\n+            good: data[(Bound::Excluded(5), Bound::Included(5))] == [];\n+            good: data[(Bound::Included(6), Bound::Included(5))] == [];\n+            bad: data[(Bound::Unbounded, Bound::Included(6))];\n+            message: \"out of range\";\n+        }\n     }\n \n     panic_cases! {\n@@ -1416,6 +1437,14 @@ mod slice_index {\n             bad: data[4..=2];\n             message: \"but ends at\";\n         }\n+\n+        in mod boundpair_neg_width {\n+            data: [0, 1, 2, 3, 4, 5];\n+\n+            good: data[(Bound::Included(4), Bound::Excluded(4))] == [];\n+            bad: data[(Bound::Included(4), Bound::Excluded(3))];\n+            message: \"but ends at\";\n+        }\n     }\n \n     panic_cases! {\n@@ -1434,6 +1463,20 @@ mod slice_index {\n             bad: data[..= usize::MAX];\n             message: \"maximum usize\";\n         }\n+\n+        in mod boundpair_overflow_end {\n+            data: [0; 1];\n+\n+            bad: data[(Bound::Unbounded, Bound::Included(usize::MAX))];\n+            message: \"maximum usize\";\n+        }\n+\n+        in mod boundpair_overflow_start {\n+            data: [0; 1];\n+\n+            bad: data[(Bound::Excluded(usize::MAX), Bound::Unbounded)];\n+            message: \"maximum usize\";\n+        }\n     } // panic_cases!\n }\n "}]}