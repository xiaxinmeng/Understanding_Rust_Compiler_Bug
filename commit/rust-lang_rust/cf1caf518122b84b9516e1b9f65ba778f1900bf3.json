{"sha": "cf1caf518122b84b9516e1b9f65ba778f1900bf3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmMWNhZjUxODEyMmI4NGI5NTE2ZTFiOWY2NWJhNzc4ZjE5MDBiZjM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-04-02T15:18:00Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-04-02T16:15:13Z"}, "message": "simplify", "tree": {"sha": "a0f814c651b12b55e54fe01a2621d6527f285db2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0f814c651b12b55e54fe01a2621d6527f285db2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf1caf518122b84b9516e1b9f65ba778f1900bf3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf1caf518122b84b9516e1b9f65ba778f1900bf3", "html_url": "https://github.com/rust-lang/rust/commit/cf1caf518122b84b9516e1b9f65ba778f1900bf3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf1caf518122b84b9516e1b9f65ba778f1900bf3/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a758a2c4803c7ecc956d2aa6ed2ce48c4e4edd9", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a758a2c4803c7ecc956d2aa6ed2ce48c4e4edd9", "html_url": "https://github.com/rust-lang/rust/commit/0a758a2c4803c7ecc956d2aa6ed2ce48c4e4edd9"}], "stats": {"total": 736, "additions": 336, "deletions": 400}, "files": [{"sha": "4c3eea3d2e9d62b74be5bec29a4a42b1ef229948", "filename": "crates/ra_syntax/src/string_lexing.rs", "status": "modified", "additions": 332, "deletions": 6, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/cf1caf518122b84b9516e1b9f65ba778f1900bf3/crates%2Fra_syntax%2Fsrc%2Fstring_lexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf1caf518122b84b9516e1b9f65ba778f1900bf3/crates%2Fra_syntax%2Fsrc%2Fstring_lexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fstring_lexing.rs?ref=cf1caf518122b84b9516e1b9f65ba778f1900bf3", "patch": "@@ -1,7 +1,333 @@\n-mod parser;\n-mod string;\n+use crate::{TextRange, TextUnit};\n+use self::StringComponentKind::*;\n \n-pub use self::{\n-    parser::{StringComponent, StringComponentKind},\n-    string::{parse_string_literal, parse_char_literal, parse_byte_literal, parse_byte_string_literal},\n-};\n+#[derive(Debug, Eq, PartialEq, Clone)]\n+pub(crate) struct StringComponent {\n+    pub(crate) range: TextRange,\n+    pub(crate) kind: StringComponentKind,\n+}\n+\n+#[derive(Debug, Eq, PartialEq, Clone)]\n+pub(crate) enum StringComponentKind {\n+    IgnoreNewline,\n+    CodePoint,\n+    AsciiEscape,\n+    AsciiCodeEscape,\n+    UnicodeEscape,\n+}\n+\n+pub(crate) fn parse_quoted_literal(\n+    prefix: Option<char>,\n+    quote: char,\n+    src: &str,\n+) -> StringComponentIter {\n+    let prefix = prefix.map(|p| match p {\n+        'b' => b'b',\n+        _ => panic!(\"invalid prefix\"),\n+    });\n+    let quote = match quote {\n+        '\\'' => b'\\'',\n+        '\"' => b'\"',\n+        _ => panic!(\"invalid quote\"),\n+    };\n+    StringComponentIter { src, prefix, quote, pos: 0, has_closing_quote: false, suffix: None }\n+}\n+\n+pub(crate) struct StringComponentIter<'a> {\n+    src: &'a str,\n+    prefix: Option<u8>,\n+    quote: u8,\n+    pos: usize,\n+    pub(crate) has_closing_quote: bool,\n+    pub(crate) suffix: Option<TextRange>,\n+}\n+\n+impl<'a> Iterator for StringComponentIter<'a> {\n+    type Item = StringComponent;\n+    fn next(&mut self) -> Option<StringComponent> {\n+        if self.pos == 0 {\n+            if let Some(prefix) = self.prefix {\n+                assert!(\n+                    self.advance() == prefix as char,\n+                    \"literal should start with a {:?}\",\n+                    prefix as char,\n+                );\n+            }\n+            assert!(\n+                self.advance() == self.quote as char,\n+                \"literal should start with a {:?}\",\n+                self.quote as char,\n+            );\n+        }\n+\n+        if let Some(component) = self.parse_component() {\n+            return Some(component);\n+        }\n+\n+        // We get here when there are no char components left to parse\n+        if self.peek() == Some(self.quote as char) {\n+            self.advance();\n+            self.has_closing_quote = true;\n+            if let Some(range) = self.parse_suffix() {\n+                self.suffix = Some(range);\n+            }\n+        }\n+\n+        assert!(\n+            self.peek() == None,\n+            \"literal should leave no unparsed input: src = {:?}, pos = {}, length = {}\",\n+            self.src,\n+            self.pos,\n+            self.src.len()\n+        );\n+\n+        None\n+    }\n+}\n+\n+impl<'a> StringComponentIter<'a> {\n+    fn peek(&self) -> Option<char> {\n+        if self.pos == self.src.len() {\n+            return None;\n+        }\n+\n+        self.src[self.pos..].chars().next()\n+    }\n+\n+    fn advance(&mut self) -> char {\n+        let next = self.peek().expect(\"cannot advance if end of input is reached\");\n+        self.pos += next.len_utf8();\n+        next\n+    }\n+\n+    fn parse_component(&mut self) -> Option<StringComponent> {\n+        let next = self.peek()?;\n+\n+        // Ignore string close\n+        if next == self.quote as char {\n+            return None;\n+        }\n+\n+        let start = self.start_range();\n+        self.advance();\n+\n+        if next == '\\\\' {\n+            // Strings can use `\\` to ignore newlines, so we first try to parse one of those\n+            // before falling back to parsing char escapes\n+            if self.quote == b'\"' {\n+                if let Some(component) = self.parse_ignore_newline(start) {\n+                    return Some(component);\n+                }\n+            }\n+\n+            Some(self.parse_escape(start))\n+        } else {\n+            Some(self.finish_component(start, CodePoint))\n+        }\n+    }\n+\n+    fn parse_ignore_newline(&mut self, start: TextUnit) -> Option<StringComponent> {\n+        // In string literals, when a `\\` occurs immediately before the newline, the `\\`,\n+        // the newline, and all whitespace at the beginning of the next line are ignored\n+        match self.peek() {\n+            Some('\\n') | Some('\\r') => {\n+                self.skip_whitespace();\n+                Some(self.finish_component(start, IgnoreNewline))\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    fn skip_whitespace(&mut self) {\n+        while self.peek().map(|c| c.is_whitespace()) == Some(true) {\n+            self.advance();\n+        }\n+    }\n+\n+    fn parse_escape(&mut self, start: TextUnit) -> StringComponent {\n+        if self.peek().is_none() {\n+            return self.finish_component(start, AsciiEscape);\n+        }\n+\n+        let next = self.advance();\n+        match next {\n+            'x' => self.parse_ascii_code_escape(start),\n+            'u' => self.parse_unicode_escape(start),\n+            _ => self.finish_component(start, AsciiEscape),\n+        }\n+    }\n+\n+    fn parse_unicode_escape(&mut self, start: TextUnit) -> StringComponent {\n+        match self.peek() {\n+            Some('{') => {\n+                self.advance();\n+\n+                // Parse anything until we reach `}`\n+                while let Some(next) = self.peek() {\n+                    self.advance();\n+                    if next == '}' {\n+                        break;\n+                    }\n+                }\n+\n+                self.finish_component(start, UnicodeEscape)\n+            }\n+            Some(_) | None => self.finish_component(start, UnicodeEscape),\n+        }\n+    }\n+\n+    fn parse_ascii_code_escape(&mut self, start: TextUnit) -> StringComponent {\n+        let code_start = self.pos;\n+        while let Some(next) = self.peek() {\n+            if next == '\\'' || (self.pos - code_start == 2) {\n+                break;\n+            }\n+\n+            self.advance();\n+        }\n+        self.finish_component(start, AsciiCodeEscape)\n+    }\n+\n+    fn parse_suffix(&mut self) -> Option<TextRange> {\n+        let start = self.start_range();\n+        let _ = self.peek()?;\n+        while let Some(_) = self.peek() {\n+            self.advance();\n+        }\n+        Some(self.finish_range(start))\n+    }\n+\n+    fn start_range(&self) -> TextUnit {\n+        TextUnit::from_usize(self.pos)\n+    }\n+\n+    fn finish_range(&self, start: TextUnit) -> TextRange {\n+        TextRange::from_to(start, TextUnit::from_usize(self.pos))\n+    }\n+\n+    fn finish_component(&self, start: TextUnit, kind: StringComponentKind) -> StringComponent {\n+        let range = self.finish_range(start);\n+        StringComponent { range, kind }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    fn parse(src: &str) -> (bool, Vec<StringComponent>) {\n+        let component_iterator = &mut parse_quoted_literal(None, '\\'', src);\n+        let components: Vec<_> = component_iterator.collect();\n+        (component_iterator.has_closing_quote, components)\n+    }\n+\n+    fn unclosed_char_component(src: &str) -> StringComponent {\n+        let (has_closing_quote, components) = parse(src);\n+        assert!(!has_closing_quote, \"char should not have closing quote\");\n+        assert!(components.len() == 1);\n+        components[0].clone()\n+    }\n+\n+    fn closed_char_component(src: &str) -> StringComponent {\n+        let (has_closing_quote, components) = parse(src);\n+        assert!(has_closing_quote, \"char should have closing quote\");\n+        assert!(components.len() == 1, \"Literal: {}\\nComponents: {:#?}\", src, components);\n+        components[0].clone()\n+    }\n+\n+    fn closed_char_components(src: &str) -> Vec<StringComponent> {\n+        let (has_closing_quote, components) = parse(src);\n+        assert!(has_closing_quote, \"char should have closing quote\");\n+        components\n+    }\n+\n+    fn range_closed(src: &str) -> TextRange {\n+        TextRange::from_to(1.into(), (src.len() as u32 - 1).into())\n+    }\n+\n+    fn range_unclosed(src: &str) -> TextRange {\n+        TextRange::from_to(1.into(), (src.len() as u32).into())\n+    }\n+\n+    #[test]\n+    fn test_unicode_escapes() {\n+        let unicode_escapes = &[r\"{DEAD}\", \"{BEEF}\", \"{FF}\", \"{}\", \"\"];\n+        for escape in unicode_escapes {\n+            let escape_sequence = format!(r\"'\\u{}'\", escape);\n+            let component = closed_char_component(&escape_sequence);\n+            let expected_range = range_closed(&escape_sequence);\n+            assert_eq!(component.kind, UnicodeEscape);\n+            assert_eq!(component.range, expected_range);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_unicode_escapes_unclosed() {\n+        let unicode_escapes = &[\"{DEAD\", \"{BEEF\", \"{FF\"];\n+        for escape in unicode_escapes {\n+            let escape_sequence = format!(r\"'\\u{}'\", escape);\n+            let component = unclosed_char_component(&escape_sequence);\n+            let expected_range = range_unclosed(&escape_sequence);\n+            assert_eq!(component.kind, UnicodeEscape);\n+            assert_eq!(component.range, expected_range);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_empty_char() {\n+        let (has_closing_quote, components) = parse(\"''\");\n+        assert!(has_closing_quote, \"char should have closing quote\");\n+        assert!(components.len() == 0);\n+    }\n+\n+    #[test]\n+    fn test_unclosed_char() {\n+        let component = unclosed_char_component(\"'a\");\n+        assert!(component.kind == CodePoint);\n+        assert!(component.range == TextRange::from_to(1.into(), 2.into()));\n+    }\n+\n+    #[test]\n+    fn test_digit_escapes() {\n+        let literals = &[r\"\", r\"5\", r\"55\"];\n+\n+        for literal in literals {\n+            let lit_text = format!(r\"'\\x{}'\", literal);\n+            let component = closed_char_component(&lit_text);\n+            assert!(component.kind == AsciiCodeEscape);\n+            assert!(component.range == range_closed(&lit_text));\n+        }\n+\n+        // More than 2 digits starts a new codepoint\n+        let components = closed_char_components(r\"'\\x555'\");\n+        assert!(components.len() == 2);\n+        assert!(components[1].kind == CodePoint);\n+    }\n+\n+    #[test]\n+    fn test_ascii_escapes() {\n+        let literals = &[\n+            r\"\\'\", \"\\\\\\\"\", // equivalent to \\\"\n+            r\"\\n\", r\"\\r\", r\"\\t\", r\"\\\\\", r\"\\0\",\n+        ];\n+\n+        for literal in literals {\n+            let lit_text = format!(\"'{}'\", literal);\n+            let component = closed_char_component(&lit_text);\n+            assert!(component.kind == AsciiEscape);\n+            assert!(component.range == range_closed(&lit_text));\n+        }\n+    }\n+\n+    #[test]\n+    fn test_no_escapes() {\n+        let literals = &['\"', 'n', 'r', 't', '0', 'x', 'u'];\n+\n+        for &literal in literals {\n+            let lit_text = format!(\"'{}'\", literal);\n+            let component = closed_char_component(&lit_text);\n+            assert!(component.kind == CodePoint);\n+            assert!(component.range == range_closed(&lit_text));\n+        }\n+    }\n+}"}, {"sha": "7469eb903ede5fb21088f112c2f03a7edf0e6375", "filename": "crates/ra_syntax/src/string_lexing/parser.rs", "status": "removed", "additions": 0, "deletions": 168, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/0a758a2c4803c7ecc956d2aa6ed2ce48c4e4edd9/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a758a2c4803c7ecc956d2aa6ed2ce48c4e4edd9/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fparser.rs?ref=0a758a2c4803c7ecc956d2aa6ed2ce48c4e4edd9", "patch": "@@ -1,168 +0,0 @@\n-use rowan::{TextRange, TextUnit};\n-\n-use self::StringComponentKind::*;\n-\n-pub struct Parser<'a> {\n-    pub(super) quote: u8,\n-    pub(super) src: &'a str,\n-    pub(super) pos: usize,\n-}\n-\n-impl<'a> Parser<'a> {\n-    pub fn new(src: &'a str, quote: u8) -> Parser<'a> {\n-        Parser { quote, src, pos: 0 }\n-    }\n-\n-    // Utility methods\n-\n-    pub fn peek(&self) -> Option<char> {\n-        if self.pos == self.src.len() {\n-            return None;\n-        }\n-\n-        self.src[self.pos..].chars().next()\n-    }\n-\n-    pub fn advance(&mut self) -> char {\n-        let next = self.peek().expect(\"cannot advance if end of input is reached\");\n-        self.pos += next.len_utf8();\n-        next\n-    }\n-\n-    pub fn skip_whitespace(&mut self) {\n-        while self.peek().map(|c| c.is_whitespace()) == Some(true) {\n-            self.advance();\n-        }\n-    }\n-\n-    pub fn get_pos(&self) -> TextUnit {\n-        (self.pos as u32).into()\n-    }\n-\n-    // Char parsing methods\n-\n-    fn parse_unicode_escape(&mut self, start: TextUnit) -> StringComponent {\n-        match self.peek() {\n-            Some('{') => {\n-                self.advance();\n-\n-                // Parse anything until we reach `}`\n-                while let Some(next) = self.peek() {\n-                    self.advance();\n-                    if next == '}' {\n-                        break;\n-                    }\n-                }\n-\n-                let end = self.get_pos();\n-                StringComponent::new(TextRange::from_to(start, end), UnicodeEscape)\n-            }\n-            Some(_) | None => {\n-                let end = self.get_pos();\n-                StringComponent::new(TextRange::from_to(start, end), UnicodeEscape)\n-            }\n-        }\n-    }\n-\n-    fn parse_ascii_code_escape(&mut self, start: TextUnit) -> StringComponent {\n-        let code_start = self.get_pos();\n-        while let Some(next) = self.peek() {\n-            if next == '\\'' || (self.get_pos() - code_start == 2.into()) {\n-                break;\n-            }\n-\n-            self.advance();\n-        }\n-\n-        let end = self.get_pos();\n-        StringComponent::new(TextRange::from_to(start, end), AsciiCodeEscape)\n-    }\n-\n-    fn parse_escape(&mut self, start: TextUnit) -> StringComponent {\n-        if self.peek().is_none() {\n-            return StringComponent::new(TextRange::from_to(start, self.get_pos()), AsciiEscape);\n-        }\n-\n-        let next = self.advance();\n-        let end = self.get_pos();\n-        let range = TextRange::from_to(start, end);\n-        match next {\n-            'x' => self.parse_ascii_code_escape(start),\n-            'u' => self.parse_unicode_escape(start),\n-            _ => StringComponent::new(range, AsciiEscape),\n-        }\n-    }\n-\n-    pub fn parse_ignore_newline(&mut self, start: TextUnit) -> Option<StringComponent> {\n-        // In string literals, when a `\\` occurs immediately before the newline, the `\\`,\n-        // the newline, and all whitespace at the beginning of the next line are ignored\n-        match self.peek() {\n-            Some('\\n') | Some('\\r') => {\n-                self.skip_whitespace();\n-                Some(StringComponent::new(\n-                    TextRange::from_to(start, self.get_pos()),\n-                    StringComponentKind::IgnoreNewline,\n-                ))\n-            }\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn parse_component(&mut self) -> Option<StringComponent> {\n-        let next = self.peek()?;\n-\n-        // Ignore string close\n-        if next == self.quote as char {\n-            return None;\n-        }\n-\n-        let start = self.get_pos();\n-        self.advance();\n-\n-        if next == '\\\\' {\n-            // Strings can use `\\` to ignore newlines, so we first try to parse one of those\n-            // before falling back to parsing char escapes\n-            if self.quote == b'\"' {\n-                if let Some(component) = self.parse_ignore_newline(start) {\n-                    return Some(component);\n-                }\n-            }\n-\n-            Some(self.parse_escape(start))\n-        } else {\n-            let end = self.get_pos();\n-            Some(StringComponent::new(TextRange::from_to(start, end), CodePoint))\n-        }\n-    }\n-\n-    pub fn parse_suffix(&mut self) -> Option<TextRange> {\n-        let start = self.get_pos();\n-        let _ = self.peek()?;\n-        while let Some(_) = self.peek() {\n-            self.advance();\n-        }\n-        let end = self.get_pos();\n-        Some(TextRange::from_to(start, end))\n-    }\n-}\n-\n-#[derive(Debug, Eq, PartialEq, Clone)]\n-pub struct StringComponent {\n-    pub range: TextRange,\n-    pub kind: StringComponentKind,\n-}\n-\n-impl StringComponent {\n-    fn new(range: TextRange, kind: StringComponentKind) -> StringComponent {\n-        StringComponent { range, kind }\n-    }\n-}\n-\n-#[derive(Debug, Eq, PartialEq, Clone)]\n-pub enum StringComponentKind {\n-    IgnoreNewline,\n-    CodePoint,\n-    AsciiEscape,\n-    AsciiCodeEscape,\n-    UnicodeEscape,\n-}"}, {"sha": "a4742a0d1f84f1f44b1948e222619843311375dd", "filename": "crates/ra_syntax/src/string_lexing/string.rs", "status": "removed", "additions": 0, "deletions": 222, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/0a758a2c4803c7ecc956d2aa6ed2ce48c4e4edd9/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a758a2c4803c7ecc956d2aa6ed2ce48c4e4edd9/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fstring.rs?ref=0a758a2c4803c7ecc956d2aa6ed2ce48c4e4edd9", "patch": "@@ -1,222 +0,0 @@\n-use crate::{\n-    TextRange,\n-    string_lexing::{\n-    parser::Parser,\n-    StringComponent,\n-}};\n-\n-pub fn parse_string_literal(src: &str) -> StringComponentIterator {\n-    StringComponentIterator {\n-        parser: Parser::new(src, b'\"'),\n-        has_closing_quote: false,\n-        suffix: None,\n-        prefix: None,\n-        quote: b'\"',\n-    }\n-}\n-\n-pub fn parse_byte_string_literal(src: &str) -> StringComponentIterator {\n-    StringComponentIterator {\n-        parser: Parser::new(src, b'\"'),\n-        has_closing_quote: false,\n-        suffix: None,\n-        prefix: Some(b'b'),\n-        quote: b'\"',\n-    }\n-}\n-\n-pub fn parse_char_literal(src: &str) -> StringComponentIterator {\n-    StringComponentIterator {\n-        parser: Parser::new(src, b'\\''),\n-        has_closing_quote: false,\n-        suffix: None,\n-        prefix: None,\n-        quote: b'\\'',\n-    }\n-}\n-\n-pub fn parse_byte_literal(src: &str) -> StringComponentIterator {\n-    StringComponentIterator {\n-        parser: Parser::new(src, b'\\''),\n-        has_closing_quote: false,\n-        suffix: None,\n-        prefix: Some(b'b'),\n-        quote: b'\\'',\n-    }\n-}\n-\n-pub struct StringComponentIterator<'a> {\n-    parser: Parser<'a>,\n-    pub has_closing_quote: bool,\n-    pub suffix: Option<TextRange>,\n-    prefix: Option<u8>,\n-    quote: u8,\n-}\n-\n-impl<'a> Iterator for StringComponentIterator<'a> {\n-    type Item = StringComponent;\n-    fn next(&mut self) -> Option<StringComponent> {\n-        if self.parser.pos == 0 {\n-            if let Some(prefix) = self.prefix {\n-                assert!(\n-                    self.parser.advance() == prefix as char,\n-                    \"literal should start with a {:?}\",\n-                    prefix as char,\n-                );\n-            }\n-            assert!(\n-                self.parser.advance() == self.quote as char,\n-                \"literal should start with a {:?}\",\n-                self.quote as char,\n-            );\n-        }\n-\n-        if let Some(component) = self.parser.parse_component() {\n-            return Some(component);\n-        }\n-\n-        // We get here when there are no char components left to parse\n-        if self.parser.peek() == Some(self.quote as char) {\n-            self.parser.advance();\n-            self.has_closing_quote = true;\n-            if let Some(range) = self.parser.parse_suffix() {\n-                self.suffix = Some(range);\n-            }\n-        }\n-\n-        assert!(\n-            self.parser.peek() == None,\n-            \"literal should leave no unparsed input: src = {:?}, pos = {}, length = {}\",\n-            self.parser.src,\n-            self.parser.pos,\n-            self.parser.src.len()\n-        );\n-\n-        None\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use rowan::TextRange;\n-    use crate::string_lexing::{\n-        StringComponent,\n-        StringComponentKind::*,\n-};\n-\n-    fn parse(src: &str) -> (bool, Vec<StringComponent>) {\n-        let component_iterator = &mut super::parse_char_literal(src);\n-        let components: Vec<_> = component_iterator.collect();\n-        (component_iterator.has_closing_quote, components)\n-    }\n-\n-    fn unclosed_char_component(src: &str) -> StringComponent {\n-        let (has_closing_quote, components) = parse(src);\n-        assert!(!has_closing_quote, \"char should not have closing quote\");\n-        assert!(components.len() == 1);\n-        components[0].clone()\n-    }\n-\n-    fn closed_char_component(src: &str) -> StringComponent {\n-        let (has_closing_quote, components) = parse(src);\n-        assert!(has_closing_quote, \"char should have closing quote\");\n-        assert!(components.len() == 1, \"Literal: {}\\nComponents: {:#?}\", src, components);\n-        components[0].clone()\n-    }\n-\n-    fn closed_char_components(src: &str) -> Vec<StringComponent> {\n-        let (has_closing_quote, components) = parse(src);\n-        assert!(has_closing_quote, \"char should have closing quote\");\n-        components\n-    }\n-\n-    fn range_closed(src: &str) -> TextRange {\n-        TextRange::from_to(1.into(), (src.len() as u32 - 1).into())\n-    }\n-\n-    fn range_unclosed(src: &str) -> TextRange {\n-        TextRange::from_to(1.into(), (src.len() as u32).into())\n-    }\n-\n-    #[test]\n-    fn test_unicode_escapes() {\n-        let unicode_escapes = &[r\"{DEAD}\", \"{BEEF}\", \"{FF}\", \"{}\", \"\"];\n-        for escape in unicode_escapes {\n-            let escape_sequence = format!(r\"'\\u{}'\", escape);\n-            let component = closed_char_component(&escape_sequence);\n-            let expected_range = range_closed(&escape_sequence);\n-            assert_eq!(component.kind, UnicodeEscape);\n-            assert_eq!(component.range, expected_range);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_unicode_escapes_unclosed() {\n-        let unicode_escapes = &[\"{DEAD\", \"{BEEF\", \"{FF\"];\n-        for escape in unicode_escapes {\n-            let escape_sequence = format!(r\"'\\u{}'\", escape);\n-            let component = unclosed_char_component(&escape_sequence);\n-            let expected_range = range_unclosed(&escape_sequence);\n-            assert_eq!(component.kind, UnicodeEscape);\n-            assert_eq!(component.range, expected_range);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_empty_char() {\n-        let (has_closing_quote, components) = parse(\"''\");\n-        assert!(has_closing_quote, \"char should have closing quote\");\n-        assert!(components.len() == 0);\n-    }\n-\n-    #[test]\n-    fn test_unclosed_char() {\n-        let component = unclosed_char_component(\"'a\");\n-        assert!(component.kind == CodePoint);\n-        assert!(component.range == TextRange::from_to(1.into(), 2.into()));\n-    }\n-\n-    #[test]\n-    fn test_digit_escapes() {\n-        let literals = &[r\"\", r\"5\", r\"55\"];\n-\n-        for literal in literals {\n-            let lit_text = format!(r\"'\\x{}'\", literal);\n-            let component = closed_char_component(&lit_text);\n-            assert!(component.kind == AsciiCodeEscape);\n-            assert!(component.range == range_closed(&lit_text));\n-        }\n-\n-        // More than 2 digits starts a new codepoint\n-        let components = closed_char_components(r\"'\\x555'\");\n-        assert!(components.len() == 2);\n-        assert!(components[1].kind == CodePoint);\n-    }\n-\n-    #[test]\n-    fn test_ascii_escapes() {\n-        let literals = &[\n-            r\"\\'\", \"\\\\\\\"\", // equivalent to \\\"\n-            r\"\\n\", r\"\\r\", r\"\\t\", r\"\\\\\", r\"\\0\",\n-        ];\n-\n-        for literal in literals {\n-            let lit_text = format!(\"'{}'\", literal);\n-            let component = closed_char_component(&lit_text);\n-            assert!(component.kind == AsciiEscape);\n-            assert!(component.range == range_closed(&lit_text));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_no_escapes() {\n-        let literals = &['\"', 'n', 'r', 't', '0', 'x', 'u'];\n-\n-        for &literal in literals {\n-            let lit_text = format!(\"'{}'\", literal);\n-            let component = closed_char_component(&lit_text);\n-            assert!(component.kind == CodePoint);\n-            assert!(component.range == range_closed(&lit_text));\n-        }\n-    }\n-}"}, {"sha": "f653e65d033f9931d95813b52a3c46dc721b1f19", "filename": "crates/ra_syntax/src/validation/byte.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf1caf518122b84b9516e1b9f65ba778f1900bf3/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf1caf518122b84b9516e1b9f65ba778f1900bf3/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte.rs?ref=cf1caf518122b84b9516e1b9f65ba778f1900bf3", "patch": "@@ -12,7 +12,7 @@ use crate::{\n pub(super) fn validate_byte_node(node: SyntaxToken, errors: &mut Vec<SyntaxError>) {\n     let literal_text = node.text();\n     let literal_range = node.range();\n-    let mut components = string_lexing::parse_byte_literal(literal_text);\n+    let mut components = string_lexing::parse_quoted_literal(Some('b'), '\\'', literal_text);\n     let mut len = 0;\n     for component in &mut components {\n         len += 1;"}, {"sha": "1d48c2d9b1674fc7888a8c151fd573592ff9a447", "filename": "crates/ra_syntax/src/validation/byte_string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf1caf518122b84b9516e1b9f65ba778f1900bf3/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf1caf518122b84b9516e1b9f65ba778f1900bf3/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte_string.rs?ref=cf1caf518122b84b9516e1b9f65ba778f1900bf3", "patch": "@@ -10,7 +10,7 @@ use super::byte;\n pub(crate) fn validate_byte_string_node(node: SyntaxToken, errors: &mut Vec<SyntaxError>) {\n     let literal_text = node.text();\n     let literal_range = node.range();\n-    let mut components = string_lexing::parse_byte_string_literal(literal_text);\n+    let mut components = string_lexing::parse_quoted_literal(Some('b'), '\"', literal_text);\n     for component in &mut components {\n         let range = component.range + literal_range.start();\n "}, {"sha": "0f1885873b7258fdd57cbf3ca12f0bf76bc77094", "filename": "crates/ra_syntax/src/validation/char.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf1caf518122b84b9516e1b9f65ba778f1900bf3/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf1caf518122b84b9516e1b9f65ba778f1900bf3/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fchar.rs?ref=cf1caf518122b84b9516e1b9f65ba778f1900bf3", "patch": "@@ -15,7 +15,7 @@ use crate::{\n pub(super) fn validate_char_node(node: SyntaxToken, errors: &mut Vec<SyntaxError>) {\n     let literal_text = node.text();\n     let literal_range = node.range();\n-    let mut components = string_lexing::parse_char_literal(literal_text);\n+    let mut components = string_lexing::parse_quoted_literal(None, '\\'', literal_text);\n     let mut len = 0;\n     for component in &mut components {\n         len += 1;"}, {"sha": "fc2f1b992125ce6e759ecc1cc62d35c91f00a12b", "filename": "crates/ra_syntax/src/validation/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf1caf518122b84b9516e1b9f65ba778f1900bf3/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf1caf518122b84b9516e1b9f65ba778f1900bf3/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fstring.rs?ref=cf1caf518122b84b9516e1b9f65ba778f1900bf3", "patch": "@@ -10,7 +10,7 @@ use super::char;\n pub(crate) fn validate_string_node(node: SyntaxToken, errors: &mut Vec<SyntaxError>) {\n     let literal_text = node.text();\n     let literal_range = node.range();\n-    let mut components = string_lexing::parse_string_literal(literal_text);\n+    let mut components = string_lexing::parse_quoted_literal(None, '\"', literal_text);\n     for component in &mut components {\n         let range = component.range + literal_range.start();\n "}]}