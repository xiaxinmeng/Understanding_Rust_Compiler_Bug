{"sha": "a8111b7d30e8c47c339852987d304fa126f1b4a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4MTExYjdkMzBlOGM0N2MzMzk4NTI5ODdkMzA0ZmExMjZmMWI0YTY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-02-19T18:50:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-02-19T18:50:43Z"}, "message": "Apply suggestions from code review\n\nCo-Authored-By: RalfJung <post@ralfj.de>", "tree": {"sha": "a6624fb3136fb4d4d34ee104c72267894b07eb25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6624fb3136fb4d4d34ee104c72267894b07eb25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8111b7d30e8c47c339852987d304fa126f1b4a6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcbFADCRBK7hj4Ov3rIwAAdHIIAD3pkM82BQi9SeYMsGLvVVGG\npQwgf2B8pGhHAKNwBGSY03Aa3Bo9QPwF3gTGArMZj+L5As3LO0BA8nF3VvtXI164\nU6g2t0XDfZh2GAmNptybVpmcg2yv4MwHr/FaFEOtyTwZd9d3nksE1RFoShX62vMY\nP0Q3Pj6a+8InE24xRzLO2QqjjuDUw1yTLfvqyyfRWfqh8G3S+x/yKiJ8kA3M3i5X\njmIKE2hp2pNwUJtqejtlv6WdEPTSVrYW+bL3l0t8UYomOTGOXXaGjsUtPmE4cXr0\nSrt8CO/QLqMgwMvqOdUp7XAJ0HVG9zJkCyoXo3EyfrTuRZ7g6AKahjVrpQRG3Ow=\n=ViWc\n-----END PGP SIGNATURE-----\n", "payload": "tree a6624fb3136fb4d4d34ee104c72267894b07eb25\nparent a8d18b9560736dc3291cee253b0329b1a6ec0faf\nauthor Ralf Jung <post@ralfj.de> 1550602243 +0100\ncommitter GitHub <noreply@github.com> 1550602243 +0100\n\nApply suggestions from code review\n\nCo-Authored-By: RalfJung <post@ralfj.de>"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8111b7d30e8c47c339852987d304fa126f1b4a6", "html_url": "https://github.com/rust-lang/rust/commit/a8111b7d30e8c47c339852987d304fa126f1b4a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8111b7d30e8c47c339852987d304fa126f1b4a6/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8d18b9560736dc3291cee253b0329b1a6ec0faf", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8d18b9560736dc3291cee253b0329b1a6ec0faf", "html_url": "https://github.com/rust-lang/rust/commit/a8d18b9560736dc3291cee253b0329b1a6ec0faf"}], "stats": {"total": 24, "additions": 12, "deletions": 12}, "files": [{"sha": "ed56f76c14cfc809eb59f3db835b5254064327b8", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a8111b7d30e8c47c339852987d304fa126f1b4a6/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8111b7d30e8c47c339852987d304fa126f1b4a6/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=a8111b7d30e8c47c339852987d304fa126f1b4a6", "patch": "@@ -24,7 +24,7 @@\n //! self-references and other special behaviors that are only possible for unmovable\n //! values.\n //!\n-//! It is worth reiterating that [`Pin`] does *not* change the fact that the Rust compiler\n+//! It is worth reiterating that [`Pin`] does *not* change the fact that a Rust compiler\n //! considers all types movable.  [`mem::swap`] remains callable for any `T`.  Instead, `Pin`\n //! prevents certain *values* (pointed to by pointers wrapped in `Pin`) from being\n //! moved by making it impossible to call methods like [`mem::swap`] on them.\n@@ -39,7 +39,7 @@\n //!\n //! Note that pinning and `Unpin` only affect the pointed-to type, not the pointer\n //! type itself that got wrapped in `Pin`. For example, whether or not `Box<T>` is\n-//! `Unpin` has no affect on the behavior of `Pin<Box<T>>` (here, `T` is the\n+//! `Unpin` has no effect on the behavior of `Pin<Box<T>>` (here, `T` is the\n //! pointed-to type).\n //!\n //! # Examples\n@@ -110,25 +110,25 @@\n //!\n //! The purpose of this guarantee is to allow data structures that store pointers\n //! to pinned data. For example, in an intrusive doubly-linked list, every element\n-//! will have pointers to its predecessor and successor in the list. Every element\n-//! will be pinned, because moving the elements around would invalidate the pointers.\n+//! has pointers to its predecessor and successor in the list. Every element\n+//! must also be pinned, because moving the elements around would invalidate the pointers.\n //! Moreover, the `Drop` implementation of a linked list element will patch the pointers\n //! of its predecessor and successor to remove itself from the list. Clearly, if an element\n //! could be deallocated or overwritten without calling `drop`, the pointers into it\n //! from its neighbouring elements would become invalid, which would break the data structure.\n //!\n //! Notice that this guarantee does *not* mean that memory does not leak! It is still\n //! completely okay not to ever call `drop` on a pinned element (e.g., you can still\n-//! call [`mem::forget`] on a `Pin<Box<T>>`). What you may not do is free or reuse the storage\n+//! call [`mem::forget`] on a `Pin<Box<T>>`). However you may *not* then free or reuse the storage\n //! without calling `drop`.\n //!\n //! # `Drop` implementation\n //!\n //! If your type relies on pinning (for example, because it contains internal\n //! references, or because you are implementing something like the intrusive\n //! doubly-linked list mentioned in the previous section), you have to be careful\n-//! when implementing `Drop`: notice that `drop` takes `&mut self`, but this\n-//! will be called even if your type was previously pinned! It is as if the\n+//! when implementing `Drop`. The `drop` function takes `&mut self`, but this\n+//! is called *even if your type was previously pinned*! It is as if the\n //! compiler automatically called `get_unchecked_mut`. This can never cause\n //! a problem in safe code because implementing a type that relies on pinning\n //! requires unsafe code, but be aware that deciding to make use of pinning\n@@ -140,7 +140,7 @@\n //! # Projections and Structural Pinning\n //!\n //! One interesting question arises when considering pinning and \"container types\" --\n-//! types such as `Vec` or `Box` but also `RefCell`; types that serve as wrappers\n+//! types such as `Vec`, `Box`, or `RefCell`; types that serve as wrappers\n //! around other types.  When can such a type have a \"projection\" operation, an\n //! operation with type `fn(Pin<&[mut] Container<T>>) -> Pin<&[mut] T>`?\n //! This does not just apply to generic container types, even for normal structs\n@@ -170,7 +170,7 @@\n //!    moved around when they are dropped to properly align them, which is in conflict with\n //!    claiming that the fields are pinned when your struct is.\n //! 4. You must make sure that you uphold the [`Drop` guarantee][drop-guarantee]:\n-//!    you must make sure that, once your container is pinned, the memory containing the\n+//!    once your container is pinned, the memory that contains the\n //!    content is not overwritten or deallocated without calling the content's destructors.\n //!    This can be tricky, as witnessed by `VecDeque`: the destructor of `VecDeque` can fail\n //!    to call `drop` on all elements if one of the destructors panics. This violates the\n@@ -186,9 +186,9 @@\n //!    which can be used with [`mem::swap`].\n //!\n //! On the other hand, if you decide *not* to offer any pinning projections, you\n-//! are free to do `impl<T> Unpin for Container<T>`.  In the standard library,\n-//! we do this for all pointer types: `Box<T>: Unpin` holds for all `T`.\n-//! It makes a lot of sense to do this for pointer types, because moving the `Box<T>`\n+//! are free to `impl<T> Unpin for Container<T>`.  In the standard library,\n+//! this is done for all pointer types: `Box<T>: Unpin` holds for all `T`.\n+//! It makes sense to do this for pointer types, because moving the `Box<T>`\n //! does not actually move the `T`: the `Box<T>` can be freely movable even if the `T`\n //! is not. In fact, even `Pin<Box<T>>` and `Pin<&mut T>` are always `Unpin` themselves,\n //! for the same reason."}]}