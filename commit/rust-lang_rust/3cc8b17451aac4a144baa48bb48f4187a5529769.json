{"sha": "3cc8b17451aac4a144baa48bb48f4187a5529769", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjYzhiMTc0NTFhYWM0YTE0NGJhYTQ4YmI0OGY0MTg3YTU1Mjk3Njk=", "commit": {"author": {"name": "Nikita Popov", "email": "nikita.ppv@gmail.com", "date": "2018-11-05T13:52:08Z"}, "committer": {"name": "Nikita Popov", "email": "nikita.ppv@gmail.com", "date": "2018-11-05T14:04:26Z"}, "message": "Remove support for building against LLVM 4\n\nWith emscripten removed in #55626, we no longer need to support\nbuilding against LLVM 4.", "tree": {"sha": "441ffae2eddb2da1aad6e69edf73037462cb678b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/441ffae2eddb2da1aad6e69edf73037462cb678b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3cc8b17451aac4a144baa48bb48f4187a5529769", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3cc8b17451aac4a144baa48bb48f4187a5529769", "html_url": "https://github.com/rust-lang/rust/commit/3cc8b17451aac4a144baa48bb48f4187a5529769", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3cc8b17451aac4a144baa48bb48f4187a5529769/comments", "author": {"login": "nikic", "id": 216080, "node_id": "MDQ6VXNlcjIxNjA4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/216080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikic", "html_url": "https://github.com/nikic", "followers_url": "https://api.github.com/users/nikic/followers", "following_url": "https://api.github.com/users/nikic/following{/other_user}", "gists_url": "https://api.github.com/users/nikic/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikic/subscriptions", "organizations_url": "https://api.github.com/users/nikic/orgs", "repos_url": "https://api.github.com/users/nikic/repos", "events_url": "https://api.github.com/users/nikic/events{/privacy}", "received_events_url": "https://api.github.com/users/nikic/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikic", "id": 216080, "node_id": "MDQ6VXNlcjIxNjA4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/216080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikic", "html_url": "https://github.com/nikic", "followers_url": "https://api.github.com/users/nikic/followers", "following_url": "https://api.github.com/users/nikic/following{/other_user}", "gists_url": "https://api.github.com/users/nikic/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikic/subscriptions", "organizations_url": "https://api.github.com/users/nikic/orgs", "repos_url": "https://api.github.com/users/nikic/repos", "events_url": "https://api.github.com/users/nikic/events{/privacy}", "received_events_url": "https://api.github.com/users/nikic/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1", "html_url": "https://github.com/rust-lang/rust/commit/6cfc6033955dd2685dfa7baeec6f6bc3bfdfe2f1"}], "stats": {"total": 288, "additions": 29, "deletions": 259}, "files": [{"sha": "f04dde26e07e9735b4285acfe5783dcb2d2d5269", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3cc8b17451aac4a144baa48bb48f4187a5529769/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc8b17451aac4a144baa48bb48f4187a5529769/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=3cc8b17451aac4a144baa48bb48f4187a5529769", "patch": "@@ -595,9 +595,7 @@ fn run_pass_manager(cgcx: &CodegenContext,\n         };\n         with_llvm_pmb(llmod, config, opt_level, false, &mut |b| {\n             if thin {\n-                if !llvm::LLVMRustPassManagerBuilderPopulateThinLTOPassManager(b, pm) {\n-                    panic!(\"this version of LLVM does not support ThinLTO\");\n-                }\n+                llvm::LLVMRustPassManagerBuilderPopulateThinLTOPassManager(b, pm);\n             } else {\n                 llvm::LLVMPassManagerBuilderPopulateLTOPassManager(b, pm,\n                     /* Internalize = */ False,"}, {"sha": "129305963c6c4f579a667766d1163f092303c2cb", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 13, "deletions": 44, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/3cc8b17451aac4a144baa48bb48f4187a5529769/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc8b17451aac4a144baa48bb48f4187a5529769/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=3cc8b17451aac4a144baa48bb48f4187a5529769", "patch": "@@ -859,8 +859,7 @@ impl Builder<'a, 'll, 'tcx> {\n             // FIXME: add a non-fast math version once\n             // https://bugs.llvm.org/show_bug.cgi?id=36732\n             // is fixed.\n-            let instr = llvm::LLVMRustBuildVectorReduceFAdd(self.llbuilder, acc, src)\n-                .expect(\"LLVMRustBuildVectorReduceFAdd is not available in LLVM version < 5.0\");\n+            let instr = llvm::LLVMRustBuildVectorReduceFAdd(self.llbuilder, acc, src);\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n@@ -871,92 +870,62 @@ impl Builder<'a, 'll, 'tcx> {\n             // FIXME: add a non-fast math version once\n             // https://bugs.llvm.org/show_bug.cgi?id=36732\n             // is fixed.\n-            let instr = llvm::LLVMRustBuildVectorReduceFMul(self.llbuilder, acc, src)\n-                .expect(\"LLVMRustBuildVectorReduceFMul is not available in LLVM version < 5.0\");\n+            let instr = llvm::LLVMRustBuildVectorReduceFMul(self.llbuilder, acc, src);\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n     pub fn vector_reduce_add(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.add\");\n-        unsafe {\n-            let instr = llvm::LLVMRustBuildVectorReduceAdd(self.llbuilder, src);\n-            instr.expect(\"LLVMRustBuildVectorReduceAdd is not available in LLVM version < 5.0\")\n-        }\n+        unsafe { llvm::LLVMRustBuildVectorReduceAdd(self.llbuilder, src) }\n     }\n     pub fn vector_reduce_mul(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.mul\");\n-        unsafe {\n-            let instr = llvm::LLVMRustBuildVectorReduceMul(self.llbuilder, src);\n-            instr.expect(\"LLVMRustBuildVectorReduceMul is not available in LLVM version < 5.0\")\n-        }\n+        unsafe { llvm::LLVMRustBuildVectorReduceMul(self.llbuilder, src) }\n     }\n     pub fn vector_reduce_and(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.and\");\n-        unsafe {\n-            let instr = llvm::LLVMRustBuildVectorReduceAnd(self.llbuilder, src);\n-            instr.expect(\"LLVMRustBuildVectorReduceAnd is not available in LLVM version < 5.0\")\n-        }\n+        unsafe { llvm::LLVMRustBuildVectorReduceAnd(self.llbuilder, src) }\n     }\n     pub fn vector_reduce_or(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.or\");\n-        unsafe {\n-            let instr = llvm::LLVMRustBuildVectorReduceOr(self.llbuilder, src);\n-            instr.expect(\"LLVMRustBuildVectorReduceOr is not available in LLVM version < 5.0\")\n-        }\n+        unsafe { llvm::LLVMRustBuildVectorReduceOr(self.llbuilder, src) }\n     }\n     pub fn vector_reduce_xor(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.xor\");\n-        unsafe {\n-            let instr = llvm::LLVMRustBuildVectorReduceXor(self.llbuilder, src);\n-            instr.expect(\"LLVMRustBuildVectorReduceXor is not available in LLVM version < 5.0\")\n-        }\n+        unsafe { llvm::LLVMRustBuildVectorReduceXor(self.llbuilder, src) }\n     }\n     pub fn vector_reduce_fmin(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fmin\");\n-        unsafe {\n-            let instr = llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ false);\n-            instr.expect(\"LLVMRustBuildVectorReduceFMin is not available in LLVM version < 5.0\")\n-        }\n+        unsafe { llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ false) }\n     }\n     pub fn vector_reduce_fmax(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fmax\");\n-        unsafe {\n-            let instr = llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ false);\n-            instr.expect(\"LLVMRustBuildVectorReduceFMax is not available in LLVM version < 5.0\")\n-        }\n+        unsafe { llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ false) }\n     }\n     pub fn vector_reduce_fmin_fast(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fmin_fast\");\n         unsafe {\n-            let instr = llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ true)\n-                .expect(\"LLVMRustBuildVectorReduceFMin is not available in LLVM version < 5.0\");\n+            let instr = llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ true);\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n     pub fn vector_reduce_fmax_fast(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fmax_fast\");\n         unsafe {\n-            let instr = llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ true)\n-                .expect(\"LLVMRustBuildVectorReduceFMax is not available in LLVM version < 5.0\");\n+            let instr = llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ true);\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n     pub fn vector_reduce_min(&self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n         self.count_insn(\"vector.reduce.min\");\n-        unsafe {\n-            let instr = llvm::LLVMRustBuildVectorReduceMin(self.llbuilder, src, is_signed);\n-            instr.expect(\"LLVMRustBuildVectorReduceMin is not available in LLVM version < 5.0\")\n-        }\n+        unsafe { llvm::LLVMRustBuildVectorReduceMin(self.llbuilder, src, is_signed) }\n     }\n     pub fn vector_reduce_max(&self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n         self.count_insn(\"vector.reduce.max\");\n-        unsafe {\n-            let instr = llvm::LLVMRustBuildVectorReduceMax(self.llbuilder, src, is_signed);\n-            instr.expect(\"LLVMRustBuildVectorReduceMax is not available in LLVM version < 5.0\")\n-        }\n+        unsafe { llvm::LLVMRustBuildVectorReduceMax(self.llbuilder, src, is_signed) }\n     }\n \n     pub fn extract_value(&self, agg_val: &'ll Value, idx: u64) -> &'ll Value {"}, {"sha": "9a4b94eda7a36f264a6eda93727904bf861ee052", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3cc8b17451aac4a144baa48bb48f4187a5529769/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc8b17451aac4a144baa48bb48f4187a5529769/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=3cc8b17451aac4a144baa48bb48f4187a5529769", "patch": "@@ -1041,42 +1041,42 @@ extern \"C\" {\n     pub fn LLVMRustBuildVectorReduceFAdd(B: &Builder<'a>,\n                                          Acc: &'a Value,\n                                          Src: &'a Value)\n-                                         -> Option<&'a Value>;\n+                                         -> &'a Value;\n     pub fn LLVMRustBuildVectorReduceFMul(B: &Builder<'a>,\n                                          Acc: &'a Value,\n                                          Src: &'a Value)\n-                                         -> Option<&'a Value>;\n+                                         -> &'a Value;\n     pub fn LLVMRustBuildVectorReduceAdd(B: &Builder<'a>,\n                                         Src: &'a Value)\n-                                        -> Option<&'a Value>;\n+                                        -> &'a Value;\n     pub fn LLVMRustBuildVectorReduceMul(B: &Builder<'a>,\n                                         Src: &'a Value)\n-                                        -> Option<&'a Value>;\n+                                        -> &'a Value;\n     pub fn LLVMRustBuildVectorReduceAnd(B: &Builder<'a>,\n                                         Src: &'a Value)\n-                                        -> Option<&'a Value>;\n+                                        -> &'a Value;\n     pub fn LLVMRustBuildVectorReduceOr(B: &Builder<'a>,\n                                        Src: &'a Value)\n-                                       -> Option<&'a Value>;\n+                                       -> &'a Value;\n     pub fn LLVMRustBuildVectorReduceXor(B: &Builder<'a>,\n                                         Src: &'a Value)\n-                                        -> Option<&'a Value>;\n+                                        -> &'a Value;\n     pub fn LLVMRustBuildVectorReduceMin(B: &Builder<'a>,\n                                         Src: &'a Value,\n                                         IsSigned: bool)\n-                                        -> Option<&'a Value>;\n+                                        -> &'a Value;\n     pub fn LLVMRustBuildVectorReduceMax(B: &Builder<'a>,\n                                         Src: &'a Value,\n                                         IsSigned: bool)\n-                                        -> Option<&'a Value>;\n+                                        -> &'a Value;\n     pub fn LLVMRustBuildVectorReduceFMin(B: &Builder<'a>,\n                                          Src: &'a Value,\n                                          IsNaN: bool)\n-                                         -> Option<&'a Value>;\n+                                         -> &'a Value;\n     pub fn LLVMRustBuildVectorReduceFMax(B: &Builder<'a>,\n                                          Src: &'a Value,\n                                          IsNaN: bool)\n-                                         -> Option<&'a Value>;\n+                                         -> &'a Value;\n \n     pub fn LLVMRustBuildMinNum(\n         B: &Builder<'a>,\n@@ -1157,7 +1157,7 @@ extern \"C\" {\n                                                         RunInliner: Bool);\n     pub fn LLVMRustPassManagerBuilderPopulateThinLTOPassManager(\n         PMB: &PassManagerBuilder,\n-        PM: &PassManager) -> bool;\n+        PM: &PassManager);\n \n     // Stuff that's in rustllvm/ because it's not upstream yet.\n "}, {"sha": "1355c0377ce913eed566ae4d08f80689087cc095", "filename": "src/rustllvm/ArchiveWrapper.cpp", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cc8b17451aac4a144baa48bb48f4187a5529769/src%2Frustllvm%2FArchiveWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3cc8b17451aac4a144baa48bb48f4187a5529769/src%2Frustllvm%2FArchiveWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FArchiveWrapper.cpp?ref=3cc8b17451aac4a144baa48bb48f4187a5529769", "patch": "@@ -204,9 +204,7 @@ LLVMRustWriteArchive(char *Dst, size_t NumMembers,\n         LLVMRustSetLastError(toString(MOrErr.takeError()).c_str());\n         return LLVMRustResult::Failure;\n       }\n-#if LLVM_VERSION_GE(5, 0)\n       MOrErr->MemberName = sys::path::filename(MOrErr->MemberName);\n-#endif\n       Members.push_back(std::move(*MOrErr));\n     } else {\n       Expected<NewArchiveMember> MOrErr ="}, {"sha": "60b8464947a644793921c9c904ff768498a21fd8", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 1, "deletions": 40, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/3cc8b17451aac4a144baa48bb48f4187a5529769/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3cc8b17451aac4a144baa48bb48f4187a5529769/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=3cc8b17451aac4a144baa48bb48f4187a5529769", "patch": "@@ -36,9 +36,6 @@\n #include \"llvm/Transforms/IPO/FunctionImport.h\"\n #include \"llvm/Transforms/Utils/FunctionImportUtils.h\"\n #include \"llvm/LTO/LTO.h\"\n-#if LLVM_VERSION_LE(4, 0)\n-#include \"llvm/Object/ModuleSummaryIndexObjectFile.h\"\n-#endif\n \n #include \"llvm-c/Transforms/PassManagerBuilder.h\"\n \n@@ -111,12 +108,11 @@ extern \"C\" void LLVMRustAddPass(LLVMPassManagerRef PMR, LLVMPassRef RustPass) {\n }\n \n extern \"C\"\n-bool LLVMRustPassManagerBuilderPopulateThinLTOPassManager(\n+void LLVMRustPassManagerBuilderPopulateThinLTOPassManager(\n   LLVMPassManagerBuilderRef PMBR,\n   LLVMPassManagerRef PMR\n ) {\n   unwrap(PMBR)->populateThinLTOPassManager(*unwrap(PMR));\n-  return true;\n }\n \n #ifdef LLVM_COMPONENT_X86\n@@ -869,21 +865,10 @@ LLVMRustCreateThinLTOData(LLVMRustThinLTOModule *modules,\n \n     Ret->ModuleMap[module->identifier] = mem_buffer;\n \n-#if LLVM_VERSION_GE(5, 0)\n     if (Error Err = readModuleSummaryIndex(mem_buffer, Ret->Index, i)) {\n       LLVMRustSetLastError(toString(std::move(Err)).c_str());\n       return nullptr;\n     }\n-#else\n-    Expected<std::unique_ptr<object::ModuleSummaryIndexObjectFile>> ObjOrErr =\n-      object::ModuleSummaryIndexObjectFile::create(mem_buffer);\n-    if (!ObjOrErr) {\n-      LLVMRustSetLastError(toString(ObjOrErr.takeError()).c_str());\n-      return nullptr;\n-    }\n-    auto Index = (*ObjOrErr)->takeIndex();\n-    Ret->Index.mergeFrom(std::move(Index), i);\n-#endif\n   }\n \n   // Collect for each module the list of function it defines (GUID -> Summary)\n@@ -900,7 +885,6 @@ LLVMRustCreateThinLTOData(LLVMRustThinLTOModule *modules,\n   // combined index\n   //\n   // This is copied from `lib/LTO/ThinLTOCodeGenerator.cpp`\n-#if LLVM_VERSION_GE(5, 0)\n #if LLVM_VERSION_GE(7, 0)\n   auto deadIsPrevailing = [&](GlobalValue::GUID G) {\n     return PrevailingType::Unknown;\n@@ -915,16 +899,6 @@ LLVMRustCreateThinLTOData(LLVMRustThinLTOModule *modules,\n     Ret->ImportLists,\n     Ret->ExportLists\n   );\n-#else\n-  auto DeadSymbols = computeDeadSymbols(Ret->Index, Ret->GUIDPreservedSymbols);\n-  ComputeCrossModuleImport(\n-    Ret->Index,\n-    Ret->ModuleToDefinedGVSummaries,\n-    Ret->ImportLists,\n-    Ret->ExportLists,\n-    &DeadSymbols\n-  );\n-#endif\n \n   // Resolve LinkOnce/Weak symbols, this has to be computed early be cause it\n   // impacts the caching.\n@@ -934,13 +908,8 @@ LLVMRustCreateThinLTOData(LLVMRustThinLTOModule *modules,\n   StringMap<std::map<GlobalValue::GUID, GlobalValue::LinkageTypes>> ResolvedODR;\n   DenseMap<GlobalValue::GUID, const GlobalValueSummary *> PrevailingCopy;\n   for (auto &I : Ret->Index) {\n-#if LLVM_VERSION_GE(5, 0)\n     if (I.second.SummaryList.size() > 1)\n       PrevailingCopy[I.first] = getFirstDefinitionForLinker(I.second.SummaryList);\n-#else\n-    if (I.second.size() > 1)\n-      PrevailingCopy[I.first] = getFirstDefinitionForLinker(I.second);\n-#endif\n   }\n   auto isPrevailing = [&](GlobalValue::GUID GUID, const GlobalValueSummary *S) {\n     const auto &Prevailing = PrevailingCopy.find(GUID);\n@@ -962,19 +931,11 @@ LLVMRustCreateThinLTOData(LLVMRustThinLTOModule *modules,\n   // linkage will stay as external, and internal will stay as internal.\n   std::set<GlobalValue::GUID> ExportedGUIDs;\n   for (auto &List : Ret->Index) {\n-#if LLVM_VERSION_GE(5, 0)\n     for (auto &GVS: List.second.SummaryList) {\n-#else\n-    for (auto &GVS: List.second) {\n-#endif\n       if (GlobalValue::isLocalLinkage(GVS->linkage()))\n         continue;\n       auto GUID = GVS->getOriginalName();\n-#if LLVM_VERSION_GE(5, 0)\n       if (GVS->flags().Live)\n-#else\n-      if (!DeadSymbols.count(GUID))\n-#endif\n         ExportedGUIDs.insert(GUID);\n     }\n   }"}, {"sha": "aa7241e3b3d31b49ee4191dd7b8990a3dd34a132", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 2, "deletions": 158, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/3cc8b17451aac4a144baa48bb48f4187a5529769/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3cc8b17451aac4a144baa48bb48f4187a5529769/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=3cc8b17451aac4a144baa48bb48f4187a5529769", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #include \"rustllvm.h\"\n+#include \"llvm/IR/CallSite.h\"\n #include \"llvm/IR/DebugInfoMetadata.h\"\n #include \"llvm/IR/DiagnosticInfo.h\"\n #include \"llvm/IR/DiagnosticPrinter.h\"\n@@ -18,14 +19,7 @@\n #include \"llvm/Object/ObjectFile.h\"\n #include \"llvm/Bitcode/BitcodeWriterPass.h\"\n #include \"llvm/Support/Signals.h\"\n-\n-#include \"llvm/IR/CallSite.h\"\n-\n-#if LLVM_VERSION_GE(5, 0)\n #include \"llvm/ADT/Optional.h\"\n-#else\n-#include <cstdlib>\n-#endif\n \n #include <iostream>\n \n@@ -212,14 +206,7 @@ extern \"C\" void LLVMRustAddCallSiteAttribute(LLVMValueRef Instr, unsigned Index,\n                                              LLVMRustAttribute RustAttr) {\n   CallSite Call = CallSite(unwrap<Instruction>(Instr));\n   Attribute Attr = Attribute::get(Call->getContext(), fromRust(RustAttr));\n-#if LLVM_VERSION_GE(5, 0)\n   Call.addAttribute(Index, Attr);\n-#else\n-  AttrBuilder B(Attr);\n-  Call.setAttributes(Call.getAttributes().addAttributes(\n-      Call->getContext(), Index,\n-      AttributeSet::get(Call->getContext(), Index, B)));\n-#endif\n }\n \n extern \"C\" void LLVMRustAddAlignmentCallSiteAttr(LLVMValueRef Instr,\n@@ -228,14 +215,8 @@ extern \"C\" void LLVMRustAddAlignmentCallSiteAttr(LLVMValueRef Instr,\n   CallSite Call = CallSite(unwrap<Instruction>(Instr));\n   AttrBuilder B;\n   B.addAlignmentAttr(Bytes);\n-#if LLVM_VERSION_GE(5, 0)\n   Call.setAttributes(Call.getAttributes().addAttributes(\n       Call->getContext(), Index, B));\n-#else\n-  Call.setAttributes(Call.getAttributes().addAttributes(\n-      Call->getContext(), Index,\n-      AttributeSet::get(Call->getContext(), Index, B)));\n-#endif\n }\n \n extern \"C\" void LLVMRustAddDereferenceableCallSiteAttr(LLVMValueRef Instr,\n@@ -244,14 +225,8 @@ extern \"C\" void LLVMRustAddDereferenceableCallSiteAttr(LLVMValueRef Instr,\n   CallSite Call = CallSite(unwrap<Instruction>(Instr));\n   AttrBuilder B;\n   B.addDereferenceableAttr(Bytes);\n-#if LLVM_VERSION_GE(5, 0)\n   Call.setAttributes(Call.getAttributes().addAttributes(\n       Call->getContext(), Index, B));\n-#else\n-  Call.setAttributes(Call.getAttributes().addAttributes(\n-      Call->getContext(), Index,\n-      AttributeSet::get(Call->getContext(), Index, B)));\n-#endif\n }\n \n extern \"C\" void LLVMRustAddDereferenceableOrNullCallSiteAttr(LLVMValueRef Instr,\n@@ -260,26 +235,16 @@ extern \"C\" void LLVMRustAddDereferenceableOrNullCallSiteAttr(LLVMValueRef Instr,\n   CallSite Call = CallSite(unwrap<Instruction>(Instr));\n   AttrBuilder B;\n   B.addDereferenceableOrNullAttr(Bytes);\n-#if LLVM_VERSION_GE(5, 0)\n   Call.setAttributes(Call.getAttributes().addAttributes(\n       Call->getContext(), Index, B));\n-#else\n-  Call.setAttributes(Call.getAttributes().addAttributes(\n-      Call->getContext(), Index,\n-      AttributeSet::get(Call->getContext(), Index, B)));\n-#endif\n }\n \n extern \"C\" void LLVMRustAddFunctionAttribute(LLVMValueRef Fn, unsigned Index,\n                                              LLVMRustAttribute RustAttr) {\n   Function *A = unwrap<Function>(Fn);\n   Attribute Attr = Attribute::get(A->getContext(), fromRust(RustAttr));\n   AttrBuilder B(Attr);\n-#if LLVM_VERSION_GE(5, 0)\n   A->addAttributes(Index, B);\n-#else\n-  A->addAttributes(Index, AttributeSet::get(A->getContext(), Index, B));\n-#endif\n }\n \n extern \"C\" void LLVMRustAddAlignmentAttr(LLVMValueRef Fn,\n@@ -288,23 +253,15 @@ extern \"C\" void LLVMRustAddAlignmentAttr(LLVMValueRef Fn,\n   Function *A = unwrap<Function>(Fn);\n   AttrBuilder B;\n   B.addAlignmentAttr(Bytes);\n-#if LLVM_VERSION_GE(5, 0)\n   A->addAttributes(Index, B);\n-#else\n-  A->addAttributes(Index, AttributeSet::get(A->getContext(), Index, B));\n-#endif\n }\n \n extern \"C\" void LLVMRustAddDereferenceableAttr(LLVMValueRef Fn, unsigned Index,\n                                                uint64_t Bytes) {\n   Function *A = unwrap<Function>(Fn);\n   AttrBuilder B;\n   B.addDereferenceableAttr(Bytes);\n-#if LLVM_VERSION_GE(5, 0)\n   A->addAttributes(Index, B);\n-#else\n-  A->addAttributes(Index, AttributeSet::get(A->getContext(), Index, B));\n-#endif\n }\n \n extern \"C\" void LLVMRustAddDereferenceableOrNullAttr(LLVMValueRef Fn,\n@@ -313,11 +270,7 @@ extern \"C\" void LLVMRustAddDereferenceableOrNullAttr(LLVMValueRef Fn,\n   Function *A = unwrap<Function>(Fn);\n   AttrBuilder B;\n   B.addDereferenceableOrNullAttr(Bytes);\n-#if LLVM_VERSION_GE(5, 0)\n   A->addAttributes(Index, B);\n-#else\n-  A->addAttributes(Index, AttributeSet::get(A->getContext(), Index, B));\n-#endif\n }\n \n extern \"C\" void LLVMRustAddFunctionAttrStringValue(LLVMValueRef Fn,\n@@ -327,11 +280,7 @@ extern \"C\" void LLVMRustAddFunctionAttrStringValue(LLVMValueRef Fn,\n   Function *F = unwrap<Function>(Fn);\n   AttrBuilder B;\n   B.addAttribute(Name, Value);\n-#if LLVM_VERSION_GE(5, 0)\n   F->addAttributes(Index, B);\n-#else\n-  F->addAttributes(Index, AttributeSet::get(F->getContext(), Index, B));\n-#endif\n }\n \n extern \"C\" void LLVMRustRemoveFunctionAttributes(LLVMValueRef Fn,\n@@ -341,12 +290,7 @@ extern \"C\" void LLVMRustRemoveFunctionAttributes(LLVMValueRef Fn,\n   Attribute Attr = Attribute::get(F->getContext(), fromRust(RustAttr));\n   AttrBuilder B(Attr);\n   auto PAL = F->getAttributes();\n-#if LLVM_VERSION_GE(5, 0)\n   auto PALNew = PAL.removeAttributes(F->getContext(), Index, B);\n-#else\n-  const AttributeSet PALNew = PAL.removeAttributes(\n-      F->getContext(), Index, AttributeSet::get(F->getContext(), Index, B));\n-#endif\n   F->setAttributes(PALNew);\n }\n \n@@ -396,7 +340,6 @@ enum class LLVMRustSynchronizationScope {\n   CrossThread,\n };\n \n-#if LLVM_VERSION_GE(5, 0)\n static SyncScope::ID fromRust(LLVMRustSynchronizationScope Scope) {\n   switch (Scope) {\n   case LLVMRustSynchronizationScope::SingleThread:\n@@ -407,18 +350,6 @@ static SyncScope::ID fromRust(LLVMRustSynchronizationScope Scope) {\n     report_fatal_error(\"bad SynchronizationScope.\");\n   }\n }\n-#else\n-static SynchronizationScope fromRust(LLVMRustSynchronizationScope Scope) {\n-  switch (Scope) {\n-  case LLVMRustSynchronizationScope::SingleThread:\n-    return SingleThread;\n-  case LLVMRustSynchronizationScope::CrossThread:\n-    return CrossThread;\n-  default:\n-    report_fatal_error(\"bad SynchronizationScope.\");\n-  }\n-}\n-#endif\n \n extern \"C\" LLVMValueRef\n LLVMRustBuildAtomicFence(LLVMBuilderRef B, LLVMAtomicOrdering Order,\n@@ -463,18 +394,6 @@ extern \"C\" void LLVMRustAppendModuleInlineAsm(LLVMModuleRef M, const char *Asm)\n \n typedef DIBuilder *LLVMRustDIBuilderRef;\n \n-#if LLVM_VERSION_LT(5, 0)\n-typedef struct LLVMOpaqueMetadata *LLVMMetadataRef;\n-\n-namespace llvm {\n-DEFINE_ISA_CONVERSION_FUNCTIONS(Metadata, LLVMMetadataRef)\n-\n-inline Metadata **unwrap(LLVMMetadataRef *Vals) {\n-  return reinterpret_cast<Metadata **>(Vals);\n-}\n-}\n-#endif\n-\n template <typename DIT> DIT *unwrapDIPtr(LLVMMetadataRef Ref) {\n   return (DIT *)(Ref ? unwrap<MDNode>(Ref) : nullptr);\n }\n@@ -590,11 +509,6 @@ static DINode::DIFlags fromRust(LLVMRustDIFlags Flags) {\n   if (isSet(Flags & LLVMRustDIFlags::FlagRValueReference)) {\n     Result |= DINode::DIFlags::FlagRValueReference;\n   }\n-#if LLVM_VERSION_LE(4, 0)\n-  if (isSet(Flags & LLVMRustDIFlags::FlagExternalTypeRef)) {\n-    Result |= DINode::DIFlags::FlagExternalTypeRef;\n-  }\n-#endif\n   if (isSet(Flags & LLVMRustDIFlags::FlagIntroducedVirtual)) {\n     Result |= DINode::DIFlags::FlagIntroducedVirtual;\n   }\n@@ -693,9 +607,7 @@ extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreatePointerType(\n     uint64_t SizeInBits, uint32_t AlignInBits, const char *Name) {\n   return wrap(Builder->createPointerType(unwrapDI<DIType>(PointeeTy),\n                                          SizeInBits, AlignInBits,\n-#if LLVM_VERSION_GE(5, 0)\n                                          /* DWARFAddressSpace */ None,\n-#endif\n                                          Name));\n }\n \n@@ -902,12 +814,7 @@ LLVMRustDIBuilderCreateNameSpace(LLVMRustDIBuilderRef Builder,\n                                  LLVMMetadataRef Scope, const char *Name,\n                                  LLVMMetadataRef File, unsigned LineNo) {\n   return wrap(Builder->createNameSpace(\n-      unwrapDI<DIDescriptor>(Scope), Name\n-#if LLVM_VERSION_LT(5, 0)\n-      ,\n-      unwrapDI<DIFile>(File), LineNo\n-#endif\n-      ,\n+      unwrapDI<DIDescriptor>(Scope), Name,\n       false // ExportSymbols (only relevant for C++ anonymous namespaces)\n       ));\n }\n@@ -937,12 +844,7 @@ extern \"C\" int64_t LLVMRustDIBuilderCreateOpDeref() {\n }\n \n extern \"C\" int64_t LLVMRustDIBuilderCreateOpPlusUconst() {\n-#if LLVM_VERSION_GE(5, 0)\n   return dwarf::DW_OP_plus_uconst;\n-#else\n-  // older LLVM used `plus` to behave like `plus_uconst`.\n-  return dwarf::DW_OP_plus;\n-#endif\n }\n \n extern \"C\" void LLVMRustWriteTypeToString(LLVMTypeRef Ty, RustStringRef Str) {\n@@ -1014,21 +916,12 @@ extern \"C\" void LLVMRustUnpackOptimizationDiagnostic(\n   *FunctionOut = wrap(&Opt->getFunction());\n \n   RawRustStringOstream FilenameOS(FilenameOut);\n-#if LLVM_VERSION_GE(5,0)\n   DiagnosticLocation loc = Opt->getLocation();\n   if (loc.isValid()) {\n     *Line = loc.getLine();\n     *Column = loc.getColumn();\n     FilenameOS << loc.getFilename();\n   }\n-#else\n-  const DebugLoc &loc = Opt->getDebugLoc();\n-  if (loc) {\n-    *Line = loc.getLine();\n-    *Column = loc.getCol();\n-    FilenameOS << cast<DIScope>(loc.getScope())->getFilename();\n-  }\n-#endif\n \n   RawRustStringOstream MessageOS(MessageOut);\n   MessageOS << Opt->getMsg();\n@@ -1451,7 +1344,6 @@ LLVMRustModuleCost(LLVMModuleRef M) {\n }\n \n // Vector reductions:\n-#if LLVM_VERSION_GE(5, 0)\n extern \"C\" LLVMValueRef\n LLVMRustBuildVectorReduceFAdd(LLVMBuilderRef B, LLVMValueRef Acc, LLVMValueRef Src) {\n     return wrap(unwrap(B)->CreateFAddReduce(unwrap(Acc),unwrap(Src)));\n@@ -1497,54 +1389,6 @@ LLVMRustBuildVectorReduceFMax(LLVMBuilderRef B, LLVMValueRef Src, bool NoNaN) {\n   return wrap(unwrap(B)->CreateFPMaxReduce(unwrap(Src), NoNaN));\n }\n \n-#else\n-\n-extern \"C\" LLVMValueRef\n-LLVMRustBuildVectorReduceFAdd(LLVMBuilderRef, LLVMValueRef, LLVMValueRef) {\n-  return nullptr;\n-}\n-extern \"C\" LLVMValueRef\n-LLVMRustBuildVectorReduceFMul(LLVMBuilderRef, LLVMValueRef, LLVMValueRef) {\n-  return nullptr;\n-}\n-extern \"C\" LLVMValueRef\n-LLVMRustBuildVectorReduceAdd(LLVMBuilderRef, LLVMValueRef) {\n-  return nullptr;\n-}\n-extern \"C\" LLVMValueRef\n-LLVMRustBuildVectorReduceMul(LLVMBuilderRef, LLVMValueRef) {\n-  return nullptr;\n-}\n-extern \"C\" LLVMValueRef\n-LLVMRustBuildVectorReduceAnd(LLVMBuilderRef, LLVMValueRef) {\n-  return nullptr;\n-}\n-extern \"C\" LLVMValueRef\n-LLVMRustBuildVectorReduceOr(LLVMBuilderRef, LLVMValueRef) {\n-  return nullptr;\n-}\n-extern \"C\" LLVMValueRef\n-LLVMRustBuildVectorReduceXor(LLVMBuilderRef, LLVMValueRef) {\n-  return nullptr;\n-}\n-extern \"C\" LLVMValueRef\n-LLVMRustBuildVectorReduceMin(LLVMBuilderRef, LLVMValueRef, bool) {\n-  return nullptr;\n-}\n-extern \"C\" LLVMValueRef\n-LLVMRustBuildVectorReduceMax(LLVMBuilderRef, LLVMValueRef, bool) {\n-  return nullptr;\n-}\n-extern \"C\" LLVMValueRef\n-LLVMRustBuildVectorReduceFMin(LLVMBuilderRef, LLVMValueRef, bool) {\n-  return nullptr;\n-}\n-extern \"C\" LLVMValueRef\n-LLVMRustBuildVectorReduceFMax(LLVMBuilderRef, LLVMValueRef, bool) {\n-  return nullptr;\n-}\n-#endif\n-\n #if LLVM_VERSION_GE(6, 0)\n extern \"C\" LLVMValueRef\n LLVMRustBuildMinNum(LLVMBuilderRef B, LLVMValueRef LHS, LLVMValueRef RHS) {"}]}