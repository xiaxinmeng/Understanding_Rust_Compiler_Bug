{"sha": "a3382b6f26e582210a3b649c9a71badaef0530bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzMzgyYjZmMjZlNTgyMjEwYTNiNjQ5YzlhNzFiYWRhZWYwNTMwYmY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-26T20:55:56Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-30T23:01:49Z"}, "message": "Eliminate usages of old sugared call syntax", "tree": {"sha": "bd30506542a14a132b09aae154417c7cc9312498", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd30506542a14a132b09aae154417c7cc9312498"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3382b6f26e582210a3b649c9a71badaef0530bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3382b6f26e582210a3b649c9a71badaef0530bf", "html_url": "https://github.com/rust-lang/rust/commit/a3382b6f26e582210a3b649c9a71badaef0530bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3382b6f26e582210a3b649c9a71badaef0530bf/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b2491160d71aa7a84ed822b85e9b3eff6097225", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b2491160d71aa7a84ed822b85e9b3eff6097225", "html_url": "https://github.com/rust-lang/rust/commit/8b2491160d71aa7a84ed822b85e9b3eff6097225"}], "stats": {"total": 3133, "additions": 1561, "deletions": 1572}, "files": [{"sha": "ee8ffe654f6106d5d2ce90054bded1349e4e56b5", "filename": "doc/rust.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -1638,7 +1638,7 @@ task in a _failing state_.\n ~~~~\n # let buildr = task::builder();\n # task::unsupervise(buildr);\n-# task::run(buildr) {||\n+# do task::run(buildr) {||\n \n (~[1, 2, 3, 4])[0];\n (~[mut 'x', 'y'])[1] = 'z';\n@@ -3365,7 +3365,7 @@ An example of a `spawn` call:\n let po = comm::port();\n let ch = comm::chan(po);\n \n-task::spawn {||\n+do task::spawn {||\n     // let task run, do other things\n     // ...\n     comm::send(ch, true);"}, {"sha": "1a5b5a4b429c17fd52dbb37010e6c0ca115716b0", "filename": "doc/tutorial.md", "status": "modified", "additions": 21, "deletions": 33, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -924,7 +924,7 @@ processes. They copy the values they close over, much like boxed\n closures, but they also 'own' them\u2014meaning no other code can access\n them. Unique closures mostly exist for spawning new [tasks](#tasks).\n \n-### Shorthand syntax\n+### Do syntax\n \n The compact syntax used for stack closures (`{|arg1, arg2| body}`) can\n also be used to express boxed and unique closures in situations where\n@@ -934,25 +934,10 @@ the long-hand syntax for the function you're passing, since the\n compiler can look at the argument type to find out what the parameter\n types are.\n \n-As a further simplification, if the final parameter to a function is a\n-closure, the closure need not be placed within parentheses. You could,\n-for example, write...\n-\n-~~~~\n-let doubled = vec::map(~[1, 2, 3]) {|x| x*2};\n-~~~~\n-\n-`vec::map` is a function in the core library that applies its last\n-argument to every element of a vector, producing a new vector.\n-\n-Even when a closure takes no parameters, you must still write the bars\n-for the parameter list, as in `{|| ...}`.\n-\n-## Iteration\n-\n-Functions taking closures provide a good way to define non-trivial\n-iteration constructs. For example, this one iterates over a vector\n-of integers backwards:\n+Because closures in Rust are so versatile, they are used often, and in\n+particular, functions taking closures are used as control structures\n+in much the same way as `if` or `loop`. For example, this one iterates\n+over a vector of integers backwards:\n \n ~~~~\n fn for_rev(v: ~[int], act: fn(int)) {\n@@ -971,19 +956,22 @@ To run such an iteration, you could do this:\n for_rev(~[1, 2, 3], {|n| log(error, n); });\n ~~~~\n \n-Making use of the shorthand where a final closure argument can be\n-moved outside of the parentheses permits the following, which\n-looks quite like a normal loop:\n+Because this is such a common pattern Rust has a special form\n+of function call that can be written more like a built-in control\n+structure:\n \n ~~~~\n-# fn for_rev(v: ~[int], act: fn(int)) {}\n-for_rev(~[1, 2, 3]) {|n|\n+# fn for_rev(v: [int], act: fn(int)) {}\n+do for_rev(~[1, 2, 3]) {|n|\n     log(error, n);\n }\n ~~~~\n \n-Note that, because `for_rev()` returns unit type, no semicolon is\n-needed when the final closure is pulled outside of the parentheses.\n+Notice that the call is prefixed with the keyword `do` and, instead of\n+writing the final closure inside the argument list it is moved outside\n+of the parenthesis where it looks visually more like a typical block\n+of code. The `do` expression is purely syntactic sugar for a call\n+that takes a final closure argument.\n \n # For loops\n \n@@ -992,12 +980,12 @@ To allow breaking out of loops, many iteration functions, such as\n `false` to break off iteration.\n \n ~~~~\n-vec::each(~[2, 4, 8, 5, 16]) {|n|\n+vec::each(~[2, 4, 8, 5, 16], {|n|\n     if n % 2 != 0 {\n         io::println(\"found odd number!\");\n         false\n     } else { true }\n-}\n+});\n ~~~~\n \n You can see how that gets noisy. As a syntactic convenience, if the\n@@ -2350,7 +2338,7 @@ module `task`.  Let's begin with the simplest one, `task::spawn()`:\n \n ~~~~\n let some_value = 22;\n-task::spawn {||\n+do task::spawn {||\n     io::println(\"This executes in the child task.\");\n     io::println(#fmt(\"%d\", some_value));\n }\n@@ -2376,7 +2364,7 @@ in parallel.  We might write something like:\n # fn some_other_expensive_computation() {}\n let port = comm::port::<int>();\n let chan = comm::chan::<int>(port);\n-task::spawn {||\n+do task::spawn {||\n     let result = some_expensive_computation();\n     comm::send(chan, result);\n }\n@@ -2407,7 +2395,7 @@ The next statement actually spawns the child:\n # fn some_expensive_computation() -> int { 42 }\n # let port = comm::port::<int>();\n # let chan = comm::chan::<int>(port);\n-task::spawn {||\n+do task::spawn {||\n     let result = some_expensive_computation();\n     comm::send(chan, result);\n }\n@@ -2470,7 +2458,7 @@ Here is the code for the parent task:\n fn main() {\n     let from_child = comm::port();\n     let to_parent = comm::chan(from_child);\n-    let to_child = task::spawn_listener {|from_parent|\n+    let to_child = do task::spawn_listener {|from_parent|\n         stringifier(from_parent, to_parent);\n     };\n     comm::send(to_child, 22u);"}, {"sha": "e8cc605fbdde3c00799fa4dbcebf71923e8d78a8", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -1469,10 +1469,10 @@ fn print_source(s: source) {\n     }, copy s.packages);\n     let l = vec::len(pks);\n \n-    print(io::with_str_writer() { |writer|\n+    print(io::with_str_writer({ |writer|\n         let mut list = \"   >> \";\n \n-        vec::iteri(pks) { |i, pk|\n+        do vec::iteri(pks) { |i, pk|\n             if str::len(list) > 78u {\n                 writer.write_line(list);\n                 list = \"   >> \";\n@@ -1481,14 +1481,14 @@ fn print_source(s: source) {\n         }\n \n         writer.write_line(list);\n-    });\n+    }));\n }\n \n fn cmd_list(c: cargo) {\n     sync(c);\n \n     if vec::len(c.opts.free) >= 3u {\n-        vec::iter_between(c.opts.free, 2u, vec::len(c.opts.free)) { |name|\n+        do vec::iter_between(c.opts.free, 2u, vec::len(c.opts.free)) { |name|\n             if !valid_pkg_name(name) {\n                 error(#fmt(\"'%s' is an invalid source name\", name));\n             } else {"}, {"sha": "2810ffd139a93935302076335c642fe75645434f", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -43,11 +43,11 @@ fn load_props(testfile: str) -> test_props {\n             pp_exact = parse_pp_exact(ln, testfile);\n         }\n \n-        option::iter(parse_aux_build(ln)) {|ab|\n+        do option::iter(parse_aux_build(ln)) {|ab|\n             vec::push(aux_builds, ab);\n         }\n \n-        option::iter(parse_exec_env(ln)) {|ee|\n+        do option::iter(parse_exec_env(ln)) {|ee|\n             vec::push(exec_env, ee);\n         }\n     };\n@@ -104,7 +104,7 @@ fn parse_compile_flags(line: str) -> option<str> {\n }\n \n fn parse_exec_env(line: str) -> option<(str, str)> {\n-    parse_name_value_directive(line, \"exec-env\").map {|nv|\n+    do parse_name_value_directive(line, \"exec-env\").map {|nv|\n         // nv is either FOO or FOO=BAR\n         let strs = str::splitn_char(nv, '=', 1u);\n         alt strs.len() {"}, {"sha": "dfe66b57a88152a2f9fdc471fcefad663b470870", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -13,7 +13,7 @@ fn target_env(lib_path: str, prog: str) -> ~[(str,str)] {\n     assert prog.ends_with(\".exe\");\n     let aux_path = prog.slice(0u, prog.len() - 4u) + \".libaux\";\n \n-    env = vec::map(env) {|pair|\n+    env = do vec::map(env) {|pair|\n         let (k,v) = pair;\n         if k == \"PATH\" { (\"PATH\", v + \";\" + lib_path + \";\" + aux_path) }\n         else { (k,v) }\n@@ -60,14 +60,14 @@ fn run(lib_path: str,\n     writeclose(pipe_in.out, input);\n     let p = comm::port();\n     let ch = comm::chan(p);\n-    task::spawn_sched(task::single_threaded) {||\n+    do task::spawn_sched(task::single_threaded) {||\n         let errput = readclose(pipe_err.in);\n         comm::send(ch, (2, errput));\n-    };\n-    task::spawn_sched(task::single_threaded) {||\n+    }\n+    do task::spawn_sched(task::single_threaded) {||\n         let output = readclose(pipe_out.in);\n         comm::send(ch, (1, output));\n-    };\n+    }\n     let status = run::waitpid(pid);\n     let mut errs = \"\";\n     let mut outs = \"\";"}, {"sha": "c7fcf1ca3f6a491657aafa5d956c65747ba76cbd", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -321,7 +321,7 @@ fn compose_and_run_compiler(\n \n     let extra_link_args = ~[\"-L\", aux_output_dir_name(config, testfile)];\n \n-    vec::iter(props.aux_builds) {|rel_ab|\n+    do vec::iter(props.aux_builds) {|rel_ab|\n         let abs_ab = path::connect(config.aux_base, rel_ab);\n         let aux_args =\n             make_compile_args(config, props, ~[\"--lib\"] + extra_link_args,"}, {"sha": "2cbcfafb4f26ed920ad714a861d7d264fa34c431", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -259,9 +259,9 @@ fn check_variants_T<T: copy>(\n     let L = vec::len(things);\n \n     if L < 100u {\n-        under(uint::min(L, 20u)) {|i|\n+        do under(uint::min(L, 20u)) {|i|\n             log(error, \"Replacing... #\" + uint::str(i));\n-            under(uint::min(L, 30u)) {|j|\n+            do under(uint::min(L, 30u)) {|j|\n                 log(error, \"With... \" + stringifier(@things[j]));\n                 let crate2 = @replacer(crate, i, things[j], cx.mode);\n                 // It would be best to test the *crate* for stability, but\n@@ -421,15 +421,15 @@ fn parse_and_print(code: @str) -> str {\n     write_file(filename, *code);\n     let crate = parse::parse_crate_from_source_str(\n         filename, code, ~[], sess);\n-    io::with_str_reader(*code) { |rdr|\n+    io::with_str_reader(*code, { |rdr|\n         as_str({|a|pprust::print_crate(sess.cm,\n                                        sess.span_diagnostic,\n                                        crate,\n                                        filename,\n                                        rdr, a,\n                                        pprust::no_ann(),\n                                        false)})\n-    }\n+    })\n }\n \n fn has_raw_pointers(c: ast::crate) -> bool {\n@@ -565,16 +565,16 @@ fn check_variants(files: ~[str], cx: context) {\n             parse::parse_crate_from_source_str(\n                 file,\n                 s, ~[], sess);\n-        io::with_str_reader(*s) { |rdr|\n+        io::with_str_reader(*s, { |rdr|\n             #error(\"%s\",\n                    as_str({|a|pprust::print_crate(sess.cm,\n                                                   sess.span_diagnostic,\n                                                   crate,\n                                                   file,\n                                                   rdr, a,\n                                                   pprust::no_ann(),\n-                                                  false)}));\n-        }\n+                                                  false)}))\n+        });\n         check_variants_of_ast(*crate, sess.cm, file, cx);\n     }\n }"}, {"sha": "7a74410dc61d47301e5b4e34b051774cba5d205b", "filename": "src/libcore/arc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farc.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -109,9 +109,9 @@ impl methods<T: send> for exclusive<T> {\n             unsafe::reinterpret_cast(self.data);\n         let r = {\n             let rec: &ex_data<T> = &(*ptr).data;\n-            rec.lock.lock_cond() {|c|\n+            rec.lock.lock_cond({|c|\n                 f(c, &rec.data)\n-            }\n+            })\n         };\n         unsafe::forget(ptr);\n         r\n@@ -135,7 +135,7 @@ fn shared_arc<T: send const>(-data: T) -> shared_arc<T> {\n     let a = arc::arc(data);\n     let p = port();\n     let c = chan(p);\n-    task::spawn() {|move a|\n+    do task::spawn() {|move a|\n         let mut live = true;\n         let terminate = port();\n         let get = port();\n@@ -174,7 +174,7 @@ mod tests {\n         let p = port();\n         let c = chan(p);\n \n-        task::spawn() {||\n+        do task::spawn() {||\n             let p = port();\n             c.send(chan(p));\n \n@@ -200,7 +200,7 @@ mod tests {\n         let p = port();\n         let c = chan(p);\n \n-        task::spawn() {||\n+        do task::spawn() {||\n             let arc_v = get_arc(arc_c);\n             let v = *get(&arc_v);\n             assert v[2] == 3;\n@@ -225,7 +225,7 @@ mod tests {\n             let total = total.clone();\n             futures += ~[future::spawn({||\n                 for uint::range(0u, count) {|_i|\n-                    total.with {|_cond, count|\n+                    do total.with {|_cond, count|\n                         **count += 1u;\n                     }\n                 }\n@@ -234,7 +234,7 @@ mod tests {\n \n         for futures.each {|f| f.get() };\n \n-        total.with {|_cond, total|\n+        do total.with {|_cond, total|\n             assert **total == num_tasks * count\n         };\n     }"}, {"sha": "131b09b2d43b17c4cfd8cc41776f91e6d25073c4", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -65,7 +65,7 @@ pure fn to_bit(v: bool) -> u8 { if v { 1u8 } else { 0u8 } }\n \n #[test]\n fn test_bool_from_str() {\n-    all_values { |v|\n+    do all_values { |v|\n         assert some(v) == from_str(bool::to_str(v))\n     }\n }\n@@ -78,7 +78,7 @@ fn test_bool_to_str() {\n \n #[test]\n fn test_bool_to_bit() {\n-    all_values { |v|\n+    do all_values { |v|\n         assert to_bit(v) == if is_true(v) { 1u8 } else { 0u8 };\n     }\n }"}, {"sha": "894256872bf95282ea6ba9b2a7387f355fa64758", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -98,7 +98,7 @@ class port_ptr<T:send> {\n   let po: *rust_port;\n   new(po: *rust_port) { self.po = po; }\n   drop unsafe {\n-    task::unkillable {||\n+    do task::unkillable {||\n         // Once the port is detached it's guaranteed not to receive further\n         // messages\n         let yield = 0u;\n@@ -223,7 +223,7 @@ fn select2<A: send, B: send>(p_a: port<A>, p_b: port<B>)\n \n     let mut resport: *rust_port;\n     resport = rusti::init::<*rust_port>();\n-    vec::as_buf(ports) {|ports|\n+    do vec::as_buf(ports) {|ports|\n         rustrt::rust_port_select(ptr::addr_of(resport), ports, n_ports,\n                                  yieldp);\n     }\n@@ -364,16 +364,16 @@ fn test_select2_rendezvous() {\n     let ch_a = chan(po_a);\n     let ch_b = chan(po_b);\n \n-    iter::repeat(10u) {||\n-        task::spawn {||\n-            iter::repeat(10u) {|| task::yield() }\n+    do iter::repeat(10u) {||\n+        do task::spawn {||\n+            iter::repeat(10u, {|| task::yield() });\n             send(ch_a, \"a\");\n         };\n \n         assert select2(po_a, po_b) == either::left(\"a\");\n \n-        task::spawn {||\n-            iter::repeat(10u) {|| task::yield() }\n+        do task::spawn {||\n+            iter::repeat(10u, {|| task::yield() });\n             send(ch_b, \"b\");\n         };\n \n@@ -391,22 +391,22 @@ fn test_select2_stress() {\n     let msgs = 100u;\n     let times = 4u;\n \n-    iter::repeat(times) {||\n-        task::spawn {||\n-            iter::repeat(msgs) {||\n+    do iter::repeat(times) {||\n+        do task::spawn {||\n+            do iter::repeat(msgs) {||\n                 send(ch_a, \"a\")\n             }\n         };\n-        task::spawn {||\n-            iter::repeat(msgs) {||\n+        do task::spawn {||\n+            do iter::repeat(msgs) {||\n                 send(ch_b, \"b\")\n             }\n         };\n     }\n \n     let mut as = 0;\n     let mut bs = 0;\n-    iter::repeat(msgs * times * 2u) {||\n+    do iter::repeat(msgs * times * 2u) {||\n         alt check select2(po_a, po_b) {\n           either::left(\"a\") { as += 1 }\n           either::right(\"b\") { bs += 1 }\n@@ -440,9 +440,9 @@ fn test_recv_chan_wrong_task() {\n     let po = port();\n     let ch = chan(po);\n     send(ch, \"flower\");\n-    assert result::is_err(task::try {||\n+    assert result::is_err(task::try({||\n         recv_chan(ch)\n-    })\n+    }))\n }\n \n #[test]\n@@ -462,8 +462,8 @@ fn test_chan_peek() {\n \n #[test]\n fn test_listen() {\n-    listen {|parent|\n-        task::spawn {||\n+    do listen {|parent|\n+        do task::spawn {||\n             parent.send(\"oatmeal-salad\");\n         }\n         assert parent.recv() == \"oatmeal-salad\";\n@@ -473,18 +473,18 @@ fn test_listen() {\n #[test]\n #[ignore(cfg(windows))]\n fn test_port_detach_fail() {\n-    iter::repeat(100u) {||\n+    do iter::repeat(100u) {||\n         let builder = task::builder();\n         task::unsupervise(builder);\n-        task::run(builder) {||\n+        do task::run(builder) {||\n             let po = port();\n             let ch = po.chan();\n \n-            task::spawn {||\n+            do task::spawn {||\n                 fail;\n             }\n \n-            task::spawn {||\n+            do task::spawn {||\n                 ch.send(());\n             }\n         }"}, {"sha": "5f1bc5c6ce9a68eaa796a25a71567d2ecc6552e5", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -114,12 +114,12 @@ impl extensions<A> for dvec<A> {\n     \"]\n     #[inline(always)]\n     fn swap(f: fn(-~[mut A]) -> ~[mut A]) {\n-        self.borrow { |v| self.return(f(v)) }\n+        self.borrow({ |v| self.return(f(v)) })\n     }\n \n     #[doc = \"Returns the number of elements currently in the dvec\"]\n     fn len() -> uint {\n-        self.borrow { |v|\n+        do self.borrow { |v|\n             let l = v.len();\n             self.return(v);\n             l\n@@ -134,7 +134,7 @@ impl extensions<A> for dvec<A> {\n \n     #[doc = \"Remove and return the last element\"]\n     fn pop() -> A {\n-        self.borrow { |v|\n+        do self.borrow { |v|\n             let mut v <- v;\n             let result = vec::pop(v);\n             self.return(v);\n@@ -164,7 +164,7 @@ impl extensions<A> for dvec<A> {\n \n     #[doc = \"Remove and return the first element\"]\n     fn shift() -> A {\n-        self.borrow { |v|\n+        do self.borrow { |v|\n             let mut v = vec::from_mut(v);\n             let result = vec::shift(v);\n             self.return(vec::to_mut(v));\n@@ -187,7 +187,7 @@ impl extensions<A:copy> for dvec<A> {\n         Appends elements from `from_idx` to `to_idx` (exclusive)\n     \"]\n     fn push_slice(ts: &[const A], from_idx: uint, to_idx: uint) {\n-        self.swap { |v|\n+        do self.swap { |v|\n             let mut v <- v;\n             let new_len = vec::len(v) + to_idx - from_idx;\n             vec::reserve(v, new_len);\n@@ -207,7 +207,7 @@ impl extensions<A:copy> for dvec<A> {\n         attempts to access this vector.\n     \"]\n     fn append_iter<A, I:iter::base_iter<A>>(ts: I) {\n-       self.swap { |v|\n+       do self.swap { |v|\n            let mut v = alt ts.size_hint() {\n              none { v }\n              some(h) {\n@@ -229,7 +229,7 @@ impl extensions<A:copy> for dvec<A> {\n         See `unwrap()` if you do not wish to copy the contents.\n     \"]\n     fn get() -> ~[A] {\n-        self.borrow { |v|\n+        do self.borrow { |v|\n             let w = vec::from_mut(copy v);\n             self.return(v);\n             w\n@@ -259,7 +259,7 @@ impl extensions<A:copy> for dvec<A> {\n     growing the vector if necessary.  New elements will be initialized\n     with `initval`\"]\n     fn grow_set_elt(idx: uint, initval: A, val: A) {\n-        self.swap { |v|\n+        do self.swap { |v|\n             let mut v <- v;\n             vec::grow_set(v, idx, initval, val);\n             v"}, {"sha": "6c707d56dd788475c50f8c48738be78ee12ee575", "filename": "src/libcore/future.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -64,7 +64,7 @@ fn from_port<A:send>(-port: comm::port<A>) -> future<A> {\n     waiting for the result to be received on the port.\n     \"];\n \n-    from_fn {||\n+    do from_fn {||\n         comm::recv(port)\n     }\n }\n@@ -93,7 +93,7 @@ fn spawn<A:send>(+blk: fn~() -> A) -> future<A> {\n \n     let mut po = comm::port();\n     let ch = comm::chan(po);\n-    task::spawn {||\n+    do task::spawn {||\n         comm::send(ch, blk())\n     };\n     from_port(po)\n@@ -102,7 +102,7 @@ fn spawn<A:send>(+blk: fn~() -> A) -> future<A> {\n fn get<A:copy>(future: future<A>) -> A {\n     #[doc = \"Get the value of the future\"];\n \n-    with(future) {|v| v }\n+    do with(future) {|v| v }\n }\n \n fn with<A,B>(future: future<A>, blk: fn(A) -> B) -> B {\n@@ -150,25 +150,25 @@ fn test_iface_get() {\n #[test]\n fn test_with() {\n     let f = from_value(\"nail\");\n-    assert with(f) {|v| v} == \"nail\";\n+    assert with(f, {|v| v}) == \"nail\";\n }\n \n #[test]\n fn test_iface_with() {\n     let f = from_value(\"kale\");\n-    assert f.with {|v| v} == \"kale\";\n+    assert f.with({|v| v}) == \"kale\";\n }\n \n #[test]\n fn test_spawn() {\n-    let f = spawn {|| \"bale\" };\n+    let f = spawn({|| \"bale\" });\n     assert get(f) == \"bale\";\n }\n \n #[test]\n #[should_fail]\n #[ignore(cfg(target_os = \"win32\"))]\n fn test_futurefail() {\n-    let f = spawn {|| fail };\n+    let f = spawn({|| fail });\n     let _x: str = get(f);\n }"}, {"sha": "91f44e7067bc92c6d39eb09b964efafcccf49f84", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -93,8 +93,8 @@ fn from_str(s: str) -> option<T> { parse_buf(str::bytes(s), 10u) }\n \n #[doc = \"Convert to a string in a given base\"]\n fn to_str(n: T, radix: uint) -> str {\n-    to_str_bytes(n, radix) {|slice|\n-        vec::unpack_slice(slice) {|p, len|\n+    do to_str_bytes(n, radix) {|slice|\n+        do vec::unpack_slice(slice) {|p, len|\n             unsafe { str::unsafe::from_buf_len(p, len) }\n         }\n     }"}, {"sha": "316c4d45761636ecc9081a917b0dcbedf64be3a6", "filename": "src/libcore/io.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -195,7 +195,7 @@ impl of reader for *libc::FILE {\n     fn read_bytes(len: uint) -> ~[u8] {\n         let mut buf : ~[mut u8] = ~[mut];\n         vec::reserve(buf, len);\n-        vec::as_mut_buf(buf) {|b|\n+        do vec::as_mut_buf(buf) {|b|\n             let read = libc::fread(b as *mut c_void, 1u as size_t,\n                                    len as size_t, self);\n             unsafe { vec::unsafe::set_len(buf, read as uint) };\n@@ -308,7 +308,7 @@ fn str_reader(s: str) -> reader {\n }\n \n fn with_str_reader<T>(s: str, f: fn(reader) -> T) -> T {\n-    str::as_bytes(s) { |bytes|\n+    do str::as_bytes(s) { |bytes|\n         with_bytes_reader_between(bytes, 0u, str::len(s), f)\n     }\n }\n@@ -334,7 +334,7 @@ impl <T: writer, C> of writer for {base: T, cleanup: C} {\n \n impl of writer for *libc::FILE {\n     fn write(v: &[const u8]) {\n-        vec::unpack_const_slice(v) {|vbuf, len|\n+        do vec::unpack_const_slice(v) {|vbuf, len|\n             let nout = libc::fwrite(vbuf as *c_void, len as size_t,\n                                     1u as size_t, self);\n             if nout < 1 as size_t {\n@@ -363,7 +363,7 @@ fn FILE_writer(f: *libc::FILE, cleanup: bool) -> writer {\n impl of writer for fd_t {\n     fn write(v: &[const u8]) {\n         let mut count = 0u;\n-        vec::unpack_const_slice(v) {|vbuf, len|\n+        do vec::unpack_const_slice(v) {|vbuf, len|\n             while count < len {\n                 let vb = ptr::const_offset(vbuf, count) as *c_void;\n                 let nout = libc::write(self, vb, len as size_t);\n@@ -420,7 +420,7 @@ fn mk_file_writer(path: str, flags: ~[fileflag])\n           no_flag { }\n         }\n     }\n-    let fd = os::as_c_charp(path) {|pathbuf|\n+    let fd = do os::as_c_charp(path) {|pathbuf|\n         libc::open(pathbuf, fflags,\n                    (S_IRUSR | S_IWUSR) as c_int)\n     };\n@@ -514,64 +514,64 @@ impl writer_util for writer {\n             self.write_str(str::from_char(ch));\n         }\n     }\n-    fn write_str(s: str/&) { str::byte_slice(s) {|v| self.write(v); } }\n+    fn write_str(s: str/&) { str::byte_slice(s, {|v| self.write(v); }) }\n     fn write_line(s: str/&) {\n         self.write_str(s);\n         self.write_str(\"\\n\"/&);\n     }\n     fn write_int(n: int) {\n-        int::to_str_bytes(n, 10u) {|buf| self.write(buf) }\n+        int::to_str_bytes(n, 10u, {|buf| self.write(buf) })\n     }\n     fn write_uint(n: uint) {\n-        uint::to_str_bytes(false, n, 10u) {|buf| self.write(buf) }\n+        uint::to_str_bytes(false, n, 10u, {|buf| self.write(buf) })\n     }\n     fn write_le_uint(n: uint, size: uint) {\n-        u64_to_le_bytes(n as u64, size) {|v| self.write(v); }\n+        u64_to_le_bytes(n as u64, size, {|v| self.write(v) })\n     }\n     fn write_le_int(n: int, size: uint) {\n-        u64_to_le_bytes(n as u64, size) {|v| self.write(v); }\n+        u64_to_le_bytes(n as u64, size, {|v| self.write(v) })\n     }\n     fn write_be_uint(n: uint, size: uint) {\n-        u64_to_be_bytes(n as u64, size) {|v| self.write(v); }\n+        u64_to_be_bytes(n as u64, size, {|v| self.write(v) })\n     }\n     fn write_be_int(n: int, size: uint) {\n-        u64_to_be_bytes(n as u64, size) {|v| self.write(v); }\n+        u64_to_be_bytes(n as u64, size, {|v| self.write(v) })\n     }\n     fn write_be_u64(n: u64) {\n-        u64_to_be_bytes(n, 8u) {|v| self.write(v); }\n+        u64_to_be_bytes(n, 8u, {|v| self.write(v) })\n     }\n     fn write_be_u32(n: u32) {\n-        u64_to_be_bytes(n as u64, 4u) {|v| self.write(v); }\n+        u64_to_be_bytes(n as u64, 4u, {|v| self.write(v) })\n     }\n     fn write_be_u16(n: u16) {\n-        u64_to_be_bytes(n as u64, 2u) {|v| self.write(v); }\n+        u64_to_be_bytes(n as u64, 2u, {|v| self.write(v) })\n     }\n     fn write_be_i64(n: i64) {\n-        u64_to_be_bytes(n as u64, 8u) {|v| self.write(v); }\n+        u64_to_be_bytes(n as u64, 8u, {|v| self.write(v) })\n     }\n     fn write_be_i32(n: i32) {\n-        u64_to_be_bytes(n as u64, 4u) {|v| self.write(v); }\n+        u64_to_be_bytes(n as u64, 4u, {|v| self.write(v) })\n     }\n     fn write_be_i16(n: i16) {\n-        u64_to_be_bytes(n as u64, 2u) {|v| self.write(v); }\n+        u64_to_be_bytes(n as u64, 2u, {|v| self.write(v) })\n     }\n     fn write_le_u64(n: u64) {\n-        u64_to_le_bytes(n, 8u) {|v| self.write(v); }\n+        u64_to_le_bytes(n, 8u, {|v| self.write(v) })\n     }\n     fn write_le_u32(n: u32) {\n-        u64_to_le_bytes(n as u64, 4u) {|v| self.write(v); }\n+        u64_to_le_bytes(n as u64, 4u, {|v| self.write(v) })\n     }\n     fn write_le_u16(n: u16) {\n-        u64_to_le_bytes(n as u64, 2u) {|v| self.write(v); }\n+        u64_to_le_bytes(n as u64, 2u, {|v| self.write(v) })\n     }\n     fn write_le_i64(n: i64) {\n-        u64_to_le_bytes(n as u64, 8u) {|v| self.write(v); }\n+        u64_to_le_bytes(n as u64, 8u, {|v| self.write(v) })\n     }\n     fn write_le_i32(n: i32) {\n-        u64_to_le_bytes(n as u64, 4u) {|v| self.write(v); }\n+        u64_to_le_bytes(n as u64, 4u, {|v| self.write(v) })\n     }\n     fn write_le_i16(n: i16) {\n-        u64_to_le_bytes(n as u64, 2u) {|v| self.write(v); }\n+        u64_to_le_bytes(n as u64, 2u, {|v| self.write(v) })\n     }\n \n     fn write_u8(n: u8) { self.write(&[n]) }\n@@ -584,8 +584,8 @@ fn file_writer(path: str, flags: ~[fileflag]) -> result<writer, str> {\n \n // FIXME: fileflags // #2004\n fn buffered_file_writer(path: str) -> result<writer, str> {\n-    let f = os::as_c_charp(path) {|pathbuf|\n-        os::as_c_charp(\"w\") {|modebuf|\n+    let f = do os::as_c_charp(path) {|pathbuf|\n+        do os::as_c_charp(\"w\") {|modebuf|\n             libc::fopen(pathbuf, modebuf)\n         }\n     };"}, {"sha": "5f7058ec975e81911e45d5a22279461b94599cd5", "filename": "src/libcore/iter-trait/dvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdvec.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -7,7 +7,7 @@ Attempts to access this dvec during iteration will fail.\n \"]\n fn EACH<A>(self: IMPL_T<A>, f: fn(A) -> bool) {\n     import dvec::extensions;\n-    self.swap { |v| vec::each(v, f); v }\n+    self.swap({ |v| vec::each(v, f); v })\n }\n \n fn SIZE_HINT<A>(self: IMPL_T<A>) -> option<uint> {"}, {"sha": "7466bc11bc32c732db939a0ddd52be452e7aa287", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -28,7 +28,7 @@ fn any<A,IA:base_iter<A>>(self: IA, blk: fn(A) -> bool) -> bool {\n fn filter_to_vec<A:copy,IA:base_iter<A>>(self: IA,\n                                          prd: fn(A) -> bool) -> ~[A] {\n     let mut result = ~[];\n-    self.size_hint().iter {|hint| vec::reserve(result, hint); }\n+    self.size_hint().iter({|hint| vec::reserve(result, hint); });\n     for self.each {|a|\n         if prd(a) { vec::push(result, a); }\n     }\n@@ -37,7 +37,7 @@ fn filter_to_vec<A:copy,IA:base_iter<A>>(self: IA,\n \n fn map_to_vec<A:copy,B,IA:base_iter<A>>(self: IA, op: fn(A) -> B) -> ~[B] {\n     let mut result = ~[];\n-    self.size_hint().iter {|hint| vec::reserve(result, hint); }\n+    self.size_hint().iter({|hint| vec::reserve(result, hint); });\n     for self.each {|a|\n         vec::push(result, op(a));\n     }\n@@ -76,7 +76,7 @@ fn contains<A,IA:base_iter<A>>(self: IA, x: A) -> bool {\n }\n \n fn count<A,IA:base_iter<A>>(self: IA, x: A) -> uint {\n-    foldl(self, 0u) {|count, value|\n+    do foldl(self, 0u) {|count, value|\n         if value == x {\n             count + 1u\n         } else {\n@@ -108,7 +108,7 @@ fn repeat(times: uint, blk: fn()) {\n }\n \n fn min<A:copy,IA:base_iter<A>>(self: IA) -> A {\n-    alt foldl::<A,option<A>,IA>(self, none) {|a, b|\n+    alt do foldl::<A,option<A>,IA>(self, none) {|a, b|\n         alt a {\n           some(a_) if a_ < b {\n             // FIXME (#2005): Not sure if this is successfully optimized to\n@@ -124,7 +124,7 @@ fn min<A:copy,IA:base_iter<A>>(self: IA) -> A {\n }\n \n fn max<A:copy,IA:base_iter<A>>(self: IA) -> A {\n-    alt foldl::<A,option<A>,IA>(self, none) {|a, b|\n+    alt do foldl::<A,option<A>,IA>(self, none) {|a, b|\n         alt a {\n           some(a_) if a_ > b {\n             // FIXME (#2005): Not sure if this is successfully optimized to"}, {"sha": "2c45034feb22b21383bde94d57ff840bbac3b1ad", "filename": "src/libcore/newcomm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fnewcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fnewcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnewcomm.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -31,7 +31,7 @@ fn chan<T: send>(p: port<T>) -> chan<T> {\n \n fn send<T: send>(c: chan<T>, -x: T) {\n     let mut x <- some(x);\n-    (*c).with {|cond, data|\n+    do (*c).with {|cond, data|\n         let mut xx = none;\n         xx <-> x;\n         (*data).push(option::unwrap(xx));\n@@ -40,7 +40,7 @@ fn send<T: send>(c: chan<T>, -x: T) {\n }\n \n fn recv<T: send>(p: port<T>) -> T {\n-    (*p).with {|cond, data|\n+    do (*p).with {|cond, data|\n         if (*data).len() == 0u {\n             cond.wait();\n         }"}, {"sha": "39437656c936f59d1380a4079527f3f43ed82335", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -133,10 +133,10 @@ fn test_unwrap_ptr() {\n #[test]\n fn test_unwrap_str() {\n     let x = \"test\";\n-    let addr_x = str::as_buf(x) {|buf| ptr::addr_of(buf) };\n+    let addr_x = str::as_buf(x, {|buf| ptr::addr_of(buf) });\n     let opt = some(x);\n     let y = unwrap(opt);\n-    let addr_y = str::as_buf(y) {|buf| ptr::addr_of(buf) };\n+    let addr_y = str::as_buf(y, {|buf| ptr::addr_of(buf) });\n     assert addr_x == addr_y;\n }\n "}, {"sha": "bd5354a8625a1343d306e2866a8458d62a37f35a", "filename": "src/libcore/os.rs", "status": "modified", "additions": 41, "deletions": 42, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -64,13 +64,13 @@ fn env() -> ~[(str,str)] {\n const tmpbuf_sz : uint = 1000u;\n \n fn as_c_charp<T>(s: str, f: fn(*c_char) -> T) -> T {\n-    str::as_c_str(s) {|b| f(b as *c_char) }\n+    str::as_c_str(s, {|b| f(b as *c_char) })\n }\n \n fn fill_charp_buf(f: fn(*mut c_char, size_t) -> bool)\n     -> option<str> {\n     let buf = vec::to_mut(vec::from_elem(tmpbuf_sz, 0u8 as c_char));\n-    vec::as_mut_buf(buf) { |b|\n+    do vec::as_mut_buf(buf) { |b|\n         if f(b, tmpbuf_sz as size_t) unsafe {\n             some(str::unsafe::from_buf(b as *u8))\n         } else {\n@@ -95,7 +95,7 @@ mod win32 {\n         let mut done = false;\n         while !done {\n             let buf = vec::to_mut(vec::from_elem(n as uint, 0u16));\n-            vec::as_mut_buf(buf) {|b|\n+            do vec::as_mut_buf(buf) {|b|\n                 let k : dword = f(b, tmpbuf_sz as dword);\n                 if k == (0 as dword) {\n                     done = true;\n@@ -182,7 +182,7 @@ mod global_env {\n \n     fn global_env_task(msg_po: comm::port<msg>) {\n         unsafe {\n-            priv::weaken_task {|weak_po|\n+            do priv::weaken_task {|weak_po|\n                 loop {\n                     alt comm::select2(msg_po, weak_po) {\n                       either::left(msg_getenv(n, resp_ch)) {\n@@ -220,8 +220,8 @@ mod global_env {\n             import libc::types::os::arch::extra::*;\n             import libc::funcs::extra::kernel32::*;\n             import win32::*;\n-            as_utf16_p(n) {|u|\n-                fill_utf16_buf_and_decode() {|buf, sz|\n+            do as_utf16_p(n) {|u|\n+                do fill_utf16_buf_and_decode() {|buf, sz|\n                     GetEnvironmentVariableW(u, buf, sz)\n                 }\n             }\n@@ -233,8 +233,8 @@ mod global_env {\n \n             // FIXME: remove this when export globs work properly. #1238\n             import libc::funcs::posix01::unistd::setenv;\n-            str::as_c_str(n) {|nbuf|\n-                str::as_c_str(v) {|vbuf|\n+            do str::as_c_str(n) {|nbuf|\n+                do str::as_c_str(v) {|vbuf|\n                     setenv(nbuf, vbuf, 1i32);\n                 }\n             }\n@@ -246,8 +246,8 @@ mod global_env {\n             // FIXME: remove imports when export globs work properly. #1238\n             import libc::funcs::extra::kernel32::*;\n             import win32::*;\n-            as_utf16_p(n) {|nbuf|\n-                as_utf16_p(v) {|vbuf|\n+            do as_utf16_p(n) {|nbuf|\n+                do as_utf16_p(v) {|vbuf|\n                     SetEnvironmentVariableW(nbuf, vbuf);\n                 }\n             }\n@@ -257,7 +257,7 @@ mod global_env {\n }\n \n fn fdopen(fd: c_int) -> *FILE {\n-    ret as_c_charp(\"r\") {|modebuf|\n+    ret do as_c_charp(\"r\") {|modebuf|\n         libc::fdopen(fd, modebuf)\n     };\n }\n@@ -370,7 +370,7 @@ fn self_exe_path() -> option<path> {\n         unsafe {\n             import libc::funcs::bsd44::*;\n             import libc::consts::os::extra::*;\n-            fill_charp_buf() {|buf, sz|\n+            do fill_charp_buf() {|buf, sz|\n                 let mib = ~[CTL_KERN as c_int,\n                            KERN_PROC as c_int,\n                            KERN_PROC_PATHNAME as c_int, -1 as c_int];\n@@ -384,8 +384,8 @@ fn self_exe_path() -> option<path> {\n     #[cfg(target_os = \"linux\")]\n     fn load_self() -> option<path> {\n         import libc::funcs::posix01::unistd::readlink;\n-        fill_charp_buf() {|buf, sz|\n-            as_c_charp(\"/proc/self/exe\") { |proc_self_buf|\n+        do fill_charp_buf() {|buf, sz|\n+            do as_c_charp(\"/proc/self/exe\") { |proc_self_buf|\n                 readlink(proc_self_buf, buf, sz) != (-1 as ssize_t)\n             }\n         }\n@@ -395,8 +395,7 @@ fn self_exe_path() -> option<path> {\n     fn load_self() -> option<path> {\n         // FIXME: remove imports when export globs work properly. #1238\n         import libc::funcs::extra::*;\n-\n-        fill_charp_buf() {|buf, sz|\n+        do fill_charp_buf() {|buf, sz|\n             _NSGetExecutablePath(buf, ptr::mut_addr_of(sz as u32))\n                 == (0 as c_int)\n         }\n@@ -408,12 +407,12 @@ fn self_exe_path() -> option<path> {\n         import libc::types::os::arch::extra::*;\n         import libc::funcs::extra::kernel32::*;\n         import win32::*;\n-        fill_utf16_buf_and_decode() {|buf, sz|\n+        do fill_utf16_buf_and_decode() {|buf, sz|\n             GetModuleFileNameW(0u as dword, buf, sz)\n         }\n     }\n \n-    option::map(load_self()) {|pth|\n+    do option::map(load_self()) {|pth|\n         path::dirname(pth) + path::path_sep()\n     }\n }\n@@ -453,7 +452,7 @@ fn homedir() -> option<path> {\n \n     #[cfg(windows)]\n     fn secondary() -> option<path> {\n-        option::chain(getenv(\"USERPROFILE\")) {|p|\n+        do option::chain(getenv(\"USERPROFILE\")) {|p|\n             if !str::is_empty(p) {\n                 some(p)\n             } else {\n@@ -470,7 +469,7 @@ fn walk_dir(p: path, f: fn(path) -> bool) {\n \n     fn walk_dir_(p: path, f: fn(path) -> bool) -> bool {\n         let mut keepgoing = true;\n-        list_dir(p).each {|q|\n+        do list_dir(p).each {|q|\n             let path = path::connect(p, q);\n             if !f(path) {\n                 keepgoing = false;\n@@ -494,14 +493,14 @@ fn walk_dir(p: path, f: fn(path) -> bool) {\n \n #[doc = \"Indicates whether a path represents a directory\"]\n fn path_is_dir(p: path) -> bool {\n-    str::as_c_str(p) {|buf|\n+    do str::as_c_str(p) {|buf|\n         rustrt::rust_path_is_dir(buf) != 0 as c_int\n     }\n }\n \n #[doc = \"Indicates whether a path exists\"]\n fn path_exists(p: path) -> bool {\n-    str::as_c_str(p) {|buf|\n+    do str::as_c_str(p) {|buf|\n         rustrt::rust_path_exists(buf) != 0 as c_int\n     }\n }\n@@ -538,15 +537,15 @@ fn make_dir(p: path, mode: c_int) -> bool {\n         import libc::funcs::extra::kernel32::*;\n         import win32::*;\n         // FIXME: turn mode into something useful? #2623\n-        as_utf16_p(p) {|buf|\n+        do as_utf16_p(p) {|buf|\n             CreateDirectoryW(buf, unsafe { unsafe::reinterpret_cast(0) })\n                 != (0 as BOOL)\n         }\n     }\n \n     #[cfg(unix)]\n     fn mkdir(p: path, mode: c_int) -> bool {\n-        as_c_charp(p) {|c|\n+        do as_c_charp(p) {|c|\n             libc::mkdir(c, mode as mode_t) == (0 as c_int)\n         }\n     }\n@@ -569,7 +568,7 @@ fn list_dir(p: path) -> ~[str] {\n         }\n     }\n \n-    rustrt::rust_list_files(star(p)).filter {|filename|\n+    do rustrt::rust_list_files(star(p)).filter {|filename|\n         !str::eq(filename, \".\") && !str::eq(filename, \"..\")\n     }\n }\n@@ -586,7 +585,7 @@ fn list_dir_path(p: path) -> ~[str] {\n                     && p[pl - 1u] as char != path::consts::alt_path_sep) {\n         p += path::path_sep();\n     }\n-    os::list_dir(p).map {|f| p + f}\n+    os::list_dir(p).map({|f| p + f})\n }\n \n #[doc = \"Removes a directory at the specified path\"]\n@@ -599,14 +598,14 @@ fn remove_dir(p: path) -> bool {\n         import libc::funcs::extra::kernel32::*;\n         import libc::types::os::arch::extra::*;\n         import win32::*;\n-        ret as_utf16_p(p) {|buf|\n+        ret do as_utf16_p(p) {|buf|\n             RemoveDirectoryW(buf) != (0 as BOOL)\n         };\n     }\n \n     #[cfg(unix)]\n     fn rmdir(p: path) -> bool {\n-        ret as_c_charp(p) {|buf|\n+        ret do as_c_charp(p) {|buf|\n             libc::rmdir(buf) == (0 as c_int)\n         };\n     }\n@@ -621,14 +620,14 @@ fn change_dir(p: path) -> bool {\n         import libc::funcs::extra::kernel32::*;\n         import libc::types::os::arch::extra::*;\n         import win32::*;\n-        ret as_utf16_p(p) {|buf|\n+        ret do as_utf16_p(p) {|buf|\n             SetCurrentDirectoryW(buf) != (0 as BOOL)\n         };\n     }\n \n     #[cfg(unix)]\n     fn chdir(p: path) -> bool {\n-        ret as_c_charp(p) {|buf|\n+        ret do as_c_charp(p) {|buf|\n             libc::chdir(buf) == (0 as c_int)\n         };\n     }\n@@ -644,25 +643,25 @@ fn copy_file(from: path, to: path) -> bool {\n         import libc::funcs::extra::kernel32::*;\n         import libc::types::os::arch::extra::*;\n         import win32::*;\n-        ret as_utf16_p(from) {|fromp|\n-            as_utf16_p(to) {|top|\n+        ret do as_utf16_p(from) {|fromp|\n+            do as_utf16_p(to) {|top|\n                 CopyFileW(fromp, top, (0 as BOOL)) != (0 as BOOL)\n             }\n         }\n     }\n \n     #[cfg(unix)]\n     fn do_copy_file(from: path, to: path) -> bool {\n-        let istream = as_c_charp(from) {|fromp|\n-            as_c_charp(\"rb\") {|modebuf|\n+        let istream = do as_c_charp(from) {|fromp|\n+            do as_c_charp(\"rb\") {|modebuf|\n                 libc::fopen(fromp, modebuf)\n             }\n         };\n         if istream as uint == 0u {\n             ret false;\n         }\n-        let ostream = as_c_charp(to) {|top|\n-            as_c_charp(\"w+b\") {|modebuf|\n+        let ostream = do as_c_charp(to) {|top|\n+            do as_c_charp(\"w+b\") {|modebuf|\n                 libc::fopen(top, modebuf)\n             }\n         };\n@@ -676,7 +675,7 @@ fn copy_file(from: path, to: path) -> bool {\n         let mut done = false;\n         let mut ok = true;\n         while !done {\n-          vec::as_mut_buf(buf) {|b|\n+          do vec::as_mut_buf(buf) {|b|\n               let nread = libc::fread(b as *mut c_void, 1u as size_t,\n                                       bufsize as size_t,\n                                       istream);\n@@ -708,14 +707,14 @@ fn remove_file(p: path) -> bool {\n         import libc::funcs::extra::kernel32::*;\n         import libc::types::os::arch::extra::*;\n         import win32::*;\n-        ret as_utf16_p(p) {|buf|\n+        ret do as_utf16_p(p) {|buf|\n             DeleteFileW(buf) != (0 as BOOL)\n         };\n     }\n \n     #[cfg(unix)]\n     fn unlink(p: path) -> bool {\n-        ret as_c_charp(p) {|buf|\n+        ret do as_c_charp(p) {|buf|\n             libc::unlink(buf) == (0 as c_int)\n         };\n     }\n@@ -971,15 +970,15 @@ mod tests {\n       let out = tempdir + path::path_sep() + \"out.txt\";\n \n       /* Write the temp input file */\n-      let ostream = as_c_charp(in) {|fromp|\n-            as_c_charp(\"w+b\") {|modebuf|\n+      let ostream = do as_c_charp(in) {|fromp|\n+            do as_c_charp(\"w+b\") {|modebuf|\n                 libc::fopen(fromp, modebuf)\n             }\n       };\n       assert (ostream as uint != 0u);\n       let s = \"hello\";\n       let mut buf = vec::to_mut(str::bytes(s) + ~[0 as u8]);\n-      vec::as_mut_buf(buf) {|b|\n+      do vec::as_mut_buf(buf) {|b|\n           assert (libc::fwrite(b as *c_void, 1u as size_t,\n                                (str::len(s) + 1u) as size_t, ostream)\n                   == buf.len() as size_t)};"}, {"sha": "f8ce85e360f053c6dddd2bcfb7b6feb69eea1676", "filename": "src/libcore/priv.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fpriv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fpriv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpriv.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -41,7 +41,7 @@ unsafe fn chan_from_global_ptr<T: send>(\n \n         let setup_po = comm::port();\n         let setup_ch = comm::chan(setup_po);\n-        let setup_ch = task::run_listener(builder()) {|setup_po|\n+        let setup_ch = do task::run_listener(builder()) {|setup_po|\n             let po = comm::port::<T>();\n             let ch = comm::chan(po);\n             comm::send(setup_ch, ch);\n@@ -92,7 +92,7 @@ fn test_from_global_chan1() {\n \n     // Create the global channel, attached to a new task\n     let ch = unsafe {\n-        chan_from_global_ptr(globchanp, task::builder) {|po|\n+        do chan_from_global_ptr(globchanp, task::builder) {|po|\n             let ch = comm::recv(po);\n             comm::send(ch, true);\n             let ch = comm::recv(po);\n@@ -106,7 +106,7 @@ fn test_from_global_chan1() {\n \n     // This one just reuses the previous channel\n     let ch = unsafe {\n-        chan_from_global_ptr(globchanp, task::builder) {|po|\n+        do chan_from_global_ptr(globchanp, task::builder) {|po|\n             let ch = comm::recv(po);\n             comm::send(ch, false);\n         }\n@@ -121,7 +121,7 @@ fn test_from_global_chan1() {\n #[test]\n fn test_from_global_chan2() {\n \n-    iter::repeat(100u) {||\n+    do iter::repeat(100u) {||\n         // The global channel\n         let globchan = 0u;\n         let globchanp = ptr::addr_of(globchan);\n@@ -132,9 +132,9 @@ fn test_from_global_chan2() {\n         // Spawn a bunch of tasks that all want to compete to\n         // create the global channel\n         for uint::range(0u, 10u) {|i|\n-            task::spawn() {||\n+            do task::spawn {||\n                 let ch = unsafe {\n-                    chan_from_global_ptr(\n+                    do chan_from_global_ptr(\n                         globchanp, task::builder) {|po|\n \n                         for uint::range(0u, 10u) {|_j|\n@@ -200,9 +200,9 @@ unsafe fn weaken_task(f: fn(comm::port<()>)) {\n \n #[test]\n fn test_weaken_task_then_unweaken() {\n-    task::try {||\n+    do task::try {||\n         unsafe {\n-            weaken_task {|_po|\n+            do weaken_task {|_po|\n             }\n         }\n     };\n@@ -212,9 +212,9 @@ fn test_weaken_task_then_unweaken() {\n fn test_weaken_task_wait() {\n     let builder = task::builder();\n     task::unsupervise(builder);\n-    task::run(builder) {||\n+    do task::run(builder) {||\n         unsafe {\n-            weaken_task {|po|\n+            do weaken_task {|po|\n                 comm::recv(po);\n             }\n         }\n@@ -224,18 +224,18 @@ fn test_weaken_task_wait() {\n #[test]\n fn test_weaken_task_stress() {\n     // Create a bunch of weak tasks\n-    iter::repeat(100u) {||\n-        task::spawn {||\n+    do iter::repeat(100u) {||\n+        do task::spawn {||\n             unsafe {\n-                weaken_task {|_po|\n+                do weaken_task {|_po|\n                 }\n             }\n         }\n         let builder = task::builder();\n         task::unsupervise(builder);\n-        task::run(builder) {||\n+        do task::run(builder) {||\n             unsafe {\n-                weaken_task {|po|\n+                do weaken_task {|po|\n                     // Wait for it to tell us to die\n                     comm::recv(po);\n                 }\n@@ -247,9 +247,9 @@ fn test_weaken_task_stress() {\n #[test]\n #[ignore(cfg(windows))]\n fn test_weaken_task_fail() {\n-    let res = task::try {||\n+    let res = do task::try {||\n         unsafe {\n-            weaken_task {|_po|\n+            do weaken_task {|_po|\n                 fail;\n             }\n         }"}, {"sha": "add3c87ce3484ded721fba651acb1b18a9131aee", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -70,7 +70,7 @@ fn mut_offset<T>(ptr: *mut T, count: uint) -> *mut T {\n #[doc = \"Return the offset of the first null pointer in `buf`.\"]\n #[inline(always)]\n unsafe fn buf_len<T>(buf: **T) -> uint {\n-    position(buf) {|i| i == null() }\n+    do position(buf) {|i| i == null() }\n }\n \n #[doc = \"Return the first offset `i` such that `f(buf[i]) == true`.\"]\n@@ -171,9 +171,9 @@ fn test_position() {\n \n     let s = \"hello\";\n     unsafe {\n-        assert 2u == as_c_str(s) {|p| position(p) {|c| c == 'l' as c_char} };\n-        assert 4u == as_c_str(s) {|p| position(p) {|c| c == 'o' as c_char} };\n-        assert 5u == as_c_str(s) {|p| position(p) {|c| c == 0 as c_char } };\n+        assert 2u == as_c_str(s, {|p| position(p, {|c| c == 'l' as c_char})});\n+        assert 4u == as_c_str(s, {|p| position(p, {|c| c == 'o' as c_char})});\n+        assert 5u == as_c_str(s, {|p| position(p, {|c| c == 0 as c_char })});\n     }\n }\n \n@@ -182,11 +182,11 @@ fn test_buf_len() {\n     let s0 = \"hello\";\n     let s1 = \"there\";\n     let s2 = \"thing\";\n-    str::as_c_str(s0) {|p0|\n-        str::as_c_str(s1) {|p1|\n-            str::as_c_str(s2) {|p2|\n+    do str::as_c_str(s0) {|p0|\n+        do str::as_c_str(s1) {|p1|\n+            do str::as_c_str(s2) {|p2|\n                 let v = ~[p0, p1, p2, null()];\n-                vec::as_buf(v) {|vp|\n+                do vec::as_buf(v) {|vp|\n                     assert unsafe { buf_len(vp) } == 3u;\n                 }\n             }"}, {"sha": "1eb0983b7e490b1868a93cd6cb9cca03034e3444", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -152,7 +152,7 @@ impl extensions for rng {\n \n     #[doc = \"Return a random byte string of the specified length\"]\n     fn gen_bytes(len: uint) -> ~[u8] {\n-        vec::from_fn(len) {|_i|\n+        do vec::from_fn(len) {|_i|\n             self.gen_u8()\n         }\n     }"}, {"sha": "899ad6040c1d4873e70738e1eec8ff816d0dcf3e", "filename": "src/libcore/result.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -362,33 +362,33 @@ mod tests {\n     #[test]\n     fn test_impl_iter() {\n         let mut valid = false;\n-        ok::<str, str>(\"a\").iter { |_x| valid = true; };\n+        ok::<str, str>(\"a\").iter({ |_x| valid = true; });\n         assert valid;\n \n-        err::<str, str>(\"b\").iter { |_x| valid = false; };\n+        err::<str, str>(\"b\").iter({ |_x| valid = false; });\n         assert valid;\n     }\n \n     #[test]\n     fn test_impl_iter_err() {\n         let mut valid = true;\n-        ok::<str, str>(\"a\").iter_err { |_x| valid = false; };\n+        ok::<str, str>(\"a\").iter_err({ |_x| valid = false; });\n         assert valid;\n \n         valid = false;\n-        err::<str, str>(\"b\").iter_err { |_x| valid = true; };\n+        err::<str, str>(\"b\").iter_err({ |_x| valid = true; });\n         assert valid;\n     }\n \n     #[test]\n     fn test_impl_map() {\n-        assert ok::<str, str>(\"a\").map { |_x| \"b\" } == ok(\"b\");\n-        assert err::<str, str>(\"a\").map { |_x| \"b\" } == err(\"a\");\n+        assert ok::<str, str>(\"a\").map({ |_x| \"b\" }) == ok(\"b\");\n+        assert err::<str, str>(\"a\").map({ |_x| \"b\" }) == err(\"a\");\n     }\n \n     #[test]\n     fn test_impl_map_err() {\n-        assert ok::<str, str>(\"a\").map_err { |_x| \"b\" } == ok(\"a\");\n-        assert err::<str, str>(\"a\").map_err { |_x| \"b\" } == err(\"b\");\n+        assert ok::<str, str>(\"a\").map_err({ |_x| \"b\" }) == ok(\"a\");\n+        assert err::<str, str>(\"a\").map_err({ |_x| \"b\" }) == err(\"b\");\n     }\n }"}, {"sha": "83033bdf9d21f8b7313ec79d1e6dd666010513a8", "filename": "src/libcore/run.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -67,9 +67,9 @@ fn spawn_process(prog: str, args: ~[str],\n                  dir: option<str>,\n                  in_fd: c_int, out_fd: c_int, err_fd: c_int)\n    -> pid_t {\n-    with_argv(prog, args) {|argv|\n-        with_envp(env) { |envp|\n-            with_dirp(dir) { |dirp|\n+    do with_argv(prog, args) {|argv|\n+        do with_envp(env) { |envp|\n+            do with_dirp(dir) { |dirp|\n                 rustrt::rust_run_program(argv, envp, dirp,\n                                          in_fd, out_fd, err_fd)\n             }\n@@ -79,12 +79,12 @@ fn spawn_process(prog: str, args: ~[str],\n \n fn with_argv<T>(prog: str, args: ~[str],\n                 cb: fn(**libc::c_char) -> T) -> T {\n-    let mut argptrs = str::as_c_str(prog) {|b| ~[b] };\n+    let mut argptrs = str::as_c_str(prog, {|b| ~[b] });\n     let mut tmps = ~[];\n     for vec::each(args) {|arg|\n         let t = @arg;\n         vec::push(tmps, t);\n-        vec::push_all(argptrs, str::as_c_str(*t) {|b| ~[b] });\n+        vec::push_all(argptrs, str::as_c_str(*t, {|b| ~[b] }));\n     }\n     vec::push(argptrs, ptr::null());\n     vec::as_buf(argptrs, cb)\n@@ -104,12 +104,12 @@ fn with_envp<T>(env: option<~[(str,str)]>,\n             let (k,v) = e;\n             let t = @(#fmt(\"%s=%s\", k, v));\n             vec::push(tmps, t);\n-            vec::push_all(ptrs, str::as_c_str(*t) {|b| ~[b]});\n+            vec::push_all(ptrs, str::as_c_str(*t, {|b| ~[b]}));\n         }\n         vec::push(ptrs, ptr::null());\n-        vec::as_buf(ptrs) { |p|\n+        vec::as_buf(ptrs, { |p|\n             unsafe { cb(::unsafe::reinterpret_cast(p)) }\n-        }\n+        })\n       }\n       _ {\n         cb(ptr::null())\n@@ -135,7 +135,7 @@ fn with_envp<T>(env: option<~[(str,str)]>,\n                 ::unsafe::forget(v);\n             }\n             blk += ~[0_u8];\n-            vec::as_buf(blk) {|p| cb(::unsafe::reinterpret_cast(p)) }\n+            vec::as_buf(blk, {|p| cb(::unsafe::reinterpret_cast(p)) })\n           }\n           _ {\n             cb(ptr::null())\n@@ -298,11 +298,11 @@ fn program_output(prog: str, args: ~[str]) ->\n     // clever way to do this.\n     let p = comm::port();\n     let ch = comm::chan(p);\n-    task::spawn_sched(task::single_threaded) {||\n+    do task::spawn_sched(task::single_threaded) {||\n         let errput = readclose(pipe_err.in);\n         comm::send(ch, (2, errput));\n     };\n-    task::spawn_sched(task::single_threaded) {||\n+    do task::spawn_sched(task::single_threaded) {||\n         let output = readclose(pipe_out.in);\n         comm::send(ch, (1, output));\n     };"}, {"sha": "d6c78a4c57561d6bc2d602da7c58b7513a66546b", "filename": "src/libcore/stackwalk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fstackwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fstackwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstackwalk.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -18,7 +18,7 @@ fn walk_stack(visit: fn(frame) -> bool) {\n \n     #debug(\"beginning stack walk\");\n \n-    frame_address { |frame_pointer|\n+    do frame_address { |frame_pointer|\n         let mut frame_address: *word = unsafe {\n             reinterpret_cast(frame_pointer)\n         };"}, {"sha": "01b463fce244a551984d7f4d5bf2cea60576b3cb", "filename": "src/libcore/str.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -154,7 +154,7 @@ fn push_char(&s: str, ch: char) {\n         let new_len = len + nb;\n         reserve_at_least(s, new_len);\n         let off = len;\n-        as_buf(s) {|buf|\n+        do as_buf(s) {|buf|\n             let buf: *mut u8 = ::unsafe::reinterpret_cast(buf);\n             if nb == 1u {\n                 *ptr::mut_offset(buf, off) =\n@@ -208,7 +208,7 @@ fn push_char(&s: str, ch: char) {\n             *ptr::mut_offset(buf, off + nb) = 0u8;\n         }\n \n-        as_bytes(s) {|bytes|\n+        do as_bytes(s) {|bytes|\n             let mut mut_bytes: ~[u8] = ::unsafe::reinterpret_cast(bytes);\n             vec::unsafe::set_len(mut_bytes, new_len + 1u);\n             ::unsafe::forget(mut_bytes);\n@@ -336,7 +336,7 @@ Work with the string as a byte slice, not including trailing null.\n \"]\n #[inline(always)]\n pure fn byte_slice<T>(s: str/&, f: fn(v: &[u8]) -> T) -> T {\n-    unpack_slice(s) {|p,n|\n+    do unpack_slice(s) {|p,n|\n         unsafe { vec::unsafe::form_slice(p, n-1u, f) }\n     }\n }\n@@ -495,7 +495,7 @@ pure fn iter_matches(s: str/&a, sep: str/&b, f: fn(uint, uint)) {\n \n pure fn iter_between_matches(s: str/&a, sep: str/&b, f: fn(uint, uint)) {\n     let mut last_end = 0u;\n-    iter_matches(s, sep) {|from, to|\n+    do iter_matches(s, sep) {|from, to|\n         f(last_end, from);\n         last_end = to;\n     }\n@@ -513,15 +513,15 @@ assert [\\\"\\\", \\\"XXX\\\", \\\"YYY\\\", \\\"\\\"] == split_str(\\\".XXX.YYY.\\\", \\\".\\\")\n \"]\n pure fn split_str(s: str/&a, sep: str/&b) -> ~[str] {\n     let mut result = ~[];\n-    iter_between_matches(s, sep) {|from, to|\n+    do iter_between_matches(s, sep) {|from, to|\n         unsafe { vec::push(result, unsafe::slice_bytes(s, from, to)); }\n     }\n     result\n }\n \n pure fn split_str_nonempty(s: str/&a, sep: str/&b) -> ~[str] {\n     let mut result = ~[];\n-    iter_between_matches(s, sep) {|from, to|\n+    do iter_between_matches(s, sep) {|from, to|\n         if to > from {\n             unsafe { vec::push(result, unsafe::slice_bytes(s, from, to)); }\n         }\n@@ -585,7 +585,7 @@ The original string with all occurances of `from` replaced with `to`\n \"]\n pure fn replace(s: str, from: str, to: str) -> str {\n     let mut result = \"\", first = true;\n-    iter_between_matches(s, from) {|start, end|\n+    do iter_between_matches(s, from) {|start, end|\n         if first { first = false; } else { result += to; }\n         unsafe { result += unsafe::slice_bytes(s, start, end); }\n     }\n@@ -651,7 +651,7 @@ pure fn map(ss: str/&, ff: fn(char) -> char) -> str {\n     let mut result = \"\";\n     unchecked {\n         reserve(result, len(ss));\n-        chars_iter(ss) {|cc|\n+        do chars_iter(ss) {|cc|\n             str::push_char(result, ff(cc));\n         }\n     }\n@@ -1215,7 +1215,7 @@ fn is_alphanumeric(s: str/&) -> bool {\n Returns the string length/size in bytes not counting the null terminator\n \"]\n pure fn len(s: str/&) -> uint {\n-    unpack_slice(s) { |_p, n| n - 1u }\n+    do unpack_slice(s) { |_p, n| n - 1u }\n }\n \n #[doc = \"Returns the number of characters that a string holds\"]\n@@ -1267,7 +1267,7 @@ pure fn is_utf16(v: &[const u16]) -> bool {\n #[doc = \"Converts to a vector of `u16` encoded as UTF-16\"]\n pure fn to_utf16(s: str/&) -> ~[u16] {\n     let mut u = ~[];\n-    chars_iter(s) {|cch|\n+    do chars_iter(s) {|cch|\n         // Arithmetic with u32 literals is easier on the eyes than chars.\n         let mut ch = cch as u32;\n \n@@ -1316,7 +1316,7 @@ pure fn from_utf16(v: &[const u16]) -> str {\n     let mut buf = \"\";\n     unchecked {\n         reserve(buf, vec::len(v));\n-        utf16_chars(v) {|ch| push_char(buf, ch); }\n+        do utf16_chars(v) {|ch| push_char(buf, ch); }\n     }\n     ret buf;\n }\n@@ -1583,7 +1583,7 @@ Allows for unsafe manipulation of strings, which is useful for native\n interop.\n \"]\n pure fn as_buf<T>(s: str, f: fn(*u8) -> T) -> T {\n-    as_bytes(s) { |v| unsafe { vec::as_buf(v, f) } }\n+    as_bytes(s, { |v| unsafe { vec::as_buf(v, f) } })\n }\n \n #[doc = \"\n@@ -1599,7 +1599,7 @@ let s = str::as_buf(\\\"PATH\\\", { |path_buf| libc::getenv(path_buf) });\n ~~~\n \"]\n pure fn as_c_str<T>(s: str, f: fn(*libc::c_char) -> T) -> T {\n-    as_buf(s) {|buf| f(buf as *libc::c_char) }\n+    as_buf(s, {|buf| f(buf as *libc::c_char) })\n }\n \n \n@@ -1671,7 +1671,7 @@ Returns the number of single-byte characters the string can hold without\n reallocating\n \"]\n pure fn capacity(&&s: str) -> uint {\n-    as_bytes(s) {|buf|\n+    do as_bytes(s) {|buf|\n         let vcap = vec::capacity(buf);\n         assert vcap > 0u;\n         vcap - 1u\n@@ -1683,7 +1683,7 @@ pure fn escape_default(s: str/&) -> str {\n     let mut out: str = \"\";\n     unchecked {\n         reserve_at_least(out, str::len(s));\n-        chars_iter(s) {|c| out += char::escape_default(c); }\n+        do chars_iter(s) {|c| out += char::escape_default(c); }\n     }\n     ret out;\n }\n@@ -1693,7 +1693,7 @@ pure fn escape_unicode(s: str/&) -> str {\n     let mut out: str = \"\";\n     unchecked {\n         reserve_at_least(out, str::len(s));\n-        chars_iter(s) {|c| out += char::escape_unicode(c); }\n+        do chars_iter(s) {|c| out += char::escape_unicode(c); }\n     }\n     ret out;\n }\n@@ -1726,7 +1726,7 @@ mod unsafe {\n     unsafe fn from_buf_len(buf: *u8, len: uint) -> str {\n         let mut v: ~[u8] = ~[];\n         vec::reserve(v, len + 1u);\n-        vec::as_buf(v) {|b| ptr::memcpy(b, buf, len); }\n+        do vec::as_buf(v) {|b| ptr::memcpy(b, buf, len); }\n         vec::unsafe::set_len(v, len);\n         vec::push(v, 0u8);\n \n@@ -1777,14 +1777,14 @@ mod unsafe {\n    If end is greater than the length of the string.\n    \"]\n    unsafe fn slice_bytes(s: str/&, begin: uint, end: uint) -> str {\n-       unpack_slice(s) { |sbuf, n|\n+       do unpack_slice(s) { |sbuf, n|\n            assert (begin <= end);\n            assert (end <= n);\n \n            let mut v = ~[];\n            vec::reserve(v, end - begin + 1u);\n            unsafe {\n-               vec::as_buf(v) { |vbuf|\n+               do vec::as_buf(v) { |vbuf|\n                    let src = ptr::offset(sbuf, begin);\n                    ptr::memcpy(vbuf, src, end - begin);\n                }\n@@ -2574,7 +2574,7 @@ mod tests {\n     #[should_fail]\n     fn test_as_bytes_fail() {\n         // Don't double free\n-        as_bytes(\"\") {|_bytes| fail }\n+        do as_bytes(\"\") {|_bytes| fail }\n     }\n \n     #[test]\n@@ -2647,7 +2647,7 @@ mod tests {\n     #[test]\n     fn test_chars_iter() {\n         let mut i = 0;\n-        chars_iter(\"x\\u03c0y\") {|ch|\n+        do chars_iter(\"x\\u03c0y\") {|ch|\n             alt check i {\n               0 { assert ch == 'x'; }\n               1 { assert ch == '\\u03c0'; }\n@@ -2656,14 +2656,14 @@ mod tests {\n             i += 1;\n         }\n \n-        chars_iter(\"\") {|_ch| fail; } // should not fail\n+        do chars_iter(\"\") {|_ch| fail; } // should not fail\n     }\n \n     #[test]\n     fn test_bytes_iter() {\n         let mut i = 0;\n \n-        bytes_iter(\"xyz\") {|bb|\n+        do bytes_iter(\"xyz\") {|bb|\n             alt check i {\n               0 { assert bb == 'x' as u8; }\n               1 { assert bb == 'y' as u8; }\n@@ -2672,7 +2672,7 @@ mod tests {\n             i += 1;\n         }\n \n-        bytes_iter(\"\") {|bb| assert bb == 0u8; }\n+        do bytes_iter(\"\") {|bb| assert bb == 0u8; }\n     }\n \n     #[test]\n@@ -2681,7 +2681,7 @@ mod tests {\n \n         let mut ii = 0;\n \n-        split_char_iter(data, ' ') {|xx|\n+        do split_char_iter(data, ' ') {|xx|\n             alt ii {\n               0 { assert \"\\nMary\" == xx; }\n               1 { assert \"had\"    == xx; }\n@@ -2699,7 +2699,7 @@ mod tests {\n \n         let mut ii = 0;\n \n-        splitn_char_iter(data, ' ', 2u) {|xx|\n+        do splitn_char_iter(data, ' ', 2u) {|xx|\n             alt ii {\n               0 { assert \"\\nMary\" == xx; }\n               1 { assert \"had\"    == xx; }\n@@ -2716,7 +2716,7 @@ mod tests {\n \n         let mut ii = 0;\n \n-        words_iter(data) {|ww|\n+        do words_iter(data) {|ww|\n             alt ii {\n               0 { assert \"Mary\"   == ww; }\n               1 { assert \"had\"    == ww; }\n@@ -2727,7 +2727,7 @@ mod tests {\n             ii += 1;\n         }\n \n-        words_iter(\"\") {|_x| fail; } // should not fail\n+        do words_iter(\"\") {|_x| fail; } // should not fail\n     }\n \n     #[test]\n@@ -2736,7 +2736,7 @@ mod tests {\n \n         let mut ii = 0;\n \n-        lines_iter(lf) {|x|\n+        do lines_iter(lf) {|x|\n             alt ii {\n                 0 { assert \"\" == x; }\n                 1 { assert \"Mary had a little lamb\" == x; }\n@@ -2844,7 +2844,7 @@ mod tests {\n     #[test]\n     fn test_unpack_slice() {\n         let a = \"hello\";\n-        unpack_slice(a) {|buf, len|\n+        do unpack_slice(a) {|buf, len|\n             unsafe {\n                 assert a[0] == 'h' as u8;\n                 assert *buf == 'h' as u8;"}, {"sha": "25fa1fb525e47aa1e2603ac7a4a1e7c23ecba784", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -183,16 +183,16 @@ mod tests {\n         let lock = arc::arc(create_lock());\n         let lock2 = arc::clone(&lock);\n \n-        task::spawn {|move lock2|\n+        do task::spawn {|move lock2|\n             let lock = arc::get(&lock2);\n-            (*lock).lock_cond {|c|\n+            do (*lock).lock_cond {|c|\n                 c.wait();\n             }\n         }\n \n         let mut signaled = false;\n         while !signaled {\n-            (*arc::get(&lock)).lock_cond {|c|\n+            do (*arc::get(&lock)).lock_cond {|c|\n                 signaled = c.signal()\n             }\n         }"}, {"sha": "c3d215b2de798e658ba089e5937679d17a1d40da", "filename": "src/libcore/task.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -295,7 +295,7 @@ fn future_result(builder: builder) -> future::future<task_result> {\n         with get_opts(builder)\n     });\n \n-    future::from_fn {||\n+    do future::from_fn {||\n         alt comm::recv(po) {\n           exit(_, result) { result }\n         }\n@@ -307,7 +307,7 @@ fn future_task(builder: builder) -> future::future<task> {\n \n     let mut po = comm::port();\n     let ch = comm::chan(po);\n-    add_wrapper(builder) {|body|\n+    do add_wrapper(builder) {|body|\n         fn~() {\n             comm::send(ch, get_task());\n             body();\n@@ -342,7 +342,7 @@ fn run_listener<A:send>(-builder: builder,\n     let setup_po = comm::port();\n     let setup_ch = comm::chan(setup_po);\n \n-    run(builder) {||\n+    do run(builder) {||\n         let po = comm::port();\n         let mut ch = comm::chan(po);\n         comm::send(setup_ch, ch);\n@@ -439,7 +439,7 @@ fn try<T:send>(+f: fn~() -> T) -> result<T,()> {\n     let mut builder = builder();\n     unsupervise(builder);\n     let result = future_result(builder);\n-    run(builder) {||\n+    do run(builder) {||\n         comm::send(ch, f());\n     }\n     alt future::get(result) {\n@@ -540,7 +540,7 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n         };\n         assert !new_task.is_null();\n \n-        option::iter(opts.notify_chan) {|c|\n+        do option::iter(opts.notify_chan) {|c|\n             // FIXME (#1087): Would like to do notification in Rust\n             rustrt::rust_task_config_notify(new_task, c);\n         }\n@@ -657,10 +657,10 @@ unsafe fn key_to_key_value<T>(key: local_data_key<T>) -> *libc::c_void {\n unsafe fn local_data_lookup<T>(map: task_local_map, key: local_data_key<T>)\n         -> option<(uint, *libc::c_void, fn@(+*libc::c_void))> {\n     let key_value = key_to_key_value(key);\n-    let map_pos = (*map).position {|entry|\n+    let map_pos = (*map).position({|entry|\n         alt entry { some((k,_,_)) { k == key_value } none { false } }\n-    };\n-    map_pos.map {|index|\n+    });\n+    do map_pos.map {|index|\n         // .get() is guaranteed because of \"none { false }\" above.\n         let (_, data_ptr, finaliser) = (*map)[index].get();\n         (index, data_ptr, finaliser)\n@@ -671,7 +671,7 @@ unsafe fn local_get_helper<T>(task: *rust_task, key: local_data_key<T>,\n                               do_pop: bool) -> option<@T> {\n     let map = get_task_local_map(task);\n     // Interpret our findings from the map\n-    local_data_lookup(map, key).map {|result|\n+    do local_data_lookup(map, key).map {|result|\n         // A reference count magically appears on 'data' out of thin air.\n         // 'data' has the reference we originally stored it with. We either\n         // need to erase it from the map or artificially bump the count.\n@@ -799,7 +799,7 @@ native mod rustrt {\n fn test_spawn_raw_simple() {\n     let po = comm::port();\n     let ch = comm::chan(po);\n-    spawn_raw(default_task_opts()) {||\n+    do spawn_raw(default_task_opts()) {||\n         comm::send(ch, ());\n     }\n     comm::recv(po);\n@@ -812,7 +812,7 @@ fn test_spawn_raw_unsupervise() {\n         supervise: false\n         with default_task_opts()\n     };\n-    spawn_raw(opts) {||\n+    do spawn_raw(opts) {||\n         fail;\n     }\n }\n@@ -829,7 +829,7 @@ fn test_spawn_raw_notify() {\n         notify_chan: some(notify_ch)\n         with default_task_opts()\n     };\n-    spawn_raw(opts) {||\n+    do spawn_raw(opts) {||\n         comm::send(task_ch, get_task());\n     }\n     let task_ = comm::recv(task_po);\n@@ -840,7 +840,7 @@ fn test_spawn_raw_notify() {\n         notify_chan: some(notify_ch)\n         with default_task_opts()\n     };\n-    spawn_raw(opts) {||\n+    do spawn_raw(opts) {||\n         comm::send(task_ch, get_task());\n         fail;\n     }\n@@ -853,7 +853,7 @@ fn test_run_basic() {\n     let po = comm::port();\n     let ch = comm::chan(po);\n     let buildr = builder();\n-    run(buildr) {||\n+    do run(buildr) {||\n         comm::send(ch, ());\n     }\n     comm::recv(po);\n@@ -864,13 +864,13 @@ fn test_add_wrapper() {\n     let po = comm::port();\n     let ch = comm::chan(po);\n     let buildr = builder();\n-    add_wrapper(buildr) {|body|\n+    do add_wrapper(buildr) {|body|\n         fn~() {\n             body();\n             comm::send(ch, ());\n         }\n     }\n-    run(buildr) {||}\n+    do run(buildr) {||}\n     comm::recv(po);\n }\n \n@@ -879,13 +879,13 @@ fn test_add_wrapper() {\n fn test_future_result() {\n     let buildr = builder();\n     let result = future_result(buildr);\n-    run(buildr) {||}\n+    do run(buildr) {||}\n     assert future::get(result) == success;\n \n     let buildr = builder();\n     let result = future_result(buildr);\n     unsupervise(buildr);\n-    run(buildr) {|| fail }\n+    do run(buildr) {|| fail }\n     assert future::get(result) == failure;\n }\n \n@@ -895,15 +895,15 @@ fn test_future_task() {\n     let ch = comm::chan(po);\n     let buildr = builder();\n     let task1 = future_task(buildr);\n-    run(buildr) {|| comm::send(ch, get_task()) }\n+    do run(buildr) {|| comm::send(ch, get_task()) }\n     assert future::get(task1) == comm::recv(po);\n }\n \n #[test]\n fn test_spawn_listiner_bidi() {\n     let po = comm::port();\n     let ch = comm::chan(po);\n-    let ch = spawn_listener {|po|\n+    let ch = do spawn_listener {|po|\n         // Now the child has a port called 'po' to read from and\n         // an environment-captured channel called 'ch'.\n         let res = comm::recv(po);\n@@ -918,7 +918,7 @@ fn test_spawn_listiner_bidi() {\n \n #[test]\n fn test_try_success() {\n-    alt try {||\n+    alt do try {||\n         \"Success!\"\n     } {\n         result::ok(\"Success!\") { }\n@@ -929,7 +929,7 @@ fn test_try_success() {\n #[test]\n #[ignore(cfg(windows))]\n fn test_try_fail() {\n-    alt try {||\n+    alt do try {||\n         fail\n     } {\n         result::err(()) { }\n@@ -941,7 +941,7 @@ fn test_try_fail() {\n #[should_fail]\n #[ignore(cfg(windows))]\n fn test_spawn_sched_no_threads() {\n-    spawn_sched(manual_threads(0u)) {|| };\n+    do spawn_sched(manual_threads(0u)) {|| };\n }\n \n #[test]\n@@ -952,7 +952,7 @@ fn test_spawn_sched() {\n     fn f(i: int, ch: comm::chan<()>) {\n         let parent_sched_id = rustrt::rust_get_sched_id();\n \n-        spawn_sched(single_threaded) {||\n+        do spawn_sched(single_threaded) {||\n             let child_sched_id = rustrt::rust_get_sched_id();\n             assert parent_sched_id != child_sched_id;\n \n@@ -973,9 +973,9 @@ fn test_spawn_sched_childs_on_same_sched() {\n     let po = comm::port();\n     let ch = comm::chan(po);\n \n-    spawn_sched(single_threaded) {||\n+    do spawn_sched(single_threaded) {||\n         let parent_sched_id = rustrt::rust_get_sched_id();\n-        spawn {||\n+        do spawn {||\n             let child_sched_id = rustrt::rust_get_sched_id();\n             // This should be on the same scheduler\n             assert parent_sched_id == child_sched_id;\n@@ -1002,7 +1002,7 @@ fn test_spawn_sched_blocking() {\n \n     // Testing that a task in one scheduler can block in foreign code\n     // without affecting other schedulers\n-    iter::repeat(20u) {||\n+    do iter::repeat(20u) {||\n \n         let start_po = comm::port();\n         let start_ch = comm::chan(start_po);\n@@ -1011,7 +1011,7 @@ fn test_spawn_sched_blocking() {\n \n         let lock = testrt::rust_dbg_lock_create();\n \n-        spawn_sched(single_threaded) {||\n+        do spawn_sched(single_threaded) {||\n             testrt::rust_dbg_lock_lock(lock);\n \n             comm::send(start_ch, ());\n@@ -1038,7 +1038,7 @@ fn test_spawn_sched_blocking() {\n         let setup_ch = comm::chan(setup_po);\n         let parent_po = comm::port();\n         let parent_ch = comm::chan(parent_po);\n-        spawn {||\n+        do spawn {||\n             let child_po = comm::port();\n             comm::send(setup_ch, comm::chan(child_po));\n             pingpong(child_po, parent_ch);\n@@ -1063,7 +1063,7 @@ fn avoid_copying_the_body(spawnfn: fn(+fn~())) {\n     let x = ~1;\n     let x_in_parent = ptr::addr_of(*x) as uint;\n \n-    spawnfn {||\n+    do spawnfn {||\n         let x_in_child = ptr::addr_of(*x) as uint;\n         comm::send(ch, x_in_child);\n     }\n@@ -1079,7 +1079,7 @@ fn test_avoid_copying_the_body_spawn() {\n \n #[test]\n fn test_avoid_copying_the_body_spawn_listener() {\n-    avoid_copying_the_body {|f|\n+    do avoid_copying_the_body {|f|\n         spawn_listener(fn~(move f, _po: comm::port<int>) {\n             f();\n         });\n@@ -1088,17 +1088,17 @@ fn test_avoid_copying_the_body_spawn_listener() {\n \n #[test]\n fn test_avoid_copying_the_body_run() {\n-    avoid_copying_the_body {|f|\n+    do avoid_copying_the_body {|f|\n         let buildr = builder();\n-        run(buildr) {||\n+        do run(buildr) {||\n             f();\n         }\n     }\n }\n \n #[test]\n fn test_avoid_copying_the_body_run_listener() {\n-    avoid_copying_the_body {|f|\n+    do avoid_copying_the_body {|f|\n         let buildr = builder();\n         run_listener(buildr, fn~(move f, _po: comm::port<int>) {\n             f();\n@@ -1108,30 +1108,30 @@ fn test_avoid_copying_the_body_run_listener() {\n \n #[test]\n fn test_avoid_copying_the_body_try() {\n-    avoid_copying_the_body {|f|\n-        try {||\n+    do avoid_copying_the_body {|f|\n+        do try {||\n             f()\n         };\n     }\n }\n \n #[test]\n fn test_avoid_copying_the_body_future_task() {\n-    avoid_copying_the_body {|f|\n+    do avoid_copying_the_body {|f|\n         let buildr = builder();\n         future_task(buildr);\n-        run(buildr) {||\n+        do run(buildr) {||\n             f();\n         }\n     }\n }\n \n #[test]\n fn test_avoid_copying_the_body_unsupervise() {\n-    avoid_copying_the_body {|f|\n+    do avoid_copying_the_body {|f|\n         let buildr = builder();\n         unsupervise(buildr);\n-        run(buildr) {||\n+        do run(buildr) {||\n             f();\n         }\n     }\n@@ -1151,7 +1151,7 @@ fn test_osmain() {\n \n     let po = comm::port();\n     let ch = comm::chan(po);\n-    run(buildr) {||\n+    do run(buildr) {||\n         comm::send(ch, ());\n     }\n     comm::recv(po);\n@@ -1166,20 +1166,20 @@ fn test_unkillable() {\n     let ch = po.chan();\n \n     // We want to do this after failing\n-    spawn {||\n+    do spawn {||\n         iter::repeat(10u, yield);\n         ch.send(());\n     }\n \n-    spawn {||\n+    do spawn {||\n         yield();\n         // We want to fail after the unkillable task\n         // blocks on recv\n         fail;\n     }\n \n     unsafe {\n-        unkillable {||\n+        do unkillable {||\n             let p = ~0;\n             let pp: *uint = unsafe::transmute(p);\n \n@@ -1198,7 +1198,7 @@ fn test_unkillable() {\n fn test_tls_multitask() unsafe {\n     fn my_key(+_x: @str) { }\n     local_data_set(my_key, @\"parent data\");\n-    task::spawn {||\n+    do task::spawn {||\n         assert local_data_get(my_key) == none; // TLS shouldn't carry over.\n         local_data_set(my_key, @\"child data\");\n         assert *(local_data_get(my_key).get()) == \"child data\";\n@@ -1230,19 +1230,19 @@ fn test_tls_pop() unsafe {\n #[test]\n fn test_tls_modify() unsafe {\n     fn my_key(+_x: @str) { }\n-    local_data_modify(my_key) {|data|\n+    local_data_modify(my_key, {|data|\n         alt data {\n             some(@val) { fail \"unwelcome value: \" + val }\n             none       { some(@\"first data\") }\n         }\n-    }\n-    local_data_modify(my_key) {|data|\n+    });\n+    local_data_modify(my_key, {|data|\n         alt data {\n             some(@\"first data\") { some(@\"next data\") }\n             some(@val)          { fail \"wrong value: \" + val }\n             none                { fail \"missing value\" }\n         }\n-    }\n+    });\n     assert *(local_data_pop(my_key).get()) == \"next data\";\n }\n \n@@ -1254,7 +1254,7 @@ fn test_tls_crust_automorestack_memorial_bug() unsafe {\n     // something within a rust stack segment. Then a subsequent upcall (esp.\n     // for logging, think vsnprintf) would run on a stack smaller than 1 MB.\n     fn my_key(+_x: @str) { }\n-    task::spawn {||\n+    do task::spawn {||\n         unsafe { local_data_set(my_key, @\"hax\"); }\n     }\n }\n@@ -1264,7 +1264,7 @@ fn test_tls_multiple_types() unsafe {\n     fn str_key(+_x: @str) { }\n     fn box_key(+_x: @@()) { }\n     fn int_key(+_x: @int) { }\n-    task::spawn{||\n+    do task::spawn{||\n         local_data_set(str_key, @\"string data\");\n         local_data_set(box_key, @@());\n         local_data_set(int_key, @42);\n@@ -1276,7 +1276,7 @@ fn test_tls_overwrite_multiple_types() unsafe {\n     fn str_key(+_x: @str) { }\n     fn box_key(+_x: @@()) { }\n     fn int_key(+_x: @int) { }\n-    task::spawn{||\n+    do task::spawn{||\n         local_data_set(str_key, @\"string data\");\n         local_data_set(int_key, @42);\n         // This could cause a segfault if overwriting-destruction is done with\n@@ -1294,7 +1294,7 @@ fn test_tls_cleanup_on_failure() unsafe {\n     fn int_key(+_x: @int) { }\n     local_data_set(str_key, @\"parent data\");\n     local_data_set(box_key, @@());\n-    task::spawn{|| // spawn_linked\n+    do task::spawn{|| // spawn_linked\n         local_data_set(str_key, @\"string data\");\n         local_data_set(box_key, @@());\n         local_data_set(int_key, @42);"}, {"sha": "8e63bc61a7de7bf15c41b8d21fc5e9ca5917d4d4", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -131,8 +131,8 @@ Convert to a string in a given base\n Fails if `radix` < 2 or `radix` > 16\n \"]\n fn to_str(num: T, radix: uint) -> str {\n-    to_str_bytes(false, num, radix) {|slice|\n-        vec::unpack_slice(slice) {|p, len|\n+    do to_str_bytes(false, num, radix) {|slice|\n+        do vec::unpack_slice(slice) {|p, len|\n             unsafe { str::unsafe::from_buf_len(p, len) }\n         }\n     }\n@@ -177,7 +177,7 @@ fn to_str_bytes<U>(neg: bool, num: T, radix: uint,\n     // in-bounds, no extra cost.\n \n     unsafe {\n-        vec::unpack_slice(buf) {|p, len|\n+        do vec::unpack_slice(buf) {|p, len|\n             let mp = p as *mut u8;\n             let mut i = len;\n             let mut n = num;"}, {"sha": "cd895d5b436faa7fab69e5fd5b6627ac17937a61", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -103,12 +103,12 @@ type init_op<T> = fn(uint) -> T;\n \n #[doc = \"Returns true if a vector contains no elements\"]\n pure fn is_empty<T>(v: &[const T]) -> bool {\n-    unpack_const_slice(v) {|_p, len| len == 0u}\n+    unpack_const_slice(v, {|_p, len| len == 0u})\n }\n \n #[doc = \"Returns true if a vector contains some elements\"]\n pure fn is_not_empty<T>(v: &[const T]) -> bool {\n-    unpack_const_slice(v) {|_p, len| len > 0u}\n+    unpack_const_slice(v, {|_p, len| len > 0u})\n }\n \n #[doc = \"Returns true if two vectors have the same length\"]\n@@ -169,7 +169,7 @@ pure fn capacity<T>(&&v: ~[const T]) -> uint {\n #[doc = \"Returns the length of a vector\"]\n #[inline(always)]\n pure fn len<T>(&&v: &[const T]) -> uint {\n-    unpack_const_slice(v) {|_p, len| len}\n+    unpack_const_slice(v, { |_p, len| len})\n }\n \n #[doc = \"\n@@ -266,7 +266,7 @@ pure fn slice<T: copy>(v: &[const T], start: uint, end: uint) -> ~[T] {\n pure fn view<T: copy>(v: &[const T], start: uint, end: uint) -> &a.[T] {\n     assert (start <= end);\n     assert (end <= len(v));\n-    unpack_slice(v) {|p, _len|\n+    do unpack_slice(v) {|p, _len|\n         unsafe {\n             ::unsafe::reinterpret_cast(\n                 (ptr::offset(p, start), (end - start) * sys::size_of::<T>()))\n@@ -455,9 +455,9 @@ fn push_slow<T>(&v: ~[const T], +initval: T) {\n // Unchecked vector indexing\n #[inline(always)]\n unsafe fn ref<T: copy>(v: &[const T], i: uint) -> T {\n-    unpack_slice(v) {|p, _len|\n+    unpack_slice(v, {|p, _len|\n         *ptr::offset(p, i)\n-    }\n+    })\n }\n \n #[inline(always)]\n@@ -473,7 +473,7 @@ fn push_all<T: copy>(&v: ~[const T], rhs: &[const T]) {\n fn push_all_move<T>(&v: ~[const T], -rhs: ~[const T]) {\n     reserve(v, v.len() + rhs.len());\n     unsafe {\n-        unpack_slice(rhs) {|p, len|\n+        do unpack_slice(rhs) {|p, len|\n             for uint::range(0, len) {|i|\n                 let x <- *ptr::offset(p, i);\n                 push(v, x);\n@@ -678,7 +678,7 @@ pure fn connect<T: copy>(v: &[[T]/~], sep: T) -> ~[T] {\n #[doc = \"Reduce a vector from left to right\"]\n pure fn foldl<T: copy, U>(z: T, v: &[U], p: fn(T, U) -> T) -> T {\n     let mut accum = z;\n-    iter(v) { |elt|\n+    do iter(v) { |elt|\n         accum = p(accum, elt);\n     }\n     ret accum;\n@@ -687,7 +687,7 @@ pure fn foldl<T: copy, U>(z: T, v: &[U], p: fn(T, U) -> T) -> T {\n #[doc = \"Reduce a vector from right to left\"]\n pure fn foldr<T, U: copy>(v: &[T], z: U, p: fn(T, U) -> U) -> U {\n     let mut accum = z;\n-    riter(v) { |elt|\n+    do riter(v) { |elt|\n         accum = p(elt, accum);\n     }\n     ret accum;\n@@ -787,7 +787,7 @@ is returned. If `f` matches no elements then none is returned.\n \"]\n pure fn find_between<T: copy>(v: &[T], start: uint, end: uint,\n                       f: fn(T) -> bool) -> option<T> {\n-    option::map(position_between(v, start, end, f)) { |i| v[i] }\n+    option::map(position_between(v, start, end, f), { |i| v[i] })\n }\n \n #[doc = \"\n@@ -810,12 +810,12 @@ the element is returned. If `f` matches no elements then none is returned.\n \"]\n pure fn rfind_between<T: copy>(v: &[T], start: uint, end: uint,\n                                f: fn(T) -> bool) -> option<T> {\n-    option::map(rposition_between(v, start, end, f)) { |i| v[i] }\n+    option::map(rposition_between(v, start, end, f), { |i| v[i] })\n }\n \n #[doc = \"Find the first index containing a matching value\"]\n pure fn position_elem<T>(v: &[T], x: T) -> option<uint> {\n-    position(v) { |y| x == y }\n+    position(v, { |y| x == y })\n }\n \n #[doc = \"\n@@ -847,7 +847,7 @@ pure fn position_between<T>(v: &[T], start: uint, end: uint,\n \n #[doc = \"Find the last index containing a matching value\"]\n pure fn rposition_elem<T>(v: &[T], x: T) -> option<uint> {\n-    rposition(v) { |y| x == y }\n+    rposition(v, { |y| x == y })\n }\n \n #[doc = \"\n@@ -974,7 +974,7 @@ element's value.\n */\n #[inline(always)]\n pure fn iter_between<T>(v: &[T], start: uint, end: uint, f: fn(T)) {\n-    unpack_slice(v) { |base_ptr, len|\n+    do unpack_slice(v) { |base_ptr, len|\n         assert start <= end;\n         assert end <= len;\n         unsafe {\n@@ -996,7 +996,7 @@ Return true to continue, false to break.\n \"]\n #[inline(always)]\n pure fn each<T>(v: &[const T], f: fn(T) -> bool) {\n-    vec::unpack_slice(v) {|p, n|\n+    do vec::unpack_slice(v) {|p, n|\n         let mut n = n;\n         let mut p = p;\n         while n > 0u {\n@@ -1016,7 +1016,7 @@ Return true to continue, false to break.\n \"]\n #[inline(always)]\n pure fn eachi<T>(v: &[const T], f: fn(uint, T) -> bool) {\n-    vec::unpack_slice(v) {|p, n|\n+    do vec::unpack_slice(v) {|p, n|\n         let mut i = 0u;\n         let mut p = p;\n         while i < n {\n@@ -1064,7 +1064,7 @@ Iterates over vector `v` and, for each element, calls function `f` with the\n element's value.\n \"]\n pure fn riter<T>(v: &[T], f: fn(T)) {\n-    riteri(v) { |_i, v| f(v) }\n+    riteri(v, { |_i, v| f(v) })\n }\n \n #[doc =\"\n@@ -1102,9 +1102,9 @@ pure fn permute<T: copy>(v: &[T], put: fn(~[T])) {\n             let mut rest = slice(v, 0u, i);\n             unchecked {\n                 push_all(rest, view(v, i+1u, ln));\n-                permute(rest) {|permutation|\n+                permute(rest, {|permutation|\n                     put(append(~[elt], permutation))\n-                }\n+                })\n             }\n             i += 1u;\n         }\n@@ -1130,11 +1130,11 @@ Allows for unsafe manipulation of vector contents, which is useful for native\n interop.\n \"]\n fn as_buf<E,T>(v: &[E], f: fn(*E) -> T) -> T {\n-    unpack_slice(v) { |buf, _len| f(buf) }\n+    unpack_slice(v, { |buf, _len| f(buf) })\n }\n \n fn as_mut_buf<E,T>(v: &[mut E], f: fn(*mut E) -> T) -> T {\n-    unpack_mut_slice(v) { |buf, _len| f(buf) }\n+    unpack_mut_slice(v, { |buf, _len| f(buf) })\n }\n \n #[doc = \"\n@@ -1896,19 +1896,19 @@ mod tests {\n         let mut results: ~[~[int]];\n \n         results = ~[];\n-        permute(~[]) {|v| vec::push(results, v); }\n+        permute(~[], {|v| vec::push(results, v); });\n         assert results == ~[~[]];\n \n         results = ~[];\n-        permute(~[7]) {|v| results += ~[v]; }\n+        permute(~[7], {|v| results += ~[v]; });\n         assert results == ~[~[7]];\n \n         results = ~[];\n-        permute(~[1,1]) {|v| results += ~[v]; }\n+        permute(~[1,1], {|v| results += ~[v]; });\n         assert results == ~[~[1,1],~[1,1]];\n \n         results = ~[];\n-        permute(~[5,2,0]) {|v| results += ~[v]; }\n+        permute(~[5,2,0], {|v| results += ~[v]; });\n         assert results ==\n             ~[~[5,2,0],~[5,0,2],~[2,5,0],~[2,0,5],~[0,5,2],~[0,2,5]];\n     }"}, {"sha": "e3152839793508d18e26748305bd31891de89dee", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -222,19 +222,19 @@ impl writer for writer {\n     }\n \n     fn wr_tagged_u64(tag_id: uint, v: u64) {\n-        io::u64_to_be_bytes(v, 8u) {|v|\n+        do io::u64_to_be_bytes(v, 8u) {|v|\n             self.wr_tagged_bytes(tag_id, v);\n         }\n     }\n \n     fn wr_tagged_u32(tag_id: uint, v: u32) {\n-        io::u64_to_be_bytes(v as u64, 4u) {|v|\n+        do io::u64_to_be_bytes(v as u64, 4u) {|v|\n             self.wr_tagged_bytes(tag_id, v);\n         }\n     }\n \n     fn wr_tagged_u16(tag_id: uint, v: u16) {\n-        io::u64_to_be_bytes(v as u64, 2u) {|v|\n+        do io::u64_to_be_bytes(v as u64, 2u) {|v|\n             self.wr_tagged_bytes(tag_id, v);\n         }\n     }\n@@ -244,19 +244,19 @@ impl writer for writer {\n     }\n \n     fn wr_tagged_i64(tag_id: uint, v: i64) {\n-        io::u64_to_be_bytes(v as u64, 8u) {|v|\n+        do io::u64_to_be_bytes(v as u64, 8u) {|v|\n             self.wr_tagged_bytes(tag_id, v);\n         }\n     }\n \n     fn wr_tagged_i32(tag_id: uint, v: i32) {\n-        io::u64_to_be_bytes(v as u64, 4u) {|v|\n+        do io::u64_to_be_bytes(v as u64, 4u) {|v|\n             self.wr_tagged_bytes(tag_id, v);\n         }\n     }\n \n     fn wr_tagged_i16(tag_id: uint, v: i16) {\n-        io::u64_to_be_bytes(v as u64, 2u) {|v|\n+        do io::u64_to_be_bytes(v as u64, 2u) {|v|\n             self.wr_tagged_bytes(tag_id, v);\n         }\n     }\n@@ -355,7 +355,7 @@ impl serializer of serialization::serializer for ebml::writer {\n     fn emit_enum_variant_arg(_idx: uint, f: fn()) { f() }\n \n     fn emit_vec(len: uint, f: fn()) {\n-        self.wr_tag(es_vec as uint) {||\n+        do self.wr_tag(es_vec as uint) {||\n             self._emit_tagged_uint(es_vec_len, len);\n             f()\n         }\n@@ -482,7 +482,7 @@ impl deserializer of serialization::deserializer for ebml_deserializer {\n         #debug[\"read_enum_variant()\"];\n         let idx = self._next_uint(es_enum_vid);\n         #debug[\"  idx=%u\", idx];\n-        self.push_doc(self.next_doc(es_enum_body)) {||\n+        do self.push_doc(self.next_doc(es_enum_body)) {||\n             f(idx)\n         }\n     }\n@@ -494,7 +494,7 @@ impl deserializer of serialization::deserializer for ebml_deserializer {\n \n     fn read_vec<T:copy>(f: fn(uint) -> T) -> T {\n         #debug[\"read_vec()\"];\n-        self.push_doc(self.next_doc(es_vec)) {||\n+        do self.push_doc(self.next_doc(es_vec)) {||\n             let len = self._next_uint(es_vec_len);\n             #debug[\"  len=%u\", len];\n             f(len)\n@@ -549,14 +549,14 @@ fn test_option_int() {\n     }\n \n     fn serialize_0<S: serialization::serializer>(s: S, v: option<int>) {\n-        s.emit_enum(\"core::option::t\") {||\n+        do s.emit_enum(\"core::option::t\") {||\n             alt v {\n               none {\n-                s.emit_enum_variant(\"core::option::none\", 0u, 0u) {||}\n+                s.emit_enum_variant(\"core::option::none\", 0u, 0u, {||});\n               }\n               some(v0) {\n-                s.emit_enum_variant(\"core::option::some\", 1u, 1u) {||\n-                    s.emit_enum_variant_arg(0u) {|| serialize_1(s, v0) }\n+                do s.emit_enum_variant(\"core::option::some\", 1u, 1u) {||\n+                    s.emit_enum_variant_arg(0u, {|| serialize_1(s, v0) });\n                 }\n               }\n             }\n@@ -568,12 +568,12 @@ fn test_option_int() {\n     }\n \n     fn deserialize_0<S: serialization::deserializer>(s: S) -> option<int> {\n-        s.read_enum(\"core::option::t\") {||\n-            s.read_enum_variant {|i|\n+        do s.read_enum(\"core::option::t\") {||\n+            do s.read_enum_variant {|i|\n                 alt check i {\n                   0u { none }\n                   1u {\n-                    let v0 = s.read_enum_variant_arg(0u) {||\n+                    let v0 = do s.read_enum_variant_arg(0u) {||\n                         deserialize_1(s)\n                     };\n                     some(v0)"}, {"sha": "51f59f59d133565c9e46beab87a321caade8cbf9", "filename": "src/libstd/json.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -90,7 +90,7 @@ fn to_writer(wr: io::writer, j: json) {\n \n fn escape_str(s: str) -> str {\n     let mut escaped = \"\\\"\";\n-    str::chars_iter(s) { |c|\n+    do str::chars_iter(s) { |c|\n         alt c {\n           '\"' { escaped += \"\\\\\\\"\"; }\n           '\\\\' { escaped += \"\\\\\\\\\"; }\n@@ -110,7 +110,7 @@ fn escape_str(s: str) -> str {\n \n #[doc = \"Serializes a json value into a string\"]\n fn to_str(j: json) -> str {\n-    io::with_str_writer { |wr| to_writer(wr, j) }\n+    io::with_str_writer({ |wr| to_writer(wr, j) })\n }\n \n type parser = {\n@@ -598,7 +598,7 @@ impl <A: to_json copy, B: to_json copy, C: to_json copy>\n }\n \n impl <A: to_json> of to_json for ~[A] {\n-    fn to_json() -> json { list(@self.map { |elt| elt.to_json() }) }\n+    fn to_json() -> json { list(@self.map({ |elt| elt.to_json() })) }\n }\n \n impl <A: to_json copy> of to_json for hashmap<str, A> {\n@@ -635,7 +635,7 @@ mod tests {\n     fn mk_dict(items: ~[(str, json)]) -> json {\n         let d = map::str_hash();\n \n-        vec::iter(items) { |item|\n+        do vec::iter(items) { |item|\n             let (key, value) = copy item;\n             d.insert(key, value);\n         };"}, {"sha": "5018f9860ce846a46d545cb336369a24d740151f", "filename": "src/libstd/list.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -29,7 +29,7 @@ accumulated result.\n \"]\n fn foldl<T: copy, U>(z: T, ls: @list<U>, f: fn(T, U) -> T) -> T {\n     let mut accum: T = z;\n-    iter(ls) {|elt| accum = f(accum, elt);}\n+    do iter(ls) {|elt| accum = f(accum, elt);}\n     accum\n }\n \n@@ -77,7 +77,7 @@ pure fn is_not_empty<T: copy>(ls: @list<T>) -> bool {\n #[doc = \"Returns the length of a list\"]\n fn len<T>(ls: @list<T>) -> uint {\n     let mut count = 0u;\n-    iter(ls) {|_e| count += 1u;}\n+    iter(ls, {|_e| count += 1u;});\n     count\n }\n "}, {"sha": "331bc6dcced83c89189c8d76c946b7e6d4719f4a", "filename": "src/libstd/map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -261,9 +261,9 @@ mod chained {\n             }\n         }\n \n-        fn each_key(blk: fn(K) -> bool) { self.each { |k, _v| blk(k)} }\n+        fn each_key(blk: fn(K) -> bool) { self.each({ |k, _v| blk(k)}) }\n \n-        fn each_value(blk: fn(V) -> bool) { self.each { |_k, v| blk(v)} }\n+        fn each_value(blk: fn(V) -> bool) { self.each({ |_k, v| blk(v)}) }\n     }\n \n     fn chains<K,V>(nchains: uint) -> ~[mut chain<K,V>] {\n@@ -332,7 +332,7 @@ Convert a set into a vector.\n \"]\n fn vec_from_set<T: copy>(s: set<T>) -> ~[T] {\n     let mut v = ~[];\n-    s.each_key() {|k|\n+    do s.each_key() {|k|\n         vec::push(v, k);\n         true\n     };\n@@ -343,7 +343,7 @@ fn vec_from_set<T: copy>(s: set<T>) -> ~[T] {\n fn hash_from_vec<K: const copy, V: copy>(hasher: hashfn<K>, eqer: eqfn<K>,\n                                          items: ~[(K, V)]) -> hashmap<K, V> {\n     let map = hashmap(hasher, eqer);\n-    vec::iter(items) { |item|\n+    do vec::iter(items) { |item|\n         let (key, value) = item;\n         map.insert(key, value);\n     }"}, {"sha": "f923b6fedea5c1731326d1eb977a4365fd4c6ed1", "filename": "src/libstd/md4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibstd%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibstd%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmd4.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -88,7 +88,7 @@ fn md4_str(msg: ~[u8]) -> str {\n         f(a); f(b); f(c); f(d);\n     }\n     let mut result = \"\";\n-    app(a, b, c, d) {|u|\n+    do app(a, b, c, d) {|u|\n         let mut i = 0u32;\n         while i < 4u32 {\n             let byte = (u >> (i * 8u32)) as u8;"}, {"sha": "f1e28ed0290f921f2c152b0bd277b60810d590f6", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -48,7 +48,7 @@ class tcp_socket {\n        };\n        let close_data_ptr = ptr::addr_of(close_data);\n        let stream_handle_ptr = (*(self.socket_data)).stream_handle_ptr;\n-       iotask::interact((*(self.socket_data)).iotask) {|loop_ptr|\n+       do iotask::interact((*(self.socket_data)).iotask) {|loop_ptr|\n           log(debug, #fmt(\"interact dtor for tcp_socket stream %? loop %?\",\n             stream_handle_ptr, loop_ptr));\n            uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n@@ -72,7 +72,7 @@ class tcp_conn_port {\n     let server_stream_ptr = ptr::addr_of((*conn_data_ptr).server_stream);\n     let stream_closed_po = (*(self.conn_data)).stream_closed_po;\n     let iotask = (*conn_data_ptr).iotask;\n-    iotask::interact(iotask) {|loop_ptr|\n+    do iotask::interact(iotask) {|loop_ptr|\n         log(debug, #fmt(\"dtor for tcp_conn_port loop: %?\",\n                        loop_ptr));\n         uv::ll::close(server_stream_ptr, tcp_nl_close_cb);\n@@ -131,7 +131,7 @@ fn connect(input_ip: ip::ip_addr, port: uint,\n     // we can send into the interact cb to be handled in libuv..\n     log(debug, #fmt(\"stream_handle_ptr outside interact %?\",\n         stream_handle_ptr));\n-    iotask::interact(iotask) {|loop_ptr|\n+    do iotask::interact(iotask) {|loop_ptr|\n         log(debug, \"in interact cb for tcp client connect..\");\n         log(debug, #fmt(\"stream_handle_ptr in interact %?\",\n             stream_handle_ptr));\n@@ -251,7 +251,7 @@ value as the `err` variant\n fn write_future(sock: tcp_socket, raw_write_data: ~[u8])\n     -> future<result::result<(), tcp_err_data>> unsafe {\n     let socket_data_ptr = ptr::addr_of(*(sock.socket_data));\n-    future_spawn {||\n+    do future_spawn {||\n         write_common_impl(socket_data_ptr, raw_write_data)\n     }\n }\n@@ -340,7 +340,7 @@ read attempt. Pass `0u` to wait indefinitely\n fn read_future(sock: tcp_socket, timeout_msecs: uint)\n     -> future<result::result<~[u8],tcp_err_data>> {\n     let socket_data = ptr::addr_of(*(sock.socket_data));\n-    future_spawn {||\n+    do future_spawn {||\n         read_common_impl(socket_data, timeout_msecs)\n     }\n }\n@@ -387,7 +387,7 @@ fn new_listener(host_ip: ip::ip_addr, port: uint, backlog: uint,\n \n     let setup_po = comm::port::<option<tcp_err_data>>();\n     let setup_ch = comm::chan(setup_po);\n-    iotask::interact(iotask) {|loop_ptr|\n+    do iotask::interact(iotask) {|loop_ptr|\n         let tcp_addr = ipv4_ip_addr_to_sockaddr_in(host_ip,\n                                                    port);\n         alt uv::ll::tcp_init(loop_ptr, server_stream_ptr) {\n@@ -488,7 +488,7 @@ fn conn_recv_spawn(server_port: tcp_conn_port,\n     let new_conn_po = (*(server_port.conn_data)).new_conn_po;\n     let iotask = (*(server_port.conn_data)).iotask;\n     let new_conn_result = comm::recv(new_conn_po);\n-    task::spawn {||\n+    do task::spawn {||\n         let sock_create_result = alt new_conn_result {\n           ok(client_stream_ptr) {\n             conn_port_new_tcp_socket(client_stream_ptr, iotask)\n@@ -709,7 +709,7 @@ fn listen_for_conn(host_ip: ip::ip_addr, port: uint, backlog: uint,\n \n     let setup_po = comm::port::<option<tcp_err_data>>();\n     let setup_ch = comm::chan(setup_po);\n-    iotask::interact(iotask) {|loop_ptr|\n+    do iotask::interact(iotask) {|loop_ptr|\n         let tcp_addr = ipv4_ip_addr_to_sockaddr_in(host_ip,\n                                                    port);\n         alt uv::ll::tcp_init(loop_ptr, server_stream_ptr) {\n@@ -755,7 +755,7 @@ fn listen_for_conn(host_ip: ip::ip_addr, port: uint, backlog: uint,\n       none {\n         on_establish_cb(kill_ch);\n         let kill_result = comm::recv(kill_po);\n-        iotask::interact(iotask) {|loop_ptr|\n+        do iotask::interact(iotask) {|loop_ptr|\n             log(debug, #fmt(\"tcp::listen post-kill recv hl interact %?\",\n                             loop_ptr));\n             (*server_data_ptr).active = false;\n@@ -861,7 +861,7 @@ fn read_stop_common_impl(socket_data: *tcp_socket_data) ->\n     let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n     let stop_po = comm::port::<option<tcp_err_data>>();\n     let stop_ch = comm::chan(stop_po);\n-    iotask::interact((*socket_data).iotask) {|loop_ptr|\n+    do iotask::interact((*socket_data).iotask) {|loop_ptr|\n         log(debug, \"in interact cb for tcp::read_stop\");\n         alt uv::ll::read_stop(stream_handle_ptr as *uv::ll::uv_stream_t) {\n           0i32 {\n@@ -893,7 +893,7 @@ fn read_start_common_impl(socket_data: *tcp_socket_data)\n     let start_po = comm::port::<option<uv::ll::uv_err_data>>();\n     let start_ch = comm::chan(start_po);\n     log(debug, \"in tcp::read_start before interact loop\");\n-    iotask::interact((*socket_data).iotask) {|loop_ptr|\n+    do iotask::interact((*socket_data).iotask) {|loop_ptr|\n         log(debug, #fmt(\"in tcp::read_start interact cb %?\", loop_ptr));\n         alt uv::ll::read_start(stream_handle_ptr as *uv::ll::uv_stream_t,\n                                on_alloc_cb,\n@@ -935,7 +935,7 @@ fn write_common_impl(socket_data_ptr: *tcp_socket_data,\n         result_ch: comm::chan(result_po)\n     };\n     let write_data_ptr = ptr::addr_of(write_data);\n-    iotask::interact((*socket_data_ptr).iotask) {|loop_ptr|\n+    do iotask::interact((*socket_data_ptr).iotask) {|loop_ptr|\n         log(debug, #fmt(\"in interact cb for tcp::write %?\", loop_ptr));\n         alt uv::ll::write(write_req_ptr,\n                           stream_handle_ptr,\n@@ -979,8 +979,8 @@ fn conn_port_new_tcp_socket(\n         iotask : iotask\n     };\n     let client_socket_data_ptr = ptr::addr_of(*client_socket_data);\n-    comm::listen {|cont_ch|\n-        iotask::interact(iotask) {|loop_ptr|\n+    do comm::listen {|cont_ch|\n+        do iotask::interact(iotask) {|loop_ptr|\n             log(debug, #fmt(\"in interact cb 4 conn_port_new_tcp.. loop %?\",\n                 loop_ptr));\n             uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n@@ -1332,8 +1332,8 @@ mod test {\n         let cont_po = comm::port::<()>();\n         let cont_ch = comm::chan(cont_po);\n         // server\n-        task::spawn_sched(task::manual_threads(1u)) {||\n-            let actual_req = comm::listen {|server_ch|\n+        do task::spawn_sched(task::manual_threads(1u)) {||\n+            let actual_req = do comm::listen {|server_ch|\n                 run_tcp_test_server(\n                     server_ip,\n                     server_port,\n@@ -1347,7 +1347,7 @@ mod test {\n         comm::recv(cont_po);\n         // client\n         log(debug, \"server started, firing up client..\");\n-        let actual_resp = comm::listen {|client_ch|\n+        let actual_resp = do comm::listen {|client_ch|\n             run_tcp_test_client(\n                 server_ip,\n                 server_port,\n@@ -1376,8 +1376,8 @@ mod test {\n         let cont_po = comm::port::<()>();\n         let cont_ch = comm::chan(cont_po);\n         // server\n-        task::spawn_sched(task::manual_threads(1u)) {||\n-            let actual_req = comm::listen {|server_ch|\n+        do task::spawn_sched(task::manual_threads(1u)) {||\n+            let actual_req = do comm::listen {|server_ch|\n                 run_tcp_test_server_listener(\n                     server_ip,\n                     server_port,\n@@ -1391,7 +1391,7 @@ mod test {\n         comm::recv(cont_po);\n         // client\n         log(debug, \"server started, firing up client..\");\n-        let actual_resp = comm::listen {|client_ch|\n+        let actual_resp = do comm::listen {|client_ch|\n             run_tcp_test_client(\n                 server_ip,\n                 server_port,\n@@ -1413,7 +1413,7 @@ mod test {\n                           cont_ch: comm::chan<()>,\n                           iotask: iotask) -> str {\n \n-        task::spawn_sched(task::manual_threads(1u)) {||\n+        do task::spawn_sched(task::manual_threads(1u)) {||\n             let server_ip_addr = ip::v4::parse_addr(server_ip);\n             let listen_result =\n                 listen_for_conn(server_ip_addr, server_port, 128u,\n@@ -1428,8 +1428,8 @@ mod test {\n                 // will want the POWER\n                 {|new_conn, kill_ch|\n                 log(debug, \"SERVER: new connection!\");\n-                comm::listen {|cont_ch|\n-                    task::spawn_sched(task::manual_threads(1u)) {||\n+                do comm::listen {|cont_ch|\n+                    do task::spawn_sched(task::manual_threads(1u)) {||\n                         log(debug, \"SERVER: starting worker for new req\");\n \n                         let accept_result = accept(new_conn);\n@@ -1492,7 +1492,7 @@ mod test {\n                                     cont_ch: comm::chan<()>,\n                                     iotask: iotask) -> str {\n \n-        task::spawn_sched(task::manual_threads(1u)) {||\n+        do task::spawn_sched(task::manual_threads(1u)) {||\n             let server_ip_addr = ip::v4::parse_addr(server_ip);\n             let new_listener_result =\n                 new_listener(server_ip_addr, server_port, 128u, iotask);"}, {"sha": "eab0fa6980f9d0cddfea58dbc8e0c31367c8fbe0", "filename": "src/libstd/par.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -41,9 +41,9 @@ fn map_slices<A: copy send, B: copy send>(\n         while base < len {\n             let end = uint::min(len, base + items_per_task);\n             // FIXME: why is the ::<A, ()> annotation required here? (#2617)\n-            vec::unpack_slice::<A, ()>(xs) {|p, _len|\n+            do vec::unpack_slice::<A, ()>(xs) {|p, _len|\n                 let f = f();\n-                let f = future_spawn() {|copy base|\n+                let f = do future_spawn() {|copy base|\n                     unsafe {\n                         let len = end - base;\n                         let slice = (ptr::offset(p, base),\n@@ -66,7 +66,7 @@ fn map_slices<A: copy send, B: copy send>(\n         log(info, #fmt(\"num_tasks: %?\", (num_tasks, futures.len())));\n         assert(num_tasks == futures.len());\n \n-        let r = futures.map() {|ys|\n+        let r = do futures.map() {|ys|\n             ys.get()\n         };\n         assert(r.len() == futures.len());\n@@ -76,23 +76,23 @@ fn map_slices<A: copy send, B: copy send>(\n \n #[doc=\"A parallel version of map.\"]\n fn map<A: copy send, B: copy send>(xs: ~[A], f: fn~(A) -> B) -> ~[B] {\n-    vec::concat(map_slices(xs) {||\n+    vec::concat(map_slices(xs, {||\n         fn~(_base: uint, slice : &[A], copy f) -> ~[B] {\n             vec::map(slice, f)\n         }\n-    })\n+    }))\n }\n \n #[doc=\"A parallel version of mapi.\"]\n fn mapi<A: copy send, B: copy send>(xs: ~[A],\n                                     f: fn~(uint, A) -> B) -> ~[B] {\n-    let slices = map_slices(xs) {||\n+    let slices = map_slices(xs, {||\n         fn~(base: uint, slice : &[A], copy f) -> ~[B] {\n-            vec::mapi(slice) {|i, x|\n+            vec::mapi(slice, {|i, x|\n                 f(i + base, x)\n-            }\n+            })\n         }\n-    };\n+    });\n     let r = vec::concat(slices);\n     log(info, (r.len(), xs.len()));\n     assert(r.len() == xs.len());\n@@ -105,14 +105,14 @@ In this case, f is a function that creates functions to run over the\n inner elements. This is to skirt the need for copy constructors.\"]\n fn mapi_factory<A: copy send, B: copy send>(\n     xs: ~[A], f: fn() -> fn~(uint, A) -> B) -> ~[B] {\n-    let slices = map_slices(xs) {||\n+    let slices = map_slices(xs, {||\n         let f = f();\n         fn~(base: uint, slice : &[A], move f) -> ~[B] {\n-            vec::mapi(slice) {|i, x|\n+            vec::mapi(slice, {|i, x|\n                 f(i + base, x)\n-            }\n+            })\n         }\n-    };\n+    });\n     let r = vec::concat(slices);\n     log(info, (r.len(), xs.len()));\n     assert(r.len() == xs.len());\n@@ -121,20 +121,20 @@ fn mapi_factory<A: copy send, B: copy send>(\n \n #[doc=\"Returns true if the function holds for all elements in the vector.\"]\n fn alli<A: copy send>(xs: ~[A], f: fn~(uint, A) -> bool) -> bool {\n-    vec::all(map_slices(xs) {||\n+    do vec::all(map_slices(xs, {||\n         fn~(base: uint, slice : &[A], copy f) -> bool {\n-            vec::alli(slice) {|i, x|\n+            vec::alli(slice, {|i, x|\n                 f(i + base, x)\n-            }\n+            })\n         }\n-    }) {|x| x }\n+    })) {|x| x }\n }\n \n #[doc=\"Returns true if the function holds for any elements in the vector.\"]\n fn any<A: copy send>(xs: ~[A], f: fn~(A) -> bool) -> bool {\n-    vec::any(map_slices(xs) {||\n+    do vec::any(map_slices(xs, {||\n         fn~(_base : uint, slice: &[A], copy f) -> bool {\n             vec::any(slice, f)\n         }\n-    }) {|x| x }\n+    })) {|x| x }\n }"}, {"sha": "374add74404d04b75abe85a90e527e6d5314eb40", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -397,7 +397,7 @@ Loop through a rope, char by char, until the end.\n * it - A block to execute with each consecutive character of the rope.\n \"]\n fn iter_chars(rope: rope, it: fn(char)) {\n-    loop_chars(rope) {|x|\n+    do loop_chars(rope) {|x|\n         it(x);\n         true\n     };"}, {"sha": "6819711aad6926f67e55e2c4062e63c4b06c7796", "filename": "src/libstd/serialization.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibstd%2Fserialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibstd%2Fserialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -84,19 +84,19 @@ iface deserializer {\n // In some cases, these should eventually be coded as traits.\n \n fn emit_from_vec<S: serializer, T>(s: S, v: ~[T], f: fn(T)) {\n-    s.emit_vec(vec::len(v)) {||\n-        vec::iteri(v) {|i,e|\n-            s.emit_vec_elt(i) {||\n+    do s.emit_vec(vec::len(v)) {||\n+        do vec::iteri(v) {|i,e|\n+            do s.emit_vec_elt(i) {||\n                 f(e)\n             }\n         }\n     }\n }\n \n fn read_to_vec<D: deserializer, T: copy>(d: D, f: fn() -> T) -> ~[T] {\n-    d.read_vec {|len|\n-        vec::from_fn(len) {|i|\n-            d.read_vec_elt(i) {|| f() }\n+    do d.read_vec {|len|\n+        do vec::from_fn(len) {|i|\n+            do d.read_vec_elt(i) {|| f() }\n         }\n     }\n }\n@@ -234,16 +234,16 @@ fn deserialize_bool<D: deserializer>(d: D) -> bool {\n }\n \n fn serialize_option<S: serializer,T>(s: S, v: option<T>, st: fn(T)) {\n-    s.emit_enum(\"option\") {||\n+    do s.emit_enum(\"option\") {||\n         alt v {\n           none {\n-            s.emit_enum_variant(\"none\", 0u, 0u) {||\n+            do s.emit_enum_variant(\"none\", 0u, 0u) {||\n             }\n           }\n \n           some(v) {\n-            s.emit_enum_variant(\"some\", 1u, 1u) {||\n-                s.emit_enum_variant_arg(0u) {||\n+            do s.emit_enum_variant(\"some\", 1u, 1u) {||\n+                do s.emit_enum_variant_arg(0u) {||\n                     st(v)\n                 }\n             }\n@@ -254,16 +254,16 @@ fn serialize_option<S: serializer,T>(s: S, v: option<T>, st: fn(T)) {\n \n fn deserialize_option<D: deserializer,T: copy>(d: D, st: fn() -> T)\n     -> option<T> {\n-    d.read_enum(\"option\") {||\n-        d.read_enum_variant {|i|\n+    do d.read_enum(\"option\") {||\n+        do d.read_enum_variant {|i|\n             alt check i {\n               0u { // none\n                 none\n               }\n               1u { // some(v)\n-                some(d.read_enum_variant_arg(0u) {||\n+                some(d.read_enum_variant_arg(0u, {||\n                     st()\n-                })\n+                }))\n               }\n             }\n         }"}, {"sha": "a7df6df281acf7311cc69dc8d1563eed62b30554", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -102,7 +102,7 @@ impl <V: copy> of map::map<uint, V> for smallintmap<V> {\n         }\n     }\n     fn each_value(it: fn(V) -> bool) {\n-        self.each {|_i, v| it(v)}\n+        self.each({|_i, v| it(v)});\n     }\n }\n "}, {"sha": "6c18afb6474e874e52a51d2ab4cb180cb5d7a8a1", "filename": "src/libstd/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -216,7 +216,7 @@ fn run_tests_console(opts: test_opts,\n fn print_failures(st: console_test_state) {\n     st.out.write_line(\"\\nfailures:\");\n     let failures = copy st.failures;\n-    let failures = vec::map(failures) {|test| test.name};\n+    let failures = vec::map(failures, {|test| test.name});\n     let failures = sort::merge_sort(str::le, failures);\n     for vec::each(failures) {|name|\n         st.out.write_line(#fmt[\"    %s\", name]);\n@@ -390,7 +390,7 @@ fn run_test(+test: test_desc, monitor_ch: comm::chan<monitor_msg>) {\n         ret;\n     }\n \n-    task::spawn {||\n+    do task::spawn {||\n         let testfn = copy test.fn;\n         let mut builder = task::builder();\n         let result_future = task::future_result(builder);"}, {"sha": "e38f72ab189af0c493e3d147949a9ff6edb50f70", "filename": "src/libstd/time.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -283,21 +283,21 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n           }\n           'c' {\n             parse_type(s, pos, 'a', tm)\n-                .chain { |pos| parse_char(s, pos, ' ') }\n-                .chain { |pos| parse_type(s, pos, 'b', tm) }\n-                .chain { |pos| parse_char(s, pos, ' ') }\n-                .chain { |pos| parse_type(s, pos, 'e', tm) }\n-                .chain { |pos| parse_char(s, pos, ' ') }\n-                .chain { |pos| parse_type(s, pos, 'T', tm) }\n-                .chain { |pos| parse_char(s, pos, ' ') }\n-                .chain { |pos| parse_type(s, pos, 'Y', tm) }\n+                .chain({ |pos| parse_char(s, pos, ' ') })\n+                .chain({ |pos| parse_type(s, pos, 'b', tm) })\n+                .chain({ |pos| parse_char(s, pos, ' ') })\n+                .chain({ |pos| parse_type(s, pos, 'e', tm) })\n+                .chain({ |pos| parse_char(s, pos, ' ') })\n+                .chain({ |pos| parse_type(s, pos, 'T', tm) })\n+                .chain({ |pos| parse_char(s, pos, ' ') })\n+                .chain({ |pos| parse_type(s, pos, 'Y', tm) })\n           }\n           'D' | 'x' {\n             parse_type(s, pos, 'm', tm)\n-                .chain { |pos| parse_char(s, pos, '/') }\n-                .chain { |pos| parse_type(s, pos, 'd', tm) }\n-                .chain { |pos| parse_char(s, pos, '/') }\n-                .chain { |pos| parse_type(s, pos, 'y', tm) }\n+                .chain({ |pos| parse_char(s, pos, '/') })\n+                .chain({ |pos| parse_type(s, pos, 'd', tm) })\n+                .chain({ |pos| parse_char(s, pos, '/') })\n+                .chain({ |pos| parse_type(s, pos, 'y', tm) })\n           }\n           'd' {\n             alt match_digits(s, pos, 2u, false) {\n@@ -313,10 +313,10 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n           }\n           'F' {\n             parse_type(s, pos, 'Y', tm)\n-                .chain { |pos| parse_char(s, pos, '-') }\n-                .chain { |pos| parse_type(s, pos, 'm', tm) }\n-                .chain { |pos| parse_char(s, pos, '-') }\n-                .chain { |pos| parse_type(s, pos, 'd', tm) }\n+                .chain({ |pos| parse_char(s, pos, '-') })\n+                .chain({ |pos| parse_type(s, pos, 'm', tm) })\n+                .chain({ |pos| parse_char(s, pos, '-') })\n+                .chain({ |pos| parse_type(s, pos, 'd', tm) })\n           }\n           'H' {\n             // FIXME (#2350): range check.\n@@ -398,17 +398,17 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n           }\n           'R' {\n             parse_type(s, pos, 'H', tm)\n-                .chain { |pos| parse_char(s, pos, ':') }\n-                .chain { |pos| parse_type(s, pos, 'M', tm) }\n+                .chain({ |pos| parse_char(s, pos, ':') })\n+                .chain({ |pos| parse_type(s, pos, 'M', tm) })\n           }\n           'r' {\n             parse_type(s, pos, 'I', tm)\n-                .chain { |pos| parse_char(s, pos, ':') }\n-                .chain { |pos| parse_type(s, pos, 'M', tm) }\n-                .chain { |pos| parse_char(s, pos, ':') }\n-                .chain { |pos| parse_type(s, pos, 'S', tm) }\n-                .chain { |pos| parse_char(s, pos, ' ') }\n-                .chain { |pos| parse_type(s, pos, 'p', tm) }\n+                .chain({ |pos| parse_char(s, pos, ':') })\n+                .chain({ |pos| parse_type(s, pos, 'M', tm) })\n+                .chain({ |pos| parse_char(s, pos, ':') })\n+                .chain({ |pos| parse_type(s, pos, 'S', tm) })\n+                .chain({ |pos| parse_char(s, pos, ' ') })\n+                .chain({ |pos| parse_type(s, pos, 'p', tm) })\n           }\n           'S' {\n             // FIXME (#2350): range check.\n@@ -424,10 +424,10 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n           //'s' {}\n           'T' | 'X' {\n             parse_type(s, pos, 'H', tm)\n-                .chain { |pos| parse_char(s, pos, ':') }\n-                .chain { |pos| parse_type(s, pos, 'M', tm) }\n-                .chain { |pos| parse_char(s, pos, ':') }\n-                .chain { |pos| parse_type(s, pos, 'S', tm) }\n+                .chain({ |pos| parse_char(s, pos, ':') })\n+                .chain({ |pos| parse_type(s, pos, 'M', tm) })\n+                .chain({ |pos| parse_char(s, pos, ':') })\n+                .chain({ |pos| parse_type(s, pos, 'S', tm) })\n           }\n           't' { parse_char(s, pos, '\\t') }\n           'u' {\n@@ -443,10 +443,10 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n           }\n           'v' {\n             parse_type(s, pos, 'e', tm)\n-                .chain { |pos| parse_char(s, pos, '-') }\n-                .chain { |pos| parse_type(s, pos, 'b', tm) }\n-                .chain { |pos| parse_char(s, pos, '-') }\n-                .chain { |pos| parse_type(s, pos, 'Y', tm) }\n+                .chain({ |pos| parse_char(s, pos, '-') })\n+                .chain({ |pos| parse_type(s, pos, 'b', tm) })\n+                .chain({ |pos| parse_char(s, pos, '-') })\n+                .chain({ |pos| parse_type(s, pos, 'Y', tm) })\n           }\n           //'W' {}\n           'w' {\n@@ -526,7 +526,7 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n         }\n     }\n \n-    io::with_str_reader(format) { |rdr|\n+    do io::with_str_reader(format) { |rdr|\n         let tm = {\n             mut tm_sec: 0_i32,\n             mut tm_min: 0_i32,\n@@ -738,7 +738,7 @@ fn strftime(format: str, tm: tm) -> str {\n \n     let mut buf = \"\";\n \n-    io::with_str_reader(format) { |rdr|\n+    do io::with_str_reader(format) { |rdr|\n         while !rdr.eof() {\n             alt rdr.read_char() {\n                 '%' { buf += parse_type(rdr.read_char(), tm); }\n@@ -1002,7 +1002,7 @@ mod tests {\n             }\n         }\n \n-        [\n+        do [\n             \"Sunday\",\n             \"Monday\",\n             \"Tuesday\",\n@@ -1012,7 +1012,7 @@ mod tests {\n             \"Saturday\"\n         ]/_.iter { |day| assert test(day, \"%A\"); }\n \n-        [\n+        do [\n             \"Sun\",\n             \"Mon\",\n             \"Tue\",\n@@ -1022,7 +1022,7 @@ mod tests {\n             \"Sat\"\n         ]/_.iter { |day| assert test(day, \"%a\"); }\n \n-        [\n+        do [\n             \"January\",\n             \"February\",\n             \"March\",\n@@ -1037,7 +1037,7 @@ mod tests {\n             \"December\"\n         ]/_.iter { |day| assert test(day, \"%B\"); }\n \n-        [\n+        do [\n             \"Jan\",\n             \"Feb\",\n             \"Mar\","}, {"sha": "b907944e51a72a373afa73863beba2d700e1078d", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -31,7 +31,7 @@ fn delayed_send<T: copy send>(iotask: iotask,\n             let timer_done_ch_ptr = ptr::addr_of(timer_done_ch);\n             let timer = uv::ll::timer_t();\n             let timer_ptr = ptr::addr_of(timer);\n-            iotask::interact(iotask) {|loop_ptr|\n+            do iotask::interact(iotask) {|loop_ptr|\n                 let init_result = uv::ll::timer_init(loop_ptr, timer_ptr);\n                 if (init_result == 0i32) {\n                     let start_result = uv::ll::timer_start(\n@@ -151,7 +151,7 @@ mod test {\n     #[test]\n     fn test_gl_timer_sleep_stress1() {\n         let hl_loop = uv::global_loop::get();\n-        iter::repeat(200u) {||\n+        do iter::repeat(200u) {||\n             sleep(hl_loop, 1u);\n         }\n     }\n@@ -171,22 +171,22 @@ mod test {\n \n         };\n \n-        iter::repeat(repeat) {||\n+        do iter::repeat(repeat) {||\n \n             for spec.each {|spec|\n                 let (times, maxms) = spec;\n-                task::spawn {||\n+                do task::spawn {||\n                     import rand::*;\n                     let rng = rng();\n-                    iter::repeat(times) {||\n+                    do iter::repeat(times) {||\n                         sleep(hl_loop, rng.next() as uint % maxms);\n                     }\n                     comm::send(ch, ());\n                 }\n             }\n         }\n \n-        iter::repeat(repeat * spec.len()) {||\n+        do iter::repeat(repeat * spec.len()) {||\n             comm::recv(po)\n         }\n     }\n@@ -204,14 +204,14 @@ mod test {\n         let mut failures = 0;\n         let hl_loop = uv::global_loop::get();\n \n-        iter::repeat(times as uint) {||\n+        do iter::repeat(times as uint) {||\n             task::yield();\n \n             let expected = rand::rng().gen_str(16u);\n             let test_po = comm::port::<str>();\n             let test_ch = comm::chan(test_po);\n \n-            task::spawn() {||\n+            do task::spawn() {||\n                 delayed_send(hl_loop, 1u, test_ch, expected);\n             };\n \n@@ -231,12 +231,12 @@ mod test {\n         let mut failures = 0;\n         let hl_loop = uv::global_loop::get();\n \n-        iter::repeat(times as uint) {||\n+        do iter::repeat(times as uint) {||\n             let expected = rand::rng().gen_str(16u);\n             let test_po = comm::port::<str>();\n             let test_ch = comm::chan(test_po);\n \n-            task::spawn() {||\n+            do task::spawn() {||\n                 delayed_send(hl_loop, 1000u, test_ch, expected);\n             };\n "}, {"sha": "6ea7b48ad97ff6cb2a2af41b83451920d60763c2", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -56,12 +56,12 @@ fn get_monitor_task_gl() -> iotask unsafe {\n     #debug(\"before priv::chan_from_global_ptr\");\n     type monchan = chan<iotask>;\n \n-    let monitor_ch = chan_from_global_ptr::<monchan>(monitor_loop_chan_ptr,\n+    let monitor_ch = do chan_from_global_ptr::<monchan>(monitor_loop_chan_ptr,\n                                                      builder_fn) {|msg_po|\n         #debug(\"global monitor task starting\");\n \n         // As a weak task the runtime will notify us when to exit\n-        weaken_task() {|weak_exit_po|\n+        do weaken_task() {|weak_exit_po|\n             #debug(\"global monitor task is now weak\");\n             let hl_loop = spawn_loop();\n             loop {\n@@ -87,19 +87,19 @@ fn get_monitor_task_gl() -> iotask unsafe {\n \n     // once we have a chan to the monitor loop, we ask it for\n     // the libuv loop's async handle\n-    listen { |fetch_ch|\n+    do listen { |fetch_ch|\n         monitor_ch.send(fetch_ch);\n         fetch_ch.recv()\n     }\n }\n \n fn spawn_loop() -> iotask unsafe {\n     let builder = task::builder();\n-    task::add_wrapper(builder) {|task_body|\n+    do task::add_wrapper(builder) {|task_body|\n         fn~(move task_body) {\n             // The I/O loop task also needs to be weak so it doesn't keep\n             // the runtime alive\n-            weaken_task {|weak_exit_po|\n+            do weaken_task {|weak_exit_po|\n                 #debug(\"global libuv task is now weak %?\", weak_exit_po);\n                 task_body();\n \n@@ -129,7 +129,7 @@ mod test {\n         log(debug, \"in simple timer cb\");\n         ll::timer_stop(timer_ptr);\n         let hl_loop = get_gl();\n-        iotask::interact(hl_loop) {|_loop_ptr|\n+        do iotask::interact(hl_loop) {|_loop_ptr|\n             log(debug, \"closing timer\");\n             ll::close(timer_ptr, simple_timer_close_cb);\n             log(debug, \"about to deref exit_ch_ptr\");\n@@ -146,7 +146,7 @@ mod test {\n                        exit_ch_ptr));\n         let timer_handle = ll::timer_t();\n         let timer_ptr = ptr::addr_of(timer_handle);\n-        iotask::interact(iotask) {|loop_ptr|\n+        do iotask::interact(iotask) {|loop_ptr|\n             log(debug, \"user code inside interact loop!!!\");\n             let init_status = ll::timer_init(loop_ptr, timer_ptr);\n             if(init_status == 0i32) {\n@@ -191,13 +191,13 @@ mod test {\n         let exit_po = comm::port::<()>();\n         let exit_ch = comm::chan(exit_po);\n         let cycles = 5000u;\n-        iter::repeat(cycles) {||\n+        do iter::repeat(cycles) {||\n             task::spawn_sched(task::manual_threads(1u), {||\n                 impl_uv_hl_simple_timer(hl_loop);\n                 comm::send(exit_ch, ());\n             });\n         };\n-        iter::repeat(cycles) {||\n+        do iter::repeat(cycles) {||\n             comm::recv(exit_po);\n         };\n         log(debug, \"test_stress_gl_uv_global_loop_high_level_global_timer\"+"}, {"sha": "625a261b6f5a7e05f3a7d236f0f716d2ed37db3a", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -39,9 +39,9 @@ fn spawn_iotask(-builder: task::builder) -> iotask {\n         with get_opts(builder)\n     });\n \n-    listen {|iotask_ch|\n+    do listen {|iotask_ch|\n \n-        run(copy(builder)) {||\n+        do run(copy(builder)) {||\n             #debug(\"entering libuv task\");\n             run_loop(iotask_ch);\n             #debug(\"libuv task exiting\");\n@@ -211,7 +211,7 @@ mod test {\n             exit_ch: exit_ch\n         };\n         let ah_data_ptr = ptr::addr_of(ah_data);\n-        interact(iotask) {|loop_ptr|\n+        do interact(iotask) {|loop_ptr|\n             ll::async_init(loop_ptr, ah_ptr, async_handle_cb);\n             ll::set_data_for_uv_handle(ah_ptr, ah_data_ptr as *libc::c_void);\n             ll::async_send(ah_ptr);\n@@ -224,7 +224,7 @@ mod test {\n     unsafe fn spawn_test_loop(exit_ch: comm::chan<()>) -> iotask {\n         let iotask_port = comm::port::<iotask>();\n         let iotask_ch = comm::chan(iotask_port);\n-        task::spawn_sched(task::manual_threads(1u)) {||\n+        do task::spawn_sched(task::manual_threads(1u)) {||\n             run_loop(iotask_ch);\n             exit_ch.send(());\n         };\n@@ -255,13 +255,13 @@ mod test {\n         // called, at least.\n         let work_exit_po = comm::port::<()>();\n         let work_exit_ch = comm::chan(work_exit_po);\n-        iter::repeat(7u) {||\n-            task::spawn_sched(task::manual_threads(1u), {||\n+        do iter::repeat(7u) {||\n+            do task::spawn_sched(task::manual_threads(1u)) {||\n                 impl_uv_iotask_async(iotask);\n                 comm::send(work_exit_ch, ());\n-            });\n+            };\n         };\n-        iter::repeat(7u) {||\n+        do iter::repeat(7u) {||\n             comm::recv(work_exit_po);\n         };\n         log(debug, \"sending teardown_loop msg..\");"}, {"sha": "bb8eac6d528a79e18916376e5aad50c1a6ebc8d5", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -1262,7 +1262,7 @@ mod test {\n         let continue_chan = comm::chan::<bool>(continue_port);\n         let continue_chan_ptr = ptr::addr_of(continue_chan);\n \n-        task::spawn_sched(task::manual_threads(1u)) {||\n+        do task::spawn_sched(task::manual_threads(1u)) {||\n             impl_uv_tcp_server(bind_ip, port,\n                                kill_server_msg,\n                                server_resp_msg,\n@@ -1275,7 +1275,7 @@ mod test {\n         comm::recv(continue_port);\n         log(debug, \"received on continue port, set up tcp client\");\n \n-        task::spawn_sched(task::manual_threads(1u)) {||\n+        do task::spawn_sched(task::manual_threads(1u)) {||\n             impl_uv_tcp_request(request_ip, port,\n                                kill_server_msg,\n                                ptr::addr_of(client_chan));"}, {"sha": "f393f37dfb97b5ce34f7a15ea673c05af29f951e", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -11,7 +11,7 @@ type path = ~[path_elt];\n \n /* FIXMEs that say \"bad\" are as per #2543 */\n fn path_to_str_with_sep(p: path, sep: str) -> str {\n-    let strs = vec::map(p) {|e|\n+    let strs = do vec::map(p) {|e|\n         alt e {\n           path_mod(s) { /* FIXME (#2543) */ copy *s }\n           path_name(s) { /* FIXME (#2543) */ copy *s }\n@@ -156,7 +156,7 @@ fn map_block(b: blk, cx: ctx, v: vt) {\n }\n \n fn number_pat(cx: ctx, pat: @pat) {\n-    ast_util::walk_pat(pat) {|p|\n+    do ast_util::walk_pat(pat) {|p|\n         alt p.node {\n           pat_ident(_, _) {\n             cx.map.insert(p.id, node_local(cx.local_id));\n@@ -218,12 +218,12 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n           let (_, ms) = ast_util::split_class_items(items);\n           // Map iface refs to their parent classes. This is\n           // so we can find the self_ty\n-          vec::iter(ifces) {|p| cx.map.insert(p.id,\n+          do vec::iter(ifces) {|p| cx.map.insert(p.id,\n                                   node_item(i, item_path)); };\n           let d_id = ast_util::local_def(i.id);\n           let p = extend(cx, i.ident);\n            // only need to handle methods\n-          vec::iter(ms) {|m| map_method(d_id, p, m, cx); }\n+          do vec::iter(ms) {|m| map_method(d_id, p, m, cx); }\n       }\n       _ { }\n     }"}, {"sha": "fdb6d4dc7d999027b60d1c13bb777b74db9184c7", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -408,7 +408,7 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n             alt vi.node {\n               view_item_use(_, _, id) { vfn(id) }\n               view_item_import(vps) | view_item_export(vps) {\n-                vec::iter(vps) {|vp|\n+                do vec::iter(vps) {|vp|\n                     alt vp.node {\n                       view_path_simple(_, _, id) { vfn(id) }\n                       view_path_glob(_, id) { vfn(id) }\n@@ -473,7 +473,7 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n         },\n \n         visit_ty_params: fn@(ps: ~[ty_param]) {\n-            vec::iter(ps) {|p| vfn(p.id) }\n+            vec::iter(ps, {|p| vfn(p.id) })\n         },\n \n         visit_constr: fn@(_p: @path, _sp: span, id: node_id) {\n@@ -486,23 +486,23 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n \n             alt fk {\n               visit::fk_ctor(nm, tps, self_id, parent_id) {\n-                vec::iter(tps) {|tp| vfn(tp.id)}\n+                vec::iter(tps, {|tp| vfn(tp.id)});\n                 vfn(id);\n                 vfn(self_id);\n                 vfn(parent_id.node);\n               }\n               visit::fk_dtor(tps, self_id, parent_id) {\n-                vec::iter(tps) {|tp| vfn(tp.id)}\n+                vec::iter(tps, {|tp| vfn(tp.id)});\n                 vfn(id);\n                 vfn(self_id);\n                 vfn(parent_id.node);\n               }\n               visit::fk_item_fn(_, tps) {\n-                vec::iter(tps) {|tp| vfn(tp.id)}\n+                vec::iter(tps, {|tp| vfn(tp.id)});\n               }\n               visit::fk_method(_, tps, m) {\n                 vfn(m.self_id);\n-                vec::iter(tps) {|tp| vfn(tp.id)}\n+                vec::iter(tps, {|tp| vfn(tp.id)});\n               }\n               visit::fk_anon(_, capture_clause)\n               | visit::fk_fn_block(capture_clause) {\n@@ -512,7 +512,7 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n               }\n             }\n \n-            vec::iter(d.inputs) {|arg|\n+            do vec::iter(d.inputs) {|arg|\n                 vfn(arg.id)\n             }\n         },\n@@ -536,15 +536,15 @@ fn visit_ids_for_inlined_item(item: inlined_item, vfn: fn@(node_id)) {\n fn compute_id_range(visit_ids_fn: fn(fn@(node_id))) -> id_range {\n     let min = @mut int::max_value;\n     let max = @mut int::min_value;\n-    visit_ids_fn { |id|\n+    do visit_ids_fn { |id|\n         *min = int::min(*min, id);\n         *max = int::max(*max, id + 1);\n     }\n     ret {min:*min, max:*max};\n }\n \n fn compute_id_range_for_inlined_item(item: inlined_item) -> id_range {\n-    compute_id_range { |f| visit_ids_for_inlined_item(item, f) }\n+    compute_id_range({ |f| visit_ids_for_inlined_item(item, f) })\n }\n \n pure fn is_item_impl(item: @ast::item) -> bool {"}, {"sha": "08e2fd6c9b8115dcc1c60567e36b4659856e9552", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -315,7 +315,7 @@ From a list of crate attributes get only the meta_items that impact crate\n linkage\n \"]\n fn find_linkage_metas(attrs: ~[ast::attribute]) -> ~[@ast::meta_item] {\n-    find_linkage_attrs(attrs).flat_map {|attr|\n+    do find_linkage_attrs(attrs).flat_map {|attr|\n         alt check attr.node.value.node {\n           ast::meta_list(_, items) { /* FIXME (#2543) */ copy items }\n         }\n@@ -351,7 +351,7 @@ enum inline_attr {\n #[doc = \"True if something like #[inline] is found in the list of attrs.\"]\n fn find_inline_attr(attrs: ~[ast::attribute]) -> inline_attr {\n     // TODO---validate the usage of #[inline] and #[inline(always)]\n-    vec::foldl(ia_none, attrs) {|ia,attr|\n+    do vec::foldl(ia_none, attrs) {|ia,attr|\n         alt attr.node.value.node {\n           ast::meta_word(@\"inline\") { ia_hint }\n           ast::meta_list(@\"inline\", items) {"}, {"sha": "56017cd1f2761c43246897f969b09c7f596bcc4a", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -249,7 +249,7 @@ fn highlight_lines(cm: codemap::codemap, sp: span,\n }\n \n fn print_macro_backtrace(cm: codemap::codemap, sp: span) {\n-    option::iter (sp.expn_info) {|ei|\n+    do option::iter (sp.expn_info) {|ei|\n         let ss = option::map_default(ei.callie.span, @\"\", {\n             |span|\n             @codemap::span_to_str(span, cm)"}, {"sha": "487a435df468bc9081f8909a0620561ad8d84d14", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -100,7 +100,7 @@ fn expand(cx: ext_ctxt,\n           with *item}\n     }\n \n-    vec::flat_map(in_items) {|in_item|\n+    do vec::flat_map(in_items) {|in_item|\n         alt in_item.node {\n           ast::item_ty(ty, tps, _) {\n             vec::append(~[filter_attrs(in_item)],\n@@ -151,7 +151,7 @@ impl helpers for ext_ctxt {\n     fn ty_fn(span: span,\n              -input_tys: ~[@ast::ty],\n              -output: @ast::ty) -> @ast::ty {\n-        let args = vec::map(input_tys) {|ty|\n+        let args = do vec::map(input_tys) {|ty|\n             {mode: ast::expl(ast::by_ref),\n              ty: ty,\n              ident: @\"\",\n@@ -294,7 +294,7 @@ fn ser_path(cx: ext_ctxt, tps: ser_tps_map, path: @ast::path,\n             ast::expr_path(\n                 cx.helper_path(path, \"serialize\")));\n \n-    let ty_args = vec::map(path.types) {|ty|\n+    let ty_args = do vec::map(path.types) {|ty|\n         let sv_stmts = ser_ty(cx, tps, ty, cx.clone(s), #ast{ __v });\n         let sv = cx.expr(path.span,\n                          ast::expr_block(cx.blk(path.span, sv_stmts)));\n@@ -316,12 +316,14 @@ fn ser_variant(cx: ext_ctxt,\n                bodyfn: fn(-@ast::expr, ast::blk) -> @ast::expr,\n                argfn: fn(-@ast::expr, uint, ast::blk) -> @ast::expr)\n     -> ast::arm {\n-    let vnames = vec::from_fn(vec::len(tys)) {|i| @#fmt[\"__v%u\", i]};\n-    let pats = vec::from_fn(vec::len(tys)) {|i|\n+    let vnames = do vec::from_fn(vec::len(tys)) {|i|\n+        @#fmt[\"__v%u\", i]\n+    };\n+    let pats = do vec::from_fn(vec::len(tys)) {|i|\n         cx.binder_pat(tys[i].span, vnames[i])\n     };\n     let pat: @ast::pat = @{id: cx.next_id(), node: pfn(pats), span: span};\n-    let stmts = vec::from_fn(vec::len(tys)) {|i|\n+    let stmts = do vec::from_fn(vec::len(tys)) {|i|\n         let v = cx.var_ref(span, vnames[i]);\n         let arg_blk =\n             cx.blk(\n@@ -374,7 +376,7 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n       }\n \n       ast::ty_rec(flds) {\n-        let fld_stmts = vec::from_fn(vec::len(flds)) {|fidx|\n+        let fld_stmts = do vec::from_fn(vec::len(flds)) {|fidx|\n             let fld = flds[fidx];\n             let vf = cx.expr(fld.span,\n                              ast::expr_field(cx.clone(v),\n@@ -516,7 +518,7 @@ fn mk_ser_fn(cx: ext_ctxt, span: span, name: ast::ident,\n                     tp_inputs);\n \n     let tps_map = map::str_hash();\n-    vec::iter2(tps, tp_inputs) {|tp, arg|\n+    do vec::iter2(tps, tp_inputs) {|tp, arg|\n         let arg_ident = arg.ident;\n         tps_map.insert(\n             *tp.ident,\n@@ -537,7 +539,7 @@ fn mk_ser_fn(cx: ext_ctxt, span: span, name: ast::ident,\n         vec::append(~[{ident: @\"__S\",\n                       id: cx.next_id(),\n                       bounds: ser_bnds}],\n-                    vec::map(tps) {|tp| cx.clone_ty_param(tp) });\n+                    vec::map(tps, {|tp| cx.clone_ty_param(tp) }));\n \n     let ser_output: @ast::ty = @{id: cx.next_id(),\n                                  node: ast::ty_nil,\n@@ -573,7 +575,7 @@ fn deser_path(cx: ext_ctxt, tps: deser_tps_map, path: @ast::path,\n             ast::expr_path(\n                 cx.helper_path(path, \"deserialize\")));\n \n-    let ty_args = vec::map(path.types) {|ty|\n+    let ty_args = do vec::map(path.types) {|ty|\n         let dv_expr = deser_ty(cx, tps, ty, cx.clone(d));\n         cx.lambda(cx.expr_blk(dv_expr))\n     };\n@@ -616,7 +618,7 @@ fn deser_ty(cx: ext_ctxt, tps: deser_tps_map,\n       }\n \n       ast::ty_rec(flds) {\n-        let fields = vec::from_fn(vec::len(flds)) {|fidx|\n+        let fields = do vec::from_fn(vec::len(flds)) {|fidx|\n             let fld = flds[fidx];\n             let d = cx.clone(d);\n             let f = cx.lit_str(fld.span, fld.node.ident);\n@@ -645,7 +647,7 @@ fn deser_ty(cx: ext_ctxt, tps: deser_tps_map,\n         //    d.read_tup_elt(2u, {||...}))\n         // }\n \n-        let arg_exprs = vec::from_fn(vec::len(tys)) {|i|\n+        let arg_exprs = do vec::from_fn(vec::len(tys)) {|i|\n             let idx = cx.lit_uint(ty.span, i);\n             let body = deser_lambda(cx, tps, tys[i], cx.clone(d));\n             #ast{ $(d).read_tup_elt($(idx), $(body)) }\n@@ -723,7 +725,7 @@ fn mk_deser_fn(cx: ext_ctxt, span: span,\n                     tp_inputs);\n \n     let tps_map = map::str_hash();\n-    vec::iter2(tps, tp_inputs) {|tp, arg|\n+    do vec::iter2(tps, tp_inputs) {|tp, arg|\n         let arg_ident = arg.ident;\n         tps_map.insert(\n             *tp.ident,\n@@ -743,12 +745,12 @@ fn mk_deser_fn(cx: ext_ctxt, span: span,\n         vec::append(~[{ident: @\"__D\",\n                       id: cx.next_id(),\n                       bounds: deser_bnds}],\n-                    vec::map(tps) {|tp|\n+                    vec::map(tps, {|tp|\n                         let cloned = cx.clone_ty_param(tp);\n                         {bounds: @(vec::append(*cloned.bounds,\n                                                ~[ast::bound_copy]))\n                          with cloned}\n-                    });\n+                    }));\n \n     let deser_blk = cx.expr_blk(f(cx, tps_map, #ast(expr){__d}));\n \n@@ -781,11 +783,11 @@ fn ser_enum(cx: ext_ctxt, tps: ser_tps_map, e_name: ast::ident,\n             e_span: span, variants: ~[ast::variant],\n             -s: @ast::expr, -v: @ast::expr) -> ~[@ast::stmt] {\n     let ext_cx = cx;\n-    let arms = vec::from_fn(vec::len(variants)) {|vidx|\n+    let arms = do vec::from_fn(vec::len(variants)) {|vidx|\n         let variant = variants[vidx];\n         let v_span = variant.span;\n         let v_name = variant.node.name;\n-        let variant_tys = vec::map(variant.node.args) {|a| a.ty };\n+        let variant_tys = vec::map(variant.node.args, {|a| a.ty });\n \n         ser_variant(\n             cx, tps, variant_tys, v_span, cx.clone(s),\n@@ -830,13 +832,13 @@ fn deser_enum(cx: ext_ctxt, tps: deser_tps_map, e_name: ast::ident,\n               e_span: span, variants: ~[ast::variant],\n               -d: @ast::expr) -> @ast::expr {\n     let ext_cx = cx;\n-    let arms: ~[ast::arm] = vec::from_fn(vec::len(variants)) {|vidx|\n+    let arms: ~[ast::arm] = do vec::from_fn(vec::len(variants)) {|vidx|\n         let variant = variants[vidx];\n         let v_span = variant.span;\n         let v_name = variant.node.name;\n-        let tys = vec::map(variant.node.args) {|a| a.ty };\n+        let tys = vec::map(variant.node.args, {|a| a.ty });\n \n-        let arg_exprs = vec::from_fn(vec::len(tys)) {|i|\n+        let arg_exprs = do vec::from_fn(vec::len(tys)) {|i|\n             let idx = cx.lit_uint(v_span, i);\n             let body = deser_lambda(cx, tps, tys[i], cx.clone(d));\n             #ast{ $(d).read_enum_variant_arg($(idx), $(body)) }"}, {"sha": "1b7abc213948492df6b82229d4c5898cb052eaf5", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -100,8 +100,8 @@ fn expand_mod_items(exts: hashmap<str, syntax_extension>, cx: ext_ctxt,\n     // For each item, look through the attributes.  If any of them are\n     // decorated with \"item decorators\", then use that function to transform\n     // the item into a new set of items.\n-    let new_items = vec::flat_map(module.items) {|item|\n-        vec::foldr(item.attrs, ~[item]) {|attr, items|\n+    let new_items = do vec::flat_map(module.items) {|item|\n+        do vec::foldr(item.attrs, ~[item]) {|attr, items|\n             let mname = alt attr.node.value.node {\n               ast::meta_word(n) { n }\n               ast::meta_name_value(n, _) { n }"}, {"sha": "367a0dcea50533a08f951fdcc93413450a731ac3", "filename": "src/libsyntax/ext/qquote.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -106,7 +106,7 @@ fn gather_anti_quotes<N: qq_helper>(lo: uint, node: N) -> aq_ctxt\n     node.visit(cx, mk_vt(v));\n     // FIXME (#2250): Maybe this is an overkill (merge_sort), it might\n     // be better to just keep the gather array in sorted order.\n-    cx.gather.swap { |v|\n+    do cx.gather.swap { |v|\n         vec::to_mut(std::sort::merge_sort({|a,b| a.lo < b.lo}, v))\n     };\n     ret cx;\n@@ -132,7 +132,7 @@ fn expand_ast(ecx: ext_ctxt, _sp: span,\n     -> @ast::expr\n {\n     let mut what = \"expr\";\n-    option::iter(arg) {|arg|\n+    do option::iter(arg) {|arg|\n         let args: ~[@ast::expr] =\n             alt arg.node {\n               ast::expr_vec(elts, _) { elts }\n@@ -205,7 +205,7 @@ fn finish<T: qq_helper>\n     let mut state = active;\n     let mut i = 0u, j = 0u;\n     let g_len = cx.gather.len();\n-    str::chars_iter(*str) {|ch|\n+    do str::chars_iter(*str) {|ch|\n         if (j < g_len && i == cx.gather[j].lo) {\n             assert ch == '$';\n             let repl = #fmt(\"$%u \", j);\n@@ -259,11 +259,11 @@ fn finish<T: qq_helper>\n         rcall = mk_call(cx,sp,\n                         ~[@\"syntax\", @\"ext\", @\"qquote\", @\"replace\"],\n                         ~[pcall,\n-                         mk_uniq_vec_e(cx,sp, qcx.gather.map_to_vec {|g|\n+                         mk_uniq_vec_e(cx,sp, qcx.gather.map_to_vec({|g|\n                              mk_call(cx,sp,\n                                      ~[@\"syntax\", @\"ext\",\n                                       @\"qquote\", @g.constr],\n-                                     ~[g.e])}),\n+                                     ~[g.e])})),\n                          mk_path(cx,sp,\n                                  ~[@\"syntax\", @\"ext\", @\"qquote\",\n                                   @node.get_fold_fn()])]);"}, {"sha": "cc3a4d04d068f2d44c43c34808001e1725fb3406", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -276,7 +276,7 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n             let mut repeat: option<{rep_count: uint, name: ident}> = none;\n             /* we need to walk over all the free vars in lockstep, except for\n             the leaves, which are just duplicated */\n-            free_vars(b, repeat_me) {|fv|\n+            do free_vars(b, repeat_me) {|fv|\n                 let cur_pos = follow(b.get(fv), idx_path);\n                 alt cur_pos {\n                   leaf(_) { }"}, {"sha": "51feb53b2b3f2639c389272832543432a4baefae", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -88,9 +88,9 @@ fn expand_include_bin(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n \n     alt io::read_whole_file(res_rel_file(cx, sp, file)) {\n       result::ok(src) {\n-        let u8_exprs = vec::map(src) { |char: u8|\n+        let u8_exprs = vec::map(src, { |char: u8|\n             mk_lit(cx, sp, ast::lit_uint(char as u64, ast::ty_u8))\n-        };\n+        });\n         ret mk_uniq_vec_e(cx, sp, u8_exprs);\n       }\n       result::err(e) {"}, {"sha": "dbe09a31dd27b36612f5130ffe906557190691ed", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -255,7 +255,7 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n               let ctor_body = fld.fold_block(ctor.node.body);\n               let ctor_decl = fold_fn_decl(ctor.node.dec, fld);\n               let ctor_id   = fld.new_id(ctor.node.id);\n-              let dtor = option::map(m_dtor) {|dtor|\n+              let dtor = do option::map(m_dtor) {|dtor|\n                 let dtor_body = fld.fold_block(dtor.node.body);\n                 let dtor_id   = fld.new_id(dtor.node.id);\n                 {node: {body: dtor_body,\n@@ -273,7 +273,7 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n           item_impl(tps, rp, ifce, ty, methods) {\n               item_impl(fold_ty_params(tps, fld),\n                         rp,\n-                        ifce.map { |p| fold_iface_ref(p, fld) },\n+                        ifce.map({ |p| fold_iface_ref(p, fld) }),\n                         fld.fold_ty(ty),\n                         vec::map(methods, fld.fold_method))\n           }\n@@ -332,8 +332,8 @@ fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n           }\n           pat_lit(e) { pat_lit(fld.fold_expr(e)) }\n           pat_enum(pth, pats) {\n-              pat_enum(fld.fold_path(pth), option::map(pats)\n-                       {|pats| vec::map(pats, fld.fold_pat)})\n+              pat_enum(fld.fold_path(pth), option::map(pats,\n+                       {|pats| vec::map(pats, fld.fold_pat)}))\n           }\n           pat_rec(fields, etc) {\n             let mut fs = ~[];\n@@ -490,9 +490,9 @@ fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n       ty_vec(mt) {ty_vec(fold_mt(mt, fld))}\n       ty_ptr(mt) {ty_ptr(fold_mt(mt, fld))}\n       ty_rptr(region, mt) {ty_rptr(region, fold_mt(mt, fld))}\n-      ty_rec(fields) {ty_rec(vec::map(fields) {|f| fold_field(f, fld)})}\n+      ty_rec(fields) {ty_rec(vec::map(fields, {|f| fold_field(f, fld)}))}\n       ty_fn(proto, decl) {ty_fn(proto, fold_fn_decl(decl, fld))}\n-      ty_tup(tys) {ty_tup(vec::map(tys) {|ty| fld.fold_ty(ty)})}\n+      ty_tup(tys) {ty_tup(vec::map(tys, {|ty| fld.fold_ty(ty)}))}\n       ty_path(path, id) {ty_path(fld.fold_path(path), fld.new_id(id))}\n       ty_constr(ty, constrs) {ty_constr(fld.fold_ty(ty),\n                                 vec::map(constrs, fld.fold_ty_constr))}"}, {"sha": "da09b5daf27a5ccf11424ca220cb03d292d30e8f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -159,7 +159,7 @@ class parser {\n     }\n \n     fn parse_ty_fn_decl(purity: ast::purity) -> fn_decl {\n-        let inputs = self.parse_unspanned_seq(\n+        let inputs = do self.parse_unspanned_seq(\n             token::LPAREN, token::RPAREN,\n             seq_sep_trailing_disallowed(token::COMMA)) { |p|\n             let mode = p.parse_arg_mode();\n@@ -186,7 +186,7 @@ class parser {\n     }\n \n     fn parse_ty_methods() -> ~[ty_method] {\n-        self.parse_unspanned_seq(token::LBRACE, token::RBRACE,\n+        do self.parse_unspanned_seq(token::LBRACE, token::RBRACE,\n                                  seq_sep_none()) { |p|\n             let attrs = p.parse_outer_attributes();\n             let flo = p.span.lo;\n@@ -494,11 +494,11 @@ class parser {\n     }\n \n     fn parse_arg_or_capture_item() -> arg_or_capture_item {\n-        self.parse_capture_item_or() {|p| p.parse_arg() }\n+        self.parse_capture_item_or({|p| p.parse_arg() })\n     }\n \n     fn parse_fn_block_arg() -> arg_or_capture_item {\n-        self.parse_capture_item_or() {|p|\n+        do self.parse_capture_item_or {|p|\n             let m = p.parse_arg_mode();\n             let i = p.parse_value_ident();\n             let t = if p.eat(token::COLON) {\n@@ -2065,7 +2065,7 @@ class parser {\n               members(mms) { ms = vec::append(ms, mms); }\n             }\n         }\n-        let actual_dtor = option::map(the_dtor) {|dtor|\n+        let actual_dtor = do option::map(the_dtor) {|dtor|\n             let (d_body, d_s) = dtor;\n             {node: {id: self.get_id(),\n                     self_id: self.get_id(),"}, {"sha": "9a994afb1492007e1a3639a351ae164e07a1968b", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -511,7 +511,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n           print_fn_args_and_ret(s, ctor.node.dec, ~[]);\n           space(s.s);\n           print_block(s, ctor.node.body);\n-          option::iter(m_dtor) {|dtor|\n+          do option::iter(m_dtor) {|dtor|\n             hardbreak_if_not_bol(s);\n             maybe_print_comment(s, dtor.span.lo);\n             head(s, \"drop\");\n@@ -1136,8 +1136,8 @@ fn print_decl(s: ps, decl: @ast::decl) {\n         word_nbsp(s, \"let\");\n \n         // if any are mut, all are mut\n-        if vec::any(locs) {|l| l.node.is_mutbl } {\n-            assert vec::all(locs) {|l| l.node.is_mutbl };\n+        if vec::any(locs, {|l| l.node.is_mutbl }) {\n+            assert vec::all(locs, {|l| l.node.is_mutbl });\n             word_nbsp(s, \"mut\");\n         }\n \n@@ -1405,7 +1405,7 @@ fn print_view_path(s: ps, &&vp: @ast::view_path) {\n       ast::view_path_list(path, idents, _) {\n         print_path(s, path, false);\n         word(s.s, \"::{\");\n-        commasep(s, inconsistent, idents) {|s, w|\n+        do commasep(s, inconsistent, idents) {|s, w|\n             word(s.s, *w.node.name)\n         }\n         word(s.s, \"}\");"}, {"sha": "4e8f1028bcdc44c28593f8ba6100f923adefd6ba", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -151,7 +151,7 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n           for ifaces.each {|p| visit_path(p.path, e, v); }\n           visit_class_ctor_helper(ctor, i.ident, tps,\n                                   ast_util::local_def(i.id), e, v);\n-          option::iter(m_dtor) {|dtor|\n+          do option::iter(m_dtor) {|dtor|\n                   visit_class_dtor_helper(dtor, tps,\n                      ast_util::local_def(i.id), e, v)};\n       }\n@@ -227,7 +227,7 @@ fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n     alt p.node {\n       pat_enum(path, children) {\n         visit_path(path, e, v);\n-        option::iter(children) {|children|\n+        do option::iter(children) {|children|\n                 for children.each {|child| v.visit_pat(child, e, v); }}\n       }\n       pat_rec(fields, _) {\n@@ -239,7 +239,7 @@ fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n       }\n       pat_ident(path, inner) {\n           visit_path(path, e, v);\n-          option::iter(inner) {|subpat| v.visit_pat(subpat, e, v)};\n+          do option::iter(inner) {|subpat| v.visit_pat(subpat, e, v)};\n       }\n       pat_lit(ex) { v.visit_expr(ex, e, v); }\n       pat_range(e1, e2) { v.visit_expr(e1, e, v); v.visit_expr(e2, e, v); }\n@@ -344,7 +344,7 @@ fn visit_exprs<E>(exprs: ~[@expr], e: E, v: vt<E>) {\n fn visit_mac<E>(m: mac, e: E, v: vt<E>) {\n     alt m.node {\n       ast::mac_invoc(pth, arg, body) {\n-        option::map(arg) {|arg| v.visit_expr(arg, e, v)}; }\n+        option::map(arg, {|arg| v.visit_expr(arg, e, v)}); }\n       ast::mac_invoc_tt(pth, tt) { /* no user-serviceable parts inside */ }\n       ast::mac_embed_type(ty) { v.visit_ty(ty, e, v); }\n       ast::mac_embed_block(blk) { v.visit_block(blk, e, v); }"}, {"sha": "4bdf5ae311b5cb187641a776c5bd954cf94adfae", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -443,7 +443,7 @@ fn get_symbol_hash(ccx: @crate_ctxt, t: ty::t) -> str {\n // gas doesn't!\n fn sanitize(s: str) -> str {\n     let mut result = \"\";\n-    str::chars_iter(s) {|c|\n+    do str::chars_iter(s) {|c|\n         alt c {\n           '@' { result += \"_sbox_\"; }\n           '~' { result += \"_ubox_\"; }"}, {"sha": "806f6cded59cd495d4910a93ca40cad3349ce5c8", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -322,7 +322,7 @@ fn pretty_print_input(sess: session, cfg: ast::crate_cfg, input: input,\n     };\n     let is_expanded = upto != cu_parse;\n     let src = codemap::get_filemap(sess.codemap, source_name(input)).src;\n-    io::with_str_reader(*src) { |rdr|\n+    do io::with_str_reader(*src) { |rdr|\n         pprust::print_crate(sess.codemap, sess.span_diagnostic, crate,\n                             source_name(input),\n                             rdr, io::stdout(), ann, is_expanded);\n@@ -417,7 +417,7 @@ fn build_session_options(match: getopts::match,\n     let lint_flags = vec::append(getopts::opt_strs(match, \"W\"),\n                                  getopts::opt_strs(match, \"warn\"));\n     let lint_dict = lint::get_lint_dict();\n-    let lint_opts = vec::map(lint_flags) {|flag|\n+    let lint_opts = do vec::map(lint_flags) {|flag|\n         alt lint::lookup_lint(lint_dict, flag) {\n           (flag, none) {\n             early_error(demitter, #fmt(\"unknown warning: %s\", flag))"}, {"sha": "68cfb22fab169d40941c7cad14ecc3edf405d083", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -211,7 +211,7 @@ fn monitor(+f: fn~(diagnostic::emitter)) {\n     let p = comm::port();\n     let ch = comm::chan(p);\n \n-    alt task::try  {||\n+    alt do task::try  {||\n \n         // The 'diagnostics emitter'. Every error, warning, etc. should\n         // go through this function.\n@@ -259,7 +259,7 @@ fn monitor(+f: fn~(diagnostic::emitter)) {\n }\n \n fn main(args: ~[str]) {\n-    monitor {|demitter|\n+    do monitor {|demitter|\n         run_compiler(args, demitter);\n     }\n }"}, {"sha": "58976b6be3695b9c41ff296ae515326733eb1552", "filename": "src/rustc/front/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fconfig.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -13,7 +13,7 @@ type ctxt = @{\n // Support conditional compilation by transforming the AST, stripping out\n // any items that do not belong in the current configuration\n fn strip_unconfigured_items(crate: @ast::crate) -> @ast::crate {\n-    strip_items(crate) {|attrs|\n+    do strip_items(crate) {|attrs|\n         in_cfg(crate.node.config, attrs)\n     }\n }"}, {"sha": "1f71352b0f32ae76adf4c6be68372efa178f829d", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -57,7 +57,7 @@ fn generate_test_harness(sess: session::session,\n fn strip_test_functions(crate: @ast::crate) -> @ast::crate {\n     // When not compiling with --test we should not compile the\n     // #[test] functions\n-    config::strip_items(crate) {|attrs|\n+    do config::strip_items(crate) {|attrs|\n         !attr::contains_name(attr::attr_metas(attrs), \"test\")\n     }\n }"}, {"sha": "aec77c13633fc3d9527fc4a4415397f7fee2ab55", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -68,14 +68,14 @@ fn warn_if_multiple_versions(diag: span_handler,\n     if crate_cache.len() != 0u {\n         let name = loader::crate_name_from_metas(*crate_cache.last().metas);\n         let {lefts: matches, rights: non_matches} =\n-            partition(crate_cache.map_to_vec {|entry|\n+            partition(crate_cache.map_to_vec({|entry|\n                 let othername = loader::crate_name_from_metas(*entry.metas);\n                 if name == othername {\n                     left(entry)\n                 } else {\n                     right(entry)\n                 }\n-            });\n+            }));\n \n         assert matches.is_not_empty();\n "}, {"sha": "14877cf7971b8928de57cfb2e61bffe0cfbd9a52", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -120,7 +120,7 @@ fn get_impls_for_mod(cstore: cstore::cstore, def: ast::def_id,\n                      name: option<ast::ident>)\n     -> @~[@decoder::_impl] {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n-    decoder::get_impls_for_mod(cdata, def.node, name) {|cnum|\n+    do decoder::get_impls_for_mod(cdata, def.node, name) {|cnum|\n         cstore::get_crate_data(cstore, cnum)\n     }\n }"}, {"sha": "cfdc1f555a497a6667a125da3605ddc7dd4dbf62", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -96,7 +96,7 @@ fn get_crate_vers(cstore: cstore, cnum: ast::crate_num) -> @str {\n fn set_crate_data(cstore: cstore, cnum: ast::crate_num,\n                   data: crate_metadata) {\n     p(cstore).metas.insert(cnum, data);\n-    vec::iter(decoder::get_crate_module_paths(data.data)) {|dp|\n+    do vec::iter(decoder::get_crate_module_paths(data.data)) {|dp|\n         let (did, path) = dp;\n         let d = {crate: cnum, node: did.node};\n         p(cstore).mod_path_map.insert(d, @path);"}, {"sha": "b738bd2ed8cc12e5492aa52c478116cd177617f5", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -64,7 +64,7 @@ fn lookup_hash(d: ebml::doc, eq_fn: fn@(~[u8]) -> bool, hash: uint) ->\n \n     let mut result: ~[ebml::doc] = ~[];\n     let belt = tag_index_buckets_bucket_elt;\n-    ebml::tagged_docs(bucket, belt) {|elt|\n+    do ebml::tagged_docs(bucket, belt) {|elt|\n         let pos = io::u64_from_be_bytes(*elt.data, elt.start, 4u) as uint;\n         if eq_fn(vec::slice::<u8>(*elt.data, elt.start + 4u, elt.end)) {\n             vec::push(result, ebml::doc_at(d.data, pos).doc);\n@@ -110,7 +110,7 @@ fn item_symbol(item: ebml::doc) -> str {\n \n fn item_parent_item(d: ebml::doc) -> option<ast::def_id> {\n     let mut found = none;\n-    ebml::tagged_docs(d, tag_items_data_parent_item) {|did|\n+    do ebml::tagged_docs(d, tag_items_data_parent_item) {|did|\n         found = some(parse_def_id(ebml::doc_data(did)));\n     }\n     found\n@@ -134,7 +134,7 @@ fn field_mutability(d: ebml::doc) -> ast::class_mutability {\n }\n \n fn variant_disr_val(d: ebml::doc) -> option<int> {\n-    option::chain(ebml::maybe_get_doc(d, tag_disr_val)) {|val_doc|\n+    do option::chain(ebml::maybe_get_doc(d, tag_disr_val)) {|val_doc|\n         int::parse_buf(ebml::doc_data(val_doc), 10u)\n     }\n }\n@@ -157,7 +157,7 @@ fn item_type(item_id: ast::def_id, item: ebml::doc,\n fn item_impl_iface(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n     -> option<ty::t> {\n     let mut result = none;\n-    ebml::tagged_docs(item, tag_impl_iface) {|ity|\n+    do ebml::tagged_docs(item, tag_impl_iface) {|ity|\n         result = some(doc_type(ity, tcx, cdata));\n     };\n     result\n@@ -166,7 +166,7 @@ fn item_impl_iface(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n fn item_ty_param_bounds(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n     -> @~[ty::param_bounds] {\n     let mut bounds = ~[];\n-    ebml::tagged_docs(item, tag_items_data_item_ty_param_bounds) {|p|\n+    do ebml::tagged_docs(item, tag_items_data_item_ty_param_bounds) {|p|\n         let bd = parse_bounds_data(p.data, p.start, cdata.cnum, tcx, {|did|\n             translate_def_id(cdata, did)\n         });\n@@ -197,7 +197,7 @@ fn item_ty_param_count(item: ebml::doc) -> uint {\n fn enum_variant_ids(item: ebml::doc, cdata: cmd) -> ~[ast::def_id] {\n     let mut ids: ~[ast::def_id] = ~[];\n     let v = tag_items_data_item_variant;\n-    ebml::tagged_docs(item, v) {|p|\n+    do ebml::tagged_docs(item, v) {|p|\n         let ext = parse_def_id(ebml::doc_data(p));\n         vec::push(ids, {crate: cdata.cnum, node: ext.node});\n     };\n@@ -232,7 +232,7 @@ fn item_path(item_doc: ebml::doc) -> ast_map::path {\n     let mut result = ~[];\n     vec::reserve(result, len);\n \n-    ebml::docs(path_doc) {|tag, elt_doc|\n+    do ebml::docs(path_doc) {|tag, elt_doc|\n         if tag == tag_path_elt_mod {\n             let str = ebml::doc_as_str(elt_doc);\n             vec::push(result, ast_map::path_mod(@str));\n@@ -306,7 +306,7 @@ fn get_impl_method(cdata: cmd, id: ast::node_id,\n                    name: ast::ident) -> ast::def_id {\n     let items = ebml::get_doc(ebml::doc(cdata.data), tag_items);\n     let mut found = none;\n-    ebml::tagged_docs(find_item(id, items), tag_item_impl_method) {|mid|\n+    do ebml::tagged_docs(find_item(id, items), tag_item_impl_method) {|mid|\n         let m_did = parse_def_id(ebml::doc_data(mid));\n         if item_name(find_item(m_did.node, items)) == name {\n             found = some(translate_def_id(cdata, m_did));\n@@ -323,7 +323,7 @@ fn get_class_method(cdata: cmd, id: ast::node_id,\n             some(it) { it }\n             none { fail (#fmt(\"get_class_method: class id not found \\\n              when looking up method %s\", *name)) }};\n-    ebml::tagged_docs(cls_items, tag_item_iface_method) {|mid|\n+    do ebml::tagged_docs(cls_items, tag_item_iface_method) {|mid|\n         let m_did = class_member_id(mid, cdata);\n         if item_name(mid) == name {\n             found = some(m_did);\n@@ -343,7 +343,7 @@ fn class_dtor(cdata: cmd, id: ast::node_id) -> option<ast::def_id> {\n             none     { fail (#fmt(\"class_dtor: class id not found \\\n               when looking up dtor for %d\", id)); }\n     };\n-    ebml::tagged_docs(cls_items, tag_item_dtor) {|doc|\n+    do ebml::tagged_docs(cls_items, tag_item_dtor) {|doc|\n          let doc1 = ebml::get_doc(doc, tag_def_id);\n          let did = parse_def_id(ebml::doc_data(doc1));\n          found = some(translate_def_id(cdata, did));\n@@ -429,7 +429,7 @@ type _impl = {did: ast::def_id, ident: ast::ident, methods: ~[@method_info]};\n fn item_impl_methods(cdata: cmd, item: ebml::doc, base_tps: uint)\n     -> ~[@method_info] {\n     let mut rslt = ~[];\n-    ebml::tagged_docs(item, tag_item_impl_method) {|doc|\n+    do ebml::tagged_docs(item, tag_item_impl_method) {|doc|\n         let m_did = parse_def_id(ebml::doc_data(doc));\n         let mth_item = lookup_item(m_did.node, cdata.data);\n         vec::push(rslt, @{did: translate_def_id(cdata, m_did),\n@@ -447,7 +447,7 @@ fn get_impls_for_mod(cdata: cmd, m_id: ast::node_id,\n     let data = cdata.data;\n     let mod_item = lookup_item(m_id, data);\n     let mut result = ~[];\n-    ebml::tagged_docs(mod_item, tag_mod_impl) {|doc|\n+    do ebml::tagged_docs(mod_item, tag_mod_impl) {|doc|\n         let did = parse_def_id(ebml::doc_data(doc));\n         let local_did = translate_def_id(cdata, did);\n           // The impl may be defined in a different crate. Ask the caller\n@@ -473,7 +473,7 @@ fn get_iface_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n-    ebml::tagged_docs(item, tag_item_iface_method) {|mth|\n+    do ebml::tagged_docs(item, tag_item_iface_method) {|mth|\n         let bounds = item_ty_param_bounds(mth, tcx, cdata);\n         let name = item_name(mth);\n         let ty = doc_type(mth, tcx, cdata);\n@@ -498,7 +498,7 @@ fn get_class_members(cdata: cmd, id: ast::node_id,\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n-    ebml::tagged_docs(item, tag_item_field) {|an_item|\n+    do ebml::tagged_docs(item, tag_item_field) {|an_item|\n        let f = item_family(an_item);\n        if p(f) {\n           let name = item_name(an_item);\n@@ -578,12 +578,12 @@ fn item_family_to_str(fam: char) -> str {\n \n fn get_meta_items(md: ebml::doc) -> ~[@ast::meta_item] {\n     let mut items: ~[@ast::meta_item] = ~[];\n-    ebml::tagged_docs(md, tag_meta_item_word) {|meta_item_doc|\n+    do ebml::tagged_docs(md, tag_meta_item_word) {|meta_item_doc|\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = str::from_bytes(ebml::doc_data(nd));\n         vec::push(items, attr::mk_word_item(@n));\n     };\n-    ebml::tagged_docs(md, tag_meta_item_name_value) {|meta_item_doc|\n+    do ebml::tagged_docs(md, tag_meta_item_name_value) {|meta_item_doc|\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n         let vd = ebml::get_doc(meta_item_doc, tag_meta_item_value);\n         let n = str::from_bytes(ebml::doc_data(nd));\n@@ -592,7 +592,7 @@ fn get_meta_items(md: ebml::doc) -> ~[@ast::meta_item] {\n         // but currently the encoder just drops them\n         vec::push(items, attr::mk_name_value_item_str(@n, v));\n     };\n-    ebml::tagged_docs(md, tag_meta_item_list) {|meta_item_doc|\n+    do ebml::tagged_docs(md, tag_meta_item_list) {|meta_item_doc|\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = str::from_bytes(ebml::doc_data(nd));\n         let subitems = get_meta_items(meta_item_doc);\n@@ -605,7 +605,7 @@ fn get_attributes(md: ebml::doc) -> ~[ast::attribute] {\n     let mut attrs: ~[ast::attribute] = ~[];\n     alt ebml::maybe_get_doc(md, tag_attributes) {\n       option::some(attrs_d) {\n-        ebml::tagged_docs(attrs_d, tag_attribute) {|attr_doc|\n+        do ebml::tagged_docs(attrs_d, tag_attribute) {|attr_doc|\n             let meta_items = get_meta_items(attr_doc);\n             // Currently it's only possible to have a single meta item on\n             // an attribute\n@@ -652,7 +652,7 @@ fn get_crate_deps(data: @~[u8]) -> ~[crate_dep] {\n     fn docstr(doc: ebml::doc, tag_: uint) -> str {\n         str::from_bytes(ebml::doc_data(ebml::get_doc(doc, tag_)))\n     }\n-    ebml::tagged_docs(depsdoc, tag_crate_dep) {|depdoc|\n+    do ebml::tagged_docs(depsdoc, tag_crate_dep) {|depdoc|\n         vec::push(deps, {cnum: crate_num,\n                   name: @docstr(depdoc, tag_crate_dep_name),\n                   vers: @docstr(depdoc, tag_crate_dep_vers),\n@@ -691,7 +691,7 @@ fn get_crate_vers(data: @~[u8]) -> @str {\n fn list_crate_items(bytes: @~[u8], md: ebml::doc, out: io::writer) {\n     out.write_str(\"=Items=\\n\");\n     let items = ebml::get_doc(md, tag_items);\n-    iter_crate_items(bytes) {|path, did|\n+    do iter_crate_items(bytes) {|path, did|\n         out.write_str(#fmt[\"%s (%s)\\n\", path, describe_def(items, did)]);\n     }\n     out.write_str(\"\\n\");\n@@ -702,9 +702,9 @@ fn iter_crate_items(bytes: @~[u8], proc: fn(str, ast::def_id)) {\n     let paths = ebml::get_doc(md, tag_paths);\n     let index = ebml::get_doc(paths, tag_index);\n     let bs = ebml::get_doc(index, tag_index_buckets);\n-    ebml::tagged_docs(bs, tag_index_buckets_bucket) {|bucket|\n+    do ebml::tagged_docs(bs, tag_index_buckets_bucket) {|bucket|\n         let et = tag_index_buckets_bucket_elt;\n-        ebml::tagged_docs(bucket, et) {|elt|\n+        do ebml::tagged_docs(bucket, et) {|elt|\n             let data = read_path(elt);\n             let {tag:_, doc:def} = ebml::doc_at(bytes, data.pos);\n             let did_doc = ebml::get_doc(def, tag_def_id);\n@@ -723,7 +723,7 @@ fn get_crate_module_paths(bytes: @~[u8]) -> ~[(ast::def_id, str)] {\n     // fowarded path due to renamed import or reexport\n     let mut res = ~[];\n     let mods = map::str_hash();\n-    iter_crate_items(bytes) {|path, did|\n+    do iter_crate_items(bytes) {|path, did|\n         let m = mod_of_path(path);\n         if str::is_not_empty(m) {\n             // if m has a sub-item, it must be a module\n@@ -734,7 +734,7 @@ fn get_crate_module_paths(bytes: @~[u8]) -> ~[(ast::def_id, str)] {\n         // unified later by using the mods map\n         vec::push(res, (did, path));\n     }\n-    ret vec::filter(res) {|x|\n+    ret do vec::filter(res) {|x|\n         let (_, xp) = x;\n         mods.contains_key(xp)\n     }"}, {"sha": "b62854ab8cc29a55dfbff16951d6c6db40e4d2c0", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -87,20 +87,20 @@ fn encode_name_and_def_id(ebml_w: ebml::writer, nm: ident,\n }\n \n fn encode_region_param(ebml_w: ebml::writer, rp: region_param) {\n-    ebml_w.wr_tag(tag_region_param) {||\n+    do ebml_w.wr_tag(tag_region_param) {||\n         serialize_region_param(ebml_w, rp)\n     }\n }\n \n fn encode_named_def_id(ebml_w: ebml::writer, name: ident, id: def_id) {\n-    ebml_w.wr_tag(tag_paths_data_item) {||\n+    do ebml_w.wr_tag(tag_paths_data_item) {||\n         encode_name(ebml_w, name);\n         encode_def_id(ebml_w, id);\n     }\n }\n \n fn encode_mutability(ebml_w: ebml::writer, mt: class_mutability) {\n-    ebml_w.wr_tag(tag_class_mut) {||\n+    do ebml_w.wr_tag(tag_class_mut) {||\n         ebml_w.writer.write(&[alt mt { class_immutable { 'i' }\n                 class_mutable { 'm' } } as u8]);\n         }\n@@ -112,7 +112,7 @@ fn encode_enum_variant_paths(ebml_w: ebml::writer, variants: ~[variant],\n                             path: ~[ident], &index: ~[entry<str>]) {\n     for variants.each {|variant|\n         add_to_index(ebml_w, path, index, variant.node.name);\n-        ebml_w.wr_tag(tag_paths_data_item) {||\n+        do ebml_w.wr_tag(tag_paths_data_item) {||\n             encode_name(ebml_w, variant.node.name);\n             encode_def_id(ebml_w, local_def(variant.node.id));\n         }\n@@ -170,31 +170,31 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n             encode_named_def_id(ebml_w, it.ident, local_def(it.id));\n           }\n           item_mod(_mod) {\n-            ebml_w.wr_tag(tag_paths_data_mod) {||\n+            do ebml_w.wr_tag(tag_paths_data_mod) {||\n                encode_name_and_def_id(ebml_w, it.ident, it.id);\n                encode_module_item_paths(ebml_w, ecx, _mod,\n                                         vec::append_one(path, it.ident),\n                                         index);\n             }\n           }\n           item_foreign_mod(nmod) {\n-            ebml_w.wr_tag(tag_paths_data_mod) {||\n+            do ebml_w.wr_tag(tag_paths_data_mod) {||\n               encode_name_and_def_id(ebml_w, it.ident, it.id);\n               encode_foreign_module_item_paths(\n                   ebml_w, nmod,\n                   vec::append_one(path, it.ident), index);\n             }\n           }\n           item_ty(_, tps, _) {\n-            ebml_w.wr_tag(tag_paths_data_item) {||\n+            do ebml_w.wr_tag(tag_paths_data_item) {||\n               encode_name_and_def_id(ebml_w, it.ident, it.id);\n             }\n           }\n           item_class(_, _, items, ctor, m_dtor, _) {\n-            ebml_w.wr_tag(tag_paths_data_item) {||\n+            do ebml_w.wr_tag(tag_paths_data_item) {||\n                 encode_name_and_def_id(ebml_w, it.ident, it.id);\n             }\n-            ebml_w.wr_tag(tag_paths) {||\n+            do ebml_w.wr_tag(tag_paths) {||\n                 // We add the same ident twice: for the\n                 // class and for its ctor\n                 add_to_index(ebml_w, path, index, it.ident);\n@@ -206,13 +206,13 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n             }\n           }\n           item_enum(variants, _, _) {\n-              ebml_w.wr_tag(tag_paths_data_item) {||\n+              do ebml_w.wr_tag(tag_paths_data_item) {||\n                   encode_name_and_def_id(ebml_w, it.ident, it.id);\n               }\n               encode_enum_variant_paths(ebml_w, variants, path, index);\n           }\n           item_iface(*) {\n-              ebml_w.wr_tag(tag_paths_data_item) {||\n+              do ebml_w.wr_tag(tag_paths_data_item) {||\n                   encode_name_and_def_id(ebml_w, it.ident, it.id);\n               }\n           }\n@@ -372,9 +372,9 @@ fn encode_path(ebml_w: ebml::writer,\n         ebml_w.wr_tagged_str(tag, *name);\n     }\n \n-    ebml_w.wr_tag(tag_path) {||\n+    do ebml_w.wr_tag(tag_path) {||\n         ebml_w.wr_tagged_u32(tag_path_len, (vec::len(path) + 1u) as u32);\n-        vec::iter(path) {|pe| encode_path_elt(ebml_w, pe); }\n+        do vec::iter(path) {|pe| encode_path_elt(ebml_w, pe); }\n         encode_path_elt(ebml_w, name);\n     }\n }\n@@ -602,7 +602,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n       }\n       item_enum(variants, tps, rp) {\n         add_to_index();\n-        ebml_w.wr_tag(tag_items_data_item) {||\n+        do ebml_w.wr_tag(tag_items_data_item) {||\n             encode_def_id(ebml_w, local_def(item.id));\n             encode_family(ebml_w, 't');\n             encode_type_param_bounds(ebml_w, ecx, tps);\n@@ -626,7 +626,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         let idx = encode_info_for_class(ecx, ebml_w, item.id, path, tps,\n                                           items, index);\n         /* Encode the dtor */\n-        option::iter(m_dtor) {|dtor|\n+        do option::iter(m_dtor) {|dtor|\n             vec::push(*index, {val: dtor.node.id, pos: ebml_w.writer.tell()});\n           encode_info_for_fn(ecx, ebml_w, dtor.node.id, @(*item.ident\n                              + \"_dtor\"), path, if tps.len() > 0u {\n@@ -651,8 +651,8 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         }\n         /* Encode the dtor */\n         /* Encode id for dtor */\n-        option::iter(m_dtor) {|dtor|\n-            ebml_w.wr_tag(tag_item_dtor) {||\n+        do option::iter(m_dtor) {|dtor|\n+            do ebml_w.wr_tag(tag_item_dtor) {||\n                 encode_def_id(ebml_w, local_def(dtor.node.id));\n             }\n         };\n@@ -708,7 +708,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n             ebml_w.writer.write(str::bytes(def_to_str(local_def(m.id))));\n             ebml_w.end_tag();\n         }\n-        option::iter(ifce) {|t|\n+        do option::iter(ifce) {|t|\n            encode_iface_ref(ebml_w, ecx, t)\n         };\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n@@ -977,7 +977,7 @@ fn encode_crate_deps(ebml_w: ebml::writer, cstore: cstore::cstore) {\n \n         // Pull the cnums and name,vers,hash out of cstore\n         let mut deps: ~[mut numdep] = ~[mut];\n-        cstore::iter_crate_data(cstore) {|key, val|\n+        do cstore::iter_crate_data(cstore) {|key, val|\n             let dep = {cnum: key, name: @val.name,\n                        vers: decoder::get_crate_vers(val.data),\n                        hash: decoder::get_crate_hash(val.data)};"}, {"sha": "8ceb5d5b68c35ea6c3c1a9ae2cf34dfa64505d56", "filename": "src/rustc/metadata/filesearch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ffilesearch.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -134,7 +134,7 @@ fn get_cargo_root() -> result<path, str> {\n }\n \n fn get_cargo_root_nearest() -> result<path, str> {\n-    result::chain(get_cargo_root()) { |p|\n+    do result::chain(get_cargo_root()) { |p|\n         let cwd = os::getcwd();\n         let mut dirname = path::dirname(cwd);\n         let mut dirpath = path::split(dirname);\n@@ -158,13 +158,13 @@ fn get_cargo_root_nearest() -> result<path, str> {\n }\n \n fn get_cargo_lib_path() -> result<path, str> {\n-    result::chain(get_cargo_root()) { |p|\n+    do result::chain(get_cargo_root()) { |p|\n         result::ok(path::connect(p, libdir()))\n     }\n }\n \n fn get_cargo_lib_path_nearest() -> result<path, str> {\n-    result::chain(get_cargo_root_nearest()) { |p|\n+    do result::chain(get_cargo_root_nearest()) { |p|\n         result::ok(path::connect(p, libdir()))\n     }\n }"}, {"sha": "3fc88ffa794a7034de0b715648c2b272d474b947", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -192,9 +192,9 @@ fn parse_vstore(st: @pstate) -> ty::vstore {\n }\n \n fn parse_substs(st: @pstate, conv: conv_did) -> ty::substs {\n-    let self_r = parse_opt(st) {|| parse_region(st) };\n+    let self_r = parse_opt(st, {|| parse_region(st) });\n \n-    let self_ty = parse_opt(st) {|| parse_ty(st, conv) };\n+    let self_ty = parse_opt(st, {|| parse_ty(st, conv) });\n \n     assert next(st) == '[';\n     let mut params: [ty::t]/~ = []/~;"}, {"sha": "f90834ea1fc4a4d49f752a80239d492040dee1b4", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -115,8 +115,8 @@ fn enc_opt<T>(w: io::writer, t: option<T>, enc_f: fn(T)) {\n }\n \n fn enc_substs(w: io::writer, cx: @ctxt, substs: ty::substs) {\n-    enc_opt(w, substs.self_r) { |r| enc_region(w, cx, r) }\n-    enc_opt(w, substs.self_ty) { |t| enc_ty(w, cx, t) }\n+    do enc_opt(w, substs.self_r) { |r| enc_region(w, cx, r) }\n+    do enc_opt(w, substs.self_ty) { |t| enc_ty(w, cx, t) }\n     w.write_char('[');\n     for substs.tps.each { |t| enc_ty(w, cx, t); }\n     w.write_char(']');"}, {"sha": "165a9e28264f081796e4363f68b228abdf1380ed", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 84, "deletions": 84, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -87,7 +87,7 @@ fn encode_inlined_item(ecx: @e::encode_ctxt,\n            ebml_w.writer.tell()];\n \n     let id_range = ast_util::compute_id_range_for_inlined_item(ii);\n-    ebml_w.wr_tag(c::tag_ast as uint) {||\n+    do ebml_w.wr_tag(c::tag_ast as uint) {||\n         ast_util::serialize_id_range(ebml_w, id_range);\n         encode_ast(ebml_w, simplify_ast(ii));\n         encode_side_tables_for_ii(ecx, maps, ebml_w, ii);\n@@ -210,7 +210,7 @@ impl deserializer_helpers<D: deserializer> for D {\n // but eventually we should add entries to the local codemap as required.\n \n fn encode_ast(ebml_w: ebml::writer, item: ast::inlined_item) {\n-    ebml_w.wr_tag(c::tag_tree as uint) {||\n+    do ebml_w.wr_tag(c::tag_tree as uint) {||\n         ast::serialize_inlined_item(ebml_w, item)\n     }\n }\n@@ -227,7 +227,7 @@ fn encode_ast(ebml_w: ebml::writer, item: ast::inlined_item) {\n // inlined items.\n fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n     fn drop_nested_items(blk: ast::blk_, fld: fold::ast_fold) -> ast::blk_ {\n-        let stmts_sans_items = vec::filter(blk.stmts) {|stmt|\n+        let stmts_sans_items = do vec::filter(blk.stmts) {|stmt|\n             alt stmt.node {\n               ast::stmt_expr(_, _) | ast::stmt_semi(_, _) |\n               ast::stmt_decl(@{node: ast::decl_local(_), span: _}, _) { true }\n@@ -425,45 +425,45 @@ fn encode_vtable_res(ecx: @e::encode_ctxt,\n     // ty::t doesn't work, and there is no way (atm) to have\n     // hand-written serialization routines combine with auto-generated\n     // ones.  perhaps we should fix this.\n-    ebml_w.emit_from_vec(*dr) {|vtable_origin|\n+    do ebml_w.emit_from_vec(*dr) {|vtable_origin|\n         encode_vtable_origin(ecx, ebml_w, vtable_origin)\n     }\n }\n \n fn encode_vtable_origin(ecx: @e::encode_ctxt,\n                       ebml_w: ebml::writer,\n                       vtable_origin: typeck::vtable_origin) {\n-    ebml_w.emit_enum(\"vtable_origin\") {||\n+    do ebml_w.emit_enum(\"vtable_origin\") {||\n         alt vtable_origin {\n           typeck::vtable_static(def_id, tys, vtable_res) {\n-            ebml_w.emit_enum_variant(\"vtable_static\", 0u, 3u) {||\n-                ebml_w.emit_enum_variant_arg(0u) {||\n+            do ebml_w.emit_enum_variant(\"vtable_static\", 0u, 3u) {||\n+                do ebml_w.emit_enum_variant_arg(0u) {||\n                     ebml_w.emit_def_id(def_id)\n                 }\n-                ebml_w.emit_enum_variant_arg(1u) {||\n+                do ebml_w.emit_enum_variant_arg(1u) {||\n                     ebml_w.emit_tys(ecx, tys);\n                 }\n-                ebml_w.emit_enum_variant_arg(2u) {||\n+                do ebml_w.emit_enum_variant_arg(2u) {||\n                     encode_vtable_res(ecx, ebml_w, vtable_res);\n                 }\n             }\n           }\n           typeck::vtable_param(pn, bn) {\n-            ebml_w.emit_enum_variant(\"vtable_param\", 1u, 2u) {||\n-                ebml_w.emit_enum_variant_arg(0u) {||\n+            do ebml_w.emit_enum_variant(\"vtable_param\", 1u, 2u) {||\n+                do ebml_w.emit_enum_variant_arg(0u) {||\n                     ebml_w.emit_uint(pn);\n                 }\n-                ebml_w.emit_enum_variant_arg(1u) {||\n+                do ebml_w.emit_enum_variant_arg(1u) {||\n                     ebml_w.emit_uint(bn);\n                 }\n             }\n           }\n           typeck::vtable_iface(def_id, tys) {\n-            ebml_w.emit_enum_variant(\"vtable_iface\", 1u, 3u) {||\n-                ebml_w.emit_enum_variant_arg(0u) {||\n+            do ebml_w.emit_enum_variant(\"vtable_iface\", 1u, 3u) {||\n+                do ebml_w.emit_enum_variant_arg(0u) {||\n                     ebml_w.emit_def_id(def_id)\n                 }\n-                ebml_w.emit_enum_variant_arg(1u) {||\n+                do ebml_w.emit_enum_variant_arg(1u) {||\n                     ebml_w.emit_tys(ecx, tys);\n                 }\n             }\n@@ -475,43 +475,43 @@ fn encode_vtable_origin(ecx: @e::encode_ctxt,\n \n impl helpers for ebml::ebml_deserializer {\n     fn read_vtable_res(xcx: extended_decode_ctxt) -> typeck::vtable_res {\n-        @self.read_to_vec {|| self.read_vtable_origin(xcx) }\n+        @self.read_to_vec({|| self.read_vtable_origin(xcx) })\n     }\n \n     fn read_vtable_origin(xcx: extended_decode_ctxt)\n         -> typeck::vtable_origin {\n-        self.read_enum(\"vtable_origin\") {||\n-            self.read_enum_variant {|i|\n+        do self.read_enum(\"vtable_origin\") {||\n+            do self.read_enum_variant {|i|\n                 alt check i {\n                   0u {\n                     typeck::vtable_static(\n-                        self.read_enum_variant_arg(0u) {||\n+                        do self.read_enum_variant_arg(0u) {||\n                             self.read_def_id(xcx)\n                         },\n-                        self.read_enum_variant_arg(1u) {||\n+                        do self.read_enum_variant_arg(1u) {||\n                             self.read_tys(xcx)\n                         },\n-                        self.read_enum_variant_arg(2u) {||\n+                        do self.read_enum_variant_arg(2u) {||\n                             self.read_vtable_res(xcx)\n                         }\n                     )\n                   }\n                   1u {\n                     typeck::vtable_param(\n-                        self.read_enum_variant_arg(0u) {||\n+                        do self.read_enum_variant_arg(0u) {||\n                             self.read_uint()\n                         },\n-                        self.read_enum_variant_arg(1u) {||\n+                        do self.read_enum_variant_arg(1u) {||\n                             self.read_uint()\n                         }\n                     )\n                   }\n                   2u {\n                     typeck::vtable_iface(\n-                        self.read_enum_variant_arg(0u) {||\n+                        do self.read_enum_variant_arg(0u) {||\n                             self.read_def_id(xcx)\n                         },\n-                        self.read_enum_variant_arg(1u) {||\n+                        do self.read_enum_variant_arg(1u) {||\n                             self.read_tys(xcx)\n                         }\n                     )\n@@ -541,7 +541,7 @@ impl helpers for ebml::writer {\n     }\n \n     fn emit_tys(ecx: @e::encode_ctxt, tys: ~[ty::t]) {\n-        self.emit_from_vec(tys) {|ty|\n+        do self.emit_from_vec(tys) {|ty|\n             e::write_type(ecx, self, ty)\n         }\n     }\n@@ -551,16 +551,16 @@ impl helpers for ebml::writer {\n     }\n \n     fn emit_tpbt(ecx: @e::encode_ctxt, tpbt: ty::ty_param_bounds_and_ty) {\n-        self.emit_rec {||\n-            self.emit_rec_field(\"bounds\", 0u) {||\n-                self.emit_from_vec(*tpbt.bounds) {|bs|\n+        do self.emit_rec {||\n+            do self.emit_rec_field(\"bounds\", 0u) {||\n+                do self.emit_from_vec(*tpbt.bounds) {|bs|\n                     self.emit_bounds(ecx, bs)\n                 }\n             }\n-            self.emit_rec_field(\"rp\", 1u) {||\n+            do self.emit_rec_field(\"rp\", 1u) {||\n                 ast::serialize_region_param(self, tpbt.rp)\n             }\n-            self.emit_rec_field(\"ty\", 2u) {||\n+            do self.emit_rec_field(\"ty\", 2u) {||\n                 self.emit_ty(ecx, tpbt.ty);\n             }\n         }\n@@ -569,7 +569,7 @@ impl helpers for ebml::writer {\n \n impl writer for ebml::writer {\n     fn tag(tag_id: c::astencode_tag, f: fn()) {\n-        self.wr_tag(tag_id as uint) {|| f() }\n+        do self.wr_tag(tag_id as uint) {|| f() }\n     }\n \n     fn id(id: ast::node_id) {\n@@ -581,7 +581,7 @@ fn encode_side_tables_for_ii(ecx: @e::encode_ctxt,\n                              maps: maps,\n                              ebml_w: ebml::writer,\n                              ii: ast::inlined_item) {\n-    ebml_w.wr_tag(c::tag_table as uint) {||\n+    do ebml_w.wr_tag(c::tag_table as uint) {||\n         ast_util::visit_ids_for_inlined_item(\n             ii,\n             fn@(id: ast::node_id, copy ebml_w) {\n@@ -601,57 +601,57 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n \n     #debug[\"Encoding side tables for id %d\", id];\n \n-    option::iter(tcx.def_map.find(id)) {|def|\n-        ebml_w.tag(c::tag_table_def) {||\n+    do option::iter(tcx.def_map.find(id)) {|def|\n+        do ebml_w.tag(c::tag_table_def) {||\n             ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val) {||\n+            do ebml_w.tag(c::tag_table_val) {||\n                 ast::serialize_def(ebml_w, def)\n             }\n         }\n     }\n-    option::iter((*tcx.node_types).find(id as uint)) {|ty|\n-        ebml_w.tag(c::tag_table_node_type) {||\n+    do option::iter((*tcx.node_types).find(id as uint)) {|ty|\n+        do ebml_w.tag(c::tag_table_node_type) {||\n             ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val) {||\n+            do ebml_w.tag(c::tag_table_val) {||\n                 e::write_type(ecx, ebml_w, ty)\n             }\n         }\n     }\n \n-    option::iter(tcx.node_type_substs.find(id)) {|tys|\n-        ebml_w.tag(c::tag_table_node_type_subst) {||\n+    do option::iter(tcx.node_type_substs.find(id)) {|tys|\n+        do ebml_w.tag(c::tag_table_node_type_subst) {||\n             ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val) {||\n+            do ebml_w.tag(c::tag_table_val) {||\n                 ebml_w.emit_tys(ecx, tys)\n             }\n         }\n     }\n \n-    option::iter(tcx.freevars.find(id)) {|fv|\n-        ebml_w.tag(c::tag_table_freevars) {||\n+    do option::iter(tcx.freevars.find(id)) {|fv|\n+        do ebml_w.tag(c::tag_table_freevars) {||\n             ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val) {||\n-                ebml_w.emit_from_vec(*fv) {|fv_entry|\n+            do ebml_w.tag(c::tag_table_val) {||\n+                do ebml_w.emit_from_vec(*fv) {|fv_entry|\n                     encode_freevar_entry(ebml_w, *fv_entry)\n                 }\n             }\n         }\n     }\n \n     let lid = {crate: ast::local_crate, node: id};\n-    option::iter(tcx.tcache.find(lid)) {|tpbt|\n-        ebml_w.tag(c::tag_table_tcache) {||\n+    do option::iter(tcx.tcache.find(lid)) {|tpbt|\n+        do ebml_w.tag(c::tag_table_tcache) {||\n             ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val) {||\n+            do ebml_w.tag(c::tag_table_val) {||\n                 ebml_w.emit_tpbt(ecx, tpbt);\n             }\n         }\n     }\n \n-    option::iter(tcx.ty_param_bounds.find(id)) {|pbs|\n-        ebml_w.tag(c::tag_table_param_bounds) {||\n+    do option::iter(tcx.ty_param_bounds.find(id)) {|pbs|\n+        do ebml_w.tag(c::tag_table_param_bounds) {||\n             ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val) {||\n+            do ebml_w.tag(c::tag_table_val) {||\n                 ebml_w.emit_bounds(ecx, pbs)\n             }\n         }\n@@ -671,17 +671,17 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n     //    }\n     //}\n \n-    option::iter(maps.mutbl_map.find(id)) {|_m|\n-        ebml_w.tag(c::tag_table_mutbl) {||\n+    do option::iter(maps.mutbl_map.find(id)) {|_m|\n+        do ebml_w.tag(c::tag_table_mutbl) {||\n             ebml_w.id(id);\n         }\n     }\n \n-    option::iter(maps.last_use_map.find(id)) {|m|\n-        ebml_w.tag(c::tag_table_last_use) {||\n+    do option::iter(maps.last_use_map.find(id)) {|m|\n+        do ebml_w.tag(c::tag_table_last_use) {||\n             ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val) {||\n-                ebml_w.emit_from_vec((*m).get()) {|id|\n+            do ebml_w.tag(c::tag_table_val) {||\n+                do ebml_w.emit_from_vec((*m).get()) {|id|\n                     ebml_w.emit_int(id);\n                 }\n             }\n@@ -691,28 +691,28 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n     // impl_map is not used except when emitting metadata,\n     // don't need to keep it.\n \n-    option::iter(maps.method_map.find(id)) {|mme|\n-        ebml_w.tag(c::tag_table_method_map) {||\n+    do option::iter(maps.method_map.find(id)) {|mme|\n+        do ebml_w.tag(c::tag_table_method_map) {||\n             ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val) {||\n+            do ebml_w.tag(c::tag_table_val) {||\n                 serialize_method_map_entry(ebml_w, mme)\n             }\n         }\n     }\n \n-    option::iter(maps.vtable_map.find(id)) {|dr|\n-        ebml_w.tag(c::tag_table_vtable_map) {||\n+    do option::iter(maps.vtable_map.find(id)) {|dr|\n+        do ebml_w.tag(c::tag_table_vtable_map) {||\n             ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val) {||\n+            do ebml_w.tag(c::tag_table_val) {||\n                 encode_vtable_res(ecx, ebml_w, dr);\n             }\n         }\n     }\n \n-    option::iter(tcx.borrowings.find(id)) {|borrow|\n-        ebml_w.tag(c::tag_table_borrowings) {||\n+    do option::iter(tcx.borrowings.find(id)) {|borrow|\n+        do ebml_w.tag(c::tag_table_borrowings) {||\n             ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val) {||\n+            do ebml_w.tag(c::tag_table_val) {||\n                 ty::serialize_borrow(ebml_w, borrow)\n             }\n         }\n@@ -742,7 +742,7 @@ impl decoder for ebml::ebml_deserializer {\n     }\n \n     fn read_tys(xcx: extended_decode_ctxt) -> ~[ty::t] {\n-        self.read_to_vec {|| self.read_ty(xcx) }\n+        self.read_to_vec({|| self.read_ty(xcx) })\n     }\n \n     fn read_bounds(xcx: extended_decode_ctxt) -> @~[ty::param_bound] {\n@@ -753,17 +753,17 @@ impl decoder for ebml::ebml_deserializer {\n \n     fn read_ty_param_bounds_and_ty(xcx: extended_decode_ctxt)\n         -> ty::ty_param_bounds_and_ty {\n-        self.read_rec {||\n+        do self.read_rec {||\n             {\n-                bounds: self.read_rec_field(\"bounds\", 0u) {||\n-                    @self.read_to_vec {|| self.read_bounds(xcx) }\n-                },\n-                rp: self.read_rec_field(\"rp\", 1u) {||\n+                bounds: self.read_rec_field(\"bounds\", 0u, {||\n+                    @self.read_to_vec({|| self.read_bounds(xcx) })\n+                }),\n+                rp: self.read_rec_field(\"rp\", 1u, {||\n                     ast::deserialize_region_param(self)\n-                },\n-                ty: self.read_rec_field(\"ty\", 2u) {||\n+                }),\n+                ty: self.read_rec_field(\"ty\", 2u, {||\n                     self.read_ty(xcx)\n-                }\n+                })\n             }\n         }\n     }\n@@ -773,7 +773,7 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n                       ast_doc: ebml::doc) {\n     let dcx = xcx.dcx;\n     let tbl_doc = ast_doc[c::tag_table];\n-    ebml::docs(tbl_doc) {|tag, entry_doc|\n+    do ebml::docs(tbl_doc) {|tag, entry_doc|\n         let id0 = entry_doc[c::tag_table_id].as_int();\n         let id = xcx.tr_id(id0);\n \n@@ -796,9 +796,9 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n                 let tys = val_dsr.read_tys(xcx);\n                 dcx.tcx.node_type_substs.insert(id, tys);\n             } else if tag == (c::tag_table_freevars as uint) {\n-                let fv_info = @val_dsr.read_to_vec {||\n+                let fv_info = @val_dsr.read_to_vec({||\n                     @val_dsr.read_freevar_entry(xcx)\n-                };\n+                });\n                 dcx.tcx.freevars.insert(id, fv_info);\n             } else if tag == (c::tag_table_tcache as uint) {\n                 let tpbt = val_dsr.read_ty_param_bounds_and_ty(xcx);\n@@ -808,9 +808,9 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n                 let bounds = val_dsr.read_bounds(xcx);\n                 dcx.tcx.ty_param_bounds.insert(id, bounds);\n             } else if tag == (c::tag_table_last_use as uint) {\n-                let ids = val_dsr.read_to_vec {||\n+                let ids = val_dsr.read_to_vec({||\n                     xcx.tr_id(val_dsr.read_int())\n-                };\n+                });\n                 let dvec = @dvec::from_vec(vec::to_mut(ids));\n                 dcx.maps.last_use_map.insert(id, dvec);\n             } else if tag == (c::tag_table_method_map as uint) {\n@@ -838,7 +838,7 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n \n #[cfg(test)]\n fn encode_item_ast(ebml_w: ebml::writer, item: @ast::item) {\n-    ebml_w.wr_tag(c::tag_tree as uint) {||\n+    do ebml_w.wr_tag(c::tag_tree as uint) {||\n         ast::serialize_item(ebml_w, *item);\n     }\n }\n@@ -881,9 +881,9 @@ fn roundtrip(in_item: @ast::item) {\n     #debug[\"out_item = %s\", pprust::item_to_str(out_item)];\n \n     let exp_str =\n-        io::with_str_writer {|w| ast::serialize_item(w, *in_item) };\n+        io::with_str_writer({|w| ast::serialize_item(w, *in_item) });\n     let out_str =\n-        io::with_str_writer {|w| ast::serialize_item(w, *out_item) };\n+        io::with_str_writer({|w| ast::serialize_item(w, *out_item) });\n \n     #debug[\"expected string: %s\", exp_str];\n     #debug[\"actual string  : %s\", out_str];"}, {"sha": "adf68fa52da7ae7f965c2107341348a2b26ccbdd", "filename": "src/rustc/middle/borrowck/categorization.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -280,7 +280,7 @@ impl public_methods for borrowck_ctxt {\n                                 cmt: cmt) -> cmt {\n         @{id: arg.id(), span: arg.span(),\n           cat: cat_comp(cmt, comp_variant(enum_did)),\n-          lp: cmt.lp.map { |l| @lp_comp(l, comp_variant(enum_did)) },\n+          lp: cmt.lp.map({ |l| @lp_comp(l, comp_variant(enum_did)) }),\n           mutbl: cmt.mutbl, // imm iff in an immutable context\n           ty: self.tcx.ty(arg)}\n     }\n@@ -311,20 +311,20 @@ impl public_methods for borrowck_ctxt {\n           m_mutbl | m_const { f_mutbl }\n         };\n         let f_comp = comp_field(f_name, f_mutbl);\n-        let lp = base_cmt.lp.map { |lp|\n+        let lp = base_cmt.lp.map({ |lp|\n             @lp_comp(lp, f_comp)\n-        };\n+        });\n         @{id: node.id(), span: node.span(),\n           cat: cat_comp(base_cmt, f_comp), lp:lp,\n           mutbl: m, ty: self.tcx.ty(node)}\n     }\n \n     fn cat_deref<N:ast_node>(node: N, base_cmt: cmt, derefs: uint,\n                              expl: bool) -> option<cmt> {\n-        ty::deref(self.tcx, base_cmt.ty, expl).map { |mt|\n+        do ty::deref(self.tcx, base_cmt.ty, expl).map { |mt|\n             alt deref_kind(self.tcx, base_cmt.ty) {\n               deref_ptr(ptr) {\n-                let lp = base_cmt.lp.chain { |l|\n+                let lp = do base_cmt.lp.chain { |l|\n                     // Given that the ptr itself is loanable, we can\n                     // loan out deref'd uniq ptrs as the data they are\n                     // the only way to reach the data they point at.\n@@ -341,7 +341,7 @@ impl public_methods for borrowck_ctxt {\n               }\n \n               deref_comp(comp) {\n-                let lp = base_cmt.lp.map { |l| @lp_comp(l, comp) };\n+                let lp = base_cmt.lp.map({ |l| @lp_comp(l, comp) });\n                 @{id:node.id(), span:node.span(),\n                   cat:cat_comp(base_cmt, comp), lp:lp,\n                   mutbl:mt.mutbl, ty:mt.ty}\n@@ -367,7 +367,7 @@ impl public_methods for borrowck_ctxt {\n           deref_ptr(ptr) {\n             // make deref of vectors explicit, as explained in the comment at\n             // the head of this section\n-            let deref_lp = base_cmt.lp.map { |lp| @lp_deref(lp, ptr) };\n+            let deref_lp = base_cmt.lp.map({ |lp| @lp_deref(lp, ptr) });\n             let deref_cmt = @{id:expr.id, span:expr.span,\n                               cat:cat_deref(base_cmt, 0u, ptr), lp:deref_lp,\n                               mutbl:m_imm, ty:mt.ty};\n@@ -383,7 +383,7 @@ impl public_methods for borrowck_ctxt {\n         fn comp(expr: @ast::expr, of_cmt: cmt,\n                 vect: ty::t, mt: ty::mt) -> cmt {\n             let comp = comp_index(vect, mt.mutbl);\n-            let index_lp = of_cmt.lp.map { |lp| @lp_comp(lp, comp) };\n+            let index_lp = of_cmt.lp.map({ |lp| @lp_comp(lp, comp) });\n             @{id:expr.id, span:expr.span,\n               cat:cat_comp(of_cmt, comp), lp:index_lp,\n               mutbl:mt.mutbl, ty:mt.ty}\n@@ -393,7 +393,7 @@ impl public_methods for borrowck_ctxt {\n     fn cat_tuple_elt<N: ast_node>(elt: N, cmt: cmt) -> cmt {\n         @{id: elt.id(), span: elt.span(),\n           cat: cat_comp(cmt, comp_tuple),\n-          lp: cmt.lp.map { |l| @lp_comp(l, comp_tuple) },\n+          lp: cmt.lp.map({ |l| @lp_comp(l, comp_tuple) }),\n           mutbl: cmt.mutbl, // imm iff in an immutable context\n           ty: self.tcx.ty(elt)}\n     }"}, {"sha": "41abc8af1cebcc993c01086f171fa0a6da498c41", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -488,7 +488,7 @@ impl methods for check_loan_ctxt {\n         let arg_tys =\n             ty::ty_fn_args(\n                 ty::node_id_to_type(self.tcx(), callee_id));\n-        vec::iter2(args, arg_tys) { |arg, arg_ty|\n+        do vec::iter2(args, arg_tys) { |arg, arg_ty|\n             alt ty::resolved_mode(self.tcx(), arg_ty.mode) {\n               ast::by_move {\n                 self.check_move_out(arg);\n@@ -508,9 +508,9 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n                      visitor: visit::vt<check_loan_ctxt>) {\n \n     #debug[\"purity on entry=%?\", copy self.declared_purity];\n-    save_and_restore(self.in_ctor) {||\n-        save_and_restore(self.declared_purity) {||\n-            save_and_restore(self.fn_args) {||\n+    do save_and_restore(self.in_ctor) {||\n+        do save_and_restore(self.declared_purity) {||\n+            do save_and_restore(self.fn_args) {||\n                 let is_stack_closure = self.is_stack_closure(id);\n \n                 // In principle, we could consider fk_anon(*) or\n@@ -637,7 +637,7 @@ fn check_loans_in_expr(expr: @ast::expr,\n fn check_loans_in_block(blk: ast::blk,\n                         &&self: check_loan_ctxt,\n                         vt: visit::vt<check_loan_ctxt>) {\n-    save_and_restore(self.declared_purity) {||\n+    do save_and_restore(self.declared_purity) {||\n         self.check_for_conflicting_loans(blk.node.id);\n \n         alt blk.node.rules {"}, {"sha": "9c40621918369f64868aaa9ac775e8c0568ac122", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -56,7 +56,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n       ast::expr_call(f, args, _) {\n         let arg_tys = ty::ty_fn_args(ty::expr_ty(self.tcx(), f));\n         let scope_r = ty::re_scope(ex.id);\n-        vec::iter2(args, arg_tys) { |arg, arg_ty|\n+        do vec::iter2(args, arg_tys) { |arg, arg_ty|\n             alt ty::resolved_mode(self.tcx(), arg_ty.mode) {\n               ast::by_mutbl_ref {\n                 let arg_cmt = self.bccx.cat_expr(arg);\n@@ -215,7 +215,7 @@ impl methods for gather_loan_ctxt {\n             };\n \n             let result = {\n-                self.check_mutbl(req_mutbl, cmt).chain { |_ok|\n+                do self.check_mutbl(req_mutbl, cmt).chain { |_ok|\n                     self.bccx.preserve(cmt, opt_scope_id)\n                 }\n             };"}, {"sha": "0340a373ddd2eb77242f70af7e8a7733283ab6a1", "filename": "src/rustc/middle/capture.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcapture.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -106,7 +106,7 @@ fn compute_capture_vars(tcx: ty::ctxt,\n       ast::proto_bare | ast::proto_box | ast::proto_uniq { cap_copy }\n     };\n \n-    vec::iter(*freevars) { |fvar|\n+    do vec::iter(*freevars) { |fvar|\n         let fvar_def_id = ast_util::def_id_of_def(fvar.def).node;\n         alt cap_map.find(fvar_def_id) {\n           option::some(_) { /* was explicitly named, do nothing */ }"}, {"sha": "8db30048ff9a29ac7a58e2f34e3e0ffb902d7adf", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -219,7 +219,7 @@ fn missing_ctor(tcx: ty::ctxt, m: matrix, left_ty: ty::t) -> option<ctor> {\n       ty::ty_enum(eid, _) {\n         let mut found = ~[];\n         for m.each {|r|\n-            option::iter(pat_ctor_id(tcx, r[0])) {|id|\n+            do option::iter(pat_ctor_id(tcx, r[0])) {|id|\n                 if !vec::contains(found, id) { vec::push(found, id); }\n             }\n         }"}, {"sha": "a84be38488c28acbaa7aed9e8da172b0ca8fc258", "filename": "src/rustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_const.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -27,7 +27,7 @@ fn check_item(sess: session, ast_map: ast_map::map, def_map: resolve::def_map,\n       }\n       item_enum(vs, _, _) {\n         for vs.each {|var|\n-            option::iter(var.node.disr_expr) {|ex|\n+            do option::iter(var.node.disr_expr) {|ex|\n                 v.visit_expr(ex, true, v);\n             }\n         }"}, {"sha": "d29bd4f9b7c9c3fa222687c12adbc15130527b96", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -150,7 +150,7 @@ fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n \n     // Find the check function that enforces the appropriate bounds for this\n     // kind of function:\n-    with_appropriate_checker(cx, fn_id) { |chk|\n+    do with_appropriate_checker(cx, fn_id) { |chk|\n \n         // Begin by checking the variables in the capture clause, if any.\n         // Here we slightly abuse the map function to both check and report\n@@ -162,7 +162,7 @@ fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n           visit::fk_item_fn(*) | visit::fk_method(*) |\n           visit::fk_ctor(*) | visit::fk_dtor(*) { @~[] }\n         };\n-        let captured_vars = (*cap_clause).map { |cap_item|\n+        let captured_vars = do (*cap_clause).map { |cap_item|\n             let cap_def = cx.tcx.def_map.get(cap_item.id);\n             let cap_def_id = ast_util::def_id_of_def(cap_def).node;\n             let ty = ty::node_id_to_type(cx.tcx, cap_def_id);\n@@ -251,7 +251,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n         }\n       }\n       expr_path(_) | expr_field(_, _, _) {\n-        option::iter(cx.tcx.node_type_substs.find(e.id)) {|ts|\n+        do option::iter(cx.tcx.node_type_substs.find(e.id)) {|ts|\n             let bounds = alt check e.node {\n               expr_path(_) {\n                 let did = ast_util::def_id_of_def(cx.tcx.def_map.get(e.id));\n@@ -286,7 +286,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n                   %s (%u tys), declared = %? (%u tys)\",\n                   tys_to_str(cx.tcx, ts), ts.len(), *bounds, (*bounds).len());\n             }\n-            vec::iter2(ts, *bounds) {|ty, bound|\n+            do vec::iter2(ts, *bounds) {|ty, bound|\n                 check_bounds(cx, e.id, e.span, ty, bound)\n             }\n         }\n@@ -314,10 +314,10 @@ fn check_stmt(stmt: @stmt, cx: ctx, v: visit::vt<ctx>) {\n fn check_ty(aty: @ty, cx: ctx, v: visit::vt<ctx>) {\n     alt aty.node {\n       ty_path(_, id) {\n-        option::iter(cx.tcx.node_type_substs.find(id)) {|ts|\n+        do option::iter(cx.tcx.node_type_substs.find(id)) {|ts|\n             let did = ast_util::def_id_of_def(cx.tcx.def_map.get(id));\n             let bounds = ty::lookup_item_type(cx.tcx, did).bounds;\n-            vec::iter2(ts, *bounds) {|ty, bound|\n+            do vec::iter2(ts, *bounds) {|ty, bound|\n                 check_bounds(cx, aty.id, aty.span, ty, bound)\n             }\n         }"}, {"sha": "9755e0deeaab91c50f1cf7a4be953f31880a4be2", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -273,7 +273,7 @@ fn lookup_lint(dict: lint_dict, s: str)\n }\n \n fn build_settings_item(i: @ast::item, &&cx: ctxt, v: visit::vt<ctxt>) {\n-    cx.with_warn_attrs(i.attrs) {|cx|\n+    do cx.with_warn_attrs(i.attrs) {|cx|\n         if !cx.is_default {\n             cx.sess.warning_settings.settings_map.insert(i.id, cx.curr);\n         }\n@@ -297,7 +297,7 @@ fn build_settings_crate(sess: session::session, crate: @ast::crate) {\n         cx.set_level(lint, level);\n     }\n \n-    cx.with_warn_attrs(crate.node.attrs) {|cx|\n+    do cx.with_warn_attrs(crate.node.attrs) {|cx|\n         // Copy out the default settings\n         for cx.curr.each {|k, v|\n             sess.warning_settings.default_settings.insert(k, v);\n@@ -357,7 +357,7 @@ fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n \n     fn check_foreign_fn(cx: ty::ctxt, fn_id: ast::node_id,\n                        decl: ast::fn_decl) {\n-        let tys = vec::map(decl.inputs) {|a| a.ty };\n+        let tys = vec::map(decl.inputs, {|a| a.ty });\n         for vec::each(vec::append_one(tys, decl.output)) {|ty|\n             alt ty.node {\n               ast::ty_path(_, id) {"}, {"sha": "8aaf53adecec3cd11a98e8f1065a676eda3b04aa", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -406,7 +406,7 @@ fn add_class_fields(self: @ir_maps, did: def_id) {\n \n fn visit_local(local: @local, &&self: @ir_maps, vt: vt<@ir_maps>) {\n     let def_map = self.tcx.def_map;\n-    pat_util::pat_bindings(def_map, local.node.pat) { |p_id, sp, path|\n+    do pat_util::pat_bindings(def_map, local.node.pat) { |p_id, sp, path|\n         #debug[\"adding local variable %d\", p_id];\n         let name = ast_util::path_to_ident(path);\n         (*self).add_live_node_for_node(p_id, lnk_vdef(sp));\n@@ -560,9 +560,9 @@ class liveness {\n         alt expr.node {\n           expr_path(_) {\n             let def = self.tcx.def_map.get(expr.id);\n-            relevant_def(def).map { |rdef|\n+            relevant_def(def).map({ |rdef|\n                 self.variable_from_rdef(rdef, expr.span)\n-            }\n+            })\n           }\n           _ {none}\n         }\n@@ -576,9 +576,9 @@ class liveness {\n                              span: span) -> option<variable> {\n         alt self.tcx.def_map.find(node_id) {\n           some(def) {\n-            relevant_def(def).map { |rdef|\n+            relevant_def(def).map({ |rdef|\n               self.variable_from_rdef(rdef, span)\n-            }\n+            })\n           }\n           none {\n             self.tcx.sess.span_bug(\n@@ -589,7 +589,7 @@ class liveness {\n \n     fn pat_bindings(pat: @pat, f: fn(live_node, variable, span)) {\n         let def_map = self.tcx.def_map;\n-        pat_util::pat_bindings(def_map, pat) {|p_id, sp, _n|\n+        do pat_util::pat_bindings(def_map, pat) {|p_id, sp, _n|\n             let ln = self.live_node(p_id, sp);\n             let var = self.variable(p_id, sp);\n             f(ln, var, sp);\n@@ -663,7 +663,7 @@ class liveness {\n     }\n \n     fn ln_str(ln: live_node) -> str {\n-        io::with_str_writer { |wr|\n+        do io::with_str_writer { |wr|\n             wr.write_str(\"[ln(\");\n             wr.write_uint(*ln);\n             wr.write_str(\") of kind \");\n@@ -695,9 +695,9 @@ class liveness {\n     fn init_from_succ(ln: live_node, succ_ln: live_node) {\n         // more efficient version of init_empty() / merge_from_succ()\n         self.successors[*ln] = succ_ln;\n-        self.indices2(ln, succ_ln) { |idx, succ_idx|\n+        self.indices2(ln, succ_ln, { |idx, succ_idx|\n             self.users[idx] = self.users[succ_idx];\n-        }\n+        });\n         #debug[\"init_from_succ(ln=%s, succ=%s)\",\n                self.ln_str(ln), self.ln_str(succ_ln)];\n     }\n@@ -707,7 +707,7 @@ class liveness {\n         if ln == succ_ln { ret false; }\n \n         let mut changed = false;\n-        self.indices2(ln, succ_ln) { |idx, succ_idx|\n+        do self.indices2(ln, succ_ln) { |idx, succ_idx|\n             changed |= copy_if_invalid(copy self.users[succ_idx].reader,\n                                        self.users[idx].reader);\n             changed |= copy_if_invalid(copy self.users[succ_idx].writer,\n@@ -776,9 +776,9 @@ class liveness {\n         // effectively a return---this only occurs in `for` loops,\n         // where the body is really a closure.\n         let entry_ln: live_node =\n-            self.with_loop_nodes(self.s.exit_ln, self.s.exit_ln) {||\n+            self.with_loop_nodes(self.s.exit_ln, self.s.exit_ln, {||\n                 self.propagate_through_fn_block(decl, body)\n-            };\n+            });\n \n         // hack to skip the loop unless #debug is enabled:\n         #debug[\"^^ liveness computation results for body %d (entry=%s)\",\n@@ -832,7 +832,7 @@ class liveness {\n \n     fn propagate_through_block(blk: blk, succ: live_node) -> live_node {\n         let succ = self.propagate_through_opt_expr(blk.node.expr, succ);\n-        blk.node.stmts.foldr(succ) { |stmt, succ|\n+        do blk.node.stmts.foldr(succ) { |stmt, succ|\n             self.propagate_through_stmt(stmt, succ)\n         }\n     }\n@@ -852,7 +852,7 @@ class liveness {\n     fn propagate_through_decl(decl: @decl, succ: live_node) -> live_node {\n         alt decl.node {\n           decl_local(locals) {\n-            locals.foldr(succ) { |local, succ|\n+            do locals.foldr(succ) { |local, succ|\n                 self.propagate_through_local(local, succ)\n             }\n           }\n@@ -877,9 +877,9 @@ class liveness {\n         // initialization, which is mildly more complex than checking\n         // once at the func header but otherwise equivalent.\n \n-        let opt_init = local.node.init.map { |i| i.expr };\n+        let opt_init = local.node.init.map({ |i| i.expr });\n         let mut succ = self.propagate_through_opt_expr(opt_init, succ);\n-        self.pat_bindings(local.node.pat) { |ln, var, _sp|\n+        do self.pat_bindings(local.node.pat) { |ln, var, _sp|\n             self.init_from_succ(ln, succ);\n             self.define(ln, var);\n             succ = ln;\n@@ -889,14 +889,14 @@ class liveness {\n \n     fn propagate_through_exprs(exprs: ~[@expr],\n                                succ: live_node) -> live_node {\n-        exprs.foldr(succ) { |expr, succ|\n+        do exprs.foldr(succ) { |expr, succ|\n             self.propagate_through_expr(expr, succ)\n         }\n     }\n \n     fn propagate_through_opt_expr(opt_expr: option<@expr>,\n                                   succ: live_node) -> live_node {\n-        opt_expr.foldl(succ) { |succ, expr|\n+        do opt_expr.foldl(succ) { |succ, expr|\n             self.propagate_through_expr(expr, succ)\n         }\n     }\n@@ -930,7 +930,7 @@ class liveness {\n             // the construction of a closure itself is not important,\n             // but we have to consider the closed over variables.\n             let caps = (*self.ir).captures(expr);\n-            (*caps).foldr(succ) { |cap, succ|\n+            do (*caps).foldr(succ) { |cap, succ|\n                 self.init_from_succ(cap.ln, succ);\n                 let var = self.variable_from_rdef(cap.rv, expr.span);\n                 self.acc(cap.ln, var, ACC_READ | ACC_USE);\n@@ -1063,7 +1063,7 @@ class liveness {\n \n           expr_rec(fields, with_expr) {\n             let succ = self.propagate_through_opt_expr(with_expr, succ);\n-            fields.foldr(succ) { |field, succ|\n+            do fields.foldr(succ) { |field, succ|\n                 self.propagate_through_expr(field.node.expr, succ)\n             }\n           }\n@@ -1273,10 +1273,10 @@ class liveness {\n             alt def {\n               def_self(_) {\n                 // Note: the field_map is empty unless we are in a ctor\n-                ret self.ir.field_map.find(fld).map { |var|\n+                ret self.ir.field_map.find(fld).map({ |var|\n                     let ln = self.live_node(expr.id, expr.span);\n                     (ln, var)\n-                };\n+                });\n               }\n               _ { ret none; }\n             }\n@@ -1320,17 +1320,17 @@ class liveness {\n             first_merge = false;\n         }\n         let cond_ln = self.propagate_through_opt_expr(cond, ln);\n-        let body_ln = self.with_loop_nodes(succ, ln) {||\n+        let body_ln = self.with_loop_nodes(succ, ln, {||\n             self.propagate_through_block(body, cond_ln)\n-        };\n+        });\n \n         // repeat until fixed point is reached:\n         while self.merge_from_succ(ln, body_ln, first_merge) {\n             first_merge = false;\n             assert cond_ln == self.propagate_through_opt_expr(cond, ln);\n-            assert body_ln == self.with_loop_nodes(succ, ln) {||\n+            assert body_ln == self.with_loop_nodes(succ, ln, {||\n                 self.propagate_through_block(body, cond_ln)\n-            };\n+            });\n         }\n \n         cond_ln\n@@ -1373,7 +1373,7 @@ fn check_local(local: @local, &&self: @liveness, vt: vt<@liveness>) {\n         // should not be live at this point.\n \n         #debug[\"check_local() with no initializer\"];\n-        (*self).pat_bindings(local.node.pat) { |ln, var, sp|\n+        do (*self).pat_bindings(local.node.pat) { |ln, var, sp|\n             if !self.warn_about_unused(sp, ln, var) {\n                 alt (*self).live_on_exit(ln, var) {\n                   none { /* not live: good */ }\n@@ -1438,7 +1438,7 @@ fn check_expr(expr: @expr, &&self: @liveness, vt: vt<@liveness>) {\n       expr_call(f, args, _) {\n         let targs = ty::ty_fn_args(ty::expr_ty(self.tcx, f));\n         vt.visit_expr(f, self, vt);\n-        vec::iter2(args, targs) { |arg_expr, arg_ty|\n+        do vec::iter2(args, targs) { |arg_expr, arg_ty|\n             alt ty::resolved_mode(self.tcx, arg_ty.mode) {\n               by_val | by_copy | by_ref | by_mutbl_ref{\n                 vt.visit_expr(arg_expr, self, vt);\n@@ -1621,7 +1621,7 @@ impl check_methods for @liveness {\n     }\n \n     fn check_for_reassignments_in_pat(pat: @pat) {\n-        (*self).pat_bindings(pat) { |ln, var, sp|\n+        do (*self).pat_bindings(pat) { |ln, var, sp|\n             self.check_for_reassignment(ln, var, sp);\n         }\n     }\n@@ -1752,7 +1752,7 @@ impl check_methods for @liveness {\n     }\n \n     fn warn_about_unused_or_dead_vars_in_pat(pat: @pat) {\n-        (*self).pat_bindings(pat) { |ln, var, sp|\n+        do (*self).pat_bindings(pat) { |ln, var, sp|\n             if !self.warn_about_unused(sp, ln, var) {\n                 self.warn_about_dead_assign(sp, ln, var);\n             }"}, {"sha": "c139915c0a547b8ba5f65429562ebba13aea0541", "filename": "src/rustc/middle/pat_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fpat_util.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -15,7 +15,7 @@ type pat_id_map = std::map::hashmap<ident, node_id>;\n // use the node_id of their namesake in the first pattern.\n fn pat_id_map(dm: resolve::def_map, pat: @pat) -> pat_id_map {\n     let map = std::map::box_str_hash();\n-    pat_bindings(dm, pat) {|p_id, _s, n|\n+    do pat_bindings(dm, pat) {|p_id, _s, n|\n       map.insert(path_to_ident(n), p_id);\n     };\n     ret map;\n@@ -39,7 +39,7 @@ fn pat_is_variant(dm: resolve::def_map, pat: @pat) -> bool {\n // Could return a constrained type in order to express that (future work)\n fn pat_bindings(dm: resolve::def_map, pat: @pat,\n                 it: fn(node_id, span, @path)) {\n-    walk_pat(pat) {|p|\n+    do walk_pat(pat) {|p|\n         alt p.node {\n           pat_ident(pth, _) if !pat_is_variant(dm, p) {\n             it(p.id, p.span, pth);\n@@ -51,6 +51,6 @@ fn pat_bindings(dm: resolve::def_map, pat: @pat,\n \n fn pat_binding_ids(dm: resolve::def_map, pat: @pat) -> ~[node_id] {\n     let mut found = ~[];\n-    pat_bindings(dm, pat) {|b_id, _sp, _pt| vec::push(found, b_id); };\n+    pat_bindings(dm, pat, {|b_id, _sp, _pt| vec::push(found, b_id); });\n     ret found;\n }"}, {"sha": "a3a81092ed563c3cdb023e0e5fe27aa8134995eb", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -212,7 +212,7 @@ fn iter_import_paths(vi: ast::view_item, f: fn(vp: @ast::view_path)) {\n fn iter_effective_import_paths(vi: ast::view_item,\n                                f: fn(vp: @ast::view_path)) {\n     iter_import_paths(vi, f);\n-    iter_export_paths(vi) {|vp|\n+    do iter_export_paths(vi) {|vp|\n         alt vp.node {\n           ast::view_path_simple(_, _, _) { }\n           // FIXME (but also see #1893): support uniform ident-list exports\n@@ -231,7 +231,7 @@ fn iter_effective_import_paths(vi: ast::view_item,\n fn map_crate(e: @env, c: @ast::crate) {\n \n     fn index_vi(e: @env, i: @ast::view_item, &&sc: scopes, _v: vt<scopes>) {\n-        iter_effective_import_paths(*i) { |vp|\n+        do iter_effective_import_paths(*i) { |vp|\n             alt vp.node {\n               ast::view_path_simple(name, path, id) {\n                 e.imports.insert(id, todo(name, @path.idents, vp.span,\n@@ -255,7 +255,7 @@ fn map_crate(e: @env, c: @ast::crate) {\n \n     fn path_from_scope(sc: scopes, n: str) -> str {\n         let mut path = n + \"::\";\n-        list::iter(sc) {|s|\n+        do list::iter(sc) {|s|\n             alt s {\n               scope_item(i) { path = *i.ident + \"::\" + path; }\n               _ {}\n@@ -294,7 +294,7 @@ fn map_crate(e: @env, c: @ast::crate) {\n     // So we wind up reusing the glob-import machinery when looking at\n     // glob exports. They just do re-exporting in a later step.\n     fn link_glob(e: @env, vi: @ast::view_item, &&sc: scopes, _v: vt<scopes>) {\n-        iter_effective_import_paths(*vi) { |vp|\n+        do iter_effective_import_paths(*vi) { |vp|\n             alt vp.node {\n               ast::view_path_glob(path, _) {\n                 alt follow_import(*e, sc, path.idents, vp.span) {\n@@ -440,7 +440,7 @@ fn resolve_names(e: @env, c: @ast::crate) {\n              refer to, so it's possible to resolve them.\n            */\n           ast::item_impl(_, _, ifce, _, _) {\n-            ifce.iter {|p| resolve_iface_ref(p, sc, e);}\n+            ifce.iter({|p| resolve_iface_ref(p, sc, e);})\n           }\n           ast::item_class(_, ifaces, _, _, _, _) {\n             for ifaces.each {|p|\n@@ -554,7 +554,7 @@ fn visit_item_with_scope(e: @env, i: @ast::item,\n     alt i.node {\n       ast::item_impl(tps, _, ifce, sty, methods) {\n         v.visit_ty_params(tps, sc, v);\n-        option::iter(ifce) {|p| visit::visit_path(p.path, sc, v)};\n+        option::iter(ifce, {|p| visit::visit_path(p.path, sc, v)});\n         v.visit_ty(sty, sc, v);\n         for methods.each {|m|\n             v.visit_ty_params(m.tps, sc, v);\n@@ -588,7 +588,7 @@ fn visit_item_with_scope(e: @env, i: @ast::item,\n                                              local_def(i.id)), ctor.node.dec,\n                             ctor.node.body, ctor.span, ctor.node.id,\n                             ctor_scope, v);\n-        option::iter(m_dtor) {|dtor|\n+        do option::iter(m_dtor) {|dtor|\n           let dtor_scope = @cons(scope_method(dtor.node.self_id, tps),\n                                  class_scope);\n \n@@ -694,7 +694,7 @@ fn visit_local_with_scope(e: @env, loc: @local, &&sc: scopes, v:vt<scopes>) {\n     // scope. We disallow this, in order to make alt patterns consisting of a\n     // single identifier unambiguous (does the pattern \"foo\" refer to enum\n     // foo, or is it binding a new name foo?)\n-    ast_util::walk_pat(loc.node.pat) { |p|\n+    do ast_util::walk_pat(loc.node.pat) { |p|\n         alt p.node {\n           pat_ident(path, _) {\n             alt lookup_in_scope(*e, sc, loc.span, path_to_ident(path),\n@@ -780,7 +780,7 @@ fn resolve_import(e: env, n_id: node_id, name: ast::ident,\n         fn lst(my_id: node_id, vis: ~[@view_item]) -> ~[node_id] {\n             let mut imports = ~[], found = false;\n             for vis.each {|vi|\n-                iter_effective_import_paths(*vi) {|vp|\n+                do iter_effective_import_paths(*vi) {|vp|\n                     alt vp.node {\n                       view_path_simple(_, _, id)\n                       | view_path_glob(_, id) {\n@@ -1180,7 +1180,7 @@ fn lookup_in_ty_params(e: env, name: ident, ty_params: ~[ast::ty_param])\n fn lookup_in_pat(e: env, name: ident, pat: @ast::pat) -> option<node_id> {\n     let mut found = none;\n \n-    pat_util::pat_bindings(e.def_map, pat) {|p_id, _sp, n|\n+    do pat_util::pat_bindings(e.def_map, pat) {|p_id, _sp, n|\n         if str::eq(*path_to_ident(n), *name)\n                     { found = some(p_id); }\n     };\n@@ -1612,7 +1612,7 @@ fn index_view_items(view_items: ~[@ast::view_item],\n           _ {}\n         }\n \n-        iter_effective_import_paths(*vi) {|vp|\n+        do iter_effective_import_paths(*vi) {|vp|\n             alt vp.node {\n               ast::view_path_simple(ident, _, id) {\n                 add_to_index(index, ident, mie_import_ident(id, vp.span));\n@@ -1793,7 +1793,7 @@ fn check_item(e: @env, i: @ast::item, &&x: (), v: vt<()>) {\n }\n \n fn check_pat(e: @env, ch: checker, p: @ast::pat) {\n-    pat_util::pat_bindings(e.def_map, p) {|_i, p_sp, n|\n+    do pat_util::pat_bindings(e.def_map, p) {|_i, p_sp, n|\n        add_name(ch, p_sp, path_to_ident(n));\n     };\n }\n@@ -1840,7 +1840,7 @@ fn check_block(e: @env, b: ast::blk, &&x: (), v: vt<()>) {\n               ast::decl_local(locs) {\n                 let local_values = checker(*e, \"value\");\n                 for locs.each {|loc|\n-                     pat_util::pat_bindings(e.def_map, loc.node.pat)\n+                     do pat_util::pat_bindings(e.def_map, loc.node.pat)\n                          {|_i, p_sp, n|\n                          let ident = path_to_ident(n);\n                          add_name(local_values, p_sp, ident);\n@@ -1943,7 +1943,7 @@ fn check_exports(e: @env) {\n             let ixm = e.mod_map.get(mid.node);\n \n             for ixm.index.each {|ident, mies|\n-                list::iter(mies) {|mie|\n+                do list::iter(mies) {|mie|\n                     alt mie {\n                       mie_item(item) {\n                         let defs =\n@@ -1984,7 +1984,7 @@ fn check_exports(e: @env) {\n \n \n     fn maybe_add_reexport(e: @env, export_id: node_id, def: option<def>) {\n-        option::iter(def) {|def|\n+        do option::iter(def) {|def|\n             add_export(e, export_id, def_id_of_def(def), true);\n         }\n     }\n@@ -2004,7 +2004,7 @@ fn check_exports(e: @env) {\n         if _mod.index.contains_key(ident) {\n             found_something = true;\n             let xs = _mod.index.get(ident);\n-            list::iter(xs) {|x|\n+            do list::iter(xs) {|x|\n                 alt x {\n                   mie_import_ident(id, _) {\n                     alt check e.imports.get(id) {\n@@ -2045,7 +2045,7 @@ fn check_exports(e: @env) {\n             e.sess.span_fatal(sp, #fmt(\"undefined id %s in an export\", *id));\n           }\n           some(ms) {\n-            let maybe_id = list_search(ms) {|m|\n+            let maybe_id = do list_search(ms) {|m|\n                 alt m {\n                   mie_item(@{node: item_enum(_, _, _), id, _}) { some(id) }\n                   _ { none }\n@@ -2069,7 +2069,7 @@ fn check_exports(e: @env) {\n             let mut found = false;\n             alt _mod.index.find(variant_id.node.name) {\n               some(ms) {\n-                list::iter(ms) {|m|\n+                do list::iter(ms) {|m|\n                     alt m {\n                       mie_enum_variant(_, _, actual_parent_id, _) {\n                         found = true;\n@@ -2099,7 +2099,7 @@ fn check_exports(e: @env) {\n             let glob_is_re_exported = int_hash();\n \n             for m.view_items.each {|vi|\n-                iter_export_paths(*vi) { |vp|\n+                do iter_export_paths(*vi) { |vp|\n                     alt vp.node {\n                       ast::view_path_simple(ident, _, id) {\n                         check_export(e, ident, _mod, id, vi);\n@@ -2126,7 +2126,7 @@ fn check_exports(e: @env) {\n                   ast::view_path_glob(_, node_id) { node_id }\n                 };\n                 if ! glob_is_re_exported.contains_key(id) { cont; }\n-                iter_mod(*e, glob.def,\n+                do iter_mod(*e, glob.def,\n                          glob.path.span, outside) {|ident, def|\n                     vec::push(_mod.globbed_exports, ident);\n                     maybe_add_reexport(e, id, some(def));\n@@ -2177,13 +2177,13 @@ fn find_impls_in_view_item(e: env, vi: @ast::view_item,\n         }\n     }\n \n-    iter_effective_import_paths(*vi) { |vp|\n+    do iter_effective_import_paths(*vi) { |vp|\n         alt vp.node {\n           ast::view_path_simple(name, pt, id) {\n             let mut found = ~[];\n             if vec::len(pt.idents) == 1u {\n-                option::iter(sc) {|sc|\n-                    list::iter(sc) {|level|\n+                do option::iter(sc) {|sc|\n+                    do list::iter(sc) {|level|\n                         if vec::len(found) == 0u {\n                             for vec::each(*level) {|imp|\n                                 if imp.ident == pt.idents[0] {\n@@ -2198,7 +2198,7 @@ fn find_impls_in_view_item(e: env, vi: @ast::view_item,\n                     }\n                 }\n             } else {\n-                lookup_imported_impls(e, id) {|is|\n+                do lookup_imported_impls(e, id) {|is|\n                     for vec::each(*is) {|i|\n                         vec::push(impls, @{ident: name with *i});\n                     }\n@@ -2208,9 +2208,9 @@ fn find_impls_in_view_item(e: env, vi: @ast::view_item,\n \n           ast::view_path_list(base, names, _) {\n             for names.each {|nm|\n-                lookup_imported_impls(e, nm.node.id) {|is|\n+                lookup_imported_impls(e, nm.node.id, {|is|\n                     vec::push_all(impls, *is);\n-                }\n+                })\n             }\n           }\n \n@@ -2256,7 +2256,7 @@ fn find_impls_in_item(e: env, i: @ast::item, &impls: ~[@_impl],\n       ast::item_class(tps, ifces, items, _, _, _) {\n           let (_, mthds) = ast_util::split_class_items(items);\n           let n_tps = tps.len();\n-          vec::iter(ifces) {|p|\n+          do vec::iter(ifces) {|p|\n               // The def_id, in this case, identifies the combination of\n               // class and iface\n               vec::push(impls, @{did: local_def(p.id),\n@@ -2289,7 +2289,7 @@ fn find_impls_in_mod_by_id(e: env, defid: def_id, &impls: ~[@_impl],\n             for md.items.each {|i|\n                 find_impls_in_item(e, i, tmp, none, none);\n             }\n-            @vec::filter(tmp) {|i| is_exported(e, i.ident, mi)}\n+            @vec::filter(tmp, {|i| is_exported(e, i.ident, mi)})\n         } else {\n             csearch::get_impls_for_mod(e.sess.cstore, defid, none)\n         };"}, {"sha": "82b47654377cf6c0ec653ce0d526384368a31ce8", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -153,7 +153,7 @@ fn enter_match(dm: def_map, m: match, col: uint, val: ValueRef,\n }\n \n fn enter_default(dm: def_map, m: match, col: uint, val: ValueRef) -> match {\n-    enter_match(dm, m, col, val) {|p|\n+    do enter_match(dm, m, col, val) {|p|\n         alt p.node {\n           ast::pat_wild | ast::pat_rec(_, _) | ast::pat_tup(_) { some(~[]) }\n           ast::pat_ident(_, none) if !pat_is_variant(dm, p) {\n@@ -167,7 +167,7 @@ fn enter_default(dm: def_map, m: match, col: uint, val: ValueRef) -> match {\n fn enter_opt(tcx: ty::ctxt, m: match, opt: opt, col: uint,\n              variant_size: uint, val: ValueRef) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n-    enter_match(tcx.def_map, m, col, val) {|p|\n+    do enter_match(tcx.def_map, m, col, val) {|p|\n         alt p.node {\n           ast::pat_enum(_, subpats) {\n             if opt_eq(tcx, variant_opt(tcx, p.id), opt) {\n@@ -193,7 +193,7 @@ fn enter_opt(tcx: ty::ctxt, m: match, opt: opt, col: uint,\n fn enter_rec(dm: def_map, m: match, col: uint, fields: ~[ast::ident],\n              val: ValueRef) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n-    enter_match(dm, m, col, val) {|p|\n+    do enter_match(dm, m, col, val) {|p|\n         alt p.node {\n           ast::pat_rec(fpats, _) {\n             let mut pats = ~[];\n@@ -214,7 +214,7 @@ fn enter_rec(dm: def_map, m: match, col: uint, fields: ~[ast::ident],\n fn enter_tup(dm: def_map, m: match, col: uint, val: ValueRef,\n              n_elts: uint) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n-    enter_match(dm, m, col, val) {|p|\n+    do enter_match(dm, m, col, val) {|p|\n         alt p.node {\n           ast::pat_tup(elts) { some(elts) }\n           _ { some(vec::from_elem(n_elts, dummy)) }\n@@ -224,7 +224,7 @@ fn enter_tup(dm: def_map, m: match, col: uint, val: ValueRef,\n \n fn enter_box(dm: def_map, m: match, col: uint, val: ValueRef) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n-    enter_match(dm, m, col, val) {|p|\n+    do enter_match(dm, m, col, val) {|p|\n         alt p.node {\n           ast::pat_box(sub) { some(~[sub]) }\n           _ { some(~[dummy]) }\n@@ -234,7 +234,7 @@ fn enter_box(dm: def_map, m: match, col: uint, val: ValueRef) -> match {\n \n fn enter_uniq(dm: def_map, m: match, col: uint, val: ValueRef) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n-    enter_match(dm, m, col, val) {|p|\n+    do enter_match(dm, m, col, val) {|p|\n         alt p.node {\n           ast::pat_uniq(sub) { some(~[sub]) }\n           _ { some(~[dummy]) }\n@@ -285,7 +285,7 @@ fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n     }\n     let vdefs_tg = vdefs.enm;\n     let vdefs_var = vdefs.var;\n-    let args = vec::from_fn(size) { |i|\n+    let args = do vec::from_fn(size) { |i|\n         GEP_enum(bcx, blobptr, vdefs_tg, vdefs_var,\n                  enum_ty_substs, i)\n     };\n@@ -398,11 +398,11 @@ fn compile_submatch(bcx: block, m: match, vals: ~[ValueRef],\n                 bcx.fcx.lllocals.insert(val, loc);\n             };\n             let {bcx: guard_cx, val} = {\n-                with_scope_result(bcx, e.info(), \"guard\") {|bcx|\n+                do with_scope_result(bcx, e.info(), \"guard\") {|bcx|\n                     trans_temp_expr(bcx, e)\n                 }\n             };\n-            bcx = with_cond(guard_cx, Not(guard_cx, val)) {|bcx|\n+            bcx = do with_cond(guard_cx, Not(guard_cx, val)) {|bcx|\n                 compile_submatch(bcx, vec::tail(m), vals, chk, exits);\n                 bcx\n             };\n@@ -553,7 +553,7 @@ fn compile_submatch(bcx: block, m: match, vals: ~[ValueRef],\n               compare {\n                 let t = node_id_type(bcx, pat_id);\n                 let {bcx: after_cx, val: matches} = {\n-                    with_scope_result(bcx, none, \"compare_scope\") {|bcx|\n+                    do with_scope_result(bcx, none, \"compare_scope\") {|bcx|\n                         alt trans_opt(bcx, opt) {\n                           single_result({bcx, val}) {\n                             trans_compare(bcx, ast::eq, test_val, t, val, t)\n@@ -636,7 +636,7 @@ fn trans_alt(bcx: block,\n              mode: ast::alt_mode,\n              dest: dest) -> block {\n     let _icx = bcx.insn_ctxt(\"alt::trans_alt\");\n-    with_scope(bcx, alt_expr.info(), \"alt\") {|bcx|\n+    do with_scope(bcx, alt_expr.info(), \"alt\") {|bcx|\n         trans_alt_inner(bcx, expr, arms, mode, dest)\n     }\n }\n@@ -728,7 +728,7 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n         let vdefs = ast_util::variant_def_ids(ccx.tcx.def_map.get(pat.id));\n         let args = extract_variant_args(bcx, pat.id, vdefs, val);\n         let mut i = 0;\n-        option::iter(sub) {|sub| for vec::each(args.vals) {|argval|\n+        do option::iter(sub) {|sub| for vec::each(args.vals) {|argval|\n             bcx = bind_irrefutable_pat(bcx, sub[i], argval, make_copy);\n             i += 1;\n         }}"}, {"sha": "a743d6254b85e77b684a77f66723437d0f7855c7", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -733,7 +733,7 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n       }\n       ty::ty_class(did,substs) {\n         // Call the dtor if there is one\n-        option::map_default(ty::ty_dtor(bcx.tcx(), did), bcx) {|dt_id|\n+        do option::map_default(ty::ty_dtor(bcx.tcx(), did), bcx) {|dt_id|\n           trans_class_drop(bcx, v, dt_id, did, substs)\n         }\n       }\n@@ -746,7 +746,7 @@ fn trans_class_drop(bcx: block, v0: ValueRef, dtor_did: ast::def_id,\n                     class_did: ast::def_id,\n                     substs: ty::substs) -> block {\n   let drop_flag = GEPi(bcx, v0, ~[0u, 0u]);\n-  with_cond(bcx, IsNotNull(bcx, Load(bcx, drop_flag))) {|cx|\n+  do with_cond(bcx, IsNotNull(bcx, Load(bcx, drop_flag))) {|cx|\n     let mut bcx = cx;\n       // We have to cast v0\n      let classptr = GEPi(bcx, v0, ~[0u, 1u]);\n@@ -864,12 +864,12 @@ fn decr_refcnt_maybe_free(bcx: block, box_ptr: ValueRef, t: ty::t) -> block {\n \n     let llbox_ty = T_opaque_box_ptr(ccx);\n     let box_ptr = PointerCast(bcx, box_ptr, llbox_ty);\n-    with_cond(bcx, IsNotNull(bcx, box_ptr)) {|bcx|\n+    do with_cond(bcx, IsNotNull(bcx, box_ptr)) {|bcx|\n         let rc_ptr = GEPi(bcx, box_ptr, ~[0u, abi::box_field_refcnt]);\n         let rc = Sub(bcx, Load(bcx, rc_ptr), C_int(ccx, 1));\n         Store(bcx, rc, rc_ptr);\n         let zero_test = ICmp(bcx, lib::llvm::IntEQ, C_int(ccx, 0), rc);\n-        with_cond(bcx, zero_test) {|bcx| free_ty(bcx, box_ptr, t)}\n+        with_cond(bcx, zero_test, {|bcx| free_ty(bcx, box_ptr, t)})\n     }\n }\n \n@@ -1354,7 +1354,7 @@ fn copy_val(cx: block, action: copy_action, dst: ValueRef,\n         let dstcmp = load_if_immediate(cx, dst, t);\n         let cast = PointerCast(cx, dstcmp, val_ty(src));\n         // Self-copy check\n-        with_cond(cx, ICmp(cx, lib::llvm::IntNE, cast, src)) {|bcx|\n+        do with_cond(cx, ICmp(cx, lib::llvm::IntNE, cast, src)) {|bcx|\n             copy_val_no_check(bcx, action, dst, src, t)\n         }\n     } else {\n@@ -1637,7 +1637,7 @@ fn fail_if_zero(cx: block, span: span, divmod: ast::binop,\n                           ty_to_str(cx.ccx().tcx, rhs_t));\n       }\n     };\n-    with_cond(cx, is_zero) {|bcx|\n+    do with_cond(cx, is_zero) {|bcx|\n         trans_fail(bcx, some(span), text)\n     }\n }\n@@ -1870,7 +1870,7 @@ fn trans_lazy_binop(bcx: block, op: lazy_binop_ty, a: @ast::expr,\n                     b: @ast::expr, dest: dest) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_lazy_binop\");\n     let {bcx: past_lhs, val: lhs} = {\n-        with_scope_result(bcx, a.info(), \"lhs\") { |bcx|\n+        do with_scope_result(bcx, a.info(), \"lhs\") { |bcx|\n             trans_temp_expr(bcx, a)\n         }\n     };\n@@ -1882,7 +1882,7 @@ fn trans_lazy_binop(bcx: block, op: lazy_binop_ty, a: @ast::expr,\n       lazy_or { CondBr(past_lhs, lhs, join.llbb, before_rhs.llbb); }\n     }\n     let {bcx: past_rhs, val: rhs} = {\n-        with_scope_result(before_rhs, b.info(), \"rhs\") { |bcx|\n+        do with_scope_result(before_rhs, b.info(), \"rhs\") { |bcx|\n             trans_temp_expr(bcx, b)\n         }\n     };\n@@ -2331,7 +2331,7 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n               ast::item_enum(_, _, _) {\n                 let vs_here = ty::enum_variants(ccx.tcx, local_def(item.id));\n                 let vs_there = ty::enum_variants(ccx.tcx, parent_id);\n-                vec::iter2(*vs_here, *vs_there) {|here, there|\n+                do vec::iter2(*vs_here, *vs_there) {|here, there|\n                     if there.id == fn_id { my_id = here.id.node; }\n                     ccx.external.insert(there.id, some(here.id.node));\n                 }\n@@ -2622,7 +2622,7 @@ fn trans_index(cx: block, ex: @ast::expr, base: @ast::expr,\n     #debug(\"trans_index: len %s\", val_str(bcx.ccx().tn, len));\n \n     let bounds_check = ICmp(bcx, lib::llvm::IntUGE, scaled_ix, len);\n-    let bcx = with_cond(bcx, bounds_check) {|bcx|\n+    let bcx = do with_cond(bcx, bounds_check) {|bcx|\n         // fail: bad bounds check.\n         trans_fail(bcx, some(ex.span), \"bounds check\")\n     };\n@@ -3109,7 +3109,7 @@ fn trans_args(cx: block, llenv: ValueRef, args: call_args, fn_ty: ty::t,\n       arg_exprs(es) {\n         let llarg_tys = type_of_explicit_args(ccx, arg_tys);\n         let last = es.len() - 1u;\n-        vec::iteri(es) {|i, e|\n+        do vec::iteri(es) {|i, e|\n             let r = trans_arg_expr(bcx, arg_tys[i], llarg_tys[i],\n                                    e, temp_cleanups, if i == last { ret_flag }\n                                    else { none }, 0u);\n@@ -3125,7 +3125,7 @@ fn trans_args(cx: block, llenv: ValueRef, args: call_args, fn_ty: ty::t,\n     // now that all arguments have been successfully built, we can revoke any\n     // temporary cleanups, as they are only needed if argument construction\n     // should fail (for example, cleanup of copy mode args).\n-    vec::iter(temp_cleanups) {|c|\n+    do vec::iter(temp_cleanups) {|c|\n         revoke_clean(bcx, c)\n     }\n \n@@ -3169,7 +3169,7 @@ fn trans_call_inner(\n     args: call_args,\n     dest: dest) -> block {\n \n-    with_scope(in_cx, call_info, \"call\") {|cx|\n+    do with_scope(in_cx, call_info, \"call\") {|cx|\n         let ret_in_loop = alt args {\n           arg_exprs(args) { args.len() > 0u && alt vec::last(args).node {\n             ast::expr_loop_body(@{node: ast::expr_fn_block(_, body, _), _}) {\n@@ -3237,8 +3237,8 @@ fn trans_call_inner(\n         if ty::type_is_bot(ret_ty) {\n             Unreachable(bcx);\n         } else if ret_in_loop {\n-            bcx = with_cond(bcx, Load(bcx, option::get(ret_flag))) {|bcx|\n-                option::iter(copy bcx.fcx.loop_ret) {|lret|\n+            bcx = do with_cond(bcx, Load(bcx, option::get(ret_flag))) {|bcx|\n+                do option::iter(copy bcx.fcx.loop_ret) {|lret|\n                     Store(bcx, C_bool(true), lret.flagptr);\n                     Store(bcx, C_bool(false), bcx.fcx.llretptr);\n                 }\n@@ -3297,7 +3297,7 @@ fn need_invoke(bcx: block) -> bool {\n \n fn have_cached_lpad(bcx: block) -> bool {\n     let mut res = false;\n-    in_lpad_scope_cx(bcx) {|inf|\n+    do in_lpad_scope_cx(bcx) {|inf|\n         alt inf.landing_pad {\n           some(_) { res = true; }\n           none { res = false; }\n@@ -3325,7 +3325,7 @@ fn get_landing_pad(bcx: block) -> BasicBlockRef {\n     let _icx = bcx.insn_ctxt(\"get_landing_pad\");\n \n     let mut cached = none, pad_bcx = bcx; // Guaranteed to be set below\n-    in_lpad_scope_cx(bcx) {|inf|\n+    do in_lpad_scope_cx(bcx) {|inf|\n         // If there is a valid landing pad still around, use it\n         alt copy inf.landing_pad {\n           some(target) { cached = some(target); }\n@@ -3585,7 +3585,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n             ret alt::trans_alt(bcx, e, expr, arms, mode, dest);\n           }\n           ast::expr_block(blk) {\n-            ret with_scope(bcx, blk.info(), \"block-expr body\") {|bcx|\n+            ret do with_scope(bcx, blk.info(), \"block-expr body\") {|bcx|\n                 trans_block(bcx, blk, dest)\n             };\n           }\n@@ -3697,7 +3697,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n             otherwise. */\n             let c = get_extern_const(bcx.ccx().externs, bcx.ccx().llmod,\n                                      \"check_claims\", T_bool());\n-            ret with_cond(bcx, Load(bcx, c)) {|bcx|\n+            ret do with_cond(bcx, Load(bcx, c)) {|bcx|\n                 trans_check_expr(bcx, e, a, \"Claim\")\n             };\n           }\n@@ -3895,13 +3895,14 @@ fn trans_log(log_ex: @ast::expr, lvl: @ast::expr,\n     };\n     let current_level = Load(bcx, global);\n     let {bcx, val: level} = {\n-        with_scope_result(bcx, lvl.info(), \"level\") {|bcx|\n+        do with_scope_result(bcx, lvl.info(), \"level\") {|bcx|\n             trans_temp_expr(bcx, lvl)\n         }\n     };\n \n-    with_cond(bcx, ICmp(bcx, lib::llvm::IntUGE, current_level, level)) {|bcx|\n-        with_scope(bcx, log_ex.info(), \"log\") {|bcx|\n+    do with_cond(bcx, ICmp(bcx, lib::llvm::IntUGE, current_level, level)) {\n+        |bcx|\n+        do with_scope(bcx, log_ex.info(), \"log\") {|bcx|\n             let {bcx, val, _} = trans_temp_expr(bcx, e);\n             let e_ty = expr_ty(bcx, e);\n             let tydesc = get_tydesc_simple(ccx, e_ty);\n@@ -3919,11 +3920,11 @@ fn trans_check_expr(bcx: block, chk_expr: @ast::expr,\n     let _icx = bcx.insn_ctxt(\"trans_check_expr\");\n     let expr_str = s + \" \" + expr_to_str(pred_expr) + \" failed\";\n     let {bcx, val} = {\n-        with_scope_result(bcx, chk_expr.info(), \"check\") {|bcx|\n+        do with_scope_result(bcx, chk_expr.info(), \"check\") {|bcx|\n             trans_temp_expr(bcx, pred_expr)\n         }\n     };\n-    with_cond(bcx, Not(bcx, val)) {|bcx|\n+    do with_cond(bcx, Not(bcx, val)) {|bcx|\n         trans_fail(bcx, some(pred_expr.span), expr_str)\n     }\n }\n@@ -4159,7 +4160,7 @@ fn new_block(cx: fn_ctxt, parent: option<block>, +kind: block_kind,\n         llvm::LLVMAppendBasicBlock(cx.llfn, buf)\n     });\n     let bcx = mk_block(llbb, parent, kind, opt_node_info, cx);\n-    option::iter(parent) {|cx|\n+    do option::iter(parent) {|cx|\n         if cx.unreachable { Unreachable(bcx); }\n     };\n     ret bcx;\n@@ -4223,7 +4224,7 @@ fn trans_block_cleanups_(bcx: block, cleanup_cx: block, is_lpad: bool) ->\n     alt check cleanup_cx.kind {\n       block_scope({cleanups, _}) {\n         let cleanups = copy cleanups;\n-        vec::riter(cleanups) {|cu|\n+        do vec::riter(cleanups) {|cu|\n             alt cu {\n               clean(cfn, cleanup_type) | clean_temp(_, cfn, cleanup_type) {\n                 // Some types don't need to be cleaned up during\n@@ -4361,7 +4362,7 @@ fn alloc_local(cx: block, local: @ast::local) -> block {\n     };\n     let val = alloc_ty(cx, t);\n     if cx.sess().opts.debuginfo {\n-        option::iter(simple_name) {|name|\n+        do option::iter(simple_name) {|name|\n             str::as_c_str(*name, {|buf|\n                 llvm::LLVMSetValueName(val, buf)\n             });\n@@ -4375,7 +4376,7 @@ fn trans_block(bcx: block, b: ast::blk, dest: dest)\n     -> block {\n     let _icx = bcx.insn_ctxt(\"trans_block\");\n     let mut bcx = bcx;\n-    block_locals(b) {|local| bcx = alloc_local(bcx, local); };\n+    do block_locals(b) {|local| bcx = alloc_local(bcx, local); };\n     for vec::each(b.node.stmts) {|s|\n         debuginfo::update_source_pos(bcx, b.span);\n         bcx = trans_stmt(bcx, *s);\n@@ -4871,7 +4872,7 @@ fn trans_class_dtor(ccx: @crate_ctxt, path: path,\n   /* Look up the parent class's def_id */\n   let mut class_ty = ty::lookup_item_type(tcx, parent_id).ty;\n   /* Substitute in the class type if necessary */\n-  option::iter(psubsts) {|ss|\n+  do option::iter(psubsts) {|ss|\n     class_ty = ty::subst_tps(tcx, ss.tys, class_ty);\n   }\n \n@@ -4889,7 +4890,7 @@ fn trans_class_dtor(ccx: @crate_ctxt, path: path,\n \n   /* If we're monomorphizing, register the monomorphized decl\n      for the dtor */\n-  option::iter(hash_id) {|h_id|\n+  do option::iter(hash_id) {|h_id|\n     ccx.monomorphized.insert(h_id, lldecl);\n   }\n   /* Translate the dtor body */\n@@ -4966,7 +4967,7 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n           trans_class_ctor(ccx, *path, ctor.node.dec, ctor.node.body,\n                            get_item_val(ccx, ctor.node.id), psubsts,\n                            ctor.node.id, local_def(item.id), ctor.span);\n-          option::iter(m_dtor) {|dtor|\n+          do option::iter(m_dtor) {|dtor|\n              trans_class_dtor(ccx, *path, dtor.node.body,\n                dtor.node.id, none, none, local_def(item.id));\n           };"}, {"sha": "f2e0a9eaef2b73f980a55b091c0bae63cc4680b4", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -672,7 +672,7 @@ fn Call(cx: block, Fn: ValueRef, Args: ~[ValueRef]) -> ValueRef {\n \n         #debug[\"Call(Fn=%s, Args=%?)\",\n                val_str(cx.ccx().tn, Fn),\n-               Args.map { |arg| val_str(cx.ccx().tn, arg) }];\n+               Args.map({ |arg| val_str(cx.ccx().tn, arg) })];\n \n         ret llvm::LLVMBuildCall(B(cx), Fn, vec::unsafe::to_ptr(Args),\n                                 Args.len() as c_uint, noname());"}, {"sha": "c98fe609661e89442b4686fc0651ee79e2eda50f", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -233,7 +233,7 @@ fn store_environment(bcx: block,\n \n     // Copy expr values into boxed bindings.\n     let mut bcx = bcx;\n-    vec::iteri(bound_values) { |i, bv|\n+    do vec::iteri(bound_values) { |i, bv|\n         #debug[\"Copy %s into closure\", ev_to_str(ccx, bv)];\n \n         if !ccx.sess.no_asm_comments() {\n@@ -294,7 +294,7 @@ fn build_closure(bcx0: block,\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n \n     // Package up the captured upvars\n-    vec::iter(cap_vars) { |cap_var|\n+    do vec::iter(cap_vars) { |cap_var|\n         #debug[\"Building closure: captured variable %?\", cap_var];\n         let lv = trans_local_var(bcx, cap_var.def);\n         let nid = ast_util::def_id_of_def(cap_var.def).node;\n@@ -323,7 +323,7 @@ fn build_closure(bcx0: block,\n           }\n         }\n     }\n-    option::iter(include_ret_handle) {|flagptr|\n+    do option::iter(include_ret_handle) {|flagptr|\n         let our_ret = alt bcx.fcx.loop_ret {\n           some({retptr, _}) { retptr }\n           none { bcx.fcx.llretptr }\n@@ -354,7 +354,7 @@ fn load_environment(fcx: fn_ctxt,\n \n     // Populate the upvars from the environment.\n     let mut i = 0u;\n-    vec::iter(cap_vars) { |cap_var|\n+    do vec::iter(cap_vars) { |cap_var|\n         alt cap_var.mode {\n           capture::cap_drop { /* ignore */ }\n           _ {\n@@ -504,7 +504,7 @@ fn make_fn_glue(\n     let fn_env = fn@(ck: ty::closure_kind) -> block {\n         let box_cell_v = GEPi(cx, v, ~[0u, abi::fn_field_box]);\n         let box_ptr_v = Load(cx, box_cell_v);\n-        with_cond(cx, IsNotNull(cx, box_ptr_v)) {|bcx|\n+        do with_cond(cx, IsNotNull(cx, box_ptr_v)) {|bcx|\n             let closure_ty = ty::mk_opaque_closure_ptr(tcx, ck);\n             glue_fn(bcx, box_cell_v, closure_ty)\n         }\n@@ -537,7 +537,7 @@ fn make_opaque_cbox_take_glue(\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n     let llopaquecboxty = T_opaque_box_ptr(ccx);\n     let cbox_in = Load(bcx, cboxptr);\n-    with_cond(bcx, IsNotNull(bcx, cbox_in)) {|bcx|\n+    do with_cond(bcx, IsNotNull(bcx, cbox_in)) {|bcx|\n         // Load the size from the type descr found in the cbox\n         let cbox_in = PointerCast(bcx, cbox_in, llopaquecboxty);\n         let tydescptr = GEPi(bcx, cbox_in, ~[0u, abi::box_field_tydesc]);\n@@ -599,7 +599,7 @@ fn make_opaque_cbox_free_glue(\n     }\n \n     let ccx = bcx.ccx();\n-    with_cond(bcx, IsNotNull(bcx, cbox)) {|bcx|\n+    do with_cond(bcx, IsNotNull(bcx, cbox)) {|bcx|\n         // Load the type descr found in the cbox\n         let lltydescty = T_ptr(ccx.tydesc_type);\n         let cbox = PointerCast(bcx, cbox, T_opaque_cbox_ptr(ccx));"}, {"sha": "cf23bf7e6bcb31468dfaad928002922ab8eae843", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -251,7 +251,7 @@ fn add_clean(cx: block, val: ValueRef, ty: ty::t) {\n            cx.to_str(), val_str(cx.ccx().tn, val),\n            ty_to_str(cx.ccx().tcx, ty)];\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n-    in_scope_cx(cx) {|info|\n+    do in_scope_cx(cx) {|info|\n         vec::push(info.cleanups, clean({|a|base::drop_ty(a, val, ty)},\n                                 cleanup_type));\n         scope_clean_changed(info);\n@@ -271,7 +271,7 @@ fn add_clean_temp(cx: block, val: ValueRef, ty: ty::t) {\n             ret base::drop_ty(bcx, val, ty);\n         }\n     }\n-    in_scope_cx(cx) {|info|\n+    do in_scope_cx(cx) {|info|\n         vec::push(info.cleanups, clean_temp(val, {|a|do_drop(a, val, ty)},\n                                      cleanup_type));\n         scope_clean_changed(info);\n@@ -283,7 +283,7 @@ fn add_clean_temp_mem(cx: block, val: ValueRef, ty: ty::t) {\n            cx.to_str(), val_str(cx.ccx().tn, val),\n            ty_to_str(cx.ccx().tcx, ty)];\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n-    in_scope_cx(cx) {|info|\n+    do in_scope_cx(cx) {|info|\n         vec::push(info.cleanups,\n                   clean_temp(val, {|a|base::drop_ty(a, val, ty)},\n                              cleanup_type));\n@@ -295,7 +295,7 @@ fn add_clean_free(cx: block, ptr: ValueRef, heap: heap) {\n       heap_shared { {|a|base::trans_free(a, ptr)} }\n       heap_exchange { {|a|base::trans_unique_free(a, ptr)} }\n     };\n-    in_scope_cx(cx) {|info|\n+    do in_scope_cx(cx) {|info|\n         vec::push(info.cleanups, clean_temp(ptr, free_fn,\n                                      normal_exit_and_unwind));\n         scope_clean_changed(info);\n@@ -307,8 +307,8 @@ fn add_clean_free(cx: block, ptr: ValueRef, heap: heap) {\n // this will be more involved. For now, we simply zero out the local, and the\n // drop glue checks whether it is zero.\n fn revoke_clean(cx: block, val: ValueRef) {\n-    in_scope_cx(cx) {|info|\n-        option::iter(vec::position(info.cleanups, {|cu|\n+    do in_scope_cx(cx) {|info|\n+        do option::iter(vec::position(info.cleanups, {|cu|\n             alt cu { clean_temp(v, _, _) if v == val { true } _ { false } }\n         })) {|i|\n             info.cleanups =\n@@ -361,7 +361,7 @@ impl node_info for ast::blk {\n \n impl node_info for option<@ast::expr> {\n     fn info() -> option<node_info> {\n-        self.chain { |s| s.info() }\n+        self.chain({ |s| s.info() })\n     }\n }\n \n@@ -840,7 +840,7 @@ fn C_cstr(cx: @crate_ctxt, s: str) -> ValueRef {\n       none { }\n     }\n \n-    let sc = str::as_c_str(s) {|buf|\n+    let sc = do str::as_c_str(s) {|buf|\n         llvm::LLVMConstString(buf, str::len(s) as c_uint, False)\n     };\n     let g =\n@@ -862,7 +862,7 @@ fn C_estr_slice(cx: @crate_ctxt, s: str) -> ValueRef {\n \n // Returns a Plain Old LLVM String:\n fn C_postr(s: str) -> ValueRef {\n-    ret str::as_c_str(s) {|buf|\n+    ret do str::as_c_str(s) {|buf|\n         llvm::LLVMConstString(buf, str::len(s) as c_uint, False)\n     };\n }\n@@ -924,7 +924,7 @@ fn hash_mono_id(&&mi: mono_id) -> uint {\n         h = h * alt param {\n           mono_precise(ty, vts) {\n             let mut h = ty::type_id(ty);\n-            option::iter(vts) {|vts|\n+            do option::iter(vts) {|vts|\n                 for vec::each(vts) {|vt| h += hash_mono_id(vt); }\n             }\n             h\n@@ -980,7 +980,7 @@ fn node_id_type_params(bcx: block, id: ast::node_id) -> ~[ty::t] {\n     let params = ty::node_id_to_type_params(tcx, id);\n     alt bcx.fcx.param_substs {\n       some(substs) {\n-        vec::map(params) {|t| ty::subst_tps(tcx, substs.tys, t) }\n+        vec::map(params, {|t| ty::subst_tps(tcx, substs.tys, t) })\n       }\n       _ { params }\n     }"}, {"sha": "23a90e7b39f9bc79d9bcb1775c842859bcd64d1e", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -67,7 +67,7 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n     fn struct_tys(ty: TypeRef) -> ~[TypeRef] {\n         let n = llvm::LLVMCountStructElementTypes(ty);\n         let elts = vec::from_elem(n as uint, ptr::null());\n-        vec::as_buf(elts) {|buf|\n+        do vec::as_buf(elts) {|buf|\n             llvm::LLVMGetStructElementTypes(ty, buf);\n         }\n         ret elts;\n@@ -82,7 +82,7 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n             2 /* float */ { 4u }\n             3 /* double */ { 8u }\n             10 /* struct */ {\n-                vec::foldl(0u, struct_tys(ty)) {|a, t|\n+                do vec::foldl(0u, struct_tys(ty)) {|a, t|\n                     uint::max(a, ty_align(t))\n                 }\n             }\n@@ -105,7 +105,7 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n             2 /* float */ { 4u }\n             3 /* double */ { 8u }\n             10 /* struct */ {\n-                vec::foldl(0u, struct_tys(ty)) {|s, t|\n+                do vec::foldl(0u, struct_tys(ty)) {|s, t|\n                     s + ty_size(t)\n                 }\n             }\n@@ -404,12 +404,12 @@ fn x86_64_tys(atys: ~[TypeRef],\n \n fn decl_x86_64_fn(tys: x86_64_tys,\n                   decl: fn(fnty: TypeRef) -> ValueRef) -> ValueRef {\n-    let atys = vec::map(tys.arg_tys) {|t| t.ty };\n+    let atys = vec::map(tys.arg_tys, {|t| t.ty });\n     let rty = tys.ret_ty.ty;\n     let fnty = T_fn(atys, rty);\n     let llfn = decl(fnty);\n \n-    vec::iteri(tys.attrs) {|i, a|\n+    do vec::iteri(tys.attrs) {|i, a|\n         alt a {\n             option::some(attr) {\n                 let llarg = get_param(llfn, i);\n@@ -640,7 +640,7 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n             let _icx = bcx.insn_ctxt(\"foreign::shim::build_ret\");\n             alt tys.x86_64_tys {\n                 some(x86_64) {\n-                    vec::iteri(x86_64.attrs) {|i, a|\n+                    do vec::iteri(x86_64.attrs) {|i, a|\n                         alt a {\n                             some(attr) {\n                                 llvm::LLVMAddInstrAttribute(\n@@ -691,7 +691,7 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n         // Declare the \"prototype\" for the base function F:\n         alt tys.x86_64_tys {\n           some(x86_64) {\n-            decl_x86_64_fn(x86_64) {|fnty|\n+            do decl_x86_64_fn(x86_64) {|fnty|\n                 decl_fn(ccx.llmod, lname, cc, fnty)\n             }\n           }\n@@ -1153,7 +1153,7 @@ fn register_extern_fn(ccx: @crate_ctxt, sp: span,\n     ret if ccx.sess.targ_cfg.arch == arch_x86_64 {\n         let ret_def = !ty::type_is_bot(ret_ty) && !ty::type_is_nil(ret_ty);\n         let x86_64 = x86_64_tys(llargtys, llretty, ret_def);\n-        decl_x86_64_fn(x86_64) {|fnty|\n+        do decl_x86_64_fn(x86_64) {|fnty|\n             register_fn_fuller(ccx, sp, path, node_id,\n                                t, lib::llvm::CCallConv, fnty)\n         }"}, {"sha": "b62434eb21196830619eb07851ef93d261e7ae06", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -260,7 +260,7 @@ fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: ~[ty::t],\n                                                              impl_id))),\n                          {|| \"make_impl_vtable: non-iface-type implemented\"});\n     let has_tps = (*ty::lookup_item_type(ccx.tcx, impl_id).bounds).len() > 0u;\n-    make_vtable(ccx, vec::map(*ty::iface_methods(tcx, ifce_id)) {|im|\n+    make_vtable(ccx, vec::map(*ty::iface_methods(tcx, ifce_id), {|im|\n         let fty = ty::subst_tps(tcx, substs, ty::mk_fn(tcx, im.fty));\n         if (*im.tps).len() > 0u || ty::type_has_self(fty) {\n             C_null(T_ptr(T_nil()))\n@@ -279,7 +279,7 @@ fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: ~[ty::t],\n                 trans_external_path(ccx, m_id, fty)\n             }\n         }\n-    })\n+    }))\n }\n \n fn trans_cast(bcx: block, val: @ast::expr, id: ast::node_id, dest: dest)"}, {"sha": "05253f29adcc14429bb98b43958494b7bf66ea0d", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -53,7 +53,7 @@ fn traverse_exports(cx: ctx, vis: ~[@view_item]) -> bool {\n }\n \n fn traverse_export(cx: ctx, exp_id: node_id) {\n-    option::iter(cx.exp_map.find(exp_id)) {|defs|\n+    do option::iter(cx.exp_map.find(exp_id)) {|defs|\n         for vec::each(defs) {|def| traverse_def_id(cx, def.id); }\n     }\n }\n@@ -111,7 +111,7 @@ fn traverse_public_item(cx: ctx, item: @item) {\n       }\n       item_class(tps, _ifaces, items, ctor, m_dtor, _) {\n         cx.rmap.insert(ctor.node.id, ());\n-        option::iter(m_dtor) {|dtor|\n+        do option::iter(m_dtor) {|dtor|\n             cx.rmap.insert(dtor.node.id, ());\n             // dtors don't have attrs\n             if tps.len() > 0u {"}, {"sha": "00af035e1fa14ddc95c893ecb92039c8d07b07e3", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -129,12 +129,12 @@ impl methods for reflector {\n \n           ty::ty_vec(mt) { self.bracketed_mt(\"vec\", mt, ~[]) }\n           ty::ty_estr(vst) {\n-            self.vstore_name_and_extra(t, vst) {|name, extra|\n+            do self.vstore_name_and_extra(t, vst) {|name, extra|\n                 self.visit(\"estr_\" + name, extra)\n             }\n           }\n           ty::ty_evec(mt, vst) {\n-            self.vstore_name_and_extra(t, vst) {|name, extra|\n+            do self.vstore_name_and_extra(t, vst) {|name, extra|\n                 self.bracketed_mt(\"evec_\" + name, mt, extra)\n             }\n           }"}, {"sha": "404682ada7b9e395fe02faea381a72c0c9d19938", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -28,7 +28,7 @@ type nominal_id = @{did: ast::def_id, parent_id: option<ast::def_id>,\n fn mk_nominal_id(tcx: ty::ctxt, did: ast::def_id,\n                  parent_id: option<ast::def_id>,\n                  tps: ~[ty::t]) -> nominal_id {\n-    let tps_norm = tps.map { |t| ty::normalize_ty(tcx, t) };\n+    let tps_norm = tps.map({ |t| ty::normalize_ty(tcx, t) });\n     @{did: did, parent_id: parent_id, tps: tps_norm}\n }\n \n@@ -49,7 +49,7 @@ fn eq_nominal_id(&&mi: nominal_id, &&ni: nominal_id) -> bool {\n     if mi.did != ni.did {\n         false\n     } else {\n-        vec::all2(mi.tps, ni.tps) { |m_tp, n_tp|\n+        do vec::all2(mi.tps, ni.tps) { |m_tp, n_tp|\n             ty::type_id(m_tp) == ty::type_id(n_tp)\n         }\n     }\n@@ -137,7 +137,7 @@ enum enum_kind {\n \n fn enum_kind(ccx: @crate_ctxt, did: ast::def_id) -> enum_kind {\n     let variants = ty::enum_variants(ccx.tcx, did);\n-    if vec::any(*variants) {|v| vec::len(v.args) > 0u} {\n+    if vec::any(*variants, {|v| vec::len(v.args) > 0u}) {\n         if vec::len(*variants) == 1u { tk_newtype }\n         else { tk_complex }\n     } else {\n@@ -338,7 +338,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t) -> ~[u8] {\n             ~[shape_res]\n           }\n         else { ~[shape_struct] }, sub = ~[];\n-        option::iter(m_dtor_did) {|dtor_did|\n+        do option::iter(m_dtor_did) {|dtor_did|\n           let ri = @{did: dtor_did, parent_id: some(did), tps: tps};\n           let id = interner::intern(ccx.shape_cx.resources, ri);\n           add_u16(s, id as u16);\n@@ -391,7 +391,7 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n     while i < ccx.shape_cx.tag_order.len() {\n         let {did, substs} = ccx.shape_cx.tag_order[i];\n         let variants = @ty::substd_enum_variants(ccx.tcx, did, substs);\n-        vec::iter(*variants) {|v|\n+        do vec::iter(*variants) {|v|\n             offsets += ~[vec::len(data) as u16];\n \n             let variant_shape = shape_of_variant(ccx, v);\n@@ -583,7 +583,7 @@ fn gen_resource_shapes(ccx: @crate_ctxt) -> ValueRef {\n     for uint::range(0u, len) {|i|\n         let ri = interner::get(ccx.shape_cx.resources, i);\n         for ri.tps.each() {|s| assert !ty::type_has_params(s); }\n-        option::iter(ri.parent_id) {|id|\n+        do option::iter(ri.parent_id) {|id|\n             dtors += ~[trans::base::get_res_dtor(ccx, ri.did, id, ri.tps)];\n         }\n     }\n@@ -742,7 +742,7 @@ fn simplify_type(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n                                         ty::mk_u8(tcx),\n                                         mutbl: ast::m_mutbl}}] }\n                 else { ~[] }) +\n-              ty::lookup_class_fields(tcx, did).map {|f|\n+              do ty::lookup_class_fields(tcx, did).map {|f|\n                  let t = ty::lookup_field_type(tcx, did, f.id, substs);\n                  {ident: f.ident,\n                   mt: {ty: simplify_type(tcx, t), mutbl: ast::m_const}}\n@@ -752,5 +752,5 @@ fn simplify_type(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n           _ { typ }\n         }\n     }\n-    ty::fold_ty(tcx, typ) {|t| simplifier(tcx, t) }\n+    ty::fold_ty(tcx, typ, {|t| simplifier(tcx, t) })\n }"}, {"sha": "cda8f2f1e524ac6a6949c64285a6ea4d8be20bc1", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -360,7 +360,7 @@ fn trans_append_literal(bcx: block, vptrptr: ValueRef, vec_ty: ty::t,\n         let new_fill = Add(bcx, old_fill, elt_sz);\n         let do_grow = ICmp(bcx, lib::llvm::IntUGT, new_fill,\n                            get_alloc(bcx, vptr));\n-        bcx = base::with_cond(bcx, do_grow) {|bcx|\n+        bcx = do base::with_cond(bcx, do_grow) {|bcx|\n             let pt = PointerCast(bcx, vptrptr,\n                                  T_ptr(T_ptr(T_i8())));\n             Call(bcx, ccx.upcalls.vec_grow, ~[pt, new_fill]);"}, {"sha": "1ae34c5ce600b785d9f821c398e4a56503812034", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -16,7 +16,7 @@ export type_of_non_gc_box;\n \n fn type_of_explicit_args(cx: @crate_ctxt,\n                          inputs: ~[ty::arg]) -> ~[TypeRef] {\n-    vec::map(inputs) {|arg|\n+    do vec::map(inputs) {|arg|\n         let arg_ty = arg.ty;\n         let llty = type_of(cx, arg_ty);\n         alt ty::resolved_mode(cx.tcx, arg.mode) {\n@@ -175,7 +175,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n           ty::ty_class(did, ts) {\n             // Only instance vars are record fields at runtime.\n             let fields = lookup_class_fields(cx.tcx, did);\n-            let mut tys = vec::map(fields) {|f|\n+            let mut tys = do vec::map(fields) {|f|\n                 let t = ty::lookup_field_type(cx.tcx, did, f.id, ts);\n                 type_of(cx, t)\n             };"}, {"sha": "f71ff22db883be8980af45e3b248e3e4e0da370a", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -114,7 +114,7 @@ fn type_needs(cx: ctx, use: uint, ty: ty::t) {\n \n fn type_needs_inner(cx: ctx, use: uint, ty: ty::t,\n                     enums_seen: @list<def_id>) {\n-    ty::maybe_walk_ty(ty) {|ty|\n+    do ty::maybe_walk_ty(ty) {|ty|\n         if ty::type_has_params(ty) {\n             alt ty::get(ty).struct {\n                 /*\n@@ -181,11 +181,11 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n         }\n       }\n       expr_path(_) {\n-        cx.ccx.tcx.node_type_substs.find(e.id).iter {|ts|\n+        do cx.ccx.tcx.node_type_substs.find(e.id).iter {|ts|\n             let id = ast_util::def_id_of_def(cx.ccx.tcx.def_map.get(e.id));\n-            vec::iter2(type_uses_for(cx.ccx, id, ts.len()), ts) {|uses, subst|\n+            vec::iter2(type_uses_for(cx.ccx, id, ts.len()), ts, {|uses, subst|\n                 type_needs(cx, uses, subst)\n-            }\n+            })\n         }\n       }\n       expr_fn(*) | expr_fn_block(*) {\n@@ -209,11 +209,11 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n         let base_ty = ty::node_id_to_type(cx.ccx.tcx, base.id);\n         type_needs(cx, use_repr, ty::type_autoderef(cx.ccx.tcx, base_ty));\n \n-        option::iter(cx.ccx.maps.method_map.find(e.id)) {|mth|\n+        do option::iter(cx.ccx.maps.method_map.find(e.id)) {|mth|\n             alt mth.origin {\n               typeck::method_static(did) {\n-                option::iter(cx.ccx.tcx.node_type_substs.find(e.id)) {|ts|\n-                    vec::iter2(type_uses_for(cx.ccx, did, ts.len()), ts)\n+                do option::iter(cx.ccx.tcx.node_type_substs.find(e.id)) {|ts|\n+                    do vec::iter2(type_uses_for(cx.ccx, did, ts.len()), ts)\n                         {|uses, subst| type_needs(cx, uses, subst)}\n                 }\n               }\n@@ -231,14 +231,14 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n         node_type_needs(cx, use_repr, v.id);\n       }\n       expr_call(f, _, _) {\n-        vec::iter(ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx, f.id))) {|a|\n+        vec::iter(ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx, f.id)), {|a|\n             alt a.mode {\n               expl(by_move) | expl(by_copy) | expl(by_val) {\n                 type_needs(cx, use_repr, a.ty);\n               }\n               _ {}\n             }\n-        }\n+        })\n       }\n       expr_alt(_, _, _) | expr_block(_) | expr_if(_, _, _) |\n       expr_while(_, _) | expr_fail(_) | expr_break | expr_cont |\n@@ -265,7 +265,7 @@ fn handle_body(cx: ctx, body: blk) {\n         },\n         visit_block: {|b, cx, v|\n             visit::visit_block(b, cx, v);\n-            option::iter(b.node.expr) {|e|\n+            do option::iter(b.node.expr) {|e|\n                 node_type_needs(cx, use_repr, e.id);\n             }\n         },"}, {"sha": "544128acf2e6de780e8166727a1129d14e5bbc2e", "filename": "src/rustc/middle/trans/uniq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -10,7 +10,7 @@ export make_free_glue, autoderef, duplicate;\n fn make_free_glue(bcx: block, vptr: ValueRef, t: ty::t)\n     -> block {\n     let _icx = bcx.insn_ctxt(\"uniq::make_free_glue\");\n-    with_cond(bcx, IsNotNull(bcx, vptr)) {|bcx|\n+    do with_cond(bcx, IsNotNull(bcx, vptr)) {|bcx|\n         let content_ty = content_ty(t);\n         let body_ptr = opaque_box_body(bcx, content_ty, vptr);\n         let bcx = drop_ty(bcx, body_ptr, content_ty);"}, {"sha": "2cb4efa40b609e876f59deff270feec9e702aa87", "filename": "src/rustc/middle/tstate/auxiliary.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -661,7 +661,7 @@ fn find_instances(_fcx: fn_ctxt, subst: subst,\n \n     if vec::len(subst) == 0u { ret ~[]; }\n     let mut res = ~[];\n-    (*c.descs).swap { |v|\n+    do (*c.descs).swap { |v|\n         let v <- vec::from_mut(v);\n         for v.each { |d|\n             if args_mention(d.node.args, find_in_subst_bool, subst) {\n@@ -821,8 +821,8 @@ fn forget_in_postcond(fcx: fn_ctxt, parent_exp: node_id, dead_v: node_id) {\n     // In the postcondition given by parent_exp, clear the bits\n     // for any constraints mentioning dead_v\n     let d = local_node_id_to_local_def_id(fcx, dead_v);\n-    option::iter(d) {|d_id|\n-        for_constraints_mentioning(fcx, d_id) {|c|\n+    do option::iter(d) {|d_id|\n+        do for_constraints_mentioning(fcx, d_id) {|c|\n                 #debug(\"clearing constraint %u %s\",\n                        c.bit_num,\n                        constraint_to_str(fcx.ccx.tcx, c.c));\n@@ -838,8 +838,8 @@ fn forget_in_poststate(fcx: fn_ctxt, p: poststate, dead_v: node_id) -> bool {\n     // for any constraints mentioning dead_v\n     let d = local_node_id_to_local_def_id(fcx, dead_v);\n     let mut changed = false;\n-    option::iter(d) {|d_id|\n-        for_constraints_mentioning(fcx, d_id) {|c|\n+    do option::iter(d) {|d_id|\n+        do for_constraints_mentioning(fcx, d_id) {|c|\n                 changed |= clear_in_poststate_(c.bit_num, p);\n         }\n     }\n@@ -926,7 +926,7 @@ type binding = {lhs: ~[dest], rhs: option<initializer>};\n \n fn local_to_bindings(tcx: ty::ctxt, loc: @local) -> binding {\n     let mut lhs = ~[];\n-    pat_bindings(tcx.def_map, loc.node.pat) {|p_id, _s, name|\n+    do pat_bindings(tcx.def_map, loc.node.pat) {|p_id, _s, name|\n       vec::push(lhs, local_dest({ident: path_to_ident(name), node: p_id}));\n     };\n     {lhs: lhs, rhs: loc.node.init}\n@@ -956,7 +956,7 @@ fn callee_modes(fcx: fn_ctxt, callee: node_id) -> ~[mode] {\n }\n \n fn callee_arg_init_ops(fcx: fn_ctxt, callee: node_id) -> ~[init_op] {\n-    vec::map(callee_modes(fcx, callee)) {|m|\n+    do vec::map(callee_modes(fcx, callee)) {|m|\n         alt ty::resolved_mode(fcx.ccx.tcx, m) {\n           by_move { init_move }\n           by_copy | by_ref | by_val | by_mutbl_ref { init_assign }"}, {"sha": "d1be0f990b1a5314d6ed1490cf34b2ca532543e2", "filename": "src/rustc/middle/tstate/bitvectors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -49,7 +49,7 @@ fn seq_postconds(fcx: fn_ctxt, ps: ~[postcond]) -> postcond {\n     let sz = vec::len(ps);\n     if sz >= 1u {\n         let prev = tritv_clone(ps[0]);\n-        vec::iter_between(ps, 1u, sz) {|p| seq_tritv(prev, p); }\n+        vec::iter_between(ps, 1u, sz, {|p| seq_tritv(prev, p); });\n         ret prev;\n     } else { ret ann::empty_poststate(num_constraints(fcx.enclosing)); }\n }"}, {"sha": "5c31cc2c17c914902eecf3ae904eaad3bd822c51", "filename": "src/rustc/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -230,7 +230,7 @@ fn handle_update(fcx: fn_ctxt, parent: @expr, lhs: @expr, rhs: @expr,\n \n fn forget_args_moved_in(fcx: fn_ctxt, parent: @expr, modes: ~[mode],\n                         operands: ~[@expr]) {\n-    vec::iteri(modes) {|i,mode|\n+    do vec::iteri(modes) {|i,mode|\n         alt ty::resolved_mode(fcx.ccx.tcx, mode) {\n           by_move { forget_in_postcond(fcx, parent.id, operands[i].id); }\n           by_ref | by_val | by_mutbl_ref | by_copy { }\n@@ -463,7 +463,7 @@ fn find_pre_post_stmt(fcx: fn_ctxt, s: stmt) {\n                     /* LHS always becomes initialized,\n                      whether or not this is a move */\n                     find_pre_post_expr(fcx, an_init.expr);\n-                    pat_bindings(fcx.ccx.tcx.def_map, alocal.node.pat)\n+                    do pat_bindings(fcx.ccx.tcx.def_map, alocal.node.pat)\n                         {|p_id, _s, _n|\n                         copy_pre_post(fcx.ccx, p_id, an_init.expr);\n                     };\n@@ -477,7 +477,7 @@ fn find_pre_post_stmt(fcx: fn_ctxt, s: stmt) {\n                       _ { }\n                     }\n \n-                    pat_bindings(fcx.ccx.tcx.def_map, alocal.node.pat)\n+                    do pat_bindings(fcx.ccx.tcx.def_map, alocal.node.pat)\n                         {|p_id, _s, n|\n                         let ident = path_to_ident(n);\n                         alt p {\n@@ -505,7 +505,7 @@ fn find_pre_post_stmt(fcx: fn_ctxt, s: stmt) {\n                                    prev_pp.postcondition);\n                   }\n                   none {\n-                    pat_bindings(fcx.ccx.tcx.def_map, alocal.node.pat)\n+                    do pat_bindings(fcx.ccx.tcx.def_map, alocal.node.pat)\n                         {|p_id, _s, _n|\n                         clear_pp(node_id_to_ts_ann(fcx.ccx, p_id).conditions);\n                     };"}, {"sha": "840dc83477c28fa955ebf3ed190a1a4408b1a2ee", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 36, "deletions": 40, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -558,7 +558,7 @@ fn mk_t_with_id(cx: ctxt, st: sty, o_def_id: option<ast::def_id>) -> t {\n     fn sflags(substs: substs) -> uint {\n         let mut f = 0u;\n         for substs.tps.each {|tt| f |= get(tt).flags; }\n-        substs.self_r.iter { |r| f |= rflags(r) }\n+        substs.self_r.iter({ |r| f |= rflags(r) });\n         ret f;\n     }\n     alt st {\n@@ -795,8 +795,8 @@ fn fold_sty_to_ty(tcx: ty::ctxt, sty: sty, foldop: fn(t) -> t) -> t {\n fn fold_sty(sty: sty, fldop: fn(t) -> t) -> sty {\n     fn fold_substs(substs: substs, fldop: fn(t) -> t) -> substs {\n         {self_r: substs.self_r,\n-         self_ty: substs.self_ty.map { |t| fldop(t) },\n-         tps: substs.tps.map { |t| fldop(t) }}\n+         self_ty: substs.self_ty.map({ |t| fldop(t) }),\n+         tps: substs.tps.map({ |t| fldop(t) })}\n     }\n \n     alt sty {\n@@ -825,22 +825,22 @@ fn fold_sty(sty: sty, fldop: fn(t) -> t) -> sty {\n         ty_iface(did, fold_substs(substs, fldop))\n       }\n       ty_rec(fields) {\n-        let new_fields = vec::map(fields) {|fl|\n+        let new_fields = do vec::map(fields) {|fl|\n             let new_ty = fldop(fl.mt.ty);\n             let new_mt = {ty: new_ty, mutbl: fl.mt.mutbl};\n             {ident: fl.ident, mt: new_mt}\n         };\n         ty_rec(new_fields)\n       }\n       ty_tup(ts) {\n-        let new_ts = vec::map(ts) {|tt| fldop(tt) };\n+        let new_ts = vec::map(ts, {|tt| fldop(tt) });\n         ty_tup(new_ts)\n       }\n       ty_fn(f) {\n-        let new_args = vec::map(f.inputs) {|a|\n+        let new_args = vec::map(f.inputs, {|a|\n             let new_ty = fldop(a.ty);\n             {mode: a.mode, ty: new_ty}\n-        };\n+        });\n         let new_output = fldop(f.output);\n         ty_fn({inputs: new_args, output: new_output with f})\n       }\n@@ -863,7 +863,7 @@ fn fold_sty(sty: sty, fldop: fn(t) -> t) -> sty {\n \n // Folds types from the bottom up.\n fn fold_ty(cx: ctxt, t0: t, fldop: fn(t) -> t) -> t {\n-    let sty = fold_sty(get(t0).struct) {|t| fold_ty(cx, fldop(t), fldop) };\n+    let sty = fold_sty(get(t0).struct, {|t| fold_ty(cx, fldop(t), fldop) });\n     fldop(mk_t(cx, sty))\n }\n \n@@ -894,9 +894,9 @@ fn fold_regions_and_ty(\n         fldr: fn(r: region) -> region,\n         fldt: fn(t: t) -> t) -> substs {\n \n-        {self_r: substs.self_r.map { |r| fldr(r) },\n-         self_ty: substs.self_ty.map { |t| fldt(t) },\n-         tps: substs.tps.map { |t| fldt(t) }}\n+        {self_r: substs.self_r.map({ |r| fldr(r) }),\n+         self_ty: substs.self_ty.map({ |t| fldt(t) }),\n+         tps: substs.tps.map({ |t| fldt(t) })}\n     }\n \n     let tb = ty::get(ty);\n@@ -925,14 +925,10 @@ fn fold_regions_and_ty(\n         ty::mk_iface(cx, def_id, fold_substs(substs, fldr, fldt))\n       }\n       sty @ ty_fn(_) {\n-        fold_sty_to_ty(cx, sty) {|t|\n-            fldfnt(t)\n-        }\n+        fold_sty_to_ty(cx, sty, {|t| fldfnt(t) })\n       }\n       sty {\n-        fold_sty_to_ty(cx, sty) {|t|\n-            fldt(t)\n-        }\n+        fold_sty_to_ty(cx, sty, {|t| fldt(t) })\n       }\n     }\n }\n@@ -981,7 +977,7 @@ fn fold_region(cx: ctxt, t0: t, fldop: fn(region, bool) -> region) -> t {\n             t0\n           }\n           sty {\n-            fold_sty_to_ty(cx, sty) {|t|\n+            do fold_sty_to_ty(cx, sty) {|t|\n                 do_fold(cx, t, under_r, fldop)\n             }\n           }\n@@ -998,7 +994,7 @@ fn subst_tps(cx: ctxt, tps: ~[t], typ: t) -> t {\n     if !tbox_has_flag(tb, has_params) { ret typ; }\n     alt tb.struct {\n       ty_param(idx, _) { tps[idx] }\n-      sty { fold_sty_to_ty(cx, sty) {|t| subst_tps(cx, tps, t) } }\n+      sty { fold_sty_to_ty(cx, sty, {|t| subst_tps(cx, tps, t) }) }\n     }\n }\n \n@@ -1012,7 +1008,7 @@ fn substs_to_str(cx: ctxt, substs: substs) -> str {\n     #fmt[\"substs(self_r=%s, self_ty=%s, tps=%?)\",\n          substs.self_r.map_default(\"none\", { |r| region_to_str(cx, r) }),\n          substs.self_ty.map_default(\"none\", { |t| ty_to_str(cx, t) }),\n-         substs.tps.map { |t| ty_to_str(cx, t) }]\n+         substs.tps.map({ |t| ty_to_str(cx, t) })]\n }\n \n fn subst(cx: ctxt,\n@@ -1276,7 +1272,7 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n \n     let mut encountered_box = encountered_box;\n     let mut needs_unwind_cleanup = false;\n-    maybe_walk_ty(ty) {|ty|\n+    do maybe_walk_ty(ty) {|ty|\n         let old_encountered_box = encountered_box;\n         let result = alt get(ty).struct {\n           ty_box(_) | ty_opaque_box {\n@@ -1665,7 +1661,7 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n           }\n \n           ty_rec(fields) {\n-            vec::any(fields) {|field|\n+            do vec::any(fields) {|field|\n                 type_requires(cx, seen, r_ty, field.mt.ty)\n             }\n           }\n@@ -1680,16 +1676,16 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n \n           ty_class(did, substs) {\n             vec::push(*seen, did);\n-            let r = vec::any(class_items_as_fields(cx, did, substs)) {|f|\n-                      type_requires(cx, seen, r_ty, f.mt.ty)};\n+            let r = vec::any(class_items_as_fields(cx, did, substs),{|f|\n+                      type_requires(cx, seen, r_ty, f.mt.ty)});\n             vec::pop(*seen);\n             r\n           }\n \n           ty_tup(ts) {\n-            vec::any(ts) {|t|\n+            vec::any(ts, {|t|\n                 type_requires(cx, seen, r_ty, t)\n-            }\n+            })\n           }\n \n           ty_enum(did, _) if vec::contains(*seen, did) {\n@@ -1699,12 +1695,12 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n           ty_enum(did, substs) {\n             vec::push(*seen, did);\n             let vs = enum_variants(cx, did);\n-            let r = vec::len(*vs) > 0u && vec::all(*vs) {|variant|\n-                vec::any(variant.args) {|aty|\n+            let r = vec::len(*vs) > 0u && vec::all(*vs, {|variant|\n+                vec::any(variant.args, {|aty|\n                     let sty = subst(cx, substs, aty);\n                     type_requires(cx, seen, r_ty, sty)\n-                }\n-            };\n+                })\n+            });\n             vec::pop(*seen);\n             r\n           }\n@@ -1865,11 +1861,11 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       ty_param(_, _) { result = false; }\n       ty_opaque_closure_ptr(_) { result = true; }\n       ty_class(did, substs) {\n-        result = vec::any(lookup_class_fields(cx, did)) { |f|\n+        result = vec::any(lookup_class_fields(cx, did), { |f|\n             let fty = ty::lookup_item_type(cx, f.id);\n             let sty = subst(cx, substs, fty.ty);\n             type_is_pod(cx, sty)\n-        };\n+        });\n       }\n \n       ty_estr(vstore_slice(*)) | ty_evec(_, vstore_slice(*)) {\n@@ -2294,7 +2290,7 @@ fn occurs_check(tcx: ctxt, sp: span, vid: tv_vid, rt: t) {\n     // contain duplicates.  (Integral type vars aren't counted.)\n     fn vars_in_type(ty: t) -> ~[tv_vid] {\n         let mut rslt = ~[];\n-        walk_ty(ty) {|ty|\n+        do walk_ty(ty) {|ty|\n             alt get(ty).struct { ty_var(v) { vec::push(rslt, v); } _ { } }\n         }\n         rslt\n@@ -2574,10 +2570,10 @@ type variant_info = @{args: ~[t], ctor_ty: t, name: ast::ident,\n fn substd_enum_variants(cx: ctxt,\n                         id: ast::def_id,\n                         substs: substs) -> ~[variant_info] {\n-    vec::map(*enum_variants(cx, id)) { |variant_info|\n-        let substd_args = vec::map(variant_info.args) {|aty|\n+    do vec::map(*enum_variants(cx, id)) { |variant_info|\n+        let substd_args = vec::map(variant_info.args, {|aty|\n             subst(cx, substs, aty)\n-        };\n+        });\n \n         let substd_ctor_ty = subst(cx, substs, variant_info.ctor_ty);\n \n@@ -2682,7 +2678,7 @@ fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[variant_info] {\n                 let ctor_ty = node_id_to_type(cx, variant.node.id);\n                 let arg_tys = {\n                     if vec::len(variant.node.args) > 0u {\n-                        ty_fn_args(ctor_ty).map { |a| a.ty }\n+                        ty_fn_args(ctor_ty).map({ |a| a.ty })\n                     } else { ~[] }\n                 };\n                 alt variant.node.disr_expr {\n@@ -2791,8 +2787,8 @@ fn lookup_class_fields(cx: ctxt, did: ast::def_id) -> ~[field_ty] {\n \n fn lookup_class_field(cx: ctxt, parent: ast::def_id, field_id: ast::def_id)\n     -> field_ty {\n-    alt vec::find(lookup_class_fields(cx, parent))\n-                 {|f| f.id.node == field_id.node} {\n+    alt vec::find(lookup_class_fields(cx, parent),\n+                 {|f| f.id.node == field_id.node}) {\n         some(t) { t }\n         none { cx.sess.bug(\"class ID not found in parent's fields\"); }\n     }\n@@ -3029,7 +3025,7 @@ fn normalize_ty(cx: ctxt, t: t) -> t {\n     // types, which isn't necessary after #2187\n     let t = mk_t(cx, mach_sty(cx.sess.targ_cfg, t));\n \n-    let sty = fold_sty(get(t).struct) {|t| normalize_ty(cx, t) };\n+    let sty = fold_sty(get(t).struct, {|t| normalize_ty(cx, t) });\n     let t_norm = mk_t(cx, sty);\n     cx.normalized_cache.insert(t, t_norm);\n     ret t_norm;"}, {"sha": "be0018aeeba0bd1e16bad896bec037337454b0ee", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -121,7 +121,7 @@ fn ast_path_to_substs_and_ty<AC: ast_conv, RS: region_scope copy>(\n             #fmt[\"wrong number of type arguments, expected %u but found %u\",\n                  (*decl_bounds).len(), path.types.len()]);\n     }\n-    let tps = path.types.map { |a_t| ast_ty_to_ty(self, rscope, a_t) };\n+    let tps = path.types.map({ |a_t| ast_ty_to_ty(self, rscope, a_t) });\n \n     let substs = {self_r:self_r, self_ty:none, tps:tps};\n     {substs: substs, ty: ty::subst(tcx, substs, decl_ty)}\n@@ -244,11 +244,11 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n         ty::mk_rptr(tcx, r, mt)\n       }\n       ast::ty_tup(fields) {\n-        let flds = vec::map(fields) { |t| ast_ty_to_ty(self, rscope, t) };\n+        let flds = vec::map(fields, { |t| ast_ty_to_ty(self, rscope, t) });\n         ty::mk_tup(tcx, flds)\n       }\n       ast::ty_rec(fields) {\n-        let flds = fields.map {|f|\n+        let flds = do fields.map {|f|\n             let tm = ast_mt_to_mt(self, rscope, f.node.mt);\n             {ident: f.node.ident, mt: tm}\n         };\n@@ -412,30 +412,30 @@ fn ty_of_fn_decl<AC: ast_conv, RS: region_scope copy>(\n     expected_tys: expected_tys) -> ty::fn_ty {\n \n     #debug[\"ty_of_fn_decl\"];\n-    indent {||\n+    do indent {||\n         // new region names that appear inside of the fn decl are bound to\n         // that function type\n         let rb = in_binding_rscope(rscope);\n \n-        let input_tys = decl.inputs.mapi { |i, a|\n-            let expected_arg_ty = expected_tys.chain { |e|\n+        let input_tys = do decl.inputs.mapi { |i, a|\n+            let expected_arg_ty = do expected_tys.chain { |e|\n                 // no guarantee that the correct number of expected args\n                 // were supplied\n                 if i < e.inputs.len() {some(e.inputs[i])} else {none}\n             };\n             ty_of_arg(self, rb, a, expected_arg_ty)\n         };\n \n-        let expected_ret_ty = expected_tys.map { |e| e.output };\n+        let expected_ret_ty = expected_tys.map({ |e| e.output });\n         let output_ty = alt decl.output.node {\n           ast::ty_infer if expected_ret_ty.is_some() {expected_ret_ty.get()}\n           ast::ty_infer {self.ty_infer(decl.output.span)}\n           _ {ast_ty_to_ty(self, rb, decl.output)}\n         };\n \n-        let out_constrs = vec::map(decl.constraints) {|constr|\n+        let out_constrs = vec::map(decl.constraints, {|constr|\n             ty::ast_constr_to_constr(self.tcx(), constr)\n-        };\n+        });\n \n         {purity: decl.purity, proto: proto, inputs: input_tys,\n          output: output_ty, ret_style: decl.cf, constraints: out_constrs}"}, {"sha": "c46e2e63c77c72d2fd40e5973ef66b97abde15a1", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -172,13 +172,13 @@ fn check_fn(ccx: @crate_ctxt,\n                                        { |br| ty::re_free(body.node.id, br) })\n     };\n \n-    let arg_tys = fn_ty.inputs.map { |a| a.ty };\n+    let arg_tys = fn_ty.inputs.map({ |a| a.ty });\n     let ret_ty = fn_ty.output;\n \n     #debug[\"check_fn(arg_tys=%?, ret_ty=%?, self_ty=%?)\",\n-           arg_tys.map {|a| ty_to_str(tcx, a) },\n+           arg_tys.map({|a| ty_to_str(tcx, a) }),\n            ty_to_str(tcx, ret_ty),\n-           option::map(self_ty) {|st| ty_to_str(tcx, st) }];\n+           option::map(self_ty, {|st| ty_to_str(tcx, st) })];\n \n     // ______________________________________________________________________\n     // Create the function context.  This is either derived from scratch or,\n@@ -239,7 +239,7 @@ fn check_fn(ccx: @crate_ctxt,\n     }\n \n     let mut i = 0u;\n-    vec::iter(arg_tys) {|arg|\n+    do vec::iter(arg_tys) {|arg|\n         fcx.write_ty(decl.inputs[i].id, arg);\n         i += 1u;\n     }\n@@ -272,7 +272,7 @@ fn check_fn(ccx: @crate_ctxt,\n         };\n \n         // Add formal parameters.\n-        vec::iter2(arg_tys, decl.inputs) {|arg_ty, input|\n+        do vec::iter2(arg_tys, decl.inputs) {|arg_ty, input|\n             assign(input.id, some(arg_ty));\n             #debug[\"Argument %s is assigned to %s\",\n                    *input.ident, fcx.locals.get(input.id).to_str()];\n@@ -368,7 +368,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n           // Write the ctor's self's type\n           write_ty_to_tcx(tcx, ctor.node.self_id, class_t);\n \n-          option::iter(m_dtor) {|dtor|\n+          do option::iter(m_dtor) {|dtor|\n             // typecheck the dtor\n            check_bare_fn(ccx, ast_util::dtor_dec(),\n                            dtor.node.body, dtor.node.id,\n@@ -430,7 +430,7 @@ impl of region_scope for @fn_ctxt {\n         result::ok(self.infcx.next_region_var())\n     }\n     fn named_region(id: ast::ident) -> result<ty::region, str> {\n-        empty_rscope.named_region(id).chain_err { |_e|\n+        do empty_rscope.named_region(id).chain_err { |_e|\n             alt self.in_scope_regions.find(ty::br_named(id)) {\n               some(r) { result::ok(r) }\n               none if *id == \"blk\" { self.block_region() }\n@@ -632,7 +632,7 @@ fn check_expr_with(fcx: @fn_ctxt, expr: @ast::expr, expected: ty::t) -> bool {\n \n fn check_expr(fcx: @fn_ctxt, expr: @ast::expr,\n               expected: option<ty::t>) -> bool {\n-    ret check_expr_with_unifier(fcx, expr, expected) {||\n+    ret do check_expr_with_unifier(fcx, expr, expected) {||\n         for expected.each {|t|\n             demand::suptype(fcx, expr.span, t, fcx.expr_ty(expr));\n         }\n@@ -697,7 +697,7 @@ fn lookup_field_ty(tcx: ty::ctxt, class_id: ast::def_id,\n                    substs: ty::substs) -> option<ty::t> {\n \n     let o_field = vec::find(items, {|f| f.ident == fieldname});\n-    option::map(o_field) {|f|\n+    do option::map(o_field) {|f|\n         ty::lookup_field_type(tcx, class_id, f.id, substs)\n     }\n }\n@@ -756,7 +756,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // if the wrong number of arguments were supplied\n         let expected_arg_count = vec::len(fn_ty.inputs);\n         let arg_tys = if expected_arg_count == supplied_arg_count {\n-            fn_ty.inputs.map { |a| a.ty }\n+            fn_ty.inputs.map({ |a| a.ty })\n         } else {\n             fcx.ccx.tcx.sess.span_err(\n                 sp, #fmt[\"this function takes %u parameter%s but %u \\\n@@ -792,10 +792,10 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                     if is_block == check_blocks {\n                         let arg_ty = arg_tys[i];\n                         bot |= check_expr_with_unifier(\n-                            fcx, a, some(arg_ty)) {||\n+                            fcx, a, some(arg_ty), {||\n                             demand::assign(fcx, a.span, call_expr_id,\n                                            arg_ty, a);\n-                        };\n+                        });\n                     }\n                   }\n                   none { }\n@@ -824,7 +824,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n         // Call the generic checker.\n         let fty = {\n-            let args_opt = args.map { |arg| some(arg) };\n+            let args_opt = args.map({ |arg| some(arg) });\n             let r = check_call_or_bind(fcx, sp, call_expr_id,\n                                        fn_ty, args_opt);\n             bot |= r.bot;\n@@ -1021,7 +1021,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                      expected: option<ty::t>) {\n         let tcx = fcx.ccx.tcx;\n \n-        let expected_tys = unpack_expected(fcx, expected) { |sty|\n+        let expected_tys = do unpack_expected(fcx, expected) { |sty|\n             alt sty {\n               ty::ty_fn(fn_ty) {some({inputs:fn_ty.inputs,\n                                       output:fn_ty.output})}\n@@ -1106,7 +1106,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         fcx.write_nil(expr.id);\n       }\n       ast::expr_unary(unop, oprnd) {\n-        let exp_inner = unpack_expected(fcx, expected) {|sty|\n+        let exp_inner = do unpack_expected(fcx, expected) {|sty|\n             alt unop {\n               ast::box(_) | ast::uniq(_) {\n                 alt sty {\n@@ -1182,9 +1182,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         fcx.write_ty(id, oprnd_t);\n       }\n       ast::expr_addr_of(mutbl, oprnd) {\n-        bot = check_expr(fcx, oprnd, unpack_expected(fcx, expected) {|ty|\n+        bot = check_expr(fcx, oprnd, unpack_expected(fcx, expected, {|ty|\n             alt ty { ty::ty_rptr(_, mt) { some(mt.ty) } _ { none } }\n-        });\n+        }));\n         let region = region_of(fcx, oprnd);\n         let tm = { ty: fcx.expr_ty(oprnd), mutbl: mutbl };\n         let oprnd_t = ty::mk_rptr(tcx, region, tm);\n@@ -1418,29 +1418,29 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       ast::expr_tup(elts) {\n         let mut elt_ts = ~[];\n         vec::reserve(elt_ts, vec::len(elts));\n-        let flds = unpack_expected(fcx, expected) {|sty|\n+        let flds = unpack_expected(fcx, expected, {|sty|\n             alt sty { ty::ty_tup(flds) { some(flds) } _ { none } }\n-        };\n+        });\n         for elts.eachi {|i, e|\n-            check_expr(fcx, e, flds.map {|fs| fs[i]});\n+            check_expr(fcx, e, flds.map({|fs| fs[i]}));\n             let ety = fcx.expr_ty(e);\n             vec::push(elt_ts, ety);\n         }\n         let typ = ty::mk_tup(tcx, elt_ts);\n         fcx.write_ty(id, typ);\n       }\n       ast::expr_rec(fields, base) {\n-        option::iter(base) {|b| check_expr(fcx, b, expected); }\n+        option::iter(base, {|b| check_expr(fcx, b, expected); });\n         let expected = if expected == none && base != none {\n             some(fcx.expr_ty(base.get()))\n         } else { expected };\n-        let flds = unpack_expected(fcx, expected) {|sty|\n+        let flds = unpack_expected(fcx, expected, {|sty|\n             alt sty { ty::ty_rec(flds) { some(flds) } _ { none } }\n-        };\n+        });\n         let fields_t = vec::map(fields, {|f|\n-            bot |= check_expr(fcx, f.node.expr, flds.chain {|flds|\n-                vec::find(flds) {|tf| tf.ident == f.node.ident}\n-            }.map {|tf| tf.mt.ty});\n+            bot |= check_expr(fcx, f.node.expr, flds.chain({|flds|\n+                vec::find(flds, {|tf| tf.ident == f.node.ident})\n+            }).map({|tf| tf.mt.ty}));\n             let expr_t = fcx.expr_ty(f.node.expr);\n             let expr_mt = {ty: expr_t, mutbl: f.node.mutbl};\n             // for the most precise error message,\n@@ -1533,7 +1533,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           _ {}\n         }\n         if !handled {\n-            let tps = vec::map(tys) { |ty| fcx.to_ty(ty) };\n+            let tps = vec::map(tys, { |ty| fcx.to_ty(ty) });\n             let is_self_ref = self_ref(fcx, base.id);\n \n             // this will be the call or block that immediately\n@@ -1829,7 +1829,7 @@ fn check_enum_variants(ccx: @crate_ctxt,\n         vec::push(disr_vals, disr_val);\n         let ctor_ty = ty::node_id_to_type(ccx.tcx, v.node.id);\n         let arg_tys = if v.node.args.len() > 0u {\n-            ty::ty_fn_args(ctor_ty).map {|a| a.ty }\n+            ty::ty_fn_args(ctor_ty).map({|a| a.ty })\n           } else { ~[] };\n         vec::push(variants, @{args: arg_tys, ctor_ty: ctor_ty,\n               name: v.node.name, id: local_def(v.node.id),\n@@ -2098,7 +2098,7 @@ fn instantiate_path(fcx: @fn_ctxt,\n             (sp, \"not enough type parameters provided for this item\");\n         fcx.infcx.next_ty_vars(ty_param_count)\n     } else {\n-        pth.types.map { |aty| fcx.to_ty(aty) }\n+        pth.types.map({ |aty| fcx.to_ty(aty) })\n     };\n \n     let substs = {self_r: self_r, self_ty: none, tps: tps};"}, {"sha": "6831e7da077d0a69e1d52430e8728349d79e8277", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -79,7 +79,7 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n             let vinfo =\n                 ty::enum_variant_with_id(\n                     tcx, v_def_ids.enm, v_def_ids.var);\n-            vinfo.args.map { |t| ty::subst(tcx, expected_substs, t) }\n+            vinfo.args.map({ |t| ty::subst(tcx, expected_substs, t) })\n         };\n         let arg_len = arg_types.len(), subpats_len = alt subpats {\n             none { arg_len }\n@@ -96,8 +96,8 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n                 tcx.sess.span_fatal(pat.span, s);\n             }\n \n-            option::iter(subpats) {|pats|\n-                vec::iter2(pats, arg_types) {|subpat, arg_ty|\n+            do option::iter(subpats) {|pats|\n+                do vec::iter2(pats, arg_types) {|subpat, arg_ty|\n                   check_pat(pcx, subpat, arg_ty);\n                 }\n             };"}, {"sha": "fc208bcb56f33b2decd789e863fcbeb82b60601e", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -15,22 +15,22 @@ fn replace_bound_regions_in_fn_ty(\n     for self_ty.each { |t| vec::push(all_tys, t) }\n \n     #debug[\"replace_bound_regions_in_fn_ty(self_ty=%?, fn_ty=%s, all_tys=%?)\",\n-           self_ty.map { |t| ty_to_str(tcx, t) },\n+           self_ty.map({ |t| ty_to_str(tcx, t) }),\n            ty_to_str(tcx, ty::mk_fn(tcx, fn_ty)),\n-           all_tys.map { |t| ty_to_str(tcx, t) }];\n+           all_tys.map({ |t| ty_to_str(tcx, t) })];\n     let _i = indenter();\n \n-    let isr = create_bound_region_mapping(tcx, isr, all_tys) { |br|\n+    let isr = do create_bound_region_mapping(tcx, isr, all_tys) { |br|\n         #debug[\"br=%?\", br];\n         mapf(br)\n     };\n-    let t_fn = ty::fold_sty_to_ty(tcx, ty::ty_fn(fn_ty)) { |t|\n+    let t_fn = ty::fold_sty_to_ty(tcx, ty::ty_fn(fn_ty), { |t|\n         replace_bound_regions(tcx, isr, t)\n-    };\n-    let t_self = self_ty.map { |t| replace_bound_regions(tcx, isr, t) };\n+    });\n+    let t_self = self_ty.map({ |t| replace_bound_regions(tcx, isr, t) });\n \n     #debug[\"result of replace_bound_regions_in_fn_ty: self_ty=%?, fn_ty=%s\",\n-           t_self.map { |t| ty_to_str(tcx, t) },\n+           t_self.map({ |t| ty_to_str(tcx, t) }),\n            ty_to_str(tcx, t_fn)];\n \n     ret {isr: isr,\n@@ -78,15 +78,15 @@ fn replace_bound_regions_in_fn_ty(\n         }\n \n         // For each type `ty` in `tys`...\n-        tys.foldl(isr) { |isr, ty|\n+        do tys.foldl(isr) { |isr, ty|\n             let mut isr = isr;\n \n             // Using fold_regions is inefficient, because it\n             // constructs new types, but it avoids code duplication in\n             // terms of locating all the regions within the various\n             // kinds of types.  This had already caused me several\n             // bugs so I decided to switch over.\n-            ty::fold_regions(tcx, ty) { |r, in_fn|\n+            do ty::fold_regions(tcx, ty) { |r, in_fn|\n                 if !in_fn { isr = append_isr(isr, to_r, r); }\n                 r\n             };\n@@ -104,7 +104,7 @@ fn replace_bound_regions_in_fn_ty(\n         isr: isr_alist,\n         ty: ty::t) -> ty::t {\n \n-        ty::fold_regions(tcx, ty) { |r, in_fn|\n+        do ty::fold_regions(tcx, ty) { |r, in_fn|\n             alt r {\n               // As long as we are not within a fn() type, `&T` is\n               // mapped to the free region anon_r.  But within a fn"}, {"sha": "6c001bfda8f31219a48971269f0285b0b67a0d63", "filename": "src/rustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -83,7 +83,7 @@ fn visit_expr(e: @ast::expr, wbcx: wb_ctxt, v: wb_vt) {\n     alt e.node {\n       ast::expr_fn(_, decl, _, _) |\n       ast::expr_fn_block(decl, _, _) {\n-        vec::iter(decl.inputs) {|input|\n+        do vec::iter(decl.inputs) {|input|\n             let r_ty = resolve_type_vars_for_node(wbcx, e.span, input.id);\n \n             // Just in case we never constrained the mode to anything,"}, {"sha": "2bc178d1641826eee3844eca3cbc61ffeaebb62a", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -109,10 +109,10 @@ fn get_enum_variant_types(ccx: @crate_ctxt,\n             enum_ty\n         } else {\n             let rs = type_rscope(rp);\n-            let args = variant.node.args.map { |va|\n+            let args = variant.node.args.map({ |va|\n                 let arg_ty = ccx.to_ty(rs, va.ty);\n                 {mode: ast::expl(ast::by_copy), ty: arg_ty}\n-            };\n+            });\n             ty::mk_fn(tcx, {purity: ast::pure_fn,\n                             proto: ast::proto_box,\n                             inputs: args,\n@@ -137,17 +137,17 @@ fn ensure_iface_methods(ccx: @crate_ctxt, id: ast::node_id) {\n     let tcx = ccx.tcx;\n     alt check tcx.items.get(id) {\n       ast_map::node_item(@{node: ast::item_iface(_, rp, ms), _}, _) {\n-        store_methods::<ast::ty_method>(ccx, id, ms) {|m|\n+        store_methods::<ast::ty_method>(ccx, id, ms, {|m|\n             ty_of_ty_method(ccx, m, rp)\n-        };\n+        });\n       }\n       ast_map::node_item(@{node: ast::item_class(_,_,its,_,_,rp), _}, _) {\n         let (_,ms) = split_class_items(its);\n         // All methods need to be stored, since lookup_method\n         // relies on the same method cache for self-calls\n-        store_methods::<@ast::method>(ccx, id, ms) {|m|\n+        store_methods::<@ast::method>(ccx, id, ms, {|m|\n             ty_of_method(ccx, m, rp)\n-        };\n+        });\n       }\n     }\n }\n@@ -196,7 +196,7 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span,\n         replace_bound_self(tcx, impl_fty, dummy_self_r)\n     };\n     let if_fty = {\n-        let dummy_tps = vec::from_fn((*if_m.tps).len()) { |i|\n+        let dummy_tps = do vec::from_fn((*if_m.tps).len()) { |i|\n             // hack: we don't know the def id of the impl tp, but it\n             // is not important for unification\n             ty::mk_param(tcx, i + impl_tps, {crate: 0, node: 0})\n@@ -217,7 +217,7 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span,\n     // Replaces bound references to the self region with `with_r`.\n     fn replace_bound_self(tcx: ty::ctxt, ty: ty::t,\n                           with_r: ty::region) -> ty::t {\n-        ty::fold_regions(tcx, ty) { |r, _in_fn|\n+        do ty::fold_regions(tcx, ty) { |r, _in_fn|\n             if r == ty::re_bound(ty::br_self) {with_r} else {r}\n         }\n     }\n@@ -276,7 +276,7 @@ fn convert_methods(ccx: @crate_ctxt,\n                    self_ty: ty::t) -> ~[converted_method] {\n \n     let tcx = ccx.tcx;\n-    vec::map(ms) { |m|\n+    do vec::map(ms) { |m|\n         write_ty_to_tcx(tcx, m.self_id, self_ty);\n         let bounds = ty_param_bounds(ccx, m.tps);\n         let mty = ty_of_method(ccx, m, rp);\n@@ -330,8 +330,8 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n         tcx.tcache.insert(local_def(it.id), tpt);\n         // Write the ctor type\n-        let t_args = ctor.node.dec.inputs.map {|a|\n-                           ty_of_arg(ccx, type_rscope(rp), a, none)};\n+        let t_args = ctor.node.dec.inputs.map({|a|\n+                           ty_of_arg(ccx, type_rscope(rp), a, none)});\n         let t_res = ty::mk_class(tcx, local_def(it.id),\n                                  {self_r: alt rp {\n                        ast::rp_none { none }\n@@ -350,7 +350,7 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n                           {bounds: tpt.bounds,\n                            rp: rp,\n                            ty: t_ctor});\n-        option::iter(m_dtor) {|dtor|\n+        do option::iter(m_dtor) {|dtor|\n             // Write the dtor type\n             let t_dtor = ty::mk_fn(\n                 tcx,\n@@ -553,7 +553,7 @@ fn ty_param_bounds(ccx: @crate_ctxt,\n \n     fn compute_bounds(ccx: @crate_ctxt,\n                       param: ast::ty_param) -> ty::param_bounds {\n-        @vec::flat_map(*param.bounds) { |b|\n+        @do vec::flat_map(*param.bounds) { |b|\n             alt b {\n               ast::bound_send { ~[ty::bound_send] }\n               ast::bound_copy { ~[ty::bound_copy] }\n@@ -576,7 +576,7 @@ fn ty_param_bounds(ccx: @crate_ctxt,\n         }\n     }\n \n-    @params.map { |param|\n+    @do params.map { |param|\n         alt ccx.tcx.ty_param_bounds.find(param.id) {\n           some(bs) { bs }\n           none {\n@@ -595,7 +595,7 @@ fn ty_of_foreign_fn_decl(ccx: @crate_ctxt,\n \n     let bounds = ty_param_bounds(ccx, ty_params);\n     let rb = in_binding_rscope(empty_rscope);\n-    let input_tys = decl.inputs.map { |a| ty_of_arg(ccx, rb, a, none) };\n+    let input_tys = decl.inputs.map({ |a| ty_of_arg(ccx, rb, a, none) });\n     let output_ty = ast_ty_to_ty(ccx, rb, decl.output);\n \n     let t_fn = ty::mk_fn(ccx.tcx, {purity: decl.purity,"}, {"sha": "f34cfd5cc3f960e0590fd535ce7e0d0ae3bb7cd0", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 133, "deletions": 132, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -355,31 +355,31 @@ fn new_infer_ctxt(tcx: ty::ctxt) -> infer_ctxt {\n \n fn mk_subty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n     #debug[\"mk_subty(%s <: %s)\", a.to_str(cx), b.to_str(cx)];\n-    indent {|| cx.commit {|| sub(cx).tys(a, b) } }.to_ures()\n+    indent({|| cx.commit({|| sub(cx).tys(a, b) }) }).to_ures()\n }\n \n fn can_mk_subty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n     #debug[\"can_mk_subty(%s <: %s)\", a.to_str(cx), b.to_str(cx)];\n-    indent {|| cx.probe {|| sub(cx).tys(a, b) } }.to_ures()\n+    indent({|| cx.probe({|| sub(cx).tys(a, b) }) }).to_ures()\n }\n \n fn mk_subr(cx: infer_ctxt, a: ty::region, b: ty::region) -> ures {\n     #debug[\"mk_subr(%s <: %s)\", a.to_str(cx), b.to_str(cx)];\n-    indent {|| cx.commit {|| sub(cx).regions(a, b) } }.to_ures()\n+    indent({|| cx.commit({|| sub(cx).regions(a, b) }) }).to_ures()\n }\n \n fn mk_eqty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n     #debug[\"mk_eqty(%s <: %s)\", a.to_str(cx), b.to_str(cx)];\n-    indent {|| cx.commit {|| cx.eq_tys(a, b) } }.to_ures()\n+    indent({|| cx.commit({|| cx.eq_tys(a, b) }) }).to_ures()\n }\n \n fn mk_assignty(cx: infer_ctxt, anmnt: assignment,\n                a: ty::t, b: ty::t) -> ures {\n     #debug[\"mk_assignty(%? / %s <: %s)\",\n            anmnt, a.to_str(cx), b.to_str(cx)];\n-    indent {|| cx.commit {||\n+    indent({|| cx.commit({||\n         cx.assign_tys(anmnt, a, b)\n-    } }.to_ures()\n+    }) }).to_ures()\n }\n \n fn can_mk_assignty(cx: infer_ctxt, anmnt: assignment,\n@@ -392,9 +392,9 @@ fn can_mk_assignty(cx: infer_ctxt, anmnt: assignment,\n     // used in method lookup, and there must be exactly one match or an\n     // error is reported. Still, it should be fixed.\n \n-    indent {|| cx.probe {||\n+    indent({|| cx.probe({||\n         cx.assign_tys(anmnt, a, b)\n-    } }.to_ures()\n+    }) }).to_ures()\n }\n \n // See comment on the type `resolve_state` below\n@@ -418,7 +418,7 @@ fn resolve_deep(cx: infer_ctxt, a: ty::t, force_vars: force_level)\n impl methods for ures {\n     fn then<T:copy>(f: fn() -> result<T,ty::type_err>)\n         -> result<T,ty::type_err> {\n-        self.chain() {|_i| f() }\n+        self.chain({|_i| f() })\n     }\n }\n \n@@ -431,7 +431,7 @@ impl methods<T:copy> for cres<T> {\n     }\n \n     fn compare(t: T, f: fn() -> ty::type_err) -> cres<T> {\n-        self.chain {|s|\n+        do self.chain {|s|\n             if s == t {\n                 self\n             } else {\n@@ -520,7 +520,7 @@ impl of st for ty::t {\n \n impl of st for ty::region {\n     fn sub(infcx: infer_ctxt, &&b: ty::region) -> ures {\n-        sub(infcx).regions(self, b).chain {|_r| ok(()) }\n+        sub(infcx).regions(self, b).chain({|_r| ok(()) })\n     }\n \n     fn lub(infcx: infer_ctxt, &&b: ty::region) -> cres<ty::region> {\n@@ -605,7 +605,7 @@ impl methods for infer_ctxt {\n     }\n \n     fn next_ty_vars(n: uint) -> ~[ty::t] {\n-        vec::from_fn(n) {|_i| self.next_ty_var() }\n+        vec::from_fn(n, {|_i| self.next_ty_var() })\n     }\n \n     fn next_ty_var_integral_id() -> tvi_vid {\n@@ -706,7 +706,7 @@ impl unify_methods for infer_ctxt {\n             ok(b)\n           }\n           (some(v_a), some(v_b)) {\n-            merge_op(v_a, v_b).chain {|v|\n+            do merge_op(v_a, v_b).chain {|v|\n                 ok(some(v))\n             }\n           }\n@@ -719,11 +719,11 @@ impl unify_methods for infer_ctxt {\n         glb: fn(V,V) -> cres<V>) -> cres<bounds<V>> {\n \n         let _r = indenter();\n-        self.merge_bnd(a.ub, b.ub, glb).chain {|ub|\n+        do self.merge_bnd(a.ub, b.ub, glb).chain {|ub|\n             #debug[\"glb of ubs %s and %s is %s\",\n                    a.ub.to_str(self), b.ub.to_str(self),\n                    ub.to_str(self)];\n-            self.merge_bnd(a.lb, b.lb, lub).chain {|lb|\n+            do self.merge_bnd(a.lb, b.lb, lub).chain {|lb|\n                 #debug[\"lub of lbs %s and %s is %s\",\n                        a.lb.to_str(self), b.lb.to_str(self),\n                        lb.to_str(self)];\n@@ -771,19 +771,19 @@ impl unify_methods for infer_ctxt {\n         // them explicitly gives the type inferencer more\n         // information and helps to produce tighter bounds\n         // when necessary.\n-        indent {||\n-        self.bnds(a.lb, b.ub).then {||\n-        self.bnds(b.lb, a.ub).then {||\n-        self.merge_bnd(a.ub, b.ub, {|x, y| x.glb(self, y)}).chain {|ub|\n-        self.merge_bnd(a.lb, b.lb, {|x, y| x.lub(self, y)}).chain {|lb|\n+        do indent {||\n+        do self.bnds(a.lb, b.ub).then {||\n+        do self.bnds(b.lb, a.ub).then {||\n+        do self.merge_bnd(a.ub, b.ub, {|x, y| x.glb(self, y)}).chain {|ub|\n+        do self.merge_bnd(a.lb, b.lb, {|x, y| x.lub(self, y)}).chain {|lb|\n             let bnds = {lb: lb, ub: ub};\n             #debug[\"merge(%s): bnds=%s\",\n                    v_id.to_str(),\n                    bnds.to_str(self)];\n \n             // the new bounds must themselves\n             // be relatable:\n-            self.bnds(bnds.lb, bnds.ub).then {||\n+            do self.bnds(bnds.lb, bnds.ub).then {||\n                 self.set(vb, v_id, root(bnds, rank));\n                 uok()\n         }\n@@ -812,7 +812,7 @@ impl unify_methods for infer_ctxt {\n         // see if we can make those types subtypes.\n         alt (a_bounds.ub, b_bounds.lb) {\n           (some(a_ub), some(b_lb)) {\n-            let r = self.try {|| a_ub.sub(self, b_lb) };\n+            let r = self.try({|| a_ub.sub(self, b_lb) });\n             alt r {\n               ok(()) { ret result::ok(()); }\n               err(_) { /*fallthrough */ }\n@@ -835,17 +835,17 @@ impl unify_methods for infer_ctxt {\n             // i.e., b should redirect to a.\n             self.set(vb, b_id, redirect(a_id));\n             self.set_var_to_merged_bounds(\n-                vb, a_id, a_bounds, b_bounds, nde_a.rank).then {||\n+                vb, a_id, a_bounds, b_bounds, nde_a.rank).then({||\n                 uok()\n-            }\n+            })\n         } else if nde_a.rank < nde_b.rank {\n             #debug[\"vars(): b has smaller rank\"];\n             // b has greater rank, so a should redirect to b.\n             self.set(vb, a_id, redirect(b_id));\n             self.set_var_to_merged_bounds(\n-                vb, b_id, a_bounds, b_bounds, nde_b.rank).then {||\n+                vb, b_id, a_bounds, b_bounds, nde_b.rank).then({||\n                 uok()\n-            }\n+            })\n         } else {\n             #debug[\"vars(): a and b have equal rank\"];\n             assert nde_a.rank == nde_b.rank;\n@@ -854,9 +854,9 @@ impl unify_methods for infer_ctxt {\n             // to a and increment a's rank.\n             self.set(vb, b_id, redirect(a_id));\n             self.set_var_to_merged_bounds(\n-                vb, a_id, a_bounds, b_bounds, nde_a.rank + 1u).then {||\n+                vb, a_id, a_bounds, b_bounds, nde_a.rank + 1u).then({||\n                 uok()\n-            }\n+            })\n         }\n     }\n \n@@ -1026,7 +1026,7 @@ impl unify_methods for infer_ctxt {\n         a: bound<T>, b: bound<T>) -> ures {\n \n         #debug(\"bnds(%s <: %s)\", a.to_str(self), b.to_str(self));\n-        indent {||\n+        do indent {||\n             alt (a, b) {\n               (none, none) |\n               (some(_), none) |\n@@ -1044,7 +1044,7 @@ impl unify_methods for infer_ctxt {\n         as: ~[@ty::type_constr], bs: ~[@ty::type_constr]) -> ures {\n \n         if check vec::same_length(as, bs) {\n-            iter_vec2(as, bs) {|a,b|\n+            do iter_vec2(as, bs) {|a,b|\n                 self.constrs(a, b)\n             }\n         } else {\n@@ -1053,24 +1053,24 @@ impl unify_methods for infer_ctxt {\n     }\n \n     fn sub_tys(a: ty::t, b: ty::t) -> ures {\n-        sub(self).tys(a, b).chain {|_t| ok(()) }\n+        sub(self).tys(a, b).chain({|_t| ok(()) })\n     }\n \n     fn sub_regions(a: ty::region, b: ty::region) -> ures {\n-        sub(self).regions(a, b).chain {|_t| ok(()) }\n+        sub(self).regions(a, b).chain({|_t| ok(()) })\n     }\n \n     fn eq_tys(a: ty::t, b: ty::t) -> ures {\n-        self.sub_tys(a, b).then {||\n+        self.sub_tys(a, b).then({||\n             self.sub_tys(b, a)\n-        }\n+        })\n     }\n \n     fn eq_regions(a: ty::region, b: ty::region) -> ures {\n         #debug[\"eq_regions(%s, %s)\",\n                a.to_str(self), b.to_str(self)];\n-        indent {||\n-            self.sub_regions(a, b).then {||\n+        do indent {||\n+            do self.sub_regions(a, b).then {||\n                 self.sub_regions(b, a)\n             }\n         }\n@@ -1134,7 +1134,7 @@ impl methods for resolve_state {\n         // allow us to pass back errors in any useful way.\n \n         assert vec::is_empty(self.v_seen) && vec::is_empty(self.r_seen);\n-        let rty = indent {|| self.resolve1(typ) };\n+        let rty = indent({|| self.resolve1(typ) });\n         assert vec::is_empty(self.v_seen) && vec::is_empty(self.r_seen);\n         alt self.err {\n           none {\n@@ -1462,11 +1462,11 @@ impl assignment for infer_ctxt {\n                anmnt, a.to_str(self), nr_b.to_str(self),\n                r_b.to_str(self)];\n \n-        indent {||\n-            self.sub_tys(a, nr_b).then {||\n+        do indent {||\n+            do self.sub_tys(a, nr_b).then {||\n                 let r_a = ty::re_scope(anmnt.borrow_scope);\n                 #debug[\"anmnt=%?\", anmnt];\n-                sub(self).contraregions(r_a, r_b).chain {|_r|\n+                do sub(self).contraregions(r_a, r_b).chain {|_r|\n                     // if successful, add an entry indicating that\n                     // borrowing occurred\n                     #debug[\"borrowing expression #%?\", anmnt];\n@@ -1564,7 +1564,7 @@ fn super_substs<C:combine>(\n             ok(none)\n           }\n           (some(a), some(b)) {\n-            infcx.eq_regions(a, b).then {||\n+            do infcx.eq_regions(a, b).then {||\n                 ok(some(a))\n             }\n           }\n@@ -1582,9 +1582,10 @@ fn super_substs<C:combine>(\n         }\n     }\n \n-    self.tps(a.tps, b.tps).chain { |tps|\n-        self.self_tys(a.self_ty, b.self_ty).chain { |self_ty|\n-            eq_opt_regions(self.infcx(), a.self_r, b.self_r).chain { |self_r|\n+    do self.tps(a.tps, b.tps).chain { |tps|\n+        do self.self_tys(a.self_ty, b.self_ty).chain { |self_ty|\n+            do eq_opt_regions(self.infcx(), a.self_r, b.self_r).chain {\n+                |self_r|\n                 ok({self_r: self_r, self_ty: self_ty, tps: tps})\n             }\n         }\n@@ -1600,11 +1601,11 @@ fn super_tps<C:combine>(\n     // variance.\n \n     if check vec::same_length(as, bs) {\n-        iter_vec2(as, bs) {|a, b|\n+        iter_vec2(as, bs, {|a, b|\n             self.infcx().eq_tys(a, b)\n-        }.then {||\n+        }).then({||\n             ok(as)\n-        }\n+        })\n     } else {\n         err(ty::terr_ty_param_size(bs.len(), as.len()))\n     }\n@@ -1621,9 +1622,9 @@ fn super_self_tys<C:combine>(\n         ok(none)\n       }\n       (some(a), some(b)) {\n-        self.infcx().eq_tys(a, b).then {||\n+        self.infcx().eq_tys(a, b).then({||\n             ok(some(a))\n-        }\n+        })\n       }\n       (none, some(_)) |\n       (some(_), none) {\n@@ -1639,11 +1640,11 @@ fn super_flds<C:combine>(\n     self: C, a: ty::field, b: ty::field) -> cres<ty::field> {\n \n     if a.ident == b.ident {\n-        self.mts(a.mt, b.mt).chain {|mt|\n+        self.mts(a.mt, b.mt).chain({|mt|\n             ok({ident: a.ident, mt: mt})\n-        }.chain_err {|e|\n+        }).chain_err({|e|\n             err(ty::terr_in_field(@e, a.ident))\n-        }\n+        })\n     } else {\n         err(ty::terr_record_fields(b.ident, a.ident))\n     }\n@@ -1661,8 +1662,8 @@ fn super_args<C:combine>(\n     self: C, a: ty::arg, b: ty::arg)\n     -> cres<ty::arg> {\n \n-    self.modes(a.mode, b.mode).chain {|m|\n-        self.contratys(a.ty, b.ty).chain {|t|\n+    do self.modes(a.mode, b.mode).chain {|m|\n+        do self.contratys(a.ty, b.ty).chain {|t|\n             ok({mode: m, ty: t})\n         }\n     }\n@@ -1674,7 +1675,7 @@ fn super_vstores<C:combine>(\n \n     alt (a, b) {\n       (ty::vstore_slice(a_r), ty::vstore_slice(b_r)) {\n-        self.contraregions(a_r, b_r).chain {|r|\n+        do self.contraregions(a_r, b_r).chain {|r|\n             ok(ty::vstore_slice(r))\n         }\n       }\n@@ -1696,17 +1697,17 @@ fn super_fns<C:combine>(\n                           b_args: ~[ty::arg]) -> cres<~[ty::arg]> {\n \n         if check vec::same_length(a_args, b_args) {\n-            map_vec2(a_args, b_args) {|a, b| self.args(a, b) }\n+            map_vec2(a_args, b_args, {|a, b| self.args(a, b) })\n         } else {\n             err(ty::terr_arg_count)\n         }\n     }\n \n-    self.protos(a_f.proto, b_f.proto).chain {|p|\n-        self.ret_styles(a_f.ret_style, b_f.ret_style).chain {|rs|\n-            argvecs(self, a_f.inputs, b_f.inputs).chain {|inputs|\n-                self.tys(a_f.output, b_f.output).chain {|output|\n-                    self.purities(a_f.purity, b_f.purity).chain {|purity|\n+    do self.protos(a_f.proto, b_f.proto).chain {|p|\n+        do self.ret_styles(a_f.ret_style, b_f.ret_style).chain {|rs|\n+            do argvecs(self, a_f.inputs, b_f.inputs).chain {|inputs|\n+                do self.tys(a_f.output, b_f.output).chain {|output|\n+                    do self.purities(a_f.purity, b_f.purity).chain {|purity|\n                     // FIXME: uncomment if #2588 doesn't get accepted:\n                     // self.infcx().constrvecs(a_f.constraints,\n                     //                         b_f.constraints).then {||\n@@ -1743,18 +1744,18 @@ fn super_tys<C:combine>(\n \n       // Have to handle these first\n       (ty::ty_var_integral(a_id), ty::ty_var_integral(b_id)) {\n-        self.infcx().vars_integral(self.infcx().tvib, a_id, b_id).then {||\n-            ok(a) }\n+        self.infcx().vars_integral(self.infcx().tvib, a_id, b_id).then({||\n+            ok(a) })\n       }\n       (ty::ty_var_integral(a_id), ty::ty_int(_)) |\n       (ty::ty_var_integral(a_id), ty::ty_uint(_)) {\n-        self.infcx().vart_integral(self.infcx().tvib, a_id, b).then {||\n-            ok(a) }\n+        self.infcx().vart_integral(self.infcx().tvib, a_id, b).then({||\n+            ok(a) })\n       }\n       (ty::ty_int(_), ty::ty_var_integral(b_id)) |\n       (ty::ty_uint(_), ty::ty_var_integral(b_id)) {\n-        self.infcx().tvar_integral(self.infcx().tvib, a, b_id).then {||\n-            ok(a) }\n+        self.infcx().tvar_integral(self.infcx().tvib, a, b_id).then({||\n+            ok(a) })\n       }\n \n       (ty::ty_int(_), _) |\n@@ -1786,102 +1787,102 @@ fn super_tys<C:combine>(\n \n       (ty::ty_enum(a_id, a_substs), ty::ty_enum(b_id, b_substs))\n       if a_id == b_id {\n-        self.substs(a_substs, b_substs).chain {|tps|\n+        do self.substs(a_substs, b_substs).chain {|tps|\n             ok(ty::mk_enum(tcx, a_id, tps))\n         }\n       }\n \n       (ty::ty_iface(a_id, a_substs), ty::ty_iface(b_id, b_substs))\n       if a_id == b_id {\n-        self.substs(a_substs, b_substs).chain {|substs|\n+        do self.substs(a_substs, b_substs).chain {|substs|\n             ok(ty::mk_iface(tcx, a_id, substs))\n         }\n       }\n \n       (ty::ty_class(a_id, a_substs), ty::ty_class(b_id, b_substs))\n       if a_id == b_id {\n-        self.substs(a_substs, b_substs).chain {|substs|\n+        do self.substs(a_substs, b_substs).chain {|substs|\n             ok(ty::mk_class(tcx, a_id, substs))\n         }\n       }\n \n       (ty::ty_box(a_mt), ty::ty_box(b_mt)) {\n-        self.mts(a_mt, b_mt).chain {|mt|\n+        do self.mts(a_mt, b_mt).chain {|mt|\n             ok(ty::mk_box(tcx, mt))\n         }\n       }\n \n       (ty::ty_uniq(a_mt), ty::ty_uniq(b_mt)) {\n-        self.mts(a_mt, b_mt).chain {|mt|\n+        do self.mts(a_mt, b_mt).chain {|mt|\n             ok(ty::mk_uniq(tcx, mt))\n         }\n       }\n \n       (ty::ty_vec(a_mt), ty::ty_vec(b_mt)) {\n-        self.mts(a_mt, b_mt).chain {|mt|\n+        do self.mts(a_mt, b_mt).chain {|mt|\n             ok(ty::mk_vec(tcx, mt))\n         }\n       }\n \n       (ty::ty_ptr(a_mt), ty::ty_ptr(b_mt)) {\n-        self.mts(a_mt, b_mt).chain {|mt|\n+        do self.mts(a_mt, b_mt).chain {|mt|\n             ok(ty::mk_ptr(tcx, mt))\n         }\n       }\n \n       (ty::ty_rptr(a_r, a_mt), ty::ty_rptr(b_r, b_mt)) {\n-        self.contraregions(a_r, b_r).chain {|r|\n-            self.mts(a_mt, b_mt).chain {|mt|\n+        do self.contraregions(a_r, b_r).chain {|r|\n+            do self.mts(a_mt, b_mt).chain {|mt|\n                 ok(ty::mk_rptr(tcx, r, mt))\n             }\n         }\n       }\n \n       (ty::ty_evec(a_mt, vs_a), ty::ty_evec(b_mt, vs_b)) {\n-        self.mts(a_mt, b_mt).chain {|mt|\n-            self.vstores(ty::terr_vec, vs_a, vs_b).chain {|vs|\n+        do self.mts(a_mt, b_mt).chain {|mt|\n+            do self.vstores(ty::terr_vec, vs_a, vs_b).chain {|vs|\n                 ok(ty::mk_evec(tcx, mt, vs))\n             }\n         }\n       }\n \n       (ty::ty_estr(vs_a), ty::ty_estr(vs_b)) {\n-        self.vstores(ty::terr_str, vs_a, vs_b).chain {|vs|\n+        do self.vstores(ty::terr_str, vs_a, vs_b).chain {|vs|\n             ok(ty::mk_estr(tcx,vs))\n         }\n       }\n \n       (ty::ty_rec(as), ty::ty_rec(bs)) {\n         if check vec::same_length(as, bs) {\n-            map_vec2(as, bs) {|a,b|\n+            map_vec2(as, bs, {|a,b|\n                 self.flds(a, b)\n-            }.chain {|flds|\n+            }).chain({|flds|\n                 ok(ty::mk_rec(tcx, flds))\n-            }\n+            })\n         } else {\n             err(ty::terr_record_size(bs.len(), as.len()))\n         }\n       }\n \n       (ty::ty_tup(as), ty::ty_tup(bs)) {\n         if check vec::same_length(as, bs) {\n-            map_vec2(as, bs) {|a, b| self.tys(a, b) }.chain {|ts|\n+            map_vec2(as, bs, {|a, b| self.tys(a, b) }).chain({|ts|\n                 ok(ty::mk_tup(tcx, ts))\n-            }\n+            })\n         } else {\n             err(ty::terr_tuple_size(bs.len(), as.len()))\n         }\n       }\n \n       (ty::ty_fn(a_fty), ty::ty_fn(b_fty)) {\n-        self.fns(a_fty, b_fty).chain {|fty|\n+        do self.fns(a_fty, b_fty).chain {|fty|\n             ok(ty::mk_fn(tcx, fty))\n         }\n       }\n \n       (ty::ty_constr(a_t, a_constrs), ty::ty_constr(b_t, b_constrs)) {\n-        self.tys(a_t, b_t).chain {|t|\n-            self.infcx().constrvecs(a_constrs, b_constrs).then {||\n+        do self.tys(a_t, b_t).chain {|t|\n+            do self.infcx().constrvecs(a_constrs, b_constrs).then {||\n                 ok(ty::mk_constr(tcx, t, a_constrs))\n             }\n         }\n@@ -1910,25 +1911,25 @@ impl of combine for sub {\n                self.tag(),\n                a.to_str(self.infcx()),\n                b.to_str(self.infcx())];\n-        indent {||\n+        do indent {||\n             alt (a, b) {\n               (ty::re_var(a_id), ty::re_var(b_id)) {\n-                self.infcx().vars(self.rb, a_id, b_id).then {||\n+                do self.infcx().vars(self.rb, a_id, b_id).then {||\n                     ok(a)\n                 }\n               }\n               (ty::re_var(a_id), _) {\n-                  self.infcx().vart(self.rb, a_id, b).then {||\n+                  do self.infcx().vart(self.rb, a_id, b).then {||\n                       ok(a)\n                   }\n               }\n               (_, ty::re_var(b_id)) {\n-                  self.infcx().tvar(self.rb, a, b_id).then {||\n+                  do self.infcx().tvar(self.rb, a, b_id).then {||\n                       ok(a)\n                   }\n               }\n               _ {\n-                self.lub().regions(a, b).compare(b) {||\n+                do self.lub().regions(a, b).compare(b) {||\n                     ty::terr_regions_differ(b, a)\n                 }\n               }\n@@ -1947,50 +1948,50 @@ impl of combine for sub {\n           m_mutbl {\n             // If supertype is mut, subtype must match exactly\n             // (i.e., invariant if mut):\n-            self.infcx().eq_tys(a.ty, b.ty).then {|| ok(a) }\n+            self.infcx().eq_tys(a.ty, b.ty).then({|| ok(a) })\n           }\n           m_imm | m_const {\n             // Otherwise we can be covariant:\n-            self.tys(a.ty, b.ty).chain {|_t| ok(a) }\n+            self.tys(a.ty, b.ty).chain({|_t| ok(a) })\n           }\n         }\n     }\n \n     fn protos(a: ast::proto, b: ast::proto) -> cres<ast::proto> {\n-        self.lub().protos(a, b).compare(b) {||\n+        self.lub().protos(a, b).compare(b, {||\n             ty::terr_proto_mismatch(b, a)\n-        }\n+        })\n     }\n \n     fn purities(f1: purity, f2: purity) -> cres<purity> {\n-        self.lub().purities(f1, f2).compare(f2) {||\n+        self.lub().purities(f1, f2).compare(f2, {||\n             ty::terr_purity_mismatch(f2, f1)\n-        }\n+        })\n     }\n \n     fn ret_styles(a: ret_style, b: ret_style) -> cres<ret_style> {\n-        self.lub().ret_styles(a, b).compare(b) {||\n+        self.lub().ret_styles(a, b).compare(b, {||\n             ty::terr_ret_style_mismatch(b, a)\n-        }\n+        })\n     }\n \n     fn tys(a: ty::t, b: ty::t) -> cres<ty::t> {\n         #debug(\"%s.tys(%s, %s)\", self.tag(),\n                a.to_str(*self), b.to_str(*self));\n         if a == b { ret ok(a); }\n-        indent {||\n+        do indent {||\n             alt (ty::get(a).struct, ty::get(b).struct) {\n               (ty::ty_bot, _) {\n                 ok(a)\n               }\n               (ty::ty_var(a_id), ty::ty_var(b_id)) {\n-                self.infcx().vars(self.tvb, a_id, b_id).then {|| ok(a) }\n+                self.infcx().vars(self.tvb, a_id, b_id).then({|| ok(a) })\n               }\n               (ty::ty_var(a_id), _) {\n-                self.infcx().vart(self.tvb, a_id, b).then {|| ok(a) }\n+                self.infcx().vart(self.tvb, a_id, b).then({|| ok(a) })\n               }\n               (_, ty::ty_var(b_id)) {\n-                self.infcx().tvar(self.tvb, a, b_id).then {|| ok(a) }\n+                self.infcx().tvar(self.tvb, a, b_id).then({|| ok(a) })\n               }\n               (_, ty::ty_bot) {\n                 err(ty::terr_sorts(b, a))\n@@ -2011,7 +2012,7 @@ impl of combine for sub {\n         // First, we instantiate each bound region in the subtype with a fresh\n         // region variable.\n         let {fn_ty: a_fn_ty, _} = {\n-            replace_bound_regions_in_fn_ty(self.tcx, @nil, none, a) { |br|\n+            do replace_bound_regions_in_fn_ty(self.tcx, @nil, none, a) { |br|\n                 // N.B.: The name of the bound region doesn't have\n                 // anything to do with the region variable that's created\n                 // for it.  The only thing we're doing with `br` here is\n@@ -2027,7 +2028,7 @@ impl of combine for sub {\n         // Second, we instantiate each bound region in the supertype with a\n         // fresh concrete region.\n         let {fn_ty: b_fn_ty, _} = {\n-            replace_bound_regions_in_fn_ty(self.tcx, @nil, none, b) { |br|\n+            do replace_bound_regions_in_fn_ty(self.tcx, @nil, none, b) { |br|\n                 // FIXME: eventually re_skolemized (issue #2263)\n                 ty::re_bound(br)\n             }\n@@ -2093,21 +2094,21 @@ impl of combine for lub {\n \n         alt m {\n           m_imm | m_const {\n-            self.tys(a.ty, b.ty).chain {|t|\n+            self.tys(a.ty, b.ty).chain({|t|\n                 ok({ty: t, mutbl: m})\n-            }\n+            })\n           }\n \n           m_mutbl {\n-            self.infcx().try {||\n-                self.infcx().eq_tys(a.ty, b.ty).then {||\n+            self.infcx().try({||\n+                self.infcx().eq_tys(a.ty, b.ty).then({||\n                     ok({ty: a.ty, mutbl: m})\n-                }\n-            }.chain_err {|_e|\n-                self.tys(a.ty, b.ty).chain {|t|\n+                })\n+            }).chain_err({|_e|\n+                self.tys(a.ty, b.ty).chain({|t|\n                     ok({ty: t, mutbl: m_const})\n-                }\n-            }\n+                })\n+            })\n           }\n         }\n     }\n@@ -2159,7 +2160,7 @@ impl of combine for lub {\n                a.to_str(self.infcx()),\n                b.to_str(self.infcx())];\n \n-        indent {||\n+        do indent {||\n             alt (a, b) {\n               (ty::re_static, _) | (_, ty::re_static) {\n                 ok(ty::re_static) // nothing lives longer than static\n@@ -2272,37 +2273,37 @@ impl of combine for glb {\n           // If one side or both is mut, then the GLB must use\n           // the precise type from the mut side.\n           (m_mutbl, m_const) {\n-            sub(*self).tys(a.ty, b.ty).chain {|_t|\n+            sub(*self).tys(a.ty, b.ty).chain({|_t|\n                 ok({ty: a.ty, mutbl: m_mutbl})\n-            }\n+            })\n           }\n           (m_const, m_mutbl) {\n-            sub(*self).tys(b.ty, a.ty).chain {|_t|\n+            sub(*self).tys(b.ty, a.ty).chain({|_t|\n                 ok({ty: b.ty, mutbl: m_mutbl})\n-            }\n+            })\n           }\n           (m_mutbl, m_mutbl) {\n-            self.infcx().eq_tys(a.ty, b.ty).then {||\n+            self.infcx().eq_tys(a.ty, b.ty).then({||\n                 ok({ty: a.ty, mutbl: m_mutbl})\n-            }\n+            })\n           }\n \n           // If one side or both is immutable, we can use the GLB of\n           // both sides but mutbl must be `m_imm`.\n           (m_imm, m_const) |\n           (m_const, m_imm) |\n           (m_imm, m_imm) {\n-            self.tys(a.ty, b.ty).chain {|t|\n+            self.tys(a.ty, b.ty).chain({|t|\n                 ok({ty: t, mutbl: m_imm})\n-            }\n+            })\n           }\n \n           // If both sides are const, then we can use GLB of both\n           // sides and mutbl of only `m_const`.\n           (m_const, m_const) {\n-            self.tys(a.ty, b.ty).chain {|t|\n+            self.tys(a.ty, b.ty).chain({|t|\n                 ok({ty: t, mutbl: m_const})\n-            }\n+            })\n           }\n \n           // There is no mutual subtype of these combinations.\n@@ -2356,7 +2357,7 @@ impl of combine for glb {\n                a.to_str(self.infcx()),\n                b.to_str(self.infcx())];\n \n-        indent {||\n+        do indent {||\n             alt (a, b) {\n               (ty::re_static, r) | (r, ty::re_static) {\n                 // static lives longer than everything else\n@@ -2494,7 +2495,7 @@ fn lattice_tys<L:lattice_ops combine>(\n            a.to_str(self.infcx()),\n            b.to_str(self.infcx()));\n     if a == b { ret ok(a); }\n-    indent {||\n+    do indent {||\n         alt (ty::get(a).struct, ty::get(b).struct) {\n           (ty::ty_bot, _) { self.ty_bot(b) }\n           (_, ty::ty_bot) { self.ty_bot(a) }\n@@ -2580,7 +2581,7 @@ fn lattice_vars<V:copy vid, T:copy to_str st, L:lattice_ops combine>(\n     let a_bnd = self.bnd(a_bounds), b_bnd = self.bnd(b_bounds);\n     alt (a_bnd, b_bnd) {\n       (some(a_ty), some(b_ty)) {\n-        alt self.infcx().try {|| c_ts(a_ty, b_ty) } {\n+        alt self.infcx().try({|| c_ts(a_ty, b_ty) }) {\n             ok(t) { ret ok(t); }\n             err(_) { /*fallthrough */ }\n         }\n@@ -2590,9 +2591,9 @@ fn lattice_vars<V:copy vid, T:copy to_str st, L:lattice_ops combine>(\n \n     // Otherwise, we need to merge A and B into one variable.  We can\n     // then use either variable as an upper bound:\n-    self.infcx().vars(vb, a_vid, b_vid).then {||\n+    self.infcx().vars(vb, a_vid, b_vid).then({||\n         ok(a_t)\n-    }\n+    })\n }\n \n fn lattice_var_t<V:copy vid, T:copy to_str st, L:lattice_ops combine>(\n@@ -2623,7 +2624,7 @@ fn lattice_var_t<V:copy vid, T:copy to_str st, L:lattice_ops combine>(\n         // and then return b.\n         #debug[\"bnd=none\"];\n         let a_bounds = self.with_bnd(a_bounds, b);\n-        self.infcx().bnds(a_bounds.lb, a_bounds.ub).then {||\n+        do self.infcx().bnds(a_bounds.lb, a_bounds.ub).then {||\n             self.infcx().set(vb, a_id, root(a_bounds,\n                                             nde_a.rank));\n             ok(b)"}, {"sha": "3210f07803a65a0ac640bc7b233fcbd6257aff5d", "filename": "src/rustc/middle/typeck/rscope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -28,7 +28,7 @@ impl of region_scope for type_rscope {\n         }\n     }\n     fn named_region(id: ast::ident) -> result<ty::region, str> {\n-        empty_rscope.named_region(id).chain_err { |_e|\n+        do empty_rscope.named_region(id).chain_err { |_e|\n             if *id == \"self\" { self.anon_region() }\n             else {\n                 result::err(\"named regions other than `self` are not \\\n@@ -62,7 +62,7 @@ impl of region_scope for @binding_rscope {\n         result::ok(ty::re_bound(ty::br_anon))\n     }\n     fn named_region(id: ast::ident) -> result<ty::region, str> {\n-        self.base.named_region(id).chain_err {|_e|\n+        do self.base.named_region(id).chain_err {|_e|\n             result::ok(ty::re_bound(ty::br_named(id)))\n         }\n     }"}, {"sha": "8de7718fef2d790f7e52e63e8eb4311bb0cef753", "filename": "src/rustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fcommon.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -56,13 +56,13 @@ fn loop_query(b: ast::blk, p: fn@(ast::expr_) -> bool) -> bool {\n }\n \n fn has_nonlocal_exits(b: ast::blk) -> bool {\n-    loop_query(b) {|e| alt e {\n+    do loop_query(b) {|e| alt e {\n       ast::expr_break | ast::expr_cont { true }\n       _ { false }}}\n }\n \n fn may_break(b: ast::blk) -> bool {\n-    loop_query(b) {|e| alt e {\n+    do loop_query(b) {|e| alt e {\n       ast::expr_break { true }\n       _ { false }}}\n }"}, {"sha": "7f82e690e338f27b8c74c630864cc8ab498703ea", "filename": "src/rustdoc/astsrv.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fastsrv.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -60,7 +60,7 @@ fn from_file<T>(file: str, owner: srv_owner<T>) -> T {\n fn run<T>(owner: srv_owner<T>, source: str, +parse: parser) -> T {\n \n     let srv_ = srv({\n-        ch: task::spawn_listener {|po|\n+        ch: do task::spawn_listener {|po|\n             act(po, source, parse);\n         }\n     });\n@@ -199,8 +199,8 @@ fn build_error_handlers(\n #[test]\n fn should_prune_unconfigured_items() {\n     let source = \"#[cfg(shut_up_and_leave_me_alone)]fn a() { }\";\n-    from_str(source) {|srv|\n-        exec(srv) {|ctxt|\n+    do from_str(source) {|srv|\n+        do exec(srv) {|ctxt|\n             assert vec::is_empty(ctxt.ast.node.module.items);\n         }\n     }\n@@ -209,8 +209,8 @@ fn should_prune_unconfigured_items() {\n #[test]\n fn srv_should_build_ast_map() {\n     let source = \"fn a() { }\";\n-    from_str(source) {|srv|\n-        exec(srv) {|ctxt|\n+    do from_str(source) {|srv|\n+        do exec(srv) {|ctxt|\n             assert ctxt.ast_map.size() != 0u\n         };\n     }\n@@ -219,8 +219,8 @@ fn srv_should_build_ast_map() {\n #[test]\n fn srv_should_build_reexport_map() {\n     let source = \"import a::b; export b; mod a { mod b { } }\";\n-    from_str(source) {|srv|\n-        exec(srv) {|ctxt|\n+    do from_str(source) {|srv|\n+        do exec(srv) {|ctxt|\n             assert ctxt.exp_map.size() != 0u\n         };\n     }\n@@ -232,41 +232,41 @@ fn srv_should_resolve_external_crates() {\n                   fn f() -> std::sha1::sha1 {\\\n                   std::sha1::mk_sha1() }\";\n     // Just testing that resolve doesn't crash\n-    from_str(source) {|_srv| }\n+    from_str(source, {|_srv| })\n }\n \n #[test]\n fn srv_should_resolve_core_crate() {\n     let source = \"fn a() -> option { fail }\";\n     // Just testing that resolve doesn't crash\n-    from_str(source) {|_srv| }\n+    from_str(source, {|_srv| })\n }\n \n #[test]\n fn srv_should_resolve_non_existant_imports() {\n     // We want to ignore things we can't resolve. Shouldn't\n     // need to be able to find external crates to create docs.\n     let source = \"import wooboo; fn a() { }\";\n-    from_str(source) {|_srv| }\n+    from_str(source, {|_srv| })\n }\n \n #[test]\n fn srv_should_resolve_non_existant_uses() {\n     let source = \"use forble; fn a() { }\";\n-    from_str(source) {|_srv| }\n+    from_str(source, {|_srv| })\n }\n \n #[test]\n fn should_ignore_external_import_paths_that_dont_exist() {\n     let source = \"use forble; import forble::bippy;\";\n-    from_str(source) {|_srv| }\n+    from_str(source, {|_srv| })\n }\n \n #[test]\n fn srv_should_return_request_result() {\n     let source = \"fn a() { }\";\n-    from_str(source) {|srv|\n-        let result = exec(srv) {|_ctxt| 1000};\n+    do from_str(source) {|srv|\n+        let result = exec(srv, {|_ctxt| 1000});\n         assert result == 1000;\n     }\n }"}, {"sha": "21e8d002d0d416985a9c82545cf6cc94110b5dba", "filename": "src/rustdoc/attr_pass.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_pass.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -42,7 +42,7 @@ fn fold_crate(\n     let srv = fold.ctxt;\n     let doc = fold::default_seq_fold_crate(fold, doc);\n \n-    let attrs = astsrv::exec(srv) {|ctxt|\n+    let attrs = do astsrv::exec(srv) {|ctxt|\n         let attrs = ctxt.ast.node.attrs;\n         attr_parser::parse_crate(attrs)\n     };\n@@ -74,7 +74,7 @@ fn fold_item(\n \n     let desc = if doc.id == ast::crate_node_id {\n         // This is the top-level mod, use the crate attributes\n-        astsrv::exec(srv) {|ctxt|\n+        do astsrv::exec(srv) {|ctxt|\n             attr_parser::parse_desc(ctxt.ast.node.attrs)\n         }\n     } else {\n@@ -91,7 +91,7 @@ fn parse_item_attrs<T:send>(\n     srv: astsrv::srv,\n     id: doc::ast_id,\n     +parse_attrs: fn~(~[ast::attribute]) -> T) -> T {\n-    astsrv::exec(srv) {|ctxt|\n+    do astsrv::exec(srv) {|ctxt|\n         let attrs = alt ctxt.ast_map.get(id) {\n           ast_map::node_item(item, _) { item.attrs }\n           ast_map::node_foreign_item(item, _, _) { item.attrs }\n@@ -143,16 +143,16 @@ fn fold_enum(\n     let doc = fold::default_seq_fold_enum(fold, doc);\n \n     {\n-        variants: par::anymap(doc.variants) {|variant|\n-            let desc = astsrv::exec(srv) {|ctxt|\n+        variants: do par::anymap(doc.variants) {|variant|\n+            let desc = do astsrv::exec(srv) {|ctxt|\n                 alt check ctxt.ast_map.get(doc_id) {\n                   ast_map::node_item(@{\n                     node: ast::item_enum(ast_variants, _, _), _\n                   }, _) {\n                     let ast_variant = option::get(\n-                        vec::find(ast_variants) {|v|\n+                        vec::find(ast_variants, {|v|\n                             *v.node.name == variant.name\n-                        });\n+                        }));\n \n                     attr_parser::parse_desc(ast_variant.node.attrs)\n                   }\n@@ -201,27 +201,27 @@ fn merge_method_attrs(\n ) -> ~[doc::methoddoc] {\n \n     // Create an assoc list from method name to attributes\n-    let attrs: ~[(str, option<str>)] = astsrv::exec(srv) {|ctxt|\n+    let attrs: ~[(str, option<str>)] = do astsrv::exec(srv) {|ctxt|\n         alt ctxt.ast_map.get(item_id) {\n           ast_map::node_item(@{\n             node: ast::item_iface(_, _, methods), _\n           }, _) {\n-            par::seqmap(methods) {|method|\n+            par::seqmap(methods, {|method|\n                 (*method.ident, attr_parser::parse_desc(method.attrs))\n-            }\n+            })\n           }\n           ast_map::node_item(@{\n             node: ast::item_impl(_, _, _, _, methods), _\n           }, _) {\n-            par::seqmap(methods) {|method|\n+            par::seqmap(methods, {|method|\n                 (*method.ident, attr_parser::parse_desc(method.attrs))\n-            }\n+            })\n           }\n           _ { fail \"unexpected item\" }\n         }\n     };\n \n-    vec::map2(docs, attrs) {|doc, attrs|\n+    do vec::map2(docs, attrs) {|doc, attrs|\n         assert doc.name == tuple::first(attrs);\n         let desc = tuple::second(attrs);\n \n@@ -282,7 +282,7 @@ fn should_extract_impl_method_docs() {\n #[cfg(test)]\n mod test {\n     fn mk_doc(source: str) -> doc::doc {\n-        astsrv::from_str(source) {|srv|\n+        do astsrv::from_str(source) {|srv|\n             let doc = extract::from_srv(srv, \"\");\n             run(srv, doc)\n         }"}, {"sha": "e3332cfe54b6dbdf69fe5a262f955551f5a8ecd7", "filename": "src/rustdoc/config.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fconfig.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -122,43 +122,45 @@ fn config_from_opts(\n \n     let config = default_config(input_crate);\n     let result = result::ok(config);\n-    let result = result::chain(result) {|config|\n+    let result = do result::chain(result) {|config|\n         let output_dir = getopts::opt_maybe_str(match, opt_output_dir());\n         result::ok({\n             output_dir: option::get_default(output_dir, config.output_dir)\n             with config\n         })\n     };\n-    let result = result::chain(result) {|config|\n+    let result = do result::chain(result) {|config|\n         let output_format = getopts::opt_maybe_str(\n             match, opt_output_format());\n-        option::map_default(output_format, result::ok(config))\n+        do option::map_default(output_format, result::ok(config))\n            {|output_format|\n-            result::chain(parse_output_format(output_format)) {|output_format|\n+            do result::chain(parse_output_format(output_format))\n+                {|output_format|\n+\n                 result::ok({\n                     output_format: output_format\n                     with config\n                 })\n             }\n         }\n     };\n-    let result = result::chain(result) {|config|\n+    let result = do result::chain(result) {|config|\n         let output_style = getopts::opt_maybe_str(match, opt_output_style());\n-        option::map_default(output_style, result::ok(config))\n+        do option::map_default(output_style, result::ok(config))\n           {|output_style|\n-            result::chain(parse_output_style(output_style)) {|output_style|\n+            do result::chain(parse_output_style(output_style)) {|output_style|\n                 result::ok({\n                     output_style: output_style\n                     with config\n                 })\n             }\n         }\n     };\n-    let result = result::chain(result) {|config|\n+    let result = do result::chain(result) {|config|\n         let pandoc_cmd = getopts::opt_maybe_str(match, opt_pandoc_cmd());\n         let pandoc_cmd = maybe_find_pandoc(\n             config, pandoc_cmd, program_output);\n-        result::chain(pandoc_cmd) {|pandoc_cmd|\n+        do result::chain(pandoc_cmd) {|pandoc_cmd|\n             result::ok({\n                 pandoc_cmd: pandoc_cmd\n                 with config\n@@ -205,7 +207,7 @@ fn maybe_find_pandoc(\n       }\n     };\n \n-    let pandoc = vec::find(possible_pandocs) {|pandoc|\n+    let pandoc = do vec::find(possible_pandocs) {|pandoc|\n         let output = program_output(pandoc, ~[\"--version\"]);\n         #debug(\"testing pandoc cmd %s: %?\", pandoc, output);\n         output.status == 0"}, {"sha": "3738b443ffe55bc893f624294dffd71496d5f34a", "filename": "src/rustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdesc_to_brief_pass.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -42,12 +42,12 @@ fn fold_iface(fold: fold::fold<()>, doc: doc::ifacedoc) -> doc::ifacedoc {\n     let doc =fold::default_seq_fold_iface(fold, doc);\n \n     {\n-        methods: par::anymap(doc.methods) {|doc|\n+        methods: par::anymap(doc.methods, {|doc|\n             {\n                 brief: extract(doc.desc)\n                 with doc\n             }\n-        }\n+        })\n         with doc\n     }\n }\n@@ -56,12 +56,12 @@ fn fold_impl(fold: fold::fold<()>, doc: doc::impldoc) -> doc::impldoc {\n     let doc =fold::default_seq_fold_impl(fold, doc);\n \n     {\n-        methods: par::anymap(doc.methods) {|doc|\n+        methods: par::anymap(doc.methods, {|doc|\n             {\n                 brief: extract(doc.desc)\n                 with doc\n             }\n-        }\n+        })\n         with doc\n     }\n }\n@@ -88,7 +88,7 @@ fn should_promote_impl_method_desc() {\n #[cfg(test)]\n mod test {\n     fn mk_doc(source: str) -> doc::doc {\n-        astsrv::from_str(source) {|srv|\n+        do astsrv::from_str(source) {|srv|\n             let doc = extract::from_srv(srv, \"\");\n             let doc = attr_pass::mk_pass().f(srv, doc);\n             run(srv, doc)\n@@ -134,7 +134,7 @@ fn first_sentence_(s: str) -> str {\n     let mut dotcount = 0;\n     // The index of the character following a single dot. This allows\n     // Things like [0..1) to appear in the brief description\n-    let idx = str::find(s) {|ch|\n+    let idx = do str::find(s) {|ch|\n         if ch == '.' {\n             dotcount += 1;\n             false\n@@ -165,7 +165,7 @@ fn paragraphs(s: str) -> ~[str] {\n     let lines = str::lines_any(s);\n     let mut whitespace_lines = 0;\n     let mut accum = \"\";\n-    let paras = vec::foldl(~[], lines) {|paras, line|\n+    let paras = do vec::foldl(~[], lines) {|paras, line|\n         let mut res = paras;\n \n         if str::is_whitespace(line) {"}, {"sha": "b0369620daf844ee5cf0d6cf0766e11c4a36e9ec", "filename": "src/rustdoc/doc.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdoc.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -128,12 +128,12 @@ type index_entry = {\n \n impl util for doc {\n     fn cratedoc() -> cratedoc {\n-        option::get(vec::foldl(none, self.pages) {|_m, page|\n+        option::get(vec::foldl(none, self.pages, {|_m, page|\n             alt page {\n               doc::cratepage(doc) { some(doc) }\n               _ { none }\n             }\n-        })\n+        }))\n     }\n \n     fn cratemod() -> moddoc {\n@@ -145,7 +145,7 @@ impl util for doc {\n impl util for moddoc {\n \n     fn mods() -> ~[moddoc] {\n-        vec::filter_map(self.items) {|itemtag|\n+        do vec::filter_map(self.items) {|itemtag|\n             alt itemtag {\n               modtag(moddoc) { some(moddoc) }\n               _ { none }\n@@ -154,7 +154,7 @@ impl util for moddoc {\n     }\n \n     fn nmods() -> ~[nmoddoc] {\n-        vec::filter_map(self.items) {|itemtag|\n+        do vec::filter_map(self.items) {|itemtag|\n             alt itemtag {\n               nmodtag(nmoddoc) { some(nmoddoc) }\n               _ { none }\n@@ -163,7 +163,7 @@ impl util for moddoc {\n     }\n \n     fn fns() -> ~[fndoc] {\n-        vec::filter_map(self.items) {|itemtag|\n+        do vec::filter_map(self.items) {|itemtag|\n             alt itemtag {\n               fntag(fndoc) { some(fndoc) }\n               _ { none }\n@@ -172,7 +172,7 @@ impl util for moddoc {\n     }\n \n     fn consts() -> ~[constdoc] {\n-        vec::filter_map(self.items) {|itemtag|\n+        do vec::filter_map(self.items) {|itemtag|\n             alt itemtag {\n               consttag(constdoc) { some(constdoc) }\n               _ { none }\n@@ -181,7 +181,7 @@ impl util for moddoc {\n     }\n \n     fn enums() -> ~[enumdoc] {\n-        vec::filter_map(self.items) {|itemtag|\n+        do vec::filter_map(self.items) {|itemtag|\n             alt itemtag {\n               enumtag(enumdoc) { some(enumdoc) }\n               _ { none }\n@@ -190,7 +190,7 @@ impl util for moddoc {\n     }\n \n     fn ifaces() -> ~[ifacedoc] {\n-        vec::filter_map(self.items) {|itemtag|\n+        do vec::filter_map(self.items) {|itemtag|\n             alt itemtag {\n               ifacetag(ifacedoc) { some(ifacedoc) }\n               _ { none }\n@@ -199,7 +199,7 @@ impl util for moddoc {\n     }\n \n     fn impls() -> ~[impldoc] {\n-        vec::filter_map(self.items) {|itemtag|\n+        do vec::filter_map(self.items) {|itemtag|\n             alt itemtag {\n               impltag(impldoc) { some(impldoc) }\n               _ { none }\n@@ -208,7 +208,7 @@ impl util for moddoc {\n     }\n \n     fn types() -> ~[tydoc] {\n-        vec::filter_map(self.items) {|itemtag|\n+        do vec::filter_map(self.items) {|itemtag|\n             alt itemtag {\n               tytag(tydoc) { some(tydoc) }\n               _ { none }\n@@ -220,7 +220,7 @@ impl util for moddoc {\n impl util for ~[page] {\n \n     fn mods() -> ~[moddoc] {\n-        vec::filter_map(self) {|page|\n+        do vec::filter_map(self) {|page|\n             alt page {\n               itempage(modtag(moddoc)) { some(moddoc) }\n               _ { none }\n@@ -229,7 +229,7 @@ impl util for ~[page] {\n     }\n \n     fn nmods() -> ~[nmoddoc] {\n-        vec::filter_map(self) {|page|\n+        do vec::filter_map(self) {|page|\n             alt page {\n               itempage(nmodtag(nmoddoc)) { some(nmoddoc) }\n               _ { none }\n@@ -238,7 +238,7 @@ impl util for ~[page] {\n     }\n \n     fn fns() -> ~[fndoc] {\n-        vec::filter_map(self) {|page|\n+        do vec::filter_map(self) {|page|\n             alt page {\n               itempage(fntag(fndoc)) { some(fndoc) }\n               _ { none }\n@@ -247,7 +247,7 @@ impl util for ~[page] {\n     }\n \n     fn consts() -> ~[constdoc] {\n-        vec::filter_map(self) {|page|\n+        do vec::filter_map(self) {|page|\n             alt page {\n               itempage(consttag(constdoc)) { some(constdoc) }\n               _ { none }\n@@ -256,7 +256,7 @@ impl util for ~[page] {\n     }\n \n     fn enums() -> ~[enumdoc] {\n-        vec::filter_map(self) {|page|\n+        do vec::filter_map(self) {|page|\n             alt page {\n               itempage(enumtag(enumdoc)) { some(enumdoc) }\n               _ { none }\n@@ -265,7 +265,7 @@ impl util for ~[page] {\n     }\n \n     fn ifaces() -> ~[ifacedoc] {\n-        vec::filter_map(self) {|page|\n+        do vec::filter_map(self) {|page|\n             alt page {\n               itempage(ifacetag(ifacedoc)) { some(ifacedoc) }\n               _ { none }\n@@ -274,7 +274,7 @@ impl util for ~[page] {\n     }\n \n     fn impls() -> ~[impldoc] {\n-        vec::filter_map(self) {|page|\n+        do vec::filter_map(self) {|page|\n             alt page {\n               itempage(impltag(impldoc)) { some(impldoc) }\n               _ { none }\n@@ -283,7 +283,7 @@ impl util for ~[page] {\n     }\n \n     fn types() -> ~[tydoc] {\n-        vec::filter_map(self) {|page|\n+        do vec::filter_map(self) {|page|\n             alt page {\n               itempage(tytag(tydoc)) { some(tydoc) }\n               _ { none }"}, {"sha": "17ce84f266db9cb0113522a0153d71de1a83e13a", "filename": "src/rustdoc/extract.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fextract.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -11,7 +11,7 @@ fn from_srv(\n \n     #[doc = \"Use the AST service to create a document tree\"];\n \n-    astsrv::exec(srv) {|ctxt|\n+    do astsrv::exec(srv) {|ctxt|\n         extract(ctxt.ast, default_name)\n     }\n }\n@@ -55,7 +55,7 @@ fn moddoc_from_mod(\n ) -> doc::moddoc {\n     {\n         item: itemdoc,\n-        items: vec::filter_map(module.items) {|item|\n+        items: do vec::filter_map(module.items) {|item|\n             let itemdoc = mk_itemdoc(item.id, item.ident);\n             alt item.node {\n               ast::item_mod(m) {\n@@ -113,7 +113,7 @@ fn nmoddoc_from_mod(\n ) -> doc::nmoddoc {\n     {\n         item: itemdoc,\n-        fns: par::seqmap(module.items) {|item|\n+        fns: do par::seqmap(module.items) {|item|\n             let itemdoc = mk_itemdoc(item.id, item.ident);\n             alt item.node {\n               ast::foreign_item_fn(_, _) {\n@@ -189,7 +189,7 @@ fn ifacedoc_from_iface(\n ) -> doc::ifacedoc {\n     {\n         item: itemdoc,\n-        methods: par::seqmap(methods) {|method|\n+        methods: do par::seqmap(methods) {|method|\n             {\n                 name: *method.ident,\n                 brief: none,\n@@ -221,7 +221,7 @@ fn impldoc_from_impl(\n         item: itemdoc,\n         iface_ty: none,\n         self_ty: none,\n-        methods: par::seqmap(methods) {|method|\n+        methods: do par::seqmap(methods) {|method|\n             {\n                 name: *method.ident,\n                 brief: none,\n@@ -339,7 +339,7 @@ mod test {\n     #[test]\n     fn extract_from_seq_srv() {\n         let source = \"\";\n-        astsrv::from_str(source) {|srv|\n+        do astsrv::from_str(source) {|srv|\n             let doc = from_srv(srv, \"name\");\n             assert doc.cratemod().name() == \"name\";\n         }"}, {"sha": "7e5cafcb91e6ff6d37b1e454ba2427bdc63bc4e4", "filename": "src/rustdoc/fold.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ffold.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -133,7 +133,7 @@ fn default_par_fold<T:send copy>(ctxt: T) -> fold<T> {\n \n fn default_seq_fold_doc<T>(fold: fold<T>, doc: doc::doc) -> doc::doc {\n     {\n-        pages: par::seqmap(doc.pages) {|page|\n+        pages: do par::seqmap(doc.pages) {|page|\n             alt page {\n               doc::cratepage(doc) {\n                 doc::cratepage(fold.fold_crate(fold, doc))\n@@ -169,9 +169,9 @@ fn default_any_fold_mod<T:send copy>(\n ) -> doc::moddoc {\n     {\n         item: fold.fold_item(fold, doc.item),\n-        items: par::anymap(doc.items) {|itemtag, copy fold|\n+        items: par::anymap(doc.items, {|itemtag, copy fold|\n             fold_itemtag(fold, itemtag)\n-        }\n+        })\n         with doc\n     }\n }\n@@ -182,9 +182,9 @@ fn default_seq_fold_mod<T>(\n ) -> doc::moddoc {\n     {\n         item: fold.fold_item(fold, doc.item),\n-        items: par::seqmap(doc.items) {|itemtag|\n+        items: par::seqmap(doc.items, {|itemtag|\n             fold_itemtag(fold, itemtag)\n-        }\n+        })\n         with doc\n     }\n }\n@@ -195,9 +195,9 @@ fn default_par_fold_mod<T:send copy>(\n ) -> doc::moddoc {\n     {\n         item: fold.fold_item(fold, doc.item),\n-        items: par::parmap(doc.items) {|itemtag, copy fold|\n+        items: par::parmap(doc.items, {|itemtag, copy fold|\n             fold_itemtag(fold, itemtag)\n-        }\n+        })\n         with doc\n     }\n }\n@@ -208,9 +208,9 @@ fn default_any_fold_nmod<T:send copy>(\n ) -> doc::nmoddoc {\n     {\n         item: fold.fold_item(fold, doc.item),\n-        fns: par::anymap(doc.fns) {|fndoc, copy fold|\n+        fns: par::anymap(doc.fns, {|fndoc, copy fold|\n             fold.fold_fn(fold, fndoc)\n-        }\n+        })\n         with doc\n     }\n }\n@@ -221,9 +221,9 @@ fn default_seq_fold_nmod<T>(\n ) -> doc::nmoddoc {\n     {\n         item: fold.fold_item(fold, doc.item),\n-        fns: par::seqmap(doc.fns) {|fndoc|\n+        fns: par::seqmap(doc.fns, {|fndoc|\n             fold.fold_fn(fold, fndoc)\n-        }\n+        })\n         with doc\n     }\n }\n@@ -234,9 +234,9 @@ fn default_par_fold_nmod<T:send copy>(\n ) -> doc::nmoddoc {\n     {\n         item: fold.fold_item(fold, doc.item),\n-        fns: par::parmap(doc.fns) {|fndoc, copy fold|\n+        fns: par::parmap(doc.fns, {|fndoc, copy fold|\n             fold.fold_fn(fold, fndoc)\n-        }\n+        })\n         with doc\n     }\n }"}, {"sha": "83d2180e1e7b3fef09058f63cc57035aa44f2ee6", "filename": "src/rustdoc/markdown_index_pass.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_index_pass.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -55,9 +55,9 @@ fn build_mod_index(\n     config: config::config\n ) -> doc::index {\n     {\n-        entries: par::anymap(doc.items) {|doc|\n+        entries: par::anymap(doc.items, {|doc|\n             item_to_entry(doc, config)\n-        }\n+        })\n     }\n }\n \n@@ -66,9 +66,9 @@ fn build_nmod_index(\n     config: config::config\n ) -> doc::index {\n     {\n-        entries: par::anymap(doc.fns) {|doc|\n+        entries: par::anymap(doc.fns, {|doc|\n             item_to_entry(doc::fntag(doc), config)\n-        }\n+        })\n     }\n }\n \n@@ -215,7 +215,7 @@ fn should_index_foreign_mod_contents() {\n #[cfg(test)]\n mod test {\n     fn mk_doc(output_style: config::output_style, source: str) -> doc::doc {\n-        astsrv::from_str(source) {|srv|\n+        do astsrv::from_str(source) {|srv|\n             let config = {\n                 output_style: output_style\n                 with config::default_config(\"whatever\")"}, {"sha": "9fe29dafd051afa9d2f65cd698eccea76ca308ca", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -82,7 +82,7 @@ fn write_markdown(\n     doc: doc::doc,\n     +writer_factory: writer_factory\n ) {\n-    par::anymap(doc.pages) {|page|\n+    do par::anymap(doc.pages) {|page|\n         let ctxt = {\n             w: writer_factory(page)\n         };\n@@ -115,7 +115,7 @@ fn should_request_new_writer_for_each_page() {\n     let doc = page_pass::mk_pass(config::doc_per_mod).f(srv, doc);\n     write_markdown(doc, writer_factory);\n     // We expect two pages to have been written\n-    iter::repeat(2u) {||\n+    do iter::repeat(2u) {||\n         comm::recv(po);\n     }\n }\n@@ -146,7 +146,7 @@ fn should_write_title_for_each_page() {\n         \"#[link(name = \\\"core\\\")]; mod a { }\");\n     let doc = page_pass::mk_pass(config::doc_per_mod).f(srv, doc);\n     write_markdown(doc, writer_factory);\n-    iter::repeat(2u) {||\n+    do iter::repeat(2u) {||\n         let (page, markdown) = comm::recv(po);\n         alt page {\n           doc::cratepage(_) {\n@@ -295,7 +295,7 @@ fn write_desc(\n }\n \n fn write_sections(ctxt: ctxt, sections: ~[doc::section]) {\n-    vec::iter(sections) {|section|\n+    do vec::iter(sections) {|section|\n         write_section(ctxt, section);\n     }\n }\n@@ -645,7 +645,7 @@ fn write_iface(ctxt: ctxt, doc: doc::ifacedoc) {\n }\n \n fn write_methods(ctxt: ctxt, docs: ~[doc::methoddoc]) {\n-    vec::iter(docs) {|doc| write_method(ctxt, doc) }\n+    do vec::iter(docs) {|doc| write_method(ctxt, doc) }\n }\n \n fn write_method(ctxt: ctxt, doc: doc::methoddoc) {\n@@ -760,7 +760,7 @@ mod test {\n     }\n \n     fn create_doc_srv(source: str) -> (astsrv::srv, doc::doc) {\n-        astsrv::from_str(source) {|srv|\n+        do astsrv::from_str(source) {|srv|\n \n             let config = {\n                 output_style: config::doc_per_crate"}, {"sha": "6d8a4d9632c0d9e04504a7d0700e4988dd52480a", "filename": "src/rustdoc/markdown_writer.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_writer.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -56,7 +56,7 @@ fn markdown_writer(\n     page: doc::page\n ) -> writer {\n     let filename = make_local_filename(config, page);\n-    generic_writer {|markdown|\n+    do generic_writer {|markdown|\n         write_file(filename, markdown);\n     }\n }\n@@ -78,7 +78,7 @@ fn pandoc_writer(\n         \"--output=\" + filename\n     ];\n \n-    generic_writer {|markdown|\n+    do generic_writer {|markdown|\n         import io::writer_util;\n \n         #debug(\"pandoc cmd: %s\", pandoc_cmd);\n@@ -101,14 +101,14 @@ fn pandoc_writer(\n \n         let stdout_po = comm::port();\n         let stdout_ch = comm::chan(stdout_po);\n-        task::spawn_sched(task::single_threaded) {||\n+        do task::spawn_sched(task::single_threaded) {||\n             comm::send(stdout_ch, readclose(pipe_out.in));\n         }\n         let stdout = comm::recv(stdout_po);\n \n         let stderr_po = comm::port();\n         let stderr_ch = comm::chan(stderr_po);\n-        task::spawn_sched(task::single_threaded) {||\n+        do task::spawn_sched(task::single_threaded) {||\n             comm::send(stderr_ch, readclose(pipe_err.in));\n         }\n         let stderr = comm::recv(stderr_po);\n@@ -137,7 +137,7 @@ fn readclose(fd: libc::c_int) -> str {\n }\n \n fn generic_writer(+process: fn~(markdown: str)) -> writer {\n-    let ch = task::spawn_listener {|po: comm::port<writeinstr>|\n+    let ch = do task::spawn_listener {|po: comm::port<writeinstr>|\n         let mut markdown = \"\";\n         let mut keep_going = true;\n         while keep_going {\n@@ -236,7 +236,7 @@ fn should_name_mod_file_names_by_path() {\n #[cfg(test)]\n mod test {\n     fn mk_doc(name: str, source: str) -> doc::doc {\n-        astsrv::from_str(source) {|srv|\n+        do astsrv::from_str(source) {|srv|\n             let doc = extract::from_srv(srv, name);\n             let doc = path_pass::mk_pass().f(srv, doc);\n             doc\n@@ -262,7 +262,7 @@ fn future_writer_factory(\n     let writer_factory = fn~(page: doc::page) -> writer {\n         let writer_po = comm::port();\n         let writer_ch = comm::chan(writer_po);\n-        task::spawn {||\n+        do task::spawn {||\n             let (writer, future) = future_writer();\n             comm::send(writer_ch, writer);\n             let s = future::get(future);\n@@ -280,7 +280,7 @@ fn future_writer() -> (writer, future::future<str>) {\n     let writer = fn~(+instr: writeinstr) {\n         comm::send(chan, copy instr);\n     };\n-    let future = future::from_fn {||\n+    let future = do future::from_fn {||\n         let mut res = \"\";\n         loop {\n             alt comm::recv(port) {"}, {"sha": "753ce879b61e7f84c3f37581b64cbe6b5c8e57ae", "filename": "src/rustdoc/page_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fpage_pass.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -32,7 +32,7 @@ fn run(\n \n     let result_port = comm::port();\n     let result_chan = comm::chan(result_port);\n-    let page_chan = task::spawn_listener {|page_port|\n+    let page_chan = do task::spawn_listener {|page_port|\n         comm::send(result_chan, make_doc_from_pages(page_port));\n     };\n \n@@ -106,7 +106,7 @@ fn fold_mod(\n \n fn strip_mod(doc: doc::moddoc) -> doc::moddoc {\n     {\n-        items: vec::filter(doc.items) {|item|\n+        items: do vec::filter(doc.items) {|item|\n             alt item {\n               doc::modtag(_) { false }\n               doc::nmodtag(_) { false }\n@@ -166,7 +166,7 @@ mod test {\n         output_style: config::output_style,\n         source: str\n     ) -> doc::doc {\n-        astsrv::from_str(source) {|srv|\n+        do astsrv::from_str(source) {|srv|\n             let doc = extract::from_srv(srv, \"\");\n             run(srv, doc, output_style)\n         }"}, {"sha": "6275e47d26c5665e7ccbf5ab8144b56cfbf2a260", "filename": "src/rustdoc/par.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fpar.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -9,23 +9,23 @@ fn seqmap<T, U>(v: ~[T], f: fn(T) -> U) -> ~[U] {\n }\n \n fn parmap<T:send, U:send>(v: ~[T], f: fn~(T) -> U) -> ~[U] unsafe {\n-    let futures = vec::map(v) {|elt|\n+    let futures = do vec::map(v) {|elt|\n         let po = comm::port();\n         let ch = comm::chan(po);\n         let addr = ptr::addr_of(elt);\n-        task::spawn {|copy f|\n+        do task::spawn {|copy f|\n             comm::send(ch, f(*addr));\n         }\n         po\n     };\n-    vec::map(futures) {|future|\n+    do vec::map(futures) {|future|\n         comm::recv(future)\n     }\n }\n \n #[test]\n fn test_parallel_map() {\n     let i = ~[1, 2, 3, 4];\n-    let j = parmap(i) {|e| e + 1 };\n+    let j = parmap(i, {|e| e + 1 });\n     assert j == ~[2, 3, 4, 5];\n }"}, {"sha": "081cd9fe293aaed6924c08262dbbdeeaac45e11f", "filename": "src/rustdoc/path_pass.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fpath_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fpath_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fpath_pass.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -66,7 +66,7 @@ fn fold_nmod(fold: fold::fold<ctxt>, doc: doc::nmoddoc) -> doc::nmoddoc {\n #[test]\n fn should_record_mod_paths() {\n     let source = \"mod a { mod b { mod c { } } mod d { mod e { } } }\";\n-    astsrv::from_str(source) {|srv|\n+    do astsrv::from_str(source) {|srv|\n         let doc = extract::from_srv(srv, \"\");\n         let doc = run(srv, doc);\n         assert doc.cratemod().mods()[0].mods()[0].mods()[0].path()\n@@ -79,7 +79,7 @@ fn should_record_mod_paths() {\n #[test]\n fn should_record_fn_paths() {\n     let source = \"mod a { fn b() { } }\";\n-    astsrv::from_str(source) {|srv|\n+    do astsrv::from_str(source) {|srv|\n         let doc = extract::from_srv(srv, \"\");\n         let doc = run(srv, doc);\n         assert doc.cratemod().mods()[0].fns()[0].path() == ~[\"a\"];\n@@ -89,7 +89,7 @@ fn should_record_fn_paths() {\n #[test]\n fn should_record_foreign_mod_paths() {\n     let source = \"mod a { native mod b { } }\";\n-    astsrv::from_str(source) {|srv|\n+    do astsrv::from_str(source) {|srv|\n         let doc = extract::from_srv(srv, \"\");\n         let doc = run(srv, doc);\n         assert doc.cratemod().mods()[0].nmods()[0].path() == ~[\"a\"];\n@@ -99,7 +99,7 @@ fn should_record_foreign_mod_paths() {\n #[test]\n fn should_record_foreign_fn_paths() {\n     let source = \"native mod a { fn b(); }\";\n-    astsrv::from_str(source) {|srv|\n+    do astsrv::from_str(source) {|srv|\n         let doc = extract::from_srv(srv, \"\");\n         let doc = run(srv, doc);\n         assert doc.cratemod().nmods()[0].fns[0].path() == ~[\"a\"];"}, {"sha": "24c0c019ee6c0c191406db5fded78d73cf960301", "filename": "src/rustdoc/prune_hidden_pass.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fprune_hidden_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fprune_hidden_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_hidden_pass.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -25,9 +25,9 @@ fn fold_mod(\n     let doc = fold::default_any_fold_mod(fold, doc);\n \n     {\n-        items: vec::filter(doc.items) {|itemtag|\n+        items: vec::filter(doc.items, {|itemtag|\n             !is_hidden(fold.ctxt, itemtag.item())\n-        }\n+        })\n         with doc\n     }\n }\n@@ -36,7 +36,7 @@ fn is_hidden(srv: astsrv::srv, doc: doc::itemdoc) -> bool {\n     import syntax::ast_map;\n \n     let id = doc.id;\n-    astsrv::exec(srv) {|ctxt|\n+    do astsrv::exec(srv) {|ctxt|\n         let attrs = alt ctxt.ast_map.get(id) {\n           ast_map::node_item(item, _) { item.attrs }\n           _ { ~[] }\n@@ -54,7 +54,7 @@ fn should_prune_hidden_items() {\n #[cfg(test)]\n mod test {\n     fn mk_doc(source: str) -> doc::doc {\n-        astsrv::from_str(source) {|srv|\n+        do astsrv::from_str(source) {|srv|\n             let doc = extract::from_srv(srv, \"\");\n             run(srv, doc)\n         }"}, {"sha": "8e9d15e25ec11c479d722264bedb45f2ae6d3a00", "filename": "src/rustdoc/prune_unexported_pass.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fprune_unexported_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fprune_unexported_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_unexported_pass.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -72,7 +72,7 @@ fn exported_items_from(\n     doc: doc::moddoc,\n     is_exported: fn(astsrv::srv, str) -> bool\n ) -> ~[doc::itemtag] {\n-    vec::filter_map(doc.items) { |itemtag|\n+    do vec::filter_map(doc.items) { |itemtag|\n         let itemtag = alt itemtag {\n           doc::enumtag(enumdoc) {\n             // Also need to check variant exportedness\n@@ -97,7 +97,7 @@ fn exported_variants_from(\n     doc: doc::enumdoc,\n     is_exported: fn(astsrv::srv, str) -> bool\n ) -> ~[doc::variantdoc] {\n-    vec::filter_map(doc.variants) { |doc|\n+    do vec::filter_map(doc.variants) { |doc|\n         if is_exported(srv, doc.name) {\n             some(doc)\n         } else {\n@@ -111,7 +111,7 @@ fn is_exported_from_mod(\n     mod_id: doc::ast_id,\n     item_name: str\n ) -> bool {\n-    astsrv::exec(srv) {|ctxt|\n+    do astsrv::exec(srv) {|ctxt|\n         alt ctxt.ast_map.get(mod_id) {\n           ast_map::node_item(item, _) {\n             alt item.node {\n@@ -132,7 +132,7 @@ fn is_exported_from_crate(\n     srv: astsrv::srv,\n     item_name: str\n ) -> bool {\n-    astsrv::exec(srv) {|ctxt|\n+    do astsrv::exec(srv) {|ctxt|\n         ast_util::is_exported(@item_name, ctxt.ast.node.module)\n     }\n }\n@@ -223,7 +223,7 @@ fn should_prune_unexported_types() {\n #[test]\n fn should_not_prune_reexports() {\n     fn mk_doc(source: str) -> doc::doc {\n-        astsrv::from_str(source) {|srv|\n+        do astsrv::from_str(source) {|srv|\n             let doc = extract::from_srv(srv, \"\");\n             let doc = reexport_pass::mk_pass().f(srv, doc);\n             run(srv, doc)\n@@ -238,7 +238,7 @@ fn should_not_prune_reexports() {\n #[cfg(test)]\n mod test {\n     fn mk_doc(source: str) -> doc::doc {\n-        astsrv::from_str(source) {|srv|\n+        do astsrv::from_str(source) {|srv|\n             let doc = extract::from_srv(srv, \"\");\n             run(srv, doc)\n         }"}, {"sha": "3232a7247454e7b831ff680ecbcac0cf1ab77af6", "filename": "src/rustdoc/reexport_pass.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Freexport_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Freexport_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Freexport_pass.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -58,7 +58,7 @@ fn from_assoc_list<K:copy, V:copy>(\n ) -> map::hashmap<K, V> {\n \n     let map = new_hash();\n-    vec::iter(list) {|elt|\n+    do vec::iter(list) {|elt|\n         let (k, v) = elt;\n         map.insert(k, v);\n     }\n@@ -78,7 +78,7 @@ fn from_str_assoc_list<V:copy>(\n }\n \n fn build_reexport_def_set(srv: astsrv::srv) -> def_set {\n-    let assoc_list = astsrv::exec(srv) {|ctxt|\n+    let assoc_list = do astsrv::exec(srv) {|ctxt|\n         let def_set = ast_util::new_def_hash();\n         for ctxt.exp_map.each {|_id, defs|\n             for defs.each {|def|\n@@ -98,7 +98,7 @@ fn build_reexport_def_set(srv: astsrv::srv) -> def_set {\n \n fn find_reexport_impls(ctxt: astsrv::ctxt) -> ~[ast::def_id] {\n     let defs = @mut ~[];\n-    for_each_reexported_impl(ctxt) {|_mod_id, i|\n+    do for_each_reexported_impl(ctxt) {|_mod_id, i|\n         *defs += ~[i.did]\n     }\n     ret *defs;\n@@ -166,7 +166,7 @@ fn build_reexport_path_map(srv: astsrv::srv, -def_map: def_map) -> path_map {\n     let def_assoc_list = to_assoc_list(def_map);\n     #debug(\"def_map: %?\", def_assoc_list);\n \n-    let assoc_list = astsrv::exec(srv) {|ctxt|\n+    let assoc_list = do astsrv::exec(srv) {|ctxt|\n \n         let def_map = from_def_assoc_list(def_assoc_list);\n         let path_map = map::str_hash::<~[(str,doc::itemtag)]>();\n@@ -194,7 +194,7 @@ fn build_reexport_path_map(srv: astsrv::srv, -def_map: def_map) -> path_map {\n             }\n \n             if reexportdocs.len() > 0u {\n-                option::iter(path_map.find(modpath)) {|docs|\n+                do option::iter(path_map.find(modpath)) {|docs|\n                     reexportdocs = docs + vec::filter(reexportdocs, {|x|\n                         !vec::contains(docs, x)\n                     });\n@@ -226,7 +226,7 @@ fn find_reexport_impl_docs(\n ) -> ~[(str, (str, doc::itemtag))] {\n     let docs = @mut ~[];\n \n-    for_each_reexported_impl(ctxt) {|mod_id, i|\n+    do for_each_reexported_impl(ctxt) {|mod_id, i|\n         let path = alt ctxt.ast_map.find(mod_id) {\n           some(ast_map::node_item(item, path)) {\n             let path = ast_map::path_to_str(*path);\n@@ -338,7 +338,7 @@ fn merge_reexports(\n         #debug(\"looking for reexports in path %?\", path);\n         alt path_map.find(str::connect(path, \"::\")) {\n           some(name_docs) {\n-            vec::foldl(~[], name_docs) {|v, name_doc|\n+            do vec::foldl(~[], name_docs) {|v, name_doc|\n                 let (name, doc) = name_doc;\n                 v + ~[reexport_doc(doc, name)]\n             }\n@@ -462,7 +462,7 @@ fn should_duplicate_multiple_reexported_items() {\n                   import a::b; import a::c; \\\n                   export b; export c; \\\n                   }\";\n-    astsrv::from_str(source) {|srv|\n+    do astsrv::from_str(source) {|srv|\n         let doc = extract::from_srv(srv, \"\");\n         let doc = path_pass::mk_pass().f(srv, doc);\n         let doc = run(srv, doc);\n@@ -484,7 +484,7 @@ fn should_rename_items_reexported_with_different_names() {\n #[test]\n fn should_reexport_in_topmod() {\n     fn mk_doc(source: str) -> doc::doc {\n-        astsrv::from_str(source) {|srv|\n+        do astsrv::from_str(source) {|srv|\n             let doc = extract::from_srv(srv, \"core\");\n             let doc = path_pass::mk_pass().f(srv, doc);\n             run(srv, doc)\n@@ -515,7 +515,7 @@ fn should_not_reexport_multiple_times() {\n #[cfg(test)]\n mod test {\n     fn mk_doc(source: str) -> doc::doc {\n-        astsrv::from_str(source) {|srv|\n+        do astsrv::from_str(source) {|srv|\n             let doc = extract::from_srv(srv, \"\");\n             let doc = path_pass::mk_pass().f(srv, doc);\n             run(srv, doc)"}, {"sha": "c9d08567596440f75b624d8bfaff247059392fe0", "filename": "src/rustdoc/rustdoc.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -31,11 +31,11 @@ fn run_passes(\n     )];\n \n     let mut passno = 0;\n-    vec::foldl(doc, passes) {|doc, pass|\n+    do vec::foldl(doc, passes) {|doc, pass|\n         log(debug, #fmt(\"pass #%d\", passno));\n         passno += 1;\n         log(debug, doc);\n-        time(pass.name) {||\n+        do time(pass.name) {||\n             pass.f(srv, doc)\n         }\n     }\n@@ -82,7 +82,7 @@ fn test_run_passes() {\n         }\n     }\n     let source = \"\";\n-    astsrv::from_str(source) {|srv|\n+    do astsrv::from_str(source) {|srv|\n         let passes = ~[\n             {\n                 name: \"\",\n@@ -129,14 +129,14 @@ fn time<T>(what: str, f: fn() -> T) -> T {\n fn run(config: config::config) {\n \n     let source_file = config.input_crate;\n-    astsrv::from_file(source_file) {|srv|\n-        time(\"wait_ast\") {||\n-            astsrv::exec(srv) {|_ctxt| () }\n+    do astsrv::from_file(source_file) {|srv|\n+        do time(\"wait_ast\") {||\n+            do astsrv::exec(srv) {|_ctxt| () }\n         };\n-        let doc = time(\"extract\") {||\n+        let doc = time(\"extract\", {||\n             let default_name = source_file;\n             extract::from_srv(srv, default_name)\n-        };\n+        });\n         run_passes(srv, doc, ~[\n             reexport_pass::mk_pass(),\n             prune_unexported_pass::mk_pass(),"}, {"sha": "d4a453acb8355487c8215a4360411115aed7ced0", "filename": "src/rustdoc/sectionalize_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsectionalize_pass.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -34,7 +34,7 @@ fn fold_iface(fold: fold::fold<()>, doc: doc::ifacedoc) -> doc::ifacedoc {\n     let doc = fold::default_seq_fold_iface(fold, doc);\n \n     {\n-        methods: par::anymap(doc.methods) {|method|\n+        methods: do par::anymap(doc.methods) {|method|\n             let (desc, sections) = sectionalize(method.desc);\n \n             {\n@@ -51,7 +51,7 @@ fn fold_impl(fold: fold::fold<()>, doc: doc::impldoc) -> doc::impldoc {\n     let doc = fold::default_seq_fold_impl(fold, doc);\n \n     {\n-        methods: par::anymap(doc.methods) {|method|\n+        methods: do par::anymap(doc.methods) {|method|\n             let (desc, sections) = sectionalize(method.desc);\n \n             {\n@@ -228,7 +228,7 @@ fn should_sectionalize_impl_methods() {\n #[cfg(test)]\n mod test {\n     fn mk_doc(source: str) -> doc::doc {\n-        astsrv::from_str(source) {|srv|\n+        do astsrv::from_str(source) {|srv|\n             let doc = extract::from_srv(srv, \"\");\n             let doc = attr_pass::mk_pass().f(srv, doc);\n             run(srv, doc)"}, {"sha": "580286922ffaa8c245dd8b1390bc91955edc0fe0", "filename": "src/rustdoc/sort_item_name_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fsort_item_name_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fsort_item_name_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsort_item_name_pass.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -3,15 +3,15 @@\n export mk_pass;\n \n fn mk_pass() -> pass {\n-    sort_pass::mk_pass(\"sort_item_name\") { |item1, item2|\n+    sort_pass::mk_pass(\"sort_item_name\", { |item1, item2|\n         str::le(item1.name(), item2.name())\n-    }\n+    })\n }\n \n #[test]\n fn test() {\n     let source = \"mod z { } fn y() { }\";\n-    astsrv::from_str(source) {|srv|\n+    do astsrv::from_str(source) {|srv|\n         let doc = extract::from_srv(srv, \"\");\n         let doc = mk_pass().f(srv, doc);\n         assert doc.cratemod().items[0].name() == \"y\";"}, {"sha": "4509a1e996d7fb59de9791f1f490b9eebdbb68c4", "filename": "src/rustdoc/sort_item_type_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fsort_item_type_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fsort_item_type_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsort_item_type_pass.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -3,7 +3,7 @@\n export mk_pass;\n \n fn mk_pass() -> pass {\n-    sort_pass::mk_pass(\"sort_item_type\") { |item1, item2|\n+    do sort_pass::mk_pass(\"sort_item_type\") { |item1, item2|\n         fn score(item: doc::itemtag) -> int {\n             alt item {\n               doc::consttag(_) { 0 }\n@@ -32,7 +32,7 @@ fn test() {\n          iface iiface { fn a(); } \\\n          impl iimpl for int { fn a() { } } \\\n          type itype = int;\";\n-    astsrv::from_str(source) {|srv|\n+    do astsrv::from_str(source) {|srv|\n         let doc = extract::from_srv(srv, \"\");\n         let doc = mk_pass().f(srv, doc);\n         assert doc.cratemod().items[0].name() == \"iconst\";"}, {"sha": "838348dd99ba7ab8507af5342b35d5b2596e314a", "filename": "src/rustdoc/sort_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fsort_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Fsort_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsort_pass.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -47,7 +47,7 @@ fn test() {\n     }\n \n     let source = \"mod z { mod y { } fn x() { } } mod w { }\";\n-    astsrv::from_str(source) {|srv|\n+    do astsrv::from_str(source) {|srv|\n         let doc = extract::from_srv(srv, \"\");\n         let doc = mk_pass(\"\", name_lteq).f(srv, doc);\n         assert doc.cratemod().mods()[0].name() == \"w\";\n@@ -64,7 +64,7 @@ fn should_be_stable() {\n     }\n \n     let source = \"mod a { mod b { } } mod c { mod d { } }\";\n-    astsrv::from_str(source) {|srv|\n+    do astsrv::from_str(source) {|srv|\n         let doc = extract::from_srv(srv, \"\");\n         let doc = mk_pass(\"\", always_eq).f(srv, doc);\n         assert doc.cratemod().mods()[0].items[0].name() == \"b\";"}, {"sha": "bb750491947e6e01412b7d486e04d59b1b5f8f0f", "filename": "src/rustdoc/text_pass.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftext_pass.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -30,7 +30,7 @@ fn run(\n }\n \n fn maybe_apply_op(op: op, s: option<str>) -> option<str> {\n-    option::map(s) {|s| op(s) }\n+    option::map(s, {|s| op(s) })\n }\n \n fn fold_item(fold: fold::fold<op>, doc: doc::itemdoc) -> doc::itemdoc {\n@@ -45,19 +45,19 @@ fn fold_item(fold: fold::fold<op>, doc: doc::itemdoc) -> doc::itemdoc {\n }\n \n fn apply_to_sections(op: op, sections: ~[doc::section]) -> ~[doc::section] {\n-    par::anymap(sections) {|section, copy op|\n+    par::anymap(sections, {|section, copy op|\n         {\n             header: op(section.header),\n             body: op(section.body)\n         }\n-    }\n+    })\n }\n \n fn fold_enum(fold: fold::fold<op>, doc: doc::enumdoc) -> doc::enumdoc {\n     let doc = fold::default_seq_fold_enum(fold, doc);\n \n     {\n-        variants: par::anymap(doc.variants) {|variant, copy fold|\n+        variants: do par::anymap(doc.variants) {|variant, copy fold|\n             {\n                 desc: maybe_apply_op(fold.ctxt, variant.desc)\n                 with variant\n@@ -77,7 +77,7 @@ fn fold_iface(fold: fold::fold<op>, doc: doc::ifacedoc) -> doc::ifacedoc {\n }\n \n fn apply_to_methods(op: op, docs: ~[doc::methoddoc]) -> ~[doc::methoddoc] {\n-    par::anymap(docs) {|doc, copy op|\n+    do par::anymap(docs) {|doc, copy op|\n         {\n             brief: maybe_apply_op(op, doc.brief),\n             desc: maybe_apply_op(op, doc.desc),\n@@ -253,7 +253,7 @@ fn should_execute_on_impl_method_section_bodies() {\n #[cfg(test)]\n mod test {\n     fn mk_doc(source: str) -> doc::doc {\n-        astsrv::from_str(source) {|srv|\n+        do astsrv::from_str(source) {|srv|\n             let doc = extract::from_srv(srv, \"\");\n             let doc = attr_pass::mk_pass().f(srv, doc);\n             let doc = desc_to_brief_pass::mk_pass().f(srv, doc);"}, {"sha": "d9076516209b9f8ef3363f0751d6d825b9cd16ea", "filename": "src/rustdoc/trim_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Ftrim_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Ftrim_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftrim_pass.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -23,7 +23,7 @@ fn should_trim_text() {\n #[cfg(test)]\n mod test {\n     fn mk_doc(source: str) -> doc::doc {\n-        astsrv::from_str(source) {|srv|\n+        do astsrv::from_str(source) {|srv|\n             let doc = extract::from_srv(srv, \"\");\n             let doc = attr_pass::mk_pass().f(srv, doc);\n             mk_pass().f(srv, doc)"}, {"sha": "33410cca2996209625b6602ed652f59f3b3221e8", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -45,7 +45,7 @@ fn fold_fn(\n }\n \n fn get_fn_sig(srv: astsrv::srv, fn_id: doc::ast_id) -> option<str> {\n-    astsrv::exec(srv) {|ctxt|\n+    do astsrv::exec(srv) {|ctxt|\n         alt check ctxt.ast_map.get(fn_id) {\n           ast_map::node_item(@{\n             ident: ident,\n@@ -80,7 +80,7 @@ fn fold_const(\n     let srv = fold.ctxt;\n \n     {\n-        sig: some(astsrv::exec(srv) {|ctxt|\n+        sig: some(do astsrv::exec(srv) {|ctxt|\n             alt check ctxt.ast_map.get(doc.id()) {\n               ast_map::node_item(@{\n                 node: ast::item_const(ty, _), _\n@@ -107,14 +107,14 @@ fn fold_enum(\n     let srv = fold.ctxt;\n \n     {\n-        variants: par::anymap(doc.variants) {|variant|\n-            let sig = astsrv::exec(srv) {|ctxt|\n+        variants: do par::anymap(doc.variants) {|variant|\n+            let sig = do astsrv::exec(srv) {|ctxt|\n                 alt check ctxt.ast_map.get(doc_id) {\n                   ast_map::node_item(@{\n                     node: ast::item_enum(ast_variants, _, _), _\n                   }, _) {\n                     let ast_variant = option::get(\n-                        vec::find(ast_variants) {|v|\n+                        do vec::find(ast_variants) {|v|\n                             *v.node.name == variant.name\n                         });\n \n@@ -153,7 +153,7 @@ fn merge_methods(\n     item_id: doc::ast_id,\n     docs: ~[doc::methoddoc]\n ) -> ~[doc::methoddoc] {\n-    par::anymap(docs) {|doc|\n+    do par::anymap(docs) {|doc|\n         {\n             sig: get_method_sig(srv, item_id, doc.name)\n             with doc\n@@ -166,14 +166,14 @@ fn get_method_sig(\n     item_id: doc::ast_id,\n     method_name: str\n ) -> option<str> {\n-    astsrv::exec(srv) {|ctxt|\n+    do astsrv::exec(srv) {|ctxt|\n         alt check ctxt.ast_map.get(item_id) {\n           ast_map::node_item(@{\n             node: ast::item_iface(_, _, methods), _\n           }, _) {\n-            alt check vec::find(methods) {|method|\n+            alt check vec::find(methods, {|method|\n                 *method.ident == method_name\n-            } {\n+            }) {\n                 some(method) {\n                     some(pprust::fun_to_str(\n                         method.decl,\n@@ -186,9 +186,9 @@ fn get_method_sig(\n           ast_map::node_item(@{\n             node: ast::item_impl(_, _, _, _, methods), _\n           }, _) {\n-            alt check vec::find(methods) {|method|\n+            alt check vec::find(methods, {|method|\n                 *method.ident == method_name\n-            } {\n+            }) {\n                 some(method) {\n                     some(pprust::fun_to_str(\n                         method.decl,\n@@ -216,14 +216,14 @@ fn fold_impl(\n \n     let srv = fold.ctxt;\n \n-    let (iface_ty, self_ty) = astsrv::exec(srv) {|ctxt|\n+    let (iface_ty, self_ty) = do astsrv::exec(srv) {|ctxt|\n         alt ctxt.ast_map.get(doc.id()) {\n           ast_map::node_item(@{\n             node: ast::item_impl(_, _, iface_ty, self_ty, _), _\n           }, _) {\n-            let iface_ty = option::map(iface_ty) {|p|\n+            let iface_ty = option::map(iface_ty, {|p|\n                 pprust::path_to_str(p.path)\n-            };\n+            });\n             (iface_ty, some(pprust::ty_to_str(self_ty)))\n           }\n           _ { fail \"expected impl\" }\n@@ -271,7 +271,7 @@ fn fold_type(\n     let srv = fold.ctxt;\n \n     {\n-        sig: astsrv::exec(srv) {|ctxt|\n+        sig: do astsrv::exec(srv) {|ctxt|\n             alt ctxt.ast_map.get(doc.id()) {\n               ast_map::node_item(@{\n                 ident: ident,\n@@ -300,7 +300,7 @@ fn should_add_type_signatures() {\n #[cfg(test)]\n mod test {\n     fn mk_doc(source: str) -> doc::doc {\n-        astsrv::from_str(source) {|srv|\n+        do astsrv::from_str(source) {|srv|\n             let doc = extract::from_srv(srv, \"\");\n             run(srv, doc)\n         }"}, {"sha": "9e10637e8f20e046f0e9b71a976e8acf5f636c40", "filename": "src/rustdoc/unindent_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Frustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Funindent_pass.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -21,7 +21,7 @@ fn unindent(s: str) -> str {\n     let lines = str::lines_any(s);\n     let mut saw_first_line = false;\n     let mut saw_second_line = false;\n-    let min_indent = vec::foldl(uint::max_value, lines) {|min_indent, line|\n+    let min_indent = do vec::foldl(uint::max_value, lines) {|min_indent, line|\n \n         // After we see the first non-whitespace line, look at\n         // the line we have. If it is not whitespace, and therefore\n@@ -47,7 +47,7 @@ fn unindent(s: str) -> str {\n         } else {\n             saw_first_line = true;\n             let mut spaces = 0u;\n-            str::all(line) {|char|\n+            do str::all(line) {|char|\n                 // Only comparing against space because I wouldn't\n                 // know what to do with mixed whitespace chars\n                 if char == ' ' {\n@@ -63,7 +63,7 @@ fn unindent(s: str) -> str {\n \n     if check vec::is_not_empty(lines) {\n         let unindented = ~[str::trim(vec::head(lines))]\n-            + par::anymap(vec::tail(lines)) {|line|\n+            + do par::anymap(vec::tail(lines)) {|line|\n             if str::is_whitespace(line) {\n                 line\n             } else {"}, {"sha": "42e419e69ced62f523190c47c25d6cf088ab1fb3", "filename": "src/test/auxiliary/cci_capture_clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -5,7 +5,7 @@ import comm::*;\n fn foo<T: send copy>(x: T) -> port<T> {\n     let p = port();\n     let c = chan(p);\n-    task::spawn() {|copy c, copy x|\n+    do task::spawn() {|copy c, copy x|\n         c.send(x);\n     }\n     p"}, {"sha": "3574fc74c20c7181491eca0e123bad688c5d6c5e", "filename": "src/test/auxiliary/test_comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fauxiliary%2Ftest_comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fauxiliary%2Ftest_comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftest_comm.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -34,7 +34,7 @@ class port_ptr<T:send> {\n     self.po = po; }\n    drop unsafe {\n     #debug(\"in the port_ptr destructor\");\n-    task::unkillable {||\n+    do task::unkillable {||\n         let yield = 0u;\n         let yieldp = ptr::addr_of(yield);\n         rustrt::rust_port_begin_detach(self.po, yieldp);"}, {"sha": "218d05ec30ed6cd0d55934211f462d34d8da29b5", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -60,24 +60,24 @@ fn make_edges(scale: uint, edgefactor: uint) -> ~[(node_id, node_id)] {\n         }\n     }\n \n-    vec::from_fn((1u << scale) * edgefactor) {|_i|\n+    do vec::from_fn((1u << scale) * edgefactor) {|_i|\n         choose_edge(0i64, 0i64, scale, r)\n     }\n }\n \n fn make_graph(N: uint, edges: ~[(node_id, node_id)]) -> graph {\n-    let graph = vec::from_fn(N) {|_i| \n+    let graph = do vec::from_fn(N) {|_i| \n         map::hashmap::<node_id, ()>({|x| x as uint }, {|x, y| x == y })\n     };\n \n-    vec::each(edges) {|e| \n+    do vec::each(edges) {|e| \n         let (i, j) = e;\n         map::set_add(graph[i], j);\n         map::set_add(graph[j], i);\n         true\n     }\n \n-    graph.map() {|v|\n+    do graph.map() {|v|\n         map::vec_from_set(v)\n     }\n }\n@@ -89,9 +89,9 @@ fn gen_search_keys(graph: graph, n: uint) -> ~[node_id] {\n     while keys.size() < n {\n         let k = r.gen_uint_range(0u, graph.len());\n \n-        if graph[k].len() > 0u && vec::any(graph[k]) {|i|\n+        if graph[k].len() > 0u && vec::any(graph[k], {|i|\n             i != k as node_id\n-        } {\n+        }) {\n             map::set_add(keys, k as node_id);\n         }\n     }\n@@ -113,7 +113,7 @@ fn bfs(graph: graph, key: node_id) -> bfs_result {\n     while Q.size() > 0u {\n         let t = Q.pop_front();\n \n-        graph[t].each() {|k| \n+        do graph[t].each() {|k| \n             if marks[k] == -1i64 {\n                 marks[k] = t;\n                 Q.add_back(k);\n@@ -140,7 +140,7 @@ fn bfs2(graph: graph, key: node_id) -> bfs_result {\n         black(node_id)\n     };\n \n-    let mut colors = vec::from_fn(graph.len()) {|i|\n+    let mut colors = do vec::from_fn(graph.len()) {|i|\n         if i as node_id == key {\n             gray(key)\n         }\n@@ -161,7 +161,7 @@ fn bfs2(graph: graph, key: node_id) -> bfs_result {\n         // Do the BFS.\n         log(info, #fmt(\"PBFS iteration %?\", i));\n         i += 1u;\n-        colors = colors.mapi() {|i, c|\n+        colors = do colors.mapi() {|i, c|\n             let c : color = c;\n             alt c {\n               white {\n@@ -171,7 +171,7 @@ fn bfs2(graph: graph, key: node_id) -> bfs_result {\n                 \n                 let mut color = white;\n \n-                neighbors.each() {|k|\n+                do neighbors.each() {|k|\n                     if is_gray(colors[k]) {\n                         color = gray(k);\n                         false\n@@ -188,7 +188,7 @@ fn bfs2(graph: graph, key: node_id) -> bfs_result {\n     }\n \n     // Convert the results.\n-    vec::map(colors) {|c|\n+    do vec::map(colors) {|c|\n         alt c {\n           white { -1i64 }\n           black(parent) { parent }\n@@ -209,7 +209,7 @@ fn pbfs(&&graph: arc::arc<graph>, key: node_id) -> bfs_result {\n         black(node_id)\n     };\n \n-    let mut colors = vec::from_fn((*arc::get(&graph)).len()) {|i|\n+    let mut colors = do vec::from_fn((*arc::get(&graph)).len()) {|i|\n         if i as node_id == key {\n             gray(key)\n         }\n@@ -235,7 +235,7 @@ fn pbfs(&&graph: arc::arc<graph>, key: node_id) -> bfs_result {\n \n         let color = arc::arc(colors);\n \n-        colors = par::mapi_factory(*arc::get(&color)) {||\n+        colors = do par::mapi_factory(*arc::get(&color)) {||\n             let colors = arc::clone(&color);\n             let graph = arc::clone(&graph);\n             fn~(i: uint, c: color) -> color {\n@@ -250,7 +250,7 @@ fn pbfs(&&graph: arc::arc<graph>, key: node_id) -> bfs_result {\n                     \n                     let mut color = white;\n                     \n-                    neighbors.each() {|k|\n+                    do neighbors.each() {|k|\n                         if is_gray(colors[k]) {\n                             color = gray(k);\n                             false\n@@ -268,7 +268,7 @@ fn pbfs(&&graph: arc::arc<graph>, key: node_id) -> bfs_result {\n     }\n \n     // Convert the results.\n-    par::map(colors) {|c|\n+    do par::map(colors) {|c|\n         alt c {\n           white { -1i64 }\n           black(parent) { parent }\n@@ -291,7 +291,7 @@ fn validate(edges: ~[(node_id, node_id)],\n     log(info, \"Verifying tree structure...\");\n \n     let mut status = true;\n-    let level = tree.map() {|parent| \n+    let level = do tree.map() {|parent| \n         let mut parent = parent;\n         let mut path = ~[];\n \n@@ -322,7 +322,7 @@ fn validate(edges: ~[(node_id, node_id)],\n \n     log(info, \"Verifying tree edges...\");\n \n-    let status = tree.alli() {|k, parent|\n+    let status = do tree.alli() {|k, parent|\n         if parent != root && parent != -1i64 {\n             level[parent] == level[k] - 1\n         }\n@@ -338,7 +338,7 @@ fn validate(edges: ~[(node_id, node_id)],\n \n     log(info, \"Verifying graph edges...\");\n \n-    let status = edges.all() {|e| \n+    let status = do edges.all() {|e| \n         let (u, v) = e;\n \n         abs(level[u] - level[v]) <= 1\n@@ -355,7 +355,7 @@ fn validate(edges: ~[(node_id, node_id)],\n \n     log(info, \"Verifying tree and graph edges...\");\n \n-    let status = par::alli(tree) {|u, v|\n+    let status = do par::alli(tree) {|u, v|\n         let u = u as node_id;\n         if v == -1i64 || u == root {\n             true\n@@ -397,7 +397,7 @@ fn main(args: ~[str]) {\n     let stop = time::precise_time_s();\n \n     let mut total_edges = 0u;\n-    vec::each(graph) {|edges| total_edges += edges.len(); true };\n+    vec::each(graph, {|edges| total_edges += edges.len(); true });\n \n     io::stdout().write_line(#fmt(\"Generated graph with %? edges in %? seconds.\",\n                                  total_edges / 2u,\n@@ -408,7 +408,7 @@ fn main(args: ~[str]) {\n \n     let graph_arc = arc::arc(copy graph);\n \n-    gen_search_keys(graph, num_keys).map() {|root|\n+    do gen_search_keys(graph, num_keys).map() {|root|\n         io::stdout().write_line(\"\");\n         io::stdout().write_line(#fmt(\"Search key: %?\", root));\n "}, {"sha": "daf67a9dccd2e7b6a4b9a4d9d1090f7d225fe547", "filename": "src/test/bench/msgsend-ring-new.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fbench%2Fmsgsend-ring-new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fbench%2Fmsgsend-ring-new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-new.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -46,7 +46,7 @@ fn main(args: ~[str]) {\n         let get_chan_chan = chan(get_chan);\n         {\n             let num_chan = num_chan.clone();\n-            futures += ~[future::spawn {|move num_chan, move get_chan_chan|\n+            futures += ~[do future::spawn {|move num_chan, move get_chan_chan|\n                 let p = port();\n                 get_chan_chan.send(chan(p));\n                 thread_ring(i, msg_per_task, num_chan,  p)"}, {"sha": "d8bffab57d7b5618e582f8b7af8393b660d32fbe", "filename": "src/test/bench/msgsend-ring.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fbench%2Fmsgsend-ring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fbench%2Fmsgsend-ring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -45,7 +45,7 @@ fn main(args: ~[str]) {\n         let get_chan = port();\n         let get_chan_chan = chan(get_chan);\n \n-        futures += ~[future::spawn {|copy num_chan, move get_chan_chan|\n+        futures += ~[do future::spawn {|copy num_chan, move get_chan_chan|\n             let p = port();\n             get_chan_chan.send(chan(p));\n             thread_ring(i, msg_per_task, num_chan,  p)"}, {"sha": "e3546316a2ed6852547894cc92ad4e85014c5e7a", "filename": "src/test/bench/msgsend.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fbench%2Fmsgsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fbench%2Fmsgsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -30,7 +30,7 @@ fn server(requests: comm::port<request>, responses: comm::chan<uint>) {\n fn run(args: ~[str]) {\n     let from_child = comm::port();\n     let to_parent = comm::chan(from_child);\n-    let to_child = task::spawn_listener {|po|\n+    let to_child = do task::spawn_listener {|po|\n         server(po, to_parent);\n     };\n     let size = option::get(uint::from_str(args[1]));\n@@ -41,13 +41,13 @@ fn run(args: ~[str]) {\n     for uint::range(0u, workers) {|_i|\n         let builder = task::builder();\n         vec::push(worker_results, task::future_result(builder));\n-        task::run(builder) {||\n+        do task::run(builder) {||\n             for uint::range(0u, size / workers) {|_i|\n                 comm::send(to_child, bytes(100u));\n             }\n         };\n     }\n-    vec::iter(worker_results) {|r| future::get(r); }\n+    vec::iter(worker_results, {|r| future::get(r); });\n     comm::send(to_child, stop);\n     let result = comm::recv(from_child);\n     let end = std::time::precise_time_s();"}, {"sha": "5ab0477c0c57bd1047b33b999068e5a6d31bd491", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -142,7 +142,7 @@ fn main(args: ~[str]) {\n    let from_child = vec::map (sizes, { |_sz|     comm::port() });\n    let to_parent  = vec::mapi(sizes, { |ii, _sz| comm::chan(from_child[ii]) });\n    let to_child   = vec::mapi(sizes, fn@(ii: uint, sz: uint) -> comm::chan<~[u8]> {\n-      ret task::spawn_listener { |from_parent|\n+      ret do task::spawn_listener { |from_parent|\n          make_sequence_processor(sz, from_parent, to_parent[ii]);\n       };\n    });"}, {"sha": "e3c78856bc783429a4eccf636323b6f230006018", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -158,12 +158,12 @@ fn main(args: ~[str]) {\n \n     let writep = comm::port();\n     let writech = comm::chan(writep);\n-    task::spawn {||\n+    do task::spawn {||\n         writer(path, writech, size);\n     };\n     let ch = comm::recv(writep);\n     for uint::range(0_u, size) {|j|\n-        task::spawn {|| chanmb(j, size, ch);};\n+        do task::spawn {|| chanmb(j, size, ch);};\n         if j % yieldevery == 0_u {\n             #debug(\"Y %u\", j);\n             task::yield();"}, {"sha": "1045bafdb5cb229abddc74bcd4b0a7b63428a20e", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -32,15 +32,15 @@ fn fib(n: int) -> int {\n         } else {\n             let p = port();\n             let ch = chan(p);\n-            task::spawn {|| pfib(ch, n - 1); };\n-            task::spawn {|| pfib(ch, n - 2); };\n+            task::spawn({|| pfib(ch, n - 1); });\n+            task::spawn({|| pfib(ch, n - 2); });\n             send(c, recv(p) + recv(p));\n         }\n     }\n \n     let p = port();\n     let ch = chan(p);\n-    let t = task::spawn {|| pfib(ch, n); };\n+    let t = task::spawn({|| pfib(ch, n); });\n     ret recv(p);\n }\n \n@@ -73,7 +73,7 @@ fn stress(num_tasks: int) {\n     for range(0, num_tasks) {|i|\n         let builder = task::builder();\n         results += ~[task::future_result(builder)];\n-        task::run(builder) {|| stress_task(i); }\n+        task::run(builder, {|| stress_task(i); });\n     }\n     for results.each {|r| future::get(r); }\n }"}, {"sha": "b9bfc85ceed551c46ef45e1cf7caa118522aa6b4", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -10,7 +10,7 @@ fn start(+token: int) {\n     let mut ch = comm::chan(p);\n     for int::range(2, n_threads + 1) { |i|\n         let id = n_threads + 2 - i;\n-        let to_child = task::spawn_listener::<int> {|p, copy ch|\n+        let to_child = do task::spawn_listener::<int> {|p, copy ch|\n             roundtrip(id, p, ch)\n         };\n         ch = to_child;"}, {"sha": "24ab027ef007f5dacf218ac1b07bf05bd4f6f005", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -17,9 +17,9 @@ fn main() {\n }\n \n fn run(repeat: int, depth: int) {\n-    iter::repeat(repeat as uint) { ||\n+    do iter::repeat(repeat as uint) { ||\n         #debug(\"starting %.4f\", precise_time_s());\n-        task::try { ||\n+        do task::try { ||\n             recurse_or_fail(depth, none)\n         };\n         #debug(\"stopping %.4f\", precise_time_s());"}, {"sha": "cdb16bffd6b47c3fcf538e8c145b8a116c507993", "filename": "src/test/bench/task-perf-one-million.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -12,13 +12,13 @@ fn calc(children: uint, parent_ch: comm::chan<msg>) {\n     let mut child_chs = ~[];\n     let mut sum = 0;\n \n-    iter::repeat (children) {||\n-        task::spawn {||\n+    do iter::repeat (children) {||\n+        do task::spawn {||\n             calc(0u, chan);\n         };\n     }\n \n-    iter::repeat (children) {||\n+    do iter::repeat (children) {||\n         alt check comm::recv(port) {\n           ready(child_ch) {\n             vec::push(child_chs, child_ch);\n@@ -30,13 +30,13 @@ fn calc(children: uint, parent_ch: comm::chan<msg>) {\n \n     alt check comm::recv(port) {\n         start {\n-          vec::iter (child_chs) { |child_ch|\n+          do vec::iter (child_chs) { |child_ch|\n               comm::send(child_ch, start);\n           }\n         }\n     }\n \n-    iter::repeat (children) {||\n+    do iter::repeat (children) {||\n         alt check comm::recv(port) {\n           done(child_sum) { sum += child_sum; }\n         }\n@@ -57,7 +57,7 @@ fn main(args: ~[str]) {\n     let children = uint::from_str(args[1]).get();\n     let port = comm::port();\n     let chan = comm::chan(port);\n-    task::spawn {||\n+    do task::spawn {||\n         calc(children, chan);\n     };\n     alt check comm::recv(port) {"}, {"sha": "15cb3a98635fca75a946f2b1953c5f0799e2efac", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -1,7 +1,7 @@\n fn f(&&n: uint) {\n     let mut i = 0u;\n     while i < n {\n-        task::try {|| g() };\n+        do task::try {|| g() };\n         i += 1u;\n     }\n }\n@@ -18,5 +18,5 @@ fn main(args: ~[str]) {\n     };\n     let n = uint::from_str(args[1]).get();\n     let mut i = 0u;\n-    while i < n { task::spawn {|| f(n); }; i += 1u; }\n+    while i < n { task::spawn({|| f(n); }); i += 1u; }\n }"}, {"sha": "1068e48467a03c058cbeb31dbcfa147b46d03511", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -35,7 +35,7 @@ type joinable_task = port<()>;\n fn spawn_joinable(f: fn~()) -> joinable_task {\n     let p = port();\n     let c = chan(p);\n-    task::spawn() {||\n+    do task::spawn() {||\n         f();\n         c.send(());\n     }\n@@ -97,7 +97,7 @@ mod map_reduce {\n     {\n         let mut tasks = ~[];\n         for inputs.each {|i|\n-            tasks += ~[spawn_joinable {|| map_task(map, ctrl, i)}];\n+            tasks += ~[spawn_joinable({|| map_task(map, ctrl, i)})];\n         }\n         ret tasks;\n     }\n@@ -208,7 +208,7 @@ mod map_reduce {\n                     let ch = chan(p);\n                     let r = reduce, kk = k;\n                     tasks += ~[\n-                        spawn_joinable {|| reduce_task(r, kk, ch) }\n+                        spawn_joinable({|| reduce_task(r, kk, ch) })\n                     ];\n                     c = recv(p);\n                     treemap::insert(reducers, k, c);"}, {"sha": "17fb9dab88ea7b2d56b1b055d7efb45b0ba74097", "filename": "src/test/bench/task-perf-word-count.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -64,7 +64,7 @@ mod map_reduce {\n         for inputs.each {|i|\n             let builder = task::builder();\n             results += ~[task::future_result(builder)];\n-            task::run(builder) {|| map_task(ctrl, i)}\n+            do task::run(builder) {|| map_task(ctrl, i)}\n         }\n         ret results;\n     }\n@@ -162,7 +162,7 @@ mod map_reduce {\n                     let ch = chan(p);\n                     let builder = task::builder();\n                     results += ~[task::future_result(builder)];\n-                    task::run(builder) {||reduce_task(k, ch)}\n+                    task::run(builder, {||reduce_task(k, ch)});\n                     c = recv(p);\n                     reducers.insert(k, c);\n                   }"}, {"sha": "b7e570b1b08fd316f336de536b084eaeef1b7341", "filename": "src/test/compile-fail/block-arg-as-stmt-with-value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -2,7 +2,7 @@\n fn compute1() -> float {\n     let v = ~[0f, 1f, 2f, 3f];\n \n-    vec::foldl(0f, v) { |x, y| x + y } - 10f\n+    do vec::foldl(0f, v) { |x, y| x + y } - 10f\n     //!^ ERROR mismatched types: expected `()`\n }\n "}, {"sha": "c0fd5ae8e0525d724c4406253e93819a5e260e37", "filename": "src/test/compile-fail/borrowck-assign-comp-idx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -17,7 +17,7 @@ fn b() {\n \n     let mut p = ~[mut 1];\n \n-    borrow(p) {|| //! NOTE loan of mutable vec content granted here\n+    do borrow(p) {|| //! NOTE loan of mutable vec content granted here\n         p[0] = 5; //! ERROR assigning to mutable vec content prohibited due to outstanding loan\n     }\n }"}, {"sha": "663b6b2dd59aaf8151a9d5a1fa34cddb50e934ad", "filename": "src/test/compile-fail/borrowck-lend-flow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -76,7 +76,7 @@ fn at_most_once_block() {\n \n     let mut v = ~3, w = ~4;\n     let mut _x = &mut w;\n-    at_most_once {||\n+    do at_most_once {||\n         borrow(v); //! ERROR loan of mutable variable declared in an outer block as immutable conflicts with prior loan\n         _x = &mut v; //! NOTE prior loan as mutable granted here\n     }"}, {"sha": "35743c6f20064a2a8af57d98435118dcb84cb004", "filename": "src/test/compile-fail/borrowck-loan-blocks-move-cc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -5,7 +5,7 @@ fn borrow(v: &int, f: fn(x: &int)) {\n fn box_imm() {\n     let mut v = ~3;\n     let _w = &mut v; //! NOTE loan of mutable local variable granted here\n-    task::spawn { |move v|\n+    do task::spawn { |move v|\n         //!^ ERROR moving out of mutable local variable prohibited due to outstanding loan\n         #debug[\"v=%d\", *v];\n     }"}, {"sha": "387a5fb9fae2b1806b57bee2a1a0fe19c25d90aa", "filename": "src/test/compile-fail/borrowck-loan-blocks-mut-uniq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -4,7 +4,7 @@ fn borrow(v: &int, f: fn(x: &int)) {\n \n fn box_imm() {\n     let mut v = ~3;\n-    borrow(v) { |w| //! NOTE loan of mutable local variable granted here\n+    do borrow(v) { |w| //! NOTE loan of mutable local variable granted here\n         v = ~4; //! ERROR assigning to mutable variable declared in an outer block prohibited due to outstanding loan\n         assert *v == 3;\n         assert *w == 4;"}, {"sha": "e057f2f53b8049c8e244f60469ce4fc3f3bf9801", "filename": "src/test/compile-fail/borrowck-loan-rcvr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -19,7 +19,7 @@ fn a() {\n     p.impurem();\n \n     // But in this case we do not honor the loan:\n-    p.blockm {||  //! NOTE loan of mutable local variable granted here\n+    do p.blockm {||  //! NOTE loan of mutable local variable granted here\n         p.x = 10; //! ERROR assigning to mutable field prohibited due to outstanding loan\n     }\n }"}, {"sha": "7d5f1b4f3d6c90f64a438c1fb19f382964c72309", "filename": "src/test/compile-fail/borrowck-loan-vec-content.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -8,13 +8,13 @@ fn takes_imm_elt(_v: &int, f: fn()) {\n \n fn has_mut_vec_and_does_not_try_to_change_it() {\n     let v = ~[mut 1, 2, 3];\n-    takes_imm_elt(&v[0]) {||\n+    do takes_imm_elt(&v[0]) {||\n     }\n }\n \n fn has_mut_vec_but_tries_to_change_it() {\n     let v = ~[mut 1, 2, 3];\n-    takes_imm_elt(&v[0]) {|| //! NOTE loan of mutable vec content granted here\n+    do takes_imm_elt(&v[0]) {|| //! NOTE loan of mutable vec content granted here\n         v[1] = 4; //! ERROR assigning to mutable vec content prohibited due to outstanding loan\n     }\n }\n@@ -25,7 +25,7 @@ fn takes_const_elt(_v: &const int, f: fn()) {\n \n fn has_mut_vec_and_tries_to_change_it() {\n     let v = ~[mut 1, 2, 3];\n-    takes_const_elt(&const v[0]) {||\n+    do takes_const_elt(&const v[0]) {||\n         v[1] = 4;\n     }\n }"}, {"sha": "6012dd1ba2576209475ef11cb5a1c1d2fb5faa1a", "filename": "src/test/compile-fail/cap-clause-with-stack-closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fcap-clause-with-stack-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fcap-clause-with-stack-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcap-clause-with-stack-closure.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -3,12 +3,12 @@ fn bar(_f: @int) {}\n \n fn main() {\n     let x = @3;\n-    foo {|| bar(x); }\n+    foo({|| bar(x); });\n \n     let x = @3;\n-    foo {|copy x| bar(x); } //! ERROR cannot capture values explicitly with a block closure\n+    foo({|copy x| bar(x); }); //! ERROR cannot capture values explicitly with a block closure\n \n     let x = @3;\n-    foo {|move x| bar(x); } //! ERROR cannot capture values explicitly with a block closure\n+    foo({|move x| bar(x); }); //! ERROR cannot capture values explicitly with a block closure\n }\n "}, {"sha": "49ffcd86a5f59bc97a889bb485007361691ccbc8", "filename": "src/test/compile-fail/do1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fdo1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fdo1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdo1.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -1,3 +1,3 @@\n fn main() {\n-    let x = do y; //! ERROR: `do` must be followed by a block call\n+    let x = do y; //! ERROR: expecting '{' but found\n }"}, {"sha": "01fe95f87c0ccc87ff9bef0c608949553403c3df", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -7,5 +7,5 @@ impl monad<A> for ~[A] {\n    }\n }\n fn main() {\n-    [\"hi\"].bind {|x| [x] };\n+    [\"hi\"].bind({|x| [x] });\n }\n\\ No newline at end of file"}, {"sha": "44b0fe55ae49741e80ac0d9a6b4320eee439d223", "filename": "src/test/compile-fail/issue-2151.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fissue-2151.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fissue-2151.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2151.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n-    vec::iter(fail) {|i|\n+    do vec::iter(fail) {|i|\n         log (debug, i * 2);\n         //!^ ERROR the type of this value must be known\n    };"}, {"sha": "4f1e337ce481ff2864b08f1730c04309eaf9dbf3", "filename": "src/test/compile-fail/issue-2487-b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fissue-2487-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fissue-2487-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2487-b.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -6,7 +6,7 @@ class socket {\n     drop { }\n \n     fn set_identity()  {\n-      closure { ||\n+      do closure { ||\n         setsockopt_bytes(self.sock) //! ERROR copying a noncopyable value\n       } \n     }"}, {"sha": "cf22f3164eda7f91c372022bf74b9165c94f4ea5", "filename": "src/test/compile-fail/kindck-implicit-close-over-mut-var.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fkindck-implicit-close-over-mut-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fkindck-implicit-close-over-mut-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-implicit-close-over-mut-var.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -3,7 +3,7 @@ fn use(_i: int) {}\n fn foo() {\n     // Here, i is *moved* into the closure: Not actually OK\n     let mut i = 0;\n-    task::spawn {||\n+    do task::spawn {||\n         use(i); //! ERROR mutable variables cannot be implicitly captured\n     }\n }\n@@ -13,7 +13,7 @@ fn bar() {\n     // is mutable: bad\n     let mut i = 0;\n     while i < 10 {\n-        task::spawn {||\n+        do task::spawn {||\n             use(i); //! ERROR mutable variables cannot be implicitly captured\n         }\n         i += 1;\n@@ -24,7 +24,7 @@ fn car() {\n     // Here, i is mutable, but *explicitly* copied:\n     let mut i = 0;\n     while i < 10 {\n-        task::spawn {|copy i|\n+        do task::spawn {|copy i|\n             use(i);\n         }\n         i += 1;"}, {"sha": "30b6f85045eaa88023fc8ec0ac9230fec0215a3b", "filename": "src/test/compile-fail/liveness-issue-2163.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -1,5 +1,5 @@\n fn main(_s: ~[str]) {\n     let a: ~[int] = ~[];\n-    vec::each(a) { |_x| //! ERROR not all control paths return a value\n+    do vec::each(a) { |_x| //! ERROR not all control paths return a value\n     }\n }"}, {"sha": "e9cc27c59cec62582a5cddbb5166fc37f8c9dafe", "filename": "src/test/compile-fail/no-capture-arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -6,7 +6,7 @@ fn main() {\n     let v = ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n     let arc_v = arc::arc(v);\n     \n-    task::spawn() {||\n+    do task::spawn() {||\n         let v = *arc::get(&arc_v);\n         assert v[3] == 4;\n     };"}, {"sha": "a4882f05b0b3cf2b71e6b639e603cec0ff77a147", "filename": "src/test/compile-fail/no-reuse-move-arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -4,7 +4,7 @@ fn main() {\n     let v = ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n     let arc_v = arc::arc(v);\n \n-    task::spawn() {|move arc_v| //! NOTE move of variable occurred here\n+    do task::spawn() {|move arc_v| //! NOTE move of variable occurred here\n         let v = *arc::get(&arc_v);\n         assert v[3] == 4;\n     };"}, {"sha": "4b060c7a5931520dafa29bbf58cd1c1e9b75ae8c", "filename": "src/test/compile-fail/no-send-res-ports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -7,7 +7,7 @@ fn main() {\n    \n     let x = ~mut some(foo(comm::port()));\n \n-    task::spawn {|move x| //! ERROR not a sendable value\n+    do task::spawn {|move x| //! ERROR not a sendable value\n         let mut y = none;\n         *x <-> y;\n         log(error, y);"}, {"sha": "9b79840b5edb82636fac68f449d9393005a88788", "filename": "src/test/compile-fail/private-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fprivate-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fprivate-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-method.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -2,7 +2,7 @@\n class cat {\n   priv {\n     let mut meows : uint;\n-    fn nap() { uint::range(1u, 10000u) {|_i|}}\n+    fn nap() { uint::range(1u, 10000u, {|_i|})}\n   }\n \n   let how_hungry : int;"}, {"sha": "8dba6b695c9824a574508d9d233792da08be2df5", "filename": "src/test/compile-fail/pure-higher-order.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fpure-higher-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fpure-higher-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpure-higher-order.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -9,7 +9,7 @@ pure fn range(from: uint, to: uint, f: fn(uint)) {\n }\n \n pure fn range2(from: uint, to: uint, f: fn(uint)) {\n-    range(from, to) { |i|\n+    do range(from, to) { |i|\n         f(i*2u);\n     }\n }\n@@ -31,7 +31,7 @@ pure fn range6(from: uint, to: uint, x: @{f: fn(uint)}) {\n }\n \n pure fn range7(from: uint, to: uint) {\n-    range(from, to) { |i|\n+    do range(from, to) { |i|\n         print(i); //! ERROR access to impure function prohibited in pure context\n     }\n }"}, {"sha": "5c538481b0f5d696eb1ab8977221fd79917abb0a", "filename": "src/test/compile-fail/regions-addr-of-upvar-self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-upvar-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-upvar-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-upvar-self.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -6,7 +6,7 @@ class dog {\n     }\n \n     fn chase_cat() {\n-        uint::range(0u, 10u) { |i|\n+        do uint::range(0u, 10u) { |i|\n             let p: &static.mut uint = &mut self.food; //! ERROR mismatched types\n             *p = 3u;\n         }"}, {"sha": "d6d39041671a77eca0bb8908644c76648609fea8", "filename": "src/test/compile-fail/regions-escape-loop-via-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-vec.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -8,7 +8,7 @@ fn broken() -> int {\n         y += ~[&mut z];\n         x += 1;\n     }\n-    vec::foldl(0, y) {|v, p| v + *p }\n+    vec::foldl(0, y, {|v, p| v + *p })\n     //!^ ERROR reference is not valid\n     //!^^ ERROR reference is not valid\n     //!^^^ ERROR reference is not valid"}, {"sha": "25bd6611d4046959d273884e31575ae9ab34222e", "filename": "src/test/compile-fail/regions-scoping.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fregions-scoping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fregions-scoping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-scoping.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -1,7 +1,7 @@\n fn with<T>(t: T, f: fn(T)) { f(t) }\n \n fn nested(x: &x.int) {  // (1)\n-    with(\n+    do with(\n         fn&(x: &x.int, // Refers to the region `x` at (1)\n             y: &y.int, // A fresh region `y` (2)\n             z: fn(x: &x.int, // Refers to `x` at (1)\n@@ -26,17 +26,17 @@ fn nested(x: &x.int) {  // (1)\n         }\n     ) {|foo|\n \n-        let a: &x.int = foo(x, x) { |_x, _y, z| z };\n-        let b: &x.int = foo(x, a) { |_x, _y, z| z };\n-        let c: &x.int = foo(a, a) { |_x, _y, z| z };\n+        let a: &x.int = foo(x, x, { |_x, _y, z| z });\n+        let b: &x.int = foo(x, a, { |_x, _y, z| z });\n+        let c: &x.int = foo(a, a, { |_x, _y, z| z });\n \n         let z = 3i;\n-        let d: &x.int = foo(x, x) { |_x, _y, z| z };\n-        let e: &x.int = foo(x, &z) { |_x, _y, z| z };\n-        let f: &x.int = foo(&z, &z) { |_x, _y, z| z }; //! ERROR mismatched types: expected `&x.int` but found\n+        let d: &x.int = foo(x, x, { |_x, _y, z| z });\n+        let e: &x.int = foo(x, &z, { |_x, _y, z| z });\n+        let f: &x.int = foo(&z, &z, { |_x, _y, z| z }); //! ERROR mismatched types: expected `&x.int` but found\n \n-        foo(x, &z) { |x, _y, _z| x }; //! ERROR mismatched types: expected `&z.int` but found `&x.int`\n-        foo(x, &z) { |_x, y, _z| y }; //! ERROR mismatched types: expected `&z.int` but found `&<block at\n+        foo(x, &z, { |x, _y, _z| x }); //! ERROR mismatched types: expected `&z.int` but found `&x.int`\n+        foo(x, &z, { |_x, y, _z| y }); //! ERROR mismatched types: expected `&z.int` but found `&<block at\n     }\n }\n "}, {"sha": "cad55808577bb5985b91425f326409c527db29f7", "filename": "src/test/compile-fail/vec-concat-bug.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -2,10 +2,10 @@ fn concat<T: copy>(v: ~[const ~[const T]]) -> ~[T] {\n     let mut r = ~[];\n \n     // Earlier versions of our type checker accepted this:\n-    vec::iter(v) {|&&inner: ~[T]|\n+    vec::iter(v, {|&&inner: ~[T]|\n         //!^ ERROR values differ in mutability\n         r += inner;\n-    }\n+    });\n \n     ret r;\n }"}, {"sha": "d70f4fdfa4a0dc9aac149806462635eb90b3dea3", "filename": "src/test/pretty/block-arg-disambig.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fpretty%2Fblock-arg-disambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fpretty%2Fblock-arg-disambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblock-arg-disambig.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -1,2 +1,2 @@\n fn blk1(b: fn()) -> fn@() { ret fn@() { }; }\n-fn test1() { (blk1 {|| #debug[\"hi\"]; })(); }\n+fn test1() { (do blk1 {|| #debug[\"hi\"]; })(); }"}, {"sha": "f48fef31b338841ef1aa639704dec0991fe47761", "filename": "src/test/pretty/disamb-stmt-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fpretty%2Fdisamb-stmt-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Fpretty%2Fdisamb-stmt-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fdisamb-stmt-expr.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -6,5 +6,5 @@\n \n fn id(f: fn() -> int) -> int { f() }\n \n-fn wsucc(n: int) -> int { (id {|| 1 }) - 0 }\n+fn wsucc(n: int) -> int { (do id {|| 1 }) - 0 }\n fn main() { }"}, {"sha": "7d0f5c0a39113cb5098f5467a1edaf708e0fb20d", "filename": "src/test/run-fail/bug-2470-bounds-check-overflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -9,7 +9,7 @@ fn main() {\n     // huge).\n \n     let x = ~[1u,2u,3u];\n-    vec::unpack_slice(x) {|p, _len|\n+    do vec::unpack_slice(x) {|p, _len|\n         let base = p as uint;                     // base = 0x1230 say\n         let idx = base / sys::size_of::<uint>();  // idx  = 0x0246 say\n         #error(\"ov1 base = 0x%x\", base);"}, {"sha": "015e609af0defc9b4f057c836cfa4705ff70a839", "filename": "src/test/run-fail/crust-fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Fcrust-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Fcrust-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fcrust-fail.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -21,8 +21,8 @@ fn count(n: uint) -> uint {\n }\n \n fn main() {\n-    iter::repeat(10u) {||\n-        task::spawn {||\n+    do iter::repeat(10u) {||\n+        do task::spawn {||\n             let result = count(5u);\n             #debug(\"result = %?\", result);\n             fail;"}, {"sha": "3f301d9800726bac5cd324848ac0b4ae0d1630df", "filename": "src/test/run-fail/for-each-loop-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Ffor-each-loop-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Ffor-each-loop-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffor-each-loop-fail.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -1,4 +1,4 @@\n // error-pattern:moop\n use std;\n import uint;\n-fn main() { uint::range(0u, 10u) {|_i| fail \"moop\"; } }\n+fn main() { uint::range(0u, 10u, {|_i| fail \"moop\"; }); }"}, {"sha": "6784d4e52b69e8f94c6808ad090ebb9161c7377d", "filename": "src/test/run-fail/issue-2156.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Fissue-2156.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Fissue-2156.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-2156.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -4,7 +4,7 @@ use std;\n import io::{reader, reader_util};\n \n fn main() {\n-    io::with_str_reader(\"\") { |rdr|\n+    do io::with_str_reader(\"\") { |rdr|\n         alt rdr.read_char() { '=' { } _ { fail } }\n     }\n }"}, {"sha": "89e0f566244e84d21e06db8301a9562bc31f3886", "filename": "src/test/run-fail/linked-failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Flinked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Flinked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -10,6 +10,6 @@ fn child() { assert (1 == 2); }\n \n fn main() {\n     let p = port::<int>();\n-    task::spawn {|| child(); };\n+    task::spawn({|| child(); });\n     let x = recv(p);\n }"}, {"sha": "6f8c480b44ef88f98ac32319d370e153d8695f8a", "filename": "src/test/run-fail/linked-failure2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Flinked-failure2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Flinked-failure2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure2.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -11,6 +11,6 @@ fn child() { fail; }\n \n fn main() {\n     let p = port::<int>();\n-    task::spawn {|| child(); };\n+    task::spawn({|| child(); });\n     task::yield();\n }"}, {"sha": "e050dac28ed34d12cf17b41eebef865aba1e1cf9", "filename": "src/test/run-fail/linked-failure3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Flinked-failure3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Flinked-failure3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure3.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -10,12 +10,12 @@ fn grandchild() { fail \"grandchild dies\"; }\n \n fn child() {\n     let p = port::<int>();\n-    task::spawn {|| grandchild(); };\n+    task::spawn({|| grandchild(); });\n     let x = recv(p);\n }\n \n fn main() {\n     let p = port::<int>();\n-    task::spawn {|| child(); };\n+    task::spawn({|| child(); });\n     let x = recv(p);\n }"}, {"sha": "d80669a1e6ffeb62e21a90a11f812f71a203b800", "filename": "src/test/run-fail/linked-failure4.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Flinked-failure4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Flinked-failure4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure4.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -10,7 +10,7 @@ fn child() { assert (1 == 2); }\n \n fn parent() {\n     let p = port::<int>();\n-    task::spawn {|| child(); };\n+    task::spawn({|| child(); });\n     let x = recv(p);\n }\n \n@@ -22,6 +22,6 @@ fn sleeper() {\n }\n \n fn main() {\n-    task::spawn {|| sleeper(); };\n-    task::spawn {|| parent(); };\n+    task::spawn({|| sleeper(); });\n+    task::spawn({|| parent(); });\n }\n\\ No newline at end of file"}, {"sha": "1d9419ccae353df18c16e0a9bdb761ee9f678f19", "filename": "src/test/run-fail/morestack2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Fmorestack2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Fmorestack2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmorestack2.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -34,7 +34,7 @@ class and_then_get_big_again {\n }\n \n fn main() {\n-    task::spawn {||\n+    do task::spawn {||\n         let r = and_then_get_big_again(4);\n         getbig_call_c_and_fail(10000);\n     };"}, {"sha": "cfae8dc9182e2d87d5123e97d07e226ac44476c1", "filename": "src/test/run-fail/morestack3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Fmorestack3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Fmorestack3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmorestack3.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -27,7 +27,7 @@ class and_then_get_big_again {\n }\n \n fn main() {\n-    task::spawn {||\n+    do task::spawn {||\n         getbig_and_fail(400);\n     };\n }\n\\ No newline at end of file"}, {"sha": "c3deca6f080935ae56f2001c4321347243dbcb1f", "filename": "src/test/run-fail/morestack4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Fmorestack4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Fmorestack4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmorestack4.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -20,7 +20,7 @@ class and_then_get_big_again {\n }\n \n fn main() {\n-    task::spawn {||\n+    do task::spawn {||\n         getbig_and_fail(1);\n     };\n }\n\\ No newline at end of file"}, {"sha": "30fcfdc5977a3600a90d40dd55464f11a25040e8", "filename": "src/test/run-fail/rt-set-exit-status-fail2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Frt-set-exit-status-fail2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Frt-set-exit-status-fail2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frt-set-exit-status-fail2.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -13,7 +13,7 @@ class r {\n \n fn main() {\n     log(error, \"whatever\");\n-    task::spawn {||\n+    do task::spawn {||\n       let i = r(5);\n     };\n     fail;"}, {"sha": "96f0c12c760f66d335b513e455b8810c405a2000", "filename": "src/test/run-fail/small-negative-indexing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Fsmall-negative-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Fsmall-negative-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fsmall-negative-indexing.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -1,6 +1,6 @@\n // error-pattern:bounds check\n fn main() {\n-    let v = vec::from_fn(1024u) {|n| n};\n+    let v = vec::from_fn(1024u, {|n| n});\n     // this should trip a bounds check\n     log(error, v[-1i8]);\n }"}, {"sha": "896cf7902b288b3760f13cda402aca54f1c8133f", "filename": "src/test/run-fail/spawnfail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Fspawnfail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Fspawnfail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fspawnfail.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -8,5 +8,5 @@ fn main() {\n     fn f() {\n         fail;\n     }\n-    task::spawn {|| f(); };\n+    task::spawn({|| f(); });\n }\n\\ No newline at end of file"}, {"sha": "fcfc2046d9df3e0ab0843fa3072974e4bf8460f3", "filename": "src/test/run-fail/task-comm-recv-block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Ftask-comm-recv-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Ftask-comm-recv-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftask-comm-recv-block.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -10,7 +10,7 @@ fn goodfail() {\n }\n \n fn main() {\n-    task::spawn {|| goodfail(); };\n+    task::spawn({|| goodfail(); });\n     let po = comm::port();\n     // We shouldn't be able to get past this recv since there's no\n     // message available"}, {"sha": "5c504c8ba5982332e3b6ad2c154c0f0b75534097", "filename": "src/test/run-fail/unwind-iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Funwind-iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Funwind-iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-iter.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -7,5 +7,5 @@ fn x(it: fn(int)) {\n \n fn main() {\n     let a = @0;\n-    x {|_i|};\n+    x({|_i|});\n }\n\\ No newline at end of file"}, {"sha": "1bf4cbbc109b34c4a4b60fc84eb0d384b0ba3c21", "filename": "src/test/run-fail/unwind-iter2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Funwind-iter2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-fail%2Funwind-iter2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-iter2.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -6,5 +6,5 @@ fn x(it: fn(int)) {\n }\n \n fn main() {\n-    x {|_x| fail; };\n+    x({|_x| fail; });\n }\n\\ No newline at end of file"}, {"sha": "ee28c18e6da3d8a09659ac904e0038a3c2bcda33", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -79,8 +79,8 @@ fn main() {\n     // issue #1926\n     let s = #ast(expr){__s};\n     let e = #ast(expr){__e};\n-    let call = #ast(expr){$(s).foo {|__e| $(e)}};\n-    check_pp(call, pprust::print_expr, \"__s.foo {|__e| __e }\")\n+    let call = #ast(expr){$(s).foo({|__e| $(e)})};\n+    check_pp(call, pprust::print_expr, \"__s.foo({|__e| __e })\")\n }\n \n fn check_pp<T>(expr: T, f: fn(pprust::ps, T), expect: str) {"}, {"sha": "2a995e4b47fa25fb2c67a954e1e7912ea26a4d42", "filename": "src/test/run-pass/alt-phi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Falt-phi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Falt-phi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-phi.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -7,7 +7,7 @@ fn foo(it: fn(int)) { it(10); }\n fn main() {\n     let mut x = true;\n     alt a {\n-      a { x = true; foo {|_i|} }\n+      a { x = true; foo({|_i|}) }\n       b { x = false; }\n       c { x = false; }\n     }"}, {"sha": "1fe8dc77ac63e123a2b3d52405bbe95750953ab8", "filename": "src/test/run-pass/auto_serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -18,7 +18,7 @@ fn test_ser_and_deser<A>(a1: A,\n \n     // check the pretty printer:\n     io_ser_fn(io::stdout(), a1);\n-    let s = io::with_str_writer {|w| io_ser_fn(w, a1) };\n+    let s = io::with_str_writer({|w| io_ser_fn(w, a1) });\n     #debug[\"s == %?\", s];\n     assert s == expected;\n "}, {"sha": "a361f98040871597f2d8f474e46d3df83b04b56d", "filename": "src/test/run-pass/basic-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fbasic-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fbasic-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic-1.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -12,8 +12,8 @@ fn a(c: chan<int>) { send(c, 10); }\n fn main() {\n     let p = port();\n     let ch = chan(p);\n-    task::spawn {|| a(ch); };\n-    task::spawn {|| a(ch); };\n+    task::spawn({|| a(ch); });\n+    task::spawn({|| a(ch); });\n     let mut n: int = 0;\n     n = recv(p);\n     n = recv(p);"}, {"sha": "51653c5514e36b1efcd77191dbd0a1338585db3f", "filename": "src/test/run-pass/basic-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fbasic-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fbasic-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic-2.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -13,8 +13,8 @@ fn a(c: chan<int>) { #debug(\"task a0\"); #debug(\"task a1\"); send(c, 10); }\n fn main() {\n     let p = port();\n     let ch = chan(p);\n-    task::spawn {|| a(ch); };\n-    task::spawn {|| b(ch); };\n+    task::spawn({|| a(ch); });\n+    task::spawn({|| b(ch); });\n     let mut n: int = 0;\n     n = recv(p);\n     n = recv(p);"}, {"sha": "54bc671dbff28f7eff1c237b0df43a3e8487c277", "filename": "src/test/run-pass/basic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -32,8 +32,8 @@ fn main() {\n     let s: str = \"hello there\";\n     let p = comm::port();\n     let ch = comm::chan(p);\n-    task::spawn {|| a(ch); };\n-    task::spawn {|| b(ch); };\n+    task::spawn({|| a(ch); });\n+    task::spawn({|| b(ch); });\n     let mut x: int = 10;\n     x = g(n, s);\n     log(debug, x);"}, {"sha": "7ba4698016bb58f9839e277518339e298f1258cc", "filename": "src/test/run-pass/block-arg-can-be-followed-by-binop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -2,7 +2,7 @@ fn main() {\n     let v = ~[-1f, 0f, 1f, 2f, 3f];\n \n     // Trailing expressions require parentheses:\n-    let y = vec::foldl(0f, v) { |x, y| x + y } + 10f;\n+    let y = vec::foldl(0f, v, { |x, y| x + y }) + 10f;\n \n     assert y == 15f;\n }"}, {"sha": "65d03610aeb9723a50ad2f5774b0e8107ed05481", "filename": "src/test/run-pass/block-arg-can-be-followed-by-block-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -1,6 +1,6 @@\n fn main() {\n     fn f(i: fn() -> uint) -> uint { i() }\n     let v = ~[-1f, 0f, 1f, 2f, 3f];\n-    let z = vec::foldl(f, v) { |x, _y| x } { || 22u };\n+    let z = do do vec::foldl(f, v) { |x, _y| x } { || 22u };\n     assert z == 22u;\n }"}, {"sha": "d77b1bf0e0c13d72a80d584f813f448567d44f6a", "filename": "src/test/run-pass/block-arg-can-be-followed-by-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -1,6 +1,6 @@\n fn main() {\n     fn f(i: uint) -> uint { i }\n     let v = ~[-1f, 0f, 1f, 2f, 3f];\n-    let z = vec::foldl(f, v) { |x, _y| x } (22u);\n+    let z = do vec::foldl(f, v) { |x, _y| x } (22u);\n     assert z == 22u;\n }"}, {"sha": "701acd23bd2e048727dc843cfe5f0fc698bd8924", "filename": "src/test/run-pass/block-arg-in-parentheses.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -1,20 +1,20 @@\n fn w_semi(v: ~[int]) -> int {\n     // the semicolon causes compiler not to\n     // complain about the ignored return value:\n-    vec::foldl(0, v) {|x,y| x+y};\n+    do vec::foldl(0, v) {|x,y| x+y};\n     -10\n }\n \n fn w_paren1(v: ~[int]) -> int {\n-    (vec::foldl(0, v) {|x,y| x+y}) - 10\n+    (do vec::foldl(0, v) {|x,y| x+y}) - 10\n }\n \n fn w_paren2(v: ~[int]) -> int {\n-    (vec::foldl(0, v) {|x,y| x+y} - 10)\n+    (do vec::foldl(0, v) {|x,y| x+y} - 10)\n }\n \n fn w_ret(v: ~[int]) -> int {\n-    ret vec::foldl(0, v) {|x,y| x+y} - 10;\n+    ret do vec::foldl(0, v) {|x,y| x+y} - 10;\n }\n \n fn main() {"}, {"sha": "fbf60b6ffb39915381b5fb10b9b0c2d721418b9b", "filename": "src/test/run-pass/block-arg-used-as-any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-any.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-any.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-any.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -3,6 +3,6 @@ fn call_any(f: fn() -> uint) -> uint {\n }\n \n fn main() {\n-    let x_r = call_any {|| 22u };\n+    let x_r = do call_any {|| 22u };\n     assert x_r == 22u;\n }"}, {"sha": "14794df5190878c82894ed8c6b2ec7c0d92ba861", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -3,33 +3,33 @@ fn main() {\n     let v = ~[-1f, 0f, 1f, 2f, 3f];\n \n     // Statement form does not require parentheses:\n-    vec::iter(v) { |i|\n+    vec::iter(v, { |i|\n         log(info, i);\n-    }\n+    });\n \n     // Usable at all:\n-    let mut any_negative = vec::any(v) { |e| float::is_negative(e) };\n+    let mut any_negative = vec::any(v, { |e| float::is_negative(e) });\n     assert any_negative;\n \n     // Higher precedence than assignments:\n-    any_negative = vec::any(v) { |e| float::is_negative(e) };\n+    any_negative = vec::any(v, { |e| float::is_negative(e) });\n     assert any_negative;\n \n     // Higher precedence than unary operations:\n-    let abs_v = vec::map(v) { |e| float::abs(e) };\n-    assert vec::all(abs_v) { |e| float::is_nonnegative(e) };\n-    assert !vec::any(abs_v) { |e| float::is_negative(e) };\n+    let abs_v = vec::map(v, { |e| float::abs(e) });\n+    assert vec::all(abs_v, { |e| float::is_nonnegative(e) });\n+    assert !vec::any(abs_v, { |e| float::is_negative(e) });\n \n     // Usable in funny statement-like forms:\n-    if !vec::any(v) { |e| float::is_positive(e) } {\n+    if !vec::any(v, { |e| float::is_positive(e) }) {\n         assert false;\n     }\n-    alt vec::all(v) { |e| float::is_negative(e) } {\n+    alt vec::all(v, { |e| float::is_negative(e) }) {\n         true { fail \"incorrect answer.\"; }\n         false { }\n     }\n     alt 3 {\n-      _ if vec::any(v) { |e| float::is_negative(e) } {\n+      _ if vec::any(v, { |e| float::is_negative(e) }) {\n       }\n       _ {\n         fail \"wrong answer.\";\n@@ -39,8 +39,8 @@ fn main() {\n \n     // Lower precedence than binary operations:\n     let w = vec::foldl(0f, v, { |x, y| x + y }) + 10f;\n-    let y = vec::foldl(0f, v) { |x, y| x + y } + 10f;\n-    let z = 10f + vec::foldl(0f, v) { |x, y| x + y };\n+    let y = vec::foldl(0f, v, { |x, y| x + y }) + 10f;\n+    let z = 10f + vec::foldl(0f, v, { |x, y| x + y });\n     assert w == y;\n     assert y == z;\n "}, {"sha": "e7606a39304d77394d6d5fac72486f670662c891", "filename": "src/test/run-pass/borrowck-borrow-from-expr-block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -4,7 +4,7 @@ fn borrow(x: &int, f: fn(x: &int)) {\n \n fn test1(x: @~int) {\n     // Right now, at least, this induces a copy of the unique pointer:\n-    borrow({*x}) { |p|\n+    do borrow({*x}) { |p|\n         let x_a = ptr::addr_of(**x);\n         assert (x_a as uint) != (p as uint);\n         assert unsafe{*x_a} == *p;"}, {"sha": "f2517d17694cdd174472f95ca155070b4ebb1da7", "filename": "src/test/run-pass/borrowck-preserve-box-in-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -9,7 +9,7 @@ fn borrow(x: &int, f: fn(x: &int)) {\n \n fn main() {\n     let mut x = @{f: ~3};\n-    borrow(x.f) {|b_x|\n+    do borrow(x.f) {|b_x|\n         assert *b_x == 3;\n         assert ptr::addr_of(*x.f) == ptr::addr_of(*b_x);\n         x = @{f: ~4};"}, {"sha": "431e456575b9c9b34b346a2a70ce8db57a366e99", "filename": "src/test/run-pass/borrowck-preserve-box-in-uniq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -9,7 +9,7 @@ fn borrow(x: &int, f: fn(x: &int)) {\n \n fn main() {\n     let mut x = ~mut @{f: ~3};\n-    borrow(x.f) {|b_x|\n+    do borrow(x.f) {|b_x|\n         assert *b_x == 3;\n         assert ptr::addr_of(*x.f) == ptr::addr_of(*b_x);\n         *x = @{f: ~4};"}, {"sha": "2a2edbac2598607eeb49e641d7323a80b602e55b", "filename": "src/test/run-pass/borrowck-preserve-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -9,7 +9,7 @@ fn borrow(x: &int, f: fn(x: &int)) {\n \n fn main() {\n     let mut x = @3;\n-    borrow(x) {|b_x|\n+    do borrow(x) {|b_x|\n         assert *b_x == 3;\n         assert ptr::addr_of(*x) == ptr::addr_of(*b_x);\n         x = @22;"}, {"sha": "80f009e525d1519ba70dcdf2b133ee3f731d826c", "filename": "src/test/run-pass/borrowck-preserve-expl-deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -9,7 +9,7 @@ fn borrow(x: &int, f: fn(x: &int)) {\n \n fn main() {\n     let mut x = @{f: ~3};\n-    borrow((*x).f) {|b_x|\n+    do borrow((*x).f) {|b_x|\n         assert *b_x == 3;\n         assert ptr::addr_of(*x.f) == ptr::addr_of(*b_x);\n         x = @{f: ~4};"}, {"sha": "6a62f11160920642ef917e03a73bcb069d0c9b16", "filename": "src/test/run-pass/cci_impl_exe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fcci_impl_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fcci_impl_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_impl_exe.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -8,7 +8,7 @@ fn main() {\n     //let bt0 = sys::frame_address();\n     //#debug[\"%?\", bt0];\n \n-    3u.to(10u) {|i|\n+    do 3u.to(10u) {|i|\n         io::print(#fmt[\"%u\\n\", i]);\n \n         //let bt1 = sys::frame_address();"}, {"sha": "84ca70155833a2cc4758c3070267e845465b3bc2", "filename": "src/test/run-pass/cci_iter_exe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fcci_iter_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fcci_iter_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_iter_exe.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -6,7 +6,7 @@ use cci_iter_lib;\n fn main() {\n     //let bt0 = sys::rusti::frame_address(1u32);\n     //#debug[\"%?\", bt0];\n-    cci_iter_lib::iter(~[1, 2, 3]) {|i|\n+    do cci_iter_lib::iter(~[1, 2, 3]) {|i|\n         io::print(#fmt[\"%d\", i]);\n         //assert bt0 == sys::rusti::frame_address(2u32);\n     }"}, {"sha": "ddd70ff7960adf5847fd2e8e538f5831678bfd04", "filename": "src/test/run-pass/cci_no_inline_exe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fcci_no_inline_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fcci_no_inline_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_no_inline_exe.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -12,7 +12,7 @@ fn main() {\n     // actually working.\n     //let bt0 = sys::frame_address();\n     //#debug[\"%?\", bt0];\n-    iter(~[1u, 2u, 3u]) {|i|\n+    do iter(~[1u, 2u, 3u]) {|i|\n         io::print(#fmt[\"%u\\n\", i]);\n \n         //let bt1 = sys::frame_address();"}, {"sha": "eebc93fd5140340235bfee3c6a70a73b3875bcec", "filename": "src/test/run-pass/chan-leak.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fchan-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fchan-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchan-leak.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -24,7 +24,7 @@ fn request_task(c: chan<ctx>) {\n fn new_cx() -> ctx {\n     let p = port();\n     let ch = chan(p);\n-    let t = task::spawn {|| request_task(ch); };\n+    let t = task::spawn({|| request_task(ch); });\n     let mut cx: ctx;\n     cx = recv(p);\n     ret cx;"}, {"sha": "97a53856ec7354daaa692f76a56f9ae6bb060216", "filename": "src/test/run-pass/child-outlives-parent.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -5,4 +5,4 @@ import task;\n \n fn child2(&&s: str) { }\n \n-fn main() { let x = task::spawn {|| child2(\"hi\"); }; }\n+fn main() { let x = task::spawn({|| child2(\"hi\"); }); }"}, {"sha": "5613517102e3fa087f199d3a28ae57d33d7cecb2", "filename": "src/test/run-pass/class-iface-bounded-param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fclass-iface-bounded-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fclass-iface-bounded-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-iface-bounded-param.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -10,7 +10,7 @@ class keys<K: copy, V: copy, M: copy map<K,V>>\n         self.map = map;\n     }\n \n-    fn each(blk: fn(K) -> bool) { self.map.each { |k, _v| blk(k)} }\n+    fn each(blk: fn(K) -> bool) { self.map.each({ |k, _v| blk(k)}) }\n     fn size_hint() -> option<uint> { some(self.map.size()) }\n     fn eachi(blk: fn(uint, K) -> bool) { iter::eachi(self, blk) }\n }"}, {"sha": "1feddf0c3e16cd6cc163369c3342587781806e08", "filename": "src/test/run-pass/class-implements-multiple-ifaces.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-ifaces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-ifaces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-ifaces.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -53,7 +53,7 @@ class cat : noisy, scratchy, bitey {\n       let t : hashmap<body_part, uint> =\n         hashmap::<body_part, uint>(hsher, eqer);\n       self.bite_counts = t;\n-      iter(~[finger, toe, nose, ear]) {|p|\n+      do iter(~[finger, toe, nose, ear]) {|p|\n           self.bite_counts.insert(p, 0u);\n       };\n     }\n@@ -73,7 +73,7 @@ class cat : noisy, scratchy, bitey {\n     #error(\"In bite()\");\n     let all = ~[toe, nose, ear];\n     let mut min = finger;\n-    iter(all) {|next|\n+    do iter(all) {|next|\n       #debug(\"min = %?\", min);\n         if self.bite_counts.get(next) < self.bite_counts.get(min) {\n             min = next;"}, {"sha": "59260fa1bf3f96e5cce8541938559b237c575e67", "filename": "src/test/run-pass/cleanup-copy-mode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fcleanup-copy-mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fcleanup-copy-mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcleanup-copy-mode.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -2,8 +2,8 @@\n fn adder(+x: @int, +y: @int) -> int { ret *x + *y; }\n fn failer() -> @int { fail; }\n fn main() {\n-    assert(result::is_err(task::try {||\n+    assert(result::is_err(task::try({||\n         adder(@2, failer()); ()\n-    }));\n+    })));\n }\n "}, {"sha": "58aaeeea2589c4026d35f10624fa2874ed05fa6d", "filename": "src/test/run-pass/comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomm.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -10,7 +10,7 @@ import task;\n fn main() {\n     let p = comm::port();\n     let ch = comm::chan(p);\n-    let t = task::spawn {|| child(ch); };\n+    let t = task::spawn({|| child(ch); });\n     let y = recv(p);\n     #error(\"received\");\n     log(error, y);"}, {"sha": "ba9b78c75b488dc2a18316a063d5482471d494aa", "filename": "src/test/run-pass/crust-call-deep2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fcrust-call-deep2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fcrust-call-deep2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrust-call-deep2.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -19,7 +19,7 @@ fn count(n: uint) -> uint {\n fn main() {\n     // Make sure we're on a task with small Rust stacks (main currently\n     // has a large stack)\n-    task::spawn {||\n+    do task::spawn {||\n         let result = count(1000u);\n         #debug(\"result = %?\", result);\n         assert result == 1000u;"}, {"sha": "ba920acb6011432567ec3a74ada745555e5a27dc", "filename": "src/test/run-pass/crust-call-scrub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fcrust-call-scrub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fcrust-call-scrub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrust-call-scrub.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -23,7 +23,7 @@ fn count(n: uint) -> uint {\n fn main() {\n     // Make sure we're on a task with small Rust stacks (main currently\n     // has a large stack)\n-    task::spawn {||\n+    do task::spawn {||\n         let result = count(12u);\n         #debug(\"result = %?\", result);\n         assert result == 2048u;"}, {"sha": "dcc78c862c06004a1b9008d1a7866a4253a6d035", "filename": "src/test/run-pass/crust-stress.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fcrust-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fcrust-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrust-stress.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -20,8 +20,8 @@ fn count(n: uint) -> uint {\n }\n \n fn main() {\n-    iter::repeat(100u) {||\n-        task::spawn {||\n+    do iter::repeat(100u) {||\n+        do task::spawn {||\n             assert count(5u) == 16u;\n         };\n     }"}, {"sha": "9eb5533b90c6a150b95af5ff70d09f62045c0fae", "filename": "src/test/run-pass/crust-yield.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fcrust-yield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fcrust-yield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrust-yield.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -17,8 +17,8 @@ fn count(n: uint) -> uint {\n }\n \n fn main() {\n-    iter::repeat(10u) {||\n-        task::spawn {||\n+    do iter::repeat(10u) {||\n+        do task::spawn {||\n             let result = count(5u);\n             #debug(\"result = %?\", result);\n             assert result == 16u;"}, {"sha": "e2ce7fe6e7eeaa250448fad4865a81bf68e69c4d", "filename": "src/test/run-pass/foreach-nested.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-nested.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -7,9 +7,9 @@ fn two(it: fn(int)) { it(0); it(1); }\n fn main() {\n     let a: ~[mut int] = ~[mut -1, -1, -1, -1];\n     let mut p: int = 0;\n-    two {|i|\n-        two {|j| a[p] = 10 * i + j; p += 1; };\n-    };\n+    do two {|i|\n+        do two {|j| a[p] = 10 * i + j; p += 1; }\n+    }\n     assert (a[0] == 0);\n     assert (a[1] == 1);\n     assert (a[2] == 10);"}, {"sha": "f10bfbe851afcd6d4619ae6a26df4934f6f30623", "filename": "src/test/run-pass/foreach-put-structured.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fforeach-put-structured.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fforeach-put-structured.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-put-structured.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -9,7 +9,7 @@ fn pairs(it: fn((int, int))) {\n fn main() {\n     let mut i: int = 10;\n     let mut j: int = 0;\n-    pairs() {|p|\n+    do pairs() {|p|\n         let (_0, _1) = p;\n         log(debug, _0);\n         log(debug, _1);"}, {"sha": "3f9060733a23d7329d35fa1190788b54d88e115c", "filename": "src/test/run-pass/foreach-simple-outer-slot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fforeach-simple-outer-slot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fforeach-simple-outer-slot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-simple-outer-slot.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -4,7 +4,7 @@\n // -*- rust -*-\n fn main() {\n     let mut sum: int = 0;\n-    first_ten {|i| #debug(\"main\"); log(debug, i); sum = sum + i; };\n+    do first_ten {|i| #debug(\"main\"); log(debug, i); sum = sum + i; }\n     #debug(\"sum\");\n     log(debug, sum);\n     assert (sum == 45);"}, {"sha": "3d26c653d034839dc8f4b68763c2ddf1e55a3f72", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -35,7 +35,7 @@ mod map_reduce {\n \n     fn start_mappers(ctrl: chan<ctrl_proto>, inputs: ~[str]) {\n         for inputs.each {|i|\n-            task::spawn {|| map_task(ctrl, i); };\n+            do task::spawn {|| map_task(ctrl, i); }\n         }\n     }\n "}, {"sha": "25511ec2e894c7b3e688a9bac000b4ff0530cfdf", "filename": "src/test/run-pass/intrinsic-frame-address.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fintrinsic-frame-address.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fintrinsic-frame-address.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-frame-address.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -4,7 +4,7 @@ native mod rusti {\n }\n \n fn main() {\n-    rusti::frame_address {|addr|\n+    do rusti::frame_address {|addr|\n         assert addr.is_not_null();\n     }\n }"}, {"sha": "6a90e98c6b29f58a00cb64e7b18f937b48b7d796", "filename": "src/test/run-pass/issue-2185.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fissue-2185.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fissue-2185.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2185.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -11,18 +11,18 @@ impl<A> of iterable<A> for fn@(fn(A)) {\n }\n \n impl of iterable<uint> for fn@(fn(uint)) {\n-    fn iter(blk: fn(&&uint)) { self { |i| blk(i) } }\n+    fn iter(blk: fn(&&uint)) { self({ |i| blk(i) }) }\n }\n \n fn filter<A,IA:iterable<A>>(self: IA, prd: fn@(A) -> bool, blk: fn(A)) {\n-    self.iter {|a|\n+    do self.iter {|a|\n         if prd(a) { blk(a) }\n     }\n }\n \n fn foldl<A,B,IA:iterable<A>>(self: IA, +b0: B, blk: fn(B, A) -> B) -> B {\n     let mut b <- b0;\n-    self.iter { |a|\n+    do self.iter { |a|\n         b <- blk(b, a);\n     }\n     ret b;\n@@ -42,7 +42,7 @@ fn main() {\n         range,\n         {|&&n: uint| n % 3u != 0u && n % 5u != 0u },\n         a)};\n-    let sum = foldl(filt, 0u) {|accum, &&n: uint| accum + n };\n+    let sum = foldl(filt, 0u, {|accum, &&n: uint| accum + n });\n \n     io::println(#fmt(\"%u\", sum));\n }\n\\ No newline at end of file"}, {"sha": "348e750a484824aa4f32ab2294ed9546de74db33", "filename": "src/test/run-pass/issue-2487-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fissue-2487-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fissue-2487-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2487-a.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -6,7 +6,7 @@ class socket {\n     drop { }\n \n     fn set_identity()  {\n-        closure { ||\n+        do closure { ||\n             setsockopt_bytes(copy self.sock)\n         }\n     }"}, {"sha": "0c840864fd552168198c47610ac51bfc784b5521", "filename": "src/test/run-pass/issue-507.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fissue-507.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fissue-507.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-507.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -17,14 +17,14 @@ import comm::recv;\n fn grandchild(c: chan<int>) { send(c, 42); }\n \n fn child(c: chan<int>) {\n-    task::spawn {|| grandchild(c); }\n+    task::spawn({|| grandchild(c); })\n }\n \n fn main() {\n     let p = comm::port();\n     let ch = chan(p);\n \n-    task::spawn {|| child(ch); }\n+    task::spawn({|| child(ch); });\n \n     let x: int = recv(p);\n "}, {"sha": "4d15b3c387a375605b534b12232c83b57ca30b14", "filename": "src/test/run-pass/issue-687.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fissue-687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fissue-687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-687.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -41,10 +41,10 @@ fn main() {\n     let ch = chan(p);\n     let recv_reader: port<chan<~[u8]>> = port();\n     let recv_reader_chan = chan(recv_reader);\n-    let pack = task::spawn {|| packager(recv_reader_chan, ch); };\n+    let pack = task::spawn({|| packager(recv_reader_chan, ch); });\n \n     let source_chan: chan<~[u8]> = recv(recv_reader);\n-    let prod = task::spawn {|| producer(source_chan); };\n+    let prod = task::spawn({|| producer(source_chan); });\n \n     loop {\n         let msg = recv(p);"}, {"sha": "85a125b0149ba45f92205d3566ecbd4e700ec2a8", "filename": "src/test/run-pass/issue-783.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fissue-783.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fissue-783.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-783.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -10,7 +10,7 @@ fn a() {\n         }\n         let p = port();\n         let ch = chan(p);\n-        spawn {|| b(ch); };\n+        spawn({|| b(ch); });\n         recv(p);\n     }\n     let mut i = 0;\n@@ -21,7 +21,7 @@ fn a() {\n }\n \n fn main() {\n-    iter::repeat(100u) {||\n-        spawn {|| a(); }\n+    do iter::repeat(100u) {||\n+        spawn({|| a(); });\n     }\n }"}, {"sha": "93b9542bd10ebb01c658c7638a6280de3c6cad0c", "filename": "src/test/run-pass/iter-range.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fiter-range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fiter-range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-range.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -8,6 +8,6 @@ fn range(a: int, b: int, it: fn(int)) {\n \n fn main() {\n     let mut sum: int = 0;\n-    range(0, 100) {|x| sum += x; }\n+    range(0, 100, {|x| sum += x; });\n     log(debug, sum);\n }"}, {"sha": "1d59957fbd7aebcc6f762cf77c40c446942c914e", "filename": "src/test/run-pass/ivec-tag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fivec-tag.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -16,7 +16,7 @@ fn producer(c: chan<~[u8]>) {\n fn main() {\n     let p: port<~[u8]> = port();\n     let ch = chan(p);\n-    let prod = task::spawn {|| producer(ch); };\n+    let prod = task::spawn({|| producer(ch); });\n \n     let data: ~[u8] = recv(p);\n }"}, {"sha": "9f3eebc8f22a92fd72fb43b68e29b152f92299e8", "filename": "src/test/run-pass/last-use-in-block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Flast-use-in-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Flast-use-in-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flast-use-in-block.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -10,7 +10,7 @@ fn lp<T>(s: str, f: fn(str) -> T) -> T {\n \n fn apply<T>(s: str, f: fn(str) -> T) -> T {\n     fn g<T>(s: str, f: fn(str) -> T) -> T {f(s)}\n-    g(s) {|v| let r = f(v); r }\n+    g(s, {|v| let r = f(v); r })\n }\n \n fn main() {}"}, {"sha": "fe1a18f0750827b89b938b3a106316ed53b68399", "filename": "src/test/run-pass/last-use-is-capture.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Flast-use-is-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Flast-use-is-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flast-use-is-capture.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -4,5 +4,5 @@ fn main() {\n     fn invoke(f: fn@()) { f(); }\n     let k = ~22;\n     let _u = {a: k};\n-    invoke {||log(error, k);}\n+    invoke({||log(error, k);})\n }"}, {"sha": "643a7b56f4a53b6e363c3a0f7f371383c8986beb", "filename": "src/test/run-pass/lazychan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Flazychan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Flazychan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flazychan.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -9,13 +9,13 @@ fn main() {\n     let ch = chan(p);\n     let mut y: int;\n \n-    task::spawn {|| child(ch); };\n+    task::spawn({|| child(ch); });\n     y = recv(p);\n     #debug(\"received 1\");\n     log(debug, y);\n     assert (y == 10);\n \n-    task::spawn {|| child(ch); };\n+    task::spawn({|| child(ch); });\n     y = recv(p);\n     #debug(\"received 2\");\n     log(debug, y);"}, {"sha": "19ee9a66f8dd09e2ed2465505bf30386000c98ff", "filename": "src/test/run-pass/lots-a-fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Flots-a-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Flots-a-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flots-a-fail.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -9,13 +9,13 @@ fn die() {\n }\n \n fn iloop() {\n-    task::spawn {|| die(); };\n+    task::spawn({|| die(); });\n }\n \n fn main() {\n     for uint::range(0u, 100u) {|_i|\n         let builder = task::builder();\n         task::unsupervise(builder);\n-        task::run(builder) {|| iloop(); };\n+        task::run(builder, {|| iloop(); });\n     }\n }\n\\ No newline at end of file"}, {"sha": "c13f6c02def3be064e60e451c8887dfe81b28bf0", "filename": "src/test/run-pass/many.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fmany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fmany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmany.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -10,7 +10,7 @@ fn sub(parent: comm::chan<int>, id: int) {\n     } else {\n         let p = comm::port();\n         let ch = comm::chan(p);\n-        let child = task::spawn {|| sub(ch, id - 1); };\n+        let child = task::spawn({|| sub(ch, id - 1); });\n         let y = comm::recv(p);\n         comm::send(parent, y + 1);\n     }\n@@ -19,7 +19,7 @@ fn sub(parent: comm::chan<int>, id: int) {\n fn main() {\n     let p = comm::port();\n     let ch = comm::chan(p);\n-    let child = task::spawn {|| sub(ch, 200); };\n+    let child = task::spawn({|| sub(ch, 200); });\n     let y = comm::recv(p);\n     #debug(\"transmission complete\");\n     log(debug, y);"}, {"sha": "466dd101daece9c3b7e7016ccba1f5c44bc009c1", "filename": "src/test/run-pass/monad.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fmonad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fmonad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonad.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -16,12 +16,12 @@ impl monad<A> for option<A> {\n }\n \n fn transform(x: option<int>) -> option<str> {\n-    x.bind {|n| some(n + 1)}.bind {|n| some(int::str(n))}\n+    x.bind({|n| some(n + 1)}).bind({|n| some(int::str(n))})\n }\n \n fn main() {\n     assert transform(some(10)) == some(\"11\");\n     assert transform(none) == none;\n-    assert (~[\"hi\"]).bind {|x| ~[x, x + \"!\"]}.bind {|x| ~[x, x + \"?\"]} ==\n+    assert (~[\"hi\"]).bind({|x| ~[x, x + \"!\"]}).bind({|x| ~[x, x + \"?\"]}) ==\n         ~[\"hi\", \"hi?\", \"hi!\", \"hi!?\"];\n }"}, {"sha": "20fe8e027bfc568dcc754b0c19df5db9bf3d14a2", "filename": "src/test/run-pass/morestack5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fmorestack5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fmorestack5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmorestack5.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -12,7 +12,7 @@ fn getbig(&&i: int) {\n fn main() {\n     let mut sz = 400u;\n     while sz < 500u {\n-        task::try {|| getbig(200) };\n+        task::try({|| getbig(200) });\n         sz += 1u;\n     }\n }\n\\ No newline at end of file"}, {"sha": "d4290fd81eb19188f28b3b33b5b0e74388b1020d", "filename": "src/test/run-pass/morestack6.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmorestack6.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -58,6 +58,6 @@ fn main() {\n     for fns.each {|f|\n         let sz = rng.next() % 256u32 + 256u32;\n         let frame_backoff = rng.next() % 10u32 + 1u32;\n-        task::try {|| runtest(f, frame_backoff) };\n+        task::try({|| runtest(f, frame_backoff) });\n     }\n }"}, {"sha": "92eb1d93dd9357e03016547cf75342b0490def07", "filename": "src/test/run-pass/osmain.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fosmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fosmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fosmain.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -24,7 +24,7 @@ fn run(i: int) {\n     };\n     task::set_opts(builder, opts);\n     task::unsupervise(builder);\n-    task::run(builder) {||\n+    do task::run(builder) {||\n         task::yield();\n         let builder = task::builder();\n         let opts = {\n@@ -36,7 +36,7 @@ fn run(i: int) {\n         };\n         task::set_opts(builder, opts);\n         task::unsupervise(builder);\n-        task::run(builder) {||\n+        do task::run(builder) {||\n             task::yield();\n             run(i - 1);\n             task::yield();"}, {"sha": "0a378235682842ff8b24482fb719f7e531055edd", "filename": "src/test/run-pass/regions-params.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fregions-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fregions-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-params.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -3,9 +3,9 @@ fn region_identity(x: &r.uint) -> &r.uint { x }\n fn apply<T>(t: T, f: fn(T) -> T) -> T { f(t) }\n \n fn parameterized(x: &uint) -> uint {\n-    let z = apply(x) {|y|\n+    let z = apply(x, ({|y|\n         region_identity(y)\n-    };\n+    }));\n     *z\n }\n "}, {"sha": "b691676f8613a17bd32f8c97a7819f5acdf5f571", "filename": "src/test/run-pass/send-iloop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fsend-iloop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fsend-iloop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-iloop.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -9,7 +9,7 @@ fn die() {\n }\n \n fn iloop() {\n-    task::spawn {|| die(); };\n+    task::spawn({|| die(); });\n     let p = comm::port::<()>();\n     let c = comm::chan(p);\n     loop {\n@@ -24,6 +24,6 @@ fn main() {\n     for uint::range(0u, 16u) {|_i|\n         let builder = task::builder();\n         task::unsupervise(builder);\n-        task::run(builder) {|| iloop(); }\n+        task::run(builder, {|| iloop(); });\n     }\n }\n\\ No newline at end of file"}, {"sha": "0be6e71d66f7559ce0a60bf8628c7337252722b7", "filename": "src/test/run-pass/send-resource.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fsend-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fsend-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-resource.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -11,7 +11,7 @@ fn main() {\n     let p = port();\n     let c = chan(p);\n \n-    spawn() {||\n+    do spawn() {||\n         let p = port();\n         c.send(chan(p));\n "}, {"sha": "ee5fa5dc4f35864e6743a3283ff18ee736cea255", "filename": "src/test/run-pass/sendfn-generic-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fsendfn-generic-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fsendfn-generic-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsendfn-generic-fn.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -27,7 +27,7 @@ fn spawn<A: copy, B: copy>(f: native fn(fn~(A,B)->pair<A,B>)) {\n     let arg = fn~(a: A, b: B) -> pair<A,B> {\n         ret make_generic_record(a, b);\n     };\n-    task::spawn {|| f(arg); };\n+    task::spawn({|| f(arg); });\n }\n \n fn test05() {"}, {"sha": "02d8fd1b4371b25d413e2827471262283e83f1ae", "filename": "src/test/run-pass/spawn-fn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fspawn-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fspawn-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-fn.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -10,9 +10,9 @@ fn x(s: str, n: int) {\n }\n \n fn main() {\n-    task::spawn {|| x(\"hello from first spawned fn\", 65); };\n-    task::spawn {|| x(\"hello from second spawned fn\", 66); };\n-    task::spawn {|| x(\"hello from third spawned fn\", 67); };\n+    task::spawn({|| x(\"hello from first spawned fn\", 65); });\n+    task::spawn({|| x(\"hello from second spawned fn\", 66); });\n+    task::spawn({|| x(\"hello from third spawned fn\", 67); });\n     let mut i: int = 30;\n     while i > 0 { i = i - 1; #debug(\"parent sleeping\"); yield(); }\n }"}, {"sha": "9abe4f6a3ef2e4612abcda55732b24692bb36876", "filename": "src/test/run-pass/spawn-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-types.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -19,5 +19,5 @@ fn iotask(cx: ctx, ip: str) {\n fn main() {\n     let p = comm::port::<int>();\n     let ch = comm::chan(p);\n-    task::spawn {|| iotask(ch, \"localhost\"); };\n+    task::spawn({|| iotask(ch, \"localhost\"); });\n }"}, {"sha": "110284920d326815cc26c3ecfd373ebde54ce2d9", "filename": "src/test/run-pass/spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -5,7 +5,7 @@ use std;\n import task;\n \n fn main() {\n-    task::spawn {|| child(10); };\n+    task::spawn({|| child(10); });\n }\n \n fn child(&&i: int) { log(error, i); assert (i == 10); }"}, {"sha": "3a9506cc278ac2749275e965de935fc52dfa3e2d", "filename": "src/test/run-pass/spawn2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fspawn2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fspawn2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn2.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -3,7 +3,7 @@\n use std;\n import task::spawn;\n \n-fn main() { spawn {|| child((10, 20, 30, 40, 50, 60, 70, 80, 90)); }; }\n+fn main() { spawn({|| child((10, 20, 30, 40, 50, 60, 70, 80, 90)); }); }\n \n fn child(&&args: (int, int, int, int, int, int, int, int, int)) {\n     let (i1, i2, i3, i4, i5, i6, i7, i8, i9) = args;"}, {"sha": "ad2324a34c2a9cb6b6ef06b72076b240e1c68276", "filename": "src/test/run-pass/static-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-impl.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -37,6 +37,6 @@ fn main() {\n     assert (~[3, 4]).map_({|a| a + 4})[0] == 7;\n     assert (~[3, 4]).map_::<uint>({|a| a as uint + 4u})[0] == 7u;\n     let mut x = 0u;\n-    10u.times {|_n| x += 2u;}\n+    10u.times({|_n| x += 2u;});\n     assert x == 20u;\n }"}, {"sha": "ab16868caf1650d3d11a6dfc70f4eb053e5c9f98", "filename": "src/test/run-pass/task-comm-0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -20,7 +20,7 @@ fn test05_start(ch : chan<int>) {\n fn test05() {\n     let po = comm::port();\n     let ch = comm::chan(po);\n-    task::spawn {|| test05_start(ch); };\n+    task::spawn({|| test05_start(ch); });\n     let mut value = comm::recv(po);\n     log(error, value);\n     value = comm::recv(po);"}, {"sha": "4995bfa0422219b756776d0f5acfbaa3f391397f", "filename": "src/test/run-pass/task-comm-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -3,6 +3,6 @@ fn main() { test00(); }\n fn start() { #debug(\"Started / Finished task.\"); }\n \n fn test00() {\n-    task::try {|| start() };\n+    task::try({|| start() });\n     #debug(\"Completing.\");\n }"}, {"sha": "f06d694bdce8a1f3343cd0912de75549e8080646", "filename": "src/test/run-pass/task-comm-10.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -19,7 +19,7 @@ fn start(c: comm::chan<comm::chan<str>>) {\n fn main() {\n     let p = comm::port();\n     let ch = comm::chan(p);\n-    let child = task::spawn {|| start(ch); };\n+    let child = task::spawn({|| start(ch); });\n \n     let c = comm::recv(p);\n     comm::send(c, \"A\");"}, {"sha": "df159fa52852aa3668a67083ea68eece80f9677d", "filename": "src/test/run-pass/task-comm-11.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -10,6 +10,6 @@ fn start(c: comm::chan<comm::chan<int>>) {\n fn main() {\n     let p = comm::port();\n     let ch = comm::chan(p);\n-    let child = task::spawn {|| start(ch); };\n+    let child = task::spawn({|| start(ch); });\n     let c = comm::recv(p);\n }"}, {"sha": "aff0eb5cf764723c2fa7373ce7b177f65ec56422", "filename": "src/test/run-pass/task-comm-12.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -9,7 +9,7 @@ fn test00() {\n     let i: int = 0;\n     let builder = task::builder();\n     let r = task::future_result(builder);\n-    task::run(builder) {|| start(i); };\n+    task::run(builder, {|| start(i); });\n \n     // Sleep long enough for the task to finish.\n     let mut i = 0;"}, {"sha": "a3608173978f138c812300093ca807075558e0e5", "filename": "src/test/run-pass/task-comm-13.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -12,6 +12,6 @@ fn main() {\n     #debug(\"Check that we don't deadlock.\");\n     let p = comm::port::<int>();\n     let ch = comm::chan(p);\n-    task::try {|| start(ch, 0, 10) };\n+    task::try({|| start(ch, 0, 10) });\n     #debug(\"Joined task\");\n }"}, {"sha": "1adc04f6e1c38ab8cd4e82fec7d889115a1d2b2e", "filename": "src/test/run-pass/task-comm-14.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -10,7 +10,7 @@ fn main() {\n     let mut i = 10;\n     while (i > 0) {\n         log(debug, i);\n-        task::spawn {|copy i| child(i, ch); };\n+        task::spawn({|copy i| child(i, ch); });\n         i = i - 1;\n     }\n "}, {"sha": "816e41eb017158992acb42bfa9cbc57d169cd834", "filename": "src/test/run-pass/task-comm-15.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -18,6 +18,6 @@ fn main() {\n     // the child's point of view the receiver may die. We should\n     // drop messages on the floor in this case, and not crash!\n     let ch = comm::chan(p);\n-    let child = task::spawn {|| start(ch, 10); };\n+    let child = task::spawn({|| start(ch, 10); });\n     let c = comm::recv(p);\n }"}, {"sha": "b3462d87f5a6416f0bd6acfbb9b340303cd88004", "filename": "src/test/run-pass/task-comm-17.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftask-comm-17.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftask-comm-17.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-17.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -9,5 +9,5 @@ fn f() {\n }\n \n fn main() {\n-    task::spawn {|| f() };\n+    task::spawn({|| f() });\n }\n\\ No newline at end of file"}, {"sha": "f0bb3818d862332daff28ef02256098b6481236f", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -34,7 +34,7 @@ fn test00() {\n     while i < number_of_tasks {\n         let builder = task::builder();\n         results += ~[task::future_result(builder)];\n-        task::run(builder) {|copy i|\n+        do task::run(builder) {|copy i|\n             test00_start(ch, i, number_of_messages)\n         }\n         i = i + 1;"}, {"sha": "2498dc3d043cc7a5f0fff63c1fca2c1d8ba90fc5", "filename": "src/test/run-pass/task-comm-7.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -16,16 +16,16 @@ fn test00() {\n     let number_of_messages: int = 10;\n     let c = comm::chan(p);\n \n-    task::spawn {||\n+    do task::spawn {||\n         test00_start(c, number_of_messages * 0, number_of_messages);\n     }\n-    task::spawn {||\n+    do task::spawn {||\n         test00_start(c, number_of_messages * 1, number_of_messages);\n     }\n-    task::spawn {||\n+    do task::spawn {||\n         test00_start(c, number_of_messages * 2, number_of_messages);\n     }\n-    task::spawn {||\n+    do task::spawn {||\n         test00_start(c, number_of_messages * 3, number_of_messages);\n     }\n "}, {"sha": "4469f8194c82a66ebf69b5862642ea9d9882afb8", "filename": "src/test/run-pass/task-comm-9.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -18,7 +18,7 @@ fn test00() {\n \n     let builder = task::builder();\n     let r = task::future_result(builder);\n-    task::run(builder) {||\n+    do task::run(builder) {||\n         test00_start(ch, number_of_messages);\n     }\n "}, {"sha": "8fba756534138a4c8a3c10c2f397b23dc57ceed4", "filename": "src/test/run-pass/task-comm-chan-cleanup4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup4.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -16,13 +16,13 @@ fn starbase() {\n     for int::range(0, 10) { |_i|\n         let p = comm::port();\n         let c = comm::chan(p);\n-        task::spawn {|| starship(c);};\n+        task::spawn({|| starship(c);});\n         task::yield();\n     }\n }\n \n fn main() {\n     for int::range(0, 10) { |_i|\n-        task::spawn {|| starbase();};\n+        task::spawn({|| starbase();});\n     }\n }\n\\ No newline at end of file"}, {"sha": "a929c2237b0187425a79b6c5106258de7ee13130", "filename": "src/test/run-pass/task-comm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -43,7 +43,7 @@ fn test00() {\n         i = i + 1;\n         let builder = task::builder();\n         results += ~[task::future_result(builder)];\n-        task::run(builder) {|copy i|\n+        do task::run(builder) {|copy i|\n             test00_start(ch, i, number_of_messages);\n         }\n     }\n@@ -89,7 +89,7 @@ fn test04_start() {\n fn test04() {\n     #debug(\"Spawning lots of tasks.\");\n     let mut i: int = 4;\n-    while i > 0 { i = i - 1; task::spawn {|| test04_start(); }; }\n+    while i > 0 { i = i - 1; task::spawn({|| test04_start(); }); }\n     #debug(\"Finishing up.\");\n }\n \n@@ -104,7 +104,7 @@ fn test05_start(ch: chan<int>) {\n fn test05() {\n     let po = comm::port();\n     let ch = chan(po);\n-    task::spawn {|| test05_start(ch); };\n+    task::spawn({|| test05_start(ch); });\n     let mut value: int;\n     value = recv(po);\n     value = recv(po);\n@@ -130,7 +130,7 @@ fn test06() {\n         i = i + 1;\n         let builder = task::builder();\n         results += ~[task::future_result(builder)];\n-        task::run(builder) {|copy i|\n+        do task::run(builder) {|copy i|\n             test06_start(i);\n         };\n     }"}, {"sha": "9038667e90b6fd183ba20104c98df7cc1f0cc9da", "filename": "src/test/run-pass/task-killjoin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftask-killjoin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftask-killjoin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-killjoin.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -20,13 +20,13 @@ fn supervisor() {\n     // Unsupervise this task so the process doesn't return a failure status as\n     // a result of the main task being killed.\n     let f = supervised;\n-    task::try {|| supervised() };\n+    task::try({|| supervised() });\n }\n \n fn main() {\n     let builder = task::builder();\n     task::unsupervise(builder);\n-    task::run(builder) {|| supervisor(); }\n+    task::run(builder, {|| supervisor(); })\n }\n \n // Local Variables:"}, {"sha": "bf19f937bcfc00624c19a3f002b5eabd722df47e", "filename": "src/test/run-pass/task-life-0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftask-life-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftask-life-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-life-0.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -1,7 +1,7 @@\n use std;\n import task;\n fn main() {\n-    task::spawn {|| child(\"Hello\"); };\n+    task::spawn({|| child(\"Hello\"); });\n }\n \n fn child(&&s: str) {"}, {"sha": "3b26722f4979737a5129991191971e0041ddd016", "filename": "src/test/run-pass/terminate-in-initializer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fterminate-in-initializer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fterminate-in-initializer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fterminate-in-initializer.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -12,13 +12,13 @@ fn test_ret() { let x: @int = ret; }\n \n fn test_fail() {\n     fn f() { let x: @int = fail; }\n-    task::try {|| f() };\n+    task::try({|| f() });\n }\n \n fn test_fail_indirect() {\n     fn f() -> ! { fail; }\n     fn g() { let x: @int = f(); }\n-    task::try {|| g() };\n+    task::try({|| g() });\n }\n \n fn main() {"}, {"sha": "efc530aac4b5c9e4fac72a2b8a855f918d9eebf5", "filename": "src/test/run-pass/threads.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fthreads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fthreads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fthreads.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -5,7 +5,7 @@ import task;\n \n fn main() {\n     let mut i = 10;\n-    while i > 0 { task::spawn {|copy i| child(i); }; i = i - 1; }\n+    while i > 0 { task::spawn({|copy i| child(i); }); i = i - 1; }\n     #debug(\"main thread exiting\");\n }\n "}, {"sha": "4b19981887be1b5fab0d7157535f60b0bf066479", "filename": "src/test/run-pass/too-much-recursion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftoo-much-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftoo-much-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftoo-much-recursion.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -7,7 +7,7 @@\n fn main() {\n     let builder = task::builder();\n     task::unsupervise(builder);\n-    task::run(builder) {||\n+    do task::run(builder) {||\n         fn f() { f() };\n         f();\n     };"}, {"sha": "2aec1c3f8da69669d1600f8dd72432f9a862dac1", "filename": "src/test/run-pass/type-params-in-for-each.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftype-params-in-for-each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Ftype-params-in-for-each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-params-in-for-each.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -6,7 +6,7 @@ fn range(lo: uint, hi: uint, it: fn(uint)) {\n }\n \n fn create_index<T>(index: ~[{a: T, b: uint}], hash_fn: native fn(T) -> uint) {\n-    range(0u, 256u) {|_i| let bucket: ~[T] = ~[]; }\n+    range(0u, 256u, {|_i| let bucket: ~[T] = ~[]; })\n }\n \n fn main() { }"}, {"sha": "e9d7d91ba3305c9b57cf62c3296cd4f6e8a18078", "filename": "src/test/run-pass/unique-send-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-send-2.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -13,7 +13,7 @@ fn main() {\n     let n = 100u;\n     let mut expected = 0u;\n     for uint::range(0u, n) {|i|\n-        task::spawn {|| child(ch, i); };\n+        task::spawn({|| child(ch, i); });\n         expected += i;\n     }\n "}, {"sha": "7791c396b10baff63e779108ab98fbcba196bcf2", "filename": "src/test/run-pass/unwind-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Funwind-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Funwind-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-box.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -10,5 +10,5 @@ fn f() {\n fn main() {\n     let builder = task::builder();\n     task::unsupervise(builder);\n-    task::run(builder) {|| f(); }\n+    task::run(builder, {|| f(); });\n }\n\\ No newline at end of file"}, {"sha": "e9222c21b91ddf2a4fb6ccebc92c36950032f609", "filename": "src/test/run-pass/unwind-resource.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-resource.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -23,7 +23,7 @@ fn main() {\n     let c = comm::chan(p);\n     let builder = task::builder();\n     task::unsupervise(builder);\n-    task::run(builder) {|| f(c); }\n+    task::run(builder, {|| f(c); });\n     #error(\"hiiiiiiiii\");\n     assert comm::recv(p);\n }\n\\ No newline at end of file"}, {"sha": "73ee572acb12ce0a1426acc43d803918e233e833", "filename": "src/test/run-pass/unwind-resource2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Funwind-resource2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Funwind-resource2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-resource2.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -17,5 +17,5 @@ fn f() {\n fn main() {\n     let builder = task::builder();\n     task::unsupervise(builder);\n-    task::run(builder) {|| f(); }\n+    task::run(builder, {|| f(); });\n }\n\\ No newline at end of file"}, {"sha": "2039b3d63d7ca8749ce823266491bf50edb9bcda", "filename": "src/test/run-pass/unwind-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Funwind-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Funwind-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-unique.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -10,5 +10,5 @@ fn f() {\n fn main() {\n     let builder = task::builder();\n     task::unsupervise(builder);\n-    task::run(builder) {|| f(); }\n+    task::run(builder, {|| f(); });\n }\n\\ No newline at end of file"}, {"sha": "fdb1b52b2773fd7898d9ace946372a93be726c67", "filename": "src/test/run-pass/yield.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fyield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fyield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -6,7 +6,7 @@ import task::*;\n fn main() {\n     let builder = task::builder();\n     let result = task::future_result(builder);\n-    task::run(builder) {|| child(); }\n+    task::run(builder, {|| child(); });\n     #error(\"1\");\n     yield();\n     #error(\"2\");"}, {"sha": "044671072565d57cdfa28748289862cbd2cfe72a", "filename": "src/test/run-pass/yield1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fyield1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3382b6f26e582210a3b649c9a71badaef0530bf/src%2Ftest%2Frun-pass%2Fyield1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield1.rs?ref=a3382b6f26e582210a3b649c9a71badaef0530bf", "patch": "@@ -6,7 +6,7 @@ import task::*;\n fn main() {\n     let builder = task::builder();\n     let result = task::future_result(builder);\n-    task::run(builder) {|| child(); }\n+    task::run(builder, {|| child(); });\n     #error(\"1\");\n     yield();\n     future::get(result);"}]}