{"sha": "0f46f2773aafc9f9cfe3018b9e896c39913044d5", "node_id": "C_kwDOAAsO6NoAKDBmNDZmMjc3M2FhZmM5ZjljZmUzMDE4YjllODk2YzM5OTEzMDQ0ZDU", "commit": {"author": {"name": "DropDemBits", "email": "r3usrlnd@gmail.com", "date": "2022-10-10T04:47:53Z"}, "committer": {"name": "DropDemBits", "email": "r3usrlnd@gmail.com", "date": "2022-10-10T14:47:54Z"}, "message": "Migrate most of `ide_assists::utils` to format arg capture", "tree": {"sha": "ba65db0d5473ad0cdafaa450d7f9cd686634806e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba65db0d5473ad0cdafaa450d7f9cd686634806e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f46f2773aafc9f9cfe3018b9e896c39913044d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f46f2773aafc9f9cfe3018b9e896c39913044d5", "html_url": "https://github.com/rust-lang/rust/commit/0f46f2773aafc9f9cfe3018b9e896c39913044d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f46f2773aafc9f9cfe3018b9e896c39913044d5/comments", "author": {"login": "DropDemBits", "id": 13354275, "node_id": "MDQ6VXNlcjEzMzU0Mjc1", "avatar_url": "https://avatars.githubusercontent.com/u/13354275?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DropDemBits", "html_url": "https://github.com/DropDemBits", "followers_url": "https://api.github.com/users/DropDemBits/followers", "following_url": "https://api.github.com/users/DropDemBits/following{/other_user}", "gists_url": "https://api.github.com/users/DropDemBits/gists{/gist_id}", "starred_url": "https://api.github.com/users/DropDemBits/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DropDemBits/subscriptions", "organizations_url": "https://api.github.com/users/DropDemBits/orgs", "repos_url": "https://api.github.com/users/DropDemBits/repos", "events_url": "https://api.github.com/users/DropDemBits/events{/privacy}", "received_events_url": "https://api.github.com/users/DropDemBits/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DropDemBits", "id": 13354275, "node_id": "MDQ6VXNlcjEzMzU0Mjc1", "avatar_url": "https://avatars.githubusercontent.com/u/13354275?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DropDemBits", "html_url": "https://github.com/DropDemBits", "followers_url": "https://api.github.com/users/DropDemBits/followers", "following_url": "https://api.github.com/users/DropDemBits/following{/other_user}", "gists_url": "https://api.github.com/users/DropDemBits/gists{/gist_id}", "starred_url": "https://api.github.com/users/DropDemBits/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DropDemBits/subscriptions", "organizations_url": "https://api.github.com/users/DropDemBits/orgs", "repos_url": "https://api.github.com/users/DropDemBits/repos", "events_url": "https://api.github.com/users/DropDemBits/events{/privacy}", "received_events_url": "https://api.github.com/users/DropDemBits/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d23537394e92e1abc864dc4cabdab14ad9b9c0c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/d23537394e92e1abc864dc4cabdab14ad9b9c0c1", "html_url": "https://github.com/rust-lang/rust/commit/d23537394e92e1abc864dc4cabdab14ad9b9c0c1"}], "stats": {"total": 60, "additions": 30, "deletions": 30}, "files": [{"sha": "acbb56c5f755039359aaff967ae5c4c29762a53a", "filename": "crates/ide-assists/src/utils.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f46f2773aafc9f9cfe3018b9e896c39913044d5/crates%2Fide-assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f46f2773aafc9f9cfe3018b9e896c39913044d5/crates%2Fide-assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Futils.rs?ref=0f46f2773aafc9f9cfe3018b9e896c39913044d5", "patch": "@@ -189,8 +189,8 @@ pub(crate) fn render_snippet(_cap: SnippetCap, node: &SyntaxNode, cursor: Cursor\n     let mut placeholder = cursor.node().to_string();\n     escape(&mut placeholder);\n     let tab_stop = match cursor {\n-        Cursor::Replace(placeholder) => format!(\"${{0:{}}}\", placeholder),\n-        Cursor::Before(placeholder) => format!(\"$0{}\", placeholder),\n+        Cursor::Replace(placeholder) => format!(\"${{0:{placeholder}}}\"),\n+        Cursor::Before(placeholder) => format!(\"$0{placeholder}\"),\n     };\n \n     let mut buf = node.to_string();\n@@ -535,37 +535,37 @@ impl ReferenceConversion {\n             ReferenceConversionType::AsRefSlice => {\n                 let type_argument_name =\n                     self.ty.type_arguments().next().unwrap().display(db).to_string();\n-                format!(\"&[{}]\", type_argument_name)\n+                format!(\"&[{type_argument_name}]\")\n             }\n             ReferenceConversionType::Dereferenced => {\n                 let type_argument_name =\n                     self.ty.type_arguments().next().unwrap().display(db).to_string();\n-                format!(\"&{}\", type_argument_name)\n+                format!(\"&{type_argument_name}\")\n             }\n             ReferenceConversionType::Option => {\n                 let type_argument_name =\n                     self.ty.type_arguments().next().unwrap().display(db).to_string();\n-                format!(\"Option<&{}>\", type_argument_name)\n+                format!(\"Option<&{type_argument_name}>\")\n             }\n             ReferenceConversionType::Result => {\n                 let mut type_arguments = self.ty.type_arguments();\n                 let first_type_argument_name =\n                     type_arguments.next().unwrap().display(db).to_string();\n                 let second_type_argument_name =\n                     type_arguments.next().unwrap().display(db).to_string();\n-                format!(\"Result<&{}, &{}>\", first_type_argument_name, second_type_argument_name)\n+                format!(\"Result<&{first_type_argument_name}, &{second_type_argument_name}>\")\n             }\n         }\n     }\n \n     pub(crate) fn getter(&self, field_name: String) -> String {\n         match self.conversion {\n-            ReferenceConversionType::Copy => format!(\"self.{}\", field_name),\n+            ReferenceConversionType::Copy => format!(\"self.{field_name}\"),\n             ReferenceConversionType::AsRefStr\n             | ReferenceConversionType::AsRefSlice\n             | ReferenceConversionType::Dereferenced\n             | ReferenceConversionType::Option\n-            | ReferenceConversionType::Result => format!(\"self.{}.as_ref()\", field_name),\n+            | ReferenceConversionType::Result => format!(\"self.{field_name}.as_ref()\"),\n         }\n     }\n }"}, {"sha": "6c87e66c134d72a28642c8e614d0e372e63073fc", "filename": "crates/ide-assists/src/utils/gen_trait_fn_body.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0f46f2773aafc9f9cfe3018b9e896c39913044d5/crates%2Fide-assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f46f2773aafc9f9cfe3018b9e896c39913044d5/crates%2Fide-assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs?ref=0f46f2773aafc9f9cfe3018b9e896c39913044d5", "patch": "@@ -41,7 +41,7 @@ fn gen_clone_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n             let mut arms = vec![];\n             for variant in list.variants() {\n                 let name = variant.name()?;\n-                let variant_name = make::ext::path_from_idents([\"Self\", &format!(\"{}\", name)])?;\n+                let variant_name = make::ext::path_from_idents([\"Self\", &format!(\"{name}\")])?;\n \n                 match variant.field_list() {\n                     // => match self { Self::Name { x } => Self::Name { x: x.clone() } }\n@@ -70,7 +70,7 @@ fn gen_clone_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                         let mut pats = vec![];\n                         let mut fields = vec![];\n                         for (i, _) in list.fields().enumerate() {\n-                            let field_name = format!(\"arg{}\", i);\n+                            let field_name = format!(\"arg{i}\");\n                             let pat = make::ident_pat(false, false, make::name(&field_name));\n                             pats.push(pat.into());\n \n@@ -118,7 +118,7 @@ fn gen_clone_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                     let mut fields = vec![];\n                     for (i, _) in field_list.fields().enumerate() {\n                         let f_path = make::expr_path(make::ext::ident_path(\"self\"));\n-                        let target = make::expr_field(f_path, &format!(\"{}\", i));\n+                        let target = make::expr_field(f_path, &format!(\"{i}\"));\n                         fields.push(gen_clone_call(target));\n                     }\n                     let struct_name = make::expr_path(make::ext::ident_path(\"Self\"));\n@@ -151,15 +151,15 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n             let mut arms = vec![];\n             for variant in list.variants() {\n                 let name = variant.name()?;\n-                let variant_name = make::ext::path_from_idents([\"Self\", &format!(\"{}\", name)])?;\n+                let variant_name = make::ext::path_from_idents([\"Self\", &format!(\"{name}\")])?;\n                 let target = make::expr_path(make::ext::ident_path(\"f\"));\n \n                 match variant.field_list() {\n                     Some(ast::FieldList::RecordFieldList(list)) => {\n                         // => f.debug_struct(name)\n                         let target = make::expr_path(make::ext::ident_path(\"f\"));\n                         let method = make::name_ref(\"debug_struct\");\n-                        let struct_name = format!(\"\\\"{}\\\"\", name);\n+                        let struct_name = format!(\"\\\"{name}\\\"\");\n                         let args = make::arg_list(Some(make::expr_literal(&struct_name).into()));\n                         let mut expr = make::expr_method_call(target, method, args);\n \n@@ -173,8 +173,8 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n \n                             // => <expr>.field(\"field_name\", field)\n                             let method_name = make::name_ref(\"field\");\n-                            let name = make::expr_literal(&(format!(\"\\\"{}\\\"\", field_name))).into();\n-                            let path = &format!(\"{}\", field_name);\n+                            let name = make::expr_literal(&(format!(\"\\\"{field_name}\\\"\"))).into();\n+                            let path = &format!(\"{field_name}\");\n                             let path = make::expr_path(make::ext::ident_path(path));\n                             let args = make::arg_list(vec![name, path]);\n                             expr = make::expr_method_call(expr, method_name, args);\n@@ -192,13 +192,13 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                         // => f.debug_tuple(name)\n                         let target = make::expr_path(make::ext::ident_path(\"f\"));\n                         let method = make::name_ref(\"debug_tuple\");\n-                        let struct_name = format!(\"\\\"{}\\\"\", name);\n+                        let struct_name = format!(\"\\\"{name}\\\"\");\n                         let args = make::arg_list(Some(make::expr_literal(&struct_name).into()));\n                         let mut expr = make::expr_method_call(target, method, args);\n \n                         let mut pats = vec![];\n                         for (i, _) in list.fields().enumerate() {\n-                            let name = format!(\"arg{}\", i);\n+                            let name = format!(\"arg{i}\");\n \n                             // create a field pattern for use in `MyStruct(fields..)`\n                             let field_name = make::name(&name);\n@@ -222,7 +222,7 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                         arms.push(make::match_arm(Some(pat.into()), None, expr));\n                     }\n                     None => {\n-                        let fmt_string = make::expr_literal(&(format!(\"\\\"{}\\\"\", name))).into();\n+                        let fmt_string = make::expr_literal(&(format!(\"\\\"{name}\\\"\"))).into();\n                         let args = make::arg_list([target, fmt_string]);\n                         let macro_name = make::expr_path(make::ext::ident_path(\"write\"));\n                         let macro_call = make::expr_macro_call(macro_name, args);\n@@ -244,7 +244,7 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n         }\n \n         ast::Adt::Struct(strukt) => {\n-            let name = format!(\"\\\"{}\\\"\", annotated_name);\n+            let name = format!(\"\\\"{annotated_name}\\\"\");\n             let args = make::arg_list(Some(make::expr_literal(&name).into()));\n             let target = make::expr_path(make::ext::ident_path(\"f\"));\n \n@@ -258,10 +258,10 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                     let mut expr = make::expr_method_call(target, method, args);\n                     for field in field_list.fields() {\n                         let name = field.name()?;\n-                        let f_name = make::expr_literal(&(format!(\"\\\"{}\\\"\", name))).into();\n+                        let f_name = make::expr_literal(&(format!(\"\\\"{name}\\\"\"))).into();\n                         let f_path = make::expr_path(make::ext::ident_path(\"self\"));\n                         let f_path = make::expr_ref(f_path, false);\n-                        let f_path = make::expr_field(f_path, &format!(\"{}\", name));\n+                        let f_path = make::expr_field(f_path, &format!(\"{name}\"));\n                         let args = make::arg_list([f_name, f_path]);\n                         expr = make::expr_method_call(expr, make::name_ref(\"field\"), args);\n                     }\n@@ -275,7 +275,7 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                     for (i, _) in field_list.fields().enumerate() {\n                         let f_path = make::expr_path(make::ext::ident_path(\"self\"));\n                         let f_path = make::expr_ref(f_path, false);\n-                        let f_path = make::expr_field(f_path, &format!(\"{}\", i));\n+                        let f_path = make::expr_field(f_path, &format!(\"{i}\"));\n                         let method = make::name_ref(\"field\");\n                         expr = make::expr_method_call(expr, method, make::arg_list(Some(f_path)));\n                     }\n@@ -379,7 +379,7 @@ fn gen_hash_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                 let mut stmts = vec![];\n                 for (i, _) in field_list.fields().enumerate() {\n                     let base = make::expr_path(make::ext::ident_path(\"self\"));\n-                    let target = make::expr_field(base, &format!(\"{}\", i));\n+                    let target = make::expr_field(base, &format!(\"{i}\"));\n                     stmts.push(gen_hash_call(target));\n                 }\n                 make::block_expr(stmts, None).indent(ast::edit::IndentLevel(1))\n@@ -453,10 +453,10 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                         for field in list.fields() {\n                             let field_name = field.name()?.to_string();\n \n-                            let l_name = &format!(\"l_{}\", field_name);\n+                            let l_name = &format!(\"l_{field_name}\");\n                             l_fields.push(gen_record_pat_field(&field_name, l_name));\n \n-                            let r_name = &format!(\"r_{}\", field_name);\n+                            let r_name = &format!(\"r_{field_name}\");\n                             r_fields.push(gen_record_pat_field(&field_name, r_name));\n \n                             let lhs = make::expr_path(make::ext::ident_path(l_name));\n@@ -484,12 +484,12 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                         let mut r_fields = vec![];\n \n                         for (i, _) in list.fields().enumerate() {\n-                            let field_name = format!(\"{}\", i);\n+                            let field_name = format!(\"{i}\");\n \n-                            let l_name = format!(\"l{}\", field_name);\n+                            let l_name = format!(\"l{field_name}\");\n                             l_fields.push(gen_tuple_field(&l_name));\n \n-                            let r_name = format!(\"r{}\", field_name);\n+                            let r_name = format!(\"r{field_name}\");\n                             r_fields.push(gen_tuple_field(&r_name));\n \n                             let lhs = make::expr_path(make::ext::ident_path(&l_name));\n@@ -548,7 +548,7 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n             Some(ast::FieldList::TupleFieldList(field_list)) => {\n                 let mut expr = None;\n                 for (i, _) in field_list.fields().enumerate() {\n-                    let idx = format!(\"{}\", i);\n+                    let idx = format!(\"{i}\");\n                     let lhs = make::expr_path(make::ext::ident_path(\"self\"));\n                     let lhs = make::expr_field(lhs, &idx);\n                     let rhs = make::expr_path(make::ext::ident_path(\"other\"));\n@@ -628,7 +628,7 @@ fn gen_partial_ord(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n             Some(ast::FieldList::TupleFieldList(field_list)) => {\n                 let mut exprs = vec![];\n                 for (i, _) in field_list.fields().enumerate() {\n-                    let idx = format!(\"{}\", i);\n+                    let idx = format!(\"{i}\");\n                     let lhs = make::expr_path(make::ext::ident_path(\"self\"));\n                     let lhs = make::expr_field(lhs, &idx);\n                     let rhs = make::expr_path(make::ext::ident_path(\"other\"));"}]}