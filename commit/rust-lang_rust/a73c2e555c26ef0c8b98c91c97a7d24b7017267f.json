{"sha": "a73c2e555c26ef0c8b98c91c97a7d24b7017267f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3M2MyZTU1NWMyNmVmMGM4Yjk4YzkxYzk3YTdkMjRiNzAxNzI2N2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-06T20:55:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-06T20:55:36Z"}, "message": "Auto merge of #80883 - GuillaumeGomez:remove-some-function-fields, r=ollie27\n\nRemove some function fields\n\nSame kind as #80845.\n\nThis PR removes the `all_types` and `ret_types` from the `clean::Function` type.\n\nAnother change that I had to do was implementing the `From` trait to be able to convert `hir::def::DefKind` into `clean::TypeKind` without requiring `DocContext` (and so I updated the `clean` method so that it's taken into account).\n\nThe last two commits improve a bit the `get_real_types` function and the `Type::generics` method.\n\nr? `@jyn514`", "tree": {"sha": "96373010f49cc4ff16ed9a4ab5aa38ee8ddd1d5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96373010f49cc4ff16ed9a4ab5aa38ee8ddd1d5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a73c2e555c26ef0c8b98c91c97a7d24b7017267f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a73c2e555c26ef0c8b98c91c97a7d24b7017267f", "html_url": "https://github.com/rust-lang/rust/commit/a73c2e555c26ef0c8b98c91c97a7d24b7017267f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a73c2e555c26ef0c8b98c91c97a7d24b7017267f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a1d6174c925f54c923599e29b09d6855e6b3a78", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a1d6174c925f54c923599e29b09d6855e6b3a78", "html_url": "https://github.com/rust-lang/rust/commit/9a1d6174c925f54c923599e29b09d6855e6b3a78"}, {"sha": "c92b161df0a42b613e2d8975b8aa1dd49497aaec", "url": "https://api.github.com/repos/rust-lang/rust/commits/c92b161df0a42b613e2d8975b8aa1dd49497aaec", "html_url": "https://github.com/rust-lang/rust/commit/c92b161df0a42b613e2d8975b8aa1dd49497aaec"}], "stats": {"total": 466, "additions": 246, "deletions": 220}, "files": [{"sha": "cdff37cbd51f4e828649c9c6dcf639bb2397907f", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a73c2e555c26ef0c8b98c91c97a7d24b7017267f/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73c2e555c26ef0c8b98c91c97a7d24b7017267f/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=a73c2e555c26ef0c8b98c91c97a7d24b7017267f", "patch": "@@ -217,13 +217,10 @@ fn build_external_function(cx: &DocContext<'_>, did: DefId) -> clean::Function {\n     let (generics, decl) = clean::enter_impl_trait(cx, || {\n         ((cx.tcx.generics_of(did), predicates).clean(cx), (did, sig).clean(cx))\n     });\n-    let (all_types, ret_types) = clean::get_all_types(&generics, &decl, cx);\n     clean::Function {\n         decl,\n         generics,\n         header: hir::FnHeader { unsafety: sig.unsafety(), abi: sig.abi(), constness, asyncness },\n-        all_types,\n-        ret_types,\n     }\n }\n "}, {"sha": "331bb2a73f962f8fa87abc70c51f37b8d8edd8dd", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 28, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a73c2e555c26ef0c8b98c91c97a7d24b7017267f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73c2e555c26ef0c8b98c91c97a7d24b7017267f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=a73c2e555c26ef0c8b98c91c97a7d24b7017267f", "patch": "@@ -928,8 +928,7 @@ impl<'a> Clean<Function> for (&'a hir::FnSig<'a>, &'a hir::Generics<'a>, hir::Bo\n     fn clean(&self, cx: &DocContext<'_>) -> Function {\n         let (generics, decl) =\n             enter_impl_trait(cx, || (self.1.clean(cx), (&*self.0.decl, self.2).clean(cx)));\n-        let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n-        Function { decl, generics, header: self.0.header, all_types, ret_types }\n+        Function { decl, generics, header: self.0.header }\n     }\n }\n \n@@ -1043,21 +1042,7 @@ impl Clean<PolyTrait> for hir::PolyTraitRef<'_> {\n \n impl Clean<TypeKind> for hir::def::DefKind {\n     fn clean(&self, _: &DocContext<'_>) -> TypeKind {\n-        match *self {\n-            hir::def::DefKind::Mod => TypeKind::Module,\n-            hir::def::DefKind::Struct => TypeKind::Struct,\n-            hir::def::DefKind::Union => TypeKind::Union,\n-            hir::def::DefKind::Enum => TypeKind::Enum,\n-            hir::def::DefKind::Trait => TypeKind::Trait,\n-            hir::def::DefKind::TyAlias => TypeKind::Typedef,\n-            hir::def::DefKind::ForeignTy => TypeKind::Foreign,\n-            hir::def::DefKind::TraitAlias => TypeKind::TraitAlias,\n-            hir::def::DefKind::Fn => TypeKind::Function,\n-            hir::def::DefKind::Const => TypeKind::Const,\n-            hir::def::DefKind::Static => TypeKind::Static,\n-            hir::def::DefKind::Macro(_) => TypeKind::Macro,\n-            _ => TypeKind::Foreign,\n-        }\n+        (*self).into()\n     }\n }\n \n@@ -1082,9 +1067,7 @@ impl Clean<Item> for hir::TraitItem<'_> {\n                     let (generics, decl) = enter_impl_trait(cx, || {\n                         (self.generics.clean(cx), (&*sig.decl, &names[..]).clean(cx))\n                     });\n-                    let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n-                    let mut t =\n-                        Function { header: sig.header, decl, generics, all_types, ret_types };\n+                    let mut t = Function { header: sig.header, decl, generics };\n                     if t.header.constness == hir::Constness::Const\n                         && is_unstable_const_fn(cx.tcx, local_did).is_some()\n                     {\n@@ -1196,7 +1179,6 @@ impl Clean<Item> for ty::AssocItem {\n                     ty::ImplContainer(_) => true,\n                     ty::TraitContainer(_) => self.defaultness.has_value(),\n                 };\n-                let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n                 if provided {\n                     let constness = if is_min_const_fn(cx.tcx, self.def_id) {\n                         hir::Constness::Const\n@@ -1218,8 +1200,6 @@ impl Clean<Item> for ty::AssocItem {\n                                 constness,\n                                 asyncness,\n                             },\n-                            all_types,\n-                            ret_types,\n                         },\n                         defaultness,\n                     )\n@@ -1233,8 +1213,6 @@ impl Clean<Item> for ty::AssocItem {\n                             constness: hir::Constness::NotConst,\n                             asyncness: hir::IsAsync::NotAsync,\n                         },\n-                        all_types,\n-                        ret_types,\n                     })\n                 }\n             }\n@@ -2274,7 +2252,6 @@ impl Clean<Item> for (&hir::ForeignItem<'_>, Option<Symbol>) {\n                     let (generics, decl) = enter_impl_trait(cx, || {\n                         (generics.clean(cx), (&**decl, &names[..]).clean(cx))\n                     });\n-                    let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n                     ForeignFunctionItem(Function {\n                         decl,\n                         generics,\n@@ -2284,8 +2261,6 @@ impl Clean<Item> for (&hir::ForeignItem<'_>, Option<Symbol>) {\n                             constness: hir::Constness::NotConst,\n                             asyncness: hir::IsAsync::NotAsync,\n                         },\n-                        all_types,\n-                        ret_types,\n                     })\n                 }\n                 hir::ForeignItemKind::Static(ref ty, mutability) => ForeignStaticItem(Static {"}, {"sha": "754f1c2eeeb21c0b6609457fd227ee895d597524", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 39, "deletions": 4, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a73c2e555c26ef0c8b98c91c97a7d24b7017267f/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73c2e555c26ef0c8b98c91c97a7d24b7017267f/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=a73c2e555c26ef0c8b98c91c97a7d24b7017267f", "patch": "@@ -1087,8 +1087,6 @@ crate struct Function {\n     crate decl: FnDecl,\n     crate generics: Generics,\n     crate header: hir::FnHeader,\n-    crate all_types: Vec<(Type, TypeKind)>,\n-    crate ret_types: Vec<(Type, TypeKind)>,\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n@@ -1304,6 +1302,43 @@ crate enum TypeKind {\n     Primitive,\n }\n \n+impl From<hir::def::DefKind> for TypeKind {\n+    fn from(other: hir::def::DefKind) -> Self {\n+        match other {\n+            hir::def::DefKind::Enum => Self::Enum,\n+            hir::def::DefKind::Fn => Self::Function,\n+            hir::def::DefKind::Mod => Self::Module,\n+            hir::def::DefKind::Const => Self::Const,\n+            hir::def::DefKind::Static => Self::Static,\n+            hir::def::DefKind::Struct => Self::Struct,\n+            hir::def::DefKind::Union => Self::Union,\n+            hir::def::DefKind::Trait => Self::Trait,\n+            hir::def::DefKind::TyAlias => Self::Typedef,\n+            hir::def::DefKind::TraitAlias => Self::TraitAlias,\n+            hir::def::DefKind::Macro(_) => Self::Macro,\n+            hir::def::DefKind::ForeignTy\n+            | hir::def::DefKind::Variant\n+            | hir::def::DefKind::AssocTy\n+            | hir::def::DefKind::TyParam\n+            | hir::def::DefKind::ConstParam\n+            | hir::def::DefKind::Ctor(..)\n+            | hir::def::DefKind::AssocFn\n+            | hir::def::DefKind::AssocConst\n+            | hir::def::DefKind::ExternCrate\n+            | hir::def::DefKind::Use\n+            | hir::def::DefKind::ForeignMod\n+            | hir::def::DefKind::AnonConst\n+            | hir::def::DefKind::OpaqueTy\n+            | hir::def::DefKind::Field\n+            | hir::def::DefKind::LifetimeParam\n+            | hir::def::DefKind::GlobalAsm\n+            | hir::def::DefKind::Impl\n+            | hir::def::DefKind::Closure\n+            | hir::def::DefKind::Generator => Self::Foreign,\n+        }\n+    }\n+}\n+\n crate trait GetDefId {\n     /// Use this method to get the [`DefId`] of a [`clean`] AST node.\n     /// This will return [`None`] when called on a primitive [`clean::Type`].\n@@ -1367,14 +1402,14 @@ impl Type {\n         }\n     }\n \n-    crate fn generics(&self) -> Option<Vec<Type>> {\n+    crate fn generics(&self) -> Option<Vec<&Type>> {\n         match *self {\n             ResolvedPath { ref path, .. } => path.segments.last().and_then(|seg| {\n                 if let GenericArgs::AngleBracketed { ref args, .. } = seg.args {\n                     Some(\n                         args.iter()\n                             .filter_map(|arg| match arg {\n-                                GenericArg::Type(ty) => Some(ty.clone()),\n+                                GenericArg::Type(ty) => Some(ty),\n                                 _ => None,\n                             })\n                             .collect(),"}, {"sha": "2c829c49953ff606ddd4c2815a92f09f9c8250b0", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 3, "deletions": 123, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/a73c2e555c26ef0c8b98c91c97a7d24b7017267f/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73c2e555c26ef0c8b98c91c97a7d24b7017267f/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=a73c2e555c26ef0c8b98c91c97a7d24b7017267f", "patch": "@@ -1,10 +1,9 @@\n use crate::clean::auto_trait::AutoTraitFinder;\n use crate::clean::blanket_impl::BlanketImplFinder;\n use crate::clean::{\n-    inline, Clean, Crate, ExternalCrate, FnDecl, FnRetTy, Generic, GenericArg, GenericArgs,\n-    GenericBound, Generics, GetDefId, ImportSource, Item, ItemKind, Lifetime, MacroKind, Path,\n-    PathSegment, Primitive, PrimitiveType, ResolvedPath, Type, TypeBinding, TypeKind,\n-    WherePredicate,\n+    inline, Clean, Crate, ExternalCrate, Generic, GenericArg, GenericArgs, ImportSource, Item,\n+    ItemKind, Lifetime, MacroKind, Path, PathSegment, Primitive, PrimitiveType, ResolvedPath, Type,\n+    TypeBinding, TypeKind,\n };\n use crate::core::DocContext;\n \n@@ -160,125 +159,6 @@ pub(super) fn external_path(\n     }\n }\n \n-/// The point of this function is to replace bounds with types.\n-///\n-/// i.e. `[T, U]` when you have the following bounds: `T: Display, U: Option<T>` will return\n-/// `[Display, Option]` (we just returns the list of the types, we don't care about the\n-/// wrapped types in here).\n-crate fn get_real_types(\n-    generics: &Generics,\n-    arg: &Type,\n-    cx: &DocContext<'_>,\n-    recurse: i32,\n-) -> FxHashSet<(Type, TypeKind)> {\n-    fn insert(res: &mut FxHashSet<(Type, TypeKind)>, cx: &DocContext<'_>, ty: Type) {\n-        if let Some(kind) = ty.def_id().map(|did| cx.tcx.def_kind(did).clean(cx)) {\n-            res.insert((ty, kind));\n-        } else if ty.is_primitive() {\n-            // This is a primitive, let's store it as such.\n-            res.insert((ty, TypeKind::Primitive));\n-        }\n-    }\n-    let mut res = FxHashSet::default();\n-    if recurse >= 10 {\n-        // FIXME: remove this whole recurse thing when the recursion bug is fixed\n-        return res;\n-    }\n-\n-    if arg.is_full_generic() {\n-        let arg_s = Symbol::intern(&arg.print(&cx.cache).to_string());\n-        if let Some(where_pred) = generics.where_predicates.iter().find(|g| match g {\n-            WherePredicate::BoundPredicate { ty, .. } => ty.def_id() == arg.def_id(),\n-            _ => false,\n-        }) {\n-            let bounds = where_pred.get_bounds().unwrap_or_else(|| &[]);\n-            for bound in bounds.iter() {\n-                if let GenericBound::TraitBound(poly_trait, _) = bound {\n-                    for x in poly_trait.generic_params.iter() {\n-                        if !x.is_type() {\n-                            continue;\n-                        }\n-                        if let Some(ty) = x.get_type() {\n-                            let adds = get_real_types(generics, &ty, cx, recurse + 1);\n-                            if !adds.is_empty() {\n-                                res.extend(adds);\n-                            } else if !ty.is_full_generic() {\n-                                insert(&mut res, cx, ty);\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        if let Some(bound) = generics.params.iter().find(|g| g.is_type() && g.name == arg_s) {\n-            for bound in bound.get_bounds().unwrap_or_else(|| &[]) {\n-                if let Some(ty) = bound.get_trait_type() {\n-                    let adds = get_real_types(generics, &ty, cx, recurse + 1);\n-                    if !adds.is_empty() {\n-                        res.extend(adds);\n-                    } else if !ty.is_full_generic() {\n-                        insert(&mut res, cx, ty);\n-                    }\n-                }\n-            }\n-        }\n-    } else {\n-        insert(&mut res, cx, arg.clone());\n-        if let Some(gens) = arg.generics() {\n-            for gen in gens.iter() {\n-                if gen.is_full_generic() {\n-                    let adds = get_real_types(generics, gen, cx, recurse + 1);\n-                    if !adds.is_empty() {\n-                        res.extend(adds);\n-                    }\n-                } else {\n-                    insert(&mut res, cx, gen.clone());\n-                }\n-            }\n-        }\n-    }\n-    res\n-}\n-\n-/// Return the full list of types when bounds have been resolved.\n-///\n-/// i.e. `fn foo<A: Display, B: Option<A>>(x: u32, y: B)` will return\n-/// `[u32, Display, Option]`.\n-crate fn get_all_types(\n-    generics: &Generics,\n-    decl: &FnDecl,\n-    cx: &DocContext<'_>,\n-) -> (Vec<(Type, TypeKind)>, Vec<(Type, TypeKind)>) {\n-    let mut all_types = FxHashSet::default();\n-    for arg in decl.inputs.values.iter() {\n-        if arg.type_.is_self_type() {\n-            continue;\n-        }\n-        let args = get_real_types(generics, &arg.type_, cx, 0);\n-        if !args.is_empty() {\n-            all_types.extend(args);\n-        } else {\n-            if let Some(kind) = arg.type_.def_id().map(|did| cx.tcx.def_kind(did).clean(cx)) {\n-                all_types.insert((arg.type_.clone(), kind));\n-            }\n-        }\n-    }\n-\n-    let ret_types = match decl.output {\n-        FnRetTy::Return(ref return_type) => {\n-            let mut ret = get_real_types(generics, &return_type, cx, 0);\n-            if ret.is_empty() {\n-                if let Some(kind) = return_type.def_id().map(|did| cx.tcx.def_kind(did).clean(cx)) {\n-                    ret.insert((return_type.clone(), kind));\n-                }\n-            }\n-            ret.into_iter().collect()\n-        }\n-        _ => Vec::new(),\n-    };\n-    (all_types.into_iter().collect(), ret_types)\n-}\n-\n crate fn strip_type(ty: Type) -> Type {\n     match ty {\n         Type::ResolvedPath { path, param_names, did, is_generic } => {"}, {"sha": "ce1204c7be19cbc9c8d68855893b765dadf9aab1", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 59, "deletions": 46, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/a73c2e555c26ef0c8b98c91c97a7d24b7017267f/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73c2e555c26ef0c8b98c91c97a7d24b7017267f/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=a73c2e555c26ef0c8b98c91c97a7d24b7017267f", "patch": "@@ -5,6 +5,7 @@ use std::path::{Path, PathBuf};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX};\n use rustc_middle::middle::privacy::AccessLevels;\n+use rustc_middle::ty::TyCtxt;\n use rustc_span::source_map::FileName;\n use rustc_span::Symbol;\n \n@@ -121,13 +122,21 @@ crate struct Cache {\n     crate aliases: BTreeMap<String, Vec<usize>>,\n }\n \n+/// This struct is used to wrap the `cache` and `tcx` in order to run `DocFolder`.\n+struct CacheBuilder<'a, 'tcx> {\n+    cache: &'a mut Cache,\n+    empty_cache: Cache,\n+    tcx: TyCtxt<'tcx>,\n+}\n+\n impl Cache {\n-    crate fn from_krate(\n+    crate fn from_krate<'tcx>(\n         render_info: RenderInfo,\n         document_private: bool,\n         extern_html_root_urls: &BTreeMap<String, String>,\n         dst: &Path,\n         mut krate: clean::Crate,\n+        tcx: TyCtxt<'tcx>,\n     ) -> (clean::Crate, Cache) {\n         // Crawl the crate to build various caches used for the output\n         let RenderInfo {\n@@ -194,7 +203,8 @@ impl Cache {\n \n         cache.stack.push(krate.name.to_string());\n \n-        krate = cache.fold_crate(krate);\n+        krate = CacheBuilder { tcx, cache: &mut cache, empty_cache: Cache::default() }\n+            .fold_crate(krate);\n \n         for (trait_did, dids, impl_) in cache.orphan_trait_impls.drain(..) {\n             if cache.traits.contains_key(&trait_did) {\n@@ -208,7 +218,7 @@ impl Cache {\n     }\n }\n \n-impl DocFolder for Cache {\n+impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n         if item.def_id.is_local() {\n             debug!(\"folding {} \\\"{:?}\\\", id {:?}\", item.type_(), item.name, item.def_id);\n@@ -218,17 +228,17 @@ impl DocFolder for Cache {\n         // we don't want it or its children in the search index.\n         let orig_stripped_mod = match *item.kind {\n             clean::StrippedItem(box clean::ModuleItem(..)) => {\n-                mem::replace(&mut self.stripped_mod, true)\n+                mem::replace(&mut self.cache.stripped_mod, true)\n             }\n-            _ => self.stripped_mod,\n+            _ => self.cache.stripped_mod,\n         };\n \n         // If the impl is from a masked crate or references something from a\n         // masked crate then remove it completely.\n         if let clean::ImplItem(ref i) = *item.kind {\n-            if self.masked_crates.contains(&item.def_id.krate)\n-                || i.trait_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate))\n-                || i.for_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate))\n+            if self.cache.masked_crates.contains(&item.def_id.krate)\n+                || i.trait_.def_id().map_or(false, |d| self.cache.masked_crates.contains(&d.krate))\n+                || i.for_.def_id().map_or(false, |d| self.cache.masked_crates.contains(&d.krate))\n             {\n                 return None;\n             }\n@@ -237,14 +247,15 @@ impl DocFolder for Cache {\n         // Propagate a trait method's documentation to all implementors of the\n         // trait.\n         if let clean::TraitItem(ref t) = *item.kind {\n-            self.traits.entry(item.def_id).or_insert_with(|| t.clone());\n+            self.cache.traits.entry(item.def_id).or_insert_with(|| t.clone());\n         }\n \n         // Collect all the implementors of traits.\n         if let clean::ImplItem(ref i) = *item.kind {\n             if let Some(did) = i.trait_.def_id() {\n                 if i.blanket_impl.is_none() {\n-                    self.implementors\n+                    self.cache\n+                        .implementors\n                         .entry(did)\n                         .or_default()\n                         .push(Impl { impl_item: item.clone() });\n@@ -257,7 +268,7 @@ impl DocFolder for Cache {\n             let (parent, is_inherent_impl_item) = match *item.kind {\n                 clean::StrippedItem(..) => ((None, None), false),\n                 clean::AssocConstItem(..) | clean::TypedefItem(_, true)\n-                    if self.parent_is_trait_impl =>\n+                    if self.cache.parent_is_trait_impl =>\n                 {\n                     // skip associated items in trait impls\n                     ((None, None), false)\n@@ -267,18 +278,18 @@ impl DocFolder for Cache {\n                 | clean::StructFieldItem(..)\n                 | clean::VariantItem(..) => (\n                     (\n-                        Some(*self.parent_stack.last().expect(\"parent_stack is empty\")),\n-                        Some(&self.stack[..self.stack.len() - 1]),\n+                        Some(*self.cache.parent_stack.last().expect(\"parent_stack is empty\")),\n+                        Some(&self.cache.stack[..self.cache.stack.len() - 1]),\n                     ),\n                     false,\n                 ),\n                 clean::MethodItem(..) | clean::AssocConstItem(..) => {\n-                    if self.parent_stack.is_empty() {\n+                    if self.cache.parent_stack.is_empty() {\n                         ((None, None), false)\n                     } else {\n-                        let last = self.parent_stack.last().expect(\"parent_stack is empty 2\");\n+                        let last = self.cache.parent_stack.last().expect(\"parent_stack is empty 2\");\n                         let did = *last;\n-                        let path = match self.paths.get(&did) {\n+                        let path = match self.cache.paths.get(&did) {\n                             // The current stack not necessarily has correlation\n                             // for where the type was defined. On the other\n                             // hand, `paths` always has the right\n@@ -290,24 +301,24 @@ impl DocFolder for Cache {\n                                 | ItemType::Union\n                                 | ItemType::Enum,\n                             )) => Some(&fqp[..fqp.len() - 1]),\n-                            Some(..) => Some(&*self.stack),\n+                            Some(..) => Some(&*self.cache.stack),\n                             None => None,\n                         };\n                         ((Some(*last), path), true)\n                     }\n                 }\n-                _ => ((None, Some(&*self.stack)), false),\n+                _ => ((None, Some(&*self.cache.stack)), false),\n             };\n \n             match parent {\n-                (parent, Some(path)) if is_inherent_impl_item || !self.stripped_mod => {\n+                (parent, Some(path)) if is_inherent_impl_item || !self.cache.stripped_mod => {\n                     debug_assert!(!item.is_stripped());\n \n                     // A crate has a module at its root, containing all items,\n                     // which should not be indexed. The crate-item itself is\n                     // inserted later on when serializing the search-index.\n                     if item.def_id.index != CRATE_DEF_INDEX {\n-                        self.search_index.push(IndexItem {\n+                        self.cache.search_index.push(IndexItem {\n                             ty: item.type_(),\n                             name: s.to_string(),\n                             path: path.join(\"::\"),\n@@ -316,21 +327,22 @@ impl DocFolder for Cache {\n                                 .map_or_else(String::new, |x| short_markdown_summary(&x.as_str())),\n                             parent,\n                             parent_idx: None,\n-                            search_type: get_index_search_type(&item, None),\n+                            search_type: get_index_search_type(&item, &self.empty_cache, self.tcx),\n                         });\n \n                         for alias in item.attrs.get_doc_aliases() {\n-                            self.aliases\n+                            self.cache\n+                                .aliases\n                                 .entry(alias.to_lowercase())\n                                 .or_insert(Vec::new())\n-                                .push(self.search_index.len() - 1);\n+                                .push(self.cache.search_index.len() - 1);\n                         }\n                     }\n                 }\n                 (Some(parent), None) if is_inherent_impl_item => {\n                     // We have a parent, but we don't know where they're\n                     // defined yet. Wait for later to index this item.\n-                    self.orphan_impl_items.push((parent, item.clone()));\n+                    self.cache.orphan_impl_items.push((parent, item.clone()));\n                 }\n                 _ => {}\n             }\n@@ -339,7 +351,7 @@ impl DocFolder for Cache {\n         // Keep track of the fully qualified path for this item.\n         let pushed = match item.name {\n             Some(n) if !n.is_empty() => {\n-                self.stack.push(n.to_string());\n+                self.cache.stack.push(n.to_string());\n                 true\n             }\n             _ => false,\n@@ -361,54 +373,54 @@ impl DocFolder for Cache {\n             | clean::MacroItem(..)\n             | clean::ProcMacroItem(..)\n             | clean::VariantItem(..)\n-                if !self.stripped_mod =>\n+                if !self.cache.stripped_mod =>\n             {\n                 // Re-exported items mean that the same id can show up twice\n                 // in the rustdoc ast that we're looking at. We know,\n                 // however, that a re-exported item doesn't show up in the\n                 // `public_items` map, so we can skip inserting into the\n                 // paths map if there was already an entry present and we're\n                 // not a public item.\n-                if !self.paths.contains_key(&item.def_id)\n-                    || self.access_levels.is_public(item.def_id)\n+                if !self.cache.paths.contains_key(&item.def_id)\n+                    || self.cache.access_levels.is_public(item.def_id)\n                 {\n-                    self.paths.insert(item.def_id, (self.stack.clone(), item.type_()));\n+                    self.cache.paths.insert(item.def_id, (self.cache.stack.clone(), item.type_()));\n                 }\n             }\n             clean::PrimitiveItem(..) => {\n-                self.paths.insert(item.def_id, (self.stack.clone(), item.type_()));\n+                self.cache.paths.insert(item.def_id, (self.cache.stack.clone(), item.type_()));\n             }\n \n             _ => {}\n         }\n \n         // Maintain the parent stack\n-        let orig_parent_is_trait_impl = self.parent_is_trait_impl;\n+        let orig_parent_is_trait_impl = self.cache.parent_is_trait_impl;\n         let parent_pushed = match *item.kind {\n             clean::TraitItem(..)\n             | clean::EnumItem(..)\n             | clean::ForeignTypeItem\n             | clean::StructItem(..)\n             | clean::UnionItem(..)\n             | clean::VariantItem(..) => {\n-                self.parent_stack.push(item.def_id);\n-                self.parent_is_trait_impl = false;\n+                self.cache.parent_stack.push(item.def_id);\n+                self.cache.parent_is_trait_impl = false;\n                 true\n             }\n             clean::ImplItem(ref i) => {\n-                self.parent_is_trait_impl = i.trait_.is_some();\n+                self.cache.parent_is_trait_impl = i.trait_.is_some();\n                 match i.for_ {\n                     clean::ResolvedPath { did, .. } => {\n-                        self.parent_stack.push(did);\n+                        self.cache.parent_stack.push(did);\n                         true\n                     }\n                     ref t => {\n                         let prim_did = t\n                             .primitive_type()\n-                            .and_then(|t| self.primitive_locations.get(&t).cloned());\n+                            .and_then(|t| self.cache.primitive_locations.get(&t).cloned());\n                         match prim_did {\n                             Some(did) => {\n-                                self.parent_stack.push(did);\n+                                self.cache.parent_stack.push(did);\n                                 true\n                             }\n                             None => false,\n@@ -433,8 +445,9 @@ impl DocFolder for Cache {\n                     dids.insert(did);\n                 }\n                 ref t => {\n-                    let did =\n-                        t.primitive_type().and_then(|t| self.primitive_locations.get(&t).cloned());\n+                    let did = t\n+                        .primitive_type()\n+                        .and_then(|t| self.cache.primitive_locations.get(&t).cloned());\n \n                     if let Some(did) = did {\n                         dids.insert(did);\n@@ -450,27 +463,27 @@ impl DocFolder for Cache {\n                 }\n             }\n             let impl_item = Impl { impl_item: item };\n-            if impl_item.trait_did().map_or(true, |d| self.traits.contains_key(&d)) {\n+            if impl_item.trait_did().map_or(true, |d| self.cache.traits.contains_key(&d)) {\n                 for did in dids {\n-                    self.impls.entry(did).or_insert(vec![]).push(impl_item.clone());\n+                    self.cache.impls.entry(did).or_insert(vec![]).push(impl_item.clone());\n                 }\n             } else {\n                 let trait_did = impl_item.trait_did().expect(\"no trait did\");\n-                self.orphan_trait_impls.push((trait_did, dids, impl_item));\n+                self.cache.orphan_trait_impls.push((trait_did, dids, impl_item));\n             }\n             None\n         } else {\n             Some(item)\n         };\n \n         if pushed {\n-            self.stack.pop().expect(\"stack already empty\");\n+            self.cache.stack.pop().expect(\"stack already empty\");\n         }\n         if parent_pushed {\n-            self.parent_stack.pop().expect(\"parent stack already empty\");\n+            self.cache.parent_stack.pop().expect(\"parent stack already empty\");\n         }\n-        self.stripped_mod = orig_stripped_mod;\n-        self.parent_is_trait_impl = orig_parent_is_trait_impl;\n+        self.cache.stripped_mod = orig_stripped_mod;\n+        self.cache.parent_is_trait_impl = orig_parent_is_trait_impl;\n         ret\n     }\n }"}, {"sha": "6437ba45511a1f04c5688056c76d00a758e413aa", "filename": "src/librustdoc/formats/renderer.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a73c2e555c26ef0c8b98c91c97a7d24b7017267f/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73c2e555c26ef0c8b98c91c97a7d24b7017267f/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Frenderer.rs?ref=a73c2e555c26ef0c8b98c91c97a7d24b7017267f", "patch": "@@ -61,6 +61,7 @@ crate fn run_format<'tcx, T: FormatRenderer<'tcx>>(\n             &options.extern_html_root_urls,\n             &options.output,\n             krate,\n+            tcx,\n         )\n     });\n     let prof = &tcx.sess.prof;"}, {"sha": "a21cf5266fe1ffacfe4fdaa781735f44cefeb68f", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 138, "deletions": 13, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/a73c2e555c26ef0c8b98c91c97a7d24b7017267f/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73c2e555c26ef0c8b98c91c97a7d24b7017267f/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=a73c2e555c26ef0c8b98c91c97a7d24b7017267f", "patch": "@@ -1,11 +1,14 @@\n use std::collections::BTreeMap;\n use std::path::Path;\n \n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::{sym, Symbol};\n use serde::Serialize;\n \n-use crate::clean::types::GetDefId;\n+use crate::clean::types::{\n+    FnDecl, FnRetTy, GenericBound, Generics, GetDefId, Type, TypeKind, WherePredicate,\n+};\n use crate::clean::{self, AttributesExt};\n use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n@@ -62,7 +65,7 @@ crate fn extern_location(\n }\n \n /// Builds the search index from the collected metadata\n-crate fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n+crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<'tcx>) -> String {\n     let mut defid_to_pathid = FxHashMap::default();\n     let mut crate_items = Vec::with_capacity(cache.search_index.len());\n     let mut crate_paths = vec![];\n@@ -78,7 +81,7 @@ crate fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n                 desc: item.doc_value().map_or_else(String::new, |s| short_markdown_summary(&s)),\n                 parent: Some(did),\n                 parent_idx: None,\n-                search_type: get_index_search_type(&item, Some(cache)),\n+                search_type: get_index_search_type(&item, cache, tcx),\n             });\n             for alias in item.attrs.get_doc_aliases() {\n                 cache\n@@ -164,14 +167,15 @@ crate fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     )\n }\n \n-crate fn get_index_search_type(\n+crate fn get_index_search_type<'tcx>(\n     item: &clean::Item,\n-    cache: Option<&Cache>,\n+    cache: &Cache,\n+    tcx: TyCtxt<'tcx>,\n ) -> Option<IndexItemFunctionType> {\n     let (all_types, ret_types) = match *item.kind {\n-        clean::FunctionItem(ref f) => (&f.all_types, &f.ret_types),\n-        clean::MethodItem(ref m, _) => (&m.all_types, &m.ret_types),\n-        clean::TyMethodItem(ref m) => (&m.all_types, &m.ret_types),\n+        clean::FunctionItem(ref f) => get_all_types(&f.generics, &f.decl, tcx),\n+        clean::MethodItem(ref m, _) => get_all_types(&m.generics, &m.decl, tcx),\n+        clean::TyMethodItem(ref m) => get_all_types(&m.generics, &m.decl, tcx),\n         _ => return None,\n     };\n \n@@ -190,9 +194,9 @@ crate fn get_index_search_type(\n     Some(IndexItemFunctionType { inputs, output })\n }\n \n-fn get_index_type(clean_type: &clean::Type, cache: &Option<&Cache>) -> RenderType {\n+fn get_index_type(clean_type: &clean::Type, cache: &Cache) -> RenderType {\n     RenderType {\n-        ty: cache.map_or_else(|| clean_type.def_id(), |cache| clean_type.def_id_full(cache)),\n+        ty: clean_type.def_id_full(cache),\n         idx: None,\n         name: get_index_type_name(clean_type, true).map(|s| s.as_str().to_ascii_lowercase()),\n         generics: get_generics(clean_type, cache),\n@@ -227,18 +231,139 @@ fn get_index_type_name(clean_type: &clean::Type, accept_generic: bool) -> Option\n     }\n }\n \n-fn get_generics(clean_type: &clean::Type, cache: &Option<&Cache>) -> Option<Vec<Generic>> {\n+fn get_generics(clean_type: &clean::Type, cache: &Cache) -> Option<Vec<Generic>> {\n     clean_type.generics().and_then(|types| {\n         let r = types\n             .iter()\n             .filter_map(|t| {\n                 get_index_type_name(t, false).map(|name| Generic {\n                     name: name.as_str().to_ascii_lowercase(),\n-                    defid: cache.map_or_else(|| t.def_id(), |cache| t.def_id_full(cache)),\n+                    defid: t.def_id_full(cache),\n                     idx: None,\n                 })\n             })\n             .collect::<Vec<_>>();\n         if r.is_empty() { None } else { Some(r) }\n     })\n }\n+\n+/// The point of this function is to replace bounds with types.\n+///\n+/// i.e. `[T, U]` when you have the following bounds: `T: Display, U: Option<T>` will return\n+/// `[Display, Option]` (we just returns the list of the types, we don't care about the\n+/// wrapped types in here).\n+crate fn get_real_types<'tcx>(\n+    generics: &Generics,\n+    arg: &Type,\n+    tcx: TyCtxt<'tcx>,\n+    recurse: i32,\n+    res: &mut FxHashSet<(Type, TypeKind)>,\n+) -> usize {\n+    fn insert(res: &mut FxHashSet<(Type, TypeKind)>, tcx: TyCtxt<'_>, ty: Type) -> usize {\n+        if let Some(kind) = ty.def_id().map(|did| tcx.def_kind(did).into()) {\n+            res.insert((ty, kind));\n+            1\n+        } else if ty.is_primitive() {\n+            // This is a primitive, let's store it as such.\n+            res.insert((ty, TypeKind::Primitive));\n+            1\n+        } else {\n+            0\n+        }\n+    }\n+\n+    if recurse >= 10 {\n+        // FIXME: remove this whole recurse thing when the recursion bug is fixed\n+        return 0;\n+    }\n+    let mut nb_added = 0;\n+\n+    if let &Type::Generic(arg_s) = arg {\n+        if let Some(where_pred) = generics.where_predicates.iter().find(|g| match g {\n+            WherePredicate::BoundPredicate { ty, .. } => ty.def_id() == arg.def_id(),\n+            _ => false,\n+        }) {\n+            let bounds = where_pred.get_bounds().unwrap_or_else(|| &[]);\n+            for bound in bounds.iter() {\n+                if let GenericBound::TraitBound(poly_trait, _) = bound {\n+                    for x in poly_trait.generic_params.iter() {\n+                        if !x.is_type() {\n+                            continue;\n+                        }\n+                        if let Some(ty) = x.get_type() {\n+                            let adds = get_real_types(generics, &ty, tcx, recurse + 1, res);\n+                            nb_added += adds;\n+                            if adds == 0 && !ty.is_full_generic() {\n+                                nb_added += insert(res, tcx, ty);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        if let Some(bound) = generics.params.iter().find(|g| g.is_type() && g.name == arg_s) {\n+            for bound in bound.get_bounds().unwrap_or(&[]) {\n+                if let Some(ty) = bound.get_trait_type() {\n+                    let adds = get_real_types(generics, &ty, tcx, recurse + 1, res);\n+                    nb_added += adds;\n+                    if adds == 0 && !ty.is_full_generic() {\n+                        nb_added += insert(res, tcx, ty);\n+                    }\n+                }\n+            }\n+        }\n+    } else {\n+        nb_added += insert(res, tcx, arg.clone());\n+        if let Some(gens) = arg.generics() {\n+            for gen in gens.iter() {\n+                if gen.is_full_generic() {\n+                    nb_added += get_real_types(generics, gen, tcx, recurse + 1, res);\n+                } else {\n+                    nb_added += insert(res, tcx, (*gen).clone());\n+                }\n+            }\n+        }\n+    }\n+    nb_added\n+}\n+\n+/// Return the full list of types when bounds have been resolved.\n+///\n+/// i.e. `fn foo<A: Display, B: Option<A>>(x: u32, y: B)` will return\n+/// `[u32, Display, Option]`.\n+crate fn get_all_types<'tcx>(\n+    generics: &Generics,\n+    decl: &FnDecl,\n+    tcx: TyCtxt<'tcx>,\n+) -> (Vec<(Type, TypeKind)>, Vec<(Type, TypeKind)>) {\n+    let mut all_types = FxHashSet::default();\n+    for arg in decl.inputs.values.iter() {\n+        if arg.type_.is_self_type() {\n+            continue;\n+        }\n+        let mut args = FxHashSet::default();\n+        get_real_types(generics, &arg.type_, tcx, 0, &mut args);\n+        if !args.is_empty() {\n+            all_types.extend(args);\n+        } else {\n+            if let Some(kind) = arg.type_.def_id().map(|did| tcx.def_kind(did).into()) {\n+                all_types.insert((arg.type_.clone(), kind));\n+            }\n+        }\n+    }\n+\n+    let ret_types = match decl.output {\n+        FnRetTy::Return(ref return_type) => {\n+            let mut ret = FxHashSet::default();\n+            get_real_types(generics, &return_type, tcx, 0, &mut ret);\n+            if ret.is_empty() {\n+                if let Some(kind) = return_type.def_id().map(|did| tcx.def_kind(did).into()) {\n+                    ret.insert((return_type.clone(), kind));\n+                }\n+            }\n+            ret.into_iter().collect()\n+        }\n+        _ => Vec::new(),\n+    };\n+    (all_types.into_iter().collect(), ret_types)\n+}"}, {"sha": "16366d7b1310e4060dba4559c3f46fb87a765e97", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a73c2e555c26ef0c8b98c91c97a7d24b7017267f/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73c2e555c26ef0c8b98c91c97a7d24b7017267f/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=a73c2e555c26ef0c8b98c91c97a7d24b7017267f", "patch": "@@ -499,7 +499,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n         krate = sources::render(&dst, &mut scx, krate)?;\n \n         // Build our search index\n-        let index = build_index(&krate, &mut cache);\n+        let index = build_index(&krate, &mut cache, tcx);\n \n         let mut cx = Context {\n             current: Vec::new(),"}, {"sha": "9107ba59bd01305d9681162e2ab2acfc294e30f6", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a73c2e555c26ef0c8b98c91c97a7d24b7017267f/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73c2e555c26ef0c8b98c91c97a7d24b7017267f/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=a73c2e555c26ef0c8b98c91c97a7d24b7017267f", "patch": "@@ -238,7 +238,7 @@ fn stringify_header(header: &rustc_hir::FnHeader) -> String {\n \n impl From<clean::Function> for Function {\n     fn from(function: clean::Function) -> Self {\n-        let clean::Function { decl, generics, header, all_types: _, ret_types: _ } = function;\n+        let clean::Function { decl, generics, header } = function;\n         Function {\n             decl: decl.into(),\n             generics: generics.into(),\n@@ -435,7 +435,7 @@ impl From<clean::Impl> for Impl {\n }\n \n crate fn from_function_method(function: clean::Function, has_body: bool) -> Method {\n-    let clean::Function { header, decl, generics, all_types: _, ret_types: _ } = function;\n+    let clean::Function { header, decl, generics } = function;\n     Method {\n         decl: decl.into(),\n         generics: generics.into(),"}]}