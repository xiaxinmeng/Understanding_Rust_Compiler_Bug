{"sha": "d469e0de9acc38b2e63796fb105369e567773cfb", "node_id": "C_kwDOAAsO6NoAKGQ0NjllMGRlOWFjYzM4YjJlNjM3OTZmYjEwNTM2OWU1Njc3NzNjZmI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-22T20:35:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-22T20:35:31Z"}, "message": "Auto merge of #12840 - Veykril:be-lazy, r=Veykril\n\ninternal: Use ItemTree for variant, field and module attribute collection in attrs_query\n\nLess parsing = very good, should speed up lang item collection as that basically probes attributes of all enum variants which currently triggers parsing\n\nNot fond of how this is searching for the correct index, ideally we'd map between HIR and item tree Id here but I am not sure how, storing the item tree ids in the HIR version doesn't work due to the usage of `Trace`...", "tree": {"sha": "3d8865389fe0dd636eaf226044cdfb5b671a50aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d8865389fe0dd636eaf226044cdfb5b671a50aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d469e0de9acc38b2e63796fb105369e567773cfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d469e0de9acc38b2e63796fb105369e567773cfb", "html_url": "https://github.com/rust-lang/rust/commit/d469e0de9acc38b2e63796fb105369e567773cfb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d469e0de9acc38b2e63796fb105369e567773cfb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e30ca1f2a3782246a530bc279eb3df1c3048d37", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e30ca1f2a3782246a530bc279eb3df1c3048d37", "html_url": "https://github.com/rust-lang/rust/commit/7e30ca1f2a3782246a530bc279eb3df1c3048d37"}, {"sha": "0081ef383489679e491d99a1978ded16e06906d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/0081ef383489679e491d99a1978ded16e06906d3", "html_url": "https://github.com/rust-lang/rust/commit/0081ef383489679e491d99a1978ded16e06906d3"}], "stats": {"total": 300, "additions": 183, "deletions": 117}, "files": [{"sha": "277135d6dc4288798700d48e66712f5add18cc6f", "filename": "crates/hir-def/src/adt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d469e0de9acc38b2e63796fb105369e567773cfb/crates%2Fhir-def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d469e0de9acc38b2e63796fb105369e567773cfb/crates%2Fhir-def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fadt.rs?ref=d469e0de9acc38b2e63796fb105369e567773cfb", "patch": "@@ -136,9 +136,9 @@ impl EnumData {\n \n         let enum_ = &item_tree[loc.id.value];\n         let mut variants = Arena::new();\n-        for var_id in enum_.variants.clone() {\n-            if item_tree.attrs(db, krate, var_id.into()).is_cfg_enabled(&cfg_options) {\n-                let var = &item_tree[var_id];\n+        for tree_id in enum_.variants.clone() {\n+            if item_tree.attrs(db, krate, tree_id.into()).is_cfg_enabled(&cfg_options) {\n+                let var = &item_tree[tree_id];\n                 let var_data = lower_fields(\n                     db,\n                     krate,"}, {"sha": "8a6b6f3effd2ed33e6f121a79f8bf816688b8125", "filename": "crates/hir-def/src/attr.rs", "status": "modified", "additions": 105, "deletions": 43, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/d469e0de9acc38b2e63796fb105369e567773cfb/crates%2Fhir-def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d469e0de9acc38b2e63796fb105369e567773cfb/crates%2Fhir-def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fattr.rs?ref=d469e0de9acc38b2e63796fb105369e567773cfb", "patch": "@@ -7,7 +7,7 @@ use cfg::{CfgExpr, CfgOptions};\n use either::Either;\n use hir_expand::{hygiene::Hygiene, name::AsName, HirFileId, InFile};\n use itertools::Itertools;\n-use la_arena::ArenaMap;\n+use la_arena::{ArenaMap, Idx, RawIdx};\n use mbe::{syntax_node_to_token_tree, DelimiterKind, Punct};\n use smallvec::{smallvec, SmallVec};\n use syntax::{\n@@ -19,12 +19,12 @@ use tt::Subtree;\n use crate::{\n     db::DefDatabase,\n     intern::Interned,\n-    item_tree::{ItemTreeId, ItemTreeNode},\n-    nameres::ModuleSource,\n+    item_tree::{AttrOwner, Fields, ItemTreeId, ItemTreeNode},\n+    nameres::{ModuleOrigin, ModuleSource},\n     path::{ModPath, PathKind},\n     src::{HasChildSource, HasSource},\n-    AdtId, AttrDefId, EnumId, GenericParamId, HasModule, LocalEnumVariantId, LocalFieldId, Lookup,\n-    MacroId, VariantId,\n+    AdtId, AttrDefId, EnumId, GenericParamId, LocalEnumVariantId, LocalFieldId, Lookup, MacroId,\n+    VariantId,\n };\n \n /// Holds documentation\n@@ -201,15 +201,23 @@ impl Attrs {\n         db: &dyn DefDatabase,\n         e: EnumId,\n     ) -> Arc<ArenaMap<LocalEnumVariantId, Attrs>> {\n-        let krate = e.lookup(db).container.krate;\n-        let src = e.child_source(db);\n+        // FIXME: There should be some proper form of mapping between item tree enum variant ids and hir enum variant ids\n         let mut res = ArenaMap::default();\n \n-        for (id, var) in src.value.iter() {\n-            let attrs = RawAttrs::from_attrs_owner(db, src.with_value(var as &dyn ast::HasAttrs))\n-                .filter(db, krate);\n-\n-            res.insert(id, attrs)\n+        let loc = e.lookup(db);\n+        let krate = loc.container.krate;\n+        let item_tree = loc.id.item_tree(db);\n+        let enum_ = &item_tree[loc.id.value];\n+        let crate_graph = db.crate_graph();\n+        let cfg_options = &crate_graph[krate].cfg_options;\n+\n+        let mut idx = 0;\n+        for variant in enum_.variants.clone() {\n+            let attrs = item_tree.attrs(db, krate, variant.into());\n+            if attrs.is_cfg_enabled(cfg_options) {\n+                res.insert(Idx::from_raw(RawIdx::from(idx)), attrs);\n+                idx += 1;\n+            }\n         }\n \n         Arc::new(res)\n@@ -219,18 +227,64 @@ impl Attrs {\n         db: &dyn DefDatabase,\n         v: VariantId,\n     ) -> Arc<ArenaMap<LocalFieldId, Attrs>> {\n-        let krate = v.module(db).krate;\n-        let src = v.child_source(db);\n+        // FIXME: There should be some proper form of mapping between item tree field ids and hir field ids\n         let mut res = ArenaMap::default();\n \n-        for (id, fld) in src.value.iter() {\n-            let owner: &dyn HasAttrs = match fld {\n-                Either::Left(tuple) => tuple,\n-                Either::Right(record) => record,\n-            };\n-            let attrs = RawAttrs::from_attrs_owner(db, src.with_value(owner)).filter(db, krate);\n+        let crate_graph = db.crate_graph();\n+        let (fields, item_tree, krate) = match v {\n+            VariantId::EnumVariantId(it) => {\n+                let e = it.parent;\n+                let loc = e.lookup(db);\n+                let krate = loc.container.krate;\n+                let item_tree = loc.id.item_tree(db);\n+                let enum_ = &item_tree[loc.id.value];\n+\n+                let cfg_options = &crate_graph[krate].cfg_options;\n+                let variant = 'tri: loop {\n+                    let mut idx = 0;\n+                    for variant in enum_.variants.clone() {\n+                        let attrs = item_tree.attrs(db, krate, variant.into());\n+                        if attrs.is_cfg_enabled(cfg_options) {\n+                            if it.local_id == Idx::from_raw(RawIdx::from(idx)) {\n+                                break 'tri variant;\n+                            }\n+                            idx += 1;\n+                        }\n+                    }\n+                    return Arc::new(res);\n+                };\n+                (item_tree[variant].fields.clone(), item_tree, krate)\n+            }\n+            VariantId::StructId(it) => {\n+                let loc = it.lookup(db);\n+                let krate = loc.container.krate;\n+                let item_tree = loc.id.item_tree(db);\n+                let struct_ = &item_tree[loc.id.value];\n+                (struct_.fields.clone(), item_tree, krate)\n+            }\n+            VariantId::UnionId(it) => {\n+                let loc = it.lookup(db);\n+                let krate = loc.container.krate;\n+                let item_tree = loc.id.item_tree(db);\n+                let union_ = &item_tree[loc.id.value];\n+                (union_.fields.clone(), item_tree, krate)\n+            }\n+        };\n \n-            res.insert(id, attrs);\n+        let fields = match fields {\n+            Fields::Record(fields) | Fields::Tuple(fields) => fields,\n+            Fields::Unit => return Arc::new(res),\n+        };\n+\n+        let cfg_options = &crate_graph[krate].cfg_options;\n+\n+        let mut idx = 0;\n+        for field in fields {\n+            let attrs = item_tree.attrs(db, krate, field.into());\n+            if attrs.is_cfg_enabled(cfg_options) {\n+                res.insert(Idx::from_raw(RawIdx::from(idx)), attrs);\n+                idx += 1;\n+            }\n         }\n \n         Arc::new(res)\n@@ -243,11 +297,14 @@ impl Attrs {\n \n impl Attrs {\n     pub fn cfg(&self) -> Option<CfgExpr> {\n-        let mut cfgs = self.by_key(\"cfg\").tt_values().map(CfgExpr::parse).collect::<Vec<_>>();\n-        match cfgs.len() {\n-            0 => None,\n-            1 => Some(cfgs.pop().unwrap()),\n-            _ => Some(CfgExpr::All(cfgs)),\n+        let mut cfgs = self.by_key(\"cfg\").tt_values().map(CfgExpr::parse);\n+        let first = cfgs.next()?;\n+        match cfgs.next() {\n+            Some(second) => {\n+                let cfgs = [first, second].into_iter().chain(cfgs);\n+                Some(CfgExpr::All(cfgs.collect()))\n+            }\n+            None => Some(first),\n         }\n     }\n     pub(crate) fn is_cfg_enabled(&self, cfg_options: &CfgOptions) -> bool {\n@@ -315,25 +372,30 @@ impl AttrsWithOwner {\n             AttrDefId::ModuleId(module) => {\n                 let def_map = module.def_map(db);\n                 let mod_data = &def_map[module.local_id];\n-                match mod_data.declaration_source(db) {\n-                    Some(it) => {\n-                        let raw_attrs = RawAttrs::from_attrs_owner(\n-                            db,\n-                            it.as_ref().map(|it| it as &dyn ast::HasAttrs),\n-                        );\n-                        match mod_data.definition_source(db) {\n-                            InFile { file_id, value: ModuleSource::SourceFile(file) } => raw_attrs\n-                                .merge(RawAttrs::from_attrs_owner(db, InFile::new(file_id, &file))),\n-                            _ => raw_attrs,\n-                        }\n+\n+                match mod_data.origin {\n+                    ModuleOrigin::File { definition, declaration_tree_id, .. } => {\n+                        let decl_attrs = declaration_tree_id\n+                            .item_tree(db)\n+                            .raw_attrs(AttrOwner::ModItem(declaration_tree_id.value.into()))\n+                            .clone();\n+                        let tree = db.file_item_tree(definition.into());\n+                        let def_attrs = tree.raw_attrs(AttrOwner::TopLevel).clone();\n+                        decl_attrs.merge(def_attrs)\n+                    }\n+                    ModuleOrigin::CrateRoot { definition } => {\n+                        let tree = db.file_item_tree(definition.into());\n+                        tree.raw_attrs(AttrOwner::TopLevel).clone()\n                     }\n-                    None => RawAttrs::from_attrs_owner(\n+                    ModuleOrigin::Inline { definition_tree_id, .. } => definition_tree_id\n+                        .item_tree(db)\n+                        .raw_attrs(AttrOwner::ModItem(definition_tree_id.value.into()))\n+                        .clone(),\n+                    ModuleOrigin::BlockExpr { block } => RawAttrs::from_attrs_owner(\n                         db,\n-                        mod_data.definition_source(db).as_ref().map(|src| match src {\n-                            ModuleSource::SourceFile(file) => file as &dyn ast::HasAttrs,\n-                            ModuleSource::Module(module) => module as &dyn ast::HasAttrs,\n-                            ModuleSource::BlockExpr(block) => block as &dyn ast::HasAttrs,\n-                        }),\n+                        InFile::new(block.file_id, block.to_node(db.upcast()))\n+                            .as_ref()\n+                            .map(|it| it as &dyn ast::HasAttrs),\n                     ),\n                 }\n             }"}, {"sha": "4309411419334d4a3bf358f96d15bf145aa07c5c", "filename": "crates/hir-def/src/data.rs", "status": "modified", "additions": 54, "deletions": 63, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/d469e0de9acc38b2e63796fb105369e567773cfb/crates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d469e0de9acc38b2e63796fb105369e567773cfb/crates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdata.rs?ref=d469e0de9acc38b2e63796fb105369e567773cfb", "patch": "@@ -1,22 +1,23 @@\n //! Contains basic data about various HIR declarations.\n \n-use std::{mem, sync::Arc};\n+use std::sync::Arc;\n \n-use hir_expand::{name::Name, AstId, ExpandResult, HirFileId, InFile, MacroCallId, MacroDefKind};\n+use hir_expand::{name::Name, AstId, ExpandResult, HirFileId, MacroCallId, MacroDefKind};\n+use smallvec::SmallVec;\n use syntax::ast;\n \n use crate::{\n     attr::Attrs,\n     body::{Expander, Mark},\n     db::DefDatabase,\n     intern::Interned,\n-    item_tree::{self, AssocItem, FnFlags, ItemTreeId, ModItem, Param, TreeId},\n+    item_tree::{self, AssocItem, FnFlags, ItemTree, ItemTreeId, ModItem, Param, TreeId},\n     nameres::{attr_resolution::ResolvedAttr, DefMap},\n     type_ref::{TraitRef, TypeBound, TypeRef},\n     visibility::RawVisibility,\n     AssocItemId, AstIdWithPath, ConstId, ConstLoc, FunctionId, FunctionLoc, HasModule, ImplId,\n-    Intern, ItemContainerId, Lookup, Macro2Id, MacroRulesId, ModuleId, ProcMacroId, StaticId,\n-    TraitId, TypeAliasId, TypeAliasLoc,\n+    Intern, ItemContainerId, ItemLoc, Lookup, Macro2Id, MacroRulesId, ModuleId, ProcMacroId,\n+    StaticId, TraitId, TypeAliasId, TypeAliasLoc,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -209,35 +210,31 @@ pub struct TraitData {\n \n impl TraitData {\n     pub(crate) fn trait_data_query(db: &dyn DefDatabase, tr: TraitId) -> Arc<TraitData> {\n-        let tr_loc = tr.lookup(db);\n-        let item_tree = tr_loc.id.item_tree(db);\n-        let tr_def = &item_tree[tr_loc.id.value];\n+        let tr_loc @ ItemLoc { container: module_id, id: tree_id } = tr.lookup(db);\n+        let item_tree = tree_id.item_tree(db);\n+        let tr_def = &item_tree[tree_id.value];\n         let _cx = stdx::panic_context::enter(format!(\n             \"trait_data_query({:?} -> {:?} -> {:?})\",\n             tr, tr_loc, tr_def\n         ));\n         let name = tr_def.name.clone();\n         let is_auto = tr_def.is_auto;\n         let is_unsafe = tr_def.is_unsafe;\n-        let module_id = tr_loc.container;\n         let visibility = item_tree[tr_def.visibility].clone();\n         let skip_array_during_method_dispatch = item_tree\n-            .attrs(db, tr_loc.container.krate(), ModItem::from(tr_loc.id.value).into())\n+            .attrs(db, module_id.krate(), ModItem::from(tree_id.value).into())\n             .by_key(\"rustc_skip_array_during_method_dispatch\")\n             .exists();\n \n-        let mut collector = AssocItemCollector::new(\n-            db,\n-            module_id,\n-            tr_loc.id.file_id(),\n-            ItemContainerId::TraitId(tr),\n-        );\n-        collector.collect(tr_loc.id.tree_id(), &tr_def.items);\n+        let mut collector =\n+            AssocItemCollector::new(db, module_id, tree_id.file_id(), ItemContainerId::TraitId(tr));\n+        collector.collect(&item_tree, tree_id.tree_id(), &tr_def.items);\n+        let (items, attribute_calls) = collector.finish();\n \n         Arc::new(TraitData {\n             name,\n-            attribute_calls: collector.take_attr_calls(),\n-            items: collector.items,\n+            attribute_calls,\n+            items,\n             is_auto,\n             is_unsafe,\n             visibility,\n@@ -284,25 +281,20 @@ pub struct ImplData {\n impl ImplData {\n     pub(crate) fn impl_data_query(db: &dyn DefDatabase, id: ImplId) -> Arc<ImplData> {\n         let _p = profile::span(\"impl_data_query\");\n-        let impl_loc = id.lookup(db);\n+        let ItemLoc { container: module_id, id: tree_id } = id.lookup(db);\n \n-        let item_tree = impl_loc.id.item_tree(db);\n-        let impl_def = &item_tree[impl_loc.id.value];\n+        let item_tree = tree_id.item_tree(db);\n+        let impl_def = &item_tree[tree_id.value];\n         let target_trait = impl_def.target_trait.clone();\n         let self_ty = impl_def.self_ty.clone();\n         let is_negative = impl_def.is_negative;\n-        let module_id = impl_loc.container;\n \n-        let mut collector = AssocItemCollector::new(\n-            db,\n-            module_id,\n-            impl_loc.id.file_id(),\n-            ItemContainerId::ImplId(id),\n-        );\n-        collector.collect(impl_loc.id.tree_id(), &impl_def.items);\n+        let mut collector =\n+            AssocItemCollector::new(db, module_id, tree_id.file_id(), ItemContainerId::ImplId(id));\n+        collector.collect(&item_tree, tree_id.tree_id(), &impl_def.items);\n \n-        let attribute_calls = collector.take_attr_calls();\n-        let items = collector.items.into_iter().map(|(_, item)| item).collect();\n+        let (items, attribute_calls) = collector.finish();\n+        let items = items.into_iter().map(|(_, item)| item).collect();\n \n         Arc::new(ImplData { target_trait, self_ty, items, is_negative, attribute_calls })\n     }\n@@ -463,18 +455,19 @@ impl<'a> AssocItemCollector<'a> {\n         }\n     }\n \n-    fn take_attr_calls(&mut self) -> Option<Box<Vec<(AstId<ast::Item>, MacroCallId)>>> {\n-        let attribute_calls = mem::take(&mut self.attr_calls);\n-        if attribute_calls.is_empty() {\n-            None\n-        } else {\n-            Some(Box::new(attribute_calls))\n-        }\n+    fn finish(\n+        self,\n+    ) -> (Vec<(Name, AssocItemId)>, Option<Box<Vec<(AstId<ast::Item>, MacroCallId)>>>) {\n+        (\n+            self.items,\n+            if self.attr_calls.is_empty() { None } else { Some(Box::new(self.attr_calls)) },\n+        )\n     }\n \n     // FIXME: proc-macro diagnostics\n-    fn collect(&mut self, tree_id: TreeId, assoc_items: &[AssocItem]) {\n-        let item_tree = tree_id.item_tree(self.db);\n+    fn collect(&mut self, item_tree: &ItemTree, tree_id: TreeId, assoc_items: &[AssocItem]) {\n+        let container = self.container;\n+        self.items.reserve(assoc_items.len());\n \n         'items: for &item in assoc_items {\n             let attrs = item_tree.attrs(self.db, self.module_id.krate, ModItem::from(item).into());\n@@ -509,9 +502,9 @@ impl<'a> AssocItemCollector<'a> {\n                             continue 'attrs;\n                         }\n                     }\n-                    match self.expander.enter_expand_id(self.db, call_id) {\n-                        ExpandResult { value: Some((mark, mac)), .. } => {\n-                            self.collect_macro_items(mark, mac);\n+                    match self.expander.enter_expand_id::<ast::MacroItems>(self.db, call_id) {\n+                        ExpandResult { value: Some((mark, _)), .. } => {\n+                            self.collect_macro_items(mark);\n                             continue 'items;\n                         }\n                         ExpandResult { .. } => {}\n@@ -522,59 +515,57 @@ impl<'a> AssocItemCollector<'a> {\n             match item {\n                 AssocItem::Function(id) => {\n                     let item = &item_tree[id];\n+\n                     let def =\n-                        FunctionLoc { container: self.container, id: ItemTreeId::new(tree_id, id) }\n-                            .intern(self.db);\n+                        FunctionLoc { container, id: ItemTreeId::new(tree_id, id) }.intern(self.db);\n                     self.items.push((item.name.clone(), def.into()));\n                 }\n                 AssocItem::Const(id) => {\n                     let item = &item_tree[id];\n+\n                     let name = match item.name.clone() {\n                         Some(name) => name,\n                         None => continue,\n                     };\n                     let def =\n-                        ConstLoc { container: self.container, id: ItemTreeId::new(tree_id, id) }\n-                            .intern(self.db);\n+                        ConstLoc { container, id: ItemTreeId::new(tree_id, id) }.intern(self.db);\n                     self.items.push((name, def.into()));\n                 }\n                 AssocItem::TypeAlias(id) => {\n                     let item = &item_tree[id];\n-                    let def = TypeAliasLoc {\n-                        container: self.container,\n-                        id: ItemTreeId::new(tree_id, id),\n-                    }\n-                    .intern(self.db);\n+\n+                    let def = TypeAliasLoc { container, id: ItemTreeId::new(tree_id, id) }\n+                        .intern(self.db);\n                     self.items.push((item.name.clone(), def.into()));\n                 }\n                 AssocItem::MacroCall(call) => {\n-                    let call = &item_tree[call];\n-                    let ast_id_map = self.db.ast_id_map(self.expander.current_file_id());\n                     if let Some(root) = self.db.parse_or_expand(self.expander.current_file_id()) {\n+                        let call = &item_tree[call];\n+\n+                        let ast_id_map = self.db.ast_id_map(self.expander.current_file_id());\n                         let call = ast_id_map.get(call.ast_id).to_node(&root);\n                         let _cx = stdx::panic_context::enter(format!(\n                             \"collect_items MacroCall: {}\",\n                             call\n                         ));\n-                        let res = self.expander.enter_expand(self.db, call);\n+                        let res = self.expander.enter_expand::<ast::MacroItems>(self.db, call);\n \n-                        if let Ok(ExpandResult { value: Some((mark, mac)), .. }) = res {\n-                            self.collect_macro_items(mark, mac);\n+                        if let Ok(ExpandResult { value: Some((mark, _)), .. }) = res {\n+                            self.collect_macro_items(mark);\n                         }\n                     }\n                 }\n             }\n         }\n     }\n \n-    fn collect_macro_items(&mut self, mark: Mark, mac: ast::MacroItems) {\n-        let src: InFile<ast::MacroItems> = self.expander.to_source(mac);\n-        let tree_id = item_tree::TreeId::new(src.file_id, None);\n+    fn collect_macro_items(&mut self, mark: Mark) {\n+        let tree_id = item_tree::TreeId::new(self.expander.current_file_id(), None);\n         let item_tree = tree_id.item_tree(self.db);\n-        let iter: Vec<_> =\n+        let iter: SmallVec<[_; 2]> =\n             item_tree.top_level_items().iter().filter_map(ModItem::as_assoc_item).collect();\n \n-        self.collect(tree_id, &iter);\n+        self.collect(&item_tree, tree_id, &iter);\n \n         self.expander.exit(self.db, mark);\n     }"}, {"sha": "c67046dfdab55e10fdc72b8469adac10a06f8e87", "filename": "crates/hir-def/src/nameres.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d469e0de9acc38b2e63796fb105369e567773cfb/crates%2Fhir-def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d469e0de9acc38b2e63796fb105369e567773cfb/crates%2Fhir-def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres.rs?ref=d469e0de9acc38b2e63796fb105369e567773cfb", "patch": "@@ -70,7 +70,7 @@ use syntax::{ast, SmolStr};\n use crate::{\n     db::DefDatabase,\n     item_scope::{BuiltinShadowMode, ItemScope},\n-    item_tree::TreeId,\n+    item_tree::{ItemTreeId, Mod, TreeId},\n     nameres::{diagnostics::DefDiagnostic, path_resolution::ResolveMode},\n     path::ModPath,\n     per_ns::PerNs,\n@@ -141,9 +141,11 @@ pub enum ModuleOrigin {\n     File {\n         is_mod_rs: bool,\n         declaration: AstId<ast::Module>,\n+        declaration_tree_id: ItemTreeId<Mod>,\n         definition: FileId,\n     },\n     Inline {\n+        definition_tree_id: ItemTreeId<Mod>,\n         definition: AstId<ast::Module>,\n     },\n     /// Pseudo-module introduced by a block scope (contains only inner items).\n@@ -186,7 +188,7 @@ impl ModuleOrigin {\n                 let sf = db.parse(file_id).tree();\n                 InFile::new(file_id.into(), ModuleSource::SourceFile(sf))\n             }\n-            ModuleOrigin::Inline { definition } => InFile::new(\n+            ModuleOrigin::Inline { definition, .. } => InFile::new(\n                 definition.file_id,\n                 ModuleSource::Module(definition.to_node(db.upcast())),\n             ),"}, {"sha": "67651e06413ca21e95589c9eea86f2b1f794bf1b", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d469e0de9acc38b2e63796fb105369e567773cfb/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d469e0de9acc38b2e63796fb105369e567773cfb/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=d469e0de9acc38b2e63796fb105369e567773cfb", "patch": "@@ -1525,7 +1525,7 @@ impl ModCollector<'_, '_> {\n             };\n \n             match item {\n-                ModItem::Mod(m) => self.collect_module(&self.item_tree[m], &attrs),\n+                ModItem::Mod(m) => self.collect_module(m, &attrs),\n                 ModItem::Import(import_id) => {\n                     let imports = Import::from_use(\n                         db,\n@@ -1700,9 +1700,10 @@ impl ModCollector<'_, '_> {\n         }\n     }\n \n-    fn collect_module(&mut self, module: &Mod, attrs: &Attrs) {\n+    fn collect_module(&mut self, module_id: FileItemTreeId<Mod>, attrs: &Attrs) {\n         let path_attr = attrs.by_key(\"path\").string_value();\n         let is_macro_use = attrs.by_key(\"macro_use\").exists();\n+        let module = &self.item_tree[module_id];\n         match &module.kind {\n             // inline module, just recurse\n             ModKind::Inline { items } => {\n@@ -1711,6 +1712,7 @@ impl ModCollector<'_, '_> {\n                     AstId::new(self.file_id(), module.ast_id),\n                     None,\n                     &self.item_tree[module.visibility],\n+                    module_id,\n                 );\n \n                 if let Some(mod_dir) = self.mod_dir.descend_into_definition(&module.name, path_attr)\n@@ -1748,6 +1750,7 @@ impl ModCollector<'_, '_> {\n                                 ast_id,\n                                 Some((file_id, is_mod_rs)),\n                                 &self.item_tree[module.visibility],\n+                                module_id,\n                             );\n                             ModCollector {\n                                 def_collector: self.def_collector,\n@@ -1774,6 +1777,7 @@ impl ModCollector<'_, '_> {\n                             ast_id,\n                             None,\n                             &self.item_tree[module.visibility],\n+                            module_id,\n                         );\n                         self.def_collector.def_map.diagnostics.push(\n                             DefDiagnostic::unresolved_module(self.module_id, ast_id, candidates),\n@@ -1790,17 +1794,24 @@ impl ModCollector<'_, '_> {\n         declaration: AstId<ast::Module>,\n         definition: Option<(FileId, bool)>,\n         visibility: &crate::visibility::RawVisibility,\n+        mod_tree_id: FileItemTreeId<Mod>,\n     ) -> LocalModuleId {\n         let def_map = &mut self.def_collector.def_map;\n         let vis = def_map\n             .resolve_visibility(self.def_collector.db, self.module_id, visibility)\n             .unwrap_or(Visibility::Public);\n         let modules = &mut def_map.modules;\n         let origin = match definition {\n-            None => ModuleOrigin::Inline { definition: declaration },\n-            Some((definition, is_mod_rs)) => {\n-                ModuleOrigin::File { declaration, definition, is_mod_rs }\n-            }\n+            None => ModuleOrigin::Inline {\n+                definition: declaration,\n+                definition_tree_id: ItemTreeId::new(self.tree_id, mod_tree_id),\n+            },\n+            Some((definition, is_mod_rs)) => ModuleOrigin::File {\n+                declaration,\n+                definition,\n+                is_mod_rs,\n+                declaration_tree_id: ItemTreeId::new(self.tree_id, mod_tree_id),\n+            },\n         };\n \n         let res = modules.alloc(ModuleData::new(origin, vis));"}]}