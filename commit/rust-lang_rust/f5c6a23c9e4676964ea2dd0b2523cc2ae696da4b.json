{"sha": "f5c6a23c9e4676964ea2dd0b2523cc2ae696da4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1YzZhMjNjOWU0Njc2OTY0ZWEyZGQwYjI1MjNjYzJhZTY5NmRhNGI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-12T00:16:47Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-16T15:55:37Z"}, "message": "Various simplifications and renamings based on the fact that old-school closures are gone and type parameters can now have multiple region bounds (and hence use a different path). Should have no effect on the external behavior of the compiler.", "tree": {"sha": "34b28dad3343094a3a47d104471985ace2858c4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34b28dad3343094a3a47d104471985ace2858c4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5c6a23c9e4676964ea2dd0b2523cc2ae696da4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5c6a23c9e4676964ea2dd0b2523cc2ae696da4b", "html_url": "https://github.com/rust-lang/rust/commit/f5c6a23c9e4676964ea2dd0b2523cc2ae696da4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5c6a23c9e4676964ea2dd0b2523cc2ae696da4b/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "931a3c4f9df2fbf043bc30c0524bc93e1ffa397e", "url": "https://api.github.com/repos/rust-lang/rust/commits/931a3c4f9df2fbf043bc30c0524bc93e1ffa397e", "html_url": "https://github.com/rust-lang/rust/commit/931a3c4f9df2fbf043bc30c0524bc93e1ffa397e"}], "stats": {"total": 207, "additions": 94, "deletions": 113}, "files": [{"sha": "1c247f33818cfb7483352c6cd7cac0d2a1daa0d1", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 30, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f5c6a23c9e4676964ea2dd0b2523cc2ae696da4b/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5c6a23c9e4676964ea2dd0b2523cc2ae696da4b/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f5c6a23c9e4676964ea2dd0b2523cc2ae696da4b", "patch": "@@ -5896,42 +5896,13 @@ pub fn each_bound_trait_and_supertraits<'tcx, F>(tcx: &ctxt<'tcx>,\n     return true;\n }\n \n-pub fn object_region_bounds<'tcx>(\n-    tcx: &ctxt<'tcx>,\n-    opt_principal: Option<&PolyTraitRef<'tcx>>, // None for closures\n-    others: BuiltinBounds)\n-    -> Vec<ty::Region>\n-{\n-    // Since we don't actually *know* the self type for an object,\n-    // this \"open(err)\" serves as a kind of dummy standin -- basically\n-    // a skolemized type.\n-    let open_ty = ty::mk_infer(tcx, FreshTy(0));\n-\n-    let opt_trait_ref = opt_principal.map_or(Vec::new(), |principal| {\n-        // Note that we preserve the overall binding levels here.\n-        assert!(!open_ty.has_escaping_regions());\n-        let substs = tcx.mk_substs(principal.0.substs.with_self_ty(open_ty));\n-        vec!(ty::Binder(Rc::new(ty::TraitRef::new(principal.0.def_id, substs))))\n-    });\n-\n-    let param_bounds = ty::ParamBounds {\n-        region_bounds: Vec::new(),\n-        builtin_bounds: others,\n-        trait_bounds: opt_trait_ref,\n-        projection_bounds: Vec::new(), // not relevant to computing region bounds\n-    };\n-\n-    let predicates = ty::predicates(tcx, open_ty, &param_bounds);\n-    ty::required_region_bounds(tcx, open_ty, predicates)\n-}\n-\n /// Given a set of predicates that apply to an object type, returns\n /// the region bounds that the (erased) `Self` type must\n /// outlive. Precisely *because* the `Self` type is erased, the\n /// parameter `erased_self_ty` must be supplied to indicate what type\n /// has been used to represent `Self` in the predicates\n /// themselves. This should really be a unique type; `FreshTy(0)` is a\n-/// popular choice (see `object_region_bounds` above).\n+/// popular choice.\n ///\n /// Requires that trait definitions have been processed so that we can\n /// elaborate predicates and walk supertraits."}, {"sha": "ac892e64861df705a4f933386f0f2f34794d4c7d", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 70, "deletions": 64, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/f5c6a23c9e4676964ea2dd0b2523cc2ae696da4b/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5c6a23c9e4676964ea2dd0b2523cc2ae696da4b/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=f5c6a23c9e4676964ea2dd0b2523cc2ae696da4b", "patch": "@@ -55,7 +55,7 @@ use middle::resolve_lifetime as rl;\n use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs};\n use middle::traits;\n use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty};\n-use rscope::{self, UnelidableRscope, RegionScope, SpecificRscope,\n+use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope,\n              ShiftedRscope, BindingRscope};\n use TypeAndSubsts;\n use util::common::{ErrorReported, FN_OUTPUT_NAME};\n@@ -465,7 +465,7 @@ fn convert_ty_with_lifetime_elision<'tcx>(this: &AstConv<'tcx>,\n {\n     match implied_output_region {\n         Some(implied_output_region) => {\n-            let rb = SpecificRscope::new(implied_output_region);\n+            let rb = ElidableRscope::new(implied_output_region);\n             ast_ty_to_ty(this, &rb, ty)\n         }\n         None => {\n@@ -932,7 +932,7 @@ fn trait_ref_to_object_type<'tcx>(this: &AstConv<'tcx>,\n     let existential_bounds = conv_existential_bounds(this,\n                                                      rscope,\n                                                      span,\n-                                                     Some(trait_ref.clone()),\n+                                                     trait_ref.clone(),\n                                                      projection_bounds,\n                                                      bounds);\n \n@@ -1518,11 +1518,11 @@ pub fn ty_of_closure<'tcx>(\n /// `ExistentialBounds` struct. The `main_trait_refs` argument specifies the `Foo` -- it is absent\n /// for closures. Eventually this should all be normalized, I think, so that there is no \"main\n /// trait ref\" and instead we just have a flat list of bounds as the existential type.\n-pub fn conv_existential_bounds<'tcx>(\n+fn conv_existential_bounds<'tcx>(\n     this: &AstConv<'tcx>,\n     rscope: &RegionScope,\n     span: Span,\n-    principal_trait_ref: Option<ty::PolyTraitRef<'tcx>>, // None for boxed closures\n+    principal_trait_ref: ty::PolyTraitRef<'tcx>,\n     projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>,\n     ast_bounds: &[ast::TyParamBound])\n     -> ty::ExistentialBounds<'tcx>\n@@ -1546,15 +1546,15 @@ fn conv_ty_poly_trait_ref<'tcx>(\n     let mut projection_bounds = Vec::new();\n     let main_trait_bound = if !partitioned_bounds.trait_bounds.is_empty() {\n         let trait_bound = partitioned_bounds.trait_bounds.remove(0);\n-        Some(instantiate_poly_trait_ref(this,\n-                                        rscope,\n-                                        trait_bound,\n-                                        None,\n-                                        &mut projection_bounds))\n+        instantiate_poly_trait_ref(this,\n+                                   rscope,\n+                                   trait_bound,\n+                                   None,\n+                                   &mut projection_bounds)\n     } else {\n         span_err!(this.tcx().sess, span, E0224,\n-            \"at least one non-builtin trait is required for an object type\");\n-        None\n+                  \"at least one non-builtin trait is required for an object type\");\n+        return this.tcx().types.err;\n     };\n \n     let bounds =\n@@ -1565,17 +1565,14 @@ fn conv_ty_poly_trait_ref<'tcx>(\n                                                         projection_bounds,\n                                                         partitioned_bounds);\n \n-    match main_trait_bound {\n-        None => this.tcx().types.err,\n-        Some(principal) => ty::mk_trait(this.tcx(), principal, bounds)\n-    }\n+    ty::mk_trait(this.tcx(), main_trait_bound, bounds)\n }\n \n pub fn conv_existential_bounds_from_partitioned_bounds<'tcx>(\n     this: &AstConv<'tcx>,\n     rscope: &RegionScope,\n     span: Span,\n-    principal_trait_ref: Option<ty::PolyTraitRef<'tcx>>, // None for boxed closures\n+    principal_trait_ref: ty::PolyTraitRef<'tcx>,\n     mut projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>, // Empty for boxed closures\n     partitioned_bounds: PartitionedBounds)\n     -> ty::ExistentialBounds<'tcx>\n@@ -1588,16 +1585,15 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx>(\n     if !trait_bounds.is_empty() {\n         let b = &trait_bounds[0];\n         span_err!(this.tcx().sess, b.trait_ref.path.span, E0225,\n-            \"only the builtin traits can be used \\\n-                     as closure or object bounds\");\n+                  \"only the builtin traits can be used as closure or object bounds\");\n     }\n \n-    let region_bound = compute_region_bound(this,\n-                                            rscope,\n-                                            span,\n-                                            &region_bounds,\n-                                            principal_trait_ref,\n-                                            builtin_bounds);\n+    let region_bound = compute_object_lifetime_bound(this,\n+                                                     rscope,\n+                                                     span,\n+                                                     &region_bounds,\n+                                                     principal_trait_ref,\n+                                                     builtin_bounds);\n \n     ty::sort_bounds_list(&mut projection_bounds);\n \n@@ -1608,17 +1604,21 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx>(\n     }\n }\n \n-/// Given the bounds on a type parameter / existential type, determines what single region bound\n+/// Given the bounds on an object, determines what single region bound\n /// (if any) we can use to summarize this type. The basic idea is that we will use the bound the\n /// user provided, if they provided one, and otherwise search the supertypes of trait bounds for\n /// region bounds. It may be that we can derive no bound at all, in which case we return `None`.\n-fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                  span: Span,\n-                                  explicit_region_bounds: &[&ast::Lifetime],\n-                                  principal_trait_ref: Option<ty::PolyTraitRef<'tcx>>,\n-                                  builtin_bounds: ty::BuiltinBounds)\n-                                  -> Option<ty::Region>\n+fn compute_object_lifetime_bound<'tcx>(\n+    this: &AstConv<'tcx>,\n+    rscope: &RegionScope,\n+    span: Span,\n+    explicit_region_bounds: &[&ast::Lifetime],\n+    principal_trait_ref: ty::PolyTraitRef<'tcx>,\n+    builtin_bounds: ty::BuiltinBounds)\n+    -> ty::Region\n {\n+    let tcx = this.tcx();\n+\n     debug!(\"compute_opt_region_bound(explicit_region_bounds={:?}, \\\n            principal_trait_ref={}, builtin_bounds={})\",\n            explicit_region_bounds,\n@@ -1633,24 +1633,32 @@ fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n     if explicit_region_bounds.len() != 0 {\n         // Explicitly specified region bound. Use that.\n         let r = explicit_region_bounds[0];\n-        return Some(ast_region_to_region(tcx, r));\n+        return ast_region_to_region(tcx, r);\n     }\n \n     // No explicit region bound specified. Therefore, examine trait\n     // bounds and see if we can derive region bounds from those.\n     let derived_region_bounds =\n-        ty::object_region_bounds(tcx, principal_trait_ref.as_ref(), builtin_bounds);\n+        object_region_bounds(tcx, &principal_trait_ref, builtin_bounds);\n \n     // If there are no derived region bounds, then report back that we\n     // can find no region bound.\n     if derived_region_bounds.len() == 0 {\n-        return None;\n+        match rscope.object_lifetime_default(span) {\n+            Some(r) => { return r; }\n+            None => {\n+                span_err!(this.tcx().sess, span, E0228,\n+                          \"the lifetime bound for this object type cannot be deduced \\\n+                           from context; please supply an explicit bound\");\n+                return ty::ReStatic;\n+            }\n+        }\n     }\n \n     // If any of the derived region bounds are 'static, that is always\n     // the best choice.\n     if derived_region_bounds.iter().any(|r| ty::ReStatic == *r) {\n-        return Some(ty::ReStatic);\n+        return ty::ReStatic;\n     }\n \n     // Determine whether there is exactly one unique region in the set\n@@ -1659,38 +1667,36 @@ fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n     let r = derived_region_bounds[0];\n     if derived_region_bounds[1..].iter().any(|r1| r != *r1) {\n         span_err!(tcx.sess, span, E0227,\n-            \"ambiguous lifetime bound, \\\n-                     explicit lifetime bound required\");\n+                  \"ambiguous lifetime bound, explicit lifetime bound required\");\n     }\n-    return Some(r);\n+    return r;\n }\n \n-/// A version of `compute_opt_region_bound` for use where some region bound is required\n-/// (existential types, basically). Reports an error if no region bound can be derived and we are\n-/// in an `rscope` that does not provide a default.\n-fn compute_region_bound<'tcx>(\n-    this: &AstConv<'tcx>,\n-    rscope: &RegionScope,\n-    span: Span,\n-    region_bounds: &[&ast::Lifetime],\n-    principal_trait_ref: Option<ty::PolyTraitRef<'tcx>>, // None for closures\n-    builtin_bounds: ty::BuiltinBounds)\n-    -> ty::Region\n+pub fn object_region_bounds<'tcx>(\n+    tcx: &ty::ctxt<'tcx>,\n+    principal: &ty::PolyTraitRef<'tcx>,\n+    others: ty::BuiltinBounds)\n+    -> Vec<ty::Region>\n {\n-    match compute_opt_region_bound(this.tcx(), span, region_bounds,\n-                                   principal_trait_ref, builtin_bounds) {\n-        Some(r) => r,\n-        None => {\n-            match rscope.default_region_bound(span) {\n-                Some(r) => { r }\n-                None => {\n-                    span_err!(this.tcx().sess, span, E0228,\n-                        \"explicit lifetime bound required\");\n-                    ty::ReStatic\n-                }\n-            }\n-        }\n-    }\n+    // Since we don't actually *know* the self type for an object,\n+    // this \"open(err)\" serves as a kind of dummy standin -- basically\n+    // a skolemized type.\n+    let open_ty = ty::mk_infer(tcx, ty::FreshTy(0));\n+\n+    // Note that we preserve the overall binding levels here.\n+    assert!(!open_ty.has_escaping_regions());\n+    let substs = tcx.mk_substs(principal.0.substs.with_self_ty(open_ty));\n+    let trait_refs = vec!(ty::Binder(Rc::new(ty::TraitRef::new(principal.0.def_id, substs))));\n+\n+    let param_bounds = ty::ParamBounds {\n+        region_bounds: Vec::new(),\n+        builtin_bounds: others,\n+        trait_bounds: trait_refs,\n+        projection_bounds: Vec::new(), // not relevant to computing region bounds\n+    };\n+\n+    let predicates = ty::predicates(tcx, open_ty, &param_bounds);\n+    ty::required_region_bounds(tcx, open_ty, predicates)\n }\n \n pub struct PartitionedBounds<'a> {"}, {"sha": "874bd40ab9f5c2c4a1a6360c42d690a2a7ac8e0e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5c6a23c9e4676964ea2dd0b2523cc2ae696da4b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5c6a23c9e4676964ea2dd0b2523cc2ae696da4b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f5c6a23c9e4676964ea2dd0b2523cc2ae696da4b", "patch": "@@ -1890,7 +1890,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> RegionScope for FnCtxt<'a, 'tcx> {\n-    fn default_region_bound(&self, span: Span) -> Option<ty::Region> {\n+    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n         Some(self.infcx().next_region_var(infer::MiscVariable(span)))\n     }\n "}, {"sha": "209570585d29dd87d902ef621fc239821133b515", "filename": "src/librustc_typeck/check/regionmanip.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5c6a23c9e4676964ea2dd0b2523cc2ae696da4b/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5c6a23c9e4676964ea2dd0b2523cc2ae696da4b/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs?ref=f5c6a23c9e4676964ea2dd0b2523cc2ae696da4b", "patch": "@@ -12,6 +12,7 @@\n \n pub use self::WfConstraint::*;\n \n+use astconv::object_region_bounds;\n use middle::infer::GenericKind;\n use middle::subst::{ParamSpace, Subst, Substs};\n use middle::ty::{self, Ty};\n@@ -95,7 +96,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n \n             ty::ty_trait(ref t) => {\n                 let required_region_bounds =\n-                    ty::object_region_bounds(self.tcx, Some(&t.principal), t.bounds.builtin_bounds);\n+                    object_region_bounds(self.tcx, &t.principal, t.bounds.builtin_bounds);\n                 self.accumulate_from_object_ty(ty, t.bounds.region_bound, required_region_bounds)\n             }\n "}, {"sha": "c53fe91dc43c226b76171051ecffcb181b7f18e1", "filename": "src/librustc_typeck/rscope.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f5c6a23c9e4676964ea2dd0b2523cc2ae696da4b/src%2Flibrustc_typeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5c6a23c9e4676964ea2dd0b2523cc2ae696da4b/src%2Flibrustc_typeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Frscope.rs?ref=f5c6a23c9e4676964ea2dd0b2523cc2ae696da4b", "patch": "@@ -32,7 +32,10 @@ pub trait RegionScope {\n                     count: uint)\n                     -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>>;\n \n-    fn default_region_bound(&self, span: Span) -> Option<ty::Region>;\n+    /// If an object omits any explicit lifetime bound, and none can\n+    /// be derived from the object traits, what should we use? If\n+    /// `None` is returned, an explicit annotation is required.\n+    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region>;\n }\n \n // A scope in which all regions must be explicitly named. This is used\n@@ -41,7 +44,7 @@ pub trait RegionScope {\n pub struct ExplicitRscope;\n \n impl RegionScope for ExplicitRscope {\n-    fn default_region_bound(&self, _span: Span) -> Option<ty::Region> {\n+    fn object_lifetime_default(&self, _span: Span) -> Option<ty::Region> {\n         None\n     }\n \n@@ -63,7 +66,7 @@ impl UnelidableRscope {\n }\n \n impl RegionScope for UnelidableRscope {\n-    fn default_region_bound(&self, _span: Span) -> Option<ty::Region> {\n+    fn object_lifetime_default(&self, _span: Span) -> Option<ty::Region> {\n         None\n     }\n \n@@ -76,21 +79,22 @@ impl RegionScope for UnelidableRscope {\n     }\n }\n \n-// A scope in which any omitted region defaults to `default`. This is\n-// used after the `->` in function signatures, but also for backwards\n-// compatibility with object types. The latter use may go away.\n-pub struct SpecificRscope {\n-    default: ty::Region\n+// A scope in which omitted anonymous region defaults to\n+// `default`. This is used after the `->` in function signatures. The\n+// latter use may go away. Note that object-lifetime defaults work a\n+// bit differently, as specified in RFC #599.\n+pub struct ElidableRscope {\n+    default: ty::Region,\n }\n \n-impl SpecificRscope {\n-    pub fn new(r: ty::Region) -> SpecificRscope {\n-        SpecificRscope { default: r }\n+impl ElidableRscope {\n+    pub fn new(r: ty::Region) -> ElidableRscope {\n+        ElidableRscope { default: r }\n     }\n }\n \n-impl RegionScope for SpecificRscope {\n-    fn default_region_bound(&self, _span: Span) -> Option<ty::Region> {\n+impl RegionScope for ElidableRscope {\n+    fn object_lifetime_default(&self, _span: Span) -> Option<ty::Region> {\n         Some(self.default)\n     }\n \n@@ -124,7 +128,7 @@ impl BindingRscope {\n }\n \n impl RegionScope for BindingRscope {\n-    fn default_region_bound(&self, _span: Span) -> Option<ty::Region>\n+    fn object_lifetime_default(&self, _span: Span) -> Option<ty::Region>\n     {\n         Some(self.next_region())\n     }\n@@ -151,9 +155,8 @@ impl<'r> ShiftedRscope<'r> {\n }\n \n impl<'r> RegionScope for ShiftedRscope<'r> {\n-    fn default_region_bound(&self, span: Span) -> Option<ty::Region>\n-    {\n-        self.base_scope.default_region_bound(span)\n+    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n+        self.base_scope.object_lifetime_default(span)\n             .map(|r| ty_fold::shift_region(r, 1))\n     }\n "}]}