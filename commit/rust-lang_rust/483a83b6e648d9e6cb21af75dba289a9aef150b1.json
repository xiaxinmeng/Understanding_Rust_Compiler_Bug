{"sha": "483a83b6e648d9e6cb21af75dba289a9aef150b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4M2E4M2I2ZTY0OGQ5ZTZjYjIxYWY3NWRiYTI4OWE5YWVmMTUwYjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-25T22:45:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-25T22:45:50Z"}, "message": "Auto merge of #66178 - Aaron1011:fix/opaque-normalize, r=varkor\n\nFix opaque types resulting from projections in function signature\n\nWhen we normalize the types in a function signature, we may end up\nresolving a projection to an opaque type (e.g. `Self::MyType` when\nwe have `type MyType = impl SomeTrait`). When the projection is\nresolved, we will instantiate the generic parameters into fresh\ninference variables.\n\nWhile we do want to normalize projections to opaque types, we don't want\nto replace the explicit generic parameters (e.g. `T` in `impl\nMyTrait<T>`) with inference variables. We want the opaque type in the\nfunction signature to be eligible to be a defining use of that opaque\ntype - adding inference variables prevents this, since the opaque type\nsubsts now appears to refer to some specific type, rather than a generic\ntype.\n\nTo resolve this issue, we inspect the opaque types in the function\nsignature after normalization. Any inference variables in the substs are\nreplaced with the corresponding generic parameter in the identity substs\n(e.g. `T` in `impl MyTrait<T>`). Note that normalization is the only way\nthat we can end up with inference variables in opaque substs in a\nfunction signature - users have no way of getting inference variables\ninto a function signature.\n\nNote that all of this refers to the opaque type (ty::Opaque) and its\nsubst - *not* to the underlying type.\n\nFixes #59342", "tree": {"sha": "15eafda02beb085de7b362f089c626422bf7adc3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15eafda02beb085de7b362f089c626422bf7adc3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/483a83b6e648d9e6cb21af75dba289a9aef150b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/483a83b6e648d9e6cb21af75dba289a9aef150b1", "html_url": "https://github.com/rust-lang/rust/commit/483a83b6e648d9e6cb21af75dba289a9aef150b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/483a83b6e648d9e6cb21af75dba289a9aef150b1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a44774c3a9739b2eea8923e09d67b14312c78ef3", "url": "https://api.github.com/repos/rust-lang/rust/commits/a44774c3a9739b2eea8923e09d67b14312c78ef3", "html_url": "https://github.com/rust-lang/rust/commit/a44774c3a9739b2eea8923e09d67b14312c78ef3"}, {"sha": "df3f33870ad48b29a82cce524c1fa092280e76c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/df3f33870ad48b29a82cce524c1fa092280e76c8", "html_url": "https://github.com/rust-lang/rust/commit/df3f33870ad48b29a82cce524c1fa092280e76c8"}], "stats": {"total": 273, "additions": 226, "deletions": 47}, "files": [{"sha": "688523dc05b0bd7797a1070375d18a8540be0ed2", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 108, "deletions": 1, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/483a83b6e648d9e6cb21af75dba289a9aef150b1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/483a83b6e648d9e6cb21af75dba289a9aef150b1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=483a83b6e648d9e6cb21af75dba289a9aef150b1", "patch": "@@ -114,7 +114,7 @@ use rustc::ty::{\n use rustc::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability, PointerCast\n };\n-use rustc::ty::fold::TypeFoldable;\n+use rustc::ty::fold::{TypeFoldable, TypeFolder};\n use rustc::ty::query::Providers;\n use rustc::ty::subst::{\n     GenericArgKind, Subst, InternalSubsts, SubstsRef, UserSelfTy, UserSubsts,\n@@ -872,6 +872,111 @@ fn used_trait_imports(tcx: TyCtxt<'_>, def_id: DefId) -> &DefIdSet {\n     &*tcx.typeck_tables_of(def_id).used_trait_imports\n }\n \n+/// Inspects the substs of opaque types, replacing any inference variables\n+/// with proper generic parameter from the identity substs.\n+///\n+/// This is run after we normalize the function signature, to fix any inference\n+/// variables introduced by the projection of associated types. This ensures that\n+/// any opaque types used in the signature continue to refer to generic parameters,\n+/// allowing them to be considered for defining uses in the function body\n+///\n+/// For example, consider this code.\n+///\n+/// ```rust\n+/// trait MyTrait {\n+///     type MyItem;\n+///     fn use_it(self) -> Self::MyItem\n+/// }\n+/// impl<T, I> MyTrait for T where T: Iterator<Item = I> {\n+///     type MyItem = impl Iterator<Item = I>;\n+///     fn use_it(self) -> Self::MyItem {\n+///         self\n+///     }\n+/// }\n+/// ```\n+///\n+/// When we normalize the signature of `use_it` from the impl block,\n+/// we will normalize `Self::MyItem` to the opaque type `impl Iterator<Item = I>`\n+/// However, this projection result may contain inference variables, due\n+/// to the way that projection works. We didn't have any inference variables\n+/// in the signature to begin with - leaving them in will cause us to incorrectly\n+/// conclude that we don't have a defining use of `MyItem`. By mapping inference\n+/// variables back to the actual generic parameters, we will correctly see that\n+/// we have a defining use of `MyItem`\n+fn fixup_opaque_types<'tcx, T>(tcx: TyCtxt<'tcx>, val: &T) -> T where T: TypeFoldable<'tcx> {\n+    struct FixupFolder<'tcx> {\n+        tcx: TyCtxt<'tcx>\n+    }\n+\n+    impl<'tcx> TypeFolder<'tcx> for FixupFolder<'tcx> {\n+        fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n+            self.tcx\n+        }\n+\n+        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+            match ty.kind {\n+                ty::Opaque(def_id, substs) => {\n+                    debug!(\"fixup_opaque_types: found type {:?}\", ty);\n+                    // Here, we replace any inference variables that occur within\n+                    // the substs of an opaque type. By definition, any type occuring\n+                    // in the substs has a corresponding generic parameter, which is what\n+                    // we replace it with.\n+                    // This replacement is only run on the function signature, so any\n+                    // inference variables that we come across must be the rust of projection\n+                    // (there's no other way for a user to get inference variables into\n+                    // a function signature).\n+                    if ty.needs_infer() {\n+                        let new_substs = InternalSubsts::for_item(self.tcx, def_id, |param, _| {\n+                            let old_param = substs[param.index as usize];\n+                            match old_param.unpack() {\n+                                GenericArgKind::Type(old_ty) => {\n+                                    if let ty::Infer(_) = old_ty.kind {\n+                                        // Replace inference type with a generic parameter\n+                                        self.tcx.mk_param_from_def(param)\n+                                    } else {\n+                                        old_param.fold_with(self)\n+                                    }\n+                                },\n+                                GenericArgKind::Const(old_const) => {\n+                                    if let ty::ConstKind::Infer(_) = old_const.val {\n+                        // This should never happen - we currently do not support\n+                        // 'const projections', e.g.:\n+                        // `impl<T: SomeTrait> MyTrait for T where <T as SomeTrait>::MyConst == 25`\n+                        // which should be the only way for us to end up with a const inference\n+                        // variable after projection. If Rust ever gains support for this kind\n+                        // of projection, this should *probably* be changed to\n+                        // `self.tcx.mk_param_from_def(param)`\n+                                        bug!(\"Found infer const: `{:?}` in opaque type: {:?}\",\n+                                             old_const, ty);\n+                                    } else {\n+                                        old_param.fold_with(self)\n+                                    }\n+                                }\n+                                GenericArgKind::Lifetime(old_region) => {\n+                                    if let RegionKind::ReVar(_) = old_region {\n+                                        self.tcx.mk_param_from_def(param)\n+                                    } else {\n+                                        old_param.fold_with(self)\n+                                    }\n+                                }\n+                            }\n+                        });\n+                        let new_ty = self.tcx.mk_opaque(def_id, new_substs);\n+                        debug!(\"fixup_opaque_types: new type: {:?}\", new_ty);\n+                        new_ty\n+                    } else {\n+                        ty\n+                    }\n+                },\n+                _ => ty.super_fold_with(self)\n+            }\n+        }\n+    }\n+\n+    debug!(\"fixup_opaque_types({:?})\", val);\n+    val.fold_with(&mut FixupFolder { tcx })\n+}\n+\n fn typeck_tables_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::TypeckTables<'_> {\n     // Closures' tables come from their outermost function,\n     // as they are part of the same \"inference environment\".\n@@ -911,6 +1016,8 @@ fn typeck_tables_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::TypeckTables<'_> {\n                                                   param_env,\n                                                   &fn_sig);\n \n+            let fn_sig = fixup_opaque_types(tcx, &fn_sig);\n+\n             let fcx = check_fn(&inh, param_env, fn_sig, decl, id, body, None).0;\n             fcx\n         } else {"}, {"sha": "652f081e1761ca5f237c14615739325503f501f5", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/483a83b6e648d9e6cb21af75dba289a9aef150b1/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/483a83b6e648d9e6cb21af75dba289a9aef150b1/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=483a83b6e648d9e6cb21af75dba289a9aef150b1", "patch": "@@ -1617,11 +1617,18 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     ty::Param(_) => true,\n                     _ => false,\n                 };\n-                if !substs.types().all(is_param) {\n-                    self.tcx.sess.span_err(\n-                        span,\n-                        \"defining opaque type use does not fully define opaque type\",\n-                    );\n+                let bad_substs: Vec<_> = substs.types().enumerate()\n+                    .filter(|(_, ty)| !is_param(ty)).collect();\n+                if !bad_substs.is_empty() {\n+                    let identity_substs = InternalSubsts::identity_for_item(self.tcx, self.def_id);\n+                    for (i, bad_subst) in bad_substs {\n+                        self.tcx.sess.span_err(\n+                            span,\n+                            &format!(\"defining opaque type use does not fully define opaque type: \\\n+                            generic parameter `{}` is specified as concrete type `{}`\",\n+                            identity_substs.type_at(i), bad_subst)\n+                        );\n+                    }\n                 } else if let Some((prev_span, prev_ty, ref prev_indices)) = self.found {\n                     let mut ty = concrete_type.walk().fuse();\n                     let mut p_ty = prev_ty.walk().fuse();\n@@ -2059,6 +2066,9 @@ fn explicit_predicates_of(\n                 ty::print::with_no_queries(|| {\n                     let substs = InternalSubsts::identity_for_item(tcx, def_id);\n                     let opaque_ty = tcx.mk_opaque(def_id, substs);\n+                    debug!(\"explicit_predicates_of({:?}): created opaque type {:?}\",\n+                        def_id, opaque_ty);\n+\n \n                     // Collect the bounds, i.e., the `A + B + 'c` in `impl A + B + 'c`.\n                     let bounds = AstConv::compute_bounds("}, {"sha": "d834d9bb112f53ae57737bad22b32d5f851bab91", "filename": "src/test/ui/impl-trait/type-alias-generic-param.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/483a83b6e648d9e6cb21af75dba289a9aef150b1/src%2Ftest%2Fui%2Fimpl-trait%2Ftype-alias-generic-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/483a83b6e648d9e6cb21af75dba289a9aef150b1/src%2Ftest%2Fui%2Fimpl-trait%2Ftype-alias-generic-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftype-alias-generic-param.rs?ref=483a83b6e648d9e6cb21af75dba289a9aef150b1", "patch": "@@ -0,0 +1,22 @@\n+// Regression test for issue #59342\n+// Checks that we properly detect defining uses of opaque\n+// types in 'item' position when generic parameters are involved\n+//\n+// run-pass\n+#![feature(type_alias_impl_trait)]\n+\n+trait Meow {\n+    type MeowType;\n+    fn meow(self) -> Self::MeowType;\n+}\n+\n+impl<T, I> Meow for I\n+    where I: Iterator<Item = T>\n+{\n+    type MeowType = impl Iterator<Item = T>;\n+    fn meow(self) -> Self::MeowType {\n+        self\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "5db677d82e2663ae97bb51764fe3bb5b8f2220f7", "filename": "src/test/ui/type-alias-impl-trait/assoc-type-const.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/483a83b6e648d9e6cb21af75dba289a9aef150b1/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fassoc-type-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/483a83b6e648d9e6cb21af75dba289a9aef150b1/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fassoc-type-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fassoc-type-const.rs?ref=483a83b6e648d9e6cb21af75dba289a9aef150b1", "patch": "@@ -0,0 +1,36 @@\n+// Tests that we properly detect defining usages when using\n+// const generics in an associated opaque type\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+trait UnwrapItemsExt<const C: usize> {\n+    type Iter;\n+    fn unwrap_items(self) -> Self::Iter;\n+}\n+\n+struct MyStruct<const C: usize> {}\n+\n+trait MyTrait<'a, const C: usize> {\n+    type MyItem;\n+    const MY_CONST: usize;\n+}\n+\n+impl<'a, const C: usize> MyTrait<'a, {C}> for MyStruct<{C}> {\n+    type MyItem = u8;\n+    const MY_CONST: usize = C;\n+}\n+\n+impl<'a, I, const C: usize> UnwrapItemsExt<{C}> for I\n+where\n+{\n+    type Iter = impl MyTrait<'a, {C}>;\n+\n+    fn unwrap_items(self) -> Self::Iter {\n+        MyStruct::<{C}> {}\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "0adbee2f24439474c489a9be9d6183aaca2c4020", "filename": "src/test/ui/type-alias-impl-trait/assoc-type-const.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/483a83b6e648d9e6cb21af75dba289a9aef150b1/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fassoc-type-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/483a83b6e648d9e6cb21af75dba289a9aef150b1/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fassoc-type-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fassoc-type-const.stderr?ref=483a83b6e648d9e6cb21af75dba289a9aef150b1", "patch": "@@ -0,0 +1,8 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/assoc-type-const.rs:6:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+"}, {"sha": "cff1d24494e8392a4163bbee65c7c436b213cd2c", "filename": "src/test/ui/type-alias-impl-trait/assoc-type-lifetime.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/483a83b6e648d9e6cb21af75dba289a9aef150b1/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fassoc-type-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/483a83b6e648d9e6cb21af75dba289a9aef150b1/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fassoc-type-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fassoc-type-lifetime.rs?ref=483a83b6e648d9e6cb21af75dba289a9aef150b1", "patch": "@@ -0,0 +1,28 @@\n+// Tests that we still detect defining usages when\n+// lifetimes are used in an associated opaque type\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+\n+trait UnwrapItemsExt {\n+    type Iter;\n+    fn unwrap_items(self) -> Self::Iter;\n+}\n+\n+struct MyStruct {}\n+\n+trait MyTrait<'a> {}\n+\n+impl<'a> MyTrait<'a> for MyStruct {}\n+\n+impl<'a, I> UnwrapItemsExt for I\n+where\n+{\n+    type Iter = impl MyTrait<'a>;\n+\n+    fn unwrap_items(self) -> Self::Iter {\n+        MyStruct {}\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "bb22d582f21676d966b64747ec390091331e2c45", "filename": "src/test/ui/type-alias-impl-trait/bound_reduction2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/483a83b6e648d9e6cb21af75dba289a9aef150b1/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/483a83b6e648d9e6cb21af75dba289a9aef150b1/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr?ref=483a83b6e648d9e6cb21af75dba289a9aef150b1", "patch": "@@ -1,4 +1,4 @@\n-error: defining opaque type use does not fully define opaque type\n+error: defining opaque type use does not fully define opaque type: generic parameter `V` is specified as concrete type `<T as TraitWithAssoc>::Assoc`\n   --> $DIR/bound_reduction2.rs:17:1\n    |\n LL | / fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {"}, {"sha": "b952aaa79ccee7cdaaea641fd3314195bc988104", "filename": "src/test/ui/type-alias-impl-trait/generic_nondefining_use.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/483a83b6e648d9e6cb21af75dba289a9aef150b1/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/483a83b6e648d9e6cb21af75dba289a9aef150b1/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.stderr?ref=483a83b6e648d9e6cb21af75dba289a9aef150b1", "patch": "@@ -4,7 +4,7 @@ error: at least one trait must be specified\n LL | type Cmp<T> = impl 'static;\n    |               ^^^^^^^^^^^^\n \n-error: defining opaque type use does not fully define opaque type\n+error: defining opaque type use does not fully define opaque type: generic parameter `T` is specified as concrete type `u32`\n   --> $DIR/generic_nondefining_use.rs:11:1\n    |\n LL | / fn cmp() -> Cmp<u32> {"}, {"sha": "96ac7860283ac3b6f63e53dbd34def8a7095ccae", "filename": "src/test/ui/type-alias-impl-trait/issue-58887.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/483a83b6e648d9e6cb21af75dba289a9aef150b1/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-58887.rs", "raw_url": "https://github.com/rust-lang/rust/raw/483a83b6e648d9e6cb21af75dba289a9aef150b1/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-58887.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-58887.rs?ref=483a83b6e648d9e6cb21af75dba289a9aef150b1", "patch": "@@ -1,3 +1,5 @@\n+// run-pass\n+\n #![feature(type_alias_impl_trait)]\n \n trait UnwrapItemsExt {\n@@ -11,11 +13,8 @@ where\n     E: std::fmt::Debug,\n {\n     type Iter = impl Iterator<Item = T>;\n-    //~^ ERROR: could not find defining uses\n \n     fn unwrap_items(self) -> Self::Iter {\n-    //~^ ERROR: type parameter `T` is part of concrete type\n-    //~| ERROR: type parameter `E` is part of concrete type\n         self.map(|x| x.unwrap())\n     }\n }"}, {"sha": "7e2895711d34550f44fba1094e38f97adcded536", "filename": "src/test/ui/type-alias-impl-trait/issue-58887.stderr", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a44774c3a9739b2eea8923e09d67b14312c78ef3/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-58887.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a44774c3a9739b2eea8923e09d67b14312c78ef3/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-58887.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-58887.stderr?ref=a44774c3a9739b2eea8923e09d67b14312c78ef3", "patch": "@@ -1,30 +0,0 @@\n-error: type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-  --> $DIR/issue-58887.rs:16:41\n-   |\n-LL |       fn unwrap_items(self) -> Self::Iter {\n-   |  _________________________________________^\n-LL | |\n-LL | |\n-LL | |         self.map(|x| x.unwrap())\n-LL | |     }\n-   | |_____^\n-\n-error: type parameter `E` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-  --> $DIR/issue-58887.rs:16:41\n-   |\n-LL |       fn unwrap_items(self) -> Self::Iter {\n-   |  _________________________________________^\n-LL | |\n-LL | |\n-LL | |         self.map(|x| x.unwrap())\n-LL | |     }\n-   | |_____^\n-\n-error: could not find defining uses\n-  --> $DIR/issue-58887.rs:13:5\n-   |\n-LL |     type Iter = impl Iterator<Item = T>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 3 previous errors\n-"}, {"sha": "8686100205ffb7ec507daedd065b57b63ad03b7e", "filename": "src/test/ui/type-alias-impl-trait/issue-60564.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/483a83b6e648d9e6cb21af75dba289a9aef150b1/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs", "raw_url": "https://github.com/rust-lang/rust/raw/483a83b6e648d9e6cb21af75dba289a9aef150b1/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs?ref=483a83b6e648d9e6cb21af75dba289a9aef150b1", "patch": "@@ -18,7 +18,7 @@ where\n {\n     type BitsIter = IterBitsIter<T, E, u8>;\n     fn iter_bits(self, n: u8) -> Self::BitsIter {\n-    //~^ ERROR type parameter `E` is part of concrete type but not used\n+    //~^ ERROR defining opaque type use does not fully define opaque type\n         (0u8..n)\n             .rev()\n             .map(move |shift| ((self >> T::from(shift)) & T::from(1)).try_into().unwrap())"}, {"sha": "9de3e759e15211084e155ce3690193b7bd7b7cd0", "filename": "src/test/ui/type-alias-impl-trait/issue-60564.stderr", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/483a83b6e648d9e6cb21af75dba289a9aef150b1/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/483a83b6e648d9e6cb21af75dba289a9aef150b1/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.stderr?ref=483a83b6e648d9e6cb21af75dba289a9aef150b1", "patch": "@@ -1,8 +1,7 @@\n-error: type parameter `E` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-  --> $DIR/issue-60564.rs:20:49\n+error: defining opaque type use does not fully define opaque type: generic parameter `I` is specified as concrete type `u8`\n+  --> $DIR/issue-60564.rs:20:5\n    |\n-LL |       fn iter_bits(self, n: u8) -> Self::BitsIter {\n-   |  _________________________________________________^\n+LL | /     fn iter_bits(self, n: u8) -> Self::BitsIter {\n LL | |\n LL | |         (0u8..n)\n LL | |             .rev()"}, {"sha": "d68f1bd30a0da1035d19d5ca6196f5f12834bbf6", "filename": "src/test/ui/type-alias-impl-trait/not_a_defining_use.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/483a83b6e648d9e6cb21af75dba289a9aef150b1/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_a_defining_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/483a83b6e648d9e6cb21af75dba289a9aef150b1/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_a_defining_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_a_defining_use.stderr?ref=483a83b6e648d9e6cb21af75dba289a9aef150b1", "patch": "@@ -1,4 +1,4 @@\n-error: defining opaque type use does not fully define opaque type\n+error: defining opaque type use does not fully define opaque type: generic parameter `U` is specified as concrete type `u32`\n   --> $DIR/not_a_defining_use.rs:9:1\n    |\n LL | / fn two<T: Debug>(t: T) -> Two<T, u32> {"}]}