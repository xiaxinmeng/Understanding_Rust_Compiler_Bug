{"sha": "acf4aeeda06b5355060e3dd8316e096465242f94", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjZjRhZWVkYTA2YjUzNTUwNjBlM2RkODMxNmUwOTY0NjUyNDJmOTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-26T07:42:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-26T07:42:10Z"}, "message": "Auto merge of #31210 - Manishearth:rollup, r=Manishearth\n\n- Successful merges: #31152, #31184, #31189, #31192, #31197, #31199, #31201\n- Failed merges:", "tree": {"sha": "812b6e0d57a0f74ed7e698db3133b8d86615b314", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/812b6e0d57a0f74ed7e698db3133b8d86615b314"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/acf4aeeda06b5355060e3dd8316e096465242f94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/acf4aeeda06b5355060e3dd8316e096465242f94", "html_url": "https://github.com/rust-lang/rust/commit/acf4aeeda06b5355060e3dd8316e096465242f94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/acf4aeeda06b5355060e3dd8316e096465242f94/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "faf6d1e87391b25196b35909c3c95e5d873cacf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/faf6d1e87391b25196b35909c3c95e5d873cacf0", "html_url": "https://github.com/rust-lang/rust/commit/faf6d1e87391b25196b35909c3c95e5d873cacf0"}, {"sha": "79157b3fb5d534500caf9c5f2a40161bea01e79d", "url": "https://api.github.com/repos/rust-lang/rust/commits/79157b3fb5d534500caf9c5f2a40161bea01e79d", "html_url": "https://github.com/rust-lang/rust/commit/79157b3fb5d534500caf9c5f2a40161bea01e79d"}], "stats": {"total": 851, "additions": 332, "deletions": 519}, "files": [{"sha": "40891dbe191e9ca9a40346b64238a63340304518", "filename": "src/doc/book/error-handling.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acf4aeeda06b5355060e3dd8316e096465242f94/src%2Fdoc%2Fbook%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/acf4aeeda06b5355060e3dd8316e096465242f94/src%2Fdoc%2Fbook%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ferror-handling.md?ref=acf4aeeda06b5355060e3dd8316e096465242f94", "patch": "@@ -1512,7 +1512,7 @@ and [`rustc-serialize`](https://crates.io/crates/rustc-serialize) crates.\n \n We're not going to spend a lot of time on setting up a project with\n Cargo because it is already covered well in [the Cargo\n-section](../book/hello-cargo.html) and [Cargo's documentation][14].\n+section](getting-started.html#hello-cargo) and [Cargo's documentation][14].\n \n To get started from scratch, run `cargo new --bin city-pop` and make sure your\n `Cargo.toml` looks something like this:"}, {"sha": "d7b6e15794ef4f9f831c1700a847b8438016183f", "filename": "src/doc/book/getting-started.md", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/acf4aeeda06b5355060e3dd8316e096465242f94/src%2Fdoc%2Fbook%2Fgetting-started.md", "raw_url": "https://github.com/rust-lang/rust/raw/acf4aeeda06b5355060e3dd8316e096465242f94/src%2Fdoc%2Fbook%2Fgetting-started.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fgetting-started.md?ref=acf4aeeda06b5355060e3dd8316e096465242f94", "patch": "@@ -167,6 +167,10 @@ variable. If it isn't, run the installer again, select \"Change\" on the \"Change,\n repair, or remove installation\" page and ensure \"Add to PATH\" is installed on\n the local hard drive.\n \n+Rust does not do its own linking, and so you\u2019ll need to have a linker\n+installed. Doing so will depend on your specific system, consult its\n+documentation for more details.\n+\n If not, there are a number of places where we can get help. The easiest is\n [the #rust IRC channel on irc.mozilla.org][irc], which we can access through\n [Mibbit][mibbit]. Click that link, and we'll be chatting with other Rustaceans\n@@ -604,11 +608,11 @@ This chapter covered the basics that will serve you well through the rest of\n this book, and the rest of your time with Rust. Now that you\u2019ve got the tools\n down, we'll cover more about the Rust language itself.\n \n-You have two options: Dive into a project with \u2018[Learn Rust][learnrust]\u2019, or\n+You have two options: Dive into a project with \u2018[Tutorial: Guessing Game][guessinggame]\u2019, or\n start from the bottom and work your way up with \u2018[Syntax and\n Semantics][syntax]\u2019. More experienced systems programmers will probably prefer\n-\u2018Learn Rust\u2019, while those from dynamic backgrounds may enjoy either. Different\n+\u2018Tutorial: Guessing Game\u2019, while those from dynamic backgrounds may enjoy either. Different\n people learn differently! Choose whatever\u2019s right for you.\n \n-[learnrust]: learn-rust.html\n+[guessinggame]: guessing-game.html\n [syntax]: syntax-and-semantics.html"}, {"sha": "7be7fa4f039a710dece1e34f1507f17757bbc286", "filename": "src/doc/book/learn-rust.md", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/faf6d1e87391b25196b35909c3c95e5d873cacf0/src%2Fdoc%2Fbook%2Flearn-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/faf6d1e87391b25196b35909c3c95e5d873cacf0/src%2Fdoc%2Fbook%2Flearn-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Flearn-rust.md?ref=faf6d1e87391b25196b35909c3c95e5d873cacf0", "patch": "@@ -1,9 +0,0 @@\n-% Learn Rust\n-\n-Welcome! This chapter has a few tutorials that teach you Rust through building\n-projects. You\u2019ll get a high-level overview, but we\u2019ll skim over the details.\n-\n-If you\u2019d prefer a more \u2018from the ground up\u2019-style experience, check\n-out [Syntax and Semantics][ss].\n-\n-[ss]: syntax-and-semantics.html"}, {"sha": "5b08c2fb04dbde49616e5a5fc74a835cf1f112d9", "filename": "src/doc/book/loops.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acf4aeeda06b5355060e3dd8316e096465242f94/src%2Fdoc%2Fbook%2Floops.md", "raw_url": "https://github.com/rust-lang/rust/raw/acf4aeeda06b5355060e3dd8316e096465242f94/src%2Fdoc%2Fbook%2Floops.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Floops.md?ref=acf4aeeda06b5355060e3dd8316e096465242f94", "patch": "@@ -195,7 +195,7 @@ for x in 0..10 {\n You may also encounter situations where you have nested loops and need to\n specify which one your `break` or `continue` statement is for. Like most\n other languages, by default a `break` or `continue` will apply to innermost\n-loop. In a situation where you would like to a `break` or `continue` for one\n+loop. In a situation where you would like to `break` or `continue` for one\n of the outer loops, you can use labels to specify which loop the `break` or\n  `continue` statement applies to. This will only print when both `x` and `y` are\n  odd:"}, {"sha": "6041355e9dbc0d861d8a3584038e509725ac7e2b", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/acf4aeeda06b5355060e3dd8316e096465242f94/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf4aeeda06b5355060e3dd8316e096465242f94/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=acf4aeeda06b5355060e3dd8316e096465242f94", "patch": "@@ -414,7 +414,9 @@ impl<T: ?Sized> RefCell<T> {\n     ///\n     /// let c = RefCell::new(5);\n     ///\n-    /// let borrowed_five = c.borrow_mut();\n+    /// *c.borrow_mut() = 7;\n+    ///\n+    /// assert_eq!(*c.borrow(), 7);\n     /// ```\n     ///\n     /// An example of panic:"}, {"sha": "ddc4fb32cde4e2b5fea13bb5a83697e4733c01df", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/acf4aeeda06b5355060e3dd8316e096465242f94/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf4aeeda06b5355060e3dd8316e096465242f94/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=acf4aeeda06b5355060e3dd8316e096465242f94", "patch": "@@ -2740,7 +2740,13 @@ pub trait Extend<A> {\n /// It is important to note that both back and forth work on the same range,\n /// and do not cross: iteration is over when they meet in the middle.\n ///\n+/// In a similar fashion to the [`Iterator`] protocol, once a\n+/// `DoubleEndedIterator` returns `None` from a `next_back()`, calling it again\n+/// may or may not ever return `Some` again. `next()` and `next_back()` are\n+/// interchangable for this purpose.\n+///\n /// [`Iterator`]: trait.Iterator.html\n+///\n /// # Examples\n ///\n /// Basic usage:"}, {"sha": "4f6c1305f768357bca6220070d29f8e22b4822c2", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/acf4aeeda06b5355060e3dd8316e096465242f94/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf4aeeda06b5355060e3dd8316e096465242f94/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=acf4aeeda06b5355060e3dd8316e096465242f94", "patch": "@@ -108,7 +108,6 @@ pub mod middle {\n     pub mod free_region;\n     pub mod intrinsicck;\n     pub mod infer;\n-    pub mod implicator;\n     pub mod lang_items;\n     pub mod liveness;\n     pub mod mem_categorization;"}, {"sha": "d25084bbdffb5e5794cc0840f0c4cf9d7b4750e9", "filename": "src/librustc/middle/implicator.rs", "status": "removed", "additions": 0, "deletions": 454, "changes": 454, "blob_url": "https://github.com/rust-lang/rust/blob/faf6d1e87391b25196b35909c3c95e5d873cacf0/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/faf6d1e87391b25196b35909c3c95e5d873cacf0/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fimplicator.rs?ref=faf6d1e87391b25196b35909c3c95e5d873cacf0", "patch": "@@ -1,454 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// #![warn(deprecated_mode)]\n-\n-use middle::def_id::DefId;\n-use middle::infer::{InferCtxt, GenericKind};\n-use middle::subst::Substs;\n-use middle::traits;\n-use middle::ty::{self, ToPredicate, Ty};\n-use middle::ty::fold::{TypeFoldable, TypeFolder};\n-\n-use syntax::ast;\n-use syntax::codemap::Span;\n-\n-use util::common::ErrorReported;\n-use util::nodemap::FnvHashSet;\n-\n-// Helper functions related to manipulating region types.\n-\n-#[derive(Debug)]\n-pub enum Implication<'tcx> {\n-    RegionSubRegion(Option<Ty<'tcx>>, ty::Region, ty::Region),\n-    RegionSubGeneric(Option<Ty<'tcx>>, ty::Region, GenericKind<'tcx>),\n-    Predicate(DefId, ty::Predicate<'tcx>),\n-}\n-\n-struct Implicator<'a, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a,'tcx>,\n-    body_id: ast::NodeId,\n-    stack: Vec<(ty::Region, Option<Ty<'tcx>>)>,\n-    span: Span,\n-    out: Vec<Implication<'tcx>>,\n-    visited: FnvHashSet<Ty<'tcx>>,\n-}\n-\n-/// This routine computes the well-formedness constraints that must hold for the type `ty` to\n-/// appear in a context with lifetime `outer_region`\n-pub fn implications<'a,'tcx>(\n-    infcx: &'a InferCtxt<'a,'tcx>,\n-    body_id: ast::NodeId,\n-    ty: Ty<'tcx>,\n-    outer_region: ty::Region,\n-    span: Span)\n-    -> Vec<Implication<'tcx>>\n-{\n-    debug!(\"implications(body_id={}, ty={:?}, outer_region={:?})\",\n-           body_id,\n-           ty,\n-           outer_region);\n-\n-    let mut stack = Vec::new();\n-    stack.push((outer_region, None));\n-    let mut wf = Implicator { infcx: infcx,\n-                              body_id: body_id,\n-                              span: span,\n-                              stack: stack,\n-                              out: Vec::new(),\n-                              visited: FnvHashSet() };\n-    wf.accumulate_from_ty(ty);\n-    debug!(\"implications: out={:?}\", wf.out);\n-    wf.out\n-}\n-\n-impl<'a, 'tcx> Implicator<'a, 'tcx> {\n-    fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n-        self.infcx.tcx\n-    }\n-\n-    fn accumulate_from_ty(&mut self, ty: Ty<'tcx>) {\n-        debug!(\"accumulate_from_ty(ty={:?})\",\n-               ty);\n-\n-        // When expanding out associated types, we can visit a cyclic\n-        // set of types. Issue #23003.\n-        if !self.visited.insert(ty) {\n-            return;\n-        }\n-\n-        match ty.sty {\n-            ty::TyBool |\n-            ty::TyChar |\n-            ty::TyInt(..) |\n-            ty::TyUint(..) |\n-            ty::TyFloat(..) |\n-            ty::TyBareFn(..) |\n-            ty::TyError |\n-            ty::TyStr => {\n-                // No borrowed content reachable here.\n-            }\n-\n-            ty::TyClosure(_, ref substs) => {\n-                // FIXME(#27086). We do not accumulate from substs, since they\n-                // don't represent reachable data. This means that, in\n-                // practice, some of the lifetime parameters might not\n-                // be in scope when the body runs, so long as there is\n-                // no reachable data with that lifetime. For better or\n-                // worse, this is consistent with fn types, however,\n-                // which can also encapsulate data in this fashion\n-                // (though it's somewhat harder, and typically\n-                // requires virtual dispatch).\n-                //\n-                // Note that changing this (in a naive way, at least)\n-                // causes regressions for what appears to be perfectly\n-                // reasonable code like this:\n-                //\n-                // ```\n-                // fn foo<'a>(p: &Data<'a>) {\n-                //    bar(|q: &mut Parser| q.read_addr())\n-                // }\n-                // fn bar(p: Box<FnMut(&mut Parser)+'static>) {\n-                // }\n-                // ```\n-                //\n-                // Note that `p` (and `'a`) are not used in the\n-                // closure at all, but to meet the requirement that\n-                // the closure type `C: 'static` (so it can be coerced\n-                // to the object type), we get the requirement that\n-                // `'a: 'static` since `'a` appears in the closure\n-                // type `C`.\n-                //\n-                // A smarter fix might \"prune\" unused `func_substs` --\n-                // this would avoid breaking simple examples like\n-                // this, but would still break others (which might\n-                // indeed be invalid, depending on your POV). Pruning\n-                // would be a subtle process, since we have to see\n-                // what func/type parameters are used and unused,\n-                // taking into consideration UFCS and so forth.\n-\n-                for &upvar_ty in &substs.upvar_tys {\n-                    self.accumulate_from_ty(upvar_ty);\n-                }\n-            }\n-\n-            ty::TyTrait(ref t) => {\n-                let required_region_bounds =\n-                    object_region_bounds(self.tcx(), &t.principal, t.bounds.builtin_bounds);\n-                self.accumulate_from_object_ty(ty, t.bounds.region_bound, required_region_bounds)\n-            }\n-\n-            ty::TyEnum(def, substs) |\n-            ty::TyStruct(def, substs) => {\n-                let item_scheme = def.type_scheme(self.tcx());\n-                self.accumulate_from_adt(ty, def.did, &item_scheme.generics, substs)\n-            }\n-\n-            ty::TyArray(t, _) |\n-            ty::TySlice(t) |\n-            ty::TyRawPtr(ty::TypeAndMut { ty: t, .. }) |\n-            ty::TyBox(t) => {\n-                self.accumulate_from_ty(t)\n-            }\n-\n-            ty::TyRef(r_b, mt) => {\n-                self.accumulate_from_rptr(ty, *r_b, mt.ty);\n-            }\n-\n-            ty::TyParam(p) => {\n-                self.push_param_constraint_from_top(p);\n-            }\n-\n-            ty::TyProjection(ref data) => {\n-                // `<T as TraitRef<..>>::Name`\n-\n-                self.push_projection_constraint_from_top(data);\n-            }\n-\n-            ty::TyTuple(ref tuptys) => {\n-                for &tupty in tuptys {\n-                    self.accumulate_from_ty(tupty);\n-                }\n-            }\n-\n-            ty::TyInfer(_) => {\n-                // This should not happen, BUT:\n-                //\n-                //   Currently we uncover region relationships on\n-                //   entering the fn check. We should do this after\n-                //   the fn check, then we can call this case a bug().\n-            }\n-        }\n-    }\n-\n-    fn accumulate_from_rptr(&mut self,\n-                            ty: Ty<'tcx>,\n-                            r_b: ty::Region,\n-                            ty_b: Ty<'tcx>) {\n-        // We are walking down a type like this, and current\n-        // position is indicated by caret:\n-        //\n-        //     &'a &'b ty_b\n-        //         ^\n-        //\n-        // At this point, top of stack will be `'a`. We must\n-        // require that `'a <= 'b`.\n-\n-        self.push_region_constraint_from_top(r_b);\n-\n-        // Now we push `'b` onto the stack, because it must\n-        // constrain any borrowed content we find within `T`.\n-\n-        self.stack.push((r_b, Some(ty)));\n-        self.accumulate_from_ty(ty_b);\n-        self.stack.pop().unwrap();\n-    }\n-\n-    /// Pushes a constraint that `r_b` must outlive the top region on the stack.\n-    fn push_region_constraint_from_top(&mut self,\n-                                       r_b: ty::Region) {\n-\n-        // Indicates that we have found borrowed content with a lifetime\n-        // of at least `r_b`. This adds a constraint that `r_b` must\n-        // outlive the region `r_a` on top of the stack.\n-        //\n-        // As an example, imagine walking a type like:\n-        //\n-        //     &'a &'b T\n-        //         ^\n-        //\n-        // when we hit the inner pointer (indicated by caret), `'a` will\n-        // be on top of stack and `'b` will be the lifetime of the content\n-        // we just found. So we add constraint that `'a <= 'b`.\n-\n-        let &(r_a, opt_ty) = self.stack.last().unwrap();\n-        self.push_sub_region_constraint(opt_ty, r_a, r_b);\n-    }\n-\n-    /// Pushes a constraint that `r_a <= r_b`, due to `opt_ty`\n-    fn push_sub_region_constraint(&mut self,\n-                                  opt_ty: Option<Ty<'tcx>>,\n-                                  r_a: ty::Region,\n-                                  r_b: ty::Region) {\n-        self.out.push(Implication::RegionSubRegion(opt_ty, r_a, r_b));\n-    }\n-\n-    /// Pushes a constraint that `param_ty` must outlive the top region on the stack.\n-    fn push_param_constraint_from_top(&mut self,\n-                                      param_ty: ty::ParamTy) {\n-        let &(region, opt_ty) = self.stack.last().unwrap();\n-        self.push_param_constraint(region, opt_ty, param_ty);\n-    }\n-\n-    /// Pushes a constraint that `projection_ty` must outlive the top region on the stack.\n-    fn push_projection_constraint_from_top(&mut self,\n-                                           projection_ty: &ty::ProjectionTy<'tcx>) {\n-        let &(region, opt_ty) = self.stack.last().unwrap();\n-        self.out.push(Implication::RegionSubGeneric(\n-            opt_ty, region, GenericKind::Projection(projection_ty.clone())));\n-    }\n-\n-    /// Pushes a constraint that `region <= param_ty`, due to `opt_ty`\n-    fn push_param_constraint(&mut self,\n-                             region: ty::Region,\n-                             opt_ty: Option<Ty<'tcx>>,\n-                             param_ty: ty::ParamTy) {\n-        self.out.push(Implication::RegionSubGeneric(\n-            opt_ty, region, GenericKind::Param(param_ty)));\n-    }\n-\n-    fn accumulate_from_adt(&mut self,\n-                           ty: Ty<'tcx>,\n-                           def_id: DefId,\n-                           _generics: &ty::Generics<'tcx>,\n-                           substs: &Substs<'tcx>)\n-    {\n-        let predicates =\n-            self.tcx().lookup_predicates(def_id).instantiate(self.tcx(), substs);\n-        let predicates = match self.fully_normalize(&predicates) {\n-            Ok(predicates) => predicates,\n-            Err(ErrorReported) => { return; }\n-        };\n-\n-        for predicate in predicates.predicates.as_slice() {\n-            match *predicate {\n-                ty::Predicate::Trait(..) => { }\n-                ty::Predicate::Equate(..) => { }\n-                ty::Predicate::Projection(..) => { }\n-                ty::Predicate::RegionOutlives(ref data) => {\n-                    match self.tcx().no_late_bound_regions(data) {\n-                        None => { }\n-                        Some(ty::OutlivesPredicate(r_a, r_b)) => {\n-                            self.push_sub_region_constraint(Some(ty), r_b, r_a);\n-                        }\n-                    }\n-                }\n-                ty::Predicate::TypeOutlives(ref data) => {\n-                    match self.tcx().no_late_bound_regions(data) {\n-                        None => { }\n-                        Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n-                            self.stack.push((r_b, Some(ty)));\n-                            self.accumulate_from_ty(ty_a);\n-                            self.stack.pop().unwrap();\n-                        }\n-                    }\n-                }\n-                ty::Predicate::ObjectSafe(_) |\n-                ty::Predicate::WellFormed(_) => {\n-                }\n-            }\n-        }\n-\n-        let obligations = predicates.predicates\n-                                    .into_iter()\n-                                    .map(|pred| Implication::Predicate(def_id, pred));\n-        self.out.extend(obligations);\n-\n-        let variances = self.tcx().item_variances(def_id);\n-        self.accumulate_from_substs(substs, Some(&variances));\n-    }\n-\n-    fn accumulate_from_substs(&mut self,\n-                              substs: &Substs<'tcx>,\n-                              variances: Option<&ty::ItemVariances>)\n-    {\n-        let mut tmp_variances = None;\n-        let variances = variances.unwrap_or_else(|| {\n-            tmp_variances = Some(ty::ItemVariances {\n-                types: substs.types.map(|_| ty::Variance::Invariant),\n-                regions: substs.regions().map(|_| ty::Variance::Invariant),\n-            });\n-            tmp_variances.as_ref().unwrap()\n-        });\n-\n-        for (&region, &variance) in substs.regions().iter().zip(&variances.regions) {\n-            match variance {\n-                ty::Contravariant | ty::Invariant => {\n-                    // If any data with this lifetime is reachable\n-                    // within, it must be at least contravariant.\n-                    self.push_region_constraint_from_top(region)\n-                }\n-                ty::Covariant | ty::Bivariant => { }\n-            }\n-        }\n-\n-        for (&ty, &variance) in substs.types.iter().zip(&variances.types) {\n-            match variance {\n-                ty::Covariant | ty::Invariant => {\n-                    // If any data of this type is reachable within,\n-                    // it must be at least covariant.\n-                    self.accumulate_from_ty(ty);\n-                }\n-                ty::Contravariant | ty::Bivariant => { }\n-            }\n-        }\n-    }\n-\n-    fn accumulate_from_object_ty(&mut self,\n-                                 ty: Ty<'tcx>,\n-                                 region_bound: ty::Region,\n-                                 required_region_bounds: Vec<ty::Region>)\n-    {\n-        // Imagine a type like this:\n-        //\n-        //     trait Foo { }\n-        //     trait Bar<'c> : 'c { }\n-        //\n-        //     &'b (Foo+'c+Bar<'d>)\n-        //         ^\n-        //\n-        // In this case, the following relationships must hold:\n-        //\n-        //     'b <= 'c\n-        //     'd <= 'c\n-        //\n-        // The first conditions is due to the normal region pointer\n-        // rules, which say that a reference cannot outlive its\n-        // referent.\n-        //\n-        // The final condition may be a bit surprising. In particular,\n-        // you may expect that it would have been `'c <= 'd`, since\n-        // usually lifetimes of outer things are conservative\n-        // approximations for inner things. However, it works somewhat\n-        // differently with trait objects: here the idea is that if the\n-        // user specifies a region bound (`'c`, in this case) it is the\n-        // \"master bound\" that *implies* that bounds from other traits are\n-        // all met. (Remember that *all bounds* in a type like\n-        // `Foo+Bar+Zed` must be met, not just one, hence if we write\n-        // `Foo<'x>+Bar<'y>`, we know that the type outlives *both* 'x and\n-        // 'y.)\n-        //\n-        // Note: in fact we only permit builtin traits, not `Bar<'d>`, I\n-        // am looking forward to the future here.\n-\n-        // The content of this object type must outlive\n-        // `bounds.region_bound`:\n-        let r_c = region_bound;\n-        self.push_region_constraint_from_top(r_c);\n-\n-        // And then, in turn, to be well-formed, the\n-        // `region_bound` that user specified must imply the\n-        // region bounds required from all of the trait types:\n-        for &r_d in &required_region_bounds {\n-            // Each of these is an instance of the `'c <= 'b`\n-            // constraint above\n-            self.out.push(Implication::RegionSubRegion(Some(ty), r_d, r_c));\n-        }\n-    }\n-\n-    fn fully_normalize<T>(&self, value: &T) -> Result<T,ErrorReported>\n-        where T : TypeFoldable<'tcx>\n-    {\n-        let value =\n-            traits::fully_normalize(self.infcx,\n-                                    traits::ObligationCause::misc(self.span, self.body_id),\n-                                    value);\n-        match value {\n-            Ok(value) => Ok(value),\n-            Err(errors) => {\n-                // I don't like reporting these errors here, but I\n-                // don't know where else to report them just now. And\n-                // I don't really expect errors to arise here\n-                // frequently. I guess the best option would be to\n-                // propagate them out.\n-                traits::report_fulfillment_errors(self.infcx, &errors);\n-                Err(ErrorReported)\n-            }\n-        }\n-    }\n-}\n-\n-/// Given an object type like `SomeTrait+Send`, computes the lifetime\n-/// bounds that must hold on the elided self type. These are derived\n-/// from the declarations of `SomeTrait`, `Send`, and friends -- if\n-/// they declare `trait SomeTrait : 'static`, for example, then\n-/// `'static` would appear in the list. The hard work is done by\n-/// `ty::required_region_bounds`, see that for more information.\n-pub fn object_region_bounds<'tcx>(\n-    tcx: &ty::ctxt<'tcx>,\n-    principal: &ty::PolyTraitRef<'tcx>,\n-    others: ty::BuiltinBounds)\n-    -> Vec<ty::Region>\n-{\n-    // Since we don't actually *know* the self type for an object,\n-    // this \"open(err)\" serves as a kind of dummy standin -- basically\n-    // a skolemized type.\n-    let open_ty = tcx.mk_infer(ty::FreshTy(0));\n-\n-    // Note that we preserve the overall binding levels here.\n-    assert!(!open_ty.has_escaping_regions());\n-    let substs = tcx.mk_substs(principal.0.substs.with_self_ty(open_ty));\n-    let trait_refs = vec!(ty::Binder(ty::TraitRef::new(principal.0.def_id, substs)));\n-\n-    let mut predicates = others.to_predicates(tcx, open_ty);\n-    predicates.extend(trait_refs.iter().map(|t| t.to_predicate()));\n-\n-    tcx.required_region_bounds(open_ty, predicates)\n-}"}, {"sha": "56b02412c31b2f1c65fb703206e7647868333713", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 48, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/acf4aeeda06b5355060e3dd8316e096465242f94/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf4aeeda06b5355060e3dd8316e096465242f94/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=acf4aeeda06b5355060e3dd8316e096465242f94", "patch": "@@ -86,7 +86,6 @@ use astconv::AstConv;\n use check::dropck;\n use check::FnCtxt;\n use middle::free_region::FreeRegionMap;\n-use middle::implicator::{self, Implication};\n use middle::mem_categorization as mc;\n use middle::mem_categorization::Categorization;\n use middle::region::{self, CodeExtent};\n@@ -365,60 +364,14 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n                    r_o, r_o.cause);\n             let sup_type = self.resolve_type(r_o.sup_type);\n             let origin = self.code_to_origin(r_o.cause.span, sup_type, &r_o.cause.code);\n-\n-            if r_o.sub_region != ty::ReEmpty {\n-                type_must_outlive(self, origin, sup_type, r_o.sub_region);\n-            } else {\n-                self.visit_old_school_wf(node_id, sup_type, origin);\n-            }\n+            type_must_outlive(self, origin, sup_type, r_o.sub_region);\n         }\n \n         // Processing the region obligations should not cause the list to grow further:\n         assert_eq!(region_obligations.len(),\n                    self.fcx.inh.infcx.fulfillment_cx.borrow().region_obligations(node_id).len());\n     }\n \n-    fn visit_old_school_wf(&mut self,\n-                           body_id: ast::NodeId,\n-                           ty: Ty<'tcx>,\n-                           origin: infer::SubregionOrigin<'tcx>) {\n-        // As a weird kind of hack, we use a region of empty as a signal\n-        // to mean \"old-school WF rules\". The only reason the old-school\n-        // WF rules are not encoded using WF is that this leads to errors,\n-        // and we want to phase those in gradually.\n-\n-        // FIXME(#27579) remove this weird special case once we phase in new WF rules completely\n-        let implications = implicator::implications(self.infcx(),\n-                                                    body_id,\n-                                                    ty,\n-                                                    ty::ReEmpty,\n-                                                    origin.span());\n-        let origin_for_ty = |ty: Option<Ty<'tcx>>| match ty {\n-            None => origin.clone(),\n-            Some(ty) => infer::ReferenceOutlivesReferent(ty, origin.span()),\n-        };\n-        for implication in implications {\n-            match implication {\n-                Implication::RegionSubRegion(ty, r1, r2) => {\n-                    self.fcx.mk_subr(origin_for_ty(ty), r1, r2);\n-                }\n-                Implication::RegionSubGeneric(ty, r1, GenericKind::Param(param_ty)) => {\n-                    param_ty_must_outlive(self, origin_for_ty(ty), r1, param_ty);\n-                }\n-                Implication::RegionSubGeneric(ty, r1, GenericKind::Projection(proj_ty)) => {\n-                    projection_must_outlive(self, origin_for_ty(ty), r1, proj_ty);\n-                }\n-                Implication::Predicate(def_id, predicate) => {\n-                    let cause = traits::ObligationCause::new(origin.span(),\n-                                                             body_id,\n-                                                             traits::ItemObligation(def_id));\n-                    let obligation = traits::Obligation::new(cause, predicate);\n-                    self.fcx.register_predicate(obligation);\n-                }\n-            }\n-        }\n-    }\n-\n     fn code_to_origin(&self,\n                       span: Span,\n                       sup_type: Ty<'tcx>,"}, {"sha": "bfd76db0359bdf2a5f836419e5eeeb6f1881906b", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acf4aeeda06b5355060e3dd8316e096465242f94/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf4aeeda06b5355060e3dd8316e096465242f94/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=acf4aeeda06b5355060e3dd8316e096465242f94", "patch": "@@ -1005,7 +1005,7 @@ fn is_in_follow(_: &ExtCtxt, tok: &Token, frag: &str) -> Result<bool, String> {\n             },\n             \"path\" | \"ty\" => {\n                 match *tok {\n-                    OpenDelim(token::DelimToken::Brace) |\n+                    OpenDelim(token::DelimToken::Brace) | OpenDelim(token::DelimToken::Bracket) |\n                     Comma | FatArrow | Colon | Eq | Gt | Semi | BinOp(token::Or) => Ok(true),\n                     Ident(i, _) if (i.name.as_str() == \"as\" ||\n                                     i.name.as_str() == \"where\") => Ok(true),"}, {"sha": "35944bada4d6490ca4578ae574c12cf4a9d630eb", "filename": "src/test/compile-fail/macro-follow.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/acf4aeeda06b5355060e3dd8316e096465242f94/src%2Ftest%2Fcompile-fail%2Fmacro-follow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf4aeeda06b5355060e3dd8316e096465242f94/src%2Ftest%2Fcompile-fail%2Fmacro-follow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-follow.rs?ref=acf4aeeda06b5355060e3dd8316e096465242f94", "patch": "@@ -0,0 +1,122 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// Check the macro follow sets (see corresponding rpass test).\n+\n+// FOLLOW(pat) = {FatArrow, Comma, Eq, Or, Ident(if), Ident(in)}\n+macro_rules! follow_pat {\n+    ($p:pat ()) => {};       //~WARN  `$p:pat` is followed by `(`\n+    ($p:pat []) => {};       //~WARN  `$p:pat` is followed by `[`\n+    ($p:pat {}) => {};       //~WARN  `$p:pat` is followed by `{`\n+    ($p:pat :) => {};        //~ERROR `$p:pat` is followed by `:`\n+    ($p:pat >) => {};        //~ERROR `$p:pat` is followed by `>`\n+    ($p:pat +) => {};        //~ERROR `$p:pat` is followed by `+`\n+    ($p:pat ident) => {};    //~ERROR `$p:pat` is followed by `ident`\n+    ($p:pat $p:pat) => {};   //~ERROR `$p:pat` is followed by `$p:pat`\n+    ($p:pat $e:expr) => {};  //~ERROR `$p:pat` is followed by `$e:expr`\n+    ($p:pat $t:ty) => {};    //~ERROR `$p:pat` is followed by `$t:ty`\n+    ($p:pat $s:stmt) => {};  //~ERROR `$p:pat` is followed by `$s:stmt`\n+    ($p:pat $p:path) => {};  //~ERROR `$p:pat` is followed by `$p:path`\n+    ($p:pat $b:block) => {}; //~ERROR `$p:pat` is followed by `$b:block`\n+    ($p:pat $i:ident) => {}; //~ERROR `$p:pat` is followed by `$i:ident`\n+    ($p:pat $t:tt) => {};    //~ERROR `$p:pat` is followed by `$t:tt`\n+    ($p:pat $i:item) => {};  //~ERROR `$p:pat` is followed by `$i:item`\n+    ($p:pat $m:meta) => {};  //~ERROR `$p:pat` is followed by `$m:meta`\n+}\n+// FOLLOW(expr) = {FatArrow, Comma, Semicolon}\n+macro_rules! follow_expr {\n+    ($e:expr ()) => {};       //~WARN  `$e:expr` is followed by `(`\n+    ($e:expr []) => {};       //~WARN  `$e:expr` is followed by `[`\n+    ($e:expr {}) => {};       //~WARN  `$e:expr` is followed by `{`\n+    ($e:expr =) => {};        //~ERROR `$e:expr` is followed by `=`\n+    ($e:expr |) => {};        //~ERROR `$e:expr` is followed by `|`\n+    ($e:expr :) => {};        //~ERROR `$e:expr` is followed by `:`\n+    ($e:expr >) => {};        //~ERROR `$e:expr` is followed by `>`\n+    ($e:expr +) => {};        //~ERROR `$e:expr` is followed by `+`\n+    ($e:expr ident) => {};    //~ERROR `$e:expr` is followed by `ident`\n+    ($e:expr if) => {};       //~ERROR `$e:expr` is followed by `if`\n+    ($e:expr in) => {};       //~ERROR `$e:expr` is followed by `in`\n+    ($e:expr $p:pat) => {};   //~ERROR `$e:expr` is followed by `$p:pat`\n+    ($e:expr $e:expr) => {};  //~ERROR `$e:expr` is followed by `$e:expr`\n+    ($e:expr $t:ty) => {};    //~ERROR `$e:expr` is followed by `$t:ty`\n+    ($e:expr $s:stmt) => {};  //~ERROR `$e:expr` is followed by `$s:stmt`\n+    ($e:expr $p:path) => {};  //~ERROR `$e:expr` is followed by `$p:path`\n+    ($e:expr $b:block) => {}; //~ERROR `$e:expr` is followed by `$b:block`\n+    ($e:expr $i:ident) => {}; //~ERROR `$e:expr` is followed by `$i:ident`\n+    ($e:expr $t:tt) => {};    //~ERROR `$e:expr` is followed by `$t:tt`\n+    ($e:expr $i:item) => {};  //~ERROR `$e:expr` is followed by `$i:item`\n+    ($e:expr $m:meta) => {};  //~ERROR `$e:expr` is followed by `$m:meta`\n+}\n+// FOLLOW(ty) = {OpenDelim(Brace), Comma, FatArrow, Colon, Eq, Gt, Semi, Or,\n+//               Ident(as), Ident(where), OpenDelim(Bracket)}\n+macro_rules! follow_ty {\n+    ($t:ty ()) => {};       //~WARN  `$t:ty` is followed by `(`\n+    ($t:ty []) => {};       // ok (RFC 1462)\n+    ($t:ty +) => {};        //~ERROR `$t:ty` is followed by `+`\n+    ($t:ty ident) => {};    //~ERROR `$t:ty` is followed by `ident`\n+    ($t:ty if) => {};       //~ERROR `$t:ty` is followed by `if`\n+    ($t:ty $p:pat) => {};   //~ERROR `$t:ty` is followed by `$p:pat`\n+    ($t:ty $e:expr) => {};  //~ERROR `$t:ty` is followed by `$e:expr`\n+    ($t:ty $t:ty) => {};    //~ERROR `$t:ty` is followed by `$t:ty`\n+    ($t:ty $s:stmt) => {};  //~ERROR `$t:ty` is followed by `$s:stmt`\n+    ($t:ty $p:path) => {};  //~ERROR `$t:ty` is followed by `$p:path`\n+    ($t:ty $b:block) => {}; //~ERROR `$t:ty` is followed by `$b:block`\n+    ($t:ty $i:ident) => {}; //~ERROR `$t:ty` is followed by `$i:ident`\n+    ($t:ty $t:tt) => {};    //~ERROR `$t:ty` is followed by `$t:tt`\n+    ($t:ty $i:item) => {};  //~ERROR `$t:ty` is followed by `$i:item`\n+    ($t:ty $m:meta) => {};  //~ERROR `$t:ty` is followed by `$m:meta`\n+}\n+// FOLLOW(stmt) = FOLLOW(expr)\n+macro_rules! follow_stmt {\n+    ($s:stmt ()) => {};       //~WARN  `$s:stmt` is followed by `(`\n+    ($s:stmt []) => {};       //~WARN  `$s:stmt` is followed by `[`\n+    ($s:stmt {}) => {};       //~WARN  `$s:stmt` is followed by `{`\n+    ($s:stmt =) => {};        //~ERROR `$s:stmt` is followed by `=`\n+    ($s:stmt |) => {};        //~ERROR `$s:stmt` is followed by `|`\n+    ($s:stmt :) => {};        //~ERROR `$s:stmt` is followed by `:`\n+    ($s:stmt >) => {};        //~ERROR `$s:stmt` is followed by `>`\n+    ($s:stmt +) => {};        //~ERROR `$s:stmt` is followed by `+`\n+    ($s:stmt ident) => {};    //~ERROR `$s:stmt` is followed by `ident`\n+    ($s:stmt if) => {};       //~ERROR `$s:stmt` is followed by `if`\n+    ($s:stmt in) => {};       //~ERROR `$s:stmt` is followed by `in`\n+    ($s:stmt $p:pat) => {};   //~ERROR `$s:stmt` is followed by `$p:pat`\n+    ($s:stmt $e:expr) => {};  //~ERROR `$s:stmt` is followed by `$e:expr`\n+    ($s:stmt $t:ty) => {};    //~ERROR `$s:stmt` is followed by `$t:ty`\n+    ($s:stmt $s:stmt) => {};  //~ERROR `$s:stmt` is followed by `$s:stmt`\n+    ($s:stmt $p:path) => {};  //~ERROR `$s:stmt` is followed by `$p:path`\n+    ($s:stmt $b:block) => {}; //~ERROR `$s:stmt` is followed by `$b:block`\n+    ($s:stmt $i:ident) => {}; //~ERROR `$s:stmt` is followed by `$i:ident`\n+    ($s:stmt $t:tt) => {};    //~ERROR `$s:stmt` is followed by `$t:tt`\n+    ($s:stmt $i:item) => {};  //~ERROR `$s:stmt` is followed by `$i:item`\n+    ($s:stmt $m:meta) => {};  //~ERROR `$s:stmt` is followed by `$m:meta`\n+}\n+// FOLLOW(path) = FOLLOW(ty)\n+macro_rules! follow_path {\n+    ($p:path ()) => {};       //~WARN  `$p:path` is followed by `(`\n+    ($p:path []) => {};       // ok (RFC 1462)\n+    ($p:path +) => {};        //~ERROR `$p:path` is followed by `+`\n+    ($p:path ident) => {};    //~ERROR `$p:path` is followed by `ident`\n+    ($p:path if) => {};       //~ERROR `$p:path` is followed by `if`\n+    ($p:path $p:pat) => {};   //~ERROR `$p:path` is followed by `$p:pat`\n+    ($p:path $e:expr) => {};  //~ERROR `$p:path` is followed by `$e:expr`\n+    ($p:path $t:ty) => {};    //~ERROR `$p:path` is followed by `$t:ty`\n+    ($p:path $s:stmt) => {};  //~ERROR `$p:path` is followed by `$s:stmt`\n+    ($p:path $p:path) => {};  //~ERROR `$p:path` is followed by `$p:path`\n+    ($p:path $b:block) => {}; //~ERROR `$p:path` is followed by `$b:block`\n+    ($p:path $i:ident) => {}; //~ERROR `$p:path` is followed by `$i:ident`\n+    ($p:path $t:tt) => {};    //~ERROR `$p:path` is followed by `$t:tt`\n+    ($p:path $i:item) => {};  //~ERROR `$p:path` is followed by `$i:item`\n+    ($p:path $m:meta) => {};  //~ERROR `$p:path` is followed by `$m:meta`\n+}\n+// FOLLOW(block) = any token\n+// FOLLOW(ident) = any token\n+\n+fn main() {}\n+"}, {"sha": "ce6498f67f9ee3395a5033583938b425a8e3df01", "filename": "src/test/run-pass/macro-follow.rs", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/acf4aeeda06b5355060e3dd8316e096465242f94/src%2Ftest%2Frun-pass%2Fmacro-follow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf4aeeda06b5355060e3dd8316e096465242f94/src%2Ftest%2Frun-pass%2Fmacro-follow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-follow.rs?ref=acf4aeeda06b5355060e3dd8316e096465242f94", "patch": "@@ -0,0 +1,190 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check the macro follow sets (see corresponding cfail test).\n+\n+// FOLLOW(pat) = {FatArrow, Comma, Eq, Or, Ident(if), Ident(in)}\n+macro_rules! follow_pat {\n+    ($p:pat =>) => {};\n+    ($p:pat ,) => {};\n+    ($p:pat =) => {};\n+    ($p:pat |) => {};\n+    ($p:pat if) => {};\n+    ($p:pat in) => {};\n+}\n+// FOLLOW(expr) = {FatArrow, Comma, Semicolon}\n+macro_rules! follow_expr {\n+    ($e:expr =>) => {};\n+    ($e:expr ,) => {};\n+    ($e:expr ;) => {};\n+}\n+// FOLLOW(ty) = {OpenDelim(Brace), Comma, FatArrow, Colon, Eq, Gt, Semi, Or,\n+//               Ident(as), Ident(where), OpenDelim(Bracket)}\n+macro_rules! follow_ty {\n+    ($t:ty {}) => {};\n+    ($t:ty ,) => {};\n+    ($t:ty =>) => {};\n+    ($t:ty :) => {};\n+    ($t:ty =) => {};\n+    ($t:ty >) => {};\n+    ($t:ty ;) => {};\n+    ($t:ty |) => {};\n+    ($t:ty as) => {};\n+    ($t:ty where) => {};\n+    ($t:ty []) => {};\n+}\n+// FOLLOW(stmt) = FOLLOW(expr)\n+macro_rules! follow_stmt {\n+    ($s:stmt =>) => {};\n+    ($s:stmt ,) => {};\n+    ($s:stmt ;) => {};\n+}\n+// FOLLOW(path) = FOLLOW(ty)\n+macro_rules! follow_path {\n+    ($p:path {}) => {};\n+    ($p:path ,) => {};\n+    ($p:path =>) => {};\n+    ($p:path :) => {};\n+    ($p:path =) => {};\n+    ($p:path >) => {};\n+    ($p:path ;) => {};\n+    ($p:path |) => {};\n+    ($p:path as) => {};\n+    ($p:path where) => {};\n+    ($p:path []) => {};\n+}\n+// FOLLOW(block) = any token\n+macro_rules! follow_block {\n+    ($b:block ()) => {};\n+    ($b:block []) => {};\n+    ($b:block {}) => {};\n+    ($b:block ,) => {};\n+    ($b:block =>) => {};\n+    ($b:block :) => {};\n+    ($b:block =) => {};\n+    ($b:block >) => {};\n+    ($b:block ;) => {};\n+    ($b:block |) => {};\n+    ($b:block +) => {};\n+    ($b:block ident) => {};\n+    ($b:block $p:pat) => {};\n+    ($b:block $e:expr) => {};\n+    ($b:block $t:ty) => {};\n+    ($b:block $s:stmt) => {};\n+    ($b:block $p:path) => {};\n+    ($b:block $b:block) => {};\n+    ($b:block $i:ident) => {};\n+    ($b:block $t:tt) => {};\n+    ($b:block $i:item) => {};\n+    ($b:block $m:meta) => {};\n+}\n+// FOLLOW(ident) = any token\n+macro_rules! follow_ident {\n+    ($i:ident ()) => {};\n+    ($i:ident []) => {};\n+    ($i:ident {}) => {};\n+    ($i:ident ,) => {};\n+    ($i:ident =>) => {};\n+    ($i:ident :) => {};\n+    ($i:ident =) => {};\n+    ($i:ident >) => {};\n+    ($i:ident ;) => {};\n+    ($i:ident |) => {};\n+    ($i:ident +) => {};\n+    ($i:ident ident) => {};\n+    ($i:ident $p:pat) => {};\n+    ($i:ident $e:expr) => {};\n+    ($i:ident $t:ty) => {};\n+    ($i:ident $s:stmt) => {};\n+    ($i:ident $p:path) => {};\n+    ($i:ident $b:block) => {};\n+    ($i:ident $i:ident) => {};\n+    ($i:ident $t:tt) => {};\n+    ($i:ident $i:item) => {};\n+    ($i:ident $m:meta) => {};\n+}\n+// FOLLOW(tt) = any token\n+macro_rules! follow_tt {\n+    ($t:tt ()) => {};\n+    ($t:tt []) => {};\n+    ($t:tt {}) => {};\n+    ($t:tt ,) => {};\n+    ($t:tt =>) => {};\n+    ($t:tt :) => {};\n+    ($t:tt =) => {};\n+    ($t:tt >) => {};\n+    ($t:tt ;) => {};\n+    ($t:tt |) => {};\n+    ($t:tt +) => {};\n+    ($t:tt ident) => {};\n+    ($t:tt $p:pat) => {};\n+    ($t:tt $e:expr) => {};\n+    ($t:tt $t:ty) => {};\n+    ($t:tt $s:stmt) => {};\n+    ($t:tt $p:path) => {};\n+    ($t:tt $b:block) => {};\n+    ($t:tt $i:ident) => {};\n+    ($t:tt $t:tt) => {};\n+    ($t:tt $i:item) => {};\n+    ($t:tt $m:meta) => {};\n+}\n+// FOLLOW(item) = any token\n+macro_rules! follow_item {\n+    ($i:item ()) => {};\n+    ($i:item []) => {};\n+    ($i:item {}) => {};\n+    ($i:item ,) => {};\n+    ($i:item =>) => {};\n+    ($i:item :) => {};\n+    ($i:item =) => {};\n+    ($i:item >) => {};\n+    ($i:item ;) => {};\n+    ($i:item |) => {};\n+    ($i:item +) => {};\n+    ($i:item ident) => {};\n+    ($i:item $p:pat) => {};\n+    ($i:item $e:expr) => {};\n+    ($i:item $t:ty) => {};\n+    ($i:item $s:stmt) => {};\n+    ($i:item $p:path) => {};\n+    ($i:item $b:block) => {};\n+    ($i:item $i:ident) => {};\n+    ($i:item $t:tt) => {};\n+    ($i:item $i:item) => {};\n+    ($i:item $m:meta) => {};\n+}\n+// FOLLOW(meta) = any token\n+macro_rules! follow_meta {\n+    ($m:meta ()) => {};\n+    ($m:meta []) => {};\n+    ($m:meta {}) => {};\n+    ($m:meta ,) => {};\n+    ($m:meta =>) => {};\n+    ($m:meta :) => {};\n+    ($m:meta =) => {};\n+    ($m:meta >) => {};\n+    ($m:meta ;) => {};\n+    ($m:meta |) => {};\n+    ($m:meta +) => {};\n+    ($m:meta ident) => {};\n+    ($m:meta $p:pat) => {};\n+    ($m:meta $e:expr) => {};\n+    ($m:meta $t:ty) => {};\n+    ($m:meta $s:stmt) => {};\n+    ($m:meta $p:path) => {};\n+    ($m:meta $b:block) => {};\n+    ($m:meta $i:ident) => {};\n+    ($m:meta $t:tt) => {};\n+    ($m:meta $i:item) => {};\n+    ($m:meta $m:meta) => {};\n+}\n+\n+fn main() {}\n+"}]}