{"sha": "66e7493543bfef2bdd12454155670cc810de8ea9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2ZTc0OTM1NDNiZmVmMmJkZDEyNDU0MTU1NjcwY2M4MTBkZThlYTk=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-05-31T22:59:56Z"}, "committer": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-06-10T21:46:40Z"}, "message": "Add more functionality to BitMatrix", "tree": {"sha": "3a2423868f61b7caffdc45ccc29c39249711e303", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a2423868f61b7caffdc45ccc29c39249711e303"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66e7493543bfef2bdd12454155670cc810de8ea9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66e7493543bfef2bdd12454155670cc810de8ea9", "html_url": "https://github.com/rust-lang/rust/commit/66e7493543bfef2bdd12454155670cc810de8ea9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66e7493543bfef2bdd12454155670cc810de8ea9/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a38991f755e0180101d46351a63db7b6657f08b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/a38991f755e0180101d46351a63db7b6657f08b4", "html_url": "https://github.com/rust-lang/rust/commit/a38991f755e0180101d46351a63db7b6657f08b4"}], "stats": {"total": 94, "additions": 93, "deletions": 1}, "files": [{"sha": "7a11ca070071b6ec26509361700aad60fa41f566", "filename": "src/librustc_data_structures/bit_set.rs", "status": "modified", "additions": 83, "deletions": 1, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/66e7493543bfef2bdd12454155670cc810de8ea9/src%2Flibrustc_data_structures%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66e7493543bfef2bdd12454155670cc810de8ea9/src%2Flibrustc_data_structures%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbit_set.rs?ref=66e7493543bfef2bdd12454155670cc810de8ea9", "patch": "@@ -636,7 +636,7 @@ impl<T: Idx> GrowableBitSet<T> {\n ///\n /// All operations that involve a row and/or column index will panic if the\n /// index exceeds the relevant bound.\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, Eq, PartialEq, RustcDecodable, RustcEncodable)]\n pub struct BitMatrix<R: Idx, C: Idx> {\n     num_rows: usize,\n     num_columns: usize,\n@@ -658,6 +658,23 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n         }\n     }\n \n+    /// Creates a new matrix, with `row` used as the value for every row.\n+    pub fn from_row_n(row: &BitSet<C>, num_rows: usize) -> BitMatrix<R, C> {\n+        let num_columns = row.domain_size();\n+        let words_per_row = num_words(num_columns);\n+        assert_eq!(words_per_row, row.words().len());\n+        BitMatrix {\n+            num_rows,\n+            num_columns,\n+            words: iter::repeat(row.words()).take(num_rows).flatten().cloned().collect(),\n+            marker: PhantomData,\n+        }\n+    }\n+\n+    pub fn rows(&self) -> impl Iterator<Item = R> {\n+        (0..self.num_rows).map(R::new)\n+    }\n+\n     /// The range of bits for a given row.\n     fn range(&self, row: R) -> (usize, usize) {\n         let words_per_row = num_words(self.num_columns);\n@@ -737,6 +754,49 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n         changed\n     }\n \n+    /// Adds the bits from `with` to the bits from row `write`, and\n+    /// returns `true` if anything changed.\n+    pub fn union_row_with(&mut self, with: &BitSet<C>, write: R) -> bool {\n+        assert!(write.index() < self.num_rows);\n+        assert_eq!(with.domain_size(), self.num_columns);\n+        let (write_start, write_end) = self.range(write);\n+        let mut changed = false;\n+        for (read_index, write_index) in (0..with.words().len()).zip(write_start..write_end) {\n+            let word = self.words[write_index];\n+            let new_word = word | with.words()[read_index];\n+            self.words[write_index] = new_word;\n+            changed |= word != new_word;\n+        }\n+        changed\n+    }\n+\n+    /// Sets every cell in `row` to true.\n+    pub fn insert_all_into_row(&mut self, row: R) {\n+        assert!(row.index() < self.num_rows);\n+        let (start, end) = self.range(row);\n+        let words = &mut self.words[..];\n+        for index in start..end {\n+            words[index] = !0;\n+        }\n+        self.clear_excess_bits(row);\n+    }\n+\n+    /// Clear excess bits in the final word of the row.\n+    fn clear_excess_bits(&mut self, row: R) {\n+        let num_bits_in_final_word = self.num_columns % WORD_BITS;\n+        if num_bits_in_final_word > 0 {\n+            let mask = (1 << num_bits_in_final_word) - 1;\n+            let (_, end) = self.range(row);\n+            let final_word_idx = end - 1;\n+            self.words[final_word_idx] &= mask;\n+        }\n+    }\n+\n+    /// Gets a slice of the underlying words.\n+    pub fn words(&self) -> &[Word] {\n+        &self.words\n+    }\n+\n     /// Iterates through all the columns set to true in a given row of\n     /// the matrix.\n     pub fn iter<'a>(&'a self, row: R) -> BitIter<'a, C> {\n@@ -748,6 +808,12 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n             marker: PhantomData,\n         }\n     }\n+\n+    /// Returns the number of elements in `row`.\n+    pub fn count(&self, row: R) -> usize {\n+        let (start, end) = self.range(row);\n+        self.words[start..end].iter().map(|e| e.count_ones() as usize).sum()\n+    }\n }\n \n /// A fixed-column-size, variable-row-size 2D bit matrix with a moderately\n@@ -1057,6 +1123,7 @@ fn matrix_iter() {\n     matrix.insert(2, 99);\n     matrix.insert(4, 0);\n     matrix.union_rows(3, 5);\n+    matrix.insert_all_into_row(6);\n \n     let expected = [99];\n     let mut iter = expected.iter();\n@@ -1068,6 +1135,7 @@ fn matrix_iter() {\n \n     let expected = [22, 75];\n     let mut iter = expected.iter();\n+    assert_eq!(matrix.count(3), expected.len());\n     for i in matrix.iter(3) {\n         let j = *iter.next().unwrap();\n         assert_eq!(i, j);\n@@ -1076,6 +1144,7 @@ fn matrix_iter() {\n \n     let expected = [0];\n     let mut iter = expected.iter();\n+    assert_eq!(matrix.count(4), expected.len());\n     for i in matrix.iter(4) {\n         let j = *iter.next().unwrap();\n         assert_eq!(i, j);\n@@ -1084,11 +1153,24 @@ fn matrix_iter() {\n \n     let expected = [22, 75];\n     let mut iter = expected.iter();\n+    assert_eq!(matrix.count(5), expected.len());\n     for i in matrix.iter(5) {\n         let j = *iter.next().unwrap();\n         assert_eq!(i, j);\n     }\n     assert!(iter.next().is_none());\n+\n+    assert_eq!(matrix.count(6), 100);\n+    let mut count = 0;\n+    for (idx, i) in matrix.iter(6).enumerate() {\n+        assert_eq!(idx, i);\n+        count += 1;\n+    }\n+    assert_eq!(count, 100);\n+\n+    if let Some(i) = matrix.iter(7).next() {\n+        panic!(\"expected no elements in row, but contains element {:?}\", i);\n+    }\n }\n \n #[test]"}, {"sha": "0c81c27a96ee5e018cb7b52ea0f7d101c693d449", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/66e7493543bfef2bdd12454155670cc810de8ea9/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66e7493543bfef2bdd12454155670cc810de8ea9/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=66e7493543bfef2bdd12454155670cc810de8ea9", "patch": "@@ -503,6 +503,16 @@ impl<I: indexed_vec::Idx, CTX> HashStable<CTX> for bit_set::BitSet<I>\n     }\n }\n \n+impl<R: indexed_vec::Idx, C: indexed_vec::Idx, CTX> HashStable<CTX>\n+for bit_set::BitMatrix<R, C>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.words().hash_stable(ctx, hasher);\n+    }\n+}\n+\n impl_stable_hash_via_hash!(::std::path::Path);\n impl_stable_hash_via_hash!(::std::path::PathBuf);\n "}]}