{"sha": "2dc60b1180b2974b8966c33100e9541845e1d2e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkYzYwYjExODBiMjk3NGI4OTY2YzMzMTAwZTk1NDE4NDVlMWQyZTg=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-01-18T03:27:09Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-01-22T21:37:38Z"}, "message": "Refactor `TokenStream`.", "tree": {"sha": "8d5ca1abc7811361e7528325010330143daba668", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d5ca1abc7811361e7528325010330143daba668"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2dc60b1180b2974b8966c33100e9541845e1d2e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2dc60b1180b2974b8966c33100e9541845e1d2e8", "html_url": "https://github.com/rust-lang/rust/commit/2dc60b1180b2974b8966c33100e9541845e1d2e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2dc60b1180b2974b8966c33100e9541845e1d2e8/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec29011346ac91f2acdc0455ad6dc19a6f9614ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec29011346ac91f2acdc0455ad6dc19a6f9614ca", "html_url": "https://github.com/rust-lang/rust/commit/ec29011346ac91f2acdc0455ad6dc19a6f9614ca"}], "stats": {"total": 1712, "additions": 424, "deletions": 1288}, "files": [{"sha": "d7218b6bc89700d5b94357b787e6bf1f50d3b27f", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dc60b1180b2974b8966c33100e9541845e1d2e8/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/2dc60b1180b2974b8966c33100e9541845e1d2e8/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=2dc60b1180b2974b8966c33100e9541845e1d2e8", "patch": "@@ -103,7 +103,7 @@ DEPS_syntax_ext := syntax syntax_pos rustc_errors fmt_macros proc_macro\n DEPS_proc_macro := syntax syntax_pos rustc_plugin log\n DEPS_syntax_pos := serialize\n DEPS_proc_macro_tokens := syntax syntax_pos log\n-DEPS_proc_macro_plugin := syntax syntax_pos rustc_plugin log proc_macro_tokens\n+DEPS_proc_macro_plugin := syntax syntax_pos rustc_plugin\n \n DEPS_rustc_const_math := std syntax log serialize rustc_i128\n DEPS_rustc_const_eval := rustc_const_math rustc syntax log serialize \\"}, {"sha": "86fdece237b9ba3bf80d6e070b1be0876b8513fd", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=2dc60b1180b2974b8966c33100e9541845e1d2e8", "patch": "@@ -208,10 +208,9 @@ dependencies = [\n name = \"proc_macro_plugin\"\n version = \"0.0.0\"\n dependencies = [\n- \"log 0.0.0\",\n- \"proc_macro_tokens 0.0.0\",\n  \"rustc_plugin 0.0.0\",\n  \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n ]\n \n [[package]]"}, {"sha": "f962c888f42cc4da71e568a567a40f3cd563d5dc", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=2dc60b1180b2974b8966c33100e9541845e1d2e8", "patch": "@@ -82,14 +82,15 @@ pub mod __internal {\n     use syntax::ast;\n     use syntax::ptr::P;\n     use syntax::parse::{self, token, ParseSess};\n-    use syntax::tokenstream::TokenStream as TokenStream_;\n+    use syntax::tokenstream::{TokenTree, TokenStream as TokenStream_};\n \n     use super::{TokenStream, LexError};\n \n     pub fn new_token_stream(item: P<ast::Item>) -> TokenStream {\n-        TokenStream { inner: TokenStream_::from_tokens(vec![\n-            token::Interpolated(Rc::new(token::NtItem(item)))\n-        ])}\n+        TokenStream {\n+            inner: TokenTree::Token(item.span, token::Interpolated(Rc::new(token::NtItem(item))))\n+                .into()\n+        }\n     }\n \n     pub fn token_stream_wrap(inner: TokenStream_) -> TokenStream {\n@@ -175,7 +176,7 @@ impl FromStr for TokenStream {\n             let tts = try!(parse::parse_tts_from_source_str(name, src, sess)\n                 .map_err(parse_to_lex_err));\n \n-            Ok(__internal::token_stream_wrap(TokenStream_::from_tts(tts)))\n+            Ok(__internal::token_stream_wrap(tts.into_iter().collect()))\n         })\n     }\n }"}, {"sha": "146a66cdf01cb484586677b7c68cbdc89e2dd233", "filename": "src/libproc_macro_plugin/Cargo.toml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2Flibproc_macro_plugin%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2Flibproc_macro_plugin%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_plugin%2FCargo.toml?ref=2dc60b1180b2974b8966c33100e9541845e1d2e8", "patch": "@@ -8,7 +8,6 @@ path = \"lib.rs\"\n crate-type = [\"dylib\"]\n \n [dependencies]\n-log = { path = \"../liblog\" }\n rustc_plugin = { path = \"../librustc_plugin\" }\n syntax = { path = \"../libsyntax\" }\n-proc_macro_tokens = { path = \"../libproc_macro_tokens\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "e904290957619cbb8f8d0c3d87f3c042c740e420", "filename": "src/libproc_macro_plugin/lib.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2Flibproc_macro_plugin%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2Flibproc_macro_plugin%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_plugin%2Flib.rs?ref=2dc60b1180b2974b8966c33100e9541845e1d2e8", "patch": "@@ -15,11 +15,8 @@\n //! ## Usage\n //! This crate provides the `qquote!` macro for syntax creation.\n //!\n-//! The `qquote!` macro imports `syntax::ext::proc_macro_shim::prelude::*`, so you\n-//! will need to `extern crate syntax` for usage. (This is a temporary solution until more\n-//! of the external API in libproc_macro_tokens is stabilized to support the token construction\n-//! operations that the qausiquoter relies on.) The shim file also provides additional\n-//! operations, such as `build_block_emitter` (as used in the `cond` example below).\n+//! The `qquote!` macro uses the crate `syntax`, so users must declare `extern crate syntax;`\n+//! at the crate root. This is a temporary solution until we have better hygiene.\n //!\n //! ## Quasiquotation\n //!\n@@ -88,19 +85,20 @@\n \n extern crate rustc_plugin;\n extern crate syntax;\n-extern crate proc_macro_tokens;\n-#[macro_use] extern crate log;\n+extern crate syntax_pos;\n \n mod qquote;\n-\n use qquote::qquote;\n \n use rustc_plugin::Registry;\n+use syntax::ext::base::SyntaxExtension;\n+use syntax::symbol::Symbol;\n \n // ____________________________________________________________________________________________\n // Main macro definition\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_macro(\"qquote\", qquote);\n+    reg.register_syntax_extension(Symbol::intern(\"qquote\"),\n+                                  SyntaxExtension::ProcMacro(Box::new(qquote)));\n }"}, {"sha": "69c6eba6c0f89a5aa968f9e254933b5af127e1c1", "filename": "src/libproc_macro_plugin/qquote.rs", "status": "modified", "additions": 159, "deletions": 399, "changes": 558, "blob_url": "https://github.com/rust-lang/rust/blob/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2Flibproc_macro_plugin%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2Flibproc_macro_plugin%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_plugin%2Fqquote.rs?ref=2dc60b1180b2974b8966c33100e9541845e1d2e8", "patch": "@@ -9,463 +9,223 @@\n // except according to those terms.\n \n //! # Quasiquoter\n-//! This file contains the implementation internals of the quasiquoter provided by `quote!`.\n-//!\n-//! ## Ouput\n-//! The quasiquoter produces output of the form:\n-//! let tmp0 = ...;\n-//! let tmp1 = ...;\n-//! ...\n-//! concat(from_tokens(...), concat(...))\n-//!\n-//! To the more explicit, the quasiquoter produces a series of bindings that each\n-//! construct TokenStreams via constructing Tokens and using `from_tokens`, ultimately\n-//! invoking `concat` on these bindings (and inlined expressions) to construct a\n-//! TokenStream that resembles the output syntax.\n-//!\n-\n-use proc_macro_tokens::build::*;\n-use proc_macro_tokens::parse::lex;\n-\n-use qquote::int_build::*;\n+//! This file contains the implementation internals of the quasiquoter provided by `qquote!`.\n \n use syntax::ast::Ident;\n-use syntax::codemap::Span;\n-use syntax::ext::base::*;\n-use syntax::ext::base;\n-use syntax::ext::proc_macro_shim::build_block_emitter;\n-use syntax::parse::token::{self, Token};\n-use syntax::print::pprust;\n+use syntax::parse::token::{self, Token, Lit};\n use syntax::symbol::Symbol;\n-use syntax::tokenstream::{TokenTree, TokenStream};\n+use syntax::tokenstream::{self, Delimited, TokenTree, TokenStream};\n+use syntax_pos::DUMMY_SP;\n \n-// ____________________________________________________________________________________________\n-// Main definition\n-/// The user should use the macro, not this procedure.\n-pub fn qquote<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[TokenTree])\n-                   -> Box<base::MacResult + 'cx> {\n+use std::rc::Rc;\n \n-    debug!(\"\\nTTs in: {:?}\\n\", pprust::tts_to_string(&tts[..]));\n-    let output = qquoter(cx, TokenStream::from_tts(tts.clone().to_owned()));\n-    debug!(\"\\nQQ out: {}\\n\", pprust::tts_to_string(&output.to_tts()[..]));\n-    let imports = concat(lex(\"use syntax::ext::proc_macro_shim::prelude::*;\"),\n-                         lex(\"use proc_macro_tokens::prelude::*;\"));\n-    build_block_emitter(cx, sp, build_brace_delimited(concat(imports, output)))\n+pub fn qquote<'cx>(stream: TokenStream) -> TokenStream {\n+    stream.quote()\n }\n \n-// ____________________________________________________________________________________________\n-// Datatype Definitions\n-\n-#[derive(Debug)]\n-struct QDelimited {\n-    delim: token::DelimToken,\n-    open_span: Span,\n-    tts: Vec<Qtt>,\n-    close_span: Span,\n+trait Quote {\n+    fn quote(&self) -> TokenStream;\n }\n \n-#[derive(Debug)]\n-enum Qtt {\n-    TT(TokenTree),\n-    Delimited(QDelimited),\n-    QIdent(TokenTree),\n+macro_rules! quote_tok {\n+    (,) => { Token::Comma };\n+    (.) => { Token::Dot };\n+    (:) => { Token::Colon };\n+    (::) => { Token::ModSep };\n+    (!) => { Token::Not };\n+    (<) => { Token::Lt };\n+    (>) => { Token::Gt };\n+    (_) => { Token::Underscore };\n+    ($i:ident) => { Token::Ident(Ident::from_str(stringify!($i))) };\n }\n \n-type Bindings = Vec<(Ident, TokenStream)>;\n-\n-// ____________________________________________________________________________________________\n-// Quasiquoter Algorithm\n-// This algorithm works as follows:\n-// Input: TokenStream\n-// 1. Walk the TokenStream, gathering up the unquoted expressions and marking them separately.\n-// 2. Hoist any unquoted term into its own let-binding via a gensym'd identifier\n-// 3. Convert the body from a `complex expression` into a simplified one via `convert_complex_tts\n-// 4. Stitch everything together with `concat`.\n-fn qquoter<'cx>(cx: &'cx mut ExtCtxt, ts: TokenStream) -> TokenStream {\n-    if ts.is_empty() {\n-        return lex(\"TokenStream::mk_empty()\");\n-    }\n-    let qq_res = qquote_iter(cx, 0, ts);\n-    let mut bindings = qq_res.0;\n-    let body = qq_res.1;\n-    let mut cct_res = convert_complex_tts(cx, body);\n-\n-    bindings.append(&mut cct_res.0);\n-\n-    if bindings.is_empty() {\n-        cct_res.1\n-    } else {\n-        debug!(\"BINDINGS\");\n-        for b in bindings.clone() {\n-            debug!(\"{:?} = {}\", b.0, pprust::tts_to_string(&b.1.to_tts()[..]));\n-        }\n-        TokenStream::concat(unravel(bindings), cct_res.1)\n-   }\n+macro_rules! quote_tree {\n+    ((unquote $($t:tt)*)) => { $($t)* };\n+    ((quote $($t:tt)*)) => { ($($t)*).quote() };\n+    (($($t:tt)*)) => { delimit(token::Paren, quote!($($t)*)) };\n+    ([$($t:tt)*]) => { delimit(token::Bracket, quote!($($t)*)) };\n+    ({$($t:tt)*}) => { delimit(token::Brace, quote!($($t)*)) };\n+    ($t:tt) => { TokenStream::from(TokenTree::Token(DUMMY_SP, quote_tok!($t))) };\n }\n \n-fn qquote_iter<'cx>(cx: &'cx mut ExtCtxt, depth: i64, ts: TokenStream) -> (Bindings, Vec<Qtt>) {\n-    let mut depth = depth;\n-    let mut bindings: Bindings = Vec::new();\n-    let mut output: Vec<Qtt> = Vec::new();\n-\n-    let mut iter = ts.iter();\n-\n-    loop {\n-        let next = iter.next();\n-        if next.is_none() {\n-            break;\n-        }\n-        let next = next.unwrap().clone();\n-        match next {\n-            TokenTree::Token(_, Token::Ident(id)) if is_unquote(id) => {\n-                if depth == 0 {\n-                    let exp = iter.next();\n-                    if exp.is_none() {\n-                        break;\n-                    } // produce an error or something first\n-                    let exp = vec![exp.unwrap().to_owned()];\n-                    debug!(\"RHS: {:?}\", exp.clone());\n-                    let new_id = Ident::with_empty_ctxt(Symbol::gensym(\"tmp\"));\n-                    debug!(\"RHS TS: {:?}\", TokenStream::from_tts(exp.clone()));\n-                    debug!(\"RHS TS TT: {:?}\", TokenStream::from_tts(exp.clone()).to_vec());\n-                    bindings.push((new_id, TokenStream::from_tts(exp)));\n-                    debug!(\"BINDINGS\");\n-                    for b in bindings.clone() {\n-                        debug!(\"{:?} = {}\", b.0, pprust::tts_to_string(&b.1.to_tts()[..]));\n-                    }\n-                    output.push(Qtt::QIdent(as_tt(Token::Ident(new_id.clone()))));\n-                } else {\n-                    depth = depth - 1;\n-                    output.push(Qtt::TT(next.clone()));\n-                }\n-            }\n-            TokenTree::Token(_, Token::Ident(id)) if is_qquote(id) => {\n-                depth = depth + 1;\n-            }\n-            TokenTree::Delimited(_, ref dl) => {\n-                let br = qquote_iter(cx, depth, TokenStream::from_tts(dl.tts.clone().to_owned()));\n-                let mut nested_bindings = br.0;\n-                let nested = br.1;\n-                bindings.append(&mut nested_bindings);\n-\n-                let new_dl = QDelimited {\n-                    delim: dl.delim,\n-                    open_span: dl.open_span,\n-                    tts: nested,\n-                    close_span: dl.close_span,\n-                };\n-\n-                output.push(Qtt::Delimited(new_dl));\n-            }\n-            t => {\n-                output.push(Qtt::TT(t));\n-            }\n-        }\n-    }\n+fn delimit(delim: token::DelimToken, stream: TokenStream) -> TokenStream {\n+    TokenTree::Delimited(DUMMY_SP, Rc::new(Delimited {\n+        delim: delim,\n+        tts: stream.trees().cloned().collect(),\n+        open_span: DUMMY_SP,\n+        close_span: DUMMY_SP,\n+    })).into()\n+}\n \n-    (bindings, output)\n+macro_rules! quote {\n+    () => { TokenStream::empty() };\n+    ($($t:tt)*) => { [ $( quote_tree!($t), )* ].iter().cloned().collect::<TokenStream>() };\n }\n \n-// ____________________________________________________________________________________________\n-// Turns QQTs into a TokenStream and some Bindings.\n-/// Construct a chain of concatenations.\n-fn unravel_concats(tss: Vec<TokenStream>) -> TokenStream {\n-    let mut pushes: Vec<TokenStream> =\n-        tss.into_iter().filter(|&ref ts| !ts.is_empty()).collect();\n-    let mut output = match pushes.pop() {\n-        Some(ts) => ts,\n-        None => {\n-            return TokenStream::mk_empty();\n+impl<T: Quote> Quote for Option<T> {\n+    fn quote(&self) -> TokenStream {\n+        match *self {\n+            Some(ref t) => quote!(::std::option::Option::Some((quote t))),\n+            None => quote!(::std::option::Option::None),\n         }\n-    };\n-\n-    while let Some(ts) = pushes.pop() {\n-        output = build_fn_call(Ident::from_str(\"concat\"),\n-                               concat(concat(ts,\n-                                             from_tokens(vec![Token::Comma])),\n-                                      output));\n     }\n-    output\n }\n \n-/// This converts the vector of Qtts into a set of Bindings for construction and the main\n-/// body as a TokenStream.\n-fn convert_complex_tts<'cx>(cx: &'cx mut ExtCtxt, tts: Vec<Qtt>) -> (Bindings, TokenStream) {\n-    let mut pushes: Vec<TokenStream> = Vec::new();\n-    let mut bindings: Bindings = Vec::new();\n+impl Quote for TokenStream {\n+    fn quote(&self) -> TokenStream {\n+        if self.is_empty() {\n+            return quote!(::syntax::tokenstream::TokenStream::empty());\n+        }\n \n-    let mut iter = tts.into_iter();\n+        struct Quote<'a>(tokenstream::Cursor<'a>);\n \n-    loop {\n-        let next = iter.next();\n-        if next.is_none() {\n-            break;\n-        }\n-        let next = next.unwrap();\n-        match next {\n-            Qtt::TT(TokenTree::Token(_, t)) => {\n-                let token_out = emit_token(t);\n-                pushes.push(token_out);\n-            }\n-            // FIXME handle sequence repetition tokens\n-            Qtt::Delimited(qdl) => {\n-                debug!(\"  Delimited: {:?} \", qdl.tts);\n-                let fresh_id = Ident::with_empty_ctxt(Symbol::gensym(\"qdl_tmp\"));\n-                let (mut nested_bindings, nested_toks) = convert_complex_tts(cx, qdl.tts);\n+        impl<'a> Iterator for Quote<'a> {\n+            type Item = TokenStream;\n \n-                let body = if nested_toks.is_empty() {\n-                    assert!(nested_bindings.is_empty());\n-                    build_mod_call(vec![Ident::from_str(\"TokenStream\"),\n-                                        Ident::from_str(\"mk_empty\")],\n-                                   TokenStream::mk_empty())\n-                } else {\n-                    bindings.append(&mut nested_bindings);\n-                    bindings.push((fresh_id, nested_toks));\n-                    TokenStream::from_tokens(vec![Token::Ident(fresh_id)])\n+            fn next(&mut self) -> Option<TokenStream> {\n+                let is_unquote = match self.0.peek() {\n+                    Some(&TokenTree::Token(_, Token::Ident(ident))) if ident.name == \"unquote\" => {\n+                        self.0.next();\n+                        true\n+                    }\n+                    _ => false,\n                 };\n \n-                let delimitiers = build_delim_tok(qdl.delim);\n-\n-                pushes.push(build_mod_call(vec![Ident::from_str(\"proc_macro_tokens\"),\n-                                                Ident::from_str(\"build\"),\n-                                                Ident::from_str(\"build_delimited\")],\n-                                           flatten(vec![body,\n-                                                        lex(\",\"),\n-                                                        delimitiers].into_iter())));\n+                self.0.next().cloned().map(|tree| {\n+                    let quoted_tree = if is_unquote { tree.into() } else { tree.quote() };\n+                    quote!(::syntax::tokenstream::TokenStream::from((unquote quoted_tree)),)\n+                })\n             }\n-            Qtt::QIdent(t) => {\n-                pushes.push(TokenStream::from_tts(vec![t]));\n-                pushes.push(TokenStream::mk_empty());\n-            }\n-            _ => panic!(\"Unhandled case!\"),\n         }\n \n+        let quoted = Quote(self.trees()).collect::<TokenStream>();\n+        quote!([(unquote quoted)].iter().cloned().collect::<::syntax::tokenstream::TokenStream>())\n     }\n-\n-    (bindings, unravel_concats(pushes))\n }\n \n-// ____________________________________________________________________________________________\n-// Utilities\n-\n-/// Unravels Bindings into a TokenStream of `let` declarations.\n-fn unravel(bindings: Bindings) -> TokenStream {\n-    flatten(bindings.into_iter().map(|(a, b)| build_let(a, b)))\n+impl Quote for Vec<TokenTree> {\n+    fn quote(&self) -> TokenStream {\n+        let stream = self.iter().cloned().collect::<TokenStream>();\n+        quote!((quote stream).trees().cloned().collect::<::std::vec::Vec<_> >())\n+    }\n }\n \n-/// Checks if the Ident is `unquote`.\n-fn is_unquote(id: Ident) -> bool {\n-    let qq = Ident::from_str(\"unquote\");\n-    id.name == qq.name  // We disregard context; unquote is _reserved_\n+impl Quote for TokenTree {\n+    fn quote(&self) -> TokenStream {\n+        match *self {\n+            TokenTree::Token(_, ref token) => quote! {\n+                ::syntax::tokenstream::TokenTree::Token(::syntax::ext::quote::rt::DUMMY_SP,\n+                                                        (quote token))\n+            },\n+            TokenTree::Delimited(_, ref delimited) => quote! {\n+                ::syntax::tokenstream::TokenTree::Delimited(::syntax::ext::quote::rt::DUMMY_SP,\n+                                                            (quote delimited))\n+            },\n+            _ => panic!(\"unexpected `TokenTree::Sequence` in `qquote`\"),\n+        }\n+    }\n }\n \n-/// Checks if the Ident is `quote`.\n-fn is_qquote(id: Ident) -> bool {\n-    let qq = Ident::from_str(\"qquote\");\n-    id.name == qq.name  // We disregard context; qquote is _reserved_\n+impl Quote for Rc<Delimited> {\n+    fn quote(&self) -> TokenStream {\n+        quote!(::std::rc::Rc::new(::syntax::tokenstream::Delimited {\n+            open_span: ::syntax::ext::quote::rt::DUMMY_SP,\n+            close_span: ::syntax::ext::quote::rt::DUMMY_SP,\n+            delim: (quote self.delim),\n+            tts: (quote self.tts),\n+        }))\n+    }\n }\n \n-mod int_build {\n-    use proc_macro_tokens::build::*;\n-    use proc_macro_tokens::parse::*;\n-\n-    use syntax::ast::{self, Ident};\n-    use syntax::codemap::{DUMMY_SP};\n-    use syntax::parse::token::{self, Token, Lit};\n-    use syntax::symbol::keywords;\n-    use syntax::tokenstream::{TokenTree, TokenStream};\n-\n-    // ____________________________________________________________________________________________\n-    // Emitters\n-\n-    pub fn emit_token(t: Token) -> TokenStream {\n-        concat(lex(\"TokenStream::from_tokens\"),\n-               build_paren_delimited(build_vec(build_token_tt(t))))\n+impl<'a> Quote for &'a str {\n+    fn quote(&self) -> TokenStream {\n+        TokenTree::Token(DUMMY_SP, Token::Literal(token::Lit::Str_(Symbol::intern(self)), None))\n+            .into()\n     }\n+}\n \n-    pub fn emit_lit(l: Lit, n: Option<ast::Name>) -> TokenStream {\n-        let suf = match n {\n-            Some(n) => format!(\"Some(ast::Name({}))\", n.as_u32()),\n-            None => \"None\".to_string(),\n-        };\n-\n-        let lit = match l {\n-            Lit::Byte(n) => format!(\"Lit::Byte(Symbol::intern(\\\"{}\\\"))\", n.to_string()),\n-            Lit::Char(n) => format!(\"Lit::Char(Symbol::intern(\\\"{}\\\"))\", n.to_string()),\n-            Lit::Float(n) => format!(\"Lit::Float(Symbol::intern(\\\"{}\\\"))\", n.to_string()),\n-            Lit::Str_(n) => format!(\"Lit::Str_(Symbol::intern(\\\"{}\\\"))\", n.to_string()),\n-            Lit::Integer(n) => format!(\"Lit::Integer(Symbol::intern(\\\"{}\\\"))\", n.to_string()),\n-            Lit::ByteStr(n) => format!(\"Lit::ByteStr(Symbol::intern(\\\"{}\\\"))\", n.to_string()),\n-            _ => panic!(\"Unsupported literal\"),\n-        };\n-\n-        let res = format!(\"Token::Literal({},{})\", lit, suf);\n-        debug!(\"{}\", res);\n-        lex(&res)\n+impl Quote for Ident {\n+    fn quote(&self) -> TokenStream {\n+        // FIXME(jseyfried) quote hygiene\n+        quote!(::syntax::ast::Ident::from_str((quote &*self.name.as_str())))\n     }\n+}\n \n-    // ____________________________________________________________________________________________\n-    // Token Builders\n-\n-    pub fn build_binop_tok(bot: token::BinOpToken) -> TokenStream {\n-        match bot {\n-            token::BinOpToken::Plus => lex(\"Token::BinOp(BinOpToken::Plus)\"),\n-            token::BinOpToken::Minus => lex(\"Token::BinOp(BinOpToken::Minus)\"),\n-            token::BinOpToken::Star => lex(\"Token::BinOp(BinOpToken::Star)\"),\n-            token::BinOpToken::Slash => lex(\"Token::BinOp(BinOpToken::Slash)\"),\n-            token::BinOpToken::Percent => lex(\"Token::BinOp(BinOpToken::Percent)\"),\n-            token::BinOpToken::Caret => lex(\"Token::BinOp(BinOpToken::Caret)\"),\n-            token::BinOpToken::And => lex(\"Token::BinOp(BinOpToken::And)\"),\n-            token::BinOpToken::Or => lex(\"Token::BinOp(BinOpToken::Or)\"),\n-            token::BinOpToken::Shl => lex(\"Token::BinOp(BinOpToken::Shl)\"),\n-            token::BinOpToken::Shr => lex(\"Token::BinOp(BinOpToken::Shr)\"),\n-        }\n+impl Quote for Symbol {\n+    fn quote(&self) -> TokenStream {\n+        quote!(::syntax::symbol::Symbol::intern((quote &*self.as_str())))\n     }\n+}\n \n-    pub fn build_binopeq_tok(bot: token::BinOpToken) -> TokenStream {\n-        match bot {\n-            token::BinOpToken::Plus => lex(\"Token::BinOpEq(BinOpToken::Plus)\"),\n-            token::BinOpToken::Minus => lex(\"Token::BinOpEq(BinOpToken::Minus)\"),\n-            token::BinOpToken::Star => lex(\"Token::BinOpEq(BinOpToken::Star)\"),\n-            token::BinOpToken::Slash => lex(\"Token::BinOpEq(BinOpToken::Slash)\"),\n-            token::BinOpToken::Percent => lex(\"Token::BinOpEq(BinOpToken::Percent)\"),\n-            token::BinOpToken::Caret => lex(\"Token::BinOpEq(BinOpToken::Caret)\"),\n-            token::BinOpToken::And => lex(\"Token::BinOpEq(BinOpToken::And)\"),\n-            token::BinOpToken::Or => lex(\"Token::BinOpEq(BinOpToken::Or)\"),\n-            token::BinOpToken::Shl => lex(\"Token::BinOpEq(BinOpToken::Shl)\"),\n-            token::BinOpToken::Shr => lex(\"Token::BinOpEq(BinOpToken::Shr)\"),\n+impl Quote for Token {\n+    fn quote(&self) -> TokenStream {\n+        macro_rules! gen_match {\n+            ($($i:ident),*; $($t:tt)*) => {\n+                match *self {\n+                    $( Token::$i => quote!(::syntax::parse::token::$i), )*\n+                    $( $t )*\n+                }\n+            }\n         }\n-    }\n \n-    pub fn build_delim_tok(dt: token::DelimToken) -> TokenStream {\n-        match dt {\n-            token::DelimToken::Paren => lex(\"DelimToken::Paren\"),\n-            token::DelimToken::Bracket => lex(\"DelimToken::Bracket\"),\n-            token::DelimToken::Brace => lex(\"DelimToken::Brace\"),\n-            token::DelimToken::NoDelim => lex(\"DelimToken::NoDelim\"),\n+        gen_match! {\n+            Eq, Lt, Le, EqEq, Ne, Ge, Gt, AndAnd, OrOr, Not, Tilde, At, Dot, DotDot, DotDotDot,\n+            Comma, Semi, Colon, ModSep, RArrow, LArrow, FatArrow, Pound, Dollar, Question,\n+            Underscore;\n+\n+            Token::OpenDelim(delim) => quote!(::syntax::parse::token::OpenDelim((quote delim))),\n+            Token::CloseDelim(delim) => quote!(::syntax::parse::token::CloseDelim((quote delim))),\n+            Token::BinOp(tok) => quote!(::syntax::parse::token::BinOp((quote tok))),\n+            Token::BinOpEq(tok) => quote!(::syntax::parse::token::BinOpEq((quote tok))),\n+            Token::Ident(ident) => quote!(::syntax::parse::token::Ident((quote ident))),\n+            Token::Lifetime(ident) => quote!(::syntax::parse::token::Lifetime((quote ident))),\n+            Token::Literal(lit, sfx) => quote! {\n+                ::syntax::parse::token::Literal((quote lit), (quote sfx))\n+            },\n+            _ => panic!(\"Unhandled case!\"),\n         }\n     }\n+}\n \n-    pub fn build_token_tt(t: Token) -> TokenStream {\n-        match t {\n-            Token::Eq => lex(\"Token::Eq\"),\n-            Token::Lt => lex(\"Token::Lt\"),\n-            Token::Le => lex(\"Token::Le\"),\n-            Token::EqEq => lex(\"Token::EqEq\"),\n-            Token::Ne => lex(\"Token::Ne\"),\n-            Token::Ge => lex(\"Token::Ge\"),\n-            Token::Gt => lex(\"Token::Gt\"),\n-            Token::AndAnd => lex(\"Token::AndAnd\"),\n-            Token::OrOr => lex(\"Token::OrOr\"),\n-            Token::Not => lex(\"Token::Not\"),\n-            Token::Tilde => lex(\"Token::Tilde\"),\n-            Token::BinOp(tok) => build_binop_tok(tok),\n-            Token::BinOpEq(tok) => build_binopeq_tok(tok),\n-            Token::At => lex(\"Token::At\"),\n-            Token::Dot => lex(\"Token::Dot\"),\n-            Token::DotDot => lex(\"Token::DotDot\"),\n-            Token::DotDotDot => lex(\"Token::DotDotDot\"),\n-            Token::Comma => lex(\"Token::Comma\"),\n-            Token::Semi => lex(\"Token::Semi\"),\n-            Token::Colon => lex(\"Token::Colon\"),\n-            Token::ModSep => lex(\"Token::ModSep\"),\n-            Token::RArrow => lex(\"Token::RArrow\"),\n-            Token::LArrow => lex(\"Token::LArrow\"),\n-            Token::FatArrow => lex(\"Token::FatArrow\"),\n-            Token::Pound => lex(\"Token::Pound\"),\n-            Token::Dollar => lex(\"Token::Dollar\"),\n-            Token::Question => lex(\"Token::Question\"),\n-            Token::OpenDelim(dt) => {\n-                match dt {\n-                    token::DelimToken::Paren => lex(\"Token::OpenDelim(DelimToken::Paren)\"),\n-                    token::DelimToken::Bracket => lex(\"Token::OpenDelim(DelimToken::Bracket)\"),\n-                    token::DelimToken::Brace => lex(\"Token::OpenDelim(DelimToken::Brace)\"),\n-                    token::DelimToken::NoDelim => lex(\"DelimToken::NoDelim\"),\n+impl Quote for token::BinOpToken {\n+    fn quote(&self) -> TokenStream {\n+        macro_rules! gen_match {\n+            ($($i:ident),*) => {\n+                match *self {\n+                    $( token::BinOpToken::$i => quote!(::syntax::parse::token::BinOpToken::$i), )*\n                 }\n             }\n-            Token::CloseDelim(dt) => {\n-                match dt {\n-                    token::DelimToken::Paren => lex(\"Token::CloseDelim(DelimToken::Paren)\"),\n-                    token::DelimToken::Bracket => lex(\"Token::CloseDelim(DelimToken::Bracket)\"),\n-                    token::DelimToken::Brace => lex(\"Token::CloseDelim(DelimToken::Brace)\"),\n-                    token::DelimToken::NoDelim => lex(\"DelimToken::NoDelim\"),\n-                }\n-            }\n-            Token::Underscore => lex(\"_\"),\n-            Token::Literal(lit, sfx) => emit_lit(lit, sfx),\n-            // fix ident expansion information... somehow\n-            Token::Ident(ident) =>\n-                lex(&format!(\"Token::Ident(Ident::from_str(\\\"{}\\\"))\", ident.name)),\n-            Token::Lifetime(ident) =>\n-                lex(&format!(\"Token::Ident(Ident::from_str(\\\"{}\\\"))\", ident.name)),\n-            _ => panic!(\"Unhandled case!\"),\n         }\n-    }\n-\n-    // ____________________________________________________________________________________________\n-    // Conversion operators\n \n-    pub fn as_tt(t: Token) -> TokenTree {\n-        // FIXME do something nicer with the spans\n-        TokenTree::Token(DUMMY_SP, t)\n-    }\n-\n-    // ____________________________________________________________________________________________\n-    // Build Procedures\n-\n-    /// Takes `input` and returns `vec![input]`.\n-    pub fn build_vec(ts: TokenStream) -> TokenStream {\n-        build_mac_call(Ident::from_str(\"vec\"), ts)\n-        // tts.clone().to_owned()\n-    }\n-\n-    /// Takes `ident` and `rhs` and produces `let ident = rhs;`.\n-    pub fn build_let(id: Ident, tts: TokenStream) -> TokenStream {\n-        concat(from_tokens(vec![keyword_to_token_ident(keywords::Let),\n-                                Token::Ident(id),\n-                                Token::Eq]),\n-               concat(tts, from_tokens(vec![Token::Semi])))\n-    }\n-\n-    /// Takes `ident ...`, and `args ...` and produces `ident::...(args ...)`.\n-    pub fn build_mod_call(ids: Vec<Ident>, args: TokenStream) -> TokenStream {\n-        let call = from_tokens(intersperse(ids.into_iter().map(|id| Token::Ident(id)).collect(),\n-                                     Token::ModSep));\n-        concat(call, build_paren_delimited(args))\n-    }\n-\n-    /// Takes `ident` and `args ...` and produces `ident(args ...)`.\n-    pub fn build_fn_call(name: Ident, args: TokenStream) -> TokenStream {\n-        concat(from_tokens(vec![Token::Ident(name)]), build_paren_delimited(args))\n-    }\n-\n-    /// Takes `ident` and `args ...` and produces `ident!(args ...)`.\n-    pub fn build_mac_call(name: Ident, args: TokenStream) -> TokenStream {\n-        concat(from_tokens(vec![Token::Ident(name), Token::Not]),\n-               build_paren_delimited(args))\n+        gen_match!(Plus, Minus, Star, Slash, Percent, Caret, And, Or, Shl, Shr)\n     }\n+}\n \n-    // ____________________________________________________________________________________________\n-    // Utilities\n+impl Quote for Lit {\n+    fn quote(&self) -> TokenStream {\n+        macro_rules! gen_match {\n+            ($($i:ident),*) => {\n+                match *self {\n+                    $( Lit::$i(lit) => quote!(::syntax::parse::token::Lit::$i((quote lit))), )*\n+                    _ => panic!(\"Unsupported literal\"),\n+                }\n+            }\n+        }\n \n-    /// A wrapper around `TokenStream::from_tokens` to avoid extra namespace specification and\n-    /// provide it as a generic operator.\n-    pub fn from_tokens(tokens: Vec<Token>) -> TokenStream {\n-        TokenStream::from_tokens(tokens)\n+        gen_match!(Byte, Char, Float, Str_, Integer, ByteStr)\n     }\n+}\n \n-    pub fn intersperse<T>(vs: Vec<T>, t: T) -> Vec<T>\n-        where T: Clone\n-    {\n-        if vs.len() < 2 {\n-            return vs;\n+impl Quote for token::DelimToken {\n+    fn quote(&self) -> TokenStream {\n+        macro_rules! gen_match {\n+            ($($i:ident),*) => {\n+                match *self {\n+                    $(token::DelimToken::$i => { quote!(::syntax::parse::token::DelimToken::$i) })*\n+                }\n+            }\n         }\n-        let mut output = vec![vs.get(0).unwrap().to_owned()];\n \n-        for v in vs.into_iter().skip(1) {\n-            output.push(t.clone());\n-            output.push(v);\n-        }\n-        output\n+        gen_match!(Paren, Bracket, Brace, NoDelim)\n     }\n }"}, {"sha": "ed97d57cccd91dfc8625b2e11311646bd1e13bad", "filename": "src/libproc_macro_tokens/build.rs", "status": "modified", "additions": 8, "deletions": 23, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2Flibproc_macro_tokens%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2Flibproc_macro_tokens%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_tokens%2Fbuild.rs?ref=2dc60b1180b2974b8966c33100e9541845e1d2e8", "patch": "@@ -18,20 +18,7 @@ use std::rc::Rc;\n /// A wrapper around `TokenStream::concat` to avoid extra namespace specification and\n /// provide TokenStream concatenation as a generic operator.\n pub fn concat(ts1: TokenStream, ts2: TokenStream) -> TokenStream {\n-    TokenStream::concat(ts1, ts2)\n-}\n-\n-/// Flatten a sequence of TokenStreams into a single TokenStream.\n-pub fn flatten<T: Iterator<Item=TokenStream>>(mut iter: T) -> TokenStream {\n-    match iter.next() {\n-        Some(mut ts) => {\n-            for next in iter {\n-                ts = TokenStream::concat(ts, next);\n-            }\n-            ts\n-        }\n-        None => TokenStream::mk_empty()\n-    }\n+    TokenStream::concat([ts1, ts2].iter().cloned())\n }\n \n /// Checks if two identifiers have the same name, disregarding context. This allows us to\n@@ -69,14 +56,12 @@ pub fn keyword_to_token_ident(kw: keywords::Keyword) -> Token {\n /// Generically takes a `ts` and delimiter and returns `ts` delimited by the specified\n /// delimiter.\n pub fn build_delimited(ts: TokenStream, delim: token::DelimToken) -> TokenStream {\n-    let tts = ts.to_tts();\n-    TokenStream::from_tts(vec![TokenTree::Delimited(DUMMY_SP,\n-                                                    Rc::new(tokenstream::Delimited {\n-                                                        delim: delim,\n-                                                        open_span: DUMMY_SP,\n-                                                        tts: tts,\n-                                                        close_span: DUMMY_SP,\n-                                                    }))])\n+    TokenTree::Delimited(DUMMY_SP, Rc::new(tokenstream::Delimited {\n+        delim: delim,\n+        open_span: DUMMY_SP,\n+        tts: ts.trees().cloned().collect(),\n+        close_span: DUMMY_SP,\n+    })).into()\n }\n \n /// Takes `ts` and returns `[ts]`.\n@@ -96,5 +81,5 @@ pub fn build_paren_delimited(ts: TokenStream) -> TokenStream {\n \n /// Constructs `()`.\n pub fn build_empty_args() -> TokenStream {\n-    build_paren_delimited(TokenStream::mk_empty())\n+    build_paren_delimited(TokenStream::empty())\n }"}, {"sha": "d1c1e99bcdc7ae96609475f55fc635b22b5d7229", "filename": "src/libproc_macro_tokens/parse.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2Flibproc_macro_tokens%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2Flibproc_macro_tokens%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_tokens%2Fparse.rs?ref=2dc60b1180b2974b8966c33100e9541845e1d2e8", "patch": "@@ -16,9 +16,8 @@ use syntax::tokenstream::TokenStream;\n /// Map a string to tts, using a made-up filename. For example, `lex(\"15\")` will return a\n /// TokenStream containing the literal 15.\n pub fn lex(source_str: &str) -> TokenStream {\n-    let ps = ParseSess::new();\n-    TokenStream::from_tts(filemap_to_tts(&ps,\n-                                         ps.codemap().new_filemap(\"<procmacro_lex>\".to_string(),\n-                                                                  None,\n-                                                                  source_str.to_owned())))\n+    let sess = ParseSess::new();\n+    let filemap =\n+        sess.codemap().new_filemap(\"<procmacro_lex>\".to_string(), None, source_str.to_owned());\n+    filemap_to_tts(&sess, filemap).into_iter().collect()\n }"}, {"sha": "0f4b844b0eac81e5f3f71894fb7aa51587cd2c8b", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=2dc60b1180b2974b8966c33100e9541845e1d2e8", "patch": "@@ -73,23 +73,6 @@ pub fn dummy_spanned<T>(t: T) -> Spanned<T> {\n     respan(DUMMY_SP, t)\n }\n \n-/// Build a span that covers the two provided spans.\n-pub fn combine_spans(sp1: Span, sp2: Span) -> Span {\n-    if sp1 == DUMMY_SP && sp2 == DUMMY_SP {\n-        DUMMY_SP\n-    } else if sp1 == DUMMY_SP {\n-        sp2\n-    } else if sp2 == DUMMY_SP {\n-        sp1\n-    } else {\n-        Span {\n-            lo: if sp1.lo < sp2.lo { sp1.lo } else { sp2.lo },\n-            hi: if sp1.hi > sp2.hi { sp1.hi } else { sp2.hi },\n-            expn_id: if sp1.expn_id == sp2.expn_id { sp1.expn_id } else { NO_EXPANSION },\n-        }\n-    }\n-}\n-\n #[derive(Clone, Hash, Debug)]\n pub struct NameAndSpan {\n     /// The format with which the macro was invoked."}, {"sha": "226625ebc8e5e4fd0cf501ac92ca1145e7029506", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=2dc60b1180b2974b8966c33100e9541845e1d2e8", "patch": "@@ -364,10 +364,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 kind.expect_from_annotatables(items)\n             }\n             SyntaxExtension::AttrProcMacro(ref mac) => {\n-                let attr_toks = TokenStream::from_tts(tts_for_attr_args(&attr,\n-                                                                        &self.cx.parse_sess));\n-\n-                let item_toks = TokenStream::from_tts(tts_for_item(&item, &self.cx.parse_sess));\n+                let attr_toks = tts_for_attr_args(&attr, &self.cx.parse_sess).into_iter().collect();\n+                let item_toks = tts_for_item(&item, &self.cx.parse_sess).into_iter().collect();\n \n                 let tok_result = mac.expand(self.cx, attr.span, attr_toks, item_toks);\n                 self.parse_expansion(tok_result, kind, name, attr.span)\n@@ -467,7 +465,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     },\n                 });\n \n-                let toks = TokenStream::from_tts(marked_tts);\n+                let toks = marked_tts.into_iter().collect();\n                 let tok_result = expandfun.expand(self.cx, span, toks);\n                 Some(self.parse_expansion(tok_result, kind, extname, span))\n             }\n@@ -490,7 +488,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n     fn parse_expansion(&mut self, toks: TokenStream, kind: ExpansionKind, name: Name, span: Span)\n                        -> Expansion {\n-        let mut parser = self.cx.new_parser_from_tts(&toks.to_tts());\n+        let mut parser = self.cx.new_parser_from_tts(&toks.trees().cloned().collect::<Vec<_>>());\n         let expansion = match parser.parse_expansion(kind, false) {\n             Ok(expansion) => expansion,\n             Err(mut err) => {"}, {"sha": "21ce89a6dd5be7d54ec78a3d4dde8a87082e2048", "filename": "src/libsyntax/ext/proc_macro_shim.rs", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/ec29011346ac91f2acdc0455ad6dc19a6f9614ca/src%2Flibsyntax%2Fext%2Fproc_macro_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec29011346ac91f2acdc0455ad6dc19a6f9614ca/src%2Flibsyntax%2Fext%2Fproc_macro_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro_shim.rs?ref=ec29011346ac91f2acdc0455ad6dc19a6f9614ca", "patch": "@@ -1,72 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! This is a shim file to ease the transition to the final procedural macro interface for\n-//! Macros 2.0. It currently exposes the `libsyntax` operations that the quasiquoter's\n-//! output needs to compile correctly, along with the following operators:\n-//!\n-//! - `build_block_emitter`, which produces a `block` output macro result from the\n-//!   provided TokenStream.\n-\n-use ast;\n-use codemap::Span;\n-use parse::parser::Parser;\n-use ptr::P;\n-use tokenstream::TokenStream;\n-use ext::base::*;\n-\n-/// Take a `ExtCtxt`, `Span`, and `TokenStream`, and produce a Macro Result that parses\n-/// the TokenStream as a block and returns it as an `Expr`.\n-pub fn build_block_emitter<'cx>(cx: &'cx mut ExtCtxt,\n-                                sp: Span,\n-                                output: TokenStream)\n-                                -> Box<MacResult + 'cx> {\n-    let parser = cx.new_parser_from_tts(&output.to_tts());\n-\n-    struct Result<'a> {\n-        prsr: Parser<'a>,\n-        span: Span,\n-    }; //FIXME is this the right lifetime\n-\n-    impl<'a> Result<'a> {\n-        fn block(&mut self) -> P<ast::Block> {\n-            let res = self.prsr.parse_block().unwrap();\n-            res\n-        }\n-    }\n-\n-    impl<'a> MacResult for Result<'a> {\n-        fn make_expr(self: Box<Self>) -> Option<P<ast::Expr>> {\n-            let mut me = *self;\n-            Some(P(ast::Expr {\n-                id: ast::DUMMY_NODE_ID,\n-                node: ast::ExprKind::Block(me.block()),\n-                span: me.span,\n-                attrs: ast::ThinVec::new(),\n-            }))\n-\n-        }\n-    }\n-\n-    Box::new(Result {\n-        prsr: parser,\n-        span: sp,\n-    })\n-}\n-\n-pub mod prelude {\n-    pub use super::build_block_emitter;\n-    pub use ast::Ident;\n-    pub use codemap::{DUMMY_SP, Span};\n-    pub use ext::base::{ExtCtxt, MacResult};\n-    pub use parse::token::{self, Token, DelimToken};\n-    pub use symbol::keywords;\n-    pub use tokenstream::{TokenTree, TokenStream};\n-}"}, {"sha": "871e6b3783a41e7d4daba1932e38874e97fc5dd8", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=2dc60b1180b2974b8966c33100e9541845e1d2e8", "patch": "@@ -89,6 +89,9 @@ pub mod util {\n \n     mod thin_vec;\n     pub use self::thin_vec::ThinVec;\n+\n+    mod rc_slice;\n+    pub use self::rc_slice::RcSlice;\n }\n \n pub mod json;\n@@ -129,7 +132,6 @@ pub mod ext {\n     pub mod expand;\n     pub mod placeholders;\n     pub mod hygiene;\n-    pub mod proc_macro_shim;\n     pub mod quote;\n     pub mod source_util;\n "}, {"sha": "65e7ec0a34cf7775e458f2202ff78aeab88013b1", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=2dc60b1180b2974b8966c33100e9541845e1d2e8", "patch": "@@ -196,7 +196,7 @@ pub fn new_parser_from_tts<'a>(sess: &'a ParseSess, tts: Vec<tokenstream::TokenT\n }\n \n pub fn new_parser_from_ts<'a>(sess: &'a ParseSess, ts: tokenstream::TokenStream) -> Parser<'a> {\n-    tts_to_parser(sess, ts.to_tts())\n+    tts_to_parser(sess, ts.trees().cloned().collect())\n }\n \n "}, {"sha": "26e976dc0762fc5d7c41cb47e3ae409d4dd1f011", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 127, "deletions": 684, "changes": 811, "blob_url": "https://github.com/rust-lang/rust/blob/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=2dc60b1180b2974b8966c33100e9541845e1d2e8", "patch": "@@ -25,19 +25,19 @@\n //! ownership of the original.\n \n use ast::{self, AttrStyle, LitKind};\n-use syntax_pos::{Span, DUMMY_SP, NO_EXPANSION};\n-use codemap::{Spanned, combine_spans};\n+use syntax_pos::Span;\n+use codemap::Spanned;\n use ext::base;\n use ext::tt::macro_parser;\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use parse::{self, Directory};\n use parse::token::{self, Token, Lit, Nonterminal};\n use print::pprust;\n+use serialize::{Decoder, Decodable, Encoder, Encodable};\n use symbol::Symbol;\n+use util::RcSlice;\n \n-use std::fmt;\n-use std::iter::*;\n-use std::ops::{self, Index};\n+use std::{fmt, iter};\n use std::rc::Rc;\n \n /// A delimited sequence of token trees\n@@ -323,555 +323,158 @@ impl TokenTree {\n     }\n }\n \n-/// #Token Streams\n+/// # Token Streams\n ///\n-/// TokenStreams are a syntactic abstraction over TokenTrees. The goal is for procedural\n-/// macros to work over TokenStreams instead of arbitrary syntax. For now, however, we\n-/// are going to cut a few corners (i.e., use some of the AST structure) when we need to\n-/// for backwards compatibility.\n-\n-/// TokenStreams are collections of TokenTrees that represent a syntactic structure. The\n-/// struct itself shouldn't be directly manipulated; the internal structure is not stable,\n-/// and may be changed at any time in the future. The operators will not, however (except\n-/// for signatures, later on).\n-#[derive(Clone, Eq, Hash, RustcEncodable, RustcDecodable)]\n+/// A `TokenStream` is an abstract sequence of tokens, organized into `TokenTree`s.\n+/// The goal is for procedural macros to work with `TokenStream`s and `TokenTree`s\n+/// instead of a representation of the abstract syntax tree.\n+/// Today's `TokenTree`s can still contain AST via `Token::Interpolated` for back-compat.\n+#[derive(Clone, Debug)]\n pub struct TokenStream {\n-    ts: InternalTS,\n+    kind: TokenStreamKind,\n }\n \n-// This indicates the maximum size for a leaf in the concatenation algorithm.\n-// If two leafs will be collectively smaller than this, they will be merged.\n-// If a leaf is larger than this, it will be concatenated at the top.\n-const LEAF_SIZE : usize = 32;\n-\n-// NB If Leaf access proves to be slow, inroducing a secondary Leaf without the bounds\n-// for unsliced Leafs may lead to some performance improvemenet.\n-#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n-pub enum InternalTS {\n-    Empty(Span),\n-    Leaf {\n-        tts: Rc<Vec<TokenTree>>,\n-        offset: usize,\n-        len: usize,\n-        sp: Span,\n-    },\n-    Node {\n-        left: Rc<InternalTS>,\n-        right: Rc<InternalTS>,\n-        len: usize,\n-        sp: Span,\n-    },\n+#[derive(Clone, Debug)]\n+enum TokenStreamKind {\n+    Empty,\n+    Tree(TokenTree),\n+    Stream(RcSlice<TokenStream>),\n }\n \n-impl fmt::Debug for TokenStream {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.ts.fmt(f)\n+impl From<TokenTree> for TokenStream {\n+    fn from(tt: TokenTree) -> TokenStream {\n+        TokenStream { kind: TokenStreamKind::Tree(tt) }\n     }\n }\n \n-impl fmt::Debug for InternalTS {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            InternalTS::Empty(..) => Ok(()),\n-            InternalTS::Leaf { ref tts, offset, len, .. } => {\n-                for t in tts.iter().skip(offset).take(len) {\n-                    try!(write!(f, \"{:?}\", t));\n-                }\n-                Ok(())\n-            }\n-            InternalTS::Node { ref left, ref right, .. } => {\n-                try!(left.fmt(f));\n-                right.fmt(f)\n-            }\n-        }\n+impl<T: Into<TokenStream>> iter::FromIterator<T> for TokenStream {\n+    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {\n+        TokenStream::concat(iter.into_iter().map(Into::into))\n     }\n }\n \n-/// Checks if two TokenStreams are equivalent (including spans). For unspanned\n-/// equality, see `eq_unspanned`.\n+impl Eq for TokenStream {}\n+\n impl PartialEq<TokenStream> for TokenStream {\n     fn eq(&self, other: &TokenStream) -> bool {\n-        self.iter().eq(other.iter())\n-    }\n-}\n-\n-// NB this will disregard gaps. if we have [a|{2,5} , b|{11,13}], the resultant span\n-// will be at {2,13}. Without finer-grained span structures, however, this seems to be\n-// our only recourse.\n-// FIXME Do something smarter to compute the expansion id.\n-fn covering_span(trees: &[TokenTree]) -> Span {\n-    // disregard any dummy spans we have\n-    let trees = trees.iter().filter(|t| t.span() != DUMMY_SP).collect::<Vec<&TokenTree>>();\n-\n-    // if we're out of spans, stop\n-    if trees.len() < 1 {\n-        return DUMMY_SP;\n-    }\n-\n-    // set up the initial values\n-    let fst_span = trees[0].span();\n-\n-    let mut lo_span = fst_span.lo;\n-    let mut hi_span = fst_span.hi;\n-    let mut expn_id = fst_span.expn_id;\n-\n-    // compute the spans iteratively\n-    for t in trees.iter().skip(1) {\n-        let sp = t.span();\n-        if sp.lo < lo_span {\n-            lo_span = sp.lo;\n-        }\n-        if hi_span < sp.hi {\n-            hi_span = sp.hi;\n-        }\n-        if expn_id != sp.expn_id {\n-            expn_id = NO_EXPANSION;\n-        }\n-    }\n-\n-    Span {\n-        lo: lo_span,\n-        hi: hi_span,\n-        expn_id: expn_id,\n+        self.trees().eq(other.trees())\n     }\n }\n \n-impl InternalTS {\n-    fn len(&self) -> usize {\n-        match *self {\n-            InternalTS::Empty(..) => 0,\n-            InternalTS::Leaf { len, .. } => len,\n-            InternalTS::Node { len, .. } => len,\n-        }\n-    }\n-\n-    fn span(&self) -> Span {\n-        match *self {\n-            InternalTS::Empty(sp) |\n-            InternalTS::Leaf { sp, .. } |\n-            InternalTS::Node { sp, .. } => sp,\n-        }\n-    }\n-\n-    fn slice(&self, range: ops::Range<usize>) -> TokenStream {\n-        let from = range.start;\n-        let to = range.end;\n-        if from == to {\n-            return TokenStream::mk_empty();\n-        }\n-        if from > to {\n-            panic!(\"Invalid range: {} to {}\", from, to);\n-        }\n-        if from == 0 && to == self.len() {\n-            return TokenStream { ts: self.clone() }; /* should be cheap */\n-        }\n-        match *self {\n-            InternalTS::Empty(..) => panic!(\"Invalid index\"),\n-            InternalTS::Leaf { ref tts, offset, .. } => {\n-                let offset = offset + from;\n-                let len = to - from;\n-                TokenStream::mk_sub_leaf(tts.clone(),\n-                                         offset,\n-                                         len,\n-                                         covering_span(&tts[offset..offset + len]))\n-            }\n-            InternalTS::Node { ref left, ref right, .. } => {\n-                let left_len = left.len();\n-                if to <= left_len {\n-                    left.slice(range)\n-                } else if from >= left_len {\n-                    right.slice(from - left_len..to - left_len)\n-                } else {\n-                    TokenStream::concat(left.slice(from..left_len), right.slice(0..to - left_len))\n-                }\n-            }\n-        }\n-    }\n-\n-    fn to_vec(&self) -> Vec<&TokenTree> {\n-        let mut res = Vec::with_capacity(self.len());\n-        fn traverse_and_append<'a>(res: &mut Vec<&'a TokenTree>, ts: &'a InternalTS) {\n-            match *ts {\n-                InternalTS::Empty(..) => {},\n-                InternalTS::Leaf { ref tts, offset, len, .. } => {\n-                    let mut to_app = tts[offset..offset + len].iter().collect();\n-                    res.append(&mut to_app);\n-                }\n-                InternalTS::Node { ref left, ref right, .. } => {\n-                    traverse_and_append(res, left);\n-                    traverse_and_append(res, right);\n-                }\n-            }\n-        }\n-        traverse_and_append(&mut res, self);\n-        res\n-    }\n-\n-    fn to_tts(&self) -> Vec<TokenTree> {\n-        self.to_vec().into_iter().cloned().collect::<Vec<TokenTree>>()\n-    }\n-\n-    // Returns an internal node's children.\n-    fn children(&self) -> Option<(Rc<InternalTS>, Rc<InternalTS>)> {\n-        match *self {\n-            InternalTS::Node { ref left, ref right, .. } => Some((left.clone(), right.clone())),\n-            _ => None,\n-        }\n-    }\n-}\n-\n-/// TokenStream operators include basic destructuring, boolean operations, `maybe_...`\n-/// operations, and `maybe_..._prefix` operations. Boolean operations are straightforward,\n-/// indicating information about the structure of the stream. The `maybe_...` operations\n-/// return `Some<...>` if the tokenstream contains the appropriate item.\n-///\n-/// Similarly, the `maybe_..._prefix` operations potentially return a\n-/// partially-destructured stream as a pair where the first element is the expected item\n-/// and the second is the remainder of the stream. As anb example,\n-///\n-///    `maybe_path_prefix(\"a::b::c(a,b,c).foo()\") -> (a::b::c, \"(a,b,c).foo()\")`\n impl TokenStream {\n-    // Construct an empty node with a dummy span.\n-    pub fn mk_empty() -> TokenStream {\n-        TokenStream { ts: InternalTS::Empty(DUMMY_SP) }\n-    }\n-\n-    // Construct an empty node with the provided span.\n-    fn mk_spanned_empty(sp: Span) -> TokenStream {\n-        TokenStream { ts: InternalTS::Empty(sp) }\n-    }\n-\n-    // Construct a leaf node with a 0 offset and length equivalent to the input.\n-    fn mk_leaf(tts: Rc<Vec<TokenTree>>, sp: Span) -> TokenStream {\n-        let len = tts.len();\n-        TokenStream {\n-            ts: InternalTS::Leaf {\n-                tts: tts,\n-                offset: 0,\n-                len: len,\n-                sp: sp,\n-            },\n-        }\n-    }\n-\n-    // Construct a leaf node with the provided values.\n-    fn mk_sub_leaf(tts: Rc<Vec<TokenTree>>, offset: usize, len: usize, sp: Span) -> TokenStream {\n-        TokenStream {\n-            ts: InternalTS::Leaf {\n-                tts: tts,\n-                offset: offset,\n-                len: len,\n-                sp: sp,\n-            },\n-        }\n+    pub fn empty() -> TokenStream {\n+        TokenStream { kind: TokenStreamKind::Empty }\n     }\n \n-    // Construct an internal node with the provided values.\n-    fn mk_int_node(left: Rc<InternalTS>,\n-                   right: Rc<InternalTS>,\n-                   len: usize,\n-                   sp: Span)\n-                   -> TokenStream {\n-        TokenStream {\n-            ts: InternalTS::Node {\n-                left: left,\n-                right: right,\n-                len: len,\n-                sp: sp,\n-            },\n-        }\n-    }\n-\n-    /// Convert a vector of `TokenTree`s into a `TokenStream`.\n-    pub fn from_tts(trees: Vec<TokenTree>) -> TokenStream {\n-        let span = covering_span(&trees[..]);\n-        TokenStream::mk_leaf(Rc::new(trees), span)\n-    }\n-\n-    /// Convert a vector of Tokens into a TokenStream.\n-    pub fn from_tokens(tokens: Vec<Token>) -> TokenStream {\n-        // FIXME do something nicer with the spans\n-        TokenStream::from_tts(tokens.into_iter().map(|t| TokenTree::Token(DUMMY_SP, t)).collect())\n-    }\n-\n-    /// Manually change a TokenStream's span.\n-    pub fn respan(self, span: Span) -> TokenStream {\n-        match self.ts {\n-            InternalTS::Empty(..) => TokenStream::mk_spanned_empty(span),\n-            InternalTS::Leaf { tts, offset, len, .. } => {\n-                TokenStream::mk_sub_leaf(tts, offset, len, span)\n-            }\n-            InternalTS::Node { left, right, len, .. } => {\n-                TokenStream::mk_int_node(left, right, len, span)\n-            }\n-        }\n-    }\n-\n-    /// Concatenates two TokenStreams into a new TokenStream.\n-    pub fn concat(left: TokenStream, right: TokenStream) -> TokenStream {\n-        // This internal procedure performs 'aggressive compacting' during concatenation as\n-        // follows:\n-        // - If the nodes' combined total total length is less than 32, we copy both of\n-        //   them into a new vector and build a new leaf node.\n-        // - If one node is an internal node and the other is a 'small' leaf (length<32),\n-        //   we recur down the internal node on the appropriate side.\n-        // - Otherwise, we construct a new internal node that points to them as left and\n-        // right.\n-        fn concat_internal(left: Rc<InternalTS>, right: Rc<InternalTS>) -> TokenStream {\n-            let llen = left.len();\n-            let rlen = right.len();\n-            let len = llen + rlen;\n-            let span = combine_spans(left.span(), right.span());\n-            if len <= LEAF_SIZE {\n-                let mut new_vec = left.to_tts();\n-                let mut rvec = right.to_tts();\n-                new_vec.append(&mut rvec);\n-                return TokenStream::mk_leaf(Rc::new(new_vec), span);\n-            }\n-\n-            match (left.children(), right.children()) {\n-                (Some((lleft, lright)), None) => {\n-                    if rlen <= LEAF_SIZE  {\n-                        let new_right = concat_internal(lright, right);\n-                        TokenStream::mk_int_node(lleft, Rc::new(new_right.ts), len, span)\n-                    } else {\n-                       TokenStream::mk_int_node(left, right, len, span)\n-                    }\n-                }\n-                (None, Some((rleft, rright))) => {\n-                    if rlen <= LEAF_SIZE  {\n-                        let new_left = concat_internal(left, rleft);\n-                        TokenStream::mk_int_node(Rc::new(new_left.ts), rright, len, span)\n-                    } else {\n-                       TokenStream::mk_int_node(left, right, len, span)\n-                    }\n-                }\n-                (_, _) => TokenStream::mk_int_node(left, right, len, span),\n-            }\n-        }\n-\n-        if left.is_empty() {\n-            right\n-        } else if right.is_empty() {\n-            left\n-        } else {\n-            concat_internal(Rc::new(left.ts), Rc::new(right.ts))\n-        }\n-    }\n-\n-    /// Indicate if the TokenStream is empty.\n     pub fn is_empty(&self) -> bool {\n-        self.len() == 0\n-    }\n-\n-    /// Return a TokenStream's length.\n-    pub fn len(&self) -> usize {\n-        self.ts.len()\n-    }\n-\n-    /// Convert a TokenStream into a vector of borrowed TokenTrees.\n-    pub fn to_vec(&self) -> Vec<&TokenTree> {\n-        self.ts.to_vec()\n-    }\n-\n-    /// Convert a TokenStream into a vector of TokenTrees (by cloning the TokenTrees).\n-    /// (This operation is an O(n) deep copy of the underlying structure.)\n-    pub fn to_tts(&self) -> Vec<TokenTree> {\n-        self.ts.to_tts()\n-    }\n-\n-    /// Return the TokenStream's span.\n-    pub fn span(&self) -> Span {\n-        self.ts.span()\n-    }\n-\n-    /// Returns an iterator over a TokenStream (as a sequence of TokenTrees).\n-    pub fn iter<'a>(&self) -> Iter {\n-        Iter { vs: self, idx: 0 }\n-    }\n-\n-    /// Splits a TokenStream based on the provided `&TokenTree -> bool` predicate.\n-    pub fn split<P>(&self, pred: P) -> Split<P>\n-        where P: FnMut(&TokenTree) -> bool\n-    {\n-        Split {\n-            vs: self,\n-            pred: pred,\n-            finished: false,\n-            idx: 0,\n+        match self.kind {\n+            TokenStreamKind::Empty => true,\n+            _ => false,\n         }\n     }\n \n-    /// Produce a slice of the input TokenStream from the `from` index, inclusive, to the\n-    /// `to` index, non-inclusive.\n-    pub fn slice(&self, range: ops::Range<usize>) -> TokenStream {\n-        self.ts.slice(range)\n-    }\n-\n-    /// Slice starting at the provided index, inclusive.\n-    pub fn slice_from(&self, from: ops::RangeFrom<usize>) -> TokenStream {\n-        self.slice(from.start..self.len())\n-    }\n-\n-    /// Slice up to the provided index, non-inclusive.\n-    pub fn slice_to(&self, to: ops::RangeTo<usize>) -> TokenStream {\n-        self.slice(0..to.end)\n-    }\n-\n-    /// Indicates where the stream is a single, delimited expression (e.g., `(a,b,c)` or\n-    /// `{a,b,c}`).\n-    pub fn is_delimited(&self) -> bool {\n-        self.maybe_delimited().is_some()\n-    }\n-\n-    /// Returns the inside of the delimited term as a new TokenStream.\n-    pub fn maybe_delimited(&self) -> Option<TokenStream> {\n-        if !(self.len() == 1) {\n-            return None;\n-        }\n-\n-        // FIXME It would be nice to change Delimited to move the Rc around the TokenTree\n-        // vector directly in order to avoid the clone here.\n-        match self[0] {\n-            TokenTree::Delimited(_, ref rc) => Some(TokenStream::from_tts(rc.tts.clone())),\n-            _ => None,\n-        }\n+    pub fn concat<I: IntoIterator<Item = TokenStream>>(streams: I) -> TokenStream {\n+        let mut streams = streams.into_iter().filter(|stream| !stream.is_empty());\n+        let first_stream = match streams.next() {\n+            Some(stream) => stream,\n+            None => return TokenStream::empty(),\n+        };\n+        let second_stream = match streams.next() {\n+            Some(stream) => stream,\n+            None => return first_stream,\n+        };\n+        let mut vec = vec![first_stream, second_stream];\n+        vec.extend(streams);\n+        TokenStream { kind: TokenStreamKind::Stream(RcSlice::new(vec)) }\n     }\n \n-    /// Indicates if the stream is exactly one identifier.\n-    pub fn is_ident(&self) -> bool {\n-        self.maybe_ident().is_some()\n-    }\n-\n-    /// Returns an identifier\n-    pub fn maybe_ident(&self) -> Option<ast::Ident> {\n-        if !(self.len() == 1) {\n-            return None;\n-        }\n-\n-        match self[0] {\n-            TokenTree::Token(_, Token::Ident(t)) => Some(t),\n-            _ => None,\n-        }\n+    pub fn trees<'a>(&'a self) -> Cursor {\n+        Cursor::new(self)\n     }\n \n     /// Compares two TokenStreams, checking equality without regarding span information.\n     pub fn eq_unspanned(&self, other: &TokenStream) -> bool {\n-        for (t1, t2) in self.iter().zip(other.iter()) {\n+        for (t1, t2) in self.trees().zip(other.trees()) {\n             if !t1.eq_unspanned(t2) {\n                 return false;\n             }\n         }\n         true\n     }\n-\n-    /// Convert a vector of TokenTrees into a parentheses-delimited TokenStream.\n-    pub fn as_delimited_stream(tts: Vec<TokenTree>, delim: token::DelimToken) -> TokenStream {\n-        let new_sp = covering_span(&tts);\n-\n-        let new_delim = Rc::new(Delimited {\n-            delim: delim,\n-            open_span: DUMMY_SP,\n-            tts: tts,\n-            close_span: DUMMY_SP,\n-        });\n-\n-        TokenStream::from_tts(vec![TokenTree::Delimited(new_sp, new_delim)])\n-    }\n }\n \n-impl fmt::Display for TokenStream {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.write_str(&pprust::tts_to_string(&self.to_tts()))\n-    }\n-}\n-\n-// FIXME Reimplement this iterator to hold onto a slice iterator for a leaf, getting the\n-// next leaf's iterator when the current one is exhausted.\n-pub struct Iter<'a> {\n-    vs: &'a TokenStream,\n-    idx: usize,\n+pub struct Cursor<'a> {\n+    current_frame: CursorFrame<'a>,\n+    stack: Vec<CursorFrame<'a>>,\n }\n \n-impl<'a> Iterator for Iter<'a> {\n+impl<'a> Iterator for Cursor<'a> {\n     type Item = &'a TokenTree;\n \n     fn next(&mut self) -> Option<&'a TokenTree> {\n-        if self.vs.is_empty() || self.idx >= self.vs.len() {\n-            return None;\n-        }\n-\n-        let ret = Some(&self.vs[self.idx]);\n-        self.idx = self.idx + 1;\n-        ret\n+        let tree = self.peek();\n+        self.current_frame = self.stack.pop().unwrap_or(CursorFrame::Empty);\n+        tree\n     }\n }\n \n-pub struct Split<'a, P>\n-    where P: FnMut(&TokenTree) -> bool\n-{\n-    vs: &'a TokenStream,\n-    pred: P,\n-    finished: bool,\n-    idx: usize,\n+enum CursorFrame<'a> {\n+    Empty,\n+    Tree(&'a TokenTree),\n+    Stream(&'a RcSlice<TokenStream>, usize),\n }\n \n-impl<'a, P> Iterator for Split<'a, P>\n-    where P: FnMut(&TokenTree) -> bool\n-{\n-    type Item = TokenStream;\n+impl<'a> CursorFrame<'a> {\n+    fn new(stream: &'a TokenStream) -> Self {\n+        match stream.kind {\n+            TokenStreamKind::Empty => CursorFrame::Empty,\n+            TokenStreamKind::Tree(ref tree) => CursorFrame::Tree(tree),\n+            TokenStreamKind::Stream(ref stream) => CursorFrame::Stream(stream, 0),\n+        }\n+    }\n+}\n \n-    fn next(&mut self) -> Option<TokenStream> {\n-        if self.finished {\n-            return None;\n+impl<'a> Cursor<'a> {\n+    fn new(stream: &'a TokenStream) -> Self {\n+        Cursor {\n+            current_frame: CursorFrame::new(stream),\n+            stack: Vec::new(),\n         }\n-        if self.idx >= self.vs.len() {\n-            self.finished = true;\n-            return None;\n+    }\n+\n+    pub fn peek(&mut self) -> Option<&'a TokenTree> {\n+        while let CursorFrame::Stream(stream, index) = self.current_frame {\n+            self.current_frame = if index == stream.len() {\n+                self.stack.pop().unwrap_or(CursorFrame::Empty)\n+            } else {\n+                self.stack.push(CursorFrame::Stream(stream, index + 1));\n+                CursorFrame::new(&stream[index])\n+            };\n         }\n \n-        let mut lookup = self.vs.iter().skip(self.idx);\n-        match lookup.position(|x| (self.pred)(&x)) {\n-            None => {\n-                self.finished = true;\n-                Some(self.vs.slice_from(self.idx..))\n-            }\n-            Some(edx) => {\n-                let ret = Some(self.vs.slice(self.idx..self.idx + edx));\n-                self.idx += edx + 1;\n-                ret\n-            }\n+        match self.current_frame {\n+            CursorFrame::Empty => None,\n+            CursorFrame::Tree(tree) => Some(tree),\n+            CursorFrame::Stream(..) => unreachable!(),\n         }\n     }\n }\n \n-impl Index<usize> for TokenStream {\n-    type Output = TokenTree;\n-\n-    fn index(&self, index: usize) -> &TokenTree {\n-        &self.ts[index]\n+impl fmt::Display for TokenStream {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.write_str(&pprust::tts_to_string(&self.trees().cloned().collect::<Vec<_>>()))\n     }\n }\n \n-impl Index<usize> for InternalTS {\n-    type Output = TokenTree;\n+impl Encodable for TokenStream {\n+    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), E::Error> {\n+        self.trees().cloned().collect::<Vec<_>>().encode(encoder)\n+    }\n+}\n \n-    fn index(&self, index: usize) -> &TokenTree {\n-        if self.len() <= index {\n-            panic!(\"Index {} too large for {:?}\", index, self);\n-        }\n-        match *self {\n-            InternalTS::Empty(..) => panic!(\"Invalid index\"),\n-            InternalTS::Leaf { ref tts, offset, .. } => tts.get(index + offset).unwrap(),\n-            InternalTS::Node { ref left, ref right, .. } => {\n-                let left_len = left.len();\n-                if index < left_len {\n-                    Index::index(&**left, index)\n-                } else {\n-                    Index::index(&**right, index - left_len)\n-                }\n-            }\n-        }\n+impl Decodable for TokenStream {\n+    fn decode<D: Decoder>(decoder: &mut D) -> Result<TokenStream, D::Error> {\n+        Vec::<TokenTree>::decode(decoder).map(|vec| vec.into_iter().collect())\n     }\n }\n \n@@ -880,10 +483,13 @@ impl Index<usize> for InternalTS {\n mod tests {\n     use super::*;\n     use syntax::ast::Ident;\n-    use syntax_pos::{Span, BytePos, NO_EXPANSION, DUMMY_SP};\n-    use parse::token::{self, Token};\n+    use syntax_pos::{Span, BytePos, NO_EXPANSION};\n+    use parse::token::Token;\n     use util::parser_testing::string_to_tts;\n-    use std::rc::Rc;\n+\n+    fn string_to_ts(string: &str) -> TokenStream {\n+        string_to_tts(string.to_owned()).into_iter().collect()\n+    }\n \n     fn sp(a: u32, b: u32) -> Span {\n         Span {\n@@ -893,239 +499,76 @@ mod tests {\n         }\n     }\n \n-    fn as_paren_delimited_stream(tts: Vec<TokenTree>) -> TokenStream {\n-        TokenStream::as_delimited_stream(tts, token::DelimToken::Paren)\n-    }\n-\n     #[test]\n     fn test_concat() {\n-        let test_res = TokenStream::from_tts(string_to_tts(\"foo::bar::baz\".to_string()));\n-        let test_fst = TokenStream::from_tts(string_to_tts(\"foo::bar\".to_string()));\n-        let test_snd = TokenStream::from_tts(string_to_tts(\"::baz\".to_string()));\n-        let eq_res = TokenStream::concat(test_fst, test_snd);\n-        assert_eq!(test_res.len(), 5);\n-        assert_eq!(eq_res.len(), 5);\n+        let test_res = string_to_ts(\"foo::bar::baz\");\n+        let test_fst = string_to_ts(\"foo::bar\");\n+        let test_snd = string_to_ts(\"::baz\");\n+        let eq_res = TokenStream::concat([test_fst, test_snd].iter().cloned());\n+        assert_eq!(test_res.trees().count(), 5);\n+        assert_eq!(eq_res.trees().count(), 5);\n         assert_eq!(test_res.eq_unspanned(&eq_res), true);\n     }\n \n     #[test]\n     fn test_from_to_bijection() {\n         let test_start = string_to_tts(\"foo::bar(baz)\".to_string());\n-        let test_end = TokenStream::from_tts(string_to_tts(\"foo::bar(baz)\".to_string())).to_tts();\n+        let ts = test_start.iter().cloned().collect::<TokenStream>();\n+        let test_end: Vec<TokenTree> = ts.trees().cloned().collect();\n         assert_eq!(test_start, test_end)\n     }\n \n     #[test]\n     fn test_to_from_bijection() {\n-        let test_start = TokenStream::from_tts(string_to_tts(\"foo::bar(baz)\".to_string()));\n-        let test_end = TokenStream::from_tts(test_start.clone().to_tts());\n+        let test_start = string_to_ts(\"foo::bar(baz)\");\n+        let test_end = test_start.trees().cloned().collect();\n         assert_eq!(test_start, test_end)\n     }\n \n     #[test]\n     fn test_eq_0() {\n-        let test_res = TokenStream::from_tts(string_to_tts(\"foo\".to_string()));\n-        let test_eqs = TokenStream::from_tts(string_to_tts(\"foo\".to_string()));\n+        let test_res = string_to_ts(\"foo\");\n+        let test_eqs = string_to_ts(\"foo\");\n         assert_eq!(test_res, test_eqs)\n     }\n \n     #[test]\n     fn test_eq_1() {\n-        let test_res = TokenStream::from_tts(string_to_tts(\"::bar::baz\".to_string()));\n-        let test_eqs = TokenStream::from_tts(string_to_tts(\"::bar::baz\".to_string()));\n+        let test_res = string_to_ts(\"::bar::baz\");\n+        let test_eqs = string_to_ts(\"::bar::baz\");\n         assert_eq!(test_res, test_eqs)\n     }\n \n-    #[test]\n-    fn test_eq_2() {\n-        let test_res = TokenStream::from_tts(string_to_tts(\"foo::bar\".to_string()));\n-        let test_eqs = TokenStream::from_tts(string_to_tts(\"foo::bar::baz\".to_string()));\n-        assert_eq!(test_res, test_eqs.slice(0..3))\n-    }\n-\n     #[test]\n     fn test_eq_3() {\n-        let test_res = TokenStream::from_tts(string_to_tts(\"\".to_string()));\n-        let test_eqs = TokenStream::from_tts(string_to_tts(\"\".to_string()));\n+        let test_res = string_to_ts(\"\");\n+        let test_eqs = string_to_ts(\"\");\n         assert_eq!(test_res, test_eqs)\n     }\n \n     #[test]\n     fn test_diseq_0() {\n-        let test_res = TokenStream::from_tts(string_to_tts(\"::bar::baz\".to_string()));\n-        let test_eqs = TokenStream::from_tts(string_to_tts(\"bar::baz\".to_string()));\n+        let test_res = string_to_ts(\"::bar::baz\");\n+        let test_eqs = string_to_ts(\"bar::baz\");\n         assert_eq!(test_res == test_eqs, false)\n     }\n \n     #[test]\n     fn test_diseq_1() {\n-        let test_res = TokenStream::from_tts(string_to_tts(\"(bar,baz)\".to_string()));\n-        let test_eqs = TokenStream::from_tts(string_to_tts(\"bar,baz\".to_string()));\n+        let test_res = string_to_ts(\"(bar,baz)\");\n+        let test_eqs = string_to_ts(\"bar,baz\");\n         assert_eq!(test_res == test_eqs, false)\n     }\n \n-    #[test]\n-    fn test_slice_0() {\n-        let test_res = TokenStream::from_tts(string_to_tts(\"foo::bar\".to_string()));\n-        let test_eqs = TokenStream::from_tts(string_to_tts(\"foo::bar::baz\".to_string()));\n-        assert_eq!(test_res, test_eqs.slice(0..3))\n-    }\n-\n-    #[test]\n-    fn test_slice_1() {\n-        let test_res = TokenStream::from_tts(string_to_tts(\"foo::bar::baz\".to_string()))\n-            .slice(2..3);\n-        let test_eqs = TokenStream::from_tts(vec![TokenTree::Token(sp(5,8),\n-                                                    token::Ident(Ident::from_str(\"bar\")))]);\n-        assert_eq!(test_res, test_eqs)\n-    }\n-\n     #[test]\n     fn test_is_empty() {\n-        let test0 = TokenStream::from_tts(Vec::new());\n-        let test1 = TokenStream::from_tts(\n-            vec![TokenTree::Token(sp(0, 1), Token::Ident(Ident::from_str(\"a\")))]\n-        );\n-\n-        let test2 = TokenStream::from_tts(string_to_tts(\"foo(bar::baz)\".to_string()));\n+        let test0: TokenStream = Vec::<TokenTree>::new().into_iter().collect();\n+        let test1: TokenStream =\n+            TokenTree::Token(sp(0, 1), Token::Ident(Ident::from_str(\"a\"))).into();\n+        let test2 = string_to_ts(\"foo(bar::baz)\");\n \n         assert_eq!(test0.is_empty(), true);\n         assert_eq!(test1.is_empty(), false);\n         assert_eq!(test2.is_empty(), false);\n     }\n-\n-    #[test]\n-    fn test_is_delimited() {\n-        let test0 = TokenStream::from_tts(string_to_tts(\"foo(bar::baz)\".to_string()));\n-        let test1 = TokenStream::from_tts(string_to_tts(\"(bar::baz)\".to_string()));\n-        let test2 = TokenStream::from_tts(string_to_tts(\"(foo,bar,baz)\".to_string()));\n-        let test3 = TokenStream::from_tts(string_to_tts(\"(foo,bar,baz)(zab,rab,oof)\".to_string()));\n-        let test4 = TokenStream::from_tts(string_to_tts(\"(foo,bar,baz)foo\".to_string()));\n-        let test5 = TokenStream::from_tts(string_to_tts(\"\".to_string()));\n-\n-        assert_eq!(test0.is_delimited(), false);\n-        assert_eq!(test1.is_delimited(), true);\n-        assert_eq!(test2.is_delimited(), true);\n-        assert_eq!(test3.is_delimited(), false);\n-        assert_eq!(test4.is_delimited(), false);\n-        assert_eq!(test5.is_delimited(), false);\n-    }\n-\n-    #[test]\n-    fn test_is_ident() {\n-        let test0 = TokenStream::from_tts(string_to_tts(\"\\\"foo\\\"\".to_string()));\n-        let test1 = TokenStream::from_tts(string_to_tts(\"5\".to_string()));\n-        let test2 = TokenStream::from_tts(string_to_tts(\"foo\".to_string()));\n-        let test3 = TokenStream::from_tts(string_to_tts(\"foo::bar\".to_string()));\n-        let test4 = TokenStream::from_tts(string_to_tts(\"foo(bar)\".to_string()));\n-\n-        assert_eq!(test0.is_ident(), false);\n-        assert_eq!(test1.is_ident(), false);\n-        assert_eq!(test2.is_ident(), true);\n-        assert_eq!(test3.is_ident(), false);\n-        assert_eq!(test4.is_ident(), false);\n-    }\n-\n-    #[test]\n-    fn test_maybe_delimited() {\n-        let test0_input = TokenStream::from_tts(string_to_tts(\"foo(bar::baz)\".to_string()));\n-        let test1_input = TokenStream::from_tts(string_to_tts(\"(bar::baz)\".to_string()));\n-        let test2_input = TokenStream::from_tts(string_to_tts(\"(foo,bar,baz)\".to_string()));\n-        let test3_input = TokenStream::from_tts(string_to_tts(\"(foo,bar,baz)(zab,rab)\"\n-            .to_string()));\n-        let test4_input = TokenStream::from_tts(string_to_tts(\"(foo,bar,baz)foo\".to_string()));\n-        let test5_input = TokenStream::from_tts(string_to_tts(\"\".to_string()));\n-\n-        let test0 = test0_input.maybe_delimited();\n-        let test1 = test1_input.maybe_delimited();\n-        let test2 = test2_input.maybe_delimited();\n-        let test3 = test3_input.maybe_delimited();\n-        let test4 = test4_input.maybe_delimited();\n-        let test5 = test5_input.maybe_delimited();\n-\n-        assert_eq!(test0, None);\n-\n-        let test1_expected = TokenStream::from_tts(vec![TokenTree::Token(sp(1, 4),\n-                                                        token::Ident(Ident::from_str(\"bar\"))),\n-                                       TokenTree::Token(sp(4, 6), token::ModSep),\n-                                       TokenTree::Token(sp(6, 9),\n-                                                        token::Ident(Ident::from_str(\"baz\")))]);\n-        assert_eq!(test1, Some(test1_expected));\n-\n-        let test2_expected = TokenStream::from_tts(vec![TokenTree::Token(sp(1, 4),\n-                                                        token::Ident(Ident::from_str(\"foo\"))),\n-                                       TokenTree::Token(sp(4, 5), token::Comma),\n-                                       TokenTree::Token(sp(5, 8),\n-                                                        token::Ident(Ident::from_str(\"bar\"))),\n-                                       TokenTree::Token(sp(8, 9), token::Comma),\n-                                       TokenTree::Token(sp(9, 12),\n-                                                        token::Ident(Ident::from_str(\"baz\")))]);\n-        assert_eq!(test2, Some(test2_expected));\n-\n-        assert_eq!(test3, None);\n-\n-        assert_eq!(test4, None);\n-\n-        assert_eq!(test5, None);\n-    }\n-\n-    // pub fn maybe_ident(&self) -> Option<ast::Ident>\n-    #[test]\n-    fn test_maybe_ident() {\n-        let test0 = TokenStream::from_tts(string_to_tts(\"\\\"foo\\\"\".to_string())).maybe_ident();\n-        let test1 = TokenStream::from_tts(string_to_tts(\"5\".to_string())).maybe_ident();\n-        let test2 = TokenStream::from_tts(string_to_tts(\"foo\".to_string())).maybe_ident();\n-        let test3 = TokenStream::from_tts(string_to_tts(\"foo::bar\".to_string())).maybe_ident();\n-        let test4 = TokenStream::from_tts(string_to_tts(\"foo(bar)\".to_string())).maybe_ident();\n-\n-        assert_eq!(test0, None);\n-        assert_eq!(test1, None);\n-        assert_eq!(test2, Some(Ident::from_str(\"foo\")));\n-        assert_eq!(test3, None);\n-        assert_eq!(test4, None);\n-    }\n-\n-    #[test]\n-    fn test_as_delimited_stream() {\n-        let test0 = as_paren_delimited_stream(string_to_tts(\"foo,bar,\".to_string()));\n-        let test1 = as_paren_delimited_stream(string_to_tts(\"baz(foo,bar)\".to_string()));\n-\n-        let test0_tts = vec![TokenTree::Token(sp(0, 3), token::Ident(Ident::from_str(\"foo\"))),\n-                             TokenTree::Token(sp(3, 4), token::Comma),\n-                             TokenTree::Token(sp(4, 7), token::Ident(Ident::from_str(\"bar\"))),\n-                             TokenTree::Token(sp(7, 8), token::Comma)];\n-        let test0_stream = TokenStream::from_tts(vec![TokenTree::Delimited(sp(0, 8),\n-                                                               Rc::new(Delimited {\n-                                                                   delim: token::DelimToken::Paren,\n-                                                                   open_span: DUMMY_SP,\n-                                                                   tts: test0_tts,\n-                                                                   close_span: DUMMY_SP,\n-                                                               }))]);\n-\n-        assert_eq!(test0, test0_stream);\n-\n-\n-        let test1_tts = vec![TokenTree::Token(sp(4, 7), token::Ident(Ident::from_str(\"foo\"))),\n-                             TokenTree::Token(sp(7, 8), token::Comma),\n-                             TokenTree::Token(sp(8, 11), token::Ident(Ident::from_str(\"bar\")))];\n-\n-        let test1_parse = vec![TokenTree::Token(sp(0, 3), token::Ident(Ident::from_str(\"baz\"))),\n-                               TokenTree::Delimited(sp(3, 12),\n-                                                    Rc::new(Delimited {\n-                                                        delim: token::DelimToken::Paren,\n-                                                        open_span: sp(3, 4),\n-                                                        tts: test1_tts,\n-                                                        close_span: sp(11, 12),\n-                                                    }))];\n-\n-        let test1_stream = TokenStream::from_tts(vec![TokenTree::Delimited(sp(0, 12),\n-                                                               Rc::new(Delimited {\n-                                                                   delim: token::DelimToken::Paren,\n-                                                                   open_span: DUMMY_SP,\n-                                                                   tts: test1_parse,\n-                                                                   close_span: DUMMY_SP,\n-                                                               }))]);\n-\n-        assert_eq!(test1, test1_stream);\n-    }\n }"}, {"sha": "cb3becf83f6828e7ab747fe982b2fdf225cc0ede", "filename": "src/libsyntax/util/rc_slice.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2Flibsyntax%2Futil%2Frc_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2Flibsyntax%2Futil%2Frc_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Frc_slice.rs?ref=2dc60b1180b2974b8966c33100e9541845e1d2e8", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::hash::{self, Hash};\n+use std::fmt;\n+use std::ops::Deref;\n+use std::rc::Rc;\n+\n+#[derive(Clone)]\n+pub struct RcSlice<T> {\n+    data: Rc<Box<[T]>>,\n+    offset: u32,\n+    len: u32,\n+}\n+\n+impl<T> RcSlice<T> {\n+    pub fn new(vec: Vec<T>) -> Self {\n+        RcSlice {\n+            offset: 0,\n+            len: vec.len() as u32,\n+            data: Rc::new(vec.into_boxed_slice()),\n+        }\n+    }\n+}\n+\n+impl<T> Deref for RcSlice<T> {\n+    type Target = [T];\n+    fn deref(&self) -> &[T] {\n+        &self.data[self.offset as usize .. (self.offset + self.len) as usize]\n+    }\n+}\n+\n+impl<T: Hash> Hash for RcSlice<T> {\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        self.deref().hash(state);\n+    }\n+}\n+\n+impl<T: fmt::Debug> fmt::Debug for RcSlice<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(self.deref(), f)\n+    }\n+}"}, {"sha": "730e112c70016f9fd2bdfb78108ca49571c65125", "filename": "src/test/run-pass-fulldeps/auxiliary/cond_plugin.rs", "status": "modified", "additions": 31, "deletions": 38, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_plugin.rs?ref=2dc60b1180b2974b8966c33100e9541845e1d2e8", "patch": "@@ -15,52 +15,45 @@\n #![plugin(proc_macro_plugin)]\n \n extern crate rustc_plugin;\n-extern crate proc_macro_tokens;\n extern crate syntax;\n \n-use proc_macro_tokens::prelude::*;\n-\n use rustc_plugin::Registry;\n \n-use syntax::ast::Ident;\n-use syntax::codemap::{DUMMY_SP, Span};\n-use syntax::ext::proc_macro_shim::build_block_emitter;\n-use syntax::ext::base::{ExtCtxt, MacResult};\n-use syntax::parse::token::{self, Token, DelimToken};\n+use syntax::ext::base::SyntaxExtension;\n+use syntax::parse::token::Token;\n+use syntax::symbol::Symbol;\n use syntax::tokenstream::{TokenTree, TokenStream};\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_macro(\"cond\", cond);\n-}\n-\n-fn cond<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[TokenTree]) -> Box<MacResult + 'cx> {\n-    let output = cond_rec(TokenStream::from_tts(tts.clone().to_owned()));\n-    build_block_emitter(cx, sp, output)\n+    reg.register_syntax_extension(Symbol::intern(\"cond\"),\n+                                  SyntaxExtension::ProcMacro(Box::new(cond)));\n }\n \n-fn cond_rec(input: TokenStream) -> TokenStream {\n-  if input.is_empty() {\n-      return qquote!();\n-  }\n-\n-  let next = input.slice(0..1);\n-  let rest = input.slice_from(1..);\n-\n-  let clause : TokenStream = match next.maybe_delimited() {\n-    Some(ts) => ts,\n-    _ => panic!(\"Invalid input\"),\n-  };\n-\n-  // clause is ([test]) [rhs]\n-  if clause.len() < 2 { panic!(\"Invalid macro usage in cond: {:?}\", clause) }\n-\n-  let test: TokenStream = clause.slice(0..1);\n-  let rhs: TokenStream = clause.slice_from(1..);\n-\n-  if ident_eq(&test[0], Ident::from_str(\"else\")) || rest.is_empty() {\n-    qquote!({unquote(rhs)})\n-  } else {\n-    qquote!({if unquote(test) { unquote(rhs) } else { cond!(unquote(rest)) } })\n-  }\n+fn cond(input: TokenStream) -> TokenStream {\n+    let mut conds = Vec::new();\n+    let mut input = input.trees();\n+    while let Some(tree) = input.next() {\n+        let cond: TokenStream = match *tree {\n+            TokenTree::Delimited(_, ref delimited) => delimited.tts.iter().cloned().collect(),\n+            _ => panic!(\"Invalid input\"),\n+        };\n+        let mut trees = cond.trees().cloned();\n+        let test = trees.next();\n+        let rhs = trees.collect::<TokenStream>();\n+        if rhs.is_empty() {\n+            panic!(\"Invalid macro usage in cond: {}\", cond);\n+        }\n+        let is_else = match test {\n+            Some(TokenTree::Token(_, Token::Ident(ident))) if ident.name == \"else\" => true,\n+            _ => false,\n+        };\n+        conds.push(if is_else || input.peek().is_none() {\n+            qquote!({ unquote rhs })\n+        } else {\n+            qquote!(if unquote(test.unwrap()) { unquote rhs } else)\n+        });\n+    }\n+\n+    conds.into_iter().collect()\n }"}, {"sha": "91075276a302039d221fc5d648de642231f245a4", "filename": "src/test/run-pass-fulldeps/auxiliary/hello_macro.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fhello_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fhello_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fhello_macro.rs?ref=2dc60b1180b2974b8966c33100e9541845e1d2e8", "patch": "@@ -14,22 +14,21 @@\n #![plugin(proc_macro_plugin)]\n \n extern crate rustc_plugin;\n-extern crate proc_macro_tokens;\n extern crate syntax;\n \n-use syntax::ext::proc_macro_shim::prelude::*;\n-use proc_macro_tokens::prelude::*;\n-\n use rustc_plugin::Registry;\n+use syntax::ext::base::SyntaxExtension;\n+use syntax::symbol::Symbol;\n+use syntax::tokenstream::TokenStream;\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_macro(\"hello\", hello);\n+    reg.register_syntax_extension(Symbol::intern(\"hello\"),\n+                                  SyntaxExtension::ProcMacro(Box::new(hello)));\n }\n \n // This macro is not very interesting, but it does contain delimited tokens with\n // no content - `()` and `{}` - which has caused problems in the past.\n-fn hello<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[TokenTree]) -> Box<MacResult + 'cx> {\n-    let output = qquote!({ fn hello() {} hello(); });\n-    build_block_emitter(cx, sp, output)\n+fn hello(_: TokenStream) -> TokenStream {\n+    qquote!({ fn hello() {} hello(); })\n }"}, {"sha": "612c199e8281a1a02909481ad31620aa979619fb", "filename": "src/test/run-pass-fulldeps/auxiliary/proc_macro_def.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fproc_macro_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fproc_macro_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fproc_macro_def.rs?ref=2dc60b1180b2974b8966c33100e9541845e1d2e8", "patch": "@@ -9,15 +9,14 @@\n // except according to those terms.\n \n #![feature(plugin, plugin_registrar, rustc_private)]\n+#![plugin(proc_macro_plugin)]\n \n-extern crate proc_macro_tokens;\n extern crate rustc_plugin;\n extern crate syntax;\n \n-use proc_macro_tokens::prelude::*;\n use rustc_plugin::Registry;\n use syntax::ext::base::SyntaxExtension;\n-use syntax::ext::proc_macro_shim::prelude::*;\n+use syntax::tokenstream::TokenStream;\n use syntax::symbol::Symbol;\n \n #[plugin_registrar]\n@@ -35,23 +34,21 @@ pub fn plugin_registrar(reg: &mut Registry) {\n }\n \n fn attr_tru(_attr: TokenStream, _item: TokenStream) -> TokenStream {\n-    lex(\"fn f1() -> bool { true }\")\n+    qquote!(fn f1() -> bool { true })\n }\n \n fn attr_identity(_attr: TokenStream, item: TokenStream) -> TokenStream {\n-    let source = item.to_string();\n-    lex(&source)\n+    qquote!(unquote item)\n }\n \n fn tru(_ts: TokenStream) -> TokenStream {\n-    lex(\"true\")\n+    qquote!(true)\n }\n \n fn ret_tru(_ts: TokenStream) -> TokenStream {\n-    lex(\"return true;\")\n+    qquote!(return true;)\n }\n \n fn identity(ts: TokenStream) -> TokenStream {\n-    let source = ts.to_string();\n-    lex(&source)\n+    qquote!(unquote ts)\n }"}, {"sha": "57b6c3f0adb89723c77851cee84ada3b7378a426", "filename": "src/test/run-pass-fulldeps/macro-quote-1.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc60b1180b2974b8966c33100e9541845e1d2e8/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-1.rs?ref=2dc60b1180b2974b8966c33100e9541845e1d2e8", "patch": "@@ -14,12 +14,14 @@\n #![feature(rustc_private)]\n #![plugin(proc_macro_plugin)]\n \n-extern crate proc_macro_tokens;\n-use proc_macro_tokens::prelude::*;\n-\n extern crate syntax;\n+extern crate syntax_pos;\n+\n+use syntax::ast::Ident;\n+use syntax::parse::token;\n+use syntax::tokenstream::TokenTree;\n \n fn main() {\n-    let lex_true = lex(\"true\");\n-    assert_eq!(qquote!(true).eq_unspanned(&lex_true), true);\n+    let true_tok = TokenTree::Token(syntax_pos::DUMMY_SP, token::Ident(Ident::from_str(\"true\")));\n+    assert!(qquote!(true).eq_unspanned(&true_tok.into()));\n }"}]}