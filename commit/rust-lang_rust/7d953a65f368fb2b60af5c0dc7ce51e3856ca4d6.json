{"sha": "7d953a65f368fb2b60af5c0dc7ce51e3856ca4d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkOTUzYTY1ZjM2OGZiMmI2MGFmNWMwZGM3Y2U1MWUzODU2Y2E0ZDY=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-05-20T09:26:40Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-05-20T09:26:40Z"}, "message": "Rustup to rustc 1.28.0-nightly (a3085756e 2018-05-19)", "tree": {"sha": "dc5621db3062a219852efdea700b15185771f009", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc5621db3062a219852efdea700b15185771f009"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d953a65f368fb2b60af5c0dc7ce51e3856ca4d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d953a65f368fb2b60af5c0dc7ce51e3856ca4d6", "html_url": "https://github.com/rust-lang/rust/commit/7d953a65f368fb2b60af5c0dc7ce51e3856ca4d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d953a65f368fb2b60af5c0dc7ce51e3856ca4d6/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04608016ecd042308f2c55d652f67cac9025ae78", "url": "https://api.github.com/repos/rust-lang/rust/commits/04608016ecd042308f2c55d652f67cac9025ae78", "html_url": "https://github.com/rust-lang/rust/commit/04608016ecd042308f2c55d652f67cac9025ae78"}], "stats": {"total": 83, "additions": 42, "deletions": 41}, "files": [{"sha": "e7250eca949d1a835fc42c55c63a2a577b586127", "filename": "src/fn_call.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7d953a65f368fb2b60af5c0dc7ce51e3856ca4d6/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d953a65f368fb2b60af5c0dc7ce51e3856ca4d6/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=7d953a65f368fb2b60af5c0dc7ce51e3856ca4d6", "patch": "@@ -1,5 +1,5 @@\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, Align, LayoutOf};\n+use rustc::ty::layout::{self, Align, LayoutOf, Size};\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc::mir;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -187,7 +187,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                     self.write_null(dest, dest_ty)?;\n                 } else {\n                     let align = self.tcx.data_layout.pointer_align;\n-                    let ptr = self.memory.allocate(size, align, Some(MemoryKind::C.into()))?;\n+                    let ptr = self.memory.allocate(Size::from_bytes(size), align, Some(MemoryKind::C.into()))?;\n                     self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n                 }\n             }\n@@ -281,7 +281,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             \"memcmp\" => {\n                 let left = self.into_ptr(args[0].value)?;\n                 let right = self.into_ptr(args[1].value)?;\n-                let n = self.value_to_primval(args[2])?.to_u64()?;\n+                let n = Size::from_bytes(self.value_to_primval(args[2])?.to_u64()?);\n \n                 let result = {\n                     let left_bytes = self.memory.read_bytes(left, n)?;\n@@ -306,11 +306,11 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 let ptr = self.into_ptr(args[0].value)?;\n                 let val = self.value_to_primval(args[1])?.to_u64()? as u8;\n                 let num = self.value_to_primval(args[2])?.to_u64()?;\n-                if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().rev().position(\n+                if let Some(idx) = self.memory.read_bytes(ptr, Size::from_bytes(num))?.iter().rev().position(\n                     |&c| c == val,\n                 )\n                 {\n-                    let new_ptr = ptr.offset(num - idx as u64 - 1, &self)?;\n+                    let new_ptr = ptr.offset(Size::from_bytes(num - idx as u64 - 1), &self)?;\n                     self.write_ptr(dest, new_ptr, dest_ty)?;\n                 } else {\n                     self.write_null(dest, dest_ty)?;\n@@ -321,11 +321,11 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 let ptr = self.into_ptr(args[0].value)?;\n                 let val = self.value_to_primval(args[1])?.to_u64()? as u8;\n                 let num = self.value_to_primval(args[2])?.to_u64()?;\n-                if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().position(\n+                if let Some(idx) = self.memory.read_bytes(ptr, Size::from_bytes(num))?.iter().position(\n                     |&c| c == val,\n                 )\n                 {\n-                    let new_ptr = ptr.offset(idx as u64, &self)?;\n+                    let new_ptr = ptr.offset(Size::from_bytes(idx as u64), &self)?;\n                     self.write_ptr(dest, new_ptr, dest_ty)?;\n                 } else {\n                     self.write_null(dest, dest_ty)?;\n@@ -381,12 +381,12 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 if let Some((name, value)) = new {\n                     // +1 for the null terminator\n                     let value_copy = self.memory.allocate(\n-                        (value.len() + 1) as u64,\n+                        Size::from_bytes((value.len() + 1) as u64),\n                         Align::from_bytes(1, 1).unwrap(),\n                         Some(MemoryKind::Env.into()),\n                     )?;\n                     self.memory.write_bytes(value_copy.into(), &value)?;\n-                    let trailing_zero_ptr = value_copy.offset(value.len() as u64, &self)?.into();\n+                    let trailing_zero_ptr = value_copy.offset(Size::from_bytes(value.len() as u64), &self)?.into();\n                     self.memory.write_bytes(trailing_zero_ptr, &[0])?;\n                     if let Some(var) = self.machine.env_vars.insert(\n                         name.to_owned(),\n@@ -410,7 +410,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                     // stdout/stderr\n                     use std::io::{self, Write};\n \n-                    let buf_cont = self.memory.read_bytes(buf, n)?;\n+                    let buf_cont = self.memory.read_bytes(buf, Size::from_bytes(n))?;\n                     let res = if fd == 1 {\n                         io::stdout().write(buf_cont)\n                     } else {\n@@ -502,7 +502,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                     key_ptr,\n                     key_align,\n                     PrimVal::Bytes(key),\n-                    key_size.bytes(),\n+                    key_size,\n                     false,\n                 )?;\n \n@@ -643,7 +643,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 if !align.is_power_of_two() {\n                     return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                let ptr = self.memory.allocate(size,\n+                let ptr = self.memory.allocate(Size::from_bytes(size),\n                                                Align::from_bytes(align, align).unwrap(),\n                                                Some(MemoryKind::Rust.into()))?;\n                 self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n@@ -657,10 +657,10 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 if !align.is_power_of_two() {\n                     return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                let ptr = self.memory.allocate(size,\n+                let ptr = self.memory.allocate(Size::from_bytes(size),\n                                                Align::from_bytes(align, align).unwrap(),\n                                                Some(MemoryKind::Rust.into()))?;\n-                self.memory.write_repeat(ptr.into(), 0, size)?;\n+                self.memory.write_repeat(ptr.into(), 0, Size::from_bytes(size))?;\n                 self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n             }\n             \"alloc::alloc::::__rust_dealloc\" => {\n@@ -675,7 +675,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 }\n                 self.memory.deallocate(\n                     ptr,\n-                    Some((old_size, Align::from_bytes(align, align).unwrap())),\n+                    Some((Size::from_bytes(old_size), Align::from_bytes(align, align).unwrap())),\n                     MemoryKind::Rust.into(),\n                 )?;\n             }\n@@ -692,9 +692,9 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 }\n                 let new_ptr = self.memory.reallocate(\n                     ptr,\n-                    old_size,\n+                    Size::from_bytes(old_size),\n                     Align::from_bytes(align, align).unwrap(),\n-                    new_size,\n+                    Size::from_bytes(new_size),\n                     Align::from_bytes(align, align).unwrap(),\n                     MemoryKind::Rust.into(),\n                 )?;"}, {"sha": "30de1c68ca6180009e9461da8d3ee260c09f58d8", "filename": "src/intrinsic.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d953a65f368fb2b60af5c0dc7ce51e3856ca4d6/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d953a65f368fb2b60af5c0dc7ce51e3856ca4d6/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=7d953a65f368fb2b60af5c0dc7ce51e3856ca4d6", "patch": "@@ -1,5 +1,5 @@\n use rustc::mir;\n-use rustc::ty::layout::{TyLayout, LayoutOf};\n+use rustc::ty::layout::{TyLayout, LayoutOf, Size};\n use rustc::ty;\n \n use rustc::mir::interpret::{EvalResult, PrimVal, PrimValKind, Value, Pointer};\n@@ -35,7 +35,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 // FIXME: return a real value in case the target allocation has an\n                 // alignment bigger than the one requested\n                 let n = u128::max_value();\n-                let amt = 128 - self.memory.pointer_size() * 8;\n+                let amt = 128 - self.memory.pointer_size().bytes() * 8;\n                 self.write_primval(dest, PrimVal::Bytes((n << amt) >> amt), dest_layout.ty)?;\n             },\n \n@@ -225,7 +225,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                         elem_align,\n                         dest,\n                         elem_align,\n-                        count * elem_size,\n+                        Size::from_bytes(count * elem_size),\n                         intrinsic_name.ends_with(\"_nonoverlapping\"),\n                     )?;\n                 }\n@@ -332,7 +332,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             \"likely\" | \"unlikely\" | \"forget\" => {}\n \n             \"init\" => {\n-                let size = dest_layout.size.bytes();\n+                let size = dest_layout.size;\n                 let init = |this: &mut Self, val: Value| {\n                     let zero_val = match val {\n                         Value::ByRef(ptr, _) => {\n@@ -631,7 +631,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             }\n \n             \"uninit\" => {\n-                let size = dest_layout.size.bytes();\n+                let size = dest_layout.size;\n                 let uninit = |this: &mut Self, val: Value| match val {\n                     Value::ByRef(ptr, _) => {\n                         this.memory.mark_definedness(ptr, size, false)?;\n@@ -662,7 +662,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                     // HashMap relies on write_bytes on a NULL ptr with count == 0 to work\n                     // TODO: Should we, at least, validate the alignment? (Also see the copy intrinsic)\n                     self.memory.check_align(ptr, ty_layout.align)?;\n-                    self.memory.write_repeat(ptr, val_byte, ty_layout.size.bytes() * count)?;\n+                    self.memory.write_repeat(ptr, val_byte, ty_layout.size * count)?;\n                 }\n             }\n "}, {"sha": "66ad6377e32798104ade3e4dcb00e992ffd1be67", "filename": "src/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7d953a65f368fb2b60af5c0dc7ce51e3856ca4d6/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d953a65f368fb2b60af5c0dc7ce51e3856ca4d6/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=7d953a65f368fb2b60af5c0dc7ce51e3856ca4d6", "patch": "@@ -20,7 +20,7 @@ extern crate regex;\n extern crate lazy_static;\n \n use rustc::ty::{self, TyCtxt};\n-use rustc::ty::layout::{TyLayout, LayoutOf};\n+use rustc::ty::layout::{TyLayout, LayoutOf, Size};\n use rustc::ty::subst::Subst;\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n@@ -93,7 +93,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n             }\n \n             // Return value\n-            let size = ecx.tcx.data_layout.pointer_size.bytes();\n+            let size = ecx.tcx.data_layout.pointer_size;\n             let align = ecx.tcx.data_layout.pointer_align;\n             let ret_ptr = ecx.memory_mut().allocate(size, align, Some(MemoryKind::Stack))?;\n             cleanup_ptr = Some(ret_ptr);\n@@ -299,7 +299,7 @@ impl<'mir, 'tcx: 'mir> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         let layout = ecx.layout_of(mir.return_ty().subst(tcx, cid.instance.substs))?;\n         assert!(!layout.is_unsized());\n         let ptr = ecx.memory.allocate(\n-            layout.size.bytes(),\n+            layout.size,\n             layout.align,\n             None,\n         )?;\n@@ -373,8 +373,8 @@ impl<'mir, 'tcx: 'mir> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         ecx.write_value(\n             ValTy {\n                 value: Value::ByVal(PrimVal::Bytes(match layout.size.bytes() {\n-                    0 => 1,\n-                    size => size,\n+                    0 => 1 as u128,\n+                    size => size as u128,\n                 }.into())),\n                 ty: usize,\n             },\n@@ -407,10 +407,10 @@ impl<'mir, 'tcx: 'mir> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     fn check_locks<'a>(\n         mem: &Memory<'a, 'mir, 'tcx, Self>,\n         ptr: MemoryPointer,\n-        size: u64,\n+        size: Size,\n         access: AccessKind,\n     ) -> EvalResult<'tcx> {\n-        mem.check_locks(ptr, size, access)\n+        mem.check_locks(ptr, size.bytes(), access)\n     }\n \n     fn add_lock<'a>(\n@@ -439,7 +439,7 @@ impl<'mir, 'tcx: 'mir> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n                     //ptr, FIXME\n                     ptr: MemoryPointer {\n                         alloc_id: AllocId(0),\n-                        offset: 0,\n+                        offset: Size::from_bytes(0),\n                     },\n                     lock: lock.active,\n                 }.into()"}, {"sha": "9efbabc7171b36580962814699710bbdaf99d90f", "filename": "src/locks.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7d953a65f368fb2b60af5c0dc7ce51e3856ca4d6/src%2Flocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d953a65f368fb2b60af5c0dc7ce51e3856ca4d6/src%2Flocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flocks.rs?ref=7d953a65f368fb2b60af5c0dc7ce51e3856ca4d6", "patch": "@@ -1,5 +1,6 @@\n use super::*;\n use rustc::middle::region;\n+use rustc::ty::layout::Size;\n \n ////////////////////////////////////////////////////////////////////////////////\n // Locks\n@@ -116,7 +117,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n         };\n         let frame = self.cur_frame;\n         locks\n-            .check(Some(frame), ptr.offset, len, access)\n+            .check(Some(frame), ptr.offset.bytes(), len, access)\n             .map_err(|lock| {\n                 EvalErrorKind::MemoryLockViolation {\n                     ptr,\n@@ -146,7 +147,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n             len,\n             region\n         );\n-        self.check_bounds(ptr.offset(len, &*self)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n+        self.check_bounds(ptr.offset(Size::from_bytes(len), &*self)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n \n         let locks = match self.data.locks.get_mut(&ptr.alloc_id) {\n             Some(locks) => locks,\n@@ -157,7 +158,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n         // Iterate over our range and acquire the lock.  If the range is already split into pieces,\n         // we have to manipulate all of them.\n         let lifetime = DynamicLifetime { frame, region };\n-        for lock in locks.iter_mut(ptr.offset, len) {\n+        for lock in locks.iter_mut(ptr.offset.bytes(), len) {\n             if !lock.access_permitted(None, kind) {\n                 return err!(MemoryAcquireConflict {\n                     ptr,\n@@ -203,7 +204,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n             None => return Ok(()),\n         };\n \n-        'locks: for lock in locks.iter_mut(ptr.offset, len) {\n+        'locks: for lock in locks.iter_mut(ptr.offset.bytes(), len) {\n             let is_our_lock = match lock.active {\n                 WriteLock(lft) =>\n                     // Double-check that we are holding the lock.\n@@ -281,7 +282,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n             None => return Ok(()),\n         };\n \n-        for lock in locks.iter_mut(ptr.offset, len) {\n+        for lock in locks.iter_mut(ptr.offset.bytes(), len) {\n             // Check if we have a suspension here\n             let (got_the_lock, remove_suspension) = match lock.suspended.get_mut(&lock_id) {\n                 None => {"}, {"sha": "557e07975d73bfe011d223ffb82b029f010ac9c6", "filename": "src/operator.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d953a65f368fb2b60af5c0dc7ce51e3856ca4d6/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d953a65f368fb2b60af5c0dc7ce51e3856ca4d6/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=7d953a65f368fb2b60af5c0dc7ce51e3856ca4d6", "patch": "@@ -89,9 +89,9 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                         Sub => {\n                             return self.binary_op(\n                                 Sub,\n-                                PrimVal::Bytes(left.offset as u128),\n+                                PrimVal::Bytes(left.offset.bytes() as u128),\n                                 self.tcx.types.usize,\n-                                PrimVal::Bytes(right.offset as u128),\n+                                PrimVal::Bytes(right.offset.bytes() as u128),\n                                 self.tcx.types.usize,\n                             ).map(Some)\n                         }\n@@ -150,17 +150,17 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             Add if signed =>\n                 map_to_primval(left.overflowing_signed_offset(right, self)),\n             Add if !signed =>\n-                map_to_primval(left.overflowing_offset(right as u64, self)),\n+                map_to_primval(left.overflowing_offset(Size::from_bytes(right as u64), self)),\n \n             BitAnd if !signed => {\n                 let base_mask : u64 = !(self.memory.get(left.alloc_id)?.align.abi() - 1);\n                 let right = right as u64;\n                 if right & base_mask == base_mask {\n                     // Case 1: The base address bits are all preserved, i.e., right is all-1 there\n-                    (PrimVal::Ptr(MemoryPointer::new(left.alloc_id, left.offset & right)), false)\n+                    (PrimVal::Ptr(MemoryPointer::new(left.alloc_id, Size::from_bytes(left.offset.bytes() & right))), false)\n                 } else if right & base_mask == 0 {\n                     // Case 2: The base address bits are all taken away, i.e., right is all-0 there\n-                    (PrimVal::from_u128((left.offset & right) as u128), false)\n+                    (PrimVal::from_u128((left.offset.bytes() & right) as u128), false)\n                 } else {\n                     return err!(ReadPointerAsBytes);\n                 }"}]}