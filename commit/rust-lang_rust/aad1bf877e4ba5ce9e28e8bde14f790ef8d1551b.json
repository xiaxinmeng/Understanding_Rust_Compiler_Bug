{"sha": "aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhZDFiZjg3N2U0YmE1Y2U5ZTI4ZThiZGUxNGY3OTBlZjhkMTU1MWI=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-11T15:35:41Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-11T15:35:41Z"}, "message": "Merge #496\n\n496: Include two element ranges into the nav. r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "9d3ea7f166adcd09fb77cfdb7fc1bad03efc95cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d3ea7f166adcd09fb77cfdb7fc1bad03efc95cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b", "html_url": "https://github.com/rust-lang/rust/commit/aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "0b83bde6e2f3782ea6acd907fa0a634912cebb3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b83bde6e2f3782ea6acd907fa0a634912cebb3d", "html_url": "https://github.com/rust-lang/rust/commit/0b83bde6e2f3782ea6acd907fa0a634912cebb3d"}, {"sha": "f23a13bfa7bae7e34070bfd14d22b70a82315022", "url": "https://api.github.com/repos/rust-lang/rust/commits/f23a13bfa7bae7e34070bfd14d22b70a82315022", "html_url": "https://github.com/rust-lang/rust/commit/f23a13bfa7bae7e34070bfd14d22b70a82315022"}], "stats": {"total": 542, "additions": 294, "deletions": 248}, "files": [{"sha": "8ec6b9b2b025599c024fe22341eba033bc3289dd", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b", "patch": "@@ -274,6 +274,8 @@ pub struct Function {\n     pub(crate) def_id: DefId,\n }\n \n+pub use crate::code_model_impl::function::ScopeEntryWithSyntax;\n+\n /// The declared signature of a function.\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct FnSignature {"}, {"sha": "009175bab96315dd2cc1fb76e610fd6940b9aed3", "filename": "crates/ra_hir/src/code_model_impl/function.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs?ref=aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b", "patch": "@@ -15,7 +15,7 @@ use crate::{\n     impl_block::ImplBlock,\n };\n \n-pub use self::scope::{FnScopes, ScopesWithSyntaxMapping};\n+pub use self::scope::{FnScopes, ScopesWithSyntaxMapping, ScopeEntryWithSyntax};\n \n impl Function {\n     pub(crate) fn new(def_id: DefId) -> Function {"}, {"sha": "fe8be570072b67f545a9aba8813834f1655b1df4", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b", "patch": "@@ -59,5 +59,5 @@ pub use self::code_model_api::{\n     Def,\n     Module, ModuleSource, Problem,\n     Struct, Enum, EnumVariant,\n-    Function, FnSignature,\n+    Function, FnSignature, ScopeEntryWithSyntax,\n };"}, {"sha": "8d2ff561ac6304e67436560e8c182e1ad17b387f", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 28, "deletions": 59, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b", "patch": "@@ -1,22 +1,24 @@\n use ra_db::{FileId, Cancelable, SyntaxDatabase};\n use ra_syntax::{\n-    TextRange, AstNode, ast, SyntaxKind::{NAME, MODULE},\n+    AstNode, ast,\n     algo::find_node_at_offset,\n };\n \n-use crate::{FilePosition, NavigationTarget, db::RootDatabase};\n+use crate::{FilePosition, NavigationTarget, db::RootDatabase, RangeInfo};\n \n pub(crate) fn goto_definition(\n     db: &RootDatabase,\n     position: FilePosition,\n-) -> Cancelable<Option<Vec<NavigationTarget>>> {\n+) -> Cancelable<Option<RangeInfo<Vec<NavigationTarget>>>> {\n     let file = db.source_file(position.file_id);\n     let syntax = file.syntax();\n     if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(syntax, position.offset) {\n-        return Ok(Some(reference_definition(db, position.file_id, name_ref)?));\n+        let navs = reference_definition(db, position.file_id, name_ref)?;\n+        return Ok(Some(RangeInfo::new(name_ref.syntax().range(), navs)));\n     }\n     if let Some(name) = find_node_at_offset::<ast::Name>(syntax, position.offset) {\n-        return name_definition(db, position.file_id, name);\n+        let navs = ctry!(name_definition(db, position.file_id, name)?);\n+        return Ok(Some(RangeInfo::new(name.syntax().range(), navs)));\n     }\n     Ok(None)\n }\n@@ -32,13 +34,7 @@ pub(crate) fn reference_definition(\n         let scope = fn_descr.scopes(db)?;\n         // First try to resolve the symbol locally\n         if let Some(entry) = scope.resolve_local_name(name_ref) {\n-            let nav = NavigationTarget {\n-                file_id,\n-                name: entry.name().to_string().into(),\n-                range: entry.ptr().range(),\n-                kind: NAME,\n-                ptr: None,\n-            };\n+            let nav = NavigationTarget::from_scope_entry(file_id, &entry);\n             return Ok(vec![nav]);\n         };\n     }\n@@ -79,18 +75,7 @@ fn name_definition(\n             if let Some(child_module) =\n                 hir::source_binder::module_from_declaration(db, file_id, module)?\n             {\n-                let (file_id, _) = child_module.definition_source(db)?;\n-                let name = match child_module.name(db)? {\n-                    Some(name) => name.to_string().into(),\n-                    None => \"\".into(),\n-                };\n-                let nav = NavigationTarget {\n-                    file_id,\n-                    name,\n-                    range: TextRange::offset_len(0.into(), 0.into()),\n-                    kind: MODULE,\n-                    ptr: None,\n-                };\n+                let nav = NavigationTarget::from_module(db, child_module)?;\n                 return Ok(Some(vec![nav]));\n             }\n         }\n@@ -100,31 +85,32 @@ fn name_definition(\n \n #[cfg(test)]\n mod tests {\n-    use test_utils::assert_eq_dbg;\n     use crate::mock_analysis::analysis_and_position;\n \n+    fn check_goto(fixuture: &str, expected: &str) {\n+        let (analysis, pos) = analysis_and_position(fixuture);\n+\n+        let mut navs = analysis.goto_definition(pos).unwrap().unwrap().info;\n+        assert_eq!(navs.len(), 1);\n+        let nav = navs.pop().unwrap();\n+        nav.assert_match(expected);\n+    }\n+\n     #[test]\n     fn goto_definition_works_in_items() {\n-        let (analysis, pos) = analysis_and_position(\n+        check_goto(\n             \"\n             //- /lib.rs\n             struct Foo;\n             enum E { X(Foo<|>) }\n             \",\n-        );\n-\n-        let symbols = analysis.goto_definition(pos).unwrap().unwrap();\n-        assert_eq_dbg(\n-            r#\"[NavigationTarget { file_id: FileId(1), name: \"Foo\",\n-                                   kind: STRUCT_DEF, range: [0; 11),\n-                                   ptr: Some(LocalSyntaxPtr { range: [0; 11), kind: STRUCT_DEF }) }]\"#,\n-            &symbols,\n+            \"Foo STRUCT_DEF FileId(1) [0; 11) [7; 10)\",\n         );\n     }\n \n     #[test]\n     fn goto_definition_resolves_correct_name() {\n-        let (analysis, pos) = analysis_and_position(\n+        check_goto(\n             \"\n             //- /lib.rs\n             use a::Foo;\n@@ -136,47 +122,30 @@ mod tests {\n             //- /b.rs\n             struct Foo;\n             \",\n-        );\n-\n-        let symbols = analysis.goto_definition(pos).unwrap().unwrap();\n-        assert_eq_dbg(\n-            r#\"[NavigationTarget { file_id: FileId(2), name: \"Foo\",\n-                                   kind: STRUCT_DEF, range: [0; 11),\n-                                   ptr: Some(LocalSyntaxPtr { range: [0; 11), kind: STRUCT_DEF }) }]\"#,\n-            &symbols,\n+            \"Foo STRUCT_DEF FileId(2) [0; 11) [7; 10)\",\n         );\n     }\n \n     #[test]\n     fn goto_definition_works_for_module_declaration() {\n-        let (analysis, pos) = analysis_and_position(\n+        check_goto(\n             \"\n             //- /lib.rs\n             mod <|>foo;\n             //- /foo.rs\n             // empty\n-        \",\n-        );\n-\n-        let symbols = analysis.goto_definition(pos).unwrap().unwrap();\n-        assert_eq_dbg(\n-            r#\"[NavigationTarget { file_id: FileId(2), name: \"foo\", kind: MODULE, range: [0; 0), ptr: None }]\"#,\n-            &symbols,\n+            \",\n+            \"foo SOURCE_FILE FileId(2) [0; 10)\",\n         );\n \n-        let (analysis, pos) = analysis_and_position(\n+        check_goto(\n             \"\n             //- /lib.rs\n             mod <|>foo;\n             //- /foo/mod.rs\n             // empty\n-        \",\n-        );\n-\n-        let symbols = analysis.goto_definition(pos).unwrap().unwrap();\n-        assert_eq_dbg(\n-            r#\"[NavigationTarget { file_id: FileId(2), name: \"foo\", kind: MODULE, range: [0; 0), ptr: None }]\"#,\n-            &symbols,\n+            \",\n+            \"foo SOURCE_FILE FileId(2) [0; 10)\",\n         );\n     }\n }"}, {"sha": "f544ffa6d129f036f66bb9749d3e592e682ccae9", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b", "patch": "@@ -88,11 +88,11 @@ fn doc_text_for(db: &RootDatabase, nav: NavigationTarget) -> Cancelable<Option<S\n \n impl NavigationTarget {\n     fn node(&self, db: &RootDatabase) -> Option<TreePtr<SyntaxNode>> {\n-        let source_file = db.source_file(self.file_id);\n+        let source_file = db.source_file(self.file_id());\n         let source_file = source_file.syntax();\n         let node = source_file\n             .descendants()\n-            .find(|node| node.kind() == self.kind && node.range() == self.range)?\n+            .find(|node| node.kind() == self.kind() && node.range() == self.full_range())?\n             .to_owned();\n         Some(node)\n     }"}, {"sha": "ba4aa0fd5790731a69e87b5c1bea234e125cdbed", "filename": "crates/ra_ide_api/src/imp.rs", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b/crates%2Fra_ide_api%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b/crates%2Fra_ide_api%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fimp.rs?ref=aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b", "patch": "@@ -11,12 +11,11 @@ use ra_syntax::{\n     TextRange, AstNode, SourceFile,\n     ast::{self, NameOwner},\n     algo::find_node_at_offset,\n-    SyntaxKind::*,\n };\n \n use crate::{\n     AnalysisChange,\n-    Cancelable, NavigationTarget,\n+    Cancelable,\n     CrateId, db, Diagnostic, FileId, FilePosition, FileRange, FileSystemEdit,\n     Query, RootChange, SourceChange, SourceFileEdit,\n     symbol_index::{LibrarySymbolsQuery, FileSymbol},\n@@ -99,29 +98,6 @@ impl db::RootDatabase {\n }\n \n impl db::RootDatabase {\n-    /// This returns `Vec` because a module may be included from several places. We\n-    /// don't handle this case yet though, so the Vec has length at most one.\n-    pub(crate) fn parent_module(\n-        &self,\n-        position: FilePosition,\n-    ) -> Cancelable<Vec<NavigationTarget>> {\n-        let module = match source_binder::module_from_position(self, position)? {\n-            None => return Ok(Vec::new()),\n-            Some(it) => it,\n-        };\n-        let (file_id, ast_module) = match module.declaration_source(self)? {\n-            None => return Ok(Vec::new()),\n-            Some(it) => it,\n-        };\n-        let name = ast_module.name().unwrap();\n-        Ok(vec![NavigationTarget {\n-            file_id,\n-            name: name.text().clone(),\n-            range: name.syntax().range(),\n-            kind: MODULE,\n-            ptr: None,\n-        }])\n-    }\n     /// Returns `Vec` for the same reason as `parent_module`\n     pub(crate) fn crate_for(&self, file_id: FileId) -> Cancelable<Vec<CrateId>> {\n         let module = match source_binder::module_from_file_id(self, file_id)? {"}, {"sha": "6155d903a0cd3133e90e484606eed6f707d8425a", "filename": "crates/ra_ide_api/src/lib.rs", "status": "modified", "additions": 11, "deletions": 113, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Flib.rs?ref=aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b", "patch": "@@ -18,25 +18,26 @@ macro_rules! ctry {\n     };\n }\n \n-mod completion;\n mod db;\n-mod goto_definition;\n mod imp;\n pub mod mock_analysis;\n-mod runnables;\n mod symbol_index;\n+mod navigation_target;\n \n+mod completion;\n+mod runnables;\n+mod goto_definition;\n mod extend_selection;\n mod hover;\n mod call_info;\n mod syntax_highlighting;\n+mod parent_module;\n \n use std::{fmt, sync::Arc};\n \n-use hir::{Def, ModuleSource, Name};\n-use ra_syntax::{SmolStr, SourceFile, TreePtr, SyntaxKind, SyntaxNode, TextRange, TextUnit, AstNode};\n+use ra_syntax::{SourceFile, TreePtr, TextRange, TextUnit};\n use ra_text_edit::TextEdit;\n-use ra_db::{SyntaxDatabase, FilesDatabase, LocalSyntaxPtr, BaseDatabase};\n+use ra_db::{SyntaxDatabase, FilesDatabase, BaseDatabase};\n use rayon::prelude::*;\n use relative_path::RelativePathBuf;\n use rustc_hash::FxHashMap;\n@@ -50,6 +51,7 @@ use crate::{\n pub use crate::{\n     completion::{CompletionItem, CompletionItemKind, InsertText},\n     runnables::{Runnable, RunnableKind},\n+    navigation_target::NavigationTarget,\n };\n pub use ra_ide_api_light::{\n     Fold, FoldKind, HighlightedRange, Severity, StructureNode,\n@@ -243,118 +245,14 @@ impl Query {\n     }\n }\n \n-/// `NavigationTarget` represents and element in the editor's UI whihc you can\n-/// click on to navigate to a particular piece of code.\n-///\n-/// Typically, a `NavigationTarget` corresponds to some element in the source\n-/// code, like a function or a struct, but this is not strictly required.\n-#[derive(Debug, Clone)]\n-pub struct NavigationTarget {\n-    file_id: FileId,\n-    name: SmolStr,\n-    kind: SyntaxKind,\n-    range: TextRange,\n-    // Should be DefId ideally\n-    ptr: Option<LocalSyntaxPtr>,\n-}\n-\n-impl NavigationTarget {\n-    fn from_symbol(symbol: FileSymbol) -> NavigationTarget {\n-        NavigationTarget {\n-            file_id: symbol.file_id,\n-            name: symbol.name.clone(),\n-            kind: symbol.ptr.kind(),\n-            range: symbol.ptr.range(),\n-            ptr: Some(symbol.ptr.clone()),\n-        }\n-    }\n-\n-    fn from_syntax(name: Option<Name>, file_id: FileId, node: &SyntaxNode) -> NavigationTarget {\n-        NavigationTarget {\n-            file_id,\n-            name: name.map(|n| n.to_string().into()).unwrap_or(\"\".into()),\n-            kind: node.kind(),\n-            range: node.range(),\n-            ptr: Some(LocalSyntaxPtr::new(node)),\n-        }\n-    }\n-    // TODO once Def::Item is gone, this should be able to always return a NavigationTarget\n-    fn from_def(db: &db::RootDatabase, def: Def) -> Cancelable<Option<NavigationTarget>> {\n-        Ok(match def {\n-            Def::Struct(s) => {\n-                let (file_id, node) = s.source(db)?;\n-                Some(NavigationTarget::from_syntax(\n-                    s.name(db)?,\n-                    file_id.original_file(db),\n-                    node.syntax(),\n-                ))\n-            }\n-            Def::Enum(e) => {\n-                let (file_id, node) = e.source(db)?;\n-                Some(NavigationTarget::from_syntax(\n-                    e.name(db)?,\n-                    file_id.original_file(db),\n-                    node.syntax(),\n-                ))\n-            }\n-            Def::EnumVariant(ev) => {\n-                let (file_id, node) = ev.source(db)?;\n-                Some(NavigationTarget::from_syntax(\n-                    ev.name(db)?,\n-                    file_id.original_file(db),\n-                    node.syntax(),\n-                ))\n-            }\n-            Def::Function(f) => {\n-                let (file_id, node) = f.source(db)?;\n-                let name = f.signature(db).name().clone();\n-                Some(NavigationTarget::from_syntax(\n-                    Some(name),\n-                    file_id.original_file(db),\n-                    node.syntax(),\n-                ))\n-            }\n-            Def::Module(m) => {\n-                let (file_id, source) = m.definition_source(db)?;\n-                let name = m.name(db)?;\n-                match source {\n-                    ModuleSource::SourceFile(node) => {\n-                        Some(NavigationTarget::from_syntax(name, file_id, node.syntax()))\n-                    }\n-                    ModuleSource::Module(node) => {\n-                        Some(NavigationTarget::from_syntax(name, file_id, node.syntax()))\n-                    }\n-                }\n-            }\n-            Def::Item => None,\n-        })\n-    }\n-\n-    pub fn name(&self) -> &SmolStr {\n-        &self.name\n-    }\n-\n-    pub fn kind(&self) -> SyntaxKind {\n-        self.kind\n-    }\n-\n-    pub fn file_id(&self) -> FileId {\n-        self.file_id\n-    }\n-\n-    pub fn range(&self) -> TextRange {\n-        self.range\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct RangeInfo<T> {\n     pub range: TextRange,\n     pub info: T,\n }\n \n impl<T> RangeInfo<T> {\n-    fn new(range: TextRange, info: T) -> RangeInfo<T> {\n+    pub fn new(range: TextRange, info: T) -> RangeInfo<T> {\n         RangeInfo { range, info }\n     }\n }\n@@ -494,7 +392,7 @@ impl Analysis {\n     pub fn goto_definition(\n         &self,\n         position: FilePosition,\n-    ) -> Cancelable<Option<Vec<NavigationTarget>>> {\n+    ) -> Cancelable<Option<RangeInfo<Vec<NavigationTarget>>>> {\n         self.db\n             .catch_canceled(|db| goto_definition::goto_definition(db, position))?\n     }\n@@ -517,7 +415,7 @@ impl Analysis {\n \n     /// Returns a `mod name;` declaration which created the current module.\n     pub fn parent_module(&self, position: FilePosition) -> Cancelable<Vec<NavigationTarget>> {\n-        self.with_db(|db| db.parent_module(position))?\n+        self.with_db(|db| parent_module::parent_module(db, position))?\n     }\n \n     /// Returns crates this file belongs too."}, {"sha": "b955bbe42b0b12199fea94d49d2cd007aa6e1130", "filename": "crates/ra_ide_api/src/navigation_target.rs", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b/crates%2Fra_ide_api%2Fsrc%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b/crates%2Fra_ide_api%2Fsrc%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fnavigation_target.rs?ref=aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b", "patch": "@@ -0,0 +1,159 @@\n+use ra_db::{FileId, Cancelable};\n+use ra_syntax::{\n+    SyntaxNode, AstNode, SmolStr, TextRange, ast,\n+    SyntaxKind::{self, NAME},\n+};\n+use hir::{Def, ModuleSource};\n+\n+use crate::{FileSymbol, db::RootDatabase};\n+\n+/// `NavigationTarget` represents and element in the editor's UI which you can\n+/// click on to navigate to a particular piece of code.\n+///\n+/// Typically, a `NavigationTarget` corresponds to some element in the source\n+/// code, like a function or a struct, but this is not strictly required.\n+#[derive(Debug, Clone)]\n+pub struct NavigationTarget {\n+    file_id: FileId,\n+    name: SmolStr,\n+    kind: SyntaxKind,\n+    full_range: TextRange,\n+    focus_range: Option<TextRange>,\n+}\n+\n+impl NavigationTarget {\n+    pub fn name(&self) -> &SmolStr {\n+        &self.name\n+    }\n+\n+    pub fn kind(&self) -> SyntaxKind {\n+        self.kind\n+    }\n+\n+    pub fn file_id(&self) -> FileId {\n+        self.file_id\n+    }\n+\n+    pub fn full_range(&self) -> TextRange {\n+        self.full_range\n+    }\n+\n+    /// A \"most interesting\" range withing the `range_full`.\n+    ///\n+    /// Typically, `range` is the whole syntax node, including doc comments, and\n+    /// `focus_range` is the range of the identifier.\n+    pub fn focus_range(&self) -> Option<TextRange> {\n+        self.focus_range\n+    }\n+\n+    pub(crate) fn from_symbol(symbol: FileSymbol) -> NavigationTarget {\n+        NavigationTarget {\n+            file_id: symbol.file_id,\n+            name: symbol.name.clone(),\n+            kind: symbol.ptr.kind(),\n+            full_range: symbol.ptr.range(),\n+            focus_range: None,\n+        }\n+    }\n+\n+    pub(crate) fn from_scope_entry(\n+        file_id: FileId,\n+        entry: &hir::ScopeEntryWithSyntax,\n+    ) -> NavigationTarget {\n+        NavigationTarget {\n+            file_id,\n+            name: entry.name().to_string().into(),\n+            full_range: entry.ptr().range(),\n+            focus_range: None,\n+            kind: NAME,\n+        }\n+    }\n+\n+    pub(crate) fn from_module(\n+        db: &RootDatabase,\n+        module: hir::Module,\n+    ) -> Cancelable<NavigationTarget> {\n+        let (file_id, source) = module.definition_source(db)?;\n+        let name = module\n+            .name(db)?\n+            .map(|it| it.to_string().into())\n+            .unwrap_or_default();\n+        let res = match source {\n+            ModuleSource::SourceFile(node) => {\n+                NavigationTarget::from_syntax(file_id, name, None, node.syntax())\n+            }\n+            ModuleSource::Module(node) => {\n+                NavigationTarget::from_syntax(file_id, name, None, node.syntax())\n+            }\n+        };\n+        Ok(res)\n+    }\n+\n+    // TODO once Def::Item is gone, this should be able to always return a NavigationTarget\n+    pub(crate) fn from_def(db: &RootDatabase, def: Def) -> Cancelable<Option<NavigationTarget>> {\n+        let res = match def {\n+            Def::Struct(s) => {\n+                let (file_id, node) = s.source(db)?;\n+                NavigationTarget::from_named(file_id.original_file(db), &*node)\n+            }\n+            Def::Enum(e) => {\n+                let (file_id, node) = e.source(db)?;\n+                NavigationTarget::from_named(file_id.original_file(db), &*node)\n+            }\n+            Def::EnumVariant(ev) => {\n+                let (file_id, node) = ev.source(db)?;\n+                NavigationTarget::from_named(file_id.original_file(db), &*node)\n+            }\n+            Def::Function(f) => {\n+                let (file_id, node) = f.source(db)?;\n+                NavigationTarget::from_named(file_id.original_file(db), &*node)\n+            }\n+            Def::Module(m) => NavigationTarget::from_module(db, m)?,\n+            Def::Item => return Ok(None),\n+        };\n+        Ok(Some(res))\n+    }\n+\n+    #[cfg(test)]\n+    pub(crate) fn assert_match(&self, expected: &str) {\n+        let actual = self.debug_render();\n+        test_utils::assert_eq_text!(expected.trim(), actual.trim(),);\n+    }\n+\n+    #[cfg(test)]\n+    pub(crate) fn debug_render(&self) -> String {\n+        let mut buf = format!(\n+            \"{} {:?} {:?} {:?}\",\n+            self.name(),\n+            self.kind(),\n+            self.file_id(),\n+            self.full_range()\n+        );\n+        if let Some(focus_range) = self.focus_range() {\n+            buf.push_str(&format!(\" {:?}\", focus_range))\n+        }\n+        buf\n+    }\n+\n+    fn from_named(file_id: FileId, node: &impl ast::NameOwner) -> NavigationTarget {\n+        let name = node.name().map(|it| it.text().clone()).unwrap_or_default();\n+        let focus_range = node.name().map(|it| it.syntax().range());\n+        NavigationTarget::from_syntax(file_id, name, focus_range, node.syntax())\n+    }\n+\n+    fn from_syntax(\n+        file_id: FileId,\n+        name: SmolStr,\n+        focus_range: Option<TextRange>,\n+        node: &SyntaxNode,\n+    ) -> NavigationTarget {\n+        NavigationTarget {\n+            file_id,\n+            name,\n+            kind: node.kind(),\n+            full_range: node.range(),\n+            focus_range,\n+            // ptr: Some(LocalSyntaxPtr::new(node)),\n+        }\n+    }\n+}"}, {"sha": "d345839a35006a427cdd9a7b33a8fe31da0b16d1", "filename": "crates/ra_ide_api/src/parent_module.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs?ref=aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b", "patch": "@@ -0,0 +1,52 @@\n+use ra_db::{Cancelable, FilePosition};\n+\n+use crate::{NavigationTarget, db::RootDatabase};\n+\n+/// This returns `Vec` because a module may be included from several places. We\n+/// don't handle this case yet though, so the Vec has length at most one.\n+pub(crate) fn parent_module(\n+    db: &RootDatabase,\n+    position: FilePosition,\n+) -> Cancelable<Vec<NavigationTarget>> {\n+    let module = match hir::source_binder::module_from_position(db, position)? {\n+        None => return Ok(Vec::new()),\n+        Some(it) => it,\n+    };\n+    let nav = NavigationTarget::from_module(db, module)?;\n+    Ok(vec![nav])\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::mock_analysis::analysis_and_position;\n+\n+    #[test]\n+    fn test_resolve_parent_module() {\n+        let (analysis, pos) = analysis_and_position(\n+            \"\n+            //- /lib.rs\n+            mod foo;\n+            //- /foo.rs\n+            <|>// empty\n+            \",\n+        );\n+        let nav = analysis.parent_module(pos).unwrap().pop().unwrap();\n+        nav.assert_match(\"foo SOURCE_FILE FileId(2) [0; 10)\");\n+    }\n+\n+    #[test]\n+    fn test_resolve_parent_module_for_inline() {\n+        let (analysis, pos) = analysis_and_position(\n+            \"\n+            //- /lib.rs\n+            mod foo {\n+                mod bar {\n+                    mod baz { <|> }\n+                }\n+            }\n+            \",\n+        );\n+        let nav = analysis.parent_module(pos).unwrap().pop().unwrap();\n+        nav.assert_match(\"baz MODULE FileId(1) [32; 44)\");\n+    }\n+}"}, {"sha": "7dc1dba73ae564e308a5cd66be6689579c8e6483", "filename": "crates/ra_ide_api/tests/test/main.rs", "status": "modified", "additions": 2, "deletions": 38, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b/crates%2Fra_ide_api%2Ftests%2Ftest%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b/crates%2Fra_ide_api%2Ftests%2Ftest%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Ftests%2Ftest%2Fmain.rs?ref=aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b", "patch": "@@ -4,7 +4,7 @@ use ra_syntax::TextRange;\n use test_utils::{assert_eq_dbg, assert_eq_text};\n \n use ra_ide_api::{\n-    mock_analysis::{analysis_and_position, single_file, single_file_with_position, MockAnalysis},\n+    mock_analysis::{single_file, single_file_with_position, MockAnalysis},\n     AnalysisChange, CrateGraph, FileId, Query\n };\n \n@@ -34,42 +34,6 @@ fn test_unresolved_module_diagnostic_no_diag_for_inline_mode() {\n     assert_eq_dbg(r#\"[]\"#, &diagnostics);\n }\n \n-#[test]\n-fn test_resolve_parent_module() {\n-    let (analysis, pos) = analysis_and_position(\n-        \"\n-        //- /lib.rs\n-        mod foo;\n-        //- /foo.rs\n-        <|>// empty\n-    \",\n-    );\n-    let symbols = analysis.parent_module(pos).unwrap();\n-    assert_eq_dbg(\n-        r#\"[NavigationTarget { file_id: FileId(1), name: \"foo\", kind: MODULE, range: [4; 7), ptr: None }]\"#,\n-        &symbols,\n-    );\n-}\n-\n-#[test]\n-fn test_resolve_parent_module_for_inline() {\n-    let (analysis, pos) = analysis_and_position(\n-        \"\n-        //- /lib.rs\n-        mod foo {\n-            mod bar {\n-                mod baz { <|> }\n-            }\n-        }\n-    \",\n-    );\n-    let symbols = analysis.parent_module(pos).unwrap();\n-    assert_eq_dbg(\n-        r#\"[NavigationTarget { file_id: FileId(1), name: \"baz\", kind: MODULE, range: [36; 39), ptr: None }]\"#,\n-        &symbols,\n-    );\n-}\n-\n #[test]\n fn test_resolve_crate_root() {\n     let mock = MockAnalysis::with_files(\n@@ -245,5 +209,5 @@ pub trait HirDatabase: SyntaxDatabase {}\n     let mut symbols = analysis.symbol_search(Query::new(\"Hir\".into())).unwrap();\n     let s = symbols.pop().unwrap();\n     assert_eq!(s.name(), \"HirDatabase\");\n-    assert_eq!(s.range(), TextRange::from_to(33.into(), 44.into()));\n+    assert_eq!(s.full_range(), TextRange::from_to(33.into(), 44.into()));\n }"}, {"sha": "76fa98cbeb9b89d4a05315e624035bde75b45c56", "filename": "crates/ra_lsp_server/src/conv.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs?ref=aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b", "patch": "@@ -1,12 +1,12 @@\n use languageserver_types::{\n-    self, CreateFile, DocumentChangeOperation, DocumentChanges, InsertTextFormat, Location,\n+    self, CreateFile, DocumentChangeOperation, DocumentChanges, InsertTextFormat, Location, LocationLink,\n     Position, Range, RenameFile, ResourceOp, SymbolKind, TextDocumentEdit, TextDocumentIdentifier,\n     TextDocumentItem, TextDocumentPositionParams, Url, VersionedTextDocumentIdentifier,\n     WorkspaceEdit,\n };\n use ra_ide_api::{\n     CompletionItem, CompletionItemKind, FileId, FilePosition, FileRange, FileSystemEdit,\n-    InsertText, NavigationTarget, SourceChange, SourceFileEdit,\n+    InsertText, NavigationTarget, SourceChange, SourceFileEdit, RangeInfo,\n     LineCol, LineIndex, translate_offset_with_edit\n };\n use ra_syntax::{SyntaxKind, TextRange, TextUnit};\n@@ -345,10 +345,32 @@ impl TryConvWith for &NavigationTarget {\n     type Output = Location;\n     fn try_conv_with(self, world: &ServerWorld) -> Result<Location> {\n         let line_index = world.analysis().file_line_index(self.file_id());\n-        to_location(self.file_id(), self.range(), &world, &line_index)\n+        let range = self.focus_range().unwrap_or(self.full_range());\n+        to_location(self.file_id(), range, &world, &line_index)\n     }\n }\n \n+pub fn to_location_link(\n+    target: &RangeInfo<NavigationTarget>,\n+    world: &ServerWorld,\n+    // line index for original range file\n+    line_index: &LineIndex,\n+) -> Result<LocationLink> {\n+    let url = target.info.file_id().try_conv_with(world)?;\n+    let tgt_line_index = world.analysis().file_line_index(target.info.file_id());\n+\n+    let res = LocationLink {\n+        origin_selection_range: Some(target.range.conv_with(line_index)),\n+        target_uri: url.to_string(),\n+        target_range: target.info.full_range().conv_with(&tgt_line_index),\n+        target_selection_range: target\n+            .info\n+            .focus_range()\n+            .map(|it| it.conv_with(&tgt_line_index)),\n+    };\n+    Ok(res)\n+}\n+\n pub fn to_location(\n     file_id: FileId,\n     range: TextRange,"}, {"sha": "aad9d6568f247993bfe3bec55f0934583194b387", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=aad1bf877e4ba5ce9e28e8bde14f790ef8d1551b", "patch": "@@ -9,15 +9,15 @@ use languageserver_types::{\n     SignatureInformation, SymbolInformation, TextDocumentIdentifier, TextEdit, WorkspaceEdit,\n };\n use ra_ide_api::{\n-    FileId, FilePosition, FileRange, FoldKind, Query, RunnableKind, Severity,\n+    FileId, FilePosition, FileRange, FoldKind, Query, RunnableKind, Severity, RangeInfo,\n };\n use ra_syntax::{TextUnit, AstNode};\n use rustc_hash::FxHashMap;\n use serde_json::to_value;\n use std::io::Write;\n \n use crate::{\n-    conv::{to_location, Conv, ConvWith, MapConvWith, TryConvWith},\n+    conv::{to_location, to_location_link, Conv, ConvWith, MapConvWith, TryConvWith},\n     project_model::TargetKind,\n     req::{self, Decoration},\n     server_world::ServerWorld,\n@@ -208,15 +208,19 @@ pub fn handle_goto_definition(\n     params: req::TextDocumentPositionParams,\n ) -> Result<Option<req::GotoDefinitionResponse>> {\n     let position = params.try_conv_with(&world)?;\n-    let navs = match world.analysis().goto_definition(position)? {\n+    let line_index = world.analysis().file_line_index(position.file_id);\n+    let nav_info = match world.analysis().goto_definition(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n-    let res = navs\n+    let nav_range = nav_info.range;\n+    let res = nav_info\n+        .info\n         .into_iter()\n-        .map(|nav| nav.try_conv_with(&world))\n+        .map(|nav| RangeInfo::new(nav_range, nav))\n+        .map(|nav| to_location_link(&nav, &world, &line_index))\n         .collect::<Result<Vec<_>>>()?;\n-    Ok(Some(req::GotoDefinitionResponse::Array(res)))\n+    Ok(Some(req::GotoDefinitionResponse::Link(res)))\n }\n \n pub fn handle_parent_module("}]}