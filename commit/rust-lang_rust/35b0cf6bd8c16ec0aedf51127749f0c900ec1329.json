{"sha": "35b0cf6bd8c16ec0aedf51127749f0c900ec1329", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1YjBjZjZiZDhjMTZlYzBhZWRmNTExMjc3NDlmMGM5MDBlYzEzMjk=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-12T08:38:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-12T08:38:43Z"}, "message": "Rollup merge of #37698 - GuillaumeGomez:marker_urls, r=brson\n\nAdd missing urls for marker's traits\n\nr? @steveklabnik", "tree": {"sha": "0b0cf9f26c44ccac090de7d2df603162df9abe79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b0cf9f26c44ccac090de7d2df603162df9abe79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35b0cf6bd8c16ec0aedf51127749f0c900ec1329", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35b0cf6bd8c16ec0aedf51127749f0c900ec1329", "html_url": "https://github.com/rust-lang/rust/commit/35b0cf6bd8c16ec0aedf51127749f0c900ec1329", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35b0cf6bd8c16ec0aedf51127749f0c900ec1329/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8886eccdf7ff704acf664ab875c3c71e74cca1ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/8886eccdf7ff704acf664ab875c3c71e74cca1ed", "html_url": "https://github.com/rust-lang/rust/commit/8886eccdf7ff704acf664ab875c3c71e74cca1ed"}, {"sha": "fdf482c398a5efea0c748d840c6b77c71fbe8a7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/fdf482c398a5efea0c748d840c6b77c71fbe8a7b", "html_url": "https://github.com/rust-lang/rust/commit/fdf482c398a5efea0c748d840c6b77c71fbe8a7b"}], "stats": {"total": 42, "additions": 21, "deletions": 21}, "files": [{"sha": "9af10966eda4bc8e9bc81a5ab96955918e679886", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/35b0cf6bd8c16ec0aedf51127749f0c900ec1329/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b0cf6bd8c16ec0aedf51127749f0c900ec1329/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=35b0cf6bd8c16ec0aedf51127749f0c900ec1329", "patch": "@@ -26,15 +26,15 @@ use hash::Hasher;\n /// appropriate.\n ///\n /// An example of a non-`Send` type is the reference-counting pointer\n-/// [`rc::Rc`][rc]. If two threads attempt to clone `Rc`s that point to the same\n+/// [`rc::Rc`][`Rc`]. If two threads attempt to clone [`Rc`]s that point to the same\n /// reference-counted value, they might try to update the reference count at the\n-/// same time, which is [undefined behavior][ub] because `Rc` doesn't use atomic\n+/// same time, which is [undefined behavior][ub] because [`Rc`] doesn't use atomic\n /// operations. Its cousin [`sync::Arc`][arc] does use atomic operations (incurring\n /// some overhead) and thus is `Send`.\n ///\n /// See [the Nomicon](../../nomicon/send-and-sync.html) for more details.\n ///\n-/// [rc]: ../../std/rc/struct.Rc.html\n+/// [`Rc`]: ../../std/rc/struct.Rc.html\n /// [arc]: ../../std/sync/struct.Arc.html\n /// [ub]: ../../reference.html#behavior-considered-undefined\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -183,20 +183,17 @@ pub trait Unsize<T: ?Sized> {\n /// Copies happen implicitly, for example as part of an assignment `y = x`. The behavior of\n /// `Copy` is not overloadable; it is always a simple bit-wise copy.\n ///\n-/// Cloning is an explicit action, `x.clone()`. The implementation of [`Clone`][clone] can\n+/// Cloning is an explicit action, `x.clone()`. The implementation of [`Clone`] can\n /// provide any type-specific behavior necessary to duplicate values safely. For example,\n-/// the implementation of `Clone` for [`String`][string] needs to copy the pointed-to string\n-/// buffer in the heap. A simple bitwise copy of `String` values would merely copy the\n-/// pointer, leading to a double free down the line. For this reason, `String` is `Clone`\n+/// the implementation of [`Clone`] for [`String`] needs to copy the pointed-to string\n+/// buffer in the heap. A simple bitwise copy of [`String`] values would merely copy the\n+/// pointer, leading to a double free down the line. For this reason, [`String`] is [`Clone`]\n /// but not `Copy`.\n ///\n-/// `Clone` is a supertrait of `Copy`, so everything which is `Copy` must also implement\n-/// `Clone`. If a type is `Copy` then its `Clone` implementation need only return `*self`\n+/// [`Clone`] is a supertrait of `Copy`, so everything which is `Copy` must also implement\n+/// [`Clone`]. If a type is `Copy` then its [`Clone`] implementation need only return `*self`\n /// (see the example above).\n ///\n-/// [clone]: ../clone/trait.Clone.html\n-/// [string]: ../../std/string/struct.String.html\n-///\n /// ## When can my type be `Copy`?\n ///\n /// A type can implement `Copy` if all of its components implement `Copy`. For example, this\n@@ -210,7 +207,7 @@ pub trait Unsize<T: ?Sized> {\n /// }\n /// ```\n ///\n-/// A struct can be `Copy`, and `i32` is `Copy`, therefore `Point` is eligible to be `Copy`.\n+/// A struct can be `Copy`, and [`i32`] is `Copy`, therefore `Point` is eligible to be `Copy`.\n /// By contrast, consider\n ///\n /// ```\n@@ -231,8 +228,8 @@ pub trait Unsize<T: ?Sized> {\n /// ## When *can't* my type be `Copy`?\n ///\n /// Some types can't be copied safely. For example, copying `&mut T` would create an aliased\n-/// mutable reference. Copying [`String`] would duplicate responsibility for managing the `String`'s\n-/// buffer, leading to a double free.\n+/// mutable reference. Copying [`String`] would duplicate responsibility for managing the\n+/// [`String`]'s buffer, leading to a double free.\n ///\n /// Generalizing the latter case, any type implementing [`Drop`] can't be `Copy`, because it's\n /// managing some resource besides its own [`size_of::<T>()`] bytes.\n@@ -255,6 +252,9 @@ pub trait Unsize<T: ?Sized> {\n /// [`String`]: ../../std/string/struct.String.html\n /// [`Drop`]: ../../std/ops/trait.Drop.html\n /// [`size_of::<T>()`]: ../../std/mem/fn.size_of.html\n+/// [`Clone`]: ../clone/trait.Clone.html\n+/// [`String`]: ../../std/string/struct.String.html\n+/// [`i32`]: ../../std/primitive.i32.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"copy\"]\n pub trait Copy : Clone {\n@@ -290,20 +290,20 @@ pub trait Copy : Clone {\n /// mutability\" in a non-thread-safe form, such as [`cell::Cell`][cell]\n /// and [`cell::RefCell`][refcell]. These types allow for mutation of\n /// their contents even through an immutable, shared reference. For\n-/// example the `set` method on `Cell<T>` takes `&self`, so it requires\n-/// only a shared reference `&Cell<T>`. The method performs no\n-/// synchronization, thus `Cell` cannot be `Sync`.\n+/// example the `set` method on [`Cell<T>`][cell] takes `&self`, so it requires\n+/// only a shared reference [`&Cell<T>`][cell]. The method performs no\n+/// synchronization, thus [`Cell`][cell] cannot be `Sync`.\n ///\n /// Another example of a non-`Sync` type is the reference-counting\n-/// pointer [`rc::Rc`][rc]. Given any reference `&Rc<T>`, you can clone\n-/// a new `Rc<T>`, modifying the reference counts in a non-atomic way.\n+/// pointer [`rc::Rc`][rc]. Given any reference [`&Rc<T>`][rc], you can clone\n+/// a new [`Rc<T>`][rc], modifying the reference counts in a non-atomic way.\n ///\n /// For cases when one does need thread-safe interior mutability,\n /// Rust provides [atomic data types], as well as explicit locking via\n /// [`sync::Mutex`][mutex] and [`sync::RWLock`][rwlock]. These types\n /// ensure that any mutation cannot cause data races, hence the types\n /// are `Sync`. Likewise, [`sync::Arc`][arc] provides a thread-safe\n-/// analogue of `Rc`.\n+/// analogue of [`Rc`][rc].\n ///\n /// Any types with interior mutability must also use the\n /// [`cell::UnsafeCell`][unsafecell] wrapper around the value(s) which"}]}