{"sha": "e1dcec0e02fdfaba47f68703bf82529165e99601", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxZGNlYzBlMDJmZGZhYmE0N2Y2ODcwM2JmODI1MjkxNjVlOTk2MDE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-10T13:18:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-10T13:18:09Z"}, "message": "Merge #9846\n\n9846: feat: Generate default trait fn impl when generating `Clone` r=Veykril a=yoshuawuyts\n\nImplements a default trait function body when generating the `Clone` trait for a type. Thanks!\r\n\r\nr? `@\\veykril`\n\nCo-authored-by: Yoshua Wuyts <yoshuawuyts@gmail.com>", "tree": {"sha": "6dc134572fd3591f75e180ac3e256d6cf0db4744", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6dc134572fd3591f75e180ac3e256d6cf0db4744"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1dcec0e02fdfaba47f68703bf82529165e99601", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhEnyRCRBK7hj4Ov3rIwAASKsIAECcxr9wzJM2DK98iT4/h1kn\nkeGRzii68gLamsJb+hZyWg2sK+D8zqIO+bkJBvcq0ySMnTJUgG6feVGGmdDf/2BF\nxUvBRp2qsvDwMZSw9cIN5HlWNo6M5nSfkhDn7cgKet7DxhhEDVNsAKwt4qOPjrIt\np8vldHGrs0MZtGSzdAYtTKXgFg/XpAk36ylNiIJZKKoUc18sWuR2e/JZ56q15dq5\n0o94wzOZVioZjOajpDjxy7XWxLu5/5ivHruxgTxD6nx2UF2igyBSKTJKhtuIjlG5\nHaB5B+xTkoWxIJPhq9GQ4PA4OkmWqv8qAEjlzvBE38BrDAW+hU1e+mo8Kfqedps=\n=LA12\n-----END PGP SIGNATURE-----\n", "payload": "tree 6dc134572fd3591f75e180ac3e256d6cf0db4744\nparent f6ef043a887835ee78be43f18340ce36f99925e1\nparent 2f866974d9bfd7cd3be89f3806dbb623cf358bf3\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1628601489 +0000\ncommitter GitHub <noreply@github.com> 1628601489 +0000\n\nMerge #9846\n\n9846: feat: Generate default trait fn impl when generating `Clone` r=Veykril a=yoshuawuyts\n\nImplements a default trait function body when generating the `Clone` trait for a type. Thanks!\r\n\r\nr? `@\\veykril`\n\nCo-authored-by: Yoshua Wuyts <yoshuawuyts@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1dcec0e02fdfaba47f68703bf82529165e99601", "html_url": "https://github.com/rust-lang/rust/commit/e1dcec0e02fdfaba47f68703bf82529165e99601", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1dcec0e02fdfaba47f68703bf82529165e99601/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6ef043a887835ee78be43f18340ce36f99925e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6ef043a887835ee78be43f18340ce36f99925e1", "html_url": "https://github.com/rust-lang/rust/commit/f6ef043a887835ee78be43f18340ce36f99925e1"}, {"sha": "2f866974d9bfd7cd3be89f3806dbb623cf358bf3", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f866974d9bfd7cd3be89f3806dbb623cf358bf3", "html_url": "https://github.com/rust-lang/rust/commit/2f866974d9bfd7cd3be89f3806dbb623cf358bf3"}], "stats": {"total": 285, "additions": 281, "deletions": 4}, "files": [{"sha": "f256bf035ba61f2d8fd40ecdc157fc1ff5accfc3", "filename": "crates/ide_assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/e1dcec0e02fdfaba47f68703bf82529165e99601/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1dcec0e02fdfaba47f68703bf82529165e99601/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=e1dcec0e02fdfaba47f68703bf82529165e99601", "patch": "@@ -443,6 +443,169 @@ impl core::hash::Hash for Foo {\n         core::mem::discriminant(self).hash(state);\n     }\n }\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_custom_impl_clone_record_struct() {\n+        check_assist(\n+            replace_derive_with_manual_impl,\n+            r#\"\n+//- minicore: clone\n+#[derive(Clo$0ne)]\n+struct Foo {\n+    bin: usize,\n+    bar: usize,\n+}\n+\"#,\n+            r#\"\n+struct Foo {\n+    bin: usize,\n+    bar: usize,\n+}\n+\n+impl Clone for Foo {\n+    $0fn clone(&self) -> Self {\n+        Self { bin: self.bin.clone(), bar: self.bar.clone() }\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_custom_impl_clone_tuple_struct() {\n+        check_assist(\n+            replace_derive_with_manual_impl,\n+            r#\"\n+//- minicore: clone\n+#[derive(Clo$0ne)]\n+struct Foo(usize, usize);\n+\"#,\n+            r#\"\n+struct Foo(usize, usize);\n+\n+impl Clone for Foo {\n+    $0fn clone(&self) -> Self {\n+        Self(self.0.clone(), self.1.clone())\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_custom_impl_clone_empty_struct() {\n+        check_assist(\n+            replace_derive_with_manual_impl,\n+            r#\"\n+//- minicore: clone\n+#[derive(Clo$0ne)]\n+struct Foo;\n+\"#,\n+            r#\"\n+struct Foo;\n+\n+impl Clone for Foo {\n+    $0fn clone(&self) -> Self {\n+        Self {  }\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_custom_impl_clone_enum() {\n+        check_assist(\n+            replace_derive_with_manual_impl,\n+            r#\"\n+//- minicore: clone\n+#[derive(Clo$0ne)]\n+enum Foo {\n+    Bar,\n+    Baz,\n+}\n+\"#,\n+            r#\"\n+enum Foo {\n+    Bar,\n+    Baz,\n+}\n+\n+impl Clone for Foo {\n+    $0fn clone(&self) -> Self {\n+        match self {\n+            Self::Bar => Self::Bar,\n+            Self::Baz => Self::Baz,\n+        }\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_custom_impl_clone_tuple_enum() {\n+        check_assist(\n+            replace_derive_with_manual_impl,\n+            r#\"\n+//- minicore: clone\n+#[derive(Clo$0ne)]\n+enum Foo {\n+    Bar(String),\n+    Baz,\n+}\n+\"#,\n+            r#\"\n+enum Foo {\n+    Bar(String),\n+    Baz,\n+}\n+\n+impl Clone for Foo {\n+    $0fn clone(&self) -> Self {\n+        match self {\n+            Self::Bar(arg0) => Self::Bar(arg0.clone()),\n+            Self::Baz => Self::Baz,\n+        }\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_custom_impl_clone_record_enum() {\n+        check_assist(\n+            replace_derive_with_manual_impl,\n+            r#\"\n+//- minicore: clone\n+#[derive(Clo$0ne)]\n+enum Foo {\n+    Bar {\n+        bin: String,\n+    },\n+    Baz,\n+}\n+\"#,\n+            r#\"\n+enum Foo {\n+    Bar {\n+        bin: String,\n+    },\n+    Baz,\n+}\n+\n+impl Clone for Foo {\n+    $0fn clone(&self) -> Self {\n+        match self {\n+            Self::Bar { bin } => Self::Bar { bin: bin.clone() },\n+            Self::Baz => Self::Baz,\n+        }\n+    }\n+}\n \"#,\n         )\n     }"}, {"sha": "04f396d46e20a24bf15fb3054ab02e3470f7c46f", "filename": "crates/ide_assists/src/utils/gen_trait_fn_body.rs", "status": "modified", "additions": 118, "deletions": 4, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/e1dcec0e02fdfaba47f68703bf82529165e99601/crates%2Fide_assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1dcec0e02fdfaba47f68703bf82529165e99601/crates%2Fide_assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs?ref=e1dcec0e02fdfaba47f68703bf82529165e99601", "patch": "@@ -16,13 +16,127 @@ pub(crate) fn gen_trait_fn_body(\n     adt: &ast::Adt,\n ) -> Option<()> {\n     match trait_path.segment()?.name_ref()?.text().as_str() {\n+        \"Clone\" => gen_clone_impl(adt, func),\n         \"Debug\" => gen_debug_impl(adt, func),\n         \"Default\" => gen_default_impl(adt, func),\n         \"Hash\" => gen_hash_impl(adt, func),\n         _ => None,\n     }\n }\n \n+/// Generate a `Clone` impl based on the fields and members of the target type.\n+fn gen_clone_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n+    fn gen_clone_call(target: ast::Expr) -> ast::Expr {\n+        let method = make::name_ref(\"clone\");\n+        make::expr_method_call(target, method, make::arg_list(None))\n+    }\n+    let expr = match adt {\n+        // `Clone` cannot be derived for unions, so no default impl can be provided.\n+        ast::Adt::Union(_) => return None,\n+        ast::Adt::Enum(enum_) => {\n+            let list = enum_.variant_list()?;\n+            let mut arms = vec![];\n+            for variant in list.variants() {\n+                let name = variant.name()?;\n+                let left = make::ext::ident_path(\"Self\");\n+                let right = make::ext::ident_path(&format!(\"{}\", name));\n+                let variant_name = make::path_concat(left, right);\n+\n+                match variant.field_list() {\n+                    // => match self { Self::Name { x } => Self::Name { x: x.clone() } }\n+                    Some(ast::FieldList::RecordFieldList(list)) => {\n+                        let mut pats = vec![];\n+                        let mut fields = vec![];\n+                        for field in list.fields() {\n+                            let field_name = field.name()?;\n+                            let pat = make::ident_pat(false, false, field_name.clone());\n+                            pats.push(pat.into());\n+\n+                            let path = make::ext::ident_path(&field_name.to_string());\n+                            let method_call = gen_clone_call(make::expr_path(path));\n+                            let name_ref = make::name_ref(&field_name.to_string());\n+                            let field = make::record_expr_field(name_ref, Some(method_call));\n+                            fields.push(field);\n+                        }\n+                        let pat = make::record_pat(variant_name.clone(), pats.into_iter());\n+                        let fields = make::record_expr_field_list(fields);\n+                        let record_expr = make::record_expr(variant_name, fields).into();\n+                        arms.push(make::match_arm(Some(pat.into()), None, record_expr));\n+                    }\n+\n+                    // => match self { Self::Name(arg1) => Self::Name(arg1.clone()) }\n+                    Some(ast::FieldList::TupleFieldList(list)) => {\n+                        let mut pats = vec![];\n+                        let mut fields = vec![];\n+                        for (i, _) in list.fields().enumerate() {\n+                            let field_name = format!(\"arg{}\", i);\n+                            let pat = make::ident_pat(false, false, make::name(&field_name));\n+                            pats.push(pat.into());\n+\n+                            let f_path = make::expr_path(make::ext::ident_path(&field_name));\n+                            fields.push(gen_clone_call(f_path));\n+                        }\n+                        let pat = make::tuple_struct_pat(variant_name.clone(), pats.into_iter());\n+                        let struct_name = make::expr_path(variant_name);\n+                        let tuple_expr = make::expr_call(struct_name, make::arg_list(fields));\n+                        arms.push(make::match_arm(Some(pat.into()), None, tuple_expr));\n+                    }\n+\n+                    // => match self { Self::Name => Self::Name }\n+                    None => {\n+                        let pattern = make::path_pat(variant_name.clone());\n+                        let variant_expr = make::expr_path(variant_name);\n+                        arms.push(make::match_arm(Some(pattern.into()), None, variant_expr));\n+                    }\n+                }\n+            }\n+\n+            let match_target = make::expr_path(make::ext::ident_path(\"self\"));\n+            let list = make::match_arm_list(arms).indent(ast::edit::IndentLevel(1));\n+            make::expr_match(match_target, list)\n+        }\n+        ast::Adt::Struct(strukt) => {\n+            match strukt.field_list() {\n+                // => Self { name: self.name.clone() }\n+                Some(ast::FieldList::RecordFieldList(field_list)) => {\n+                    let mut fields = vec![];\n+                    for field in field_list.fields() {\n+                        let base = make::expr_path(make::ext::ident_path(\"self\"));\n+                        let target = make::expr_field(base, &field.name()?.to_string());\n+                        let method_call = gen_clone_call(target);\n+                        let name_ref = make::name_ref(&field.name()?.to_string());\n+                        let field = make::record_expr_field(name_ref, Some(method_call));\n+                        fields.push(field);\n+                    }\n+                    let struct_name = make::ext::ident_path(\"Self\");\n+                    let fields = make::record_expr_field_list(fields);\n+                    make::record_expr(struct_name, fields).into()\n+                }\n+                // => Self(self.0.clone(), self.1.clone())\n+                Some(ast::FieldList::TupleFieldList(field_list)) => {\n+                    let mut fields = vec![];\n+                    for (i, _) in field_list.fields().enumerate() {\n+                        let f_path = make::expr_path(make::ext::ident_path(\"self\"));\n+                        let target = make::expr_field(f_path, &format!(\"{}\", i)).into();\n+                        fields.push(gen_clone_call(target));\n+                    }\n+                    let struct_name = make::expr_path(make::ext::ident_path(\"Self\"));\n+                    make::expr_call(struct_name, make::arg_list(fields))\n+                }\n+                // => Self { }\n+                None => {\n+                    let struct_name = make::ext::ident_path(\"Self\");\n+                    let fields = make::record_expr_field_list(None);\n+                    make::record_expr(struct_name, fields).into()\n+                }\n+            }\n+        }\n+    };\n+    let body = make::block_expr(None, Some(expr)).indent(ast::edit::IndentLevel(1));\n+    ted::replace(func.body()?.syntax(), body.clone_for_update().syntax());\n+    Some(())\n+}\n+\n /// Generate a `Debug` impl based on the fields and members of the target type.\n fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n     let annotated_name = adt.name()?;\n@@ -88,10 +202,10 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                 Some(ast::FieldList::TupleFieldList(field_list)) => {\n                     let method = make::name_ref(\"debug_tuple\");\n                     let mut expr = make::expr_method_call(target, method, args);\n-                    for (idx, _) in field_list.fields().enumerate() {\n+                    for (i, _) in field_list.fields().enumerate() {\n                         let f_path = make::expr_path(make::ext::ident_path(\"self\"));\n                         let f_path = make::expr_ref(f_path, false);\n-                        let f_path = make::expr_field(f_path, &format!(\"{}\", idx)).into();\n+                        let f_path = make::expr_field(f_path, &format!(\"{}\", i)).into();\n                         let method = make::name_ref(\"field\");\n                         expr = make::expr_method_call(expr, method, make::arg_list(Some(f_path)));\n                     }\n@@ -182,7 +296,7 @@ fn gen_hash_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n             make::block_expr(Some(stmt), None).indent(ast::edit::IndentLevel(1))\n         }\n         ast::Adt::Struct(strukt) => match strukt.field_list() {\n-            // => self.<field>.hash(state);*\n+            // => self.<field>.hash(state);\n             Some(ast::FieldList::RecordFieldList(field_list)) => {\n                 let mut stmts = vec![];\n                 for field in field_list.fields() {\n@@ -193,7 +307,7 @@ fn gen_hash_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                 make::block_expr(stmts, None).indent(ast::edit::IndentLevel(1))\n             }\n \n-            // => self.<field_index>.hash(state);*\n+            // => self.<field_index>.hash(state);\n             Some(ast::FieldList::TupleFieldList(field_list)) => {\n                 let mut stmts = vec![];\n                 for (i, _) in field_list.fields().enumerate() {"}]}