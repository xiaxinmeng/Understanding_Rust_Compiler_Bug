{"sha": "e0fa5cd2edbbb611ff3759a31357a70ca9582245", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwZmE1Y2QyZWRiYmI2MTFmZjM3NTlhMzEzNTdhNzBjYTk1ODIyNDU=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-30T10:52:34Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-06T08:56:41Z"}, "message": "Self types for ifaces\n\nThis allows a 'Name:' to appear in front of an iface declaration's\nname, which will cause 'Name' to refer to the self type (with the same\nnumber of type parameters as the iface has) in the method signatures\nof the iface. For example:\n\n    iface F: functor<A> {\n        fn fmap<B>(f: fn(A) -> B) -> F<B>;\n    }\n\nIssue #1718", "tree": {"sha": "8c7e0bce2a1ea13e77de4aee89e4b975eb427eb9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c7e0bce2a1ea13e77de4aee89e4b975eb427eb9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0fa5cd2edbbb611ff3759a31357a70ca9582245", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0fa5cd2edbbb611ff3759a31357a70ca9582245", "html_url": "https://github.com/rust-lang/rust/commit/e0fa5cd2edbbb611ff3759a31357a70ca9582245", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0fa5cd2edbbb611ff3759a31357a70ca9582245/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c42e3df9c811be18a220f33fbcb229702922104", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c42e3df9c811be18a220f33fbcb229702922104", "html_url": "https://github.com/rust-lang/rust/commit/5c42e3df9c811be18a220f33fbcb229702922104"}], "stats": {"total": 391, "additions": 242, "deletions": 149}, "files": [{"sha": "680129aa778e41752ab108b5ed5f35a26fa9f77e", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e0fa5cd2edbbb611ff3759a31357a70ca9582245/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fa5cd2edbbb611ff3759a31357a70ca9582245/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=e0fa5cd2edbbb611ff3759a31357a70ca9582245", "patch": "@@ -216,6 +216,13 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         let did = parse_def(st, conv);\n         ret ty::mk_param(st.tcx, parse_int(st) as uint, did);\n       }\n+      's' {\n+        assert next(st) as char == '[';\n+        let params = [];\n+        while peek(st) as char != ']' { params += [parse_ty(st, conv)]; }\n+        st.pos += 1u;\n+        ret ty::mk_self(st.tcx, params);\n+      }\n       '@' { ret ty::mk_box(st.tcx, parse_mt(st, conv)); }\n       '~' { ret ty::mk_uniq(st.tcx, parse_mt(st, conv)); }\n       '*' { ret ty::mk_ptr(st.tcx, parse_mt(st, conv)); }"}, {"sha": "9570669d203075cb2023a3336a8818fac1ec00eb", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e0fa5cd2edbbb611ff3759a31357a70ca9582245/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fa5cd2edbbb611ff3759a31357a70ca9582245/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=e0fa5cd2edbbb611ff3759a31357a70ca9582245", "patch": "@@ -169,6 +169,11 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         w.write_char('|');\n         w.write_str(uint::str(id));\n       }\n+      ty::ty_self(tps) {\n+        w.write_str(\"s[\");\n+        for t in tps { enc_ty(w, cx, t); }\n+        w.write_char(']');\n+      }\n       ty::ty_type { w.write_char('Y'); }\n       ty::ty_send_type { w.write_char('y'); }\n       ty::ty_opaque_closure_ptr(ty::ck_block) { w.write_str(\"C&\"); }"}, {"sha": "043e28b57c0408ce57160d2191ea4856e857a16e", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e0fa5cd2edbbb611ff3759a31357a70ca9582245/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fa5cd2edbbb611ff3759a31357a70ca9582245/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=e0fa5cd2edbbb611ff3759a31357a70ca9582245", "patch": "@@ -888,10 +888,17 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n               ast::item_impl(tps, _, _, _) {\n                 if ns == ns_type { ret lookup_in_ty_params(e, name, tps); }\n               }\n-              ast::item_iface(tps, _) | ast::item_enum(_, tps) |\n-              ast::item_ty(_, tps) {\n+              ast::item_enum(_, tps) | ast::item_ty(_, tps) {\n                 if ns == ns_type { ret lookup_in_ty_params(e, name, tps); }\n               }\n+              ast::item_iface(tps, _) {\n+                if ns == ns_type {\n+                    if name == \"self\" {\n+                        ret some(def_self(local_def(it.id)));\n+                    }\n+                    ret lookup_in_ty_params(e, name, tps);\n+                }\n+              }\n               ast::item_mod(_) {\n                 ret lookup_in_local_mod(e, it.id, sp, name, ns, inside);\n               }"}, {"sha": "6d94552db7a514f4354e9efa4c63de8c1cd52c36", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e0fa5cd2edbbb611ff3759a31357a70ca9582245/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fa5cd2edbbb611ff3759a31357a70ca9582245/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=e0fa5cd2edbbb611ff3759a31357a70ca9582245", "patch": "@@ -421,9 +421,6 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n         add_substr(s, shape_of(ccx, subt, ty_param_map));\n \n       }\n-      ty::ty_var(n) {\n-        fail \"shape_of ty_var\";\n-      }\n       ty::ty_param(n, _) {\n         // Find the type parameter in the parameter list.\n         alt vec::position_elt(ty_param_map, n) {\n@@ -450,8 +447,8 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n       ty::ty_constr(inner_t, _) {\n         s += shape_of(ccx, inner_t, ty_param_map);\n       }\n-      ty::ty_named(_, _) {\n-        ccx.tcx.sess.bug(\"shape_of: shouldn't see a ty_named\");\n+      ty::ty_var(_) | ty::ty_named(_, _) | ty::ty_self(_) {\n+        ccx.tcx.sess.bug(\"shape_of: unexpected type struct found\");\n       }\n     }\n "}, {"sha": "6868c233cff34fb062c666aa57cfe559f1e1d61d", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e0fa5cd2edbbb611ff3759a31357a70ca9582245/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fa5cd2edbbb611ff3759a31357a70ca9582245/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=e0fa5cd2edbbb611ff3759a31357a70ca9582245", "patch": "@@ -5315,7 +5315,10 @@ fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n         impl::trans_impl_vtable(ccx, item_path(ccx, it), i_did, ms, tps, it);\n       }\n       ast::item_iface(_, _) {\n-        impl::trans_iface_vtable(ccx, item_path(ccx, it), it);\n+        if !vec::any(*ty::iface_methods(ccx.tcx, local_def(it.id)), {|m|\n+            ty::type_contains_vars(ccx.tcx, ty::mk_fn(ccx.tcx, m.fty))}) {\n+            impl::trans_iface_vtable(ccx, item_path(ccx, it), it);\n+        }\n       }\n       _ { }\n     }"}, {"sha": "c2f0d655da0f9bd0ff8c56b8aa2ee8fb11e9a98d", "filename": "src/comp/middle/trans/impl.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e0fa5cd2edbbb611ff3759a31357a70ca9582245/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fa5cd2edbbb611ff3759a31357a70ca9582245/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs?ref=e0fa5cd2edbbb611ff3759a31357a70ca9582245", "patch": "@@ -94,10 +94,9 @@ fn trans_static_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n     {env: self_env(val) with lval_static_fn(bcx, did, callee_id)}\n }\n \n-fn wrapper_fn_ty(ccx: @crate_ctxt, dict_ty: TypeRef, m: ty::method)\n-    -> {ty: ty::t, llty: TypeRef} {\n-    let fty = ty::mk_fn(ccx.tcx, m.fty);\n-    let bare_fn_ty = type_of_fn_from_ty(ccx, fty, *m.tps);\n+fn wrapper_fn_ty(ccx: @crate_ctxt, dict_ty: TypeRef, fty: ty::t,\n+                 tps: @[ty::param_bounds]) -> {ty: ty::t, llty: TypeRef} {\n+    let bare_fn_ty = type_of_fn_from_ty(ccx, fty, *tps);\n     let {inputs, output} = llfn_arg_tys(bare_fn_ty);\n     {ty: fty, llty: T_fn([dict_ty] + inputs, output)}\n }\n@@ -107,7 +106,9 @@ fn trans_vtable_callee(bcx: @block_ctxt, self: ValueRef, dict: ValueRef,\n                        n_method: uint) -> lval_maybe_callee {\n     let bcx = bcx, ccx = bcx_ccx(bcx), tcx = ccx.tcx;\n     let method = ty::iface_methods(tcx, iface_id)[n_method];\n-    let {ty: fty, llty: llfty} = wrapper_fn_ty(ccx, val_ty(dict), method);\n+    let {ty: fty, llty: llfty} =\n+        wrapper_fn_ty(ccx, val_ty(dict), ty::node_id_to_type(tcx, callee_id),\n+                      method.tps);\n     let vtable = PointerCast(bcx, Load(bcx, GEPi(bcx, dict, [0, 0])),\n                              T_ptr(T_array(T_ptr(llfty), n_method + 1u)));\n     let mptr = Load(bcx, GEPi(bcx, vtable, [0, n_method as int]));\n@@ -266,7 +267,8 @@ fn trans_impl_vtable(ccx: @crate_ctxt, pt: path,\n \n fn trans_iface_wrapper(ccx: @crate_ctxt, pt: path, m: ty::method,\n                        n: uint) -> ValueRef {\n-    let {llty: llfty, _} = wrapper_fn_ty(ccx, T_ptr(T_i8()), m);\n+    let {llty: llfty, _} = wrapper_fn_ty(ccx, T_ptr(T_i8()),\n+                                         ty::mk_fn(ccx.tcx, m.fty), m.tps);\n     trans_wrapper(ccx, pt, llfty, {|llfn, bcx|\n         let self = Load(bcx, PointerCast(bcx,\n                                          LLVMGetParam(llfn, 2u as c_uint),\n@@ -358,10 +360,7 @@ fn dict_id(tcx: ty::ctxt, origin: typeck::dict_origin) -> dict_id {\n                     d_params += [dict_param_dict(dict_id(tcx, origs[orig]))];\n                     orig += 1u;\n                   }\n-                  _ {\n-                    tcx.sess.bug(\"Someone forgot to document an invariant in \\\n-                      dict_id\");\n-                  }\n+                  _ {}\n                 }\n             }\n         }"}, {"sha": "0f03d273b4c53d154e66a0c36306ff6f410738a0", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 19, "deletions": 44, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/e0fa5cd2edbbb611ff3759a31357a70ca9582245/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fa5cd2edbbb611ff3759a31357a70ca9582245/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=e0fa5cd2edbbb611ff3759a31357a70ca9582245", "patch": "@@ -80,6 +80,7 @@ export mk_send_type;\n export mk_uint;\n export mk_uniq;\n export mk_var;\n+export mk_self;\n export mk_opaque_closure_ptr;\n export mk_named;\n export gen_ty;\n@@ -126,6 +127,7 @@ export ty_send_type;\n export ty_uint;\n export ty_uniq;\n export ty_var;\n+export ty_self;\n export ty_named;\n export same_type;\n export ty_var_id;\n@@ -266,9 +268,10 @@ enum sty {\n     ty_iface(def_id, [t]),\n     ty_res(def_id, t, [t]),\n     ty_tup([t]),\n-    ty_var(int), // type variable\n \n-    ty_param(uint, def_id), // fn/enum type param\n+    ty_var(int), // type variable during typechecking\n+    ty_param(uint, def_id), // type parameter\n+    ty_self([t]), // interface method self type\n \n     ty_type, // type_desc*\n     ty_send_type, // type_desc* that has been cloned into exchange heap\n@@ -324,45 +327,25 @@ type ty_param_bounds_and_ty = {bounds: @[param_bounds], ty: t};\n type type_cache = hashmap<ast::def_id, ty_param_bounds_and_ty>;\n \n const idx_nil: uint = 0u;\n-\n const idx_bool: uint = 1u;\n-\n const idx_int: uint = 2u;\n-\n const idx_float: uint = 3u;\n-\n const idx_uint: uint = 4u;\n-\n const idx_i8: uint = 5u;\n-\n const idx_i16: uint = 6u;\n-\n const idx_i32: uint = 7u;\n-\n const idx_i64: uint = 8u;\n-\n const idx_u8: uint = 9u;\n-\n const idx_u16: uint = 10u;\n-\n const idx_u32: uint = 11u;\n-\n const idx_u64: uint = 12u;\n-\n const idx_f32: uint = 13u;\n-\n const idx_f64: uint = 14u;\n-\n const idx_char: uint = 15u;\n-\n const idx_str: uint = 16u;\n-\n const idx_type: uint = 17u;\n-\n const idx_send_type: uint = 18u;\n-\n const idx_bot: uint = 19u;\n-\n const idx_first_others: uint = 20u;\n \n type type_store = interner::interner<@raw_t>;\n@@ -462,7 +445,7 @@ fn mk_raw_ty(cx: ctxt, st: sty) -> @raw_t {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_str | ty_type | ty_send_type | ty_opaque_closure_ptr(_) {}\n       ty_param(_, _) { has_params = true; }\n-      ty_var(_) { has_vars = true; }\n+      ty_var(_) | ty_self(_) { has_vars = true; }\n       ty_enum(_, tys) | ty_iface(_, tys) {\n         for tt: t in tys { derive_flags_t(cx, has_params, has_vars, tt); }\n       }\n@@ -598,6 +581,8 @@ fn mk_res(cx: ctxt, did: ast::def_id, inner: t, tps: [t]) -> t {\n \n fn mk_var(cx: ctxt, v: int) -> t { ret gen_ty(cx, ty_var(v)); }\n \n+fn mk_self(cx: ctxt, tps: [t]) -> t { ret gen_ty(cx, ty_self(tps)); }\n+\n fn mk_param(cx: ctxt, n: uint, k: def_id) -> t {\n     ret gen_ty(cx, ty_param(n, k));\n }\n@@ -653,7 +638,6 @@ pure fn ty_name(cx: ctxt, typ: t) -> option<@str> {\n }\n \n fn default_arg_mode_for_ty(tcx: ty::ctxt, ty: ty::t) -> ast::rmode {\n-    assert !ty::type_contains_vars(tcx, ty);\n     if ty::type_is_immediate(tcx, ty) { ast::by_val }\n     else { ast::by_ref }\n }\n@@ -664,7 +648,7 @@ fn walk_ty(cx: ctxt, ty: t, f: fn(t)) {\n       ty_str | ty_send_type | ty_type |\n       ty_opaque_closure_ptr(_) | ty_var(_) | ty_param(_, _) {}\n       ty_box(tm) | ty_vec(tm) | ty_ptr(tm) { walk_ty(cx, tm.ty, f); }\n-      ty_enum(_, subtys) | ty_iface(_, subtys) {\n+      ty_enum(_, subtys) | ty_iface(_, subtys) | ty_self(subtys) {\n         for subty: t in subtys { walk_ty(cx, subty, f); }\n       }\n       ty_rec(fields) {\n@@ -728,6 +712,9 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n       ty_iface(did, subtys) {\n         ty = mk_iface(cx, did, vec::map(subtys, {|t| fold_ty(cx, fld, t) }));\n       }\n+      ty_self(subtys) {\n+        ty = mk_self(cx, vec::map(subtys, {|t| fold_ty(cx, fld, t) }));\n+      }\n       ty_rec(fields) {\n         let new_fields: [field] = [];\n         for fl: field in fields {\n@@ -1189,15 +1176,9 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n         result = type_is_pod(cx, substitute_type_params(cx, tps, inner));\n       }\n       ty_constr(subt, _) { result = type_is_pod(cx, subt); }\n-      ty_var(_) {\n-          cx.sess.bug(\"ty_var in type_is_pod\");\n-      }\n       ty_param(_, _) { result = false; }\n       ty_opaque_closure_ptr(_) { result = true; }\n-      ty_named(_,_) {\n-          cx.sess.bug(\"ty_named in type_is_pod\");\n-      }\n-\n+      _ { cx.sess.bug(\"unexpected type in type_is_pod\"); }\n     }\n \n     ret result;\n@@ -1352,6 +1333,11 @@ fn hash_type_structure(st: sty) -> uint {\n       ty_fn(f) { ret hash_fn(27u, f.inputs, f.output); }\n       ty_var(v) { ret hash_uint(30u, v as uint); }\n       ty_param(pid, _) { ret hash_uint(31u, pid); }\n+      ty_self(ts) {\n+        let h = 28u;\n+        for t in ts { h += (h << 5u) + t; }\n+        ret h;\n+      }\n       ty_type { ret 32u; }\n       ty_bot { ret 34u; }\n       ty_ptr(mt) { ret hash_subty(35u, mt.ty); }\n@@ -2548,19 +2534,8 @@ fn type_err_to_str(err: ty::type_err) -> str {\n // Replaces type parameters in the given type using the given list of\n // substitions.\n fn substitute_type_params(cx: ctxt, substs: [ty::t], typ: t) -> t {\n-   if !type_contains_params(cx, typ) { ret typ; }\n     // Precondition? idx < vec::len(substs)\n-    fn substituter(_cx: ctxt, substs: @[ty::t], idx: uint, _did: def_id)\n-        -> t {\n-        if idx < vec::len(*substs) {\n-            ret substs[idx];\n-        }\n-        else {\n-            fail #fmt(\"Internal error in substituter (substitute_type_params)\\\n-             %u %u\", vec::len(*substs), idx);\n-        }\n-    }\n-    ret fold_ty(cx, fm_param(bind substituter(cx, @substs, _, _)), typ);\n+    fold_ty(cx, fm_param({|idx, _id| substs[idx]}), typ)\n }\n \n fn def_has_ty_params(def: ast::def) -> bool {"}, {"sha": "adc276ee3359435a3fc80ef630dc16cecb91942e", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 185, "deletions": 83, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/e0fa5cd2edbbb611ff3759a31357a70ca9582245/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fa5cd2edbbb611ff3759a31357a70ca9582245/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=e0fa5cd2edbbb611ff3759a31357a70ca9582245", "patch": "@@ -44,9 +44,7 @@ type dict_map = hashmap<ast::node_id, dict_res>;\n type ty_table = hashmap<ast::def_id, ty::t>;\n \n // Used for typechecking the methods of an impl\n-enum self_info {\n-    self_impl(ty::t),\n-}\n+enum self_info { self_impl(ty::t) }\n \n type crate_ctxt = {mutable self_infos: [self_info],\n                    impl_map: resolve::impl_map,\n@@ -118,11 +116,6 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n         let typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, id.node));\n         ret {bounds: @[], ty: typ};\n       }\n-      ast::def_mod(_) {\n-        // Hopefully part of a path.\n-        // TODO: return a type that's more poisonous, perhaps?\n-        ret {bounds: @[], ty: ty::mk_nil(fcx.ccx.tcx)};\n-      }\n       ast::def_ty(_) {\n         fcx.ccx.tcx.sess.span_fatal(sp, \"expected value but found type\");\n       }\n@@ -317,19 +310,34 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n         typ = ty::mk_fn(tcx, ty_of_fn_decl(tcx, mode, proto, decl));\n       }\n       ast::ty_path(path, id) {\n-        alt tcx.def_map.find(id) {\n-          some(ast::def_ty(id)) {\n+        alt tcx.def_map.get(id) {\n+          ast::def_ty(id) {\n             typ = instantiate(tcx, ast_ty.span, mode, id, path.node.types);\n           }\n-          some(ast::def_ty_param(id, n)) {\n+          ast::def_ty_param(id, n) {\n+            if vec::len(path.node.types) > 0u {\n+                tcx.sess.span_err(ast_ty.span, \"provided type parameters to \\\n+                                                a type parameter\");\n+            }\n             typ = ty::mk_param(tcx, n, id);\n           }\n-          some(_) {\n-            tcx.sess.span_fatal(ast_ty.span,\n-                                \"found type name used as a variable\");\n+          ast::def_self(iface_id) {\n+            alt tcx.items.get(iface_id.node) {\n+              ast_map::node_item(@{node: ast::item_iface(tps, _), _}, _) {\n+                if vec::len(tps) != vec::len(path.node.types) {\n+                    tcx.sess.span_err(ast_ty.span, \"incorrect number of type \\\n+                                                    parameter to self type\");\n+                }\n+                typ = ty::mk_self(tcx, vec::map(path.node.types, {|ast_ty|\n+                    ast_ty_to_ty(tcx, mode, ast_ty)\n+                }));\n+              }\n+              _ { fail; }\n+            }\n           }\n           _ {\n-            tcx.sess.span_fatal(ast_ty.span, \"internal error in instantiate\");\n+            tcx.sess.span_fatal(ast_ty.span,\n+                                \"found type name used as a variable\");\n           }\n         }\n       }\n@@ -588,14 +596,17 @@ fn mk_ty_params(tcx: ty::ctxt, atps: [ast::ty_param])\n }\n \n fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n-                       impl_tps: uint, if_m: ty::method, substs: [ty::t]) {\n+                       impl_tps: uint, if_m: ty::method, substs: [ty::t],\n+                       self_ty: ty::t) -> ty::t {\n     if impl_m.tps != if_m.tps {\n         tcx.sess.span_err(sp, \"method `\" + if_m.ident +\n                           \"` has an incompatible set of type parameters\");\n+        ty::mk_fn(tcx, impl_m.fty)\n     } else {\n         let auto_modes = vec::map2(impl_m.fty.inputs, if_m.fty.inputs, {|i, f|\n             alt ty::struct(tcx, f.ty) {\n-              ty::ty_param(0u, _) {\n+              ty::ty_param(_, _) | ty::ty_self(_)\n+              if alt i.mode { ast::infer(_) { true } _ { false } } {\n                 {mode: ast::expl(ast::by_ref) with i}\n               }\n               _ { i }\n@@ -606,17 +617,79 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n         let substs = substs + vec::init_fn(vec::len(*if_m.tps), {|i|\n             ty::mk_param(tcx, i + impl_tps, {crate: 0, node: 0})\n         });\n-        let if_fty = ty::substitute_type_params(tcx, substs,\n-                                                ty::mk_fn(tcx, if_m.fty));\n+        let if_fty = ty::mk_fn(tcx, if_m.fty);\n+        if_fty = ty::substitute_type_params(tcx, substs, if_fty);\n+        if ty::type_contains_vars(tcx, if_fty) {\n+            if_fty = fixup_self_in_method_ty(tcx, if_fty, substs,\n+                                             self_full(self_ty, impl_tps));\n+        }\n         alt ty::unify::unify(impl_fty, if_fty, ty::unify::precise, tcx) {\n           ty::unify::ures_err(err) {\n             tcx.sess.span_err(sp, \"method `\" + if_m.ident +\n                               \"` has an incompatible type: \" +\n                               ty::type_err_to_str(err));\n-          }\n-          _ {}\n-        }\n-    }\n+            impl_fty\n+          }\n+          ty::unify::ures_ok(tp) { tp }\n+        }\n+    }\n+}\n+\n+enum self_subst { self_param(ty::t, @fn_ctxt, span), self_full(ty::t, uint) }\n+\n+// Mangles an iface method ty to make its self type conform to the self type\n+// of a specific impl or bounded type parameter. This is rather involved\n+// because the type parameters of ifaces and impls are not required to line up\n+// (an impl can have less or more parameters than the iface it implements), so\n+// some mangling of the substituted types is required.\n+fn fixup_self_in_method_ty(cx: ty::ctxt, mty: ty::t, m_substs: [ty::t],\n+                           self: self_subst) -> ty::t {\n+    if ty::type_contains_vars(cx, mty) {\n+        ty::fold_ty(cx, ty::fm_general(fn@(t: ty::t) -> ty::t {\n+            alt ty::struct(cx, t) {\n+              ty::ty_self(tps) {\n+                if vec::len(tps) > 0u {\n+                    // Move the substs into the type param system of the\n+                    // context.\n+                    let substs = vec::map(tps, {|t|\n+                        let f = fixup_self_in_method_ty(cx, t, m_substs,\n+                                                        self);\n+                        ty::substitute_type_params(cx, m_substs, f)\n+                    });\n+                    alt self {\n+                      self_param(t, fcx, sp) {\n+                        // Simply ensure that the type parameters for the self\n+                        // type match the context.\n+                        vec::iter2(substs, m_substs) {|s, ms|\n+                            demand::simple(fcx, sp, s, ms);\n+                        }\n+                        t\n+                      }\n+                      self_full(selfty, impl_n_tps) {\n+                        // Add extra substs for impl type parameters.\n+                        while vec::len(substs) < impl_n_tps {\n+                            substs += [ty::mk_param(cx, vec::len(substs),\n+                                                    {crate: 0, node: 0})];\n+                        }\n+                        // And for method type parameters.\n+                        let method_n_tps =\n+                            (vec::len(m_substs) - vec::len(tps)) as int;\n+                        if method_n_tps > 0 {\n+                            substs += vec::tail_n(m_substs, vec::len(m_substs)\n+                                                  - (method_n_tps as uint));\n+                        }\n+                        // And then instantiate the self type using all those.\n+                        ty::substitute_type_params(cx, substs, selfty)\n+                      }\n+                    }\n+                } else {\n+                    alt self { self_param(t, _, _) | self_full(t, _) { t } }\n+                }\n+              }\n+              _ { t }\n+            }\n+        }), mty)\n+    } else { mty }\n }\n \n // Item collection - a pair of bootstrap passes:\n@@ -682,15 +755,15 @@ mod collect {\n             for m in ms {\n                 let bounds = ty_param_bounds(cx.tcx, m_collect, m.tps);\n                 let mty = ty_of_method(cx.tcx, m_collect, m);\n-                my_methods += [mty];\n+                my_methods += [{mty: mty, id: m.id, span: m.span}];\n                 let fty = ty::mk_fn(cx.tcx, mty.fty);\n                 cx.tcx.tcache.insert(local_def(m.id),\n                                      {bounds: @(*i_bounds + *bounds),\n                                       ty: fty});\n                 write_ty(cx.tcx, m.id, fty);\n             }\n-            write_ty(cx.tcx, it.id, ast_ty_to_ty(cx.tcx, m_collect,\n-                                                       selfty));\n+            let selfty = ast_ty_to_ty(cx.tcx, m_collect, selfty);\n+            write_ty(cx.tcx, it.id, selfty);\n             alt ifce {\n               some(t) {\n                 let iface_ty = ast_ty_to_ty(cx.tcx, m_collect, t);\n@@ -700,10 +773,18 @@ mod collect {\n                   ty::ty_iface(did, tys) {\n                     for if_m in *ty::iface_methods(cx.tcx, did) {\n                         alt vec::find(my_methods,\n-                                      {|m| if_m.ident == m.ident}) {\n-                          some(m) {\n-                            compare_impl_method(cx.tcx, t.span, m,\n-                                                vec::len(tps), if_m, tys);\n+                                      {|m| if_m.ident == m.mty.ident}) {\n+                          some({mty: m, id, span}) {\n+                            let mt = compare_impl_method(\n+                                cx.tcx, span, m, vec::len(tps), if_m, tys,\n+                                selfty);\n+                            let old = cx.tcx.tcache.get(local_def(id));\n+                            if old.ty != mt {\n+                                cx.tcx.tcache.insert(local_def(id),\n+                                                     {bounds: old.bounds,\n+                                                     ty: mt});\n+                                write_ty(cx.tcx, id, mt);\n+                            }\n                           }\n                           none {\n                             cx.tcx.sess.span_err(t.span, \"missing method `\" +\n@@ -1459,12 +1540,54 @@ fn impl_self_ty(tcx: ty::ctxt, did: ast::def_id) -> {n_tps: uint, ty: ty::t} {\n     }\n }\n \n-fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n-                 name: ast::ident, ty: ty::t, sp: span)\n-    -> option<{method_ty: ty::t, n_tps: uint, substs: [ty::t],\n-                  origin: method_origin}> {\n-    let tcx = fcx.ccx.tcx;\n+fn lookup_method(fcx: @fn_ctxt, expr: @ast::expr, node_id: ast::node_id,\n+                 name: ast::ident, ty: ty::t, tps: [ty::t])\n+    -> option::t<method_origin> {\n+    alt lookup_method_inner(fcx, expr, name, ty) {\n+      some({method_ty: fty, n_tps: method_n_tps, substs, origin, self_sub}) {\n+        let tcx = fcx.ccx.tcx;\n+        let substs = substs, n_tps = vec::len(substs), n_tys = vec::len(tps);\n+        let has_self = ty::type_contains_params(tcx, fty);\n+        if method_n_tps + n_tps > 0u {\n+            if n_tys > 0u {\n+                if n_tys != method_n_tps {\n+                    tcx.sess.span_fatal\n+                        (expr.span, \"incorrect number of type \\\n+                                     parameters given for this method\");\n+\n+                }\n+                substs += tps;\n+            } else {\n+                substs += vec::init_fn(method_n_tps, {|_i|\n+                    ty::mk_var(tcx, next_ty_var_id(fcx))\n+                });\n+            };\n+            write_ty_substs(tcx, node_id, fty, substs);\n+        } else if n_tys > 0u {\n+            tcx.sess.span_fatal(expr.span,\n+                                \"this method does not take type \\\n+                                 parameters\");\n+        } else {\n+            write_ty(tcx, node_id, fty);\n+        }\n+        if has_self && !option::is_none(self_sub) {\n+            let fty = ty::node_id_to_type(tcx, node_id);\n+            fty = fixup_self_in_method_ty(\n+                tcx, fty, substs, option::get(self_sub));\n+            write_ty(tcx, node_id, fty);\n+        }\n+        some(origin)\n+      }\n+      none { none }\n+    }\n+}\n \n+fn lookup_method_inner(fcx: @fn_ctxt, expr: @ast::expr,\n+                       name: ast::ident, ty: ty::t)\n+    -> option::t<{method_ty: ty::t, n_tps: uint, substs: [ty::t],\n+                  origin: method_origin,\n+                  self_sub: option::t<self_subst>}> {\n+    let tcx = fcx.ccx.tcx;\n     // First, see whether this is an interface-bounded parameter\n     alt ty::struct(tcx, ty) {\n       ty::ty_param(n, did) {\n@@ -1473,11 +1596,8 @@ fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n             alt bound {\n               ty::bound_iface(t) {\n                 let (iid, tps) = alt ty::struct(tcx, t) {\n-                    ty::ty_iface(i, tps) { (i, tps) }\n-                    _ {\n-                        tcx.sess.span_bug(sp, \"Undocument invariant in \\\n-                          lookup_method\");\n-                    }\n+                  ty::ty_iface(i, tps) { (i, tps) }\n+                  _ { fail; }\n                 };\n                 let ifce_methods = ty::iface_methods(tcx, iid);\n                 alt vec::position(*ifce_methods, {|m| m.ident == name}) {\n@@ -1486,7 +1606,9 @@ fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n                     ret some({method_ty: ty::mk_fn(tcx, m.fty),\n                               n_tps: vec::len(*m.tps),\n                               substs: tps,\n-                              origin: method_param(iid, pos, n, bound_n)});\n+                              origin: method_param(iid, pos, n, bound_n),\n+                              self_sub: some(self_param(ty, fcx, expr.span))\n+                             });\n                   }\n                   _ {}\n                 }\n@@ -1501,10 +1623,17 @@ fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n         let i = 0u;\n         for m in *ty::iface_methods(tcx, did) {\n             if m.ident == name {\n-                ret some({method_ty: ty::mk_fn(tcx, m.fty),\n+                let fty = ty::mk_fn(tcx, m.fty);\n+                if ty::type_contains_vars(tcx, fty) {\n+                    tcx.sess.span_fatal(\n+                        expr.span, \"can not call a method that contains a \\\n+                                    self type through a boxed iface\");\n+                }\n+                ret some({method_ty: fty,\n                           n_tps: vec::len(*m.tps),\n                           substs: tps,\n-                          origin: method_iface(i)});\n+                          origin: method_iface(i),\n+                          self_sub: none});\n             }\n             i += 1u;\n         }\n@@ -1527,7 +1656,7 @@ fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n     }\n \n     let result = none;\n-    std::list::iter(isc) {|impls|\n+    std::list::iter(fcx.ccx.impl_map.get(expr.id)) {|impls|\n         if option::is_some(result) { ret; }\n         for @{did, methods, _} in *impls {\n             alt vec::find(methods, {|m| m.ident == name}) {\n@@ -1541,13 +1670,14 @@ fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n                     if option::is_some(result) {\n                         // FIXME[impl] score specificity to resolve ambiguity?\n                         tcx.sess.span_err(\n-                            sp, \"multiple applicable methods in scope\");\n+                           expr.span, \"multiple applicable methods in scope\");\n                     } else {\n                         result = some({\n                             method_ty: ty_from_did(tcx, m.did),\n                             n_tps: m.n_tps,\n                             substs: vars,\n-                            origin: method_static(m.did)\n+                            origin: method_static(m.did),\n+                            self_sub: none\n                         });\n                     }\n                   }\n@@ -1763,13 +1893,12 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         }\n     }\n     fn lookup_op_method(fcx: @fn_ctxt, op_ex: @ast::expr, self_t: ty::t,\n-                        opname: str,\n-                        args: [option<@ast::expr>]) -> option<ty::t> {\n-        let isc = fcx.ccx.impl_map.get(op_ex.id);\n-        alt lookup_method(fcx, isc, opname, self_t, op_ex.span) {\n-          some({method_ty, n_tps: 0u, substs, origin}) {\n-            let callee_id = ast_util::op_expr_callee_id(op_ex);\n-            write_ty_substs(fcx.ccx.tcx, callee_id, method_ty, substs);\n+                        opname: str, args: [option::t<@ast::expr>])\n+        -> option::t<ty::t> {\n+        let callee_id = ast_util::op_expr_callee_id(op_ex);\n+        alt lookup_method(fcx, op_ex, callee_id, opname, self_t, []) {\n+          some(origin) {\n+            let method_ty = ty::node_id_to_type(fcx.ccx.tcx, callee_id);\n             check_call_or_bind(fcx, op_ex.span, method_ty, args);\n             fcx.ccx.method_map.insert(op_ex.id, origin);\n             some(ty::ty_fn_ret(fcx.ccx.tcx, method_ty))\n@@ -2235,36 +2364,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n           _ {}\n         }\n         if !handled {\n-            let iscope = fcx.ccx.impl_map.get(expr.id);\n-            alt lookup_method(fcx, iscope, field, expr_t, expr.span) {\n-              some({method_ty: fty, n_tps: method_n_tps, substs, origin}) {\n-                let substs = substs, n_tps = vec::len(substs);\n-                if method_n_tps + n_tps > 0u {\n-                    if n_tys > 0u {\n-                        if n_tys != method_n_tps {\n-                            tcx.sess.span_fatal\n-                                (expr.span, \"incorrect number of type \\\n-                                           parameters given for this method\");\n-\n-                        }\n-                        for ty in tys {\n-                            substs += [ast_ty_to_ty_crate(fcx.ccx, ty)];\n-                        }\n-                    } else {\n-                        let i = 0u;\n-                        while i < method_n_tps {\n-                            substs += [ty::mk_var(tcx, next_ty_var_id(fcx))];\n-                            i += 1u;\n-                        }\n-                    }\n-                    write_ty_substs(fcx.ccx.tcx, id, fty, substs);\n-                } else if n_tys > 0u {\n-                    tcx.sess.span_fatal(expr.span,\n-                                        \"this method does not take type \\\n-                                         parameters\");\n-                } else {\n-                    write_ty(tcx, id, fty);\n-                }\n+            let tps = vec::map(tys, {|ty| ast_ty_to_ty_crate(fcx.ccx, ty)});\n+            alt lookup_method(fcx, expr, expr.id, field, expr_t, tps) {\n+              some(origin) {\n                 fcx.ccx.method_map.insert(id, origin);\n               }\n               none {"}, {"sha": "6402571eda5d240c9c82fbe6555d80367d4a638a", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0fa5cd2edbbb611ff3759a31357a70ca9582245/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fa5cd2edbbb611ff3759a31357a70ca9582245/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=e0fa5cd2edbbb611ff3759a31357a70ca9582245", "patch": "@@ -259,9 +259,7 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n             item_impl(tps, option::map(ifce, fld.fold_ty), fld.fold_ty(ty),\n                       vec::map(methods, fld.fold_method))\n           }\n-          item_iface(tps, methods) {\n-            item_iface(tps, methods)\n-          }\n+          item_iface(tps, methods) { item_iface(tps, methods) }\n           item_res(decl, typms, body, did, cid) {\n             item_res(fold_fn_decl(decl, fld), typms, fld.fold_block(body),\n                      did, cid)"}, {"sha": "99137629db66b51d712ff91520389eb91eda972b", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0fa5cd2edbbb611ff3759a31357a70ca9582245/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fa5cd2edbbb611ff3759a31357a70ca9582245/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=e0fa5cd2edbbb611ff3759a31357a70ca9582245", "patch": "@@ -579,4 +579,4 @@ mod test {\n         let doc = extract::from_srv(srv, \"\");\n         run(srv, doc)\n     }\n-}\n\\ No newline at end of file\n+}"}]}