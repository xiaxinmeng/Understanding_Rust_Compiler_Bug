{"sha": "e17806e1c887f35aea4edde785378b9b29f7433e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxNzgwNmUxYzg4N2YzNWFlYTRlZGRlNzg1Mzc4YjliMjlmNzQzM2U=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-12-15T17:38:23Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-12-15T17:38:40Z"}, "message": "rustc: Translate pattern matching", "tree": {"sha": "7bb335696d4b62a80c2a0dfe21333cc080fb43f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7bb335696d4b62a80c2a0dfe21333cc080fb43f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e17806e1c887f35aea4edde785378b9b29f7433e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e17806e1c887f35aea4edde785378b9b29f7433e", "html_url": "https://github.com/rust-lang/rust/commit/e17806e1c887f35aea4edde785378b9b29f7433e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e17806e1c887f35aea4edde785378b9b29f7433e/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd55b7ed89ce74faa2c42c8d819e4d849de4be81", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd55b7ed89ce74faa2c42c8d819e4d849de4be81", "html_url": "https://github.com/rust-lang/rust/commit/cd55b7ed89ce74faa2c42c8d819e4d849de4be81"}], "stats": {"total": 156, "additions": 155, "deletions": 1}, "files": [{"sha": "6f2145b6d7d03bb348b4128181ba9366f54f9d4a", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 155, "deletions": 1, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/e17806e1c887f35aea4edde785378b9b29f7433e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17806e1c887f35aea4edde785378b9b29f7433e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=e17806e1c887f35aea4edde785378b9b29f7433e", "patch": "@@ -15,6 +15,8 @@ import middle.typeck;\n import back.x86;\n import back.abi;\n \n+import middle.typeck.pat_ty;\n+\n import util.common;\n import util.common.istr;\n import util.common.new_def_hash;\n@@ -950,6 +952,7 @@ fn build_memcpy(@block_ctxt cx,\n     //   lib.llvm.llvm.LLVMAlignOf(llty);\n     // but this makes it upset because it's not a constant.\n \n+    log \"building memcpy\";\n     auto volatile = C_integral(0, T_i1());\n     ret res(cx, cx.build.Call(memcpy,\n                               vec(dst_ptr, src_ptr,\n@@ -1320,6 +1323,150 @@ impure fn trans_do_while(@block_ctxt cx, &ast.block body,\n     ret res(next_cx, body_res.val);\n }\n \n+// Pattern matching translation\n+\n+// Returns a pointer to the union part of the LLVM representation of a tag\n+// type, cast to the appropriate type.\n+fn get_pat_union_ptr(@block_ctxt cx, vec[@ast.pat] subpats, ValueRef llval)\n+        -> ValueRef {\n+    auto llblobptr = cx.build.GEP(llval, vec(C_int(0), C_int(1)));\n+\n+    // Generate the union type.\n+    let vec[TypeRef] llsubpattys = vec();\n+    for (@ast.pat subpat in subpats) {\n+        llsubpattys += vec(type_of(cx.fcx.ccx, pat_ty(subpat)));\n+    }\n+\n+    // Recursively check subpatterns.\n+    auto llunionty = T_struct(llsubpattys);\n+    ret cx.build.TruncOrBitCast(llblobptr, T_ptr(llunionty));\n+}\n+\n+impure fn trans_pat_match(@block_ctxt cx, @ast.pat pat, ValueRef llval,\n+                          @block_ctxt next_cx) -> result {\n+    alt (pat.node) {\n+        case (ast.pat_wild(_)) { ret res(cx, llval); }\n+        case (ast.pat_bind(_, _, _)) { ret res(cx, llval); }\n+        case (ast.pat_tag(?id, ?subpats, ?vdef_opt, ?ann)) {\n+            auto lltagptr = cx.build.GEP(llval, vec(C_int(0), C_int(0)));\n+            auto lltag = cx.build.Load(lltagptr);\n+            \n+            auto vdef = option.get[ast.variant_def](vdef_opt);\n+            auto variant_id = vdef._1;\n+            auto tinfo = cx.fcx.ccx.tags.get(vdef._0);\n+            auto variant_tag = 0;\n+            auto i = 0;\n+            for (tup(ast.def_id,arity) vinfo in tinfo.variants) {\n+                auto this_variant_id = vinfo._0;\n+                if (variant_id._0 == this_variant_id._0 &&\n+                        variant_id._1 == this_variant_id._1) {\n+                    variant_tag = i;\n+                }\n+                i += 1;\n+            }\n+\n+            auto matched_cx = new_sub_block_ctxt(cx, \"matched_cx\");\n+\n+            auto lleq = cx.build.ICmp(lib.llvm.LLVMIntEQ, lltag,\n+                                      C_int(variant_tag));\n+            cx.build.CondBr(lleq, matched_cx.llbb, next_cx.llbb);\n+\n+            if (_vec.len[@ast.pat](subpats) > 0u) {\n+                auto llunionptr = get_pat_union_ptr(matched_cx, subpats,\n+                                                    llval);\n+                auto i = 0;\n+                for (@ast.pat subpat in subpats) {\n+                    auto llsubvalptr = matched_cx.build.GEP(llunionptr,\n+                                                            vec(C_int(0),\n+                                                                C_int(i)));\n+                    auto llsubval = load_non_structural(matched_cx,\n+                                                        llsubvalptr,\n+                                                        pat_ty(subpat));\n+                    auto subpat_res = trans_pat_match(matched_cx, subpat,\n+                                                      llsubval, next_cx);\n+                    matched_cx = subpat_res.bcx;\n+                }\n+            }\n+\n+            ret res(matched_cx, llval);\n+        }\n+    }\n+\n+    fail;\n+}\n+\n+impure fn trans_pat_binding(@block_ctxt cx, @ast.pat pat, ValueRef llval)\n+        -> result {\n+    alt (pat.node) {\n+        case (ast.pat_wild(_)) { ret res(cx, llval); }\n+        case (ast.pat_bind(?id, ?def_id, ?ann)) {\n+            auto ty = node_ann_type(cx.fcx.ccx, ann);\n+            auto llty = type_of(cx.fcx.ccx, ty);\n+\n+            auto dst = cx.build.Alloca(llty);\n+            llvm.LLVMSetValueName(dst, _str.buf(id));\n+            cx.fcx.lllocals.insert(def_id, dst);\n+            cx.cleanups += clean(bind drop_slot(_, dst, ty));\n+\n+            ret copy_ty(cx, true, dst, llval, ty);\n+        }\n+        case (ast.pat_tag(_, ?subpats, _, _)) {\n+            if (_vec.len[@ast.pat](subpats) == 0u) { ret res(cx, llval); }\n+\n+            auto llunionptr = get_pat_union_ptr(cx, subpats, llval);\n+\n+            auto this_cx = cx;\n+            auto i = 0;\n+            for (@ast.pat subpat in subpats) {\n+                auto llsubvalptr = this_cx.build.GEP(llunionptr,\n+                                                     vec(C_int(0), C_int(i)));\n+                auto llsubval = load_non_structural(this_cx, llsubvalptr,\n+                                                    pat_ty(subpat));\n+                auto subpat_res = trans_pat_binding(this_cx, subpat,\n+                                                    llsubval);\n+                this_cx = subpat_res.bcx;\n+            }\n+\n+            ret res(this_cx, llval);\n+        }\n+    }\n+}\n+\n+impure fn trans_alt(@block_ctxt cx, @ast.expr expr, vec[ast.arm] arms)\n+        -> result {\n+    auto expr_res = trans_expr(cx, expr);\n+\n+    auto last_cx = new_sub_block_ctxt(expr_res.bcx, \"last\");\n+\n+    auto this_cx = expr_res.bcx;\n+    for (ast.arm arm in arms) {\n+        auto next_cx = new_sub_block_ctxt(expr_res.bcx, \"next\");\n+        auto match_res = trans_pat_match(this_cx, arm.pat, expr_res.val,\n+                                         next_cx);\n+\n+        auto binding_cx = new_scope_block_ctxt(match_res.bcx, \"binding\");\n+        match_res.bcx.build.Br(binding_cx.llbb);\n+\n+        auto binding_res = trans_pat_binding(binding_cx, arm.pat,\n+                                             expr_res.val);\n+\n+        auto block_res = trans_block(binding_res.bcx, arm.block);\n+        if (!is_terminated(block_res.bcx)) {\n+            block_res.bcx.build.Br(last_cx.llbb);\n+        }\n+\n+        this_cx = next_cx;\n+    }\n+\n+    // FIXME: This is executed when none of the patterns match; it should fail\n+    // instead!\n+    this_cx.build.Br(last_cx.llbb);\n+\n+    // FIXME: This is very wrong; we should phi together all the arm blocks,\n+    // since this is an expression.\n+    ret res(last_cx, C_nil());\n+}\n+\n // The additional bool returned indicates whether it's mem (that is\n // represented as an alloca or heap, hence needs a 'load' to be used as an\n // immediate).\n@@ -1339,6 +1486,10 @@ fn trans_name(@block_ctxt cx, &ast.name n, &option.t[ast.def] dopt)\n                     ret tup(res(cx, cx.fcx.lllocals.get(did)),\n                             true);\n                 }\n+                case (ast.def_binding(?did)) {\n+                    check (cx.fcx.lllocals.contains_key(did));\n+                    ret tup(res(cx, cx.fcx.lllocals.get(did)), true);\n+                }\n                 case (ast.def_fn(?did)) {\n                     check (cx.fcx.ccx.item_ids.contains_key(did));\n                     ret tup(res(cx, cx.fcx.ccx.item_ids.get(did)),\n@@ -1666,6 +1817,10 @@ impure fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n             ret trans_do_while(cx, body, cond);\n         }\n \n+        case (ast.expr_alt(?expr, ?arms, _)) {\n+            ret trans_alt(cx, expr, arms);\n+        }\n+\n         case (ast.expr_block(?blk, _)) {\n             auto sub_cx = new_scope_block_ctxt(cx, \"block-expr body\");\n             auto next_cx = new_sub_block_ctxt(cx, \"next\");\n@@ -2461,7 +2616,6 @@ fn trans_main_fn(@crate_ctxt cx, ValueRef llcrate) {\n     auto start_args = vec(p2i(llrust_main), p2i(llcrate), llargc, llargv);\n \n     b.Ret(b.Call(llrust_start, start_args));\n-\n }\n \n fn declare_intrinsics(ModuleRef llmod) -> hashmap[str,ValueRef] {"}]}