{"sha": "20991829e2639d1786acbd52621b220c89f0d9cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwOTkxODI5ZTI2MzlkMTc4NmFjYmQ1MjYyMWIyMjBjODlmMGQ5Y2I=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-10-12T17:15:28Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-10-12T21:07:56Z"}, "message": "Rollup merge of #37084 - jseyfried:cleanup_expanded_macro_use_scopes, r=nrc\n\nmacros: clean up scopes of expanded `#[macro_use]` imports\n\nThis PR changes the scope of macro-expanded `#[macro_use]` imports to match that of unexpanded `#[macro_use]` imports. For example, this would be allowed:\n```rust\nexample!();\nmacro_rules! m { () => { #[macro_use(example)] extern crate example_crate; } }\nm!();\n```\n\nThis PR also enforces the full shadowing restrictions from RFC 1560 on `#[macro_use]` imports (currently, we only enforce the weakened restrictions from #36767).\n\nThis is a [breaking-change], but I believe it is highly unlikely to cause breakage in practice.\nr? @nrc", "tree": {"sha": "a7ff8a46ca55d95a90fefa785bc59667e94cfc23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7ff8a46ca55d95a90fefa785bc59667e94cfc23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20991829e2639d1786acbd52621b220c89f0d9cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20991829e2639d1786acbd52621b220c89f0d9cb", "html_url": "https://github.com/rust-lang/rust/commit/20991829e2639d1786acbd52621b220c89f0d9cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20991829e2639d1786acbd52621b220c89f0d9cb/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d71be5780f2c7548956625d2261d39798f3ce83", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d71be5780f2c7548956625d2261d39798f3ce83", "html_url": "https://github.com/rust-lang/rust/commit/2d71be5780f2c7548956625d2261d39798f3ce83"}, {"sha": "829bd8c9b9519d7e4f769ad752b5da0ebe60e3ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/829bd8c9b9519d7e4f769ad752b5da0ebe60e3ad", "html_url": "https://github.com/rust-lang/rust/commit/829bd8c9b9519d7e4f769ad752b5da0ebe60e3ad"}], "stats": {"total": 543, "additions": 316, "deletions": 227}, "files": [{"sha": "137c6b58dc99817cde20d652f6f747b579391398", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/20991829e2639d1786acbd52621b220c89f0d9cb/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20991829e2639d1786acbd52621b220c89f0d9cb/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=20991829e2639d1786acbd52621b220c89f0d9cb", "patch": "@@ -94,13 +94,7 @@ pub fn lower_crate(sess: &Session,\n     let _ignore = sess.dep_graph.in_ignore();\n \n     LoweringContext {\n-        crate_root: if std_inject::no_core(krate) {\n-            None\n-        } else if std_inject::no_std(krate) {\n-            Some(\"core\")\n-        } else {\n-            Some(\"std\")\n-        },\n+        crate_root: std_inject::injected_crate_name(krate),\n         sess: sess,\n         parent_def: None,\n         resolver: resolver,"}, {"sha": "e8ab2f3a2405b541553dfa908585ca297c4b998f", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/20991829e2639d1786acbd52621b220c89f0d9cb/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20991829e2639d1786acbd52621b220c89f0d9cb/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=20991829e2639d1786acbd52621b220c89f0d9cb", "patch": "@@ -649,7 +649,7 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n     let resolver_arenas = Resolver::arenas();\n     let mut resolver =\n         Resolver::new(sess, &krate, make_glob_map, &mut crate_loader, &resolver_arenas);\n-    syntax_ext::register_builtins(&mut resolver, sess.features.borrow().quote);\n+    syntax_ext::register_builtins(&mut resolver, syntax_exts, sess.features.borrow().quote);\n \n     krate = time(time_passes, \"expansion\", || {\n         // Windows dlls do not have rpaths, so they don't know how to find their\n@@ -686,11 +686,17 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n             ..syntax::ext::expand::ExpansionConfig::default(crate_name.to_string())\n         };\n         let mut ecx = ExtCtxt::new(&sess.parse_sess, krate.config.clone(), cfg, &mut resolver);\n-        let ret = syntax::ext::expand::expand_crate(&mut ecx, syntax_exts, krate);\n+        let err_count = ecx.parse_sess.span_diagnostic.err_count();\n+\n+        let krate = ecx.monotonic_expander().expand_crate(krate);\n+\n+        if ecx.parse_sess.span_diagnostic.err_count() - ecx.resolve_err_count > err_count {\n+            ecx.parse_sess.span_diagnostic.abort_if_errors();\n+        }\n         if cfg!(windows) {\n             env::set_var(\"PATH\", &old_path);\n         }\n-        ret\n+        krate\n     });\n \n     krate.exported_macros = mem::replace(&mut resolver.exported_macros, Vec::new());"}, {"sha": "5600669d45fb97988583fb08e6e6b300a77dacc9", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 44, "deletions": 26, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/20991829e2639d1786acbd52621b220c89f0d9cb/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20991829e2639d1786acbd52621b220c89f0d9cb/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=20991829e2639d1786acbd52621b220c89f0d9cb", "patch": "@@ -13,7 +13,7 @@\n //! Here we build the \"reduced graph\": the graph of the module tree without\n //! any imports resolved.\n \n-use macros;\n+use macros::{InvocationData, LegacyScope};\n use resolve_imports::ImportDirectiveSubclass::{self, GlobImport};\n use {Module, ModuleS, ModuleKind};\n use Namespace::{self, TypeNS, ValueNS};\n@@ -200,16 +200,16 @@ impl<'b> Resolver<'b> {\n                         LoadedMacroKind::Def(mut def) => {\n                             let name = def.ident.name;\n                             if def.use_locally {\n-                                let ext = macro_rules::compile(&self.session.parse_sess, &def);\n-                                let shadowing =\n-                                    self.resolve_macro_name(Mark::root(), name, false).is_some();\n-                                self.expansion_data[&Mark::root()].module.macros.borrow_mut()\n-                                    .insert(name, macros::NameBinding {\n-                                        ext: Rc::new(ext),\n-                                        expansion: expansion,\n-                                        shadowing: shadowing,\n-                                        span: loaded_macro.import_site,\n-                                    });\n+                                let ext =\n+                                    Rc::new(macro_rules::compile(&self.session.parse_sess, &def));\n+                                if self.builtin_macros.insert(name, ext).is_some() &&\n+                                   expansion != Mark::root() {\n+                                    let msg = format!(\"`{}` is already in scope\", name);\n+                                    self.session.struct_span_err(loaded_macro.import_site, &msg)\n+                                        .note(\"macro-expanded `#[macro_use]`s may not shadow \\\n+                                               existing macros (see RFC 1560)\")\n+                                        .emit();\n+                                }\n                                 self.macro_names.insert(name);\n                             }\n                             if def.export {\n@@ -250,7 +250,6 @@ impl<'b> Resolver<'b> {\n                         attr::contains_name(&item.attrs, \"no_implicit_prelude\")\n                     },\n                     normal_ancestor_id: Some(item.id),\n-                    macros_escape: self.contains_macro_use(&item.attrs),\n                     ..ModuleS::new(Some(parent), ModuleKind::Def(def, name))\n                 });\n                 self.define(parent, name, TypeNS, (module, sp, vis));\n@@ -520,45 +519,62 @@ impl<'b> Resolver<'b> {\n \n pub struct BuildReducedGraphVisitor<'a, 'b: 'a> {\n     pub resolver: &'a mut Resolver<'b>,\n+    pub legacy_scope: LegacyScope<'b>,\n     pub expansion: Mark,\n }\n \n impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n-    fn visit_invoc(&mut self, id: ast::NodeId) {\n-        self.resolver.expansion_data.get_mut(&Mark::from_placeholder_id(id)).unwrap().module =\n-            self.resolver.current_module;\n+    fn visit_invoc(&mut self, id: ast::NodeId) -> &'b InvocationData<'b> {\n+        let invocation = self.resolver.invocations[&Mark::from_placeholder_id(id)];\n+        invocation.module.set(self.resolver.current_module);\n+        invocation.legacy_scope.set(self.legacy_scope);\n+        invocation\n     }\n }\n \n macro_rules! method {\n     ($visit:ident: $ty:ty, $invoc:path, $walk:ident) => {\n         fn $visit(&mut self, node: &$ty) {\n-            match node.node {\n-                $invoc(..) => self.visit_invoc(node.id),\n-                _ => visit::$walk(self, node),\n+            if let $invoc(..) = node.node {\n+                self.visit_invoc(node.id);\n+            } else {\n+                visit::$walk(self, node);\n             }\n         }\n     }\n }\n \n impl<'a, 'b> Visitor for BuildReducedGraphVisitor<'a, 'b> {\n     method!(visit_impl_item: ast::ImplItem, ast::ImplItemKind::Macro, walk_impl_item);\n-    method!(visit_stmt:      ast::Stmt,     ast::StmtKind::Mac,       walk_stmt);\n     method!(visit_expr:      ast::Expr,     ast::ExprKind::Mac,       walk_expr);\n     method!(visit_pat:       ast::Pat,      ast::PatKind::Mac,        walk_pat);\n     method!(visit_ty:        ast::Ty,       ast::TyKind::Mac,         walk_ty);\n \n     fn visit_item(&mut self, item: &Item) {\n-        match item.node {\n+        let macro_use = match item.node {\n             ItemKind::Mac(..) if item.id == ast::DUMMY_NODE_ID => return, // Scope placeholder\n-            ItemKind::Mac(..) => return self.visit_invoc(item.id),\n-            _ => {}\n-        }\n+            ItemKind::Mac(..) => {\n+                return self.legacy_scope = LegacyScope::Expansion(self.visit_invoc(item.id));\n+            }\n+            ItemKind::Mod(..) => self.resolver.contains_macro_use(&item.attrs),\n+            _ => false,\n+        };\n \n-        let parent = self.resolver.current_module;\n+        let (parent, legacy_scope) = (self.resolver.current_module, self.legacy_scope);\n         self.resolver.build_reduced_graph_for_item(item, self.expansion);\n         visit::walk_item(self, item);\n         self.resolver.current_module = parent;\n+        if !macro_use {\n+            self.legacy_scope = legacy_scope;\n+        }\n+    }\n+\n+    fn visit_stmt(&mut self, stmt: &ast::Stmt) {\n+        if let ast::StmtKind::Mac(..) = stmt.node {\n+            self.legacy_scope = LegacyScope::Expansion(self.visit_invoc(stmt.id));\n+        } else {\n+            visit::walk_stmt(self, stmt);\n+        }\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n@@ -567,18 +583,20 @@ impl<'a, 'b> Visitor for BuildReducedGraphVisitor<'a, 'b> {\n     }\n \n     fn visit_block(&mut self, block: &Block) {\n-        let parent = self.resolver.current_module;\n+        let (parent, legacy_scope) = (self.resolver.current_module, self.legacy_scope);\n         self.resolver.build_reduced_graph_for_block(block);\n         visit::walk_block(self, block);\n         self.resolver.current_module = parent;\n+        self.legacy_scope = legacy_scope;\n     }\n \n     fn visit_trait_item(&mut self, item: &TraitItem) {\n         let parent = self.resolver.current_module;\n         let def_id = parent.def_id().unwrap();\n \n         if let TraitItemKind::Macro(_) = item.node {\n-            return self.visit_invoc(item.id);\n+            self.visit_invoc(item.id);\n+            return\n         }\n \n         // Add the item to the trait info."}, {"sha": "6db844c1d0376ca2ceb3c853cf321e8bf3cc5218", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 38, "deletions": 12, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/20991829e2639d1786acbd52621b220c89f0d9cb/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20991829e2639d1786acbd52621b220c89f0d9cb/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=20991829e2639d1786acbd52621b220c89f0d9cb", "patch": "@@ -57,6 +57,7 @@ use syntax::ext::base::MultiItemModifier;\n use syntax::ext::hygiene::Mark;\n use syntax::ast::{self, FloatTy};\n use syntax::ast::{CRATE_NODE_ID, Name, NodeId, IntTy, UintTy};\n+use syntax::ext::base::SyntaxExtension;\n use syntax::parse::token::{self, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n@@ -77,6 +78,7 @@ use std::mem::replace;\n use std::rc::Rc;\n \n use resolve_imports::{ImportDirective, NameResolution};\n+use macros::{InvocationData, LegacyBinding, LegacyScope};\n \n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n@@ -791,9 +793,6 @@ pub struct ModuleS<'a> {\n     // access the children must be preceded with a\n     // `populate_module_if_necessary` call.\n     populated: Cell<bool>,\n-\n-    macros: RefCell<FnvHashMap<Name, macros::NameBinding>>,\n-    macros_escape: bool,\n }\n \n pub type Module<'a> = &'a ModuleS<'a>;\n@@ -811,8 +810,6 @@ impl<'a> ModuleS<'a> {\n             globs: RefCell::new((Vec::new())),\n             traits: RefCell::new(None),\n             populated: Cell::new(true),\n-            macros: RefCell::new(FnvHashMap()),\n-            macros_escape: false,\n         }\n     }\n \n@@ -1076,7 +1073,7 @@ pub struct Resolver<'a> {\n \n     privacy_errors: Vec<PrivacyError<'a>>,\n     ambiguity_errors: Vec<AmbiguityError<'a>>,\n-    macro_shadowing_errors: FnvHashSet<Span>,\n+    disallowed_shadowing: Vec<(Name, Span, LegacyScope<'a>)>,\n \n     arenas: &'a ResolverArenas<'a>,\n     dummy_binding: &'a NameBinding<'a>,\n@@ -1086,9 +1083,10 @@ pub struct Resolver<'a> {\n     pub derive_modes: FnvHashMap<Name, Rc<MultiItemModifier>>,\n     crate_loader: &'a mut CrateLoader,\n     macro_names: FnvHashSet<Name>,\n+    builtin_macros: FnvHashMap<Name, Rc<SyntaxExtension>>,\n \n     // Maps the `Mark` of an expansion to its containing module or block.\n-    expansion_data: FnvHashMap<Mark, macros::ExpansionData<'a>>,\n+    invocations: FnvHashMap<Mark, &'a InvocationData<'a>>,\n }\n \n pub struct ResolverArenas<'a> {\n@@ -1097,6 +1095,8 @@ pub struct ResolverArenas<'a> {\n     name_bindings: arena::TypedArena<NameBinding<'a>>,\n     import_directives: arena::TypedArena<ImportDirective<'a>>,\n     name_resolutions: arena::TypedArena<RefCell<NameResolution<'a>>>,\n+    invocation_data: arena::TypedArena<InvocationData<'a>>,\n+    legacy_bindings: arena::TypedArena<LegacyBinding<'a>>,\n }\n \n impl<'a> ResolverArenas<'a> {\n@@ -1120,6 +1120,13 @@ impl<'a> ResolverArenas<'a> {\n     fn alloc_name_resolution(&'a self) -> &'a RefCell<NameResolution<'a>> {\n         self.name_resolutions.alloc(Default::default())\n     }\n+    fn alloc_invocation_data(&'a self, expansion_data: InvocationData<'a>)\n+                             -> &'a InvocationData<'a> {\n+        self.invocation_data.alloc(expansion_data)\n+    }\n+    fn alloc_legacy_binding(&'a self, binding: LegacyBinding<'a>) -> &'a LegacyBinding<'a> {\n+        self.legacy_bindings.alloc(binding)\n+    }\n }\n \n impl<'a> ty::NodeIdTree for Resolver<'a> {\n@@ -1205,8 +1212,9 @@ impl<'a> Resolver<'a> {\n         let mut definitions = Definitions::new();\n         DefCollector::new(&mut definitions).collect_root();\n \n-        let mut expansion_data = FnvHashMap();\n-        expansion_data.insert(Mark::root(), macros::ExpansionData::root(graph_root));\n+        let mut invocations = FnvHashMap();\n+        invocations.insert(Mark::root(),\n+                           arenas.alloc_invocation_data(InvocationData::root(graph_root)));\n \n         Resolver {\n             session: session,\n@@ -1252,7 +1260,7 @@ impl<'a> Resolver<'a> {\n \n             privacy_errors: Vec::new(),\n             ambiguity_errors: Vec::new(),\n-            macro_shadowing_errors: FnvHashSet(),\n+            disallowed_shadowing: Vec::new(),\n \n             arenas: arenas,\n             dummy_binding: arenas.alloc_name_binding(NameBinding {\n@@ -1266,7 +1274,8 @@ impl<'a> Resolver<'a> {\n             derive_modes: FnvHashMap(),\n             crate_loader: crate_loader,\n             macro_names: FnvHashSet(),\n-            expansion_data: expansion_data,\n+            builtin_macros: FnvHashMap(),\n+            invocations: invocations,\n         }\n     }\n \n@@ -1277,6 +1286,8 @@ impl<'a> Resolver<'a> {\n             name_bindings: arena::TypedArena::new(),\n             import_directives: arena::TypedArena::new(),\n             name_resolutions: arena::TypedArena::new(),\n+            invocation_data: arena::TypedArena::new(),\n+            legacy_bindings: arena::TypedArena::new(),\n         }\n     }\n \n@@ -3338,7 +3349,8 @@ impl<'a> Resolver<'a> {\n         vis.is_accessible_from(module.normal_ancestor_id.unwrap(), self)\n     }\n \n-    fn report_errors(&self) {\n+    fn report_errors(&mut self) {\n+        self.report_shadowing_errors();\n         let mut reported_spans = FnvHashSet();\n \n         for &AmbiguityError { span, name, b1, b2 } in &self.ambiguity_errors {\n@@ -3366,6 +3378,20 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n+    fn report_shadowing_errors(&mut self) {\n+        let mut reported_errors = FnvHashSet();\n+        for (name, span, scope) in replace(&mut self.disallowed_shadowing, Vec::new()) {\n+            if self.resolve_macro_name(scope, name, false).is_some() &&\n+               reported_errors.insert((name, span)) {\n+                let msg = format!(\"`{}` is already in scope\", name);\n+                self.session.struct_span_err(span, &msg)\n+                    .note(\"macro-expanded `macro_rules!`s may not shadow \\\n+                           existing macros (see RFC 1560)\")\n+                    .emit();\n+            }\n+        }\n+    }\n+\n     fn report_conflict(&self,\n                        parent: Module,\n                        name: Name,"}, {"sha": "86ab077191eefd9429fcb24eb6a4e6d16e85eb58", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 129, "deletions": 82, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/20991829e2639d1786acbd52621b220c89f0d9cb/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20991829e2639d1786acbd52621b220c89f0d9cb/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=20991829e2639d1786acbd52621b220c89f0d9cb", "patch": "@@ -12,47 +12,76 @@ use {Module, Resolver};\n use build_reduced_graph::BuildReducedGraphVisitor;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefIndex};\n use rustc::hir::map::{self, DefCollector};\n+use rustc::util::nodemap::FnvHashMap;\n+use std::cell::Cell;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::errors::DiagnosticBuilder;\n-use syntax::ext::base::{self, MultiModifier, MultiDecorator, MultiItemModifier};\n+use syntax::ext::base::{self, Determinacy, MultiModifier, MultiDecorator, MultiItemModifier};\n use syntax::ext::base::{NormalTT, SyntaxExtension};\n use syntax::ext::expand::{Expansion, Invocation, InvocationKind};\n-use syntax::ext::hygiene::{Mark, SyntaxContext};\n+use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n use syntax::parse::token::intern;\n use syntax::util::lev_distance::find_best_match_for_name;\n-use syntax_pos::{Span, DUMMY_SP};\n-\n-// FIXME(jseyfried) Merge with `::NameBinding`.\n-pub struct NameBinding {\n-    pub ext: Rc<SyntaxExtension>,\n-    pub expansion: Mark,\n-    pub shadowing: bool,\n-    pub span: Span,\n-}\n+use syntax_pos::Span;\n \n #[derive(Clone)]\n-pub struct ExpansionData<'a> {\n-    backtrace: SyntaxContext,\n-    pub module: Module<'a>,\n+pub struct InvocationData<'a> {\n+    pub module: Cell<Module<'a>>,\n     def_index: DefIndex,\n     // True if this expansion is in a `const_integer` position, for example `[u32; m!()]`.\n     // c.f. `DefCollector::visit_ast_const_integer`.\n     const_integer: bool,\n+    // The scope in which the invocation path is resolved.\n+    pub legacy_scope: Cell<LegacyScope<'a>>,\n+    // The smallest scope that includes this invocation's expansion,\n+    // or `Empty` if this invocation has not been expanded yet.\n+    pub expansion: Cell<LegacyScope<'a>>,\n }\n \n-impl<'a> ExpansionData<'a> {\n+impl<'a> InvocationData<'a> {\n     pub fn root(graph_root: Module<'a>) -> Self {\n-        ExpansionData {\n-            backtrace: SyntaxContext::empty(),\n-            module: graph_root,\n+        InvocationData {\n+            module: Cell::new(graph_root),\n             def_index: CRATE_DEF_INDEX,\n             const_integer: false,\n+            legacy_scope: Cell::new(LegacyScope::Empty),\n+            expansion: Cell::new(LegacyScope::Empty),\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+pub enum LegacyScope<'a> {\n+    Empty,\n+    Invocation(&'a InvocationData<'a>), // The scope of the invocation, not including its expansion\n+    Expansion(&'a InvocationData<'a>), // The scope of the invocation, including its expansion\n+    Binding(&'a LegacyBinding<'a>),\n+}\n+\n+impl<'a> LegacyScope<'a> {\n+    fn simplify_expansion(mut invoc: &'a InvocationData<'a>) -> Self {\n+        while let LegacyScope::Invocation(_) = invoc.expansion.get() {\n+            match invoc.legacy_scope.get() {\n+                LegacyScope::Expansion(new_invoc) => invoc = new_invoc,\n+                LegacyScope::Binding(_) => break,\n+                scope @ _ => return scope,\n+            }\n         }\n+        LegacyScope::Expansion(invoc)\n     }\n }\n \n+pub struct LegacyBinding<'a> {\n+    parent: LegacyScope<'a>,\n+    name: ast::Name,\n+    ext: Rc<SyntaxExtension>,\n+    span: Span,\n+}\n+\n+pub type LegacyImports = FnvHashMap<ast::Name, (Rc<SyntaxExtension>, Span)>;\n+\n impl<'a> base::Resolver for Resolver<'a> {\n     fn next_node_id(&mut self) -> ast::NodeId {\n         self.session.next_node_id()\n@@ -61,37 +90,43 @@ impl<'a> base::Resolver for Resolver<'a> {\n     fn get_module_scope(&mut self, id: ast::NodeId) -> Mark {\n         let mark = Mark::fresh();\n         let module = self.module_map[&id];\n-        self.expansion_data.insert(mark, ExpansionData {\n-            backtrace: SyntaxContext::empty(),\n-            module: module,\n+        self.invocations.insert(mark, self.arenas.alloc_invocation_data(InvocationData {\n+            module: Cell::new(module),\n             def_index: module.def_id().unwrap().index,\n             const_integer: false,\n-        });\n+            legacy_scope: Cell::new(LegacyScope::Empty),\n+            expansion: Cell::new(LegacyScope::Empty),\n+        }));\n         mark\n     }\n \n     fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion) {\n-        self.collect_def_ids(mark, expansion);\n-        self.current_module = self.expansion_data[&mark].module;\n-        expansion.visit_with(&mut BuildReducedGraphVisitor { resolver: self, expansion: mark });\n+        let invocation = self.invocations[&mark];\n+        self.collect_def_ids(invocation, expansion);\n+\n+        self.current_module = invocation.module.get();\n+        let mut visitor = BuildReducedGraphVisitor {\n+            resolver: self,\n+            legacy_scope: LegacyScope::Invocation(invocation),\n+            expansion: mark,\n+        };\n+        expansion.visit_with(&mut visitor);\n+        invocation.expansion.set(visitor.legacy_scope);\n     }\n \n     fn add_macro(&mut self, scope: Mark, mut def: ast::MacroDef) {\n         if &def.ident.name.as_str() == \"macro_rules\" {\n             self.session.span_err(def.span, \"user-defined macros may not be named `macro_rules`\");\n         }\n         if def.use_locally {\n-            let ExpansionData { mut module, backtrace, .. } = self.expansion_data[&scope];\n-            while module.macros_escape {\n-                module = module.parent.unwrap();\n-            }\n-            let binding = NameBinding {\n+            let invocation = self.invocations[&scope];\n+            let binding = self.arenas.alloc_legacy_binding(LegacyBinding {\n+                parent: invocation.legacy_scope.get(),\n+                name: def.ident.name,\n                 ext: Rc::new(macro_rules::compile(&self.session.parse_sess, &def)),\n-                expansion: backtrace.data().prev_ctxt.data().outer_mark,\n-                shadowing: self.resolve_macro_name(scope, def.ident.name, false).is_some(),\n                 span: def.span,\n-            };\n-            module.macros.borrow_mut().insert(def.ident.name, binding);\n+            });\n+            invocation.legacy_scope.set(LegacyScope::Binding(binding));\n             self.macro_names.insert(def.ident.name);\n         }\n         if def.export {\n@@ -104,12 +139,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         if let NormalTT(..) = *ext {\n             self.macro_names.insert(ident.name);\n         }\n-        self.graph_root.macros.borrow_mut().insert(ident.name, NameBinding {\n-            ext: ext,\n-            expansion: Mark::root(),\n-            shadowing: false,\n-            span: DUMMY_SP,\n-        });\n+        self.builtin_macros.insert(ident.name, ext);\n     }\n \n     fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>) {\n@@ -119,8 +149,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n     fn find_attr_invoc(&mut self, attrs: &mut Vec<ast::Attribute>) -> Option<ast::Attribute> {\n         for i in 0..attrs.len() {\n             let name = intern(&attrs[i].name());\n-            match self.expansion_data[&Mark::root()].module.macros.borrow().get(&name) {\n-                Some(binding) => match *binding.ext {\n+            match self.builtin_macros.get(&name) {\n+                Some(ext) => match **ext {\n                     MultiModifier(..) | MultiDecorator(..) | SyntaxExtension::AttrProcMacro(..) => {\n                         return Some(attrs.remove(i))\n                     }\n@@ -132,27 +162,36 @@ impl<'a> base::Resolver for Resolver<'a> {\n         None\n     }\n \n-    fn resolve_invoc(&mut self, scope: Mark, invoc: &Invocation) -> Option<Rc<SyntaxExtension>> {\n+    fn resolve_invoc(&mut self, scope: Mark, invoc: &Invocation, force: bool)\n+                     -> Result<Rc<SyntaxExtension>, Determinacy> {\n         let (name, span) = match invoc.kind {\n             InvocationKind::Bang { ref mac, .. } => {\n                 let path = &mac.node.path;\n                 if path.segments.len() > 1 || path.global ||\n                    !path.segments[0].parameters.is_empty() {\n                     self.session.span_err(path.span,\n                                           \"expected macro name without module separators\");\n-                    return None;\n+                    return Err(Determinacy::Determined);\n                 }\n                 (path.segments[0].identifier.name, path.span)\n             }\n             InvocationKind::Attr { ref attr, .. } => (intern(&*attr.name()), attr.span),\n         };\n \n-        self.resolve_macro_name(scope, name, true).or_else(|| {\n-            let mut err =\n-                self.session.struct_span_err(span, &format!(\"macro undefined: '{}!'\", name));\n-            self.suggest_macro_name(&name.as_str(), &mut err);\n-            err.emit();\n-            None\n+        let invocation = self.invocations[&scope];\n+        if let LegacyScope::Expansion(parent) = invocation.legacy_scope.get() {\n+            invocation.legacy_scope.set(LegacyScope::simplify_expansion(parent));\n+        }\n+        self.resolve_macro_name(invocation.legacy_scope.get(), name, true).ok_or_else(|| {\n+            if force {\n+                let mut err =\n+                    self.session.struct_span_err(span, &format!(\"macro undefined: '{}!'\", name));\n+                self.suggest_macro_name(&name.as_str(), &mut err);\n+                err.emit();\n+                Determinacy::Determined\n+            } else {\n+                Determinacy::Undetermined\n+            }\n         })\n     }\n \n@@ -162,36 +201,40 @@ impl<'a> base::Resolver for Resolver<'a> {\n }\n \n impl<'a> Resolver<'a> {\n-    pub fn resolve_macro_name(&mut self, scope: Mark, name: ast::Name, record_used: bool)\n+    pub fn resolve_macro_name(&mut self,\n+                              mut scope: LegacyScope<'a>,\n+                              name: ast::Name,\n+                              record_used: bool)\n                               -> Option<Rc<SyntaxExtension>> {\n-        let ExpansionData { mut module, backtrace, .. } = self.expansion_data[&scope];\n+        let mut relative_depth: u32 = 0;\n         loop {\n-            if let Some(binding) = module.macros.borrow().get(&name) {\n-                let mut backtrace = backtrace.data();\n-                while binding.expansion != backtrace.outer_mark {\n-                    if backtrace.outer_mark != Mark::root() {\n-                        backtrace = backtrace.prev_ctxt.data();\n-                        continue\n+            scope = match scope {\n+                LegacyScope::Empty => break,\n+                LegacyScope::Expansion(invocation) => {\n+                    if let LegacyScope::Empty = invocation.expansion.get() {\n+                        invocation.legacy_scope.get()\n+                    } else {\n+                        relative_depth += 1;\n+                        invocation.expansion.get()\n                     }\n-\n-                    if record_used && binding.shadowing &&\n-                       self.macro_shadowing_errors.insert(binding.span) {\n-                        let msg = format!(\"`{}` is already in scope\", name);\n-                        self.session.struct_span_err(binding.span, &msg)\n-                            .note(\"macro-expanded `macro_rules!`s and `#[macro_use]`s \\\n-                                   may not shadow existing macros (see RFC 1560)\")\n-                            .emit();\n+                }\n+                LegacyScope::Invocation(invocation) => {\n+                    relative_depth = relative_depth.saturating_sub(1);\n+                    invocation.legacy_scope.get()\n+                }\n+                LegacyScope::Binding(binding) => {\n+                    if binding.name == name {\n+                        if record_used && relative_depth > 0 {\n+                            self.disallowed_shadowing.push((name, binding.span, binding.parent));\n+                        }\n+                        return Some(binding.ext.clone());\n                     }\n-                    break\n+                    binding.parent\n                 }\n-                return Some(binding.ext.clone());\n-            }\n-            match module.parent {\n-                Some(parent) => module = parent,\n-                None => break,\n-            }\n+            };\n         }\n-        None\n+\n+        self.builtin_macros.get(&name).cloned()\n     }\n \n     fn suggest_macro_name(&mut self, name: &str, err: &mut DiagnosticBuilder<'a>) {\n@@ -204,15 +247,19 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn collect_def_ids(&mut self, mark: Mark, expansion: &Expansion) {\n-        let expansion_data = &mut self.expansion_data;\n-        let ExpansionData { backtrace, def_index, const_integer, module } = expansion_data[&mark];\n+    fn collect_def_ids(&mut self, invocation: &'a InvocationData<'a>, expansion: &Expansion) {\n+        let Resolver { ref mut invocations, arenas, graph_root, .. } = *self;\n+        let InvocationData { def_index, const_integer, .. } = *invocation;\n+\n         let visit_macro_invoc = &mut |invoc: map::MacroInvocationData| {\n-            expansion_data.entry(invoc.mark).or_insert(ExpansionData {\n-                backtrace: backtrace.apply_mark(invoc.mark),\n-                def_index: invoc.def_index,\n-                const_integer: invoc.const_integer,\n-                module: module,\n+            invocations.entry(invoc.mark).or_insert_with(|| {\n+                arenas.alloc_invocation_data(InvocationData {\n+                    def_index: invoc.def_index,\n+                    const_integer: invoc.const_integer,\n+                    module: Cell::new(graph_root),\n+                    expansion: Cell::new(LegacyScope::Empty),\n+                    legacy_scope: Cell::new(LegacyScope::Empty),\n+                })\n             });\n         };\n "}, {"sha": "0939e6f1644de8fb496b8d565da955c0c5105459", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/20991829e2639d1786acbd52621b220c89f0d9cb/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20991829e2639d1786acbd52621b220c89f0d9cb/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=20991829e2639d1786acbd52621b220c89f0d9cb", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use self::Determinacy::*;\n use self::ImportDirectiveSubclass::*;\n \n use Module;\n@@ -26,6 +25,7 @@ use rustc::lint::builtin::PRIVATE_IN_PUBLIC;\n use rustc::hir::def::*;\n \n use syntax::ast::{NodeId, Name};\n+use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::Span;\n \n@@ -37,12 +37,6 @@ impl<'a> Resolver<'a> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug)]\n-pub enum Determinacy {\n-    Determined,\n-    Undetermined,\n-}\n-\n /// Contains data for specific types of import directives.\n #[derive(Clone, Debug)]\n pub enum ImportDirectiveSubclass<'a> {"}, {"sha": "f7c88073c9d405425e431db0f0110d156ffc6ca6", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 11, "deletions": 26, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/20991829e2639d1786acbd52621b220c89f0d9cb/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20991829e2639d1786acbd52621b220c89f0d9cb/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=20991829e2639d1786acbd52621b220c89f0d9cb", "patch": "@@ -22,7 +22,6 @@ use parse::{self, parser};\n use parse::token;\n use parse::token::{InternedString, str_to_ident};\n use ptr::P;\n-use std_inject;\n use util::small_vector::SmallVector;\n \n use std::path::PathBuf;\n@@ -523,10 +522,17 @@ pub trait Resolver {\n     fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>);\n \n     fn find_attr_invoc(&mut self, attrs: &mut Vec<Attribute>) -> Option<Attribute>;\n-    fn resolve_invoc(&mut self, scope: Mark, invoc: &Invocation) -> Option<Rc<SyntaxExtension>>;\n+    fn resolve_invoc(&mut self, scope: Mark, invoc: &Invocation, force: bool)\n+                     -> Result<Rc<SyntaxExtension>, Determinacy>;\n     fn resolve_derive_mode(&mut self, ident: ast::Ident) -> Option<Rc<MultiItemModifier>>;\n }\n \n+#[derive(Copy, Clone, Debug)]\n+pub enum Determinacy {\n+    Determined,\n+    Undetermined,\n+}\n+\n pub struct DummyResolver;\n \n impl Resolver for DummyResolver {\n@@ -540,8 +546,9 @@ impl Resolver for DummyResolver {\n \n     fn find_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>) -> Option<Attribute> { None }\n     fn resolve_derive_mode(&mut self, _ident: ast::Ident) -> Option<Rc<MultiItemModifier>> { None }\n-    fn resolve_invoc(&mut self, _scope: Mark, _invoc: &Invocation) -> Option<Rc<SyntaxExtension>> {\n-        None\n+    fn resolve_invoc(&mut self, _scope: Mark, _invoc: &Invocation, _force: bool)\n+                     -> Result<Rc<SyntaxExtension>, Determinacy> {\n+        Err(Determinacy::Determined)\n     }\n }\n \n@@ -737,28 +744,6 @@ impl<'a> ExtCtxt<'a> {\n     pub fn name_of(&self, st: &str) -> ast::Name {\n         token::intern(st)\n     }\n-\n-    pub fn initialize(&mut self, user_exts: Vec<NamedSyntaxExtension>, krate: &ast::Crate) {\n-        if std_inject::no_core(&krate) {\n-            self.crate_root = None;\n-        } else if std_inject::no_std(&krate) {\n-            self.crate_root = Some(\"core\");\n-        } else {\n-            self.crate_root = Some(\"std\");\n-        }\n-\n-        for (name, extension) in user_exts {\n-            let ident = ast::Ident::with_empty_ctxt(name);\n-            self.resolver.add_ext(ident, Rc::new(extension));\n-        }\n-\n-        let mut module = ModuleData {\n-            mod_path: vec![token::str_to_ident(&self.ecfg.crate_name)],\n-            directory: PathBuf::from(self.parse_sess.codemap().span_to_filename(krate.span)),\n-        };\n-        module.directory.pop();\n-        self.current_expansion.module = Rc::new(module);\n-    }\n }\n \n /// Extract a string literal from the macro expanded version of `expr`,"}, {"sha": "363ceebf0f4750e23b75ac0aa2d58c3d79b285c8", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 45, "deletions": 33, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/20991829e2639d1786acbd52621b220c89f0d9cb/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20991829e2639d1786acbd52621b220c89f0d9cb/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=20991829e2639d1786acbd52621b220c89f0d9cb", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{Block, Crate, Ident, Mac_, PatKind};\n+use ast::{Block, Ident, Mac_, PatKind};\n use ast::{Name, MacStmtStyle, StmtKind, ItemKind};\n use ast;\n use ext::hygiene::Mark;\n@@ -26,6 +26,7 @@ use parse::parser::Parser;\n use parse::token::{self, intern, keywords};\n use print::pprust;\n use ptr::P;\n+use std_inject;\n use tokenstream::{TokenTree, TokenStream};\n use util::small_vector::SmallVector;\n use visit::Visitor;\n@@ -186,8 +187,14 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         MacroExpander { cx: cx, monotonic: monotonic }\n     }\n \n-    fn expand_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n-        let err_count = self.cx.parse_sess.span_diagnostic.err_count();\n+    pub fn expand_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n+        self.cx.crate_root = std_inject::injected_crate_name(&krate);\n+        let mut module = ModuleData {\n+            mod_path: vec![token::str_to_ident(&self.cx.ecfg.crate_name)],\n+            directory: PathBuf::from(self.cx.codemap().span_to_filename(krate.span)),\n+        };\n+        module.directory.pop();\n+        self.cx.current_expansion.module = Rc::new(module);\n \n         let krate_item = Expansion::Items(SmallVector::one(P(ast::Item {\n             attrs: krate.attrs,\n@@ -206,10 +213,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             _ => unreachable!(),\n         };\n \n-        if self.cx.parse_sess.span_diagnostic.err_count() - self.cx.resolve_err_count > err_count {\n-            self.cx.parse_sess.span_diagnostic.abort_if_errors();\n-        }\n-\n         krate\n     }\n \n@@ -221,25 +224,47 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         let (expansion, mut invocations) = self.collect_invocations(expansion);\n         invocations.reverse();\n \n-        let mut expansions = vec![vec![(0, expansion)]];\n-        while let Some(invoc) = invocations.pop() {\n+        let mut expansions = Vec::new();\n+        let mut undetermined_invocations = Vec::new();\n+        let (mut progress, mut force) = (false, !self.monotonic);\n+        loop {\n+            let invoc = if let Some(invoc) = invocations.pop() {\n+                invoc\n+            } else if undetermined_invocations.is_empty() {\n+                break\n+            } else {\n+                invocations = mem::replace(&mut undetermined_invocations, Vec::new());\n+                force = !mem::replace(&mut progress, false);\n+                continue\n+            };\n+\n+            let scope =\n+                if self.monotonic { invoc.expansion_data.mark } else { orig_expansion_data.mark };\n+            let ext = match self.cx.resolver.resolve_invoc(scope, &invoc, force) {\n+                Ok(ext) => Some(ext),\n+                Err(Determinacy::Determined) => None,\n+                Err(Determinacy::Undetermined) => {\n+                    undetermined_invocations.push(invoc);\n+                    continue\n+                }\n+            };\n+\n+            progress = true;\n             let ExpansionData { depth, mark, .. } = invoc.expansion_data;\n             self.cx.current_expansion = invoc.expansion_data.clone();\n \n-            let scope = if self.monotonic { mark } else { orig_expansion_data.mark };\n             self.cx.current_expansion.mark = scope;\n-            let expansion = match self.cx.resolver.resolve_invoc(scope, &invoc) {\n+            let expansion = match ext {\n                 Some(ext) => self.expand_invoc(invoc, ext),\n                 None => invoc.expansion_kind.dummy(invoc.span()),\n             };\n \n-            self.cx.current_expansion.depth = depth + 1;\n             let (expansion, new_invocations) = self.collect_invocations(expansion);\n \n-            if expansions.len() == depth {\n+            if expansions.len() < depth {\n                 expansions.push(Vec::new());\n             }\n-            expansions[depth].push((mark.as_u32(), expansion));\n+            expansions[depth - 1].push((mark.as_u32(), expansion));\n             if !self.cx.ecfg.single_step {\n                 invocations.extend(new_invocations.into_iter().rev());\n             }\n@@ -250,12 +275,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         let mut placeholder_expander = PlaceholderExpander::new(self.cx, self.monotonic);\n         while let Some(expansions) = expansions.pop() {\n             for (mark, expansion) in expansions.into_iter().rev() {\n-                let expansion = expansion.fold_with(&mut placeholder_expander);\n                 placeholder_expander.add(ast::NodeId::from_u32(mark), expansion);\n             }\n         }\n \n-        placeholder_expander.remove(ast::NodeId::from_u32(0))\n+        expansion.fold_with(&mut placeholder_expander)\n     }\n \n     fn collect_invocations(&mut self, expansion: Expansion) -> (Expansion, Vec<Invocation>) {\n@@ -538,7 +562,11 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         self.invocations.push(Invocation {\n             kind: kind,\n             expansion_kind: expansion_kind,\n-            expansion_data: ExpansionData { mark: mark, ..self.cx.current_expansion.clone() },\n+            expansion_data: ExpansionData {\n+                mark: mark,\n+                depth: self.cx.current_expansion.depth + 1,\n+                ..self.cx.current_expansion.clone()\n+            },\n         });\n         placeholder(expansion_kind, ast::NodeId::from_u32(mark.as_u32()))\n     }\n@@ -866,22 +894,6 @@ impl<'feat> ExpansionConfig<'feat> {\n     }\n }\n \n-pub fn expand_crate(cx: &mut ExtCtxt,\n-                    user_exts: Vec<NamedSyntaxExtension>,\n-                    c: Crate) -> Crate {\n-    cx.initialize(user_exts, &c);\n-    cx.monotonic_expander().expand_crate(c)\n-}\n-\n-// Expands crate using supplied MacroExpander - allows for\n-// non-standard expansion behaviour (e.g. step-wise).\n-pub fn expand_crate_with_expander(expander: &mut MacroExpander,\n-                                  user_exts: Vec<NamedSyntaxExtension>,\n-                                  c: Crate) -> Crate {\n-    expander.cx.initialize(user_exts, &c);\n-    expander.expand_crate(c)\n-}\n-\n // A Marker adds the given mark to the syntax context and\n // sets spans' `expn_id` to the given expn_id (unless it is `None`).\n struct Marker { mark: Mark, expn_id: Option<ExpnId> }"}, {"sha": "e323dd2f623276c16de3cfd6682194867f5c1ec1", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20991829e2639d1786acbd52621b220c89f0d9cb/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20991829e2639d1786acbd52621b220c89f0d9cb/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=20991829e2639d1786acbd52621b220c89f0d9cb", "patch": "@@ -88,10 +88,11 @@ impl<'a, 'b> PlaceholderExpander<'a, 'b> {\n     }\n \n     pub fn add(&mut self, id: ast::NodeId, expansion: Expansion) {\n+        let expansion = expansion.fold_with(self);\n         self.expansions.insert(id, expansion);\n     }\n \n-    pub fn remove(&mut self, id: ast::NodeId) -> Expansion {\n+    fn remove(&mut self, id: ast::NodeId) -> Expansion {\n         self.expansions.remove(&id).unwrap()\n     }\n }"}, {"sha": "ecb437f31a5ad03d6462ed034d20a3a86a49fa28", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20991829e2639d1786acbd52621b220c89f0d9cb/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20991829e2639d1786acbd52621b220c89f0d9cb/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=20991829e2639d1786acbd52621b220c89f0d9cb", "patch": "@@ -112,7 +112,7 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n                                       out,\n                                       ann,\n                                       is_expanded);\n-    if is_expanded && !std_inject::no_std(krate) {\n+    if is_expanded && !std_inject::injected_crate_name(krate).is_none() {\n         // We need to print `#![no_std]` (and its feature gate) so that\n         // compiling pretty-printed source won't inject libstd again.\n         // However we don't want these attributes in the AST because"}, {"sha": "1b63a2b70763aff5da297077c8134a958490c0d9", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/20991829e2639d1786acbd52621b220c89f0d9cb/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20991829e2639d1786acbd52621b220c89f0d9cb/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=20991829e2639d1786acbd52621b220c89f0d9cb", "patch": "@@ -34,23 +34,25 @@ fn ignored_span(sess: &ParseSess, sp: Span) -> Span {\n     return sp;\n }\n \n-pub fn no_core(krate: &ast::Crate) -> bool {\n-    attr::contains_name(&krate.attrs, \"no_core\")\n-}\n-\n-pub fn no_std(krate: &ast::Crate) -> bool {\n-    attr::contains_name(&krate.attrs, \"no_std\") || no_core(krate)\n+pub fn injected_crate_name(krate: &ast::Crate) -> Option<&'static str> {\n+    if attr::contains_name(&krate.attrs, \"no_core\") {\n+        None\n+    } else if attr::contains_name(&krate.attrs, \"no_std\") {\n+        Some(\"core\")\n+    } else {\n+        Some(\"std\")\n+    }\n }\n \n pub fn maybe_inject_crates_ref(sess: &ParseSess,\n                                mut krate: ast::Crate,\n                                alt_std_name: Option<String>)\n                                -> ast::Crate {\n-    if no_core(&krate) {\n-        return krate;\n-    }\n+    let name = match injected_crate_name(&krate) {\n+        Some(name) => name,\n+        None => return krate,\n+    };\n \n-    let name = if no_std(&krate) { \"core\" } else { \"std\" };\n     let crate_name = token::intern(&alt_std_name.unwrap_or(name.to_string()));\n \n     krate.module.items.insert(0, P(ast::Item {"}, {"sha": "f336b26ae41f2f3b63dc4cbcc99cc13ab2af94e0", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/20991829e2639d1786acbd52621b220c89f0d9cb/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20991829e2639d1786acbd52621b220c89f0d9cb/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=20991829e2639d1786acbd52621b220c89f0d9cb", "patch": "@@ -50,20 +50,23 @@ pub mod deriving;\n \n use std::rc::Rc;\n use syntax::ast;\n-use syntax::ext::base::{MacroExpanderFn, NormalTT, IdentTT, MultiModifier};\n+use syntax::ext::base::{MacroExpanderFn, NormalTT, IdentTT, MultiModifier, NamedSyntaxExtension};\n use syntax::ext::tt::macro_rules::MacroRulesExpander;\n use syntax::parse::token::intern;\n \n-pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver, enable_quotes: bool) {\n+pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver,\n+                         user_exts: Vec<NamedSyntaxExtension>,\n+                         enable_quotes: bool) {\n     let mut register = |name, ext| {\n-        resolver.add_ext(ast::Ident::with_empty_ctxt(intern(name)), Rc::new(ext));\n+        resolver.add_ext(ast::Ident::with_empty_ctxt(name), Rc::new(ext));\n     };\n \n-    register(\"macro_rules\", IdentTT(Box::new(MacroRulesExpander), None, false));\n+    register(intern(\"macro_rules\"), IdentTT(Box::new(MacroRulesExpander), None, false));\n \n     macro_rules! register {\n         ($( $name:ident: $f:expr, )*) => { $(\n-            register(stringify!($name), NormalTT(Box::new($f as MacroExpanderFn), None, false));\n+            register(intern(stringify!($name)),\n+                     NormalTT(Box::new($f as MacroExpanderFn), None, false));\n         )* }\n     }\n \n@@ -108,7 +111,11 @@ pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver, enable_quot\n     }\n \n     // format_args uses `unstable` things internally.\n-    register(\"format_args\", NormalTT(Box::new(format::expand_format_args), None, true));\n+    register(intern(\"format_args\"), NormalTT(Box::new(format::expand_format_args), None, true));\n \n-    register(\"derive\", MultiModifier(Box::new(deriving::expand_derive)));\n+    register(intern(\"derive\"), MultiModifier(Box::new(deriving::expand_derive)));\n+\n+    for (name, ext) in user_exts {\n+        register(name, ext);\n+    }\n }"}, {"sha": "8381dc34a6a15f695630b44de9be358fdbdfc825", "filename": "src/test/compile-fail/macro-shadowing.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/20991829e2639d1786acbd52621b220c89f0d9cb/src%2Ftest%2Fcompile-fail%2Fmacro-shadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20991829e2639d1786acbd52621b220c89f0d9cb/src%2Ftest%2Fcompile-fail%2Fmacro-shadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-shadowing.rs?ref=20991829e2639d1786acbd52621b220c89f0d9cb", "patch": "@@ -12,31 +12,28 @@\n \n macro_rules! foo { () => {} }\n macro_rules! macro_one { () => {} }\n+#[macro_use(macro_two)] extern crate two_macros;\n \n macro_rules! m1 { () => {\n     macro_rules! foo { () => {} } //~ ERROR `foo` is already in scope\n-    //~^ NOTE macro-expanded `macro_rules!`s and `#[macro_use]`s may not shadow existing macros\n+    //~^ NOTE macro-expanded `macro_rules!`s may not shadow existing macros\n \n-    #[macro_use] //~ ERROR `macro_one` is already in scope\n-    //~^ NOTE macro-expanded `macro_rules!`s and `#[macro_use]`s may not shadow existing macros\n-    extern crate two_macros;\n+    #[macro_use] //~ ERROR `macro_two` is already in scope\n+    //~^ NOTE macro-expanded `#[macro_use]`s may not shadow existing macros\n+    extern crate two_macros as __;\n }}\n m1!(); //~ NOTE in this expansion\n        //~| NOTE in this expansion\n        //~| NOTE in this expansion\n        //~| NOTE in this expansion\n \n-fn f() { macro_one!(); }\n foo!();\n \n macro_rules! m2 { () => {\n     macro_rules! foo { () => {} }\n-    #[macro_use] extern crate two_macros as __;\n-\n-    fn g() { macro_one!(); }\n     foo!();\n }}\n m2!();\n-//^ Since `foo` and `macro_one` are not used outside this expansion, they are not shadowing errors.\n+//^ Since `foo` is not used outside this expansion, it is not a shadowing error.\n \n fn main() {}"}, {"sha": "9d389413ba9adb0319e964d7cd3fae7bfd883aa6", "filename": "src/test/compile-fail/macro-use-scope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/20991829e2639d1786acbd52621b220c89f0d9cb/src%2Ftest%2Fcompile-fail%2Fmacro-use-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20991829e2639d1786acbd52621b220c89f0d9cb/src%2Ftest%2Fcompile-fail%2Fmacro-use-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-use-scope.rs?ref=20991829e2639d1786acbd52621b220c89f0d9cb", "patch": "@@ -19,10 +19,10 @@ fn f() {\n #[macro_use(macro_one)] // Check that this macro is usable in the above function\n extern crate two_macros;\n \n+fn g() {\n+    macro_two!();\n+}\n macro_rules! m { () => {\n-    fn g() {\n-        macro_two!();\n-    }\n     #[macro_use(macro_two)] // Check that this macro is usable in the above function\n     extern crate two_macros as _two_macros;\n } }"}]}