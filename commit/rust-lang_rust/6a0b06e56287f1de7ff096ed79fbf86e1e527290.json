{"sha": "6a0b06e56287f1de7ff096ed79fbf86e1e527290", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhMGIwNmU1NjI4N2YxZGU3ZmYwOTZlZDc5ZmJmODZlMWU1MjcyOTA=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-07-01T05:45:54Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-07-01T05:45:54Z"}, "message": "Rename 'exterior' to 'box' and 'interior' to 'local' (at least wrt. slots; keep MEM_interior for describing interior-parts-of-allocations)", "tree": {"sha": "5596e1e36c3f59dc7f25c84730705aaf28128a0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5596e1e36c3f59dc7f25c84730705aaf28128a0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a0b06e56287f1de7ff096ed79fbf86e1e527290", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a0b06e56287f1de7ff096ed79fbf86e1e527290", "html_url": "https://github.com/rust-lang/rust/commit/6a0b06e56287f1de7ff096ed79fbf86e1e527290", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a0b06e56287f1de7ff096ed79fbf86e1e527290/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b8186db8711c306873837c125067b6631c710b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b8186db8711c306873837c125067b6631c710b9", "html_url": "https://github.com/rust-lang/rust/commit/8b8186db8711c306873837c125067b6631c710b9"}], "stats": {"total": 398, "additions": 198, "deletions": 200}, "files": [{"sha": "44f9761be30c108a41ce25cf1c2b4b61026b4ef0", "filename": "src/boot/be/abi.ml", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Fboot%2Fbe%2Fabi.ml", "raw_url": "https://github.com/rust-lang/rust/raw/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Fboot%2Fbe%2Fabi.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fabi.ml?ref=6a0b06e56287f1de7ff096ed79fbf86e1e527290", "patch": "@@ -26,20 +26,20 @@ let frame_glue_fns_field_mark = 0;;\n let frame_glue_fns_field_drop = 1;;\n let frame_glue_fns_field_reloc = 2;;\n \n-let exterior_rc_slot_field_refcnt = 0;;\n-let exterior_rc_slot_field_body = 1;;\n+let box_rc_slot_field_refcnt = 0;;\n+let box_rc_slot_field_body = 1;;\n \n-let exterior_gc_slot_alloc_base = (-3);;\n-let exterior_gc_slot_field_prev = (-3);;\n-let exterior_gc_slot_field_next = (-2);;\n-let exterior_gc_slot_field_ctrl = (-1);;\n-let exterior_gc_slot_field_refcnt = 0;;\n-let exterior_gc_slot_field_body = 1;;\n+let box_gc_slot_alloc_base = (-3);;\n+let box_gc_slot_field_prev = (-3);;\n+let box_gc_slot_field_next = (-2);;\n+let box_gc_slot_field_ctrl = (-1);;\n+let box_gc_slot_field_refcnt = 0;;\n+let box_gc_slot_field_body = 1;;\n \n-let exterior_rc_header_size = 1;;\n-let exterior_gc_header_size = 4;;\n+let box_rc_header_size = 1;;\n+let box_gc_header_size = 4;;\n \n-let exterior_gc_malloc_return_adjustment = 3;;\n+let box_gc_malloc_return_adjustment = 3;;\n \n let stk_field_valgrind_id = 0 + 1;;\n let stk_field_limit = stk_field_valgrind_id + 1;;"}, {"sha": "d18cf11fc383528b54bb8a323b19f58990620d67", "filename": "src/boot/be/x86.ml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Fboot%2Fbe%2Fx86.ml", "raw_url": "https://github.com/rust-lang/rust/raw/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Fboot%2Fbe%2Fx86.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fx86.ml?ref=6a0b06e56287f1de7ff096ed79fbf86e1e527290", "patch": "@@ -829,7 +829,7 @@ let sweep_gc_chain\n     emit (Il.jmp Il.JE\n             (codefix exit_jmp_fix));            (* if nonzero             *)\n     mov (rc ecx)                                (* Load GC ctrl word      *)\n-      (c (edi_n Abi.exterior_gc_slot_field_ctrl));\n+      (c (edi_n Abi.box_gc_slot_field_ctrl));\n     mov (rc eax) (ro ecx);\n     band (rc eax) (immi 1L);                    (* Extract mark to eax.   *)\n     band                                        (* Clear mark in ecx.     *)\n@@ -839,7 +839,7 @@ let sweep_gc_chain\n     if clear_mark\n     then\n       mov                                       (* Write-back cleared.    *)\n-        ((edi_n Abi.exterior_gc_slot_field_ctrl))\n+        ((edi_n Abi.box_gc_slot_field_ctrl))\n         (ro ecx);\n \n     emit (Il.cmp (ro eax) (immi 0L));\n@@ -870,7 +870,7 @@ let sweep_gc_chain\n \n     mark skip_jmp_fix;\n     mov (rc edi)                                (* Advance down chain     *)\n-      (c (edi_n Abi.exterior_gc_slot_field_next));\n+      (c (edi_n Abi.box_gc_slot_field_next));\n     emit (Il.jmp Il.JMP\n             (codefix repeat_jmp_fix));          (* loop                   *)\n     mark exit_jmp_fix;\n@@ -901,7 +901,7 @@ let gc_glue\n     (* The sweep pass has two sub-passes over the GC chain:\n      *\n      *    - In pass #1, 'severing', we goes through and disposes of all\n-     *      mutable exterior slots in each record. That is, rc-- the referent,\n+     *      mutable box slots in each record. That is, rc-- the referent,\n      *      and then null-out.  If the rc-- gets to zero, that just means the\n      *      mutable is part of the garbage set currently being collected. But\n      *      a mutable may be live-and-outside; this detaches the garbage set"}, {"sha": "e3360f31d24248346c486f6166b7f6d048239739", "filename": "src/boot/fe/ast.ml", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Fboot%2Ffe%2Fast.ml", "raw_url": "https://github.com/rust-lang/rust/raw/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Fboot%2Ffe%2Fast.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fast.ml?ref=6a0b06e56287f1de7ff096ed79fbf86e1e527290", "patch": "@@ -88,7 +88,7 @@ and ty =\n   | TY_named of name\n   | TY_type\n \n-  | TY_exterior of ty\n+  | TY_box of ty\n   | TY_mutable of ty\n \n   | TY_constrained of (ty * constrs)\n@@ -100,7 +100,7 @@ and ty =\n  *)\n \n and mode =\n-  | MODE_interior\n+  | MODE_local\n   | MODE_alias\n \n and slot = { slot_mode: mode;\n@@ -201,7 +201,7 @@ and stmt' =\n   | STMT_init_str of (lval * string)\n   | STMT_init_port of lval\n   | STMT_init_chan of (lval * (lval option))\n-  | STMT_init_exterior of (lval * atom)\n+  | STMT_init_box of (lval * atom)\n   | STMT_copy of (lval * expr)\n   | STMT_copy_binop of (lval * binop * atom)\n   | STMT_call of (lval * lval * (atom array))\n@@ -523,7 +523,7 @@ and fmt_name (ff:Format.formatter) (n:name) : unit =\n and fmt_mode (ff:Format.formatter) (m:mode) : unit =\n   match m with\n     | MODE_alias -> fmt ff \"&\"\n-    | MODE_interior -> ()\n+    | MODE_local -> ()\n \n and fmt_slot (ff:Format.formatter) (s:slot) : unit =\n   match s.slot_ty with\n@@ -656,7 +656,7 @@ and fmt_ty (ff:Format.formatter) (t:ty) : unit =\n   | TY_named n -> fmt_name ff n\n   | TY_type -> fmt ff \"type\"\n \n-  | TY_exterior t ->\n+  | TY_box t ->\n       fmt ff \"@@\";\n       fmt_ty ff t\n \n@@ -1167,7 +1167,7 @@ and fmt_stmt_body (ff:Format.formatter) (s:stmt) : unit =\n           fmt_lval ff t;\n           fmt ff \";\"\n \n-      | STMT_init_exterior (lv, at) ->\n+      | STMT_init_box (lv, at) ->\n           fmt_lval ff lv;\n           fmt ff \" = @@\";\n           fmt_atom ff at;"}, {"sha": "658fb8c4ddea27669ad73dc255a266501495a054", "filename": "src/boot/fe/item.ml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Fboot%2Ffe%2Fitem.ml", "raw_url": "https://github.com/rust-lang/rust/raw/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Fboot%2Ffe%2Fitem.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fitem.ml?ref=6a0b06e56287f1de7ff096ed79fbf86e1e527290", "patch": "@@ -242,7 +242,7 @@ and parse_stmts (ps:pstate) : Ast.stmt array =\n                               match name with\n                                   Ast.NAME_base (Ast.BASE_ident ident) ->\n                                     let slot =\n-                                      { Ast.slot_mode = Ast.MODE_interior;\n+                                      { Ast.slot_mode = Ast.MODE_local;\n                                         Ast.slot_ty = None }\n                                     in\n                                       Ast.PAT_slot"}, {"sha": "ab7ff56c08dc76816d8d6590c1cb292f9ffd398b", "filename": "src/boot/fe/parser.ml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Fboot%2Ffe%2Fparser.ml", "raw_url": "https://github.com/rust-lang/rust/raw/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Fboot%2Ffe%2Fparser.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fparser.ml?ref=6a0b06e56287f1de7ff096ed79fbf86e1e527290", "patch": "@@ -180,12 +180,12 @@ let err (str:string) (ps:pstate) =\n \n \n let (slot_nil:Ast.slot) =\n-  { Ast.slot_mode = Ast.MODE_interior;\n+  { Ast.slot_mode = Ast.MODE_local;\n     Ast.slot_ty = Some Ast.TY_nil }\n ;;\n \n let (slot_auto:Ast.slot) =\n-  { Ast.slot_mode = Ast.MODE_interior;\n+  { Ast.slot_mode = Ast.MODE_local;\n     Ast.slot_ty = None }\n ;;\n "}, {"sha": "1869a7d3a2b01378953f6076959a42f34afc1513", "filename": "src/boot/fe/pexp.ml", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Fboot%2Ffe%2Fpexp.ml", "raw_url": "https://github.com/rust-lang/rust/raw/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Fboot%2Ffe%2Fpexp.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fpexp.ml?ref=6a0b06e56287f1de7ff096ed79fbf86e1e527290", "patch": "@@ -33,7 +33,7 @@ type pexp' =\n   | PEXP_lit of Ast.lit\n   | PEXP_str of string\n   | PEXP_mutable of pexp\n-  | PEXP_exterior of pexp\n+  | PEXP_box of pexp\n   | PEXP_custom of Ast.name * (pexp array) * (string option)\n \n and plval =\n@@ -334,7 +334,7 @@ and parse_atomic_ty (ps:pstate) : Ast.ty =\n \n     | AT ->\n         bump ps;\n-        Ast.TY_exterior (parse_ty ps)\n+        Ast.TY_box (parse_ty ps)\n \n     | MUTABLE ->\n         bump ps;\n@@ -368,7 +368,7 @@ and parse_slot (aliases_ok:bool) (ps:pstate) : Ast.slot =\n   match (peek ps, aliases_ok) with\n       (AND, true) -> bump ps; Ast.MODE_alias\n     | (AND, false) -> raise (err \"alias slot in prohibited context\" ps)\n-    | _ -> Ast.MODE_interior\n+    | _ -> Ast.MODE_local\n   in\n   let ty = parse_ty ps in\n     { Ast.slot_mode = mode;\n@@ -485,7 +485,7 @@ and parse_bottom_pexp (ps:pstate) : pexp =\n         bump ps;\n         let inner = parse_pexp ps in\n         let bpos = lexpos ps in\n-          span ps apos bpos (PEXP_exterior inner)\n+          span ps apos bpos (PEXP_box inner)\n \n     | TUP ->\n         bump ps;\n@@ -1102,7 +1102,7 @@ and desugar_expr_atom\n       | PEXP_bind _\n       | PEXP_spawn _\n       | PEXP_custom _\n-      | PEXP_exterior _\n+      | PEXP_box _\n       | PEXP_mutable _ ->\n           let (_, tmp, decl_stmt) = build_tmp ps slot_auto apos bpos in\n           let stmts = desugar_expr_init ps tmp pexp in\n@@ -1299,11 +1299,11 @@ and desugar_expr_init\n           in\n             aa port_stmts [| chan_stmt |]\n \n-      | PEXP_exterior arg ->\n+      | PEXP_box arg ->\n           let (arg_stmts, arg_mode_atom) =\n             desugar_expr_atom ps arg\n           in\n-          let stmt = ss (Ast.STMT_init_exterior (dst_lval, arg_mode_atom)) in\n+          let stmt = ss (Ast.STMT_init_box (dst_lval, arg_mode_atom)) in\n             aa arg_stmts [| stmt |]\n \n       | PEXP_mutable arg ->"}, {"sha": "c699ae216be7a6d5fdb08144ec0962db21efcb06", "filename": "src/boot/llvm/lltrans.ml", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Fboot%2Fllvm%2Flltrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Fboot%2Fllvm%2Flltrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fllvm%2Flltrans.ml?ref=6a0b06e56287f1de7ff096ed79fbf86e1e527290", "patch": "@@ -263,7 +263,7 @@ let trans_crate\n       | Ast.TY_chan _ | Ast.TY_port _ | Ast.TY_task  ->\n           p rc_opaque_ty\n \n-      | Ast.TY_exterior t ->\n+      | Ast.TY_box t ->\n           (* FIXME: wrong, this needs to point to a refcounted cell. *)\n           p (trans_ty t)\n \n@@ -296,7 +296,7 @@ let trans_crate\n       match slot.Ast.slot_mode with\n         | Ast.MODE_alias _ ->\n             Llvm.pointer_type base_llty\n-        | Ast.MODE_interior _ -> base_llty\n+        | Ast.MODE_local _ -> base_llty\n   in\n \n   let get_element_ptr\n@@ -453,19 +453,19 @@ let trans_crate\n                 llbuilder :=\n                   if_ptr_in_slot_not_null\n                     (decr_refcnt_and_if_zero\n-                       Abi.exterior_rc_slot_field_refcnt\n+                       Abi.box_rc_slot_field_refcnt\n                        free_and_null_out_slot)\n                     (!llbuilder)\n \n             | MEM_rc_opaque ->\n                 llbuilder :=\n                   if_ptr_in_slot_not_null\n                     (decr_refcnt_and_if_zero\n-                       Abi.exterior_rc_slot_field_refcnt\n+                       Abi.box_rc_slot_field_refcnt\n                        free_and_null_out_slot)\n                     (!llbuilder)\n \n-            | MEM_interior when Semant.type_is_structured ty ->\n+            | MEM_local when Semant.type_is_structured ty ->\n                 (* FIXME: to handle recursive types, need to call drop\n                    glue here, not inline. *)\n                 drop_ty llbuilder lltask slot_ptr ty curr_iso\n@@ -562,7 +562,7 @@ let trans_crate\n     Array.iteri build_arg (Llvm.params llfn);\n \n     (* Allocate space for all the blocks' slots.\n-     * and zero the exteriors. *)\n+     * and zero the box pointers. *)\n     let init_block (block_id:node_id) : unit =\n       let init_slot\n           (key:Ast.slot_key)"}, {"sha": "f49f450adcb05b7aeb9b1b1be79b7ebeb7ace25c", "filename": "src/boot/me/dwarf.ml", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Fboot%2Fme%2Fdwarf.ml", "raw_url": "https://github.com/rust-lang/rust/raw/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Fboot%2Fme%2Fdwarf.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fdwarf.ml?ref=6a0b06e56287f1de7ff096ed79fbf86e1e527290", "patch": "@@ -1323,7 +1323,7 @@ let (abbrev_mutable_type:abbrev) =\n    |])\n ;;\n \n-let (abbrev_exterior_type:abbrev) =\n+let (abbrev_box_type:abbrev) =\n   (DW_TAG_pointer_type, DW_CHILDREN_no,\n    [|\n      (DW_AT_type, DW_FORM_ref_addr);\n@@ -1551,7 +1551,7 @@ let dwarf_visitor\n       in\n \n         match slot.Ast.slot_mode with\n-          | Ast.MODE_interior ->\n+          | Ast.MODE_local ->\n               ref_type_die (slot_ty slot)\n \n           | Ast.MODE_alias ->\n@@ -2013,20 +2013,19 @@ let dwarf_visitor\n         ref_addr_for_fix (Stack.top iso_stack).(i)\n       in\n \n-      let exterior_type t =\n-        let fix = new_fixup \"exterior DIE\" in\n+      let box_type t =\n+        let fix = new_fixup \"box DIE\" in\n         let body_off =\n-          word_sz_int * Abi.exterior_rc_slot_field_body\n+          word_sz_int * Abi.box_rc_slot_field_body\n         in\n           emit_die (DEF (fix, SEQ [|\n-                           uleb (get_abbrev_code abbrev_exterior_type);\n+                           uleb (get_abbrev_code abbrev_box_type);\n                            (* DW_AT_type: DW_FORM_ref_addr *)\n                            (ref_type_die t);\n                            (* DW_AT_data_location: DW_FORM_block1 *)\n-                           (* This is a DWARF expression for moving\n-                              from the address of an exterior\n-                              allocation to the address of its\n-                              body. *)\n+                           (* This is a DWARF expression for moving from the\n+                              address of a box allocation to the address of\n+                              its body. *)\n                            dw_form_block1\n                              [| DW_OP_push_object_address;\n                                 DW_OP_lit body_off;\n@@ -2078,7 +2077,7 @@ let dwarf_visitor\n           | Ast.TY_param p -> rust_type_param p\n           | Ast.TY_obj ob -> obj_type ob\n           | Ast.TY_mutable t -> mutable_type t\n-          | Ast.TY_exterior t -> exterior_type t\n+          | Ast.TY_box t -> box_type t\n           | _ ->\n               bug () \"unimplemented dwarf encoding for type %a\"\n                 Ast.sprintf_ty ty\n@@ -2916,7 +2915,7 @@ let rec extract_mod_items\n             Ast.TY_native (get_opaque_of (get_native_id die))\n \n         | DW_TAG_pointer_type ->\n-            Ast.TY_exterior (get_referenced_ty die)\n+            Ast.TY_box (get_referenced_ty die)\n \n         | DW_TAG_const_type\n             when ((get_num die DW_AT_mutable) = 1) ->\n@@ -3012,7 +3011,7 @@ let rec extract_mod_items\n               Ast.slot_ty = Some ty }\n       | _ ->\n           let ty = get_ty die in\n-            { Ast.slot_mode = Ast.MODE_interior;\n+            { Ast.slot_mode = Ast.MODE_local;\n               Ast.slot_ty = Some ty }\n \n   and get_referenced_ty die ="}, {"sha": "208dc47087e887a4fbbfa60b6bf67e29fb46317e", "filename": "src/boot/me/layout.ml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Fboot%2Fme%2Flayout.ml", "raw_url": "https://github.com/rust-lang/rust/raw/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Fboot%2Fme%2Flayout.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Flayout.ml?ref=6a0b06e56287f1de7ff096ed79fbf86e1e527290", "patch": "@@ -221,7 +221,7 @@ let layout_visitor\n     let offset =\n       let word_sz = cx.ctxt_abi.Abi.abi_word_sz in\n       let word_n (n:int) = Int64.mul word_sz (Int64.of_int n) in\n-        SIZE_fixed (word_n (Abi.exterior_rc_slot_field_body\n+        SIZE_fixed (word_n (Abi.box_rc_slot_field_body\n                             + 1 (* the state tydesc. *)))\n     in\n       log cx \"laying out object-state for node #%d at offset %s\"\n@@ -262,7 +262,7 @@ let layout_visitor\n    *)\n \n   let glue_callsz =\n-    let word = interior_slot Ast.TY_int in\n+    let word = local_slot Ast.TY_int in\n     let glue_fn =\n       mk_simple_ty_fn\n         (Array.init Abi.worst_case_glue_call_args (fun _ -> word))"}, {"sha": "72558ae69c7cf510d128b6dff87bae4b2f70808e", "filename": "src/boot/me/resolve.ml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Fboot%2Fme%2Fresolve.ml", "raw_url": "https://github.com/rust-lang/rust/raw/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Fboot%2Fme%2Fresolve.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fresolve.ml?ref=6a0b06e56287f1de7ff096ed79fbf86e1e527290", "patch": "@@ -570,7 +570,7 @@ let type_resolving_visitor\n                           header_slots\n                       in\n                       let output_slot =\n-                        interior_slot (ty_iso_of cx recursive_tag_groups\n+                        local_slot (ty_iso_of cx recursive_tag_groups\n                                          all_tags nid)\n                       in\n                       let ty ="}, {"sha": "e70fd55f4dfc9713bb6957e7b54c53f998d32195", "filename": "src/boot/me/semant.ml", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Fboot%2Fme%2Fsemant.ml", "raw_url": "https://github.com/rust-lang/rust/raw/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Fboot%2Fme%2Fsemant.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fsemant.ml?ref=6a0b06e56287f1de7ff096ed79fbf86e1e527290", "patch": "@@ -21,10 +21,10 @@ type glue =\n   | GLUE_exit_main_task\n   | GLUE_exit_task\n   | GLUE_copy of Ast.ty           (* One-level copy.                    *)\n-  | GLUE_drop of Ast.ty           (* De-initialize interior memory.     *)\n-  | GLUE_free of Ast.ty           (* Drop body + free() exterior ptr.   *)\n-  | GLUE_sever of Ast.ty          (* Null all exterior state slots.     *)\n-  | GLUE_mark of Ast.ty           (* Mark all exterior state slots.     *)\n+  | GLUE_drop of Ast.ty           (* De-initialize local memory.        *)\n+  | GLUE_free of Ast.ty           (* Drop body + free() box ptr.        *)\n+  | GLUE_sever of Ast.ty          (* Null all box state slots.          *)\n+  | GLUE_mark of Ast.ty           (* Mark all box state slots.          *)\n   | GLUE_clone of Ast.ty          (* Deep copy.                         *)\n   | GLUE_compare of Ast.ty\n   | GLUE_hash of Ast.ty\n@@ -604,43 +604,43 @@ let expr_slots (cx:ctxt) (e:Ast.expr) : node_id array =\n \n (* Type extraction. *)\n \n-let interior_slot_full mut ty : Ast.slot =\n+let local_slot_full mut ty : Ast.slot =\n   let ty =\n     if mut\n     then Ast.TY_mutable ty\n     else ty\n   in\n-    { Ast.slot_mode = Ast.MODE_interior;\n+    { Ast.slot_mode = Ast.MODE_local;\n       Ast.slot_ty = Some ty }\n ;;\n \n-let exterior_slot_full mut ty : Ast.slot =\n+let box_slot_full mut ty : Ast.slot =\n   let ty =\n     match ty with\n-        Ast.TY_exterior _ -> ty\n-      | _ -> Ast.TY_exterior ty\n+        Ast.TY_box _ -> ty\n+      | _ -> Ast.TY_box ty\n   in\n   let ty =\n     if mut\n     then Ast.TY_mutable ty\n     else ty\n   in\n-  { Ast.slot_mode = Ast.MODE_interior;\n+  { Ast.slot_mode = Ast.MODE_local;\n     Ast.slot_ty = Some ty }\n ;;\n \n-let interior_slot ty : Ast.slot = interior_slot_full false ty\n+let local_slot ty : Ast.slot = local_slot_full false ty\n ;;\n \n-let exterior_slot ty : Ast.slot = exterior_slot_full false ty\n+let box_slot ty : Ast.slot = box_slot_full false ty\n ;;\n \n \n (* General folds of Ast.ty. *)\n \n type ('ty, 'tys, 'slot, 'slots, 'tag) ty_fold =\n     {\n-      (* Functions that correspond to interior nodes in Ast.ty. *)\n+      (* Functions that correspond to local nodes in Ast.ty. *)\n       ty_fold_slot : (Ast.mode * 'ty) -> 'slot;\n       ty_fold_slots : ('slot array) -> 'slots;\n       ty_fold_tys : ('ty array) -> 'tys;\n@@ -672,7 +672,7 @@ type ('ty, 'tys, 'slot, 'slots, 'tag) ty_fold =\n       ty_fold_param : (int * Ast.effect) -> 'ty;\n       ty_fold_named : Ast.name -> 'ty;\n       ty_fold_type : unit -> 'ty;\n-      ty_fold_exterior : 'ty -> 'ty;\n+      ty_fold_box : 'ty -> 'ty;\n       ty_fold_mutable : 'ty -> 'ty;\n       ty_fold_constrained : ('ty * Ast.constrs) -> 'ty }\n ;;\n@@ -739,7 +739,7 @@ let rec fold_ty\n   | Ast.TY_named n -> f.ty_fold_named n\n   | Ast.TY_type -> f.ty_fold_type ()\n \n-  | Ast.TY_exterior t -> f.ty_fold_exterior (fold_ty f t)\n+  | Ast.TY_box t -> f.ty_fold_box (fold_ty f t)\n   | Ast.TY_mutable t -> f.ty_fold_mutable (fold_ty f t)\n \n   | Ast.TY_constrained (t, constrs) ->\n@@ -778,7 +778,7 @@ let ty_fold_default (default:'a) : 'a simple_ty_fold =\n       ty_fold_param = (fun _ -> default);\n       ty_fold_named = (fun _ -> default);\n       ty_fold_type = (fun _ -> default);\n-      ty_fold_exterior = (fun _ -> default);\n+      ty_fold_box = (fun _ -> default);\n       ty_fold_mutable = (fun _ -> default);\n       ty_fold_constrained = (fun _ -> default) }\n ;;\n@@ -824,7 +824,7 @@ let ty_fold_rebuild (id:Ast.ty -> Ast.ty)\n     ty_fold_param = (fun (i, mut) -> id (Ast.TY_param (i, mut)));\n     ty_fold_named = (fun n -> id (Ast.TY_named n));\n     ty_fold_type = (fun _ -> id (Ast.TY_type));\n-    ty_fold_exterior = (fun t -> id (Ast.TY_exterior t));\n+    ty_fold_box = (fun t -> id (Ast.TY_box t));\n     ty_fold_mutable = (fun t -> id (Ast.TY_mutable t));\n     ty_fold_constrained = (fun (t, constrs) ->\n                              id (Ast.TY_constrained (t, constrs))) }\n@@ -1069,7 +1069,7 @@ let check_concrete params thing =\n \n let rec simplified_ty (t:Ast.ty) : Ast.ty =\n   match t with\n-      Ast.TY_exterior t\n+      Ast.TY_box t\n     | Ast.TY_mutable t\n     | Ast.TY_constrained (t, _) -> simplified_ty t\n     | _ -> t\n@@ -1097,12 +1097,12 @@ let rec project_type\n     | (Ast.TY_obj (_, fns), Ast.COMP_named (Ast.COMP_ident id)) ->\n         (Ast.TY_fn (Hashtbl.find fns id))\n \n-    | (Ast.TY_exterior t, Ast.COMP_deref) -> t\n+    | (Ast.TY_box t, Ast.COMP_deref) -> t\n \n-    (* Exterior, mutable and constrained are transparent to the\n+    (* Box, mutable and constrained are transparent to the\n      * other lval-ext forms: x.y and x.(y).\n      *)\n-    | (Ast.TY_exterior t, _)\n+    | (Ast.TY_box t, _)\n     | (Ast.TY_mutable t, _)\n     | (Ast.TY_constrained (t, _), _) -> project_type t comp\n \n@@ -1315,7 +1315,7 @@ let ty_of_mod_item ((*inside*)_:bool) (item:Ast.mod_item) : Ast.ty =\n         let tobj = Ast.TY_obj (ty_obj_of_obj ob) in\n         let tsig = { Ast.sig_input_slots = arg_slots ob.Ast.obj_state;\n                      Ast.sig_input_constrs = ob.Ast.obj_constrs;\n-                     Ast.sig_output_slot = interior_slot tobj }\n+                     Ast.sig_output_slot = local_slot tobj }\n         in\n           (Ast.TY_fn (tsig, taux))\n \n@@ -1325,7 +1325,7 @@ let ty_of_mod_item ((*inside*)_:bool) (item:Ast.mod_item) : Ast.ty =\n         in\n         let tsig = { Ast.sig_input_slots = tup_slots htup;\n                      Ast.sig_input_constrs = [| |];\n-                     Ast.sig_output_slot = interior_slot (Ast.TY_tag ttag) }\n+                     Ast.sig_output_slot = local_slot (Ast.TY_tag ttag) }\n         in\n           (Ast.TY_fn (tsig, taux))\n ;;\n@@ -1867,7 +1867,7 @@ let rec referent_type (abi:Abi.abi) (t:Ast.ty) : Il.referent_ty =\n \n       | Ast.TY_native _ -> ptr\n \n-      | Ast.TY_exterior t ->\n+      | Ast.TY_box t ->\n           sp (Il.StructTy [| word; referent_type abi t |])\n \n       | Ast.TY_mutable t -> referent_type abi t\n@@ -1884,7 +1884,7 @@ and slot_referent_type (abi:Abi.abi) (sl:Ast.slot) : Il.referent_ty =\n \n   let rty = referent_type abi (slot_ty sl) in\n     match sl.Ast.slot_mode with\n-      | Ast.MODE_interior _ -> rty\n+      | Ast.MODE_local _ -> rty\n       | Ast.MODE_alias _ -> sp rty\n ;;\n \n@@ -2000,7 +2000,7 @@ let slot_sz (abi:Abi.abi) (s:Ast.slot) : int64 =\n ;;\n \n let word_slot (abi:Abi.abi) : Ast.slot =\n-  interior_slot (Ast.TY_mach abi.Abi.abi_word_ty)\n+  local_slot (Ast.TY_mach abi.Abi.abi_word_ty)\n ;;\n \n let alias_slot (ty:Ast.ty) : Ast.slot =\n@@ -2045,15 +2045,15 @@ let mk_simple_ty_fn\n     (arg_slots:Ast.slot array)\n     : Ast.ty =\n   (* In some cases we don't care what the output slot is. *)\n-  let out_slot = interior_slot Ast.TY_nil in\n+  let out_slot = local_slot Ast.TY_nil in\n     mk_ty_fn out_slot arg_slots\n ;;\n \n let mk_simple_ty_iter\n     (arg_slots:Ast.slot array)\n     : Ast.ty =\n   (* In some cases we don't care what the output slot is. *)\n-  let out_slot = interior_slot Ast.TY_nil in\n+  let out_slot = local_slot Ast.TY_nil in\n     mk_ty_fn_or_iter out_slot arg_slots true\n ;;\n \n@@ -2073,7 +2073,7 @@ let ty_str (ty:Ast.ty) : string =\n   let fold_slot (mode,ty) =\n     (match mode with\n          Ast.MODE_alias -> \"a\"\n-       | Ast.MODE_interior -> \"\")\n+       | Ast.MODE_local -> \"\")\n     ^ ty\n   in\n   let num n = (string_of_int n) ^ \"$\" in\n@@ -2147,7 +2147,7 @@ let ty_str (ty:Ast.ty) : string =\n          ty_fold_param = (fun _ -> \"P\");\n          ty_fold_type = (fun _ -> \"Y\");\n          ty_fold_mutable = (fun t -> \"m\" ^ t);\n-         ty_fold_exterior = (fun t -> \"e\" ^ t);\n+         ty_fold_box = (fun t -> \"e\" ^ t);\n \n          (* FIXME (issue #78): encode obj types. *)\n          (* FIXME (issue #78): encode opaque and param numbers. *)"}, {"sha": "4b6eb19bb2b9cbf044a4dae571ebaabe4e0f8d57", "filename": "src/boot/me/trans.ml", "status": "modified", "additions": 56, "deletions": 57, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Fboot%2Fme%2Ftrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Fboot%2Fme%2Ftrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftrans.ml?ref=6a0b06e56287f1de7ff096ed79fbf86e1e527290", "patch": "@@ -1584,17 +1584,16 @@ let trans_visitor\n       : fixup =\n     let g = GLUE_free ty in\n     let inner _ (args:Il.cell) =\n-      (* \n-       * Free-glue assumes it's called with a pointer to an \n-       * exterior allocation with normal exterior layout. It's\n-       * just a way to move drop+free out of leaf code. \n+      (* Free-glue assumes it's called with a pointer to a box allocation with\n+       * normal box layout. It's just a way to move drop+free out of leaf\n+       * code.\n        *)\n       let ty_params = deref (get_element_ptr args 0) in\n       let cell = get_element_ptr args 1 in\n       let (body_mem, _) =\n         need_mem_cell\n           (get_element_ptr_dyn ty_params (deref cell)\n-             Abi.exterior_rc_slot_field_body)\n+             Abi.box_rc_slot_field_body)\n       in\n       let vr = next_vreg_cell Il.voidptr_t in\n         lea vr body_mem;\n@@ -1608,7 +1607,7 @@ let trans_visitor\n           \"free-glue complete\";\n     in\n     let ty_params_ptr = ty_params_covering ty in\n-    let fty = mk_simple_ty_fn [| ty_params_ptr; exterior_slot ty |] in\n+    let fty = mk_simple_ty_fn [| ty_params_ptr; box_slot ty |] in\n       get_typed_mem_glue g fty inner\n \n \n@@ -1657,7 +1656,7 @@ let trans_visitor\n     let ty_params_ptr = ty_params_covering ty in\n     let fty =\n       mk_ty_fn\n-        (interior_slot ty)     (* dst *)\n+        (local_slot ty)        (* dst *)\n         [|\n           ty_params_ptr;\n           alias_slot ty;       (* src *)\n@@ -1681,7 +1680,7 @@ let trans_visitor\n     let ty_params_ptr = ty_params_covering ty in\n     let fty =\n       mk_ty_fn\n-        (interior_slot ty)\n+        (local_slot ty)\n         [| ty_params_ptr; alias_slot ty |]\n     in\n       get_typed_mem_glue g fty inner\n@@ -2120,7 +2119,7 @@ let trans_visitor\n     trans_void_upcall \"upcall_kill\" [| Il.Cell task |]\n \n   (*\n-   * A vec is implicitly exterior: every slot vec[T] is 1 word and\n+   * A vec is implicitly boxed: every slot vec[T] is 1 word and\n    * points to a refcounted structure. That structure has 3 words with\n    * defined meaning at the beginning; data follows the header.\n    *\n@@ -2212,22 +2211,22 @@ let trans_visitor\n                                (ty_align abi ty))\n              (tydesc_rty abi))\n \n-  and exterior_ctrl_cell (cell:Il.cell) (off:int) : Il.cell =\n+  and box_ctrl_cell (cell:Il.cell) (off:int) : Il.cell =\n     let (mem, _) = need_mem_cell (deref_imm cell (word_n off)) in\n       word_at mem\n \n-  and exterior_rc_cell (cell:Il.cell) : Il.cell =\n-    exterior_ctrl_cell cell Abi.exterior_rc_slot_field_refcnt\n+  and box_rc_cell (cell:Il.cell) : Il.cell =\n+    box_ctrl_cell cell Abi.box_rc_slot_field_refcnt\n \n-  and exterior_allocation_size\n+  and box_allocation_size\n       (ty:Ast.ty)\n       : Il.operand =\n     let header_sz =\n       match ty_mem_ctrl ty with\n           MEM_gc\n         | MEM_rc_opaque\n-        | MEM_rc_struct -> word_n Abi.exterior_rc_header_size\n-        | MEM_interior -> bug () \"exterior_allocation_size of MEM_interior\"\n+        | MEM_rc_struct -> word_n Abi.box_rc_header_size\n+        | MEM_interior -> bug () \"box_allocation_size of MEM_interior\"\n     in\n     let ty = simplified_ty ty in\n     let refty_sz =\n@@ -2304,8 +2303,8 @@ let trans_visitor\n        * vreg and so has to be aware of when it's iterating over 2\n        * sequences of cells or just 1.\n        *)\n-      check_exterior_rty src_cell;\n-      check_exterior_rty dst_cell;\n+      check_box_rty src_cell;\n+      check_box_rty dst_cell;\n       if dst_cell = src_cell\n       then\n         begin\n@@ -2413,9 +2412,9 @@ let trans_visitor\n               (* Drop non-null bindings. *)\n               (* FIXME (issue #58): this is completely wrong, Closures need to\n                * carry tydescs like objs. For now this only works by accident,\n-               * and will leak closures with exterior substructure.\n+               * and will leak closures with box substructure.\n                *)\n-              drop_ty ty_params binding (Ast.TY_exterior Ast.TY_int) curr_iso;\n+              drop_ty ty_params binding (Ast.TY_box Ast.TY_int) curr_iso;\n               patch null_jmp\n \n         | Ast.TY_obj _ ->\n@@ -2465,13 +2464,13 @@ let trans_visitor\n             | MEM_rc_opaque\n             | MEM_rc_struct ->\n \n-                let _ = check_exterior_rty cell in\n+                let _ = check_box_rty cell in\n                 let null_jmp = null_check cell in\n-                let rc = exterior_rc_cell cell in\n+                let rc = box_rc_cell cell in\n                 let j = drop_refcount_and_cmp rc in\n \n-                  (* FIXME (issue #25): check to see that the exterior has\n-                   * further exterior members; if it doesn't we can elide the\n+                  (* FIXME (issue #25): check to see that the box has\n+                   * further box members; if it doesn't we can elide the\n                    * call to the glue function.  *)\n \n                   if mctrl = MEM_rc_opaque\n@@ -2491,7 +2490,7 @@ let trans_visitor\n \n             | MEM_interior when type_is_structured ty ->\n                 (iflog (fun _ ->\n-                          annotate (\"drop interior slot \" ^\n+                          annotate (\"drop interior memory \" ^\n                                       (Fmt.fmt_to_str Ast.fmt_ty ty))));\n                 let (mem, _) = need_mem_cell cell in\n                 let vr = next_vreg_cell Il.voidptr_t in\n@@ -2516,9 +2515,9 @@ let trans_visitor\n       match ty_mem_ctrl ty with\n           MEM_gc ->\n \n-            let _ = check_exterior_rty cell in\n+            let _ = check_box_rty cell in\n             let null_jmp = null_check cell in\n-            let rc = exterior_rc_cell cell in\n+            let rc = box_rc_cell cell in\n             let _ = note_gc_step ty \"severing GC slot\" in\n               emit (Il.binary Il.SUB rc (Il.Cell rc) one);\n               mov cell zero;\n@@ -2551,7 +2550,7 @@ let trans_visitor\n           -> mov dst (Il.Cell src)\n       | Ast.TY_fn _\n       | Ast.TY_obj _ -> ()\n-      | Ast.TY_exterior ty ->\n+      | Ast.TY_box ty ->\n           let glue_fix = get_clone_glue ty curr_iso in\n             trans_call_static_glue\n               (code_fixup_to_ptr_operand glue_fix)\n@@ -2615,8 +2614,8 @@ let trans_visitor\n                  * this only works by accident.\n                  *)\n                 trans_copy_ty ty_params true\n-                  dst_binding (Ast.TY_exterior Ast.TY_int)\n-                  src_binding (Ast.TY_exterior Ast.TY_int)\n+                  dst_binding (Ast.TY_box Ast.TY_int)\n+                  src_binding (Ast.TY_box Ast.TY_int)\n                   curr_iso;\n                 patch null_jmp\n           end\n@@ -2652,7 +2651,7 @@ let trans_visitor\n       : Ast.ty =\n     match (curr_iso, t) with\n         (Some iso, Ast.TY_idx n) ->\n-          Ast.TY_exterior (Ast.TY_iso { iso with Ast.iso_index = n })\n+          Ast.TY_box (Ast.TY_iso { iso with Ast.iso_index = n })\n       | (None, Ast.TY_idx _) ->\n           bug () \"TY_idx outside TY_iso\"\n       | _ -> t\n@@ -2687,11 +2686,11 @@ let trans_visitor\n             let marked_jump =\n               trans_compare Il.JE (Il.Cell tmp) zero;\n             in\n-              (* Iterate over exterior parts marking outgoing links. *)\n+              (* Iterate over box parts marking outgoing links. *)\n             let (body_mem, _) =\n               need_mem_cell\n                 (get_element_ptr (deref cell)\n-                   Abi.exterior_gc_slot_field_body)\n+                   Abi.box_gc_slot_field_body)\n             in\n             let ty = maybe_iso curr_iso ty in\n             let curr_iso = maybe_enter_iso ty curr_iso in\n@@ -2703,7 +2702,7 @@ let trans_visitor\n \n         | MEM_interior when type_is_structured ty ->\n             (iflog (fun _ ->\n-                      annotate (\"mark interior slot \" ^\n+                      annotate (\"mark interior memory \" ^\n                                   (Fmt.fmt_to_str Ast.fmt_ty ty))));\n             let (mem, _) = need_mem_cell cell in\n             let tmp = next_vreg_cell Il.voidptr_t in\n@@ -2716,13 +2715,13 @@ let trans_visitor\n \n         | _ -> ()\n \n-  and check_exterior_rty cell =\n+  and check_box_rty cell =\n     match cell with\n         Il.Reg (_, Il.AddrTy (Il.StructTy fields))\n       | Il.Mem (_, Il.ScalarTy (Il.AddrTy (Il.StructTy fields)))\n           when (((Array.length fields) > 0) && (fields.(0) = word_rty)) -> ()\n       | _ -> bug ()\n-          \"expected plausibly-exterior cell, got %s\"\n+          \"expected plausibly-box cell, got %s\"\n             (Il.string_of_referent_ty (Il.cell_referent_ty cell))\n \n   and drop_slot_in_current_frame\n@@ -2755,7 +2754,7 @@ let trans_visitor\n     match slot.Ast.slot_mode with\n         Ast.MODE_alias\n           (* Aliases are always free to drop. *)\n-      | Ast.MODE_interior ->\n+      | Ast.MODE_local ->\n           drop_ty ty_params cell (slot_ty slot) curr_iso\n \n   and note_drop_step ty step =\n@@ -2788,7 +2787,7 @@ let trans_visitor\n         end\n \n   (* Returns the offset of the slot-body in the initialized allocation. *)\n-  and init_exterior (cell:Il.cell) (ty:Ast.ty) : unit =\n+  and init_box (cell:Il.cell) (ty:Ast.ty) : unit =\n     let mctrl = ty_mem_ctrl ty in\n       match mctrl with\n           MEM_gc\n@@ -2799,14 +2798,14 @@ let trans_visitor\n               then Il.Cell (get_tydesc None ty)\n               else zero\n             in\n-              iflog (fun _ -> annotate \"init exterior: malloc\");\n-              let sz = exterior_allocation_size ty in\n+              iflog (fun _ -> annotate \"init box: malloc\");\n+              let sz = box_allocation_size ty in\n                 trans_malloc cell sz ctrl;\n-                iflog (fun _ -> annotate \"init exterior: load refcount\");\n-                let rc = exterior_rc_cell cell in\n+                iflog (fun _ -> annotate \"init box: load refcount\");\n+                let rc = box_rc_cell cell in\n                   mov rc one\n \n-      | MEM_interior -> bug () \"init_exterior of MEM_interior\"\n+      | MEM_interior -> bug () \"init_box of MEM_interior\"\n \n   and deref_ty\n       (initializing:bool)\n@@ -2819,14 +2818,14 @@ let trans_visitor\n       | Ast.TY_constrained (ty, _) ->\n           deref_ty initializing cell ty\n \n-      | Ast.TY_exterior ty' ->\n-          check_exterior_rty cell;\n+      | Ast.TY_box ty' ->\n+          check_box_rty cell;\n           if initializing\n-          then init_exterior cell ty;\n+          then init_box cell ty;\n           let cell =\n             get_element_ptr_dyn_in_current_frame\n               (deref cell)\n-              (Abi.exterior_rc_slot_field_body)\n+              (Abi.box_rc_slot_field_body)\n           in\n             (* Init recursively so @@@@T chain works. *)\n             deref_ty initializing cell ty'\n@@ -2840,7 +2839,7 @@ let trans_visitor\n       (slot:Ast.slot)\n       : Il.cell =\n     match slot.Ast.slot_mode with\n-        Ast.MODE_interior ->\n+        Ast.MODE_local ->\n           cell\n \n       | Ast.MODE_alias _  ->\n@@ -2892,7 +2891,7 @@ let trans_visitor\n         | (MEM_rc_struct, MEM_rc_struct) ->\n             (* Lightweight copy: twiddle refcounts, move pointer. *)\n             anno \"refcounted light\";\n-            add_to (exterior_rc_cell src) one;\n+            add_to (box_rc_cell src) one;\n             if not initializing\n             then\n               drop_ty ty_params dst dst_ty None;\n@@ -2961,7 +2960,7 @@ let trans_visitor\n       match t with\n           Ast.TY_vec _\n         | Ast.TY_str -> true\n-        | Ast.TY_exterior t when can_append t -> true\n+        | Ast.TY_box t when can_append t -> true\n         | _ -> false\n     in\n       match (dst_ty, src) with\n@@ -3129,7 +3128,7 @@ let trans_visitor\n         (Ast.MODE_alias, CLONE_none) ->\n           mov dst (Il.Cell (alias (Il.Mem (need_mem_cell src))))\n \n-      | (Ast.MODE_interior, CLONE_none) ->\n+      | (Ast.MODE_local, CLONE_none) ->\n           trans_copy_ty\n             ty_params true\n             dst dst_ty src src_ty None\n@@ -4402,9 +4401,9 @@ let trans_visitor\n     in\n     let obj_args_ty = Ast.TY_tup obj_args_tup in\n     let state_ty = Ast.TY_tup [| Ast.TY_type; obj_args_ty |] in\n-    let state_ptr_ty = Ast.TY_exterior state_ty in\n+    let state_ptr_ty = Ast.TY_box state_ty in\n     let state_ptr_rty = referent_type abi state_ptr_ty in\n-    let state_malloc_sz = exterior_allocation_size state_ptr_ty in\n+    let state_malloc_sz = box_allocation_size state_ptr_ty in\n \n     let ctor_ty = Hashtbl.find cx.ctxt_all_item_types obj_id in\n     let obj_ty =\n@@ -4684,8 +4683,8 @@ let trans_visitor\n       else ignore (Stack.pop curr_file)\n   in\n \n-  let visit_local_mod_item_pre n _ i =\n-    iflog (fun _ -> log cx \"translating local item #%d = %s\"\n+  let visit_defined_mod_item_pre n _ i =\n+    iflog (fun _ -> log cx \"translating defined item #%d = %s\"\n              (int_of_node i.id) (path_name()));\n     match i.node.Ast.decl_item with\n         Ast.MOD_ITEM_fn f -> trans_fn i.id f.Ast.fn_body\n@@ -4730,7 +4729,7 @@ let trans_visitor\n       inner.Walk.visit_obj_drop_pre obj b\n   in\n \n-  let visit_local_obj_fn_pre _ _ fn =\n+  let visit_defined_obj_fn_pre _ _ fn =\n     trans_fn fn.id fn.node.Ast.fn_body\n   in\n \n@@ -4745,7 +4744,7 @@ let trans_visitor\n       then\n         visit_required_obj_fn_pre obj ident fn\n       else\n-        visit_local_obj_fn_pre obj ident fn;\n+        visit_defined_obj_fn_pre obj ident fn;\n     end;\n     inner.Walk.visit_obj_fn_pre obj ident fn\n   in\n@@ -4757,7 +4756,7 @@ let trans_visitor\n       then\n         visit_required_mod_item_pre n p i\n       else\n-        visit_local_mod_item_pre n p i\n+        visit_defined_mod_item_pre n p i\n     end;\n     inner.Walk.visit_mod_item_pre n p i\n   in"}, {"sha": "d7fbb566488356181ac9c3c7f00afbc535e1adfe", "filename": "src/boot/me/transutil.ml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Fboot%2Fme%2Ftransutil.ml", "raw_url": "https://github.com/rust-lang/rust/raw/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Fboot%2Fme%2Ftransutil.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftransutil.ml?ref=6a0b06e56287f1de7ff096ed79fbf86e1e527290", "patch": "@@ -7,7 +7,7 @@ open Semant;;\n  * \"simple\" precise, mark-sweep, single-generation, per-task (thereby\n  * preemptable and relatively quick) GC scheme on mutable memory.\n  * \n- * - For the sake of this note, call any exterior of 'state' effect a gc_val.\n+ * - For the sake of this note, call any box of 'state' effect a gc_val.\n  *\n  * - gc_vals come from the same malloc as all other values but undergo\n  *   different storage management.\n@@ -19,7 +19,7 @@ open Semant;;\n  *\n  *  - A pointer to a gc_val, however, points to the third of these three\n  *    words. So a certain quantity of code can treat gc_vals the same way it\n- *    would treat refcounted exterior vals.\n+ *    would treat refcounted box vals.\n  *\n  *  - The first word at the head of a gc_val is used as a refcount, as in\n  *    non-gc allocations.\n@@ -122,7 +122,7 @@ let rec ty_mem_ctrl (ty:Ast.ty) : mem_ctrl =\n         if type_has_state ty\n         then MEM_gc\n         else MEM_rc_opaque\n-    | Ast.TY_exterior t ->\n+    | Ast.TY_box t ->\n         if type_has_state t\n         then MEM_gc\n         else\n@@ -139,7 +139,7 @@ let rec ty_mem_ctrl (ty:Ast.ty) : mem_ctrl =\n let slot_mem_ctrl (slot:Ast.slot) : mem_ctrl =\n   match slot.Ast.slot_mode with\n       Ast.MODE_alias -> MEM_interior\n-    | Ast.MODE_interior ->\n+    | Ast.MODE_local ->\n         ty_mem_ctrl (slot_ty slot)\n ;;\n "}, {"sha": "36f5d3a3d7ef21b3dc3ad8a8ffa17318786815d0", "filename": "src/boot/me/type.ml", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Fboot%2Fme%2Ftype.ml", "raw_url": "https://github.com/rust-lang/rust/raw/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Fboot%2Fme%2Ftype.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftype.ml?ref=6a0b06e56287f1de7ff096ed79fbf86e1e527290", "patch": "@@ -5,7 +5,7 @@ type tyspec =\n     TYSPEC_equiv of tyvar\n   | TYSPEC_all\n   | TYSPEC_resolved of (Ast.ty_param array) * Ast.ty\n-  | TYSPEC_exterior of tyvar                  (* @ of some t *)\n+  | TYSPEC_box of tyvar                       (* @ of some t *)\n   | TYSPEC_mutable of tyvar                   (* something mutable *)\n   | TYSPEC_callable of (tyvar * tyvar array)  (* out, ins *)\n   | TYSPEC_collection of tyvar                (* vec or str *)\n@@ -107,7 +107,7 @@ let rec tyspec_to_str (ts:tyspec) : string =\n       | TYSPEC_equiv tv ->\n           fmt_tyspec ff (!tv)\n \n-      | TYSPEC_exterior tv ->\n+      | TYSPEC_box tv ->\n           fmt ff \"@@\";\n           fmt_tyspec ff (!tv)\n \n@@ -173,31 +173,31 @@ let rec resolve_tyvar (tv:tyvar) : tyvar =\n \n type unify_ctxt =\n     { mut_ok: bool;\n-      ext_ok: bool }\n+      box_ok: bool }\n ;;\n \n let arg_pass_ctx =\n-  { ext_ok = false;\n+  { box_ok = false;\n     mut_ok = true }\n ;;\n \n let rval_ctx =\n-  { ext_ok = true;\n+  { box_ok = true;\n     mut_ok = true }\n ;;\n \n let lval_ctx =\n-  { ext_ok = false;\n+  { box_ok = false;\n     mut_ok = true }\n ;;\n \n let init_ctx =\n-  { ext_ok = true;\n+  { box_ok = true;\n     mut_ok = true }\n ;;\n \n let strict_ctx =\n-  { ext_ok = false;\n+  { box_ok = false;\n     mut_ok = false }\n ;;\n \n@@ -265,12 +265,12 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n         iflog cx\n           (fun _ ->\n              log cx \"%s> unifying types:\" indent;\n-             if ucx.ext_ok || ucx.mut_ok\n+             if ucx.box_ok || ucx.mut_ok\n              then\n                log cx \"%s> (w/ %s%s%s)\"\n                  indent\n-                 (if ucx.ext_ok then \"ext-ok\" else \"\")\n-                 (if ucx.ext_ok && ucx.mut_ok then \" \" else \"\")\n+                 (if ucx.box_ok then \"ext-ok\" else \"\")\n+                 (if ucx.box_ok && ucx.mut_ok then \" \" else \"\")\n                  (if ucx.mut_ok then \"mut-ok\" else \"\");\n              log cx \"%s> input tyvar A:     %s\" indent (tyspec_to_str !av);\n              log cx \"%s> input tyvar B:     %s\" indent (tyspec_to_str !bv));\n@@ -341,8 +341,8 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n           : Ast.ty =\n         match ty_a, ty_b with\n             a, b when a = b -> a\n-          | Ast.TY_exterior a, b | b, Ast.TY_exterior a when ucx.ext_ok ->\n-              Ast.TY_exterior (unify_resolved_types a b)\n+          | Ast.TY_box a, b | b, Ast.TY_box a when ucx.box_ok ->\n+              Ast.TY_box (unify_resolved_types a b)\n           | Ast.TY_mutable a, b | b, Ast.TY_mutable a when ucx.mut_ok ->\n               Ast.TY_mutable (unify_resolved_types a b)\n           | Ast.TY_constrained (a, constrs), b\n@@ -366,15 +366,15 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n               is_comparable_or_ordered comparable ty\n           | Ast.TY_mutable ty ->\n               ucx.mut_ok && is_comparable_or_ordered comparable ty\n-          | Ast.TY_exterior ty ->\n-              ucx.ext_ok && is_comparable_or_ordered comparable ty\n+          | Ast.TY_box ty ->\n+              ucx.box_ok && is_comparable_or_ordered comparable ty\n       in\n \n       let rec floating (ty:Ast.ty) : bool =\n         match ty with\n             Ast.TY_mach TY_f32 | Ast.TY_mach TY_f64 -> true\n           | Ast.TY_mutable ty when ucx.mut_ok -> floating ty\n-          | Ast.TY_exterior ty when ucx.ext_ok -> floating ty\n+          | Ast.TY_box ty when ucx.box_ok -> floating ty\n           | _ -> false\n       in\n \n@@ -386,7 +386,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n           | Ast.TY_mach TY_i64 ->\n               true\n           | Ast.TY_mutable ty when ucx.mut_ok -> integral ty\n-          | Ast.TY_exterior ty when ucx.ext_ok -> integral ty\n+          | Ast.TY_box ty when ucx.box_ok -> integral ty\n           | _ -> false\n       in\n \n@@ -397,7 +397,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n             Ast.TY_str -> true\n           | Ast.TY_vec _ -> true\n           | Ast.TY_mutable ty when ucx.mut_ok -> plusable ty\n-          | Ast.TY_exterior ty when ucx.ext_ok -> plusable ty\n+          | Ast.TY_box ty when ucx.box_ok -> plusable ty\n           | _ -> numeric ty\n       in\n \n@@ -408,7 +408,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n           | Ast.TY_mach TY_i8 | Ast.TY_mach TY_i16 | Ast.TY_mach TY_i32\n               -> true\n           | Ast.TY_mutable ty when ucx.mut_ok -> loggable ty\n-          | Ast.TY_exterior ty when ucx.ext_ok -> loggable ty\n+          | Ast.TY_box ty when ucx.box_ok -> loggable ty\n           | _ -> false\n       in\n \n@@ -419,34 +419,34 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n \n           | (TYSPEC_all, other) | (other, TYSPEC_all) -> other\n \n-          (* exterior *)\n+          (* box *)\n \n-          | (TYSPEC_exterior a', TYSPEC_exterior b') ->\n+          | (TYSPEC_box a', TYSPEC_box b') ->\n               unify_tyvars ucx a' b'; !a\n \n-          | (TYSPEC_exterior a',\n-             TYSPEC_resolved (_, Ast.TY_exterior _)) ->\n+          | (TYSPEC_box a',\n+             TYSPEC_resolved (_, Ast.TY_box _)) ->\n                unify_tyvars ucx a' b; !b\n \n-          | (TYSPEC_resolved (_, Ast.TY_exterior _),\n-             TYSPEC_exterior b') ->\n+          | (TYSPEC_resolved (_, Ast.TY_box _),\n+             TYSPEC_box b') ->\n                unify_tyvars ucx a b'; !a\n \n-          | (_, TYSPEC_resolved (params, Ast.TY_exterior ty))\n-              when ucx.ext_ok ->\n+          | (_, TYSPEC_resolved (params, Ast.TY_box ty))\n+              when ucx.box_ok ->\n               unify_ty_parametric ucx ty params a; !b\n \n-          | (TYSPEC_resolved (params, Ast.TY_exterior ty), _)\n-              when ucx.ext_ok ->\n+          | (TYSPEC_resolved (params, Ast.TY_box ty), _)\n+              when ucx.box_ok ->\n               unify_ty_parametric ucx ty params b; !a\n \n-          | (TYSPEC_exterior a', _) when ucx.ext_ok\n+          | (TYSPEC_box a', _) when ucx.box_ok\n               -> unify_tyvars ucx a' b; !a\n-          | (_, TYSPEC_exterior b') when ucx.ext_ok\n+          | (_, TYSPEC_box b') when ucx.box_ok\n               -> unify_tyvars ucx a b'; !b\n \n-          | (_, TYSPEC_exterior _)\n-          | (TYSPEC_exterior _, _) -> fail()\n+          | (_, TYSPEC_box _)\n+          | (TYSPEC_box _, _) -> fail()\n \n           (* mutable *)\n \n@@ -505,8 +505,8 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n                           unify_slot arg_pass_ctx out_slot None out_tv;\n                           Array.iteri unify_in_slot in_slots;\n                           ty\n-                    | Ast.TY_exterior ty when ucx.ext_ok\n-                        -> Ast.TY_exterior (unify ty)\n+                    | Ast.TY_box ty when ucx.box_ok\n+                        -> Ast.TY_box (unify ty)\n                     | Ast.TY_mutable ty when ucx.mut_ok\n                         -> Ast.TY_mutable (unify ty)\n                     | _ -> fail ()\n@@ -520,8 +520,8 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n                     Ast.TY_vec ty' -> unify_ty ucx ty' tv; ty\n                   | Ast.TY_str ->\n                       unify_ty ucx (Ast.TY_mach TY_u8) tv; ty\n-                  | Ast.TY_exterior ty\n-                      when ucx.ext_ok -> Ast.TY_exterior (unify ty)\n+                  | Ast.TY_box ty\n+                      when ucx.box_ok -> Ast.TY_box (unify ty)\n                   | Ast.TY_mutable ty\n                       when ucx.mut_ok -> Ast.TY_mutable (unify ty)\n                   | _ -> fail ()\n@@ -548,8 +548,8 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n                   | Ast.TY_obj (_, fns) ->\n                       unify_dict_with_obj_fns dct fns;\n                       ty\n-                  | Ast.TY_exterior ty\n-                      when ucx.ext_ok -> Ast.TY_exterior (unify ty)\n+                  | Ast.TY_box ty\n+                      when ucx.box_ok -> Ast.TY_box (unify ty)\n                   | Ast.TY_mutable ty\n                       when ucx.mut_ok -> Ast.TY_mutable (unify ty)\n                   | _ -> fail ()\n@@ -591,8 +591,8 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n                     Ast.TY_rec fields ->\n                       unify_dict_with_record_fields dct fields;\n                       ty\n-                  | Ast.TY_exterior ty\n-                      when ucx.ext_ok -> Ast.TY_exterior (unify ty)\n+                  | Ast.TY_box ty\n+                      when ucx.box_ok -> Ast.TY_box (unify ty)\n                   | Ast.TY_mutable ty\n                       when ucx.mut_ok -> Ast.TY_mutable (unify ty)\n                   | _ -> fail ()\n@@ -612,10 +612,10 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n                         in\n                           Array.iteri check_elem tvs;\n                           ty\n-                  | Ast.TY_exterior ty\n-                      when ucx.ext_ok -> Ast.TY_exterior (unify ty)\n+                  | Ast.TY_box ty\n+                      when ucx.box_ok -> Ast.TY_box (unify ty)\n                   | Ast.TY_mutable ty\n-                      when ucx.ext_ok -> Ast.TY_mutable (unify ty)\n+                      when ucx.box_ok -> Ast.TY_mutable (unify ty)\n                   | _ -> fail ()\n               in\n               TYSPEC_resolved (params, unify ty)\n@@ -625,8 +625,8 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n               let rec unify ty =\n                 match ty with\n                     Ast.TY_vec ty' -> unify_ty ucx ty' tv; ty\n-                  | Ast.TY_exterior ty when ucx.ext_ok ->\n-                      Ast.TY_exterior (unify ty)\n+                  | Ast.TY_box ty when ucx.box_ok ->\n+                      Ast.TY_box (unify ty)\n                   | Ast.TY_mutable ty when ucx.mut_ok ->\n                       Ast.TY_mutable (unify ty)\n                   | _ -> fail ()\n@@ -1113,10 +1113,10 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n                     TYSPEC_collection tv\n \n                 | Ast.COMP_deref ->\n-                    TYSPEC_exterior tv\n+                    TYSPEC_box tv\n               in\n               let base_tv = ref base_ts in\n-                unify_lval' { ucx with ext_ok = true } base base_tv;\n+                unify_lval' { ucx with box_ok = true } base base_tv;\n                 match !(resolve_tyvar base_tv) with\n                     TYSPEC_resolved (_, ty) ->\n                       unify_ty ucx (project_type ty comp) tv\n@@ -1367,7 +1367,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n                     Ast.TY_fn (tsig, _) ->\n                       begin\n                         let vec_str =\n-                          interior_slot (Ast.TY_vec Ast.TY_str)\n+                          local_slot (Ast.TY_vec Ast.TY_str)\n                         in\n                           match tsig.Ast.sig_input_slots with\n                               [| |] -> ()\n@@ -1532,8 +1532,8 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n           let ts = !(resolve_tyvar tv) in\n             match ts with\n                 TYSPEC_resolved ([||], ty) -> ty\n-              | TYSPEC_exterior tv ->\n-                  Ast.TY_exterior (get_resolved_ty tv id)\n+              | TYSPEC_box tv ->\n+                  Ast.TY_box (get_resolved_ty tv id)\n \n               | TYSPEC_mutable tv ->\n                   Ast.TY_mutable (get_resolved_ty tv id)"}, {"sha": "af4a6216a7f1b6a11ccd03872ef67286b17cb127", "filename": "src/boot/me/walk.ml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Fboot%2Fme%2Fwalk.ml", "raw_url": "https://github.com/rust-lang/rust/raw/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Fboot%2Fme%2Fwalk.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fwalk.ml?ref=6a0b06e56287f1de7ff096ed79fbf86e1e527290", "patch": "@@ -301,7 +301,7 @@ and walk_ty\n       | Ast.TY_nil -> ()\n       | Ast.TY_task -> ()\n       | Ast.TY_any -> ()\n-      | Ast.TY_exterior m -> walk_ty v m\n+      | Ast.TY_box m -> walk_ty v m\n       | Ast.TY_mutable m -> walk_ty v m\n   in\n     walk_bracketed\n@@ -471,7 +471,7 @@ and walk_stmt\n           walk_option (walk_lval v) port;\n           walk_lval v chan;\n \n-      | Ast.STMT_init_exterior (dst, src) ->\n+      | Ast.STMT_init_box (dst, src) ->\n           walk_lval v dst;\n           walk_atom v src\n "}, {"sha": "192a01f3709b8b8255ccdc0c77a1a3301a3d03bb", "filename": "src/test/run-pass/acyclic-unwind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Ftest%2Frun-pass%2Facyclic-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Ftest%2Frun-pass%2Facyclic-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Facyclic-unwind.rs?ref=6a0b06e56287f1de7ff096ed79fbf86e1e527290", "patch": "@@ -4,10 +4,10 @@ io fn f(chan[int] c)\n {\n   type t = tup(int,int,int);\n \n-  // Allocate an exterior.\n+  // Allocate a box.\n   let @t x = tup(1,2,3);\n \n-  // Signal parent that we've allocated an exterior.\n+  // Signal parent that we've allocated a box.\n   c <| 1;\n \n   while (true) {"}, {"sha": "ab068b9b599653b120656bf3ae0d74bab3beaafb", "filename": "src/test/run-pass/obj-drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Ftest%2Frun-pass%2Fobj-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0b06e56287f1de7ff096ed79fbf86e1e527290/src%2Ftest%2Frun-pass%2Fobj-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-drop.rs?ref=6a0b06e56287f1de7ff096ed79fbf86e1e527290", "patch": "@@ -1,6 +1,6 @@\n fn main() {\n   obj handle(@int i) {\n   }\n-  // This just tests whether the obj leaks its exterior state members.\n+  // This just tests whether the obj leaks its box state members.\n   auto ob = handle(0xf00f00);\n }\n\\ No newline at end of file"}]}