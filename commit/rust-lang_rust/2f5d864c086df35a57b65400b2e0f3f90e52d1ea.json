{"sha": "2f5d864c086df35a57b65400b2e0f3f90e52d1ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmNWQ4NjRjMDg2ZGYzNWE1N2I2NTQwMGIyZTBmM2Y5MGU1MmQxZWE=", "commit": {"author": {"name": "St\u00e9phane Campinas", "email": "stephane.campinas@gmail.com", "date": "2018-10-23T23:24:56Z"}, "committer": {"name": "St\u00e9phane Campinas", "email": "stephane.campinas@gmail.com", "date": "2018-10-24T10:11:11Z"}, "message": "keep track of lines which formatting was disabled in order to prevent indentation which would cause code right-shifting", "tree": {"sha": "6aa426c54dbdadcbee3f9f9e3ed470a82b078e41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6aa426c54dbdadcbee3f9f9e3ed470a82b078e41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f5d864c086df35a57b65400b2e0f3f90e52d1ea", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCgAdFiEEipi5pnt+pUplKNfibVYg2QghATMFAlvQRT8ACgkQbVYg2Qgh\nATMiIggAkc62PbETo99cS6s5cmKwo26Vo6OZp6re3dziEby8x78cdxs6ZOcxdV9u\nlXl6j9HDlaS6izvcwvStLq5RE4W0KBm0jd49jI4EBi/PXyx+P53HNBbc7vH5z7PG\nT3TmCmGQWCMRE+R5ks1rkMmfhwAWdkcJ06DBAj+8NWrnlbK5d+ubsTQr428bY5+p\nf9W/aPOiRMZ96qnh+9rm0PVmOrH5Odw8NMUmTU36Lvee9eP9oqi++6lKlzIIP9rC\n9Mzl2ofRjiY7XHJkTnPM3WREAfj2pzkdoBaj6xa61+QG22+jYXUQhXYaqGB7gYjQ\n6usq7B2eFoiqM6qvD9xmjVDDjsZeRQ==\n=aDIn\n-----END PGP SIGNATURE-----", "payload": "tree 6aa426c54dbdadcbee3f9f9e3ed470a82b078e41\nparent 9c75a15f4c81a6e412844f85d6d24541a88b49e7\nauthor St\u00e9phane Campinas <stephane.campinas@gmail.com> 1540337096 +0200\ncommitter St\u00e9phane Campinas <stephane.campinas@gmail.com> 1540375871 +0200\n\nkeep track of lines which formatting was disabled in order to prevent indentation which would cause code right-shifting\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f5d864c086df35a57b65400b2e0f3f90e52d1ea", "html_url": "https://github.com/rust-lang/rust/commit/2f5d864c086df35a57b65400b2e0f3f90e52d1ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f5d864c086df35a57b65400b2e0f3f90e52d1ea/comments", "author": {"login": "scampi", "id": 795879, "node_id": "MDQ6VXNlcjc5NTg3OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/795879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scampi", "html_url": "https://github.com/scampi", "followers_url": "https://api.github.com/users/scampi/followers", "following_url": "https://api.github.com/users/scampi/following{/other_user}", "gists_url": "https://api.github.com/users/scampi/gists{/gist_id}", "starred_url": "https://api.github.com/users/scampi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scampi/subscriptions", "organizations_url": "https://api.github.com/users/scampi/orgs", "repos_url": "https://api.github.com/users/scampi/repos", "events_url": "https://api.github.com/users/scampi/events{/privacy}", "received_events_url": "https://api.github.com/users/scampi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scampi", "id": 795879, "node_id": "MDQ6VXNlcjc5NTg3OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/795879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scampi", "html_url": "https://github.com/scampi", "followers_url": "https://api.github.com/users/scampi/followers", "following_url": "https://api.github.com/users/scampi/following{/other_user}", "gists_url": "https://api.github.com/users/scampi/gists{/gist_id}", "starred_url": "https://api.github.com/users/scampi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scampi/subscriptions", "organizations_url": "https://api.github.com/users/scampi/orgs", "repos_url": "https://api.github.com/users/scampi/repos", "events_url": "https://api.github.com/users/scampi/events{/privacy}", "received_events_url": "https://api.github.com/users/scampi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c75a15f4c81a6e412844f85d6d24541a88b49e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c75a15f4c81a6e412844f85d6d24541a88b49e7", "html_url": "https://github.com/rust-lang/rust/commit/9c75a15f4c81a6e412844f85d6d24541a88b49e7"}], "stats": {"total": 208, "additions": 129, "deletions": 79}, "files": [{"sha": "e76bb3318562e78d85a5036121de00df03ef4557", "filename": "src/comment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f5d864c086df35a57b65400b2e0f3f90e52d1ea/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f5d864c086df35a57b65400b2e0f3f90e52d1ea/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=2f5d864c086df35a57b65400b2e0f3f90e52d1ea", "patch": "@@ -620,7 +620,7 @@ impl<'a> CommentRewrite<'a> {\n                         let mut config = self.fmt.config.clone();\n                         config.set().format_doc_comments(false);\n                         match ::format_code_block(&self.code_block_buffer, &config) {\n-                            Some(ref s) => trim_custom_comment_prefix(s),\n+                            Some(ref s) => trim_custom_comment_prefix(&s.snippet),\n                             None => trim_custom_comment_prefix(&self.code_block_buffer),\n                         }\n                     }"}, {"sha": "039276ba6e886b39a54b1581d3ef459ce30833f7", "filename": "src/formatting.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f5d864c086df35a57b65400b2e0f3f90e52d1ea/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f5d864c086df35a57b65400b2e0f3f90e52d1ea/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=2f5d864c086df35a57b65400b2e0f3f90e52d1ea", "patch": "@@ -173,6 +173,8 @@ impl<'a, T: FormatHandler + 'a> FormatContext<'a, T> {\n         if visitor.macro_rewrite_failure {\n             self.report.add_macro_format_failure();\n         }\n+        self.report\n+            .add_non_formatted_ranges(visitor.skipped_range.clone());\n \n         self.handler\n             .handle_formatted_file(path, visitor.buffer.to_owned(), &mut self.report)"}, {"sha": "2dcbf823d5560e5117d6bef2de7c656401a125e8", "filename": "src/lib.rs", "status": "modified", "additions": 66, "deletions": 17, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/2f5d864c086df35a57b65400b2e0f3f90e52d1ea/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f5d864c086df35a57b65400b2e0f3f90e52d1ea/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=2f5d864c086df35a57b65400b2e0f3f90e52d1ea", "patch": "@@ -144,22 +144,56 @@ impl From<io::Error> for ErrorKind {\n     }\n }\n \n+/// Result of formatting a snippet of code along with ranges of lines that didn't get formatted,\n+/// i.e., that got returned as they were originally.\n+#[derive(Debug)]\n+struct FormattedSnippet {\n+    snippet: String,\n+    non_formatted_ranges: Vec<(usize, usize)>,\n+}\n+\n+impl FormattedSnippet {\n+    /// In case the snippet needed to be wrapped in a function, this shifts down the ranges of\n+    /// non-formatted code.\n+    fn unwrap_code_block(&mut self) {\n+        self.non_formatted_ranges\n+            .iter_mut()\n+            .for_each(|(low, high)| {\n+                *low -= 1;\n+                *high -= 1;\n+            });\n+    }\n+\n+    /// Returns true if the line n did not get formatted.\n+    fn is_line_non_formatted(&self, n: usize) -> bool {\n+        self.non_formatted_ranges\n+            .iter()\n+            .any(|(low, high)| *low <= n && n <= *high)\n+    }\n+}\n+\n /// Reports on any issues that occurred during a run of Rustfmt.\n ///\n /// Can be reported to the user via its `Display` implementation of `print_fancy`.\n #[derive(Clone)]\n pub struct FormatReport {\n     // Maps stringified file paths to their associated formatting errors.\n     internal: Rc<RefCell<(FormatErrorMap, ReportedErrors)>>,\n+    non_formatted_ranges: Vec<(usize, usize)>,\n }\n \n impl FormatReport {\n     fn new() -> FormatReport {\n         FormatReport {\n             internal: Rc::new(RefCell::new((HashMap::new(), ReportedErrors::default()))),\n+            non_formatted_ranges: Vec::new(),\n         }\n     }\n \n+    fn add_non_formatted_ranges(&mut self, mut ranges: Vec<(usize, usize)>) {\n+        self.non_formatted_ranges.append(&mut ranges);\n+    }\n+\n     fn append(&self, f: FileName, mut v: Vec<FormattingError>) {\n         self.track_errors(&v);\n         self.internal\n@@ -349,37 +383,44 @@ impl fmt::Display for FormatReport {\n \n /// Format the given snippet. The snippet is expected to be *complete* code.\n /// When we cannot parse the given snippet, this function returns `None`.\n-fn format_snippet(snippet: &str, config: &Config) -> Option<String> {\n+fn format_snippet(snippet: &str, config: &Config) -> Option<FormattedSnippet> {\n     let mut config = config.clone();\n-    let out = panic::catch_unwind(|| {\n+    panic::catch_unwind(|| {\n         let mut out: Vec<u8> = Vec::with_capacity(snippet.len() * 2);\n         config.set().emit_mode(config::EmitMode::Stdout);\n         config.set().verbose(Verbosity::Quiet);\n         config.set().hide_parse_errors(true);\n-        let formatting_error = {\n+\n+        let (formatting_error, result) = {\n             let input = Input::Text(snippet.into());\n             let mut session = Session::new(config, Some(&mut out));\n             let result = session.format(input);\n-            session.errors.has_macro_format_failure\n-                || session.out.as_ref().unwrap().is_empty() && !snippet.is_empty()\n-                || result.is_err()\n+            (\n+                session.errors.has_macro_format_failure\n+                    || session.out.as_ref().unwrap().is_empty() && !snippet.is_empty()\n+                    || result.is_err(),\n+                result,\n+            )\n         };\n         if formatting_error {\n             None\n         } else {\n-            Some(out)\n+            String::from_utf8(out).ok().map(|snippet| FormattedSnippet {\n+                snippet,\n+                non_formatted_ranges: result.unwrap().non_formatted_ranges,\n+            })\n         }\n     })\n-    .ok()??; // The first try operator handles the error from catch_unwind,\n-             // whereas the second one handles None from the closure.\n-    String::from_utf8(out).ok()\n+    // Discard panics encountered while formatting the snippet\n+    // The ? operator is needed to remove the extra Option\n+    .ok()?\n }\n \n /// Format the given code block. Mainly targeted for code block in comment.\n /// The code block may be incomplete (i.e. parser may be unable to parse it).\n /// To avoid panic in parser, we wrap the code block with a dummy function.\n /// The returned code block does *not* end with newline.\n-fn format_code_block(code_snippet: &str, config: &Config) -> Option<String> {\n+fn format_code_block(code_snippet: &str, config: &Config) -> Option<FormattedSnippet> {\n     const FN_MAIN_PREFIX: &str = \"fn main() {\\n\";\n \n     fn enclose_in_main_block(s: &str, config: &Config) -> String {\n@@ -412,13 +453,18 @@ fn format_code_block(code_snippet: &str, config: &Config) -> Option<String> {\n     config_with_unix_newline\n         .set()\n         .newline_style(NewlineStyle::Unix);\n-    let formatted = format_snippet(&snippet, &config_with_unix_newline)?;\n+    let mut formatted = format_snippet(&snippet, &config_with_unix_newline)?;\n+    // Remove wrapping main block\n+    formatted.unwrap_code_block();\n \n     // Trim \"fn main() {\" on the first line and \"}\" on the last line,\n     // then unindent the whole code block.\n-    let block_len = formatted.rfind('}').unwrap_or(formatted.len());\n+    let block_len = formatted\n+        .snippet\n+        .rfind('}')\n+        .unwrap_or(formatted.snippet.len());\n     let mut is_indented = true;\n-    for (kind, ref line) in LineClasses::new(&formatted[FN_MAIN_PREFIX.len()..block_len]) {\n+    for (kind, ref line) in LineClasses::new(&formatted.snippet[FN_MAIN_PREFIX.len()..block_len]) {\n         if !is_first {\n             result.push('\\n');\n         } else {\n@@ -451,7 +497,10 @@ fn format_code_block(code_snippet: &str, config: &Config) -> Option<String> {\n         result.push_str(trimmed_line);\n         is_indented = !kind.is_string() || line.ends_with('\\\\');\n     }\n-    Some(result)\n+    Some(FormattedSnippet {\n+        snippet: result,\n+        non_formatted_ranges: formatted.non_formatted_ranges,\n+    })\n }\n \n /// A session is a run of rustfmt across a single or multiple inputs.\n@@ -571,10 +620,10 @@ mod unit_tests {\n \n     fn test_format_inner<F>(formatter: F, input: &str, expected: &str) -> bool\n     where\n-        F: Fn(&str, &Config) -> Option<String>,\n+        F: Fn(&str, &Config) -> Option<FormattedSnippet>,\n     {\n         let output = formatter(input, &Config::default());\n-        output.is_some() && output.unwrap() == expected\n+        output.is_some() && output.unwrap().snippet == expected\n     }\n \n     #[test]"}, {"sha": "d378bb8ffb1499595184c6c96034906579d53f7d", "filename": "src/macros.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2f5d864c086df35a57b65400b2e0f3f90e52d1ea/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f5d864c086df35a57b65400b2e0f3f90e52d1ea/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=2f5d864c086df35a57b65400b2e0f3f90e52d1ea", "patch": "@@ -1323,7 +1323,7 @@ impl MacroBranch {\n         config.set().max_width(new_width);\n \n         // First try to format as items, then as statements.\n-        let new_body = match ::format_snippet(&body_str, &config) {\n+        let new_body_snippet = match ::format_snippet(&body_str, &config) {\n             Some(new_body) => new_body,\n             None => {\n                 let new_width = new_width + config.tab_spaces();\n@@ -1334,15 +1334,23 @@ impl MacroBranch {\n                 }\n             }\n         };\n-        let new_body = wrap_str(new_body, config.max_width(), shape)?;\n+        let new_body = wrap_str(\n+            new_body_snippet.snippet.to_string(),\n+            config.max_width(),\n+            shape,\n+        )?;\n \n         // Indent the body since it is in a block.\n         let indent_str = body_indent.to_string(&config);\n         let mut new_body = LineClasses::new(new_body.trim_right())\n+            .enumerate()\n             .fold(\n                 (String::new(), true),\n-                |(mut s, need_indent), (kind, ref l)| {\n-                    if !l.is_empty() && need_indent {\n+                |(mut s, need_indent), (i, (kind, ref l))| {\n+                    if !l.is_empty()\n+                        && need_indent\n+                        && !new_body_snippet.is_line_non_formatted(i + 1)\n+                    {\n                         s += &indent_str;\n                     }\n                     (s + l + \"\\n\", !kind.is_string() || l.ends_with('\\\\'))"}, {"sha": "b286465b2765ffcf5cc74fe5f210d1534638ba34", "filename": "src/visitor.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/2f5d864c086df35a57b65400b2e0f3f90e52d1ea/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f5d864c086df35a57b65400b2e0f3f90e52d1ea/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=2f5d864c086df35a57b65400b2e0f3f90e52d1ea", "patch": "@@ -29,7 +29,7 @@ use source_map::{LineRangeUtils, SpanUtils};\n use spanned::Spanned;\n use utils::{\n     self, contains_skip, count_newlines, inner_attributes, mk_sp, ptr_vec_to_ref_vec,\n-    rewrite_ident, trim_left_preserve_layout, DEPR_SKIP_ANNOTATION,\n+    rewrite_ident, DEPR_SKIP_ANNOTATION,\n };\n use {ErrorKind, FormatReport, FormattingError};\n \n@@ -71,6 +71,8 @@ pub struct FmtVisitor<'a> {\n     pub is_if_else_block: bool,\n     pub snippet_provider: &'a SnippetProvider<'a>,\n     pub line_number: usize,\n+    /// List of 1-based line ranges which were annotated with skip\n+    /// Both bounds are inclusifs.\n     pub skipped_range: Vec<(usize, usize)>,\n     pub macro_rewrite_failure: bool,\n     pub(crate) report: FormatReport,\n@@ -109,8 +111,9 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                 self.format_missing(stmt.span.hi());\n             }\n             ast::StmtKind::Local(..) | ast::StmtKind::Expr(..) | ast::StmtKind::Semi(..) => {\n-                if contains_skip(get_attrs_from_stmt(stmt)) {\n-                    self.push_skipped_with_span(stmt.span());\n+                let attrs = get_attrs_from_stmt(stmt);\n+                if contains_skip(attrs) {\n+                    self.push_skipped_with_span(attrs, stmt.span());\n                 } else {\n                     let shape = self.shape();\n                     let rewrite = self.with_context(|ctx| stmt.rewrite(&ctx, shape));\n@@ -120,7 +123,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n             ast::StmtKind::Mac(ref mac) => {\n                 let (ref mac, _macro_style, ref attrs) = **mac;\n                 if self.visit_attrs(attrs, ast::AttrStyle::Outer) {\n-                    self.push_skipped_with_span(stmt.span());\n+                    self.push_skipped_with_span(attrs, stmt.span());\n                 } else {\n                     self.visit_mac(mac, None, MacroPosition::Statement);\n                 }\n@@ -328,14 +331,14 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n             // For use items, skip rewriting attributes. Just check for a skip attribute.\n             ast::ItemKind::Use(..) => {\n                 if contains_skip(attrs) {\n-                    self.push_skipped_with_span(item.span());\n+                    self.push_skipped_with_span(attrs.as_slice(), item.span());\n                     return;\n                 }\n             }\n             // Module is inline, in this case we treat it like any other item.\n             _ if !is_mod_decl(item) => {\n                 if self.visit_attrs(&item.attrs, ast::AttrStyle::Outer) {\n-                    self.push_skipped_with_span(item.span());\n+                    self.push_skipped_with_span(item.attrs.as_slice(), item.span());\n                     return;\n                 }\n             }\n@@ -354,7 +357,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n             }\n             _ => {\n                 if self.visit_attrs(&item.attrs, ast::AttrStyle::Outer) {\n-                    self.push_skipped_with_span(item.span());\n+                    self.push_skipped_with_span(item.attrs.as_slice(), item.span());\n                     return;\n                 }\n             }\n@@ -471,7 +474,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         skip_out_of_file_lines_range_visitor!(self, ti.span);\n \n         if self.visit_attrs(&ti.attrs, ast::AttrStyle::Outer) {\n-            self.push_skipped_with_span(ti.span());\n+            self.push_skipped_with_span(ti.attrs.as_slice(), ti.span());\n             return;\n         }\n \n@@ -515,7 +518,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         skip_out_of_file_lines_range_visitor!(self, ii.span);\n \n         if self.visit_attrs(&ii.attrs, ast::AttrStyle::Outer) {\n-            self.push_skipped_with_span(ii.span());\n+            self.push_skipped_with_span(ii.attrs.as_slice(), ii.span());\n             return;\n         }\n \n@@ -574,16 +577,9 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n     }\n \n     #[allow(clippy::needless_pass_by_value)]\n-    fn push_rewrite_inner(&mut self, span: Span, rewrite: Option<String>, is_skipped: bool) {\n+    fn push_rewrite_inner(&mut self, span: Span, rewrite: Option<String>) {\n         if let Some(ref s) = rewrite {\n             self.push_str(s);\n-        } else if is_skipped {\n-            // in case the code block (e.g., inside a macro or a doc) is skipped a minimum of\n-            // leading whitespaces is trimmed so that the code layout is kept but allows it to\n-            // be indented as necessary\n-            let snippet =\n-                trim_left_preserve_layout(self.snippet(span), &self.block_indent, self.config);\n-            self.push_str(&snippet);\n         } else {\n             let snippet = self.snippet(span);\n             self.push_str(snippet);\n@@ -593,13 +589,20 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n \n     pub fn push_rewrite(&mut self, span: Span, rewrite: Option<String>) {\n         self.format_missing_with_indent(source!(self, span).lo());\n-        self.push_rewrite_inner(span, rewrite, false);\n+        self.push_rewrite_inner(span, rewrite);\n     }\n \n-    pub fn push_skipped_with_span(&mut self, span: Span) {\n-        self.format_missing_with_indent(source!(self, span).lo());\n-        let lo = self.line_number + 1;\n-        self.push_rewrite_inner(span, None, true);\n+    pub fn push_skipped_with_span(&mut self, attrs: &[ast::Attribute], item_span: Span) {\n+        self.format_missing_with_indent(source!(self, item_span).lo());\n+        // do not take into account the lines with attributes as part of the skipped range\n+        let attrs_end = attrs\n+            .iter()\n+            .map(|attr| self.source_map.lookup_char_pos(attr.span().hi()).line)\n+            .max()\n+            .unwrap_or(1);\n+        // Add 1 to get the line past the last attribute\n+        let lo = attrs_end + 1;\n+        self.push_rewrite_inner(item_span, None);\n         let hi = self.line_number + 1;\n         self.skipped_range.push((lo, hi));\n     }"}, {"sha": "f6331cd6a02c22e4cb03dbd1c169553ef6ab2045", "filename": "tests/source/issue-3105.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9c75a15f4c81a6e412844f85d6d24541a88b49e7/tests%2Fsource%2Fissue-3105.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c75a15f4c81a6e412844f85d6d24541a88b49e7/tests%2Fsource%2Fissue-3105.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fissue-3105.rs?ref=9c75a15f4c81a6e412844f85d6d24541a88b49e7", "patch": "@@ -1,30 +0,0 @@\n-// rustfmt-wrap_comments: true\n-\n-/// ```\n-/// pub unsafe fn _mm256_shufflehi_epi16(a: __m256i, imm8: i32) -> __m256i {\n-///     let imm8 = (imm8 & 0xFF) as u8;\n-///     let a = a.as_i16x16();\n-///     macro_rules! shuffle_done {\n-///         ($x01:expr, $x23:expr, $x45:expr, $x67:expr) => {\n-///             #[cfg_attr(rustfmt, rustfmt_skip)]\n-///       simd_shuffle16(a, a, [\n-///           0, 1, 2, 3, 4+$x01, 4+$x23, 4+$x45, 4+$x67,\n-///           8, 9, 10, 11, 12+$x01, 12+$x23, 12+$x45, 12+$x67\n-///       ]);\n-///         };\n-///     }\n-/// }\n-/// ```\n-pub unsafe fn _mm256_shufflehi_epi16(a: __m256i, imm8: i32) -> __m256i {\n-    let imm8 = (imm8 & 0xFF) as u8;\n-    let a = a.as_i16x16();\n-    macro_rules! shuffle_done {\n-        ($x01:expr, $x23:expr, $x45:expr, $x67:expr) => {\n-            #[cfg_attr(rustfmt, rustfmt_skip)]\n-                         simd_shuffle16(a, a, [\n-                             0, 1, 2, 3, 4+$x01, 4+$x23, 4+$x45, 4+$x67,\n-                             8, 9, 10, 11, 12+$x01, 12+$x23, 12+$x45, 12+$x67\n-                         ]);\n-        };\n-    }\n-}"}, {"sha": "4f1123805b82708738009555869f89b29c96f887", "filename": "tests/target/issue-3105.rs", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2f5d864c086df35a57b65400b2e0f3f90e52d1ea/tests%2Ftarget%2Fissue-3105.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f5d864c086df35a57b65400b2e0f3f90e52d1ea/tests%2Ftarget%2Fissue-3105.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-3105.rs?ref=2f5d864c086df35a57b65400b2e0f3f90e52d1ea", "patch": "@@ -1,16 +1,19 @@\n // rustfmt-wrap_comments: true\n \n+/// Although the indentation of the skipped method is off, it shouldn't be\n+/// changed.\n+///\n /// ```\n /// pub unsafe fn _mm256_shufflehi_epi16(a: __m256i, imm8: i32) -> __m256i {\n ///     let imm8 = (imm8 & 0xFF) as u8;\n ///     let a = a.as_i16x16();\n ///     macro_rules! shuffle_done {\n ///         ($x01:expr, $x23:expr, $x45:expr, $x67:expr) => {\n ///             #[cfg_attr(rustfmt, rustfmt_skip)]\n-///             simd_shuffle16(a, a, [\n-///                 0, 1, 2, 3, 4+$x01, 4+$x23, 4+$x45, 4+$x67,\n-///                 8, 9, 10, 11, 12+$x01, 12+$x23, 12+$x45, 12+$x67\n-///             ]);\n+///       simd_shuffle16(a, a, [\n+///           0, 1, 2, 3, 4+$x01, 4+$x23, 4+$x45, 4+$x67,\n+///           8, 9, 10, 11, 12+$x01, 12+$x23, 12+$x45, 12+$x67\n+///       ]);\n ///         };\n ///     }\n /// }\n@@ -21,7 +24,22 @@ pub unsafe fn _mm256_shufflehi_epi16(a: __m256i, imm8: i32) -> __m256i {\n     macro_rules! shuffle_done {\n         ($x01:expr, $x23:expr, $x45:expr, $x67:expr) => {\n             #[cfg_attr(rustfmt, rustfmt_skip)]\n-            simd_shuffle16(a, a, [\n+                         simd_shuffle16(a, a, [\n+                             0, 1, 2, 3, 4+$x01, 4+$x23, 4+$x45, 4+$x67,\n+                             8, 9, 10, 11, 12+$x01, 12+$x23, 12+$x45, 12+$x67\n+                         ]);\n+        };\n+    }\n+}\n+\n+/// The skipped method shouldn't right-shift\n+pub unsafe fn _mm256_shufflehi_epi32(a: __m256i, imm8: i32) -> __m256i {\n+    let imm8 = (imm8 & 0xFF) as u8;\n+    let a = a.as_i16x16();\n+    macro_rules! shuffle_done {\n+        ($x01:expr, $x23:expr, $x45:expr, $x67:expr) => {\n+            #[cfg_attr(rustfmt, rustfmt_skip)]\n+            simd_shuffle32(a, a, [\n                 0, 1, 2, 3, 4+$x01, 4+$x23, 4+$x45, 4+$x67,\n                 8, 9, 10, 11, 12+$x01, 12+$x23, 12+$x45, 12+$x67\n             ]);"}]}