{"sha": "2487e164aeeeedaba78f597724a137959b1fb299", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0ODdlMTY0YWVlZWVkYWJhNzhmNTk3NzI0YTEzNzk1OWIxZmIyOTk=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-09-30T21:09:46Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-10-02T13:36:01Z"}, "message": "rustrt: remove local_heap implementation.", "tree": {"sha": "c6472fd280224944c4d9b0a57f818afd541d1748", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6472fd280224944c4d9b0a57f818afd541d1748"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2487e164aeeeedaba78f597724a137959b1fb299", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2487e164aeeeedaba78f597724a137959b1fb299", "html_url": "https://github.com/rust-lang/rust/commit/2487e164aeeeedaba78f597724a137959b1fb299", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2487e164aeeeedaba78f597724a137959b1fb299/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "382f1bceb4e2a0496171f52d114a98ff8a86f9b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/382f1bceb4e2a0496171f52d114a98ff8a86f9b7", "html_url": "https://github.com/rust-lang/rust/commit/382f1bceb4e2a0496171f52d114a98ff8a86f9b7"}], "stats": {"total": 392, "additions": 11, "deletions": 381}, "files": [{"sha": "ad1eac41e4d6b444b2624fdda3bdd4b4fa80f3a7", "filename": "src/librustrt/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2487e164aeeeedaba78f597724a137959b1fb299/src%2Flibrustrt%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2487e164aeeeedaba78f597724a137959b1fb299/src%2Flibrustrt%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flib.rs?ref=2487e164aeeeedaba78f597724a137959b1fb299", "patch": "@@ -58,7 +58,6 @@ pub mod c_str;\n pub mod exclusive;\n pub mod local;\n pub mod local_data;\n-pub mod local_heap;\n pub mod mutex;\n pub mod rtio;\n pub mod stack;\n@@ -105,9 +104,8 @@ pub static DEFAULT_ERROR_CODE: int = 101;\n \n /// One-time runtime initialization.\n ///\n-/// Initializes global state, including frobbing\n-/// the crate's logging flags, registering GC\n-/// metadata, and storing the process arguments.\n+/// Initializes global state, including frobbing the crate's logging flags,\n+/// and storing the process arguments.\n pub fn init(argc: int, argv: *const *const u8) {\n     // FIXME: Derefing these pointers is not safe.\n     // Need to propagate the unsafety to `start`."}, {"sha": "0e84e9c0097f55a8bbea436827aa168b07a520a3", "filename": "src/librustrt/local_heap.rs", "status": "removed", "additions": 0, "deletions": 345, "changes": 345, "blob_url": "https://github.com/rust-lang/rust/blob/382f1bceb4e2a0496171f52d114a98ff8a86f9b7/src%2Flibrustrt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382f1bceb4e2a0496171f52d114a98ff8a86f9b7/src%2Flibrustrt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_heap.rs?ref=382f1bceb4e2a0496171f52d114a98ff8a86f9b7", "patch": "@@ -1,345 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The local, garbage collected heap\n-\n-use core::prelude::*;\n-\n-use alloc::libc_heap;\n-use alloc::util;\n-use libc::{c_void, free};\n-\n-use core::mem;\n-use core::ptr;\n-use core::raw;\n-use local::Local;\n-use task::Task;\n-\n-static RC_IMMORTAL : uint = 0x77777777;\n-\n-pub type Box = raw::GcBox<()>;\n-\n-pub struct MemoryRegion {\n-    live_allocations: uint,\n-}\n-\n-pub struct LocalHeap {\n-    memory_region: MemoryRegion,\n-    live_allocs: *mut raw::GcBox<()>,\n-}\n-\n-impl LocalHeap {\n-    pub fn new() -> LocalHeap {\n-        LocalHeap {\n-            memory_region: MemoryRegion { live_allocations: 0 },\n-            live_allocs: ptr::null_mut(),\n-        }\n-    }\n-\n-    #[inline]\n-    #[allow(deprecated)]\n-    pub fn alloc(&mut self,\n-                 drop_glue: fn(*mut u8),\n-                 size: uint,\n-                 align: uint) -> *mut Box {\n-        let total_size = util::get_box_size(size, align);\n-        let alloc = self.memory_region.malloc(total_size);\n-        {\n-            // Make sure that we can't use `mybox` outside of this scope\n-            let mybox: &mut Box = unsafe { mem::transmute(alloc) };\n-            // Clear out this box, and move it to the front of the live\n-            // allocations list\n-            mybox.drop_glue = drop_glue;\n-            mybox.ref_count = 1;\n-            mybox.prev = ptr::null_mut();\n-            mybox.next = self.live_allocs;\n-            if !self.live_allocs.is_null() {\n-                unsafe { (*self.live_allocs).prev = alloc; }\n-            }\n-            self.live_allocs = alloc;\n-        }\n-        return alloc;\n-    }\n-\n-    #[inline]\n-    pub fn realloc(&mut self, ptr: *mut Box, size: uint) -> *mut Box {\n-        // Make sure that we can't use `mybox` outside of this scope\n-        let total_size = size + mem::size_of::<Box>();\n-        let new_box = self.memory_region.realloc(ptr, total_size);\n-        {\n-            // Fix links because we could have moved around\n-            let mybox: &mut Box = unsafe { mem::transmute(new_box) };\n-            if !mybox.prev.is_null() {\n-                unsafe { (*mybox.prev).next = new_box; }\n-            }\n-            if !mybox.next.is_null() {\n-                unsafe { (*mybox.next).prev = new_box; }\n-            }\n-        }\n-        if self.live_allocs == ptr {\n-            self.live_allocs = new_box;\n-        }\n-        return new_box;\n-    }\n-\n-    #[inline]\n-    pub fn free(&mut self, alloc: *mut Box) {\n-        {\n-            // Make sure that we can't use `mybox` outside of this scope\n-            let mybox: &mut Box = unsafe { mem::transmute(alloc) };\n-\n-            // Unlink it from the linked list\n-            if !mybox.prev.is_null() {\n-                unsafe { (*mybox.prev).next = mybox.next; }\n-            }\n-            if !mybox.next.is_null() {\n-                unsafe { (*mybox.next).prev = mybox.prev; }\n-            }\n-            if self.live_allocs == alloc {\n-                self.live_allocs = mybox.next;\n-            }\n-        }\n-\n-        self.memory_region.free(alloc);\n-    }\n-\n-    /// Immortalize all pending allocations, forcing them to live forever.\n-    ///\n-    /// This function will freeze all allocations to prevent all pending\n-    /// allocations from being deallocated. This is used in preparation for when\n-    /// a task is about to destroy TLD.\n-    pub unsafe fn immortalize(&mut self) {\n-        let mut n_total_boxes = 0u;\n-\n-        // Pass 1: Make all boxes immortal.\n-        //\n-        // In this pass, nothing gets freed, so it does not matter whether\n-        // we read the next field before or after the callback.\n-        self.each_live_alloc(true, |_, alloc| {\n-            n_total_boxes += 1;\n-            (*alloc).ref_count = RC_IMMORTAL;\n-        });\n-\n-        if debug_mem() {\n-            // We do logging here w/o allocation.\n-            rterrln!(\"total boxes annihilated: {}\", n_total_boxes);\n-        }\n-    }\n-\n-    /// Continues deallocation of the all pending allocations in this arena.\n-    ///\n-    /// This is invoked from the destructor, and requires that `immortalize` has\n-    /// been called previously.\n-    unsafe fn annihilate(&mut self) {\n-        // Pass 2: Drop all boxes.\n-        //\n-        // In this pass, unique-managed boxes may get freed, but not\n-        // managed boxes, so we must read the `next` field *after* the\n-        // callback, as the original value may have been freed.\n-        self.each_live_alloc(false, |_, alloc| {\n-            let drop_glue = (*alloc).drop_glue;\n-            let data = &mut (*alloc).data as *mut ();\n-            drop_glue(data as *mut u8);\n-        });\n-\n-        // Pass 3: Free all boxes.\n-        //\n-        // In this pass, managed boxes may get freed (but not\n-        // unique-managed boxes, though I think that none of those are\n-        // left), so we must read the `next` field before, since it will\n-        // not be valid after.\n-        self.each_live_alloc(true, |me, alloc| {\n-            me.free(alloc);\n-        });\n-    }\n-\n-    unsafe fn each_live_alloc(&mut self, read_next_before: bool,\n-                              f: |&mut LocalHeap, alloc: *mut raw::GcBox<()>|) {\n-        //! Walks the internal list of allocations\n-\n-        let mut alloc = self.live_allocs;\n-        while alloc != ptr::null_mut() {\n-            let next_before = (*alloc).next;\n-\n-            f(self, alloc);\n-\n-            if read_next_before {\n-                alloc = next_before;\n-            } else {\n-                alloc = (*alloc).next;\n-            }\n-        }\n-    }\n-}\n-\n-impl Drop for LocalHeap {\n-    fn drop(&mut self) {\n-        unsafe { self.annihilate() }\n-        assert!(self.live_allocs.is_null());\n-    }\n-}\n-\n-struct AllocHeader;\n-\n-impl AllocHeader {\n-    fn init(&mut self, _size: u32) {}\n-    fn assert_sane(&self) {}\n-    fn update_size(&mut self, _size: u32) {}\n-\n-    fn as_box(&mut self) -> *mut Box {\n-        let myaddr: uint = unsafe { mem::transmute(self) };\n-        (myaddr + AllocHeader::size()) as *mut Box\n-    }\n-\n-    fn size() -> uint {\n-        // For some platforms, 16 byte alignment is required.\n-        let ptr_size = 16;\n-        let header_size = mem::size_of::<AllocHeader>();\n-        return (header_size + ptr_size - 1) / ptr_size * ptr_size;\n-    }\n-\n-    fn from(a_box: *mut Box) -> *mut AllocHeader {\n-        (a_box as uint - AllocHeader::size()) as *mut AllocHeader\n-    }\n-}\n-\n-#[cfg(unix)]\n-fn debug_mem() -> bool {\n-    // FIXME: Need to port the environment struct to newsched\n-    false\n-}\n-\n-#[cfg(windows)]\n-fn debug_mem() -> bool {\n-    false\n-}\n-\n-impl MemoryRegion {\n-    #[inline]\n-    fn malloc(&mut self, size: uint) -> *mut Box {\n-        let total_size = size + AllocHeader::size();\n-        let alloc: *mut AllocHeader = unsafe {\n-            libc_heap::malloc_raw(total_size) as *mut AllocHeader\n-        };\n-\n-        let alloc: &mut AllocHeader = unsafe { mem::transmute(alloc) };\n-        alloc.init(size as u32);\n-        self.claim(alloc);\n-        self.live_allocations += 1;\n-\n-        return alloc.as_box();\n-    }\n-\n-    #[inline]\n-    fn realloc(&mut self, alloc: *mut Box, size: uint) -> *mut Box {\n-        rtassert!(!alloc.is_null());\n-        let orig_alloc = AllocHeader::from(alloc);\n-        unsafe { (*orig_alloc).assert_sane(); }\n-\n-        let total_size = size + AllocHeader::size();\n-        let alloc: *mut AllocHeader = unsafe {\n-            libc_heap::realloc_raw(orig_alloc as *mut u8, total_size) as *mut AllocHeader\n-        };\n-\n-        let alloc: &mut AllocHeader = unsafe { mem::transmute(alloc) };\n-        alloc.assert_sane();\n-        alloc.update_size(size as u32);\n-        self.update(alloc, orig_alloc as *mut AllocHeader);\n-        return alloc.as_box();\n-    }\n-\n-    #[inline]\n-    fn free(&mut self, alloc: *mut Box) {\n-        rtassert!(!alloc.is_null());\n-        let alloc = AllocHeader::from(alloc);\n-        unsafe {\n-            (*alloc).assert_sane();\n-            self.release(mem::transmute(alloc));\n-            rtassert!(self.live_allocations > 0);\n-            self.live_allocations -= 1;\n-            free(alloc as *mut c_void)\n-        }\n-    }\n-\n-    #[inline]\n-    fn claim(&mut self, _alloc: &mut AllocHeader) {}\n-    #[inline]\n-    fn release(&mut self, _alloc: &AllocHeader) {}\n-    #[inline]\n-    fn update(&mut self, _alloc: &mut AllocHeader, _orig: *mut AllocHeader) {}\n-}\n-\n-impl Drop for MemoryRegion {\n-    fn drop(&mut self) {\n-        if self.live_allocations != 0 {\n-            rtabort!(\"leaked managed memory ({} objects)\", self.live_allocations);\n-        }\n-    }\n-}\n-\n-#[cfg(not(test))]\n-#[lang=\"malloc\"]\n-#[inline]\n-pub unsafe fn local_malloc_(drop_glue: fn(*mut u8), size: uint,\n-                            align: uint) -> *mut u8 {\n-    local_malloc(drop_glue, size, align)\n-}\n-\n-#[inline]\n-pub unsafe fn local_malloc(drop_glue: fn(*mut u8), size: uint,\n-                           align: uint) -> *mut u8 {\n-    // FIXME: Unsafe borrow for speed. Lame.\n-    let task: Option<*mut Task> = Local::try_unsafe_borrow();\n-    match task {\n-        Some(task) => {\n-            (*task).heap.alloc(drop_glue, size, align) as *mut u8\n-        }\n-        None => rtabort!(\"local malloc outside of task\")\n-    }\n-}\n-\n-#[cfg(not(test))]\n-#[lang=\"free\"]\n-#[inline]\n-pub unsafe fn local_free_(ptr: *mut u8) {\n-    local_free(ptr)\n-}\n-\n-// NB: Calls to free CANNOT be allowed to fail, as throwing an exception from\n-// inside a landing pad may corrupt the state of the exception handler. If a\n-// problem occurs, call exit instead.\n-#[inline]\n-pub unsafe fn local_free(ptr: *mut u8) {\n-    // FIXME: Unsafe borrow for speed. Lame.\n-    let task_ptr: Option<*mut Task> = Local::try_unsafe_borrow();\n-    match task_ptr {\n-        Some(task) => {\n-            (*task).heap.free(ptr as *mut Box)\n-        }\n-        None => rtabort!(\"local free outside of task\")\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    extern crate test;\n-    use self::test::Bencher;\n-    use std::gc::GC;\n-\n-    #[bench]\n-    fn alloc_managed_small(b: &mut Bencher) {\n-        b.iter(|| { box(GC) 10i });\n-    }\n-\n-    #[bench]\n-    fn alloc_managed_big(b: &mut Bencher) {\n-        b.iter(|| { box(GC) ([10i, ..1000]) });\n-    }\n-}"}, {"sha": "9e88d05884ce920b0025b711addd0ff1c46794fb", "filename": "src/librustrt/task.rs", "status": "modified", "additions": 9, "deletions": 32, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2487e164aeeeedaba78f597724a137959b1fb299/src%2Flibrustrt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2487e164aeeeedaba78f597724a137959b1fb299/src%2Flibrustrt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Ftask.rs?ref=2487e164aeeeedaba78f597724a137959b1fb299", "patch": "@@ -9,9 +9,8 @@\n // except according to those terms.\n \n //! Language-level runtime services that should reasonably expected\n-//! to be available 'everywhere'. Local heaps, GC, unwinding,\n-//! local storage, and logging. Even a 'freestanding' Rust would likely want\n-//! to implement this.\n+//! to be available 'everywhere'. Unwinding, local storage, and logging.\n+//! Even a 'freestanding' Rust would likely want to implement this.\n \n use alloc::arc::Arc;\n use alloc::boxed::{BoxAny, Box};\n@@ -27,7 +26,6 @@ use core::raw;\n use local_data;\n use Runtime;\n use local::Local;\n-use local_heap::LocalHeap;\n use rtio::LocalIo;\n use unwind;\n use unwind::Unwinder;\n@@ -95,8 +93,6 @@ use collections::str::SendStr;\n /// # }\n /// ```\n pub struct Task {\n-    pub heap: LocalHeap,\n-    pub gc: GarbageCollector,\n     pub storage: LocalStorage,\n     pub unwinder: Unwinder,\n     pub death: Death,\n@@ -132,7 +128,6 @@ pub struct TaskOpts {\n /// children tasks complete, recommend using a result future.\n pub type Result = ::core::result::Result<(), Box<Any + Send>>;\n \n-pub struct GarbageCollector;\n pub struct LocalStorage(pub Option<local_data::Map>);\n \n /// A handle to a blocked task. Usually this means having the Box<Task>\n@@ -163,8 +158,6 @@ impl Task {\n     /// task creation functions through libnative or libgreen.\n     pub fn new() -> Task {\n         Task {\n-            heap: LocalHeap::new(),\n-            gc: GarbageCollector,\n             storage: LocalStorage(None),\n             unwinder: Unwinder::new(),\n             death: Death::new(),\n@@ -264,32 +257,22 @@ impl Task {\n     /// already been destroyed and/or annihilated.\n     fn cleanup(self: Box<Task>, result: Result) -> Box<Task> {\n         // The first thing to do when cleaning up is to deallocate our local\n-        // resources, such as TLD and GC data.\n+        // resources, such as TLD.\n         //\n         // FIXME: there are a number of problems with this code\n         //\n         // 1. If any TLD object fails destruction, then all of TLD will leak.\n         //    This appears to be a consequence of #14875.\n         //\n-        // 2. Failing during GC annihilation aborts the runtime #14876.\n+        // 2. Setting a TLD key while destroying TLD will abort the runtime #14807.\n         //\n-        // 3. Setting a TLD key while destroying TLD or while destroying GC will\n-        //    abort the runtime #14807.\n-        //\n-        // 4. Invoking GC in GC destructors will abort the runtime #6996.\n-        //\n-        // 5. The order of destruction of TLD and GC matters, but either way is\n-        //    susceptible to leaks (see 3/4) #8302.\n+        // 3. The order of destruction of TLD matters, but either way is\n+        //    susceptible to leaks (see 2) #8302.\n         //\n         // That being said, there are a few upshots to this code\n         //\n         // 1. If TLD destruction fails, heap destruction will be attempted.\n-        //    There is a test for this at fail-during-tld-destroy.rs. Sadly the\n-        //    other way can't be tested due to point 2 above. Note that we must\n-        //    immortalize the heap first because if any deallocations are\n-        //    attempted while TLD is being dropped it will attempt to free the\n-        //    allocation from the wrong heap (because the current one has been\n-        //    replaced).\n+        //    There is a test for this at fail-during-tld-destroy.rs.\n         //\n         // 2. One failure in destruction is tolerable, so long as the task\n         //    didn't originally fail while it was running.\n@@ -301,15 +284,10 @@ impl Task {\n                 let &LocalStorage(ref mut optmap) = &mut task.storage;\n                 optmap.take()\n             };\n-            let mut heap = mem::replace(&mut task.heap, LocalHeap::new());\n-            unsafe { heap.immortalize() }\n             drop(task);\n \n             // First, destroy task-local storage. This may run user dtors.\n             drop(tld);\n-\n-            // Destroy remaining boxes. Also may run user dtors.\n-            drop(heap);\n         });\n \n         // If the above `run` block failed, then it must be the case that the\n@@ -327,9 +305,8 @@ impl Task {\n         Local::put(task);\n \n         // FIXME: this is running in a seriously constrained context. If this\n-        //        allocates GC or allocates TLD then it will likely abort the\n-        //        runtime. Similarly, if this fails, this will also likely abort\n-        //        the runtime.\n+        //        allocates TLD then it will likely abort the runtime. Similarly,\n+        //        if this fails, this will also likely abort the runtime.\n         //\n         //        This closure is currently limited to a channel send via the\n         //        standard library's task interface, but this needs"}]}