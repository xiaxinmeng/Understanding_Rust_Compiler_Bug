{"sha": "3200ce5a2e69518597badd2201d0c15effdf9893", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyMDBjZTVhMmU2OTUxODU5N2JhZGQyMjAxZDBjMTVlZmZkZjk4OTM=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-04-25T17:18:06Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-04-25T22:02:09Z"}, "message": "clarify docs for std:io::fs::Path::{is_dir,is_file,exists}; add lstat\n\nClarifies the interaction of `is_dir`, `is_file` and `exists` with\nsymbolic links.  Adds a convenience `lstat` function alongside of\n`stat`.  Removes references to conditions.\n\nCloses issue #12583.", "tree": {"sha": "69274ab1fd8b4a6dda30a7c9dd5f6e2796a0ff5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69274ab1fd8b4a6dda30a7c9dd5f6e2796a0ff5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3200ce5a2e69518597badd2201d0c15effdf9893", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3200ce5a2e69518597badd2201d0c15effdf9893", "html_url": "https://github.com/rust-lang/rust/commit/3200ce5a2e69518597badd2201d0c15effdf9893", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3200ce5a2e69518597badd2201d0c15effdf9893/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c3bdbe2e45739a5396316392ae3eb8c1d7a7434", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c3bdbe2e45739a5396316392ae3eb8c1d7a7434", "html_url": "https://github.com/rust-lang/rust/commit/6c3bdbe2e45739a5396316392ae3eb8c1d7a7434"}], "stats": {"total": 56, "additions": 28, "deletions": 28}, "files": [{"sha": "f9e189e4c80fe9a61079af80f47bceca62827e3d", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3200ce5a2e69518597badd2201d0c15effdf9893/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3200ce5a2e69518597badd2201d0c15effdf9893/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=3200ce5a2e69518597badd2201d0c15effdf9893", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -244,10 +244,6 @@ pub fn unlink(path: &Path) -> IoResult<()> {\n /// directory, etc. This function will traverse symlinks to query\n /// information about the destination file.\n ///\n-/// Returns a fully-filled out stat structure on success, and on failure it\n-/// will return a dummy stat structure (it is expected that the condition\n-/// raised is handled as well).\n-///\n /// # Example\n ///\n /// ```rust\n@@ -652,45 +648,41 @@ impl Seek for File {\n impl path::Path {\n     /// Get information on the file, directory, etc at this path.\n     ///\n-    /// Consult the `file::stat` documentation for more info.\n+    /// Consult the `fs::stat` documentation for more info.\n     ///\n     /// This call preserves identical runtime/error semantics with `file::stat`.\n     pub fn stat(&self) -> IoResult<FileStat> { stat(self) }\n \n-    /// Boolean value indicator whether the underlying file exists on the local\n-    /// filesystem. This will return true if the path points to either a\n-    /// directory or a file.\n+    /// Get information on the file, directory, etc at this path, not following\n+    /// symlinks.\n     ///\n-    /// # Error\n+    /// Consult the `fs::lstat` documentation for more info.\n     ///\n-    /// Will not raise a condition\n+    /// This call preserves identical runtime/error semantics with `file::lstat`.\n+    pub fn lstat(&self) -> IoResult<FileStat> { lstat(self) }\n+\n+    /// Boolean value indicator whether the underlying file exists on the local\n+    /// filesystem. Returns false in exactly the cases where `fs::stat` fails.\n     pub fn exists(&self) -> bool {\n         self.stat().is_ok()\n     }\n \n     /// Whether the underlying implementation (be it a file path, or something\n     /// else) points at a \"regular file\" on the FS. Will return false for paths\n     /// to non-existent locations or directories or other non-regular files\n-    /// (named pipes, etc).\n-    ///\n-    /// # Error\n-    ///\n-    /// Will not raise a condition\n+    /// (named pipes, etc). Follows links when making this determination.\n     pub fn is_file(&self) -> bool {\n         match self.stat() {\n             Ok(s) => s.kind == io::TypeFile,\n             Err(..) => false\n         }\n     }\n \n-    /// Whether the underlying implementation (be it a file path,\n-    /// or something else) is pointing at a directory in the underlying FS.\n-    /// Will return false for paths to non-existent locations or if the item is\n-    /// not a directory (eg files, named pipes, links, etc)\n-    ///\n-    /// # Error\n-    ///\n-    /// Will not raise a condition\n+    /// Whether the underlying implementation (be it a file path, or something\n+    /// else) is pointing at a directory in the underlying FS. Will return\n+    /// false for paths to non-existent locations or if the item is not a\n+    /// directory (eg files, named pipes, etc). Follows links when making this\n+    /// determination.\n     pub fn is_dir(&self) -> bool {\n         match self.stat() {\n             Ok(s) => s.kind == io::TypeDirectory,\n@@ -898,17 +890,21 @@ mod test {\n             let msg = \"hw\";\n             fs.write(msg.as_bytes()).unwrap();\n         }\n-        let stat_res = check!(stat(filename));\n-        assert_eq!(stat_res.kind, io::TypeFile);\n+        let stat_res_fn = check!(stat(filename));\n+        assert_eq!(stat_res_fn.kind, io::TypeFile);\n+        let stat_res_meth = check!(filename.stat());\n+        assert_eq!(stat_res_meth.kind, io::TypeFile);\n         check!(unlink(filename));\n     })\n \n     iotest!(fn file_test_stat_is_correct_on_is_dir() {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_stat_correct_on_is_dir\");\n         check!(mkdir(filename, io::UserRWX));\n-        let stat_res = check!(filename.stat());\n-        assert!(stat_res.kind == io::TypeDirectory);\n+        let stat_res_fn = check!(stat(filename));\n+        assert!(stat_res_fn.kind == io::TypeDirectory);\n+        let stat_res_meth = check!(filename.stat());\n+        assert!(stat_res_meth.kind == io::TypeDirectory);\n         check!(rmdir(filename));\n     })\n \n@@ -1139,6 +1135,7 @@ mod test {\n         check!(symlink(&input, &out));\n         if cfg!(not(windows)) {\n             assert_eq!(check!(lstat(&out)).kind, io::TypeSymlink);\n+            assert_eq!(check!(out.lstat()).kind, io::TypeSymlink);\n         }\n         assert_eq!(check!(stat(&out)).size, check!(stat(&input)).size);\n         assert_eq!(check!(File::open(&out).read_to_end()),\n@@ -1170,9 +1167,12 @@ mod test {\n         check!(link(&input, &out));\n         if cfg!(not(windows)) {\n             assert_eq!(check!(lstat(&out)).kind, io::TypeFile);\n+            assert_eq!(check!(out.lstat()).kind, io::TypeFile);\n             assert_eq!(check!(stat(&out)).unstable.nlink, 2);\n+            assert_eq!(check!(out.stat()).unstable.nlink, 2);\n         }\n         assert_eq!(check!(stat(&out)).size, check!(stat(&input)).size);\n+        assert_eq!(check!(stat(&out)).size, check!(input.stat()).size);\n         assert_eq!(check!(File::open(&out).read_to_end()),\n                    (Vec::from_slice(bytes!(\"foobar\"))));\n "}]}