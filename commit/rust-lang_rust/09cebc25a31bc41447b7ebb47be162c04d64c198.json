{"sha": "09cebc25a31bc41447b7ebb47be162c04d64c198", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5Y2ViYzI1YTMxYmM0MTQ0N2I3ZWJiNDdiZTE2MmMwNGQ2NGMxOTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-07T00:31:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-07T00:31:28Z"}, "message": "auto merge of #16999 : brson/rust/fannkuch, r=alexcrichton\n\nFrom the discussion on reddit:\r\nhttp://www.reddit.com/r/rust/comments/2fenlg/benchmark_improvement_fannkuchredux/\r\n\r\nThis adds two variants: the primary, that uses an unsafe block, and a secondary\r\nthat is completely safe.\r\n\r\nThe one with the unsafe block matches clang's performance and beats gcc's.", "tree": {"sha": "44e12b5b28db67496ca41509b7eb18778ffd760d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44e12b5b28db67496ca41509b7eb18778ffd760d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09cebc25a31bc41447b7ebb47be162c04d64c198", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09cebc25a31bc41447b7ebb47be162c04d64c198", "html_url": "https://github.com/rust-lang/rust/commit/09cebc25a31bc41447b7ebb47be162c04d64c198", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09cebc25a31bc41447b7ebb47be162c04d64c198/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38eb0e551411ba0d175a55ed6d01bb529d1c8684", "url": "https://api.github.com/repos/rust-lang/rust/commits/38eb0e551411ba0d175a55ed6d01bb529d1c8684", "html_url": "https://github.com/rust-lang/rust/commit/38eb0e551411ba0d175a55ed6d01bb529d1c8684"}, {"sha": "7e12e67936dd2ad12e529278344dab369ccb75a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e12e67936dd2ad12e529278344dab369ccb75a0", "html_url": "https://github.com/rust-lang/rust/commit/7e12e67936dd2ad12e529278344dab369ccb75a0"}], "stats": {"total": 186, "additions": 137, "deletions": 49}, "files": [{"sha": "cc2b01e3bb58b74dcb3193ea0410c71a8ec621be", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/09cebc25a31bc41447b7ebb47be162c04d64c198/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09cebc25a31bc41447b7ebb47be162c04d64c198/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=09cebc25a31bc41447b7ebb47be162c04d64c198", "patch": "@@ -806,7 +806,12 @@ impl<'a,T> MutableSlice<'a, T> for &'a mut [T] {\n         let mut i: uint = 0;\n         let ln = self.len();\n         while i < ln / 2 {\n-            self.swap(i, ln - i - 1);\n+            // Unsafe swap to avoid the bounds check in safe swap.\n+            unsafe {\n+                let pa: *mut T = self.unsafe_mut_ref(i);\n+                let pb: *mut T = self.unsafe_mut_ref(ln - i - 1);\n+                ptr::swap(pa, pb);\n+            }\n             i += 1;\n         }\n     }"}, {"sha": "f0798a9e7e82fe1d4f5158005e5803a1d7d24ff6", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 131, "deletions": 48, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/09cebc25a31bc41447b7ebb47be162c04d64c198/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09cebc25a31bc41447b7ebb47be162c04d64c198/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=09cebc25a31bc41447b7ebb47be162c04d64c198", "patch": "@@ -38,68 +38,151 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n-use std::cmp::max;\n+use std::{cmp, iter, mem};\n+use std::sync::Future;\n \n-fn fact(n: uint) -> uint {\n-    range(1, n + 1).fold(1, |accu, i| accu * i)\n+fn rotate(x: &mut [i32]) {\n+    let mut prev = x[0];\n+    for place in x.mut_iter().rev() {\n+        prev = mem::replace(place, prev)\n+    }\n }\n \n-fn fannkuch(n: uint, i: uint) -> (int, int) {\n-    let mut perm = Vec::from_fn(n, |e| ((n + e - i) % n + 1) as i32);\n-    let mut tperm = perm.clone();\n-    let mut count = Vec::from_elem(n, 0u);\n-    let mut perm_count = 0i;\n-    let mut checksum = 0;\n+fn next_permutation(perm: &mut [i32], count: &mut [i32]) {\n+    for i in range(1, perm.len()) {\n+        rotate(perm.mut_slice_to(i + 1));\n+        let count_i = &mut count[i];\n+        if *count_i >= i as i32 {\n+            *count_i = 0;\n+        } else {\n+            *count_i += 1;\n+            break\n+        }\n+    }\n+}\n+\n+struct P {\n+    p: [i32, .. 16],\n+}\n+\n+struct Perm {\n+    cnt: [i32, .. 16],\n+    fact: [u32, .. 16],\n+    n: u32,\n+    permcount: u32,\n+    perm: P,\n+}\n+\n+impl Perm {\n+    fn new(n: u32) -> Perm {\n+        let mut fact = [1, .. 16];\n+        for i in range(1, n as uint + 1) {\n+            fact[i] = fact[i - 1] * i as u32;\n+        }\n+        Perm {\n+            cnt: [0, .. 16],\n+            fact: fact,\n+            n: n,\n+            permcount: 0,\n+            perm: P { p: [0, .. 16 ] }\n+        }\n+    }\n+\n+    fn get(&mut self, mut idx: i32) -> P {\n+        let mut pp = [0u8, .. 16];\n+        self.permcount = idx as u32;\n+        for (i, place) in self.perm.p.mut_iter().enumerate() {\n+            *place = i as i32 + 1;\n+        }\n \n-    for countdown in range(1, fact(n - 1) + 1).rev() {\n-        for i in range(1, n) {\n-            let perm0 = *perm.get(0);\n-            for j in range(0, i) {\n-                *perm.get_mut(j) = *perm.get(j + 1);\n+        for i in range(1, self.n as uint).rev() {\n+            let d = idx / self.fact[i] as i32;\n+            self.cnt[i] = d;\n+            idx %= self.fact[i] as i32;\n+            for (place, val) in pp.mut_iter().zip(self.perm.p.slice_to(i + 1).iter()) {\n+                *place = (*val) as u8\n             }\n-            *perm.get_mut(i) = perm0;\n-\n-            let count_i = count.get_mut(i);\n-            if *count_i >= i {\n-                *count_i = 0;\n-            } else {\n-                *count_i += 1;\n-                break;\n+\n+            let d = d as uint;\n+            for j in range(0, i + 1) {\n+                self.perm.p[j] = if j + d <= i {pp[j + d]} else {pp[j+d-i-1]} as i32;\n             }\n         }\n \n-        tperm.clone_from(&perm);\n-        let mut flips_count = 0;\n-        loop {\n-            let k = *tperm.get(0);\n-            if k == 1 { break; }\n-            tperm.mut_slice_to(k as uint).reverse();\n-            flips_count += 1;\n+        self.perm\n+    }\n+\n+    fn count(&self) -> u32 { self.permcount }\n+    fn max(&self) -> u32 { self.fact[self.n as uint] }\n+\n+    fn next(&mut self) -> P {\n+        next_permutation(self.perm.p, self.cnt);\n+        self.permcount += 1;\n+\n+        self.perm\n+    }\n+}\n+\n+\n+fn reverse(tperm: &mut [i32], mut k: uint) {\n+    tperm.mut_slice_to(k).reverse()\n+}\n+\n+fn work(mut perm: Perm, n: uint, max: uint) -> (i32, i32) {\n+    let mut checksum = 0;\n+    let mut maxflips = 0;\n+\n+    let mut p = perm.get(n as i32);\n+\n+    while perm.count() < max as u32 {\n+        let mut flips = 0;\n+\n+        while p.p[0] != 1 {\n+            let k = p.p[0] as uint;\n+            reverse(p.p, k);\n+            flips += 1;\n         }\n-        perm_count = max(perm_count, flips_count);\n-        checksum += if countdown & 1 == 1 {flips_count} else {-flips_count}\n+\n+        checksum += if perm.count() % 2 == 0 {flips} else {-flips};\n+        maxflips = cmp::max(maxflips, flips);\n+\n+        p = perm.next();\n     }\n-    (checksum, perm_count)\n+\n+    (checksum, maxflips)\n }\n \n-fn main() {\n-    let n = std::os::args().as_slice()\n-                           .get(1)\n-                           .and_then(|arg| from_str(arg.as_slice()))\n-                           .unwrap_or(2u);\n-\n-    let (tx, rx) = channel();\n-    for i in range(0, n) {\n-        let tx = tx.clone();\n-        spawn(proc() tx.send(fannkuch(n, i)));\n+fn fannkuch(n: i32) -> (i32, i32) {\n+    let perm = Perm::new(n as u32);\n+\n+    let N = 4;\n+    let mut futures = vec![];\n+    let k = perm.max() / N;\n+\n+    for (i, j) in range(0, N).zip(iter::count(0, k)) {\n+        let max = cmp::min(j+k, perm.max());\n+\n+        futures.push(Future::spawn(proc() {\n+            work(perm, j as uint, max as uint)\n+        }))\n     }\n-    drop(tx);\n \n     let mut checksum = 0;\n-    let mut perm = 0;\n-    for (cur_cks, cur_perm) in rx.iter() {\n-        checksum += cur_cks;\n-        perm = max(perm, cur_perm);\n+    let mut maxflips = 0;\n+    for fut in futures.mut_iter() {\n+        let (cs, mf) = fut.get();\n+        checksum += cs;\n+        maxflips = cmp::max(maxflips, mf);\n     }\n-    println!(\"{}\\nPfannkuchen({}) = {}\", checksum, n, perm);\n+    (checksum, maxflips)\n+}\n+\n+fn main() {\n+    let n = std::os::args().as_slice()\n+        .get(1)\n+        .and_then(|arg| from_str(arg.as_slice()))\n+        .unwrap_or(2i32);\n+\n+    let (checksum, maxflips) = fannkuch(n);\n+    println!(\"{}\\nPfannkuchen({}) = {}\", checksum, n, maxflips);\n }"}]}