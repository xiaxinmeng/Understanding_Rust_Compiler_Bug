{"sha": "92927449595782926c4db5a579ba7e4c6952287d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyOTI3NDQ5NTk1NzgyOTI2YzRkYjVhNTc5YmE3ZTRjNjk1MjI4N2Q=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-23T15:09:52Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-23T15:11:35Z"}, "message": "Use the same type of record in ty::ty_fn and ty::method\n\nRemoves some more code duplication.", "tree": {"sha": "6e302a3294a7a389f234a71b60bc5dba2973a397", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e302a3294a7a389f234a71b60bc5dba2973a397"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92927449595782926c4db5a579ba7e4c6952287d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92927449595782926c4db5a579ba7e4c6952287d", "html_url": "https://github.com/rust-lang/rust/commit/92927449595782926c4db5a579ba7e4c6952287d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92927449595782926c4db5a579ba7e4c6952287d/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "970f5cc0e422a959aa6df9a2e3a545203b271cc8", "url": "https://api.github.com/repos/rust-lang/rust/commits/970f5cc0e422a959aa6df9a2e3a545203b271cc8", "html_url": "https://github.com/rust-lang/rust/commit/970f5cc0e422a959aa6df9a2e3a545203b271cc8"}], "stats": {"total": 606, "additions": 249, "deletions": 357}, "files": [{"sha": "5bea8e6ac80263ddc869a07ed3ce77270171940b", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/92927449595782926c4db5a579ba7e4c6952287d/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92927449595782926c4db5a579ba7e4c6952287d/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=92927449595782926c4db5a579ba7e4c6952287d", "patch": "@@ -253,13 +253,10 @@ fn get_tag_variants(_data: @[u8], def: ast::def_id, tcx: ty::ctxt,\n         let ctor_ty = item_type(item, external_crate_id, tcx, extres);\n         let arg_tys: [ty::t] = [];\n         alt ty::struct(tcx, ctor_ty) {\n-          ty::ty_fn(_, args, _, _, _) {\n-            for a: ty::arg in args { arg_tys += [a.ty]; }\n-          }\n-          _ {\n-            // Nullary tag variant.\n-\n+          ty::ty_fn(f) {\n+            for a: ty::arg in f.inputs { arg_tys += [a.ty]; }\n           }\n+          _ { /* Nullary tag variant. */ }\n         }\n         infos += [@{args: arg_tys, ctor_ty: ctor_ty, id: did}];\n     }"}, {"sha": "87dbb363da798471f135bd48ffe4b471e39e5610", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/92927449595782926c4db5a579ba7e4c6952287d/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92927449595782926c4db5a579ba7e4c6952287d/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=92927449595782926c4db5a579ba7e4c6952287d", "patch": "@@ -165,10 +165,7 @@ fn parse_constr<copy T>(st: @pstate, sd: str_def, pser: arg_parser<T>) ->\n }\n \n fn parse_ty_rust_fn(st: @pstate, sd: str_def, p: ast::proto) -> ty::t {\n-    let func = parse_ty_fn(st, sd);\n-    ret ty::mk_fn(st.tcx, p,\n-                  func.args, func.ty, func.cf,\n-                  func.cs);\n+    ret ty::mk_fn(st.tcx, {proto: p with parse_ty_fn(st, sd)});\n }\n \n fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n@@ -256,7 +253,7 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n       }\n       'N' {\n         let func = parse_ty_fn(st, sd);\n-        ret ty::mk_native_fn(st.tcx, func.args, func.ty);\n+        ret ty::mk_native_fn(st.tcx, func.inputs, func.output);\n       }\n       'O' {\n         assert (next(st) as char == '[');\n@@ -270,14 +267,8 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n             while peek(st) as char != '[' {\n                 name += str::unsafe_from_byte(next(st));\n             }\n-            let func = parse_ty_fn(st, sd);\n-            methods +=\n-                [{proto: proto,\n-                  ident: name,\n-                  inputs: func.args,\n-                  output: func.ty,\n-                  cf: func.cf,\n-                  constrs: func.cs}];\n+            methods += [{ident: name,\n+                         fty: {proto: proto with parse_ty_fn(st, sd)}}];\n         }\n         st.pos += 1u;\n         ret ty::mk_obj(st.tcx, methods);\n@@ -365,8 +356,7 @@ fn parse_hex(st: @pstate) -> uint {\n     ret n;\n }\n \n-fn parse_ty_fn(st: @pstate, sd: str_def) ->\n-   {args: [ty::arg], ty: ty::t, cf: ast::ret_style, cs: [@ty::constr]} {\n+fn parse_ty_fn(st: @pstate, sd: str_def) -> ty::fn_ty {\n     assert (next(st) as char == '[');\n     let inputs: [ty::arg] = [];\n     while peek(st) as char != ']' {\n@@ -383,7 +373,8 @@ fn parse_ty_fn(st: @pstate, sd: str_def) ->\n     st.pos += 1u; // eat the ']'\n     let cs = parse_constrs(st, sd);\n     let (ret_style, ret_ty) = parse_ret_ty(st, sd);\n-    ret {args: inputs, ty: ret_ty, cf: ret_style, cs: cs};\n+    ret {proto: ast::proto_bare, inputs: inputs, output: ret_ty,\n+         ret_style: ret_style, constraints: cs};\n }\n \n "}, {"sha": "6dd85e8785f06d2193966fe30722a5c92784d3c1", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/92927449595782926c4db5a579ba7e4c6952287d/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92927449595782926c4db5a579ba7e4c6952287d/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=92927449595782926c4db5a579ba7e4c6952287d", "patch": "@@ -143,20 +143,21 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         }\n         w.write_char(']');\n       }\n-      ty::ty_fn(proto, args, out, cf, constrs) {\n-        enc_proto(w, proto);\n-        enc_ty_fn(w, cx, args, out, cf, constrs);\n+      ty::ty_fn(f) {\n+        enc_proto(w, f.proto);\n+        enc_ty_fn(w, cx, f);\n       }\n       ty::ty_native_fn(args, out) {\n         w.write_char('N');\n-        enc_ty_fn(w, cx, args, out, return_val, []);\n+        enc_ty_fn(w, cx, {proto: proto_bare, inputs: args, output: out,\n+                          ret_style: return_val, constraints: []});\n       }\n       ty::ty_obj(methods) {\n         w.write_str(\"O[\");\n         for m: ty::method in methods {\n-            enc_proto(w, m.proto);\n+            enc_proto(w, m.fty.proto);\n             w.write_str(m.ident);\n-            enc_ty_fn(w, cx, m.inputs, m.output, m.cf, m.constrs);\n+            enc_ty_fn(w, cx, m.fty);\n         }\n         w.write_char(']');\n       }\n@@ -202,10 +203,9 @@ fn enc_proto(w: io::writer, proto: proto) {\n     }\n }\n \n-fn enc_ty_fn(w: io::writer, cx: @ctxt, args: [ty::arg], out: ty::t,\n-             cf: ret_style, constrs: [@ty::constr]) {\n+fn enc_ty_fn(w: io::writer, cx: @ctxt, ft: ty::fn_ty) {\n     w.write_char('[');\n-    for arg: ty::arg in args {\n+    for arg: ty::arg in ft.inputs {\n         alt arg.mode {\n           by_mut_ref. { w.write_char('&'); }\n           by_move. { w.write_char('-'); }\n@@ -217,16 +217,16 @@ fn enc_ty_fn(w: io::writer, cx: @ctxt, args: [ty::arg], out: ty::t,\n     }\n     w.write_char(']');\n     let colon = true;\n-    for c: @ty::constr in constrs {\n+    for c: @ty::constr in ft.constraints {\n         if colon {\n             w.write_char(':');\n             colon = false;\n         } else { w.write_char(';'); }\n         enc_constr(w, cx, c);\n     }\n-    alt cf {\n+    alt ft.ret_style {\n       noreturn. { w.write_char('!'); }\n-      _ { enc_ty(w, cx, out); }\n+      _ { enc_ty(w, cx, ft.output); }\n     }\n }\n "}, {"sha": "5e80f7b3dbb264e26a6c52b2ff8f795364e4f34b", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92927449595782926c4db5a579ba7e4c6952287d/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92927449595782926c4db5a579ba7e4c6952287d/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=92927449595782926c4db5a579ba7e4c6952287d", "patch": "@@ -518,9 +518,9 @@ fn ty_can_unsafely_include(cx: ctx, needle: unsafe_ty, haystack: ty::t,\n             for t in ts { if helper(tcx, needle, t, mut) { ret true; } }\n             ret false;\n           }\n-          ty::ty_fn(ast::proto_bare., _, _, _, _) { ret false; }\n+          ty::ty_fn({proto: ast::proto_bare., _}) { ret false; }\n           // These may contain anything.\n-          ty::ty_fn(_, _, _, _, _) | ty::ty_obj(_) { ret true; }\n+          ty::ty_fn(_) | ty::ty_obj(_) { ret true; }\n           // A type param may include everything, but can only be\n           // treated as opaque downstream, and is thus safe unless we\n           // saw mutable fields, in which case the whole thing can be\n@@ -558,7 +558,7 @@ fn copy_is_expensive(tcx: ty::ctxt, ty: ty::t) -> bool {\n           ty::ty_ptr(_) { 1u }\n           ty::ty_box(_) { 3u }\n           ty::ty_constr(t, _) | ty::ty_res(_, t, _) { score_ty(tcx, t) }\n-          ty::ty_fn(_, _, _, _, _) | ty::ty_native_fn(_, _) |\n+          ty::ty_fn(_) | ty::ty_native_fn(_, _) |\n           ty::ty_obj(_) { 4u }\n           ty::ty_str. | ty::ty_vec(_) | ty::ty_param(_, _) { 50u }\n           ty::ty_uniq(mt) { 1u + score_ty(tcx, mt.ty) }"}, {"sha": "afc9a901444fcda933c1a3cdbbb3c7fbcf16e4b0", "filename": "src/comp/middle/block_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92927449595782926c4db5a579ba7e4c6952287d/src%2Fcomp%2Fmiddle%2Fblock_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92927449595782926c4db5a579ba7e4c6952287d/src%2Fcomp%2Fmiddle%2Fblock_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fblock_use.rs?ref=92927449595782926c4db5a579ba7e4c6952287d", "patch": "@@ -13,7 +13,7 @@ fn check_crate(tcx: ty::ctxt, crate: @crate) {\n fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n     if !cx.allow_block {\n         alt ty::struct(cx.tcx, ty::expr_ty(cx.tcx, ex)) {\n-          ty::ty_fn(proto_block., _, _, _, _) {\n+          ty::ty_fn({proto: proto_block., _}) {\n             cx.tcx.sess.span_err(ex.span, \"expressions with block type \\\n                 can only appear in callee or (by-ref) argument position\");\n           }"}, {"sha": "10b4b096c870d3bc242a9939c0a11faf230816a4", "filename": "src/comp/middle/fn_usage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92927449595782926c4db5a579ba7e4c6952287d/src%2Fcomp%2Fmiddle%2Ffn_usage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92927449595782926c4db5a579ba7e4c6952287d/src%2Fcomp%2Fmiddle%2Ffn_usage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffn_usage.rs?ref=92927449595782926c4db5a579ba7e4c6952287d", "patch": "@@ -32,7 +32,7 @@ fn fn_usage_expr(expr: @ast::expr,\n         if !ctx.generic_bare_fn_legal\n             && ty::expr_has_ty_params(ctx.tcx, expr) {\n             alt ty::struct(ctx.tcx, ty::expr_ty(ctx.tcx, expr)) {\n-              ty::ty_fn(ast::proto_bare., _, _, _, _) {\n+              ty::ty_fn({proto: ast::proto_bare., _}) {\n                 ctx.tcx.sess.span_fatal(\n                     expr.span,\n                     \"generic bare functions can only be called or bound\");"}, {"sha": "8ae46cec408cc4f426ffc1294fccb7470494ab43", "filename": "src/comp/middle/gc.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/92927449595782926c4db5a579ba7e4c6952287d/src%2Fcomp%2Fmiddle%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92927449595782926c4db5a579ba7e4c6952287d/src%2Fcomp%2Fmiddle%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fgc.rs?ref=92927449595782926c4db5a579ba7e4c6952287d", "patch": "@@ -145,21 +145,9 @@ fn type_is_gc_relevant(cx: ty::ctxt, ty: ty::t) -> bool {\n         ret type_is_gc_relevant(cx, tm.ty);\n       }\n       ty::ty_constr(sub, _) { ret type_is_gc_relevant(cx, sub); }\n-\n-\n-\n-\n-\n-      ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_fn(_, _, _, _, _) |\n+      ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_fn(_) |\n       ty::ty_native_fn(_, _) | ty::ty_obj(_) | ty::ty_param(_, _) |\n-      ty::ty_res(_, _, _) {\n-        ret true;\n-      }\n-\n-\n-\n-\n-\n+      ty::ty_res(_, _, _) { ret true; }\n       ty::ty_var(_) {\n         fail \"ty_var in type_is_gc_relevant\";\n       }"}, {"sha": "1bc74881e6c3fa1e0e1ee49879fe55536962e377", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92927449595782926c4db5a579ba7e4c6952287d/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92927449595782926c4db5a579ba7e4c6952287d/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=92927449595782926c4db5a579ba7e4c6952287d", "patch": "@@ -416,7 +416,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint],\n             }\n         }\n       }\n-      ty::ty_fn(_, _, _, _, _) {\n+      ty::ty_fn(_) {\n         s += [shape_fn];\n       }\n       ty::ty_opaque_closure. {"}, {"sha": "366e515b05c49a5ff072577167ee4ce0373778fd", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/92927449595782926c4db5a579ba7e4c6952287d/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92927449595782926c4db5a579ba7e4c6952287d/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=92927449595782926c4db5a579ba7e4c6952287d", "patch": "@@ -168,7 +168,7 @@ fn type_of_inner(cx: @crate_ctxt, sp: span, t: ty::t)\n         }\n         T_struct(tys)\n       }\n-      ty::ty_fn(_, _, _, _, _) {\n+      ty::ty_fn(_) {\n         // FIXME: could be a constraint on ty_fn\n         check returns_non_ty_var(cx, t);\n         T_fn_pair(cx, type_of_fn_from_ty(cx, sp, t, 0u))\n@@ -232,7 +232,7 @@ fn type_of_ty_param_kinds_and_ty(lcx: @local_ctxt, sp: span,\n     let cx = lcx.ccx;\n     let t = tpt.ty;\n     alt ty::struct(cx.tcx, t) {\n-      ty::ty_fn(_, _, _, _, _) | ty::ty_native_fn(_, _) {\n+      ty::ty_fn(_) | ty::ty_native_fn(_, _) {\n         check returns_non_ty_var(cx, t);\n         ret type_of_fn_from_ty(cx, sp, t, vec::len(tpt.kinds));\n       }\n@@ -482,7 +482,7 @@ fn simplify_type(ccx: @crate_ctxt, typ: ty::t) -> ty::t {\n           ty::ty_uniq(_) {\n             ret ty::mk_imm_uniq(ccx.tcx, ty::mk_nil(ccx.tcx));\n           }\n-          ty::ty_fn(_, _, _, _, _) {\n+          ty::ty_fn(_) {\n             ret ty::mk_tup(ccx.tcx,\n                            [ty::mk_imm_box(ccx.tcx, ty::mk_nil(ccx.tcx)),\n                             ty::mk_imm_box(ccx.tcx, ty::mk_nil(ccx.tcx))]);\n@@ -1321,7 +1321,7 @@ fn make_take_glue(cx: @block_ctxt, v: ValueRef, t: ty::t) {\n         Store(bcx, s, v);\n         bcx\n       }\n-      ty::ty_native_fn(_, _) | ty::ty_fn(_, _, _, _, _) {\n+      ty::ty_native_fn(_, _) | ty::ty_fn(_) {\n         trans_closure::make_fn_glue(bcx, v, t, take_ty)\n       }\n       ty::ty_opaque_closure. {\n@@ -1396,7 +1396,7 @@ fn make_free_glue(bcx: @block_ctxt, v: ValueRef, t: ty::t) {\n         // they must be freed.\n         trans_shared_free(bcx, v)\n       }\n-      ty::ty_native_fn(_, _) | ty::ty_fn(_, _, _, _, _) {\n+      ty::ty_native_fn(_, _) | ty::ty_fn(_) {\n         trans_closure::make_fn_glue(bcx, v, t, free_ty)\n       }\n       ty::ty_opaque_closure. {\n@@ -1425,7 +1425,7 @@ fn make_drop_glue(bcx: @block_ctxt, v0: ValueRef, t: ty::t) {\n           ty::ty_res(did, inner, tps) {\n             trans_res_drop(bcx, v0, did, inner, tps)\n           }\n-          ty::ty_native_fn(_, _) | ty::ty_fn(_, _, _, _, _) {\n+          ty::ty_native_fn(_, _) | ty::ty_fn(_) {\n             trans_closure::make_fn_glue(bcx, v0, t, drop_ty)\n           }\n           ty::ty_opaque_closure. {\n@@ -1635,7 +1635,7 @@ fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n         let ccx = bcx_ccx(cx);\n         let cx = cx;\n         alt ty::struct(ccx.tcx, fn_ty) {\n-          ty::ty_fn(_, args, _, _, _) {\n+          ty::ty_fn({inputs: args, _}) {\n             let j = 0u;\n             let v_id = variant.id;\n             for a: ty::arg in args {\n@@ -2762,7 +2762,7 @@ fn trans_object_field_inner(bcx: @block_ctxt, o: ValueRef,\n     vtbl = PointerCast(bcx, vtbl, vtbl_type);\n \n     let v = GEPi(bcx, vtbl, [0, ix as int]);\n-    let fn_ty: ty::t = ty::method_ty_to_fn_ty(tcx, mths[ix]);\n+    let fn_ty: ty::t = ty::mk_fn(tcx, mths[ix].fty);\n     let ret_ty = ty::ty_fn_ret(tcx, fn_ty);\n     // FIXME: constrain ty_obj?\n     check non_ty_var(ccx, ret_ty);\n@@ -3558,7 +3558,7 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n       }\n       ast::expr_fn_block(decl, body) {\n         alt ty::struct(tcx, ty::expr_ty(tcx, e)) {\n-          ty::ty_fn(proto, _, _, _, _) {\n+          ty::ty_fn({proto, _}) {\n             let cap_clause = { copies: [], moves: [] };\n             ret trans_closure::trans_expr_fn(\n                 bcx, decl, body, e.span, e.id, cap_clause, dest);\n@@ -4443,7 +4443,7 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, bcx: @block_ctxt, args: [ast::arg],\n \n fn arg_tys_of_fn(ccx: @crate_ctxt, id: ast::node_id) -> [ty::arg] {\n     alt ty::struct(ccx.tcx, ty::node_id_to_type(ccx.tcx, id)) {\n-      ty::ty_fn(_, arg_tys, _, _, _) { ret arg_tys; }\n+      ty::ty_fn({inputs, _}) { inputs }\n     }\n }\n \n@@ -5107,7 +5107,7 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n \n     let main_takes_argv =\n         alt ty::struct(ccx.tcx, main_node_type) {\n-          ty::ty_fn(_, args, _, _, _) { vec::len(args) != 0u }\n+          ty::ty_fn({inputs, _}) { vec::len(inputs) != 0u }\n         };\n \n     let llfn = create_main(ccx, sp, main_llfn, main_takes_argv);"}, {"sha": "b60649a2280957c1f56bd3074ab921cd2ef8e9b7", "filename": "src/comp/middle/trans_closure.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92927449595782926c4db5a579ba7e4c6952287d/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92927449595782926c4db5a579ba7e4c6952287d/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs?ref=92927449595782926c4db5a579ba7e4c6952287d", "patch": "@@ -516,19 +516,19 @@ fn make_fn_glue(\n     };\n \n     ret alt ty::struct(tcx, t) {\n-      ty::ty_native_fn(_, _) | ty::ty_fn(ast::proto_bare., _, _, _, _) {\n+      ty::ty_native_fn(_, _) | ty::ty_fn({proto: ast::proto_bare., _}) {\n         bcx\n       }\n-      ty::ty_fn(ast::proto_block., _, _, _, _) {\n+      ty::ty_fn({proto: ast::proto_block., _}) {\n         bcx\n       }\n-      ty::ty_fn(ast::proto_send., _, _, _, _) {\n+      ty::ty_fn({proto: ast::proto_send., _}) {\n         fn_env({ |bcx, box_cell_v|\n             let box_ty = trans_closure::send_opaque_closure_box_ty(tcx);\n             glue_fn(bcx, box_cell_v, box_ty)\n         })\n       }\n-      ty::ty_fn(ast::proto_shared(_), _, _, _, _) {\n+      ty::ty_fn({proto: ast::proto_shared(_), _}) {\n         fn_env({ |bcx, box_cell_v|\n             let box_ty = trans_closure::shared_opaque_closure_box_ty(tcx);\n             glue_fn(bcx, box_cell_v, box_ty)"}, {"sha": "db50c28b85a009e727c259669c8b8ff1b8db99d1", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/92927449595782926c4db5a579ba7e4c6952287d/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92927449595782926c4db5a579ba7e4c6952287d/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=92927449595782926c4db5a579ba7e4c6952287d", "patch": "@@ -631,8 +631,8 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: span, m: @ty::method,\n     // return type, if necessary.\n     let llretptr = fcx.llretptr;\n     let ccx = cx.ccx;\n-    if ty::type_contains_params(ccx.tcx, m.output) {\n-        let m_output = m.output;\n+    if ty::type_contains_params(ccx.tcx, m.fty.output) {\n+        let m_output = m.fty.output;\n         check non_ty_var(ccx, m_output);\n         let llretty = type_of_inner(ccx, sp, m_output);\n         llretptr = PointerCast(bcx, llretptr, T_ptr(llretty));\n@@ -676,7 +676,7 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: span, m: @ty::method,\n     // function (they're in fcx.llargs) to llouter_mthd_args.\n \n     let a: uint = 2u; // retptr, env come first\n-    for arg: ty::arg in m.inputs {\n+    for arg: ty::arg in m.fty.inputs {\n         llouter_mthd_args += [llvm::LLVMGetParam(llbackwarding_fn, a)];\n         a += 1u;\n     }\n@@ -725,8 +725,8 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: span, m: @ty::method,\n     // return type, if necessary.\n     let llretptr = fcx.llretptr;\n     let ccx = cx.ccx;\n-    if ty::type_contains_params(ccx.tcx, m.output) {\n-        let m_output = m.output;\n+    if ty::type_contains_params(ccx.tcx, m.fty.output) {\n+        let m_output = m.fty.output;\n         check non_ty_var(ccx, m_output);\n         let llretty = type_of_inner(ccx, sp, m_output);\n         llretptr = PointerCast(bcx, llretptr, T_ptr(llretty));\n@@ -828,7 +828,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: span, m: @ty::method,\n     // function (they're in fcx.llargs) to llorig_mthd_args.\n \n     let a: uint = 2u; // retptr, env come first\n-    for arg: ty::arg in m.inputs {\n+    for arg: ty::arg in m.fty.inputs {\n         llorig_mthd_args += [llvm::LLVMGetParam(llforwarding_fn, a)];\n         a += 1u;\n     }\n@@ -877,9 +877,10 @@ fn process_normal_mthd(cx: @local_ctxt, m: @ast::method, self_ty: ty::t,\n     let llfnty = T_nil();\n     let ccx = cx.ccx;\n     alt ty::struct(cx.ccx.tcx, node_id_type(cx.ccx, m.id)) {\n-      ty::ty_fn(_, inputs, output, rs, _) {\n-        check non_ty_var(ccx, output);\n-        llfnty = type_of_fn(ccx, m.span, true, inputs, output,\n+      ty::ty_fn(f) {\n+        let out = f.output;\n+        check non_ty_var(ccx, out);\n+        llfnty = type_of_fn(ccx, m.span, true, f.inputs, out,\n                             vec::len(ty_params));\n       }\n     }\n@@ -930,9 +931,9 @@ fn populate_self_stack(bcx: @block_ctxt, self_stack: ValueRef,\n \n fn type_of_meth(ccx: @crate_ctxt, sp: span, m: @ty::method,\n                 tps: [ast::ty_param]) -> TypeRef {\n-    let out_ty = m.output;\n+    let out_ty = m.fty.output;\n     check non_ty_var(ccx, out_ty);\n-    type_of_fn(ccx, sp, true, m.inputs, out_ty, vec::len(tps))\n+    type_of_fn(ccx, sp, true, m.fty.inputs, out_ty, vec::len(tps))\n }\n \n //"}, {"sha": "fe9a7b496dba10ee3b5db586a112a01f660a8ba2", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92927449595782926c4db5a579ba7e4c6952287d/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92927449595782926c4db5a579ba7e4c6952287d/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=92927449595782926c4db5a579ba7e4c6952287d", "patch": "@@ -488,14 +488,14 @@ fn new_crate_ctxt(cx: ty::ctxt) -> crate_ctxt {\n the answer is noreturn. */\n fn controlflow_expr(ccx: crate_ctxt, e: @expr) -> ret_style {\n     alt ty::struct(ccx.tcx, ty::node_id_to_type(ccx.tcx, e.id)) {\n-      ty::ty_fn(_, _, _, cf, _) { ret cf; }\n+      ty::ty_fn(f) { ret f.ret_style; }\n       _ { ret return_val; }\n     }\n }\n \n fn constraints_expr(cx: ty::ctxt, e: @expr) -> [@ty::constr] {\n     alt ty::struct(cx, ty::node_id_to_type(cx, e.id)) {\n-      ty::ty_fn(_, _, _, _, cs) { ret cs; }\n+      ty::ty_fn(f) { ret f.constraints; }\n       _ { ret []; }\n     }\n }\n@@ -1074,7 +1074,7 @@ fn callee_modes(fcx: fn_ctxt, callee: node_id) -> [ty::mode] {\n         ty::type_autoderef(fcx.ccx.tcx,\n                            ty::node_id_to_type(fcx.ccx.tcx, callee));\n     alt ty::struct(fcx.ccx.tcx, ty) {\n-      ty::ty_fn(_, args, _, _, _) | ty::ty_native_fn(args, _) {\n+      ty::ty_fn({inputs: args, _}) | ty::ty_native_fn(args, _) {\n         let modes = [];\n         for arg: ty::arg in args { modes += [arg.mode]; }\n         ret modes;"}, {"sha": "2b18b1de08cfa0a02905d6bc637e0bfcef839311", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 120, "deletions": 173, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/92927449595782926c4db5a579ba7e4c6952287d/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92927449595782926c4db5a579ba7e4c6952287d/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=92927449595782926c4db5a579ba7e4c6952287d", "patch": "@@ -52,7 +52,6 @@ export is_pred_ty;\n export lookup_item_type;\n export method;\n export method_idx;\n-export method_ty_to_fn_ty;\n export mk_bool;\n export mk_bot;\n export mk_box;\n@@ -114,7 +113,7 @@ export ty_constr;\n export ty_opaque_closure;\n export ty_constr_arg;\n export ty_float;\n-export ty_fn;\n+export ty_fn, fn_ty;\n export ty_fn_proto;\n export ty_fn_ret;\n export ty_fn_ret_style;\n@@ -190,13 +189,7 @@ type arg = {mode: mode, ty: t};\n \n type field = {ident: ast::ident, mt: mt};\n \n-type method =\n-    {proto: ast::proto,\n-     ident: ast::ident,\n-     inputs: [arg],\n-     output: t,\n-     cf: ret_style,\n-     constrs: [@constr]};\n+type method = {ident: ast::ident, fty: fn_ty};\n \n type constr_table = hashmap<ast::node_id, [constr]>;\n \n@@ -224,15 +217,6 @@ type ctxt =\n \n type ty_ctxt = ctxt;\n \n-\n-// Needed for disambiguation from unify::ctxt.\n-// Convert from method type to function type.  Pretty easy; we just drop\n-// 'ident'.\n-fn method_ty_to_fn_ty(cx: ctxt, m: method) -> t {\n-    ret mk_fn(cx, m.proto, m.inputs, m.output, m.cf, m.constrs);\n-}\n-\n-\n // Never construct these manually. These are interned.\n type raw_t = {struct: sty,\n               hash: uint,\n@@ -247,6 +231,12 @@ tag closure_kind {\n     closure_send;\n }\n \n+type fn_ty = {proto: ast::proto,\n+              inputs: [arg],\n+              output: t,\n+              ret_style: ret_style,\n+              constraints: [@constr]};\n+\n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in front/ast::rs as well.\n tag sty {\n@@ -263,7 +253,7 @@ tag sty {\n     ty_vec(mt);\n     ty_ptr(mt);\n     ty_rec([field]);\n-    ty_fn(ast::proto, [arg], t, ret_style, [@constr]);\n+    ty_fn(fn_ty);\n     ty_native_fn([arg], t);\n     ty_obj([method]);\n     ty_res(def_id, t, [t]);\n@@ -469,15 +459,16 @@ fn mk_raw_ty(cx: ctxt, st: sty) -> @raw_t {\n       ty_tup(ts) {\n         for tt in ts { derive_flags_t(cx, has_params, has_vars, tt); }\n       }\n-      ty_fn(_, args, tt, _, _) {\n-        derive_flags_sig(cx, has_params, has_vars, args, tt);\n+      ty_fn(f) {\n+        derive_flags_sig(cx, has_params, has_vars, f.inputs, f.output);\n       }\n       ty_native_fn(args, tt) {\n         derive_flags_sig(cx, has_params, has_vars, args, tt);\n       }\n       ty_obj(meths) {\n         for m: method in meths {\n-            derive_flags_sig(cx, has_params, has_vars, m.inputs, m.output);\n+            derive_flags_sig(cx, has_params, has_vars, m.fty.inputs,\n+                             m.fty.output);\n         }\n       }\n       ty_res(_, tt, tps) {\n@@ -583,9 +574,8 @@ fn mk_constr(cx: ctxt, t: t, cs: [@type_constr]) -> t {\n \n fn mk_tup(cx: ctxt, ts: [t]) -> t { ret gen_ty(cx, ty_tup(ts)); }\n \n-fn mk_fn(cx: ctxt, proto: ast::proto, args: [arg], ty: t, cf: ret_style,\n-         constrs: [@constr]) -> t {\n-    ret gen_ty(cx, ty_fn(proto, args, ty, cf, constrs));\n+fn mk_fn(cx: ctxt, fty: fn_ty) -> t {\n+    ret gen_ty(cx, ty_fn(fty));\n }\n \n fn mk_native_fn(cx: ctxt, args: [arg], ty: t) -> t {\n@@ -651,18 +641,18 @@ fn walk_ty(cx: ctxt, walker: ty_walk, ty: t) {\n         for fl: field in fields { walk_ty(cx, walker, fl.mt.ty); }\n       }\n       ty_tup(ts) { for tt in ts { walk_ty(cx, walker, tt); } }\n-      ty_fn(proto, args, ret_ty, _, _) {\n-        for a: arg in args { walk_ty(cx, walker, a.ty); }\n-        walk_ty(cx, walker, ret_ty);\n+      ty_fn(f) {\n+        for a: arg in f.inputs { walk_ty(cx, walker, a.ty); }\n+        walk_ty(cx, walker, f.output);\n       }\n       ty_native_fn(args, ret_ty) {\n         for a: arg in args { walk_ty(cx, walker, a.ty); }\n         walk_ty(cx, walker, ret_ty);\n       }\n       ty_obj(methods) {\n         for m: method in methods {\n-            for a: arg in m.inputs { walk_ty(cx, walker, a.ty); }\n-            walk_ty(cx, walker, m.output);\n+            for a: arg in m.fty.inputs { walk_ty(cx, walker, a.ty); }\n+            walk_ty(cx, walker, m.fty.output);\n         }\n       }\n       ty_res(_, sub, tps) {\n@@ -731,14 +721,15 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n         for tt in ts { new_ts += [fold_ty(cx, fld, tt)]; }\n         ty = mk_tup(cx, new_ts);\n       }\n-      ty_fn(proto, args, ret_ty, cf, constrs) {\n+      ty_fn(f) {\n         let new_args: [arg] = [];\n-        for a: arg in args {\n+        for a: arg in f.inputs {\n             let new_ty = fold_ty(cx, fld, a.ty);\n             new_args += [{mode: a.mode, ty: new_ty}];\n         }\n-        ty = mk_fn(cx, proto, new_args, fold_ty(cx, fld, ret_ty), cf,\n-                   constrs);\n+        ty = mk_fn(cx, {inputs: new_args,\n+                        output: fold_ty(cx, fld, f.output)\n+                        with f});\n       }\n       ty_native_fn(args, ret_ty) {\n         let new_args: [arg] = [];\n@@ -749,20 +740,15 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n         ty = mk_native_fn(cx, new_args, fold_ty(cx, fld, ret_ty));\n       }\n       ty_obj(methods) {\n-        let new_methods: [method] = [];\n-        for m: method in methods {\n-            let new_args: [arg] = [];\n-            for a: arg in m.inputs {\n-                new_args += [{mode: a.mode, ty: fold_ty(cx, fld, a.ty)}];\n-            }\n-            new_methods +=\n-                [{proto: m.proto,\n-                  ident: m.ident,\n-                  inputs: new_args,\n-                  output: fold_ty(cx, fld, m.output),\n-                  cf: m.cf,\n-                  constrs: m.constrs}];\n-        }\n+        let new_methods = vec::map(methods, {|m|\n+            let new_args = vec::map(m.fty.inputs, {|a|\n+                {mode: a.mode, ty: fold_ty(cx, fld, a.ty)}\n+            });\n+            {ident: m.ident,\n+             fty: {inputs: new_args,\n+                   output: fold_ty(cx, fld, m.fty.output)\n+                   with m.fty}}\n+        });\n         ty = mk_obj(cx, new_methods);\n       }\n       ty_res(did, subty, tps) {\n@@ -802,7 +788,7 @@ fn type_is_structural(cx: ctxt, ty: t) -> bool {\n       ty_rec(_) { ret true; }\n       ty_tup(_) { ret true; }\n       ty_tag(_, _) { ret true; }\n-      ty_fn(_, _, _, _, _) { ret true; }\n+      ty_fn(_) { ret true; }\n       ty_native_fn(_, _) { ret true; }\n       ty_obj(_) { ret true; }\n       ty_res(_, _, _) { ret true; }\n@@ -983,7 +969,7 @@ fn type_kind(cx: ctxt, ty: t) -> ast::kind {\n       // FIXME: obj is broken for now, since we aren't asserting\n       // anything about its fields.\n       ty_obj(_) { kind_copyable }\n-      ty_fn(proto, _, _, _, _) { ast::proto_kind(proto) }\n+      ty_fn(f) { ast::proto_kind(f.proto) }\n       ty_opaque_closure. { kind_noncopyable }\n       // Those with refcounts-to-inner raise pinned to shared,\n       // lower unique to shared. Therefore just set result to shared.\n@@ -1155,7 +1141,7 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       ty_nil. | ty_bot. | ty_bool. | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_send_type. | ty_type. | ty_native(_) | ty_ptr(_) { result = true; }\n       // Boxed types\n-      ty_str. | ty_box(_) | ty_uniq(_) | ty_vec(_) | ty_fn(_, _, _, _, _) |\n+      ty_str. | ty_box(_) | ty_uniq(_) | ty_vec(_) | ty_fn(_) |\n       ty_native_fn(_, _) | ty_obj(_) {\n         result = false;\n       }\n@@ -1320,9 +1306,7 @@ fn hash_type_structure(st: sty) -> uint {\n       ty_tup(ts) { ret hash_subtys(25u, ts); }\n \n       // ???\n-      ty_fn(_, args, rty, _, _) {\n-        ret hash_fn(27u, args, rty);\n-      }\n+      ty_fn(f) { ret hash_fn(27u, f.inputs, f.output); }\n       ty_native_fn(args, rty) { ret hash_fn(28u, args, rty); }\n       ty_obj(methods) {\n         let h = 29u;\n@@ -1477,15 +1461,15 @@ fn type_contains_params(cx: ctxt, typ: t) -> bool {\n // Type accessors for substructures of types\n fn ty_fn_args(cx: ctxt, fty: t) -> [arg] {\n     alt struct(cx, fty) {\n-      ty::ty_fn(_, a, _, _, _) { ret a; }\n+      ty::ty_fn(f) { ret f.inputs; }\n       ty::ty_native_fn(a, _) { ret a; }\n       _ { cx.sess.bug(\"ty_fn_args() called on non-fn type\"); }\n     }\n }\n \n fn ty_fn_proto(cx: ctxt, fty: t) -> ast::proto {\n     alt struct(cx, fty) {\n-      ty::ty_fn(p, _, _, _, _) { ret p; }\n+      ty::ty_fn(f) { ret f.proto; }\n       ty::ty_native_fn(_, _) {\n         // FIXME: This should probably be proto_bare\n         ret ast::proto_shared(ast::sugar_normal);\n@@ -1497,7 +1481,7 @@ fn ty_fn_proto(cx: ctxt, fty: t) -> ast::proto {\n pure fn ty_fn_ret(cx: ctxt, fty: t) -> t {\n     let sty = struct(cx, fty);\n     alt sty {\n-      ty::ty_fn(_, _, r, _, _) { ret r; }\n+      ty::ty_fn(f) { ret f.output; }\n       ty::ty_native_fn(_, r) { ret r; }\n       _ {\n         // Unchecked is ok since we diverge here\n@@ -1512,15 +1496,15 @@ pure fn ty_fn_ret(cx: ctxt, fty: t) -> t {\n \n fn ty_fn_ret_style(cx: ctxt, fty: t) -> ast::ret_style {\n     alt struct(cx, fty) {\n-      ty::ty_fn(_, _, _, rs, _) { rs }\n+      ty::ty_fn(f) { f.ret_style }\n       ty::ty_native_fn(_, _) { ast::return_val }\n       _ { cx.sess.bug(\"ty_fn_ret_style() called on non-fn type\"); }\n     }\n }\n \n fn is_fn_ty(cx: ctxt, fty: t) -> bool {\n     alt struct(cx, fty) {\n-      ty::ty_fn(_, _, _, _, _) { ret true; }\n+      ty::ty_fn(_) { ret true; }\n       ty::ty_native_fn(_, _) { ret true; }\n       _ { ret false; }\n     }\n@@ -1623,7 +1607,7 @@ fn sort_methods(meths: [method]) -> [method] {\n     fn method_lteq(a: method, b: method) -> bool {\n         ret str::lteq(a.ident, b.ident);\n     }\n-    ret std::sort::merge_sort::<method>(bind method_lteq(_, _), meths);\n+    ret std::sort::merge_sort(bind method_lteq(_, _), meths);\n }\n \n fn occurs_check_fails(tcx: ctxt, sp: option::t<span>, vid: int, rt: t) ->\n@@ -1845,57 +1829,6 @@ mod unify {\n         }\n         ret none;\n     }\n-    tag fn_common_res {\n-        fn_common_res_err(result);\n-        fn_common_res_ok([arg], t);\n-    }\n-    fn unify_fn_common(cx: @ctxt, _expected: t, _actual: t,\n-                       expected_inputs: [arg], expected_output: t,\n-                       actual_inputs: [arg], actual_output: t,\n-                       variance: variance) ->\n-       fn_common_res {\n-        if !vec::same_length(expected_inputs, actual_inputs) {\n-            ret fn_common_res_err(ures_err(terr_arg_count));\n-        }\n-\n-        // Would use vec::map2(), but for the need to return in case of\n-        // error:\n-        let i = 0u, n = vec::len(expected_inputs);\n-        let result_ins = [];\n-        while i < n {\n-            let expected_input = expected_inputs[i];\n-            let actual_input = actual_inputs[i];\n-\n-            // Unify the result modes.\n-            let result_mode = if expected_input.mode == ast::mode_infer {\n-                actual_input.mode\n-            } else if actual_input.mode == ast::mode_infer {\n-                expected_input.mode\n-            } else if expected_input.mode != actual_input.mode {\n-                ret fn_common_res_err\n-                    (ures_err(terr_mode_mismatch(expected_input.mode,\n-                                                 actual_input.mode)));\n-            } else { expected_input.mode };\n-\n-            // The variance changes (flips basically) when descending\n-            // into arguments of function types\n-            let result = unify_step(\n-                cx, expected_input.ty, actual_input.ty,\n-                variance_transform(variance, contravariant));\n-            alt result {\n-              ures_ok(rty) { result_ins += [{mode: result_mode, ty: rty}]; }\n-              _ { ret fn_common_res_err(result); }\n-            };\n-            i += 1u;\n-        }\n-\n-        // Check the output.\n-        let result = unify_step(cx, expected_output, actual_output, variance);\n-        alt result {\n-          ures_ok(rty) { ret fn_common_res_ok(result_ins, rty); }\n-          _ { ret fn_common_res_err(result); }\n-        }\n-    }\n     fn unify_fn_proto(e_proto: ast::proto, a_proto: ast::proto,\n                       variance: variance) -> option::t<result> {\n         // Prototypes form a diamond-shaped partial order:\n@@ -1926,86 +1859,106 @@ mod unify {\n           _ { some(ures_err(terr_mismatch)) }\n         };\n     }\n-    fn unify_fn(cx: @ctxt, e_proto: ast::proto, a_proto: ast::proto,\n-                expected: t, actual: t, expected_inputs: [arg],\n-                expected_output: t, actual_inputs: [arg], actual_output: t,\n-                expected_cf: ret_style, actual_cf: ret_style,\n-                _expected_constrs: [@constr], actual_constrs: [@constr],\n-                variance: variance) ->\n-       result {\n+    fn unify_args(cx: @ctxt, e_args: [arg], a_args: [arg], variance: variance)\n+        -> either::t<result, [arg]> {\n+        if !vec::same_length(e_args, a_args) {\n+            ret either::left(ures_err(terr_arg_count));\n+        }\n+        // The variance changes (flips basically) when descending\n+        // into arguments of function types\n+        let variance = variance_transform(variance, contravariant);\n+        // Would use vec::map2(), but for the need to return in case of\n+        // error:\n+        let i = 0u, result = [];\n+        for expected_input in e_args {\n+            let actual_input = a_args[i];\n+            i += 1u;\n+            // Unify the result modes.\n+            let result_mode = if expected_input.mode == ast::mode_infer {\n+                actual_input.mode\n+            } else if actual_input.mode == ast::mode_infer {\n+                expected_input.mode\n+            } else if expected_input.mode != actual_input.mode {\n+                ret either::left(ures_err(terr_mode_mismatch(\n+                    expected_input.mode, actual_input.mode)));\n+            } else { expected_input.mode };\n \n-        alt unify_fn_proto(e_proto, a_proto, variance) {\n+            alt unify_step(cx, expected_input.ty, actual_input.ty,\n+                           variance) {\n+              ures_ok(rty) { result += [{mode: result_mode, ty: rty}]; }\n+              err { ret either::left(err); }\n+            }\n+        }\n+        either::right(result)\n+    }\n+    fn unify_fn(cx: @ctxt, e_f: fn_ty, a_f: fn_ty, variance: variance)\n+        -> result {\n+        alt unify_fn_proto(e_f.proto, a_f.proto, variance) {\n           some(err) { ret err; }\n           none. { /* fall through */ }\n         }\n \n-        if actual_cf != ast::noreturn && actual_cf != expected_cf {\n+        if a_f.ret_style != ast::noreturn && a_f.ret_style != e_f.ret_style {\n             /* even though typestate checking is mostly\n                responsible for checking control flow annotations,\n                this check is necessary to ensure that the\n                annotation in an object method matches the\n                declared object type */\n-            ret ures_err(terr_ret_style_mismatch(expected_cf, actual_cf));\n+            ret ures_err(terr_ret_style_mismatch(e_f.ret_style,\n+                                                 a_f.ret_style));\n         }\n-        let t =\n-            unify_fn_common(cx, expected, actual, expected_inputs,\n-                            expected_output, actual_inputs, actual_output,\n-                            variance);\n-        alt t {\n-          fn_common_res_err(r) { ret r; }\n-          fn_common_res_ok(result_ins, result_out) {\n-            let t2 =\n-                mk_fn(cx.tcx, e_proto, result_ins, result_out, actual_cf,\n-                      actual_constrs);\n-            ret ures_ok(t2);\n+        let result_ins = alt unify_args(cx, e_f.inputs, a_f.inputs,\n+                                        variance) {\n+            either::left(err) { ret err; }\n+            either::right(ts) { ts }\n+        };\n+\n+        // Check the output.\n+        alt unify_step(cx, e_f.output, a_f.output, variance) {\n+          ures_ok(rty) {\n+            ures_ok(mk_fn(cx.tcx, {proto: e_f.proto,\n+                                   inputs: result_ins,\n+                                   output: rty\n+                                   with a_f}))\n           }\n+          x { x }\n         }\n     }\n-    fn unify_native_fn(cx: @ctxt, expected: t, actual: t,\n-                       expected_inputs: [arg], expected_output: t,\n+    fn unify_native_fn(cx: @ctxt, expected_inputs: [arg], expected_output: t,\n                        actual_inputs: [arg], actual_output: t,\n                        variance: variance) -> result {\n-        let t =\n-            unify_fn_common(cx, expected, actual, expected_inputs,\n-                            expected_output, actual_inputs, actual_output,\n-                            variance);\n-        alt t {\n-          fn_common_res_err(r) { ret r; }\n-          fn_common_res_ok(result_ins, result_out) {\n-            let t2 = mk_native_fn(cx.tcx, result_ins, result_out);\n-            ret ures_ok(t2);\n-          }\n+        let result_ins = alt unify_args(cx, expected_inputs,\n+                                        actual_inputs, variance) {\n+            either::left(err) { ret err; }\n+            either::right(ts) { ts }\n+        };\n+        alt unify_step(cx, expected_output, actual_output, variance) {\n+          ures_ok(out) { ures_ok(mk_native_fn(cx.tcx, result_ins, out)) }\n+          err { err }\n         }\n     }\n-    fn unify_obj(cx: @ctxt, expected: t, actual: t, expected_meths: [method],\n+    fn unify_obj(cx: @ctxt, expected_meths: [method],\n                  actual_meths: [method], variance: variance) -> result {\n         let result_meths: [method] = [];\n         let i: uint = 0u;\n-        let expected_len: uint = vec::len::<method>(expected_meths);\n-        let actual_len: uint = vec::len::<method>(actual_meths);\n+        let expected_len: uint = vec::len(expected_meths);\n+        let actual_len: uint = vec::len(actual_meths);\n         if expected_len != actual_len { ret ures_err(terr_meth_count); }\n         while i < expected_len {\n             let e_meth = expected_meths[i];\n             let a_meth = actual_meths[i];\n             if !str::eq(e_meth.ident, a_meth.ident) {\n                 ret ures_err(terr_obj_meths(e_meth.ident, a_meth.ident));\n             }\n-            let r =\n-                unify_fn(cx, e_meth.proto, a_meth.proto, expected, actual,\n-                         e_meth.inputs, e_meth.output, a_meth.inputs,\n-                         a_meth.output, e_meth.cf, a_meth.cf, e_meth.constrs,\n-                         a_meth.constrs, variance);\n-            alt r {\n+            alt unify_fn(cx, e_meth.fty, a_meth.fty, variance) {\n               ures_ok(tfn) {\n                 alt struct(cx.tcx, tfn) {\n-                  ty_fn(proto, ins, out, cf, constrs) {\n-                    result_meths +=\n-                        [{inputs: ins, output: out, cf: cf, constrs: constrs\n-                             with e_meth}];\n+                  ty_fn(f) {\n+                    result_meths += [{ident: e_meth.ident, fty: f}];\n                   }\n                 }\n               }\n-              _ { ret r; }\n+              err { ret err; }\n             }\n             i += 1u;\n         }\n@@ -2370,24 +2323,18 @@ mod unify {\n               _ { ret ures_err(terr_mismatch); }\n             }\n           }\n-          ty::ty_fn(ep, expected_inputs, expected_output, expected_cf,\n-                    expected_constrs) {\n+          ty::ty_fn(expected_f) {\n             alt struct(cx.tcx, actual) {\n-              ty::ty_fn(ap, actual_inputs, actual_output, actual_cf,\n-                        actual_constrs) {\n-                ret unify_fn(cx, ep, ap, expected, actual, expected_inputs,\n-                             expected_output, actual_inputs, actual_output,\n-                             expected_cf, actual_cf, expected_constrs,\n-                             actual_constrs, variance);\n+              ty::ty_fn(actual_f) {\n+                ret unify_fn(cx, expected_f, actual_f, variance);\n               }\n               _ { ret ures_err(terr_mismatch); }\n             }\n           }\n           ty::ty_native_fn(expected_inputs, expected_output) {\n             alt struct(cx.tcx, actual) {\n               ty::ty_native_fn(actual_inputs, actual_output) {\n-                ret unify_native_fn(cx, expected, actual,\n-                                    expected_inputs, expected_output,\n+                ret unify_native_fn(cx, expected_inputs, expected_output,\n                                     actual_inputs, actual_output, variance);\n               }\n               _ { ret ures_err(terr_mismatch); }\n@@ -2396,8 +2343,7 @@ mod unify {\n           ty::ty_obj(expected_meths) {\n             alt struct(cx.tcx, actual) {\n               ty::ty_obj(actual_meths) {\n-                ret unify_obj(cx, expected, actual, expected_meths,\n-                              actual_meths, variance);\n+                ret unify_obj(cx, expected_meths, actual_meths, variance);\n               }\n               _ { ret ures_err(terr_mismatch); }\n             }\n@@ -2512,10 +2458,11 @@ fn same_type(cx: ctxt, a: t, b: t) -> bool {\n     }\n }\n fn same_method(cx: ctxt, a: method, b: method) -> bool {\n-    a.proto == b.proto && a.ident == b.ident &&\n-    vec::all2(a.inputs, b.inputs,\n+    a.fty.proto == b.fty.proto && a.ident == b.ident &&\n+    vec::all2(a.fty.inputs, b.fty.inputs,\n               {|a, b| a.mode == b.mode && same_type(cx, a.ty, b.ty) }) &&\n-    same_type(cx, a.output, b.output) && a.cf == b.cf\n+    same_type(cx, a.fty.output, b.fty.output) &&\n+    a.fty.ret_style == b.fty.ret_style\n }\n \n fn type_err_to_str(err: ty::type_err) -> str {"}, {"sha": "362f01b757311074083b6d8115bbe47def9ab1e7", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 64, "deletions": 97, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/92927449595782926c4db5a579ba7e4c6952287d/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92927449595782926c4db5a579ba7e4c6952287d/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=92927449595782926c4db5a579ba7e4c6952287d", "patch": "@@ -334,7 +334,7 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n         typ = ty::mk_rec(tcx, flds);\n       }\n       ast::ty_fn(decl) {\n-        typ = ty_of_fn_decl(tcx, mode, decl);\n+        typ = ty::mk_fn(tcx, ty_of_fn_decl(tcx, mode, decl));\n       }\n       ast::ty_path(path, id) {\n         alt tcx.def_map.find(id) {\n@@ -353,28 +353,8 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n         }\n       }\n       ast::ty_obj(meths) {\n-        let tmeths: [ty::method] = [];\n-        for m: ast::ty_method in meths {\n-            let ins = [];\n-            for ta: ast::arg in m.decl.inputs {\n-                ins += [ast_arg_to_arg(tcx, mode, ta)];\n-            }\n-            let out = ast_ty_to_ty(tcx, mode, m.decl.output);\n-\n-            let out_constrs = [];\n-            for constr: @ast::constr in m.decl.constraints {\n-                out_constrs += [ty::ast_constr_to_constr(tcx, constr)];\n-            }\n-            let new_m: ty::method =\n-                {proto: m.decl.proto,\n-                 ident: m.ident,\n-                 inputs: ins,\n-                 output: out,\n-                 cf: m.decl.cf,\n-                 constrs: out_constrs};\n-            tmeths += [new_m];\n-        }\n-        typ = ty::mk_obj(tcx, ty::sort_methods(tmeths));\n+        let ms = vec::map(meths, {|m| ty_of_ty_method(tcx, mode, m) });\n+        typ = ty::mk_obj(tcx, ty::sort_methods(ms));\n       }\n       ast::ty_constr(t, cs) {\n         let out_cs = [];\n@@ -469,7 +449,7 @@ fn ty_of_arg(tcx: ty::ctxt, mode: mode, a: ast::arg) -> ty::arg {\n     let ty = ast_ty_to_ty(tcx, mode, a.ty);\n     {mode: default_arg_mode_for_ty(tcx, a.mode, ty), ty: ty}\n }\n-fn ty_of_fn_decl(tcx: ty::ctxt, mode: mode, decl: ast::fn_decl) -> ty::t {\n+fn ty_of_fn_decl(tcx: ty::ctxt, mode: mode, decl: ast::fn_decl) -> ty::fn_ty {\n     let input_tys = [];\n     for a: ast::arg in decl.inputs { input_tys += [ty_of_arg(tcx, mode, a)]; }\n     let output_ty = ast_ty_to_ty(tcx, mode, decl.output);\n@@ -478,13 +458,14 @@ fn ty_of_fn_decl(tcx: ty::ctxt, mode: mode, decl: ast::fn_decl) -> ty::t {\n     for constr: @ast::constr in decl.constraints {\n         out_constrs += [ty::ast_constr_to_constr(tcx, constr)];\n     }\n-    ty::mk_fn(tcx, decl.proto, input_tys, output_ty, decl.cf, out_constrs)\n+    {proto: decl.proto, inputs: input_tys,\n+     output: output_ty, ret_style: decl.cf, constraints: out_constrs}\n }\n fn ty_of_fn(tcx: ty::ctxt, mode: mode, decl: ast::fn_decl,\n             ty_params: [ast::ty_param], def_id: ast::def_id)\n     -> ty::ty_param_kinds_and_ty {\n     let tpt = {kinds: ty_param_kinds(ty_params),\n-               ty: ty_of_fn_decl(tcx, mode, decl)};\n+               ty: ty::mk_fn(tcx, ty_of_fn_decl(tcx, mode, decl))};\n     tcx.tcache.insert(def_id, tpt);\n     ret tpt;\n }\n@@ -501,32 +482,19 @@ fn ty_of_native_fn_decl(tcx: ty::ctxt, mode: mode, decl: ast::fn_decl,\n     ret tpt;\n }\n fn ty_of_method(tcx: ty::ctxt, mode: mode, m: @ast::method) -> ty::method {\n-    let inputs = vec::map(m.decl.inputs,\n-                          {|i| ty_of_arg(tcx, mode, i)});\n-    let output = ast_ty_to_ty(tcx, mode, m.decl.output);\n-\n-    let out_constrs = [];\n-    for constr: @ast::constr in m.decl.constraints {\n-        out_constrs += [ty::ast_constr_to_constr(tcx, constr)];\n-    }\n-    ret {proto: m.decl.proto,\n-         ident: m.ident,\n-         inputs: inputs,\n-         output: output,\n-         cf: m.decl.cf,\n-         constrs: out_constrs};\n+    {ident: m.ident, fty: ty_of_fn_decl(tcx, mode, m.decl)}\n+}\n+fn ty_of_ty_method(tcx: ty::ctxt, mode: mode, m: ast::ty_method)\n+    -> ty::method {\n+    {ident: m.ident, fty: ty_of_fn_decl(tcx, mode, m.decl)}\n }\n fn ty_of_obj(tcx: ty::ctxt, mode: mode, id: ast::ident, ob: ast::_obj,\n         ty_params: [ast::ty_param]) -> ty::ty_param_kinds_and_ty {\n-    let methods = ty_of_obj_methods(tcx, mode, ob);\n+    let methods = vec::map(ob.methods, {|m| ty_of_method(tcx, mode, m)});\n     let t_obj = ty::mk_named(tcx, ty::mk_obj(tcx, ty::sort_methods(methods)),\n                              @id);\n     ret {kinds: ty_param_kinds(ty_params), ty: t_obj};\n }\n-fn ty_of_obj_methods(tcx: ty::ctxt, mode: mode, object: ast::_obj)\n-    -> [ty::method] {\n-    vec::map(object.methods, {|m| ty_of_method(tcx, mode, m)})\n-}\n fn ty_of_obj_ctor(tcx: ty::ctxt, mode: mode, id: ast::ident, ob: ast::_obj,\n             ctor_id: ast::node_id, ty_params: [ast::ty_param])\n     -> ty::ty_param_kinds_and_ty {\n@@ -536,9 +504,9 @@ fn ty_of_obj_ctor(tcx: ty::ctxt, mode: mode, id: ast::ident, ob: ast::_obj,\n         let t_field = ast_ty_to_ty(tcx, mode, f.ty);\n         t_inputs += [{mode: ast::by_copy, ty: t_field}];\n     }\n-    let t_fn = ty::mk_fn(tcx, ast::proto_shared(ast::sugar_normal),\n-                         t_inputs, t_obj.ty,\n-                         ast::return_val, []);\n+    let t_fn = ty::mk_fn(tcx, {proto: ast::proto_shared(ast::sugar_normal),\n+                               inputs: t_inputs, output: t_obj.ty,\n+                               ret_style: ast::return_val, constraints: []});\n     let tpt = {kinds: ty_param_kinds(ty_params), ty: t_fn};\n     tcx.tcache.insert(local_def(ctor_id), tpt);\n     ret tpt;\n@@ -660,9 +628,10 @@ mod collect {\n                     args += [{mode: ast::by_copy, ty: arg_ty}];\n                 }\n                 // FIXME: this will be different for constrained types\n-                ty::mk_fn(cx.tcx, ast::proto_shared(ast::sugar_normal),\n-                          args, tag_ty,\n-                          ast::return_val, [])\n+                ty::mk_fn(cx.tcx,\n+                          {proto: ast::proto_shared(ast::sugar_normal),\n+                           inputs: args, output: tag_ty,\n+                           ret_style: ast::return_val, constraints: []})\n             };\n             let tpt = {kinds: ty_param_kinds(ty_params), ty: result_ty};\n             cx.tcx.tcache.insert(local_def(variant.node.id), tpt);\n@@ -680,8 +649,8 @@ mod collect {\n           }\n           ast::item_impl(_, selfty, ms) {\n             for m in ms {\n-                let ty = ty::method_ty_to_fn_ty(\n-                    cx.tcx, ty_of_method(cx.tcx, m_collect, m));\n+                let ty = ty::mk_fn(cx.tcx, ty_of_fn_decl(cx.tcx, m_collect,\n+                                                         m.decl));\n                 cx.tcx.tcache.insert(local_def(m.id),\n                                      {kinds: ty_param_kinds(m.tps),\n                                       ty: ty});\n@@ -702,12 +671,12 @@ mod collect {\n             // FIXME: Inefficient; this ends up calling\n             // get_obj_method_types() twice. (The first time was above in\n             // ty_of_obj().)\n-            let method_types = ty_of_obj_methods(cx.tcx, m_collect, object);\n+            let m_types = vec::map(object.methods,\n+                                   {|m| ty_of_method(cx.tcx, m_collect, m)});\n             let i = 0u;\n             for m in object.methods {\n                 write::ty_only(cx.tcx, m.id,\n-                               ty::method_ty_to_fn_ty(cx.tcx,\n-                                                      method_types[i]));\n+                               ty::mk_fn(cx.tcx, m_types[i].fty));\n                 i += 1u;\n             }\n             // Write in the types of the object fields.\n@@ -727,15 +696,17 @@ mod collect {\n             let t_res =\n                 ty::mk_res(cx.tcx, local_def(it.id), t_arg.ty,\n                            mk_ty_params(cx.tcx, tps));\n-            let t_ctor =\n-                ty::mk_fn(cx.tcx, ast::proto_shared(ast::sugar_normal),\n-                          [{mode: ast::by_copy with t_arg}], t_res,\n-                          ast::return_val, []);\n-            let t_dtor =\n-                ty::mk_fn(cx.tcx, ast::proto_shared(ast::sugar_normal),\n-                          [t_arg],\n-                          ty::mk_nil(cx.tcx),\n-                          ast::return_val, []);\n+            let t_ctor = ty::mk_fn(cx.tcx, {\n+                proto: ast::proto_shared(ast::sugar_normal),\n+                inputs: [{mode: ast::by_copy with t_arg}],\n+                output: t_res,\n+                ret_style: ast::return_val, constraints: []\n+            });\n+            let t_dtor = ty::mk_fn(cx.tcx, {\n+                proto: ast::proto_shared(ast::sugar_normal),\n+                inputs: [t_arg], output: ty::mk_nil(cx.tcx),\n+                ret_style: ast::return_val, constraints: []\n+            });\n             write::ty_only(cx.tcx, it.id, t_res);\n             write::ty_only(cx.tcx, ctor_id, t_ctor);\n             cx.tcx.tcache.insert(local_def(ctor_id),\n@@ -909,9 +880,9 @@ fn variant_arg_types(ccx: @crate_ctxt, _sp: span, vid: ast::def_id,\n     let result: [ty::t] = [];\n     let tpt = ty::lookup_item_type(ccx.tcx, vid);\n     alt ty::struct(ccx.tcx, tpt.ty) {\n-      ty::ty_fn(_, ins, _, _, _) {\n+      ty::ty_fn(f) {\n         // N-ary variant.\n-        for arg: ty::arg in ins {\n+        for arg: ty::arg in f.inputs {\n             let arg_ty =\n                 ty::substitute_type_params(ccx.tcx, tag_ty_params, arg.ty);\n             result += [arg_ty];\n@@ -1500,7 +1471,7 @@ fn check_expr_fn_with_unifier(fcx: @fn_ctxt,\n                               expected: ty::t) {\n     let tcx = fcx.ccx.tcx;\n \n-    let fty = ty_of_fn_decl(tcx, m_check_tyvar(fcx), decl);\n+    let fty = ty::mk_fn(tcx, ty_of_fn_decl(tcx, m_check_tyvar(fcx), decl));\n \n     #debug(\"check_expr_fn_with_unifier %s fty=%s\",\n            expr_to_str(expr),\n@@ -1537,8 +1508,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         // Grab the argument types\n         let arg_tys =\n             alt sty {\n-              ty::ty_fn(_, arg_tys, _, _, _) | ty::ty_native_fn(arg_tys, _)\n-              {\n+              ty::ty_fn({inputs: arg_tys, _}) | ty::ty_native_fn(arg_tys, _) {\n                 arg_tys\n               }\n               _ {\n@@ -1642,9 +1612,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         let rt_1;\n         let fty = ty::expr_ty(fcx.ccx.tcx, f);\n         alt structure_of(fcx, sp, fty) {\n-          ty::ty_fn(_, _, rt, cf, _) {\n-            bot |= cf == ast::noreturn;\n-            rt_1 = rt;\n+          ty::ty_fn(f) {\n+            bot |= f.ret_style == ast::noreturn;\n+            rt_1 = f.output;\n           }\n           ty::ty_native_fn(_, rt) { rt_1 = rt; }\n           _ { fcx.ccx.tcx.sess.span_fatal(sp, \"calling non-function\"); }\n@@ -1957,7 +1927,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       ast::expr_fn_block(decl, body) {\n         // Take the prototype from the expected type, but default to block:\n         let proto = alt ty::struct(tcx, expected) {\n-          ty::ty_fn(proto, _, _, _, _) { proto }\n+          ty::ty_fn({proto, _}) { proto }\n           _ {\n             fcx.ccx.tcx.sess.span_warn(\n                 expr.span,\n@@ -1989,17 +1959,15 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         // Pull the argument and return types out.\n         let proto, arg_tys, rt, cf, constrs;\n         alt structure_of(fcx, expr.span, expr_ty(tcx, f)) {\n-\n-\n           // FIXME:\n           // probably need to munge the constrs to drop constraints\n           // for any bound args\n-          ty::ty_fn(proto_, arg_tys_, rt_, cf_, constrs_) {\n-            proto = proto_;\n-            arg_tys = arg_tys_;\n-            rt = rt_;\n-            cf = cf_;\n-            constrs = constrs_;\n+          ty::ty_fn(f) {\n+            proto = f.proto;\n+            arg_tys = f.inputs;\n+            rt = f.output;\n+            cf = f.ret_style;\n+            constrs = f.constraints;\n           }\n           ty::ty_native_fn(arg_tys_, rt_) {\n             proto = ast::proto_bare;\n@@ -2032,8 +2000,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             }\n         }\n \n-        let ft = ty::mk_fn(tcx, lower_bound_proto(proto),\n-                           out_args, rt, cf, constrs);\n+        let ft = ty::mk_fn(tcx, {proto: lower_bound_proto(proto),\n+                                 inputs: out_args, output: rt,\n+                                 ret_style: cf, constraints: constrs});\n         write::ty_only_fixup(fcx, id, ft);\n       }\n       ast::expr_call(f, args, _) {\n@@ -2161,10 +2130,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                                       \"can't provide type parameters \\\n                                        to an obj method\");\n                 }\n-                let meth = methods[ix];\n-                let t = ty::mk_fn(tcx, meth.proto, meth.inputs,\n-                                  meth.output, meth.cf, meth.constrs);\n-                write::ty_only_fixup(fcx, id, t);\n+                write::ty_only_fixup(fcx, id,\n+                                     ty::mk_fn(tcx, methods[ix].fty));\n                 handled = true;\n               }\n               _ {}\n@@ -2180,8 +2147,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                     alt tcx.items.get(method.did.node) {\n                       ast_map::node_method(m) {\n                         let mt = ty_of_method(tcx, m_check, m);\n-                        ty::mk_fn(tcx, mt.proto, mt.inputs,\n-                                  mt.output, mt.cf, mt.constrs)\n+                        ty::mk_fn(tcx, mt.fty)\n                       }\n                     }\n                 } else { csearch::get_type(tcx, method.did).ty };\n@@ -2339,7 +2305,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         let i = 0u;\n         while i < vec::len(ao.methods) {\n             write::ty_only(tcx, ao.methods[i].id,\n-                           ty::method_ty_to_fn_ty(tcx, method_types[i]));\n+                           ty::mk_fn(tcx, method_types[i].fty));\n             i += 1u;\n         }\n \n@@ -2696,12 +2662,13 @@ fn arg_is_argv_ty(tcx: ty::ctxt, a: ty::arg) -> bool {\n fn check_main_fn_ty(tcx: ty::ctxt, main_id: ast::node_id) {\n     let main_t = ty::node_id_to_monotype(tcx, main_id);\n     alt ty::struct(tcx, main_t) {\n-      ty::ty_fn(ast::proto_bare., args, rs, ast::return_val., constrs) {\n-        let ok = vec::len(constrs) == 0u;\n-        ok &= ty::type_is_nil(tcx, rs);\n-        let num_args = vec::len(args);\n-        ok &=\n-            num_args == 0u || num_args == 1u && arg_is_argv_ty(tcx, args[0]);\n+      ty::ty_fn({proto: ast::proto_bare., inputs, output,\n+                 ret_style: ast::return_val., constraints}) {\n+        let ok = vec::len(constraints) == 0u;\n+        ok &= ty::type_is_nil(tcx, output);\n+        let num_args = vec::len(inputs);\n+        ok &= num_args == 0u || num_args == 1u &&\n+              arg_is_argv_ty(tcx, inputs[0]);\n         if !ok {\n             let span = ast_map::node_span(tcx.items.get(main_id));\n             tcx.sess.span_err(span,"}, {"sha": "39cb65dcf30b7a58fc354c4edddf9e5985c46297", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/92927449595782926c4db5a579ba7e4c6952287d/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92927449595782926c4db5a579ba7e4c6952287d/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=92927449595782926c4db5a579ba7e4c6952287d", "patch": "@@ -54,8 +54,8 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n         ret s;\n     }\n     fn method_to_str(cx: ctxt, m: method) -> str {\n-        ret fn_to_str(cx, m.proto, some::<ast::ident>(m.ident), m.inputs,\n-                      m.output, m.cf, m.constrs) + \";\";\n+        ret fn_to_str(cx, m.fty.proto, some(m.ident), m.fty.inputs,\n+                      m.fty.output, m.fty.ret_style, m.fty.constraints) + \";\";\n     }\n     fn field_to_str(cx: ctxt, f: field) -> str {\n         ret f.ident + \": \" + mt_to_str(cx, f.mt);\n@@ -111,8 +111,9 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n         for elem in elems { strs += [ty_to_str(cx, elem)]; }\n         \"(\" + str::connect(strs, \",\") + \")\"\n       }\n-      ty_fn(proto, inputs, output, cf, constrs) {\n-        fn_to_str(cx, proto, none, inputs, output, cf, constrs)\n+      ty_fn(f) {\n+        fn_to_str(cx, f.proto, none, f.inputs, f.output, f.ret_style,\n+                  f.constraints)\n       }\n       ty_native_fn(inputs, output) {\n         fn_to_str(cx, ast::proto_bare, none, inputs, output,"}]}