{"sha": "3ea24915894d49cb93eab52e65f1e4f0baa1bc32", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlYTI0OTE1ODk0ZDQ5Y2I5M2VhYjUyZTY1ZjFlNGYwYmFhMWJjMzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-19T22:33:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-19T22:33:57Z"}, "message": "Auto merge of #50893 - kennytm:rollup, r=kennytm\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #50531 (Cleanup uses of TypeIdHasher and replace them with StableHasher)\n - #50819 (Fix potential divide by zero)\n - #50827 (Update LLVM to 56c931901cfb85cd6f7ed44c7d7520a8de1edf97)\n - #50829 (CheckLoopVisitor: also visit break expressions)\n - #50854 (in which the unused shorthand field pattern debacle/saga continues)\n - #50858 (Reorder description for snippets in rustdoc documentation)\n - #50883 (Fix warning when building stage0 libcore)\n - #50889 (Update clippy)\n\nFailed merges:", "tree": {"sha": "f38831d29ae06bc543df2e693d0135868c849128", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f38831d29ae06bc543df2e693d0135868c849128"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ea24915894d49cb93eab52e65f1e4f0baa1bc32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ea24915894d49cb93eab52e65f1e4f0baa1bc32", "html_url": "https://github.com/rust-lang/rust/commit/3ea24915894d49cb93eab52e65f1e4f0baa1bc32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3085756edf66459109c4b07948b08fe3e78bc3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3085756edf66459109c4b07948b08fe3e78bc3b", "html_url": "https://github.com/rust-lang/rust/commit/a3085756edf66459109c4b07948b08fe3e78bc3b"}, {"sha": "ada5feedda21ed5baab6cce914d26eaff0d7e7c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/ada5feedda21ed5baab6cce914d26eaff0d7e7c4", "html_url": "https://github.com/rust-lang/rust/commit/ada5feedda21ed5baab6cce914d26eaff0d7e7c4"}], "stats": {"total": 579, "additions": 271, "deletions": 308}, "files": [{"sha": "8c2d8fc989b895c5a357904ed4bfe1faad22d0cb", "filename": "src/Cargo.lock", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=3ea24915894d49cb93eab52e65f1e4f0baa1bc32", "patch": "@@ -288,12 +288,12 @@ dependencies = [\n \n [[package]]\n name = \"clippy\"\n-version = \"0.0.200\"\n+version = \"0.0.202\"\n dependencies = [\n  \"ansi_term 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cargo_metadata 0.5.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"clippy-mini-macro-test 0.2.0\",\n- \"clippy_lints 0.0.200\",\n+ \"clippy_lints 0.0.202\",\n  \"compiletest_rs 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"derive-new 0.5.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -311,6 +311,27 @@ version = \"0.2.0\"\n [[package]]\n name = \"clippy_lints\"\n version = \"0.0.200\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"cargo_metadata 0.5.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"if_chain 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itertools 0.7.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"matches 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"pulldown-cmark 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quine-mc_cluskey 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex-syntax 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-normalization 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"url 1.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"clippy_lints\"\n+version = \"0.0.202\"\n dependencies = [\n  \"cargo_metadata 0.5.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"if_chain 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1624,7 +1645,7 @@ version = \"0.128.0\"\n dependencies = [\n  \"cargo 0.29.0\",\n  \"cargo_metadata 0.5.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"clippy_lints 0.0.200\",\n+ \"clippy_lints 0.0.200 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.5.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"failure 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"json 0.11.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2978,6 +2999,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d4c819a1287eb618df47cc647173c5c4c66ba19d888a6e50d605672aed3140de\"\n \"checksum chrono 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ba5f60682a4c264e7f8d77b82e7788938a76befdf949d4a98026d19099c9d873\"\n \"checksum clap 2.31.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f0f16b89cbb9ee36d87483dc939fe9f1e13c05898d56d7b230a0d4dff033a536\"\n+\"checksum clippy_lints 0.0.200 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d2432663f6bdb90255dcf9df5ca504f99b575bb471281591138f62f9d31f863b\"\n \"checksum cmake 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5cf678ceebedde428000cb3a34465cf3606d1a48da17014948a916deac39da7c\"\n \"checksum colored 1.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b0aa3473e85a3161b59845d6096b289bb577874cafeaf75ea1b1beaa6572c7fc\"\n \"checksum commoncrypto 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d056a8586ba25a1e4d61cb090900e495952c7886786fc55f909ab2f819b69007\""}, {"sha": "7504b43e20cb3025159fbd9ca61c856f306aed89", "filename": "src/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.toml?ref=3ea24915894d49cb93eab52e65f1e4f0baa1bc32", "patch": "@@ -64,4 +64,3 @@ cargo = { path = \"tools/cargo\" }\n # RLS depends on `rustfmt` from crates.io, so we put this in a `[patch]` section\n # for crates.io\n rustfmt-nightly = { path = \"tools/rustfmt\" }\n-clippy_lints = { path = \"tools/clippy/clippy_lints\" }"}, {"sha": "fd7d1713ca574eefeebff662b3f1f3d07088c064", "filename": "src/doc/rustdoc/src/documentation-tests.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md?ref=3ea24915894d49cb93eab52e65f1e4f0baa1bc32", "patch": "@@ -268,10 +268,10 @@ not actually pass as a test.\n # fn foo() {}\n ```\n \n-`compile_fail` tells `rustdoc` that the compilation should fail. If it\n-compiles, then the test will fail. However please note that code failing\n-with the current Rust release may work in a future release, as new features\n-are added.\n+The `no_run` attribute will compile your code, but not run it. This is\n+important for examples such as \"Here's how to retrieve a web page,\"\n+which you would want to ensure compiles, but might be run in a test\n+environment that has no network access.\n \n ```text\n /// ```compile_fail\n@@ -280,7 +280,7 @@ are added.\n /// ```\n ```\n \n-The `no_run` attribute will compile your code, but not run it. This is\n-important for examples such as \"Here's how to retrieve a web page,\"\n-which you would want to ensure compiles, but might be run in a test\n-environment that has no network access.\n+`compile_fail` tells `rustdoc` that the compilation should fail. If it\n+compiles, then the test will fail. However please note that code failing\n+with the current Rust release may work in a future release, as new features\n+are added."}, {"sha": "3b19a401859eebfc1b97ea85a41a0bed49250354", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=3ea24915894d49cb93eab52e65f1e4f0baa1bc32", "patch": "@@ -1698,6 +1698,7 @@ impl<T> [T] {\n     }\n \n     /// Function to calculate lenghts of the middle and trailing slice for `align_to{,_mut}`.\n+    #[cfg(not(stage0))]\n     fn align_to_offsets<U>(&self) -> (usize, usize) {\n         // What we gonna do about `rest` is figure out what multiple of `U`s we can put in a\n         // lowest number of `T`s. And how many `T`s we need for each such \"multiple\"."}, {"sha": "1b16d93ef274863c0eddb0ba9db8524d6d14a0d9", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=3ea24915894d49cb93eab52e65f1e4f0baa1bc32", "patch": "@@ -132,7 +132,7 @@ for ty::RegionKind {\n             ty::ReLateBound(..) |\n             ty::ReVar(..) |\n             ty::ReSkolemized(..) => {\n-                bug!(\"TypeIdHasher: unexpected region {:?}\", *self)\n+                bug!(\"StableHasher: unexpected region {:?}\", *self)\n             }\n         }\n     }"}, {"sha": "3db8c746713fd3f7cf64202b28804ba5029cef2e", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 50, "deletions": 56, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=3ea24915894d49cb93eab52e65f1e4f0baa1bc32", "patch": "@@ -117,6 +117,7 @@ use std::io::prelude::*;\n use std::io;\n use std::rc::Rc;\n use syntax::ast::{self, NodeId};\n+use syntax::ptr::P;\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n \n@@ -398,72 +399,65 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n     lsets.warn_about_unused_args(body, entry_ln);\n }\n \n-fn visit_local<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, local: &'tcx hir::Local) {\n-    local.pat.each_binding(|_, p_id, sp, path1| {\n-        debug!(\"adding local variable {}\", p_id);\n+fn add_from_pat<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, pat: &P<hir::Pat>) {\n+    // For struct patterns, take note of which fields used shorthand\n+    // (`x` rather than `x: x`).\n+    //\n+    // FIXME: according to the rust-lang-nursery/rustc-guide book, `NodeId`s are to be\n+    // phased out in favor of `HirId`s; however, we need to match the signature of\n+    // `each_binding`, which uses `NodeIds`.\n+    let mut shorthand_field_ids = NodeSet();\n+    let mut pats = VecDeque::new();\n+    pats.push_back(pat);\n+    while let Some(pat) = pats.pop_front() {\n+        use hir::PatKind::*;\n+        match pat.node {\n+            Binding(_, _, _, ref inner_pat) => {\n+                pats.extend(inner_pat.iter());\n+            }\n+            Struct(_, ref fields, _) => {\n+                for field in fields {\n+                    if field.node.is_shorthand {\n+                        shorthand_field_ids.insert(field.node.pat.id);\n+                    }\n+                }\n+            }\n+            Ref(ref inner_pat, _) |\n+            Box(ref inner_pat) => {\n+                pats.push_back(inner_pat);\n+            }\n+            TupleStruct(_, ref inner_pats, _) |\n+            Tuple(ref inner_pats, _) => {\n+                pats.extend(inner_pats.iter());\n+            }\n+            Slice(ref pre_pats, ref inner_pat, ref post_pats) => {\n+                pats.extend(pre_pats.iter());\n+                pats.extend(inner_pat.iter());\n+                pats.extend(post_pats.iter());\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    pat.each_binding(|_bm, p_id, _sp, path1| {\n         let name = path1.node;\n-        ir.add_live_node_for_node(p_id, VarDefNode(sp));\n+        ir.add_live_node_for_node(p_id, VarDefNode(path1.span));\n         ir.add_variable(Local(LocalInfo {\n             id: p_id,\n             name,\n-            is_shorthand: false,\n+            is_shorthand: shorthand_field_ids.contains(&p_id)\n         }));\n     });\n+}\n+\n+fn visit_local<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, local: &'tcx hir::Local) {\n+    add_from_pat(ir, &local.pat);\n     intravisit::walk_local(ir, local);\n }\n \n fn visit_arm<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, arm: &'tcx hir::Arm) {\n-    for mut pat in &arm.pats {\n-        // For struct patterns, take note of which fields used shorthand\n-        // (`x` rather than `x: x`).\n-        //\n-        // FIXME: according to the rust-lang-nursery/rustc-guide book, `NodeId`s are to be\n-        // phased out in favor of `HirId`s; however, we need to match the signature of\n-        // `each_binding`, which uses `NodeIds`.\n-        let mut shorthand_field_ids = NodeSet();\n-        let mut pats = VecDeque::new();\n-        pats.push_back(pat);\n-        while let Some(pat) = pats.pop_front() {\n-            use hir::PatKind::*;\n-            match pat.node {\n-                Binding(_, _, _, ref inner_pat) => {\n-                    pats.extend(inner_pat.iter());\n-                }\n-                Struct(_, ref fields, _) => {\n-                    for field in fields {\n-                        if field.node.is_shorthand {\n-                            shorthand_field_ids.insert(field.node.pat.id);\n-                        }\n-                    }\n-                }\n-                Ref(ref inner_pat, _) |\n-                Box(ref inner_pat) => {\n-                    pats.push_back(inner_pat);\n-                }\n-                TupleStruct(_, ref inner_pats, _) |\n-                Tuple(ref inner_pats, _) => {\n-                    pats.extend(inner_pats.iter());\n-                }\n-                Slice(ref pre_pats, ref inner_pat, ref post_pats) => {\n-                    pats.extend(pre_pats.iter());\n-                    pats.extend(inner_pat.iter());\n-                    pats.extend(post_pats.iter());\n-                }\n-                _ => {}\n-            }\n-        }\n-\n-        pat.each_binding(|bm, p_id, _sp, path1| {\n-            debug!(\"adding local variable {} from match with bm {:?}\",\n-                   p_id, bm);\n-            let name = path1.node;\n-            ir.add_live_node_for_node(p_id, VarDefNode(path1.span));\n-            ir.add_variable(Local(LocalInfo {\n-                id: p_id,\n-                name: name,\n-                is_shorthand: shorthand_field_ids.contains(&p_id)\n-            }));\n-        })\n+    for pat in &arm.pats {\n+        add_from_pat(ir, pat);\n     }\n     intravisit::walk_arm(ir, arm);\n }"}, {"sha": "7cfcbcb86af98a62ba67d17dbdbd92bfe0d4a1fc", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 150, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=3ea24915894d49cb93eab52e65f1e4f0baa1bc32", "patch": "@@ -15,23 +15,18 @@ use hir::def_id::DefId;\n use hir::map::{DefPathData, Node};\n use hir;\n use ich::NodeIdHashingMode;\n-use middle::const_val::ConstVal;\n use traits::{self, ObligationCause};\n use ty::{self, Ty, TyCtxt, GenericParamDefKind, TypeFoldable};\n-use ty::fold::TypeVisitor;\n use ty::subst::{Substs, UnpackedKind};\n use ty::maps::TyCtxtAt;\n use ty::TypeVariants::*;\n use ty::layout::{Integer, IntegerExt};\n use util::common::ErrorReported;\n use middle::lang_items;\n \n-use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n-                                           HashStable};\n+use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use rustc_data_structures::fx::FxHashMap;\n use std::{cmp, fmt};\n-use std::hash::Hash;\n-use std::intrinsics;\n use syntax::ast;\n use syntax::attr::{self, SignedInt, UnsignedInt};\n use syntax_pos::{Span, DUMMY_SP};\n@@ -615,150 +610,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub struct TypeIdHasher<'a, 'gcx: 'a+'tcx, 'tcx: 'a, W> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    state: StableHasher<W>,\n-}\n-\n-impl<'a, 'gcx, 'tcx, W> TypeIdHasher<'a, 'gcx, 'tcx, W>\n-    where W: StableHasherResult\n-{\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n-        TypeIdHasher { tcx: tcx, state: StableHasher::new() }\n-    }\n-\n-    pub fn finish(self) -> W {\n-        self.state.finish()\n-    }\n-\n-    pub fn hash<T: Hash>(&mut self, x: T) {\n-        x.hash(&mut self.state);\n-    }\n-\n-    fn hash_discriminant_u8<T>(&mut self, x: &T) {\n-        let v = unsafe {\n-            intrinsics::discriminant_value(x)\n-        };\n-        let b = v as u8;\n-        assert_eq!(v, b as u64);\n-        self.hash(b)\n-    }\n-\n-    fn def_id(&mut self, did: DefId) {\n-        // Hash the DefPath corresponding to the DefId, which is independent\n-        // of compiler internal state. We already have a stable hash value of\n-        // all DefPaths available via tcx.def_path_hash(), so we just feed that\n-        // into the hasher.\n-        let hash = self.tcx.def_path_hash(did);\n-        self.hash(hash);\n-    }\n-}\n-\n-impl<'a, 'gcx, 'tcx, W> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, W>\n-    where W: StableHasherResult\n-{\n-    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n-        // Distinguish between the Ty variants uniformly.\n-        self.hash_discriminant_u8(&ty.sty);\n-\n-        match ty.sty {\n-            TyInt(i) => self.hash(i),\n-            TyUint(u) => self.hash(u),\n-            TyFloat(f) => self.hash(f),\n-            TyArray(_, n) => {\n-                self.hash_discriminant_u8(&n.val);\n-                match n.val {\n-                    ConstVal::Value(alloc) => self.hash(alloc),\n-                    ConstVal::Unevaluated(def_id, _) => self.def_id(def_id),\n-                }\n-            }\n-            TyRawPtr(m) => self.hash(m.mutbl),\n-            TyRef(_, _, mutbl) => self.hash(mutbl),\n-            TyClosure(def_id, _) |\n-            TyGenerator(def_id, _, _) |\n-            TyAnon(def_id, _) |\n-            TyFnDef(def_id, _) => self.def_id(def_id),\n-            TyAdt(d, _) => self.def_id(d.did),\n-            TyForeign(def_id) => self.def_id(def_id),\n-            TyFnPtr(f) => {\n-                self.hash(f.unsafety());\n-                self.hash(f.abi());\n-                self.hash(f.variadic());\n-                self.hash(f.inputs().skip_binder().len());\n-            }\n-            TyDynamic(ref data, ..) => {\n-                if let Some(p) = data.principal() {\n-                    self.def_id(p.def_id());\n-                }\n-                for d in data.auto_traits() {\n-                    self.def_id(d);\n-                }\n-            }\n-            TyGeneratorWitness(tys) => {\n-                self.hash(tys.skip_binder().len());\n-            }\n-            TyTuple(tys) => {\n-                self.hash(tys.len());\n-            }\n-            TyParam(p) => {\n-                self.hash(p.idx);\n-                self.hash(p.name);\n-            }\n-            TyProjection(ref data) => {\n-                self.def_id(data.item_def_id);\n-            }\n-            TyNever |\n-            TyBool |\n-            TyChar |\n-            TyStr |\n-            TySlice(_) => {}\n-\n-            TyError |\n-            TyInfer(_) => bug!(\"TypeIdHasher: unexpected type {}\", ty)\n-        }\n-\n-        ty.super_visit_with(self)\n-    }\n-\n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n-        self.hash_discriminant_u8(r);\n-        match *r {\n-            ty::ReErased |\n-            ty::ReStatic |\n-            ty::ReEmpty => {\n-                // No variant fields to hash for these ...\n-            }\n-            ty::ReCanonical(c) => {\n-                self.hash(c);\n-            }\n-            ty::ReLateBound(db, ty::BrAnon(i)) => {\n-                self.hash(db.depth);\n-                self.hash(i);\n-            }\n-            ty::ReEarlyBound(ty::EarlyBoundRegion { def_id, .. }) => {\n-                self.def_id(def_id);\n-            }\n-\n-            ty::ReClosureBound(..) |\n-            ty::ReLateBound(..) |\n-            ty::ReFree(..) |\n-            ty::ReScope(..) |\n-            ty::ReVar(..) |\n-            ty::ReSkolemized(..) => {\n-                bug!(\"TypeIdHasher: unexpected region {:?}\", r)\n-            }\n-        }\n-        false\n-    }\n-\n-    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, x: &ty::Binder<T>) -> bool {\n-        // Anonymize late-bound regions so that, for example:\n-        // `for<'a, b> fn(&'a &'b T)` and `for<'a, b> fn(&'b &'a T)`\n-        // result in the same TypeId (the two types are equivalent).\n-        self.tcx.anonymize_late_bound_regions(x).super_visit_with(self)\n-    }\n-}\n-\n impl<'a, 'tcx> ty::TyS<'tcx> {\n     pub fn moves_by_default(&'tcx self,\n                             tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "221012903d9997214f82d8feffc42c3c439a3c02", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=3ea24915894d49cb93eab52e65f1e4f0baa1bc32", "patch": "@@ -127,8 +127,12 @@ impl LlvmType for Reg {\n impl LlvmType for CastTarget {\n     fn llvm_type(&self, cx: &CodegenCx) -> Type {\n         let rest_ll_unit = self.rest.unit.llvm_type(cx);\n-        let rest_count = self.rest.total.bytes() / self.rest.unit.size.bytes();\n-        let rem_bytes = self.rest.total.bytes() % self.rest.unit.size.bytes();\n+        let (rest_count, rem_bytes) = if self.rest.unit.size.bytes() == 0 {\n+            (0, 0)\n+        } else {\n+            (self.rest.total.bytes() / self.rest.unit.size.bytes(),\n+            self.rest.total.bytes() % self.rest.unit.size.bytes())\n+        };\n \n         if self.prefix.iter().all(|x| x.is_none()) {\n             // Simplify to a single unit when there is no prefix and size <= unit size"}, {"sha": "ae0f6067f476767b4bfed440552ae42abd128e88", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=3ea24915894d49cb93eab52e65f1e4f0baa1bc32", "patch": "@@ -23,12 +23,11 @@ use llvm::{self, ValueRef};\n use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor,\n                       DICompositeType, DILexicalBlock, DIFlags};\n \n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def::CtorKind;\n use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n-use rustc::ty::fold::TypeVisitor;\n-use rustc::ty::util::TypeIdHasher;\n-use rustc::ich::Fingerprint;\n+use rustc::ich::{Fingerprint, NodeIdHashingMode};\n use rustc::ty::Instance;\n use common::CodegenCx;\n use rustc::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n@@ -144,9 +143,15 @@ impl<'tcx> TypeMap<'tcx> {\n \n         // The hasher we are using to generate the UniqueTypeId. We want\n         // something that provides more than the 64 bits of the DefaultHasher.\n-        let mut type_id_hasher = TypeIdHasher::<Fingerprint>::new(cx.tcx);\n-        type_id_hasher.visit_ty(type_);\n-        let unique_type_id = type_id_hasher.finish().to_hex();\n+        let mut hasher = StableHasher::<Fingerprint>::new();\n+        let mut hcx = cx.tcx.create_stable_hashing_context();\n+        let type_ = cx.tcx.erase_regions(&type_);\n+        hcx.while_hashing_spans(false, |hcx| {\n+            hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+                type_.hash_stable(hcx, &mut hasher);\n+            });\n+        });\n+        let unique_type_id = hasher.finish().to_hex();\n \n         let key = self.unique_id_interner.intern(&unique_type_id);\n         self.type_to_unique_id.insert(type_, UniqueTypeId(key));"}, {"sha": "2063db6dc533103ece971c98f1372aadb6d10447", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 73, "deletions": 63, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=3ea24915894d49cb93eab52e65f1e4f0baa1bc32", "patch": "@@ -97,18 +97,19 @@\n //! virtually impossible. Thus, symbol hash generation exclusively relies on\n //! DefPaths which are much more robust in the face of changes to the code base.\n \n-use rustc::middle::weak_lang_items;\n-use rustc_mir::monomorphize::Instance;\n-use rustc_mir::monomorphize::item::{MonoItem, MonoItemExt, InstantiationMode};\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::hir::map as hir_map;\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::ty::fold::TypeVisitor;\n+use rustc::hir::map::definitions::DefPathData;\n+use rustc::ich::NodeIdHashingMode;\n+use rustc::middle::weak_lang_items;\n use rustc::ty::item_path::{self, ItemPathBuffer, RootMode};\n use rustc::ty::maps::Providers;\n use rustc::ty::subst::Substs;\n-use rustc::hir::map::definitions::DefPathData;\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::util::common::record_time;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_mir::monomorphize::item::{InstantiationMode, MonoItem, MonoItemExt};\n+use rustc_mir::monomorphize::Instance;\n \n use syntax::attr;\n use syntax_pos::symbol::Symbol;\n@@ -124,51 +125,60 @@ pub fn provide(providers: &mut Providers) {\n     };\n }\n \n-fn get_symbol_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn get_symbol_hash<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n-                             // the DefId of the item this name is for\n-                             def_id: DefId,\n+    // the DefId of the item this name is for\n+    def_id: DefId,\n \n-                             // instance this name will be for\n-                             instance: Instance<'tcx>,\n+    // instance this name will be for\n+    instance: Instance<'tcx>,\n \n-                             // type of the item, without any generic\n-                             // parameters substituted; this is\n-                             // included in the hash as a kind of\n-                             // safeguard.\n-                             item_type: Ty<'tcx>,\n+    // type of the item, without any generic\n+    // parameters substituted; this is\n+    // included in the hash as a kind of\n+    // safeguard.\n+    item_type: Ty<'tcx>,\n \n-                             // values for generic type parameters,\n-                             // if any.\n-                             substs: &'tcx Substs<'tcx>)\n-                             -> u64 {\n-    debug!(\"get_symbol_hash(def_id={:?}, parameters={:?})\", def_id, substs);\n+    // values for generic type parameters,\n+    // if any.\n+    substs: &'tcx Substs<'tcx>,\n+) -> u64 {\n+    debug!(\n+        \"get_symbol_hash(def_id={:?}, parameters={:?})\",\n+        def_id, substs\n+    );\n \n-    let mut hasher = ty::util::TypeIdHasher::<u64>::new(tcx);\n+    let mut hasher = StableHasher::<u64>::new();\n+    let mut hcx = tcx.create_stable_hashing_context();\n \n     record_time(&tcx.sess.perf_stats.symbol_hash_time, || {\n         // the main symbol name is not necessarily unique; hash in the\n         // compiler's internal def-path, guaranteeing each symbol has a\n         // truly unique path\n-        hasher.hash(tcx.def_path_hash(def_id));\n+        tcx.def_path_hash(def_id).hash_stable(&mut hcx, &mut hasher);\n \n         // Include the main item-type. Note that, in this case, the\n         // assertions about `needs_subst` may not hold, but this item-type\n         // ought to be the same for every reference anyway.\n         assert!(!item_type.has_erasable_regions());\n-        hasher.visit_ty(item_type);\n+        hcx.while_hashing_spans(false, |hcx| {\n+            hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+                item_type.hash_stable(hcx, &mut hasher);\n+            });\n+        });\n \n         // If this is a function, we hash the signature as well.\n         // This is not *strictly* needed, but it may help in some\n         // situations, see the `run-make/a-b-a-linker-guard` test.\n         if let ty::TyFnDef(..) = item_type.sty {\n-            item_type.fn_sig(tcx).visit_with(&mut hasher);\n+            item_type.fn_sig(tcx).hash_stable(&mut hcx, &mut hasher);\n         }\n \n         // also include any type parameters (for generic items)\n         assert!(!substs.has_erasable_regions());\n         assert!(!substs.needs_subst());\n-        substs.visit_with(&mut hasher);\n+        substs.hash_stable(&mut hcx, &mut hasher);\n \n         let is_generic = substs.types().next().is_some();\n         let avoid_cross_crate_conflicts =\n@@ -194,52 +204,47 @@ fn get_symbol_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 if !def_id.is_local() && tcx.share_generics() {\n                     // If we are re-using a monomorphization from another crate,\n                     // we have to compute the symbol hash accordingly.\n-                    let upstream_monomorphizations =\n-                        tcx.upstream_monomorphizations_for(def_id);\n+                    let upstream_monomorphizations = tcx.upstream_monomorphizations_for(def_id);\n \n-                    upstream_monomorphizations.and_then(|monos| monos.get(&substs)\n-                                                                     .cloned())\n-                                              .unwrap_or(LOCAL_CRATE)\n+                    upstream_monomorphizations\n+                        .and_then(|monos| monos.get(&substs).cloned())\n+                        .unwrap_or(LOCAL_CRATE)\n                 } else {\n                     LOCAL_CRATE\n                 }\n             } else {\n                 LOCAL_CRATE\n             };\n \n-            hasher.hash(&tcx.original_crate_name(instantiating_crate).as_str()[..]);\n-            hasher.hash(&tcx.crate_disambiguator(instantiating_crate));\n+            (&tcx.original_crate_name(instantiating_crate).as_str()[..])\n+                .hash_stable(&mut hcx, &mut hasher);\n+            (&tcx.crate_disambiguator(instantiating_crate)).hash_stable(&mut hcx, &mut hasher);\n         }\n     });\n \n     // 64 bits should be enough to avoid collisions.\n     hasher.finish()\n }\n \n-fn def_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-                             -> ty::SymbolName\n-{\n+fn def_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::SymbolName {\n     let mut buffer = SymbolPathBuffer::new();\n     item_path::with_forced_absolute_paths(|| {\n         tcx.push_item_path(&mut buffer, def_id);\n     });\n     buffer.into_interned()\n }\n \n-fn symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance<'tcx>)\n-                         -> ty::SymbolName\n-{\n-    ty::SymbolName { name: Symbol::intern(&compute_symbol_name(tcx, instance)).as_interned_str() }\n+fn symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance<'tcx>) -> ty::SymbolName {\n+    ty::SymbolName {\n+        name: Symbol::intern(&compute_symbol_name(tcx, instance)).as_interned_str(),\n+    }\n }\n \n-fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance<'tcx>)\n-    -> String\n-{\n+fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance<'tcx>) -> String {\n     let def_id = instance.def_id();\n     let substs = instance.substs;\n \n-    debug!(\"symbol_name(def_id={:?}, substs={:?})\",\n-           def_id, substs);\n+    debug!(\"symbol_name(def_id={:?}, substs={:?})\", def_id, substs);\n \n     let node_id = tcx.hir.as_local_node_id(def_id);\n \n@@ -259,7 +264,7 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n     let is_foreign = if let Some(id) = node_id {\n         match tcx.hir.get(id) {\n             hir_map::NodeForeignItem(_) => true,\n-            _ => false\n+            _ => false,\n         }\n     } else {\n         tcx.is_foreign_item(def_id)\n@@ -296,8 +301,7 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n     loop {\n         let key = tcx.def_key(ty_def_id);\n         match key.disambiguated_data.data {\n-            DefPathData::TypeNs(_) |\n-            DefPathData::ValueNs(_) => {\n+            DefPathData::TypeNs(_) | DefPathData::ValueNs(_) => {\n                 instance_ty = tcx.type_of(ty_def_id);\n                 break;\n             }\n@@ -306,8 +310,12 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n                 // to be a value or type-def or something in there\n                 // *somewhere*\n                 ty_def_id.index = key.parent.unwrap_or_else(|| {\n-                    bug!(\"finding type for {:?}, encountered def-id {:?} with no \\\n-                          parent\", def_id, ty_def_id);\n+                    bug!(\n+                        \"finding type for {:?}, encountered def-id {:?} with no \\\n+                         parent\",\n+                        def_id,\n+                        ty_def_id\n+                    );\n                 });\n             }\n         }\n@@ -337,14 +345,14 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n // use C++ name-mangling.\n struct SymbolPathBuffer {\n     result: String,\n-    temp_buf: String\n+    temp_buf: String,\n }\n \n impl SymbolPathBuffer {\n     fn new() -> Self {\n         let mut result = SymbolPathBuffer {\n             result: String::with_capacity(64),\n-            temp_buf: String::with_capacity(16)\n+            temp_buf: String::with_capacity(16),\n         };\n         result.result.push_str(\"_ZN\"); // _Z == Begin name-sequence, N == nested\n         result\n@@ -353,14 +361,16 @@ impl SymbolPathBuffer {\n     fn from_interned(symbol: ty::SymbolName) -> Self {\n         let mut result = SymbolPathBuffer {\n             result: String::with_capacity(64),\n-            temp_buf: String::with_capacity(16)\n+            temp_buf: String::with_capacity(16),\n         };\n         result.result.push_str(&symbol.name.as_str());\n         result\n     }\n \n     fn into_interned(self) -> ty::SymbolName {\n-        ty::SymbolName { name: Symbol::intern(&self.result).as_interned_str() }\n+        ty::SymbolName {\n+            name: Symbol::intern(&self.result).as_interned_str(),\n+        }\n     }\n \n     fn finish(mut self, hash: u64) -> String {\n@@ -379,7 +389,11 @@ impl ItemPathBuffer for SymbolPathBuffer {\n     fn push(&mut self, text: &str) {\n         self.temp_buf.clear();\n         let need_underscore = sanitize(&mut self.temp_buf, text);\n-        let _ = write!(self.result, \"{}\", self.temp_buf.len() + (need_underscore as usize));\n+        let _ = write!(\n+            self.result,\n+            \"{}\",\n+            self.temp_buf.len() + (need_underscore as usize)\n+        );\n         if need_underscore {\n             self.result.push('_');\n         }\n@@ -410,16 +424,13 @@ pub fn sanitize(result: &mut String, s: &str) -> bool {\n             '-' | ':' => result.push('.'),\n \n             // These are legal symbols\n-            'a' ... 'z'\n-            | 'A' ... 'Z'\n-            | '0' ... '9'\n-            | '_' | '.' | '$' => result.push(c),\n+            'a'...'z' | 'A'...'Z' | '0'...'9' | '_' | '.' | '$' => result.push(c),\n \n             _ => {\n                 result.push('$');\n                 for c in c.escape_unicode().skip(1) {\n                     match c {\n-                        '{' => {},\n+                        '{' => {}\n                         '}' => result.push('$'),\n                         c => result.push(c),\n                     }\n@@ -429,7 +440,6 @@ pub fn sanitize(result: &mut String, s: &str) -> bool {\n     }\n \n     // Underscore-qualify anything that didn't start as an ident.\n-    !result.is_empty() &&\n-        result.as_bytes()[0] != '_' as u8 &&\n-        ! (result.as_bytes()[0] as char).is_xid_start()\n+    !result.is_empty() && result.as_bytes()[0] != '_' as u8\n+        && !(result.as_bytes()[0] as char).is_xid_start()\n }"}, {"sha": "ac37937509eac46cd9e2d6069f561e3d1c9b7710", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=3ea24915894d49cb93eab52e65f1e4f0baa1bc32", "patch": "@@ -89,6 +89,8 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                 self.with_context(LabeledBlock, |v| v.visit_block(&b));\n             }\n             hir::ExprBreak(label, ref opt_expr) => {\n+                opt_expr.as_ref().map(|e| self.visit_expr(e));\n+\n                 if self.require_label_in_labeled_block(e.span, &label, \"break\") {\n                     // If we emitted an error about an unlabeled break in a labeled\n                     // block, we don't need any further checking for this break any more"}, {"sha": "56c931901cfb85cd6f7ed44c7d7520a8de1edf97", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=3ea24915894d49cb93eab52e65f1e4f0baa1bc32", "patch": "@@ -1 +1 @@\n-Subproject commit 1abfd0e562cc8f7a9577d97ee92246699093b954\n+Subproject commit 56c931901cfb85cd6f7ed44c7d7520a8de1edf97"}, {"sha": "5a0292bb6a16e55c7f2db7f5cc11f43a19fe9734", "filename": "src/rustllvm/llvm-rebuild-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2Frustllvm%2Fllvm-rebuild-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2Frustllvm%2Fllvm-rebuild-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-rebuild-trigger?ref=3ea24915894d49cb93eab52e65f1e4f0baa1bc32", "patch": "@@ -1,4 +1,4 @@\n # If this file is modified, then llvm will be (optionally) cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n-2018-04-05\n+2018-05-18\n\\ No newline at end of file"}, {"sha": "b8a7a089c2313f536ded33d6adb96d4e829a8be1", "filename": "src/test/ui/issue-50761.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2Ftest%2Fui%2Fissue-50761.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2Ftest%2Fui%2Fissue-50761.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-50761.rs?ref=3ea24915894d49cb93eab52e65f1e4f0baa1bc32", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Confirm that we don't accidently divide or mod by zero in llvm_type\n+\n+// compile-pass\n+\n+mod a {\n+    pub trait A {}\n+}\n+\n+mod b {\n+    pub struct Builder {}\n+\n+    pub fn new() -> Builder {\n+        Builder {}\n+    }\n+\n+    impl Builder {\n+        pub fn with_a(&mut self, _a: fn() -> ::a::A) {}\n+    }\n+}\n+\n+pub use self::b::new;\n+\n+fn main() {}"}, {"sha": "6342d0757ee53610ff9f38e67e0a6f8ea9d0ab07", "filename": "src/test/ui/issue-50802.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2Ftest%2Fui%2Fissue-50802.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2Ftest%2Fui%2Fissue-50802.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-50802.rs?ref=3ea24915894d49cb93eab52e65f1e4f0baa1bc32", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[allow(unreachable_code)]\n+\n+fn main() {\n+    loop {\n+        break while continue { //~ ERROR E0590\n+        }\n+    }\n+}"}, {"sha": "9da2648b376f74689b2079e1b84b259878bed8ba", "filename": "src/test/ui/issue-50802.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2Ftest%2Fui%2Fissue-50802.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2Ftest%2Fui%2Fissue-50802.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-50802.stderr?ref=3ea24915894d49cb93eab52e65f1e4f0baa1bc32", "patch": "@@ -0,0 +1,9 @@\n+error[E0590]: `break` or `continue` with no label in the condition of a `while` loop\n+  --> $DIR/issue-50802.rs:15:21\n+   |\n+LL |         break while continue { //~ ERROR E0590\n+   |                     ^^^^^^^^ unlabeled `continue` in the condition of a `while` loop\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0590`."}, {"sha": "bac3f00ffc79d85bdaeee5c2e1eddae826725f5a", "filename": "src/test/ui/lint/issue-47390-unused-variable-in-struct-pattern.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2Ftest%2Fui%2Flint%2Fissue-47390-unused-variable-in-struct-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2Ftest%2Fui%2Flint%2Fissue-47390-unused-variable-in-struct-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-47390-unused-variable-in-struct-pattern.rs?ref=3ea24915894d49cb93eab52e65f1e4f0baa1bc32", "patch": "@@ -20,6 +20,11 @@ struct SoulHistory {\n     endless_and_singing: bool\n }\n \n+struct LovelyAmbition {\n+    lips: usize,\n+    fire: usize\n+}\n+\n #[derive(Clone, Copy)]\n enum Large {\n     Suit { case: () }\n@@ -45,6 +50,10 @@ fn main() {\n         hours_are_suns = false;\n     }\n \n+    let the_spirit = LovelyAmbition { lips: 1, fire: 2 };\n+    let LovelyAmbition { lips, fire } = the_spirit;\n+    println!(\"{}\", lips);\n+\n     let bag = Large::Suit {\n         case: ()\n     };"}, {"sha": "a8b0e3e4250ea751410c6b07e0425e4ed682cf35", "filename": "src/test/ui/lint/issue-47390-unused-variable-in-struct-pattern.stderr", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2Ftest%2Fui%2Flint%2Fissue-47390-unused-variable-in-struct-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ea24915894d49cb93eab52e65f1e4f0baa1bc32/src%2Ftest%2Fui%2Flint%2Fissue-47390-unused-variable-in-struct-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-47390-unused-variable-in-struct-pattern.stderr?ref=3ea24915894d49cb93eab52e65f1e4f0baa1bc32", "patch": "@@ -1,5 +1,5 @@\n warning: unused variable: `i_think_continually`\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:31:9\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:36:9\n    |\n LL |     let i_think_continually = 2;\n    |         ^^^^^^^^^^^^^^^^^^^ help: consider using `_i_think_continually` instead\n@@ -12,39 +12,39 @@ LL | #![warn(unused)] // UI tests pass `-A unused` (#43896)\n    = note: #[warn(unused_variables)] implied by #[warn(unused)]\n \n warning: unused variable: `mut_unused_var`\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:38:13\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:43:13\n    |\n LL |     let mut mut_unused_var = 1;\n    |             ^^^^^^^^^^^^^^ help: consider using `_mut_unused_var` instead\n \n warning: unused variable: `var`\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:40:14\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:45:14\n    |\n LL |     let (mut var, unused_var) = (1, 2);\n    |              ^^^ help: consider using `_var` instead\n \n warning: unused variable: `unused_var`\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:40:19\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:45:19\n    |\n LL |     let (mut var, unused_var) = (1, 2);\n    |                   ^^^^^^^^^^ help: consider using `_unused_var` instead\n \n warning: unused variable: `corridors_of_light`\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:42:26\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:47:26\n    |\n LL |     if let SoulHistory { corridors_of_light,\n    |                          ^^^^^^^^^^^^^^^^^^ help: try ignoring the field: `corridors_of_light: _`\n \n warning: variable `hours_are_suns` is assigned to, but never used\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:43:30\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:48:30\n    |\n LL |                          mut hours_are_suns,\n    |                              ^^^^^^^^^^^^^^\n    |\n    = note: consider using `_hours_are_suns` instead\n \n warning: value assigned to `hours_are_suns` is never read\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:45:9\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:50:9\n    |\n LL |         hours_are_suns = false;\n    |         ^^^^^^^^^^^^^^\n@@ -56,44 +56,50 @@ LL | #![warn(unused)] // UI tests pass `-A unused` (#43896)\n    |         ^^^^^^\n    = note: #[warn(unused_assignments)] implied by #[warn(unused)]\n \n+warning: unused variable: `fire`\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:54:32\n+   |\n+LL |     let LovelyAmbition { lips, fire } = the_spirit;\n+   |                                ^^^^ help: try ignoring the field: `fire: _`\n+\n warning: unused variable: `case`\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:54:23\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:63:23\n    |\n LL |         Large::Suit { case } => {}\n    |                       ^^^^ help: try ignoring the field: `case: _`\n \n warning: unused variable: `case`\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:59:24\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:68:24\n    |\n LL |         &Large::Suit { case } => {}\n    |                        ^^^^ help: try ignoring the field: `case: _`\n \n warning: unused variable: `case`\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:64:27\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:73:27\n    |\n LL |         box Large::Suit { case } => {}\n    |                           ^^^^ help: try ignoring the field: `case: _`\n \n warning: unused variable: `case`\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:69:24\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:78:24\n    |\n LL |         (Large::Suit { case },) => {}\n    |                        ^^^^ help: try ignoring the field: `case: _`\n \n warning: unused variable: `case`\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:74:24\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:83:24\n    |\n LL |         [Large::Suit { case }] => {}\n    |                        ^^^^ help: try ignoring the field: `case: _`\n \n warning: unused variable: `case`\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:79:29\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:88:29\n    |\n LL |         Tuple(Large::Suit { case }, ()) => {}\n    |                             ^^^^ help: try ignoring the field: `case: _`\n \n warning: variable does not need to be mutable\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:38:9\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:43:9\n    |\n LL |     let mut mut_unused_var = 1;\n    |         ----^^^^^^^^^^^^^^\n@@ -108,7 +114,7 @@ LL | #![warn(unused)] // UI tests pass `-A unused` (#43896)\n    = note: #[warn(unused_mut)] implied by #[warn(unused)]\n \n warning: variable does not need to be mutable\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:40:10\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:45:10\n    |\n LL |     let (mut var, unused_var) = (1, 2);\n    |          ----^^^"}, {"sha": "ebe0b0eed596243a2839867363cb31d93f0b9754", "filename": "src/tools/clippy", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy?ref=3ea24915894d49cb93eab52e65f1e4f0baa1bc32", "patch": "@@ -1 +1 @@\n-Subproject commit c658fc8cbcd1f199edd445a49cb43139ebdc5f02\n+Subproject commit ebe0b0eed596243a2839867363cb31d93f0b9754"}]}