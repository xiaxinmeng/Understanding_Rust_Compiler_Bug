{"sha": "5427601e9ed173ad8e36adf02e5883729753af20", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0Mjc2MDFlOWVkMTczYWQ4ZTM2YWRmMDJlNTg4MzcyOTc1M2FmMjA=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2020-01-07T20:34:08Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2020-01-09T06:06:40Z"}, "message": "Change -Z time event naming scheme and make them generic activities", "tree": {"sha": "a761c1f8e8aa9d8e8896e5ac553060358719bd81", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a761c1f8e8aa9d8e8896e5ac553060358719bd81"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5427601e9ed173ad8e36adf02e5883729753af20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5427601e9ed173ad8e36adf02e5883729753af20", "html_url": "https://github.com/rust-lang/rust/commit/5427601e9ed173ad8e36adf02e5883729753af20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5427601e9ed173ad8e36adf02e5883729753af20/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "adc65725004c8aac16392fe4052c3e347181157d", "url": "https://api.github.com/repos/rust-lang/rust/commits/adc65725004c8aac16392fe4052c3e347181157d", "html_url": "https://github.com/rust-lang/rust/commit/adc65725004c8aac16392fe4052c3e347181157d"}], "stats": {"total": 439, "additions": 203, "deletions": 236}, "files": [{"sha": "46c5ee272d2352a97077189607f01f44b5710e7d", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=5427601e9ed173ad8e36adf02e5883729753af20", "patch": "@@ -1270,7 +1270,7 @@ pub fn map_crate<'hir>(\n         definitions,\n     };\n \n-    sess.time(\"validate HIR map\", || {\n+    sess.time(\"validate_HIR_map\", || {\n         hir_id_validator::check_crate(&map);\n     });\n "}, {"sha": "5d968811addd88d58fd8f8d1642ca09b8ce392ec", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=5427601e9ed173ad8e36adf02e5883729753af20", "patch": "@@ -198,7 +198,7 @@ impl<'sess> OnDiskCache<'sess> {\n             // Encode query results.\n             let mut query_result_index = EncodedQueryResultIndex::new();\n \n-            tcx.sess.time(\"encode query results\", || {\n+            tcx.sess.time(\"encode_query_results\", || {\n                 let enc = &mut encoder;\n                 let qri = &mut query_result_index;\n \n@@ -1053,8 +1053,8 @@ where\n     Q: super::config::QueryDescription<'tcx, Value: Encodable>,\n     E: 'a + TyEncoder,\n {\n-    let desc = &format!(\"encode_query_results for {}\", ::std::any::type_name::<Q>());\n-    let _timer = tcx.sess.prof.generic_pass(desc);\n+    let desc = &format!(\"encode_query_results_for_{}\", ::std::any::type_name::<Q>());\n+    let _timer = tcx.sess.prof.extra_verbose_generic_activity(desc);\n \n     let shards = Q::query_cache(tcx).lock_shards();\n     assert!(shards.iter().all(|shard| shard.active.is_empty()));"}, {"sha": "b5895b53698dcdd213413a94a57f3669620a3bef", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=5427601e9ed173ad8e36adf02e5883729753af20", "patch": "@@ -120,12 +120,13 @@ fn prepare_lto(\n                 info!(\"adding bytecode {}\", name);\n                 let bc_encoded = data.data();\n \n-                let (bc, id) = cgcx.prof.generic_pass(&format!(\"decode {}\", name)).run(|| {\n-                    match DecodedBytecode::new(bc_encoded) {\n+                let (bc, id) = cgcx\n+                    .prof\n+                    .extra_verbose_generic_activity(&format!(\"decode {}\", name))\n+                    .run(|| match DecodedBytecode::new(bc_encoded) {\n                         Ok(b) => Ok((b.bytecode(), b.identifier().to_string())),\n                         Err(e) => Err(diag_handler.fatal(&e)),\n-                    }\n-                })?;\n+                    })?;\n                 let bc = SerializedModule::FromRlib(bc);\n                 upstream_modules.push((bc, CString::new(id).unwrap()));\n             }\n@@ -280,8 +281,9 @@ fn fat_lto(\n         // save and persist everything with the original module.\n         let mut linker = Linker::new(llmod);\n         for (bc_decoded, name) in serialized_modules {\n+            let _timer = cgcx.prof.generic_activity(\"LLVM_fat_lto_link_module\");\n             info!(\"linking {:?}\", name);\n-            cgcx.prof.generic_pass(&format!(\"ll link {:?}\", name)).run(|| {\n+            cgcx.prof.extra_verbose_generic_activity(&format!(\"ll link {:?}\", name)).run(|| {\n                 let data = bc_decoded.data();\n                 linker.add(&data).map_err(|()| {\n                     let msg = format!(\"failed to load bc of {:?}\", name);\n@@ -633,7 +635,7 @@ pub(crate) fn run_pass_manager(\n         }\n \n         cgcx.prof\n-            .generic_pass(\"LTO passes\")\n+            .extra_verbose_generic_activity(\"LTO_passes\")\n             .run(|| llvm::LLVMRunPassManager(pm, module.module_llvm.llmod()));\n \n         llvm::LLVMDisposePassManager(pm);"}, {"sha": "4be7b84660d0994fb98b5b878bdae95cf751de74", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=5427601e9ed173ad8e36adf02e5883729753af20", "patch": "@@ -424,13 +424,23 @@ pub(crate) unsafe fn optimize(\n \n         // Finally, run the actual optimization passes\n         {\n+            let _timer = cgcx.prof.generic_activity(\"LLVM_module_optimize_function_passes\");\n             let desc = &format!(\"llvm function passes [{}]\", module_name.unwrap());\n-            let _timer = if config.time_module { Some(cgcx.prof.generic_pass(desc)) } else { None };\n+            let _timer = if config.time_module {\n+                Some(cgcx.prof.extra_verbose_generic_activity(desc))\n+            } else {\n+                None\n+            };\n             llvm::LLVMRustRunFunctionPassManager(fpm, llmod);\n         }\n         {\n+            let _timer = cgcx.prof.generic_activity(\"LLVM_module_optimize_module_passes\");\n             let desc = &format!(\"llvm module passes [{}]\", module_name.unwrap());\n-            let _timer = if config.time_module { Some(cgcx.prof.generic_pass(desc)) } else { None };\n+            let _timer = if config.time_module {\n+                Some(cgcx.prof.extra_verbose_generic_activity(desc))\n+            } else {\n+                None\n+            };\n             llvm::LLVMRunPassManager(mpm, llmod);\n         }\n \n@@ -556,7 +566,11 @@ pub(crate) unsafe fn codegen(\n \n         {\n             let desc = &format!(\"codegen passes [{}]\", module_name.unwrap());\n-            let _timer = if config.time_module { Some(cgcx.prof.generic_pass(desc)) } else { None };\n+            let _timer = if config.time_module {\n+                Some(cgcx.prof.extra_verbose_generic_activity(desc))\n+            } else {\n+                None\n+            };\n \n             if config.emit_ir {\n                 let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_ir\");"}, {"sha": "35c71a66756833e5fd5522977cc4b1768f6b85ee", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=5427601e9ed173ad8e36adf02e5883729753af20", "patch": "@@ -283,7 +283,7 @@ impl CodegenBackend for LlvmCodegenBackend {\n             rustc_codegen_ssa::back::write::dump_incremental_data(&codegen_results);\n         }\n \n-        sess.time(\"serialize work products\", move || {\n+        sess.time(\"serialize_work_products\", move || {\n             rustc_incremental::save_work_product_index(sess, &dep_graph, work_products)\n         });\n \n@@ -300,7 +300,7 @@ impl CodegenBackend for LlvmCodegenBackend {\n \n         // Run the linker on any artifacts that resulted from the LLVM run.\n         // This should produce either a finished executable or library.\n-        sess.time(\"linking\", || {\n+        sess.time(\"link_crate\", || {\n             use crate::back::archive::LlvmArchiveBuilder;\n             use rustc_codegen_ssa::back::link::link_binary;\n "}, {"sha": "253225f308e8899614cfed25d38bef093749bc9d", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=5427601e9ed173ad8e36adf02e5883729753af20", "patch": "@@ -577,7 +577,7 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n     let mut i = 0;\n     loop {\n         i += 1;\n-        prog = sess.time(\"running linker\", || exec_linker(sess, &mut cmd, out_filename, tmpdir));\n+        prog = sess.time(\"run_linker\", || exec_linker(sess, &mut cmd, out_filename, tmpdir));\n         let output = match prog {\n             Ok(ref output) => output,\n             Err(_) => break,\n@@ -1562,7 +1562,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n         let name = cratepath.file_name().unwrap().to_str().unwrap();\n         let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n \n-        sess.prof.generic_pass(&format!(\"altering {}.rlib\", name)).run(|| {\n+        sess.prof.extra_verbose_generic_activity(&format!(\"altering {}.rlib\", name)).run(|| {\n             let mut archive = <B as ArchiveBuilder>::new(sess, &dst, Some(cratepath));\n             archive.update_symbols();\n "}, {"sha": "1ce0a29d55d9d5b9cc74a82b7c20d7f3e98efccf", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=5427601e9ed173ad8e36adf02e5883729753af20", "patch": "@@ -1511,7 +1511,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         llvm_start_time: &mut Option<VerboseTimingGuard<'a>>,\n     ) {\n         if config.time_module && llvm_start_time.is_none() {\n-            *llvm_start_time = Some(prof.generic_pass(\"LLVM passes\"));\n+            *llvm_start_time = Some(prof.extra_verbose_generic_activity(\"LLVM_passes\"));\n         }\n     }\n }"}, {"sha": "c838109072775e572006e9d24c116689bad251f1", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=5427601e9ed173ad8e36adf02e5883729753af20", "patch": "@@ -566,7 +566,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n             cgu_name_builder.build_cgu_name(LOCAL_CRATE, &[\"crate\"], Some(\"allocator\")).to_string();\n         let mut modules = backend.new_metadata(tcx, &llmod_id);\n         tcx.sess\n-            .time(\"write allocator module\", || backend.codegen_allocator(tcx, &mut modules, kind));\n+            .time(\"write_allocator_module\", || backend.codegen_allocator(tcx, &mut modules, kind));\n \n         Some(ModuleCodegen { name: llmod_id, module_llvm: modules, kind: ModuleKind::Allocator })\n     } else {\n@@ -582,7 +582,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n         let metadata_cgu_name =\n             cgu_name_builder.build_cgu_name(LOCAL_CRATE, &[\"crate\"], Some(\"metadata\")).to_string();\n         let mut metadata_llvm_module = backend.new_metadata(tcx, &metadata_cgu_name);\n-        tcx.sess.time(\"write compressed metadata\", || {\n+        tcx.sess.time(\"write_compressed_metadata\", || {\n             backend.write_compressed_metadata(\n                 tcx,\n                 &ongoing_codegen.metadata,\n@@ -652,7 +652,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n \n     // Since the main thread is sometimes blocked during codegen, we keep track\n     // -Ztime-passes output manually.\n-    print_time_passes_entry(tcx.sess.time_passes(), \"codegen to LLVM IR\", total_codegen_time);\n+    print_time_passes_entry(tcx.sess.time_passes(), \"codegen_to_LLVM_IR\", total_codegen_time);\n \n     ::rustc_incremental::assert_module_sources::assert_module_sources(tcx);\n \n@@ -712,9 +712,9 @@ impl<B: ExtraBackendMethods> Drop for AbortCodegenOnDrop<B> {\n }\n \n fn assert_and_save_dep_graph(tcx: TyCtxt<'_>) {\n-    tcx.sess.time(\"assert dep graph\", || ::rustc_incremental::assert_dep_graph(tcx));\n+    tcx.sess.time(\"assert_dep_graph\", || ::rustc_incremental::assert_dep_graph(tcx));\n \n-    tcx.sess.time(\"serialize dep graph\", || ::rustc_incremental::save_dep_graph(tcx));\n+    tcx.sess.time(\"serialize_dep_graph\", || ::rustc_incremental::save_dep_graph(tcx));\n }\n \n impl CrateInfo {"}, {"sha": "b779bcbd55d70eda2d967cc43ac2f949043aac9b", "filename": "src/librustc_data_structures/profiling.rs", "status": "modified", "additions": 47, "deletions": 92, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_data_structures%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_data_structures%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fprofiling.rs?ref=5427601e9ed173ad8e36adf02e5883729753af20", "patch": "@@ -8,8 +8,6 @@ use std::thread::ThreadId;\n use std::time::{Duration, Instant};\n use std::u32;\n \n-use crate::cold_path;\n-\n use measureme::StringId;\n \n /// MmapSerializatioSink is faster on macOS and Linux\n@@ -44,15 +42,11 @@ bitflags::bitflags! {\n         const QUERY_CACHE_HITS   = 1 << 2;\n         const QUERY_BLOCKED      = 1 << 3;\n         const INCR_CACHE_LOADS   = 1 << 4;\n-        const SPARSE_PASS   = 1 << 5;\n-        const GENERIC_PASS   = 1 << 6;\n \n         const DEFAULT = Self::GENERIC_ACTIVITIES.bits |\n                         Self::QUERY_PROVIDERS.bits |\n                         Self::QUERY_BLOCKED.bits |\n-                        Self::INCR_CACHE_LOADS.bits |\n-                        Self::SPARSE_PASS.bits |\n-                        Self::GENERIC_PASS.bits;\n+                        Self::INCR_CACHE_LOADS.bits;\n \n         // empty() and none() aren't const-fns unfortunately\n         const NONE = 0;\n@@ -63,8 +57,6 @@ bitflags::bitflags! {\n const EVENT_FILTERS_BY_NAME: &[(&str, EventFilter)] = &[\n     (\"none\", EventFilter::NONE),\n     (\"all\", EventFilter::ALL),\n-    (\"sparse-pass\", EventFilter::SPARSE_PASS),\n-    (\"generic-pass\", EventFilter::GENERIC_PASS),\n     (\"generic-activity\", EventFilter::GENERIC_ACTIVITIES),\n     (\"query-provider\", EventFilter::QUERY_PROVIDERS),\n     (\"query-cache-hit\", EventFilter::QUERY_CACHE_HITS),\n@@ -89,101 +81,82 @@ pub struct SelfProfilerRef {\n     // actually enabled.\n     event_filter_mask: EventFilter,\n \n-    // Print sparse passes to stdout\n-    verbose_sparse: bool,\n+    // Print verbose generic activities to stdout\n+    print_verbose_generic_activities: bool,\n \n-    // Print generic passes to stdout\n-    verbose_generic: bool,\n+    // Print extra verbose generic activities to stdout\n+    print_extra_verbose_generic_activities: bool,\n }\n \n impl SelfProfilerRef {\n     pub fn new(\n         profiler: Option<Arc<SelfProfiler>>,\n-        verbose_sparse: bool,\n-        verbose_generic: bool,\n+        print_verbose_generic_activities: bool,\n+        print_extra_verbose_generic_activities: bool,\n     ) -> SelfProfilerRef {\n         // If there is no SelfProfiler then the filter mask is set to NONE,\n         // ensuring that nothing ever tries to actually access it.\n-        let mut event_filter_mask =\n+        let event_filter_mask =\n             profiler.as_ref().map(|p| p.event_filter_mask).unwrap_or(EventFilter::NONE);\n \n-        if verbose_sparse {\n-            event_filter_mask |= EventFilter::SPARSE_PASS;\n-        }\n-\n-        if verbose_generic {\n-            event_filter_mask |= EventFilter::GENERIC_PASS;\n+        SelfProfilerRef {\n+            profiler,\n+            event_filter_mask,\n+            print_verbose_generic_activities,\n+            print_extra_verbose_generic_activities,\n         }\n-\n-        SelfProfilerRef { profiler, event_filter_mask, verbose_sparse, verbose_generic }\n     }\n \n+    // This shim makes sure that calls only get executed if the filter mask\n+    // lets them pass. It also contains some trickery to make sure that\n+    // code is optimized for non-profiling compilation sessions, i.e. anything\n+    // past the filter check is never inlined so it doesn't clutter the fast\n+    // path.\n     #[inline(always)]\n     fn exec<F>(&self, event_filter: EventFilter, f: F) -> TimingGuard<'_>\n     where\n         F: for<'a> FnOnce(&'a SelfProfiler) -> TimingGuard<'a>,\n     {\n-        self.handle_event(\n-            event_filter,\n-            || f(self.profiler.as_ref().unwrap()),\n-            || TimingGuard::none(),\n-        )\n-    }\n+        #[inline(never)]\n+        fn cold_call<F>(profiler_ref: &SelfProfilerRef, f: F) -> TimingGuard<'_>\n+        where\n+            F: for<'a> FnOnce(&'a SelfProfiler) -> TimingGuard<'a>,\n+        {\n+            let profiler = profiler_ref.profiler.as_ref().unwrap();\n+            f(&**profiler)\n+        }\n \n-    // This shim makes sure that cold calls only get executed if the filter mask\n-    // lets them pass. It also contains some trickery to make sure that\n-    // code is optimized for non-profiling compilation sessions, i.e. anything\n-    // past the filter check is never inlined so it doesn't clutter the fast\n-    // path.\n-    #[inline(always)]\n-    fn handle_event<R>(\n-        &self,\n-        event_filter: EventFilter,\n-        cold: impl FnOnce() -> R,\n-        hot: impl FnOnce() -> R,\n-    ) -> R {\n         if unlikely!(self.event_filter_mask.contains(event_filter)) {\n-            cold_path(|| cold())\n+            cold_call(self, f)\n         } else {\n-            hot()\n+            TimingGuard::none()\n         }\n     }\n \n-    /// Start profiling a sparse pass. Profiling continues until the\n+    /// Start profiling a verbose generic activity. Profiling continues until the\n     /// VerboseTimingGuard returned from this call is dropped.\n     #[inline(always)]\n-    pub fn sparse_pass<'a>(&'a self, event_id: &'a str) -> VerboseTimingGuard<'a> {\n-        self.handle_event(\n-            EventFilter::SPARSE_PASS,\n-            || {\n-                VerboseTimingGuard::start(\n-                    self.profiler\n-                        .as_ref()\n-                        .map(|profiler| (&**profiler, profiler.sparse_pass_event_kind)),\n-                    event_id,\n-                    self.verbose_sparse,\n-                )\n-            },\n-            || VerboseTimingGuard::none(),\n+    pub fn verbose_generic_activity<'a>(&'a self, event_id: &'a str) -> VerboseTimingGuard<'a> {\n+        VerboseTimingGuard::start(\n+            event_id,\n+            self.print_verbose_generic_activities,\n+            self.generic_activity(event_id),\n         )\n     }\n \n-    /// Start profiling a generic pass. Profiling continues until the\n+    /// Start profiling a extra verbose generic activity. Profiling continues until the\n     /// VerboseTimingGuard returned from this call is dropped.\n     #[inline(always)]\n-    pub fn generic_pass<'a>(&'a self, event_id: &'a str) -> VerboseTimingGuard<'a> {\n-        self.handle_event(\n-            EventFilter::GENERIC_PASS,\n-            || {\n-                VerboseTimingGuard::start(\n-                    self.profiler\n-                        .as_ref()\n-                        .map(|profiler| (&**profiler, profiler.generic_pass_event_kind)),\n-                    event_id,\n-                    self.verbose_generic,\n-                )\n-            },\n-            || VerboseTimingGuard::none(),\n+    pub fn extra_verbose_generic_activity<'a>(\n+        &'a self,\n+        event_id: &'a str,\n+    ) -> VerboseTimingGuard<'a> {\n+        // FIXME: This does not yet emit a measureme event\n+        // because callers encode arguments into `event_id`.\n+        VerboseTimingGuard::start(\n+            event_id,\n+            self.print_extra_verbose_generic_activities,\n+            TimingGuard::none(),\n         )\n     }\n \n@@ -267,8 +240,6 @@ pub struct SelfProfiler {\n     profiler: Profiler,\n     event_filter_mask: EventFilter,\n     query_event_kind: StringId,\n-    sparse_pass_event_kind: StringId,\n-    generic_pass_event_kind: StringId,\n     generic_activity_event_kind: StringId,\n     incremental_load_result_event_kind: StringId,\n     query_blocked_event_kind: StringId,\n@@ -289,8 +260,6 @@ impl SelfProfiler {\n         let profiler = Profiler::new(&path)?;\n \n         let query_event_kind = profiler.alloc_string(\"Query\");\n-        let sparse_pass_event_kind = profiler.alloc_string(\"SparsePass\");\n-        let generic_pass_event_kind = profiler.alloc_string(\"GenericPass\");\n         let generic_activity_event_kind = profiler.alloc_string(\"GenericActivity\");\n         let incremental_load_result_event_kind = profiler.alloc_string(\"IncrementalLoadResult\");\n         let query_blocked_event_kind = profiler.alloc_string(\"QueryBlocked\");\n@@ -333,8 +302,6 @@ impl SelfProfiler {\n             profiler,\n             event_filter_mask,\n             query_event_kind,\n-            sparse_pass_event_kind,\n-            generic_pass_event_kind,\n             generic_activity_event_kind,\n             incremental_load_result_event_kind,\n             query_blocked_event_kind,\n@@ -386,19 +353,11 @@ pub struct VerboseTimingGuard<'a> {\n }\n \n impl<'a> VerboseTimingGuard<'a> {\n-    pub fn start(\n-        profiler: Option<(&'a SelfProfiler, StringId)>,\n-        event_id: &'a str,\n-        verbose: bool,\n-    ) -> Self {\n-        let _guard = profiler.map_or(TimingGuard::none(), |(profiler, event_kind)| {\n-            let event = profiler.profiler.alloc_string(event_id);\n-            TimingGuard::start(profiler, event_kind, event)\n-        });\n+    pub fn start(event_id: &'a str, verbose: bool, _guard: TimingGuard<'a>) -> Self {\n         VerboseTimingGuard {\n             event_id,\n             _guard,\n-            start: if verbose { Some(Instant::now()) } else { None },\n+            start: if unlikely!(verbose) { Some(Instant::now()) } else { None },\n         }\n     }\n \n@@ -407,10 +366,6 @@ impl<'a> VerboseTimingGuard<'a> {\n         let _timer = self;\n         f()\n     }\n-\n-    fn none() -> Self {\n-        VerboseTimingGuard { event_id: \"\", start: None, _guard: TimingGuard::none() }\n-    }\n }\n \n impl Drop for VerboseTimingGuard<'_> {"}, {"sha": "a5277bcd120ed19672a579ed4eb9dd4786615abe", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=5427601e9ed173ad8e36adf02e5883729753af20", "patch": "@@ -369,7 +369,7 @@ pub fn run_compiler(\n                 queries.global_ctxt()?.peek_mut().enter(|tcx| {\n                     let result = tcx.analysis(LOCAL_CRATE);\n \n-                    sess.time(\"save analysis\", || {\n+                    sess.time(\"save_analysis\", || {\n                         save::process_crate(\n                             tcx,\n                             &expanded_crate,"}, {"sha": "0732ddd3261a4265f7f01d45145d540d9d1757c0", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=5427601e9ed173ad8e36adf02e5883729753af20", "patch": "@@ -159,7 +159,7 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n     }\n \n     MaybeAsync::Async(std::thread::spawn(move || {\n-        let _prof_timer = prof.generic_pass(\"background load prev dep-graph\");\n+        let _prof_timer = prof.generic_activity(\"incr_comp_load_dep_graph\");\n \n         match load_data(report_incremental_info, &path) {\n             LoadResult::DataOutOfDate => LoadResult::DataOutOfDate,"}, {"sha": "588e639f28946f7ef3134318db1c55a0a51659c4", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=5427601e9ed173ad8e36adf02e5883729753af20", "patch": "@@ -32,15 +32,15 @@ pub fn save_dep_graph(tcx: TyCtxt<'_>) {\n         join(\n             move || {\n                 if tcx.sess.opts.debugging_opts.incremental_queries {\n-                    sess.time(\"persist query result cache\", || {\n+                    sess.time(\"incr_comp_persist_result_cache\", || {\n                         save_in(sess, query_cache_path, |e| encode_query_cache(tcx, e));\n                     });\n                 }\n             },\n             || {\n-                sess.time(\"persist dep-graph\", || {\n+                sess.time(\"incr_comp_persist_dep_graph\", || {\n                     save_in(sess, dep_graph_path, |e| {\n-                        sess.time(\"encode dep-graph\", || encode_dep_graph(tcx, e))\n+                        sess.time(\"incr_comp_encode_dep_graph\", || encode_dep_graph(tcx, e))\n                     });\n                 });\n             },\n@@ -142,7 +142,8 @@ fn encode_dep_graph(tcx: TyCtxt<'_>, encoder: &mut Encoder) {\n     tcx.sess.opts.dep_tracking_hash().encode(encoder).unwrap();\n \n     // Encode the graph data.\n-    let serialized_graph = tcx.sess.time(\"getting serialized graph\", || tcx.dep_graph.serialize());\n+    let serialized_graph =\n+        tcx.sess.time(\"incr_comp_serialize_dep_graph\", || tcx.dep_graph.serialize());\n \n     if tcx.sess.opts.debugging_opts.incremental_info {\n         #[derive(Clone)]\n@@ -223,7 +224,7 @@ fn encode_dep_graph(tcx: TyCtxt<'_>, encoder: &mut Encoder) {\n         println!(\"[incremental]\");\n     }\n \n-    tcx.sess.time(\"encoding serialized graph\", || {\n+    tcx.sess.time(\"incr_comp_encode_serialized_dep_graph\", || {\n         serialized_graph.encode(encoder).unwrap();\n     });\n }\n@@ -244,7 +245,7 @@ fn encode_work_product_index(\n }\n \n fn encode_query_cache(tcx: TyCtxt<'_>, encoder: &mut Encoder) {\n-    tcx.sess.time(\"serialize query result cache\", || {\n+    tcx.sess.time(\"incr_comp_serialize_result_cache\", || {\n         tcx.serialize_query_result_cache(encoder).unwrap();\n     })\n }"}, {"sha": "a7e174f04553c182755dbf229874e2b8ec8c16ed", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 55, "deletions": 66, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=5427601e9ed173ad8e36adf02e5883729753af20", "patch": "@@ -54,7 +54,7 @@ use std::rc::Rc;\n use std::{env, fs, iter, mem};\n \n pub fn parse<'a>(sess: &'a Session, input: &Input) -> PResult<'a, ast::Crate> {\n-    let krate = sess.time(\"parsing\", || match input {\n+    let krate = sess.time(\"parse_crate\", || match input {\n         Input::File(file) => parse_crate_from_file(file, &sess.parse_sess),\n         Input::Str { input, name } => {\n             parse_crate_from_source_str(name.clone(), input.clone(), &sess.parse_sess)\n@@ -155,7 +155,7 @@ pub fn register_plugins<'a>(\n     mut krate: ast::Crate,\n     crate_name: &str,\n ) -> Result<(ast::Crate, Lrc<lint::LintStore>)> {\n-    krate = sess.time(\"attributes injection\", || {\n+    krate = sess.time(\"attributes_injection\", || {\n         rustc_builtin_macros::cmdline_attrs::inject(\n             krate,\n             &sess.parse_sess,\n@@ -180,9 +180,7 @@ pub fn register_plugins<'a>(\n     rustc_incremental::prepare_session_directory(sess, &crate_name, disambiguator);\n \n     if sess.opts.incremental.is_some() {\n-        sess.time(\"garbage-collect incremental cache directory\", || {\n-            let _prof_timer =\n-                sess.prof.generic_activity(\"incr_comp_garbage_collect_session_directories\");\n+        sess.time(\"incr_comp_garbage_collect_session_directories\", || {\n             if let Err(e) = rustc_incremental::garbage_collect_session_directories(sess) {\n                 warn!(\n                     \"Error while trying to garbage collect incremental \\\n@@ -193,7 +191,7 @@ pub fn register_plugins<'a>(\n         });\n     }\n \n-    sess.time(\"recursion limit\", || {\n+    sess.time(\"recursion_limit\", || {\n         middle::recursion_limit::update_limits(sess, &krate);\n     });\n \n@@ -204,8 +202,8 @@ pub fn register_plugins<'a>(\n     register_lints(&sess, &mut lint_store);\n \n     let registrars =\n-        sess.time(\"plugin loading\", || plugin::load::load_plugins(sess, metadata_loader, &krate));\n-    sess.time(\"plugin registration\", || {\n+        sess.time(\"plugin_loading\", || plugin::load::load_plugins(sess, metadata_loader, &krate));\n+    sess.time(\"plugin_registration\", || {\n         let mut registry = plugin::Registry { lint_store: &mut lint_store };\n         for registrar in registrars {\n             registrar(&mut registry);\n@@ -223,7 +221,7 @@ fn configure_and_expand_inner<'a>(\n     resolver_arenas: &'a ResolverArenas<'a>,\n     metadata_loader: &'a MetadataLoaderDyn,\n ) -> Result<(ast::Crate, Resolver<'a>)> {\n-    sess.time(\"pre-AST-expansion lint checks\", || {\n+    sess.time(\"pre_AST_expansion_lint_checks\", || {\n         rustc_lint::check_ast_crate(\n             sess,\n             lint_store,\n@@ -237,7 +235,7 @@ fn configure_and_expand_inner<'a>(\n     let mut resolver = Resolver::new(sess, &krate, crate_name, metadata_loader, &resolver_arenas);\n     rustc_builtin_macros::register_builtin_macros(&mut resolver, sess.edition());\n \n-    krate = sess.time(\"crate injection\", || {\n+    krate = sess.time(\"crate_injection\", || {\n         let alt_std_name = sess.opts.alt_std_name.as_ref().map(|s| Symbol::intern(s));\n         let (krate, name) = rustc_builtin_macros::standard_library_imports::inject(\n             krate,\n@@ -254,7 +252,7 @@ fn configure_and_expand_inner<'a>(\n     util::check_attr_crate_type(&krate.attrs, &mut resolver.lint_buffer());\n \n     // Expand all macros\n-    krate = sess.time(\"expansion\", || {\n+    krate = sess.time(\"macro_expand_crate\", || {\n         // Windows dlls do not have rpaths, so they don't know how to find their\n         // dependencies. It's up to us to tell the system where to find all the\n         // dependent dlls. Note that this uses cfg!(windows) as opposed to\n@@ -299,11 +297,11 @@ fn configure_and_expand_inner<'a>(\n         let mut ecx = ExtCtxt::new(&sess.parse_sess, cfg, &mut resolver);\n \n         // Expand macros now!\n-        let krate = sess.time(\"expand crate\", || ecx.monotonic_expander().expand_crate(krate));\n+        let krate = sess.time(\"expand_crate\", || ecx.monotonic_expander().expand_crate(krate));\n \n         // The rest is error reporting\n \n-        sess.time(\"check unused macros\", || {\n+        sess.time(\"check_unused_macros\", || {\n             ecx.check_unused_macros();\n         });\n \n@@ -322,7 +320,7 @@ fn configure_and_expand_inner<'a>(\n         krate\n     });\n \n-    sess.time(\"maybe building test harness\", || {\n+    sess.time(\"maybe_building_test_harness\", || {\n         rustc_builtin_macros::test_harness::inject(\n             &sess.parse_sess,\n             &mut resolver,\n@@ -346,7 +344,7 @@ fn configure_and_expand_inner<'a>(\n         util::ReplaceBodyWithLoop::new(&mut resolver).visit_crate(&mut krate);\n     }\n \n-    let has_proc_macro_decls = sess.time(\"AST validation\", || {\n+    let has_proc_macro_decls = sess.time(\"AST_validation\", || {\n         ast_validation::check_crate(sess, &krate, &mut resolver.lint_buffer())\n     });\n \n@@ -368,7 +366,7 @@ fn configure_and_expand_inner<'a>(\n         msg.warn(\"The generated documentation may be incorrect\");\n         msg.emit()\n     } else {\n-        krate = sess.time(\"maybe creating a macro crate\", || {\n+        krate = sess.time(\"maybe_create_a_macro_crate\", || {\n             let num_crate_types = crate_types.len();\n             let is_test_crate = sess.opts.test;\n             rustc_builtin_macros::proc_macro_harness::inject(\n@@ -398,12 +396,10 @@ fn configure_and_expand_inner<'a>(\n         println!(\"{}\", json::as_json(&krate));\n     }\n \n-    sess.time(\"name resolution\", || {\n-        resolver.resolve_crate(&krate);\n-    });\n+    resolver.resolve_crate(&krate);\n \n     // Needs to go *after* expansion to be able to check the results of macro expansion.\n-    sess.time(\"complete gated feature checking\", || {\n+    sess.time(\"complete_gated_feature_checking\", || {\n         syntax::feature_gate::check_crate(\n             &krate,\n             &sess.parse_sess,\n@@ -432,24 +428,22 @@ pub fn lower_to_hir<'res, 'tcx>(\n     arena: &'tcx Arena<'tcx>,\n ) -> Result<map::Forest<'tcx>> {\n     // Lower AST to HIR.\n-    let hir_forest = sess.time(\"lowering AST -> HIR\", || {\n-        let hir_crate = rustc_ast_lowering::lower_crate(\n-            sess,\n-            &dep_graph,\n-            &krate,\n-            resolver,\n-            rustc_parse::nt_to_tokenstream,\n-            arena,\n-        );\n+    let hir_crate = rustc_ast_lowering::lower_crate(\n+        sess,\n+        &dep_graph,\n+        &krate,\n+        resolver,\n+        rustc_parse::nt_to_tokenstream,\n+        arena,\n+    );\n \n-        if sess.opts.debugging_opts.hir_stats {\n-            hir_stats::print_hir_stats(&hir_crate);\n-        }\n+    if sess.opts.debugging_opts.hir_stats {\n+        hir_stats::print_hir_stats(&hir_crate);\n+    }\n \n-        map::Forest::new(hir_crate, &dep_graph)\n-    });\n+    let hir_forest = map::Forest::new(hir_crate, &dep_graph);\n \n-    sess.time(\"early lint checks\", || {\n+    sess.time(\"early_lint_checks\", || {\n         rustc_lint::check_ast_crate(\n             sess,\n             lint_store,\n@@ -723,12 +717,9 @@ pub fn create_global_ctxt<'tcx>(\n     let defs = mem::take(&mut resolver_outputs.definitions);\n \n     // Construct the HIR map.\n-    let hir_map = sess.time(\"indexing HIR\", || {\n-        map::map_crate(sess, &*resolver_outputs.cstore, &hir_forest, defs)\n-    });\n+    let hir_map = map::map_crate(sess, &*resolver_outputs.cstore, &hir_forest, defs);\n \n-    let query_result_on_disk_cache =\n-        sess.time(\"load query result cache\", || rustc_incremental::load_query_result_cache(sess));\n+    let query_result_on_disk_cache = rustc_incremental::load_query_result_cache(sess);\n \n     let codegen_backend = compiler.codegen_backend();\n     let mut local_providers = ty::query::Providers::default();\n@@ -761,7 +752,7 @@ pub fn create_global_ctxt<'tcx>(\n \n     // Do some initialization of the DepGraph that can only be done with the tcx available.\n     ty::tls::enter_global(&gcx, |tcx| {\n-        tcx.sess.time(\"dep graph tcx init\", || rustc_incremental::dep_graph_tcx_init(tcx));\n+        tcx.sess.time(\"dep_graph_tcx_init\", || rustc_incremental::dep_graph_tcx_init(tcx));\n     });\n \n     QueryContext(gcx)\n@@ -775,17 +766,17 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n     let sess = tcx.sess;\n     let mut entry_point = None;\n \n-    sess.time(\"misc checking 1\", || {\n+    sess.time(\"misc_checking_1\", || {\n         parallel!(\n             {\n                 entry_point = sess\n-                    .time(\"looking for entry point\", || rustc_passes::entry::find_entry_point(tcx));\n+                    .time(\"looking_for_entry_point\", || rustc_passes::entry::find_entry_point(tcx));\n \n-                sess.time(\"looking for plugin registrar\", || {\n+                sess.time(\"looking_for_plugin_registrar\", || {\n                     plugin::build::find_plugin_registrar(tcx)\n                 });\n \n-                sess.time(\"looking for derive registrar\", || proc_macro_decls::find(tcx));\n+                sess.time(\"looking_for_derive_registrar\", || proc_macro_decls::find(tcx));\n             },\n             {\n                 par_iter(&tcx.hir().krate().modules).for_each(|(&module, _)| {\n@@ -802,17 +793,17 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n     // passes are timed inside typeck\n     typeck::check_crate(tcx)?;\n \n-    sess.time(\"misc checking 2\", || {\n+    sess.time(\"misc_checking_2\", || {\n         parallel!(\n             {\n-                sess.time(\"match checking\", || {\n+                sess.time(\"match_checking\", || {\n                     tcx.par_body_owners(|def_id| {\n                         tcx.ensure().check_match(def_id);\n                     });\n                 });\n             },\n             {\n-                sess.time(\"liveness checking + intrinsic checking\", || {\n+                sess.time(\"liveness_and_intrinsic_checking\", || {\n                     par_iter(&tcx.hir().krate().modules).for_each(|(&module, _)| {\n                         // this must run before MIR dump, because\n                         // \"not all control paths return a value\" is reported here.\n@@ -828,21 +819,21 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n         );\n     });\n \n-    sess.time(\"MIR borrow checking\", || {\n+    sess.time(\"MIR_borrow_checking\", || {\n         tcx.par_body_owners(|def_id| tcx.ensure().mir_borrowck(def_id));\n     });\n \n-    sess.time(\"dumping Chalk-like clauses\", || {\n+    sess.time(\"dumping_chalk_like_clauses\", || {\n         rustc_traits::lowering::dump_program_clauses(tcx);\n     });\n \n-    sess.time(\"MIR effect checking\", || {\n+    sess.time(\"MIR_effect_checking\", || {\n         for def_id in tcx.body_owners() {\n             mir::transform::check_unsafety::check_unsafety(tcx, def_id)\n         }\n     });\n \n-    sess.time(\"layout testing\", || layout_test::test_layout(tcx));\n+    sess.time(\"layout_testing\", || layout_test::test_layout(tcx));\n \n     // Avoid overwhelming user with errors if borrow checking failed.\n     // I'm not sure how helpful this is, to be honest, but it avoids a\n@@ -853,28 +844,25 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n         return Err(ErrorReported);\n     }\n \n-    sess.time(\"misc checking 3\", || {\n+    sess.time(\"misc_checking_3\", || {\n         parallel!(\n             {\n-                sess.time(\"privacy access levels\", || {\n-                    tcx.ensure().privacy_access_levels(LOCAL_CRATE);\n-                });\n+                tcx.ensure().privacy_access_levels(LOCAL_CRATE);\n+\n                 parallel!(\n                     {\n-                        sess.time(\"private in public\", || {\n-                            tcx.ensure().check_private_in_public(LOCAL_CRATE);\n-                        });\n+                        tcx.ensure().check_private_in_public(LOCAL_CRATE);\n                     },\n                     {\n-                        sess.time(\"death checking\", || rustc_passes::dead::check_crate(tcx));\n+                        sess.time(\"death_checking\", || rustc_passes::dead::check_crate(tcx));\n                     },\n                     {\n-                        sess.time(\"unused lib feature checking\", || {\n+                        sess.time(\"unused_lib_feature_checking\", || {\n                             rustc_passes::stability::check_unused_or_stable_features(tcx)\n                         });\n                     },\n                     {\n-                        sess.time(\"lint checking\", || {\n+                        sess.time(\"lint_checking\", || {\n                             rustc_lint::check_crate(tcx, || {\n                                 rustc_lint::BuiltinCombinedLateLintPass::new()\n                             });\n@@ -883,7 +871,7 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n                 );\n             },\n             {\n-                sess.time(\"privacy checking modules\", || {\n+                sess.time(\"privacy_checking_modules\", || {\n                     par_iter(&tcx.hir().krate().modules).for_each(|(&module, _)| {\n                         tcx.ensure().check_mod_privacy(tcx.hir().local_def_id(module));\n                     });\n@@ -926,6 +914,8 @@ fn encode_and_write_metadata(\n         MetadataKind::Uncompressed | MetadataKind::Compressed => tcx.encode_metadata(),\n     };\n \n+    let _prof_timer = tcx.sess.prof.generic_activity(\"write_crate_metadata\");\n+\n     let need_metadata_file = tcx.sess.opts.output_types.contains_key(&OutputType::Metadata);\n     if need_metadata_file {\n         let crate_name = &tcx.crate_name(LOCAL_CRATE).as_str();\n@@ -968,10 +958,9 @@ pub fn start_codegen<'tcx>(\n         tcx.print_debug_stats();\n     }\n \n-    let (metadata, need_metadata_module) =\n-        tcx.sess.time(\"metadata encoding and writing\", || encode_and_write_metadata(tcx, outputs));\n+    let (metadata, need_metadata_module) = encode_and_write_metadata(tcx, outputs);\n \n-    let codegen = tcx.sess.time(\"codegen\", move || {\n+    let codegen = tcx.sess.time(\"codegen_crate\", move || {\n         codegen_backend.codegen_crate(tcx, metadata, need_metadata_module)\n     });\n "}, {"sha": "6033569d765b482853eae811f3196de180d7ce76", "filename": "src/librustc_interface/queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_interface%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_interface%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fqueries.rs?ref=5427601e9ed173ad8e36adf02e5883729753af20", "patch": "@@ -195,7 +195,7 @@ impl<'tcx> Queries<'tcx> {\n                 None => DepGraph::new_disabled(),\n                 Some(future) => {\n                     let (prev_graph, prev_work_products) =\n-                        self.session().time(\"blocked while dep-graph loading finishes\", || {\n+                        self.session().time(\"blocked_on_dep_graph_loading\", || {\n                             future\n                                 .open()\n                                 .unwrap_or_else(|e| rustc_incremental::LoadResult::Error {"}, {"sha": "67c0c98b203807d0ca99c2752d2a7f28f086ff2f", "filename": "src/librustc_lint/early.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_lint%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_lint%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fearly.rs?ref=5427601e9ed173ad8e36adf02e5883729753af20", "patch": "@@ -350,16 +350,19 @@ pub fn check_ast_crate<T: EarlyLintPass>(\n         }\n     } else {\n         for pass in &mut passes {\n-            buffered = sess.time(&format!(\"running lint: {}\", pass.name()), || {\n-                early_lint_crate(\n-                    sess,\n-                    lint_store,\n-                    krate,\n-                    EarlyLintPassObjects { lints: slice::from_mut(pass) },\n-                    buffered,\n-                    pre_expansion,\n-                )\n-            });\n+            buffered = sess\n+                .prof\n+                .extra_verbose_generic_activity(&format!(\"running lint: {}\", pass.name()))\n+                .run(|| {\n+                    early_lint_crate(\n+                        sess,\n+                        lint_store,\n+                        krate,\n+                        EarlyLintPassObjects { lints: slice::from_mut(pass) },\n+                        buffered,\n+                        pre_expansion,\n+                    )\n+                });\n         }\n     }\n "}, {"sha": "07c3b95d69972c9dd6d726675e6ad9014a66ed71", "filename": "src/librustc_lint/late.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_lint%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_lint%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flate.rs?ref=5427601e9ed173ad8e36adf02e5883729753af20", "patch": "@@ -434,18 +434,27 @@ fn late_lint_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tcx>, b\n         late_lint_pass_crate(tcx, builtin_lints);\n     } else {\n         for pass in &mut passes {\n-            tcx.sess.time(&format!(\"running late lint: {}\", pass.name()), || {\n-                late_lint_pass_crate(tcx, LateLintPassObjects { lints: slice::from_mut(pass) });\n-            });\n+            tcx.sess\n+                .prof\n+                .extra_verbose_generic_activity(&format!(\"running late lint: {}\", pass.name()))\n+                .run(|| {\n+                    late_lint_pass_crate(tcx, LateLintPassObjects { lints: slice::from_mut(pass) });\n+                });\n         }\n \n         let mut passes: Vec<_> =\n             tcx.lint_store.late_module_passes.iter().map(|pass| (pass)()).collect();\n \n         for pass in &mut passes {\n-            tcx.sess.time(&format!(\"running late module lint: {}\", pass.name()), || {\n-                late_lint_pass_crate(tcx, LateLintPassObjects { lints: slice::from_mut(pass) });\n-            });\n+            tcx.sess\n+                .prof\n+                .extra_verbose_generic_activity(&format!(\n+                    \"running late module lint: {}\",\n+                    pass.name()\n+                ))\n+                .run(|| {\n+                    late_lint_pass_crate(tcx, LateLintPassObjects { lints: slice::from_mut(pass) });\n+                });\n         }\n     }\n }\n@@ -457,13 +466,13 @@ pub fn check_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n ) {\n     join(\n         || {\n-            tcx.sess.time(\"crate lints\", || {\n+            tcx.sess.time(\"crate_lints\", || {\n                 // Run whole crate non-incremental lints\n                 late_lint_crate(tcx, builtin_lints());\n             });\n         },\n         || {\n-            tcx.sess.time(\"module lints\", || {\n+            tcx.sess.time(\"module_lints\", || {\n                 // Run per-module lints\n                 par_iter(&tcx.hir().krate().modules).for_each(|(&module, _)| {\n                     tcx.ensure().lint_mod(tcx.hir().local_def_id(module));"}, {"sha": "41fbfd22e50afcc284de1936119de7865b61cd41", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=5427601e9ed173ad8e36adf02e5883729753af20", "patch": "@@ -283,10 +283,8 @@ pub fn collect_crate_mono_items(\n ) -> (FxHashSet<MonoItem<'_>>, InliningMap<'_>) {\n     let _prof_timer = tcx.prof.generic_activity(\"monomorphization_collector\");\n \n-    let roots = tcx.sess.time(\"collecting roots\", || {\n-        let _prof_timer = tcx.prof.generic_activity(\"monomorphization_collector_root_collections\");\n-        collect_roots(tcx, mode)\n-    });\n+    let roots =\n+        tcx.sess.time(\"monomorphization_collector_root_collections\", || collect_roots(tcx, mode));\n \n     debug!(\"building mono item graph, beginning at roots\");\n \n@@ -297,7 +295,7 @@ pub fn collect_crate_mono_items(\n         let visited: MTRef<'_, _> = &mut visited;\n         let inlining_map: MTRef<'_, _> = &mut inlining_map;\n \n-        tcx.sess.time(\"collecting mono items\", || {\n+        tcx.sess.time(\"monomorphization_collector_graph_walk\", || {\n             par_iter(roots).for_each(|root| {\n                 let mut recursion_depths = DefIdMap::default();\n                 collect_items_rec(tcx, root, visited, &mut recursion_depths, inlining_map);"}, {"sha": "8fa41cab190764ca83cf1ba5933ac9f33d6f16ce", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=5427601e9ed173ad8e36adf02e5883729753af20", "patch": "@@ -865,9 +865,7 @@ fn collect_and_partition_mono_items(\n         }\n     };\n \n-    let (items, inlining_map) = tcx.sess.time(\"monomorphization collection\", || {\n-        collector::collect_crate_mono_items(tcx, collection_mode)\n-    });\n+    let (items, inlining_map) = collector::collect_crate_mono_items(tcx, collection_mode);\n \n     tcx.sess.abort_if_errors();\n \n@@ -879,12 +877,10 @@ fn collect_and_partition_mono_items(\n         PartitioningStrategy::FixedUnitCount(tcx.sess.codegen_units())\n     };\n \n-    let codegen_units = tcx.sess.time(\"codegen unit partitioning\", || {\n-        partition(tcx, items.iter().cloned(), strategy, &inlining_map)\n-            .into_iter()\n-            .map(Arc::new)\n-            .collect::<Vec<_>>()\n-    });\n+    let codegen_units = partition(tcx, items.iter().cloned(), strategy, &inlining_map)\n+        .into_iter()\n+        .map(Arc::new)\n+        .collect::<Vec<_>>();\n \n     let mono_items: DefIdSet = items\n         .iter()"}, {"sha": "fda11b647490f709c50a3f222cda9b444246ff3d", "filename": "src/librustc_session/utils.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_session%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_session%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Futils.rs?ref=5427601e9ed173ad8e36adf02e5883729753af20", "patch": "@@ -2,11 +2,11 @@ use crate::session::Session;\n use rustc_data_structures::profiling::VerboseTimingGuard;\n \n impl Session {\n-    pub fn timer<'a>(&'a self, what: &'a str) -> VerboseTimingGuard<'a> {\n-        self.prof.sparse_pass(what)\n+    pub fn timer<'a>(&'a self, what: &'static str) -> VerboseTimingGuard<'a> {\n+        self.prof.verbose_generic_activity(what)\n     }\n-    pub fn time<R>(&self, what: &str, f: impl FnOnce() -> R) -> R {\n-        self.prof.sparse_pass(what).run(f)\n+    pub fn time<R>(&self, what: &'static str, f: impl FnOnce() -> R) -> R {\n+        self.prof.verbose_generic_activity(what).run(f)\n     }\n }\n "}, {"sha": "ca10601f4135b414f3caf13981b93af33924f0e4", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=5427601e9ed173ad8e36adf02e5883729753af20", "patch": "@@ -146,8 +146,8 @@ pub fn check_coherence(tcx: TyCtxt<'_>) {\n         tcx.ensure().coherent_trait(trait_def_id);\n     }\n \n-    tcx.sess.time(\"unsafety checking\", || unsafety::check(tcx));\n-    tcx.sess.time(\"orphan checking\", || orphan::check(tcx));\n+    tcx.sess.time(\"unsafety_checking\", || unsafety::check(tcx));\n+    tcx.sess.time(\"orphan_checking\", || orphan::check(tcx));\n \n     // these queries are executed for side-effects (error reporting):\n     tcx.ensure().crate_inherent_impls(LOCAL_CRATE);"}, {"sha": "0d9940cbf92c7ec368bb8776c66f046caadffcae", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5427601e9ed173ad8e36adf02e5883729753af20/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=5427601e9ed173ad8e36adf02e5883729753af20", "patch": "@@ -309,7 +309,7 @@ pub fn check_crate(tcx: TyCtxt<'_>) -> Result<(), ErrorReported> {\n     // have valid types and not error\n     // FIXME(matthewjasper) We shouldn't need to do this.\n     tcx.sess.track_errors(|| {\n-        tcx.sess.time(\"type collecting\", || {\n+        tcx.sess.time(\"type_collecting\", || {\n             for &module in tcx.hir().krate().modules.keys() {\n                 tcx.ensure().collect_mod_item_types(tcx.hir().local_def_id(module));\n             }\n@@ -318,35 +318,35 @@ pub fn check_crate(tcx: TyCtxt<'_>) -> Result<(), ErrorReported> {\n \n     if tcx.features().rustc_attrs {\n         tcx.sess.track_errors(|| {\n-            tcx.sess.time(\"outlives testing\", || outlives::test::test_inferred_outlives(tcx));\n+            tcx.sess.time(\"outlives_testing\", || outlives::test::test_inferred_outlives(tcx));\n         })?;\n     }\n \n     tcx.sess.track_errors(|| {\n-        tcx.sess.time(\"impl wf inference\", || impl_wf_check::impl_wf_check(tcx));\n+        tcx.sess.time(\"impl_wf_inference\", || impl_wf_check::impl_wf_check(tcx));\n     })?;\n \n     tcx.sess.track_errors(|| {\n-        tcx.sess.time(\"coherence checking\", || coherence::check_coherence(tcx));\n+        tcx.sess.time(\"coherence_checking\", || coherence::check_coherence(tcx));\n     })?;\n \n     if tcx.features().rustc_attrs {\n         tcx.sess.track_errors(|| {\n-            tcx.sess.time(\"variance testing\", || variance::test::test_variance(tcx));\n+            tcx.sess.time(\"variance_testing\", || variance::test::test_variance(tcx));\n         })?;\n     }\n \n     tcx.sess.track_errors(|| {\n-        tcx.sess.time(\"wf checking\", || check::check_wf_new(tcx));\n+        tcx.sess.time(\"wf_checking\", || check::check_wf_new(tcx));\n     })?;\n \n-    tcx.sess.time(\"item-types checking\", || {\n+    tcx.sess.time(\"item_types_checking\", || {\n         for &module in tcx.hir().krate().modules.keys() {\n             tcx.ensure().check_mod_item_types(tcx.hir().local_def_id(module));\n         }\n     });\n \n-    tcx.sess.time(\"item-bodies checking\", || tcx.typeck_item_bodies(LOCAL_CRATE));\n+    tcx.sess.time(\"item_bodies_checking\", || tcx.typeck_item_bodies(LOCAL_CRATE));\n \n     check_unused::check_crate(tcx);\n     check_for_entry_fn(tcx);"}]}