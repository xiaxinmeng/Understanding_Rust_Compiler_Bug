{"sha": "bdb901c865e024161b2e8b9428235f82235df070", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkYjkwMWM4NjVlMDI0MTYxYjJlOGI5NDI4MjM1ZjgyMjM1ZGYwNzA=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-11-30T17:05:59Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-11-30T18:03:43Z"}, "message": "Rollup merge of #56336 - nnethercote:clean-up-pp, r=nikomatsakis\n\nClean up and streamline the pretty-printer\n\nSome minor improvements.", "tree": {"sha": "31a3f2ad649d24afbf964584e4283fb3d9aec0d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31a3f2ad649d24afbf964584e4283fb3d9aec0d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bdb901c865e024161b2e8b9428235f82235df070", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAlwBe4AACgkQ/vbIBR0O\nATxVGA/+Ob8PxADKZVXsIf8rKY+PA0gnH9tyv427ac+j6boiQFmOtJaM1Ljm0Ona\nWG0MXLTwkXO2RFN5E843MrjF/BoQCHVm5Gjg5GAyj2vvprNjaJp0Gz+AZ81xGlNX\nl6Iavyl/657vtGzHUBS50tNfvejwQLLrjIkCWoHZhoh5pzvGRc1h1GGuyVwtrGiD\n2Ig297EAjL0fpBXHgoTcIfeh58z3hspCCqajR89wW+s/9OqdeFe5gwtNoX24JxWB\nSu4+obZjnqPJgcbYVxTisq/fEJnTUnzxEONo1gtc6Jo22F5tzF44puwAvoKm/y+0\nPhh0JYQvVPVGbgalp7fxGfvfwFV0TTJpdWshTayiUc9CqxWC3LndHMW5EpTcdmNx\nuhdNo5fhUELdHQdjz7v1w++6KgCZzkTxkjrG0IeFm0ZMYzIOdBrB2LByzwdsb+me\ntzYaExB0iYwPXtknZ6WZY9BWgDzQsQfylwdvdDwfNHR+3zD9zVkJXnQKa3/JnT8m\nwZbDrT9NvU7rTgd5kxjNAm8kI7+33xk7b1bviPWHz/uzlHqCK2a/IiqiCioWz8qO\niS1N3BP6GUi8CKX+dHAr1bxgRmY/kQS+SvDECeIhOkxtXO8VYZl6MgWXmB3OKYKf\n+rZFpPPHZn32p2qfoL0DNnPBCy/ebat4SGwWwNm5Wv6cJ9x1umk=\n=YQaJ\n-----END PGP SIGNATURE-----", "payload": "tree 31a3f2ad649d24afbf964584e4283fb3d9aec0d5\nparent ce00a8dd4d795f47a38a207af861a2cffcee7256\nparent 64cd645d14407d312c7ed3a10efd9b3a99271884\nauthor kennytm <kennytm@gmail.com> 1543597559 +0800\ncommitter kennytm <kennytm@gmail.com> 1543601023 +0800\n\nRollup merge of #56336 - nnethercote:clean-up-pp, r=nikomatsakis\n\nClean up and streamline the pretty-printer\n\nSome minor improvements.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bdb901c865e024161b2e8b9428235f82235df070", "html_url": "https://github.com/rust-lang/rust/commit/bdb901c865e024161b2e8b9428235f82235df070", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bdb901c865e024161b2e8b9428235f82235df070/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce00a8dd4d795f47a38a207af861a2cffcee7256", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce00a8dd4d795f47a38a207af861a2cffcee7256", "html_url": "https://github.com/rust-lang/rust/commit/ce00a8dd4d795f47a38a207af861a2cffcee7256"}, {"sha": "64cd645d14407d312c7ed3a10efd9b3a99271884", "url": "https://api.github.com/repos/rust-lang/rust/commits/64cd645d14407d312c7ed3a10efd9b3a99271884", "html_url": "https://github.com/rust-lang/rust/commit/64cd645d14407d312c7ed3a10efd9b3a99271884"}], "stats": {"total": 486, "additions": 254, "deletions": 232}, "files": [{"sha": "9a0ceddcf1b4a6d920832498b234d1648ddd635c", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/bdb901c865e024161b2e8b9428235f82235df070/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb901c865e024161b2e8b9428235f82235df070/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=bdb901c865e024161b2e8b9428235f82235df070", "patch": "@@ -25,6 +25,7 @@ use hir;\n use hir::{PatKind, GenericBound, TraitBoundModifier, RangeEnd};\n use hir::{GenericParam, GenericParamKind, GenericArg};\n \n+use std::borrow::Cow;\n use std::cell::Cell;\n use std::io::{self, Write, Read};\n use std::iter::Peekable;\n@@ -209,7 +210,7 @@ pub fn to_string<F>(ann: &dyn PpAnn, f: F) -> String\n     String::from_utf8(wr).unwrap()\n }\n \n-pub fn visibility_qualified(vis: &hir::Visibility, w: &str) -> String {\n+pub fn visibility_qualified<S: Into<Cow<'static, str>>>(vis: &hir::Visibility, w: S) -> String {\n     to_string(NO_ANN, |s| {\n         s.print_visibility(vis)?;\n         s.s.word(w)\n@@ -226,12 +227,13 @@ impl<'a> State<'a> {\n         self.s.word(\" \")\n     }\n \n-    pub fn word_nbsp(&mut self, w: &str) -> io::Result<()> {\n+    pub fn word_nbsp<S: Into<Cow<'static, str>>>(&mut self, w: S) -> io::Result<()> {\n         self.s.word(w)?;\n         self.nbsp()\n     }\n \n-    pub fn head(&mut self, w: &str) -> io::Result<()> {\n+    pub fn head<S: Into<Cow<'static, str>>>(&mut self, w: S) -> io::Result<()> {\n+        let w = w.into();\n         // outer-box is consistent\n         self.cbox(indent_unit)?;\n         // head-box is inconsistent\n@@ -303,7 +305,7 @@ impl<'a> State<'a> {\n     pub fn synth_comment(&mut self, text: String) -> io::Result<()> {\n         self.s.word(\"/*\")?;\n         self.s.space()?;\n-        self.s.word(&text[..])?;\n+        self.s.word(text)?;\n         self.s.space()?;\n         self.s.word(\"*/\")\n     }\n@@ -468,7 +470,7 @@ impl<'a> State<'a> {\n                 self.end() // end the outer fn box\n             }\n             hir::ForeignItemKind::Static(ref t, m) => {\n-                self.head(&visibility_qualified(&item.vis, \"static\"))?;\n+                self.head(visibility_qualified(&item.vis, \"static\"))?;\n                 if m {\n                     self.word_space(\"mut\")?;\n                 }\n@@ -480,7 +482,7 @@ impl<'a> State<'a> {\n                 self.end() // end the outer cbox\n             }\n             hir::ForeignItemKind::Type => {\n-                self.head(&visibility_qualified(&item.vis, \"type\"))?;\n+                self.head(visibility_qualified(&item.vis, \"type\"))?;\n                 self.print_name(item.name)?;\n                 self.s.word(\";\")?;\n                 self.end()?; // end the head-ibox\n@@ -495,7 +497,7 @@ impl<'a> State<'a> {\n                               default: Option<hir::BodyId>,\n                               vis: &hir::Visibility)\n                               -> io::Result<()> {\n-        self.s.word(&visibility_qualified(vis, \"\"))?;\n+        self.s.word(visibility_qualified(vis, \"\"))?;\n         self.word_space(\"const\")?;\n         self.print_ident(ident)?;\n         self.word_space(\":\")?;\n@@ -534,7 +536,7 @@ impl<'a> State<'a> {\n         self.ann.pre(self, AnnNode::Item(item))?;\n         match item.node {\n             hir::ItemKind::ExternCrate(orig_name) => {\n-                self.head(&visibility_qualified(&item.vis, \"extern crate\"))?;\n+                self.head(visibility_qualified(&item.vis, \"extern crate\"))?;\n                 if let Some(orig_name) = orig_name {\n                     self.print_name(orig_name)?;\n                     self.s.space()?;\n@@ -547,7 +549,7 @@ impl<'a> State<'a> {\n                 self.end()?; // end outer head-block\n             }\n             hir::ItemKind::Use(ref path, kind) => {\n-                self.head(&visibility_qualified(&item.vis, \"use\"))?;\n+                self.head(visibility_qualified(&item.vis, \"use\"))?;\n                 self.print_path(path, false)?;\n \n                 match kind {\n@@ -566,7 +568,7 @@ impl<'a> State<'a> {\n                 self.end()?; // end outer head-block\n             }\n             hir::ItemKind::Static(ref ty, m, expr) => {\n-                self.head(&visibility_qualified(&item.vis, \"static\"))?;\n+                self.head(visibility_qualified(&item.vis, \"static\"))?;\n                 if m == hir::MutMutable {\n                     self.word_space(\"mut\")?;\n                 }\n@@ -582,7 +584,7 @@ impl<'a> State<'a> {\n                 self.end()?; // end the outer cbox\n             }\n             hir::ItemKind::Const(ref ty, expr) => {\n-                self.head(&visibility_qualified(&item.vis, \"const\"))?;\n+                self.head(visibility_qualified(&item.vis, \"const\"))?;\n                 self.print_name(item.name)?;\n                 self.word_space(\":\")?;\n                 self.print_type(&ty)?;\n@@ -609,7 +611,7 @@ impl<'a> State<'a> {\n                 self.ann.nested(self, Nested::Body(body))?;\n             }\n             hir::ItemKind::Mod(ref _mod) => {\n-                self.head(&visibility_qualified(&item.vis, \"mod\"))?;\n+                self.head(visibility_qualified(&item.vis, \"mod\"))?;\n                 self.print_name(item.name)?;\n                 self.nbsp()?;\n                 self.bopen()?;\n@@ -618,18 +620,18 @@ impl<'a> State<'a> {\n             }\n             hir::ItemKind::ForeignMod(ref nmod) => {\n                 self.head(\"extern\")?;\n-                self.word_nbsp(&nmod.abi.to_string())?;\n+                self.word_nbsp(nmod.abi.to_string())?;\n                 self.bopen()?;\n                 self.print_foreign_mod(nmod, &item.attrs)?;\n                 self.bclose(item.span)?;\n             }\n             hir::ItemKind::GlobalAsm(ref ga) => {\n-                self.head(&visibility_qualified(&item.vis, \"global asm\"))?;\n-                self.s.word(&ga.asm.as_str())?;\n+                self.head(visibility_qualified(&item.vis, \"global asm\"))?;\n+                self.s.word(ga.asm.as_str().get())?;\n                 self.end()?\n             }\n             hir::ItemKind::Ty(ref ty, ref generics) => {\n-                self.head(&visibility_qualified(&item.vis, \"type\"))?;\n+                self.head(visibility_qualified(&item.vis, \"type\"))?;\n                 self.print_name(item.name)?;\n                 self.print_generic_params(&generics.params)?;\n                 self.end()?; // end the inner ibox\n@@ -642,7 +644,7 @@ impl<'a> State<'a> {\n                 self.end()?; // end the outer ibox\n             }\n             hir::ItemKind::Existential(ref exist) => {\n-                self.head(&visibility_qualified(&item.vis, \"existential type\"))?;\n+                self.head(visibility_qualified(&item.vis, \"existential type\"))?;\n                 self.print_name(item.name)?;\n                 self.print_generic_params(&exist.generics.params)?;\n                 self.end()?; // end the inner ibox\n@@ -668,11 +670,11 @@ impl<'a> State<'a> {\n                 self.print_enum_def(enum_definition, params, item.name, item.span, &item.vis)?;\n             }\n             hir::ItemKind::Struct(ref struct_def, ref generics) => {\n-                self.head(&visibility_qualified(&item.vis, \"struct\"))?;\n+                self.head(visibility_qualified(&item.vis, \"struct\"))?;\n                 self.print_struct(struct_def, generics, item.name, item.span, true)?;\n             }\n             hir::ItemKind::Union(ref struct_def, ref generics) => {\n-                self.head(&visibility_qualified(&item.vis, \"union\"))?;\n+                self.head(visibility_qualified(&item.vis, \"union\"))?;\n                 self.print_struct(struct_def, generics, item.name, item.span, true)?;\n             }\n             hir::ItemKind::Impl(unsafety,\n@@ -795,7 +797,7 @@ impl<'a> State<'a> {\n                           span: syntax_pos::Span,\n                           visibility: &hir::Visibility)\n                           -> io::Result<()> {\n-        self.head(&visibility_qualified(visibility, \"enum\"))?;\n+        self.head(visibility_qualified(visibility, \"enum\"))?;\n         self.print_name(name)?;\n         self.print_generic_params(&generics.params)?;\n         self.print_where_clause(&generics.where_clause)?;\n@@ -1587,14 +1589,14 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_usize(&mut self, i: usize) -> io::Result<()> {\n-        self.s.word(&i.to_string())\n+        self.s.word(i.to_string())\n     }\n \n     pub fn print_ident(&mut self, ident: ast::Ident) -> io::Result<()> {\n         if ident.is_raw_guess() {\n-            self.s.word(&format!(\"r#{}\", ident.name))?;\n+            self.s.word(format!(\"r#{}\", ident.name))?;\n         } else {\n-            self.s.word(&ident.as_str())?;\n+            self.s.word(ident.as_str().get())?;\n         }\n         self.ann.post(self, AnnNode::Name(&ident.name))\n     }\n@@ -2010,7 +2012,7 @@ impl<'a> State<'a> {\n         self.commasep(Inconsistent, &decl.inputs, |s, ty| {\n             s.ibox(indent_unit)?;\n             if let Some(arg_name) = arg_names.get(i) {\n-                s.s.word(&arg_name.as_str())?;\n+                s.s.word(arg_name.as_str().get())?;\n                 s.s.word(\":\")?;\n                 s.s.space()?;\n             } else if let Some(body_id) = body_id {\n@@ -2073,7 +2075,8 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_bounds(&mut self, prefix: &str, bounds: &[hir::GenericBound]) -> io::Result<()> {\n+    pub fn print_bounds(&mut self, prefix: &'static str, bounds: &[hir::GenericBound])\n+                        -> io::Result<()> {\n         if !bounds.is_empty() {\n             self.s.word(prefix)?;\n             let mut first = true;\n@@ -2322,7 +2325,7 @@ impl<'a> State<'a> {\n             Some(Abi::Rust) => Ok(()),\n             Some(abi) => {\n                 self.word_nbsp(\"extern\")?;\n-                self.word_nbsp(&abi.to_string())\n+                self.word_nbsp(abi.to_string())\n             }\n             None => Ok(()),\n         }\n@@ -2332,7 +2335,7 @@ impl<'a> State<'a> {\n         match opt_abi {\n             Some(abi) => {\n                 self.word_nbsp(\"extern\")?;\n-                self.word_nbsp(&abi.to_string())\n+                self.word_nbsp(abi.to_string())\n             }\n             None => Ok(()),\n         }\n@@ -2342,7 +2345,7 @@ impl<'a> State<'a> {\n                                 header: hir::FnHeader,\n                                 vis: &hir::Visibility)\n                                 -> io::Result<()> {\n-        self.s.word(&visibility_qualified(vis, \"\"))?;\n+        self.s.word(visibility_qualified(vis, \"\"))?;\n \n         match header.constness {\n             hir::Constness::NotConst => {}\n@@ -2358,7 +2361,7 @@ impl<'a> State<'a> {\n \n         if header.abi != Abi::Rust {\n             self.word_nbsp(\"extern\")?;\n-            self.word_nbsp(&header.abi.to_string())?;\n+            self.word_nbsp(header.abi.to_string())?;\n         }\n \n         self.s.word(\"fn\")"}, {"sha": "fb8093d1d77a73e3110cf731c75d5fa8f18c724c", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdb901c865e024161b2e8b9428235f82235df070/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb901c865e024161b2e8b9428235f82235df070/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=bdb901c865e024161b2e8b9428235f82235df070", "patch": "@@ -530,7 +530,7 @@ impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n                 s.s.space()?;\n                 s.s.word(\"as\")?;\n                 s.s.space()?;\n-                s.s.word(&self.tables.get().expr_ty(expr).to_string())?;\n+                s.s.word(self.tables.get().expr_ty(expr).to_string())?;\n                 s.pclose()\n             }\n             _ => Ok(()),"}, {"sha": "103331894ff1eebbc655a811ef9a5c819264a010", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdb901c865e024161b2e8b9428235f82235df070/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb901c865e024161b2e8b9428235f82235df070/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=bdb901c865e024161b2e8b9428235f82235df070", "patch": "@@ -185,7 +185,7 @@ fn unused_crates_lint<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) {\n             Some(orig_name) => format!(\"use {} as {};\", orig_name, item.name),\n             None => format!(\"use {};\", item.name),\n         };\n-        let replacement = visibility_qualified(&item.vis, &base_replacement);\n+        let replacement = visibility_qualified(&item.vis, base_replacement);\n         tcx.struct_span_lint_node(lint, id, extern_crate.span, msg)\n             .span_suggestion_short_with_applicability(\n                 extern_crate.span,"}, {"sha": "f13bb7df0b44402228bc80842b078beaf69de8f0", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdb901c865e024161b2e8b9428235f82235df070/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb901c865e024161b2e8b9428235f82235df070/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=bdb901c865e024161b2e8b9428235f82235df070", "patch": "@@ -2791,7 +2791,7 @@ impl<'a> Parser<'a> {\n                             s.print_usize(float.trunc() as usize)?;\n                             s.pclose()?;\n                             s.s.word(\".\")?;\n-                            s.s.word(fstr.splitn(2, \".\").last().unwrap())\n+                            s.s.word(fstr.splitn(2, \".\").last().unwrap().to_string())\n                         });\n                         err.span_suggestion_with_applicability(\n                             lo.to(self.prev_span),"}, {"sha": "aaed56da29d5f5e5173a7b150084cc0d94d5d88b", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 162, "deletions": 147, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/bdb901c865e024161b2e8b9428235f82235df070/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb901c865e024161b2e8b9428235f82235df070/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=bdb901c865e024161b2e8b9428235f82235df070", "patch": "@@ -140,13 +140,14 @@\n //! calculation, SCAN will write \"infinity\" to the size and let PRINT consume\n //! it.\n //!\n-//! In this implementation (following the paper, again) the SCAN process is\n-//! the method called `Printer::pretty_print`, and the 'PRINT' process is the method\n-//! called `Printer::print`.\n+//! In this implementation (following the paper, again) the SCAN process is the\n+//! methods called `Printer::pretty_print_*`, and the 'PRINT' process is the\n+//! method called `Printer::print`.\n \n use std::collections::VecDeque;\n use std::fmt;\n use std::io;\n+use std::borrow::Cow;\n \n /// How to break. Described in more detail in the module docs.\n #[derive(Clone, Copy, PartialEq)]\n@@ -169,7 +170,10 @@ pub struct BeginToken {\n \n #[derive(Clone)]\n pub enum Token {\n-    String(String, isize),\n+    // In practice a string token contains either a `&'static str` or a\n+    // `String`. `Cow` is overkill for this because we never modify the data,\n+    // but it's more convenient than rolling our own more specialized type.\n+    String(Cow<'static, str>, isize),\n     Break(BreakToken),\n     Begin(BeginToken),\n     End,\n@@ -309,84 +313,86 @@ impl<'a> Printer<'a> {\n     pub fn last_token(&mut self) -> Token {\n         self.buf[self.right].token.clone()\n     }\n-    /// be very careful with this!\n+\n+    /// Be very careful with this!\n     pub fn replace_last_token(&mut self, t: Token) {\n         self.buf[self.right].token = t;\n     }\n-    pub fn pretty_print(&mut self, token: Token) -> io::Result<()> {\n-        debug!(\"pp Vec<{},{}>\", self.left, self.right);\n-        match token {\n-          Token::Eof => {\n-            if !self.scan_stack.is_empty() {\n-                self.check_stack(0);\n-                self.advance_left()?;\n-            }\n-            self.indent(0);\n-            Ok(())\n-          }\n-          Token::Begin(b) => {\n-            if self.scan_stack.is_empty() {\n-                self.left_total = 1;\n-                self.right_total = 1;\n-                self.left = 0;\n-                self.right = 0;\n-            } else {\n-                self.advance_right();\n-            }\n-            debug!(\"pp Begin({})/buffer Vec<{},{}>\",\n-                   b.offset, self.left, self.right);\n-            self.buf[self.right] = BufEntry { token: token, size: -self.right_total };\n-            let right = self.right;\n-            self.scan_push(right);\n-            Ok(())\n-          }\n-          Token::End => {\n-            if self.scan_stack.is_empty() {\n-                debug!(\"pp End/print Vec<{},{}>\", self.left, self.right);\n-                self.print(token, 0)\n-            } else {\n-                debug!(\"pp End/buffer Vec<{},{}>\", self.left, self.right);\n-                self.advance_right();\n-                self.buf[self.right] = BufEntry { token: token, size: -1 };\n-                let right = self.right;\n-                self.scan_push(right);\n-                Ok(())\n-            }\n-          }\n-          Token::Break(b) => {\n-            if self.scan_stack.is_empty() {\n-                self.left_total = 1;\n-                self.right_total = 1;\n-                self.left = 0;\n-                self.right = 0;\n-            } else {\n-                self.advance_right();\n-            }\n-            debug!(\"pp Break({})/buffer Vec<{},{}>\",\n-                   b.offset, self.left, self.right);\n+\n+    fn pretty_print_eof(&mut self) -> io::Result<()> {\n+        if !self.scan_stack.is_empty() {\n             self.check_stack(0);\n+            self.advance_left()?;\n+        }\n+        self.indent(0);\n+        Ok(())\n+    }\n+\n+    fn pretty_print_begin(&mut self, b: BeginToken) -> io::Result<()> {\n+        if self.scan_stack.is_empty() {\n+            self.left_total = 1;\n+            self.right_total = 1;\n+            self.left = 0;\n+            self.right = 0;\n+        } else {\n+            self.advance_right();\n+        }\n+        debug!(\"pp Begin({})/buffer Vec<{},{}>\",\n+               b.offset, self.left, self.right);\n+        self.buf[self.right] = BufEntry { token: Token::Begin(b), size: -self.right_total };\n+        let right = self.right;\n+        self.scan_push(right);\n+        Ok(())\n+    }\n+\n+    fn pretty_print_end(&mut self) -> io::Result<()> {\n+        if self.scan_stack.is_empty() {\n+            debug!(\"pp End/print Vec<{},{}>\", self.left, self.right);\n+            self.print_end()\n+        } else {\n+            debug!(\"pp End/buffer Vec<{},{}>\", self.left, self.right);\n+            self.advance_right();\n+            self.buf[self.right] = BufEntry { token: Token::End, size: -1 };\n             let right = self.right;\n             self.scan_push(right);\n-            self.buf[self.right] = BufEntry { token: token, size: -self.right_total };\n-            self.right_total += b.blank_space;\n             Ok(())\n-          }\n-          Token::String(s, len) => {\n-            if self.scan_stack.is_empty() {\n-                debug!(\"pp String('{}')/print Vec<{},{}>\",\n-                       s, self.left, self.right);\n-                self.print(Token::String(s, len), len)\n-            } else {\n-                debug!(\"pp String('{}')/buffer Vec<{},{}>\",\n-                       s, self.left, self.right);\n-                self.advance_right();\n-                self.buf[self.right] = BufEntry { token: Token::String(s, len), size: len };\n-                self.right_total += len;\n-                self.check_stream()\n-            }\n-          }\n         }\n     }\n+\n+    fn pretty_print_break(&mut self, b: BreakToken) -> io::Result<()> {\n+        if self.scan_stack.is_empty() {\n+            self.left_total = 1;\n+            self.right_total = 1;\n+            self.left = 0;\n+            self.right = 0;\n+        } else {\n+            self.advance_right();\n+        }\n+        debug!(\"pp Break({})/buffer Vec<{},{}>\",\n+               b.offset, self.left, self.right);\n+        self.check_stack(0);\n+        let right = self.right;\n+        self.scan_push(right);\n+        self.buf[self.right] = BufEntry { token: Token::Break(b), size: -self.right_total };\n+        self.right_total += b.blank_space;\n+        Ok(())\n+    }\n+\n+    fn pretty_print_string(&mut self, s: Cow<'static, str>, len: isize) -> io::Result<()> {\n+        if self.scan_stack.is_empty() {\n+            debug!(\"pp String('{}')/print Vec<{},{}>\",\n+                   s, self.left, self.right);\n+            self.print_string(s, len)\n+        } else {\n+            debug!(\"pp String('{}')/buffer Vec<{},{}>\",\n+                   s, self.left, self.right);\n+            self.advance_right();\n+            self.buf[self.right] = BufEntry { token: Token::String(s, len), size: len };\n+            self.right_total += len;\n+            self.check_stream()\n+        }\n+    }\n+\n     pub fn check_stream(&mut self) -> io::Result<()> {\n         debug!(\"check_stream Vec<{}, {}> with left_total={}, right_total={}\",\n                self.left, self.right, self.left_total, self.right_total);\n@@ -405,19 +411,24 @@ impl<'a> Printer<'a> {\n         }\n         Ok(())\n     }\n+\n     pub fn scan_push(&mut self, x: usize) {\n         debug!(\"scan_push {}\", x);\n         self.scan_stack.push_front(x);\n     }\n+\n     pub fn scan_pop(&mut self) -> usize {\n         self.scan_stack.pop_front().unwrap()\n     }\n+\n     pub fn scan_top(&mut self) -> usize {\n         *self.scan_stack.front().unwrap()\n     }\n+\n     pub fn scan_pop_bottom(&mut self) -> usize {\n         self.scan_stack.pop_back().unwrap()\n     }\n+\n     pub fn advance_right(&mut self) {\n         self.right += 1;\n         self.right %= self.buf_max_len;\n@@ -427,6 +438,7 @@ impl<'a> Printer<'a> {\n         }\n         assert_ne!(self.right, self.left);\n     }\n+\n     pub fn advance_left(&mut self) -> io::Result<()> {\n         debug!(\"advance_left Vec<{},{}>, sizeof({})={}\", self.left, self.right,\n                self.left, self.buf[self.left].size);\n@@ -461,6 +473,7 @@ impl<'a> Printer<'a> {\n \n         Ok(())\n     }\n+\n     pub fn check_stack(&mut self, k: isize) {\n         if !self.scan_stack.is_empty() {\n             let x = self.scan_top();\n@@ -488,17 +501,20 @@ impl<'a> Printer<'a> {\n             }\n         }\n     }\n+\n     pub fn print_newline(&mut self, amount: isize) -> io::Result<()> {\n         debug!(\"NEWLINE {}\", amount);\n         let ret = write!(self.out, \"\\n\");\n         self.pending_indentation = 0;\n         self.indent(amount);\n         ret\n     }\n+\n     pub fn indent(&mut self, amount: isize) {\n         debug!(\"INDENT {}\", amount);\n         self.pending_indentation += amount;\n     }\n+\n     pub fn get_top(&mut self) -> PrintStackElem {\n         match self.print_stack.last() {\n             Some(el) => *el,\n@@ -508,62 +524,50 @@ impl<'a> Printer<'a> {\n             }\n         }\n     }\n-    pub fn print_str(&mut self, s: &str) -> io::Result<()> {\n-        while self.pending_indentation > 0 {\n-            write!(self.out, \" \")?;\n-            self.pending_indentation -= 1;\n+\n+    pub fn print_begin(&mut self, b: BeginToken, l: isize) -> io::Result<()> {\n+        if l > self.space {\n+            let col = self.margin - self.space + b.offset;\n+            debug!(\"print Begin -> push broken block at col {}\", col);\n+            self.print_stack.push(PrintStackElem {\n+                offset: col,\n+                pbreak: PrintStackBreak::Broken(b.breaks)\n+            });\n+        } else {\n+            debug!(\"print Begin -> push fitting block\");\n+            self.print_stack.push(PrintStackElem {\n+                offset: 0,\n+                pbreak: PrintStackBreak::Fits\n+            });\n         }\n-        write!(self.out, \"{}\", s)\n+        Ok(())\n     }\n-    pub fn print(&mut self, token: Token, l: isize) -> io::Result<()> {\n-        debug!(\"print {} {} (remaining line space={})\", token, l,\n-               self.space);\n-        debug!(\"{}\", buf_str(&self.buf,\n-                             self.left,\n-                             self.right,\n-                             6));\n-        match token {\n-          Token::Begin(b) => {\n-            if l > self.space {\n-                let col = self.margin - self.space + b.offset;\n-                debug!(\"print Begin -> push broken block at col {}\", col);\n-                self.print_stack.push(PrintStackElem {\n-                    offset: col,\n-                    pbreak: PrintStackBreak::Broken(b.breaks)\n-                });\n-            } else {\n-                debug!(\"print Begin -> push fitting block\");\n-                self.print_stack.push(PrintStackElem {\n-                    offset: 0,\n-                    pbreak: PrintStackBreak::Fits\n-                });\n-            }\n-            Ok(())\n-          }\n-          Token::End => {\n-            debug!(\"print End -> pop End\");\n-            let print_stack = &mut self.print_stack;\n-            assert!(!print_stack.is_empty());\n-            print_stack.pop().unwrap();\n-            Ok(())\n-          }\n-          Token::Break(b) => {\n-            let top = self.get_top();\n-            match top.pbreak {\n-              PrintStackBreak::Fits => {\n+\n+    pub fn print_end(&mut self) -> io::Result<()> {\n+        debug!(\"print End -> pop End\");\n+        let print_stack = &mut self.print_stack;\n+        assert!(!print_stack.is_empty());\n+        print_stack.pop().unwrap();\n+        Ok(())\n+    }\n+\n+    pub fn print_break(&mut self, b: BreakToken, l: isize) -> io::Result<()> {\n+        let top = self.get_top();\n+        match top.pbreak {\n+            PrintStackBreak::Fits => {\n                 debug!(\"print Break({}) in fitting block\", b.blank_space);\n                 self.space -= b.blank_space;\n                 self.indent(b.blank_space);\n                 Ok(())\n-              }\n-              PrintStackBreak::Broken(Breaks::Consistent) => {\n+            }\n+            PrintStackBreak::Broken(Breaks::Consistent) => {\n                 debug!(\"print Break({}+{}) in consistent block\",\n                        top.offset, b.offset);\n                 let ret = self.print_newline(top.offset + b.offset);\n                 self.space = self.margin - (top.offset + b.offset);\n                 ret\n-              }\n-              PrintStackBreak::Broken(Breaks::Inconsistent) => {\n+            }\n+            PrintStackBreak::Broken(Breaks::Inconsistent) => {\n                 if l > self.space {\n                     debug!(\"print Break({}+{}) w/ newline in inconsistent\",\n                            top.offset, b.offset);\n@@ -577,31 +581,48 @@ impl<'a> Printer<'a> {\n                     self.space -= b.blank_space;\n                     Ok(())\n                 }\n-              }\n             }\n-          }\n-          Token::String(ref s, len) => {\n-            debug!(\"print String({})\", s);\n-            assert_eq!(l, len);\n-            // assert!(l <= space);\n-            self.space -= len;\n-            self.print_str(s)\n-          }\n-          Token::Eof => {\n-            // Eof should never get here.\n-            panic!();\n-          }\n+        }\n+    }\n+\n+    pub fn print_string(&mut self, s: Cow<'static, str>, len: isize) -> io::Result<()> {\n+        debug!(\"print String({})\", s);\n+        // assert!(len <= space);\n+        self.space -= len;\n+        while self.pending_indentation > 0 {\n+            write!(self.out, \" \")?;\n+            self.pending_indentation -= 1;\n+        }\n+        write!(self.out, \"{}\", s)\n+    }\n+\n+    pub fn print(&mut self, token: Token, l: isize) -> io::Result<()> {\n+        debug!(\"print {} {} (remaining line space={})\", token, l,\n+               self.space);\n+        debug!(\"{}\", buf_str(&self.buf,\n+                             self.left,\n+                             self.right,\n+                             6));\n+        match token {\n+            Token::Begin(b) => self.print_begin(b, l),\n+            Token::End => self.print_end(),\n+            Token::Break(b) => self.print_break(b, l),\n+            Token::String(s, len) => {\n+                assert_eq!(len, l);\n+                self.print_string(s, len)\n+            }\n+            Token::Eof => panic!(), // Eof should never get here.\n         }\n     }\n \n     // Convenience functions to talk to the printer.\n \n     /// \"raw box\"\n     pub fn rbox(&mut self, indent: usize, b: Breaks) -> io::Result<()> {\n-        self.pretty_print(Token::Begin(BeginToken {\n+        self.pretty_print_begin(BeginToken {\n             offset: indent as isize,\n             breaks: b\n-        }))\n+        })\n     }\n \n     /// Inconsistent breaking box\n@@ -615,30 +636,24 @@ impl<'a> Printer<'a> {\n     }\n \n     pub fn break_offset(&mut self, n: usize, off: isize) -> io::Result<()> {\n-        self.pretty_print(Token::Break(BreakToken {\n+        self.pretty_print_break(BreakToken {\n             offset: off,\n             blank_space: n as isize\n-        }))\n+        })\n     }\n \n     pub fn end(&mut self) -> io::Result<()> {\n-        self.pretty_print(Token::End)\n+        self.pretty_print_end()\n     }\n \n     pub fn eof(&mut self) -> io::Result<()> {\n-        self.pretty_print(Token::Eof)\n-    }\n-\n-    pub fn word(&mut self, wrd: &str) -> io::Result<()> {\n-        self.pretty_print(Token::String(wrd.to_string(), wrd.len() as isize))\n-    }\n-\n-    pub fn huge_word(&mut self, wrd: &str) -> io::Result<()> {\n-        self.pretty_print(Token::String(wrd.to_string(), SIZE_INFINITY))\n+        self.pretty_print_eof()\n     }\n \n-    pub fn zero_word(&mut self, wrd: &str) -> io::Result<()> {\n-        self.pretty_print(Token::String(wrd.to_string(), 0))\n+    pub fn word<S: Into<Cow<'static, str>>>(&mut self, wrd: S) -> io::Result<()> {\n+        let s = wrd.into();\n+        let len = s.len() as isize;\n+        self.pretty_print_string(s, len)\n     }\n \n     fn spaces(&mut self, n: usize) -> io::Result<()> {"}, {"sha": "14ad4b5c6f8159475b23ac5ba31b5d4775e51ce5", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/bdb901c865e024161b2e8b9428235f82235df070/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb901c865e024161b2e8b9428235f82235df070/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=bdb901c865e024161b2e8b9428235f82235df070", "patch": "@@ -29,6 +29,7 @@ use syntax_pos::{DUMMY_SP, FileName};\n use tokenstream::{self, TokenStream, TokenTree};\n \n use std::ascii;\n+use std::borrow::Cow;\n use std::io::{self, Write, Read};\n use std::iter::Peekable;\n use std::vec;\n@@ -444,7 +445,7 @@ pub trait PrintState<'a> {\n     fn cur_lit(&mut self) -> Option<&comments::Literal>;\n     fn bump_lit(&mut self) -> Option<comments::Literal>;\n \n-    fn word_space(&mut self, w: &str) -> io::Result<()> {\n+    fn word_space<S: Into<Cow<'static, str>>>(&mut self, w: S) -> io::Result<()> {\n         self.writer().word(w)?;\n         self.writer().space()\n     }\n@@ -539,7 +540,7 @@ pub trait PrintState<'a> {\n             comments::Mixed => {\n                 assert_eq!(cmnt.lines.len(), 1);\n                 self.writer().zerobreak()?;\n-                self.writer().word(&cmnt.lines[0])?;\n+                self.writer().word(cmnt.lines[0].clone())?;\n                 self.writer().zerobreak()\n             }\n             comments::Isolated => {\n@@ -548,7 +549,7 @@ pub trait PrintState<'a> {\n                     // Don't print empty lines because they will end up as trailing\n                     // whitespace\n                     if !line.is_empty() {\n-                        self.writer().word(&line[..])?;\n+                        self.writer().word(line.clone())?;\n                     }\n                     self.writer().hardbreak()?;\n                 }\n@@ -559,13 +560,13 @@ pub trait PrintState<'a> {\n                     self.writer().word(\" \")?;\n                 }\n                 if cmnt.lines.len() == 1 {\n-                    self.writer().word(&cmnt.lines[0])?;\n+                    self.writer().word(cmnt.lines[0].clone())?;\n                     self.writer().hardbreak()\n                 } else {\n                     self.ibox(0)?;\n                     for line in &cmnt.lines {\n                         if !line.is_empty() {\n-                            self.writer().word(&line[..])?;\n+                            self.writer().word(line.clone())?;\n                         }\n                         self.writer().hardbreak()?;\n                     }\n@@ -610,39 +611,39 @@ pub trait PrintState<'a> {\n     fn print_literal(&mut self, lit: &ast::Lit) -> io::Result<()> {\n         self.maybe_print_comment(lit.span.lo())?;\n         if let Some(ltrl) = self.next_lit(lit.span.lo()) {\n-            return self.writer().word(&ltrl.lit);\n+            return self.writer().word(ltrl.lit.clone());\n         }\n         match lit.node {\n             ast::LitKind::Str(st, style) => self.print_string(&st.as_str(), style),\n             ast::LitKind::Byte(byte) => {\n                 let mut res = String::from(\"b'\");\n                 res.extend(ascii::escape_default(byte).map(|c| c as char));\n                 res.push('\\'');\n-                self.writer().word(&res[..])\n+                self.writer().word(res)\n             }\n             ast::LitKind::Char(ch) => {\n                 let mut res = String::from(\"'\");\n                 res.extend(ch.escape_default());\n                 res.push('\\'');\n-                self.writer().word(&res[..])\n+                self.writer().word(res)\n             }\n             ast::LitKind::Int(i, t) => {\n                 match t {\n                     ast::LitIntType::Signed(st) => {\n-                        self.writer().word(&st.val_to_string(i as i128))\n+                        self.writer().word(st.val_to_string(i as i128))\n                     }\n                     ast::LitIntType::Unsigned(ut) => {\n-                        self.writer().word(&ut.val_to_string(i))\n+                        self.writer().word(ut.val_to_string(i))\n                     }\n                     ast::LitIntType::Unsuffixed => {\n-                        self.writer().word(&i.to_string())\n+                        self.writer().word(i.to_string())\n                     }\n                 }\n             }\n             ast::LitKind::Float(ref f, t) => {\n-                self.writer().word(&format!(\"{}{}\", &f, t.ty_to_string()))\n+                self.writer().word(format!(\"{}{}\", &f, t.ty_to_string()))\n             }\n-            ast::LitKind::FloatUnsuffixed(ref f) => self.writer().word(&f.as_str()),\n+            ast::LitKind::FloatUnsuffixed(ref f) => self.writer().word(f.as_str().get()),\n             ast::LitKind::Bool(val) => {\n                 if val { self.writer().word(\"true\") } else { self.writer().word(\"false\") }\n             }\n@@ -652,7 +653,7 @@ pub trait PrintState<'a> {\n                     escaped.extend(ascii::escape_default(ch)\n                                          .map(|c| c as char));\n                 }\n-                self.writer().word(&format!(\"b\\\"{}\\\"\", escaped))\n+                self.writer().word(format!(\"b\\\"{}\\\"\", escaped))\n             }\n         }\n     }\n@@ -669,7 +670,7 @@ pub trait PrintState<'a> {\n                          string=st))\n             }\n         };\n-        self.writer().word(&st[..])\n+        self.writer().word(st)\n     }\n \n     fn print_inner_attributes(&mut self,\n@@ -727,7 +728,7 @@ pub trait PrintState<'a> {\n             if segment.ident.name != keywords::CrateRoot.name() &&\n                segment.ident.name != keywords::DollarCrate.name()\n             {\n-                self.writer().word(&segment.ident.as_str())?;\n+                self.writer().word(segment.ident.as_str().get())?;\n             } else if segment.ident.name == keywords::DollarCrate.name() {\n                 self.print_dollar_crate(segment.ident.span.ctxt())?;\n             }\n@@ -746,7 +747,7 @@ pub trait PrintState<'a> {\n         }\n         self.maybe_print_comment(attr.span.lo())?;\n         if attr.is_sugared_doc {\n-            self.writer().word(&attr.value_str().unwrap().as_str())?;\n+            self.writer().word(attr.value_str().unwrap().as_str().get())?;\n             self.writer().hardbreak()\n         } else {\n             match attr.style {\n@@ -807,7 +808,7 @@ pub trait PrintState<'a> {\n     fn print_tt(&mut self, tt: tokenstream::TokenTree) -> io::Result<()> {\n         match tt {\n             TokenTree::Token(_, ref tk) => {\n-                self.writer().word(&token_to_string(tk))?;\n+                self.writer().word(token_to_string(tk))?;\n                 match *tk {\n                     parse::token::DocComment(..) => {\n                         self.writer().hardbreak()\n@@ -816,11 +817,11 @@ pub trait PrintState<'a> {\n                 }\n             }\n             TokenTree::Delimited(_, ref delimed) => {\n-                self.writer().word(&token_to_string(&delimed.open_token()))?;\n+                self.writer().word(token_to_string(&delimed.open_token()))?;\n                 self.writer().space()?;\n                 self.print_tts(delimed.stream())?;\n                 self.writer().space()?;\n-                self.writer().word(&token_to_string(&delimed.close_token()))\n+                self.writer().word(token_to_string(&delimed.close_token()))\n             },\n         }\n     }\n@@ -889,12 +890,13 @@ impl<'a> State<'a> {\n         self.s.cbox(u)\n     }\n \n-    pub fn word_nbsp(&mut self, w: &str) -> io::Result<()> {\n+    pub fn word_nbsp<S: Into<Cow<'static, str>>>(&mut self, w: S) -> io::Result<()> {\n         self.s.word(w)?;\n         self.nbsp()\n     }\n \n-    pub fn head(&mut self, w: &str) -> io::Result<()> {\n+    pub fn head<S: Into<Cow<'static, str>>>(&mut self, w: S) -> io::Result<()> {\n+        let w = w.into();\n         // outer-box is consistent\n         self.cbox(INDENT_UNIT)?;\n         // head-box is inconsistent\n@@ -956,7 +958,7 @@ impl<'a> State<'a> {\n     pub fn synth_comment(&mut self, text: String) -> io::Result<()> {\n         self.s.word(\"/*\")?;\n         self.s.space()?;\n-        self.s.word(&text[..])?;\n+        self.s.word(text)?;\n         self.s.space()?;\n         self.s.word(\"*/\")\n     }\n@@ -1129,7 +1131,7 @@ impl<'a> State<'a> {\n                 self.end() // end the outer fn box\n             }\n             ast::ForeignItemKind::Static(ref t, m) => {\n-                self.head(&visibility_qualified(&item.vis, \"static\"))?;\n+                self.head(visibility_qualified(&item.vis, \"static\"))?;\n                 if m {\n                     self.word_space(\"mut\")?;\n                 }\n@@ -1141,7 +1143,7 @@ impl<'a> State<'a> {\n                 self.end() // end the outer cbox\n             }\n             ast::ForeignItemKind::Ty => {\n-                self.head(&visibility_qualified(&item.vis, \"type\"))?;\n+                self.head(visibility_qualified(&item.vis, \"type\"))?;\n                 self.print_ident(item.ident)?;\n                 self.s.word(\";\")?;\n                 self.end()?; // end the head-ibox\n@@ -1164,7 +1166,7 @@ impl<'a> State<'a> {\n                               vis: &ast::Visibility)\n                               -> io::Result<()>\n     {\n-        self.s.word(&visibility_qualified(vis, \"\"))?;\n+        self.s.word(visibility_qualified(vis, \"\"))?;\n         self.word_space(\"const\")?;\n         self.print_ident(ident)?;\n         self.word_space(\":\")?;\n@@ -1203,7 +1205,7 @@ impl<'a> State<'a> {\n         self.ann.pre(self, AnnNode::Item(item))?;\n         match item.node {\n             ast::ItemKind::ExternCrate(orig_name) => {\n-                self.head(&visibility_qualified(&item.vis, \"extern crate\"))?;\n+                self.head(visibility_qualified(&item.vis, \"extern crate\"))?;\n                 if let Some(orig_name) = orig_name {\n                     self.print_name(orig_name)?;\n                     self.s.space()?;\n@@ -1216,14 +1218,14 @@ impl<'a> State<'a> {\n                 self.end()?; // end outer head-block\n             }\n             ast::ItemKind::Use(ref tree) => {\n-                self.head(&visibility_qualified(&item.vis, \"use\"))?;\n+                self.head(visibility_qualified(&item.vis, \"use\"))?;\n                 self.print_use_tree(tree)?;\n                 self.s.word(\";\")?;\n                 self.end()?; // end inner head-block\n                 self.end()?; // end outer head-block\n             }\n             ast::ItemKind::Static(ref ty, m, ref expr) => {\n-                self.head(&visibility_qualified(&item.vis, \"static\"))?;\n+                self.head(visibility_qualified(&item.vis, \"static\"))?;\n                 if m == ast::Mutability::Mutable {\n                     self.word_space(\"mut\")?;\n                 }\n@@ -1239,7 +1241,7 @@ impl<'a> State<'a> {\n                 self.end()?; // end the outer cbox\n             }\n             ast::ItemKind::Const(ref ty, ref expr) => {\n-                self.head(&visibility_qualified(&item.vis, \"const\"))?;\n+                self.head(visibility_qualified(&item.vis, \"const\"))?;\n                 self.print_ident(item.ident)?;\n                 self.word_space(\":\")?;\n                 self.print_type(ty)?;\n@@ -1264,7 +1266,7 @@ impl<'a> State<'a> {\n                 self.print_block_with_attrs(body, &item.attrs)?;\n             }\n             ast::ItemKind::Mod(ref _mod) => {\n-                self.head(&visibility_qualified(&item.vis, \"mod\"))?;\n+                self.head(visibility_qualified(&item.vis, \"mod\"))?;\n                 self.print_ident(item.ident)?;\n \n                 if _mod.inline || self.is_expanded {\n@@ -1281,18 +1283,18 @@ impl<'a> State<'a> {\n             }\n             ast::ItemKind::ForeignMod(ref nmod) => {\n                 self.head(\"extern\")?;\n-                self.word_nbsp(&nmod.abi.to_string())?;\n+                self.word_nbsp(nmod.abi.to_string())?;\n                 self.bopen()?;\n                 self.print_foreign_mod(nmod, &item.attrs)?;\n                 self.bclose(item.span)?;\n             }\n             ast::ItemKind::GlobalAsm(ref ga) => {\n-                self.head(&visibility_qualified(&item.vis, \"global_asm!\"))?;\n-                self.s.word(&ga.asm.as_str())?;\n+                self.head(visibility_qualified(&item.vis, \"global_asm!\"))?;\n+                self.s.word(ga.asm.as_str().get())?;\n                 self.end()?;\n             }\n             ast::ItemKind::Ty(ref ty, ref generics) => {\n-                self.head(&visibility_qualified(&item.vis, \"type\"))?;\n+                self.head(visibility_qualified(&item.vis, \"type\"))?;\n                 self.print_ident(item.ident)?;\n                 self.print_generic_params(&generics.params)?;\n                 self.end()?; // end the inner ibox\n@@ -1305,7 +1307,7 @@ impl<'a> State<'a> {\n                 self.end()?; // end the outer ibox\n             }\n             ast::ItemKind::Existential(ref bounds, ref generics) => {\n-                self.head(&visibility_qualified(&item.vis, \"existential type\"))?;\n+                self.head(visibility_qualified(&item.vis, \"existential type\"))?;\n                 self.print_ident(item.ident)?;\n                 self.print_generic_params(&generics.params)?;\n                 self.end()?; // end the inner ibox\n@@ -1326,11 +1328,11 @@ impl<'a> State<'a> {\n                 )?;\n             }\n             ast::ItemKind::Struct(ref struct_def, ref generics) => {\n-                self.head(&visibility_qualified(&item.vis, \"struct\"))?;\n+                self.head(visibility_qualified(&item.vis, \"struct\"))?;\n                 self.print_struct(struct_def, generics, item.ident, item.span, true)?;\n             }\n             ast::ItemKind::Union(ref struct_def, ref generics) => {\n-                self.head(&visibility_qualified(&item.vis, \"union\"))?;\n+                self.head(visibility_qualified(&item.vis, \"union\"))?;\n                 self.print_struct(struct_def, generics, item.ident, item.span, true)?;\n             }\n             ast::ItemKind::Impl(unsafety,\n@@ -1479,7 +1481,7 @@ impl<'a> State<'a> {\n                           generics: &ast::Generics, ident: ast::Ident,\n                           span: syntax_pos::Span,\n                           visibility: &ast::Visibility) -> io::Result<()> {\n-        self.head(&visibility_qualified(visibility, \"enum\"))?;\n+        self.head(visibility_qualified(visibility, \"enum\"))?;\n         self.print_ident(ident)?;\n         self.print_generic_params(&generics.params)?;\n         self.print_where_clause(&generics.where_clause)?;\n@@ -1514,9 +1516,9 @@ impl<'a> State<'a> {\n             ast::VisibilityKind::Restricted { ref path, .. } => {\n                 let path = to_string(|s| s.print_path(path, false, 0));\n                 if path == \"self\" || path == \"super\" {\n-                    self.word_nbsp(&format!(\"pub({})\", path))\n+                    self.word_nbsp(format!(\"pub({})\", path))\n                 } else {\n-                    self.word_nbsp(&format!(\"pub(in {})\", path))\n+                    self.word_nbsp(format!(\"pub(in {})\", path))\n                 }\n             }\n             ast::VisibilityKind::Inherited => Ok(())\n@@ -2415,19 +2417,19 @@ impl<'a> State<'a> {\n \n     pub fn print_ident(&mut self, ident: ast::Ident) -> io::Result<()> {\n         if ident.is_raw_guess() {\n-            self.s.word(&format!(\"r#{}\", ident))?;\n+            self.s.word(format!(\"r#{}\", ident))?;\n         } else {\n-            self.s.word(&ident.as_str())?;\n+            self.s.word(ident.as_str().get())?;\n         }\n         self.ann.post(self, AnnNode::Ident(&ident))\n     }\n \n     pub fn print_usize(&mut self, i: usize) -> io::Result<()> {\n-        self.s.word(&i.to_string())\n+        self.s.word(i.to_string())\n     }\n \n     pub fn print_name(&mut self, name: ast::Name) -> io::Result<()> {\n-        self.s.word(&name.as_str())?;\n+        self.s.word(name.as_str().get())?;\n         self.ann.post(self, AnnNode::Name(&name))\n     }\n \n@@ -2851,10 +2853,8 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_type_bounds(&mut self,\n-                        prefix: &str,\n-                        bounds: &[ast::GenericBound])\n-                        -> io::Result<()> {\n+    pub fn print_type_bounds(&mut self, prefix: &'static str, bounds: &[ast::GenericBound])\n+                             -> io::Result<()> {\n         if !bounds.is_empty() {\n             self.s.word(prefix)?;\n             let mut first = true;\n@@ -3146,7 +3146,7 @@ impl<'a> State<'a> {\n             Some(Abi::Rust) => Ok(()),\n             Some(abi) => {\n                 self.word_nbsp(\"extern\")?;\n-                self.word_nbsp(&abi.to_string())\n+                self.word_nbsp(abi.to_string())\n             }\n             None => Ok(())\n         }\n@@ -3157,7 +3157,7 @@ impl<'a> State<'a> {\n         match opt_abi {\n             Some(abi) => {\n                 self.word_nbsp(\"extern\")?;\n-                self.word_nbsp(&abi.to_string())\n+                self.word_nbsp(abi.to_string())\n             }\n             None => Ok(())\n         }\n@@ -3166,7 +3166,7 @@ impl<'a> State<'a> {\n     pub fn print_fn_header_info(&mut self,\n                                 header: ast::FnHeader,\n                                 vis: &ast::Visibility) -> io::Result<()> {\n-        self.s.word(&visibility_qualified(vis, \"\"))?;\n+        self.s.word(visibility_qualified(vis, \"\"))?;\n \n         match header.constness.node {\n             ast::Constness::NotConst => {}\n@@ -3178,7 +3178,7 @@ impl<'a> State<'a> {\n \n         if header.abi != Abi::Rust {\n             self.word_nbsp(\"extern\")?;\n-            self.word_nbsp(&header.abi.to_string())?;\n+            self.word_nbsp(header.abi.to_string())?;\n         }\n \n         self.s.word(\"fn\")"}, {"sha": "741877bb4c88fdc94e99d6678edcb7208c9e659a", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bdb901c865e024161b2e8b9428235f82235df070/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb901c865e024161b2e8b9428235f82235df070/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=bdb901c865e024161b2e8b9428235f82235df070", "patch": "@@ -492,6 +492,10 @@ impl LocalInternedString {\n             symbol: Symbol::intern(self.string)\n         }\n     }\n+\n+    pub fn get(&self) -> &'static str {\n+        self.string\n+    }\n }\n \n impl<U: ?Sized> ::std::convert::AsRef<U> for LocalInternedString"}]}