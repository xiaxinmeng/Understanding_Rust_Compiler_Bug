{"sha": "926f38e588bb99aff1902fa94ab82b1db89cbbce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyNmYzOGU1ODhiYjk5YWZmMTkwMmZhOTRhYjgyYjFkYjg5Y2JiY2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-08T09:58:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-08T09:58:05Z"}, "message": "Auto merge of #23998 - nrc:impl-self, r=nikomatsakis\n\nCloses #23909\r\n\r\nr? @nikomatsakis (or anyone else, really)", "tree": {"sha": "c1551948b685c3a8797592727c01b921a118beac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1551948b685c3a8797592727c01b921a118beac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/926f38e588bb99aff1902fa94ab82b1db89cbbce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/926f38e588bb99aff1902fa94ab82b1db89cbbce", "html_url": "https://github.com/rust-lang/rust/commit/926f38e588bb99aff1902fa94ab82b1db89cbbce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/926f38e588bb99aff1902fa94ab82b1db89cbbce/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a66c7f6263ca390436a6faa9b8cbd0ef66c1e6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a66c7f6263ca390436a6faa9b8cbd0ef66c1e6c", "html_url": "https://github.com/rust-lang/rust/commit/3a66c7f6263ca390436a6faa9b8cbd0ef66c1e6c"}, {"sha": "63b36ea7c211406a76c34cba5ac9b7218e003757", "url": "https://api.github.com/repos/rust-lang/rust/commits/63b36ea7c211406a76c34cba5ac9b7218e003757", "html_url": "https://github.com/rust-lang/rust/commit/63b36ea7c211406a76c34cba5ac9b7218e003757"}], "stats": {"total": 652, "additions": 399, "deletions": 253}, "files": [{"sha": "998ce0cac47003c496ba85c3369743bb86f61888", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/926f38e588bb99aff1902fa94ab82b1db89cbbce/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/926f38e588bb99aff1902fa94ab82b1db89cbbce/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=926f38e588bb99aff1902fa94ab82b1db89cbbce", "patch": "@@ -457,7 +457,11 @@ impl tr for def::Def {\n           def::DefMethod(did, p) => {\n             def::DefMethod(did.tr(dcx), p.map(|did2| did2.tr(dcx)))\n           }\n-          def::DefSelfTy(nid) => { def::DefSelfTy(dcx.tr_id(nid)) }\n+          def::DefSelfTy(opt_did, impl_ids) => { def::DefSelfTy(opt_did.map(|did| did.tr(dcx)),\n+                                                                impl_ids.map(|(nid1, nid2)| {\n+                                                                    (dcx.tr_id(nid1),\n+                                                                     dcx.tr_id(nid2))\n+                                                                })) }\n           def::DefMod(did) => { def::DefMod(did.tr(dcx)) }\n           def::DefForeignMod(did) => { def::DefForeignMod(did.tr(dcx)) }\n           def::DefStatic(did, m) => { def::DefStatic(did.tr(dcx), m) }"}, {"sha": "f0b359088549b05333b2e01efba7ed1e9c5820ea", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/926f38e588bb99aff1902fa94ab82b1db89cbbce/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/926f38e588bb99aff1902fa94ab82b1db89cbbce/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=926f38e588bb99aff1902fa94ab82b1db89cbbce", "patch": "@@ -22,7 +22,8 @@ use std::cell::RefCell;\n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Def {\n     DefFn(ast::DefId, bool /* is_ctor */),\n-    DefSelfTy(/* trait id */ ast::NodeId),\n+    DefSelfTy(Option<ast::DefId>,                    // trait id\n+              Option<(ast::NodeId, ast::NodeId)>),   // (impl id, self type id)\n     DefMod(ast::DefId),\n     DefForeignMod(ast::DefId),\n     DefStatic(ast::DefId, bool /* is_mutbl */),\n@@ -139,18 +140,19 @@ impl Def {\n             DefFn(id, _) | DefMod(id) | DefForeignMod(id) | DefStatic(id, _) |\n             DefVariant(_, id, _) | DefTy(id, _) | DefAssociatedTy(_, id) |\n             DefTyParam(_, _, id, _) | DefUse(id) | DefStruct(id) | DefTrait(id) |\n-            DefMethod(id, _) | DefConst(id) => {\n+            DefMethod(id, _) | DefConst(id) | DefSelfTy(Some(id), None)=> {\n                 id\n             }\n             DefLocal(id) |\n-            DefSelfTy(id) |\n             DefUpvar(id, _) |\n             DefRegion(id) |\n-            DefLabel(id) => {\n+            DefLabel(id)  |\n+            DefSelfTy(_, Some((_, id))) => {\n                 local_def(id)\n             }\n \n-            DefPrimTy(_) => panic!(\"attempted .def_id() on DefPrimTy\")\n+            DefPrimTy(_) => panic!(\"attempted .def_id() on DefPrimTy\"),\n+            DefSelfTy(..) => panic!(\"attempted .def_id() on invalid DefSelfTy\"),\n         }\n     }\n "}, {"sha": "2884cebf6668f6e1626bd1614770de53591d3d9a", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/926f38e588bb99aff1902fa94ab82b1db89cbbce/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/926f38e588bb99aff1902fa94ab82b1db89cbbce/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=926f38e588bb99aff1902fa94ab82b1db89cbbce", "patch": "@@ -1178,7 +1178,7 @@ impl<'a, 'tcx> VisiblePrivateTypesVisitor<'a, 'tcx> {\n         let did = match self.tcx.def_map.borrow().get(&path_id).map(|d| d.full_def()) {\n             // `int` etc. (None doesn't seem to occur.)\n             None | Some(def::DefPrimTy(..)) => return false,\n-            Some(def) => def.def_id()\n+            Some(def) => def.def_id(),\n         };\n         // A path can only be private if:\n         // it's in this crate..."}, {"sha": "f90c7640f8ce70770ee64359177953bfcd04182c", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 90, "deletions": 79, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/926f38e588bb99aff1902fa94ab82b1db89cbbce/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/926f38e588bb99aff1902fa94ab82b1db89cbbce/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=926f38e588bb99aff1902fa94ab82b1db89cbbce", "patch": "@@ -1689,7 +1689,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 }\n             }\n-            DefTyParam(..) | DefSelfTy(_) => {\n+            DefTyParam(..) | DefSelfTy(..) => {\n                 for rib in ribs {\n                     match rib.kind {\n                         NormalRibKind | MethodRibKind | ClosureRibKind(..) => {\n@@ -1797,63 +1797,57 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n \n             ItemDefaultImpl(_, ref trait_ref) => {\n-                self.with_optional_trait_ref(Some(trait_ref), |_| {});\n+                self.with_optional_trait_ref(Some(trait_ref), |_, _| {});\n             }\n-            ItemImpl(_, _,\n+            ItemImpl(_,\n+                     _,\n                      ref generics,\n-                     ref implemented_traits,\n+                     ref opt_trait_ref,\n                      ref self_type,\n                      ref impl_items) => {\n                 self.resolve_implementation(generics,\n-                                            implemented_traits,\n+                                            opt_trait_ref,\n                                             &**self_type,\n+                                            item.id,\n                                             &impl_items[..]);\n             }\n \n             ItemTrait(_, ref generics, ref bounds, ref trait_items) => {\n                 self.check_if_primitive_type_name(name, item.span);\n \n-                // Create a new rib for the self type.\n-                let mut self_type_rib = Rib::new(ItemRibKind);\n-\n-                // plain insert (no renaming, types are not currently hygienic....)\n-                let name = special_names::type_self;\n-                self_type_rib.bindings.insert(name, DlDef(DefSelfTy(item.id)));\n-                self.type_ribs.push(self_type_rib);\n-\n                 // Create a new rib for the trait-wide type parameters.\n                 self.with_type_parameter_rib(HasTypeParameters(generics,\n                                                                TypeSpace,\n-                                                               NormalRibKind),\n+                                                               ItemRibKind),\n                                              |this| {\n-                    this.visit_generics(generics);\n-                    visit::walk_ty_param_bounds_helper(this, bounds);\n-\n-                    for trait_item in trait_items {\n-                        // Create a new rib for the trait_item-specific type\n-                        // parameters.\n-                        //\n-                        // FIXME #4951: Do we need a node ID here?\n-\n-                        let type_parameters = match trait_item.node {\n-                            ast::MethodTraitItem(ref sig, _) => {\n-                                HasTypeParameters(&sig.generics,\n-                                                  FnSpace,\n-                                                  MethodRibKind)\n-                            }\n-                            ast::TypeTraitItem(..) => {\n-                                this.check_if_primitive_type_name(trait_item.ident.name,\n-                                                                  trait_item.span);\n-                                NoTypeParameters\n-                            }\n-                        };\n-                        this.with_type_parameter_rib(type_parameters, |this| {\n-                            visit::walk_trait_item(this, trait_item)\n-                        });\n-                    }\n+                    this.with_self_rib(DefSelfTy(Some(local_def(item.id)), None), |this| {\n+                        this.visit_generics(generics);\n+                        visit::walk_ty_param_bounds_helper(this, bounds);\n+\n+                        for trait_item in trait_items {\n+                            // Create a new rib for the trait_item-specific type\n+                            // parameters.\n+                            //\n+                            // FIXME #4951: Do we need a node ID here?\n+\n+                            let type_parameters = match trait_item.node {\n+                                ast::MethodTraitItem(ref sig, _) => {\n+                                    HasTypeParameters(&sig.generics,\n+                                                      FnSpace,\n+                                                      MethodRibKind)\n+                                }\n+                                ast::TypeTraitItem(..) => {\n+                                    this.check_if_primitive_type_name(trait_item.ident.name,\n+                                                                      trait_item.span);\n+                                    NoTypeParameters\n+                                }\n+                            };\n+                            this.with_type_parameter_rib(type_parameters, |this| {\n+                                visit::walk_trait_item(this, trait_item)\n+                            });\n+                        }\n+                    });\n                 });\n-\n-                self.type_ribs.pop();\n             }\n \n             ItemMod(_) | ItemForeignMod(_) => {\n@@ -2030,8 +2024,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         visit::walk_generics(self, generics);\n     }\n \n-    fn with_current_self_type<T, F>(&mut self, self_type: &Ty, f: F) -> T where\n-        F: FnOnce(&mut Resolver) -> T,\n+    fn with_current_self_type<T, F>(&mut self, self_type: &Ty, f: F) -> T\n+        where F: FnOnce(&mut Resolver) -> T\n     {\n         // Handle nested impls (inside fn bodies)\n         let previous_value = replace(&mut self.current_self_type, Some(self_type.clone()));\n@@ -2044,29 +2038,44 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                      opt_trait_ref: Option<&TraitRef>,\n                                      f: F)\n                                      -> T\n-        where F: FnOnce(&mut Resolver) -> T,\n+        where F: FnOnce(&mut Resolver, Option<DefId>) -> T\n     {\n         let mut new_val = None;\n+        let mut new_id = None;\n         if let Some(trait_ref) = opt_trait_ref {\n-            match self.resolve_trait_reference(trait_ref.ref_id, &trait_ref.path, 0) {\n-                Ok(path_res) => {\n-                    self.record_def(trait_ref.ref_id, path_res);\n-                    new_val = Some((path_res.base_def.def_id(), trait_ref.clone()));\n-                }\n-                Err(_) => { /* error was already reported */ }\n+            if let Ok(path_res) = self.resolve_trait_reference(trait_ref.ref_id,\n+                                                               &trait_ref.path, 0) {\n+                assert!(path_res.depth == 0);\n+                self.record_def(trait_ref.ref_id, path_res);\n+                new_val = Some((path_res.base_def.def_id(), trait_ref.clone()));\n+                new_id = Some(path_res.base_def.def_id());\n             }\n             visit::walk_trait_ref(self, trait_ref);\n         }\n         let original_trait_ref = replace(&mut self.current_trait_ref, new_val);\n-        let result = f(self);\n+        let result = f(self, new_id);\n         self.current_trait_ref = original_trait_ref;\n         result\n     }\n \n+    fn with_self_rib<F>(&mut self, self_def: Def, f: F)\n+        where F: FnOnce(&mut Resolver)\n+    {\n+        let mut self_type_rib = Rib::new(NormalRibKind);\n+\n+        // plain insert (no renaming, types are not currently hygienic....)\n+        let name = special_names::type_self;\n+        self_type_rib.bindings.insert(name, DlDef(self_def));\n+        self.type_ribs.push(self_type_rib);\n+        f(self);\n+        self.type_ribs.pop();\n+    }\n+\n     fn resolve_implementation(&mut self,\n                               generics: &Generics,\n                               opt_trait_reference: &Option<TraitRef>,\n                               self_type: &Ty,\n+                              item_id: NodeId,\n                               impl_items: &[P<ImplItem>]) {\n         // If applicable, create a rib for the type parameters.\n         self.with_type_parameter_rib(HasTypeParameters(generics,\n@@ -2077,40 +2086,42 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             this.visit_generics(generics);\n \n             // Resolve the trait reference, if necessary.\n-            this.with_optional_trait_ref(opt_trait_reference.as_ref(), |this| {\n+            this.with_optional_trait_ref(opt_trait_reference.as_ref(), |this, trait_id| {\n                 // Resolve the self type.\n                 this.visit_ty(self_type);\n \n-                this.with_current_self_type(self_type, |this| {\n-                    for impl_item in impl_items {\n-                        match impl_item.node {\n-                            MethodImplItem(ref sig, _) => {\n-                                // If this is a trait impl, ensure the method\n-                                // exists in trait\n-                                this.check_trait_item(impl_item.ident.name,\n-                                                      impl_item.span);\n-\n-                                // We also need a new scope for the method-\n-                                // specific type parameters.\n-                                let type_parameters =\n-                                    HasTypeParameters(&sig.generics,\n-                                                      FnSpace,\n-                                                      MethodRibKind);\n-                                this.with_type_parameter_rib(type_parameters, |this| {\n-                                    visit::walk_impl_item(this, impl_item);\n-                                });\n-                            }\n-                            TypeImplItem(ref ty) => {\n-                                // If this is a trait impl, ensure the method\n-                                // exists in trait\n-                                this.check_trait_item(impl_item.ident.name,\n-                                                      impl_item.span);\n+                this.with_self_rib(DefSelfTy(trait_id, Some((item_id, self_type.id))), |this| {\n+                    this.with_current_self_type(self_type, |this| {\n+                        for impl_item in impl_items {\n+                            match impl_item.node {\n+                                MethodImplItem(ref sig, _) => {\n+                                    // If this is a trait impl, ensure the method\n+                                    // exists in trait\n+                                    this.check_trait_item(impl_item.ident.name,\n+                                                          impl_item.span);\n+\n+                                    // We also need a new scope for the method-\n+                                    // specific type parameters.\n+                                    let type_parameters =\n+                                        HasTypeParameters(&sig.generics,\n+                                                          FnSpace,\n+                                                          MethodRibKind);\n+                                    this.with_type_parameter_rib(type_parameters, |this| {\n+                                        visit::walk_impl_item(this, impl_item);\n+                                    });\n+                                }\n+                                TypeImplItem(ref ty) => {\n+                                    // If this is a trait impl, ensure the method\n+                                    // exists in trait\n+                                    this.check_trait_item(impl_item.ident.name,\n+                                                          impl_item.span);\n \n-                                this.visit_ty(ty);\n+                                    this.visit_ty(ty);\n+                                }\n+                                ast::MacImplItem(_) => {}\n                             }\n-                            ast::MacImplItem(_) => {}\n                         }\n-                    }\n+                    });\n                 });\n             });\n         });"}, {"sha": "1a19d4a1e454c2e6402728b877f583cccbf6930e", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/926f38e588bb99aff1902fa94ab82b1db89cbbce/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/926f38e588bb99aff1902fa94ab82b1db89cbbce/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=926f38e588bb99aff1902fa94ab82b1db89cbbce", "patch": "@@ -248,7 +248,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n             def::DefFn(..) => Some(recorder::FnRef),\n \n-            def::DefSelfTy(_) |\n+            def::DefSelfTy(..) |\n             def::DefRegion(_) |\n             def::DefLabel(_) |\n             def::DefTyParam(..) |"}, {"sha": "355b866013b6396ea776055036126e97321388f6", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 193, "deletions": 102, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/926f38e588bb99aff1902fa94ab82b1db89cbbce/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/926f38e588bb99aff1902fa94ab82b1db89cbbce/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=926f38e588bb99aff1902fa94ab82b1db89cbbce", "patch": "@@ -56,7 +56,7 @@ use middle::privacy::{AllPublic, LastMod};\n use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs};\n use middle::traits;\n use middle::ty::{self, RegionEscape, Ty};\n-use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope,\n+use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope, ExplicitRscope,\n              ObjectLifetimeDefaultRscope, ShiftedRscope, BindingRscope};\n use util::common::{ErrorReported, FN_OUTPUT_NAME};\n use util::ppaux::{self, Repr, UserString};\n@@ -872,24 +872,11 @@ fn ast_type_binding_to_poly_projection_predicate<'tcx>(\n         }\n     }\n \n-    if candidates.len() > 1 {\n-        span_err!(tcx.sess, binding.span, E0217,\n-            \"ambiguous associated type: `{}` defined in multiple supertraits `{}`\",\n-                    token::get_name(binding.item_name),\n-                    candidates.user_string(tcx));\n-        return Err(ErrorReported);\n-    }\n-\n-    let candidate = match candidates.pop() {\n-        Some(c) => c,\n-        None => {\n-            span_err!(tcx.sess, binding.span, E0218,\n-                \"no associated type `{}` defined in `{}`\",\n-                        token::get_name(binding.item_name),\n-                        trait_ref.user_string(tcx));\n-            return Err(ErrorReported);\n-        }\n-    };\n+    let candidate = try!(one_bound_for_assoc_type(tcx,\n+                                                  candidates,\n+                                                  &trait_ref.user_string(tcx),\n+                                                  &token::get_name(binding.item_name),\n+                                                  binding.span));\n \n     Ok(ty::Binder(ty::ProjectionPredicate {             // <-------------------------+\n         projection_ty: ty::ProjectionTy {               //                           |\n@@ -1042,6 +1029,81 @@ fn report_ambiguous_associated_type(tcx: &ty::ctxt,\n               type_str, trait_str, name);\n }\n \n+// Search for a bound on a type parameter which includes the associated item\n+// given by assoc_name. ty_param_node_id is the node id for the type parameter\n+// (which might be `Self`, but only if it is the `Self` of a trait, not an\n+// impl). This function will fail if there are no suitable bounds or there is\n+// any ambiguity.\n+fn find_bound_for_assoc_item<'tcx>(this: &AstConv<'tcx>,\n+                                   ty_param_node_id: ast::NodeId,\n+                                   assoc_name: ast::Name,\n+                                   span: Span)\n+                                   -> Result<ty::PolyTraitRef<'tcx>, ErrorReported>\n+{\n+    let tcx = this.tcx();\n+\n+    let bounds = match this.get_type_parameter_bounds(span, ty_param_node_id) {\n+        Ok(v) => v,\n+        Err(ErrorReported) => {\n+            return Err(ErrorReported);\n+        }\n+    };\n+\n+    // Ensure the super predicates and stop if we encountered an error.\n+    if bounds.iter().any(|b| this.ensure_super_predicates(span, b.def_id()).is_err()) {\n+        return Err(ErrorReported);\n+    }\n+\n+    // Check that there is exactly one way to find an associated type with the\n+    // correct name.\n+    let suitable_bounds: Vec<_> =\n+        traits::transitive_bounds(tcx, &bounds)\n+        .filter(|b| this.trait_defines_associated_type_named(b.def_id(), assoc_name))\n+        .collect();\n+\n+    let ty_param_name = tcx.type_parameter_def(ty_param_node_id).name;\n+    one_bound_for_assoc_type(tcx,\n+                             suitable_bounds,\n+                             &token::get_name(ty_param_name),\n+                             &token::get_name(assoc_name),\n+                             span)\n+}\n+\n+\n+// Checks that bounds contains exactly one element and reports appropriate\n+// errors otherwise.\n+fn one_bound_for_assoc_type<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                  bounds: Vec<ty::PolyTraitRef<'tcx>>,\n+                                  ty_param_name: &str,\n+                                  assoc_name: &str,\n+                                  span: Span)\n+    -> Result<ty::PolyTraitRef<'tcx>, ErrorReported>\n+{\n+    if bounds.len() == 0 {\n+        span_err!(tcx.sess, span, E0220,\n+                  \"associated type `{}` not found for `{}`\",\n+                  assoc_name,\n+                  ty_param_name);\n+        return Err(ErrorReported);\n+    }\n+\n+    if bounds.len() > 1 {\n+        span_err!(tcx.sess, span, E0221,\n+                  \"ambiguous associated type `{}` in bounds of `{}`\",\n+                  assoc_name,\n+                  ty_param_name);\n+\n+        for bound in &bounds {\n+            span_note!(tcx.sess, span,\n+                       \"associated type `{}` could derive from `{}`\",\n+                       ty_param_name,\n+                       bound.user_string(tcx));\n+        }\n+    }\n+\n+    Ok(bounds[0].clone())\n+}\n+\n // Create a type from a a path to an associated type.\n // For a path A::B::C::D, ty and ty_path_def are the type and def for A::B::C\n // and item_segment is the path segment for D. We return a type and a def for\n@@ -1062,10 +1124,55 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n \n     check_path_args(tcx, slice::ref_slice(item_segment), NO_TPS | NO_REGIONS);\n \n-    // Check that the path prefix given by ty/ty_path_def is a type parameter/Self.\n-    match (&ty.sty, ty_path_def) {\n+    // Find the type of the associated item, and the trait where the associated\n+    // item is declared.\n+    let bound = match (&ty.sty, ty_path_def) {\n+        (_, def::DefSelfTy(Some(trait_did), Some((impl_id, _)))) => {\n+            // `Self` in an impl of a trait - we have a concrete self type and a\n+            // trait reference.\n+            match tcx.map.expect_item(impl_id).node {\n+                ast::ItemImpl(_, _, _, Some(ref trait_ref), _, _) => {\n+                    if this.ensure_super_predicates(span, trait_did).is_err() {\n+                        return (tcx.types.err, ty_path_def);\n+                    }\n+\n+                    let trait_segment = &trait_ref.path.segments.last().unwrap();\n+                    let trait_ref = ast_path_to_mono_trait_ref(this,\n+                                                               &ExplicitRscope,\n+                                                               span,\n+                                                               PathParamMode::Explicit,\n+                                                               trait_did,\n+                                                               Some(ty),\n+                                                               trait_segment);\n+\n+                    let candidates: Vec<ty::PolyTraitRef> =\n+                        traits::supertraits(tcx, ty::Binder(trait_ref.clone()))\n+                        .filter(|r| this.trait_defines_associated_type_named(r.def_id(),\n+                                                                             assoc_name))\n+                        .collect();\n+\n+                    match one_bound_for_assoc_type(tcx,\n+                                                   candidates,\n+                                                   \"Self\",\n+                                                   &token::get_name(assoc_name),\n+                                                   span) {\n+                        Ok(bound) => bound,\n+                        Err(ErrorReported) => return (tcx.types.err, ty_path_def),\n+                    }\n+                }\n+                _ => unreachable!()\n+            }\n+        }\n         (&ty::ty_param(_), def::DefTyParam(..)) |\n-        (&ty::ty_param(_), def::DefSelfTy(_)) => {}\n+        (&ty::ty_param(_), def::DefSelfTy(Some(_), None)) => {\n+            // A type parameter or Self, we need to find the associated item from\n+            // a bound.\n+            let ty_param_node_id = ty_path_def.local_node_id();\n+            match find_bound_for_assoc_item(this, ty_param_node_id, assoc_name, span) {\n+                Ok(bound) => bound,\n+                Err(ErrorReported) => return (tcx.types.err, ty_path_def),\n+            }\n+        }\n         _ => {\n             report_ambiguous_associated_type(tcx,\n                                              span,\n@@ -1074,61 +1181,15 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                                              &token::get_name(assoc_name));\n             return (tcx.types.err, ty_path_def);\n         }\n-    }\n-\n-    let ty_param_node_id = ty_path_def.local_node_id();\n-    let ty_param_name = tcx.ty_param_defs.borrow().get(&ty_param_node_id).unwrap().name;\n-\n-    let bounds = match this.get_type_parameter_bounds(span, ty_param_node_id) {\n-        Ok(v) => v,\n-        Err(ErrorReported) => {\n-            return (tcx.types.err, ty_path_def);\n-        }\n     };\n \n-    // Ensure the super predicates and stop if we encountered an error.\n-    if bounds.iter().any(|b| this.ensure_super_predicates(span, b.def_id()).is_err()) {\n-        return (this.tcx().types.err, ty_path_def);\n-    }\n-\n-    // Check that there is exactly one way to find an associated type with the\n-    // correct name.\n-    let mut suitable_bounds: Vec<_> =\n-        traits::transitive_bounds(tcx, &bounds)\n-        .filter(|b| this.trait_defines_associated_type_named(b.def_id(), assoc_name))\n-        .collect();\n-\n-    if suitable_bounds.len() == 0 {\n-        span_err!(tcx.sess, span, E0220,\n-                          \"associated type `{}` not found for type parameter `{}`\",\n-                                  token::get_name(assoc_name),\n-                                  token::get_name(ty_param_name));\n-        return (this.tcx().types.err, ty_path_def);\n-    }\n-\n-    if suitable_bounds.len() > 1 {\n-        span_err!(tcx.sess, span, E0221,\n-                          \"ambiguous associated type `{}` in bounds of `{}`\",\n-                                  token::get_name(assoc_name),\n-                                  token::get_name(ty_param_name));\n-\n-        for suitable_bound in &suitable_bounds {\n-            span_note!(this.tcx().sess, span,\n-                       \"associated type `{}` could derive from `{}`\",\n-                       token::get_name(ty_param_name),\n-                       suitable_bound.user_string(this.tcx()));\n-        }\n-    }\n-\n-    let suitable_bound = suitable_bounds.pop().unwrap().clone();\n-    let trait_did = suitable_bound.0.def_id;\n-\n-    let ty = this.projected_ty_from_poly_trait_ref(span, suitable_bound, assoc_name);\n+    let trait_did = bound.0.def_id;\n+    let ty = this.projected_ty_from_poly_trait_ref(span, bound, assoc_name);\n \n     let item_did = if trait_did.krate == ast::LOCAL_CRATE {\n         // `ty::trait_items` used below requires information generated\n         // by type collection, which may be in progress at this point.\n-        match this.tcx().map.expect_item(trait_did.node).node {\n+        match tcx.map.expect_item(trait_did.node).node {\n             ast::ItemTrait(_, _, _, ref trait_items) => {\n                 let item = trait_items.iter()\n                                       .find(|i| i.ident.name == assoc_name)\n@@ -1138,7 +1199,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n             _ => unreachable!()\n         }\n     } else {\n-        let trait_items = ty::trait_items(this.tcx(), trait_did);\n+        let trait_items = ty::trait_items(tcx, trait_did);\n         let item = trait_items.iter().find(|i| i.name() == assoc_name);\n         item.expect(\"missing associated type\").def_id()\n     };\n@@ -1174,14 +1235,13 @@ fn qpath_to_ty<'tcx>(this: &AstConv<'tcx>,\n \n     debug!(\"qpath_to_ty: self_type={}\", self_ty.repr(tcx));\n \n-    let trait_ref =\n-        ast_path_to_mono_trait_ref(this,\n-                                   rscope,\n-                                   span,\n-                                   param_mode,\n-                                   trait_def_id,\n-                                   Some(self_ty),\n-                                   trait_segment);\n+    let trait_ref = ast_path_to_mono_trait_ref(this,\n+                                               rscope,\n+                                               span,\n+                                               param_mode,\n+                                               trait_def_id,\n+                                               Some(self_ty),\n+                                               trait_segment);\n \n     debug!(\"qpath_to_ty: trait_ref={}\", trait_ref.repr(tcx));\n \n@@ -1221,20 +1281,20 @@ pub fn ast_ty_arg_to_ty<'tcx>(this: &AstConv<'tcx>,\n     }\n }\n \n-// Note that both base_segments and assoc_segments may be empty, although not at\n-// the same time.\n-pub fn finish_resolving_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n-                                        rscope: &RegionScope,\n-                                        span: Span,\n-                                        param_mode: PathParamMode,\n-                                        def: &def::Def,\n-                                        opt_self_ty: Option<Ty<'tcx>>,\n-                                        base_segments: &[ast::PathSegment],\n-                                        assoc_segments: &[ast::PathSegment])\n-                                        -> Ty<'tcx> {\n+// Check the base def in a PathResolution and convert it to a Ty. If there are\n+// associated types in the PathResolution, these will need to be seperately\n+// resolved.\n+fn base_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n+                        rscope: &RegionScope,\n+                        span: Span,\n+                        param_mode: PathParamMode,\n+                        def: &def::Def,\n+                        opt_self_ty: Option<Ty<'tcx>>,\n+                        base_segments: &[ast::PathSegment])\n+                        -> Ty<'tcx> {\n     let tcx = this.tcx();\n \n-    let base_ty = match *def {\n+    match *def {\n         def::DefTrait(trait_def_id) => {\n             // N.B. this case overlaps somewhat with\n             // TyObjectSum, see that fn for details\n@@ -1258,18 +1318,28 @@ pub fn finish_resolving_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n         }\n         def::DefTy(did, _) | def::DefStruct(did) => {\n             check_path_args(tcx, base_segments.init(), NO_TPS | NO_REGIONS);\n-            ast_path_to_ty(this, rscope, span,\n-                           param_mode, did,\n+            ast_path_to_ty(this,\n+                           rscope,\n+                           span,\n+                           param_mode,\n+                           did,\n                            base_segments.last().unwrap())\n         }\n         def::DefTyParam(space, index, _, name) => {\n             check_path_args(tcx, base_segments, NO_TPS | NO_REGIONS);\n             ty::mk_param(tcx, space, index, name)\n         }\n-        def::DefSelfTy(_) => {\n-            // N.b.: resolve guarantees that the this type only appears in a\n-            // trait, which we rely upon in various places when creating\n-            // substs.\n+        def::DefSelfTy(_, Some((_, self_ty_id))) => {\n+            // Self in impl (we know the concrete type).\n+            check_path_args(tcx, base_segments, NO_TPS | NO_REGIONS);\n+            if let Some(&ty) = tcx.ast_ty_to_ty_cache.borrow().get(&self_ty_id) {\n+                ty\n+            } else {\n+                tcx.sess.span_bug(span, \"self type has not been fully resolved\")\n+            }\n+        }\n+        def::DefSelfTy(Some(_), None) => {\n+            // Self in trait.\n             check_path_args(tcx, base_segments, NO_TPS | NO_REGIONS);\n             ty::mk_self_type(tcx)\n         }\n@@ -1289,6 +1359,9 @@ pub fn finish_resolving_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n             // FIXME(#22519) This part of the resolution logic should be\n             // avoided entirely for that form, once we stop needed a Def\n             // for `associated_path_def_to_ty`.\n+            // Fixing this will also let use resolve <Self>::Foo the same way we\n+            // resolve Self::Foo, at the moment we can't resolve the former because\n+            // we don't have the trait information around, which is just sad.\n \n             if !base_segments.is_empty() {\n                 span_err!(tcx.sess,\n@@ -1309,11 +1382,29 @@ pub fn finish_resolving_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                       \"found value name used as a type: {:?}\", *def);\n             return this.tcx().types.err;\n         }\n-    };\n+    }\n+}\n \n-    // If any associated type segments remain, attempt to resolve them.\n-    let mut ty = base_ty;\n+// Note that both base_segments and assoc_segments may be empty, although not at\n+// the same time.\n+pub fn finish_resolving_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n+                                        rscope: &RegionScope,\n+                                        span: Span,\n+                                        param_mode: PathParamMode,\n+                                        def: &def::Def,\n+                                        opt_self_ty: Option<Ty<'tcx>>,\n+                                        base_segments: &[ast::PathSegment],\n+                                        assoc_segments: &[ast::PathSegment])\n+                                        -> Ty<'tcx> {\n+    let mut ty = base_def_to_ty(this,\n+                                rscope,\n+                                span,\n+                                param_mode,\n+                                def,\n+                                opt_self_ty,\n+                                base_segments);\n     let mut def = *def;\n+    // If any associated type segments remain, attempt to resolve them.\n     for segment in assoc_segments {\n         if ty.sty == ty::ty_err {\n             break;\n@@ -1997,7 +2088,7 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n                                 check_type_argument_count(tcx, b.trait_ref.path.span,\n                                                           parameters.types().len(), 0, 0);\n                             }\n-                            if parameters.lifetimes().len() > 0{\n+                            if parameters.lifetimes().len() > 0 {\n                                 report_lifetime_number_error(tcx, b.trait_ref.path.span,\n                                                              parameters.lifetimes().len(), 0);\n                             }"}, {"sha": "ce1227608cf31b0dc3fdcbf389058554088579ac", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/926f38e588bb99aff1902fa94ab82b1db89cbbce/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/926f38e588bb99aff1902fa94ab82b1db89cbbce/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=926f38e588bb99aff1902fa94ab82b1db89cbbce", "patch": "@@ -3341,11 +3341,17 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n           let def = path_res.base_def;\n           if path_res.depth == 0 {\n-              let (scheme, predicates) =\n-                  type_scheme_and_predicates_for_def(fcx, expr.span, def);\n-              instantiate_path(fcx, &path.segments,\n-                               scheme, &predicates,\n-                               opt_self_ty, def, expr.span, id);\n+              let (scheme, predicates) = type_scheme_and_predicates_for_def(fcx,\n+                                                                            expr.span,\n+                                                                            def);\n+              instantiate_path(fcx,\n+                               &path.segments,\n+                               scheme,\n+                               &predicates,\n+                               opt_self_ty,\n+                               def,\n+                               expr.span,\n+                               id);\n           } else {\n               let ty_segments = path.segments.init();\n               let base_ty_end = path.segments.len() - path_res.depth;"}, {"sha": "95b943b254785ff0725dcc8801664ed19d06a703", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/926f38e588bb99aff1902fa94ab82b1db89cbbce/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/926f38e588bb99aff1902fa94ab82b1db89cbbce/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=926f38e588bb99aff1902fa94ab82b1db89cbbce", "patch": "@@ -547,14 +547,15 @@ fn is_param<'tcx>(tcx: &ty::ctxt<'tcx>,\n     if let ast::TyPath(None, _) = ast_ty.node {\n         let path_res = *tcx.def_map.borrow().get(&ast_ty.id).unwrap();\n         match path_res.base_def {\n-            def::DefSelfTy(node_id) =>\n-                path_res.depth == 0 && node_id == param_id,\n-\n-            def::DefTyParam(_, _, def_id, _) =>\n-                path_res.depth == 0 && def_id == local_def(param_id),\n-\n-            _ =>\n-                false,\n+            def::DefSelfTy(Some(def_id), None) => {\n+                path_res.depth == 0 && def_id.node == param_id\n+            }\n+            def::DefTyParam(_, _, def_id, _) => {\n+                path_res.depth == 0 && def_id == local_def(param_id)\n+            }\n+            _ => {\n+                false\n+            }\n         }\n     } else {\n         false\n@@ -1814,7 +1815,7 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                     ty::ty_param(p) => if p.idx > cur_idx {\n                         span_err!(tcx.sess, path.span, E0128,\n                                   \"type parameters with a default cannot use \\\n-                                  forward declared identifiers\");\n+                                   forward declared identifiers\");\n                         },\n                         _ => {}\n                     }"}, {"sha": "dd0c7d716b7979e462145a5dfa5fef7f44d28132", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 41, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/926f38e588bb99aff1902fa94ab82b1db89cbbce/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/926f38e588bb99aff1902fa94ab82b1db89cbbce/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=926f38e588bb99aff1902fa94ab82b1db89cbbce", "patch": "@@ -14,7 +14,6 @@ use ast::{ItemMac, MacStmtWithSemicolon, Mrk, Stmt, StmtDecl, StmtMac};\n use ast::{StmtExpr, StmtSemi};\n use ast::TokenTree;\n use ast;\n-use ast_util::path_to_ident;\n use ext::mtwt;\n use ext::build::AstBuilder;\n use attr;\n@@ -34,30 +33,6 @@ use visit;\n use visit::Visitor;\n use std_inject;\n \n-pub fn expand_type(t: P<ast::Ty>,\n-                   fld: &mut MacroExpander,\n-                   impl_ty: Option<P<ast::Ty>>)\n-                   -> P<ast::Ty> {\n-    debug!(\"expanding type {:?} with impl_ty {:?}\", t, impl_ty);\n-    let t = match (t.node.clone(), impl_ty) {\n-        // Expand uses of `Self` in impls to the concrete type.\n-        (ast::Ty_::TyPath(None, ref path), Some(ref impl_ty)) => {\n-            let path_as_ident = path_to_ident(path);\n-            // Note unhygenic comparison here. I think this is correct, since\n-            // even though `Self` is almost just a type parameter, the treatment\n-            // for this expansion is as if it were a keyword.\n-            if path_as_ident.is_some() &&\n-               path_as_ident.unwrap().name == token::special_idents::type_self.name {\n-                impl_ty.clone()\n-            } else {\n-                t\n-            }\n-        }\n-        _ => t\n-    };\n-    fold::noop_fold_ty(t, fld)\n-}\n-\n pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n     e.and_then(|ast::Expr {id, node, span}| match node {\n         // expr_mac should really be expr_ext or something; it's the\n@@ -1354,13 +1329,11 @@ fn expand_and_rename_method(sig: ast::MethodSig, body: P<ast::Block>,\n /// A tree-folder that performs macro expansion\n pub struct MacroExpander<'a, 'b:'a> {\n     pub cx: &'a mut ExtCtxt<'b>,\n-    // The type of the impl currently being expanded.\n-    current_impl_type: Option<P<ast::Ty>>,\n }\n \n impl<'a, 'b> MacroExpander<'a, 'b> {\n     pub fn new(cx: &'a mut ExtCtxt<'b>) -> MacroExpander<'a, 'b> {\n-        MacroExpander { cx: cx, current_impl_type: None }\n+        MacroExpander { cx: cx }\n     }\n }\n \n@@ -1374,14 +1347,7 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n     }\n \n     fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n-        let prev_type = self.current_impl_type.clone();\n-        if let ast::Item_::ItemImpl(_, _, _, _, ref ty, _) = item.node {\n-            self.current_impl_type = Some(ty.clone());\n-        }\n-\n-        let result = expand_item(item, self);\n-        self.current_impl_type = prev_type;\n-        result\n+        expand_item(item, self)\n     }\n \n     fn fold_item_underscore(&mut self, item: ast::Item_) -> ast::Item_ {\n@@ -1410,11 +1376,6 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n             .into_iter().map(|i| i.expect_impl_item()).collect()\n     }\n \n-    fn fold_ty(&mut self, t: P<ast::Ty>) -> P<ast::Ty> {\n-        let impl_type = self.current_impl_type.clone();\n-        expand_type(t, self, impl_type)\n-    }\n-\n     fn new_span(&mut self, span: Span) -> Span {\n         new_span(self.cx, span)\n     }"}, {"sha": "d058c6a5a3b93fbb6c6bf3f6d232d8e9fdc0806f", "filename": "src/test/compile-fail/self-impl.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/926f38e588bb99aff1902fa94ab82b1db89cbbce/src%2Ftest%2Fcompile-fail%2Fself-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/926f38e588bb99aff1902fa94ab82b1db89cbbce/src%2Ftest%2Fcompile-fail%2Fself-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fself-impl.rs?ref=926f38e588bb99aff1902fa94ab82b1db89cbbce", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that unsupported uses of `Self` in impls don't crash\n+\n+struct Bar;\n+\n+trait Foo {\n+    type Baz;\n+}\n+\n+trait SuperFoo {\n+    type SuperBaz;\n+}\n+\n+impl Foo for Bar {\n+    type Baz = bool;\n+}\n+\n+impl SuperFoo for Bar {\n+    type SuperBaz = bool;\n+}\n+\n+impl Bar {\n+    fn f() {\n+        let _: <Self>::Baz = true;\n+//~^ERROR: ambiguous associated type; specify the type using the syntax `<Bar as Trait>::Baz`\n+        let _: Self::Baz = true;\n+//~^ERROR: ambiguous associated type; specify the type using the syntax `<Bar as Trait>::Baz`\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "bb7e02d0d8b9bebf5abc9c9c26f9811b7f18cd21", "filename": "src/test/compile-fail/unboxed-closure-sugar-wrong-number-number-type-parameters-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/926f38e588bb99aff1902fa94ab82b1db89cbbce/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/926f38e588bb99aff1902fa94ab82b1db89cbbce/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-1.rs?ref=926f38e588bb99aff1902fa94ab82b1db89cbbce", "patch": "@@ -12,7 +12,7 @@\n \n trait One<A> { fn foo(&self) -> A; }\n \n-fn foo(_: &One()) //~ ERROR no associated type `Output` defined in `One<()>`\n+fn foo(_: &One()) //~ ERROR associated type `Output` not found for `One<()>`\n {}\n \n fn main() { }"}, {"sha": "20fdd52b82a3e257127e9d588a07a0767abfc51e", "filename": "src/test/compile-fail/unboxed-closure-sugar-wrong-number-number-type-parameters-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/926f38e588bb99aff1902fa94ab82b1db89cbbce/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/926f38e588bb99aff1902fa94ab82b1db89cbbce/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-3.rs?ref=926f38e588bb99aff1902fa94ab82b1db89cbbce", "patch": "@@ -14,7 +14,7 @@ trait Three<A,B,C> { fn dummy(&self) -> (A,B,C); }\n \n fn foo(_: &Three())\n //~^ ERROR wrong number of type arguments\n-//~| ERROR no associated type `Output`\n+//~| ERROR associated type `Output` not found\n {}\n \n fn main() { }"}, {"sha": "027fa6b0fe3b0866a70d208681c06dd8422ba1f5", "filename": "src/test/compile-fail/unboxed-closure-sugar-wrong-number-number-type-parameters.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/926f38e588bb99aff1902fa94ab82b1db89cbbce/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/926f38e588bb99aff1902fa94ab82b1db89cbbce/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters.rs?ref=926f38e588bb99aff1902fa94ab82b1db89cbbce", "patch": "@@ -14,7 +14,7 @@ trait Zero { fn dummy(&self); }\n \n fn foo(_: Zero())\n     //~^ ERROR wrong number of type arguments\n-    //~| ERROR no associated type `Output` defined in `Zero`\n+    //~| ERROR associated type `Output` not found for `Zero`\n {}\n \n fn main() { }"}, {"sha": "04bbfc445edeaab920911845a249d8f4a30d7220", "filename": "src/test/compile-fail/unboxed-closure-sugar-wrong-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/926f38e588bb99aff1902fa94ab82b1db89cbbce/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/926f38e588bb99aff1902fa94ab82b1db89cbbce/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-trait.rs?ref=926f38e588bb99aff1902fa94ab82b1db89cbbce", "patch": "@@ -14,6 +14,6 @@ trait Trait {}\n \n fn f<F:Trait(isize) -> isize>(x: F) {}\n //~^ ERROR wrong number of type arguments: expected 0, found 1\n-//~| ERROR no associated type `Output`\n+//~| ERROR associated type `Output` not found\n \n fn main() {}"}, {"sha": "688b66a0a87744553a75916813929b52775b879c", "filename": "src/test/run-pass/self-impl.rs", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/926f38e588bb99aff1902fa94ab82b1db89cbbce/src%2Ftest%2Frun-pass%2Fself-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/926f38e588bb99aff1902fa94ab82b1db89cbbce/src%2Ftest%2Frun-pass%2Fself-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fself-impl.rs?ref=926f38e588bb99aff1902fa94ab82b1db89cbbce", "patch": "@@ -22,27 +22,57 @@ impl Foo {\n     fn foo(_x: Self, _y: &Self, _z: Box<Self>) -> Self {\n         Foo\n     }\n+\n+    fn baz() {\n+        // Test that Self cannot be shadowed.\n+        type Foo = i32;\n+        // There is no empty method on i32.\n+        Self::empty();\n+\n+        let _: Self = Foo;\n+    }\n+\n+    fn empty() {}\n }\n \n // Test uses when implementing a trait and with a type parameter.\n pub struct Baz<X> {\n     pub f: X,\n }\n \n-trait Bar<X> {\n-    fn bar(x: Self, y: &Self, z: Box<Self>) -> Self;\n+trait SuperBar {\n+    type SuperQux;\n+}\n+\n+trait Bar<X>: SuperBar {\n+    type Qux;\n+\n+    fn bar(x: Self, y: &Self, z: Box<Self>, _: Self::SuperQux) -> Self;\n     fn dummy(&self, x: X) { }\n }\n \n+impl SuperBar for Box<Baz<isize>> {\n+    type SuperQux = bool;\n+}\n+\n impl Bar<isize> for Box<Baz<isize>> {\n-    fn bar(_x: Self, _y: &Self, _z: Box<Self>) -> Self {\n+    type Qux = i32;\n+\n+    fn bar(_x: Self, _y: &Self, _z: Box<Self>, _: Self::SuperQux) -> Self {\n+        let _: Self::Qux = 42;\n+        let _: <Self as Bar<isize>>::Qux = 42;\n+\n+        let _: Self::SuperQux = true;\n+        let _: <Self as SuperBar>::SuperQux = true;\n+\n         box Baz { f: 42 }\n     }\n }\n \n fn main() {\n     let _: Foo = Foo::foo(Foo, &Foo, box Foo);\n     let _: Box<Baz<isize>> = Bar::bar(box Baz { f: 42 },\n-                                    &box Baz { f: 42 },\n-                                    box box Baz { f: 42 });\n+                                      &box Baz { f: 42 },\n+                                      box box Baz { f: 42 },\n+                                      true);\n }"}]}