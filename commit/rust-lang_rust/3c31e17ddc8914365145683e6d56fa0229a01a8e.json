{"sha": "3c31e17ddc8914365145683e6d56fa0229a01a8e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjMzFlMTdkZGM4OTE0MzY1MTQ1NjgzZTZkNTZmYTAyMjlhMDFhOGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-16T01:43:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-16T01:43:26Z"}, "message": "Auto merge of #50541 - QuietMisdreavus:rustdoc-errors, r=GuillaumeGomez\n\nrustdoc: replace most (e)println! statements with structured warnings/errors\n\nTurns out, the rustc diagnostic handler doesn't need a whole lot of setup that we weren't already doing. For errors that occur outside a \"dealing with source code\" context, we can just use the format/color config we were already parsing and make up a `Handler` that we can emit structured warnings/errors from. So i did that. This will make it way easier to test things with `rustdoc-ui` tests, since those require the JSON error output. (In fact, this PR is a yak shave for a different one where i was trying to do just that. `>_>`)", "tree": {"sha": "3a8e44a25eaff5e2a9df14d9aa83dd717e61ed18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a8e44a25eaff5e2a9df14d9aa83dd717e61ed18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c31e17ddc8914365145683e6d56fa0229a01a8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c31e17ddc8914365145683e6d56fa0229a01a8e", "html_url": "https://github.com/rust-lang/rust/commit/3c31e17ddc8914365145683e6d56fa0229a01a8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c31e17ddc8914365145683e6d56fa0229a01a8e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e44fc6c52d9674ed09958512e3bf09bc55bccecf", "url": "https://api.github.com/repos/rust-lang/rust/commits/e44fc6c52d9674ed09958512e3bf09bc55bccecf", "html_url": "https://github.com/rust-lang/rust/commit/e44fc6c52d9674ed09958512e3bf09bc55bccecf"}, {"sha": "c3fd12ff4e88321904e4e28949945c23f399da57", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3fd12ff4e88321904e4e28949945c23f399da57", "html_url": "https://github.com/rust-lang/rust/commit/c3fd12ff4e88321904e4e28949945c23f399da57"}], "stats": {"total": 266, "additions": 144, "deletions": 122}, "files": [{"sha": "c9a80d4779177bed04d448da3b747f940b408c61", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 53, "deletions": 32, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/3c31e17ddc8914365145683e6d56fa0229a01a8e/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c31e17ddc8914365145683e6d56fa0229a01a8e/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=3c31e17ddc8914365145683e6d56fa0229a01a8e", "patch": "@@ -117,6 +117,57 @@ impl DocAccessLevels for AccessLevels<DefId> {\n     }\n }\n \n+/// Creates a new diagnostic `Handler` that can be used to emit warnings and errors.\n+///\n+/// If the given `error_format` is `ErrorOutputType::Json` and no `CodeMap` is given, a new one\n+/// will be created for the handler.\n+pub fn new_handler(error_format: ErrorOutputType, codemap: Option<Lrc<codemap::CodeMap>>)\n+    -> errors::Handler\n+{\n+    // rustdoc doesn't override (or allow to override) anything from this that is relevant here, so\n+    // stick to the defaults\n+    let sessopts = config::basic_options();\n+    let emitter: Box<dyn Emitter + sync::Send> = match error_format {\n+        ErrorOutputType::HumanReadable(color_config) => Box::new(\n+            EmitterWriter::stderr(\n+                color_config,\n+                codemap.map(|cm| cm as _),\n+                false,\n+                sessopts.debugging_opts.teach,\n+            ).ui_testing(sessopts.debugging_opts.ui_testing)\n+        ),\n+        ErrorOutputType::Json(pretty) => {\n+            let codemap = codemap.unwrap_or_else(\n+                || Lrc::new(codemap::CodeMap::new(sessopts.file_path_mapping())));\n+            Box::new(\n+                JsonEmitter::stderr(\n+                    None,\n+                    codemap,\n+                    pretty,\n+                    sessopts.debugging_opts.suggestion_applicability,\n+                ).ui_testing(sessopts.debugging_opts.ui_testing)\n+            )\n+        },\n+        ErrorOutputType::Short(color_config) => Box::new(\n+            EmitterWriter::stderr(\n+                color_config,\n+                codemap.map(|cm| cm as _),\n+                true,\n+                false)\n+        ),\n+    };\n+\n+    errors::Handler::with_emitter_and_flags(\n+        emitter,\n+        errors::HandlerFlags {\n+            can_emit_warnings: true,\n+            treat_err_as_bug: false,\n+            external_macro_backtrace: false,\n+            ..Default::default()\n+        },\n+    )\n+}\n+\n pub fn run_core(search_paths: SearchPaths,\n                 cfgs: Vec<String>,\n                 externs: config::Externs,\n@@ -159,41 +210,11 @@ pub fn run_core(search_paths: SearchPaths,\n         },\n         error_format,\n         edition,\n-        ..config::basic_options().clone()\n+        ..config::basic_options()\n     };\n     driver::spawn_thread_pool(sessopts, move |sessopts| {\n         let codemap = Lrc::new(codemap::CodeMap::new(sessopts.file_path_mapping()));\n-        let emitter: Box<dyn Emitter + sync::Send> = match error_format {\n-            ErrorOutputType::HumanReadable(color_config) => Box::new(\n-                EmitterWriter::stderr(\n-                    color_config,\n-                    Some(codemap.clone()),\n-                    false,\n-                    sessopts.debugging_opts.teach,\n-                ).ui_testing(sessopts.debugging_opts.ui_testing)\n-            ),\n-            ErrorOutputType::Json(pretty) => Box::new(\n-                JsonEmitter::stderr(\n-                    None,\n-                    codemap.clone(),\n-                    pretty,\n-                    sessopts.debugging_opts.suggestion_applicability,\n-                ).ui_testing(sessopts.debugging_opts.ui_testing)\n-            ),\n-            ErrorOutputType::Short(color_config) => Box::new(\n-                EmitterWriter::stderr(color_config, Some(codemap.clone()), true, false)\n-            ),\n-        };\n-\n-        let diagnostic_handler = errors::Handler::with_emitter_and_flags(\n-            emitter,\n-            errors::HandlerFlags {\n-                can_emit_warnings: true,\n-                treat_err_as_bug: false,\n-                external_macro_backtrace: false,\n-                ..Default::default()\n-            },\n-        );\n+        let diagnostic_handler = new_handler(error_format, Some(codemap.clone()));\n \n         let mut sess = session::build_session_(\n             sessopts, cpath, diagnostic_handler, codemap,"}, {"sha": "10b6c9850ae7773dc99d20972ce918c9f42570cc", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3c31e17ddc8914365145683e6d56fa0229a01a8e/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c31e17ddc8914365145683e6d56fa0229a01a8e/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=3c31e17ddc8914365145683e6d56fa0229a01a8e", "patch": "@@ -11,6 +11,7 @@\n use std::fs;\n use std::path::Path;\n use std::str;\n+use errors;\n use html::markdown::Markdown;\n \n #[derive(Clone)]\n@@ -28,23 +29,23 @@ pub struct ExternalHtml {\n \n impl ExternalHtml {\n     pub fn load(in_header: &[String], before_content: &[String], after_content: &[String],\n-                md_before_content: &[String], md_after_content: &[String])\n+                md_before_content: &[String], md_after_content: &[String], diag: &errors::Handler)\n             -> Option<ExternalHtml> {\n-        load_external_files(in_header)\n+        load_external_files(in_header, diag)\n             .and_then(|ih|\n-                load_external_files(before_content)\n+                load_external_files(before_content, diag)\n                     .map(|bc| (ih, bc))\n             )\n             .and_then(|(ih, bc)|\n-                load_external_files(md_before_content)\n+                load_external_files(md_before_content, diag)\n                     .map(|m_bc| (ih, format!(\"{}{}\", bc, Markdown(&m_bc, &[]))))\n             )\n             .and_then(|(ih, bc)|\n-                load_external_files(after_content)\n+                load_external_files(after_content, diag)\n                     .map(|ac| (ih, bc, ac))\n             )\n             .and_then(|(ih, bc, ac)|\n-                load_external_files(md_after_content)\n+                load_external_files(md_after_content, diag)\n                     .map(|m_ac| (ih, bc, format!(\"{}{}\", ac, Markdown(&m_ac, &[]))))\n             )\n             .map(|(ih, bc, ac)|\n@@ -62,28 +63,30 @@ pub enum LoadStringError {\n     BadUtf8,\n }\n \n-pub fn load_string<P: AsRef<Path>>(file_path: P) -> Result<String, LoadStringError> {\n+pub fn load_string<P: AsRef<Path>>(file_path: P, diag: &errors::Handler)\n+    -> Result<String, LoadStringError>\n+{\n     let file_path = file_path.as_ref();\n     let contents = match fs::read(file_path) {\n         Ok(bytes) => bytes,\n         Err(e) => {\n-            eprintln!(\"error reading `{}`: {}\", file_path.display(), e);\n+            diag.struct_err(&format!(\"error reading `{}`: {}\", file_path.display(), e)).emit();\n             return Err(LoadStringError::ReadFail);\n         }\n     };\n     match str::from_utf8(&contents) {\n         Ok(s) => Ok(s.to_string()),\n         Err(_) => {\n-            eprintln!(\"error reading `{}`: not UTF-8\", file_path.display());\n+            diag.struct_err(&format!(\"error reading `{}`: not UTF-8\", file_path.display())).emit();\n             Err(LoadStringError::BadUtf8)\n         }\n     }\n }\n \n-fn load_external_files(names: &[String]) -> Option<String> {\n+fn load_external_files(names: &[String], diag: &errors::Handler) -> Option<String> {\n     let mut out = String::new();\n     for name in names {\n-        let s = match load_string(name) {\n+        let s = match load_string(name, diag) {\n             Ok(s) => s,\n             Err(_) => return None,\n         };"}, {"sha": "7d98feaf539474856e043cd263a356020abffa6d", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 60, "deletions": 67, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/3c31e17ddc8914365145683e6d56fa0229a01a8e/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c31e17ddc8914365145683e6d56fa0229a01a8e/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=3c31e17ddc8914365145683e6d56fa0229a01a8e", "patch": "@@ -57,15 +57,13 @@ use errors::ColorConfig;\n use std::collections::{BTreeMap, BTreeSet};\n use std::default::Default;\n use std::env;\n-use std::fmt::Display;\n-use std::io;\n-use std::io::Write;\n use std::path::{Path, PathBuf};\n use std::process;\n use std::sync::mpsc::channel;\n \n use syntax::edition::Edition;\n use externalfiles::ExternalHtml;\n+use rustc::session::{early_warn, early_error};\n use rustc::session::search_paths::SearchPaths;\n use rustc::session::config::{ErrorOutputType, RustcOptGroup, Externs, CodegenOptions};\n use rustc::session::config::{nightly_options, build_codegen_options};\n@@ -119,7 +117,8 @@ pub fn main() {\n fn get_args() -> Option<Vec<String>> {\n     env::args_os().enumerate()\n         .map(|(i, arg)| arg.into_string().map_err(|arg| {\n-             print_error(format!(\"Argument {} is not valid Unicode: {:?}\", i, arg));\n+             early_warn(ErrorOutputType::default(),\n+                        &format!(\"Argument {} is not valid Unicode: {:?}\", i, arg));\n         }).ok())\n         .collect()\n }\n@@ -324,16 +323,12 @@ pub fn main_args(args: &[String]) -> isize {\n     let matches = match options.parse(&args[1..]) {\n         Ok(m) => m,\n         Err(err) => {\n-            print_error(err);\n-            return 1;\n+            early_error(ErrorOutputType::default(), &err.to_string());\n         }\n     };\n     // Check for unstable options.\n     nightly_options::check_nightly_options(&matches, &opts());\n \n-    // check for deprecated options\n-    check_deprecated_options(&matches);\n-\n     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n         usage(\"rustdoc\");\n         return 0;\n@@ -354,6 +349,35 @@ pub fn main_args(args: &[String]) -> isize {\n         return 0;\n     }\n \n+    let color = match matches.opt_str(\"color\").as_ref().map(|s| &s[..]) {\n+        Some(\"auto\") => ColorConfig::Auto,\n+        Some(\"always\") => ColorConfig::Always,\n+        Some(\"never\") => ColorConfig::Never,\n+        None => ColorConfig::Auto,\n+        Some(arg) => {\n+            early_error(ErrorOutputType::default(),\n+                        &format!(\"argument for --color must be `auto`, `always` or `never` \\\n+                                  (instead was `{}`)\", arg));\n+        }\n+    };\n+    let error_format = match matches.opt_str(\"error-format\").as_ref().map(|s| &s[..]) {\n+        Some(\"human\") => ErrorOutputType::HumanReadable(color),\n+        Some(\"json\") => ErrorOutputType::Json(false),\n+        Some(\"pretty-json\") => ErrorOutputType::Json(true),\n+        Some(\"short\") => ErrorOutputType::Short(color),\n+        None => ErrorOutputType::HumanReadable(color),\n+        Some(arg) => {\n+            early_error(ErrorOutputType::default(),\n+                        &format!(\"argument for --error-format must be `human`, `json` or \\\n+                                  `short` (instead was `{}`)\", arg));\n+        }\n+    };\n+\n+    let diag = core::new_handler(error_format, None);\n+\n+    // check for deprecated options\n+    check_deprecated_options(&matches, &diag);\n+\n     let to_check = matches.opt_strs(\"theme-checker\");\n     if !to_check.is_empty() {\n         let paths = theme::load_css_paths(include_bytes!(\"html/static/themes/light.css\"));\n@@ -362,7 +386,7 @@ pub fn main_args(args: &[String]) -> isize {\n         println!(\"rustdoc: [theme-checker] Starting tests!\");\n         for theme_file in to_check.iter() {\n             print!(\" - Checking \\\"{}\\\"...\", theme_file);\n-            let (success, differences) = theme::test_theme_against(theme_file, &paths);\n+            let (success, differences) = theme::test_theme_against(theme_file, &paths, &diag);\n             if !differences.is_empty() || !success {\n                 println!(\" FAILED\");\n                 errors += 1;\n@@ -380,47 +404,23 @@ pub fn main_args(args: &[String]) -> isize {\n     }\n \n     if matches.free.is_empty() {\n-        print_error(\"missing file operand\");\n+        diag.struct_err(\"missing file operand\").emit();\n         return 1;\n     }\n     if matches.free.len() > 1 {\n-        print_error(\"too many file operands\");\n+        diag.struct_err(\"too many file operands\").emit();\n         return 1;\n     }\n     let input = &matches.free[0];\n \n-    let color = match matches.opt_str(\"color\").as_ref().map(|s| &s[..]) {\n-        Some(\"auto\") => ColorConfig::Auto,\n-        Some(\"always\") => ColorConfig::Always,\n-        Some(\"never\") => ColorConfig::Never,\n-        None => ColorConfig::Auto,\n-        Some(arg) => {\n-            print_error(&format!(\"argument for --color must be `auto`, `always` or `never` \\\n-                                  (instead was `{}`)\", arg));\n-            return 1;\n-        }\n-    };\n-    let error_format = match matches.opt_str(\"error-format\").as_ref().map(|s| &s[..]) {\n-        Some(\"human\") => ErrorOutputType::HumanReadable(color),\n-        Some(\"json\") => ErrorOutputType::Json(false),\n-        Some(\"pretty-json\") => ErrorOutputType::Json(true),\n-        Some(\"short\") => ErrorOutputType::Short(color),\n-        None => ErrorOutputType::HumanReadable(color),\n-        Some(arg) => {\n-            print_error(&format!(\"argument for --error-format must be `human`, `json` or \\\n-                                  `short` (instead was `{}`)\", arg));\n-            return 1;\n-        }\n-    };\n-\n     let mut libs = SearchPaths::new();\n     for s in &matches.opt_strs(\"L\") {\n         libs.add_path(s, error_format);\n     }\n     let externs = match parse_externs(&matches) {\n         Ok(ex) => ex,\n         Err(err) => {\n-            print_error(err);\n+            diag.struct_err(&err.to_string()).emit();\n             return 1;\n         }\n     };\n@@ -441,10 +441,7 @@ pub fn main_args(args: &[String]) -> isize {\n \n     if let Some(ref p) = css_file_extension {\n         if !p.is_file() {\n-            writeln!(\n-                &mut io::stderr(),\n-                \"rustdoc: option --extend-css argument must be a file.\"\n-            ).unwrap();\n+            diag.struct_err(\"option --extend-css argument must be a file\").emit();\n             return 1;\n         }\n     }\n@@ -457,13 +454,14 @@ pub fn main_args(args: &[String]) -> isize {\n                                             .iter()\n                                             .map(|s| (PathBuf::from(&s), s.to_owned())) {\n             if !theme_file.is_file() {\n-                println!(\"rustdoc: option --themes arguments must all be files\");\n+                diag.struct_err(\"option --themes arguments must all be files\").emit();\n                 return 1;\n             }\n-            let (success, ret) = theme::test_theme_against(&theme_file, &paths);\n+            let (success, ret) = theme::test_theme_against(&theme_file, &paths, &diag);\n             if !success || !ret.is_empty() {\n-                println!(\"rustdoc: invalid theme: \\\"{}\\\"\", theme_s);\n-                println!(\"         Check what's wrong with the \\\"theme-checker\\\" option\");\n+                diag.struct_err(&format!(\"invalid theme: \\\"{}\\\"\", theme_s))\n+                    .help(\"check what's wrong with the --theme-checker option\")\n+                    .emit();\n                 return 1;\n             }\n             themes.push(theme_file);\n@@ -475,7 +473,7 @@ pub fn main_args(args: &[String]) -> isize {\n             &matches.opt_strs(\"html-before-content\"),\n             &matches.opt_strs(\"html-after-content\"),\n             &matches.opt_strs(\"markdown-before-content\"),\n-            &matches.opt_strs(\"markdown-after-content\")) {\n+            &matches.opt_strs(\"markdown-after-content\"), &diag) {\n         Some(eh) => eh,\n         None => return 3,\n     };\n@@ -492,7 +490,7 @@ pub fn main_args(args: &[String]) -> isize {\n     let edition = match edition.parse() {\n         Ok(e) => e,\n         Err(_) => {\n-            print_error(\"could not parse edition\");\n+            diag.struct_err(\"could not parse edition\").emit();\n             return 1;\n         }\n     };\n@@ -502,7 +500,7 @@ pub fn main_args(args: &[String]) -> isize {\n     match (should_test, markdown_input) {\n         (true, true) => {\n             return markdown::test(input, cfgs, libs, externs, test_args, maybe_sysroot,\n-                                  display_warnings, linker, edition, cg)\n+                                  display_warnings, linker, edition, cg, &diag)\n         }\n         (true, false) => {\n             return test::run(Path::new(input), cfgs, libs, externs, test_args, crate_name,\n@@ -511,7 +509,7 @@ pub fn main_args(args: &[String]) -> isize {\n         (false, true) => return markdown::render(Path::new(input),\n                                                  output.unwrap_or(PathBuf::from(\"doc\")),\n                                                  &matches, &external_html,\n-                                                 !matches.opt_present(\"markdown-no-toc\")),\n+                                                 !matches.opt_present(\"markdown-no-toc\"), &diag),\n         (false, false) => {}\n     }\n \n@@ -520,6 +518,7 @@ pub fn main_args(args: &[String]) -> isize {\n     let res = acquire_input(PathBuf::from(input), externs, edition, cg, &matches, error_format,\n                             move |out| {\n         let Output { krate, passes, renderinfo } = out;\n+        let diag = core::new_handler(error_format, None);\n         info!(\"going to format\");\n         match output_format.as_ref().map(|s| &**s) {\n             Some(\"html\") | None => {\n@@ -536,26 +535,17 @@ pub fn main_args(args: &[String]) -> isize {\n                 0\n             }\n             Some(s) => {\n-                print_error(format!(\"unknown output format: {}\", s));\n+                diag.struct_err(&format!(\"unknown output format: {}\", s)).emit();\n                 1\n             }\n         }\n     });\n     res.unwrap_or_else(|s| {\n-        print_error(format!(\"input error: {}\", s));\n+        diag.struct_err(&format!(\"input error: {}\", s)).emit();\n         1\n     })\n }\n \n-/// Prints an uniformized error message on the standard error output\n-fn print_error<T>(error_message: T) where T: Display {\n-    writeln!(\n-        &mut io::stderr(),\n-        \"rustdoc: {}\\nTry 'rustdoc --help' for more information.\",\n-        error_message\n-    ).unwrap();\n-}\n-\n /// Looks inside the command line arguments to extract the relevant input format\n /// and files and then generates the necessary rustdoc output for formatting.\n fn acquire_input<R, F>(input: PathBuf,\n@@ -722,7 +712,7 @@ where R: 'static + Send,\n }\n \n /// Prints deprecation warnings for deprecated options\n-fn check_deprecated_options(matches: &getopts::Matches) {\n+fn check_deprecated_options(matches: &getopts::Matches, diag: &errors::Handler) {\n     let deprecated_flags = [\n        \"input-format\",\n        \"output-format\",\n@@ -734,12 +724,15 @@ fn check_deprecated_options(matches: &getopts::Matches) {\n \n     for flag in deprecated_flags.into_iter() {\n         if matches.opt_present(flag) {\n-            eprintln!(\"WARNING: the '{}' flag is considered deprecated\", flag);\n-            eprintln!(\"WARNING: please see https://github.com/rust-lang/rust/issues/44136\");\n-        }\n-    }\n+            let mut err = diag.struct_warn(&format!(\"the '{}' flag is considered deprecated\",\n+                                                    flag));\n+            err.warn(\"please see https://github.com/rust-lang/rust/issues/44136\");\n \n-    if matches.opt_present(\"no-defaults\") {\n-        eprintln!(\"WARNING: (you may want to use --document-private-items)\");\n+            if *flag == \"no-defaults\" {\n+                err.help(\"you may want to use --document-private-items\");\n+            }\n+\n+            err.emit();\n+        }\n     }\n }"}, {"sha": "bf7b025884d5ab858628b5b18b320e7d98935f0e", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3c31e17ddc8914365145683e6d56fa0229a01a8e/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c31e17ddc8914365145683e6d56fa0229a01a8e/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=3c31e17ddc8914365145683e6d56fa0229a01a8e", "patch": "@@ -13,6 +13,7 @@ use std::fs::File;\n use std::io::prelude::*;\n use std::path::{PathBuf, Path};\n \n+use errors;\n use getopts;\n use testing;\n use rustc::session::search_paths::SearchPaths;\n@@ -50,7 +51,7 @@ fn extract_leading_metadata<'a>(s: &'a str) -> (Vec<&'a str>, &'a str) {\n /// Render `input` (e.g. \"foo.md\") into an HTML file in `output`\n /// (e.g. output = \"bar\" => \"bar/foo.html\").\n pub fn render(input: &Path, mut output: PathBuf, matches: &getopts::Matches,\n-              external_html: &ExternalHtml, include_toc: bool) -> isize {\n+              external_html: &ExternalHtml, include_toc: bool, diag: &errors::Handler) -> isize {\n     output.push(input.file_stem().unwrap());\n     output.set_extension(\"html\");\n \n@@ -60,7 +61,7 @@ pub fn render(input: &Path, mut output: PathBuf, matches: &getopts::Matches,\n         css.push_str(&s)\n     }\n \n-    let input_str = match load_string(input) {\n+    let input_str = match load_string(input, diag) {\n         Ok(s) => s,\n         Err(LoadStringError::ReadFail) => return 1,\n         Err(LoadStringError::BadUtf8) => return 2,\n@@ -72,15 +73,15 @@ pub fn render(input: &Path, mut output: PathBuf, matches: &getopts::Matches,\n \n     let mut out = match File::create(&output) {\n         Err(e) => {\n-            eprintln!(\"rustdoc: {}: {}\", output.display(), e);\n+            diag.struct_err(&format!(\"{}: {}\", output.display(), e)).emit();\n             return 4;\n         }\n         Ok(f) => f\n     };\n \n     let (metadata, text) = extract_leading_metadata(&input_str);\n     if metadata.is_empty() {\n-        eprintln!(\"rustdoc: invalid markdown file: no initial lines starting with `# ` or `%`\");\n+        diag.struct_err(\"invalid markdown file: no initial lines starting with `# ` or `%`\").emit();\n         return 5;\n     }\n     let title = metadata[0];\n@@ -130,7 +131,7 @@ pub fn render(input: &Path, mut output: PathBuf, matches: &getopts::Matches,\n \n     match err {\n         Err(e) => {\n-            eprintln!(\"rustdoc: cannot write to `{}`: {}\", output.display(), e);\n+            diag.struct_err(&format!(\"cannot write to `{}`: {}\", output.display(), e)).emit();\n             6\n         }\n         Ok(_) => 0,\n@@ -141,8 +142,8 @@ pub fn render(input: &Path, mut output: PathBuf, matches: &getopts::Matches,\n pub fn test(input: &str, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n             mut test_args: Vec<String>, maybe_sysroot: Option<PathBuf>,\n             display_warnings: bool, linker: Option<PathBuf>, edition: Edition,\n-            cg: CodegenOptions) -> isize {\n-    let input_str = match load_string(input) {\n+            cg: CodegenOptions, diag: &errors::Handler) -> isize {\n+    let input_str = match load_string(input, diag) {\n         Ok(s) => s,\n         Err(LoadStringError::ReadFail) => return 1,\n         Err(LoadStringError::BadUtf8) => return 2,"}, {"sha": "96a67e078875800bbc06e84183ee88a242a4b7d5", "filename": "src/librustdoc/theme.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3c31e17ddc8914365145683e6d56fa0229a01a8e/src%2Flibrustdoc%2Ftheme.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c31e17ddc8914365145683e6d56fa0229a01a8e/src%2Flibrustdoc%2Ftheme.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftheme.rs?ref=3c31e17ddc8914365145683e6d56fa0229a01a8e", "patch": "@@ -14,12 +14,14 @@ use std::hash::{Hash, Hasher};\n use std::io::Read;\n use std::path::Path;\n \n+use errors::Handler;\n+\n macro_rules! try_something {\n-    ($e:expr, $out:expr) => ({\n+    ($e:expr, $diag:expr, $out:expr) => ({\n         match $e {\n             Ok(c) => c,\n             Err(e) => {\n-                eprintln!(\"rustdoc: got an error: {}\", e);\n+                $diag.struct_err(&e.to_string()).emit();\n                 return $out;\n             }\n         }\n@@ -273,11 +275,13 @@ pub fn get_differences(against: &CssPath, other: &CssPath, v: &mut Vec<String>)\n     }\n }\n \n-pub fn test_theme_against<P: AsRef<Path>>(f: &P, against: &CssPath) -> (bool, Vec<String>) {\n-    let mut file = try_something!(File::open(f), (false, Vec::new()));\n+pub fn test_theme_against<P: AsRef<Path>>(f: &P, against: &CssPath, diag: &Handler)\n+    -> (bool, Vec<String>)\n+{\n+    let mut file = try_something!(File::open(f), diag, (false, Vec::new()));\n     let mut data = Vec::with_capacity(1000);\n \n-    try_something!(file.read_to_end(&mut data), (false, Vec::new()));\n+    try_something!(file.read_to_end(&mut data), diag, (false, Vec::new()));\n     let paths = load_css_paths(&data);\n     let mut ret = Vec::new();\n     get_differences(against, &paths, &mut ret);"}]}