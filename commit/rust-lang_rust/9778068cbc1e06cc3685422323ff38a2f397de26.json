{"sha": "9778068cbc1e06cc3685422323ff38a2f397de26", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3NzgwNjhjYmMxZTA2Y2MzNjg1NDIyMzIzZmYzOGEyZjM5N2RlMjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-07T19:36:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-07T19:36:10Z"}, "message": "Auto merge of #79078 - petrochenkov:derattr, r=Aaron1011\n\nexpand/resolve: Turn `#[derive]` into a regular macro attribute\n\nThis PR turns `#[derive]` into a regular attribute macro declared in libcore and defined in `rustc_builtin_macros`, like it was previously done with other \"active\" attributes in https://github.com/rust-lang/rust/pull/62086, https://github.com/rust-lang/rust/pull/62735 and other PRs.\nThis PR is also a continuation of #65252, #69870 and other PRs linked from them, which layed the ground for converting `#[derive]` specifically.\n\n`#[derive]` still asks `rustc_resolve` to resolve paths inside `derive(...)`, and `rustc_expand` gets those resolution results through some backdoor (which I'll try to address later), but otherwise `#[derive]` is treated as any other macro attributes, which simplifies the resolution-expansion infra pretty significantly.\n\nThe change has several observable effects on language and library.\nSome of the language changes are **feature-gated** by [`feature(macro_attributes_in_derive_output)`](https://github.com/rust-lang/rust/issues/81119).\n\n#### Library\n\n- `derive` is now available through standard library as `{core,std}::prelude::v1::derive`.\n\n#### Language\n\n- `derive` now goes through name resolution, so it can now be renamed - `use derive as my_derive; #[my_derive(Debug)] struct S;`.\n- `derive` now goes through name resolution, so this resolution can fail in corner cases. Crater found one such regression, where import `use foo as derive` goes into a cycle with `#[derive(Something)]`.\n- **[feature-gated]** `#[derive]` is now expanded as any other attributes in left-to-right order. This allows to remove the restriction on other macro attributes following `#[derive]` (https://github.com/rust-lang/reference/issues/566). The following macro attributes become a part of the derive's input (this is not a change, non-macro attributes following `#[derive]` were treated in the same way previously).\n- `#[derive]` is now expanded as any other attributes in left-to-right order. This means two derive attributes `#[derive(Foo)] #[derive(Bar)]` are now expanded separately rather than together. It doesn't generally make difference, except for esoteric cases. For example `#[derive(Foo)]` can now produce an import bringing `Bar` into scope, but previously both `Foo` and `Bar` were required to be resolved before expanding any of them.\n- **[feature-gated]** `#[derive()]` (with empty list in parentheses) actually becomes useful. For historical reasons `#[derive]` *fully configures* its input, eagerly evaluating `cfg` everywhere in its target, for example on fields.\nExpansion infra doesn't do that for other attributes, but now when macro attributes attributes are allowed to be written after `#[derive]`, it means that derive can *fully configure* items for them.\n    ```rust\n\t#[derive()]\n\t#[my_attr]\n\tstruct S {\n\t\t#[cfg(FALSE)] // this field in removed by `#[derive()]` and not observed by `#[my_attr]`\n\t\tfield: u8\n\t}\n    ```\n- `#[derive]` on some non-item targets is now prohibited. This was accidentally allowed as noop in the past, but was warned about since early 2018 (#50092), despite that crater found a few such cases in unmaintained crates.\n- Derive helper attributes used before their introduction are now reported with a deprecation lint. This change is long overdue (since macro modularization, https://github.com/rust-lang/rust/issues/52226#issuecomment-422605033), but it was hard to do without fixing expansion order for derives. The deprecation is tracked by #79202.\n```rust\n    #[trait_helper] // warning: derive helper attribute is used before it is introduced\n    #[derive(Trait)]\n    struct S {}\n```\n\nCrater analysis: https://github.com/rust-lang/rust/pull/79078#issuecomment-731436821", "tree": {"sha": "c7f9f35691cb44f5ce0d71b350b5541fdce656cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7f9f35691cb44f5ce0d71b350b5541fdce656cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9778068cbc1e06cc3685422323ff38a2f397de26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9778068cbc1e06cc3685422323ff38a2f397de26", "html_url": "https://github.com/rust-lang/rust/commit/9778068cbc1e06cc3685422323ff38a2f397de26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9778068cbc1e06cc3685422323ff38a2f397de26/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923", "url": "https://api.github.com/repos/rust-lang/rust/commits/36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923", "html_url": "https://github.com/rust-lang/rust/commit/36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923"}, {"sha": "d8af6de911957075ca6e0e51b034513b51849d99", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8af6de911957075ca6e0e51b034513b51849d99", "html_url": "https://github.com/rust-lang/rust/commit/d8af6de911957075ca6e0e51b034513b51849d99"}], "stats": {"total": 2404, "additions": 1396, "deletions": 1008}, "files": [{"sha": "6f29120455e5536968899333379bb5d01fc37064", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -3582,6 +3582,7 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_expand\",\n  \"rustc_feature\",\n+ \"rustc_lexer\",\n  \"rustc_parse\",\n  \"rustc_parse_format\",\n  \"rustc_session\","}, {"sha": "eb022b5b2b16e585744473902b12b51ba8b3ec35", "filename": "compiler/rustc_builtin_macros/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/compiler%2Frustc_builtin_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/compiler%2Frustc_builtin_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2FCargo.toml?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -15,6 +15,7 @@ rustc_attr = { path = \"../rustc_attr\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_errors = { path = \"../rustc_errors\" }\n rustc_feature = { path = \"../rustc_feature\" }\n+rustc_lexer = { path = \"../rustc_lexer\" }\n rustc_parse = { path = \"../rustc_parse\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_session = { path = \"../rustc_session\" }"}, {"sha": "fad64858ce3ffd9cdc7eb8a9cd90511d90f9df94", "filename": "compiler/rustc_builtin_macros/src/derive.rs", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -0,0 +1,132 @@\n+use rustc_ast::{self as ast, token, ItemKind, MetaItemKind, NestedMetaItem, StmtKind};\n+use rustc_errors::{struct_span_err, Applicability};\n+use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, Indeterminate, MultiItemModifier};\n+use rustc_expand::config::StripUnconfigured;\n+use rustc_feature::AttributeTemplate;\n+use rustc_parse::validate_attr;\n+use rustc_session::Session;\n+use rustc_span::symbol::sym;\n+use rustc_span::Span;\n+\n+crate struct Expander;\n+\n+impl MultiItemModifier for Expander {\n+    fn expand(\n+        &self,\n+        ecx: &mut ExtCtxt<'_>,\n+        span: Span,\n+        meta_item: &ast::MetaItem,\n+        item: Annotatable,\n+    ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n+        let sess = ecx.sess;\n+        if report_bad_target(sess, &item, span) {\n+            // We don't want to pass inappropriate targets to derive macros to avoid\n+            // follow up errors, all other errors below are recoverable.\n+            return ExpandResult::Ready(vec![item]);\n+        }\n+\n+        let template =\n+            AttributeTemplate { list: Some(\"Trait1, Trait2, ...\"), ..Default::default() };\n+        let attr = ecx.attribute(meta_item.clone());\n+        validate_attr::check_builtin_attribute(&sess.parse_sess, &attr, sym::derive, template);\n+\n+        let derives: Vec<_> = attr\n+            .meta_item_list()\n+            .unwrap_or_default()\n+            .into_iter()\n+            .filter_map(|nested_meta| match nested_meta {\n+                NestedMetaItem::MetaItem(meta) => Some(meta),\n+                NestedMetaItem::Literal(lit) => {\n+                    // Reject `#[derive(\"Debug\")]`.\n+                    report_unexpected_literal(sess, &lit);\n+                    None\n+                }\n+            })\n+            .map(|meta| {\n+                // Reject `#[derive(Debug = \"value\", Debug(abc))]`, but recover the paths.\n+                report_path_args(sess, &meta);\n+                meta.path\n+            })\n+            .collect();\n+\n+        // FIXME: Try to cache intermediate results to avoid collecting same paths multiple times.\n+        match ecx.resolver.resolve_derives(ecx.current_expansion.id, derives, ecx.force_mode) {\n+            Ok(()) => {\n+                let mut visitor =\n+                    StripUnconfigured { sess, features: ecx.ecfg.features, modified: false };\n+                let mut item = visitor.fully_configure(item);\n+                if visitor.modified {\n+                    // Erase the tokens if cfg-stripping modified the item\n+                    // This will cause us to synthesize fake tokens\n+                    // when `nt_to_tokenstream` is called on this item.\n+                    match &mut item {\n+                        Annotatable::Item(item) => item,\n+                        Annotatable::Stmt(stmt) => match &mut stmt.kind {\n+                            StmtKind::Item(item) => item,\n+                            _ => unreachable!(),\n+                        },\n+                        _ => unreachable!(),\n+                    }\n+                    .tokens = None;\n+                }\n+                ExpandResult::Ready(vec![item])\n+            }\n+            Err(Indeterminate) => ExpandResult::Retry(item),\n+        }\n+    }\n+}\n+\n+fn report_bad_target(sess: &Session, item: &Annotatable, span: Span) -> bool {\n+    let item_kind = match item {\n+        Annotatable::Item(item) => Some(&item.kind),\n+        Annotatable::Stmt(stmt) => match &stmt.kind {\n+            StmtKind::Item(item) => Some(&item.kind),\n+            _ => None,\n+        },\n+        _ => None,\n+    };\n+\n+    let bad_target =\n+        !matches!(item_kind, Some(ItemKind::Struct(..) | ItemKind::Enum(..) | ItemKind::Union(..)));\n+    if bad_target {\n+        struct_span_err!(\n+            sess,\n+            span,\n+            E0774,\n+            \"`derive` may only be applied to structs, enums and unions\",\n+        )\n+        .emit();\n+    }\n+    bad_target\n+}\n+\n+fn report_unexpected_literal(sess: &Session, lit: &ast::Lit) {\n+    let help_msg = match lit.token.kind {\n+        token::Str if rustc_lexer::is_ident(&lit.token.symbol.as_str()) => {\n+            format!(\"try using `#[derive({})]`\", lit.token.symbol)\n+        }\n+        _ => \"for example, write `#[derive(Debug)]` for `Debug`\".to_string(),\n+    };\n+    struct_span_err!(sess, lit.span, E0777, \"expected path to a trait, found literal\",)\n+        .help(&help_msg)\n+        .emit();\n+}\n+\n+fn report_path_args(sess: &Session, meta: &ast::MetaItem) {\n+    let report_error = |title, action| {\n+        let span = meta.span.with_lo(meta.path.span.hi());\n+        sess.struct_span_err(span, title)\n+            .span_suggestion(span, action, String::new(), Applicability::MachineApplicable)\n+            .emit();\n+    };\n+    match meta.kind {\n+        MetaItemKind::Word => {}\n+        MetaItemKind::List(..) => report_error(\n+            \"traits in `#[derive(...)]` don't accept arguments\",\n+            \"remove the arguments\",\n+        ),\n+        MetaItemKind::NameValue(..) => {\n+            report_error(\"traits in `#[derive(...)]` don't accept values\", \"remove the value\")\n+        }\n+    }\n+}"}, {"sha": "9a3c914337ca257b5f124afc93f29c4df8abbd0c", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -27,6 +27,7 @@ mod cfg_accessible;\n mod compile_error;\n mod concat;\n mod concat_idents;\n+mod derive;\n mod deriving;\n mod env;\n mod format;\n@@ -88,6 +89,7 @@ pub fn register_builtin_macros(resolver: &mut dyn ResolverExpand) {\n     register_attr! {\n         bench: test::expand_bench,\n         cfg_accessible: cfg_accessible::Expander,\n+        derive: derive::Expander,\n         global_allocator: global_allocator::expand,\n         test: test::expand_test,\n         test_case: test::expand_test_case,"}, {"sha": "196a774355e10d1b2c79dd9e45f24f07c5fe5a37", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 19, "deletions": 28, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -141,7 +141,10 @@ impl Annotatable {\n     }\n \n     crate fn into_tokens(self, sess: &ParseSess) -> TokenStream {\n-        nt_to_tokenstream(&self.into_nonterminal(), sess, CanSynthesizeMissingTokens::No)\n+        // Tokens of an attribute target may be invalidated by some outer `#[derive]` performing\n+        // \"full configuration\" (attributes following derives on the same item should be the most\n+        // common case), that's why synthesizing tokens is allowed.\n+        nt_to_tokenstream(&self.into_nonterminal(), sess, CanSynthesizeMissingTokens::Yes)\n     }\n \n     pub fn expect_item(self) -> P<ast::Item> {\n@@ -234,25 +237,6 @@ impl Annotatable {\n             _ => panic!(\"expected variant\"),\n         }\n     }\n-\n-    pub fn derive_allowed(&self) -> bool {\n-        match *self {\n-            Annotatable::Stmt(ref stmt) => match stmt.kind {\n-                ast::StmtKind::Item(ref item) => matches!(\n-                    item.kind,\n-                    ast::ItemKind::Struct(..) | ast::ItemKind::Enum(..) | ast::ItemKind::Union(..)\n-                ),\n-                _ => false,\n-            },\n-            Annotatable::Item(ref item) => match item.kind {\n-                ast::ItemKind::Struct(..) | ast::ItemKind::Enum(..) | ast::ItemKind::Union(..) => {\n-                    true\n-                }\n-                _ => false,\n-            },\n-            _ => false,\n-        }\n-    }\n }\n \n /// Result of an expansion that may need to be retried.\n@@ -854,12 +838,6 @@ impl SyntaxExtension {\n     }\n }\n \n-/// Result of resolving a macro invocation.\n-pub enum InvocationRes {\n-    Single(Lrc<SyntaxExtension>),\n-    DeriveContainer(Vec<Lrc<SyntaxExtension>>),\n-}\n-\n /// Error type that denotes indeterminacy.\n pub struct Indeterminate;\n \n@@ -885,16 +863,29 @@ pub trait ResolverExpand {\n         invoc: &Invocation,\n         eager_expansion_root: ExpnId,\n         force: bool,\n-    ) -> Result<InvocationRes, Indeterminate>;\n+    ) -> Result<Lrc<SyntaxExtension>, Indeterminate>;\n \n     fn check_unused_macros(&mut self);\n \n     /// Some parent node that is close enough to the given macro call.\n-    fn lint_node_id(&mut self, expn_id: ExpnId) -> NodeId;\n+    fn lint_node_id(&self, expn_id: ExpnId) -> NodeId;\n \n     // Resolver interfaces for specific built-in macros.\n     /// Does `#[derive(...)]` attribute with the given `ExpnId` have built-in `Copy` inside it?\n     fn has_derive_copy(&self, expn_id: ExpnId) -> bool;\n+    /// Resolve paths inside the `#[derive(...)]` attribute with the given `ExpnId`.\n+    fn resolve_derives(\n+        &mut self,\n+        expn_id: ExpnId,\n+        derives: Vec<ast::Path>,\n+        force: bool,\n+    ) -> Result<(), Indeterminate>;\n+    /// Take resolutions for paths inside the `#[derive(...)]` attribute with the given `ExpnId`\n+    /// back from resolver.\n+    fn take_derive_resolutions(\n+        &mut self,\n+        expn_id: ExpnId,\n+    ) -> Option<Vec<(Lrc<SyntaxExtension>, ast::Path)>>;\n     /// Path resolution logic for `#[cfg_accessible(path)]`.\n     fn cfg_accessible(&mut self, expn_id: ExpnId, path: &ast::Path) -> Result<bool, Indeterminate>;\n }"}, {"sha": "870b5c92d8983ec9683c9ecdf4ae0080bf71991a", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 117, "deletions": 222, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -1,24 +1,26 @@\n use crate::base::*;\n use crate::config::StripUnconfigured;\n use crate::configure;\n-use crate::hygiene::{ExpnData, ExpnKind, SyntaxContext};\n+use crate::hygiene::SyntaxContext;\n use crate::mbe::macro_rules::annotate_err_with_kind;\n use crate::module::{parse_external_mod, push_directory, Directory, DirectoryOwnership};\n use crate::placeholders::{placeholder, PlaceholderExpander};\n-use crate::proc_macro::collect_derives;\n \n+use rustc_ast as ast;\n use rustc_ast::mut_visit::*;\n use rustc_ast::ptr::P;\n use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n-use rustc_ast::{self as ast, AttrItem, AttrStyle, Block, LitKind, NodeId, PatKind, Path};\n-use rustc_ast::{ItemKind, MacArgs, MacCallStmt, MacStmtStyle, StmtKind, Unsafe};\n+use rustc_ast::{AttrItem, AttrStyle, Block, ItemKind, LitKind, MacArgs};\n+use rustc_ast::{MacCallStmt, MacStmtStyle, MetaItemKind, NestedMetaItem};\n+use rustc_ast::{NodeId, PatKind, Path, StmtKind, Unsafe};\n use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, is_builtin_attr, HasAttrs};\n use rustc_data_structures::map_in_place::MapInPlace;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n-use rustc_errors::{struct_span_err, Applicability, PResult};\n+use rustc_data_structures::sync::Lrc;\n+use rustc_errors::{Applicability, PResult};\n use rustc_feature::Features;\n use rustc_parse::parser::{AttemptLocalParseRecovery, ForceCollect, Parser};\n use rustc_parse::validate_attr;\n@@ -302,20 +304,11 @@ pub enum InvocationKind {\n         item: Annotatable,\n         // Required for resolving derive helper attributes.\n         derives: Vec<Path>,\n-        // We temporarily report errors for attribute macros placed after derives\n-        after_derive: bool,\n     },\n     Derive {\n         path: Path,\n         item: Annotatable,\n     },\n-    /// \"Invocation\" that contains all derives from an item,\n-    /// broken into multiple `Derive` invocations when expanded.\n-    /// FIXME: Find a way to remove it.\n-    DeriveContainer {\n-        derives: Vec<Path>,\n-        item: Annotatable,\n-    },\n }\n \n impl InvocationKind {\n@@ -328,7 +321,6 @@ impl InvocationKind {\n         match self {\n             InvocationKind::Attr { item: Annotatable::StructField(field), .. }\n             | InvocationKind::Derive { item: Annotatable::StructField(field), .. }\n-            | InvocationKind::DeriveContainer { item: Annotatable::StructField(field), .. }\n                 if field.ident.is_none() =>\n             {\n                 Some(field.vis.clone())\n@@ -344,7 +336,6 @@ impl Invocation {\n             InvocationKind::Bang { span, .. } => *span,\n             InvocationKind::Attr { attr, .. } => attr.span,\n             InvocationKind::Derive { path, .. } => path.span,\n-            InvocationKind::DeriveContainer { item, .. } => item.span(),\n         }\n     }\n }\n@@ -446,7 +437,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         let mut undetermined_invocations = Vec::new();\n         let (mut progress, mut force) = (false, !self.monotonic);\n         loop {\n-            let (invoc, res) = if let Some(invoc) = invocations.pop() {\n+            let (invoc, ext) = if let Some(invoc) = invocations.pop() {\n                 invoc\n             } else {\n                 self.resolve_imports();\n@@ -464,8 +455,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 continue;\n             };\n \n-            let res = match res {\n-                Some(res) => res,\n+            let ext = match ext {\n+                Some(ext) => ext,\n                 None => {\n                     let eager_expansion_root = if self.monotonic {\n                         invoc.expansion_data.id\n@@ -477,7 +468,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         eager_expansion_root,\n                         force,\n                     ) {\n-                        Ok(res) => res,\n+                        Ok(ext) => ext,\n                         Err(Indeterminate) => {\n                             // Cannot resolve, will retry this invocation later.\n                             undetermined_invocations.push((invoc, None));\n@@ -491,86 +482,78 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             self.cx.current_expansion = invoc.expansion_data.clone();\n             self.cx.force_mode = force;\n \n-            // FIXME(jseyfried): Refactor out the following logic\n             let fragment_kind = invoc.fragment_kind;\n-            let (expanded_fragment, new_invocations) = match res {\n-                InvocationRes::Single(ext) => match self.expand_invoc(invoc, &ext.kind) {\n-                    ExpandResult::Ready(fragment) => self.collect_invocations(fragment, &[]),\n-                    ExpandResult::Retry(invoc) => {\n-                        if force {\n-                            self.cx.span_bug(\n-                                invoc.span(),\n-                                \"expansion entered force mode but is still stuck\",\n-                            );\n-                        } else {\n-                            // Cannot expand, will retry this invocation later.\n-                            undetermined_invocations\n-                                .push((invoc, Some(InvocationRes::Single(ext))));\n-                            continue;\n-                        }\n-                    }\n-                },\n-                InvocationRes::DeriveContainer(_exts) => {\n-                    // FIXME: Consider using the derive resolutions (`_exts`) immediately,\n-                    // instead of enqueuing the derives to be resolved again later.\n-                    let (derives, mut item) = match invoc.kind {\n-                        InvocationKind::DeriveContainer { derives, item } => (derives, item),\n-                        _ => unreachable!(),\n-                    };\n-                    let (item, derive_placeholders) = if !item.derive_allowed() {\n-                        self.error_derive_forbidden_on_non_adt(&derives, &item);\n-                        item.visit_attrs(|attrs| attrs.retain(|a| !a.has_name(sym::derive)));\n-                        (item, Vec::new())\n-                    } else {\n-                        let mut visitor = StripUnconfigured {\n-                            sess: self.cx.sess,\n-                            features: self.cx.ecfg.features,\n-                            modified: false,\n-                        };\n-                        let mut item = visitor.fully_configure(item);\n-                        item.visit_attrs(|attrs| attrs.retain(|a| !a.has_name(sym::derive)));\n-                        if visitor.modified && !derives.is_empty() {\n-                            // Erase the tokens if cfg-stripping modified the item\n-                            // This will cause us to synthesize fake tokens\n-                            // when `nt_to_tokenstream` is called on this item.\n-                            match &mut item {\n-                                Annotatable::Item(item) => item.tokens = None,\n-                                Annotatable::Stmt(stmt) => {\n-                                    if let StmtKind::Item(item) = &mut stmt.kind {\n-                                        item.tokens = None\n-                                    } else {\n-                                        panic!(\"Unexpected stmt {:?}\", stmt);\n-                                    }\n-                                }\n-                                _ => panic!(\"Unexpected annotatable {:?}\", item),\n+            let (expanded_fragment, new_invocations) = match self.expand_invoc(invoc, &ext.kind) {\n+                ExpandResult::Ready(fragment) => {\n+                    let derive_placeholders = self\n+                        .cx\n+                        .resolver\n+                        .take_derive_resolutions(expn_id)\n+                        .map(|derives| {\n+                            enum AnnotatableRef<'a> {\n+                                Item(&'a P<ast::Item>),\n+                                Stmt(&'a ast::Stmt),\n                             }\n-                        }\n+                            let item = match &fragment {\n+                                AstFragment::Items(items) => match &items[..] {\n+                                    [item] => AnnotatableRef::Item(item),\n+                                    _ => unreachable!(),\n+                                },\n+                                AstFragment::Stmts(stmts) => match &stmts[..] {\n+                                    [stmt] => AnnotatableRef::Stmt(stmt),\n+                                    _ => unreachable!(),\n+                                },\n+                                _ => unreachable!(),\n+                            };\n \n-                        invocations.reserve(derives.len());\n-                        let derive_placeholders = derives\n-                            .into_iter()\n-                            .map(|path| {\n-                                let expn_id = ExpnId::fresh(None);\n-                                invocations.push((\n-                                    Invocation {\n-                                        kind: InvocationKind::Derive { path, item: item.clone() },\n-                                        fragment_kind,\n-                                        expansion_data: ExpansionData {\n-                                            id: expn_id,\n-                                            ..self.cx.current_expansion.clone()\n+                            invocations.reserve(derives.len());\n+                            derives\n+                                .into_iter()\n+                                .map(|(_exts, path)| {\n+                                    // FIXME: Consider using the derive resolutions (`_exts`)\n+                                    // instead of enqueuing the derives to be resolved again later.\n+                                    let expn_id = ExpnId::fresh(None);\n+                                    invocations.push((\n+                                        Invocation {\n+                                            kind: InvocationKind::Derive {\n+                                                path,\n+                                                item: match item {\n+                                                    AnnotatableRef::Item(item) => {\n+                                                        Annotatable::Item(item.clone())\n+                                                    }\n+                                                    AnnotatableRef::Stmt(stmt) => {\n+                                                        Annotatable::Stmt(P(stmt.clone()))\n+                                                    }\n+                                                },\n+                                            },\n+                                            fragment_kind,\n+                                            expansion_data: ExpansionData {\n+                                                id: expn_id,\n+                                                ..self.cx.current_expansion.clone()\n+                                            },\n                                         },\n-                                    },\n-                                    None,\n-                                ));\n-                                NodeId::placeholder_from_expn_id(expn_id)\n-                            })\n-                            .collect::<Vec<_>>();\n-                        (item, derive_placeholders)\n-                    };\n+                                        None,\n+                                    ));\n+                                    NodeId::placeholder_from_expn_id(expn_id)\n+                                })\n+                                .collect::<Vec<_>>()\n+                        })\n+                        .unwrap_or_default();\n \n-                    let fragment = fragment_kind.expect_from_annotatables(::std::iter::once(item));\n                     self.collect_invocations(fragment, &derive_placeholders)\n                 }\n+                ExpandResult::Retry(invoc) => {\n+                    if force {\n+                        self.cx.span_bug(\n+                            invoc.span(),\n+                            \"expansion entered force mode but is still stuck\",\n+                        );\n+                    } else {\n+                        // Cannot expand, will retry this invocation later.\n+                        undetermined_invocations.push((invoc, Some(ext)));\n+                        continue;\n+                    }\n+                }\n             };\n \n             progress = true;\n@@ -596,29 +579,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         fragment_with_placeholders\n     }\n \n-    fn error_derive_forbidden_on_non_adt(&self, derives: &[Path], item: &Annotatable) {\n-        let attr = self.cx.sess.find_by_name(item.attrs(), sym::derive);\n-        let span = attr.map_or(item.span(), |attr| attr.span);\n-        let mut err = struct_span_err!(\n-            self.cx.sess,\n-            span,\n-            E0774,\n-            \"`derive` may only be applied to structs, enums and unions\",\n-        );\n-        if let Some(ast::Attribute { style: ast::AttrStyle::Inner, .. }) = attr {\n-            let trait_list = derives.iter().map(|t| pprust::path_to_string(t)).collect::<Vec<_>>();\n-            let suggestion = format!(\"#[derive({})]\", trait_list.join(\", \"));\n-            err.span_suggestion(\n-                span,\n-                \"try an outer attribute\",\n-                suggestion,\n-                // We don't \ud835\udc58\ud835\udc5b\ud835\udc5c\ud835\udc64 that the following item is an ADT\n-                Applicability::MaybeIncorrect,\n-            );\n-        }\n-        err.emit();\n-    }\n-\n     fn resolve_imports(&mut self) {\n         if self.monotonic {\n             self.cx.resolver.resolve_imports();\n@@ -633,7 +593,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         &mut self,\n         mut fragment: AstFragment,\n         extra_placeholders: &[NodeId],\n-    ) -> (AstFragment, Vec<(Invocation, Option<InvocationRes>)>) {\n+    ) -> (AstFragment, Vec<(Invocation, Option<Lrc<SyntaxExtension>>)>) {\n         // Resolve `$crate`s in the fragment for pretty-printing.\n         self.cx.resolver.resolve_dollar_crates();\n \n@@ -733,7 +693,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 }\n                 _ => unreachable!(),\n             },\n-            InvocationKind::Attr { attr, mut item, derives, after_derive } => match ext {\n+            InvocationKind::Attr { attr, mut item, derives } => match ext {\n                 SyntaxExtensionKind::Attr(expander) => {\n                     self.gate_proc_macro_input(&item);\n                     self.gate_proc_macro_attr_item(span, &item);\n@@ -764,12 +724,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                                 ExpandResult::Retry(item) => {\n                                     // Reassemble the original invocation for retrying.\n                                     return ExpandResult::Retry(Invocation {\n-                                        kind: InvocationKind::Attr {\n-                                            attr,\n-                                            item,\n-                                            derives,\n-                                            after_derive,\n-                                        },\n+                                        kind: InvocationKind::Attr { attr, item, derives },\n                                         ..invoc\n                                     });\n                                 }\n@@ -813,7 +768,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 }\n                 _ => unreachable!(),\n             },\n-            InvocationKind::DeriveContainer { .. } => unreachable!(),\n         })\n     }\n \n@@ -1011,29 +965,13 @@ pub fn ensure_complete_parse<'a>(\n struct InvocationCollector<'a, 'b> {\n     cx: &'a mut ExtCtxt<'b>,\n     cfg: StripUnconfigured<'a>,\n-    invocations: Vec<(Invocation, Option<InvocationRes>)>,\n+    invocations: Vec<(Invocation, Option<Lrc<SyntaxExtension>>)>,\n     monotonic: bool,\n }\n \n impl<'a, 'b> InvocationCollector<'a, 'b> {\n     fn collect(&mut self, fragment_kind: AstFragmentKind, kind: InvocationKind) -> AstFragment {\n-        // Expansion data for all the collected invocations is set upon their resolution,\n-        // with exception of the derive container case which is not resolved and can get\n-        // its expansion data immediately.\n-        let expn_data = match &kind {\n-            InvocationKind::DeriveContainer { item, .. } => {\n-                let mut expn_data = ExpnData::default(\n-                    ExpnKind::Macro(MacroKind::Attr, sym::derive),\n-                    item.span(),\n-                    self.cx.sess.parse_sess.edition,\n-                    None,\n-                );\n-                expn_data.parent = self.cx.current_expansion.id;\n-                Some(expn_data)\n-            }\n-            _ => None,\n-        };\n-        let expn_id = ExpnId::fresh(expn_data);\n+        let expn_id = ExpnId::fresh(None);\n         let vis = kind.placeholder_visibility();\n         self.invocations.push((\n             Invocation {\n@@ -1061,64 +999,44 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n \n     fn collect_attr(\n         &mut self,\n-        (attr, derives, after_derive): (Option<ast::Attribute>, Vec<Path>, bool),\n+        (attr, derives): (ast::Attribute, Vec<Path>),\n         item: Annotatable,\n         kind: AstFragmentKind,\n     ) -> AstFragment {\n-        self.collect(\n-            kind,\n-            match attr {\n-                Some(attr) => InvocationKind::Attr { attr, item, derives, after_derive },\n-                None => InvocationKind::DeriveContainer { derives, item },\n-            },\n-        )\n-    }\n-\n-    fn find_attr_invoc(\n-        &self,\n-        attrs: &mut Vec<ast::Attribute>,\n-        after_derive: &mut bool,\n-    ) -> Option<ast::Attribute> {\n-        attrs\n-            .iter()\n-            .position(|a| {\n-                if a.has_name(sym::derive) {\n-                    *after_derive = true;\n-                }\n-                !self.cx.sess.is_attr_known(a) && !is_builtin_attr(a)\n-            })\n-            .map(|i| attrs.remove(i))\n-    }\n-\n-    /// If `item` is an attr invocation, remove and return the macro attribute and derive traits.\n-    fn take_first_attr(\n-        &mut self,\n-        item: &mut impl HasAttrs,\n-    ) -> Option<(Option<ast::Attribute>, Vec<Path>, /* after_derive */ bool)> {\n-        let (mut attr, mut traits, mut after_derive) = (None, Vec::new(), false);\n-\n-        item.visit_attrs(|mut attrs| {\n-            attr = self.find_attr_invoc(&mut attrs, &mut after_derive);\n-            traits = collect_derives(&mut self.cx, &mut attrs);\n-        });\n-\n-        if attr.is_some() || !traits.is_empty() { Some((attr, traits, after_derive)) } else { None }\n+        self.collect(kind, InvocationKind::Attr { attr, item, derives })\n     }\n \n-    /// Alternative to `take_first_attr()` that ignores `#[derive]` so invocations fallthrough\n-    /// to the unused-attributes lint (making it an error on statements and expressions\n-    /// is a breaking change)\n-    fn take_first_attr_no_derive(\n-        &mut self,\n-        nonitem: &mut impl HasAttrs,\n-    ) -> Option<(Option<ast::Attribute>, Vec<Path>, /* after_derive */ bool)> {\n-        let (mut attr, mut after_derive) = (None, false);\n-\n-        nonitem.visit_attrs(|mut attrs| {\n-            attr = self.find_attr_invoc(&mut attrs, &mut after_derive);\n+    /// If `item` is an attribute invocation, remove the attribute and return it together with\n+    /// derives following it. We have to collect the derives in order to resolve legacy derive\n+    /// helpers (helpers written before derives that introduce them).\n+    fn take_first_attr(&mut self, item: &mut impl HasAttrs) -> Option<(ast::Attribute, Vec<Path>)> {\n+        let mut attr = None;\n+\n+        item.visit_attrs(|attrs| {\n+            attr = attrs\n+                .iter()\n+                .position(|a| !self.cx.sess.is_attr_known(a) && !is_builtin_attr(a))\n+                .map(|attr_pos| {\n+                    let attr = attrs.remove(attr_pos);\n+                    let following_derives = attrs[attr_pos..]\n+                        .iter()\n+                        .filter(|a| a.has_name(sym::derive))\n+                        .flat_map(|a| a.meta_item_list().unwrap_or_default())\n+                        .filter_map(|nested_meta| match nested_meta {\n+                            NestedMetaItem::MetaItem(ast::MetaItem {\n+                                kind: MetaItemKind::Word,\n+                                path,\n+                                ..\n+                            }) => Some(path),\n+                            _ => None,\n+                        })\n+                        .collect();\n+\n+                    (attr, following_derives)\n+                })\n         });\n \n-        attr.map(|attr| (Some(attr), Vec::new(), after_derive))\n+        attr\n     }\n \n     fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n@@ -1132,17 +1050,6 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         for attr in attrs.iter() {\n             rustc_ast_passes::feature_gate::check_attribute(attr, self.cx.sess, features);\n             validate_attr::check_meta(&self.cx.sess.parse_sess, attr);\n-\n-            // macros are expanded before any lint passes so this warning has to be hardcoded\n-            if attr.has_name(sym::derive) {\n-                self.cx\n-                    .parse_sess()\n-                    .span_diagnostic\n-                    .struct_span_warn(attr.span, \"`#[derive]` does nothing on macro invocations\")\n-                    .note(\"this may become a hard error in a future release\")\n-                    .emit();\n-            }\n-\n             if attr.doc_str().is_some() {\n                 self.cx.sess.parse_sess.buffer_lint_with_diagnostic(\n                     &UNUSED_DOC_COMMENTS,\n@@ -1162,12 +1069,10 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         visit_clobber(expr.deref_mut(), |mut expr| {\n             self.cfg.configure_expr_kind(&mut expr.kind);\n \n-            if let Some(attr) = self.take_first_attr_no_derive(&mut expr) {\n+            if let Some(attr) = self.take_first_attr(&mut expr) {\n                 // Collect the invoc regardless of whether or not attributes are permitted here\n                 // expansion will eat the attribute so it won't error later.\n-                if let Some(attr) = attr.0.as_ref() {\n-                    self.cfg.maybe_emit_expr_attr_err(attr)\n-                }\n+                self.cfg.maybe_emit_expr_attr_err(&attr.0);\n \n                 // AstFragmentKind::Expr requires the macro to emit an expression.\n                 return self\n@@ -1263,10 +1168,8 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         expr.filter_map(|mut expr| {\n             self.cfg.configure_expr_kind(&mut expr.kind);\n \n-            if let Some(attr) = self.take_first_attr_no_derive(&mut expr) {\n-                if let Some(attr) = attr.0.as_ref() {\n-                    self.cfg.maybe_emit_expr_attr_err(attr)\n-                }\n+            if let Some(attr) = self.take_first_attr(&mut expr) {\n+                self.cfg.maybe_emit_expr_attr_err(&attr.0);\n \n                 return self\n                     .collect_attr(attr, Annotatable::Expr(P(expr)), AstFragmentKind::OptExpr)\n@@ -1308,15 +1211,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n \n         // we'll expand attributes on expressions separately\n         if !stmt.is_expr() {\n-            let attr = if stmt.is_item() {\n-                self.take_first_attr(&mut stmt)\n-            } else {\n-                // Ignore derives on non-item statements for backwards compatibility.\n-                // This will result in a unused attribute warning\n-                self.take_first_attr_no_derive(&mut stmt)\n-            };\n-\n-            if let Some(attr) = attr {\n+            if let Some(attr) = self.take_first_attr(&mut stmt) {\n                 return self\n                     .collect_attr(attr, Annotatable::Stmt(P(stmt)), AstFragmentKind::Stmts)\n                     .make_stmts();"}, {"sha": "8cbaa7c945a817bb15ef536f1ebd886a72851db9", "filename": "compiler/rustc_expand/src/proc_macro.rs", "status": "modified", "additions": 2, "deletions": 92, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -1,16 +1,14 @@\n use crate::base::{self, *};\n use crate::proc_macro_server;\n \n+use rustc_ast as ast;\n use rustc_ast::ptr::P;\n use rustc_ast::token;\n use rustc_ast::tokenstream::{CanSynthesizeMissingTokens, TokenStream, TokenTree};\n-use rustc_ast::{self as ast, *};\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{struct_span_err, Applicability, ErrorReported};\n-use rustc_lexer::is_ident;\n+use rustc_errors::ErrorReported;\n use rustc_parse::nt_to_tokenstream;\n use rustc_parse::parser::ForceCollect;\n-use rustc_span::symbol::sym;\n use rustc_span::{Span, DUMMY_SP};\n \n const EXEC_STRATEGY: pm::bridge::server::SameThread = pm::bridge::server::SameThread;\n@@ -142,91 +140,3 @@ impl MultiItemModifier for ProcMacroDerive {\n         ExpandResult::Ready(items)\n     }\n }\n-\n-crate fn collect_derives(cx: &mut ExtCtxt<'_>, attrs: &mut Vec<ast::Attribute>) -> Vec<ast::Path> {\n-    let mut result = Vec::new();\n-    attrs.retain(|attr| {\n-        if !attr.has_name(sym::derive) {\n-            return true;\n-        }\n-\n-        // 1) First let's ensure that it's a meta item.\n-        let nmis = match attr.meta_item_list() {\n-            None => {\n-                cx.struct_span_err(attr.span, \"malformed `derive` attribute input\")\n-                    .span_suggestion(\n-                        attr.span,\n-                        \"missing traits to be derived\",\n-                        \"#[derive(Trait1, Trait2, ...)]\".to_owned(),\n-                        Applicability::HasPlaceholders,\n-                    )\n-                    .emit();\n-                return false;\n-            }\n-            Some(x) => x,\n-        };\n-\n-        let mut error_reported_filter_map = false;\n-        let mut error_reported_map = false;\n-        let traits = nmis\n-            .into_iter()\n-            // 2) Moreover, let's ensure we have a path and not `#[derive(\"foo\")]`.\n-            .filter_map(|nmi| match nmi {\n-                NestedMetaItem::Literal(lit) => {\n-                    error_reported_filter_map = true;\n-                    let mut err = struct_span_err!(\n-                        cx.sess,\n-                        lit.span,\n-                        E0777,\n-                        \"expected path to a trait, found literal\",\n-                    );\n-                    let token = lit.token.to_string();\n-                    if token.starts_with('\"')\n-                        && token.len() > 2\n-                        && is_ident(&token[1..token.len() - 1])\n-                    {\n-                        err.help(&format!(\"try using `#[derive({})]`\", &token[1..token.len() - 1]));\n-                    } else {\n-                        err.help(\"for example, write `#[derive(Debug)]` for `Debug`\");\n-                    }\n-                    err.emit();\n-                    None\n-                }\n-                NestedMetaItem::MetaItem(mi) => Some(mi),\n-            })\n-            // 3) Finally, we only accept `#[derive($path_0, $path_1, ..)]`\n-            // but not e.g. `#[derive($path_0 = \"value\", $path_1(abc))]`.\n-            // In this case we can still at least determine that the user\n-            // wanted this trait to be derived, so let's keep it.\n-            .map(|mi| {\n-                let mut traits_dont_accept = |title, action| {\n-                    error_reported_map = true;\n-                    let sp = mi.span.with_lo(mi.path.span.hi());\n-                    cx.struct_span_err(sp, title)\n-                        .span_suggestion(\n-                            sp,\n-                            action,\n-                            String::new(),\n-                            Applicability::MachineApplicable,\n-                        )\n-                        .emit();\n-                };\n-                match &mi.kind {\n-                    MetaItemKind::List(..) => traits_dont_accept(\n-                        \"traits in `#[derive(...)]` don't accept arguments\",\n-                        \"remove the arguments\",\n-                    ),\n-                    MetaItemKind::NameValue(..) => traits_dont_accept(\n-                        \"traits in `#[derive(...)]` don't accept values\",\n-                        \"remove the value\",\n-                    ),\n-                    MetaItemKind::Word => {}\n-                }\n-                mi.path\n-            });\n-\n-        result.extend(traits);\n-        !error_reported_filter_map && !error_reported_map\n-    });\n-    result\n-}"}, {"sha": "2d0009c225c59e717b22154c6b2b2953b7057bd3", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -634,6 +634,10 @@ declare_features! (\n \n     /// Lessens the requirements for structs to implement `Unsize`.\n     (active, relaxed_struct_unsize, \"1.51.0\", Some(1), None),\n+\n+    /// Allows macro attributes to observe output of `#[derive]`.\n+    (active, macro_attributes_in_derive_output, \"1.51.0\", Some(81119), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------"}, {"sha": "ac50703b5444e91f494dd89df7009357c3007357", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -188,7 +188,6 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ungated!(reexport_test_harness_main, Normal, template!(NameValueStr: \"name\")),\n \n     // Macros:\n-    ungated!(derive, Normal, template!(List: \"Trait1, Trait2, ...\")),\n     ungated!(automatically_derived, Normal, template!(Word)),\n     // FIXME(#14407)\n     ungated!(macro_use, Normal, template!(Word, List: \"name1, name2, ...\")),"}, {"sha": "254220839aa472a57c122cc44f15d2fb82959a34", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -636,6 +636,9 @@ pub trait LintContext: Sized {\n                     db.span_label(span, \"ABI should be specified here\");\n                     db.help(&format!(\"the default ABI is {}\", default_abi.name()));\n                 }\n+                BuiltinLintDiagnostics::LegacyDeriveHelpers(span) => {\n+                    db.span_label(span, \"the attribute is introduced here\");\n+                }\n             }\n             // Rewrap `db`, and pass control to the user.\n             decorate(LintDiagnosticBuilder::new(db));"}, {"sha": "f0a5ea150b71941e1619d509ae32978771147a50", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -1,12 +1,11 @@\n // ignore-tidy-filelength\n+\n //! Some lints that are built in to the compiler.\n //!\n //! These are the built-in lints that are emitted direct in the main\n //! compiler code, rather than using their own custom pass. Those\n //! lints are all available in `rustc_lint::builtin`.\n \n-// ignore-tidy-filelength\n-\n use crate::{declare_lint, declare_lint_pass};\n use rustc_span::edition::Edition;\n use rustc_span::symbol::sym;\n@@ -2922,6 +2921,52 @@ declare_lint! {\n     };\n }\n \n+declare_lint! {\n+    /// The `legacy_derive_helpers` lint detects derive helper attributes\n+    /// that are used before they are introduced.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,ignore (needs extern crate)\n+    /// #[serde(rename_all = \"camelCase\")]\n+    /// #[derive(Deserialize)]\n+    /// struct S { /* fields */ }\n+    /// ```\n+    ///\n+    /// produces:\n+    ///\n+    /// ```text\n+    /// warning: derive helper attribute is used before it is introduced\n+    ///   --> $DIR/legacy-derive-helpers.rs:1:3\n+    ///    |\n+    ///  1 | #[serde(rename_all = \"camelCase\")]\n+    ///    |   ^^^^^\n+    /// ...\n+    ///  2 | #[derive(Deserialize)]\n+    ///    |          ----------- the attribute is introduced here\n+    /// ```\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Attributes like this work for historical reasons, but attribute expansion works in\n+    /// left-to-right order in general, so, to resolve `#[serde]`, compiler has to try to \"look\n+    /// into the future\" at not yet expanded part of the item , but such attempts are not always\n+    /// reliable.\n+    ///\n+    /// To fix the warning place the helper attribute after its corresponding derive.\n+    /// ```rust,ignore (needs extern crate)\n+    /// #[derive(Deserialize)]\n+    /// #[serde(rename_all = \"camelCase\")]\n+    /// struct S { /* fields */ }\n+    /// ```\n+    pub LEGACY_DERIVE_HELPERS,\n+    Warn,\n+    \"detects derive helper attributes that are used before they are introduced\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #79202 <https://github.com/rust-lang/rust/issues/79202>\",\n+    };\n+}\n+\n declare_lint_pass! {\n     /// Does nothing as a lint pass, but registers some `Lint`s\n     /// that are used by other parts of the compiler.\n@@ -3012,6 +3057,7 @@ declare_lint_pass! {\n         MISSING_ABI,\n         SEMICOLON_IN_EXPRESSIONS_FROM_MACROS,\n         DISJOINT_CAPTURE_DROP_REORDER,\n+        LEGACY_DERIVE_HELPERS,\n     ]\n }\n "}, {"sha": "594e2cbd3aed9c8592f1ad6ce9c200b647f8c9cd", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -256,6 +256,7 @@ pub enum BuiltinLintDiagnostics {\n     MissingAbi(Span, Abi),\n     UnusedDocComment(Span),\n     PatternsInFnsWithoutBody(Span, Ident),\n+    LegacyDeriveHelpers(Span),\n }\n \n /// Lints that are buffered up early on in the `Session` before the"}, {"sha": "523eb9dba35fd42339038f75f7bd0758621cf456", "filename": "compiler/rustc_parse/src/parser/attr.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -306,13 +306,11 @@ impl<'a> Parser<'a> {\n }\n \n pub fn maybe_needs_tokens(attrs: &[ast::Attribute]) -> bool {\n-    // One of the attributes may either itself be a macro, or apply derive macros (`derive`),\n+    // One of the attributes may either itself be a macro,\n     // or expand to macro attributes (`cfg_attr`).\n     attrs.iter().any(|attr| {\n         attr.ident().map_or(true, |ident| {\n-            ident.name == sym::derive\n-                || ident.name == sym::cfg_attr\n-                || !rustc_feature::is_builtin_attr_name(ident.name)\n+            ident.name == sym::cfg_attr || !rustc_feature::is_builtin_attr_name(ident.name)\n         })\n     })\n }"}, {"sha": "819fabdd1f1779ca64aabbdaa961a7b1d2337dc0", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -967,6 +967,8 @@ pub struct Resolver<'a> {\n     output_macro_rules_scopes: FxHashMap<ExpnId, MacroRulesScopeRef<'a>>,\n     /// Helper attributes that are in scope for the given expansion.\n     helper_attrs: FxHashMap<ExpnId, Vec<Ident>>,\n+    /// Resolutions for paths inside the `#[derive(...)]` attribute with the given `ExpnId`.\n+    derive_resolutions: FxHashMap<ExpnId, Vec<(Lrc<SyntaxExtension>, ast::Path)>>,\n \n     /// Avoid duplicated errors for \"name already defined\".\n     name_already_seen: FxHashMap<Symbol, Span>,\n@@ -1295,6 +1297,7 @@ impl<'a> Resolver<'a> {\n             invocation_parent_scopes: Default::default(),\n             output_macro_rules_scopes: Default::default(),\n             helper_attrs: Default::default(),\n+            derive_resolutions: Default::default(),\n             local_macro_def_scopes: FxHashMap::default(),\n             name_already_seen: FxHashMap::default(),\n             potentially_unused_imports: Vec::new(),"}, {"sha": "f7010ca94bd2c5b9b1c7e2c7f87269d8253c5e66", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 110, "deletions": 65, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -14,8 +14,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::ptr_key::PtrKey;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::struct_span_err;\n-use rustc_expand::base::{Indeterminate, InvocationRes, ResolverExpand};\n-use rustc_expand::base::{SyntaxExtension, SyntaxExtensionKind};\n+use rustc_expand::base::{Indeterminate, ResolverExpand, SyntaxExtension, SyntaxExtensionKind};\n use rustc_expand::compile_declarative_macro;\n use rustc_expand::expand::{AstFragment, Invocation, InvocationKind};\n use rustc_feature::is_builtin_attr_name;\n@@ -24,7 +23,8 @@ use rustc_hir::def_id;\n use rustc_hir::PrimTy;\n use rustc_middle::middle::stability;\n use rustc_middle::ty;\n-use rustc_session::lint::builtin::{SOFT_UNSTABLE, UNUSED_MACROS};\n+use rustc_session::lint::builtin::{LEGACY_DERIVE_HELPERS, SOFT_UNSTABLE, UNUSED_MACROS};\n+use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_session::parse::feature_err;\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n@@ -227,7 +227,7 @@ impl<'a> ResolverExpand for Resolver<'a> {\n         invoc: &Invocation,\n         eager_expansion_root: ExpnId,\n         force: bool,\n-    ) -> Result<InvocationRes, Indeterminate> {\n+    ) -> Result<Lrc<SyntaxExtension>, Indeterminate> {\n         let invoc_id = invoc.expansion_data.id;\n         let parent_scope = match self.invocation_parent_scopes.get(&invoc_id) {\n             Some(parent_scope) => *parent_scope,\n@@ -244,65 +244,15 @@ impl<'a> ResolverExpand for Resolver<'a> {\n             }\n         };\n \n-        let (path, kind, inner_attr, derives, after_derive) = match invoc.kind {\n-            InvocationKind::Attr { ref attr, ref derives, after_derive, .. } => (\n+        let (path, kind, inner_attr, derives) = match invoc.kind {\n+            InvocationKind::Attr { ref attr, ref derives, .. } => (\n                 &attr.get_normal_item().path,\n                 MacroKind::Attr,\n                 attr.style == ast::AttrStyle::Inner,\n                 self.arenas.alloc_ast_paths(derives),\n-                after_derive,\n             ),\n-            InvocationKind::Bang { ref mac, .. } => {\n-                (&mac.path, MacroKind::Bang, false, &[][..], false)\n-            }\n-            InvocationKind::Derive { ref path, .. } => {\n-                (path, MacroKind::Derive, false, &[][..], false)\n-            }\n-            InvocationKind::DeriveContainer { ref derives, .. } => {\n-                // Block expansion of the container until we resolve all derives in it.\n-                // This is required for two reasons:\n-                // - Derive helper attributes are in scope for the item to which the `#[derive]`\n-                //   is applied, so they have to be produced by the container's expansion rather\n-                //   than by individual derives.\n-                // - Derives in the container need to know whether one of them is a built-in `Copy`.\n-                // FIXME: Try to avoid repeated resolutions for derives here and in expansion.\n-                let mut exts = Vec::new();\n-                let mut helper_attrs = Vec::new();\n-                for path in derives {\n-                    exts.push(\n-                        match self.resolve_macro_path(\n-                            path,\n-                            Some(MacroKind::Derive),\n-                            &parent_scope,\n-                            true,\n-                            force,\n-                        ) {\n-                            Ok((Some(ext), _)) => {\n-                                let span = path\n-                                    .segments\n-                                    .last()\n-                                    .unwrap()\n-                                    .ident\n-                                    .span\n-                                    .normalize_to_macros_2_0();\n-                                helper_attrs.extend(\n-                                    ext.helper_attrs.iter().map(|name| Ident::new(*name, span)),\n-                                );\n-                                if ext.builtin_name == Some(sym::Copy) {\n-                                    self.containers_deriving_copy.insert(invoc_id);\n-                                }\n-                                ext\n-                            }\n-                            Ok(_) | Err(Determinacy::Determined) => {\n-                                self.dummy_ext(MacroKind::Derive)\n-                            }\n-                            Err(Determinacy::Undetermined) => return Err(Indeterminate),\n-                        },\n-                    )\n-                }\n-                self.helper_attrs.insert(invoc_id, helper_attrs);\n-                return Ok(InvocationRes::DeriveContainer(exts));\n-            }\n+            InvocationKind::Bang { ref mac, .. } => (&mac.path, MacroKind::Bang, false, &[][..]),\n+            InvocationKind::Derive { ref path, .. } => (path, MacroKind::Derive, false, &[][..]),\n         };\n \n         // Derives are not included when `invocations` are collected, so we have to add them here.\n@@ -328,14 +278,41 @@ impl<'a> ResolverExpand for Resolver<'a> {\n         ));\n \n         if let Res::Def(_, _) = res {\n-            if after_derive {\n-                self.session.span_err(span, \"macro attributes must be placed before `#[derive]`\");\n-            }\n             let normal_module_def_id = self.macro_def_scope(invoc_id).nearest_parent_mod;\n             self.definitions.add_parent_module_of_macro_def(invoc_id, normal_module_def_id);\n+\n+            // Gate macro attributes in `#[derive]` output.\n+            if !self.session.features_untracked().macro_attributes_in_derive_output\n+                && kind == MacroKind::Attr\n+                && ext.builtin_name != Some(sym::derive)\n+            {\n+                let mut expn_id = parent_scope.expansion;\n+                loop {\n+                    // Helper attr table is a quick way to determine whether the attr is `derive`.\n+                    if self.helper_attrs.contains_key(&expn_id) {\n+                        feature_err(\n+                            &self.session.parse_sess,\n+                            sym::macro_attributes_in_derive_output,\n+                            path.span,\n+                            \"macro attributes in `#[derive]` output are unstable\",\n+                        )\n+                        .emit();\n+                        break;\n+                    } else {\n+                        let expn_data = expn_id.expn_data();\n+                        match expn_data.kind {\n+                            ExpnKind::Root\n+                            | ExpnKind::Macro(MacroKind::Bang | MacroKind::Derive, _) => {\n+                                break;\n+                            }\n+                            _ => expn_id = expn_data.parent,\n+                        }\n+                    }\n+                }\n+            }\n         }\n \n-        Ok(InvocationRes::Single(ext))\n+        Ok(ext)\n     }\n \n     fn check_unused_macros(&mut self) {\n@@ -344,7 +321,7 @@ impl<'a> ResolverExpand for Resolver<'a> {\n         }\n     }\n \n-    fn lint_node_id(&mut self, expn_id: ExpnId) -> NodeId {\n+    fn lint_node_id(&self, expn_id: ExpnId) -> NodeId {\n         // FIXME - make this more precise. This currently returns the NodeId of the\n         // nearest closing item - we should try to return the closest parent of the ExpnId\n         self.invocation_parents\n@@ -356,6 +333,63 @@ impl<'a> ResolverExpand for Resolver<'a> {\n         self.containers_deriving_copy.contains(&expn_id)\n     }\n \n+    fn resolve_derives(\n+        &mut self,\n+        expn_id: ExpnId,\n+        derives: Vec<ast::Path>,\n+        force: bool,\n+    ) -> Result<(), Indeterminate> {\n+        // Block expansion of the container until we resolve all derives in it.\n+        // This is required for two reasons:\n+        // - Derive helper attributes are in scope for the item to which the `#[derive]`\n+        //   is applied, so they have to be produced by the container's expansion rather\n+        //   than by individual derives.\n+        // - Derives in the container need to know whether one of them is a built-in `Copy`.\n+        // FIXME: Try to cache intermediate results to avoid resolving same derives multiple times.\n+        let parent_scope = self.invocation_parent_scopes[&expn_id];\n+        let mut exts = Vec::new();\n+        let mut helper_attrs = Vec::new();\n+        let mut has_derive_copy = false;\n+        for path in derives {\n+            exts.push((\n+                match self.resolve_macro_path(\n+                    &path,\n+                    Some(MacroKind::Derive),\n+                    &parent_scope,\n+                    true,\n+                    force,\n+                ) {\n+                    Ok((Some(ext), _)) => {\n+                        let span =\n+                            path.segments.last().unwrap().ident.span.normalize_to_macros_2_0();\n+                        helper_attrs\n+                            .extend(ext.helper_attrs.iter().map(|name| Ident::new(*name, span)));\n+                        has_derive_copy |= ext.builtin_name == Some(sym::Copy);\n+                        ext\n+                    }\n+                    Ok(_) | Err(Determinacy::Determined) => self.dummy_ext(MacroKind::Derive),\n+                    Err(Determinacy::Undetermined) => return Err(Indeterminate),\n+                },\n+                path,\n+            ))\n+        }\n+        self.derive_resolutions.insert(expn_id, exts);\n+        self.helper_attrs.insert(expn_id, helper_attrs);\n+        // Mark this derive as having `Copy` either if it has `Copy` itself or if its parent derive\n+        // has `Copy`, to support cases like `#[derive(Clone, Copy)] #[derive(Debug)]`.\n+        if has_derive_copy || self.has_derive_copy(parent_scope.expansion) {\n+            self.containers_deriving_copy.insert(expn_id);\n+        }\n+        Ok(())\n+    }\n+\n+    fn take_derive_resolutions(\n+        &mut self,\n+        expn_id: ExpnId,\n+    ) -> Option<Vec<(Lrc<SyntaxExtension>, ast::Path)>> {\n+        self.derive_resolutions.remove(&expn_id)\n+    }\n+\n     // The function that implements the resolution logic of `#[cfg_accessible(path)]`.\n     // Returns true if the path can certainly be resolved in one of three namespaces,\n     // returns false if the path certainly cannot be resolved in any of the three namespaces.\n@@ -818,6 +852,8 @@ impl<'a> Resolver<'a> {\n                                 let is_builtin = |res| {\n                                     matches!(res, Res::NonMacroAttr(NonMacroAttrKind::Builtin(..)))\n                                 };\n+                                let derive_helper =\n+                                    Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper);\n                                 let derive_helper_compat =\n                                     Res::NonMacroAttr(NonMacroAttrKind::DeriveHelperCompat);\n \n@@ -826,7 +862,7 @@ impl<'a> Resolver<'a> {\n                                 } else if is_builtin(innermost_res) || is_builtin(res) {\n                                     Some(AmbiguityKind::BuiltinAttr)\n                                 } else if innermost_res == derive_helper_compat\n-                                    || res == derive_helper_compat\n+                                    || res == derive_helper_compat && innermost_res != derive_helper\n                                 {\n                                     Some(AmbiguityKind::DeriveHelper)\n                                 } else if innermost_flags.contains(Flags::MACRO_RULES)\n@@ -992,6 +1028,15 @@ impl<'a> Resolver<'a> {\n                     let res = binding.res();\n                     let seg = Segment::from_ident(ident);\n                     check_consistency(self, &[seg], ident.span, kind, initial_res, res);\n+                    if res == Res::NonMacroAttr(NonMacroAttrKind::DeriveHelperCompat) {\n+                        self.lint_buffer.buffer_lint_with_diagnostic(\n+                            LEGACY_DERIVE_HELPERS,\n+                            self.lint_node_id(parent_scope.expansion),\n+                            ident.span,\n+                            \"derive helper attribute is used before it is introduced\",\n+                            BuiltinLintDiagnostics::LegacyDeriveHelpers(binding.span),\n+                        );\n+                    }\n                 }\n                 Err(..) => {\n                     let expected = kind.descr_expected();\n@@ -1078,7 +1123,7 @@ impl<'a> Resolver<'a> {\n     crate fn check_reserved_macro_name(&mut self, ident: Ident, res: Res) {\n         // Reserve some names that are not quite covered by the general check\n         // performed on `Resolver::builtin_attrs`.\n-        if ident.name == sym::cfg || ident.name == sym::cfg_attr || ident.name == sym::derive {\n+        if ident.name == sym::cfg || ident.name == sym::cfg_attr {\n             let macro_kind = self.get_macro(res).map(|ext| ext.macro_kind());\n             if macro_kind.is_some() && sub_namespace_match(macro_kind, Some(MacroKind::Attr)) {\n                 self.session.span_err("}, {"sha": "20e4f7262acb96ff9ac7f373947df8d721fd1443", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -679,6 +679,7 @@ symbols! {\n         loop_break_value,\n         lt,\n         macro_at_most_once_rep,\n+        macro_attributes_in_derive_output,\n         macro_escape,\n         macro_export,\n         macro_lifetime_matcher,"}, {"sha": "7aaf5a5fd46141ae16101758cf4262e70b88e34d", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -1324,6 +1324,14 @@ pub(crate) mod builtin {\n         (false) => {{ /* compiler built-in */ }};\n     }\n \n+    /// Attribute macro used to apply derive macros.\n+    #[cfg(not(bootstrap))]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_builtin_macro]\n+    pub macro derive($item:item) {\n+        /* compiler built-in */\n+    }\n+\n     /// Attribute macro applied to a function to turn it into a unit test.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow_internal_unstable(test, rustc_attrs)]"}, {"sha": "a1fbd8dec7505364d352f9b7ac3e86b5c6d8bc41", "filename": "library/core/src/prelude/v1.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -69,6 +69,11 @@ pub use crate::macros::builtin::{\n     bench, global_allocator, test, test_case, RustcDecodable, RustcEncodable,\n };\n \n+#[cfg(not(bootstrap))]\n+#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n+#[doc(no_inline)]\n+pub use crate::macros::builtin::derive;\n+\n #[unstable(\n     feature = \"cfg_accessible\",\n     issue = \"64797\","}, {"sha": "ef9aec54a4ca2462b5ed41eecd8c9f46c4b3b176", "filename": "library/std/src/prelude/v1.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -54,6 +54,11 @@ pub use core::prelude::v1::{\n     bench, global_allocator, test, test_case, RustcDecodable, RustcEncodable,\n };\n \n+#[cfg(not(bootstrap))]\n+#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n+#[doc(hidden)]\n+pub use core::prelude::v1::derive;\n+\n #[unstable(\n     feature = \"cfg_accessible\",\n     issue = \"64797\","}, {"sha": "297fc95006b02d92e7e0ea7c781cc53d565aedad", "filename": "src/rustdoc-json-types/lib.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Frustdoc-json-types%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Frustdoc-json-types%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc-json-types%2Flib.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -96,8 +96,8 @@ pub struct Deprecation {\n     pub note: Option<String>,\n }\n \n-#[serde(rename_all = \"snake_case\")]\n #[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n+#[serde(rename_all = \"snake_case\")]\n pub enum Visibility {\n     Public,\n     /// For the most part items are private by default. The exceptions are associated items of\n@@ -112,17 +112,17 @@ pub enum Visibility {\n     },\n }\n \n-#[serde(rename_all = \"snake_case\")]\n #[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n+#[serde(rename_all = \"snake_case\")]\n pub enum GenericArgs {\n     /// <'a, 32, B: Copy, C = u32>\n     AngleBracketed { args: Vec<GenericArg>, bindings: Vec<TypeBinding> },\n     /// Fn(A, B) -> C\n     Parenthesized { inputs: Vec<Type>, output: Option<Type> },\n }\n \n-#[serde(rename_all = \"snake_case\")]\n #[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n+#[serde(rename_all = \"snake_case\")]\n pub enum GenericArg {\n     Lifetime(String),\n     Type(Type),\n@@ -144,8 +144,8 @@ pub struct TypeBinding {\n     pub binding: TypeBindingKind,\n }\n \n-#[serde(rename_all = \"snake_case\")]\n #[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n+#[serde(rename_all = \"snake_case\")]\n pub enum TypeBindingKind {\n     Equality(Type),\n     Constraint(Vec<GenericBound>),\n@@ -154,8 +154,8 @@ pub enum TypeBindingKind {\n #[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]\n pub struct Id(pub String);\n \n-#[serde(rename_all = \"snake_case\")]\n #[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n+#[serde(rename_all = \"snake_case\")]\n pub enum ItemKind {\n     Module,\n     ExternCrate,\n@@ -184,8 +184,8 @@ pub enum ItemKind {\n     Keyword,\n }\n \n-#[serde(untagged)]\n #[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n+#[serde(untagged)]\n pub enum ItemEnum {\n     ModuleItem(Module),\n     ExternCrateItem {\n@@ -264,17 +264,17 @@ pub struct Enum {\n     pub impls: Vec<Id>,\n }\n \n+#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n #[serde(rename_all = \"snake_case\")]\n #[serde(tag = \"variant_kind\", content = \"variant_inner\")]\n-#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n pub enum Variant {\n     Plain,\n     Tuple(Vec<Type>),\n     Struct(Vec<Id>),\n }\n \n-#[serde(rename_all = \"snake_case\")]\n #[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n+#[serde(rename_all = \"snake_case\")]\n pub enum StructType {\n     Plain,\n     Tuple,\n@@ -310,24 +310,24 @@ pub struct GenericParamDef {\n     pub kind: GenericParamDefKind,\n }\n \n-#[serde(rename_all = \"snake_case\")]\n #[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n+#[serde(rename_all = \"snake_case\")]\n pub enum GenericParamDefKind {\n     Lifetime,\n     Type { bounds: Vec<GenericBound>, default: Option<Type> },\n     Const(Type),\n }\n \n-#[serde(rename_all = \"snake_case\")]\n #[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n+#[serde(rename_all = \"snake_case\")]\n pub enum WherePredicate {\n     BoundPredicate { ty: Type, bounds: Vec<GenericBound> },\n     RegionPredicate { lifetime: String, bounds: Vec<GenericBound> },\n     EqPredicate { lhs: Type, rhs: Type },\n }\n \n-#[serde(rename_all = \"snake_case\")]\n #[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n+#[serde(rename_all = \"snake_case\")]\n pub enum GenericBound {\n     TraitBound {\n         #[serde(rename = \"trait\")]\n@@ -339,17 +339,17 @@ pub enum GenericBound {\n     Outlives(String),\n }\n \n-#[serde(rename_all = \"snake_case\")]\n #[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n+#[serde(rename_all = \"snake_case\")]\n pub enum TraitBoundModifier {\n     None,\n     Maybe,\n     MaybeConst,\n }\n \n+#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n #[serde(rename_all = \"snake_case\")]\n #[serde(tag = \"kind\", content = \"inner\")]\n-#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n pub enum Type {\n     /// Structs, enums, and traits\n     ResolvedPath {\n@@ -448,8 +448,8 @@ pub struct Impl {\n     pub blanket_impl: Option<Type>,\n }\n \n-#[serde(rename_all = \"snake_case\")]\n #[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n+#[serde(rename_all = \"snake_case\")]\n pub struct Import {\n     /// The full path being imported.\n     pub span: String,\n@@ -468,8 +468,8 @@ pub struct ProcMacro {\n     pub helpers: Vec<String>,\n }\n \n-#[serde(rename_all = \"snake_case\")]\n #[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n+#[serde(rename_all = \"snake_case\")]\n pub enum MacroKind {\n     /// A bang macro `foo!()`.\n     Bang,"}, {"sha": "d11cfd77c5bf91b5a39f7bb05b7f4789862e7e63", "filename": "src/test/run-make-fulldeps/simd-ffi/simd.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Frun-make-fulldeps%2Fsimd-ffi%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Frun-make-fulldeps%2Fsimd-ffi%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsimd-ffi%2Fsimd.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -75,3 +75,8 @@ auto trait Freeze {}\n macro_rules! Copy {\n     () => {};\n }\n+#[macro_export]\n+#[rustc_builtin_macro]\n+macro_rules! derive {\n+    () => {};\n+}"}, {"sha": "0137b1e5bfbf3f899b61aacffa816a7287690861", "filename": "src/test/ui/derives/derive-deadlock.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fderives%2Fderive-deadlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fderives%2Fderive-deadlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderive-deadlock.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -0,0 +1,6 @@\n+use std as derive;\n+\n+#[derive(Default)] //~ ERROR cannot determine resolution for the attribute macro `derive`\n+struct S;\n+\n+fn main() {}"}, {"sha": "8d062491c6a7c556ae7cc96015f67af832072aac", "filename": "src/test/ui/derives/derive-deadlock.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fderives%2Fderive-deadlock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fderives%2Fderive-deadlock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderive-deadlock.stderr?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -0,0 +1,10 @@\n+error: cannot determine resolution for the attribute macro `derive`\n+  --> $DIR/derive-deadlock.rs:3:3\n+   |\n+LL | #[derive(Default)]\n+   |   ^^^^^^\n+   |\n+   = note: import resolution is stuck, try simplifying macro imports\n+\n+error: aborting due to previous error\n+"}, {"sha": "e762ee357caab43d205b27bba89a16fccd924de3", "filename": "src/test/ui/derives/derive-multiple-with-packed.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fderives%2Fderive-multiple-with-packed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fderives%2Fderive-multiple-with-packed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderive-multiple-with-packed.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -0,0 +1,10 @@\n+// check-pass\n+\n+#[derive(Clone, Copy)]\n+#[derive(Debug)] // OK, even if `Copy` is in the different `#[derive]`\n+#[repr(packed)]\n+struct CacheRecordHeader {\n+    field: u64,\n+}\n+\n+fn main() {}"}, {"sha": "d310e5806c560a961b4a283db0e720fc959fa26d", "filename": "src/test/ui/derives/derive-renamed.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fderives%2Fderive-renamed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fderives%2Fderive-renamed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderive-renamed.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+// edition:2018\n+\n+use derive as my_derive;\n+\n+#[my_derive(Debug)]\n+struct S;\n+\n+fn main() {\n+    println!(\"{:?}\", S); // OK\n+}"}, {"sha": "0306ce717d0493e3823792ed10efc5df210ea2ec", "filename": "src/test/ui/derives/deriving-meta-empty-trait-list.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fderives%2Fderiving-meta-empty-trait-list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fderives%2Fderiving-meta-empty-trait-list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderiving-meta-empty-trait-list.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -1,6 +1,8 @@\n+// check-pass\n+\n #![deny(unused)]\n \n-#[derive()] //~ ERROR unused attribute\n+#[derive()] // OK\n struct _Bar;\n \n pub fn main() {}"}, {"sha": "1fd7d58c86a376f4c1889bc81854cd562d068d4b", "filename": "src/test/ui/derives/deriving-meta-empty-trait-list.stderr", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923/src%2Ftest%2Fui%2Fderives%2Fderiving-meta-empty-trait-list.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923/src%2Ftest%2Fui%2Fderives%2Fderiving-meta-empty-trait-list.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderiving-meta-empty-trait-list.stderr?ref=36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923", "patch": "@@ -1,15 +0,0 @@\n-error: unused attribute\n-  --> $DIR/deriving-meta-empty-trait-list.rs:3:1\n-   |\n-LL | #[derive()]\n-   | ^^^^^^^^^^^\n-   |\n-note: the lint level is defined here\n-  --> $DIR/deriving-meta-empty-trait-list.rs:1:9\n-   |\n-LL | #![deny(unused)]\n-   |         ^^^^^^\n-   = note: `#[deny(unused_attributes)]` implied by `#[deny(unused)]`\n-\n-error: aborting due to previous error\n-"}, {"sha": "08fc82e91f62379a681bcb41f0e4e357d25c1833", "filename": "src/test/ui/derives/issue-36617.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fderives%2Fissue-36617.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fderives%2Fissue-36617.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fissue-36617.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -1,4 +1,3 @@\n-#![derive(Copy)] //~ ERROR `derive` may only be applied to structs, enums and unions\n-                 //~| ERROR cannot determine resolution for the derive macro `Copy`\n+#![derive(Copy)] //~ ERROR cannot determine resolution for the attribute macro `derive`\n \n fn main() {}"}, {"sha": "0716764b4270460e1e616364b8d8eaa7ebb8058b", "filename": "src/test/ui/derives/issue-36617.stderr", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fderives%2Fissue-36617.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fderives%2Fissue-36617.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fissue-36617.stderr?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -1,17 +1,10 @@\n-error[E0774]: `derive` may only be applied to structs, enums and unions\n-  --> $DIR/issue-36617.rs:1:1\n+error: cannot determine resolution for the attribute macro `derive`\n+  --> $DIR/issue-36617.rs:1:4\n    |\n LL | #![derive(Copy)]\n-   | ^^^^^^^^^^^^^^^^ help: try an outer attribute: `#[derive(Copy)]`\n-\n-error: cannot determine resolution for the derive macro `Copy`\n-  --> $DIR/issue-36617.rs:1:11\n-   |\n-LL | #![derive(Copy)]\n-   |           ^^^^\n+   |    ^^^^^^\n    |\n    = note: import resolution is stuck, try simplifying macro imports\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0774`."}, {"sha": "5404b8c04bb76e0b40677fe84b1a426919be8cd6", "filename": "src/test/ui/feature-gates/issue-43106-gating-of-derive.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-derive.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -6,6 +6,7 @@\n mod derive {\n     mod inner { #![derive(Debug)] }\n     //~^ ERROR `derive` may only be applied to structs, enums and unions\n+    //~| ERROR inner macro attributes are unstable\n \n     #[derive(Debug)]\n     //~^ ERROR `derive` may only be applied to structs, enums and unions"}, {"sha": "9b1f4f46219d2e85f964709d16a1b7685b689b9e", "filename": "src/test/ui/feature-gates/issue-43106-gating-of-derive.stderr", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-derive.stderr?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -4,30 +4,40 @@ error[E0774]: `derive` may only be applied to structs, enums and unions\n LL | #[derive(Debug)]\n    | ^^^^^^^^^^^^^^^^\n \n+error[E0658]: inner macro attributes are unstable\n+  --> $DIR/issue-43106-gating-of-derive.rs:7:20\n+   |\n+LL |     mod inner { #![derive(Debug)] }\n+   |                    ^^^^^^\n+   |\n+   = note: see issue #54726 <https://github.com/rust-lang/rust/issues/54726> for more information\n+   = help: add `#![feature(custom_inner_attributes)]` to the crate attributes to enable\n+\n error[E0774]: `derive` may only be applied to structs, enums and unions\n   --> $DIR/issue-43106-gating-of-derive.rs:7:17\n    |\n LL |     mod inner { #![derive(Debug)] }\n-   |                 ^^^^^^^^^^^^^^^^^ help: try an outer attribute: `#[derive(Debug)]`\n+   |                 ^^^^^^^^^^^^^^^^^\n \n error[E0774]: `derive` may only be applied to structs, enums and unions\n-  --> $DIR/issue-43106-gating-of-derive.rs:10:5\n+  --> $DIR/issue-43106-gating-of-derive.rs:11:5\n    |\n LL |     #[derive(Debug)]\n    |     ^^^^^^^^^^^^^^^^\n \n error[E0774]: `derive` may only be applied to structs, enums and unions\n-  --> $DIR/issue-43106-gating-of-derive.rs:23:5\n+  --> $DIR/issue-43106-gating-of-derive.rs:24:5\n    |\n LL |     #[derive(Debug)]\n    |     ^^^^^^^^^^^^^^^^\n \n error[E0774]: `derive` may only be applied to structs, enums and unions\n-  --> $DIR/issue-43106-gating-of-derive.rs:27:5\n+  --> $DIR/issue-43106-gating-of-derive.rs:28:5\n    |\n LL |     #[derive(Debug)]\n    |     ^^^^^^^^^^^^^^^^\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 6 previous errors\n \n-For more information about this error, try `rustc --explain E0774`.\n+Some errors have detailed explanations: E0658, E0774.\n+For more information about an error, try `rustc --explain E0658`."}, {"sha": "dd14bac5e3a9f81dcaf103a5d86f97d26d839eb5", "filename": "src/test/ui/issues/issue-49934-errors.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fissues%2Fissue-49934-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fissues%2Fissue-49934-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-49934-errors.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -1,11 +1,8 @@\n-fn foo<#[derive(Debug)] T>() {\n-//~^ ERROR `derive` may only be applied to structs, enums and unions\n+fn foo<#[derive(Debug)] T>() { //~ ERROR expected non-macro attribute, found attribute macro\n     match 0 {\n-        #[derive(Debug)]\n-        //~^ ERROR `derive` may only be applied to structs, enums and unions\n+        #[derive(Debug)] //~ ERROR expected non-macro attribute, found attribute macro\n         _ => (),\n     }\n }\n \n-fn main() {\n-}\n+fn main() {}"}, {"sha": "8c4c54170a1014d316d07fa9c3ca11385538aa02", "filename": "src/test/ui/issues/issue-49934-errors.stderr", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fissues%2Fissue-49934-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fissues%2Fissue-49934-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-49934-errors.stderr?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -1,15 +1,14 @@\n-error[E0774]: `derive` may only be applied to structs, enums and unions\n-  --> $DIR/issue-49934-errors.rs:1:8\n+error: expected non-macro attribute, found attribute macro `derive`\n+  --> $DIR/issue-49934-errors.rs:1:10\n    |\n LL | fn foo<#[derive(Debug)] T>() {\n-   |        ^^^^^^^^^^^^^^^^\n+   |          ^^^^^^ not a non-macro attribute\n \n-error[E0774]: `derive` may only be applied to structs, enums and unions\n-  --> $DIR/issue-49934-errors.rs:4:9\n+error: expected non-macro attribute, found attribute macro `derive`\n+  --> $DIR/issue-49934-errors.rs:3:11\n    |\n LL |         #[derive(Debug)]\n-   |         ^^^^^^^^^^^^^^^^\n+   |           ^^^^^^ not a non-macro attribute\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0774`."}, {"sha": "ec73e670634df943a1ccb10684d0d493d120d022", "filename": "src/test/ui/issues/issue-49934.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fissues%2Fissue-49934.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fissues%2Fissue-49934.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-49934.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -1,7 +1,4 @@\n-// check-pass\n-\n #![feature(stmt_expr_attributes)]\n-#![warn(unused_attributes)] //~ NOTE the lint level is defined here\n \n fn main() {\n     // fold_stmt (Item)\n@@ -10,26 +7,24 @@ fn main() {\n     struct Foo;\n \n     // fold_stmt (Mac)\n-    #[derive(Debug)]\n-    //~^ WARN `#[derive]` does nothing on macro invocations\n-    //~| NOTE this may become a hard error in a future release\n+    #[derive(Debug)] //~ ERROR `derive` may only be applied to structs, enums and unions\n     println!(\"Hello, world!\");\n \n     // fold_stmt (Semi)\n-    #[derive(Debug)] //~ WARN unused attribute\n+    #[derive(Debug)] //~ ERROR `derive` may only be applied to structs, enums and unions\n     \"Hello, world!\";\n \n     // fold_stmt (Local)\n-    #[derive(Debug)] //~ WARN unused attribute\n+    #[derive(Debug)] //~ ERROR `derive` may only be applied to structs, enums and unions\n     let _ = \"Hello, world!\";\n \n     // visit_expr\n     let _ = #[derive(Debug)] \"Hello, world!\";\n-    //~^ WARN unused attribute\n+    //~^ ERROR `derive` may only be applied to structs, enums and unions\n \n     let _ = [\n         // filter_map_expr\n-        #[derive(Debug)] //~ WARN unused attribute\n-        \"Hello, world!\"\n+        #[derive(Debug)] //~ ERROR `derive` may only be applied to structs, enums and unions\n+        \"Hello, world!\",\n     ];\n }"}, {"sha": "7746ad287ab796f945677e5e92d13c1b7a0da827", "filename": "src/test/ui/issues/issue-49934.stderr", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fissues%2Fissue-49934.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fissues%2Fissue-49934.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-49934.stderr?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -1,40 +1,33 @@\n-warning: `#[derive]` does nothing on macro invocations\n-  --> $DIR/issue-49934.rs:13:5\n+error[E0774]: `derive` may only be applied to structs, enums and unions\n+  --> $DIR/issue-49934.rs:10:5\n    |\n LL |     #[derive(Debug)]\n    |     ^^^^^^^^^^^^^^^^\n-   |\n-   = note: this may become a hard error in a future release\n \n-warning: unused attribute\n-  --> $DIR/issue-49934.rs:19:5\n+error[E0774]: `derive` may only be applied to structs, enums and unions\n+  --> $DIR/issue-49934.rs:14:5\n    |\n LL |     #[derive(Debug)]\n    |     ^^^^^^^^^^^^^^^^\n-   |\n-note: the lint level is defined here\n-  --> $DIR/issue-49934.rs:4:9\n-   |\n-LL | #![warn(unused_attributes)]\n-   |         ^^^^^^^^^^^^^^^^^\n \n-warning: unused attribute\n-  --> $DIR/issue-49934.rs:23:5\n+error[E0774]: `derive` may only be applied to structs, enums and unions\n+  --> $DIR/issue-49934.rs:18:5\n    |\n LL |     #[derive(Debug)]\n    |     ^^^^^^^^^^^^^^^^\n \n-warning: unused attribute\n-  --> $DIR/issue-49934.rs:27:13\n+error[E0774]: `derive` may only be applied to structs, enums and unions\n+  --> $DIR/issue-49934.rs:22:13\n    |\n LL |     let _ = #[derive(Debug)] \"Hello, world!\";\n    |             ^^^^^^^^^^^^^^^^\n \n-warning: unused attribute\n-  --> $DIR/issue-49934.rs:32:9\n+error[E0774]: `derive` may only be applied to structs, enums and unions\n+  --> $DIR/issue-49934.rs:27:9\n    |\n LL |         #[derive(Debug)]\n    |         ^^^^^^^^^^^^^^^^\n \n-warning: 5 warnings emitted\n+error: aborting due to 5 previous errors\n \n+For more information about this error, try `rustc --explain E0774`."}, {"sha": "4f1a76b0d6e086d3842bc9ce60e2dcd13896552e", "filename": "src/test/ui/macros/builtin-std-paths-fail.stderr", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fmacros%2Fbuiltin-std-paths-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fmacros%2Fbuiltin-std-paths-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fbuiltin-std-paths-fail.stderr?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -1,3 +1,15 @@\n+error[E0433]: failed to resolve: could not find `RustcDecodable` in `core`\n+  --> $DIR/builtin-std-paths-fail.rs:2:11\n+   |\n+LL |     core::RustcDecodable,\n+   |           ^^^^^^^^^^^^^^ could not find `RustcDecodable` in `core`\n+\n+error[E0433]: failed to resolve: could not find `RustcDecodable` in `core`\n+  --> $DIR/builtin-std-paths-fail.rs:4:11\n+   |\n+LL |     core::RustcDecodable,\n+   |           ^^^^^^^^^^^^^^ could not find `RustcDecodable` in `core`\n+\n error[E0433]: failed to resolve: could not find `bench` in `core`\n   --> $DIR/builtin-std-paths-fail.rs:7:9\n    |\n@@ -23,28 +35,28 @@ LL | #[core::test]\n    |         ^^^^ could not find `test` in `core`\n \n error[E0433]: failed to resolve: could not find `RustcDecodable` in `core`\n-  --> $DIR/builtin-std-paths-fail.rs:2:11\n+  --> $DIR/builtin-std-paths-fail.rs:4:11\n    |\n LL |     core::RustcDecodable,\n    |           ^^^^^^^^^^^^^^ could not find `RustcDecodable` in `core`\n \n error[E0433]: failed to resolve: could not find `RustcDecodable` in `core`\n-  --> $DIR/builtin-std-paths-fail.rs:4:11\n+  --> $DIR/builtin-std-paths-fail.rs:2:11\n    |\n LL |     core::RustcDecodable,\n    |           ^^^^^^^^^^^^^^ could not find `RustcDecodable` in `core`\n \n-error[E0433]: failed to resolve: could not find `RustcDecodable` in `core`\n-  --> $DIR/builtin-std-paths-fail.rs:4:11\n+error[E0433]: failed to resolve: could not find `RustcDecodable` in `std`\n+  --> $DIR/builtin-std-paths-fail.rs:14:10\n    |\n-LL |     core::RustcDecodable,\n-   |           ^^^^^^^^^^^^^^ could not find `RustcDecodable` in `core`\n+LL |     std::RustcDecodable,\n+   |          ^^^^^^^^^^^^^^ could not find `RustcDecodable` in `std`\n \n-error[E0433]: failed to resolve: could not find `RustcDecodable` in `core`\n-  --> $DIR/builtin-std-paths-fail.rs:2:11\n+error[E0433]: failed to resolve: could not find `RustcDecodable` in `std`\n+  --> $DIR/builtin-std-paths-fail.rs:16:10\n    |\n-LL |     core::RustcDecodable,\n-   |           ^^^^^^^^^^^^^^ could not find `RustcDecodable` in `core`\n+LL |     std::RustcDecodable,\n+   |          ^^^^^^^^^^^^^^ could not find `RustcDecodable` in `std`\n \n error[E0433]: failed to resolve: could not find `bench` in `std`\n   --> $DIR/builtin-std-paths-fail.rs:19:8\n@@ -70,18 +82,6 @@ error[E0433]: failed to resolve: could not find `test` in `std`\n LL | #[std::test]\n    |        ^^^^ could not find `test` in `std`\n \n-error[E0433]: failed to resolve: could not find `RustcDecodable` in `std`\n-  --> $DIR/builtin-std-paths-fail.rs:14:10\n-   |\n-LL |     std::RustcDecodable,\n-   |          ^^^^^^^^^^^^^^ could not find `RustcDecodable` in `std`\n-\n-error[E0433]: failed to resolve: could not find `RustcDecodable` in `std`\n-  --> $DIR/builtin-std-paths-fail.rs:16:10\n-   |\n-LL |     std::RustcDecodable,\n-   |          ^^^^^^^^^^^^^^ could not find `RustcDecodable` in `std`\n-\n error[E0433]: failed to resolve: could not find `RustcDecodable` in `std`\n   --> $DIR/builtin-std-paths-fail.rs:16:10\n    |"}, {"sha": "fc4c3f4e64bf9d401e86a7903e23a71b71954fa6", "filename": "src/test/ui/malformed/issue-69341-malformed-derive-inert.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fmalformed%2Fissue-69341-malformed-derive-inert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fmalformed%2Fissue-69341-malformed-derive-inert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fissue-69341-malformed-derive-inert.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -1,9 +1,6 @@\n fn main() {}\n \n struct CLI {\n-    #[derive(parse())]\n-    //~^ ERROR traits in `#[derive(...)]` don't accept arguments\n-    //~| ERROR cannot find derive macro `parse` in this scope\n+    #[derive(parse())] //~ ERROR expected non-macro attribute, found attribute macro\n     path: (),\n-    //~^ ERROR `derive` may only be applied to structs, enums and unions\n }"}, {"sha": "04f7ebe019ea4d94303137da27e9173b26955a5d", "filename": "src/test/ui/malformed/issue-69341-malformed-derive-inert.stderr", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fmalformed%2Fissue-69341-malformed-derive-inert.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fmalformed%2Fissue-69341-malformed-derive-inert.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fissue-69341-malformed-derive-inert.stderr?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -1,21 +1,8 @@\n-error: traits in `#[derive(...)]` don't accept arguments\n-  --> $DIR/issue-69341-malformed-derive-inert.rs:4:19\n+error: expected non-macro attribute, found attribute macro `derive`\n+  --> $DIR/issue-69341-malformed-derive-inert.rs:4:7\n    |\n LL |     #[derive(parse())]\n-   |                   ^^ help: remove the arguments\n+   |       ^^^^^^ not a non-macro attribute\n \n-error[E0774]: `derive` may only be applied to structs, enums and unions\n-  --> $DIR/issue-69341-malformed-derive-inert.rs:7:5\n-   |\n-LL |     path: (),\n-   |     ^^^^^^^^\n-\n-error: cannot find derive macro `parse` in this scope\n-  --> $DIR/issue-69341-malformed-derive-inert.rs:4:14\n-   |\n-LL |     #[derive(parse())]\n-   |              ^^^^^\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0774`."}, {"sha": "365cc099e9d3ecd370a1dc52c0ea26fed1a71255", "filename": "src/test/ui/malformed/malformed-derive-entry.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-derive-entry.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-derive-entry.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-derive-entry.stderr?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -14,7 +14,7 @@ error: malformed `derive` attribute input\n   --> $DIR/malformed-derive-entry.rs:11:1\n    |\n LL | #[derive]\n-   | ^^^^^^^^^ help: missing traits to be derived: `#[derive(Trait1, Trait2, ...)]`\n+   | ^^^^^^^^^ help: must be of the form: `#[derive(Trait1, Trait2, ...)]`\n \n error[E0277]: the trait bound `Test1: Clone` is not satisfied\n   --> $DIR/malformed-derive-entry.rs:1:10"}, {"sha": "1764c3969cfee6e76c40dc941b56d034b536af51", "filename": "src/test/ui/malformed/malformed-special-attrs.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-special-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-special-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-special-attrs.stderr?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -18,13 +18,13 @@ error: malformed `derive` attribute input\n   --> $DIR/malformed-special-attrs.rs:7:1\n    |\n LL | #[derive]\n-   | ^^^^^^^^^ help: missing traits to be derived: `#[derive(Trait1, Trait2, ...)]`\n+   | ^^^^^^^^^ help: must be of the form: `#[derive(Trait1, Trait2, ...)]`\n \n error: malformed `derive` attribute input\n   --> $DIR/malformed-special-attrs.rs:10:1\n    |\n LL | #[derive = \"\"]\n-   | ^^^^^^^^^^^^^^ help: missing traits to be derived: `#[derive(Trait1, Trait2, ...)]`\n+   | ^^^^^^^^^^^^^^ help: must be of the form: `#[derive(Trait1, Trait2, ...)]`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "f0fec6782423ef73901040aaef98f12622e3b4d2", "filename": "src/test/ui/proc-macro/attribute-after-derive-feature-gate.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-after-derive-feature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-after-derive-feature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-after-derive-feature-gate.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -0,0 +1,37 @@\n+// gate-test-macro_attributes_in_derive_output\n+// aux-build: test-macros.rs\n+\n+#![feature(proc_macro_hygiene)]\n+#![feature(stmt_expr_attributes)]\n+\n+#[macro_use]\n+extern crate test_macros;\n+\n+#[derive(Empty)]\n+#[empty_attr] //~ ERROR macro attributes in `#[derive]` output are unstable\n+struct S1 {\n+    field: [u8; 10],\n+}\n+\n+#[derive(Empty)]\n+#[empty_helper]\n+#[empty_attr] //~ ERROR macro attributes in `#[derive]` output are unstable\n+struct S2 {\n+    field: [u8; 10],\n+}\n+\n+#[derive(Empty)]\n+struct S3 {\n+    field: [u8; #[identity_attr] 10], //~ ERROR macro attributes in `#[derive]` output are unstable\n+}\n+\n+#[derive(Empty)]\n+struct S4 {\n+    field: [u8; {\n+        #[derive(Empty)] // OK, not gated\n+        struct Inner;\n+        10\n+    }]\n+}\n+\n+fn main() {}"}, {"sha": "74cace628b94c94bfd76b84a6003bdbdab72d423", "filename": "src/test/ui/proc-macro/attribute-after-derive-feature-gate.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-after-derive-feature-gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-after-derive-feature-gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-after-derive-feature-gate.stderr?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -0,0 +1,30 @@\n+error[E0658]: macro attributes in `#[derive]` output are unstable\n+  --> $DIR/attribute-after-derive-feature-gate.rs:11:3\n+   |\n+LL | #[empty_attr]\n+   |   ^^^^^^^^^^\n+   |\n+   = note: see issue #81119 <https://github.com/rust-lang/rust/issues/81119> for more information\n+   = help: add `#![feature(macro_attributes_in_derive_output)]` to the crate attributes to enable\n+\n+error[E0658]: macro attributes in `#[derive]` output are unstable\n+  --> $DIR/attribute-after-derive-feature-gate.rs:18:3\n+   |\n+LL | #[empty_attr]\n+   |   ^^^^^^^^^^\n+   |\n+   = note: see issue #81119 <https://github.com/rust-lang/rust/issues/81119> for more information\n+   = help: add `#![feature(macro_attributes_in_derive_output)]` to the crate attributes to enable\n+\n+error[E0658]: macro attributes in `#[derive]` output are unstable\n+  --> $DIR/attribute-after-derive-feature-gate.rs:25:19\n+   |\n+LL |     field: [u8; #[identity_attr] 10],\n+   |                   ^^^^^^^^^^^^^\n+   |\n+   = note: see issue #81119 <https://github.com/rust-lang/rust/issues/81119> for more information\n+   = help: add `#![feature(macro_attributes_in_derive_output)]` to the crate attributes to enable\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "ac3f28b6ef3ea119e50cfce971341cf175e6399a", "filename": "src/test/ui/proc-macro/attribute-after-derive.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-after-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-after-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-after-derive.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -0,0 +1,30 @@\n+// Macro attributes are allowed after `#[derive]` and\n+// `#[derive]` fully configures the item for following attributes.\n+\n+// check-pass\n+// compile-flags: -Z span-debug\n+// aux-build: test-macros.rs\n+\n+#![feature(macro_attributes_in_derive_output)]\n+\n+#![no_std] // Don't load unnecessary hygiene information from std\n+extern crate std;\n+\n+#[macro_use]\n+extern crate test_macros;\n+\n+#[print_attr]\n+#[derive(Print)]\n+struct AttributeDerive {\n+    #[cfg(FALSE)]\n+    field: u8,\n+}\n+\n+#[derive(Print)]\n+#[print_attr]\n+struct DeriveAttribute {\n+    #[cfg(FALSE)]\n+    field: u8,\n+}\n+\n+fn main() {}"}, {"sha": "11f492353271a9bfe45de1a98096ca0cf568d7c0", "filename": "src/test/ui/proc-macro/attribute-after-derive.stdout", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-after-derive.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-after-derive.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-after-derive.stdout?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -0,0 +1,148 @@\n+PRINT-ATTR INPUT (DISPLAY): #[derive(Print)] struct AttributeDerive { #[cfg(FALSE)] field : u8, }\n+PRINT-ATTR INPUT (DEBUG): TokenStream [\n+    Punct {\n+        ch: '#',\n+        spacing: Alone,\n+        span: $DIR/attribute-after-derive.rs:17:1: 17:2 (#0),\n+    },\n+    Group {\n+        delimiter: Bracket,\n+        stream: TokenStream [\n+            Ident {\n+                ident: \"derive\",\n+                span: $DIR/attribute-after-derive.rs:17:3: 17:9 (#0),\n+            },\n+            Group {\n+                delimiter: Parenthesis,\n+                stream: TokenStream [\n+                    Ident {\n+                        ident: \"Print\",\n+                        span: $DIR/attribute-after-derive.rs:17:10: 17:15 (#0),\n+                    },\n+                ],\n+                span: $DIR/attribute-after-derive.rs:17:9: 17:16 (#0),\n+            },\n+        ],\n+        span: $DIR/attribute-after-derive.rs:17:2: 17:17 (#0),\n+    },\n+    Ident {\n+        ident: \"struct\",\n+        span: $DIR/attribute-after-derive.rs:18:1: 18:7 (#0),\n+    },\n+    Ident {\n+        ident: \"AttributeDerive\",\n+        span: $DIR/attribute-after-derive.rs:18:8: 18:23 (#0),\n+    },\n+    Group {\n+        delimiter: Brace,\n+        stream: TokenStream [\n+            Punct {\n+                ch: '#',\n+                spacing: Alone,\n+                span: $DIR/attribute-after-derive.rs:19:5: 19:6 (#0),\n+            },\n+            Group {\n+                delimiter: Bracket,\n+                stream: TokenStream [\n+                    Ident {\n+                        ident: \"cfg\",\n+                        span: $DIR/attribute-after-derive.rs:19:7: 19:10 (#0),\n+                    },\n+                    Group {\n+                        delimiter: Parenthesis,\n+                        stream: TokenStream [\n+                            Ident {\n+                                ident: \"FALSE\",\n+                                span: $DIR/attribute-after-derive.rs:19:11: 19:16 (#0),\n+                            },\n+                        ],\n+                        span: $DIR/attribute-after-derive.rs:19:10: 19:17 (#0),\n+                    },\n+                ],\n+                span: $DIR/attribute-after-derive.rs:19:6: 19:18 (#0),\n+            },\n+            Ident {\n+                ident: \"field\",\n+                span: $DIR/attribute-after-derive.rs:20:5: 20:10 (#0),\n+            },\n+            Punct {\n+                ch: ':',\n+                spacing: Alone,\n+                span: $DIR/attribute-after-derive.rs:20:10: 20:11 (#0),\n+            },\n+            Ident {\n+                ident: \"u8\",\n+                span: $DIR/attribute-after-derive.rs:20:12: 20:14 (#0),\n+            },\n+            Punct {\n+                ch: ',',\n+                spacing: Alone,\n+                span: $DIR/attribute-after-derive.rs:20:14: 20:15 (#0),\n+            },\n+        ],\n+        span: $DIR/attribute-after-derive.rs:18:24: 21:2 (#0),\n+    },\n+]\n+PRINT-DERIVE INPUT (DISPLAY): struct AttributeDerive { }\n+PRINT-DERIVE INPUT (DEBUG): TokenStream [\n+    Ident {\n+        ident: \"struct\",\n+        span: $DIR/attribute-after-derive.rs:18:1: 21:2 (#0),\n+    },\n+    Ident {\n+        ident: \"AttributeDerive\",\n+        span: $DIR/attribute-after-derive.rs:18:1: 21:2 (#0),\n+    },\n+    Group {\n+        delimiter: Brace,\n+        stream: TokenStream [],\n+        span: $DIR/attribute-after-derive.rs:18:1: 21:2 (#0),\n+    },\n+]\n+PRINT-ATTR INPUT (DISPLAY): struct DeriveAttribute { }\n+PRINT-ATTR INPUT (DEBUG): TokenStream [\n+    Ident {\n+        ident: \"struct\",\n+        span: $DIR/attribute-after-derive.rs:25:1: 28:2 (#0),\n+    },\n+    Ident {\n+        ident: \"DeriveAttribute\",\n+        span: $DIR/attribute-after-derive.rs:25:1: 28:2 (#0),\n+    },\n+    Group {\n+        delimiter: Brace,\n+        stream: TokenStream [],\n+        span: $DIR/attribute-after-derive.rs:25:1: 28:2 (#0),\n+    },\n+]\n+PRINT-DERIVE INPUT (DISPLAY): #[print_attr] struct DeriveAttribute { }\n+PRINT-DERIVE INPUT (DEBUG): TokenStream [\n+    Punct {\n+        ch: '#',\n+        spacing: Alone,\n+        span: $DIR/attribute-after-derive.rs:25:1: 28:2 (#0),\n+    },\n+    Group {\n+        delimiter: Bracket,\n+        stream: TokenStream [\n+            Ident {\n+                ident: \"print_attr\",\n+                span: $DIR/attribute-after-derive.rs:25:1: 28:2 (#0),\n+            },\n+        ],\n+        span: $DIR/attribute-after-derive.rs:25:1: 28:2 (#0),\n+    },\n+    Ident {\n+        ident: \"struct\",\n+        span: $DIR/attribute-after-derive.rs:25:1: 28:2 (#0),\n+    },\n+    Ident {\n+        ident: \"DeriveAttribute\",\n+        span: $DIR/attribute-after-derive.rs:25:1: 28:2 (#0),\n+    },\n+    Group {\n+        delimiter: Brace,\n+        stream: TokenStream [],\n+        span: $DIR/attribute-after-derive.rs:25:1: 28:2 (#0),\n+    },\n+]"}, {"sha": "a3d4d23450ca6f1e44c346c667e1ad97bfef83cf", "filename": "src/test/ui/proc-macro/attribute-order-restricted.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-order-restricted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-order-restricted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-order-restricted.rs?ref=36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923", "patch": "@@ -1,14 +0,0 @@\n-// aux-build:test-macros.rs\n-\n-#[macro_use]\n-extern crate test_macros;\n-\n-#[identity_attr] // OK\n-#[derive(Clone)]\n-struct Before;\n-\n-#[derive(Clone)]\n-#[identity_attr] //~ ERROR macro attributes must be placed before `#[derive]`\n-struct After;\n-\n-fn main() {}"}, {"sha": "9ca8a443e40fbb5cf1fcb8015e279b10b4954ac6", "filename": "src/test/ui/proc-macro/attribute-order-restricted.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-order-restricted.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-order-restricted.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-order-restricted.stderr?ref=36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923", "patch": "@@ -1,8 +0,0 @@\n-error: macro attributes must be placed before `#[derive]`\n-  --> $DIR/attribute-order-restricted.rs:11:1\n-   |\n-LL | #[identity_attr]\n-   | ^^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-"}, {"sha": "ca904900da0bb5a103e0c167c3cf8ea49cdfee86", "filename": "src/test/ui/proc-macro/derive-helper-legacy-limits.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-legacy-limits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-legacy-limits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-legacy-limits.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -0,0 +1,21 @@\n+// Support for legacy derive helpers is limited and heuristic-based\n+// (that's exactly the reason why they are deprecated).\n+\n+// edition:2018\n+// aux-build:test-macros.rs\n+\n+#[macro_use]\n+extern crate test_macros;\n+\n+use derive as my_derive;\n+\n+#[my_derive(Empty)]\n+#[empty_helper] // OK\n+struct S1;\n+\n+// Legacy helper detection doesn't see through `derive` renaming.\n+#[empty_helper] //~ ERROR cannot find attribute `empty_helper` in this scope\n+#[my_derive(Empty)]\n+struct S2;\n+\n+fn main() {}"}, {"sha": "186f38a00f9176e45bf07de7338266cc1600675d", "filename": "src/test/ui/proc-macro/derive-helper-legacy-limits.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-legacy-limits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-legacy-limits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-legacy-limits.stderr?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -0,0 +1,8 @@\n+error: cannot find attribute `empty_helper` in this scope\n+  --> $DIR/derive-helper-legacy-limits.rs:17:3\n+   |\n+LL | #[empty_helper]\n+   |   ^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "80d982d2504db0e3ada6f2dd1a3b211b481333b9", "filename": "src/test/ui/proc-macro/derive-helper-shadowing.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -17,6 +17,8 @@ macro_rules! gen_helper_use {\n }\n \n #[empty_helper] //~ ERROR `empty_helper` is ambiguous\n+                //~| WARN derive helper attribute is used before it is introduced\n+                //~| WARN this was previously accepted\n #[derive(Empty)]\n struct S {\n     #[empty_helper] // OK, no ambiguity, derive helpers have highest priority"}, {"sha": "a49df9f2d4a33affb09086ded90b5242cb3e2288", "filename": "src/test/ui/proc-macro/derive-helper-shadowing.stderr", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.stderr?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -1,17 +1,17 @@\n error: cannot use a derive helper attribute through an import\n-  --> $DIR/derive-helper-shadowing.rs:40:15\n+  --> $DIR/derive-helper-shadowing.rs:42:15\n    |\n LL |             #[renamed]\n    |               ^^^^^^^\n    |\n note: the derive helper attribute imported here\n-  --> $DIR/derive-helper-shadowing.rs:39:17\n+  --> $DIR/derive-helper-shadowing.rs:41:17\n    |\n LL |             use empty_helper as renamed;\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: cannot find attribute `empty_helper` in this scope\n-  --> $DIR/derive-helper-shadowing.rs:36:22\n+  --> $DIR/derive-helper-shadowing.rs:38:22\n    |\n LL |             #[derive(GenHelperUse)]\n    |                      ^^^^^^^^^^^^\n@@ -30,13 +30,13 @@ LL |             gen_helper_use!();\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0659]: `empty_helper` is ambiguous (name vs any other name during import resolution)\n-  --> $DIR/derive-helper-shadowing.rs:24:13\n+  --> $DIR/derive-helper-shadowing.rs:26:13\n    |\n LL |         use empty_helper;\n    |             ^^^^^^^^^^^^ ambiguous name\n    |\n note: `empty_helper` could refer to the derive helper attribute defined here\n-  --> $DIR/derive-helper-shadowing.rs:20:10\n+  --> $DIR/derive-helper-shadowing.rs:22:10\n    |\n LL | #[derive(Empty)]\n    |          ^^^^^\n@@ -54,7 +54,7 @@ LL | #[empty_helper]\n    |   ^^^^^^^^^^^^ ambiguous name\n    |\n note: `empty_helper` could refer to the derive helper attribute defined here\n-  --> $DIR/derive-helper-shadowing.rs:20:10\n+  --> $DIR/derive-helper-shadowing.rs:22:10\n    |\n LL | #[derive(Empty)]\n    |          ^^^^^\n@@ -65,6 +65,19 @@ LL | use test_macros::empty_attr as empty_helper;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: use `crate::empty_helper` to refer to this attribute macro unambiguously\n \n-error: aborting due to 5 previous errors\n+warning: derive helper attribute is used before it is introduced\n+  --> $DIR/derive-helper-shadowing.rs:19:3\n+   |\n+LL | #[empty_helper]\n+   |   ^^^^^^^^^^^^\n+...\n+LL | #[derive(Empty)]\n+   |          ----- the attribute is introduced here\n+   |\n+   = note: `#[warn(legacy_derive_helpers)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #79202 <https://github.com/rust-lang/rust/issues/79202>\n+\n+error: aborting due to 5 previous errors; 1 warning emitted\n \n For more information about this error, try `rustc --explain E0659`."}, {"sha": "98836bcb8937de08ffe6c51fc97f76d4ea637e63", "filename": "src/test/ui/proc-macro/derive-helper-vs-legacy.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-vs-legacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-vs-legacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-vs-legacy.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -0,0 +1,12 @@\n+// check-pass\n+// aux-build:test-macros.rs\n+\n+#[macro_use]\n+extern crate test_macros;\n+\n+#[derive(Empty)]\n+#[empty_helper] // OK, this is both derive helper and legacy derive helper\n+#[derive(Empty)]\n+struct S;\n+\n+fn main() {}"}, {"sha": "23578aa0e9fb8b2932e33e9901b634a7315e1688", "filename": "src/test/ui/proc-macro/derive-multiple-with-packed.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fderive-multiple-with-packed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fderive-multiple-with-packed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-multiple-with-packed.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+\n+#[derive(Clone, Copy)]\n+#[derive(Debug)] // OK, even if `Copy` is in the different `#[derive]`\n+#[derive(PartialEq)] // OK too\n+#[repr(packed)]\n+struct CacheRecordHeader {\n+    field: u64,\n+}\n+\n+fn main() {}"}, {"sha": "40c42d82f68de9e9c338157f857c197d1eeaaeb6", "filename": "src/test/ui/proc-macro/helper-attr-blocked-by-import-ambig.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fhelper-attr-blocked-by-import-ambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fhelper-attr-blocked-by-import-ambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fhelper-attr-blocked-by-import-ambig.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -4,8 +4,10 @@\n extern crate test_macros;\n use test_macros::empty_attr as empty_helper;\n \n-#[derive(Empty)]\n #[empty_helper] //~ ERROR `empty_helper` is ambiguous\n+                //~| WARN derive helper attribute is used before it is introduced\n+                //~| WARN this was previously accepted\n+#[derive(Empty)]\n struct S;\n \n fn main() {}"}, {"sha": "ceb6d789785cc1b39548266c2407c9f4d8cdd51d", "filename": "src/test/ui/proc-macro/helper-attr-blocked-by-import-ambig.stderr", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fhelper-attr-blocked-by-import-ambig.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fhelper-attr-blocked-by-import-ambig.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fhelper-attr-blocked-by-import-ambig.stderr?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -1,11 +1,11 @@\n error[E0659]: `empty_helper` is ambiguous (derive helper attribute vs any other name)\n-  --> $DIR/helper-attr-blocked-by-import-ambig.rs:8:3\n+  --> $DIR/helper-attr-blocked-by-import-ambig.rs:7:3\n    |\n LL | #[empty_helper]\n    |   ^^^^^^^^^^^^ ambiguous name\n    |\n note: `empty_helper` could refer to the derive helper attribute defined here\n-  --> $DIR/helper-attr-blocked-by-import-ambig.rs:7:10\n+  --> $DIR/helper-attr-blocked-by-import-ambig.rs:10:10\n    |\n LL | #[derive(Empty)]\n    |          ^^^^^\n@@ -16,6 +16,19 @@ LL | use test_macros::empty_attr as empty_helper;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: use `crate::empty_helper` to refer to this attribute macro unambiguously\n \n-error: aborting due to previous error\n+warning: derive helper attribute is used before it is introduced\n+  --> $DIR/helper-attr-blocked-by-import-ambig.rs:7:3\n+   |\n+LL | #[empty_helper]\n+   |   ^^^^^^^^^^^^\n+...\n+LL | #[derive(Empty)]\n+   |          ----- the attribute is introduced here\n+   |\n+   = note: `#[warn(legacy_derive_helpers)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #79202 <https://github.com/rust-lang/rust/issues/79202>\n+\n+error: aborting due to previous error; 1 warning emitted\n \n For more information about this error, try `rustc --explain E0659`."}, {"sha": "649e731840337ce13991b56547694318df5d0053", "filename": "src/test/ui/proc-macro/issue-75930-derive-cfg.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fissue-75930-derive-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fissue-75930-derive-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fissue-75930-derive-cfg.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -13,7 +13,8 @@\n #[macro_use]\n extern crate test_macros;\n \n-#[print_helper(a)]\n+#[print_helper(a)] //~ WARN derive helper attribute is used before it is introduced\n+                   //~| WARN this was previously accepted\n #[cfg_attr(not(FALSE), allow(dead_code))]\n #[print_attr]\n #[derive(Print)]"}, {"sha": "5227da7d766770edeef371b067fff5ac2d05b3b9", "filename": "src/test/ui/proc-macro/issue-75930-derive-cfg.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fissue-75930-derive-cfg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fissue-75930-derive-cfg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fissue-75930-derive-cfg.stderr?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -0,0 +1,15 @@\n+warning: derive helper attribute is used before it is introduced\n+  --> $DIR/issue-75930-derive-cfg.rs:16:3\n+   |\n+LL | #[print_helper(a)]\n+   |   ^^^^^^^^^^^^\n+...\n+LL | #[derive(Print)]\n+   |          ----- the attribute is introduced here\n+   |\n+   = note: `#[warn(legacy_derive_helpers)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #79202 <https://github.com/rust-lang/rust/issues/79202>\n+\n+warning: 1 warning emitted\n+"}, {"sha": "19aa4dfb60e362e8ad8faf8847f137232beb4f4f", "filename": "src/test/ui/proc-macro/issue-75930-derive-cfg.stdout", "status": "modified", "additions": 364, "deletions": 364, "changes": 728, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fissue-75930-derive-cfg.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fissue-75930-derive-cfg.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fissue-75930-derive-cfg.stdout?ref=9778068cbc1e06cc3685422323ff38a2f397de26"}, {"sha": "8d96381b9bdffe2e0776d3039d5428926409b2e4", "filename": "src/test/ui/proc-macro/proc-macro-attributes.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-attributes.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -4,10 +4,18 @@\n extern crate derive_b;\n \n #[B] //~ ERROR `B` is ambiguous\n+     //~| WARN derive helper attribute is used before it is introduced\n+     //~| WARN this was previously accepted\n #[C] //~ ERROR cannot find attribute `C` in this scope\n #[B(D)] //~ ERROR `B` is ambiguous\n+        //~| WARN derive helper attribute is used before it is introduced\n+        //~| WARN this was previously accepted\n #[B(E = \"foo\")] //~ ERROR `B` is ambiguous\n+                //~| WARN derive helper attribute is used before it is introduced\n+                //~| WARN this was previously accepted\n #[B(arbitrary tokens)] //~ ERROR `B` is ambiguous\n+                       //~| WARN derive helper attribute is used before it is introduced\n+                       //~| WARN this was previously accepted\n #[derive(B)]\n struct B;\n "}, {"sha": "1ba04258df0d53c942a78c1e33d5d6f073897c8d", "filename": "src/test/ui/proc-macro/proc-macro-attributes.stderr", "status": "modified", "additions": 58, "deletions": 9, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-attributes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-attributes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-attributes.stderr?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -1,5 +1,5 @@\n error: cannot find attribute `C` in this scope\n-  --> $DIR/proc-macro-attributes.rs:7:3\n+  --> $DIR/proc-macro-attributes.rs:9:3\n    |\n LL | #[C]\n    |   ^ help: a derive helper attribute with a similar name exists: `B`\n@@ -11,7 +11,7 @@ LL | #[B]\n    |   ^ ambiguous name\n    |\n note: `B` could refer to the derive helper attribute defined here\n-  --> $DIR/proc-macro-attributes.rs:11:10\n+  --> $DIR/proc-macro-attributes.rs:19:10\n    |\n LL | #[derive(B)]\n    |          ^\n@@ -22,13 +22,13 @@ LL | #[macro_use]\n    | ^^^^^^^^^^^^\n \n error[E0659]: `B` is ambiguous (derive helper attribute vs any other name)\n-  --> $DIR/proc-macro-attributes.rs:8:3\n+  --> $DIR/proc-macro-attributes.rs:10:3\n    |\n LL | #[B(D)]\n    |   ^ ambiguous name\n    |\n note: `B` could refer to the derive helper attribute defined here\n-  --> $DIR/proc-macro-attributes.rs:11:10\n+  --> $DIR/proc-macro-attributes.rs:19:10\n    |\n LL | #[derive(B)]\n    |          ^\n@@ -39,13 +39,13 @@ LL | #[macro_use]\n    | ^^^^^^^^^^^^\n \n error[E0659]: `B` is ambiguous (derive helper attribute vs any other name)\n-  --> $DIR/proc-macro-attributes.rs:9:3\n+  --> $DIR/proc-macro-attributes.rs:13:3\n    |\n LL | #[B(E = \"foo\")]\n    |   ^ ambiguous name\n    |\n note: `B` could refer to the derive helper attribute defined here\n-  --> $DIR/proc-macro-attributes.rs:11:10\n+  --> $DIR/proc-macro-attributes.rs:19:10\n    |\n LL | #[derive(B)]\n    |          ^\n@@ -56,13 +56,13 @@ LL | #[macro_use]\n    | ^^^^^^^^^^^^\n \n error[E0659]: `B` is ambiguous (derive helper attribute vs any other name)\n-  --> $DIR/proc-macro-attributes.rs:10:3\n+  --> $DIR/proc-macro-attributes.rs:16:3\n    |\n LL | #[B(arbitrary tokens)]\n    |   ^ ambiguous name\n    |\n note: `B` could refer to the derive helper attribute defined here\n-  --> $DIR/proc-macro-attributes.rs:11:10\n+  --> $DIR/proc-macro-attributes.rs:19:10\n    |\n LL | #[derive(B)]\n    |          ^\n@@ -72,6 +72,55 @@ note: `B` could also refer to the derive macro imported here\n LL | #[macro_use]\n    | ^^^^^^^^^^^^\n \n-error: aborting due to 5 previous errors\n+warning: derive helper attribute is used before it is introduced\n+  --> $DIR/proc-macro-attributes.rs:6:3\n+   |\n+LL | #[B]\n+   |   ^\n+...\n+LL | #[derive(B)]\n+   |          - the attribute is introduced here\n+   |\n+   = note: `#[warn(legacy_derive_helpers)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #79202 <https://github.com/rust-lang/rust/issues/79202>\n+\n+warning: derive helper attribute is used before it is introduced\n+  --> $DIR/proc-macro-attributes.rs:10:3\n+   |\n+LL | #[B(D)]\n+   |   ^\n+...\n+LL | #[derive(B)]\n+   |          - the attribute is introduced here\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #79202 <https://github.com/rust-lang/rust/issues/79202>\n+\n+warning: derive helper attribute is used before it is introduced\n+  --> $DIR/proc-macro-attributes.rs:13:3\n+   |\n+LL | #[B(E = \"foo\")]\n+   |   ^\n+...\n+LL | #[derive(B)]\n+   |          - the attribute is introduced here\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #79202 <https://github.com/rust-lang/rust/issues/79202>\n+\n+warning: derive helper attribute is used before it is introduced\n+  --> $DIR/proc-macro-attributes.rs:16:3\n+   |\n+LL | #[B(arbitrary tokens)]\n+   |   ^\n+...\n+LL | #[derive(B)]\n+   |          - the attribute is introduced here\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #79202 <https://github.com/rust-lang/rust/issues/79202>\n+\n+error: aborting due to 5 previous errors; 4 warnings emitted\n \n For more information about this error, try `rustc --explain E0659`."}, {"sha": "c5e71a87dfbe8bf1ff124f2bf91097a22805dd6f", "filename": "src/test/ui/proc-macro/reserved-macro-names.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Freserved-macro-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Freserved-macro-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Freserved-macro-names.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -17,9 +17,3 @@ pub fn cfg_attr(_: TokenStream, input: TokenStream) -> TokenStream {\n     //~^ ERROR name `cfg_attr` is reserved in attribute namespace\n     input\n }\n-\n-#[proc_macro_attribute]\n-pub fn derive(_: TokenStream, input: TokenStream) -> TokenStream {\n-    //~^ ERROR name `derive` is reserved in attribute namespace\n-    input\n-}"}, {"sha": "39bdd03be863a21e9bd370697adef9f320952bcb", "filename": "src/test/ui/proc-macro/reserved-macro-names.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Freserved-macro-names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fproc-macro%2Freserved-macro-names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Freserved-macro-names.stderr?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -10,11 +10,5 @@ error: name `cfg_attr` is reserved in attribute namespace\n LL | pub fn cfg_attr(_: TokenStream, input: TokenStream) -> TokenStream {\n    |        ^^^^^^^^\n \n-error: name `derive` is reserved in attribute namespace\n-  --> $DIR/reserved-macro-names.rs:22:8\n-   |\n-LL | pub fn derive(_: TokenStream, input: TokenStream) -> TokenStream {\n-   |        ^^^^^^\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n "}, {"sha": "840c12e16e1c8dfbb692f3647d0a9eecb21861cd", "filename": "src/test/ui/span/issue-43927-non-ADT-derive.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fspan%2Fissue-43927-non-ADT-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fspan%2Fissue-43927-non-ADT-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-43927-non-ADT-derive.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -1,10 +1,5 @@\n-#![allow(dead_code)]\n-\n #![derive(Debug, PartialEq, Eq)] // should be an outer attribute!\n-//~^ ERROR `derive` may only be applied to structs, enums and unions\n-//~| ERROR cannot determine resolution for the derive macro `Debug`\n-//~| ERROR cannot determine resolution for the derive macro `PartialEq`\n-//~| ERROR cannot determine resolution for the derive macro `Eq`\n+//~^ ERROR cannot determine resolution for the attribute macro `derive`\n struct DerivedOn;\n \n fn main() {}"}, {"sha": "9ef81c5150a45011bb71c8aee941f02185523450", "filename": "src/test/ui/span/issue-43927-non-ADT-derive.stderr", "status": "modified", "additions": 4, "deletions": 27, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fspan%2Fissue-43927-non-ADT-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fspan%2Fissue-43927-non-ADT-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-43927-non-ADT-derive.stderr?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -1,33 +1,10 @@\n-error[E0774]: `derive` may only be applied to structs, enums and unions\n-  --> $DIR/issue-43927-non-ADT-derive.rs:3:1\n+error: cannot determine resolution for the attribute macro `derive`\n+  --> $DIR/issue-43927-non-ADT-derive.rs:1:4\n    |\n LL | #![derive(Debug, PartialEq, Eq)] // should be an outer attribute!\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try an outer attribute: `#[derive(Debug, PartialEq, Eq)]`\n-\n-error: cannot determine resolution for the derive macro `Debug`\n-  --> $DIR/issue-43927-non-ADT-derive.rs:3:11\n-   |\n-LL | #![derive(Debug, PartialEq, Eq)] // should be an outer attribute!\n-   |           ^^^^^\n-   |\n-   = note: import resolution is stuck, try simplifying macro imports\n-\n-error: cannot determine resolution for the derive macro `PartialEq`\n-  --> $DIR/issue-43927-non-ADT-derive.rs:3:18\n-   |\n-LL | #![derive(Debug, PartialEq, Eq)] // should be an outer attribute!\n-   |                  ^^^^^^^^^\n-   |\n-   = note: import resolution is stuck, try simplifying macro imports\n-\n-error: cannot determine resolution for the derive macro `Eq`\n-  --> $DIR/issue-43927-non-ADT-derive.rs:3:29\n-   |\n-LL | #![derive(Debug, PartialEq, Eq)] // should be an outer attribute!\n-   |                             ^^\n+   |    ^^^^^^\n    |\n    = note: import resolution is stuck, try simplifying macro imports\n \n-error: aborting due to 4 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0774`."}, {"sha": "0a93105b6647784ab82818a8d475e59a929b1870", "filename": "src/test/ui/span/macro-ty-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -9,5 +9,5 @@ macro_rules! foo { () => () }\n fn main() {\n     foo::<T>!(); //~ ERROR generic arguments in macro path\n     foo::<>!(); //~ ERROR generic arguments in macro path\n-    m!(Default<>); //~ ERROR generic arguments in macro path\n+    m!(Default<>); //~ ERROR unexpected generic arguments in path\n }"}, {"sha": "138cd2598a1c5f7ab38ec6558d6925086f87f591", "filename": "src/test/ui/span/macro-ty-params.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.stderr?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -10,7 +10,7 @@ error: generic arguments in macro path\n LL |     foo::<>!();\n    |          ^^\n \n-error: generic arguments in macro path\n+error: unexpected generic arguments in path\n   --> $DIR/macro-ty-params.rs:12:15\n    |\n LL |     m!(Default<>);"}]}