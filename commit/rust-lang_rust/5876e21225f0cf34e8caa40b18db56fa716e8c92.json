{"sha": "5876e21225f0cf34e8caa40b18db56fa716e8c92", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4NzZlMjEyMjVmMGNmMzRlOGNhYTQwYjE4ZGI1NmZhNzE2ZThjOTI=", "commit": {"author": {"name": "Jason Toffaletti", "email": "jason@topsy.com", "date": "2013-10-07T07:07:04Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-10-26T01:27:45Z"}, "message": "add multi-producer multi-consumer bounded queue to use for sleeper list", "tree": {"sha": "1b5e39fbb2954395ae992af93d4fd6501b644071", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b5e39fbb2954395ae992af93d4fd6501b644071"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5876e21225f0cf34e8caa40b18db56fa716e8c92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5876e21225f0cf34e8caa40b18db56fa716e8c92", "html_url": "https://github.com/rust-lang/rust/commit/5876e21225f0cf34e8caa40b18db56fa716e8c92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5876e21225f0cf34e8caa40b18db56fa716e8c92/comments", "author": {"login": "toffaletti", "id": 145012, "node_id": "MDQ6VXNlcjE0NTAxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/145012?v=4", "gravatar_id": "", "url": "https://api.github.com/users/toffaletti", "html_url": "https://github.com/toffaletti", "followers_url": "https://api.github.com/users/toffaletti/followers", "following_url": "https://api.github.com/users/toffaletti/following{/other_user}", "gists_url": "https://api.github.com/users/toffaletti/gists{/gist_id}", "starred_url": "https://api.github.com/users/toffaletti/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/toffaletti/subscriptions", "organizations_url": "https://api.github.com/users/toffaletti/orgs", "repos_url": "https://api.github.com/users/toffaletti/repos", "events_url": "https://api.github.com/users/toffaletti/events{/privacy}", "received_events_url": "https://api.github.com/users/toffaletti/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf0e6eb346665d779ad012f7def9b4948c5c6b26", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf0e6eb346665d779ad012f7def9b4948c5c6b26", "html_url": "https://github.com/rust-lang/rust/commit/bf0e6eb346665d779ad012f7def9b4948c5c6b26"}], "stats": {"total": 267, "additions": 211, "deletions": 56}, "files": [{"sha": "d87580c83bfdbb866853a08264b48cd14ade1596", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5876e21225f0cf34e8caa40b18db56fa716e8c92/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5876e21225f0cf34e8caa40b18db56fa716e8c92/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=5876e21225f0cf34e8caa40b18db56fa716e8c92", "patch": "@@ -139,6 +139,9 @@ mod message_queue;\n /// A mostly lock-free multi-producer, single consumer queue.\n mod mpsc_queue;\n \n+/// A lock-free multi-producer, multi-consumer bounded queue.\n+mod mpmc_bounded_queue;\n+\n /// A parallel data structure for tracking sleeping schedulers.\n mod sleeper_list;\n "}, {"sha": "8e6ac8f79c71786299b64d8d2f96c8ac756b89bf", "filename": "src/libstd/rt/mpmc_bounded_queue.rs", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/5876e21225f0cf34e8caa40b18db56fa716e8c92/src%2Flibstd%2Frt%2Fmpmc_bounded_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5876e21225f0cf34e8caa40b18db56fa716e8c92/src%2Flibstd%2Frt%2Fmpmc_bounded_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmpmc_bounded_queue.rs?ref=5876e21225f0cf34e8caa40b18db56fa716e8c92", "patch": "@@ -0,0 +1,199 @@\n+/* Multi-producer/multi-consumer bounded queue\n+ * Copyright (c) 2010-2011 Dmitry Vyukov. All rights reserved.\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ * \n+ *    1. Redistributions of source code must retain the above copyright notice,\n+ *       this list of conditions and the following disclaimer.\n+ * \n+ *    2. Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY DMITRY VYUKOV \"AS IS\" AND ANY EXPRESS OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT\n+ * SHALL DMITRY VYUKOV OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ * The views and conclusions contained in the software and documentation are\n+ * those of the authors and should not be interpreted as representing official\n+ * policies, either expressed or implied, of Dmitry Vyukov.\n+ */\n+\n+use unstable::sync::UnsafeArc;\n+use unstable::atomics::{AtomicUint,Relaxed,Release,Acquire};\n+use option::*;\n+use vec;\n+use clone::Clone;\n+use kinds::Send;\n+use num::{Exponential,Algebraic,Round};\n+\n+struct Node<T> {\n+    sequence: AtomicUint,\n+    value: Option<T>,\n+}\n+\n+struct State<T> {\n+    buffer: ~[Node<T>],\n+    mask: uint,\n+    enqueue_pos: AtomicUint,\n+    dequeue_pos: AtomicUint,\n+}\n+\n+struct Queue<T> {\n+    priv state: UnsafeArc<State<T>>,\n+}\n+\n+impl<T: Send> State<T> {\n+    fn with_capacity(capacity: uint) -> State<T> {\n+        let capacity = if capacity < 2 || (capacity & (capacity - 1)) != 0 {\n+            // use next power of 2 as capacity\n+            2f64.pow(&((capacity as f64).log2().floor()+1f64)) as uint\n+        } else {\n+            capacity\n+        };\n+        let buffer = do vec::from_fn(capacity) |i:uint| {\n+            Node{sequence:AtomicUint::new(i),value:None}\n+        };\n+        State{\n+            buffer: buffer,\n+            mask: capacity-1,\n+            enqueue_pos: AtomicUint::new(0),\n+            dequeue_pos: AtomicUint::new(0),\n+        }\n+    }\n+\n+    fn push(&mut self, value: T) -> bool {\n+        let mask = self.mask;\n+        let mut pos = self.enqueue_pos.load(Relaxed);\n+        loop {\n+            let node = &mut self.buffer[pos & mask];\n+            let seq = node.sequence.load(Acquire);\n+            let diff: int = seq as int - pos as int;\n+\n+            if diff == 0 {\n+                let enqueue_pos = self.enqueue_pos.compare_and_swap(pos, pos+1, Relaxed);\n+                if enqueue_pos == pos {\n+                    node.value = Some(value);\n+                    node.sequence.store(pos+1, Release);\n+                    break\n+                } else {\n+                    pos = enqueue_pos;\n+                }\n+            } else if (diff < 0) {\n+                return false\n+            } else {\n+                pos = self.enqueue_pos.load(Relaxed);\n+            }\n+        }\n+        true\n+    }\n+\n+    fn pop(&mut self) -> Option<T> {\n+        let mask = self.mask;\n+        let mut pos = self.dequeue_pos.load(Relaxed);\n+        loop {\n+            let node = &mut self.buffer[pos & mask];\n+            let seq = node.sequence.load(Acquire);\n+            let diff: int = seq as int - (pos + 1) as int;\n+            if diff == 0 {\n+                let dequeue_pos = self.dequeue_pos.compare_and_swap(pos, pos+1, Relaxed);\n+                if dequeue_pos == pos {\n+                    let value = node.value.take();\n+                    node.sequence.store(pos + mask + 1, Release);\n+                    return value\n+                } else {\n+                    pos = dequeue_pos;\n+                }\n+            } else if diff < 0 {\n+                return None\n+            } else {\n+                pos = self.dequeue_pos.load(Relaxed);\n+            }\n+        }\n+    }\n+}\n+\n+impl<T: Send> Queue<T> {\n+    pub fn with_capacity(capacity: uint) -> Queue<T> {\n+        Queue{\n+            state: UnsafeArc::new(State::with_capacity(capacity))\n+        }\n+    }\n+\n+    pub fn push(&mut self, value: T) -> bool {\n+        unsafe { (*self.state.get()).push(value) }\n+    }\n+\n+    pub fn pop(&mut self) -> Option<T> {\n+        unsafe { (*self.state.get()).pop() }\n+    }\n+}\n+\n+impl<T: Send> Clone for Queue<T> {\n+    fn clone(&self) -> Queue<T> {\n+        Queue {\n+            state: self.state.clone()\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::*;\n+    use option::*;\n+    use task;\n+    use comm;\n+    use super::Queue;\n+\n+    #[test]\n+    fn test() {\n+        let nthreads = 8u;\n+        let nmsgs = 1000u;\n+        let mut q = Queue::with_capacity(nthreads*nmsgs);\n+        assert_eq!(None, q.pop());\n+\n+        for _ in range(0, nthreads) {\n+            let (port, chan)  = comm::stream();\n+            chan.send(q.clone());\n+            do task::spawn_sched(task::SingleThreaded) {\n+                let mut q = port.recv();\n+                for i in range(0, nmsgs) {\n+                    assert!(q.push(i));\n+                }\n+            }\n+        }\n+\n+        let mut completion_ports = ~[];\n+        for _ in range(0, nthreads) {\n+            let (completion_port, completion_chan) = comm::stream();\n+            completion_ports.push(completion_port);\n+            let (port, chan)  = comm::stream();\n+            chan.send(q.clone());\n+            do task::spawn_sched(task::SingleThreaded) {\n+                let mut q = port.recv();\n+                let mut i = 0u;\n+                loop {\n+                    match q.pop() {\n+                        None => {},\n+                        Some(_) => {\n+                            i += 1;\n+                            if i == nmsgs { break }\n+                        }\n+                    }\n+                }\n+                completion_chan.send(i);\n+            }\n+        }\n+\n+        for completion_port in completion_ports.iter() {\n+            assert_eq!(nmsgs, completion_port.recv());\n+        }\n+    }\n+}"}, {"sha": "39c7431837f6eed810594a59217f4eaf34b2eb25", "filename": "src/libstd/rt/sleeper_list.rs", "status": "modified", "additions": 9, "deletions": 56, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/5876e21225f0cf34e8caa40b18db56fa716e8c92/src%2Flibstd%2Frt%2Fsleeper_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5876e21225f0cf34e8caa40b18db56fa716e8c92/src%2Flibstd%2Frt%2Fsleeper_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsleeper_list.rs?ref=5876e21225f0cf34e8caa40b18db56fa716e8c92", "patch": "@@ -11,84 +11,37 @@\n //! Maintains a shared list of sleeping schedulers. Schedulers\n //! use this to wake each other up.\n \n-use container::Container;\n-use vec::OwnedVector;\n-use option::{Option, Some, None};\n-use cell::Cell;\n-use unstable::sync::{UnsafeArc, LittleLock};\n use rt::sched::SchedHandle;\n+use rt::mpmc_bounded_queue::Queue;\n+use option::*;\n use clone::Clone;\n \n pub struct SleeperList {\n-    priv state: UnsafeArc<State>\n-}\n-\n-struct State {\n-    count: uint,\n-    stack: ~[SchedHandle],\n-    lock: LittleLock\n+    priv q: Queue<SchedHandle>,\n }\n \n impl SleeperList {\n     pub fn new() -> SleeperList {\n-        SleeperList {\n-            state: UnsafeArc::new(State {\n-                count: 0,\n-                stack: ~[],\n-                lock: LittleLock::new()\n-            })\n-        }\n+        SleeperList{q: Queue::with_capacity(8*1024)}\n     }\n \n-    pub fn push(&mut self, handle: SchedHandle) {\n-        let handle = Cell::new(handle);\n-        unsafe {\n-            let state = self.state.get();\n-            do (*state).lock.lock {\n-                (*state).count += 1;\n-                (*state).stack.push(handle.take());\n-            }\n-        }\n+    pub fn push(&mut self, value: SchedHandle) {\n+        assert!(self.q.push(value))\n     }\n \n     pub fn pop(&mut self) -> Option<SchedHandle> {\n-        unsafe {\n-            let state = self.state.get();\n-            do (*state).lock.lock {\n-                if !(*state).stack.is_empty() {\n-                    (*state).count -= 1;\n-                    Some((*state).stack.pop())\n-                } else {\n-                    None\n-                }\n-            }\n-        }\n+        self.q.pop()\n     }\n \n-    /// A pop that may sometimes miss enqueued elements, but is much faster\n-    /// to give up without doing any synchronization\n     pub fn casual_pop(&mut self) -> Option<SchedHandle> {\n-        unsafe {\n-            let state = self.state.get();\n-            // NB: Unsynchronized check\n-            if (*state).count == 0 { return None; }\n-            do (*state).lock.lock {\n-                if !(*state).stack.is_empty() {\n-                    // NB: count is also protected by the lock\n-                    (*state).count -= 1;\n-                    Some((*state).stack.pop())\n-                } else {\n-                    None\n-                }\n-            }\n-        }\n+        self.q.pop()\n     }\n }\n \n impl Clone for SleeperList {\n     fn clone(&self) -> SleeperList {\n         SleeperList {\n-            state: self.state.clone()\n+            q: self.q.clone()\n         }\n     }\n }"}]}