{"sha": "cd6921923c107781abd815f3e5ed6f9540a3ab73", "node_id": "C_kwDOAAsO6NoAKGNkNjkyMTkyM2MxMDc3ODFhYmQ4MTVmM2U1ZWQ2Zjk1NDBhM2FiNzM", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2021-12-19T23:45:56Z"}, "committer": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2021-12-21T17:15:29Z"}, "message": "Provide better notes when tracking a pointer tag", "tree": {"sha": "8f193440a4d4722ee19e96c87b3832e4cb603184", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f193440a4d4722ee19e96c87b3832e4cb603184"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd6921923c107781abd815f3e5ed6f9540a3ab73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd6921923c107781abd815f3e5ed6f9540a3ab73", "html_url": "https://github.com/rust-lang/rust/commit/cd6921923c107781abd815f3e5ed6f9540a3ab73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd6921923c107781abd815f3e5ed6f9540a3ab73/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e969615937e9fdb7d293206e19f425b6184450de", "url": "https://api.github.com/repos/rust-lang/rust/commits/e969615937e9fdb7d293206e19f425b6184450de", "html_url": "https://github.com/rust-lang/rust/commit/e969615937e9fdb7d293206e19f425b6184450de"}], "stats": {"total": 39, "additions": 31, "deletions": 8}, "files": [{"sha": "a28418e74905694250740d040abd555ff9219160", "filename": "src/diagnostics.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cd6921923c107781abd815f3e5ed6f9540a3ab73/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6921923c107781abd815f3e5ed6f9540a3ab73/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=cd6921923c107781abd815f3e5ed6f9540a3ab73", "patch": "@@ -7,6 +7,7 @@ use log::trace;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::{source_map::DUMMY_SP, Span, SpanData, Symbol};\n \n+use crate::stacked_borrows::{AccessKind, SbTag};\n use crate::*;\n \n /// Details of premature program termination.\n@@ -58,7 +59,9 @@ impl MachineStopType for TerminationInfo {}\n /// Miri specific diagnostics\n pub enum NonHaltingDiagnostic {\n     CreatedPointerTag(NonZeroU64),\n-    PoppedPointerTag(Item),\n+    /// This `Item` was popped from the borrow stack, either due to a grant of\n+    /// `AccessKind` to `SbTag` or a deallocation when the second argument is `None`.\n+    PoppedPointerTag(Item, Option<(SbTag, AccessKind)>),\n     CreatedCallId(CallId),\n     CreatedAlloc(AllocId),\n     FreedAlloc(AllocId),\n@@ -321,7 +324,20 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 use NonHaltingDiagnostic::*;\n                 let msg = match e {\n                     CreatedPointerTag(tag) => format!(\"created tag {:?}\", tag),\n-                    PoppedPointerTag(item) => format!(\"popped tracked tag for item {:?}\", item),\n+                    PoppedPointerTag(item, tag) =>\n+                        match tag {\n+                            None =>\n+                                format!(\n+                                    \"popped tracked tag for item {:?} due to deallocation\",\n+                                    item\n+                                ),\n+                            Some((tag, access)) => {\n+                                format!(\n+                                    \"popped tracked tag for item {:?} due to {:?} access for {:?}\",\n+                                    item, access, tag\n+                                )\n+                            }\n+                        },\n                     CreatedCallId(id) => format!(\"function call with id {}\", id),\n                     CreatedAlloc(AllocId(id)) => format!(\"created allocation with id {}\", id),\n                     FreedAlloc(AllocId(id)) => format!(\"freed allocation with id {}\", id),"}, {"sha": "2919ce919aa47299139a00dd7a071168db726241", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cd6921923c107781abd815f3e5ed6f9540a3ab73/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6921923c107781abd815f3e5ed6f9540a3ab73/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=cd6921923c107781abd815f3e5ed6f9540a3ab73", "patch": "@@ -111,7 +111,7 @@ pub struct GlobalState {\n pub type MemoryExtra = RefCell<GlobalState>;\n \n /// Indicates which kind of access is being performed.\n-#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]\n pub enum AccessKind {\n     Read,\n     Write,\n@@ -296,19 +296,26 @@ impl<'tcx> Stack {\n     }\n \n     /// Check if the given item is protected.\n+    ///\n+    /// The `provoking_access` argument is only used to produce diagnostics.\n+    /// It is `Some` when we are granting the contained access for said tag, and it is\n+    /// `None` during a deallocation.\n     fn check_protector(\n         item: &Item,\n-        tag: Option<SbTag>,\n+        provoking_access: Option<(SbTag, AccessKind)>,\n         global: &GlobalState,\n     ) -> InterpResult<'tcx> {\n         if let SbTag::Tagged(id) = item.tag {\n             if Some(id) == global.tracked_pointer_tag {\n-                register_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(item.clone()));\n+                register_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(\n+                    item.clone(),\n+                    provoking_access,\n+                ));\n             }\n         }\n         if let Some(call) = item.protector {\n             if global.is_active(call) {\n-                if let Some(tag) = tag {\n+                if let Some((tag, _)) = provoking_access {\n                     Err(err_sb_ub(format!(\n                         \"not granting access to tag {:?} because incompatible item is protected: {:?}\",\n                         tag, item\n@@ -348,7 +355,7 @@ impl<'tcx> Stack {\n             let first_incompatible_idx = self.find_first_write_incompatible(granting_idx);\n             for item in self.borrows.drain(first_incompatible_idx..).rev() {\n                 trace!(\"access: popping item {:?}\", item);\n-                Stack::check_protector(&item, Some(tag), global)?;\n+                Stack::check_protector(&item, Some((tag, access)), global)?;\n             }\n         } else {\n             // On a read, *disable* all `Unique` above the granting item.  This ensures U2 for read accesses.\n@@ -363,7 +370,7 @@ impl<'tcx> Stack {\n                 let item = &mut self.borrows[idx];\n                 if item.perm == Permission::Unique {\n                     trace!(\"access: disabling item {:?}\", item);\n-                    Stack::check_protector(item, Some(tag), global)?;\n+                    Stack::check_protector(item, Some((tag, access)), global)?;\n                     item.perm = Permission::Disabled;\n                 }\n             }"}]}