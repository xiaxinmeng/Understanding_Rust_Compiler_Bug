{"sha": "9272942b92c069df9421ce5a2073913711ec7a7c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyNzI5NDJiOTJjMDY5ZGY5NDIxY2U1YTIwNzM5MTM3MTFlYzdhN2M=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-09T12:56:49Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-09T13:51:07Z"}, "message": "Use `CoerceMany` in `BreakableContext`", "tree": {"sha": "fe944fb3255caefbe276b6ff129a30ea252239ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe944fb3255caefbe276b6ff129a30ea252239ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9272942b92c069df9421ce5a2073913711ec7a7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9272942b92c069df9421ce5a2073913711ec7a7c", "html_url": "https://github.com/rust-lang/rust/commit/9272942b92c069df9421ce5a2073913711ec7a7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9272942b92c069df9421ce5a2073913711ec7a7c/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e968d834caad94069d863f44f90dc5872de29941", "url": "https://api.github.com/repos/rust-lang/rust/commits/e968d834caad94069d863f44f90dc5872de29941", "html_url": "https://github.com/rust-lang/rust/commit/e968d834caad94069d863f44f90dc5872de29941"}], "stats": {"total": 62, "additions": 26, "deletions": 36}, "files": [{"sha": "b1c0432273de9c74bd1bee1007e7aa6025640a4f", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9272942b92c069df9421ce5a2073913711ec7a7c/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9272942b92c069df9421ce5a2073913711ec7a7c/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=9272942b92c069df9421ce5a2073913711ec7a7c", "patch": "@@ -35,9 +35,9 @@ use stdx::impl_from;\n use syntax::SmolStr;\n \n use crate::{\n-    db::HirDatabase, fold_tys, lower::ImplTraitLoweringMode, to_assoc_type_id, AliasEq, AliasTy,\n-    DomainGoal, Goal, InEnvironment, Interner, ProjectionTy, Substitution, TraitEnvironment,\n-    TraitRef, Ty, TyBuilder, TyExt, TyKind,\n+    db::HirDatabase, fold_tys, infer::coerce::CoerceMany, lower::ImplTraitLoweringMode,\n+    to_assoc_type_id, AliasEq, AliasTy, DomainGoal, Goal, InEnvironment, Interner, ProjectionTy,\n+    Substitution, TraitEnvironment, TraitRef, Ty, TyBuilder, TyExt, TyKind,\n };\n \n // This lint has a false positive here. See the link below for details.\n@@ -349,7 +349,7 @@ struct InferenceContext<'a> {\n #[derive(Clone, Debug)]\n struct BreakableContext {\n     may_break: bool,\n-    break_ty: Ty,\n+    coerce: CoerceMany,\n     label: Option<name::Name>,\n }\n "}, {"sha": "2599a8c6b1c118936d406d9bafcbb4d3c4935c8e", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9272942b92c069df9421ce5a2073913711ec7a7c/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9272942b92c069df9421ce5a2073913711ec7a7c/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=9272942b92c069df9421ce5a2073913711ec7a7c", "patch": "@@ -48,17 +48,6 @@ impl CoerceMany {\n         CoerceMany { expected_ty: expected }\n     }\n \n-    pub(super) fn once(\n-        ctx: &mut InferenceContext<'_>,\n-        expected: Ty,\n-        expr: Option<ExprId>,\n-        expr_ty: &Ty,\n-    ) -> Ty {\n-        let mut this = CoerceMany::new(expected);\n-        this.coerce(ctx, expr, expr_ty);\n-        this.complete()\n-    }\n-\n     /// Merge two types from different branches, with possible coercion.\n     ///\n     /// Mostly this means trying to coerce one to the other, but"}, {"sha": "9904676096511c62c7d6f290e5b00e070eee0e16", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9272942b92c069df9421ce5a2073913711ec7a7c/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9272942b92c069df9421ce5a2073913711ec7a7c/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=9272942b92c069df9421ce5a2073913711ec7a7c", "patch": "@@ -163,7 +163,7 @@ impl<'a> InferenceContext<'a> {\n                         let break_ty = self.table.new_type_var();\n                         self.breakables.push(BreakableContext {\n                             may_break: false,\n-                            break_ty: break_ty.clone(),\n+                            coerce: CoerceMany::new(break_ty.clone()),\n                             label: label.map(|label| self.body[label].name.clone()),\n                         });\n                         let ty = self.infer_block(\n@@ -174,7 +174,7 @@ impl<'a> InferenceContext<'a> {\n                         );\n                         let ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n                         if ctxt.may_break {\n-                            ctxt.break_ty\n+                            ctxt.coerce.complete()\n                         } else {\n                             ty\n                         }\n@@ -202,27 +202,24 @@ impl<'a> InferenceContext<'a> {\n             Expr::Loop { body, label } => {\n                 self.breakables.push(BreakableContext {\n                     may_break: false,\n-                    break_ty: self.table.new_type_var(),\n+                    coerce: CoerceMany::new(self.table.new_type_var()),\n                     label: label.map(|label| self.body[label].name.clone()),\n                 });\n                 self.infer_expr(*body, &Expectation::has_type(TyBuilder::unit()));\n \n                 let ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n-                if ctxt.may_break {\n-                    self.diverges = Diverges::Maybe;\n-                }\n \n                 if ctxt.may_break {\n-                    ctxt.break_ty\n+                    self.diverges = Diverges::Maybe;\n+                    ctxt.coerce.complete()\n                 } else {\n                     TyKind::Never.intern(&Interner)\n                 }\n             }\n             Expr::While { condition, body, label } => {\n                 self.breakables.push(BreakableContext {\n                     may_break: false,\n-                    break_ty: self.err_ty(),\n-\n+                    coerce: CoerceMany::new(self.err_ty()),\n                     label: label.map(|label| self.body[label].name.clone()),\n                 });\n                 // while let is desugared to a match loop, so this is always simple while\n@@ -241,7 +238,7 @@ impl<'a> InferenceContext<'a> {\n \n                 self.breakables.push(BreakableContext {\n                     may_break: false,\n-                    break_ty: self.err_ty(),\n+                    coerce: CoerceMany::new(self.err_ty()),\n                     label: label.map(|label| self.body[label].name.clone()),\n                 });\n                 let pat_ty =\n@@ -383,31 +380,35 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::Continue { .. } => TyKind::Never.intern(&Interner),\n             Expr::Break { expr, label } => {\n-                let expr = *expr;\n-                let last_ty =\n-                    if let Some(ctxt) = find_breakable(&mut self.breakables, label.as_ref()) {\n-                        ctxt.break_ty.clone()\n-                    } else {\n-                        self.err_ty()\n-                    };\n+                let mut coerce = match find_breakable(&mut self.breakables, label.as_ref()) {\n+                    Some(ctxt) => {\n+                        // avoiding the borrowck\n+                        mem::replace(\n+                            &mut ctxt.coerce,\n+                            CoerceMany::new(self.result.standard_types.unknown.clone()),\n+                        )\n+                    }\n+                    None => CoerceMany::new(self.result.standard_types.unknown.clone()),\n+                };\n \n-                let val_ty = if let Some(expr) = expr {\n+                let val_ty = if let Some(expr) = *expr {\n                     self.infer_expr(expr, &Expectation::none())\n                 } else {\n                     TyBuilder::unit()\n                 };\n \n                 // FIXME: create a synthetic `()` during lowering so we have something to refer to here?\n-                let merged_type = CoerceMany::once(self, last_ty, expr, &val_ty);\n+                coerce.coerce(self, *expr, &val_ty);\n \n                 if let Some(ctxt) = find_breakable(&mut self.breakables, label.as_ref()) {\n-                    ctxt.break_ty = merged_type;\n+                    ctxt.coerce = coerce;\n                     ctxt.may_break = true;\n                 } else {\n                     self.push_diagnostic(InferenceDiagnostic::BreakOutsideOfLoop {\n                         expr: tgt_expr,\n                     });\n-                }\n+                };\n+\n                 TyKind::Never.intern(&Interner)\n             }\n             Expr::Return { expr } => {"}]}