{"sha": "49da9a3e814a42a2f4dea0cd79dbdae86bea5ce4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5ZGE5YTNlODE0YTQyYTJmNGRlYTBjZDc5ZGJkYWU4NmJlYTVjZTQ=", "commit": {"author": {"name": "kjeremy", "email": "kjeremy@gmail.com", "date": "2019-03-01T23:26:49Z"}, "committer": {"name": "Jeremy Kolb", "email": "kjeremy@gmail.com", "date": "2019-03-04T13:27:08Z"}, "message": "Make goto definition/hover resolve constructors", "tree": {"sha": "27710b8c6c7f63e2ddb25d178988f4dd6cbc2540", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27710b8c6c7f63e2ddb25d178988f4dd6cbc2540"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49da9a3e814a42a2f4dea0cd79dbdae86bea5ce4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49da9a3e814a42a2f4dea0cd79dbdae86bea5ce4", "html_url": "https://github.com/rust-lang/rust/commit/49da9a3e814a42a2f4dea0cd79dbdae86bea5ce4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49da9a3e814a42a2f4dea0cd79dbdae86bea5ce4/comments", "author": {"login": "kjeremy", "id": 4325700, "node_id": "MDQ6VXNlcjQzMjU3MDA=", "avatar_url": "https://avatars.githubusercontent.com/u/4325700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kjeremy", "html_url": "https://github.com/kjeremy", "followers_url": "https://api.github.com/users/kjeremy/followers", "following_url": "https://api.github.com/users/kjeremy/following{/other_user}", "gists_url": "https://api.github.com/users/kjeremy/gists{/gist_id}", "starred_url": "https://api.github.com/users/kjeremy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kjeremy/subscriptions", "organizations_url": "https://api.github.com/users/kjeremy/orgs", "repos_url": "https://api.github.com/users/kjeremy/repos", "events_url": "https://api.github.com/users/kjeremy/events{/privacy}", "received_events_url": "https://api.github.com/users/kjeremy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kjeremy", "id": 4325700, "node_id": "MDQ6VXNlcjQzMjU3MDA=", "avatar_url": "https://avatars.githubusercontent.com/u/4325700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kjeremy", "html_url": "https://github.com/kjeremy", "followers_url": "https://api.github.com/users/kjeremy/followers", "following_url": "https://api.github.com/users/kjeremy/following{/other_user}", "gists_url": "https://api.github.com/users/kjeremy/gists{/gist_id}", "starred_url": "https://api.github.com/users/kjeremy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kjeremy/subscriptions", "organizations_url": "https://api.github.com/users/kjeremy/orgs", "repos_url": "https://api.github.com/users/kjeremy/repos", "events_url": "https://api.github.com/users/kjeremy/events{/privacy}", "received_events_url": "https://api.github.com/users/kjeremy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc8bcc1e42b573a8c315dd42a43c0fc4d5bfa8f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc8bcc1e42b573a8c315dd42a43c0fc4d5bfa8f8", "html_url": "https://github.com/rust-lang/rust/commit/dc8bcc1e42b573a8c315dd42a43c0fc4d5bfa8f8"}], "stats": {"total": 94, "additions": 87, "deletions": 7}, "files": [{"sha": "f7a35f05b5a9c6300affe7bba73cf49fd5bea886", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 40, "deletions": 3, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/49da9a3e814a42a2f4dea0cd79dbdae86bea5ce4/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49da9a3e814a42a2f4dea0cd79dbdae86bea5ce4/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=49da9a3e814a42a2f4dea0cd79dbdae86bea5ce4", "patch": "@@ -54,13 +54,33 @@ pub fn infer(db: &impl HirDatabase, func: Function) -> Arc<InferenceResult> {\n     Arc::new(ctx.resolve_all())\n }\n \n+#[derive(Debug, Copy, Clone)]\n+enum ExprOrPatId {\n+    Expr(ExprId),\n+    Pat(PatId),\n+}\n+\n+impl From<ExprId> for ExprOrPatId {\n+    fn from(id: ExprId) -> Self {\n+        ExprOrPatId::Expr(id)\n+    }\n+}\n+\n+impl From<PatId> for ExprOrPatId {\n+    fn from(id: PatId) -> Self {\n+        ExprOrPatId::Pat(id)\n+    }\n+}\n+\n /// The result of type inference: A mapping from expressions and patterns to types.\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct InferenceResult {\n     /// For each method call expr, records the function it resolves to.\n     method_resolutions: FxHashMap<ExprId, Function>,\n     /// For each field access expr, records the field it resolves to.\n     field_resolutions: FxHashMap<ExprId, StructField>,\n+    /// For each associated function call expr, records the function it resolves to\n+    assoc_fn_resolutions: FxHashMap<ExprId, Function>,\n     pub(super) type_of_expr: ArenaMap<ExprId, Ty>,\n     pub(super) type_of_pat: ArenaMap<PatId, Ty>,\n }\n@@ -72,6 +92,9 @@ impl InferenceResult {\n     pub fn field_resolution(&self, expr: ExprId) -> Option<StructField> {\n         self.field_resolutions.get(&expr).map(|it| *it)\n     }\n+    pub fn assoc_fn_resolutions(&self, expr: ExprId) -> Option<Function> {\n+        self.assoc_fn_resolutions.get(&expr).map(|it| *it)\n+    }\n }\n \n impl Index<ExprId> for InferenceResult {\n@@ -99,6 +122,7 @@ struct InferenceContext<'a, D: HirDatabase> {\n     var_unification_table: InPlaceUnificationTable<TypeVarId>,\n     method_resolutions: FxHashMap<ExprId, Function>,\n     field_resolutions: FxHashMap<ExprId, StructField>,\n+    assoc_fn_resolutions: FxHashMap<ExprId, Function>,\n     type_of_expr: ArenaMap<ExprId, Ty>,\n     type_of_pat: ArenaMap<PatId, Ty>,\n     /// The return type of the function being inferred.\n@@ -110,6 +134,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         InferenceContext {\n             method_resolutions: FxHashMap::default(),\n             field_resolutions: FxHashMap::default(),\n+            assoc_fn_resolutions: FxHashMap::default(),\n             type_of_expr: ArenaMap::default(),\n             type_of_pat: ArenaMap::default(),\n             var_unification_table: InPlaceUnificationTable::new(),\n@@ -135,6 +160,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         InferenceResult {\n             method_resolutions: self.method_resolutions,\n             field_resolutions: self.field_resolutions,\n+            assoc_fn_resolutions: self.assoc_fn_resolutions,\n             type_of_expr: expr_types,\n             type_of_pat: pat_types,\n         }\n@@ -152,6 +178,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.field_resolutions.insert(expr, field);\n     }\n \n+    fn write_assoc_fn_resolution(&mut self, expr: ExprId, func: Function) {\n+        self.assoc_fn_resolutions.insert(expr, func);\n+    }\n+\n     fn write_pat_ty(&mut self, pat: PatId, ty: Ty) {\n         self.type_of_pat.insert(pat, ty);\n     }\n@@ -341,7 +371,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         })\n     }\n \n-    fn infer_path_expr(&mut self, resolver: &Resolver, path: &Path) -> Option<Ty> {\n+    fn infer_path_expr(&mut self, resolver: &Resolver, path: &Path, id: ExprOrPatId) -> Option<Ty> {\n         let resolved = resolver.resolve_path_segments(self.db, &path);\n \n         let (def, remaining_index) = resolved.into_inner();\n@@ -421,6 +451,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let typable: Option<TypableDef> = def.into();\n                 let typable = typable?;\n \n+                if let ExprOrPatId::Expr(expr) = id {\n+                    match typable {\n+                        TypableDef::Function(func) => self.write_assoc_fn_resolution(expr, func),\n+                        _ => {}\n+                    };\n+                }\n+\n                 let substs = Ty::substs_from_path(self.db, &self.resolver, path, typable);\n                 let ty = self.db.type_for_def(typable, Namespace::Values).apply_substs(substs);\n                 let ty = self.insert_type_vars(ty);\n@@ -572,7 +609,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Pat::Path(path) => {\n                 // TODO use correct resolver for the surrounding expression\n                 let resolver = self.resolver.clone();\n-                self.infer_path_expr(&resolver, &path).unwrap_or(Ty::Unknown)\n+                self.infer_path_expr(&resolver, &path, pat.into()).unwrap_or(Ty::Unknown)\n             }\n             Pat::Bind { mode, name: _name, subpat } => {\n                 let inner_ty = if let Some(subpat) = subpat {\n@@ -782,7 +819,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Expr::Path(p) => {\n                 // TODO this could be more efficient...\n                 let resolver = expr::resolver_for_expr(self.body.clone(), self.db, tgt_expr);\n-                self.infer_path_expr(&resolver, p).unwrap_or(Ty::Unknown)\n+                self.infer_path_expr(&resolver, p, tgt_expr.into()).unwrap_or(Ty::Unknown)\n             }\n             Expr::Continue => Ty::Never,\n             Expr::Break { expr } => {"}, {"sha": "e4febe8ccd6285bb45adfe10e12ac0dcbdef3ab9", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/49da9a3e814a42a2f4dea0cd79dbdae86bea5ce4/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49da9a3e814a42a2f4dea0cd79dbdae86bea5ce4/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=49da9a3e814a42a2f4dea0cd79dbdae86bea5ce4", "patch": "@@ -47,9 +47,10 @@ pub(crate) fn reference_definition(\n     name_ref: &ast::NameRef,\n ) -> ReferenceResult {\n     use self::ReferenceResult::*;\n-    if let Some(function) =\n-        hir::source_binder::function_from_child_node(db, file_id, name_ref.syntax())\n-    {\n+\n+    let function = hir::source_binder::function_from_child_node(db, file_id, name_ref.syntax());\n+\n+    if let Some(function) = function {\n         // Check if it is a method\n         if let Some(method_call) = name_ref.syntax().parent().and_then(ast::MethodCallExpr::cast) {\n             tested_by!(goto_definition_works_for_methods);\n@@ -122,9 +123,29 @@ pub(crate) fn reference_definition(\n             Some(Resolution::SelfType(_impl_block)) => {\n                 // TODO: go to the implemented type\n             }\n-            None => {}\n+            None => {\n+                // If we failed to resolve then check associated items\n+                if let Some(function) = function {\n+                    // Should we do this above and then grab path from the PathExpr?\n+                    if let Some(path_expr) =\n+                        name_ref.syntax().ancestors().find_map(ast::PathExpr::cast)\n+                    {\n+                        let infer_result = function.infer(db);\n+                        let syntax_mapping = function.body_syntax_mapping(db);\n+                        let expr = ast::Expr::cast(path_expr.syntax()).unwrap();\n+\n+                        if let Some(func) = syntax_mapping\n+                            .node_expr(expr)\n+                            .and_then(|it| infer_result.assoc_fn_resolutions(it))\n+                        {\n+                            return Exact(NavigationTarget::from_function(db, func));\n+                        }\n+                    }\n+                }\n+            }\n         }\n     }\n+\n     // If that fails try the index based approach.\n     let navs = crate::symbol_index::index_resolve(db, name_ref)\n         .into_iter()"}, {"sha": "0f13777d7db78d05d68faa95897beaef842836de", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/49da9a3e814a42a2f4dea0cd79dbdae86bea5ce4/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49da9a3e814a42a2f4dea0cd79dbdae86bea5ce4/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=49da9a3e814a42a2f4dea0cd79dbdae86bea5ce4", "patch": "@@ -512,4 +512,26 @@ mod tests {\n         let hover = analysis.hover(position).unwrap().unwrap();\n         assert_eq!(trim_markup_opt(hover.info.first()), Some(\"Thing\"));\n     }\n+\n+    #[test]\n+    fn test_hover_infer_associated_method_exact() {\n+        let (analysis, position) = single_file_with_position(\n+            \"\n+            struct Thing { x: u32 }\n+\n+            impl Thing {\n+                fn new() -> Thing {\n+                    Thing { x: 0 }\n+                }\n+            }\n+\n+            fn main() {\n+                let foo_test = Thing::new<|>();\n+            }\n+            \",\n+        );\n+        let hover = analysis.hover(position).unwrap().unwrap();\n+        assert_eq!(hover.info.first(), Some(\"```rust\\nfn new() -> Thing\\n```\"));\n+        assert_eq!(hover.info.is_exact(), true);\n+    }\n }"}]}