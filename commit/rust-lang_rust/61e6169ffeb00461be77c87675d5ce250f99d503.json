{"sha": "61e6169ffeb00461be77c87675d5ce250f99d503", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxZTYxNjlmZmViMDA0NjFiZTc3Yzg3Njc1ZDVjZTI1MGY5OWQ1MDM=", "commit": {"author": {"name": "ggomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-05-03T15:03:00Z"}, "committer": {"name": "ggomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-05-11T11:24:22Z"}, "message": "Improve weight algorithm and tests", "tree": {"sha": "db0ae35476ed77afb1b7d98bbc23ffc48a045d77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db0ae35476ed77afb1b7d98bbc23ffc48a045d77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61e6169ffeb00461be77c87675d5ce250f99d503", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61e6169ffeb00461be77c87675d5ce250f99d503", "html_url": "https://github.com/rust-lang/rust/commit/61e6169ffeb00461be77c87675d5ce250f99d503", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61e6169ffeb00461be77c87675d5ce250f99d503/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8fad79a07ef287a80959ec8c4f82e7e6803b053", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8fad79a07ef287a80959ec8c4f82e7e6803b053", "html_url": "https://github.com/rust-lang/rust/commit/b8fad79a07ef287a80959ec8c4f82e7e6803b053"}], "stats": {"total": 194, "additions": 134, "deletions": 60}, "files": [{"sha": "cee8561b378fd600d6bcb246857d3a60c5e1174d", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 107, "deletions": 52, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/61e6169ffeb00461be77c87675d5ce250f99d503/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61e6169ffeb00461be77c87675d5ce250f99d503/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=61e6169ffeb00461be77c87675d5ce250f99d503", "patch": "@@ -27,10 +27,10 @@ use super::{\n use fmt_macros::{Parser, Piece, Position};\n use hir::def_id::DefId;\n use infer::{self, InferCtxt, TypeOrigin};\n-use ty::{self, ToPredicate, ToPolyTraitRef, TraitRef, Ty, TyCtxt, TypeFoldable};\n+use ty::{self, ToPredicate, ToPolyTraitRef, TraitRef, Ty, TyCtxt, TypeFoldable, TypeVariants};\n use ty::fast_reject;\n use ty::fold::TypeFolder;\n-use ty::subst::{self, Subst};\n+use ty::subst::{self, ParamSpace, Subst};\n use util::nodemap::{FnvHashMap, FnvHashSet};\n \n use std::cmp;\n@@ -63,9 +63,9 @@ impl<'a, 'gcx, 'tcx> TraitErrorKey<'tcx> {\n }\n \n fn impl_substs<'a, 'tcx>(fcx: &InferCtxt<'a, 'tcx>,\n-                          did: DefId,\n-                          obligation: PredicateObligation<'tcx>)\n-                          -> subst::Substs<'tcx> {\n+                         did: DefId,\n+                         obligation: PredicateObligation<'tcx>)\n+                         -> subst::Substs<'tcx> {\n     let tcx = fcx.tcx;\n \n     let ity = tcx.lookup_item_type(did);\n@@ -82,44 +82,109 @@ fn impl_substs<'a, 'tcx>(fcx: &InferCtxt<'a, 'tcx>,\n     substs\n }\n \n-/*fn check_type_parameters<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                   trait_substs: &subst::Substs<'tcx>,\n-                                   impl_substs: &subst::Substs<'tcx>,\n-                                   obligation: &PredicateObligation<'tcx>) -> bool {\n-    let trait_types = trait_substs.types.as_slice();\n-    let impl_types = impl_substs.types.as_slice();\n-\n-    let mut failed = 0;\n-    for index_to_ignore in 0..trait_types.len() {\n-        for (index, (trait_type, impl_type)) in trait_types.iter()\n-                                                           .zip(impl_types.iter())\n-                                                           .enumerate() {\n-            if index_to_ignore != index &&\n-                infer::mk_eqty(infcx, true,\n-                               TypeOrigin::Misc(obligation.cause.span),\n-                               trait_type,\n-                               impl_type).is_err() {\n-                failed += 1;\n-                break;\n-            }\n+trait AssociatedWeight {\n+    fn get_weight(&self) -> usize;\n+}\n+\n+impl<'a> AssociatedWeight for TypeVariants<'a> {\n+    // First number is for \"global\" weight and second number is for bigger precision\n+    fn get_weight(&self) -> usize {\n+        match *self {\n+            TypeVariants::TyBool => 11,\n+            TypeVariants::TyChar => 12,\n+            TypeVariants::TyStr => 13,\n+            TypeVariants::TyInt(_) => 21,\n+            TypeVariants::TyUint(_) => 22,\n+            TypeVariants::TyFloat(_) => 23,\n+            TypeVariants::TyRawPtr(_) => 24,\n+            TypeVariants::TyEnum(_, _) => 31,\n+            TypeVariants::TyStruct(_, _) => 32,\n+            TypeVariants::TyBox(_) => 33,\n+            TypeVariants::TyTuple(_) => 34,\n+            TypeVariants::TyArray(_, _) => 41,\n+            TypeVariants::TySlice(_) => 42,\n+            TypeVariants::TyRef(_, _) => 51,\n+            TypeVariants::TyFnDef(_, _, _) => 52,\n+            TypeVariants::TyFnPtr(_) => 53,\n+            TypeVariants::TyTrait(_) => 61,\n+            TypeVariants::TyClosure(_, _) => 71,\n+            TypeVariants::TyProjection(_) => 81,\n+            TypeVariants::TyParam(_) => 82,\n+            TypeVariants::TyInfer(_) => 83,\n+            TypeVariants::TyError => 91,\n         }\n     }\n-    failed == trait_types.len() - 1\n-}*/\n+}\n+\n+// The \"closer\" the types are, the lesser the weight\n+fn get_weight_diff(a: &ty::TypeVariants, b: &TypeVariants, big_weight: bool) -> usize {\n+    let w1 = if big_weight { a.get_weight() / 10 } else { a.get_weight() % 10 };\n+    let w2 = if big_weight { b.get_weight() / 10 } else { b.get_weight() % 10 };\n+\n+    if w1 < w2 {\n+        w2 - w1\n+    } else {\n+        w1 - w2\n+    }\n+}\n+\n+// Once we have \"globally matching\" types, we need to run another filter on them\n+fn filter_matching_types<'tcx>(weights: &[(usize, usize)],\n+                               imps: &[(DefId, subst::Substs<'tcx>)],\n+                               trait_types: &[ty::Ty<'tcx>])\n+                               -> usize {\n+    let matching_weight = weights[0].1;\n+    let iter = weights.iter().filter(|&&(_, weight)| weight == matching_weight);\n+    let mut filtered_weights = vec!();\n+\n+    for &(pos, _) in iter {\n+        let mut weight = 0;\n+        for (type_to_compare, original_type) in imps[pos].1\n+                                                         .types\n+                                                         .get_slice(ParamSpace::TypeSpace)\n+                                                         .iter()\n+                                                         .zip(trait_types.iter()) {\n+            weight += get_weight_diff(&type_to_compare.sty, &original_type.sty, false);\n+        }\n+        filtered_weights.push((pos, weight));\n+    }\n+    filtered_weights.sort_by(|a, b| a.1.cmp(&b.1));\n+    filtered_weights[0].0\n+}\n+\n+fn get_best_matching_type<'tcx>(imps: &[(DefId, subst::Substs<'tcx>)],\n+                                trait_types: &[ty::Ty<'tcx>]) -> usize {\n+    let mut weights = vec!();\n+    for (pos, imp) in imps.iter().enumerate() {\n+        let mut weight = 0;\n+        for (type_to_compare, original_type) in imp.1\n+                                                   .types\n+                                                   .get_slice(ParamSpace::TypeSpace)\n+                                                   .iter()\n+                                                   .zip(trait_types.iter()) {\n+            weight += get_weight_diff(&type_to_compare.sty, &original_type.sty, true);\n+        }\n+        weights.push((pos, weight));\n+    }\n+    weights.sort_by(|a, b| a.1.cmp(&b.1));\n+    if weights[0].1 == weights[1].1 {\n+        filter_matching_types(&weights, &imps, trait_types)\n+    } else {\n+        weights[0].0\n+    }\n+}\n \n fn get_current_failing_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                       trait_ref: &TraitRef<'tcx>,\n                                       obligation: &PredicateObligation<'tcx>)\n                                      -> Option<(DefId, subst::Substs<'tcx>)> {\n-    println!(\"1\");\n     let simp = fast_reject::simplify_type(infcx.tcx,\n                                           trait_ref.self_ty(),\n                                           true);\n     let trait_def = infcx.tcx.lookup_trait_def(trait_ref.def_id);\n \n     match simp {\n         Some(_) => {\n-            println!(\"2\");\n             let mut matching_impls = Vec::new();\n             trait_def.for_each_impl(infcx.tcx, |def_id| {\n                 let imp = infcx.tcx.impl_trait_ref(def_id).unwrap();\n@@ -130,25 +195,19 @@ fn get_current_failing_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                   TypeOrigin::Misc(obligation.cause.span),\n                                   trait_ref.self_ty(),\n                                   imp.self_ty()).is_ok() {\n-                    //if check_type_parameters(infcx, &trait_ref.substs, &imp.substs, obligation) {\n-                        matching_impls.push((def_id, imp.substs.clone()));\n-                    //}\n+                    matching_impls.push((def_id, imp.substs.clone()));\n                 }\n-                println!(\"=> {:?} /// {:?}\", def_id, imp.substs);\n             });\n             if matching_impls.len() == 0 {\n-                println!(\"3\");\n                 None\n             } else if matching_impls.len() == 1 {\n-                println!(\"4\");\n                 Some(matching_impls[0].clone())\n             } else {\n-                println!(\"5\");\n+                let end = trait_ref.input_types().len() - 1;\n                 // we need to determine which type is the good one!\n-                for &(ref m, ref n) in matching_impls.iter() {\n-                    println!(\"=> {:?} /// {:?}\", m, n);\n-                }\n-                Some(matching_impls[0].clone())\n+                Some(matching_impls[get_best_matching_type(&matching_impls,\n+                                                           &trait_ref.input_types()[0..end])]\n+                                                          .clone())\n             }\n         },\n         None => None,\n@@ -171,7 +230,6 @@ fn on_unimplemented_note<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                    trait_ref: ty::PolyTraitRef<'tcx>,\n                                    obligation: &PredicateObligation<'tcx>) -> Option<String> {\n     let trait_ref = trait_ref.skip_binder();\n-    //let def_id = trait_ref.def_id;\n     let mut report = None;\n     let def_id = match get_current_failing_impl(infcx, trait_ref, obligation) {\n         Some((def_id, _)) => {\n@@ -603,8 +661,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             // Try to report a help message\n \n                             if !trait_ref.has_infer_types() &&\n-                                predicate_can_apply(infcx, trait_ref)\n-                            {\n+                                predicate_can_apply(infcx, trait_ref) {\n                                 // If a where-clause may be useful, remind the\n                                 // user that they can add it.\n                                 //\n@@ -662,18 +719,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                     // similar impls.\n \n                                     self.report_similar_impl_candidates(trait_ref, &mut err);\n+                                    // If we can't show anything useful, try to find\n+                                    // similar impls.\n+                                    let impl_candidates =\n+                                        find_similar_impl_candidates(infcx, trait_ref);\n+                                    if impl_candidates.len() > 0 {\n+                                        self.report_similar_impl_candidates(trait_ref, &mut err);\n                                 }\n                                 err\n                             }\n-                            // Check if it has a custom \"#[rustc_on_unimplemented]\"\n-                            // error message, report with that message if it does\n-                            /*let custom_note = report_on_unimplemented(infcx, &trait_ref.0,\n-                                                                      obligation);\n-                            if let Some(s) = custom_note {\n-                                err.fileline_note(obligation.cause.span, &s);\n-                            } else {\n-                                note_obligation_cause(infcx, &mut err, obligation);\n-                            }*/\n+                            note_obligation_cause(infcx, &mut err, obligation);\n                             err.emit();\n                         }\n "}, {"sha": "4471b625d7912fd4b79ac1913aaaa3cb687e4774", "filename": "src/test/compile-fail/check_on_unimplemented.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/61e6169ffeb00461be77c87675d5ce250f99d503/src%2Ftest%2Fcompile-fail%2Fcheck_on_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61e6169ffeb00461be77c87675d5ce250f99d503/src%2Ftest%2Fcompile-fail%2Fcheck_on_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcheck_on_unimplemented.rs?ref=61e6169ffeb00461be77c87675d5ce250f99d503", "patch": "@@ -31,4 +31,5 @@ impl Index<usize> for [i32] {\n fn main() {\n     Index::<u32>::index(&[1, 2, 3] as &[i32], 2u32); //~ ERROR E0277\n                                                      //~| NOTE a usize is required\n+                                                     //~| NOTE required by\n }"}, {"sha": "1a5b5ff206ad0de73445c8057ff7663f094fb593", "filename": "src/test/compile-fail/on_unimplemented.rs", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/61e6169ffeb00461be77c87675d5ce250f99d503/src%2Ftest%2Fcompile-fail%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61e6169ffeb00461be77c87675d5ce250f99d503/src%2Ftest%2Fcompile-fail%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fon_unimplemented.rs?ref=61e6169ffeb00461be77c87675d5ce250f99d503", "patch": "@@ -19,15 +19,11 @@ trait Index<Idx: ?Sized> {\n     fn index(&self, index: Idx) -> &Self::Output;\n }\n \n-struct Foo {\n-    i: usize,\n-}\n-\n-#[rustc_on_unimplemented = \"a Foo is required to index into a slice\"]\n-impl Index<Foo> for [i32] {\n+#[rustc_on_unimplemented = \"a isize is required to index into a slice\"]\n+impl Index<isize> for [i32] {\n     type Output = i32;\n-    fn index(&self, index: Foo) -> &i32 {\n-        &self[index.i]\n+    fn index(&self, index: isize) -> &i32 {\n+        &self[index as usize]\n     }\n }\n \n@@ -39,8 +35,30 @@ impl Index<usize> for [i32] {\n     }\n }\n \n+trait Foo<A, B> {\n+    fn f(&self, a: &A, b: &B);\n+}\n+\n+#[rustc_on_unimplemented = \"two i32 Foo trait takes\"]\n+impl Foo<i32, i32> for [i32] {\n+    fn f(&self, a: &i32, b: &i32) {}\n+}\n+\n+#[rustc_on_unimplemented = \"two u32 Foo trait takes\"]\n+impl Foo<u32, u32> for [i32] {\n+    fn f(&self, a: &u32, b: &u32) {}\n+}\n+\n #[rustc_error]\n fn main() {\n     Index::<u32>::index(&[1, 2, 3] as &[i32], 2u32); //~ ERROR E0277\n                                                      //~| NOTE a usize is required\n+                                                     //~| NOTE required by\n+    Index::<i32>::index(&[1, 2, 3] as &[i32], 2i32); //~ ERROR E0277\n+                                                     //~| NOTE a isize is required\n+                                                     //~| NOTE required by\n+\n+    Foo::<usize, usize>::f(&[1, 2, 3] as &[i32], &2usize, &2usize); //~ ERROR E0277\n+                                                                    //~| NOTE two u32 Foo trait\n+                                                                    //~| NOTE required by\n }"}]}