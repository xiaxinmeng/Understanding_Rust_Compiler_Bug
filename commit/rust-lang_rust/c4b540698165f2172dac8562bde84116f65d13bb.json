{"sha": "c4b540698165f2172dac8562bde84116f65d13bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0YjU0MDY5ODE2NWYyMTcyZGFjODU2MmJkZTg0MTE2ZjY1ZDEzYmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-09T09:00:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-09T09:00:16Z"}, "message": "Auto merge of #86118 - spastorino:tait-soundness-bug, r=nikomatsakis\n\nCreate different inference variables for different defining uses of TAITs\n\nFixes #73481\n\nr? `@nikomatsakis`\ncc `@oli-obk`", "tree": {"sha": "cfe4a5fa0d59a748d921592cbdb0ec9abd0f182f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfe4a5fa0d59a748d921592cbdb0ec9abd0f182f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4b540698165f2172dac8562bde84116f65d13bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4b540698165f2172dac8562bde84116f65d13bb", "html_url": "https://github.com/rust-lang/rust/commit/c4b540698165f2172dac8562bde84116f65d13bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4b540698165f2172dac8562bde84116f65d13bb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d45d205d59bd9eaca352e3a8f18c625f47f5838b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d45d205d59bd9eaca352e3a8f18c625f47f5838b", "html_url": "https://github.com/rust-lang/rust/commit/d45d205d59bd9eaca352e3a8f18c625f47f5838b"}, {"sha": "7b1e1c73330ca9ce7ad00f7a1d61ba393ea187b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b1e1c73330ca9ce7ad00f7a1d61ba393ea187b1", "html_url": "https://github.com/rust-lang/rust/commit/7b1e1c73330ca9ce7ad00f7a1d61ba393ea187b1"}], "stats": {"total": 571, "additions": 439, "deletions": 132}, "files": [{"sha": "bbfe225e23ebf8c06c300167efdd9a6586b79e22", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c4b540698165f2172dac8562bde84116f65d13bb/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b540698165f2172dac8562bde84116f65d13bb/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=c4b540698165f2172dac8562bde84116f65d13bb", "patch": "@@ -96,6 +96,7 @@ pub mod thin_vec;\n pub mod tiny_list;\n pub mod transitive_relation;\n pub mod vec_linked_list;\n+pub mod vec_map;\n pub mod work_queue;\n pub use atomic_ref::AtomicRef;\n pub mod frozen;"}, {"sha": "73b04d3329cb8e79e9c9a3c5d63f5f178b307e27", "filename": "compiler/rustc_data_structures/src/vec_map.rs", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/c4b540698165f2172dac8562bde84116f65d13bb/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b540698165f2172dac8562bde84116f65d13bb/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map.rs?ref=c4b540698165f2172dac8562bde84116f65d13bb", "patch": "@@ -0,0 +1,155 @@\n+use std::borrow::Borrow;\n+use std::iter::FromIterator;\n+use std::slice::{Iter, IterMut};\n+use std::vec::IntoIter;\n+\n+use crate::stable_hasher::{HashStable, StableHasher};\n+\n+/// A map type implemented as a vector of pairs `K` (key) and `V` (value).\n+/// It currently provides a subset of all the map operations, the rest could be added as needed.\n+#[derive(Clone, Encodable, Decodable, Debug)]\n+pub struct VecMap<K, V>(Vec<(K, V)>);\n+\n+impl<K, V> VecMap<K, V>\n+where\n+    K: PartialEq,\n+{\n+    pub fn new() -> Self {\n+        VecMap(Default::default())\n+    }\n+\n+    /// Sets the value of the entry, and returns the entry's old value.\n+    pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n+        if let Some(elem) = self.0.iter_mut().find(|(key, _)| *key == k) {\n+            Some(std::mem::replace(&mut elem.1, v))\n+        } else {\n+            self.0.push((k, v));\n+            None\n+        }\n+    }\n+\n+    /// Gets a reference to the value in the entry.\n+    pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n+    where\n+        K: Borrow<Q>,\n+        Q: Eq,\n+    {\n+        self.0.iter().find(|(key, _)| k == key.borrow()).map(|elem| &elem.1)\n+    }\n+\n+    /// Returns the value corresponding to the supplied predicate filter.\n+    ///\n+    /// The supplied predicate will be applied to each (key, value) pair and it will return a\n+    /// reference to the values where the predicate returns `true`.\n+    pub fn get_by(&self, mut predicate: impl FnMut(&(K, V)) -> bool) -> Option<&V> {\n+        self.0.iter().find(|kv| predicate(kv)).map(|elem| &elem.1)\n+    }\n+\n+    /// Returns `true` if the map contains a value for the specified key.\n+    ///\n+    /// The key may be any borrowed form of the map's key type,\n+    /// [`Eq`] on the borrowed form *must* match those for\n+    /// the key type.\n+    pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool\n+    where\n+        K: Borrow<Q>,\n+        Q: Eq,\n+    {\n+        self.get(k).is_some()\n+    }\n+\n+    /// Returns `true` if the map contains no elements.\n+    pub fn is_empty(&self) -> bool {\n+        self.0.is_empty()\n+    }\n+\n+    pub fn iter(&self) -> Iter<'_, (K, V)> {\n+        self.into_iter()\n+    }\n+\n+    pub fn iter_mut(&mut self) -> IterMut<'_, (K, V)> {\n+        self.into_iter()\n+    }\n+}\n+\n+impl<K, V> Default for VecMap<K, V> {\n+    #[inline]\n+    fn default() -> Self {\n+        Self(Default::default())\n+    }\n+}\n+\n+impl<K, V> From<Vec<(K, V)>> for VecMap<K, V> {\n+    fn from(vec: Vec<(K, V)>) -> Self {\n+        Self(vec)\n+    }\n+}\n+\n+impl<K, V> Into<Vec<(K, V)>> for VecMap<K, V> {\n+    fn into(self) -> Vec<(K, V)> {\n+        self.0\n+    }\n+}\n+\n+impl<K, V> FromIterator<(K, V)> for VecMap<K, V> {\n+    fn from_iter<I: IntoIterator<Item = (K, V)>>(iter: I) -> Self {\n+        Self(iter.into_iter().collect())\n+    }\n+}\n+\n+impl<'a, K, V> IntoIterator for &'a VecMap<K, V> {\n+    type Item = &'a (K, V);\n+    type IntoIter = Iter<'a, (K, V)>;\n+\n+    #[inline]\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.0.iter()\n+    }\n+}\n+\n+impl<'a, K, V> IntoIterator for &'a mut VecMap<K, V> {\n+    type Item = &'a mut (K, V);\n+    type IntoIter = IterMut<'a, (K, V)>;\n+\n+    #[inline]\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.0.iter_mut()\n+    }\n+}\n+\n+impl<K, V> IntoIterator for VecMap<K, V> {\n+    type Item = (K, V);\n+    type IntoIter = IntoIter<(K, V)>;\n+\n+    #[inline]\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.0.into_iter()\n+    }\n+}\n+\n+impl<K, V> Extend<(K, V)> for VecMap<K, V> {\n+    fn extend<I: IntoIterator<Item = (K, V)>>(&mut self, iter: I) {\n+        self.0.extend(iter);\n+    }\n+\n+    fn extend_one(&mut self, item: (K, V)) {\n+        self.0.extend_one(item);\n+    }\n+\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.0.extend_reserve(additional);\n+    }\n+}\n+\n+impl<K, V, CTX> HashStable<CTX> for VecMap<K, V>\n+where\n+    K: HashStable<CTX> + Eq,\n+    V: HashStable<CTX>,\n+{\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n+        self.0.hash_stable(hcx, hasher)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "9083de85982e7df482863d3e201a09acd5846cc7", "filename": "compiler/rustc_data_structures/src/vec_map/tests.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c4b540698165f2172dac8562bde84116f65d13bb/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b540698165f2172dac8562bde84116f65d13bb/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map%2Ftests.rs?ref=c4b540698165f2172dac8562bde84116f65d13bb", "patch": "@@ -0,0 +1,48 @@\n+use super::*;\n+\n+impl<K, V> VecMap<K, V> {\n+    fn into_vec(self) -> Vec<(K, V)> {\n+        self.0.into()\n+    }\n+}\n+\n+#[test]\n+fn test_from_iterator() {\n+    assert_eq!(\n+        std::iter::empty().collect::<VecMap<i32, bool>>().into_vec(),\n+        Vec::<(i32, bool)>::new()\n+    );\n+    assert_eq!(std::iter::once((42, true)).collect::<VecMap<_, _>>().into_vec(), vec![(42, true)]);\n+    assert_eq!(\n+        vec![(1, true), (2, false)].into_iter().collect::<VecMap<_, _>>().into_vec(),\n+        vec![(1, true), (2, false)]\n+    );\n+}\n+\n+#[test]\n+fn test_into_iterator_owned() {\n+    assert_eq!(VecMap::new().into_iter().collect::<Vec<(i32, bool)>>(), Vec::<(i32, bool)>::new());\n+    assert_eq!(VecMap::from(vec![(1, true)]).into_iter().collect::<Vec<_>>(), vec![(1, true)]);\n+    assert_eq!(\n+        VecMap::from(vec![(1, true), (2, false)]).into_iter().collect::<Vec<_>>(),\n+        vec![(1, true), (2, false)]\n+    );\n+}\n+\n+#[test]\n+fn test_insert() {\n+    let mut v = VecMap::new();\n+    assert_eq!(v.insert(1, true), None);\n+    assert_eq!(v.insert(2, false), None);\n+    assert_eq!(v.clone().into_vec(), vec![(1, true), (2, false)]);\n+    assert_eq!(v.insert(1, false), Some(true));\n+    assert_eq!(v.into_vec(), vec![(1, false), (2, false)]);\n+}\n+\n+#[test]\n+fn test_get() {\n+    let v = vec![(1, true), (2, false)].into_iter().collect::<VecMap<_, _>>();\n+    assert_eq!(v.get(&1), Some(&true));\n+    assert_eq!(v.get(&2), Some(&false));\n+    assert_eq!(v.get(&3), None);\n+}"}, {"sha": "4fb737f463a8621e127979700cc6eb038922006b", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c4b540698165f2172dac8562bde84116f65d13bb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b540698165f2172dac8562bde84116f65d13bb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=c4b540698165f2172dac8562bde84116f65d13bb", "patch": "@@ -2,13 +2,14 @@\n \n use crate::mir::{abstract_const, Body, Promoted};\n use crate::ty::{self, Ty, TyCtxt};\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_index::bit_set::BitMatrix;\n use rustc_index::vec::IndexVec;\n+use rustc_middle::ty::OpaqueTypeKey;\n use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n use smallvec::SmallVec;\n@@ -210,7 +211,7 @@ pub struct BorrowCheckResult<'tcx> {\n     /// All the opaque types that are restricted to concrete types\n     /// by this function. Unlike the value in `TypeckResults`, this has\n     /// unerased regions.\n-    pub concrete_opaque_types: FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>>,\n+    pub concrete_opaque_types: VecMap<OpaqueTypeKey<'tcx>, Ty<'tcx>>,\n     pub closure_requirements: Option<ClosureRegionRequirements<'tcx>>,\n     pub used_mut_upvars: SmallVec<[Field; 8]>,\n }"}, {"sha": "62d1bc7eb6d601e77900eb618b365f2265f2b308", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c4b540698165f2172dac8562bde84116f65d13bb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b540698165f2172dac8562bde84116f65d13bb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=c4b540698165f2172dac8562bde84116f65d13bb", "patch": "@@ -34,6 +34,7 @@ use rustc_data_structures::sharded::{IntoPointer, ShardedHashMap};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::sync::{self, Lock, Lrc, WorkerLocal};\n+use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -47,6 +48,7 @@ use rustc_hir::{\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_macros::HashStable;\n use rustc_middle::mir::FakeReadCause;\n+use rustc_middle::ty::OpaqueTypeKey;\n use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n use rustc_session::config::{BorrowckMode, CrateType, OutputFilenames};\n use rustc_session::lint::{Level, Lint};\n@@ -286,17 +288,6 @@ impl<'a, V> LocalTableInContextMut<'a, V> {\n     }\n }\n \n-/// All information necessary to validate and reveal an `impl Trait`.\n-#[derive(TyEncodable, TyDecodable, Debug, HashStable)]\n-pub struct ResolvedOpaqueTy<'tcx> {\n-    /// The revealed type as seen by this function.\n-    pub concrete_type: Ty<'tcx>,\n-    /// Generic parameters on the opaque type as passed by this function.\n-    /// For `type Foo<A, B> = impl Bar<A, B>; fn foo<T, U>() -> Foo<T, U> { .. }`\n-    /// this is `[T, U]`, not `[A, B]`.\n-    pub substs: SubstsRef<'tcx>,\n-}\n-\n /// Whenever a value may be live across a generator yield, the type of that value winds up in the\n /// `GeneratorInteriorTypeCause` struct. This struct adds additional information about such\n /// captured types that can be useful for diagnostics. In particular, it stores the span that\n@@ -424,7 +415,7 @@ pub struct TypeckResults<'tcx> {\n \n     /// All the opaque types that are restricted to concrete types\n     /// by this function.\n-    pub concrete_opaque_types: FxHashMap<DefId, ResolvedOpaqueTy<'tcx>>,\n+    pub concrete_opaque_types: VecMap<OpaqueTypeKey<'tcx>, Ty<'tcx>>,\n \n     /// Tracks the minimum captures required for a closure;\n     /// see `MinCaptureInformationMap` for more details."}, {"sha": "227aa8dc284e27dd7a0d80d6e63f9cf868bfd94c", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c4b540698165f2172dac8562bde84116f65d13bb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b540698165f2172dac8562bde84116f65d13bb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=c4b540698165f2172dac8562bde84116f65d13bb", "patch": "@@ -58,7 +58,7 @@ pub use self::consts::{Const, ConstInt, ConstKind, InferConst, ScalarInt, Uneval\n pub use self::context::{\n     tls, CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n     CtxtInterners, DelaySpanBugEmitted, FreeRegionInfo, GeneratorInteriorTypeCause, GlobalCtxt,\n-    Lift, ResolvedOpaqueTy, TyCtxt, TypeckResults, UserType, UserTypeAnnotationIndex,\n+    Lift, TyCtxt, TypeckResults, UserType, UserTypeAnnotationIndex,\n };\n pub use self::instance::{Instance, InstanceDef};\n pub use self::list::List;\n@@ -835,6 +835,12 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n+pub struct OpaqueTypeKey<'tcx> {\n+    pub def_id: DefId,\n+    pub substs: SubstsRef<'tcx>,\n+}\n+\n rustc_index::newtype_index! {\n     /// \"Universes\" are used during type- and trait-checking in the\n     /// presence of `for<..>` binders to control what sets of names are"}, {"sha": "bfeafa33a91cfca4e78569b2c78c9234ce9199b9", "filename": "compiler/rustc_mir/src/borrow_check/nll.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c4b540698165f2172dac8562bde84116f65d13bb/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b540698165f2172dac8562bde84116f65d13bb/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fnll.rs?ref=c4b540698165f2172dac8562bde84116f65d13bb", "patch": "@@ -1,15 +1,14 @@\n //! The entry point of the NLL borrow checker.\n \n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::Diagnostic;\n-use rustc_hir::def_id::DefId;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::mir::{\n     BasicBlock, Body, ClosureOutlivesSubject, ClosureRegionRequirements, LocalKind, Location,\n     Promoted,\n };\n-use rustc_middle::ty::{self, RegionKind, RegionVid};\n+use rustc_middle::ty::{self, OpaqueTypeKey, RegionKind, RegionVid, Ty};\n use rustc_span::symbol::sym;\n use std::env;\n use std::fmt::Debug;\n@@ -47,7 +46,7 @@ crate type PoloniusOutput = Output<RustcFacts>;\n /// closure requirements to propagate, and any generated errors.\n crate struct NllOutput<'tcx> {\n     pub regioncx: RegionInferenceContext<'tcx>,\n-    pub opaque_type_values: FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>>,\n+    pub opaque_type_values: VecMap<OpaqueTypeKey<'tcx>, Ty<'tcx>>,\n     pub polonius_output: Option<Rc<PoloniusOutput>>,\n     pub opt_closure_req: Option<ClosureRegionRequirements<'tcx>>,\n     pub nll_errors: RegionErrors<'tcx>,\n@@ -367,7 +366,7 @@ pub(super) fn dump_annotation<'a, 'tcx>(\n     body: &Body<'tcx>,\n     regioncx: &RegionInferenceContext<'tcx>,\n     closure_region_requirements: &Option<ClosureRegionRequirements<'_>>,\n-    opaque_type_values: &FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>>,\n+    opaque_type_values: &VecMap<OpaqueTypeKey<'tcx>, Ty<'tcx>>,\n     errors_buffer: &mut Vec<Diagnostic>,\n ) {\n     let tcx = infcx.tcx;"}, {"sha": "3ec24156f223717f0d63438e852fc1bfe87c35a7", "filename": "compiler/rustc_mir/src/borrow_check/region_infer/opaque_types.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c4b540698165f2172dac8562bde84116f65d13bb/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b540698165f2172dac8562bde84116f65d13bb/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fopaque_types.rs?ref=c4b540698165f2172dac8562bde84116f65d13bb", "patch": "@@ -1,7 +1,6 @@\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::def_id::DefId;\n+use rustc_data_structures::vec_map::VecMap;\n use rustc_infer::infer::InferCtxt;\n-use rustc_middle::ty::{self, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, OpaqueTypeKey, Ty, TyCtxt, TypeFoldable};\n use rustc_span::Span;\n use rustc_trait_selection::opaque_types::InferCtxtExt;\n \n@@ -51,12 +50,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     pub(in crate::borrow_check) fn infer_opaque_types(\n         &self,\n         infcx: &InferCtxt<'_, 'tcx>,\n-        opaque_ty_decls: FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>>,\n+        opaque_ty_decls: VecMap<OpaqueTypeKey<'tcx>, Ty<'tcx>>,\n         span: Span,\n-    ) -> FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>> {\n+    ) -> VecMap<OpaqueTypeKey<'tcx>, Ty<'tcx>> {\n         opaque_ty_decls\n             .into_iter()\n-            .map(|(opaque_def_id, ty::ResolvedOpaqueTy { concrete_type, substs })| {\n+            .map(|(opaque_type_key, concrete_type)| {\n+                let substs = opaque_type_key.substs;\n                 debug!(?concrete_type, ?substs);\n \n                 let mut subst_regions = vec![self.universal_regions.fr_static];\n@@ -110,16 +110,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n                 debug!(?universal_concrete_type, ?universal_substs);\n \n+                let opaque_type_key =\n+                    OpaqueTypeKey { def_id: opaque_type_key.def_id, substs: universal_substs };\n                 let remapped_type = infcx.infer_opaque_definition_from_instantiation(\n-                    opaque_def_id,\n-                    universal_substs,\n+                    opaque_type_key,\n                     universal_concrete_type,\n                     span,\n                 );\n-                (\n-                    opaque_def_id,\n-                    ty::ResolvedOpaqueTy { concrete_type: remapped_type, substs: universal_substs },\n-                )\n+                (opaque_type_key, remapped_type)\n             })\n             .collect()\n     }"}, {"sha": "09cafddeeffde9213c4f1997e3f4fe69b6d5fdc7", "filename": "compiler/rustc_mir/src/borrow_check/type_check/mod.rs", "status": "modified", "additions": 23, "deletions": 26, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c4b540698165f2172dac8562bde84116f65d13bb/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b540698165f2172dac8562bde84116f65d13bb/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=c4b540698165f2172dac8562bde84116f65d13bb", "patch": "@@ -7,9 +7,10 @@ use either::Either;\n \n use rustc_data_structures::frozen::Frozen;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n@@ -27,8 +28,8 @@ use rustc_middle::ty::cast::CastTy;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::{GenericArgKind, Subst, SubstsRef, UserSubsts};\n use rustc_middle::ty::{\n-    self, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, RegionVid, ToPredicate, Ty,\n-    TyCtxt, UserType, UserTypeAnnotationIndex, WithConstness,\n+    self, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, OpaqueTypeKey, RegionVid,\n+    ToPredicate, Ty, TyCtxt, UserType, UserTypeAnnotationIndex, WithConstness,\n };\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::VariantIdx;\n@@ -818,7 +819,7 @@ struct TypeChecker<'a, 'tcx> {\n     reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n     borrowck_context: &'a mut BorrowCheckContext<'a, 'tcx>,\n     universal_region_relations: &'a UniversalRegionRelations<'tcx>,\n-    opaque_type_values: FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>>,\n+    opaque_type_values: VecMap<OpaqueTypeKey<'tcx>, Ty<'tcx>>,\n }\n \n struct BorrowCheckContext<'a, 'tcx> {\n@@ -833,7 +834,7 @@ struct BorrowCheckContext<'a, 'tcx> {\n crate struct MirTypeckResults<'tcx> {\n     crate constraints: MirTypeckRegionConstraints<'tcx>,\n     pub(in crate::borrow_check) universal_region_relations: Frozen<UniversalRegionRelations<'tcx>>,\n-    crate opaque_type_values: FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>>,\n+    crate opaque_type_values: VecMap<OpaqueTypeKey<'tcx>, Ty<'tcx>>,\n }\n \n /// A collection of region constraints that must be satisfied for the\n@@ -978,7 +979,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             borrowck_context,\n             reported_errors: Default::default(),\n             universal_region_relations,\n-            opaque_type_values: FxHashMap::default(),\n+            opaque_type_values: VecMap::default(),\n         };\n         checker.check_user_type_annotations();\n         checker\n@@ -1240,7 +1241,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         let param_env = self.param_env;\n         let body = self.body;\n         let concrete_opaque_types = &tcx.typeck(anon_owner_def_id).concrete_opaque_types;\n-        let mut opaque_type_values = Vec::new();\n+        let mut opaque_type_values = VecMap::new();\n \n         debug!(\"eq_opaque_type_and_type: mir_def_id={:?}\", body.source.def_id());\n         let opaque_type_map = self.fully_perform_op(\n@@ -1281,37 +1282,39 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             .eq(output_ty, revealed_ty)?,\n                     );\n \n-                    for (&opaque_def_id, opaque_decl) in &opaque_type_map {\n+                    for &(opaque_type_key, opaque_decl) in &opaque_type_map {\n                         let resolved_ty = infcx.resolve_vars_if_possible(opaque_decl.concrete_ty);\n                         let concrete_is_opaque = if let ty::Opaque(def_id, _) = resolved_ty.kind() {\n-                            *def_id == opaque_def_id\n+                            *def_id == opaque_type_key.def_id\n                         } else {\n                             false\n                         };\n-                        let opaque_defn_ty = match concrete_opaque_types.get(&opaque_def_id) {\n+\n+                        let concrete_ty = match concrete_opaque_types\n+                            .get_by(|(key, _)| key.def_id == opaque_type_key.def_id)\n+                        {\n                             None => {\n                                 if !concrete_is_opaque {\n                                     tcx.sess.delay_span_bug(\n                                         body.span,\n                                         &format!(\n                                             \"Non-defining use of {:?} with revealed type\",\n-                                            opaque_def_id,\n+                                            opaque_type_key.def_id,\n                                         ),\n                                     );\n                                 }\n                                 continue;\n                             }\n-                            Some(opaque_defn_ty) => opaque_defn_ty,\n+                            Some(concrete_ty) => concrete_ty,\n                         };\n-                        debug!(\"opaque_defn_ty = {:?}\", opaque_defn_ty);\n-                        let subst_opaque_defn_ty =\n-                            opaque_defn_ty.concrete_type.subst(tcx, opaque_decl.substs);\n+                        debug!(\"concrete_ty = {:?}\", concrete_ty);\n+                        let subst_opaque_defn_ty = concrete_ty.subst(tcx, opaque_type_key.substs);\n                         let renumbered_opaque_defn_ty =\n                             renumber::renumber_regions(infcx, subst_opaque_defn_ty);\n \n                         debug!(\n                             \"eq_opaque_type_and_type: concrete_ty={:?}={:?} opaque_defn_ty={:?}\",\n-                            opaque_decl.concrete_ty, resolved_ty, renumbered_opaque_defn_ty,\n+                            concrete_ty, resolved_ty, renumbered_opaque_defn_ty,\n                         );\n \n                         if !concrete_is_opaque {\n@@ -1322,13 +1325,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                     .at(&ObligationCause::dummy(), param_env)\n                                     .eq(opaque_decl.concrete_ty, renumbered_opaque_defn_ty)?,\n                             );\n-                            opaque_type_values.push((\n-                                opaque_def_id,\n-                                ty::ResolvedOpaqueTy {\n-                                    concrete_type: renumbered_opaque_defn_ty,\n-                                    substs: opaque_decl.substs,\n-                                },\n-                            ));\n+                            opaque_type_values.insert(opaque_type_key, renumbered_opaque_defn_ty);\n                         } else {\n                             // We're using an opaque `impl Trait` type without\n                             // 'revealing' it. For example, code like this:\n@@ -1351,7 +1348,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             // gets 'revealed' into\n                             debug!(\n                                 \"eq_opaque_type_and_type: non-defining use of {:?}\",\n-                                opaque_def_id,\n+                                opaque_type_key.def_id,\n                             );\n                         }\n                     }\n@@ -1376,14 +1373,14 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         // prove that `T: Iterator` where `T` is the type we\n         // instantiated it with).\n         if let Some(opaque_type_map) = opaque_type_map {\n-            for (opaque_def_id, opaque_decl) in opaque_type_map {\n+            for (opaque_type_key, opaque_decl) in opaque_type_map {\n                 self.fully_perform_op(\n                     locations,\n                     ConstraintCategory::OpaqueType,\n                     CustomTypeOp::new(\n                         |_cx| {\n                             infcx.constrain_opaque_type(\n-                                opaque_def_id,\n+                                opaque_type_key,\n                                 &opaque_decl,\n                                 GenerateMemberConstraints::IfNoStaticBound,\n                                 universal_region_relations,"}, {"sha": "89ec211f2627bcadf4ec47f8eb14e5095e71aa2b", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 43, "deletions": 42, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/c4b540698165f2172dac8562bde84116f65d13bb/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b540698165f2172dac8562bde84116f65d13bb/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=c4b540698165f2172dac8562bde84116f65d13bb", "patch": "@@ -2,21 +2,22 @@ use crate::infer::InferCtxtExt as _;\n use crate::traits::{self, PredicateObligation};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::vec_map::VecMap;\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId};\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::Node;\n use rustc_infer::infer::error_reporting::unexpected_hidden_region_diagnostic;\n use rustc_infer::infer::free_regions::FreeRegionRelations;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{self, InferCtxt, InferOk};\n use rustc_middle::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder, TypeVisitor};\n-use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst, SubstsRef};\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst};\n+use rustc_middle::ty::{self, OpaqueTypeKey, Ty, TyCtxt};\n use rustc_span::Span;\n \n use std::ops::ControlFlow;\n \n-pub type OpaqueTypeMap<'tcx> = DefIdMap<OpaqueTypeDecl<'tcx>>;\n+pub type OpaqueTypeMap<'tcx> = VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>;\n \n /// Information about the opaque types whose values we\n /// are inferring in this function (these are the `impl Trait` that\n@@ -26,19 +27,6 @@ pub struct OpaqueTypeDecl<'tcx> {\n     /// The opaque type (`ty::Opaque`) for this declaration.\n     pub opaque_type: Ty<'tcx>,\n \n-    /// The substitutions that we apply to the opaque type that this\n-    /// `impl Trait` desugars to. e.g., if:\n-    ///\n-    ///     fn foo<'a, 'b, T>() -> impl Trait<'a>\n-    ///\n-    /// winds up desugared to:\n-    ///\n-    ///     type Foo<'x, X> = impl Trait<'x>\n-    ///     fn foo<'a, 'b, T>() -> Foo<'a, T>\n-    ///\n-    /// then `substs` would be `['a, T]`.\n-    pub substs: SubstsRef<'tcx>,\n-\n     /// The span of this particular definition of the opaque type. So\n     /// for example:\n     ///\n@@ -125,7 +113,7 @@ pub trait InferCtxtExt<'tcx> {\n \n     fn constrain_opaque_type<FRR: FreeRegionRelations<'tcx>>(\n         &self,\n-        def_id: DefId,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n         opaque_defn: &OpaqueTypeDecl<'tcx>,\n         mode: GenerateMemberConstraints,\n         free_region_relations: &FRR,\n@@ -136,14 +124,13 @@ pub trait InferCtxtExt<'tcx> {\n         &self,\n         concrete_ty: Ty<'tcx>,\n         opaque_defn: &OpaqueTypeDecl<'tcx>,\n-        opaque_type_def_id: DefId,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n         first_own_region_index: usize,\n     );\n \n     fn infer_opaque_definition_from_instantiation(\n         &self,\n-        def_id: DefId,\n-        substs: SubstsRef<'tcx>,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n         instantiated_ty: Ty<'tcx>,\n         span: Span,\n     ) -> Ty<'tcx>;\n@@ -370,10 +357,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     ) {\n         debug!(\"constrain_opaque_types()\");\n \n-        for (&def_id, opaque_defn) in opaque_types {\n+        for &(opaque_type_key, opaque_defn) in opaque_types {\n             self.constrain_opaque_type(\n-                def_id,\n-                opaque_defn,\n+                opaque_type_key,\n+                &opaque_defn,\n                 GenerateMemberConstraints::WhenRequired,\n                 free_region_relations,\n             );\n@@ -383,11 +370,13 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     /// See `constrain_opaque_types` for documentation.\n     fn constrain_opaque_type<FRR: FreeRegionRelations<'tcx>>(\n         &self,\n-        def_id: DefId,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n         opaque_defn: &OpaqueTypeDecl<'tcx>,\n         mode: GenerateMemberConstraints,\n         free_region_relations: &FRR,\n     ) {\n+        let def_id = opaque_type_key.def_id;\n+\n         debug!(\"constrain_opaque_type()\");\n         debug!(\"constrain_opaque_type: def_id={:?}\", def_id);\n         debug!(\"constrain_opaque_type: opaque_defn={:#?}\", opaque_defn);\n@@ -426,9 +415,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             let bounds = tcx.explicit_item_bounds(def_id);\n             debug!(\"constrain_opaque_type: predicates: {:#?}\", bounds);\n             let bounds: Vec<_> =\n-                bounds.iter().map(|(bound, _)| bound.subst(tcx, opaque_defn.substs)).collect();\n+                bounds.iter().map(|(bound, _)| bound.subst(tcx, opaque_type_key.substs)).collect();\n             debug!(\"constrain_opaque_type: bounds={:#?}\", bounds);\n-            let opaque_type = tcx.mk_opaque(def_id, opaque_defn.substs);\n+            let opaque_type = tcx.mk_opaque(def_id, opaque_type_key.substs);\n \n             let required_region_bounds =\n                 required_region_bounds(tcx, opaque_type, bounds.into_iter());\n@@ -440,7 +429,12 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 });\n             }\n             if let GenerateMemberConstraints::IfNoStaticBound = mode {\n-                self.generate_member_constraint(concrete_ty, opaque_defn, def_id, first_own_region);\n+                self.generate_member_constraint(\n+                    concrete_ty,\n+                    opaque_defn,\n+                    opaque_type_key,\n+                    first_own_region,\n+                );\n             }\n             return;\n         }\n@@ -454,7 +448,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // second.\n         let mut least_region = None;\n \n-        for subst_arg in &opaque_defn.substs[first_own_region..] {\n+        for subst_arg in &opaque_type_key.substs[first_own_region..] {\n             let subst_region = match subst_arg.unpack() {\n                 GenericArgKind::Lifetime(r) => r,\n                 GenericArgKind::Type(_) | GenericArgKind::Const(_) => continue,\n@@ -484,7 +478,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         return self.generate_member_constraint(\n                             concrete_ty,\n                             opaque_defn,\n-                            def_id,\n+                            opaque_type_key,\n                             first_own_region,\n                         );\n                     }\n@@ -497,7 +491,12 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         if let GenerateMemberConstraints::IfNoStaticBound = mode {\n             if least_region != tcx.lifetimes.re_static {\n-                self.generate_member_constraint(concrete_ty, opaque_defn, def_id, first_own_region);\n+                self.generate_member_constraint(\n+                    concrete_ty,\n+                    opaque_defn,\n+                    opaque_type_key,\n+                    first_own_region,\n+                );\n             }\n         }\n         concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n@@ -517,14 +516,14 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         &self,\n         concrete_ty: Ty<'tcx>,\n         opaque_defn: &OpaqueTypeDecl<'tcx>,\n-        opaque_type_def_id: DefId,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n         first_own_region: usize,\n     ) {\n         // Create the set of choice regions: each region in the hidden\n         // type can be equal to any of the region parameters of the\n         // opaque type definition.\n         let choice_regions: Lrc<Vec<ty::Region<'tcx>>> = Lrc::new(\n-            opaque_defn.substs[first_own_region..]\n+            opaque_type_key.substs[first_own_region..]\n                 .iter()\n                 .filter_map(|arg| match arg.unpack() {\n                     GenericArgKind::Lifetime(r) => Some(r),\n@@ -537,7 +536,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n             op: |r| {\n                 self.member_constraint(\n-                    opaque_type_def_id,\n+                    opaque_type_key.def_id,\n                     opaque_defn.definition_span,\n                     concrete_ty,\n                     r,\n@@ -572,11 +571,12 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     ///   `opaque_defn.concrete_ty`\n     fn infer_opaque_definition_from_instantiation(\n         &self,\n-        def_id: DefId,\n-        substs: SubstsRef<'tcx>,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n         instantiated_ty: Ty<'tcx>,\n         span: Span,\n     ) -> Ty<'tcx> {\n+        let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n+\n         debug!(\n             \"infer_opaque_definition_from_instantiation(def_id={:?}, instantiated_ty={:?})\",\n             def_id, instantiated_ty\n@@ -1007,7 +1007,9 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                             ),\n                         };\n                         if in_definition_scope {\n-                            return self.fold_opaque_ty(ty, def_id.to_def_id(), substs, origin);\n+                            let opaque_type_key =\n+                                OpaqueTypeKey { def_id: def_id.to_def_id(), substs };\n+                            return self.fold_opaque_ty(ty, opaque_type_key, origin);\n                         }\n \n                         debug!(\n@@ -1029,18 +1031,18 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n     fn fold_opaque_ty(\n         &mut self,\n         ty: Ty<'tcx>,\n-        def_id: DefId,\n-        substs: SubstsRef<'tcx>,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n         origin: hir::OpaqueTyOrigin,\n     ) -> Ty<'tcx> {\n         let infcx = self.infcx;\n         let tcx = infcx.tcx;\n+        let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n \n         debug!(\"instantiate_opaque_types: Opaque(def_id={:?}, substs={:?})\", def_id, substs);\n \n         // Use the same type variable if the exact same opaque type appears more\n         // than once in the return type (e.g., if it's passed to a type alias).\n-        if let Some(opaque_defn) = self.opaque_types.get(&def_id) {\n+        if let Some(opaque_defn) = self.opaque_types.get(&opaque_type_key) {\n             debug!(\"instantiate_opaque_types: returning concrete ty {:?}\", opaque_defn.concrete_ty);\n             return opaque_defn.concrete_ty;\n         }\n@@ -1078,10 +1080,9 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n         let definition_span = self.value_span;\n \n         self.opaque_types.insert(\n-            def_id,\n+            OpaqueTypeKey { def_id, substs },\n             OpaqueTypeDecl {\n                 opaque_type: ty,\n-                substs,\n                 definition_span,\n                 concrete_ty: ty_var,\n                 has_required_region_bounds: !required_region_bounds.is_empty(),"}, {"sha": "70d85796d002e961a70149c3cb06e1d1818699d0", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c4b540698165f2172dac8562bde84116f65d13bb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b540698165f2172dac8562bde84116f65d13bb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=c4b540698165f2172dac8562bde84116f65d13bb", "patch": "@@ -16,7 +16,7 @@ use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::layout::MAX_SIMD_LANES;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::util::{Discr, IntTypeExt};\n-use rustc_middle::ty::{self, ParamEnv, RegionKind, Ty, TyCtxt};\n+use rustc_middle::ty::{self, OpaqueTypeKey, ParamEnv, RegionKind, Ty, TyCtxt};\n use rustc_session::lint::builtin::UNINHABITED_STATIC;\n use rustc_span::symbol::sym;\n use rustc_span::{self, MultiSpan, Span};\n@@ -716,10 +716,10 @@ fn check_opaque_meets_bounds<'tcx>(\n             infcx.instantiate_opaque_types(def_id, hir_id, param_env, opaque_ty, span),\n         );\n \n-        for (def_id, opaque_defn) in opaque_type_map {\n+        for (OpaqueTypeKey { def_id, substs }, opaque_defn) in opaque_type_map {\n             match infcx\n                 .at(&misc_cause, param_env)\n-                .eq(opaque_defn.concrete_ty, tcx.type_of(def_id).subst(tcx, opaque_defn.substs))\n+                .eq(opaque_defn.concrete_ty, tcx.type_of(def_id).subst(tcx, substs))\n             {\n                 Ok(infer_ok) => inh.register_infer_ok_obligations(infer_ok),\n                 Err(ty_err) => tcx.sess.delay_span_bug("}, {"sha": "2e9bef15f900a715fe515a9bb3e8d7db23325d84", "filename": "compiler/rustc_typeck/src/check/inherited.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c4b540698165f2172dac8562bde84116f65d13bb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b540698165f2172dac8562bde84116f65d13bb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs?ref=c4b540698165f2172dac8562bde84116f65d13bb", "patch": "@@ -2,13 +2,14 @@ use super::callee::DeferredCallResolution;\n use super::MaybeInProgressTables;\n \n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::vec_map::VecMap;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefIdMap, LocalDefId};\n use rustc_hir::HirIdMap;\n use rustc_infer::infer;\n use rustc_infer::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n use rustc_middle::ty::fold::TypeFoldable;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, OpaqueTypeKey, Ty, TyCtxt};\n use rustc_span::{self, Span};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::opaque_types::OpaqueTypeDecl;\n@@ -58,7 +59,7 @@ pub struct Inherited<'a, 'tcx> {\n     // associated fresh inference variable. Writeback resolves these\n     // variables to get the concrete type, which can be used to\n     // 'de-opaque' OpaqueTypeDecl, after typeck is done with all functions.\n-    pub(super) opaque_types: RefCell<DefIdMap<OpaqueTypeDecl<'tcx>>>,\n+    pub(super) opaque_types: RefCell<VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>>,\n \n     /// A map from inference variables created from opaque\n     /// type instantiations (`ty::Infer`) to the actual opaque"}, {"sha": "032cc7ee2334abc18a641f34cbb022dc577ee171", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c4b540698165f2172dac8562bde84116f65d13bb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b540698165f2172dac8562bde84116f65d13bb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=c4b540698165f2172dac8562bde84116f65d13bb", "patch": "@@ -475,8 +475,9 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     }\n \n     fn visit_opaque_types(&mut self, span: Span) {\n-        for (&def_id, opaque_defn) in self.fcx.opaque_types.borrow().iter() {\n-            let hir_id = self.tcx().hir().local_def_id_to_hir_id(def_id.expect_local());\n+        for &(opaque_type_key, opaque_defn) in self.fcx.opaque_types.borrow().iter() {\n+            let hir_id =\n+                self.tcx().hir().local_def_id_to_hir_id(opaque_type_key.def_id.expect_local());\n             let instantiated_ty = self.resolve(opaque_defn.concrete_ty, &hir_id);\n \n             debug_assert!(!instantiated_ty.has_escaping_bound_vars());\n@@ -494,50 +495,47 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             // ```\n             // figures out the concrete type with `U`, but the stored type is with `T`.\n             let definition_ty = self.fcx.infer_opaque_definition_from_instantiation(\n-                def_id,\n-                opaque_defn.substs,\n+                opaque_type_key,\n                 instantiated_ty,\n                 span,\n             );\n \n             let mut skip_add = false;\n \n-            if let ty::Opaque(defin_ty_def_id, _substs) = *definition_ty.kind() {\n+            if let ty::Opaque(definition_ty_def_id, _substs) = *definition_ty.kind() {\n                 if let hir::OpaqueTyOrigin::Misc | hir::OpaqueTyOrigin::TyAlias = opaque_defn.origin\n                 {\n-                    if def_id == defin_ty_def_id {\n+                    if opaque_type_key.def_id == definition_ty_def_id {\n                         debug!(\n                             \"skipping adding concrete definition for opaque type {:?} {:?}\",\n-                            opaque_defn, defin_ty_def_id\n+                            opaque_defn, opaque_type_key.def_id\n                         );\n                         skip_add = true;\n                     }\n                 }\n             }\n \n-            if !opaque_defn.substs.needs_infer() {\n+            if !opaque_type_key.substs.needs_infer() {\n                 // We only want to add an entry into `concrete_opaque_types`\n                 // if we actually found a defining usage of this opaque type.\n                 // Otherwise, we do nothing - we'll either find a defining usage\n                 // in some other location, or we'll end up emitting an error due\n                 // to the lack of defining usage\n                 if !skip_add {\n-                    let new = ty::ResolvedOpaqueTy {\n-                        concrete_type: definition_ty,\n-                        substs: opaque_defn.substs,\n-                    };\n-\n-                    let old = self.typeck_results.concrete_opaque_types.insert(def_id, new);\n-                    if let Some(old) = old {\n-                        if old.concrete_type != definition_ty || old.substs != opaque_defn.substs {\n+                    let old_concrete_ty = self\n+                        .typeck_results\n+                        .concrete_opaque_types\n+                        .insert(opaque_type_key, definition_ty);\n+                    if let Some(old_concrete_ty) = old_concrete_ty {\n+                        if old_concrete_ty != definition_ty {\n                             span_bug!(\n                                 span,\n                                 \"`visit_opaque_types` tried to write different types for the same \\\n                                  opaque type: {:?}, {:?}, {:?}, {:?}\",\n-                                def_id,\n+                                opaque_type_key.def_id,\n                                 definition_ty,\n                                 opaque_defn,\n-                                old,\n+                                old_concrete_ty,\n                             );\n                         }\n                     }"}, {"sha": "29a87b18a9eb7efe5b1349649cec856e70cca496", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c4b540698165f2172dac8562bde84116f65d13bb/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b540698165f2172dac8562bde84116f65d13bb/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=c4b540698165f2172dac8562bde84116f65d13bb", "patch": "@@ -349,8 +349,8 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     let concrete_ty = tcx\n                         .mir_borrowck(owner.expect_local())\n                         .concrete_opaque_types\n-                        .get(&def_id.to_def_id())\n-                        .map(|opaque| opaque.concrete_type)\n+                        .get_by(|(key, _)| key.def_id == def_id.to_def_id())\n+                        .map(|concrete_ty| *concrete_ty)\n                         .unwrap_or_else(|| {\n                             tcx.sess.delay_span_bug(\n                                 DUMMY_SP,\n@@ -515,19 +515,27 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n             }\n             // Calling `mir_borrowck` can lead to cycle errors through\n             // const-checking, avoid calling it if we don't have to.\n-            if !self.tcx.typeck(def_id).concrete_opaque_types.contains_key(&self.def_id) {\n+            if self\n+                .tcx\n+                .typeck(def_id)\n+                .concrete_opaque_types\n+                .get_by(|(key, _)| key.def_id == self.def_id)\n+                .is_none()\n+            {\n                 debug!(\n                     \"find_opaque_ty_constraints: no constraint for `{:?}` at `{:?}`\",\n                     self.def_id, def_id,\n                 );\n                 return;\n             }\n             // Use borrowck to get the type with unerased regions.\n-            let ty = self.tcx.mir_borrowck(def_id).concrete_opaque_types.get(&self.def_id);\n-            if let Some(ty::ResolvedOpaqueTy { concrete_type, substs }) = ty {\n+            let concrete_opaque_types = &self.tcx.mir_borrowck(def_id).concrete_opaque_types;\n+            if let Some((opaque_type_key, concrete_type)) =\n+                concrete_opaque_types.iter().find(|(key, _)| key.def_id == self.def_id)\n+            {\n                 debug!(\n                     \"find_opaque_ty_constraints: found constraint for `{:?}` at `{:?}`: {:?}\",\n-                    self.def_id, def_id, ty,\n+                    self.def_id, def_id, concrete_type,\n                 );\n \n                 // FIXME(oli-obk): trace the actual span from inference to improve errors.\n@@ -538,7 +546,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n                 // using `delay_span_bug`, just in case `wfcheck` slips up.\n                 let opaque_generics = self.tcx.generics_of(self.def_id);\n                 let mut used_params: FxHashSet<_> = FxHashSet::default();\n-                for (i, arg) in substs.iter().enumerate() {\n+                for (i, arg) in opaque_type_key.substs.iter().enumerate() {\n                     let arg_is_param = match arg.unpack() {\n                         GenericArgKind::Type(ty) => matches!(ty.kind(), ty::Param(_)),\n                         GenericArgKind::Lifetime(lt) => {\n@@ -699,8 +707,8 @@ fn let_position_impl_trait_type(tcx: TyCtxt<'_>, opaque_ty_id: LocalDefId) -> Ty\n     let owner_typeck_results = tcx.typeck(scope_def_id);\n     let concrete_ty = owner_typeck_results\n         .concrete_opaque_types\n-        .get(&opaque_ty_def_id)\n-        .map(|opaque| opaque.concrete_type)\n+        .get_by(|(key, _)| key.def_id == opaque_ty_def_id)\n+        .map(|concrete_ty| *concrete_ty)\n         .unwrap_or_else(|| {\n             tcx.sess.delay_span_bug(\n                 DUMMY_SP,"}, {"sha": "ecad910f7d542a70830a5da2939f3b52161a421f", "filename": "src/test/ui/type-alias-impl-trait/multiple-def-uses-in-one-fn-pass.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c4b540698165f2172dac8562bde84116f65d13bb/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b540698165f2172dac8562bde84116f65d13bb/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn-pass.rs?ref=c4b540698165f2172dac8562bde84116f65d13bb", "patch": "@@ -0,0 +1,12 @@\n+// check-pass\n+#![feature(min_type_alias_impl_trait)]\n+\n+type X<A: ToString + Clone, B: ToString + Clone> = impl ToString;\n+\n+fn f<A: ToString + Clone, B: ToString + Clone>(a: A, b: B) -> (X<A, B>, X<A, B>) {\n+    (a.clone(), a)\n+}\n+\n+fn main() {\n+    println!(\"{}\", <X<_, _> as ToString>::to_string(&f(42_i32, String::new()).1));\n+}"}, {"sha": "67351e2015993d48aacd01a33b5440abef2ba95c", "filename": "src/test/ui/type-alias-impl-trait/multiple-def-uses-in-one-fn.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c4b540698165f2172dac8562bde84116f65d13bb/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b540698165f2172dac8562bde84116f65d13bb/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.rs?ref=c4b540698165f2172dac8562bde84116f65d13bb", "patch": "@@ -0,0 +1,16 @@\n+// https://github.com/rust-lang/rust/issues/73481\n+// This test used to cause unsoundness, since one of the two possible\n+// resolutions was chosen at random instead of erroring due to conflicts.\n+\n+#![feature(min_type_alias_impl_trait)]\n+\n+type X<A, B> = impl Into<&'static A>;\n+//~^ ERROR the trait bound `&'static B: From<&A>` is not satisfied\n+\n+fn f<A, B: 'static>(a: &'static A, b: B) -> (X<A, B>, X<B, A>) {\n+    (a, a)\n+}\n+\n+fn main() {\n+    println!(\"{}\", <X<_, _> as Into<&String>>::into(f(&[1isize, 2, 3], String::new()).1));\n+}"}, {"sha": "731c6e2788dde5e6b8206e90ef1caa0548013516", "filename": "src/test/ui/type-alias-impl-trait/multiple-def-uses-in-one-fn.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c4b540698165f2172dac8562bde84116f65d13bb/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4b540698165f2172dac8562bde84116f65d13bb/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.stderr?ref=c4b540698165f2172dac8562bde84116f65d13bb", "patch": "@@ -0,0 +1,15 @@\n+error[E0277]: the trait bound `&'static B: From<&A>` is not satisfied\n+  --> $DIR/multiple-def-uses-in-one-fn.rs:7:16\n+   |\n+LL | type X<A, B> = impl Into<&'static A>;\n+   |                ^^^^^^^^^^^^^^^^^^^^^ the trait `From<&A>` is not implemented for `&'static B`\n+   |\n+   = note: required because of the requirements on the impl of `Into<&'static B>` for `&A`\n+help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n+   |\n+LL | fn f<A, B: 'static>(a: &'static A, b: B) -> (X<A, B>, X<B, A>) where &'static B: From<&A> {\n+   |                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "38aa18fe40ee71ab57da0c7d82945a0b14904b34", "filename": "src/test/ui/type-alias-impl-trait/multiple-def-uses-in-one-fn2.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c4b540698165f2172dac8562bde84116f65d13bb/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b540698165f2172dac8562bde84116f65d13bb/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn2.rs?ref=c4b540698165f2172dac8562bde84116f65d13bb", "patch": "@@ -0,0 +1,16 @@\n+// https://github.com/rust-lang/rust/issues/73481\n+// This test used to cause unsoundness, since one of the two possible\n+// resolutions was chosen at random instead of erroring due to conflicts.\n+\n+#![feature(min_type_alias_impl_trait)]\n+\n+type X<A: ToString + Clone, B: ToString + Clone> = impl ToString;\n+//~^ ERROR could not find defining uses\n+\n+fn f<A: ToString + Clone, B: ToString + Clone>(a: A, b: B) -> (X<A, B>, X<B, A>) {\n+    (a.clone(), a)\n+}\n+\n+fn main() {\n+    println!(\"{}\", <X<_, _> as ToString>::to_string(&f(42_i32, String::new()).1));\n+}"}, {"sha": "c00973c0761b058c4410913294223756e8ec9e7f", "filename": "src/test/ui/type-alias-impl-trait/multiple-def-uses-in-one-fn2.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c4b540698165f2172dac8562bde84116f65d13bb/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4b540698165f2172dac8562bde84116f65d13bb/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn2.stderr?ref=c4b540698165f2172dac8562bde84116f65d13bb", "patch": "@@ -0,0 +1,8 @@\n+error: could not find defining uses\n+  --> $DIR/multiple-def-uses-in-one-fn2.rs:7:52\n+   |\n+LL | type X<A: ToString + Clone, B: ToString + Clone> = impl ToString;\n+   |                                                    ^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "17e900058113dd8283be89c3672611d5beb32af9", "filename": "src/test/ui/type-alias-impl-trait/multiple-def-uses-in-one-fn3.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c4b540698165f2172dac8562bde84116f65d13bb/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b540698165f2172dac8562bde84116f65d13bb/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn3.rs?ref=c4b540698165f2172dac8562bde84116f65d13bb", "patch": "@@ -0,0 +1,18 @@\n+// https://github.com/rust-lang/rust/issues/73481\n+// This test used to cause unsoundness, since one of the two possible\n+// resolutions was chosen at random instead of erroring due to conflicts.\n+\n+#![feature(min_type_alias_impl_trait)]\n+\n+type X<A: ToString + Clone, B: ToString + Clone> = impl ToString;\n+\n+fn f<A: ToString + Clone, B: ToString + Clone>(a: A, b: B) -> (X<A, B>, X<B, A>) {\n+    (a, b)\n+}\n+\n+fn g<A: ToString + Clone, B: ToString + Clone>(a: A, b: B) -> (X<A, B>, X<A, B>) {\n+    (a, b)\n+    //~^ ERROR mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "bbe709dccab4eb6e9404d4b5cba860ad4a7a2592", "filename": "src/test/ui/type-alias-impl-trait/multiple-def-uses-in-one-fn3.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c4b540698165f2172dac8562bde84116f65d13bb/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4b540698165f2172dac8562bde84116f65d13bb/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn3.stderr?ref=c4b540698165f2172dac8562bde84116f65d13bb", "patch": "@@ -0,0 +1,18 @@\n+error[E0308]: mismatched types\n+  --> $DIR/multiple-def-uses-in-one-fn3.rs:14:9\n+   |\n+LL | fn g<A: ToString + Clone, B: ToString + Clone>(a: A, b: B) -> (X<A, B>, X<A, B>) {\n+   |      -                    - found type parameter\n+   |      |\n+   |      expected type parameter\n+LL |     (a, b)\n+   |         ^ expected type parameter `A`, found type parameter `B`\n+   |\n+   = note: expected type parameter `A`\n+              found type parameter `B`\n+   = note: a type parameter was expected, but a different one was found; you might be missing a type parameter or trait bound\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}