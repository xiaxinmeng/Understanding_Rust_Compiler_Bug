{"sha": "fe212eca76f3976756e47355e4f0cb62984ec837", "node_id": "C_kwDOAAsO6NoAKGZlMjEyZWNhNzZmMzk3Njc1NmU0NzM1NWU0ZjBjYjYyOTg0ZWM4Mzc", "commit": {"author": {"name": "mejrs", "email": "", "date": "2022-11-07T18:47:32Z"}, "committer": {"name": "mejrs", "email": "", "date": "2022-11-21T14:24:50Z"}, "message": "Match crate and slug names", "tree": {"sha": "a4f98ff9af5f84e85e3b0900af3e32480f512c4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4f98ff9af5f84e85e3b0900af3e32480f512c4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe212eca76f3976756e47355e4f0cb62984ec837", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe212eca76f3976756e47355e4f0cb62984ec837", "html_url": "https://github.com/rust-lang/rust/commit/fe212eca76f3976756e47355e4f0cb62984ec837", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe212eca76f3976756e47355e4f0cb62984ec837/comments", "author": {}, "committer": {}, "parents": [{"sha": "736c675d2ab65bcde6554e1b73340c2dbc27c85a", "url": "https://api.github.com/repos/rust-lang/rust/commits/736c675d2ab65bcde6554e1b73340c2dbc27c85a", "html_url": "https://github.com/rust-lang/rust/commit/736c675d2ab65bcde6554e1b73340c2dbc27c85a"}], "stats": {"total": 1257, "additions": 652, "deletions": 605}, "files": [{"sha": "2cd4733220e829ce4d68d0dc4bb3aee962277608", "filename": "compiler/rustc_error_messages/locales/en-US/borrowck.ftl", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe212eca76f3976756e47355e4f0cb62984ec837/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/fe212eca76f3976756e47355e4f0cb62984ec837/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl?ref=fe212eca76f3976756e47355e4f0cb62984ec837", "patch": "@@ -24,9 +24,6 @@ borrowck_var_does_not_need_mut =\n     variable does not need to be mutable\n     .suggestion = remove this `mut`\n \n-borrowck_const_not_used_in_type_alias =\n-    const parameter `{$ct}` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-\n borrowck_var_cannot_escape_closure =\n     captured variable cannot escape `FnMut` closure body\n     .note = `FnMut` closures only have access to their captured variables while they are executing..."}, {"sha": "0894bbcaad474b5b36f8712a068e188b283992c8", "filename": "compiler/rustc_error_messages/locales/en-US/hir_analysis.ftl", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/fe212eca76f3976756e47355e4f0cb62984ec837/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/fe212eca76f3976756e47355e4f0cb62984ec837/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl?ref=fe212eca76f3976756e47355e4f0cb62984ec837", "patch": "@@ -1,8 +1,3 @@\n-hir_analysis_field_multiply_specified_in_initializer =\n-    field `{$ident}` specified more than once\n-    .label = used more than once\n-    .previous_use_label = first use of `{$ident}`\n-\n hir_analysis_unrecognized_atomic_operation =\n     unrecognized atomic operation function: `{$op}`\n     .label = unrecognized atomic operation\n@@ -54,44 +49,16 @@ hir_analysis_assoc_type_binding_not_allowed =\n     associated type bindings are not allowed here\n     .label = associated type not allowed here\n \n-hir_analysis_functional_record_update_on_non_struct =\n-    functional record update syntax requires a struct\n-\n hir_analysis_typeof_reserved_keyword_used =\n     `typeof` is a reserved keyword but unimplemented\n     .suggestion = consider replacing `typeof(...)` with an actual type\n     .label = reserved keyword\n \n-hir_analysis_return_stmt_outside_of_fn_body =\n-    return statement outside of function body\n-    .encl_body_label = the return is part of this body...\n-    .encl_fn_label = ...not the enclosing function body\n-\n-hir_analysis_yield_expr_outside_of_generator =\n-    yield expression outside of generator literal\n-\n-hir_analysis_struct_expr_non_exhaustive =\n-    cannot create non-exhaustive {$what} using struct expression\n-\n-hir_analysis_method_call_on_unknown_type =\n-    the type of this value must be known to call a method on a raw pointer on it\n-\n hir_analysis_value_of_associated_struct_already_specified =\n     the value of the associated type `{$item_name}` (from trait `{$def_path}`) is already specified\n     .label = re-bound here\n     .previous_bound_label = `{$item_name}` bound here first\n \n-hir_analysis_address_of_temporary_taken = cannot take address of a temporary\n-    .label = temporary value\n-\n-hir_analysis_add_return_type_add = try adding a return type\n-\n-hir_analysis_add_return_type_missing_here = a return type might be missing here\n-\n-hir_analysis_expected_default_return_type = expected `()` because of default return type\n-\n-hir_analysis_expected_return_type = expected `{$expected}` because of return type\n-\n hir_analysis_unconstrained_opaque_type = unconstrained opaque type\n     .note = `{$name}` must be used in combination with a concrete type within the same {$what}\n \n@@ -134,10 +101,6 @@ hir_analysis_extern_crate_not_idiomatic =\n \n hir_analysis_expected_used_symbol = expected `used`, `used(compiler)` or `used(linker)`\n \n-hir_analysis_missing_parentheses_in_range = can't call method `{$method_name}` on type `{$ty_str}`\n-\n-hir_analysis_add_missing_parentheses_in_range = you must surround the range in parentheses to call its `{$func_name}` function\n-\n hir_analysis_const_impl_for_non_const_trait =\n     const `impl` for trait `{$trait_name}` which is not marked with `#[const_trait]`\n     .suggestion = mark `{$trait_name}` as const\n@@ -150,6 +113,3 @@ hir_analysis_const_bound_for_non_const_trait =\n hir_analysis_self_in_impl_self =\n     `Self` is not valid in the self type of an impl block\n     .note = replace `Self` with a different type\n-\n-hir_analysis_op_trait_generic_params =\n-    `{$method_name}` must not have any generic parameters"}, {"sha": "0612dbae0b63029c0a3fd75e8bba92d1872c6d92", "filename": "compiler/rustc_error_messages/locales/en-US/hir_typeck.ftl", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/fe212eca76f3976756e47355e4f0cb62984ec837/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_typeck.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/fe212eca76f3976756e47355e4f0cb62984ec837/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_typeck.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_typeck.ftl?ref=fe212eca76f3976756e47355e4f0cb62984ec837", "patch": "@@ -6,3 +6,43 @@ hir_typeck_fru_suggestion =\n         [NONE]{\"\"}\n         *[other] {\" \"}from `{$expr}`\n     }, separate the last named field with a comma\n+\n+hir_typeck_field_multiply_specified_in_initializer =\n+    field `{$ident}` specified more than once\n+    .label = used more than once\n+    .previous_use_label = first use of `{$ident}`\n+\n+hir_typeck_return_stmt_outside_of_fn_body =\n+    return statement outside of function body\n+    .encl_body_label = the return is part of this body...\n+    .encl_fn_label = ...not the enclosing function body\n+\n+hir_typeck_yield_expr_outside_of_generator =\n+    yield expression outside of generator literal\n+\n+hir_typeck_struct_expr_non_exhaustive =\n+    cannot create non-exhaustive {$what} using struct expression\n+\n+hir_typeck_method_call_on_unknown_type =\n+    the type of this value must be known to call a method on a raw pointer on it\n+\n+hir_typeck_functional_record_update_on_non_struct =\n+    functional record update syntax requires a struct\n+\n+hir_typeck_address_of_temporary_taken = cannot take address of a temporary\n+    .label = temporary value\n+\n+hir_typeck_add_return_type_add = try adding a return type\n+\n+hir_typeck_add_return_type_missing_here = a return type might be missing here\n+\n+hir_typeck_expected_default_return_type = expected `()` because of default return type\n+\n+hir_typeck_expected_return_type = expected `{$expected}` because of return type\n+\n+hir_typeck_missing_parentheses_in_range = can't call method `{$method_name}` on type `{$ty_str}`\n+\n+hir_typeck_add_missing_parentheses_in_range = you must surround the range in parentheses to call its `{$func_name}` function\n+\n+hir_typeck_op_trait_generic_params =\n+    `{$method_name}` must not have any generic parameters"}, {"sha": "4f4e5c6a2c9c2218bed43d2e41ec213e9b4aa2e0", "filename": "compiler/rustc_error_messages/locales/en-US/middle.ftl", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe212eca76f3976756e47355e4f0cb62984ec837/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmiddle.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/fe212eca76f3976756e47355e4f0cb62984ec837/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmiddle.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmiddle.ftl?ref=fe212eca76f3976756e47355e4f0cb62984ec837", "patch": "@@ -31,3 +31,6 @@ middle_cannot_be_normalized =\n middle_strict_coherence_needs_negative_coherence =\n     to use `strict_coherence` on this trait, the `with_negative_coherence` feature must be enabled\n     .label = due to this attribute\n+\n+middle_const_not_used_in_type_alias =\n+    const parameter `{$ct}` is part of concrete type but not used in parameter list for the `impl Trait` type alias"}, {"sha": "114b7ec16288bb7b99f0abcb1ed89ba8559d68ad", "filename": "compiler/rustc_error_messages/locales/en-US/parse.ftl", "status": "added", "additions": 364, "deletions": 0, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/fe212eca76f3976756e47355e4f0cb62984ec837/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/fe212eca76f3976756e47355e4f0cb62984ec837/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl?ref=fe212eca76f3976756e47355e4f0cb62984ec837", "patch": "@@ -0,0 +1,364 @@\n+parse_struct_literal_body_without_path =\n+    struct literal body without path\n+    .suggestion = you might have forgotten to add the struct literal inside the block\n+\n+parse_maybe_report_ambiguous_plus =\n+    ambiguous `+` in a type\n+    .suggestion = use parentheses to disambiguate\n+\n+parse_maybe_recover_from_bad_type_plus =\n+    expected a path on the left-hand side of `+`, not `{$ty}`\n+\n+parse_add_paren = try adding parentheses\n+\n+parse_forgot_paren = perhaps you forgot parentheses?\n+\n+parse_expect_path = expected a path\n+\n+parse_maybe_recover_from_bad_qpath_stage_2 =\n+    missing angle brackets in associated item path\n+    .suggestion = try: `{$ty}`\n+\n+parse_incorrect_semicolon =\n+    expected item, found `;`\n+    .suggestion = remove this semicolon\n+    .help = {$name} declarations are not followed by a semicolon\n+\n+parse_incorrect_use_of_await =\n+    incorrect use of `await`\n+    .parentheses_suggestion = `await` is not a method call, remove the parentheses\n+    .postfix_suggestion = `await` is a postfix operation\n+\n+parse_in_in_typo =\n+    expected iterable, found keyword `in`\n+    .suggestion = remove the duplicated `in`\n+\n+parse_invalid_variable_declaration =\n+    invalid variable declaration\n+\n+parse_switch_mut_let_order =\n+    switch the order of `mut` and `let`\n+parse_missing_let_before_mut = missing keyword\n+parse_use_let_not_auto = write `let` instead of `auto` to introduce a new variable\n+parse_use_let_not_var = write `let` instead of `var` to introduce a new variable\n+\n+parse_invalid_comparison_operator = invalid comparison operator `{$invalid}`\n+    .use_instead = `{$invalid}` is not a valid comparison operator, use `{$correct}`\n+    .spaceship_operator_invalid = `<=>` is not a valid comparison operator, use `std::cmp::Ordering`\n+\n+parse_invalid_logical_operator = `{$incorrect}` is not a logical operator\n+    .note = unlike in e.g., Python and PHP, `&&` and `||` are used for logical operators\n+    .use_amp_amp_for_conjunction = use `&&` to perform logical conjunction\n+    .use_pipe_pipe_for_disjunction = use `||` to perform logical disjunction\n+\n+parse_tilde_is_not_unary_operator = `~` cannot be used as a unary operator\n+    .suggestion = use `!` to perform bitwise not\n+\n+parse_unexpected_if_with_if = unexpected `if` in the condition expression\n+    .suggestion = remove the `if`\n+\n+parse_unexpected_token_after_not = unexpected {$negated_desc} after identifier\n+parse_unexpected_token_after_not_bitwise = use `!` to perform bitwise not\n+parse_unexpected_token_after_not_logical = use `!` to perform logical negation\n+parse_unexpected_token_after_not_default = use `!` to perform logical negation or bitwise not\n+\n+parse_malformed_loop_label = malformed loop label\n+    .suggestion = use the correct loop label format\n+\n+parse_lifetime_in_borrow_expression = borrow expressions cannot be annotated with lifetimes\n+    .suggestion = remove the lifetime annotation\n+    .label = annotated with lifetime here\n+\n+parse_field_expression_with_generic = field expressions cannot have generic arguments\n+\n+parse_macro_invocation_with_qualified_path = macros cannot use qualified paths\n+\n+parse_unexpected_token_after_label = expected `while`, `for`, `loop` or `{\"{\"}` after a label\n+    .suggestion_remove_label = consider removing the label\n+    .suggestion_enclose_in_block = consider enclosing expression in a block\n+\n+parse_require_colon_after_labeled_expression = labeled expression must be followed by `:`\n+    .note = labels are used before loops and blocks, allowing e.g., `break 'label` to them\n+    .label = the label\n+    .suggestion = add `:` after the label\n+\n+parse_do_catch_syntax_removed = found removed `do catch` syntax\n+    .note = following RFC #2388, the new non-placeholder syntax is `try`\n+    .suggestion = replace with the new syntax\n+\n+parse_float_literal_requires_integer_part = float literals must have an integer part\n+    .suggestion = must have an integer part\n+\n+parse_missing_semicolon_before_array = expected `;`, found `[`\n+    .suggestion = consider adding `;` here\n+\n+parse_invalid_block_macro_segment = cannot use a `block` macro fragment here\n+    .label = the `block` fragment is within this context\n+\n+parse_expect_dotdot_not_dotdotdot = expected `..`, found `...`\n+    .suggestion = use `..` to fill in the rest of the fields\n+\n+parse_if_expression_missing_then_block = this `if` expression is missing a block after the condition\n+    .add_then_block = add a block here\n+    .condition_possibly_unfinished = this binary operation is possibly unfinished\n+\n+parse_if_expression_missing_condition = missing condition for `if` expression\n+    .condition_label = expected condition here\n+    .block_label = if this block is the condition of the `if` expression, then it must be followed by another block\n+\n+parse_expected_expression_found_let = expected expression, found `let` statement\n+\n+parse_expect_eq_instead_of_eqeq = expected `=`, found `==`\n+    .suggestion = consider using `=` here\n+\n+parse_expected_else_block = expected `{\"{\"}`, found {$first_tok}\n+    .label = expected an `if` or a block after this `else`\n+    .suggestion = add an `if` if this is the condition of a chained `else if` statement\n+\n+parse_outer_attribute_not_allowed_on_if_else = outer attributes are not allowed on `if` and `else` branches\n+    .branch_label = the attributes are attached to this branch\n+    .ctx_label = the branch belongs to this `{$ctx}`\n+    .suggestion = remove the attributes\n+\n+parse_missing_in_in_for_loop = missing `in` in `for` loop\n+    .use_in_not_of = try using `in` here instead\n+    .add_in = try adding `in` here\n+\n+parse_missing_comma_after_match_arm = expected `,` following `match` arm\n+    .suggestion = missing a comma here to end this `match` arm\n+\n+parse_catch_after_try = keyword `catch` cannot follow a `try` block\n+    .help = try using `match` on the result of the `try` block instead\n+\n+parse_comma_after_base_struct = cannot use a comma after the base struct\n+    .note = the base struct must always be the last field\n+    .suggestion = remove this comma\n+\n+parse_eq_field_init = expected `:`, found `=`\n+    .suggestion = replace equals symbol with a colon\n+\n+parse_dotdotdot = unexpected token: `...`\n+    .suggest_exclusive_range = use `..` for an exclusive range\n+    .suggest_inclusive_range = or `..=` for an inclusive range\n+\n+parse_left_arrow_operator = unexpected token: `<-`\n+    .suggestion = if you meant to write a comparison against a negative value, add a space in between `<` and `-`\n+\n+parse_remove_let = expected pattern, found `let`\n+    .suggestion = remove the unnecessary `let` keyword\n+\n+parse_use_eq_instead = unexpected `==`\n+    .suggestion = try using `=` instead\n+\n+parse_use_empty_block_not_semi = expected { \"`{}`\" }, found `;`\n+    .suggestion = try using { \"`{}`\" } instead\n+\n+parse_comparison_interpreted_as_generic =\n+    `<` is interpreted as a start of generic arguments for `{$type}`, not a comparison\n+    .label_args = interpreted as generic arguments\n+    .label_comparison = not interpreted as comparison\n+    .suggestion = try comparing the cast value\n+\n+parse_shift_interpreted_as_generic =\n+    `<<` is interpreted as a start of generic arguments for `{$type}`, not a shift\n+    .label_args = interpreted as generic arguments\n+    .label_comparison = not interpreted as shift\n+    .suggestion = try shifting the cast value\n+\n+parse_found_expr_would_be_stmt = expected expression, found `{$token}`\n+    .label = expected expression\n+\n+parse_leading_plus_not_supported = leading `+` is not supported\n+    .label = unexpected `+`\n+    .suggestion_remove_plus = try removing the `+`\n+\n+parse_parentheses_with_struct_fields = invalid `struct` delimiters or `fn` call arguments\n+    .suggestion_braces_for_struct = if `{$type}` is a struct, use braces as delimiters\n+    .suggestion_no_fields_for_fn = if `{$type}` is a function, use the arguments directly\n+\n+parse_labeled_loop_in_break = parentheses are required around this expression to avoid confusion with a labeled break expression\n+\n+parse_sugg_wrap_expression_in_parentheses = wrap the expression in parentheses\n+\n+parse_array_brackets_instead_of_braces = this is a block expression, not an array\n+    .suggestion = to make an array, use square brackets instead of curly braces\n+\n+parse_match_arm_body_without_braces = `match` arm body without braces\n+    .label_statements = {$num_statements ->\n+            [one] this statement is not surrounded by a body\n+           *[other] these statements are not surrounded by a body\n+        }\n+    .label_arrow = while parsing the `match` arm starting here\n+    .suggestion_add_braces = surround the {$num_statements ->\n+            [one] statement\n+           *[other] statements\n+        } with a body\n+    .suggestion_use_comma_not_semicolon = use a comma to end a `match` arm expression\n+\n+parse_struct_literal_not_allowed_here = struct literals are not allowed here\n+    .suggestion = surround the struct literal with parentheses\n+\n+parse_invalid_interpolated_expression = invalid interpolated expression\n+\n+parse_invalid_literal_suffix_on_tuple_index = suffixes on a tuple index are invalid\n+    .label = invalid suffix `{$suffix}`\n+    .tuple_exception_line_1 = `{$suffix}` is *temporarily* accepted on tuple index fields as it was incorrectly accepted on stable for a few releases\n+    .tuple_exception_line_2 = on proc macros, you'll want to use `syn::Index::from` or `proc_macro::Literal::*_unsuffixed` for code that will desugar to tuple field access\n+    .tuple_exception_line_3 = see issue #60210 <https://github.com/rust-lang/rust/issues/60210> for more information\n+\n+parse_non_string_abi_literal = non-string ABI literal\n+    .suggestion = specify the ABI with a string literal\n+\n+parse_mismatched_closing_delimiter = mismatched closing delimiter: `{$delimiter}`\n+    .label_unmatched = mismatched closing delimiter\n+    .label_opening_candidate = closing delimiter possibly meant for this\n+    .label_unclosed = unclosed delimiter\n+\n+parse_incorrect_visibility_restriction = incorrect visibility restriction\n+    .help = some possible visibility restrictions are:\n+            `pub(crate)`: visible only on the current crate\n+            `pub(super)`: visible only in the current module's parent\n+            `pub(in path::to::module)`: visible only on the specified path\n+    .suggestion = make this visible only to module `{$inner_str}` with `in`\n+\n+parse_assignment_else_not_allowed = <assignment> ... else {\"{\"} ... {\"}\"} is not allowed\n+\n+parse_expected_statement_after_outer_attr = expected statement after outer attribute\n+\n+parse_doc_comment_does_not_document_anything = found a documentation comment that doesn't document anything\n+    .help = doc comments must come before what they document, if a comment was intended use `//`\n+    .suggestion = missing comma here\n+\n+parse_const_let_mutually_exclusive = `const` and `let` are mutually exclusive\n+    .suggestion = remove `let`\n+\n+parse_invalid_expression_in_let_else = a `{$operator}` expression cannot be directly assigned in `let...else`\n+parse_invalid_curly_in_let_else = right curly brace `{\"}\"}` before `else` in a `let...else` statement not allowed\n+\n+parse_compound_assignment_expression_in_let = can't reassign to an uninitialized variable\n+    .suggestion = initialize the variable\n+    .help = if you meant to overwrite, remove the `let` binding\n+\n+parse_suffixed_literal_in_attribute = suffixed literals are not allowed in attributes\n+    .help = instead of using a suffixed literal (`1u8`, `1.0f32`, etc.), use an unsuffixed version (`1`, `1.0`, etc.)\n+\n+parse_invalid_meta_item = expected unsuffixed literal or identifier, found `{$token}`\n+\n+parse_label_inner_attr_does_not_annotate_this = the inner attribute doesn't annotate this {$item}\n+parse_sugg_change_inner_attr_to_outer = to annotate the {$item}, change the attribute from inner to outer style\n+\n+parse_inner_attr_not_permitted_after_outer_doc_comment = an inner attribute is not permitted following an outer doc comment\n+    .label_attr = not permitted following an outer doc comment\n+    .label_prev_doc_comment = previous doc comment\n+    .label_does_not_annotate_this = {parse_label_inner_attr_does_not_annotate_this}\n+    .sugg_change_inner_to_outer = {parse_sugg_change_inner_attr_to_outer}\n+\n+parse_inner_attr_not_permitted_after_outer_attr = an inner attribute is not permitted following an outer attribute\n+    .label_attr = not permitted following an outer attribute\n+    .label_prev_attr = previous outer attribute\n+    .label_does_not_annotate_this = {parse_label_inner_attr_does_not_annotate_this}\n+    .sugg_change_inner_to_outer = {parse_sugg_change_inner_attr_to_outer}\n+\n+parse_inner_attr_not_permitted = an inner attribute is not permitted in this context\n+    .label_does_not_annotate_this = {parse_label_inner_attr_does_not_annotate_this}\n+    .sugg_change_inner_to_outer = {parse_sugg_change_inner_attr_to_outer}\n+\n+parse_inner_attr_explanation = inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files\n+parse_outer_attr_explanation = outer attributes, like `#[test]`, annotate the item following them\n+\n+parse_inner_doc_comment_not_permitted = expected outer doc comment\n+    .note = inner doc comments like this (starting with `//!` or `/*!`) can only appear before items\n+    .suggestion = you might have meant to write a regular comment\n+    .label_does_not_annotate_this = the inner doc comment doesn't annotate this {$item}\n+    .sugg_change_inner_to_outer = to annotate the {$item}, change the doc comment from inner to outer style\n+\n+parse_expected_identifier_found_reserved_identifier_str = expected identifier, found reserved identifier `{$token}`\n+parse_expected_identifier_found_keyword_str = expected identifier, found keyword `{$token}`\n+parse_expected_identifier_found_reserved_keyword_str = expected identifier, found reserved keyword `{$token}`\n+parse_expected_identifier_found_doc_comment_str = expected identifier, found doc comment `{$token}`\n+parse_expected_identifier_found_str = expected identifier, found `{$token}`\n+\n+parse_expected_identifier_found_reserved_identifier = expected identifier, found reserved identifier\n+parse_expected_identifier_found_keyword = expected identifier, found keyword\n+parse_expected_identifier_found_reserved_keyword = expected identifier, found reserved keyword\n+parse_expected_identifier_found_doc_comment = expected identifier, found doc comment\n+parse_expected_identifier = expected identifier\n+\n+parse_sugg_escape_to_use_as_identifier = escape `{$ident_name}` to use it as an identifier\n+\n+parse_sugg_remove_comma = remove this comma\n+\n+parse_expected_semi_found_reserved_identifier_str = expected `;`, found reserved identifier `{$token}`\n+parse_expected_semi_found_keyword_str = expected `;`, found keyword `{$token}`\n+parse_expected_semi_found_reserved_keyword_str = expected `;`, found reserved keyword `{$token}`\n+parse_expected_semi_found_doc_comment_str = expected `;`, found doc comment `{$token}`\n+parse_expected_semi_found_str = expected `;`, found `{$token}`\n+\n+parse_sugg_change_this_to_semi = change this to `;`\n+parse_sugg_add_semi = add `;` here\n+parse_label_unexpected_token = unexpected token\n+\n+parse_unmatched_angle_brackets = {$num_extra_brackets ->\n+        [one] unmatched angle bracket\n+       *[other] unmatched angle brackets\n+    }\n+    .suggestion = {$num_extra_brackets ->\n+            [one] remove extra angle bracket\n+           *[other] remove extra angle brackets\n+        }\n+\n+parse_generic_parameters_without_angle_brackets = generic parameters without surrounding angle brackets\n+    .suggestion = surround the type parameters with angle brackets\n+\n+parse_comparison_operators_cannot_be_chained = comparison operators cannot be chained\n+    .sugg_parentheses_for_function_args = or use `(...)` if you meant to specify fn arguments\n+    .sugg_split_comparison = split the comparison into two\n+    .sugg_parenthesize = parenthesize the comparison\n+parse_sugg_turbofish_syntax = use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n+\n+parse_question_mark_in_type = invalid `?` in type\n+    .label = `?` is only allowed on expressions, not types\n+    .suggestion = if you meant to express that the type might not contain a value, use the `Option` wrapper type\n+\n+parse_unexpected_parentheses_in_for_head = unexpected parentheses surrounding `for` loop head\n+    .suggestion = remove parentheses in `for` loop\n+\n+parse_doc_comment_on_param_type = documentation comments cannot be applied to a function parameter's type\n+    .label = doc comments are not allowed here\n+\n+parse_attribute_on_param_type = attributes cannot be applied to a function parameter's type\n+    .label = attributes are not allowed here\n+\n+parse_pattern_method_param_without_body = patterns aren't allowed in methods without bodies\n+    .suggestion = give this argument a name or use an underscore to ignore it\n+\n+parse_self_param_not_first = unexpected `self` parameter in function\n+    .label = must be the first parameter of an associated function\n+\n+parse_const_generic_without_braces = expressions must be enclosed in braces to be used as const generic arguments\n+    .suggestion = enclose the `const` expression in braces\n+\n+parse_unexpected_const_param_declaration = unexpected `const` parameter declaration\n+    .label = expected a `const` expression, not a parameter declaration\n+    .suggestion = `const` parameters must be declared for the `impl`\n+\n+parse_unexpected_const_in_generic_param = expected lifetime, type, or constant, found keyword `const`\n+    .suggestion = the `const` keyword is only needed in the definition of the type\n+\n+parse_async_move_order_incorrect = the order of `move` and `async` is incorrect\n+    .suggestion = try switching the order\n+\n+parse_double_colon_in_bound = expected `:` followed by trait or lifetime\n+    .suggestion = use single colon\n+\n+parse_fn_ptr_with_generics = function pointer types may not have generic parameters\n+    .suggestion = consider moving the lifetime {$arity ->\n+        [one] parameter\n+        *[other] parameters\n+    } to {$for_param_list_exists ->\n+        [true] the\n+        *[false] a\n+    } `for` parameter list\n+\n+parse_invalid_identifier_with_leading_number = expected identifier, found number literal\n+    .label = identifiers cannot start with a number"}, {"sha": "1df5bf1a22037fef47d29a92a2b06d9df946b6d4", "filename": "compiler/rustc_error_messages/locales/en-US/parser.ftl", "status": "removed", "additions": 0, "deletions": 392, "changes": 392, "blob_url": "https://github.com/rust-lang/rust/blob/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl?ref=736c675d2ab65bcde6554e1b73340c2dbc27c85a", "patch": "@@ -1,392 +0,0 @@\n-parser_struct_literal_body_without_path =\n-    struct literal body without path\n-    .suggestion = you might have forgotten to add the struct literal inside the block\n-\n-parser_maybe_report_ambiguous_plus =\n-    ambiguous `+` in a type\n-    .suggestion = use parentheses to disambiguate\n-\n-parser_maybe_recover_from_bad_type_plus =\n-    expected a path on the left-hand side of `+`, not `{$ty}`\n-\n-parser_add_paren = try adding parentheses\n-\n-parser_forgot_paren = perhaps you forgot parentheses?\n-\n-parser_expect_path = expected a path\n-\n-parser_maybe_recover_from_bad_qpath_stage_2 =\n-    missing angle brackets in associated item path\n-    .suggestion = try: `{$ty}`\n-\n-parser_incorrect_semicolon =\n-    expected item, found `;`\n-    .suggestion = remove this semicolon\n-    .help = {$name} declarations are not followed by a semicolon\n-\n-parser_incorrect_use_of_await =\n-    incorrect use of `await`\n-    .parentheses_suggestion = `await` is not a method call, remove the parentheses\n-    .postfix_suggestion = `await` is a postfix operation\n-\n-parser_in_in_typo =\n-    expected iterable, found keyword `in`\n-    .suggestion = remove the duplicated `in`\n-\n-parser_invalid_variable_declaration =\n-    invalid variable declaration\n-\n-parser_switch_mut_let_order =\n-    switch the order of `mut` and `let`\n-parser_missing_let_before_mut = missing keyword\n-parser_use_let_not_auto = write `let` instead of `auto` to introduce a new variable\n-parser_use_let_not_var = write `let` instead of `var` to introduce a new variable\n-\n-parser_invalid_comparison_operator = invalid comparison operator `{$invalid}`\n-    .use_instead = `{$invalid}` is not a valid comparison operator, use `{$correct}`\n-    .spaceship_operator_invalid = `<=>` is not a valid comparison operator, use `std::cmp::Ordering`\n-\n-parser_invalid_logical_operator = `{$incorrect}` is not a logical operator\n-    .note = unlike in e.g., Python and PHP, `&&` and `||` are used for logical operators\n-    .use_amp_amp_for_conjunction = use `&&` to perform logical conjunction\n-    .use_pipe_pipe_for_disjunction = use `||` to perform logical disjunction\n-\n-parser_tilde_is_not_unary_operator = `~` cannot be used as a unary operator\n-    .suggestion = use `!` to perform bitwise not\n-\n-parser_unexpected_if_with_if = unexpected `if` in the condition expression\n-    .suggestion = remove the `if`\n-\n-parser_unexpected_token_after_not = unexpected {$negated_desc} after identifier\n-parser_unexpected_token_after_not_bitwise = use `!` to perform bitwise not\n-parser_unexpected_token_after_not_logical = use `!` to perform logical negation\n-parser_unexpected_token_after_not_default = use `!` to perform logical negation or bitwise not\n-\n-parser_malformed_loop_label = malformed loop label\n-    .suggestion = use the correct loop label format\n-\n-parser_lifetime_in_borrow_expression = borrow expressions cannot be annotated with lifetimes\n-    .suggestion = remove the lifetime annotation\n-    .label = annotated with lifetime here\n-\n-parser_field_expression_with_generic = field expressions cannot have generic arguments\n-\n-parser_macro_invocation_with_qualified_path = macros cannot use qualified paths\n-\n-parser_unexpected_token_after_label = expected `while`, `for`, `loop` or `{\"{\"}` after a label\n-    .suggestion_remove_label = consider removing the label\n-    .suggestion_enclose_in_block = consider enclosing expression in a block\n-\n-parser_require_colon_after_labeled_expression = labeled expression must be followed by `:`\n-    .note = labels are used before loops and blocks, allowing e.g., `break 'label` to them\n-    .label = the label\n-    .suggestion = add `:` after the label\n-\n-parser_do_catch_syntax_removed = found removed `do catch` syntax\n-    .note = following RFC #2388, the new non-placeholder syntax is `try`\n-    .suggestion = replace with the new syntax\n-\n-parser_float_literal_requires_integer_part = float literals must have an integer part\n-    .suggestion = must have an integer part\n-\n-parser_invalid_int_literal_width = invalid width `{$width}` for integer literal\n-    .help = valid widths are 8, 16, 32, 64 and 128\n-\n-parser_invalid_num_literal_base_prefix = invalid base prefix for number literal\n-    .note = base prefixes (`0xff`, `0b1010`, `0o755`) are lowercase\n-    .suggestion = try making the prefix lowercase\n-\n-parser_invalid_num_literal_suffix = invalid suffix `{$suffix}` for number literal\n-    .label = invalid suffix `{$suffix}`\n-    .help = the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n-\n-parser_invalid_float_literal_width = invalid width `{$width}` for float literal\n-    .help = valid widths are 32 and 64\n-\n-parser_invalid_float_literal_suffix = invalid suffix `{$suffix}` for float literal\n-    .label = invalid suffix `{$suffix}`\n-    .help = valid suffixes are `f32` and `f64`\n-\n-parser_int_literal_too_large = integer literal is too large\n-\n-parser_missing_semicolon_before_array = expected `;`, found `[`\n-    .suggestion = consider adding `;` here\n-\n-parser_invalid_block_macro_segment = cannot use a `block` macro fragment here\n-    .label = the `block` fragment is within this context\n-\n-parser_expect_dotdot_not_dotdotdot = expected `..`, found `...`\n-    .suggestion = use `..` to fill in the rest of the fields\n-\n-parser_if_expression_missing_then_block = this `if` expression is missing a block after the condition\n-    .add_then_block = add a block here\n-    .condition_possibly_unfinished = this binary operation is possibly unfinished\n-\n-parser_if_expression_missing_condition = missing condition for `if` expression\n-    .condition_label = expected condition here\n-    .block_label = if this block is the condition of the `if` expression, then it must be followed by another block\n-\n-parser_expected_expression_found_let = expected expression, found `let` statement\n-\n-parser_expect_eq_instead_of_eqeq = expected `=`, found `==`\n-    .suggestion = consider using `=` here\n-\n-parser_expected_else_block = expected `{\"{\"}`, found {$first_tok}\n-    .label = expected an `if` or a block after this `else`\n-    .suggestion = add an `if` if this is the condition of a chained `else if` statement\n-\n-parser_outer_attribute_not_allowed_on_if_else = outer attributes are not allowed on `if` and `else` branches\n-    .branch_label = the attributes are attached to this branch\n-    .ctx_label = the branch belongs to this `{$ctx}`\n-    .suggestion = remove the attributes\n-\n-parser_missing_in_in_for_loop = missing `in` in `for` loop\n-    .use_in_not_of = try using `in` here instead\n-    .add_in = try adding `in` here\n-\n-parser_missing_comma_after_match_arm = expected `,` following `match` arm\n-    .suggestion = missing a comma here to end this `match` arm\n-\n-parser_catch_after_try = keyword `catch` cannot follow a `try` block\n-    .help = try using `match` on the result of the `try` block instead\n-\n-parser_comma_after_base_struct = cannot use a comma after the base struct\n-    .note = the base struct must always be the last field\n-    .suggestion = remove this comma\n-\n-parser_eq_field_init = expected `:`, found `=`\n-    .suggestion = replace equals symbol with a colon\n-\n-parser_dotdotdot = unexpected token: `...`\n-    .suggest_exclusive_range = use `..` for an exclusive range\n-    .suggest_inclusive_range = or `..=` for an inclusive range\n-\n-parser_left_arrow_operator = unexpected token: `<-`\n-    .suggestion = if you meant to write a comparison against a negative value, add a space in between `<` and `-`\n-\n-parser_remove_let = expected pattern, found `let`\n-    .suggestion = remove the unnecessary `let` keyword\n-\n-parser_use_eq_instead = unexpected `==`\n-    .suggestion = try using `=` instead\n-\n-parser_use_empty_block_not_semi = expected { \"`{}`\" }, found `;`\n-    .suggestion = try using { \"`{}`\" } instead\n-\n-parser_comparison_interpreted_as_generic =\n-    `<` is interpreted as a start of generic arguments for `{$type}`, not a comparison\n-    .label_args = interpreted as generic arguments\n-    .label_comparison = not interpreted as comparison\n-    .suggestion = try comparing the cast value\n-\n-parser_shift_interpreted_as_generic =\n-    `<<` is interpreted as a start of generic arguments for `{$type}`, not a shift\n-    .label_args = interpreted as generic arguments\n-    .label_comparison = not interpreted as shift\n-    .suggestion = try shifting the cast value\n-\n-parser_found_expr_would_be_stmt = expected expression, found `{$token}`\n-    .label = expected expression\n-\n-parser_leading_plus_not_supported = leading `+` is not supported\n-    .label = unexpected `+`\n-    .suggestion_remove_plus = try removing the `+`\n-\n-parser_parentheses_with_struct_fields = invalid `struct` delimiters or `fn` call arguments\n-    .suggestion_braces_for_struct = if `{$type}` is a struct, use braces as delimiters\n-    .suggestion_no_fields_for_fn = if `{$type}` is a function, use the arguments directly\n-\n-parser_labeled_loop_in_break = parentheses are required around this expression to avoid confusion with a labeled break expression\n-\n-parser_sugg_wrap_expression_in_parentheses = wrap the expression in parentheses\n-\n-parser_array_brackets_instead_of_braces = this is a block expression, not an array\n-    .suggestion = to make an array, use square brackets instead of curly braces\n-\n-parser_match_arm_body_without_braces = `match` arm body without braces\n-    .label_statements = {$num_statements ->\n-            [one] this statement is not surrounded by a body\n-           *[other] these statements are not surrounded by a body\n-        }\n-    .label_arrow = while parsing the `match` arm starting here\n-    .suggestion_add_braces = surround the {$num_statements ->\n-            [one] statement\n-           *[other] statements\n-        } with a body\n-    .suggestion_use_comma_not_semicolon = use a comma to end a `match` arm expression\n-\n-parser_struct_literal_not_allowed_here = struct literals are not allowed here\n-    .suggestion = surround the struct literal with parentheses\n-\n-parser_invalid_interpolated_expression = invalid interpolated expression\n-\n-parser_hexadecimal_float_literal_not_supported = hexadecimal float literal is not supported\n-parser_octal_float_literal_not_supported = octal float literal is not supported\n-parser_binary_float_literal_not_supported = binary float literal is not supported\n-parser_not_supported = not supported\n-\n-parser_invalid_literal_suffix = suffixes on {$kind} literals are invalid\n-    .label = invalid suffix `{$suffix}`\n-\n-parser_invalid_literal_suffix_on_tuple_index = suffixes on a tuple index are invalid\n-    .label = invalid suffix `{$suffix}`\n-    .tuple_exception_line_1 = `{$suffix}` is *temporarily* accepted on tuple index fields as it was incorrectly accepted on stable for a few releases\n-    .tuple_exception_line_2 = on proc macros, you'll want to use `syn::Index::from` or `proc_macro::Literal::*_unsuffixed` for code that will desugar to tuple field access\n-    .tuple_exception_line_3 = see issue #60210 <https://github.com/rust-lang/rust/issues/60210> for more information\n-\n-parser_non_string_abi_literal = non-string ABI literal\n-    .suggestion = specify the ABI with a string literal\n-\n-parser_mismatched_closing_delimiter = mismatched closing delimiter: `{$delimiter}`\n-    .label_unmatched = mismatched closing delimiter\n-    .label_opening_candidate = closing delimiter possibly meant for this\n-    .label_unclosed = unclosed delimiter\n-\n-parser_incorrect_visibility_restriction = incorrect visibility restriction\n-    .help = some possible visibility restrictions are:\n-            `pub(crate)`: visible only on the current crate\n-            `pub(super)`: visible only in the current module's parent\n-            `pub(in path::to::module)`: visible only on the specified path\n-    .suggestion = make this visible only to module `{$inner_str}` with `in`\n-\n-parser_assignment_else_not_allowed = <assignment> ... else {\"{\"} ... {\"}\"} is not allowed\n-\n-parser_expected_statement_after_outer_attr = expected statement after outer attribute\n-\n-parser_doc_comment_does_not_document_anything = found a documentation comment that doesn't document anything\n-    .help = doc comments must come before what they document, if a comment was intended use `//`\n-    .suggestion = missing comma here\n-\n-parser_const_let_mutually_exclusive = `const` and `let` are mutually exclusive\n-    .suggestion = remove `let`\n-\n-parser_invalid_expression_in_let_else = a `{$operator}` expression cannot be directly assigned in `let...else`\n-parser_invalid_curly_in_let_else = right curly brace `{\"}\"}` before `else` in a `let...else` statement not allowed\n-\n-parser_compound_assignment_expression_in_let = can't reassign to an uninitialized variable\n-    .suggestion = initialize the variable\n-    .help = if you meant to overwrite, remove the `let` binding\n-\n-parser_suffixed_literal_in_attribute = suffixed literals are not allowed in attributes\n-    .help = instead of using a suffixed literal (`1u8`, `1.0f32`, etc.), use an unsuffixed version (`1`, `1.0`, etc.)\n-\n-parser_invalid_meta_item = expected unsuffixed literal or identifier, found `{$token}`\n-\n-parser_label_inner_attr_does_not_annotate_this = the inner attribute doesn't annotate this {$item}\n-parser_sugg_change_inner_attr_to_outer = to annotate the {$item}, change the attribute from inner to outer style\n-\n-parser_inner_attr_not_permitted_after_outer_doc_comment = an inner attribute is not permitted following an outer doc comment\n-    .label_attr = not permitted following an outer doc comment\n-    .label_prev_doc_comment = previous doc comment\n-    .label_does_not_annotate_this = {parser_label_inner_attr_does_not_annotate_this}\n-    .sugg_change_inner_to_outer = {parser_sugg_change_inner_attr_to_outer}\n-\n-parser_inner_attr_not_permitted_after_outer_attr = an inner attribute is not permitted following an outer attribute\n-    .label_attr = not permitted following an outer attribute\n-    .label_prev_attr = previous outer attribute\n-    .label_does_not_annotate_this = {parser_label_inner_attr_does_not_annotate_this}\n-    .sugg_change_inner_to_outer = {parser_sugg_change_inner_attr_to_outer}\n-\n-parser_inner_attr_not_permitted = an inner attribute is not permitted in this context\n-    .label_does_not_annotate_this = {parser_label_inner_attr_does_not_annotate_this}\n-    .sugg_change_inner_to_outer = {parser_sugg_change_inner_attr_to_outer}\n-\n-parser_inner_attr_explanation = inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files\n-parser_outer_attr_explanation = outer attributes, like `#[test]`, annotate the item following them\n-\n-parser_inner_doc_comment_not_permitted = expected outer doc comment\n-    .note = inner doc comments like this (starting with `//!` or `/*!`) can only appear before items\n-    .suggestion = you might have meant to write a regular comment\n-    .label_does_not_annotate_this = the inner doc comment doesn't annotate this {$item}\n-    .sugg_change_inner_to_outer = to annotate the {$item}, change the doc comment from inner to outer style\n-\n-parser_expected_identifier_found_reserved_identifier_str = expected identifier, found reserved identifier `{$token}`\n-parser_expected_identifier_found_keyword_str = expected identifier, found keyword `{$token}`\n-parser_expected_identifier_found_reserved_keyword_str = expected identifier, found reserved keyword `{$token}`\n-parser_expected_identifier_found_doc_comment_str = expected identifier, found doc comment `{$token}`\n-parser_expected_identifier_found_str = expected identifier, found `{$token}`\n-\n-parser_expected_identifier_found_reserved_identifier = expected identifier, found reserved identifier\n-parser_expected_identifier_found_keyword = expected identifier, found keyword\n-parser_expected_identifier_found_reserved_keyword = expected identifier, found reserved keyword\n-parser_expected_identifier_found_doc_comment = expected identifier, found doc comment\n-parser_expected_identifier = expected identifier\n-\n-parser_sugg_escape_to_use_as_identifier = escape `{$ident_name}` to use it as an identifier\n-\n-parser_sugg_remove_comma = remove this comma\n-\n-parser_expected_semi_found_reserved_identifier_str = expected `;`, found reserved identifier `{$token}`\n-parser_expected_semi_found_keyword_str = expected `;`, found keyword `{$token}`\n-parser_expected_semi_found_reserved_keyword_str = expected `;`, found reserved keyword `{$token}`\n-parser_expected_semi_found_doc_comment_str = expected `;`, found doc comment `{$token}`\n-parser_expected_semi_found_str = expected `;`, found `{$token}`\n-\n-parser_sugg_change_this_to_semi = change this to `;`\n-parser_sugg_add_semi = add `;` here\n-parser_label_unexpected_token = unexpected token\n-\n-parser_unmatched_angle_brackets = {$num_extra_brackets ->\n-        [one] unmatched angle bracket\n-       *[other] unmatched angle brackets\n-    }\n-    .suggestion = {$num_extra_brackets ->\n-            [one] remove extra angle bracket\n-           *[other] remove extra angle brackets\n-        }\n-\n-parser_generic_parameters_without_angle_brackets = generic parameters without surrounding angle brackets\n-    .suggestion = surround the type parameters with angle brackets\n-\n-parser_comparison_operators_cannot_be_chained = comparison operators cannot be chained\n-    .sugg_parentheses_for_function_args = or use `(...)` if you meant to specify fn arguments\n-    .sugg_split_comparison = split the comparison into two\n-    .sugg_parenthesize = parenthesize the comparison\n-parser_sugg_turbofish_syntax = use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n-\n-parser_question_mark_in_type = invalid `?` in type\n-    .label = `?` is only allowed on expressions, not types\n-    .suggestion = if you meant to express that the type might not contain a value, use the `Option` wrapper type\n-\n-parser_unexpected_parentheses_in_for_head = unexpected parentheses surrounding `for` loop head\n-    .suggestion = remove parentheses in `for` loop\n-\n-parser_doc_comment_on_param_type = documentation comments cannot be applied to a function parameter's type\n-    .label = doc comments are not allowed here\n-\n-parser_attribute_on_param_type = attributes cannot be applied to a function parameter's type\n-    .label = attributes are not allowed here\n-\n-parser_pattern_method_param_without_body = patterns aren't allowed in methods without bodies\n-    .suggestion = give this argument a name or use an underscore to ignore it\n-\n-parser_self_param_not_first = unexpected `self` parameter in function\n-    .label = must be the first parameter of an associated function\n-\n-parser_const_generic_without_braces = expressions must be enclosed in braces to be used as const generic arguments\n-    .suggestion = enclose the `const` expression in braces\n-\n-parser_unexpected_const_param_declaration = unexpected `const` parameter declaration\n-    .label = expected a `const` expression, not a parameter declaration\n-    .suggestion = `const` parameters must be declared for the `impl`\n-\n-parser_unexpected_const_in_generic_param = expected lifetime, type, or constant, found keyword `const`\n-    .suggestion = the `const` keyword is only needed in the definition of the type\n-\n-parser_async_move_order_incorrect = the order of `move` and `async` is incorrect\n-    .suggestion = try switching the order\n-\n-parser_double_colon_in_bound = expected `:` followed by trait or lifetime\n-    .suggestion = use single colon\n-\n-parser_fn_ptr_with_generics = function pointer types may not have generic parameters\n-    .suggestion = consider moving the lifetime {$arity ->\n-        [one] parameter\n-        *[other] parameters\n-    } to {$for_param_list_exists ->\n-        [true] the\n-        *[false] a\n-    } `for` parameter list\n-\n-parser_invalid_identifier_with_leading_number = expected identifier, found number literal\n-    .label = identifiers cannot start with a number"}, {"sha": "983eb926213ea587946629576a3c1b78fbf202e5", "filename": "compiler/rustc_error_messages/locales/en-US/session.ftl", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fe212eca76f3976756e47355e4f0cb62984ec837/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/fe212eca76f3976756e47355e4f0cb62984ec837/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl?ref=fe212eca76f3976756e47355e4f0cb62984ec837", "patch": "@@ -58,3 +58,31 @@ session_expr_parentheses_needed = parentheses are required to parse this as an e\n session_skipping_const_checks = skipping const checks\n session_unleashed_feature_help_named = skipping check for `{$gate}` feature\n session_unleashed_feature_help_unnamed = skipping check that does not even have a feature gate\n+\n+session_hexadecimal_float_literal_not_supported = hexadecimal float literal is not supported\n+session_octal_float_literal_not_supported = octal float literal is not supported\n+session_binary_float_literal_not_supported = binary float literal is not supported\n+session_not_supported = not supported\n+\n+session_invalid_literal_suffix = suffixes on {$kind} literals are invalid\n+    .label = invalid suffix `{$suffix}`\n+\n+session_invalid_num_literal_base_prefix = invalid base prefix for number literal\n+    .note = base prefixes (`0xff`, `0b1010`, `0o755`) are lowercase\n+    .suggestion = try making the prefix lowercase\n+\n+session_invalid_num_literal_suffix = invalid suffix `{$suffix}` for number literal\n+    .label = invalid suffix `{$suffix}`\n+    .help = the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n+\n+session_invalid_float_literal_width = invalid width `{$width}` for float literal\n+    .help = valid widths are 32 and 64\n+\n+session_invalid_float_literal_suffix = invalid suffix `{$suffix}` for float literal\n+    .label = invalid suffix `{$suffix}`\n+    .help = valid suffixes are `f32` and `f64`\n+\n+session_int_literal_too_large = integer literal is too large\n+\n+session_invalid_int_literal_width = invalid width `{$width}` for integer literal\n+    .help = valid widths are 8, 16, 32, 64 and 128"}, {"sha": "418ba3c74d7761cb574d8ad0840fd0dd09c93249", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe212eca76f3976756e47355e4f0cb62984ec837/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe212eca76f3976756e47355e4f0cb62984ec837/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=fe212eca76f3976756e47355e4f0cb62984ec837", "patch": "@@ -59,7 +59,7 @@ fluent_messages! {\n     middle => \"../locales/en-US/middle.ftl\",\n     mir_dataflow => \"../locales/en-US/mir_dataflow.ftl\",\n     monomorphize => \"../locales/en-US/monomorphize.ftl\",\n-    parser => \"../locales/en-US/parser.ftl\",\n+    parse => \"../locales/en-US/parse.ftl\",\n     passes => \"../locales/en-US/passes.ftl\",\n     plugin_impl => \"../locales/en-US/plugin_impl.ftl\",\n     privacy => \"../locales/en-US/privacy.ftl\","}, {"sha": "507272fdec5d71b334624b04d287820c7e19ecae", "filename": "compiler/rustc_hir_typeck/src/errors.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fe212eca76f3976756e47355e4f0cb62984ec837/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe212eca76f3976756e47355e4f0cb62984ec837/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs?ref=fe212eca76f3976756e47355e4f0cb62984ec837", "patch": "@@ -1,11 +1,11 @@\n-//! Errors emitted by `rustc_hir_analysis`.\n+//! Errors emitted by `rustc_hir_typeck`.\n use rustc_errors::{AddToDiagnostic, Applicability, Diagnostic, MultiSpan, SubdiagnosticMessage};\n use rustc_macros::{Diagnostic, Subdiagnostic};\n use rustc_middle::ty::Ty;\n use rustc_span::{symbol::Ident, Span};\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis_field_multiply_specified_in_initializer, code = \"E0062\")]\n+#[diag(hir_typeck_field_multiply_specified_in_initializer, code = \"E0062\")]\n pub struct FieldMultiplySpecifiedInInitializer {\n     #[primary_span]\n     #[label]\n@@ -16,7 +16,7 @@ pub struct FieldMultiplySpecifiedInInitializer {\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis_return_stmt_outside_of_fn_body, code = \"E0572\")]\n+#[diag(hir_typeck_return_stmt_outside_of_fn_body, code = \"E0572\")]\n pub struct ReturnStmtOutsideOfFnBody {\n     #[primary_span]\n     pub span: Span,\n@@ -27,36 +27,36 @@ pub struct ReturnStmtOutsideOfFnBody {\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis_yield_expr_outside_of_generator, code = \"E0627\")]\n+#[diag(hir_typeck_yield_expr_outside_of_generator, code = \"E0627\")]\n pub struct YieldExprOutsideOfGenerator {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis_struct_expr_non_exhaustive, code = \"E0639\")]\n+#[diag(hir_typeck_struct_expr_non_exhaustive, code = \"E0639\")]\n pub struct StructExprNonExhaustive {\n     #[primary_span]\n     pub span: Span,\n     pub what: &'static str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis_method_call_on_unknown_type, code = \"E0699\")]\n+#[diag(hir_typeck_method_call_on_unknown_type, code = \"E0699\")]\n pub struct MethodCallOnUnknownType {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis_functional_record_update_on_non_struct, code = \"E0436\")]\n+#[diag(hir_typeck_functional_record_update_on_non_struct, code = \"E0436\")]\n pub struct FunctionalRecordUpdateOnNonStruct {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis_address_of_temporary_taken, code = \"E0745\")]\n+#[diag(hir_typeck_address_of_temporary_taken, code = \"E0745\")]\n pub struct AddressOfTemporaryTaken {\n     #[primary_span]\n     #[label]\n@@ -66,7 +66,7 @@ pub struct AddressOfTemporaryTaken {\n #[derive(Subdiagnostic)]\n pub enum AddReturnTypeSuggestion {\n     #[suggestion(\n-        hir_analysis_add_return_type_add,\n+        hir_typeck_add_return_type_add,\n         code = \"-> {found} \",\n         applicability = \"machine-applicable\"\n     )]\n@@ -76,7 +76,7 @@ pub enum AddReturnTypeSuggestion {\n         found: String,\n     },\n     #[suggestion(\n-        hir_analysis_add_return_type_missing_here,\n+        hir_typeck_add_return_type_missing_here,\n         code = \"-> _ \",\n         applicability = \"has-placeholders\"\n     )]\n@@ -88,12 +88,12 @@ pub enum AddReturnTypeSuggestion {\n \n #[derive(Subdiagnostic)]\n pub enum ExpectedReturnTypeLabel<'tcx> {\n-    #[label(hir_analysis_expected_default_return_type)]\n+    #[label(hir_typeck_expected_default_return_type)]\n     Unit {\n         #[primary_span]\n         span: Span,\n     },\n-    #[label(hir_analysis_expected_return_type)]\n+    #[label(hir_typeck_expected_return_type)]\n     Other {\n         #[primary_span]\n         span: Span,\n@@ -102,10 +102,10 @@ pub enum ExpectedReturnTypeLabel<'tcx> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis_missing_parentheses_in_range, code = \"E0689\")]\n+#[diag(hir_typeck_missing_parentheses_in_range, code = \"E0689\")]\n pub struct MissingParentheseInRange {\n     #[primary_span]\n-    #[label(hir_analysis_missing_parentheses_in_range)]\n+    #[label(hir_typeck_missing_parentheses_in_range)]\n     pub span: Span,\n     pub ty_str: String,\n     pub method_name: String,\n@@ -115,7 +115,7 @@ pub struct MissingParentheseInRange {\n \n #[derive(Subdiagnostic)]\n #[multipart_suggestion(\n-    hir_analysis_add_missing_parentheses_in_range,\n+    hir_typeck_add_missing_parentheses_in_range,\n     style = \"verbose\",\n     applicability = \"maybe-incorrect\"\n )]\n@@ -128,7 +128,7 @@ pub struct AddMissingParenthesesInRange {\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis_op_trait_generic_params)]\n+#[diag(hir_typeck_op_trait_generic_params)]\n pub struct OpMethodGenericParams {\n     #[primary_span]\n     pub span: Span,"}, {"sha": "3ff82e5728ab6d554ed0be59e60510fe9ce0c89a", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic.rs", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fe212eca76f3976756e47355e4f0cb62984ec837/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe212eca76f3976756e47355e4f0cb62984ec837/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs?ref=fe212eca76f3976756e47355e4f0cb62984ec837", "patch": "@@ -46,7 +46,9 @@ impl<'a> DiagnosticDerive<'a> {\n                     return DiagnosticDeriveError::ErrorHandled.to_compile_error();\n                 }\n                 Some(slug) => {\n+                    let check = make_check(slug);\n                     quote! {\n+                        #check\n                         let mut #diag = #handler.struct_diagnostic(rustc_errors::fluent::#slug);\n                     }\n                 }\n@@ -128,7 +130,14 @@ impl<'a> LintDiagnosticDerive<'a> {\n                         .emit();\n                     return DiagnosticDeriveError::ErrorHandled.to_compile_error();\n                 }\n-                Some(slug) => quote! { rustc_errors::fluent::#slug.into() },\n+                Some(slug) => {\n+                    let check = make_check(slug);\n+\n+                    quote! {\n+                        #check\n+                        rustc_errors::fluent::#slug.into()\n+                    }\n+                }\n             }\n         });\n \n@@ -151,3 +160,46 @@ impl<'a> LintDiagnosticDerive<'a> {\n         })\n     }\n }\n+\n+/// Checks whether the slug starts with the crate name it's in.\n+fn make_check(slug: &syn::Path) -> TokenStream {\n+    quote! {\n+        const _: () = {\n+            let krate = env!(\"CARGO_MANIFEST_DIR\").as_bytes();\n+\n+            let mut start = 0;\n+            while !(krate[start] == b'r'\n+                && krate[start + 1] == b'u'\n+                && krate[start + 2] == b's'\n+                && krate[start + 3] == b't'\n+                && krate[start + 4] == b'c'\n+                && krate[start + 5] == b'_')\n+            {\n+                if krate.len() == start + 5 {\n+                    panic!(concat!(\"crate does not contain \\\"rustc_\\\": \", env!(\"CARGO_MANIFEST_DIR\")));\n+                }\n+                start += 1;\n+            }\n+            start += 6;\n+\n+            let slug = stringify!(#slug).as_bytes();\n+\n+            let mut pos = 0;\n+            loop {\n+                let b = slug[pos];\n+                if krate.len() == start + pos {\n+                    if b != b'_' {\n+                        panic!(concat!(\"slug \\\"\", stringify!(#slug), \"\\\" does not match the crate (\", env!(\"CARGO_MANIFEST_DIR\") ,\") it is in\"));\n+                    }\n+                    break\n+                }\n+                let a = krate[start+pos];\n+\n+                if a != b {\n+                    panic!(concat!(\"slug \\\"\", stringify!(#slug), \"\\\" does not match the crate (\", env!(\"CARGO_MANIFEST_DIR\") ,\") it is in\"));\n+                }\n+                pos += 1;\n+            }\n+        };\n+    }\n+}"}, {"sha": "5e94da8cb4d36ed4179dcaf43ab0ea4e3c668abd", "filename": "compiler/rustc_middle/src/error.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe212eca76f3976756e47355e4f0cb62984ec837/compiler%2Frustc_middle%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe212eca76f3976756e47355e4f0cb62984ec837/compiler%2Frustc_middle%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ferror.rs?ref=fe212eca76f3976756e47355e4f0cb62984ec837", "patch": "@@ -64,3 +64,11 @@ pub(crate) struct StrictCoherenceNeedsNegativeCoherence {\n     #[label]\n     pub attr_span: Option<Span>,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(middle_const_not_used_in_type_alias)]\n+pub(super) struct ConstNotUsedTraitAlias {\n+    pub ct: String,\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "69f50df62350fc4cf8127063be931de5bb135eae", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe212eca76f3976756e47355e4f0cb62984ec837/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe212eca76f3976756e47355e4f0cb62984ec837/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=fe212eca76f3976756e47355e4f0cb62984ec837", "patch": "@@ -508,11 +508,3 @@ impl<'tcx> TypeVisitor<'tcx> for IsSuggestableVisitor<'tcx> {\n         c.super_visit_with(self)\n     }\n }\n-\n-#[derive(Diagnostic)]\n-#[diag(borrowck_const_not_used_in_type_alias)]\n-pub(super) struct ConstNotUsedTraitAlias {\n-    pub ct: String,\n-    #[primary_span]\n-    pub span: Span,\n-}"}, {"sha": "98cd92007c2b22ace29115b466ce3f7fe0a75933", "filename": "compiler/rustc_middle/src/ty/opaque_types.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe212eca76f3976756e47355e4f0cb62984ec837/compiler%2Frustc_middle%2Fsrc%2Fty%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe212eca76f3976756e47355e4f0cb62984ec837/compiler%2Frustc_middle%2Fsrc%2Fty%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fopaque_types.rs?ref=fe212eca76f3976756e47355e4f0cb62984ec837", "patch": "@@ -1,7 +1,8 @@\n+use crate::error::ConstNotUsedTraitAlias;\n+use crate::ty::fold::{TypeFolder, TypeSuperFoldable};\n+use crate::ty::subst::{GenericArg, GenericArgKind};\n+use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n-use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_span::Span;\n \n /// Converts generic params of a TypeFoldable from one\n@@ -201,7 +202,7 @@ impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                     Some(u) => panic!(\"const mapped to unexpected kind: {:?}\", u),\n                     None => {\n                         if !self.ignore_errors {\n-                            self.tcx.sess.emit_err(ty::ConstNotUsedTraitAlias {\n+                            self.tcx.sess.emit_err(ConstNotUsedTraitAlias {\n                                 ct: ct.to_string(),\n                                 span: self.span,\n                             });"}, {"sha": "9875cde4a05ebe9354ef1ed5b83b6ba59e29aa5d", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 114, "deletions": 120, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/fe212eca76f3976756e47355e4f0cb62984ec837/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe212eca76f3976756e47355e4f0cb62984ec837/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=fe212eca76f3976756e47355e4f0cb62984ec837", "patch": "@@ -9,7 +9,7 @@ use rustc_span::{Span, Symbol};\n use crate::parser::TokenDescription;\n \n #[derive(Diagnostic)]\n-#[diag(parser_maybe_report_ambiguous_plus)]\n+#[diag(parse_maybe_report_ambiguous_plus)]\n pub(crate) struct AmbiguousPlus {\n     pub sum_ty: String,\n     #[primary_span]\n@@ -18,7 +18,7 @@ pub(crate) struct AmbiguousPlus {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_maybe_recover_from_bad_type_plus, code = \"E0178\")]\n+#[diag(parse_maybe_recover_from_bad_type_plus, code = \"E0178\")]\n pub(crate) struct BadTypePlus {\n     pub ty: String,\n     #[primary_span]\n@@ -30,7 +30,7 @@ pub(crate) struct BadTypePlus {\n #[derive(Subdiagnostic)]\n pub(crate) enum BadTypePlusSub {\n     #[suggestion(\n-        parser_add_paren,\n+        parse_add_paren,\n         code = \"{sum_with_parens}\",\n         applicability = \"machine-applicable\"\n     )]\n@@ -39,20 +39,20 @@ pub(crate) enum BadTypePlusSub {\n         #[primary_span]\n         span: Span,\n     },\n-    #[label(parser_forgot_paren)]\n+    #[label(parse_forgot_paren)]\n     ForgotParen {\n         #[primary_span]\n         span: Span,\n     },\n-    #[label(parser_expect_path)]\n+    #[label(parse_expect_path)]\n     ExpectPath {\n         #[primary_span]\n         span: Span,\n     },\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_maybe_recover_from_bad_qpath_stage_2)]\n+#[diag(parse_maybe_recover_from_bad_qpath_stage_2)]\n pub(crate) struct BadQPathStage2 {\n     #[primary_span]\n     #[suggestion(code = \"\", applicability = \"maybe-incorrect\")]\n@@ -61,7 +61,7 @@ pub(crate) struct BadQPathStage2 {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_incorrect_semicolon)]\n+#[diag(parse_incorrect_semicolon)]\n pub(crate) struct IncorrectSemicolon<'a> {\n     #[primary_span]\n     #[suggestion(style = \"short\", code = \"\", applicability = \"machine-applicable\")]\n@@ -72,15 +72,15 @@ pub(crate) struct IncorrectSemicolon<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_incorrect_use_of_await)]\n+#[diag(parse_incorrect_use_of_await)]\n pub(crate) struct IncorrectUseOfAwait {\n     #[primary_span]\n     #[suggestion(parentheses_suggestion, code = \"\", applicability = \"machine-applicable\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_incorrect_use_of_await)]\n+#[diag(parse_incorrect_use_of_await)]\n pub(crate) struct IncorrectAwait {\n     #[primary_span]\n     pub span: Span,\n@@ -91,7 +91,7 @@ pub(crate) struct IncorrectAwait {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_in_in_typo)]\n+#[diag(parse_in_in_typo)]\n pub(crate) struct InInTypo {\n     #[primary_span]\n     pub span: Span,\n@@ -100,7 +100,7 @@ pub(crate) struct InInTypo {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_invalid_variable_declaration)]\n+#[diag(parse_invalid_variable_declaration)]\n pub(crate) struct InvalidVariableDeclaration {\n     #[primary_span]\n     pub span: Span,\n@@ -110,22 +110,22 @@ pub(crate) struct InvalidVariableDeclaration {\n \n #[derive(Subdiagnostic)]\n pub(crate) enum InvalidVariableDeclarationSub {\n-    #[suggestion(parser_switch_mut_let_order, applicability = \"maybe-incorrect\", code = \"let mut\")]\n+    #[suggestion(parse_switch_mut_let_order, applicability = \"maybe-incorrect\", code = \"let mut\")]\n     SwitchMutLetOrder(#[primary_span] Span),\n     #[suggestion(\n-        parser_missing_let_before_mut,\n+        parse_missing_let_before_mut,\n         applicability = \"machine-applicable\",\n         code = \"let mut\"\n     )]\n     MissingLet(#[primary_span] Span),\n-    #[suggestion(parser_use_let_not_auto, applicability = \"machine-applicable\", code = \"let\")]\n+    #[suggestion(parse_use_let_not_auto, applicability = \"machine-applicable\", code = \"let\")]\n     UseLetNotAuto(#[primary_span] Span),\n-    #[suggestion(parser_use_let_not_var, applicability = \"machine-applicable\", code = \"let\")]\n+    #[suggestion(parse_use_let_not_var, applicability = \"machine-applicable\", code = \"let\")]\n     UseLetNotVar(#[primary_span] Span),\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_invalid_comparison_operator)]\n+#[diag(parse_invalid_comparison_operator)]\n pub(crate) struct InvalidComparisonOperator {\n     #[primary_span]\n     pub span: Span,\n@@ -153,7 +153,7 @@ pub(crate) enum InvalidComparisonOperatorSub {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_invalid_logical_operator)]\n+#[diag(parse_invalid_logical_operator)]\n #[note]\n pub(crate) struct InvalidLogicalOperator {\n     #[primary_span]\n@@ -182,15 +182,15 @@ pub(crate) enum InvalidLogicalOperatorSub {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_tilde_is_not_unary_operator)]\n+#[diag(parse_tilde_is_not_unary_operator)]\n pub(crate) struct TildeAsUnaryOperator(\n     #[primary_span]\n     #[suggestion(style = \"short\", applicability = \"machine-applicable\", code = \"!\")]\n     pub Span,\n );\n \n #[derive(Diagnostic)]\n-#[diag(parser_unexpected_token_after_not)]\n+#[diag(parse_unexpected_token_after_not)]\n pub(crate) struct NotAsNegationOperator {\n     #[primary_span]\n     pub negated: Span,\n@@ -202,23 +202,23 @@ pub(crate) struct NotAsNegationOperator {\n #[derive(Subdiagnostic)]\n pub enum NotAsNegationOperatorSub {\n     #[suggestion(\n-        parser_unexpected_token_after_not_default,\n+        parse_unexpected_token_after_not_default,\n         style = \"short\",\n         applicability = \"machine-applicable\",\n         code = \"!\"\n     )]\n     SuggestNotDefault(#[primary_span] Span),\n \n     #[suggestion(\n-        parser_unexpected_token_after_not_bitwise,\n+        parse_unexpected_token_after_not_bitwise,\n         style = \"short\",\n         applicability = \"machine-applicable\",\n         code = \"!\"\n     )]\n     SuggestNotBitwise(#[primary_span] Span),\n \n     #[suggestion(\n-        parser_unexpected_token_after_not_logical,\n+        parse_unexpected_token_after_not_logical,\n         style = \"short\",\n         applicability = \"machine-applicable\",\n         code = \"!\"\n@@ -227,7 +227,7 @@ pub enum NotAsNegationOperatorSub {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_malformed_loop_label)]\n+#[diag(parse_malformed_loop_label)]\n pub(crate) struct MalformedLoopLabel {\n     #[primary_span]\n     #[suggestion(applicability = \"machine-applicable\", code = \"{correct_label}\")]\n@@ -236,7 +236,7 @@ pub(crate) struct MalformedLoopLabel {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_lifetime_in_borrow_expression)]\n+#[diag(parse_lifetime_in_borrow_expression)]\n pub(crate) struct LifetimeInBorrowExpression {\n     #[primary_span]\n     pub span: Span,\n@@ -246,18 +246,18 @@ pub(crate) struct LifetimeInBorrowExpression {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_field_expression_with_generic)]\n+#[diag(parse_field_expression_with_generic)]\n pub(crate) struct FieldExpressionWithGeneric(#[primary_span] pub Span);\n \n #[derive(Diagnostic)]\n-#[diag(parser_macro_invocation_with_qualified_path)]\n+#[diag(parse_macro_invocation_with_qualified_path)]\n pub(crate) struct MacroInvocationWithQualifiedPath(#[primary_span] pub Span);\n \n #[derive(Diagnostic)]\n-#[diag(parser_unexpected_token_after_label)]\n+#[diag(parse_unexpected_token_after_label)]\n pub(crate) struct UnexpectedTokenAfterLabel {\n     #[primary_span]\n-    #[label(parser_unexpected_token_after_label)]\n+    #[label(parse_unexpected_token_after_label)]\n     pub span: Span,\n     #[suggestion(suggestion_remove_label, style = \"verbose\", code = \"\")]\n     pub remove_label: Option<Span>,\n@@ -275,7 +275,7 @@ pub(crate) struct UnexpectedTokenAfterLabelSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_require_colon_after_labeled_expression)]\n+#[diag(parse_require_colon_after_labeled_expression)]\n #[note]\n pub(crate) struct RequireColonAfterLabeledExpression {\n     #[primary_span]\n@@ -287,7 +287,7 @@ pub(crate) struct RequireColonAfterLabeledExpression {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_do_catch_syntax_removed)]\n+#[diag(parse_do_catch_syntax_removed)]\n #[note]\n pub(crate) struct DoCatchSyntaxRemoved {\n     #[primary_span]\n@@ -296,7 +296,7 @@ pub(crate) struct DoCatchSyntaxRemoved {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_float_literal_requires_integer_part)]\n+#[diag(parse_float_literal_requires_integer_part)]\n pub(crate) struct FloatLiteralRequiresIntegerPart {\n     #[primary_span]\n     #[suggestion(applicability = \"machine-applicable\", code = \"{correct}\")]\n@@ -305,7 +305,7 @@ pub(crate) struct FloatLiteralRequiresIntegerPart {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_missing_semicolon_before_array)]\n+#[diag(parse_missing_semicolon_before_array)]\n pub(crate) struct MissingSemicolonBeforeArray {\n     #[primary_span]\n     pub open_delim: Span,\n@@ -314,7 +314,7 @@ pub(crate) struct MissingSemicolonBeforeArray {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_expect_dotdot_not_dotdotdot)]\n+#[diag(parse_expect_dotdot_not_dotdotdot)]\n pub(crate) struct MissingDotDot {\n     #[primary_span]\n     pub token_span: Span,\n@@ -323,7 +323,7 @@ pub(crate) struct MissingDotDot {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_invalid_block_macro_segment)]\n+#[diag(parse_invalid_block_macro_segment)]\n pub(crate) struct InvalidBlockMacroSegment {\n     #[primary_span]\n     pub span: Span,\n@@ -332,7 +332,7 @@ pub(crate) struct InvalidBlockMacroSegment {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_if_expression_missing_then_block)]\n+#[diag(parse_if_expression_missing_then_block)]\n pub(crate) struct IfExpressionMissingThenBlock {\n     #[primary_span]\n     pub if_span: Span,\n@@ -349,7 +349,7 @@ pub(crate) enum IfExpressionMissingThenBlockSub {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_if_expression_missing_condition)]\n+#[diag(parse_if_expression_missing_condition)]\n pub(crate) struct IfExpressionMissingCondition {\n     #[primary_span]\n     #[label(condition_label)]\n@@ -359,14 +359,14 @@ pub(crate) struct IfExpressionMissingCondition {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_expected_expression_found_let)]\n+#[diag(parse_expected_expression_found_let)]\n pub(crate) struct ExpectedExpressionFoundLet {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_expect_eq_instead_of_eqeq)]\n+#[diag(parse_expect_eq_instead_of_eqeq)]\n pub(crate) struct ExpectedEqForLetExpr {\n     #[primary_span]\n     pub span: Span,\n@@ -375,7 +375,7 @@ pub(crate) struct ExpectedEqForLetExpr {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_expected_else_block)]\n+#[diag(parse_expected_else_block)]\n pub(crate) struct ExpectedElseBlock {\n     #[primary_span]\n     pub first_tok_span: Span,\n@@ -387,7 +387,7 @@ pub(crate) struct ExpectedElseBlock {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_outer_attribute_not_allowed_on_if_else)]\n+#[diag(parse_outer_attribute_not_allowed_on_if_else)]\n pub(crate) struct OuterAttributeNotAllowedOnIfElse {\n     #[primary_span]\n     pub last: Span,\n@@ -404,7 +404,7 @@ pub(crate) struct OuterAttributeNotAllowedOnIfElse {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_missing_in_in_for_loop)]\n+#[diag(parse_missing_in_in_for_loop)]\n pub(crate) struct MissingInInForLoop {\n     #[primary_span]\n     pub span: Span,\n@@ -422,23 +422,23 @@ pub(crate) enum MissingInInForLoopSub {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_missing_comma_after_match_arm)]\n+#[diag(parse_missing_comma_after_match_arm)]\n pub(crate) struct MissingCommaAfterMatchArm {\n     #[primary_span]\n     #[suggestion(applicability = \"machine-applicable\", code = \",\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_catch_after_try)]\n+#[diag(parse_catch_after_try)]\n #[help]\n pub(crate) struct CatchAfterTry {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_comma_after_base_struct)]\n+#[diag(parse_comma_after_base_struct)]\n #[note]\n pub(crate) struct CommaAfterBaseStruct {\n     #[primary_span]\n@@ -448,7 +448,7 @@ pub(crate) struct CommaAfterBaseStruct {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_eq_field_init)]\n+#[diag(parse_eq_field_init)]\n pub(crate) struct EqFieldInit {\n     #[primary_span]\n     pub span: Span,\n@@ -457,7 +457,7 @@ pub(crate) struct EqFieldInit {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_dotdotdot)]\n+#[diag(parse_dotdotdot)]\n pub(crate) struct DotDotDot {\n     #[primary_span]\n     #[suggestion(suggest_exclusive_range, applicability = \"maybe-incorrect\", code = \"..\")]\n@@ -466,39 +466,39 @@ pub(crate) struct DotDotDot {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_left_arrow_operator)]\n+#[diag(parse_left_arrow_operator)]\n pub(crate) struct LeftArrowOperator {\n     #[primary_span]\n     #[suggestion(applicability = \"maybe-incorrect\", code = \"< -\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_remove_let)]\n+#[diag(parse_remove_let)]\n pub(crate) struct RemoveLet {\n     #[primary_span]\n     #[suggestion(applicability = \"machine-applicable\", code = \"\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_use_eq_instead)]\n+#[diag(parse_use_eq_instead)]\n pub(crate) struct UseEqInstead {\n     #[primary_span]\n     #[suggestion(style = \"short\", applicability = \"machine-applicable\", code = \"=\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_use_empty_block_not_semi)]\n+#[diag(parse_use_empty_block_not_semi)]\n pub(crate) struct UseEmptyBlockNotSemi {\n     #[primary_span]\n     #[suggestion(style = \"hidden\", applicability = \"machine-applicable\", code = \"{{}}\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_comparison_interpreted_as_generic)]\n+#[diag(parse_comparison_interpreted_as_generic)]\n pub(crate) struct ComparisonInterpretedAsGeneric {\n     #[primary_span]\n     #[label(label_comparison)]\n@@ -511,7 +511,7 @@ pub(crate) struct ComparisonInterpretedAsGeneric {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_shift_interpreted_as_generic)]\n+#[diag(parse_shift_interpreted_as_generic)]\n pub(crate) struct ShiftInterpretedAsGeneric {\n     #[primary_span]\n     #[label(label_comparison)]\n@@ -533,7 +533,7 @@ pub(crate) struct ComparisonOrShiftInterpretedAsGenericSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_found_expr_would_be_stmt)]\n+#[diag(parse_found_expr_would_be_stmt)]\n pub(crate) struct FoundExprWouldBeStmt {\n     #[primary_span]\n     #[label]\n@@ -544,7 +544,7 @@ pub(crate) struct FoundExprWouldBeStmt {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_leading_plus_not_supported)]\n+#[diag(parse_leading_plus_not_supported)]\n pub(crate) struct LeadingPlusNotSupported {\n     #[primary_span]\n     #[label]\n@@ -561,7 +561,7 @@ pub(crate) struct LeadingPlusNotSupported {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_parentheses_with_struct_fields)]\n+#[diag(parse_parentheses_with_struct_fields)]\n pub(crate) struct ParenthesesWithStructFields {\n     #[primary_span]\n     pub span: Span,\n@@ -589,7 +589,7 @@ pub(crate) struct NoFieldsForFnCall {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_labeled_loop_in_break)]\n+#[diag(parse_labeled_loop_in_break)]\n pub(crate) struct LabeledLoopInBreak {\n     #[primary_span]\n     pub span: Span,\n@@ -599,7 +599,7 @@ pub(crate) struct LabeledLoopInBreak {\n \n #[derive(Subdiagnostic)]\n #[multipart_suggestion(\n-    parser_sugg_wrap_expression_in_parentheses,\n+    parse_sugg_wrap_expression_in_parentheses,\n     applicability = \"machine-applicable\"\n )]\n pub(crate) struct WrapExpressionInParentheses {\n@@ -610,7 +610,7 @@ pub(crate) struct WrapExpressionInParentheses {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_array_brackets_instead_of_braces)]\n+#[diag(parse_array_brackets_instead_of_braces)]\n pub(crate) struct ArrayBracketsInsteadOfSpaces {\n     #[primary_span]\n     pub span: Span,\n@@ -628,7 +628,7 @@ pub(crate) struct ArrayBracketsInsteadOfSpacesSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_match_arm_body_without_braces)]\n+#[diag(parse_match_arm_body_without_braces)]\n pub(crate) struct MatchArmBodyWithoutBraces {\n     #[primary_span]\n     #[label(label_statements)]\n@@ -661,7 +661,7 @@ pub(crate) enum MatchArmBodyWithoutBracesSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_struct_literal_not_allowed_here)]\n+#[diag(parse_struct_literal_not_allowed_here)]\n pub(crate) struct StructLiteralNotAllowedHere {\n     #[primary_span]\n     pub span: Span,\n@@ -679,14 +679,14 @@ pub(crate) struct StructLiteralNotAllowedHereSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_invalid_interpolated_expression)]\n+#[diag(parse_invalid_interpolated_expression)]\n pub(crate) struct InvalidInterpolatedExpression {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_invalid_literal_suffix_on_tuple_index)]\n+#[diag(parse_invalid_literal_suffix_on_tuple_index)]\n pub(crate) struct InvalidLiteralSuffixOnTupleIndex {\n     #[primary_span]\n     #[label]\n@@ -699,15 +699,15 @@ pub(crate) struct InvalidLiteralSuffixOnTupleIndex {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_non_string_abi_literal)]\n+#[diag(parse_non_string_abi_literal)]\n pub(crate) struct NonStringAbiLiteral {\n     #[primary_span]\n     #[suggestion(code = \"\\\"C\\\"\", applicability = \"maybe-incorrect\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_mismatched_closing_delimiter)]\n+#[diag(parse_mismatched_closing_delimiter)]\n pub(crate) struct MismatchedClosingDelimiter {\n     #[primary_span]\n     pub spans: Vec<Span>,\n@@ -721,7 +721,7 @@ pub(crate) struct MismatchedClosingDelimiter {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_incorrect_visibility_restriction, code = \"E0704\")]\n+#[diag(parse_incorrect_visibility_restriction, code = \"E0704\")]\n #[help]\n pub(crate) struct IncorrectVisibilityRestriction {\n     #[primary_span]\n@@ -731,21 +731,21 @@ pub(crate) struct IncorrectVisibilityRestriction {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_assignment_else_not_allowed)]\n+#[diag(parse_assignment_else_not_allowed)]\n pub(crate) struct AssignmentElseNotAllowed {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_expected_statement_after_outer_attr)]\n+#[diag(parse_expected_statement_after_outer_attr)]\n pub(crate) struct ExpectedStatementAfterOuterAttr {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_doc_comment_does_not_document_anything, code = \"E0585\")]\n+#[diag(parse_doc_comment_does_not_document_anything, code = \"E0585\")]\n #[help]\n pub(crate) struct DocCommentDoesNotDocumentAnything {\n     #[primary_span]\n@@ -755,15 +755,15 @@ pub(crate) struct DocCommentDoesNotDocumentAnything {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_const_let_mutually_exclusive)]\n+#[diag(parse_const_let_mutually_exclusive)]\n pub(crate) struct ConstLetMutuallyExclusive {\n     #[primary_span]\n     #[suggestion(code = \"const\", applicability = \"maybe-incorrect\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_invalid_expression_in_let_else)]\n+#[diag(parse_invalid_expression_in_let_else)]\n pub(crate) struct InvalidExpressionInLetElse {\n     #[primary_span]\n     pub span: Span,\n@@ -773,7 +773,7 @@ pub(crate) struct InvalidExpressionInLetElse {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_invalid_curly_in_let_else)]\n+#[diag(parse_invalid_curly_in_let_else)]\n pub(crate) struct InvalidCurlyInLetElse {\n     #[primary_span]\n     pub span: Span,\n@@ -782,7 +782,7 @@ pub(crate) struct InvalidCurlyInLetElse {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_compound_assignment_expression_in_let)]\n+#[diag(parse_compound_assignment_expression_in_let)]\n #[help]\n pub(crate) struct CompoundAssignmentExpressionInLet {\n     #[primary_span]\n@@ -791,15 +791,15 @@ pub(crate) struct CompoundAssignmentExpressionInLet {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_suffixed_literal_in_attribute)]\n+#[diag(parse_suffixed_literal_in_attribute)]\n #[help]\n pub(crate) struct SuffixedLiteralInAttribute {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_invalid_meta_item)]\n+#[diag(parse_invalid_meta_item)]\n pub(crate) struct InvalidMetaItem {\n     #[primary_span]\n     pub span: Span,\n@@ -808,7 +808,7 @@ pub(crate) struct InvalidMetaItem {\n \n #[derive(Subdiagnostic)]\n #[suggestion(\n-    parser_sugg_escape_to_use_as_identifier,\n+    parse_sugg_escape_to_use_as_identifier,\n     style = \"verbose\",\n     applicability = \"maybe-incorrect\",\n     code = \"r#\"\n@@ -820,23 +820,23 @@ pub(crate) struct SuggEscapeToUseAsIdentifier {\n }\n \n #[derive(Subdiagnostic)]\n-#[suggestion(parser_sugg_remove_comma, applicability = \"machine-applicable\", code = \"\")]\n+#[suggestion(parse_sugg_remove_comma, applicability = \"machine-applicable\", code = \"\")]\n pub(crate) struct SuggRemoveComma {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Subdiagnostic)]\n pub(crate) enum ExpectedIdentifierFound {\n-    #[label(parser_expected_identifier_found_reserved_identifier)]\n+    #[label(parse_expected_identifier_found_reserved_identifier)]\n     ReservedIdentifier(#[primary_span] Span),\n-    #[label(parser_expected_identifier_found_keyword)]\n+    #[label(parse_expected_identifier_found_keyword)]\n     Keyword(#[primary_span] Span),\n-    #[label(parser_expected_identifier_found_reserved_keyword)]\n+    #[label(parse_expected_identifier_found_reserved_keyword)]\n     ReservedKeyword(#[primary_span] Span),\n-    #[label(parser_expected_identifier_found_doc_comment)]\n+    #[label(parse_expected_identifier_found_doc_comment)]\n     DocComment(#[primary_span] Span),\n-    #[label(parser_expected_identifier)]\n+    #[label(parse_expected_identifier)]\n     Other(#[primary_span] Span),\n }\n \n@@ -871,16 +871,16 @@ impl<'a, G: EmissionGuarantee> IntoDiagnostic<'a, G> for ExpectedIdentifier {\n \n         let mut diag = handler.struct_diagnostic(match token_descr {\n             Some(TokenDescription::ReservedIdentifier) => {\n-                fluent::parser_expected_identifier_found_reserved_identifier_str\n+                fluent::parse_expected_identifier_found_reserved_identifier_str\n             }\n-            Some(TokenDescription::Keyword) => fluent::parser_expected_identifier_found_keyword_str,\n+            Some(TokenDescription::Keyword) => fluent::parse_expected_identifier_found_keyword_str,\n             Some(TokenDescription::ReservedKeyword) => {\n-                fluent::parser_expected_identifier_found_reserved_keyword_str\n+                fluent::parse_expected_identifier_found_reserved_keyword_str\n             }\n             Some(TokenDescription::DocComment) => {\n-                fluent::parser_expected_identifier_found_doc_comment_str\n+                fluent::parse_expected_identifier_found_doc_comment_str\n             }\n-            None => fluent::parser_expected_identifier_found_str,\n+            None => fluent::parse_expected_identifier_found_str,\n         });\n         diag.set_span(self.span);\n         diag.set_arg(\"token\", self.token);\n@@ -917,22 +917,20 @@ impl<'a, G: EmissionGuarantee> IntoDiagnostic<'a, G> for ExpectedSemi {\n \n         let mut diag = handler.struct_diagnostic(match token_descr {\n             Some(TokenDescription::ReservedIdentifier) => {\n-                fluent::parser_expected_semi_found_reserved_identifier_str\n+                fluent::parse_expected_semi_found_reserved_identifier_str\n             }\n-            Some(TokenDescription::Keyword) => fluent::parser_expected_semi_found_keyword_str,\n+            Some(TokenDescription::Keyword) => fluent::parse_expected_semi_found_keyword_str,\n             Some(TokenDescription::ReservedKeyword) => {\n-                fluent::parser_expected_semi_found_reserved_keyword_str\n+                fluent::parse_expected_semi_found_reserved_keyword_str\n             }\n-            Some(TokenDescription::DocComment) => {\n-                fluent::parser_expected_semi_found_doc_comment_str\n-            }\n-            None => fluent::parser_expected_semi_found_str,\n+            Some(TokenDescription::DocComment) => fluent::parse_expected_semi_found_doc_comment_str,\n+            None => fluent::parse_expected_semi_found_str,\n         });\n         diag.set_span(self.span);\n         diag.set_arg(\"token\", self.token);\n \n         if let Some(unexpected_token_label) = self.unexpected_token_label {\n-            diag.span_label(unexpected_token_label, fluent::parser_label_unexpected_token);\n+            diag.span_label(unexpected_token_label, fluent::parse_label_unexpected_token);\n         }\n \n         self.sugg.add_to_diagnostic(&mut diag);\n@@ -943,14 +941,10 @@ impl<'a, G: EmissionGuarantee> IntoDiagnostic<'a, G> for ExpectedSemi {\n \n #[derive(Subdiagnostic)]\n pub(crate) enum ExpectedSemiSugg {\n-    #[suggestion(\n-        parser_sugg_change_this_to_semi,\n-        code = \";\",\n-        applicability = \"machine-applicable\"\n-    )]\n+    #[suggestion(parse_sugg_change_this_to_semi, code = \";\", applicability = \"machine-applicable\")]\n     ChangeToSemi(#[primary_span] Span),\n     #[suggestion(\n-        parser_sugg_add_semi,\n+        parse_sugg_add_semi,\n         style = \"short\",\n         code = \";\",\n         applicability = \"machine-applicable\"\n@@ -959,7 +953,7 @@ pub(crate) enum ExpectedSemiSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_struct_literal_body_without_path)]\n+#[diag(parse_struct_literal_body_without_path)]\n pub(crate) struct StructLiteralBodyWithoutPath {\n     #[primary_span]\n     pub span: Span,\n@@ -977,7 +971,7 @@ pub(crate) struct StructLiteralBodyWithoutPathSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_unmatched_angle_brackets)]\n+#[diag(parse_unmatched_angle_brackets)]\n pub(crate) struct UnmatchedAngleBrackets {\n     #[primary_span]\n     #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n@@ -986,7 +980,7 @@ pub(crate) struct UnmatchedAngleBrackets {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_generic_parameters_without_angle_brackets)]\n+#[diag(parse_generic_parameters_without_angle_brackets)]\n pub(crate) struct GenericParamsWithoutAngleBrackets {\n     #[primary_span]\n     pub span: Span,\n@@ -1004,18 +998,18 @@ pub(crate) struct GenericParamsWithoutAngleBracketsSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_comparison_operators_cannot_be_chained)]\n+#[diag(parse_comparison_operators_cannot_be_chained)]\n pub(crate) struct ComparisonOperatorsCannotBeChained {\n     #[primary_span]\n     pub span: Vec<Span>,\n     #[suggestion(\n-        parser_sugg_turbofish_syntax,\n+        parse_sugg_turbofish_syntax,\n         style = \"verbose\",\n         code = \"::\",\n         applicability = \"maybe-incorrect\"\n     )]\n     pub suggest_turbofish: Option<Span>,\n-    #[help(parser_sugg_turbofish_syntax)]\n+    #[help(parse_sugg_turbofish_syntax)]\n     #[help(sugg_parentheses_for_function_args)]\n     pub help_turbofish: Option<()>,\n     #[subdiagnostic]\n@@ -1045,7 +1039,7 @@ pub(crate) enum ComparisonOperatorsCannotBeChainedSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_question_mark_in_type)]\n+#[diag(parse_question_mark_in_type)]\n pub(crate) struct QuestionMarkInType {\n     #[primary_span]\n     #[label]\n@@ -1064,7 +1058,7 @@ pub(crate) struct QuestionMarkInTypeSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_unexpected_parentheses_in_for_head)]\n+#[diag(parse_unexpected_parentheses_in_for_head)]\n pub(crate) struct ParenthesesInForHead {\n     #[primary_span]\n     pub span: Vec<Span>,\n@@ -1084,47 +1078,47 @@ pub(crate) struct ParenthesesInForHeadSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_doc_comment_on_param_type)]\n+#[diag(parse_doc_comment_on_param_type)]\n pub(crate) struct DocCommentOnParamType {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_attribute_on_param_type)]\n+#[diag(parse_attribute_on_param_type)]\n pub(crate) struct AttributeOnParamType {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_pattern_method_param_without_body, code = \"E0642\")]\n+#[diag(parse_pattern_method_param_without_body, code = \"E0642\")]\n pub(crate) struct PatternMethodParamWithoutBody {\n     #[primary_span]\n     #[suggestion(code = \"_\", applicability = \"machine-applicable\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_self_param_not_first)]\n+#[diag(parse_self_param_not_first)]\n pub(crate) struct SelfParamNotFirst {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_invalid_identifier_with_leading_number)]\n+#[diag(parse_invalid_identifier_with_leading_number)]\n pub(crate) struct InvalidIdentiferStartsWithNumber {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_const_generic_without_braces)]\n+#[diag(parse_const_generic_without_braces)]\n pub(crate) struct ConstGenericWithoutBraces {\n     #[primary_span]\n     pub span: Span,\n@@ -1142,7 +1136,7 @@ pub(crate) struct ConstGenericWithoutBracesSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_unexpected_const_param_declaration)]\n+#[diag(parse_unexpected_const_param_declaration)]\n pub(crate) struct UnexpectedConstParamDeclaration {\n     #[primary_span]\n     #[label]\n@@ -1174,7 +1168,7 @@ pub(crate) enum UnexpectedConstParamDeclarationSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_unexpected_const_in_generic_param)]\n+#[diag(parse_unexpected_const_in_generic_param)]\n pub(crate) struct UnexpectedConstInGenericParam {\n     #[primary_span]\n     pub span: Span,\n@@ -1183,15 +1177,15 @@ pub(crate) struct UnexpectedConstInGenericParam {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_async_move_order_incorrect)]\n+#[diag(parse_async_move_order_incorrect)]\n pub(crate) struct AsyncMoveOrderIncorrect {\n     #[primary_span]\n     #[suggestion(style = \"verbose\", code = \"async move\", applicability = \"maybe-incorrect\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_double_colon_in_bound)]\n+#[diag(parse_double_colon_in_bound)]\n pub(crate) struct DoubleColonInBound {\n     #[primary_span]\n     pub span: Span,\n@@ -1200,7 +1194,7 @@ pub(crate) struct DoubleColonInBound {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_fn_ptr_with_generics)]\n+#[diag(parse_fn_ptr_with_generics)]\n pub(crate) struct FnPtrWithGenerics {\n     #[primary_span]\n     pub span: Span,\n@@ -1221,7 +1215,7 @@ pub(crate) struct FnPtrWithGenericsSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_unexpected_if_with_if)]\n+#[diag(parse_unexpected_if_with_if)]\n pub(crate) struct UnexpectedIfWithIf(\n     #[primary_span]\n     #[suggestion(applicability = \"machine-applicable\", code = \" \", style = \"verbose\")]"}, {"sha": "fb2cee9e346bf94ed6eb429bac01086c2021c705", "filename": "compiler/rustc_parse/src/parser/attr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe212eca76f3976756e47355e4f0cb62984ec837/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe212eca76f3976756e47355e4f0cb62984ec837/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs?ref=fe212eca76f3976756e47355e4f0cb62984ec837", "patch": "@@ -55,7 +55,7 @@ impl<'a> Parser<'a> {\n                     let span = self.token.span;\n                     let mut err = self.sess.span_diagnostic.struct_span_err_with_code(\n                         span,\n-                        fluent::parser_inner_doc_comment_not_permitted,\n+                        fluent::parse_inner_doc_comment_not_permitted,\n                         error_code!(E0753),\n                     );\n                     if let Some(replacement_span) = self.annotate_following_item_if_applicable(\n@@ -200,7 +200,7 @@ impl<'a> Parser<'a> {\n                 Some(InnerAttrForbiddenReason::AfterOuterDocComment { prev_doc_comment_span }) => {\n                     let mut diag = self.struct_span_err(\n                         attr_sp,\n-                        fluent::parser_inner_attr_not_permitted_after_outer_doc_comment,\n+                        fluent::parse_inner_attr_not_permitted_after_outer_doc_comment,\n                     );\n                     diag.span_label(attr_sp, fluent::label_attr)\n                         .span_label(prev_doc_comment_span, fluent::label_prev_doc_comment);\n@@ -209,18 +209,18 @@ impl<'a> Parser<'a> {\n                 Some(InnerAttrForbiddenReason::AfterOuterAttribute { prev_outer_attr_sp }) => {\n                     let mut diag = self.struct_span_err(\n                         attr_sp,\n-                        fluent::parser_inner_attr_not_permitted_after_outer_attr,\n+                        fluent::parse_inner_attr_not_permitted_after_outer_attr,\n                     );\n                     diag.span_label(attr_sp, fluent::label_attr)\n                         .span_label(prev_outer_attr_sp, fluent::label_prev_attr);\n                     diag\n                 }\n                 Some(InnerAttrForbiddenReason::InCodeBlock) | None => {\n-                    self.struct_span_err(attr_sp, fluent::parser_inner_attr_not_permitted)\n+                    self.struct_span_err(attr_sp, fluent::parse_inner_attr_not_permitted)\n                 }\n             };\n \n-            diag.note(fluent::parser_inner_attr_explanation);\n+            diag.note(fluent::parse_inner_attr_explanation);\n             if self\n                 .annotate_following_item_if_applicable(\n                     &mut diag,\n@@ -229,7 +229,7 @@ impl<'a> Parser<'a> {\n                 )\n                 .is_some()\n             {\n-                diag.note(fluent::parser_outer_attr_explanation);\n+                diag.note(fluent::parse_outer_attr_explanation);\n             };\n             diag.emit();\n         }"}, {"sha": "4c626539238eba7da23ed4f8ccf8c98fa26579fa", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe212eca76f3976756e47355e4f0cb62984ec837/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe212eca76f3976756e47355e4f0cb62984ec837/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=fe212eca76f3976756e47355e4f0cb62984ec837", "patch": "@@ -937,7 +937,7 @@ impl<'a> Parser<'a> {\n                     if self.eat(&token::Gt) {\n                         e.span_suggestion_verbose(\n                             binop.span.shrink_to_lo(),\n-                            fluent::parser_sugg_turbofish_syntax,\n+                            fluent::parse_sugg_turbofish_syntax,\n                             \"::\",\n                             Applicability::MaybeIncorrect,\n                         )"}, {"sha": "2f7055e3cc5e8904e5f67570ec9e3c7b1583b852", "filename": "compiler/rustc_session/src/errors.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fe212eca76f3976756e47355e4f0cb62984ec837/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe212eca76f3976756e47355e4f0cb62984ec837/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ferrors.rs?ref=fe212eca76f3976756e47355e4f0cb62984ec837", "patch": "@@ -196,7 +196,7 @@ pub enum UnleashedFeatureHelp {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_invalid_literal_suffix)]\n+#[diag(session_invalid_literal_suffix)]\n pub(crate) struct InvalidLiteralSuffix {\n     #[primary_span]\n     #[label]\n@@ -207,7 +207,7 @@ pub(crate) struct InvalidLiteralSuffix {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_invalid_int_literal_width)]\n+#[diag(session_invalid_int_literal_width)]\n #[help]\n pub(crate) struct InvalidIntLiteralWidth {\n     #[primary_span]\n@@ -216,7 +216,7 @@ pub(crate) struct InvalidIntLiteralWidth {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_invalid_num_literal_base_prefix)]\n+#[diag(session_invalid_num_literal_base_prefix)]\n #[note]\n pub(crate) struct InvalidNumLiteralBasePrefix {\n     #[primary_span]\n@@ -226,7 +226,7 @@ pub(crate) struct InvalidNumLiteralBasePrefix {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_invalid_num_literal_suffix)]\n+#[diag(session_invalid_num_literal_suffix)]\n #[help]\n pub(crate) struct InvalidNumLiteralSuffix {\n     #[primary_span]\n@@ -236,7 +236,7 @@ pub(crate) struct InvalidNumLiteralSuffix {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_invalid_float_literal_width)]\n+#[diag(session_invalid_float_literal_width)]\n #[help]\n pub(crate) struct InvalidFloatLiteralWidth {\n     #[primary_span]\n@@ -245,7 +245,7 @@ pub(crate) struct InvalidFloatLiteralWidth {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_invalid_float_literal_suffix)]\n+#[diag(session_invalid_float_literal_suffix)]\n #[help]\n pub(crate) struct InvalidFloatLiteralSuffix {\n     #[primary_span]\n@@ -255,33 +255,33 @@ pub(crate) struct InvalidFloatLiteralSuffix {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_int_literal_too_large)]\n+#[diag(session_int_literal_too_large)]\n pub(crate) struct IntLiteralTooLarge {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_hexadecimal_float_literal_not_supported)]\n+#[diag(session_hexadecimal_float_literal_not_supported)]\n pub(crate) struct HexadecimalFloatLiteralNotSupported {\n     #[primary_span]\n-    #[label(parser_not_supported)]\n+    #[label(session_not_supported)]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_octal_float_literal_not_supported)]\n+#[diag(session_octal_float_literal_not_supported)]\n pub(crate) struct OctalFloatLiteralNotSupported {\n     #[primary_span]\n-    #[label(parser_not_supported)]\n+    #[label(session_not_supported)]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser_binary_float_literal_not_supported)]\n+#[diag(session_binary_float_literal_not_supported)]\n pub(crate) struct BinaryFloatLiteralNotSupported {\n     #[primary_span]\n-    #[label(parser_not_supported)]\n+    #[label(session_not_supported)]\n     pub span: Span,\n }\n "}]}