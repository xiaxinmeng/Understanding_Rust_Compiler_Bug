{"sha": "4145877731e9f38a4640d2dfeed7b123d81d061a", "node_id": "C_kwDOAAsO6NoAKDQxNDU4Nzc3MzFlOWYzOGE0NjQwZDJkZmVlZDdiMTIzZDgxZDA2MWE", "commit": {"author": {"name": "Chris Denton", "email": "christophersdenton@gmail.com", "date": "2022-01-03T12:55:42Z"}, "committer": {"name": "Chris Denton", "email": "christophersdenton@gmail.com", "date": "2022-01-03T12:55:42Z"}, "message": "Explicitly pass `PATH` to the Windows exe resolver", "tree": {"sha": "8e5c1c3440f818b82bfcdb63f57e088028ebe211", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e5c1c3440f818b82bfcdb63f57e088028ebe211"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4145877731e9f38a4640d2dfeed7b123d81d061a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE+p/jD6jrzmnSIWJLcTRy8vRWJ94FAmHS8k4ACgkQcTRy8vRW\nJ97Ldw/+Luy/v2ei4iSTOsnDEnu1qvEY0RCdWlCFZXL3pj0CqpmoK/pUnjue0gdz\nOrrT2X6wIl5FuUIqB7hGycSrDdDR9FuqJLmAjvEGZxgIHfsGwAty+8cYWJy75YH0\nCJVrHZ5v9sy4wtPYhxZCvoh6ZzdbNvbJJ9sWNy7nOzoZgoJEno9BlWDbpH8IcNrV\nnLxk0VW2I2pQjTpV1KvOFsaKTgoo04C5RMYkYuWQwi0hByw1VzsITCQ5W0cBUnrm\n9IdrLqEkudt2c+Zb3XFBqD/UgidZudZvdobu7RVJJSl7y3f3AhWCpA38vZVaGOCS\np9Pc3Ct9dBBVx8DIgIcpYh70C9UIigRHWpeIkoQmFD8U5/XcIaiCJHhXG7pRiyIA\nkw7eYK2tSrrHue8vpBiLV5+aQaK1AXR7NAgxZEXg25LsrwkZEcbYj7GvnvqiFSnb\nME//8a5tVKZ57x4MtMh7uLNA5/ZGExqoIChvQvHOvkxyAcvTnr2WOAwuxNp4geKI\n+pbZOkMs5DBmDW3FyMaJ4dGEesCjKaeWZF3OIYvl6wbVsC30k4/oR71x8NnuwEXh\nANTDCAutag7DltBRrVKiuSGYhlfe4csbR5E912dtRzdomMF79Uqqm90pqFzArunn\n85vMfSMKEz44ZIo7ocW+f/Gb6maIx0rJANfIF7yxiqwS17TtCys=\n=IIt9\n-----END PGP SIGNATURE-----", "payload": "tree 8e5c1c3440f818b82bfcdb63f57e088028ebe211\nparent d367c349ef2dd04ebc876a0cd0b0efa46c18ff12\nauthor Chris Denton <christophersdenton@gmail.com> 1641214542 +0000\ncommitter Chris Denton <christophersdenton@gmail.com> 1641214542 +0000\n\nExplicitly pass `PATH` to the Windows exe resolver\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4145877731e9f38a4640d2dfeed7b123d81d061a", "html_url": "https://github.com/rust-lang/rust/commit/4145877731e9f38a4640d2dfeed7b123d81d061a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4145877731e9f38a4640d2dfeed7b123d81d061a/comments", "author": {"login": "ChrisDenton", "id": 4459874, "node_id": "MDQ6VXNlcjQ0NTk4NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4459874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisDenton", "html_url": "https://github.com/ChrisDenton", "followers_url": "https://api.github.com/users/ChrisDenton/followers", "following_url": "https://api.github.com/users/ChrisDenton/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisDenton/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisDenton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisDenton/subscriptions", "organizations_url": "https://api.github.com/users/ChrisDenton/orgs", "repos_url": "https://api.github.com/users/ChrisDenton/repos", "events_url": "https://api.github.com/users/ChrisDenton/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisDenton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ChrisDenton", "id": 4459874, "node_id": "MDQ6VXNlcjQ0NTk4NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4459874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisDenton", "html_url": "https://github.com/ChrisDenton", "followers_url": "https://api.github.com/users/ChrisDenton/followers", "following_url": "https://api.github.com/users/ChrisDenton/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisDenton/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisDenton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisDenton/subscriptions", "organizations_url": "https://api.github.com/users/ChrisDenton/orgs", "repos_url": "https://api.github.com/users/ChrisDenton/repos", "events_url": "https://api.github.com/users/ChrisDenton/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisDenton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d367c349ef2dd04ebc876a0cd0b0efa46c18ff12", "url": "https://api.github.com/repos/rust-lang/rust/commits/d367c349ef2dd04ebc876a0cd0b0efa46c18ff12", "html_url": "https://github.com/rust-lang/rust/commit/d367c349ef2dd04ebc876a0cd0b0efa46c18ff12"}], "stats": {"total": 70, "additions": 37, "deletions": 33}, "files": [{"sha": "5ad570427978e5244b0d8d9f4af8c9ae3488d77b", "filename": "library/std/src/sys/windows/process.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4145877731e9f38a4640d2dfeed7b123d81d061a/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4145877731e9f38a4640d2dfeed7b123d81d061a/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs?ref=4145877731e9f38a4640d2dfeed7b123d81d061a", "patch": "@@ -268,7 +268,7 @@ impl Command {\n         } else {\n             None\n         };\n-        let program = resolve_exe(&self.program, child_paths)?;\n+        let program = resolve_exe(&self.program, || env::var_os(\"PATH\"), child_paths)?;\n         let mut cmd_str =\n             make_command_line(program.as_os_str(), &self.args, self.force_quotes_enabled)?;\n         cmd_str.push(0); // add null terminator\n@@ -362,7 +362,11 @@ impl fmt::Debug for Command {\n // Therefore this functions first assumes `.exe` was intended.\n // It falls back to the plain file name if a full path is given and the extension is omitted\n // or if only a file name is given and it already contains an extension.\n-fn resolve_exe<'a>(exe_path: &'a OsStr, child_paths: Option<&OsStr>) -> io::Result<PathBuf> {\n+fn resolve_exe<'a>(\n+    exe_path: &'a OsStr,\n+    parent_paths: impl FnOnce() -> Option<OsString>,\n+    child_paths: Option<&OsStr>,\n+) -> io::Result<PathBuf> {\n     // Early return if there is no filename.\n     if exe_path.is_empty() || path::has_trailing_slash(exe_path) {\n         return Err(io::Error::new_const(\n@@ -406,7 +410,7 @@ fn resolve_exe<'a>(exe_path: &'a OsStr, child_paths: Option<&OsStr>) -> io::Resu\n         let has_extension = exe_path.bytes().contains(&b'.');\n \n         // Search the directories given by `search_paths`.\n-        let result = search_paths(child_paths, |mut path| {\n+        let result = search_paths(parent_paths, child_paths, |mut path| {\n             path.push(&exe_path);\n             if !has_extension {\n                 path.set_extension(EXE_EXTENSION);\n@@ -423,15 +427,20 @@ fn resolve_exe<'a>(exe_path: &'a OsStr, child_paths: Option<&OsStr>) -> io::Resu\n \n // Calls `f` for every path that should be used to find an executable.\n // Returns once `f` returns the path to an executable or all paths have been searched.\n-fn search_paths<F>(child_paths: Option<&OsStr>, mut f: F) -> Option<PathBuf>\n+fn search_paths<Paths, Exists>(\n+    parent_paths: Paths,\n+    child_paths: Option<&OsStr>,\n+    mut exists: Exists,\n+) -> Option<PathBuf>\n where\n-    F: FnMut(PathBuf) -> Option<PathBuf>,\n+    Paths: FnOnce() -> Option<OsString>,\n+    Exists: FnMut(PathBuf) -> Option<PathBuf>,\n {\n     // 1. Child paths\n     // This is for consistency with Rust's historic behaviour.\n     if let Some(paths) = child_paths {\n         for path in env::split_paths(paths).filter(|p| !p.as_os_str().is_empty()) {\n-            if let Some(path) = f(path) {\n+            if let Some(path) = exists(path) {\n                 return Some(path);\n             }\n         }\n@@ -440,7 +449,7 @@ where\n     // 2. Application path\n     if let Ok(mut app_path) = env::current_exe() {\n         app_path.pop();\n-        if let Some(path) = f(app_path) {\n+        if let Some(path) = exists(app_path) {\n             return Some(path);\n         }\n     }\n@@ -450,25 +459,25 @@ where\n     unsafe {\n         if let Ok(Some(path)) = super::fill_utf16_buf(\n             |buf, size| c::GetSystemDirectoryW(buf, size),\n-            |buf| f(PathBuf::from(OsString::from_wide(buf))),\n+            |buf| exists(PathBuf::from(OsString::from_wide(buf))),\n         ) {\n             return Some(path);\n         }\n         #[cfg(not(target_vendor = \"uwp\"))]\n         {\n             if let Ok(Some(path)) = super::fill_utf16_buf(\n                 |buf, size| c::GetWindowsDirectoryW(buf, size),\n-                |buf| f(PathBuf::from(OsString::from_wide(buf))),\n+                |buf| exists(PathBuf::from(OsString::from_wide(buf))),\n             ) {\n                 return Some(path);\n             }\n         }\n     }\n \n     // 5. Parent paths\n-    if let Some(parent_paths) = env::var_os(\"PATH\") {\n+    if let Some(parent_paths) = parent_paths() {\n         for path in env::split_paths(&parent_paths).filter(|p| !p.as_os_str().is_empty()) {\n-            if let Some(path) = f(path) {\n+            if let Some(path) = exists(path) {\n                 return Some(path);\n             }\n         }"}, {"sha": "f1221767af30e56d43581d5d48183b27d057e7d3", "filename": "library/std/src/sys/windows/process/tests.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4145877731e9f38a4640d2dfeed7b123d81d061a/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4145877731e9f38a4640d2dfeed7b123d81d061a/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess%2Ftests.rs?ref=4145877731e9f38a4640d2dfeed7b123d81d061a", "patch": "@@ -136,51 +136,46 @@ fn windows_exe_resolver() {\n     use super::resolve_exe;\n     use crate::io;\n \n+    let env_paths = || env::var_os(\"PATH\");\n+\n     // Test a full path, with and without the `exe` extension.\n     let mut current_exe = env::current_exe().unwrap();\n-    assert!(resolve_exe(current_exe.as_ref(), None).is_ok());\n+    assert!(resolve_exe(current_exe.as_ref(), env_paths, None).is_ok());\n     current_exe.set_extension(\"\");\n-    assert!(resolve_exe(current_exe.as_ref(), None).is_ok());\n+    assert!(resolve_exe(current_exe.as_ref(), env_paths, None).is_ok());\n \n     // Test lone file names.\n-    assert!(resolve_exe(OsStr::new(\"cmd\"), None).is_ok());\n-    assert!(resolve_exe(OsStr::new(\"cmd.exe\"), None).is_ok());\n-    assert!(resolve_exe(OsStr::new(\"cmd.EXE\"), None).is_ok());\n-    assert!(resolve_exe(OsStr::new(\"fc\"), None).is_ok());\n+    assert!(resolve_exe(OsStr::new(\"cmd\"), env_paths, None).is_ok());\n+    assert!(resolve_exe(OsStr::new(\"cmd.exe\"), env_paths, None).is_ok());\n+    assert!(resolve_exe(OsStr::new(\"cmd.EXE\"), env_paths, None).is_ok());\n+    assert!(resolve_exe(OsStr::new(\"fc\"), env_paths, None).is_ok());\n \n     // Invalid file names should return InvalidInput.\n-    assert_eq!(resolve_exe(OsStr::new(\"\"), None).unwrap_err().kind(), io::ErrorKind::InvalidInput);\n     assert_eq!(\n-        resolve_exe(OsStr::new(\"\\0\"), None).unwrap_err().kind(),\n+        resolve_exe(OsStr::new(\"\"), env_paths, None).unwrap_err().kind(),\n+        io::ErrorKind::InvalidInput\n+    );\n+    assert_eq!(\n+        resolve_exe(OsStr::new(\"\\0\"), env_paths, None).unwrap_err().kind(),\n         io::ErrorKind::InvalidInput\n     );\n     // Trailing slash, therefore there's no file name component.\n     assert_eq!(\n-        resolve_exe(OsStr::new(r\"C:\\Path\\to\\\"), None).unwrap_err().kind(),\n+        resolve_exe(OsStr::new(r\"C:\\Path\\to\\\"), env_paths, None).unwrap_err().kind(),\n         io::ErrorKind::InvalidInput\n     );\n \n-    /* FIXME: fix and re-enable these tests before making changes to the resolver.\n-\n     /*\n     Some of the following tests may need to be changed if you are deliberately\n     changing the behaviour of `resolve_exe`.\n     */\n \n-    let paths = env::var_os(\"PATH\").unwrap();\n-    env::set_var(\"PATH\", \"\");\n-\n-    assert_eq!(resolve_exe(OsStr::new(\"rustc\"), None).unwrap_err().kind(), io::ErrorKind::NotFound);\n-\n-    let child_paths = Some(paths.as_os_str());\n-    assert!(resolve_exe(OsStr::new(\"rustc\"), child_paths).is_ok());\n+    let empty_paths = || None;\n \n     // The resolver looks in system directories even when `PATH` is empty.\n-    assert!(resolve_exe(OsStr::new(\"cmd.exe\"), None).is_ok());\n+    assert!(resolve_exe(OsStr::new(\"cmd.exe\"), empty_paths, None).is_ok());\n \n     // The application's directory is also searched.\n     let current_exe = env::current_exe().unwrap();\n-    assert!(resolve_exe(current_exe.file_name().unwrap().as_ref(), None).is_ok());\n-\n-    */\n+    assert!(resolve_exe(current_exe.file_name().unwrap().as_ref(), empty_paths, None).is_ok());\n }"}]}