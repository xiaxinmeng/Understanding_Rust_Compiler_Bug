{"sha": "7cfb05fd23b5ecc6a13f4629844ff81ac758497c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjZmIwNWZkMjNiNWVjYzZhMTNmNDYyOTg0NGZmODFhYzc1ODQ5N2M=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-01-30T13:16:18Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-01-30T13:16:18Z"}, "message": "Merge `locals` and `local_layouts` fields", "tree": {"sha": "f9202bed4ad74eb9fba2d8f24606e8bfd10b50bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9202bed4ad74eb9fba2d8f24606e8bfd10b50bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7cfb05fd23b5ecc6a13f4629844ff81ac758497c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7cfb05fd23b5ecc6a13f4629844ff81ac758497c", "html_url": "https://github.com/rust-lang/rust/commit/7cfb05fd23b5ecc6a13f4629844ff81ac758497c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7cfb05fd23b5ecc6a13f4629844ff81ac758497c/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43b4c4a36b6c189bf0718a9d77ff1164c3fa7cac", "url": "https://api.github.com/repos/rust-lang/rust/commits/43b4c4a36b6c189bf0718a9d77ff1164c3fa7cac", "html_url": "https://github.com/rust-lang/rust/commit/43b4c4a36b6c189bf0718a9d77ff1164c3fa7cac"}], "stats": {"total": 107, "additions": 68, "deletions": 39}, "files": [{"sha": "d2cabde986345b746c125693d2cd959dbeba227f", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 40, "deletions": 30, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/7cfb05fd23b5ecc6a13f4629844ff81ac758497c/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cfb05fd23b5ecc6a13f4629844ff81ac758497c/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=7cfb05fd23b5ecc6a13f4629844ff81ac758497c", "patch": "@@ -76,8 +76,7 @@ pub struct Frame<'mir, 'tcx: 'mir, Tag=(), Extra=()> {\n     /// The locals are stored as `Option<Value>`s.\n     /// `None` represents a local that is currently dead, while a live local\n     /// can either directly contain `Scalar` or refer to some part of an `Allocation`.\n-    pub locals: IndexVec<mir::Local, LocalValue<Tag>>,\n-    pub local_layouts: IndexVec<mir::Local, Cell<Option<TyLayout<'tcx>>>>,\n+    pub locals: IndexVec<mir::Local, LocalValue<'tcx, Tag>>,\n \n     ////////////////////////////////////////////////////////////////////////////////\n     // Current position within the function\n@@ -106,9 +105,17 @@ pub enum StackPopCleanup {\n     None { cleanup: bool },\n }\n \n-// State of a local variable\n+/// State of a local variable including a memoized layout\n+#[derive(Clone, PartialEq, Eq)]\n+pub struct LocalValue<'tcx, Tag=(), Id=AllocId> {\n+    pub state: LocalState<Tag, Id>,\n+    /// Don't modify if `Some`, this is only used to prevent computing the layout twice\n+    pub layout: Cell<Option<TyLayout<'tcx>>>,\n+}\n+\n+/// State of a local variable\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-pub enum LocalValue<Tag=(), Id=AllocId> {\n+pub enum LocalState<Tag=(), Id=AllocId> {\n     Dead,\n     // Mostly for convenience, we re-use the `Operand` type here.\n     // This is an optimization over just always having a pointer here;\n@@ -117,18 +124,18 @@ pub enum LocalValue<Tag=(), Id=AllocId> {\n     Live(Operand<Tag, Id>),\n }\n \n-impl<'tcx, Tag> LocalValue<Tag> {\n+impl<'tcx, Tag> LocalValue<'tcx, Tag> {\n     pub fn access(&self) -> EvalResult<'tcx, &Operand<Tag>> {\n-        match self {\n-            LocalValue::Dead => err!(DeadLocal),\n-            LocalValue::Live(ref val) => Ok(val),\n+        match self.state {\n+            LocalState::Dead => err!(DeadLocal),\n+            LocalState::Live(ref val) => Ok(val),\n         }\n     }\n \n     pub fn access_mut(&mut self) -> EvalResult<'tcx, &mut Operand<Tag>> {\n-        match self {\n-            LocalValue::Dead => err!(DeadLocal),\n-            LocalValue::Live(ref mut val) => Ok(val),\n+        match self.state {\n+            LocalState::Dead => err!(DeadLocal),\n+            LocalState::Live(ref mut val) => Ok(val),\n         }\n     }\n }\n@@ -312,7 +319,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         frame: &Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>,\n         local: mir::Local\n     ) -> EvalResult<'tcx, TyLayout<'tcx>> {\n-        let cell = &frame.local_layouts[local];\n+        let cell = &frame.locals[local].layout;\n         if cell.get().is_none() {\n             let local_ty = frame.mir.local_decls[local].ty;\n             let local_ty = self.monomorphize_with_substs(local_ty, frame.instance.substs);\n@@ -454,7 +461,6 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n             // empty local array, we fill it in below, after we are inside the stack frame and\n             // all methods actually know about the frame\n             locals: IndexVec::new(),\n-            local_layouts: IndexVec::from_elem_n(Default::default(), mir.local_decls.len()),\n             span,\n             instance,\n             stmt: 0,\n@@ -464,14 +470,18 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         // don't allocate at all for trivial constants\n         if mir.local_decls.len() > 1 {\n             // We put some marker immediate into the locals that we later want to initialize.\n-            // This can be anything except for LocalValue::Dead -- because *that* is the\n+            // This can be anything except for LocalState::Dead -- because *that* is the\n             // value we use for things that we know are initially dead.\n-            let dummy =\n-                LocalValue::Live(Operand::Immediate(Immediate::Scalar(ScalarMaybeUndef::Undef)));\n+            let dummy = LocalValue {\n+                state: LocalState::Live(Operand::Immediate(Immediate::Scalar(\n+                    ScalarMaybeUndef::Undef,\n+                ))),\n+                layout: Cell::new(None),\n+            };\n             let mut locals = IndexVec::from_elem(dummy, &mir.local_decls);\n             // Return place is handled specially by the `eval_place` functions, and the\n             // entry in `locals` should never be used. Make it dead, to be sure.\n-            locals[mir::RETURN_PLACE] = LocalValue::Dead;\n+            locals[mir::RETURN_PLACE].state = LocalState::Dead;\n             // Now mark those locals as dead that we do not want to initialize\n             match self.tcx.describe_def(instance.def_id()) {\n                 // statics and constants don't have `Storage*` statements, no need to look for them\n@@ -484,7 +494,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n                             match stmt.kind {\n                                 StorageLive(local) |\n                                 StorageDead(local) => {\n-                                    locals[local] = LocalValue::Dead;\n+                                    locals[local].state = LocalState::Dead;\n                                 }\n                                 _ => {}\n                             }\n@@ -494,13 +504,13 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n             }\n             // Finally, properly initialize all those that still have the dummy value\n             for (idx, local) in locals.iter_enumerated_mut() {\n-                match *local {\n-                    LocalValue::Live(_) => {\n+                match local.state {\n+                    LocalState::Live(_) => {\n                         // This needs to be peoperly initialized.\n                         let layout = self.layout_of_local(self.frame(), idx)?;\n-                        *local = LocalValue::Live(self.uninit_operand(layout)?);\n+                        local.state = LocalState::Live(self.uninit_operand(layout)?);\n                     }\n-                    LocalValue::Dead => {\n+                    LocalState::Dead => {\n                         // Nothing to do\n                     }\n                 }\n@@ -543,7 +553,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         }\n         // Deallocate all locals that are backed by an allocation.\n         for local in frame.locals {\n-            self.deallocate_local(local)?;\n+            self.deallocate_local(local.state)?;\n         }\n         // Validate the return value. Do this after deallocating so that we catch dangling\n         // references.\n@@ -587,31 +597,31 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n     pub fn storage_live(\n         &mut self,\n         local: mir::Local\n-    ) -> EvalResult<'tcx, LocalValue<M::PointerTag>> {\n+    ) -> EvalResult<'tcx, LocalState<M::PointerTag>> {\n         assert!(local != mir::RETURN_PLACE, \"Cannot make return place live\");\n         trace!(\"{:?} is now live\", local);\n \n         let layout = self.layout_of_local(self.frame(), local)?;\n-        let init = LocalValue::Live(self.uninit_operand(layout)?);\n+        let init = LocalState::Live(self.uninit_operand(layout)?);\n         // StorageLive *always* kills the value that's currently stored\n-        Ok(mem::replace(&mut self.frame_mut().locals[local], init))\n+        Ok(mem::replace(&mut self.frame_mut().locals[local].state, init))\n     }\n \n     /// Returns the old value of the local.\n     /// Remember to deallocate that!\n-    pub fn storage_dead(&mut self, local: mir::Local) -> LocalValue<M::PointerTag> {\n+    pub fn storage_dead(&mut self, local: mir::Local) -> LocalState<M::PointerTag> {\n         assert!(local != mir::RETURN_PLACE, \"Cannot make return place dead\");\n         trace!(\"{:?} is now dead\", local);\n \n-        mem::replace(&mut self.frame_mut().locals[local], LocalValue::Dead)\n+        mem::replace(&mut self.frame_mut().locals[local].state, LocalState::Dead)\n     }\n \n     pub(super) fn deallocate_local(\n         &mut self,\n-        local: LocalValue<M::PointerTag>,\n+        local: LocalState<M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n         // FIXME: should we tell the user that there was a local which was never written to?\n-        if let LocalValue::Live(Operand::Indirect(MemPlace { ptr, .. })) = local {\n+        if let LocalState::Live(Operand::Indirect(MemPlace { ptr, .. })) = local {\n             trace!(\"deallocating local\");\n             let ptr = ptr.to_ptr()?;\n             self.memory.dump_alloc(ptr.alloc_id);"}, {"sha": "6ee7d3309f464789e96a5b848661c706682c73bd", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cfb05fd23b5ecc6a13f4629844ff81ac758497c/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cfb05fd23b5ecc6a13f4629844ff81ac758497c/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=7cfb05fd23b5ecc6a13f4629844ff81ac758497c", "patch": "@@ -18,7 +18,7 @@ mod visitor;\n pub use rustc::mir::interpret::*; // have all the `interpret` symbols in one place: here\n \n pub use self::eval_context::{\n-    EvalContext, Frame, StackPopCleanup, LocalValue,\n+    EvalContext, Frame, StackPopCleanup, LocalValue, LocalState,\n };\n \n pub use self::place::{Place, PlaceTy, MemPlace, MPlaceTy};"}, {"sha": "0b5dc9446921a896ee1caf354e48e0bec22d039c", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7cfb05fd23b5ecc6a13f4629844ff81ac758497c/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cfb05fd23b5ecc6a13f4629844ff81ac758497c/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=7cfb05fd23b5ecc6a13f4629844ff81ac758497c", "patch": "@@ -7,7 +7,7 @@\n \n use std::hash::{Hash, Hasher};\n \n-use rustc::ich::StableHashingContextProvider;\n+use rustc::ich::{StableHashingContextProvider, StableHashingContext};\n use rustc::mir;\n use rustc::mir::interpret::{\n     AllocId, Pointer, Scalar,\n@@ -19,12 +19,12 @@ use rustc::ty::{self, TyCtxt};\n use rustc::ty::layout::Align;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n use syntax::ast::Mutability;\n use syntax::source_map::Span;\n \n use super::eval_context::{LocalValue, StackPopCleanup};\n-use super::{Frame, Memory, Operand, MemPlace, Place, Immediate, ScalarMaybeUndef};\n+use super::{Frame, Memory, Operand, MemPlace, Place, Immediate, ScalarMaybeUndef, LocalState};\n use const_eval::CompileTimeInterpreter;\n \n #[derive(Default)]\n@@ -250,11 +250,11 @@ impl_snapshot_for!(enum Operand {\n     Indirect(m),\n });\n \n-impl_stable_hash_for!(enum ::interpret::LocalValue {\n+impl_stable_hash_for!(enum ::interpret::LocalState {\n     Dead,\n     Live(x),\n });\n-impl_snapshot_for!(enum LocalValue {\n+impl_snapshot_for!(enum LocalState {\n     Live(v),\n     Dead,\n });\n@@ -309,7 +309,7 @@ struct FrameSnapshot<'a, 'tcx: 'a> {\n     span: &'a Span,\n     return_to_block: &'a StackPopCleanup,\n     return_place: Option<Place<(), AllocIdSnapshot<'a>>>,\n-    locals: IndexVec<mir::Local, LocalValue<(), AllocIdSnapshot<'a>>>,\n+    locals: IndexVec<mir::Local, LocalState<(), AllocIdSnapshot<'a>>>,\n     block: &'a mir::BasicBlock,\n     stmt: usize,\n }\n@@ -321,7 +321,6 @@ impl_stable_hash_for!(impl<'mir, 'tcx: 'mir> for struct Frame<'mir, 'tcx> {\n     return_to_block,\n     return_place -> (return_place.as_ref().map(|r| &**r)),\n     locals,\n-    local_layouts -> _,\n     block,\n     stmt,\n     extra,\n@@ -340,7 +339,6 @@ impl<'a, 'mir, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a Frame<'mir, 'tcx>\n             return_to_block,\n             return_place,\n             locals,\n-            local_layouts: _,\n             block,\n             stmt,\n             extra: _,\n@@ -358,6 +356,27 @@ impl<'a, 'mir, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a Frame<'mir, 'tcx>\n     }\n }\n \n+impl<'a, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a LocalValue<'tcx>\n+    where Ctx: SnapshotContext<'a>,\n+{\n+    type Item = LocalState<(), AllocIdSnapshot<'a>>;\n+\n+    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n+        self.state.snapshot(ctx)\n+    }\n+}\n+\n+\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for LocalValue<'gcx> {\n+    fn hash_stable<W: StableHasherResult>(\n+        &self,\n+        hcx: &mut StableHashingContext<'a>,\n+        hasher: &mut StableHasher<W>,\n+    ) {\n+        self.state.hash_stable(hcx, hasher);\n+    }\n+}\n+\n impl<'a, 'b, 'mir, 'tcx: 'a+'mir> SnapshotContext<'b>\n     for Memory<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>\n {"}]}