{"sha": "fd13bdf626a50b5b21afbbe87806dc346f8ea9d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkMTNiZGY2MjZhNTBiNWIyMWFmYmJlODc4MDZkYzM0NmY4ZWE5ZDc=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-27T22:03:38Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-27T22:03:38Z"}, "message": "vec fixes for huonw", "tree": {"sha": "ff0b00739a7f7891b41099b16132530a0cd80663", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff0b00739a7f7891b41099b16132530a0cd80663"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd13bdf626a50b5b21afbbe87806dc346f8ea9d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd13bdf626a50b5b21afbbe87806dc346f8ea9d7", "html_url": "https://github.com/rust-lang/rust/commit/fd13bdf626a50b5b21afbbe87806dc346f8ea9d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd13bdf626a50b5b21afbbe87806dc346f8ea9d7/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b53406f8241edb45eb962795da99cb2cf73d8c1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b53406f8241edb45eb962795da99cb2cf73d8c1a", "html_url": "https://github.com/rust-lang/rust/commit/b53406f8241edb45eb962795da99cb2cf73d8c1a"}], "stats": {"total": 31, "additions": 17, "deletions": 14}, "files": [{"sha": "93efbbbdf89a2e49df2bedad48ca8361c26dd518", "filename": "src/doc/tarpl/vec-alloc.md", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fd13bdf626a50b5b21afbbe87806dc346f8ea9d7/src%2Fdoc%2Ftarpl%2Fvec-alloc.md", "raw_url": "https://github.com/rust-lang/rust/raw/fd13bdf626a50b5b21afbbe87806dc346f8ea9d7/src%2Fdoc%2Ftarpl%2Fvec-alloc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-alloc.md?ref=fd13bdf626a50b5b21afbbe87806dc346f8ea9d7", "patch": "@@ -61,9 +61,7 @@ like the standard library as much as possible, so we'll just kill the whole\n program.\n \n We said we don't want to use intrinsics, so doing *exactly* what `std` does is\n-out. `std::rt::util::abort` actually exists, but it takes a message to print,\n-which will probably allocate. Also it's still unstable. Instead, we'll call\n-`std::process::exit` with some random number.\n+out. Instead, we'll call `std::process::exit` with some random number.\n \n ```rust\n fn oom() {\n@@ -78,7 +76,7 @@ if cap == 0:\n     allocate()\n     cap = 1\n else:\n-    reallocate\n+    reallocate()\n     cap *= 2\n ```\n \n@@ -109,7 +107,7 @@ the same location in memory, the operations need to be done to the same value,\n and they can't just be merged afterwards.\n \n When you use GEP inbounds, you are specifically telling LLVM that the offsets\n-you're about to do are within the bounds of a single allocated entity. The\n+you're about to do are within the bounds of a single \"allocated\" entity. The\n ultimate payoff being that LLVM can assume that if two pointers are known to\n point to two disjoint objects, all the offsets of those pointers are *also*\n known to not alias (because you won't just end up in some random place in\n@@ -162,7 +160,8 @@ elements. This is a runtime no-op because every element takes up no space,\n and it's fine to pretend that there's infinite zero-sized types allocated\n at `0x01`. No allocator will ever allocate that address, because they won't\n allocate `0x00` and they generally allocate to some minimal alignment higher\n-than a byte.\n+than a byte. Also generally the whole first page of memory is\n+protected from being allocated anyway (a whole 4k, on many platforms).\n \n However what about for positive-sized types? That one's a bit trickier. In\n principle, you can argue that offsetting by 0 gives LLVM no information: either"}, {"sha": "3be295f1adc2d301ad643c8294469725312e9d4f", "filename": "src/doc/tarpl/vec-drain.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd13bdf626a50b5b21afbbe87806dc346f8ea9d7/src%2Fdoc%2Ftarpl%2Fvec-drain.md", "raw_url": "https://github.com/rust-lang/rust/raw/fd13bdf626a50b5b21afbbe87806dc346f8ea9d7/src%2Fdoc%2Ftarpl%2Fvec-drain.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-drain.md?ref=fd13bdf626a50b5b21afbbe87806dc346f8ea9d7", "patch": "@@ -83,6 +83,7 @@ impl<T> Vec<T> {\n     pub fn into_iter(self) -> IntoIter<T> {\n         unsafe {\n             let iter = RawValIter::new(&self);\n+\n             let buf = ptr::read(&self.buf);\n             mem::forget(self);\n \n@@ -112,7 +113,7 @@ pub struct Drain<'a, T: 'a> {\n \n impl<'a, T> Iterator for Drain<'a, T> {\n     type Item = T;\n-    fn next(&mut self) -> Option<T> { self.iter.next_back() }\n+    fn next(&mut self) -> Option<T> { self.iter.next() }\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n "}, {"sha": "325399d622b69910741240bdd8dd453029bcb913", "filename": "src/doc/tarpl/vec-layout.md", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fd13bdf626a50b5b21afbbe87806dc346f8ea9d7/src%2Fdoc%2Ftarpl%2Fvec-layout.md", "raw_url": "https://github.com/rust-lang/rust/raw/fd13bdf626a50b5b21afbbe87806dc346f8ea9d7/src%2Fdoc%2Ftarpl%2Fvec-layout.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-layout.md?ref=fd13bdf626a50b5b21afbbe87806dc346f8ea9d7", "patch": "@@ -1,7 +1,10 @@\n % Layout\n \n-First off, we need to come up with the struct layout. Naively we want this\n-design:\n+First off, we need to come up with the struct layout. A Vec has three parts:\n+a pointer to the allocation, the size of the allocation, and the number of\n+elements that have been initialized.\n+\n+Naively, this means we just want this design:\n \n ```rust\n pub struct Vec<T> {"}, {"sha": "8f78462cf40271218ccd7d52b69e8fcd63e2d2b2", "filename": "src/doc/tarpl/vec-raw.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd13bdf626a50b5b21afbbe87806dc346f8ea9d7/src%2Fdoc%2Ftarpl%2Fvec-raw.md", "raw_url": "https://github.com/rust-lang/rust/raw/fd13bdf626a50b5b21afbbe87806dc346f8ea9d7/src%2Fdoc%2Ftarpl%2Fvec-raw.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-raw.md?ref=fd13bdf626a50b5b21afbbe87806dc346f8ea9d7", "patch": "@@ -1,9 +1,9 @@\n % RawVec\n \n We've actually reached an interesting situation here: we've duplicated the logic\n-for specifying a buffer and freeing its memory. Now that we've implemented it\n-and identified *actual* logic duplication, this is a good time to perform some\n-logic compression.\n+for specifying a buffer and freeing its memory in Vec and IntoIter. Now that\n+we've implemented it and identified *actual* logic duplication, this is a good\n+time to perform some logic compression.\n \n We're going to abstract out the `(ptr, cap)` pair and give them the logic for\n allocating, growing, and freeing:\n@@ -64,7 +64,7 @@ impl<T> Drop for RawVec<T> {\n }\n ```\n \n-And change vec as follows:\n+And change Vec as follows:\n \n ```rust,ignore\n pub struct Vec<T> {"}, {"sha": "63f83788c4bac55a8298fe17874d3fd8f99e94ce", "filename": "src/doc/tarpl/vec.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd13bdf626a50b5b21afbbe87806dc346f8ea9d7/src%2Fdoc%2Ftarpl%2Fvec.md", "raw_url": "https://github.com/rust-lang/rust/raw/fd13bdf626a50b5b21afbbe87806dc346f8ea9d7/src%2Fdoc%2Ftarpl%2Fvec.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec.md?ref=fd13bdf626a50b5b21afbbe87806dc346f8ea9d7", "patch": "@@ -12,7 +12,7 @@ bit nicer or efficient because intrinsics are permanently unstable. Although\n many intrinsics *do* become stabilized elsewhere (`std::ptr` and `str::mem`\n consist of many intrinsics).\n \n-Ultimately this means out implementation may not take advantage of all\n+Ultimately this means our implementation may not take advantage of all\n possible optimizations, though it will be by no means *naive*. We will\n definitely get into the weeds over nitty-gritty details, even\n when the problem doesn't *really* merit it."}]}