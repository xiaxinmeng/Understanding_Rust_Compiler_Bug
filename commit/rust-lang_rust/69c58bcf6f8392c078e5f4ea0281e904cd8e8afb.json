{"sha": "69c58bcf6f8392c078e5f4ea0281e904cd8e8afb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5YzU4YmNmNmY4MzkyYzA3OGU1ZjRlYTAyODFlOTA0Y2Q4ZThhZmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-10T13:56:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-10T13:56:16Z"}, "message": "auto merge of #16185 : luqmana/rust/match-drop, r=pcwalton\n\nFixes #15571.\r\nFixes #16151.\r\n\r\nr? @pcwalton", "tree": {"sha": "9ff7819aa285719a92d51ac742de4f6e808ac227", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ff7819aa285719a92d51ac742de4f6e808ac227"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69c58bcf6f8392c078e5f4ea0281e904cd8e8afb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69c58bcf6f8392c078e5f4ea0281e904cd8e8afb", "html_url": "https://github.com/rust-lang/rust/commit/69c58bcf6f8392c078e5f4ea0281e904cd8e8afb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69c58bcf6f8392c078e5f4ea0281e904cd8e8afb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4d608fabda8f39f319ebefd9aebf4ceb7c1bbf4", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4d608fabda8f39f319ebefd9aebf4ceb7c1bbf4", "html_url": "https://github.com/rust-lang/rust/commit/d4d608fabda8f39f319ebefd9aebf4ceb7c1bbf4"}, {"sha": "71df8e655c1a7a435082de753694821f359fb8a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/71df8e655c1a7a435082de753694821f359fb8a9", "html_url": "https://github.com/rust-lang/rust/commit/71df8e655c1a7a435082de753694821f359fb8a9"}], "stats": {"total": 244, "additions": 232, "deletions": 12}, "files": [{"sha": "8ed471ec58a5e7da3a805bb7968d690245d0dc4b", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/69c58bcf6f8392c078e5f4ea0281e904cd8e8afb/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69c58bcf6f8392c078e5f4ea0281e904cd8e8afb/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=69c58bcf6f8392c078e5f4ea0281e904cd8e8afb", "patch": "@@ -140,9 +140,10 @@ pub enum astencode_tag { // Reserves 0x40 -- 0x5f\n     tag_table_moves_map = 0x52,\n     tag_table_capture_map = 0x53,\n     tag_table_unboxed_closure_type = 0x54,\n+    tag_table_upvar_borrow_map = 0x55,\n }\n static first_astencode_tag: uint = tag_ast as uint;\n-static last_astencode_tag: uint = tag_table_unboxed_closure_type as uint;\n+static last_astencode_tag: uint = tag_table_upvar_borrow_map as uint;\n impl astencode_tag {\n     pub fn from_uint(value : uint) -> Option<astencode_tag> {\n         let is_a_tag = first_astencode_tag <= value && value <= last_astencode_tag;"}, {"sha": "33b663dea1557b5ea208b4d24b196eb5280de252", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/69c58bcf6f8392c078e5f4ea0281e904cd8e8afb/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69c58bcf6f8392c078e5f4ea0281e904cd8e8afb/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=69c58bcf6f8392c078e5f4ea0281e904cd8e8afb", "patch": "@@ -18,6 +18,7 @@ use driver::session::Session;\n use metadata::decoder;\n use middle::def;\n use e = metadata::encoder;\n+use middle::freevars;\n use middle::freevars::freevar_entry;\n use middle::region;\n use metadata::tydecode;\n@@ -551,6 +552,15 @@ impl tr for freevar_entry {\n     }\n }\n \n+impl tr for ty::UpvarBorrow {\n+    fn tr(&self, xcx: &ExtendedDecodeContext) -> ty::UpvarBorrow {\n+        ty::UpvarBorrow {\n+            kind: self.kind,\n+            region: self.region.tr(xcx)\n+        }\n+    }\n+}\n+\n // ______________________________________________________________________\n // Encoding and decoding of MethodCallee\n \n@@ -1061,7 +1071,29 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                     Ok(encode_freevar_entry(rbml_w, fv_entry))\n                 });\n             })\n-        })\n+        });\n+\n+        for freevar in fv.iter() {\n+            match freevars::get_capture_mode(tcx, id) {\n+                freevars::CaptureByRef => {\n+                    rbml_w.tag(c::tag_table_upvar_borrow_map, |rbml_w| {\n+                        rbml_w.id(id);\n+                        rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                            let var_id = freevar.def.def_id().node;\n+                            let upvar_id = ty::UpvarId {\n+                                var_id: var_id,\n+                                closure_expr_id: id\n+                            };\n+                            let upvar_borrow = tcx.upvar_borrow_map.borrow()\n+                                                  .get_copy(&upvar_id);\n+                            var_id.encode(rbml_w);\n+                            upvar_borrow.encode(rbml_w);\n+                        })\n+                    })\n+                }\n+                _ => {}\n+            }\n+        }\n     }\n \n     let lid = ast::DefId { krate: ast::LOCAL_CRATE, node: id };\n@@ -1468,6 +1500,15 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n                         }).unwrap().move_iter().collect();\n                         dcx.tcx.freevars.borrow_mut().insert(id, fv_info);\n                     }\n+                    c::tag_table_upvar_borrow_map => {\n+                        let var_id: ast::NodeId = Decodable::decode(val_dsr).unwrap();\n+                        let upvar_id = ty::UpvarId {\n+                            var_id: xcx.tr_id(var_id),\n+                            closure_expr_id: id\n+                        };\n+                        let ub: ty::UpvarBorrow = Decodable::decode(val_dsr).unwrap();\n+                        dcx.tcx.upvar_borrow_map.borrow_mut().insert(upvar_id, ub.tr(xcx));\n+                    }\n                     c::tag_table_tcache => {\n                         let pty = val_dsr.read_polytype(xcx);\n                         let lid = ast::DefId { krate: ast::LOCAL_CRATE, node: id };"}, {"sha": "eda567f7d187c1a33745f52b154601c20eac2c57", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69c58bcf6f8392c078e5f4ea0281e904cd8e8afb/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69c58bcf6f8392c078e5f4ea0281e904cd8e8afb/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=69c58bcf6f8392c078e5f4ea0281e904cd8e8afb", "patch": "@@ -14,6 +14,7 @@\n #![allow(non_camel_case_types)]\n \n use middle::def;\n+use middle::mem_categorization::Typer;\n use middle::resolve;\n use middle::ty;\n use util::nodemap::{DefIdSet, NodeMap, NodeSet};\n@@ -147,11 +148,8 @@ pub fn with_freevars<T>(tcx: &ty::ctxt, fid: ast::NodeId, f: |&[freevar_entry]|\n     }\n }\n \n-pub fn get_capture_mode(tcx: &ty::ctxt,\n-                        closure_expr_id: ast::NodeId)\n-                        -> CaptureMode\n-{\n-    let fn_ty = ty::node_id_to_type(tcx, closure_expr_id);\n+pub fn get_capture_mode<T: Typer>(tcx: &T, closure_expr_id: ast::NodeId) -> CaptureMode {\n+    let fn_ty = tcx.node_ty(closure_expr_id).ok().expect(\"couldn't find closure ty?\");\n     match ty::ty_closure_store(fn_ty) {\n         ty::RegionTraitStore(..) => CaptureByRef,\n         ty::UniqTraitStore => CaptureByValue"}, {"sha": "85b6294ae34e6d270c4bf49d39f2922d639d204d", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 50, "deletions": 3, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/69c58bcf6f8392c078e5f4ea0281e904cd8e8afb/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69c58bcf6f8392c078e5f4ea0281e904cd8e8afb/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=69c58bcf6f8392c078e5f4ea0281e904cd8e8afb", "patch": "@@ -189,7 +189,9 @@\n #![allow(non_camel_case_types)]\n \n use back::abi;\n+use mc = middle::mem_categorization;\n use driver::config::FullDebugInfo;\n+use euv = middle::expr_use_visitor;\n use llvm;\n use llvm::{ValueRef, BasicBlockRef};\n use middle::const_eval;\n@@ -1292,13 +1294,58 @@ pub fn trans_match<'a>(\n     trans_match_inner(bcx, match_expr.id, discr_expr, arms, dest)\n }\n \n-fn create_bindings_map(bcx: &Block, pat: Gc<ast::Pat>) -> BindingsMap {\n+/// Checks whether the binding in `discr` is assigned to anywhere in the expression `body`\n+fn is_discr_reassigned(bcx: &Block, discr: &ast::Expr, body: &ast::Expr) -> bool {\n+    match discr.node {\n+        ast::ExprPath(..) => match bcx.def(discr.id) {\n+            def::DefArg(vid, _) | def::DefBinding(vid, _) |\n+            def::DefLocal(vid, _) | def::DefUpvar(vid, _, _, _) => {\n+                let mut rc = ReassignmentChecker {\n+                    node: vid,\n+                    reassigned: false\n+                };\n+                {\n+                    let mut visitor = euv::ExprUseVisitor::new(&mut rc, bcx);\n+                    visitor.walk_expr(body);\n+                }\n+                rc.reassigned\n+            }\n+            _ => false\n+        },\n+        _ => false\n+    }\n+}\n+\n+struct ReassignmentChecker {\n+    node: ast::NodeId,\n+    reassigned: bool\n+}\n+\n+impl euv::Delegate for ReassignmentChecker {\n+    fn consume(&mut self, _: ast::NodeId, _: Span, _: mc::cmt, _: euv::ConsumeMode) {}\n+    fn consume_pat(&mut self, _: &ast::Pat, _: mc::cmt, _: euv::ConsumeMode) {}\n+    fn borrow(&mut self, _: ast::NodeId, _: Span, _: mc::cmt, _: ty::Region,\n+              _: ty::BorrowKind, _: euv::LoanCause) {}\n+    fn decl_without_init(&mut self, _: ast::NodeId, _: Span) {}\n+\n+    fn mutate(&mut self, _: ast::NodeId, _: Span, cmt: mc::cmt, _: euv::MutateMode) {\n+        match cmt.cat {\n+            mc::cat_copied_upvar(mc::CopiedUpvar { upvar_id: vid, .. }) |\n+            mc::cat_arg(vid) | mc::cat_local(vid) => self.reassigned = self.node == vid,\n+            _ => {}\n+        }\n+    }\n+}\n+\n+fn create_bindings_map(bcx: &Block, pat: Gc<ast::Pat>,\n+                      discr: &ast::Expr, body: &ast::Expr) -> BindingsMap {\n     // Create the bindings map, which is a mapping from each binding name\n     // to an alloca() that will be the value for that local variable.\n     // Note that we use the names because each binding will have many ids\n     // from the various alternatives.\n     let ccx = bcx.ccx();\n     let tcx = bcx.tcx();\n+    let reassigned = is_discr_reassigned(bcx, discr, body);\n     let mut bindings_map = HashMap::new();\n     pat_bindings(&tcx.def_map, &*pat, |bm, p_id, span, path1| {\n         let ident = path1.node;\n@@ -1310,7 +1357,7 @@ fn create_bindings_map(bcx: &Block, pat: Gc<ast::Pat>) -> BindingsMap {\n         let trmode;\n         match bm {\n             ast::BindByValue(_)\n-                if !ty::type_moves_by_default(tcx, variable_ty) => {\n+                if !ty::type_moves_by_default(tcx, variable_ty) || reassigned => {\n                 llmatch = alloca_no_lifetime(bcx,\n                                  llvariable_ty.ptr_to(),\n                                  \"__llmatch\");\n@@ -1371,7 +1418,7 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n     let arm_datas: Vec<ArmData> = arms.iter().map(|arm| ArmData {\n         bodycx: fcx.new_id_block(\"case_body\", arm.body.id),\n         arm: arm,\n-        bindings_map: create_bindings_map(bcx, *arm.pats.get(0))\n+        bindings_map: create_bindings_map(bcx, *arm.pats.get(0), discr_expr, &*arm.body)\n     }).collect();\n \n     let mut static_inliner = StaticInliner { tcx: scope_cx.tcx() };"}, {"sha": "84f380e862a4d1253ae74b7c53859847029a8bf3", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/69c58bcf6f8392c078e5f4ea0281e904cd8e8afb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69c58bcf6f8392c078e5f4ea0281e904cd8e8afb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=69c58bcf6f8392c078e5f4ea0281e904cd8e8afb", "patch": "@@ -16,6 +16,7 @@ use driver::session::Session;\n use llvm;\n use llvm::{ValueRef, BasicBlockRef, BuilderRef};\n use llvm::{True, False, Bool};\n+use mc = middle::mem_categorization;\n use middle::def;\n use middle::lang_items::LangItem;\n use middle::subst;\n@@ -481,6 +482,36 @@ impl<'a> Block<'a> {\n     }\n }\n \n+impl<'a> mc::Typer for Block<'a> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+        self.tcx()\n+    }\n+\n+    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<ty::t> {\n+        Ok(node_id_type(self, id))\n+    }\n+\n+    fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<ty::t> {\n+        self.tcx().method_map.borrow().find(&method_call).map(|method| method.ty)\n+    }\n+\n+    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment>> {\n+        &self.tcx().adjustments\n+    }\n+\n+    fn is_method_call(&self, id: ast::NodeId) -> bool {\n+        self.tcx().method_map.borrow().contains_key(&typeck::MethodCall::expr(id))\n+    }\n+\n+    fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<ast::NodeId> {\n+        self.tcx().region_maps.temporary_scope(rvalue_id)\n+    }\n+\n+    fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow {\n+        self.tcx().upvar_borrow_map.borrow().get_copy(&upvar_id)\n+    }\n+}\n+\n pub struct Result<'a> {\n     pub bcx: &'a Block<'a>,\n     pub val: ValueRef"}, {"sha": "a4588da1bd7dd7361a22669e54bfd057b0036f61", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69c58bcf6f8392c078e5f4ea0281e904cd8e8afb/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69c58bcf6f8392c078e5f4ea0281e904cd8e8afb/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=69c58bcf6f8392c078e5f4ea0281e904cd8e8afb", "patch": "@@ -539,7 +539,7 @@ pub struct UpvarId {\n     pub closure_expr_id: ast::NodeId,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n+#[deriving(Clone, PartialEq, Eq, Hash, Show, Encodable, Decodable)]\n pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n     ImmBorrow,\n@@ -634,7 +634,7 @@ pub enum BorrowKind {\n  *   the closure, so sometimes it is necessary for them to be larger\n  *   than the closure lifetime itself.\n  */\n-#[deriving(PartialEq, Clone)]\n+#[deriving(PartialEq, Clone, Encodable, Decodable)]\n pub struct UpvarBorrow {\n     pub kind: BorrowKind,\n     pub region: ty::Region,"}, {"sha": "0ef0fc83c94565ca23300abadb44e72cbf69e4a7", "filename": "src/test/run-pass/issue-15571.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/69c58bcf6f8392c078e5f4ea0281e904cd8e8afb/src%2Ftest%2Frun-pass%2Fissue-15571.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69c58bcf6f8392c078e5f4ea0281e904cd8e8afb/src%2Ftest%2Frun-pass%2Fissue-15571.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15571.rs?ref=69c58bcf6f8392c078e5f4ea0281e904cd8e8afb", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn match_on_local() {\n+    let mut foo = Some(box 5i);\n+    match foo {\n+        None => {},\n+        Some(x) => {\n+            foo = Some(x);\n+        }\n+    }\n+    println!(\"'{}'\", foo.unwrap());\n+}\n+\n+fn match_on_arg(mut foo: Option<Box<int>>) {\n+    match foo {\n+        None => {}\n+        Some(x) => {\n+            foo = Some(x);\n+        }\n+    }\n+    println!(\"'{}'\", foo.unwrap());\n+}\n+\n+fn match_on_binding() {\n+    match Some(box 7i) {\n+        mut foo => {\n+            match foo {\n+                None => {},\n+                Some(x) => {\n+                    foo = Some(x);\n+                }\n+            }\n+            println!(\"'{}'\", foo.unwrap());\n+        }\n+    }\n+}\n+\n+fn match_on_upvar() {\n+    let mut foo = Some(box 8i);\n+    (proc() {\n+        match foo {\n+            None => {},\n+            Some(x) => {\n+                foo = Some(x);\n+            }\n+        }\n+        println!(\"'{}'\", foo.unwrap());\n+    })();\n+}\n+\n+fn main() {\n+    match_on_local();\n+    match_on_arg(Some(box 6i));\n+    match_on_binding();\n+    match_on_upvar();\n+}"}, {"sha": "9cc571c7819cdc5d1366b61ff7f41a7160a71da9", "filename": "src/test/run-pass/issue-16151.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/69c58bcf6f8392c078e5f4ea0281e904cd8e8afb/src%2Ftest%2Frun-pass%2Fissue-16151.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69c58bcf6f8392c078e5f4ea0281e904cd8e8afb/src%2Ftest%2Frun-pass%2Fissue-16151.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16151.rs?ref=69c58bcf6f8392c078e5f4ea0281e904cd8e8afb", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::mem;\n+\n+static mut DROP_COUNT: uint = 0;\n+\n+struct Fragment;\n+\n+impl Drop for Fragment {\n+    fn drop(&mut self) {\n+        unsafe {\n+            DROP_COUNT += 1;\n+        }\n+    }\n+}\n+\n+fn main() {\n+    {\n+        let mut fragments = vec![Fragment, Fragment, Fragment];\n+        let _new_fragments: Vec<Fragment> = mem::replace(&mut fragments, vec![])\n+            .move_iter()\n+            .skip_while(|_fragment| {\n+                true\n+            }).collect();\n+    }\n+    unsafe {\n+        assert_eq!(DROP_COUNT, 3);\n+    }\n+}\n+"}]}