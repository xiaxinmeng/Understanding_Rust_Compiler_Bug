{"sha": "e968672ac7b4fe840b2b1561585f7ca7d4fd892d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5Njg2NzJhYzdiNGZlODQwYjJiMTU2MTU4NWY3Y2E3ZDRmZDg5MmQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-03-11T19:05:17Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-03-11T19:05:17Z"}, "message": "rustc: Map local variables to their containing blocks so we know their regions", "tree": {"sha": "97170e550a81cde99d9519e7dbaf12ee83eac46b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97170e550a81cde99d9519e7dbaf12ee83eac46b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e968672ac7b4fe840b2b1561585f7ca7d4fd892d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e968672ac7b4fe840b2b1561585f7ca7d4fd892d", "html_url": "https://github.com/rust-lang/rust/commit/e968672ac7b4fe840b2b1561585f7ca7d4fd892d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e968672ac7b4fe840b2b1561585f7ca7d4fd892d/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3035a1b205caef6279c91b276e672c54318838c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3035a1b205caef6279c91b276e672c54318838c", "html_url": "https://github.com/rust-lang/rust/commit/d3035a1b205caef6279c91b276e672c54318838c"}], "stats": {"total": 93, "additions": 85, "deletions": 8}, "files": [{"sha": "6dacdf49b854621e4172027f395776f7995d0c53", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e968672ac7b4fe840b2b1561585f7ca7d4fd892d/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e968672ac7b4fe840b2b1561585f7ca7d4fd892d/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=e968672ac7b4fe840b2b1561585f7ca7d4fd892d", "patch": "@@ -142,7 +142,7 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n              bind freevars::annotate_freevars(def_map, crate));\n     let region_map =\n         time(time_passes, \"region resolution\",\n-             bind middle::region::resolve_crate(sess, crate));\n+             bind middle::region::resolve_crate(sess, def_map, crate));\n     let ty_cx = ty::mk_ctxt(sess, def_map, ast_map, freevars, region_map);\n     let (method_map, dict_map) =\n         time(time_passes, \"typechecking\","}, {"sha": "303ad24513d417e98b85ced09041212f59130072", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 84, "deletions": 7, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/e968672ac7b4fe840b2b1561585f7ca7d4fd892d/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e968672ac7b4fe840b2b1561585f7ca7d4fd892d/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=e968672ac7b4fe840b2b1561585f7ca7d4fd892d", "patch": "@@ -10,20 +10,36 @@ import std::map;\n import std::map::hashmap;\n \n type region_map = {\n+    /* Mapping from a block to its parent block, if there is one. */\n     parent_blocks: hashmap<ast::node_id,ast::node_id>,\n-    ast_type_to_region: hashmap<ast::node_id,ty::region>\n+    /* Mapping from a region type in the AST to its resolved region. */\n+    ast_type_to_region: hashmap<ast::node_id,ty::region>,\n+    /* Mapping from a local variable to its containing block. */\n+    local_blocks: hashmap<ast::node_id,ast::node_id>\n };\n \n+/* Represents the type of the most immediate parent node. */\n enum parent {\n     pa_item(ast::node_id),\n     pa_block(ast::node_id),\n+    pa_alt,\n     pa_crate\n }\n \n type ctxt = {\n     sess: session,\n+    def_map: resolve::def_map,\n     region_map: @region_map,\n     names_in_scope: hashmap<str,ast::def_id>,\n+\n+    /*\n+     * A list of local IDs that will be parented to the next block we traverse.\n+     * This is used when resolving `alt` statements. Since we see the pattern\n+     * before the associated block, upon seeing a pattern we must parent all the\n+     * bindings in that pattern to the next block we see.\n+     */\n+    mut queued_locals: [ast::node_id],\n+\n     parent: parent\n };\n \n@@ -44,6 +60,12 @@ fn resolve_ty(ty: @ast::ty, cx: ctxt, visitor: visit::vt<ctxt>) {\n                         pa_block(block_id) {\n                             region = ty::re_block(block_id);\n                         }\n+                        pa_alt {\n+                            // FIXME: Need a design decision here.\n+                            cx.sess.span_bug(ty.span,\n+                                             \"what does & in an alt \" +\n+                                             \"resolve to?\");\n+                        }\n                         pa_crate {\n                             cx.sess.span_bug(ty.span,\n                                              \"region type outside item\");\n@@ -59,7 +81,7 @@ fn resolve_ty(ty: @ast::ty, cx: ctxt, visitor: visit::vt<ctxt>) {\n                         none {\n                             alt cx.parent {\n                                 pa_item(_) { /* ok; fall through */ }\n-                                pa_block(_) {\n+                                pa_block(_) | pa_alt {\n                                     cx.sess.span_err(ty.span,\n                                                      \"unknown region `\" +\n                                                      ident + \"`\");\n@@ -89,6 +111,12 @@ fn resolve_ty(ty: @ast::ty, cx: ctxt, visitor: visit::vt<ctxt>) {\n                         pa_block(block_id) {\n                             region = ty::re_block(block_id);\n                         }\n+                        pa_alt {\n+                            // FIXME: Need a design decision here.\n+                            cx.sess.span_bug(ty.span,\n+                                             \"what does &self. in an alt \" +\n+                                             \"resolve to?\");\n+                        }\n                         pa_crate {\n                             cx.sess.span_bug(ty.span,\n                                              \"region type outside item\");\n@@ -108,17 +136,60 @@ fn resolve_ty(ty: @ast::ty, cx: ctxt, visitor: visit::vt<ctxt>) {\n \n fn resolve_block(blk: ast::blk, cx: ctxt, visitor: visit::vt<ctxt>) {\n     alt cx.parent {\n-        pa_item(_) { /* no-op */ }\n+        pa_item(_) | pa_alt { /* no-op */ }\n         pa_block(parent_block_id) {\n             cx.region_map.parent_blocks.insert(blk.node.id, parent_block_id);\n         }\n         pa_crate { cx.sess.span_bug(blk.span, \"block outside item?!\"); }\n     }\n \n-    let new_cx: ctxt = {parent: pa_block(blk.node.id) with cx};\n+    // Resolve queued locals to this block.\n+    for local_id in cx.queued_locals {\n+        cx.region_map.local_blocks.insert(local_id, blk.node.id);\n+    }\n+\n+    let new_cx: ctxt = {parent: pa_block(blk.node.id),\n+                        mut queued_locals: [] with cx};\n     visit::visit_block(blk, new_cx, visitor);\n }\n \n+fn resolve_arm(arm: ast::arm, cx: ctxt, visitor: visit::vt<ctxt>) {\n+    let new_cx: ctxt = {parent: pa_alt,\n+                        mut queued_locals: [] with cx};\n+    visit::visit_arm(arm, new_cx, visitor);\n+}\n+\n+fn resolve_pat(pat: @ast::pat, cx: ctxt, visitor: visit::vt<ctxt>) {\n+    alt pat.node {\n+        ast::pat_ident(path, _) {\n+            let defn_opt = cx.def_map.find(pat.id);\n+            alt defn_opt {\n+                some(ast::def_variant(_,_)) {\n+                    /* Nothing to do; this names a variant. */\n+                }\n+                _ {\n+                    /*\n+                     * This names a local. Enqueue it or bind it to the containing\n+                     * block, depending on whether we're in an alt or not.\n+                     */\n+                    alt cx.parent {\n+                        pa_block(block_id) {\n+                            cx.region_map.local_blocks.insert(pat.id, block_id);\n+                        }\n+                        pa_alt {\n+                            vec::push(cx.queued_locals, pat.id);\n+                        }\n+                        _ { cx.sess.span_bug(pat.span, \"unexpected parent\"); }\n+                    }\n+                }\n+            }\n+        }\n+        _ { /* no-op */ }\n+    }\n+\n+    visit::visit_pat(pat, cx, visitor);\n+}\n+\n fn resolve_item(item: @ast::item, cx: ctxt, visitor: visit::vt<ctxt>) {\n     // Items create a new outer block scope as far as we're concerned.\n     let new_cx: ctxt = {names_in_scope: map::new_str_hash(),\n@@ -127,16 +198,22 @@ fn resolve_item(item: @ast::item, cx: ctxt, visitor: visit::vt<ctxt>) {\n     visit::visit_item(item, new_cx, visitor);\n }\n \n-fn resolve_crate(sess: session, crate: @ast::crate) -> @region_map {\n+fn resolve_crate(sess: session, def_map: resolve::def_map, crate: @ast::crate)\n+        -> @region_map {\n     let cx: ctxt = {sess: sess,\n+                    def_map: def_map,\n                     region_map: @{parent_blocks: map::new_int_hash(),\n-                                  ast_type_to_region: map::new_int_hash()},\n+                                  ast_type_to_region: map::new_int_hash(),\n+                                  local_blocks: map::new_int_hash()},\n                     names_in_scope: map::new_str_hash(),\n+                    mut queued_locals: [],\n                     parent: pa_crate};\n     let visitor = visit::mk_vt(@{\n         visit_block: resolve_block,\n         visit_item: resolve_item,\n-        visit_ty: resolve_ty\n+        visit_ty: resolve_ty,\n+        visit_arm: resolve_arm,\n+        visit_pat: resolve_pat\n         with *visit::default_visitor()\n     });\n     visit::visit_crate(*crate, cx, visitor);"}]}