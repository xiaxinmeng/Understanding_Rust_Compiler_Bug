{"sha": "a787f4001388a394d5219b74113a718d980e4c90", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3ODdmNDAwMTM4OGEzOTRkNTIxOWI3NDExM2E3MThkOTgwZTRjOTA=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-04T00:33:20Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-06T17:42:39Z"}, "message": "Select on pipes.\n\nUpdating syntax and test cases.", "tree": {"sha": "907807154819ee7859c66d230c54deaf0446d1c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/907807154819ee7859c66d230c54deaf0446d1c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a787f4001388a394d5219b74113a718d980e4c90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a787f4001388a394d5219b74113a718d980e4c90", "html_url": "https://github.com/rust-lang/rust/commit/a787f4001388a394d5219b74113a718d980e4c90", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a787f4001388a394d5219b74113a718d980e4c90/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89bdd481e59c5416f75668bc1b4782b57a167333", "url": "https://api.github.com/repos/rust-lang/rust/commits/89bdd481e59c5416f75668bc1b4782b57a167333", "html_url": "https://github.com/rust-lang/rust/commit/89bdd481e59c5416f75668bc1b4782b57a167333"}], "stats": {"total": 668, "additions": 284, "deletions": 384}, "files": [{"sha": "f1617c59ac7d3ecac17fbd54ea4840e4334e169e", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 120, "deletions": 22, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/a787f4001388a394d5219b74113a718d980e4c90/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a787f4001388a394d5219b74113a718d980e4c90/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=a787f4001388a394d5219b74113a718d980e4c90", "patch": "@@ -9,31 +9,37 @@ enum state {\n     terminated\n }\n \n-type packet<T: send> = {\n+type packet_header = {\n     mut state: state,\n     mut blocked_task: option<*rust_task>,\n+};\n+\n+type packet<T: send> = {\n+    header: packet_header,\n     mut payload: option<T>\n };\n \n fn packet<T: send>() -> *packet<T> unsafe {\n     let p: *packet<T> = unsafe::transmute(~{\n-        mut state: empty,\n-        mut blocked_task: none::<task::task>,\n+        header: {\n+            mut state: empty,\n+            mut blocked_task: none::<task::task>,\n+        },\n         mut payload: none::<T>\n     });\n     p\n }\n \n #[abi = \"rust-intrinsic\"]\n-native mod rusti {\n+extern mod rusti {\n     fn atomic_xchng(&dst: int, src: int) -> int;\n     fn atomic_xchng_acq(&dst: int, src: int) -> int;\n     fn atomic_xchng_rel(&dst: int, src: int) -> int;\n }\n \n type rust_task = libc::c_void;\n \n-native mod rustrt {\n+extern mod rustrt {\n     #[rust_stack]\n     fn rust_get_task() -> *rust_task;\n \n@@ -71,7 +77,7 @@ fn send<T: send>(-p: send_packet<T>, -payload: T) {\n     let p = unsafe { uniquify(p_) };\n     assert (*p).payload == none;\n     (*p).payload <- some(payload);\n-    let old_state = swap_state_rel((*p).state, full);\n+    let old_state = swap_state_rel(p.header.state, full);\n     alt old_state {\n       empty {\n         // Yay, fastpath.\n@@ -82,9 +88,10 @@ fn send<T: send>(-p: send_packet<T>, -payload: T) {\n       full { fail \"duplicate send\" }\n       blocked {\n         #debug(\"waking up task for %?\", p_);\n-        alt p.blocked_task {\n+        alt p.header.blocked_task {\n           some(task) {\n-            rustrt::task_signal_event(task, p_ as *libc::c_void);\n+            rustrt::task_signal_event(\n+                task, ptr::addr_of(p.header) as *libc::c_void);\n           }\n           none { fail \"blocked packet has no task\" }\n         }\n@@ -104,28 +111,28 @@ fn recv<T: send>(-p: recv_packet<T>) -> option<T> {\n     let p = unsafe { uniquify(p_) };\n     let this = rustrt::rust_get_task();\n     rustrt::task_clear_event_reject(this);\n-    p.blocked_task = some(this);\n+    p.header.blocked_task = some(this);\n     loop {\n-        let old_state = swap_state_acq((*p).state,\n+        let old_state = swap_state_acq(p.header.state,\n                                        blocked);\n         #debug(\"%?\", old_state);\n         alt old_state {\n           empty {\n             #debug(\"no data available on %?, going to sleep.\", p_);\n             rustrt::task_wait_event(this);\n-            #debug(\"woke up, p.state = %?\", p.state);\n-            if p.state == full {\n+            #debug(\"woke up, p.state = %?\", p.header.state);\n+            if p.header.state == full {\n                 let mut payload = none;\n                 payload <-> (*p).payload;\n-                p.state = terminated;\n+                p.header.state = terminated;\n                 ret some(option::unwrap(payload))\n             }\n           }\n           blocked { fail \"blocking on already blocked packet\" }\n           full {\n             let mut payload = none;\n             payload <-> (*p).payload;\n-            p.state = terminated;\n+            p.header.state = terminated;\n             ret some(option::unwrap(payload))\n           }\n           terminated {\n@@ -138,7 +145,7 @@ fn recv<T: send>(-p: recv_packet<T>) -> option<T> {\n \n fn sender_terminate<T: send>(p: *packet<T>) {\n     let p = unsafe { uniquify(p) };\n-    alt swap_state_rel((*p).state, terminated) {\n+    alt swap_state_rel(p.header.state, terminated) {\n       empty | blocked {\n         // The receiver will eventually clean up.\n         unsafe { forget(p) }\n@@ -155,7 +162,7 @@ fn sender_terminate<T: send>(p: *packet<T>) {\n \n fn receiver_terminate<T: send>(p: *packet<T>) {\n     let p = unsafe { uniquify(p) };\n-    alt swap_state_rel((*p).state, terminated) {\n+    alt swap_state_rel(p.header.state, terminated) {\n       empty {\n         // the sender will clean up\n         unsafe { forget(p) }\n@@ -170,15 +177,106 @@ fn receiver_terminate<T: send>(p: *packet<T>) {\n     }\n }\n \n+impl private_methods for packet_header {\n+    // Returns the old state.\n+    fn mark_blocked(this: *rust_task) -> state {\n+        self.blocked_task = some(this);\n+        swap_state_acq(self.state, blocked)\n+    }\n+\n+    fn unblock() {\n+        alt swap_state_acq(self.state, empty) {\n+          empty | blocked { }\n+          terminated { self.state = terminated; }\n+          full { self.state = full; }\n+        }\n+    }\n+}\n+\n+#[doc = \"Returns when one of the packet headers reports data is\n+available.\"]\n+fn wait_many(pkts: ~[&a.packet_header]) -> uint {\n+    let this = rustrt::rust_get_task();\n+\n+    rustrt::task_clear_event_reject(this);\n+    let mut data_avail = false;\n+    let mut ready_packet = pkts.len();\n+    for pkts.eachi |i, p| {\n+        let old = p.mark_blocked(this);\n+        alt old {\n+          full | terminated {\n+            data_avail = true;\n+            ready_packet = i;\n+            p.state = old;\n+            break;\n+          }\n+          blocked { fail \"blocking on blocked packet\" }\n+          empty { }\n+        }\n+    }\n+\n+    while !data_avail {\n+        #debug(\"sleeping on %? packets\", pkts.len());\n+        let event = rustrt::task_wait_event(this) as *packet_header;\n+        let pos = vec::position(pkts, |p| ptr::addr_of(*p) == event);\n+\n+        alt pos {\n+          some(i) {\n+            ready_packet = i;\n+            data_avail = true;\n+          }\n+          none {\n+            #debug(\"ignoring spurious event, %?\", event);\n+          }\n+        }\n+    }\n+\n+    #debug(\"%?\", pkts[ready_packet]);\n+\n+    for pkts.each |p| { p.unblock() }\n+\n+    #debug(\"%?, %?\", ready_packet, pkts[ready_packet]);\n+\n+    assert pkts[ready_packet].state == full\n+        || pkts[ready_packet].state == terminated;\n+\n+    ready_packet\n+}\n+\n+#[doc = \"Waits on a set of endpoints. Returns a message, its index,\n+ and a list of the remaining endpoints.\"]\n+fn select<T: send>(+endpoints: ~[recv_packet<T>])\n+    -> (uint, option<T>, ~[recv_packet<T>])\n+{\n+    let endpoints = vec::map_consume(\n+        endpoints,\n+        |p| unsafe { uniquify(p.unwrap()) });\n+    let endpoints_r = vec::view(endpoints, 0, endpoints.len());\n+    let ready = wait_many(endpoints_r.map_r(|p| &p.header));\n+    let mut remaining = ~[];\n+    let mut result = none;\n+    do vec::consume(endpoints) |i, p| {\n+        let p = recv_packet(unsafe { unsafe::transmute(p) });\n+        if i == ready {\n+            result = recv(p);\n+        }\n+        else {\n+            vec::push(remaining, p);\n+        }\n+    }\n+\n+    (ready, result, remaining)\n+}\n+\n class send_packet<T: send> {\n     let mut p: option<*packet<T>>;\n     new(p: *packet<T>) {\n-        //#error(\"take send %?\", p);\n+        //#debug(\"take send %?\", p);\n         self.p = some(p);\n     }\n     drop {\n         //if self.p != none {\n-        //    #error(\"drop send %?\", option::get(self.p));\n+        //    #debug(\"drop send %?\", option::get(self.p));\n         //}\n         if self.p != none {\n             let mut p = none;\n@@ -196,12 +294,12 @@ class send_packet<T: send> {\n class recv_packet<T: send> {\n     let mut p: option<*packet<T>>;\n     new(p: *packet<T>) {\n-        //#error(\"take recv %?\", p);\n+        //#debug(\"take recv %?\", p);\n         self.p = some(p);\n     }\n     drop {\n         //if self.p != none {\n-        //    #error(\"drop recv %?\", option::get(self.p));\n+        //    #debug(\"drop recv %?\", option::get(self.p));\n         //}\n         if self.p != none {\n             let mut p = none;\n@@ -222,7 +320,7 @@ fn entangle<T: send>() -> (send_packet<T>, recv_packet<T>) {\n }\n \n fn spawn_service<T: send>(\n-    init: native fn() -> (send_packet<T>, recv_packet<T>),\n+    init: extern fn() -> (send_packet<T>, recv_packet<T>),\n     +service: fn~(+recv_packet<T>))\n     -> send_packet<T>\n {\n@@ -241,7 +339,7 @@ fn spawn_service<T: send>(\n }\n \n fn spawn_service_recv<T: send>(\n-    init: native fn() -> (recv_packet<T>, send_packet<T>),\n+    init: extern fn() -> (recv_packet<T>, send_packet<T>),\n     +service: fn~(+send_packet<T>))\n     -> recv_packet<T>\n {"}, {"sha": "eb3d52edc24e700abae60c0f5d90efac99d2d050", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 38, "deletions": 5, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a787f4001388a394d5219b74113a718d980e4c90/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a787f4001388a394d5219b74113a718d980e4c90/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=a787f4001388a394d5219b74113a718d980e4c90", "patch": "@@ -6,6 +6,7 @@ import libc::size_t;\n \n export append;\n export append_one;\n+export consume;\n export init_op;\n export is_empty;\n export is_not_empty;\n@@ -40,6 +41,7 @@ export grow_set;\n export map;\n export mapi;\n export map2;\n+export map_consume;\n export flat_map;\n export filter_map;\n export filter;\n@@ -261,8 +263,8 @@ pure fn slice<T: copy>(v: &[const T], start: uint, end: uint) -> ~[T] {\n     ret result;\n }\n \n-/// Return a slice that points into another slice.\n-pure fn view<T: copy>(v: &[const T], start: uint, end: uint) -> &a.[T] {\n+#[doc = \"Return a slice that points into another slice.\"]\n+pure fn view<T>(v: &[const T], start: uint, end: uint) -> &a.[T] {\n     assert (start <= end);\n     assert (end <= len(v));\n     do unpack_slice(v) |p, _len| {\n@@ -373,7 +375,7 @@ fn rsplitn<T: copy>(v: &[T], n: uint, f: fn(T) -> bool) -> ~[~[T]] {\n /// Removes the first element from a vector and return it\n fn shift<T>(&v: ~[T]) -> T {\n     let ln = len::<T>(v);\n-    assert (ln > 0u);\n+    assert (ln > 0);\n \n     let mut vv = ~[];\n     v <-> vv;\n@@ -384,12 +386,12 @@ fn shift<T>(&v: ~[T]) -> T {\n             let vv = unsafe::to_ptr(vv);\n             rr <- *vv;\n \n-            for uint::range(1u, ln) |i| {\n+            for uint::range(1, ln) |i| {\n                 let r <- *ptr::offset(vv, i);\n                 push(v, r);\n             }\n         }\n-        unsafe::set_len(vv, 0u);\n+        unsafe::set_len(vv, 0);\n \n         rr\n     }\n@@ -404,6 +406,17 @@ fn unshift<T>(&v: ~[T], +x: T) {\n     }\n }\n \n+fn consume<T>(+v: ~[T], f: fn(uint, +T)) unsafe {\n+    do unpack_slice(v) |p, ln| {\n+        for uint::range(0, ln) |i| {\n+            let x <- *ptr::offset(p, i);\n+            f(i, x);\n+        }\n+    }\n+\n+    unsafe::set_len(v, 0);\n+}\n+\n /// Remove the last element from a vector and return it\n fn pop<T>(&v: ~[const T]) -> T {\n     let ln = len(v);\n@@ -575,6 +588,14 @@ pure fn map<T, U>(v: &[T], f: fn(T) -> U) -> ~[U] {\n     ret result;\n }\n \n+fn map_consume<T, U>(+v: ~[T], f: fn(+T) -> U) -> ~[U] {\n+    let mut result = ~[];\n+    do consume(v) |_i, x| {\n+        vec::push(result, f(x));\n+    }\n+    result\n+}\n+\n /// Apply a function to each element of a vector and return the results\n pure fn mapi<T, U>(v: &[T], f: fn(uint, T) -> U) -> ~[U] {\n     let mut result = ~[];\n@@ -1277,6 +1298,18 @@ impl extensions/&<T> for &[T] {\n     pure fn mapi<U>(f: fn(uint, T) -> U) -> ~[U] {\n         mapi(self, f)\n     }\n+\n+    #[inline]\n+    fn map_r<U>(f: fn(x: &self.T) -> U) -> ~[U] {\n+        let mut r = ~[];\n+        let mut i = 0;\n+        while i < self.len() {\n+            push(r, f(&self[i]));\n+            i += 1;\n+        }\n+        r\n+    }\n+\n     /**\n      * Returns true if the function returns true for all elements.\n      *"}, {"sha": "9ad3025d33aed7b7fc5d0831bae890db31bf01e0", "filename": "src/test/bench/msgsend-ring-contracts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a787f4001388a394d5219b74113a718d980e4c90/src%2Ftest%2Fbench%2Fmsgsend-ring-contracts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a787f4001388a394d5219b74113a718d980e4c90/src%2Ftest%2Fbench%2Fmsgsend-ring-contracts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-contracts.rs?ref=a787f4001388a394d5219b74113a718d980e4c90", "patch": "@@ -119,7 +119,7 @@ fn main(args: [str]/~) {\n     thread_ring(0u, msg_per_task, option::unwrap(num_chan), num_port);\n \n     // synchronize\n-    for futures.each |f| { f.get() };\n+    for futures.each |f| { future::get(f) };\n \n     let stop = time::precise_time_s();\n "}, {"sha": "0803bbfe531705b39a6e752ca99771224ffea5f6", "filename": "src/test/run-pass/pipe-manual-2.rs", "status": "modified", "additions": 0, "deletions": 178, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/a787f4001388a394d5219b74113a718d980e4c90/src%2Ftest%2Frun-pass%2Fpipe-manual-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a787f4001388a394d5219b74113a718d980e4c90/src%2Ftest%2Frun-pass%2Fpipe-manual-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-manual-2.rs?ref=a787f4001388a394d5219b74113a718d980e4c90", "patch": "@@ -13,184 +13,6 @@ At some point, we'll need to add support for select.\n \n */\n \n-// Hopefully someday we'll move this into core.\n-mod pipes {\n-    import unsafe::{forget, reinterpret_cast};\n-\n-    enum state {\n-        empty,\n-        full,\n-        blocked,\n-        terminated\n-    }\n-\n-    type packet<T: send> = {\n-        mut state: state,\n-        mut blocked_task: option<task::task>,\n-        mut payload: option<T>\n-    };\n-\n-    fn packet<T: send>() -> *packet<T> unsafe {\n-        let p: *packet<T> = unsafe::transmute(~{\n-            mut state: empty,\n-            mut blocked_task: none::<task::task>,\n-            mut payload: none::<T>\n-        });\n-        p\n-    }\n-\n-    #[abi = \"rust-intrinsic\"]\n-    native mod rusti {\n-        fn atomic_xchng(&dst: int, src: int) -> int;\n-        fn atomic_xchng_acq(&dst: int, src: int) -> int;\n-        fn atomic_xchng_rel(&dst: int, src: int) -> int;\n-    }\n-\n-    // We should consider moving this to core::unsafe, although I\n-    // suspect graydon would want us to use void pointers instead.\n-    unsafe fn uniquify<T>(x: *T) -> ~T {\n-        unsafe { unsafe::reinterpret_cast(x) }\n-    }\n-\n-    fn swap_state_acq(&dst: state, src: state) -> state {\n-        unsafe {\n-            reinterpret_cast(rusti::atomic_xchng_acq(\n-                *(ptr::mut_addr_of(dst) as *mut int),\n-                src as int))\n-        }\n-    }\n-\n-    fn swap_state_rel(&dst: state, src: state) -> state {\n-        unsafe {\n-            reinterpret_cast(rusti::atomic_xchng_rel(\n-                *(ptr::mut_addr_of(dst) as *mut int),\n-                src as int))\n-        }\n-    }\n-\n-    fn send<T: send>(-p: send_packet<T>, -payload: T) {\n-        let p = p.unwrap();\n-        let p = unsafe { uniquify(p) };\n-        assert (*p).payload == none;\n-        (*p).payload <- some(payload);\n-        let old_state = swap_state_rel((*p).state, full);\n-        alt old_state {\n-          empty {\n-            // Yay, fastpath.\n-\n-            // The receiver will eventually clean this up.\n-            unsafe { forget(p); }\n-          }\n-          full { fail \"duplicate send\" }\n-          blocked {\n-            // FIXME: once the target will actually block, tell the\n-            // scheduler to wake it up.\n-\n-            // The receiver will eventually clean this up.\n-            unsafe { forget(p); }\n-          }\n-          terminated {\n-            // The receiver will never receive this. Rely on drop_glue\n-            // to clean everything up.\n-          }\n-        }\n-    }\n-\n-    fn recv<T: send>(-p: recv_packet<T>) -> option<T> {\n-        let p = p.unwrap();\n-        let p = unsafe { uniquify(p) };\n-        loop {\n-            let old_state = swap_state_acq((*p).state,\n-                                           blocked);\n-            alt old_state {\n-              empty | blocked { task::yield(); }\n-              full {\n-                let mut payload = none;\n-                payload <-> (*p).payload;\n-                ret some(option::unwrap(payload))\n-              }\n-              terminated {\n-                assert old_state == terminated;\n-                ret none;\n-              }\n-            }\n-        }\n-    }\n-\n-    fn sender_terminate<T: send>(p: *packet<T>) {\n-        let p = unsafe { uniquify(p) };\n-        alt swap_state_rel((*p).state, terminated) {\n-          empty | blocked {\n-            // The receiver will eventually clean up.\n-            unsafe { forget(p) }\n-          }\n-          full {\n-            // This is impossible\n-            fail \"you dun goofed\"\n-          }\n-          terminated {\n-            // I have to clean up, use drop_glue\n-          }\n-        }\n-    }\n-\n-    fn receiver_terminate<T: send>(p: *packet<T>) {\n-        let p = unsafe { uniquify(p) };\n-        alt swap_state_rel((*p).state, terminated) {\n-          empty {\n-            // the sender will clean up\n-            unsafe { forget(p) }\n-          }\n-          blocked {\n-            // this shouldn't happen.\n-            fail \"terminating a blocked packet\"\n-          }\n-          terminated | full {\n-            // I have to clean up, use drop_glue\n-          }\n-        }\n-    }\n-\n-    class send_packet<T: send> {\n-        let mut p: option<*packet<T>>;\n-        new(p: *packet<T>) { self.p = some(p); }\n-        drop {\n-            if self.p != none {\n-                let mut p = none;\n-                p <-> self.p;\n-                sender_terminate(option::unwrap(p))\n-            }\n-        }\n-        fn unwrap() -> *packet<T> {\n-            let mut p = none;\n-            p <-> self.p;\n-            option::unwrap(p)\n-        }\n-    }\n-\n-    class recv_packet<T: send> {\n-        let mut p: option<*packet<T>>;\n-        new(p: *packet<T>) { self.p = some(p); }\n-        drop {\n-            if self.p != none {\n-                let mut p = none;\n-                p <-> self.p;\n-                receiver_terminate(option::unwrap(p))\n-            }\n-        }\n-        fn unwrap() -> *packet<T> {\n-            let mut p = none;\n-            p <-> self.p;\n-            option::unwrap(p)\n-        }\n-    }\n-\n-    fn entangle<T: send>() -> (send_packet<T>, recv_packet<T>) {\n-        let p = packet();\n-        (send_packet(p), recv_packet(p))\n-    }\n-}\n-\n mod pingpong {\n     enum ping = *pipes::packet<pong>;\n     enum pong = *pipes::packet<ping>;"}, {"sha": "9f05038aadc6cfb9c11c7e1012ef19c5e4293cbd", "filename": "src/test/run-pass/pipe-manual-3.rs", "status": "modified", "additions": 0, "deletions": 178, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/a787f4001388a394d5219b74113a718d980e4c90/src%2Ftest%2Frun-pass%2Fpipe-manual-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a787f4001388a394d5219b74113a718d980e4c90/src%2Ftest%2Frun-pass%2Fpipe-manual-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-manual-3.rs?ref=a787f4001388a394d5219b74113a718d980e4c90", "patch": "@@ -15,184 +15,6 @@ This file does horrible things to pretend we have self-move.\n \n */\n \n-// Hopefully someday we'll move this into core.\n-mod pipes {\n-    import unsafe::{forget, reinterpret_cast};\n-\n-    enum state {\n-        empty,\n-        full,\n-        blocked,\n-        terminated\n-    }\n-\n-    type packet<T: send> = {\n-        mut state: state,\n-        mut blocked_task: option<task::task>,\n-        mut payload: option<T>\n-    };\n-\n-    fn packet<T: send>() -> *packet<T> unsafe {\n-        let p: *packet<T> = unsafe::transmute(~{\n-            mut state: empty,\n-            mut blocked_task: none::<task::task>,\n-            mut payload: none::<T>\n-        });\n-        p\n-    }\n-\n-    #[abi = \"rust-intrinsic\"]\n-    native mod rusti {\n-        fn atomic_xchng(&dst: int, src: int) -> int;\n-        fn atomic_xchng_acq(&dst: int, src: int) -> int;\n-        fn atomic_xchng_rel(&dst: int, src: int) -> int;\n-    }\n-\n-    // We should consider moving this to core::unsafe, although I\n-    // suspect graydon would want us to use void pointers instead.\n-    unsafe fn uniquify<T>(x: *T) -> ~T {\n-        unsafe { unsafe::reinterpret_cast(x) }\n-    }\n-\n-    fn swap_state_acq(&dst: state, src: state) -> state {\n-        unsafe {\n-            reinterpret_cast(rusti::atomic_xchng_acq(\n-                *(ptr::mut_addr_of(dst) as *mut int),\n-                src as int))\n-        }\n-    }\n-\n-    fn swap_state_rel(&dst: state, src: state) -> state {\n-        unsafe {\n-            reinterpret_cast(rusti::atomic_xchng_rel(\n-                *(ptr::mut_addr_of(dst) as *mut int),\n-                src as int))\n-        }\n-    }\n-\n-    fn send<T: send>(-p: send_packet<T>, -payload: T) {\n-        let p = p.unwrap();\n-        let p = unsafe { uniquify(p) };\n-        assert (*p).payload == none;\n-        (*p).payload <- some(payload);\n-        let old_state = swap_state_rel((*p).state, full);\n-        alt old_state {\n-          empty {\n-            // Yay, fastpath.\n-\n-            // The receiver will eventually clean this up.\n-            unsafe { forget(p); }\n-          }\n-          full { fail \"duplicate send\" }\n-          blocked {\n-            // FIXME: once the target will actually block, tell the\n-            // scheduler to wake it up.\n-\n-            // The receiver will eventually clean this up.\n-            unsafe { forget(p); }\n-          }\n-          terminated {\n-            // The receiver will never receive this. Rely on drop_glue\n-            // to clean everything up.\n-          }\n-        }\n-    }\n-\n-    fn recv<T: send>(-p: recv_packet<T>) -> option<T> {\n-        let p = p.unwrap();\n-        let p = unsafe { uniquify(p) };\n-        loop {\n-            let old_state = swap_state_acq((*p).state,\n-                                           blocked);\n-            alt old_state {\n-              empty | blocked { task::yield(); }\n-              full {\n-                let mut payload = none;\n-                payload <-> (*p).payload;\n-                ret some(option::unwrap(payload))\n-              }\n-              terminated {\n-                assert old_state == terminated;\n-                ret none;\n-              }\n-            }\n-        }\n-    }\n-\n-    fn sender_terminate<T: send>(p: *packet<T>) {\n-        let p = unsafe { uniquify(p) };\n-        alt swap_state_rel((*p).state, terminated) {\n-          empty | blocked {\n-            // The receiver will eventually clean up.\n-            unsafe { forget(p) }\n-          }\n-          full {\n-            // This is impossible\n-            fail \"you dun goofed\"\n-          }\n-          terminated {\n-            // I have to clean up, use drop_glue\n-          }\n-        }\n-    }\n-\n-    fn receiver_terminate<T: send>(p: *packet<T>) {\n-        let p = unsafe { uniquify(p) };\n-        alt swap_state_rel((*p).state, terminated) {\n-          empty {\n-            // the sender will clean up\n-            unsafe { forget(p) }\n-          }\n-          blocked {\n-            // this shouldn't happen.\n-            fail \"terminating a blocked packet\"\n-          }\n-          terminated | full {\n-            // I have to clean up, use drop_glue\n-          }\n-        }\n-    }\n-\n-    class send_packet<T: send> {\n-        let mut p: option<*packet<T>>;\n-        new(p: *packet<T>) { self.p = some(p); }\n-        drop {\n-            if self.p != none {\n-                let mut p = none;\n-                p <-> self.p;\n-                sender_terminate(option::unwrap(p))\n-            }\n-        }\n-        fn unwrap() -> *packet<T> {\n-            let mut p = none;\n-            p <-> self.p;\n-            option::unwrap(p)\n-        }\n-    }\n-\n-    class recv_packet<T: send> {\n-        let mut p: option<*packet<T>>;\n-        new(p: *packet<T>) { self.p = some(p); }\n-        drop {\n-            if self.p != none {\n-                let mut p = none;\n-                p <-> self.p;\n-                receiver_terminate(option::unwrap(p))\n-            }\n-        }\n-        fn unwrap() -> *packet<T> {\n-            let mut p = none;\n-            p <-> self.p;\n-            option::unwrap(p)\n-        }\n-    }\n-\n-    fn entangle<T: send>() -> (send_packet<T>, recv_packet<T>) {\n-        let p = packet();\n-        (send_packet(p), recv_packet(p))\n-    }\n-}\n-\n mod pingpong {\n     enum ping { ping, }\n     enum ping_message = *pipes::packet<pong_message>;"}, {"sha": "163cfa954884accf817b6cce31dbdd877bc48776", "filename": "src/test/run-pass/pipe-select.rs", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/a787f4001388a394d5219b74113a718d980e4c90/src%2Ftest%2Frun-pass%2Fpipe-select.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a787f4001388a394d5219b74113a718d980e4c90/src%2Ftest%2Frun-pass%2Fpipe-select.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-select.rs?ref=a787f4001388a394d5219b74113a718d980e4c90", "patch": "@@ -0,0 +1,125 @@\n+use std;\n+import std::timer::sleep;\n+import std::uv;\n+\n+import pipes::{recv, select};\n+\n+// Compiled by pipec\n+mod oneshot {\n+    fn init() -> (client::waiting, server::waiting) { pipes::entangle() }\n+    enum waiting { signal(server::signaled), }\n+    enum signaled { }\n+    mod client {\n+        fn signal(-pipe: waiting) -> signaled {\n+            let (c, s) = pipes::entangle();\n+            let message = oneshot::signal(s);\n+            pipes::send(pipe, message);\n+            c\n+        }\n+        type waiting = pipes::send_packet<oneshot::waiting>;\n+        type signaled = pipes::send_packet<oneshot::signaled>;\n+    }\n+    mod server {\n+        impl recv for waiting {\n+            fn recv() -> extern fn(-waiting) -> oneshot::waiting {\n+                fn recv(-pipe: waiting) -> oneshot::waiting {\n+                    option::unwrap(pipes::recv(pipe))\n+                }\n+                recv\n+            }\n+        }\n+        type waiting = pipes::recv_packet<oneshot::waiting>;\n+        impl recv for signaled {\n+            fn recv() -> extern fn(-signaled) -> oneshot::signaled {\n+                fn recv(-pipe: signaled) -> oneshot::signaled {\n+                    option::unwrap(pipes::recv(pipe))\n+                }\n+                recv\n+            }\n+        }\n+        type signaled = pipes::recv_packet<oneshot::signaled>;\n+    }\n+}\n+\n+mod stream {\n+    fn init<T: send>() -> (client::stream<T>, server::stream<T>) {\n+        pipes::entangle()\n+    }\n+    enum stream<T: send> { send(T, server::stream<T>), }\n+    mod client {\n+        fn send<T: send>(+pipe: stream<T>, +x_0: T) -> stream<T> {\n+            {\n+                let (c, s) = pipes::entangle();\n+                let message = stream::send(x_0, s);\n+                pipes::send(pipe, message);\n+                c\n+            }\n+        }\n+        type stream<T: send> = pipes::send_packet<stream::stream<T>>;\n+    }\n+    mod server {\n+        impl recv<T: send> for stream<T> {\n+            fn recv() -> extern fn(+stream<T>) -> stream::stream<T> {\n+                fn recv<T: send>(+pipe: stream<T>) -> stream::stream<T> {\n+                    option::unwrap(pipes::recv(pipe))\n+                }\n+                recv\n+            }\n+        }\n+        type stream<T: send> = pipes::recv_packet<stream::stream<T>>;\n+    }\n+}\n+\n+fn main() {\n+    import oneshot::client::*;\n+    import stream::client::*;\n+\n+    let iotask = uv::global_loop::get();\n+    \n+    #macro[\n+        [#recv[chan],\n+         chan.recv()(chan)]\n+    ];\n+\n+    let c = pipes::spawn_service(stream::init, |p| { \n+        #error(\"waiting for pipes\");\n+        let stream::send(x, p) = option::unwrap(recv(p));\n+        #error(\"got pipes\");\n+        let (left, right) : (oneshot::server::waiting,\n+                             oneshot::server::waiting)\n+            = x;\n+        #error(\"selecting\");\n+        let (i, _, _) = select(~[left, right]);\n+        #error(\"selected\");\n+        assert i == 0;\n+\n+        #error(\"waiting for pipes\");\n+        let stream::send(x, _) = option::unwrap(recv(p));\n+        #error(\"got pipes\");\n+        let (left, right) : (oneshot::server::waiting,\n+                             oneshot::server::waiting)\n+            = x;\n+        #error(\"selecting\");\n+        let (i, _, _) = select(~[left, right]);\n+        #error(\"selected\");\n+        assert i == 1;\n+    });\n+\n+    let (c1, p1) = oneshot::init();\n+    let (c2, p2) = oneshot::init();\n+\n+    let c = send(c, (p1, p2));\n+    \n+    sleep(iotask, 1000);\n+\n+    signal(c1);\n+\n+    let (c1, p1) = oneshot::init();\n+    let (c2, p2) = oneshot::init();\n+\n+    send(c, (p1, p2));\n+\n+    sleep(iotask, 1000);\n+\n+    signal(c2);\n+}\n\\ No newline at end of file"}]}