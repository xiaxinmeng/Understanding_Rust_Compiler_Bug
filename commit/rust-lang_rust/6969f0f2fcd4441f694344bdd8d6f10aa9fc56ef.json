{"sha": "6969f0f2fcd4441f694344bdd8d6f10aa9fc56ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5NjlmMGYyZmNkNDQ0MWY2OTQzNDRiZGQ4ZDZmMTBhYTlmYzU2ZWY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-06-15T01:47:44Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-06-15T01:51:31Z"}, "message": "Issue #2572: (trans) Fix self-referential classes.", "tree": {"sha": "164f765f980153bd0ad4a70688efb0f8ad347d55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/164f765f980153bd0ad4a70688efb0f8ad347d55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6969f0f2fcd4441f694344bdd8d6f10aa9fc56ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6969f0f2fcd4441f694344bdd8d6f10aa9fc56ef", "html_url": "https://github.com/rust-lang/rust/commit/6969f0f2fcd4441f694344bdd8d6f10aa9fc56ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6969f0f2fcd4441f694344bdd8d6f10aa9fc56ef/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b16325f43d1e7bbdc7ad55301c17c027f9a716d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b16325f43d1e7bbdc7ad55301c17c027f9a716d", "html_url": "https://github.com/rust-lang/rust/commit/6b16325f43d1e7bbdc7ad55301c17c027f9a716d"}], "stats": {"total": 77, "additions": 58, "deletions": 19}, "files": [{"sha": "0d6ef8c6d12c1dc9dbf81c5fbe24b279fe28fe39", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 38, "deletions": 16, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/6969f0f2fcd4441f694344bdd8d6f10aa9fc56ef/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6969f0f2fcd4441f694344bdd8d6f10aa9fc56ef/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=6969f0f2fcd4441f694344bdd8d6f10aa9fc56ef", "patch": "@@ -76,10 +76,13 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n     // this then, e.g. `option<{myfield: bool}>` would be a different\n     // type than `option<myrec>`.\n     let t_norm = ty::normalize_ty(cx.tcx, t);\n-    let llty = if t != t_norm {\n-        type_of(cx, t_norm)\n+\n+    let mut llty;\n+    if t != t_norm {\n+        llty = type_of(cx, t_norm);\n+        cx.lltypes.insert(t, llty);\n     } else {\n-        alt ty::get(t).struct {\n+        llty = alt ty::get(t).struct {\n           ty::ty_nil | ty::ty_bot { T_nil() }\n           ty::ty_bool { T_bool() }\n           ty::ty_int(t) { T_int_ty(cx, t) }\n@@ -149,30 +152,46 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n           }\n           ty::ty_opaque_closure_ptr(_) { T_opaque_box_ptr(cx) }\n           ty::ty_constr(subt,_) { type_of(cx, subt) }\n+          ty::ty_class(*) {\n+            // Only create the named struct, but don't fill it in. We fill it\n+            // in *after* placing it into the type cache. This prevents\n+            // infinite recursion with recursive class types.\n+\n+            common::T_named_struct(llvm_type_name(cx, t))\n+          }\n+          ty::ty_self { cx.tcx.sess.unimpl(\"type_of: ty_self\"); }\n+          ty::ty_var(_) { cx.tcx.sess.bug(\"type_of shouldn't see a ty_var\"); }\n+          ty::ty_param(*) { cx.tcx.sess.bug(\"type_of with ty_param\"); }\n+          ty::ty_var_integral(_) {\n+            cx.tcx.sess.bug(\"type_of shouldn't see a ty_var_integral\");\n+          }\n+        };\n+\n+        cx.lltypes.insert(t, llty);\n+\n+        // If this was a class, fill in the type now.\n+        alt ty::get(t).struct {\n           ty::ty_class(did, ts) {\n-            // only instance vars are record fields at runtime\n+            // Only instance vars are record fields at runtime.\n             let fields = lookup_class_fields(cx.tcx, did);\n-            let tys = vec::map(fields) {|f|\n+            let mut tys = vec::map(fields) {|f|\n                 let t = ty::lookup_field_type(cx.tcx, did, f.id, ts);\n                 type_of(cx, t)\n             };\n-            if ty::ty_dtor(cx.tcx, did) == none {\n-              T_struct(tys)\n-            }\n-            else {\n+\n+            if ty::ty_dtor(cx.tcx, did) != none {\n               // resource type\n-              T_struct([T_i8(), T_struct(tys)])\n+              tys = [T_i8(), T_struct(tys)];\n             }\n+\n+            common::set_struct_body(llty, tys);\n           }\n-          ty::ty_self { cx.tcx.sess.unimpl(\"type_of: ty_self\"); }\n-          ty::ty_var(_) { cx.tcx.sess.bug(\"type_of shouldn't see a ty_var\"); }\n-          ty::ty_param(*) { cx.tcx.sess.bug(\"type_of with ty_param\"); }\n-          ty::ty_var_integral(_) {\n-            cx.tcx.sess.bug(\"type_of shouldn't see a ty_var_integral\");\n+          _ {\n+            // Nothing more to do.\n           }\n         }\n     };\n-    cx.lltypes.insert(t, llty);\n+\n     ret llty;\n }\n \n@@ -214,6 +233,9 @@ fn llvm_type_name(cx: @crate_ctxt, t: ty::t) -> str {\n       ty::ty_enum(did, substs) {\n         (\"enum\", did, substs.tps)\n       }\n+      ty::ty_class(did, substs) {\n+        (\"class\", did, substs.tps)\n+      }\n     };\n     ret #fmt(\n         \"%s %s[#%d]\","}, {"sha": "421bbf38e14d6170ca32765f6a1e9dc92574a205", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6969f0f2fcd4441f694344bdd8d6f10aa9fc56ef/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6969f0f2fcd4441f694344bdd8d6f10aa9fc56ef/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=6969f0f2fcd4441f694344bdd8d6f10aa9fc56ef", "patch": "@@ -3036,9 +3036,16 @@ fn normalize_ty(cx: ctxt, t: t) -> t {\n             alt r.self_r {\n               some(_) {\n                 // This enum has a self region. Get rid of it\n-                mk_enum(cx, did, {self_r: none,\n-                                  self_ty: none,\n-                                  tps: r.tps})\n+                mk_enum(cx, did, {self_r: none, self_ty: none, tps: r.tps})\n+              }\n+              none { t }\n+            }\n+        }\n+        ty_class(did, r) {\n+            alt r.self_r {\n+              some(_) {\n+                // Ditto.\n+                mk_class(cx, did, {self_r: none, self_ty: none, tps: r.tps})\n               }\n               none { t }\n             }"}, {"sha": "7add8fec1b1ee82d73a2f3b765c3c30aa55558e7", "filename": "src/test/run-pass/classes-self-referential.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6969f0f2fcd4441f694344bdd8d6f10aa9fc56ef/src%2Ftest%2Frun-pass%2Fclasses-self-referential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6969f0f2fcd4441f694344bdd8d6f10aa9fc56ef/src%2Ftest%2Frun-pass%2Fclasses-self-referential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses-self-referential.rs?ref=6969f0f2fcd4441f694344bdd8d6f10aa9fc56ef", "patch": "@@ -0,0 +1,10 @@\n+class kitten {\n+    let cat: option<cat>;\n+    new(cat: option<cat>) {\n+       self.cat = cat;\n+    }\n+}\n+\n+type cat = @kitten;\n+\n+fn main() {}"}]}