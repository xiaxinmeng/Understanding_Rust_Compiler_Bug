{"sha": "b2b383cab5959b1ec331e1d77583fa944b7fd593", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyYjM4M2NhYjU5NTliMWVjMzMxZTFkNzc1ODNmYTk0NGI3ZmQ1OTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-14T01:31:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-14T01:31:51Z"}, "message": "auto merge of #14187 : alexcrichton/rust/rollup, r=alexcrichton\n\nCloses #14184 (std: Move the owned module from core to std)\r\nCloses #14183 (Allow blocks in const expressions)\r\nCloses #14176 (Add tests for from_bits.)\r\nCloses #14175 (Replaced ~T by Box<T> in manual)\r\nCloses #14173 (Implements Default trait for BigInt and BigUint)\r\nCloses #14171 (Fix #8391)\r\nCloses #14159 (Clean up unicode code in libstd)\r\nCloses #14126 (docs: Add a not found page)\r\nCloses #14123 (add a line to the example to clarify semantics)\r\nCloses #14106 (Pretty printer improvements)\r\nCloses #14083 (rustllvm: Add LLVMRustArrayType)\r\nCloses #13957 (io: Implement process wait timeouts)", "tree": {"sha": "79540b4f5f7e125a260b9ca00f25e796241425f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79540b4f5f7e125a260b9ca00f25e796241425f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2b383cab5959b1ec331e1d77583fa944b7fd593", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2b383cab5959b1ec331e1d77583fa944b7fd593", "html_url": "https://github.com/rust-lang/rust/commit/b2b383cab5959b1ec331e1d77583fa944b7fd593", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2b383cab5959b1ec331e1d77583fa944b7fd593/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb115ac2d4f57d8b590c8d46d8f9e2958ed9a527", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb115ac2d4f57d8b590c8d46d8f9e2958ed9a527", "html_url": "https://github.com/rust-lang/rust/commit/cb115ac2d4f57d8b590c8d46d8f9e2958ed9a527"}, {"sha": "f09592a5d154177f0c9d739c9fe60742ec4cd951", "url": "https://api.github.com/repos/rust-lang/rust/commits/f09592a5d154177f0c9d739c9fe60742ec4cd951", "html_url": "https://github.com/rust-lang/rust/commit/f09592a5d154177f0c9d739c9fe60742ec4cd951"}], "stats": {"total": 3121, "additions": 2191, "deletions": 930}, "files": [{"sha": "40c2440c0c07a524d519e9f8d22c3496367ec184", "filename": "mk/docs.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -30,7 +30,7 @@ DOCS := index intro tutorial guide-ffi guide-macros guide-lifetimes \\\n \tguide-tasks guide-container guide-pointers guide-testing \\\n \tguide-runtime complement-bugreport complement-cheatsheet \\\n \tcomplement-lang-faq complement-project-faq rust rustdoc \\\n-\tguide-unsafe\n+\tguide-unsafe not_found\n \n PDF_DOCS := tutorial rust\n "}, {"sha": "ca59f344e288f6e984e3a28394cf80cbf69d48b1", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 43, "deletions": 10, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -8,19 +8,52 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::from_str::FromStr;\n+use std::fmt;\n+\n #[deriving(Clone, Eq)]\n-pub enum mode {\n-    mode_compile_fail,\n-    mode_run_fail,\n-    mode_run_pass,\n-    mode_pretty,\n-    mode_debug_info_gdb,\n-    mode_debug_info_lldb,\n-    mode_codegen\n+pub enum Mode {\n+    CompileFail,\n+    RunFail,\n+    RunPass,\n+    Pretty,\n+    DebugInfoGdb,\n+    DebugInfoLldb,\n+    Codegen\n+}\n+\n+impl FromStr for Mode {\n+    fn from_str(s: &str) -> Option<Mode> {\n+        match s {\n+          \"compile-fail\" => Some(CompileFail),\n+          \"run-fail\" => Some(RunFail),\n+          \"run-pass\" => Some(RunPass),\n+          \"pretty\" => Some(Pretty),\n+          \"debuginfo-lldb\" => Some(DebugInfoLldb),\n+          \"debuginfo-gdb\" => Some(DebugInfoGdb),\n+          \"codegen\" => Some(Codegen),\n+          _ => None,\n+        }\n+    }\n+}\n+\n+impl fmt::Show for Mode {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let msg = match *self {\n+          CompileFail => \"compile-fail\",\n+          RunFail => \"run-fail\",\n+          RunPass => \"run-pass\",\n+          Pretty => \"pretty\",\n+          DebugInfoGdb => \"debuginfo-gdb\",\n+          DebugInfoLldb => \"debuginfo-lldb\",\n+          Codegen => \"codegen\",\n+        };\n+        write!(f.buf, \"{}\", msg)\n+    }\n }\n \n #[deriving(Clone)]\n-pub struct config {\n+pub struct Config {\n     // The library paths required for running the compiler\n     pub compile_lib_path: ~str,\n \n@@ -49,7 +82,7 @@ pub struct config {\n     pub stage_id: ~str,\n \n     // The test mode, compile-fail, run-fail, run-pass\n-    pub mode: mode,\n+    pub mode: Mode,\n \n     // Run ignored tests\n     pub run_ignored: bool,"}, {"sha": "ee0fe2065303b852d0b014522c70c82cfa0b9f0a", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 21, "deletions": 48, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -14,7 +14,6 @@\n // we use our own (green) start below; do not link in libnative; issue #13247.\n #![no_start]\n \n-#![allow(non_camel_case_types)]\n #![deny(warnings)]\n \n extern crate test;\n@@ -27,9 +26,10 @@ extern crate rustuv;\n use std::os;\n use std::io;\n use std::io::fs;\n+use std::from_str::FromStr;\n use getopts::{optopt, optflag, reqopt};\n-use common::{config, mode_run_pass, mode_run_fail, mode_compile_fail, mode_pretty,\n-             mode_debug_info_gdb, mode_debug_info_lldb, mode_codegen, mode};\n+use common::Config;\n+use common::{Pretty, DebugInfoGdb, Codegen};\n use util::logv;\n \n pub mod procsrv;\n@@ -51,7 +51,7 @@ pub fn main() {\n     run_tests(&config);\n }\n \n-pub fn parse_config(args: Vec<~str> ) -> config {\n+pub fn parse_config(args: Vec<~str> ) -> Config {\n \n     let groups : Vec<getopts::OptGroup> =\n         vec!(reqopt(\"\", \"compile-lib-path\", \"path to host shared libraries\", \"PATH\"),\n@@ -112,7 +112,7 @@ pub fn parse_config(args: Vec<~str> ) -> config {\n         Path::new(m.opt_str(nm).unwrap())\n     }\n \n-    config {\n+    Config {\n         compile_lib_path: matches.opt_str(\"compile-lib-path\").unwrap(),\n         run_lib_path: matches.opt_str(\"run-lib-path\").unwrap(),\n         rustc_path: opt_path(matches, \"rustc-path\"),\n@@ -122,7 +122,7 @@ pub fn parse_config(args: Vec<~str> ) -> config {\n         build_base: opt_path(matches, \"build-base\"),\n         aux_base: opt_path(matches, \"aux-base\"),\n         stage_id: matches.opt_str(\"stage-id\").unwrap(),\n-        mode: str_mode(matches.opt_str(\"mode\").unwrap()),\n+        mode: FromStr::from_str(matches.opt_str(\"mode\").unwrap()).expect(\"invalid mode\"),\n         run_ignored: matches.opt_present(\"ignored\"),\n         filter:\n             if !matches.free.is_empty() {\n@@ -155,7 +155,7 @@ pub fn parse_config(args: Vec<~str> ) -> config {\n     }\n }\n \n-pub fn log_config(config: &config) {\n+pub fn log_config(config: &Config) {\n     let c = config;\n     logv(c, format!(\"configuration:\"));\n     logv(c, format!(\"compile_lib_path: {}\", config.compile_lib_path));\n@@ -164,7 +164,7 @@ pub fn log_config(config: &config) {\n     logv(c, format!(\"src_base: {}\", config.src_base.display()));\n     logv(c, format!(\"build_base: {}\", config.build_base.display()));\n     logv(c, format!(\"stage_id: {}\", config.stage_id));\n-    logv(c, format!(\"mode: {}\", mode_str(config.mode)));\n+    logv(c, format!(\"mode: {}\", config.mode));\n     logv(c, format!(\"run_ignored: {}\", config.run_ignored));\n     logv(c, format!(\"filter: {}\", opt_str(&config.filter)));\n     logv(c, format!(\"runtool: {}\", opt_str(&config.runtool)));\n@@ -198,35 +198,10 @@ pub fn opt_str2(maybestr: Option<~str>) -> ~str {\n     match maybestr { None => \"(none)\".to_owned(), Some(s) => { s } }\n }\n \n-pub fn str_mode(s: ~str) -> mode {\n-    match s.as_slice() {\n-        \"compile-fail\" => mode_compile_fail,\n-        \"run-fail\" => mode_run_fail,\n-        \"run-pass\" => mode_run_pass,\n-        \"pretty\" => mode_pretty,\n-        \"debuginfo-gdb\" => mode_debug_info_gdb,\n-        \"debuginfo-lldb\" => mode_debug_info_lldb,\n-        \"codegen\" => mode_codegen,\n-        s => fail!(\"invalid mode: \" + s)\n-    }\n-}\n-\n-pub fn mode_str(mode: mode) -> ~str {\n-    match mode {\n-      mode_compile_fail => \"compile-fail\".to_owned(),\n-      mode_run_fail => \"run-fail\".to_owned(),\n-      mode_run_pass => \"run-pass\".to_owned(),\n-      mode_pretty => \"pretty\".to_owned(),\n-      mode_debug_info_gdb => \"debuginfo-gdb\".to_owned(),\n-      mode_debug_info_lldb => \"debuginfo-lldb\".to_owned(),\n-      mode_codegen => \"codegen\".to_owned(),\n-    }\n-}\n-\n-pub fn run_tests(config: &config) {\n+pub fn run_tests(config: &Config) {\n     if config.target == \"arm-linux-androideabi\".to_owned() {\n-        match config.mode{\n-            mode_debug_info_gdb => {\n+        match config.mode {\n+            DebugInfoGdb => {\n                 println!(\"arm-linux-androideabi debug-info \\\n                          test uses tcp 5039 port. please reserve it\");\n             }\n@@ -255,7 +230,7 @@ pub fn run_tests(config: &config) {\n     }\n }\n \n-pub fn test_opts(config: &config) -> test::TestOpts {\n+pub fn test_opts(config: &Config) -> test::TestOpts {\n     test::TestOpts {\n         filter: config.filter.clone(),\n         run_ignored: config.run_ignored,\n@@ -270,7 +245,7 @@ pub fn test_opts(config: &config) -> test::TestOpts {\n     }\n }\n \n-pub fn make_tests(config: &config) -> Vec<test::TestDescAndFn> {\n+pub fn make_tests(config: &Config) -> Vec<test::TestDescAndFn> {\n     debug!(\"making tests from {}\",\n            config.src_base.display());\n     let mut tests = Vec::new();\n@@ -281,7 +256,7 @@ pub fn make_tests(config: &config) -> Vec<test::TestDescAndFn> {\n         if is_test(config, &file) {\n             let t = make_test(config, &file, || {\n                 match config.mode {\n-                    mode_codegen => make_metrics_test_closure(config, &file),\n+                    Codegen => make_metrics_test_closure(config, &file),\n                     _ => make_test_closure(config, &file)\n                 }\n             });\n@@ -291,11 +266,11 @@ pub fn make_tests(config: &config) -> Vec<test::TestDescAndFn> {\n     tests\n }\n \n-pub fn is_test(config: &config, testfile: &Path) -> bool {\n+pub fn is_test(config: &Config, testfile: &Path) -> bool {\n     // Pretty-printer does not work with .rc files yet\n     let valid_extensions =\n         match config.mode {\n-          mode_pretty => vec!(\".rs\".to_owned()),\n+          Pretty => vec!(\".rs\".to_owned()),\n           _ => vec!(\".rc\".to_owned(), \".rs\".to_owned())\n         };\n     let invalid_prefixes = vec!(\".\".to_owned(), \"#\".to_owned(), \"~\".to_owned());\n@@ -314,7 +289,7 @@ pub fn is_test(config: &config, testfile: &Path) -> bool {\n     return valid;\n }\n \n-pub fn make_test(config: &config, testfile: &Path, f: || -> test::TestFn)\n+pub fn make_test(config: &Config, testfile: &Path, f: || -> test::TestFn)\n                  -> test::TestDescAndFn {\n     test::TestDescAndFn {\n         desc: test::TestDesc {\n@@ -326,7 +301,7 @@ pub fn make_test(config: &config, testfile: &Path, f: || -> test::TestFn)\n     }\n }\n \n-pub fn make_test_name(config: &config, testfile: &Path) -> test::TestName {\n+pub fn make_test_name(config: &Config, testfile: &Path) -> test::TestName {\n \n     // Try to elide redundant long paths\n     fn shorten(path: &Path) -> ~str {\n@@ -336,19 +311,17 @@ pub fn make_test_name(config: &config, testfile: &Path) -> test::TestName {\n         format!(\"{}/{}\", dir.unwrap_or(\"\"), filename.unwrap_or(\"\"))\n     }\n \n-    test::DynTestName(format!(\"[{}] {}\",\n-                              mode_str(config.mode),\n-                              shorten(testfile)))\n+    test::DynTestName(format!(\"[{}] {}\", config.mode, shorten(testfile)))\n }\n \n-pub fn make_test_closure(config: &config, testfile: &Path) -> test::TestFn {\n+pub fn make_test_closure(config: &Config, testfile: &Path) -> test::TestFn {\n     let config = (*config).clone();\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let testfile = testfile.as_str().unwrap().to_owned();\n     test::DynTestFn(proc() { runtest::run(config, testfile) })\n }\n \n-pub fn make_metrics_test_closure(config: &config, testfile: &Path) -> test::TestFn {\n+pub fn make_metrics_test_closure(config: &Config, testfile: &Path) -> test::TestFn {\n     let config = (*config).clone();\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let testfile = testfile.as_str().unwrap().to_owned();"}, {"sha": "047be9554774632734624f18a845ef6fb8573879", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use common::config;\n+use common::Config;\n use common;\n use util;\n \n@@ -34,6 +34,8 @@ pub struct TestProps {\n     pub check_stdout: bool,\n     // Don't force a --crate-type=dylib flag on the command line\n     pub no_prefer_dynamic: bool,\n+    // Don't run --pretty expanded when running pretty printing tests\n+    pub no_pretty_expanded: bool,\n }\n \n // Load any test directives embedded in the file\n@@ -48,6 +50,7 @@ pub fn load_props(testfile: &Path) -> TestProps {\n     let mut force_host = false;\n     let mut check_stdout = false;\n     let mut no_prefer_dynamic = false;\n+    let mut no_pretty_expanded = false;\n     iter_header(testfile, |ln| {\n         match parse_error_pattern(ln) {\n           Some(ep) => error_patterns.push(ep),\n@@ -78,6 +81,10 @@ pub fn load_props(testfile: &Path) -> TestProps {\n             no_prefer_dynamic = parse_no_prefer_dynamic(ln);\n         }\n \n+        if !no_pretty_expanded {\n+            no_pretty_expanded = parse_no_pretty_expanded(ln);\n+        }\n+\n         match parse_aux_build(ln) {\n             Some(ab) => { aux_builds.push(ab); }\n             None => {}\n@@ -107,22 +114,23 @@ pub fn load_props(testfile: &Path) -> TestProps {\n         force_host: force_host,\n         check_stdout: check_stdout,\n         no_prefer_dynamic: no_prefer_dynamic,\n+        no_pretty_expanded: no_pretty_expanded,\n     }\n }\n \n-pub fn is_test_ignored(config: &config, testfile: &Path) -> bool {\n-    fn ignore_target(config: &config) -> ~str {\n+pub fn is_test_ignored(config: &Config, testfile: &Path) -> bool {\n+    fn ignore_target(config: &Config) -> ~str {\n         \"ignore-\".to_owned() + util::get_os(config.target)\n     }\n-    fn ignore_stage(config: &config) -> ~str {\n+    fn ignore_stage(config: &Config) -> ~str {\n         \"ignore-\".to_owned() + config.stage_id.split('-').next().unwrap()\n     }\n \n     let val = iter_header(testfile, |ln| {\n         if parse_name_directive(ln, \"ignore-test\") { false }\n         else if parse_name_directive(ln, ignore_target(config)) { false }\n         else if parse_name_directive(ln, ignore_stage(config)) { false }\n-        else if config.mode == common::mode_pretty &&\n+        else if config.mode == common::Pretty &&\n             parse_name_directive(ln, \"ignore-pretty\") { false }\n         else if config.target != config.host &&\n             parse_name_directive(ln, \"ignore-cross-compile\") { false }\n@@ -180,6 +188,10 @@ fn parse_no_prefer_dynamic(line: &str) -> bool {\n     parse_name_directive(line, \"no-prefer-dynamic\")\n }\n \n+fn parse_no_pretty_expanded(line: &str) -> bool {\n+    parse_name_directive(line, \"no-pretty-expanded\")\n+}\n+\n fn parse_exec_env(line: &str) -> Option<(~str, ~str)> {\n     parse_name_value_directive(line, \"exec-env\".to_owned()).map(|nv| {\n         // nv is either FOO or FOO=BAR"}, {"sha": "d3642a939db049a30c9c42a9ea561fe30b33a79c", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -68,19 +68,20 @@ pub fn run(lib_path: &str,\n            input: Option<~str>) -> Option<Result> {\n \n     let env = env.clone().append(target_env(lib_path, prog).as_slice());\n-    let mut opt_process = Process::configure(ProcessConfig {\n+    let opt_process = Process::configure(ProcessConfig {\n         program: prog,\n         args: args,\n         env: Some(env.as_slice()),\n         .. ProcessConfig::new()\n     });\n \n     match opt_process {\n-        Ok(ref mut process) => {\n+        Ok(mut process) => {\n             for input in input.iter() {\n                 process.stdin.get_mut_ref().write(input.as_bytes()).unwrap();\n             }\n-            let ProcessOutput { status, output, error } = process.wait_with_output();\n+            let ProcessOutput { status, output, error } =\n+                process.wait_with_output().unwrap();\n \n             Some(Result {\n                 status: status,"}, {"sha": "d18f1370a9f4769f1e8026d8a42bb29cc4b26ebb", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 84, "deletions": 59, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use common::{config, mode_compile_fail, mode_pretty, mode_run_fail, mode_run_pass};\n+use common::Config;\n+use common::{CompileFail, Pretty, RunFail, RunPass, DebugInfoGdb, DebugInfoLldb};\n use errors;\n use header::TestProps;\n use header;\n@@ -30,7 +31,7 @@ use std::strbuf::StrBuf;\n use std::task;\n use test::MetricMap;\n \n-pub fn run(config: config, testfile: ~str) {\n+pub fn run(config: Config, testfile: ~str) {\n \n     match config.target.as_slice() {\n \n@@ -47,7 +48,7 @@ pub fn run(config: config, testfile: ~str) {\n     run_metrics(config, testfile, &mut _mm);\n }\n \n-pub fn run_metrics(config: config, testfile: ~str, mm: &mut MetricMap) {\n+pub fn run_metrics(config: Config, testfile: ~str, mm: &mut MetricMap) {\n     if config.verbose {\n         // We're going to be dumping a lot of info. Start on a new line.\n         print!(\"\\n\\n\");\n@@ -57,17 +58,17 @@ pub fn run_metrics(config: config, testfile: ~str, mm: &mut MetricMap) {\n     let props = header::load_props(&testfile);\n     debug!(\"loaded props\");\n     match config.mode {\n-      mode_compile_fail => run_cfail_test(&config, &props, &testfile),\n-      mode_run_fail => run_rfail_test(&config, &props, &testfile),\n-      mode_run_pass => run_rpass_test(&config, &props, &testfile),\n-      mode_pretty => run_pretty_test(&config, &props, &testfile),\n-      mode_debug_info_gdb => run_debuginfo_gdb_test(&config, &props, &testfile),\n-      mode_debug_info_lldb => run_debuginfo_lldb_test(&config, &props, &testfile),\n-      mode_codegen => run_codegen_test(&config, &props, &testfile, mm)\n+      CompileFail => run_cfail_test(&config, &props, &testfile),\n+      RunFail => run_rfail_test(&config, &props, &testfile),\n+      RunPass => run_rpass_test(&config, &props, &testfile),\n+      Pretty => run_pretty_test(&config, &props, &testfile),\n+      DebugInfoGdb => run_debuginfo_gdb_test(&config, &props, &testfile),\n+      DebugInfoLldb => run_debuginfo_lldb_test(&config, &props, &testfile),\n+      Codegen => run_codegen_test(&config, &props, &testfile, mm),\n     }\n }\n \n-fn run_cfail_test(config: &config, props: &TestProps, testfile: &Path) {\n+fn run_cfail_test(config: &Config, props: &TestProps, testfile: &Path) {\n     let proc_res = compile_test(config, props, testfile);\n \n     if proc_res.status.success() {\n@@ -88,7 +89,7 @@ fn run_cfail_test(config: &config, props: &TestProps, testfile: &Path) {\n     check_no_compiler_crash(&proc_res);\n }\n \n-fn run_rfail_test(config: &config, props: &TestProps, testfile: &Path) {\n+fn run_rfail_test(config: &Config, props: &TestProps, testfile: &Path) {\n     let proc_res = if !config.jit {\n         let proc_res = compile_test(config, props, testfile);\n \n@@ -121,7 +122,7 @@ fn check_correct_failure_status(proc_res: &ProcRes) {\n     }\n }\n \n-fn run_rpass_test(config: &config, props: &TestProps, testfile: &Path) {\n+fn run_rpass_test(config: &Config, props: &TestProps, testfile: &Path) {\n     if !config.jit {\n         let mut proc_res = compile_test(config, props, testfile);\n \n@@ -141,7 +142,7 @@ fn run_rpass_test(config: &config, props: &TestProps, testfile: &Path) {\n     }\n }\n \n-fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n+fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n     if props.pp_exact.is_some() {\n         logv(config, \"testing for exact pretty-printing\".to_owned());\n     } else { logv(config, \"testing for converging pretty-printing\".to_owned()); }\n@@ -156,9 +157,7 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n     let mut round = 0;\n     while round < rounds {\n         logv(config, format!(\"pretty-printing round {}\", round));\n-        let proc_res = print_source(config,\n-                                    testfile,\n-                                    (*srcs.get(round)).clone());\n+        let proc_res = print_source(config, props, testfile, (*srcs.get(round)).clone(), \"normal\");\n \n         if !proc_res.status.success() {\n             fatal_ProcRes(format!(\"pretty-printing failed in round {}\", round),\n@@ -195,18 +194,43 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n     if !proc_res.status.success() {\n         fatal_ProcRes(\"pretty-printed source does not typecheck\".to_owned(), &proc_res);\n     }\n+    if props.no_pretty_expanded { return }\n+\n+    // additionally, run `--pretty expanded` and try to build it.\n+    let proc_res = print_source(config, props, testfile, (*srcs.get(round)).clone(), \"expanded\");\n+    if !proc_res.status.success() {\n+        fatal_ProcRes(format!(\"pretty-printing (expanded) failed\"), &proc_res);\n+    }\n+\n+    let ProcRes{ stdout: expanded_src, .. } = proc_res;\n+    let proc_res = typecheck_source(config, props, testfile, expanded_src);\n+    if !proc_res.status.success() {\n+        fatal_ProcRes(format!(\"pretty-printed source (expanded) does not typecheck\"), &proc_res);\n+    }\n \n     return;\n \n-    fn print_source(config: &config, testfile: &Path, src: ~str) -> ProcRes {\n-        compose_and_run(config, testfile, make_pp_args(config, testfile),\n-                        Vec::new(), config.compile_lib_path, Some(src))\n+    fn print_source(config: &Config,\n+                    props: &TestProps,\n+                    testfile: &Path,\n+                    src: ~str,\n+                    pretty_type: &str) -> ProcRes {\n+        compose_and_run(config, testfile,\n+                        make_pp_args(config, props, testfile, pretty_type.to_owned()),\n+                        props.exec_env.clone(), config.compile_lib_path, Some(src))\n     }\n \n-    fn make_pp_args(config: &config, _testfile: &Path) -> ProcArgs {\n-        let args = vec!(\"-\".to_owned(), \"--pretty\".to_owned(), \"normal\".to_owned(),\n-                     \"--target=\".to_owned() + config.target);\n+    fn make_pp_args(config: &Config,\n+                    props: &TestProps,\n+                    testfile: &Path,\n+                    pretty_type: ~str) -> ProcArgs {\n+        let aux_dir = aux_output_dir_name(config, testfile);\n         // FIXME (#9639): This needs to handle non-utf8 paths\n+        let mut args = vec!(\"-\".to_owned(), \"--pretty\".to_owned(), pretty_type,\n+                            \"--target=\".to_owned() + config.target,\n+                            \"-L\".to_owned(), aux_dir.as_str().unwrap().to_owned());\n+        args.push_all_move(split_maybe_args(&config.target_rustcflags));\n+        args.push_all_move(split_maybe_args(&props.compile_flags));\n         return ProcArgs {prog: config.rustc_path.as_str().unwrap().to_owned(), args: args};\n     }\n \n@@ -228,13 +252,13 @@ actual:\\n\\\n         }\n     }\n \n-    fn typecheck_source(config: &config, props: &TestProps,\n+    fn typecheck_source(config: &Config, props: &TestProps,\n                         testfile: &Path, src: ~str) -> ProcRes {\n         let args = make_typecheck_args(config, props, testfile);\n         compose_and_run_compiler(config, props, testfile, args, Some(src))\n     }\n \n-    fn make_typecheck_args(config: &config, props: &TestProps, testfile: &Path) -> ProcArgs {\n+    fn make_typecheck_args(config: &Config, props: &TestProps, testfile: &Path) -> ProcArgs {\n         let aux_dir = aux_output_dir_name(config, testfile);\n         let target = if props.force_host {\n             config.host.as_slice()\n@@ -255,8 +279,8 @@ actual:\\n\\\n     }\n }\n \n-fn run_debuginfo_gdb_test(config: &config, props: &TestProps, testfile: &Path) {\n-    let mut config = config {\n+fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n+    let mut config = Config {\n         target_rustcflags: cleanup_debug_info_options(&config.target_rustcflags),\n         host_rustcflags: cleanup_debug_info_options(&config.host_rustcflags),\n         .. config.clone()\n@@ -403,14 +427,14 @@ fn run_debuginfo_gdb_test(config: &config, props: &TestProps, testfile: &Path) {\n     check_debugger_output(&debugger_run_result, check_lines.as_slice());\n }\n \n-fn run_debuginfo_lldb_test(config: &config, props: &TestProps, testfile: &Path) {\n+fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path) {\n     use std::io::process::{Process, ProcessConfig, ProcessOutput};\n \n     if config.lldb_python_dir.is_none() {\n         fatal(\"Can't run LLDB test because LLDB's python path is not set.\".to_owned());\n     }\n \n-    let mut config = config {\n+    let mut config = Config {\n         target_rustcflags: cleanup_debug_info_options(&config.target_rustcflags),\n         host_rustcflags: cleanup_debug_info_options(&config.host_rustcflags),\n         .. config.clone()\n@@ -465,7 +489,7 @@ fn run_debuginfo_lldb_test(config: &config, props: &TestProps, testfile: &Path)\n \n     check_debugger_output(&debugger_run_result, check_lines.as_slice());\n \n-    fn run_lldb(config: &config, test_executable: &Path, debugger_script: &Path) -> ProcRes {\n+    fn run_lldb(config: &Config, test_executable: &Path, debugger_script: &Path) -> ProcRes {\n         // Prepare the lldb_batchmode which executes the debugger script\n         let lldb_batchmode_script = \"./src/etc/lldb_batchmode.py\".to_owned();\n         let test_executable_str = test_executable.as_str().unwrap().to_owned();\n@@ -478,16 +502,17 @@ fn run_debuginfo_lldb_test(config: &config, props: &TestProps, testfile: &Path)\n         let args = &[lldb_batchmode_script, test_executable_str, debugger_script_str];\n         let env = &[(\"PYTHONPATH\".to_owned(), config.lldb_python_dir.clone().unwrap())];\n \n-        let mut opt_process = Process::configure(ProcessConfig {\n+        let opt_process = Process::configure(ProcessConfig {\n             program: \"python\",\n             args: args,\n             env: Some(env),\n             .. ProcessConfig::new()\n         });\n \n         let (status, out, err) = match opt_process {\n-            Ok(ref mut process) => {\n-                let ProcessOutput { status, output, error } = process.wait_with_output();\n+            Ok(process) => {\n+                let ProcessOutput { status, output, error } =\n+                    process.wait_with_output().unwrap();\n \n                 (status,\n                  str::from_utf8(output.as_slice()).unwrap().to_owned(),\n@@ -834,16 +859,16 @@ struct ProcArgs {prog: ~str, args: Vec<~str> }\n \n struct ProcRes {status: ProcessExit, stdout: ~str, stderr: ~str, cmdline: ~str}\n \n-fn compile_test(config: &config, props: &TestProps,\n+fn compile_test(config: &Config, props: &TestProps,\n                 testfile: &Path) -> ProcRes {\n     compile_test_(config, props, testfile, [])\n }\n \n-fn jit_test(config: &config, props: &TestProps, testfile: &Path) -> ProcRes {\n+fn jit_test(config: &Config, props: &TestProps, testfile: &Path) -> ProcRes {\n     compile_test_(config, props, testfile, [\"--jit\".to_owned()])\n }\n \n-fn compile_test_(config: &config, props: &TestProps,\n+fn compile_test_(config: &Config, props: &TestProps,\n                  testfile: &Path, extra_args: &[~str]) -> ProcRes {\n     let aux_dir = aux_output_dir_name(config, testfile);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -855,7 +880,7 @@ fn compile_test_(config: &config, props: &TestProps,\n     compose_and_run_compiler(config, props, testfile, args, None)\n }\n \n-fn exec_compiled_test(config: &config, props: &TestProps,\n+fn exec_compiled_test(config: &Config, props: &TestProps,\n                       testfile: &Path) -> ProcRes {\n \n     let env = props.exec_env.clone();\n@@ -876,7 +901,7 @@ fn exec_compiled_test(config: &config, props: &TestProps,\n }\n \n fn compose_and_run_compiler(\n-    config: &config,\n+    config: &Config,\n     props: &TestProps,\n     testfile: &Path,\n     args: ProcArgs,\n@@ -934,7 +959,7 @@ fn ensure_dir(path: &Path) {\n     fs::mkdir(path, io::UserRWX).unwrap();\n }\n \n-fn compose_and_run(config: &config, testfile: &Path,\n+fn compose_and_run(config: &Config, testfile: &Path,\n                    ProcArgs{ args, prog }: ProcArgs,\n                    procenv: Vec<(~str, ~str)> ,\n                    lib_path: &str,\n@@ -948,10 +973,10 @@ enum TargetLocation {\n     ThisDirectory(Path),\n }\n \n-fn make_compile_args(config: &config,\n+fn make_compile_args(config: &Config,\n                      props: &TestProps,\n                      extras: Vec<~str> ,\n-                     xform: |&config, &Path| -> TargetLocation,\n+                     xform: |&Config, &Path| -> TargetLocation,\n                      testfile: &Path)\n                      -> ProcArgs {\n     let xform_file = xform(config, testfile);\n@@ -983,14 +1008,14 @@ fn make_compile_args(config: &config,\n     return ProcArgs {prog: config.rustc_path.as_str().unwrap().to_owned(), args: args};\n }\n \n-fn make_lib_name(config: &config, auxfile: &Path, testfile: &Path) -> Path {\n+fn make_lib_name(config: &Config, auxfile: &Path, testfile: &Path) -> Path {\n     // what we return here is not particularly important, as it\n     // happens; rustc ignores everything except for the directory.\n     let auxname = output_testname(auxfile);\n     aux_output_dir_name(config, testfile).join(&auxname)\n }\n \n-fn make_exe_name(config: &config, testfile: &Path) -> Path {\n+fn make_exe_name(config: &Config, testfile: &Path) -> Path {\n     let mut f = output_base_name(config, testfile);\n     if !os::consts::EXE_SUFFIX.is_empty() {\n         match f.filename().map(|s| Vec::from_slice(s).append(os::consts::EXE_SUFFIX.as_bytes())) {\n@@ -1001,7 +1026,7 @@ fn make_exe_name(config: &config, testfile: &Path) -> Path {\n     f\n }\n \n-fn make_run_args(config: &config, props: &TestProps, testfile: &Path) ->\n+fn make_run_args(config: &Config, props: &TestProps, testfile: &Path) ->\n    ProcArgs {\n     // If we've got another tool to run under (valgrind),\n     // then split apart its command\n@@ -1029,7 +1054,7 @@ fn split_maybe_args(argstr: &Option<~str>) -> Vec<~str> {\n     }\n }\n \n-fn program_output(config: &config, testfile: &Path, lib_path: &str, prog: ~str,\n+fn program_output(config: &Config, testfile: &Path, lib_path: &str, prog: ~str,\n                   args: Vec<~str> , env: Vec<(~str, ~str)> ,\n                   input: Option<~str>) -> ProcRes {\n     let cmdline =\n@@ -1069,23 +1094,23 @@ fn lib_path_cmd_prefix(path: &str) -> ~str {\n     format!(\"{}=\\\"{}\\\"\", util::lib_path_env_var(), util::make_new_path(path))\n }\n \n-fn dump_output(config: &config, testfile: &Path, out: &str, err: &str) {\n+fn dump_output(config: &Config, testfile: &Path, out: &str, err: &str) {\n     dump_output_file(config, testfile, out, \"out\");\n     dump_output_file(config, testfile, err, \"err\");\n     maybe_dump_to_stdout(config, out, err);\n }\n \n-fn dump_output_file(config: &config, testfile: &Path,\n+fn dump_output_file(config: &Config, testfile: &Path,\n                     out: &str, extension: &str) {\n     let outfile = make_out_name(config, testfile, extension);\n     File::create(&outfile).write(out.as_bytes()).unwrap();\n }\n \n-fn make_out_name(config: &config, testfile: &Path, extension: &str) -> Path {\n+fn make_out_name(config: &Config, testfile: &Path, extension: &str) -> Path {\n     output_base_name(config, testfile).with_extension(extension)\n }\n \n-fn aux_output_dir_name(config: &config, testfile: &Path) -> Path {\n+fn aux_output_dir_name(config: &Config, testfile: &Path) -> Path {\n     let mut f = output_base_name(config, testfile);\n     match f.filename().map(|s| Vec::from_slice(s).append(bytes!(\".libaux\"))) {\n         Some(v) => f.set_filename(v),\n@@ -1098,13 +1123,13 @@ fn output_testname(testfile: &Path) -> Path {\n     Path::new(testfile.filestem().unwrap())\n }\n \n-fn output_base_name(config: &config, testfile: &Path) -> Path {\n+fn output_base_name(config: &Config, testfile: &Path) -> Path {\n     config.build_base\n         .join(&output_testname(testfile))\n         .with_extension(config.stage_id.as_slice())\n }\n \n-fn maybe_dump_to_stdout(config: &config, out: &str, err: &str) {\n+fn maybe_dump_to_stdout(config: &Config, out: &str, err: &str) {\n     if config.verbose {\n         println!(\"------{}------------------------------\", \"stdout\");\n         println!(\"{}\", out);\n@@ -1137,7 +1162,7 @@ stderr:\\n\\\n     fail!();\n }\n \n-fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n+fn _arm_exec_compiled_test(config: &Config, props: &TestProps,\n                       testfile: &Path, env: Vec<(~str, ~str)> ) -> ProcRes {\n \n     let args = make_run_args(config, props, testfile);\n@@ -1237,7 +1262,7 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n     }\n }\n \n-fn _arm_push_aux_shared_library(config: &config, testfile: &Path) {\n+fn _arm_push_aux_shared_library(config: &Config, testfile: &Path) {\n     let tdir = aux_output_dir_name(config, testfile);\n \n     let dirs = fs::readdir(&tdir).unwrap();\n@@ -1260,7 +1285,7 @@ fn _arm_push_aux_shared_library(config: &config, testfile: &Path) {\n \n // codegen tests (vs. clang)\n \n-fn make_o_name(config: &config, testfile: &Path) -> Path {\n+fn make_o_name(config: &Config, testfile: &Path) -> Path {\n     output_base_name(config, testfile).with_extension(\"o\")\n }\n \n@@ -1273,7 +1298,7 @@ fn append_suffix_to_stem(p: &Path, suffix: &str) -> Path {\n     }\n }\n \n-fn compile_test_and_save_bitcode(config: &config, props: &TestProps,\n+fn compile_test_and_save_bitcode(config: &Config, props: &TestProps,\n                                  testfile: &Path) -> ProcRes {\n     let aux_dir = aux_output_dir_name(config, testfile);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -1287,7 +1312,7 @@ fn compile_test_and_save_bitcode(config: &config, props: &TestProps,\n     compose_and_run_compiler(config, props, testfile, args, None)\n }\n \n-fn compile_cc_with_clang_and_save_bitcode(config: &config, _props: &TestProps,\n+fn compile_cc_with_clang_and_save_bitcode(config: &Config, _props: &TestProps,\n                                           testfile: &Path) -> ProcRes {\n     let bitcodefile = output_base_name(config, testfile).with_extension(\"bc\");\n     let bitcodefile = append_suffix_to_stem(&bitcodefile, \"clang\");\n@@ -1303,7 +1328,7 @@ fn compile_cc_with_clang_and_save_bitcode(config: &config, _props: &TestProps,\n     compose_and_run(config, testfile, proc_args, Vec::new(), \"\", None)\n }\n \n-fn extract_function_from_bitcode(config: &config, _props: &TestProps,\n+fn extract_function_from_bitcode(config: &Config, _props: &TestProps,\n                                  fname: &str, testfile: &Path,\n                                  suffix: &str) -> ProcRes {\n     let bitcodefile = output_base_name(config, testfile).with_extension(\"bc\");\n@@ -1320,7 +1345,7 @@ fn extract_function_from_bitcode(config: &config, _props: &TestProps,\n     compose_and_run(config, testfile, proc_args, Vec::new(), \"\", None)\n }\n \n-fn disassemble_extract(config: &config, _props: &TestProps,\n+fn disassemble_extract(config: &Config, _props: &TestProps,\n                        testfile: &Path, suffix: &str) -> ProcRes {\n     let bitcodefile = output_base_name(config, testfile).with_extension(\"bc\");\n     let bitcodefile = append_suffix_to_stem(&bitcodefile, suffix);\n@@ -1344,7 +1369,7 @@ fn count_extracted_lines(p: &Path) -> uint {\n }\n \n \n-fn run_codegen_test(config: &config, props: &TestProps,\n+fn run_codegen_test(config: &Config, props: &TestProps,\n                     testfile: &Path, mm: &mut MetricMap) {\n \n     if config.llvm_bin_path.is_none() {"}, {"sha": "253b7e87d02234199ae2cf2a7e6172248b9c05c1", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use common::config;\n+use common::Config;\n \n #[cfg(target_os = \"win32\")]\n use std::os::getenv;\n@@ -51,7 +51,7 @@ pub fn lib_path_env_var() -> ~str { \"PATH\".to_owned() }\n #[cfg(target_os = \"win32\")]\n pub fn path_div() -> ~str { \";\".to_owned() }\n \n-pub fn logv(config: &config, s: ~str) {\n+pub fn logv(config: &Config, s: ~str) {\n     debug!(\"{}\", s);\n     if config.verbose { println!(\"{}\", s); }\n }"}, {"sha": "a19418ff667933c648cdd7234b2dea1ef6583b48", "filename": "src/doc/not_found.md", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Fdoc%2Fnot_found.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Fdoc%2Fnot_found.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnot_found.md?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -0,0 +1,20 @@\n+% Not Found\n+\n+<!-- Completely hide the TOC and the section numbers -->\n+<style type=\"text/css\">\n+#TOC { display: none; }\n+.header-section-number { display: none; }\n+li {list-style-type: none; }\n+</style>\n+\n+Looks like you've taken a wrong turn.\n+\n+Some things that might be helpful to you though:\n+\n+## Reference\n+* [The Rust official site](http://rust-lang.org)\n+* [The Rust reference manual](http://static.rust-lang.org/doc/master/rust.html) (* [PDF](http://static.rust-lang.org/doc/master/rust.pdf))\n+\n+## Docs\n+* [The standard library (stable)](http://doc.rust-lang.org/doc/0.10/std/index.html)\n+* [The standard library (master)](http://doc.rust-lang.org/doc/master/std/index.html)"}, {"sha": "f242a89784ce966c4dbcb36e76b94d78106db52d", "filename": "src/doc/rust.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -2648,9 +2648,9 @@ before the expression they apply to.\n   : Logical negation. On the boolean type, this flips between `true` and\n     `false`. On integer types, this inverts the individual bits in the\n     two's complement representation of the value.\n-* `~`\n+* `box`\n   :  [Boxing](#pointer-types) operators. Allocate a box to hold the value they are applied to,\n-     and store the value in it. `~` creates an owned box.\n+     and store the value in it. `box` creates an owned box.\n * `&`\n   : Borrow operator. Returns a reference, pointing to its operand.\n     The operand of a borrow is statically proven to outlive the resulting pointer.\n@@ -3156,7 +3156,7 @@ fn main() {\n ~~~~\n \n Patterns can also dereference pointers by using the `&`,\n-`~` or `@` symbols, as appropriate. For example, these two matches\n+`box` or `@` symbols, as appropriate. For example, these two matches\n on `x: &int` are equivalent:\n \n ~~~~\n@@ -3438,11 +3438,11 @@ All pointers in Rust are explicit first-class values.\n They can be copied, stored into data structures, and returned from functions.\n There are four varieties of pointer in Rust:\n \n-* Owning pointers (`~`)\n+* Owning pointers (`Box`)\n   : These point to owned heap allocations (or \"boxes\") in the shared, inter-task heap.\n     Each owned box has a single owning pointer; pointer and pointee retain a 1:1 relationship at all times.\n-    Owning pointers are written `~content`,\n-    for example `~int` means an owning pointer to an owned box containing an integer.\n+    Owning pointers are written `Box<content>`,\n+    for example `Box<int>` means an owning pointer to an owned box containing an integer.\n     Copying an owned box is a \"deep\" operation:\n     it involves allocating a new owned box and copying the contents of the old box into the new box.\n     Releasing an owning pointer immediately releases its corresponding owned box.\n@@ -3562,8 +3562,8 @@ Whereas most calls to trait methods are \"early bound\" (statically resolved) to s\n a call to a method on an object type is only resolved to a vtable entry at compile time.\n The actual implementation for each vtable entry can vary on an object-by-object basis.\n \n-Given a pointer-typed expression `E` of type `&T` or `~T`, where `T` implements trait `R`,\n-casting `E` to the corresponding pointer type `&R` or `~R` results in a value of the _object type_ `R`.\n+Given a pointer-typed expression `E` of type `&T` or `Box<T>`, where `T` implements trait `R`,\n+casting `E` to the corresponding pointer type `&R` or `Box<R>` results in a value of the _object type_ `R`.\n This result is represented as a pair of pointers:\n the vtable pointer for the `T` implementation of `R`, and the pointer value of `E`.\n \n@@ -3761,7 +3761,7 @@ Local variables are immutable unless declared otherwise like: `let mut x = ...`.\n \n Function parameters are immutable unless declared with `mut`. The\n `mut` keyword applies only to the following parameter (so `|mut x, y|`\n-and `fn f(mut x: ~int, y: ~int)` declare one mutable variable `x` and\n+and `fn f(mut x: Box<int>, y: Box<int>)` declare one mutable variable `x` and\n one immutable variable `y`).\n \n Methods that take either `self` or `~self` can optionally place them in a"}, {"sha": "7dd31f9cc77c6a16bf9f026396e7d3fd1ad2a38f", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -455,7 +455,7 @@ against each pattern in order until one matches. The matching pattern\n executes its corresponding arm.\n \n ~~~~\n-# let my_number = 1;\n+let my_number = 1;\n match my_number {\n   0     => println!(\"zero\"),\n   1 | 2 => println!(\"one or two\"),"}, {"sha": "586890ebe4c9a118fc4a8e30b462955928ff48f6", "filename": "src/etc/unicode.py", "status": "modified", "additions": 134, "deletions": 74, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -169,7 +169,7 @@ def emit_bsearch_range_table(f):\n         else if hi < c { Less }\n         else { Greater }\n     }) != None\n-}\\n\\n\n+}\\n\n \"\"\");\n \n def emit_property_module(f, mod, tbl):\n@@ -193,11 +193,11 @@ def emit_property_module(f, mod, tbl):\n         f.write(\"    pub fn %s(c: char) -> bool {\\n\" % cat)\n         f.write(\"        super::bsearch_range_table(c, %s_table)\\n\" % cat)\n         f.write(\"    }\\n\\n\")\n-    f.write(\"}\\n\")\n+    f.write(\"}\\n\\n\")\n \n \n def emit_conversions_module(f, lowerupper, upperlower):\n-    f.write(\"pub mod conversions {\\n\")\n+    f.write(\"pub mod conversions {\")\n     f.write(\"\"\"\n     use cmp::{Equal, Less, Greater};\n     use slice::ImmutableVector;\n@@ -225,13 +225,14 @@ def emit_conversions_module(f, lowerupper, upperlower):\n             else { Greater }\n         })\n     }\n+\n \"\"\");\n     emit_caseconversion_table(f, \"LuLl\", upperlower)\n     emit_caseconversion_table(f, \"LlLu\", lowerupper)\n     f.write(\"}\\n\")\n \n def emit_caseconversion_table(f, name, table):\n-    f.write(\"   static %s_table : &'static [(char, char)] = &[\\n\" % name)\n+    f.write(\"    static %s_table : &'static [(char, char)] = &[\\n\" % name)\n     sorted_table = sorted(table.iteritems(), key=operator.itemgetter(0))\n     ix = 0\n     for key, value in sorted_table:\n@@ -255,13 +256,13 @@ def format_table_content(f, content, indent):\n             line = \" \"*indent + chunk\n     f.write(line)\n \n-def emit_decomp_module(f, canon, compat, combine):\n+def emit_core_norm_module(f, canon, compat):\n     canon_keys = canon.keys()\n     canon_keys.sort()\n \n     compat_keys = compat.keys()\n     compat_keys.sort()\n-    f.write(\"pub mod decompose {\\n\");\n+    f.write(\"pub mod normalization {\\n\");\n     f.write(\"    use option::Option;\\n\");\n     f.write(\"    use option::{Some, None};\\n\");\n     f.write(\"    use slice::ImmutableVector;\\n\");\n@@ -279,23 +280,6 @@ def emit_decomp_module(f, canon, compat, combine):\n             }\n             None => None\n         }\n-    }\\n\n-\"\"\")\n-\n-    f.write(\"\"\"\n-    fn bsearch_range_value_table(c: char, r: &'static [(char, char, u8)]) -> u8 {\n-        use cmp::{Equal, Less, Greater};\n-        match r.bsearch(|&(lo, hi, _)| {\n-            if lo <= c && c <= hi { Equal }\n-            else if hi < c { Less }\n-            else { Greater }\n-        }) {\n-            Some(idx) => {\n-                let (_, _, result) = r[idx];\n-                result\n-            }\n-            None => 0\n-        }\n     }\\n\\n\n \"\"\")\n \n@@ -337,28 +321,24 @@ def emit_decomp_module(f, canon, compat, combine):\n     format_table_content(f, data, 8)\n     f.write(\"\\n    ];\\n\\n\")\n \n-    f.write(\"    static combining_class_table : &'static [(char, char, u8)] = &[\\n\")\n-    ix = 0\n-    for pair in combine:\n-        f.write(ch_prefix(ix))\n-        f.write(\"(%s, %s, %s)\" % (escape_char(pair[0]), escape_char(pair[1]), pair[2]))\n-        ix += 1\n-    f.write(\"\\n    ];\\n\")\n+    f.write(\"\"\"\n+    pub fn decompose_canonical(c: char, i: |char|) { d(c, i, false); }\n \n-    f.write(\"    pub fn canonical(c: char, i: |char|) \"\n-        + \"{ d(c, i, false); }\\n\\n\")\n-    f.write(\"    pub fn compatibility(c: char, i: |char|) \"\n-            +\"{ d(c, i, true); }\\n\\n\")\n-    f.write(\"    pub fn canonical_combining_class(c: char) -> u8 {\\n\"\n-        + \"        bsearch_range_value_table(c, combining_class_table)\\n\"\n-        + \"    }\\n\\n\")\n-    f.write(\"    fn d(c: char, i: |char|, k: bool) {\\n\")\n-    f.write(\"        use iter::Iterator;\\n\");\n+    pub fn decompose_compatible(c: char, i: |char|) { d(c, i, true); }\n \n-    f.write(\"        if c <= '\\\\x7f' { i(c); return; }\\n\")\n+    fn d(c: char, i: |char|, k: bool) {\n+        use iter::Iterator;\n \n-    # First check the canonical decompositions\n-    f.write(\"\"\"\n+        // 7-bit ASCII never decomposes\n+        if c <= '\\\\x7f' { i(c); return; }\n+\n+        // Perform decomposition for Hangul\n+        if (c as u32) >= S_BASE && (c as u32) < (S_BASE + S_COUNT) {\n+            decompose_hangul(c, i);\n+            return;\n+        }\n+\n+        // First check the canonical decompositions\n         match bsearch_table(c, canonical_table) {\n             Some(canon) => {\n                 for x in canon.iter() {\n@@ -367,13 +347,12 @@ def emit_decomp_module(f, canon, compat, combine):\n                 return;\n             }\n             None => ()\n-        }\\n\\n\"\"\")\n+        }\n \n-    # Bottom out if we're not doing compat.\n-    f.write(\"        if !k { i(c); return; }\\n\")\n+        // Bottom out if we're not doing compat.\n+        if !k { i(c); return; }\n \n-    # Then check the compatibility decompositions\n-    f.write(\"\"\"\n+        // Then check the compatibility decompositions\n         match bsearch_table(c, compatibility_table) {\n             Some(compat) => {\n                 for x in compat.iter() {\n@@ -382,24 +361,83 @@ def emit_decomp_module(f, canon, compat, combine):\n                 return;\n             }\n             None => ()\n-        }\\n\\n\"\"\")\n+        }\n \n-    # Finally bottom out.\n-    f.write(\"        i(c);\\n\")\n-    f.write(\"    }\\n\")\n-    f.write(\"}\\n\\n\")\n+        // Finally bottom out.\n+        i(c);\n+    }\n \n-r = \"unicode.rs\"\n-for i in [r]:\n-    if os.path.exists(i):\n-        os.remove(i);\n-rf = open(r, \"w\")\n+    // Constants from Unicode 6.2.0 Section 3.12 Conjoining Jamo Behavior\n+    static S_BASE: u32 = 0xAC00;\n+    static L_BASE: u32 = 0x1100;\n+    static V_BASE: u32 = 0x1161;\n+    static T_BASE: u32 = 0x11A7;\n+    static L_COUNT: u32 = 19;\n+    static V_COUNT: u32 = 21;\n+    static T_COUNT: u32 = 28;\n+    static N_COUNT: u32 = (V_COUNT * T_COUNT);\n+    static S_COUNT: u32 = (L_COUNT * N_COUNT);\n+\n+    // Decompose a precomposed Hangul syllable\n+    fn decompose_hangul(s: char, f: |char|) {\n+        use cast::transmute;\n+\n+        let si = s as u32 - S_BASE;\n+\n+        let li = si / N_COUNT;\n+        unsafe {\n+            f(transmute(L_BASE + li));\n+\n+            let vi = (si % N_COUNT) / T_COUNT;\n+            f(transmute(V_BASE + vi));\n+\n+            let ti = si % T_COUNT;\n+            if ti > 0 {\n+                f(transmute(T_BASE + ti));\n+            }\n+        }\n+    }\n+}\n \n-(canon_decomp, compat_decomp, gencats,\n- combines, lowerupper, upperlower) = load_unicode_data(\"UnicodeData.txt\")\n+\"\"\")\n+\n+def emit_std_norm_module(f, combine):\n+    f.write(\"pub mod normalization {\\n\");\n+    f.write(\"    use option::{Some, None};\\n\");\n+    f.write(\"    use slice::ImmutableVector;\\n\");\n \n-# Preamble\n-rf.write('''// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+    f.write(\"\"\"\n+    fn bsearch_range_value_table(c: char, r: &'static [(char, char, u8)]) -> u8 {\n+        use cmp::{Equal, Less, Greater};\n+        match r.bsearch(|&(lo, hi, _)| {\n+            if lo <= c && c <= hi { Equal }\n+            else if hi < c { Less }\n+            else { Greater }\n+        }) {\n+            Some(idx) => {\n+                let (_, _, result) = r[idx];\n+                result\n+            }\n+            None => 0\n+        }\n+    }\\n\\n\n+\"\"\")\n+\n+    f.write(\"    static combining_class_table : &'static [(char, char, u8)] = &[\\n\")\n+    ix = 0\n+    for pair in combine:\n+        f.write(ch_prefix(ix))\n+        f.write(\"(%s, %s, %s)\" % (escape_char(pair[0]), escape_char(pair[1]), pair[2]))\n+        ix += 1\n+    f.write(\"\\n    ];\\n\\n\")\n+\n+    f.write(\"    pub fn canonical_combining_class(c: char) -> u8 {\\n\"\n+        + \"        bsearch_range_value_table(c, combining_class_table)\\n\"\n+        + \"    }\\n\")\n+    f.write(\"}\\n\")\n+\n+\n+preamble = '''// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -409,23 +447,45 @@ def emit_decomp_module(f, canon, compat, combine):\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// The following code was generated by \"src/etc/unicode.py\"\n+// NOTE: The following code was generated by \"src/etc/unicode.py\", do not edit directly\n+\n+#![allow(missing_doc, non_uppercase_statics)]\n+\n+'''\n+\n+(canon_decomp, compat_decomp, gencats,\n+ combines, lowerupper, upperlower) = load_unicode_data(\"UnicodeData.txt\")\n+\n+def gen_core_unicode():\n+    r = \"core_unicode.rs\"\n+    if os.path.exists(r):\n+        os.remove(r);\n+    with open(r, \"w\") as rf:\n+        # Preamble\n+        rf.write(preamble)\n \n-#![allow(missing_doc)]\n-#![allow(non_uppercase_statics)]\n+        emit_bsearch_range_table(rf);\n+        emit_property_module(rf, \"general_category\", gencats)\n \n-''')\n+        emit_core_norm_module(rf, canon_decomp, compat_decomp)\n \n-emit_bsearch_range_table(rf);\n-emit_property_module(rf, \"general_category\", gencats)\n+        derived = load_properties(\"DerivedCoreProperties.txt\",\n+                [\"XID_Start\", \"XID_Continue\", \"Alphabetic\", \"Lowercase\", \"Uppercase\"])\n \n-emit_decomp_module(rf, canon_decomp, compat_decomp, combines)\n+        emit_property_module(rf, \"derived_property\", derived)\n \n-derived = load_properties(\"DerivedCoreProperties.txt\",\n-        [\"XID_Start\", \"XID_Continue\", \"Alphabetic\", \"Lowercase\", \"Uppercase\"])\n+        props = load_properties(\"PropList.txt\", [\"White_Space\"])\n+        emit_property_module(rf, \"property\", props)\n+        emit_conversions_module(rf, lowerupper, upperlower)\n \n-emit_property_module(rf, \"derived_property\", derived)\n+def gen_std_unicode():\n+    r = \"std_unicode.rs\"\n+    if os.path.exists(r):\n+        os.remove(r);\n+    with open(r, \"w\") as rf:\n+        # Preamble\n+        rf.write(preamble)\n+        emit_std_norm_module(rf, combines)\n \n-props = load_properties(\"PropList.txt\", [\"White_Space\"])\n-emit_property_module(rf, \"property\", props)\n-emit_conversions_module(rf, lowerupper, upperlower)\n+gen_core_unicode()\n+gen_std_unicode()"}, {"sha": "70cd46dcfa2b45ce8b9fc03685ba3c7b8226fe35", "filename": "src/libcore/any.rs", "status": "modified", "additions": 3, "deletions": 31, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -22,11 +22,8 @@\n \n use mem::{transmute, transmute_copy};\n use option::{Option, Some, None};\n-use owned::Box;\n use raw::TraitObject;\n-use result::{Result, Ok, Err};\n use intrinsics::TypeId;\n-use intrinsics;\n \n /// A type with no inhabitants\n pub enum Void { }\n@@ -117,38 +114,11 @@ impl<'a> AnyMutRefExt<'a> for &'a mut Any {\n     }\n }\n \n-/// Extension methods for an owning `Any` trait object\n-pub trait AnyOwnExt {\n-    /// Returns the boxed value if it is of type `T`, or\n-    /// `Err(Self)` if it isn't.\n-    fn move<T: 'static>(self) -> Result<Box<T>, Self>;\n-}\n-\n-impl AnyOwnExt for Box<Any> {\n-    #[inline]\n-    fn move<T: 'static>(self) -> Result<Box<T>, Box<Any>> {\n-        if self.is::<T>() {\n-            unsafe {\n-                // Get the raw representation of the trait object\n-                let to: TraitObject = transmute_copy(&self);\n-\n-                // Prevent destructor on self being run\n-                intrinsics::forget(self);\n-\n-                // Extract the data pointer\n-                Ok(transmute(to.data))\n-            }\n-        } else {\n-            Err(self)\n-        }\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use prelude::*;\n     use super::*;\n-    use owned::Box;\n+    use realstd::owned::{Box, AnyOwnExt};\n     use realstd::str::StrAllocating;\n \n     #[deriving(Eq, Show)]\n@@ -253,6 +223,8 @@ mod tests {\n \n     #[test]\n     fn any_move() {\n+        use realstd::any::Any;\n+        use realstd::result::{Ok, Err};\n         let a = box 8u as Box<Any>;\n         let b = box Test as Box<Any>;\n "}, {"sha": "934483dbed423d1337d4544fdde200820d7aa3fa", "filename": "src/libcore/char.rs", "status": "modified", "additions": 36, "deletions": 83, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -27,19 +27,25 @@\n use mem::transmute;\n use option::{None, Option, Some};\n use iter::{Iterator, range_step};\n-use unicode::{derived_property, property, general_category, decompose, conversions};\n+use unicode::{derived_property, property, general_category, conversions};\n+\n+/// Returns the canonical decomposition of a character.\n+pub use unicode::normalization::decompose_canonical;\n+/// Returns the compatibility decomposition of a character.\n+pub use unicode::normalization::decompose_compatible;\n \n #[cfg(not(test))] use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering};\n #[cfg(not(test))] use default::Default;\n \n // UTF-8 ranges and tags for encoding characters\n-static TAG_CONT: uint = 128u;\n-static MAX_ONE_B: uint = 128u;\n-static TAG_TWO_B: uint = 192u;\n-static MAX_TWO_B: uint = 2048u;\n-static TAG_THREE_B: uint = 224u;\n-static MAX_THREE_B: uint = 65536u;\n-static TAG_FOUR_B: uint = 240u;\n+static TAG_CONT: u8    = 0b1000_0000u8;\n+static TAG_TWO_B: u8   = 0b1100_0000u8;\n+static TAG_THREE_B: u8 = 0b1110_0000u8;\n+static TAG_FOUR_B: u8  = 0b1111_0000u8;\n+static MAX_ONE_B: u32   =     0x80u32;\n+static MAX_TWO_B: u32   =    0x800u32;\n+static MAX_THREE_B: u32 =  0x10000u32;\n+static MAX_FOUR_B:  u32 = 0x200000u32;\n \n /*\n     Lu  Uppercase_Letter        an uppercase letter\n@@ -284,53 +290,6 @@ pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n     }\n }\n \n-// Constants from Unicode 6.2.0 Section 3.12 Conjoining Jamo Behavior\n-static S_BASE: uint = 0xAC00;\n-static L_BASE: uint = 0x1100;\n-static V_BASE: uint = 0x1161;\n-static T_BASE: uint = 0x11A7;\n-static L_COUNT: uint = 19;\n-static V_COUNT: uint = 21;\n-static T_COUNT: uint = 28;\n-static N_COUNT: uint = (V_COUNT * T_COUNT);\n-static S_COUNT: uint = (L_COUNT * N_COUNT);\n-\n-// Decompose a precomposed Hangul syllable\n-fn decompose_hangul(s: char, f: |char|) {\n-    let si = s as uint - S_BASE;\n-\n-    let li = si / N_COUNT;\n-    unsafe {\n-        f(transmute((L_BASE + li) as u32));\n-\n-        let vi = (si % N_COUNT) / T_COUNT;\n-        f(transmute((V_BASE + vi) as u32));\n-\n-        let ti = si % T_COUNT;\n-        if ti > 0 {\n-            f(transmute((T_BASE + ti) as u32));\n-        }\n-    }\n-}\n-\n-/// Returns the canonical decomposition of a character\n-pub fn decompose_canonical(c: char, f: |char|) {\n-    if (c as uint) < S_BASE || (c as uint) >= (S_BASE + S_COUNT) {\n-        decompose::canonical(c, f);\n-    } else {\n-        decompose_hangul(c, f);\n-    }\n-}\n-\n-/// Returns the compatibility decomposition of a character\n-pub fn decompose_compatible(c: char, f: |char|) {\n-    if (c as uint) < S_BASE || (c as uint) >= (S_BASE + S_COUNT) {\n-        decompose::compatibility(c, f);\n-    } else {\n-        decompose_hangul(c, f);\n-    }\n-}\n-\n ///\n /// Returns the hexadecimal Unicode escape of a `char`\n ///\n@@ -386,12 +345,7 @@ pub fn escape_default(c: char, f: |char|) {\n \n /// Returns the amount of bytes this `char` would need if encoded in UTF-8\n pub fn len_utf8_bytes(c: char) -> uint {\n-    static MAX_ONE_B:   uint = 128u;\n-    static MAX_TWO_B:   uint = 2048u;\n-    static MAX_THREE_B: uint = 65536u;\n-    static MAX_FOUR_B:  uint = 2097152u;\n-\n-    let code = c as uint;\n+    let code = c as u32;\n     match () {\n         _ if code < MAX_ONE_B   => 1u,\n         _ if code < MAX_TWO_B   => 2u,\n@@ -606,41 +560,40 @@ impl Char for char {\n \n     fn len_utf8_bytes(&self) -> uint { len_utf8_bytes(*self) }\n \n-    fn encode_utf8(&self, dst: &mut [u8]) -> uint {\n-        let code = *self as uint;\n+    fn encode_utf8<'a>(&self, dst: &'a mut [u8]) -> uint {\n+        let code = *self as u32;\n         if code < MAX_ONE_B {\n             dst[0] = code as u8;\n-            return 1;\n+            1\n         } else if code < MAX_TWO_B {\n-            dst[0] = (code >> 6u & 31u | TAG_TWO_B) as u8;\n-            dst[1] = (code & 63u | TAG_CONT) as u8;\n-            return 2;\n+            dst[0] = (code >> 6u & 0x1F_u32) as u8 | TAG_TWO_B;\n+            dst[1] = (code & 0x3F_u32) as u8 | TAG_CONT;\n+            2\n         } else if code < MAX_THREE_B {\n-            dst[0] = (code >> 12u & 15u | TAG_THREE_B) as u8;\n-            dst[1] = (code >> 6u & 63u | TAG_CONT) as u8;\n-            dst[2] = (code & 63u | TAG_CONT) as u8;\n-            return 3;\n+            dst[0] = (code >> 12u & 0x0F_u32) as u8 | TAG_THREE_B;\n+            dst[1] = (code >>  6u & 0x3F_u32) as u8 | TAG_CONT;\n+            dst[2] = (code & 0x3F_u32) as u8 | TAG_CONT;\n+            3\n         } else {\n-            dst[0] = (code >> 18u & 7u | TAG_FOUR_B) as u8;\n-            dst[1] = (code >> 12u & 63u | TAG_CONT) as u8;\n-            dst[2] = (code >> 6u & 63u | TAG_CONT) as u8;\n-            dst[3] = (code & 63u | TAG_CONT) as u8;\n-            return 4;\n+            dst[0] = (code >> 18u & 0x07_u32) as u8 | TAG_FOUR_B;\n+            dst[1] = (code >> 12u & 0x3F_u32) as u8 | TAG_CONT;\n+            dst[2] = (code >>  6u & 0x3F_u32) as u8 | TAG_CONT;\n+            dst[3] = (code & 0x3F_u32) as u8 | TAG_CONT;\n+            4\n         }\n     }\n \n     fn encode_utf16(&self, dst: &mut [u16]) -> uint {\n-        let mut ch = *self as uint;\n-        if (ch & 0xFFFF_u) == ch {\n-            // The BMP falls through (assuming non-surrogate, as it\n-            // should)\n-            assert!(ch <= 0xD7FF_u || ch >= 0xE000_u);\n+        let mut ch = *self as u32;\n+        if (ch & 0xFFFF_u32) == ch {\n+            // The BMP falls through (assuming non-surrogate, as it should)\n+            assert!(ch <= 0xD7FF_u32 || ch >= 0xE000_u32);\n             dst[0] = ch as u16;\n             1\n         } else {\n             // Supplementary planes break into surrogates.\n-            assert!(ch >= 0x1_0000_u && ch <= 0x10_FFFF_u);\n-            ch -= 0x1_0000_u;\n+            assert!(ch >= 0x1_0000_u32 && ch <= 0x10_FFFF_u32);\n+            ch -= 0x1_0000_u32;\n             dst[0] = 0xD800_u16 | ((ch >> 10) as u16);\n             dst[1] = 0xDC00_u16 | ((ch as u16) & 0x3FF_u16);\n             2"}, {"sha": "cd66beabc12de3fce964966012ded57abb79a347", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -21,8 +21,6 @@ the `clone` method.\n \n */\n \n-use owned::Box;\n-\n /// A common trait for cloning an object.\n pub trait Clone {\n     /// Returns a copy of the value. The contents of owned pointers\n@@ -41,18 +39,6 @@ pub trait Clone {\n     }\n }\n \n-impl<T: Clone> Clone for Box<T> {\n-    /// Return a copy of the owned box.\n-    #[inline]\n-    fn clone(&self) -> Box<T> { box {(**self).clone()} }\n-\n-    /// Perform copy-assignment from `source` by reusing the existing allocation.\n-    #[inline]\n-    fn clone_from(&mut self, source: &Box<T>) {\n-        (**self).clone_from(&(**source));\n-    }\n-}\n-\n impl<T> Clone for @T {\n     /// Return a shallow copy of the managed box.\n     #[inline]\n@@ -129,12 +115,22 @@ extern_fn_clone!(A, B, C, D, E, F, G, H)\n #[cfg(test)]\n mod test {\n     use prelude::*;\n-    use owned::Box;\n+    use realstd::owned::Box;\n+\n+    fn realclone<T: ::realstd::clone::Clone>(t: &T) -> T {\n+        use realstd::clone::Clone;\n+        t.clone()\n+    }\n+\n+    fn realclone_from<T: ::realstd::clone::Clone>(t1: &mut T, t2: &T) {\n+        use realstd::clone::Clone;\n+        t1.clone_from(t2)\n+    }\n \n     #[test]\n     fn test_owned_clone() {\n         let a = box 5i;\n-        let b: Box<int> = a.clone();\n+        let b: Box<int> = realclone(&a);\n         assert_eq!(a, b);\n     }\n \n@@ -157,7 +153,7 @@ mod test {\n     fn test_clone_from() {\n         let a = box 5;\n         let mut b = box 10;\n-        b.clone_from(&a);\n+        realclone_from(&mut b, &a);\n         assert_eq!(*b, 5);\n     }\n "}, {"sha": "f2b1c1cd4cde699af5d80a13f3c799b219536e38", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -193,7 +193,6 @@ pub fn max<T: TotalOrd>(v1: T, v2: T) -> T {\n #[cfg(not(test))]\n mod impls {\n     use cmp::{Ord, TotalOrd, Eq, TotalEq, Ordering};\n-    use owned::Box;\n \n     // & pointers\n     impl<'a, T: Eq> Eq for &'a T {\n@@ -240,29 +239,6 @@ mod impls {\n         fn cmp(&self, other: &@T) -> Ordering { (**self).cmp(*other) }\n     }\n     impl<T: TotalEq> TotalEq for @T {}\n-\n-    // box pointers\n-    impl<T:Eq> Eq for Box<T> {\n-        #[inline]\n-        fn eq(&self, other: &Box<T>) -> bool { *(*self) == *(*other) }\n-        #[inline]\n-        fn ne(&self, other: &Box<T>) -> bool { *(*self) != *(*other) }\n-    }\n-    impl<T:Ord> Ord for Box<T> {\n-        #[inline]\n-        fn lt(&self, other: &Box<T>) -> bool { *(*self) < *(*other) }\n-        #[inline]\n-        fn le(&self, other: &Box<T>) -> bool { *(*self) <= *(*other) }\n-        #[inline]\n-        fn ge(&self, other: &Box<T>) -> bool { *(*self) >= *(*other) }\n-        #[inline]\n-        fn gt(&self, other: &Box<T>) -> bool { *(*self) > *(*other) }\n-    }\n-    impl<T: TotalOrd> TotalOrd for Box<T> {\n-        #[inline]\n-        fn cmp(&self, other: &Box<T>) -> Ordering { (**self).cmp(*other) }\n-    }\n-    impl<T: TotalEq> TotalEq for Box<T> {}\n }\n \n #[cfg(test)]"}, {"sha": "af65fcc5a779da550cbf2410c9b6b732148bfe1f", "filename": "src/libcore/default.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -10,8 +10,6 @@\n \n //! The `Default` trait for types which may have meaningful default values\n \n-use owned::Box;\n-\n /// A trait that types which have a useful default value should implement.\n pub trait Default {\n     /// Return the \"default value\" for a type.\n@@ -21,7 +19,3 @@ pub trait Default {\n impl<T: Default + 'static> Default for @T {\n     fn default() -> @T { @Default::default() }\n }\n-\n-impl<T: Default> Default for Box<T> {\n-    fn default() -> Box<T> { box Default::default() }\n-}"}, {"sha": "f6a77d6decae048c278ef1de1d7fac4695c0d7f6", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -2334,7 +2334,7 @@ mod tests {\n     use realstd::num;\n \n     use cmp;\n-    use owned::Box;\n+    use realstd::owned::Box;\n     use uint;\n \n     #[test]"}, {"sha": "97b086a093d2a11a8389d1cc70e5dc6ae4daa79d", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -30,7 +30,6 @@\n #[cfg(test)] pub use cmp = realcore::cmp;\n #[cfg(test)] pub use kinds = realcore::kinds;\n #[cfg(test)] pub use ops = realcore::ops;\n-#[cfg(test)] pub use owned = realcore::owned;\n #[cfg(test)] pub use ty = realcore::ty;\n \n #[cfg(not(test))]\n@@ -73,7 +72,6 @@ pub mod ptr;\n #[cfg(not(test))] pub mod ops;\n #[cfg(not(test))] pub mod ty;\n #[cfg(not(test))] pub mod cmp;\n-#[cfg(not(test))] pub mod owned;\n pub mod clone;\n pub mod default;\n pub mod container;\n@@ -95,6 +93,9 @@ pub mod slice;\n pub mod str;\n pub mod tuple;\n \n+#[cfg(stage0, not(test))]\n+pub mod owned;\n+\n mod failure;\n \n // FIXME: this module should not exist. Once owned allocations are no longer a"}, {"sha": "c5c6d751777288618469afdbf6fc8bb6568e2fe0", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -380,7 +380,7 @@ mod tests {\n     use mem::*;\n     use option::{Some,None};\n     use realstd::str::StrAllocating;\n-    use owned::Box;\n+    use realstd::owned::Box;\n     use raw;\n \n     #[test]"}, {"sha": "3af12c5154c29d5f08847f5ca209ff53f477781d", "filename": "src/libcore/owned.rs", "status": "modified", "additions": 74, "deletions": 11, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibcore%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibcore%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fowned.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -10,10 +10,14 @@\n \n //! Operations on unique pointer types\n \n-// FIXME: this module should not exist in libcore. It must currently because the\n-//        Box implementation is quite ad-hoc in the compiler. Once there is\n-//        proper support in the compiler this type will be able to be defined in\n-//        its own module.\n+use any::{Any, AnyRefExt};\n+use clone::Clone;\n+use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering};\n+use default::Default;\n+use intrinsics;\n+use mem;\n+use raw::TraitObject;\n+use result::{Ok, Err, Result};\n \n /// A value that represents the global exchange heap. This is the default\n /// place that the `box` keyword allocates into when no place is supplied.\n@@ -23,16 +27,75 @@\n ///     let foo = box(HEAP) Bar::new(...);\n ///     let foo = box Bar::new(...);\n #[lang=\"exchange_heap\"]\n-#[cfg(not(test))]\n-pub static HEAP: () = ();\n-\n-#[cfg(test)]\n pub static HEAP: () = ();\n \n /// A type that represents a uniquely-owned value.\n #[lang=\"owned_box\"]\n-#[cfg(not(test))]\n pub struct Box<T>(*T);\n \n-#[cfg(test)]\n-pub struct Box<T>(*T);\n+impl<T: Default> Default for Box<T> {\n+    fn default() -> Box<T> { box Default::default() }\n+}\n+\n+impl<T: Clone> Clone for Box<T> {\n+    /// Return a copy of the owned box.\n+    #[inline]\n+    fn clone(&self) -> Box<T> { box {(**self).clone()} }\n+\n+    /// Perform copy-assignment from `source` by reusing the existing allocation.\n+    #[inline]\n+    fn clone_from(&mut self, source: &Box<T>) {\n+        (**self).clone_from(&(**source));\n+    }\n+}\n+\n+// box pointers\n+impl<T:Eq> Eq for Box<T> {\n+    #[inline]\n+    fn eq(&self, other: &Box<T>) -> bool { *(*self) == *(*other) }\n+    #[inline]\n+    fn ne(&self, other: &Box<T>) -> bool { *(*self) != *(*other) }\n+}\n+impl<T:Ord> Ord for Box<T> {\n+    #[inline]\n+    fn lt(&self, other: &Box<T>) -> bool { *(*self) < *(*other) }\n+    #[inline]\n+    fn le(&self, other: &Box<T>) -> bool { *(*self) <= *(*other) }\n+    #[inline]\n+    fn ge(&self, other: &Box<T>) -> bool { *(*self) >= *(*other) }\n+    #[inline]\n+    fn gt(&self, other: &Box<T>) -> bool { *(*self) > *(*other) }\n+}\n+impl<T: TotalOrd> TotalOrd for Box<T> {\n+    #[inline]\n+    fn cmp(&self, other: &Box<T>) -> Ordering { (**self).cmp(*other) }\n+}\n+impl<T: TotalEq> TotalEq for Box<T> {}\n+\n+/// Extension methods for an owning `Any` trait object\n+pub trait AnyOwnExt {\n+    /// Returns the boxed value if it is of type `T`, or\n+    /// `Err(Self)` if it isn't.\n+    fn move<T: 'static>(self) -> Result<Box<T>, Self>;\n+}\n+\n+impl AnyOwnExt for Box<Any> {\n+    #[inline]\n+    fn move<T: 'static>(self) -> Result<Box<T>, Box<Any>> {\n+        if self.is::<T>() {\n+            unsafe {\n+                // Get the raw representation of the trait object\n+                let to: TraitObject =\n+                    *mem::transmute::<&Box<Any>, &TraitObject>(&self);\n+\n+                // Prevent destructor on self being run\n+                intrinsics::forget(self);\n+\n+                // Extract the data pointer\n+                Ok(mem::transmute(to.data))\n+            }\n+        } else {\n+            Err(self)\n+        }\n+    }\n+}"}, {"sha": "1481759297868a8be3095241f6c34783f75277ae", "filename": "src/libcore/str.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -1725,6 +1725,7 @@ impl<'a> StrSlice<'a> for &'a str {\n     #[inline]\n     fn is_char_boundary(&self, index: uint) -> bool {\n         if index == self.len() { return true; }\n+        if index > self.len() { return false; }\n         let b = self[index];\n         return b < 128u8 || b >= 192u8;\n     }"}, {"sha": "242672de2967aaece1f7a90286d14ec2e02b313a", "filename": "src/libcore/unicode.rs", "status": "modified", "additions": 54, "deletions": 7, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibcore%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibcore%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// The following code was generated by \"src/etc/unicode.py\"\n+// NOTE: The following code was generated by \"src/etc/unicode.py\", do not edit directly\n \n #![allow(missing_doc, non_uppercase_statics)]\n \n+\n fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n     use cmp::{Equal, Less, Greater};\n     use slice::ImmutableVector;\n@@ -102,7 +103,8 @@ pub mod general_category {\n     }\n \n }\n-pub mod decompose {\n+\n+pub mod normalization {\n     use option::Option;\n     use option::{Some, None};\n     use slice::ImmutableVector;\n@@ -123,7 +125,6 @@ pub mod decompose {\n     }\n \n \n-\n     // Canonical decompositions\n     static canonical_table : &'static [(char, &'static [char])] = &[\n         ('\\xc0', &['\\x41', '\\u0300']), ('\\xc1', &['\\x41', '\\u0301']), ('\\xc2', &['\\x41', '\\u0302']),\n@@ -2120,14 +2121,24 @@ pub mod decompose {\n         &['\\u53ef'])\n     ];\n \n-    pub fn canonical(c: char, i: |char|) { d(c, i, false); }\n \n-    pub fn compatibility(c: char, i: |char|) { d(c, i, true); }\n+    pub fn decompose_canonical(c: char, i: |char|) { d(c, i, false); }\n+\n+    pub fn decompose_compatible(c: char, i: |char|) { d(c, i, true); }\n \n     fn d(c: char, i: |char|, k: bool) {\n         use iter::Iterator;\n+\n+        // 7-bit ASCII never decomposes\n         if c <= '\\x7f' { i(c); return; }\n \n+        // Perform decomposition for Hangul\n+        if (c as u32) >= S_BASE && (c as u32) < (S_BASE + S_COUNT) {\n+            decompose_hangul(c, i);\n+            return;\n+        }\n+\n+        // First check the canonical decompositions\n         match bsearch_table(c, canonical_table) {\n             Some(canon) => {\n                 for x in canon.iter() {\n@@ -2138,8 +2149,10 @@ pub mod decompose {\n             None => ()\n         }\n \n+        // Bottom out if we're not doing compat.\n         if !k { i(c); return; }\n \n+        // Then check the compatibility decompositions\n         match bsearch_table(c, compatibility_table) {\n             Some(compat) => {\n                 for x in compat.iter() {\n@@ -2150,8 +2163,40 @@ pub mod decompose {\n             None => ()\n         }\n \n+        // Finally bottom out.\n         i(c);\n     }\n+\n+    // Constants from Unicode 6.2.0 Section 3.12 Conjoining Jamo Behavior\n+    static S_BASE: u32 = 0xAC00;\n+    static L_BASE: u32 = 0x1100;\n+    static V_BASE: u32 = 0x1161;\n+    static T_BASE: u32 = 0x11A7;\n+    static L_COUNT: u32 = 19;\n+    static V_COUNT: u32 = 21;\n+    static T_COUNT: u32 = 28;\n+    static N_COUNT: u32 = (V_COUNT * T_COUNT);\n+    static S_COUNT: u32 = (L_COUNT * N_COUNT);\n+\n+    // Decompose a precomposed Hangul syllable\n+    fn decompose_hangul(s: char, f: |char|) {\n+        use mem::transmute;\n+\n+        let si = s as u32 - S_BASE;\n+\n+        let li = si / N_COUNT;\n+        unsafe {\n+            f(transmute(L_BASE + li));\n+\n+            let vi = (si % N_COUNT) / T_COUNT;\n+            f(transmute(V_BASE + vi));\n+\n+            let ti = si % T_COUNT;\n+            if ti > 0 {\n+                f(transmute(T_BASE + ti));\n+            }\n+        }\n+    }\n }\n \n pub mod derived_property {\n@@ -3968,6 +4013,7 @@ pub mod derived_property {\n     pub fn XID_Start(c: char) -> bool {\n         super::bsearch_range_table(c, XID_Start_table)\n     }\n+\n }\n \n pub mod property {\n@@ -3983,6 +4029,7 @@ pub mod property {\n     pub fn White_Space(c: char) -> bool {\n         super::bsearch_range_table(c, White_Space_table)\n     }\n+\n }\n \n pub mod conversions {\n@@ -4501,7 +4548,7 @@ pub mod conversions {\n         ('\\U00010426', '\\U0001044e'), ('\\U00010427', '\\U0001044f')\n     ];\n \n-   static LlLu_table : &'static [(char, char)] = &[\n+    static LlLu_table : &'static [(char, char)] = &[\n         ('\\x61', '\\x41'), ('\\x62', '\\x42'),\n         ('\\x63', '\\x43'), ('\\x64', '\\x44'),\n         ('\\x65', '\\x45'), ('\\x66', '\\x46'),"}, {"sha": "1edd99c1d7dcc98f4fc1b0934bd35b177368ae4c", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -173,7 +173,7 @@ pub use funcs::bsd43::{shutdown};\n #[cfg(unix)] pub use consts::os::posix88::{EADDRINUSE, ENOENT, EISDIR, EAGAIN, EWOULDBLOCK};\n #[cfg(unix)] pub use consts::os::posix88::{ECANCELED, SIGINT, EINPROGRESS};\n #[cfg(unix)] pub use consts::os::posix88::{SIGTERM, SIGKILL, SIGPIPE, PROT_NONE};\n-#[cfg(unix)] pub use consts::os::posix01::{SIG_IGN, WNOHANG};\n+#[cfg(unix)] pub use consts::os::posix01::{SIG_IGN};\n #[cfg(unix)] pub use consts::os::bsd44::{AF_UNIX};\n \n #[cfg(unix)] pub use types::os::common::posix01::{pthread_t, timespec, timezone};\n@@ -2473,8 +2473,6 @@ pub mod consts {\n \n             pub static CLOCK_REALTIME: c_int = 0;\n             pub static CLOCK_MONOTONIC: c_int = 1;\n-\n-            pub static WNOHANG: c_int = 1;\n         }\n         pub mod posix08 {\n         }\n@@ -2924,8 +2922,6 @@ pub mod consts {\n \n             pub static CLOCK_REALTIME: c_int = 0;\n             pub static CLOCK_MONOTONIC: c_int = 4;\n-\n-            pub static WNOHANG: c_int = 1;\n         }\n         pub mod posix08 {\n         }\n@@ -3313,8 +3309,6 @@ pub mod consts {\n             pub static PTHREAD_CREATE_JOINABLE: c_int = 1;\n             pub static PTHREAD_CREATE_DETACHED: c_int = 2;\n             pub static PTHREAD_STACK_MIN: size_t = 8192;\n-\n-            pub static WNOHANG: c_int = 1;\n         }\n         pub mod posix08 {\n         }\n@@ -3980,16 +3974,6 @@ pub mod funcs {\n             }\n         }\n \n-        pub mod wait {\n-            use types::os::arch::c95::{c_int};\n-            use types::os::arch::posix88::{pid_t};\n-\n-            extern {\n-                pub fn waitpid(pid: pid_t, status: *mut c_int, options: c_int)\n-                               -> pid_t;\n-            }\n-        }\n-\n         pub mod glob {\n             use types::os::arch::c95::{c_char, c_int};\n             use types::os::common::posix01::{glob_t};"}, {"sha": "767090a10cda222e4584f9880f9973e29dddc8fc", "filename": "src/libnative/io/c_unix.rs", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibnative%2Fio%2Fc_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibnative%2Fio%2Fc_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_unix.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -10,7 +10,12 @@\n \n //! C definitions used by libnative that don't belong in liblibc\n \n+#![allow(dead_code)]\n+\n pub use self::select::fd_set;\n+pub use self::signal::{sigaction, siginfo, sigset_t};\n+pub use self::signal::{SA_ONSTACK, SA_RESTART, SA_RESETHAND, SA_NOCLDSTOP};\n+pub use self::signal::{SA_NODEFER, SA_NOCLDWAIT, SA_SIGINFO, SIGCHLD};\n \n use libc;\n \n@@ -34,6 +39,8 @@ pub static MSG_DONTWAIT: libc::c_int = 0x80;\n #[cfg(target_os = \"android\")]\n pub static MSG_DONTWAIT: libc::c_int = 0x40;\n \n+pub static WNOHANG: libc::c_int = 1;\n+\n extern {\n     pub fn gettimeofday(timeval: *mut libc::timeval,\n                         tzp: *libc::c_void) -> libc::c_int;\n@@ -49,6 +56,17 @@ extern {\n                       optlen: *mut libc::socklen_t) -> libc::c_int;\n     pub fn ioctl(fd: libc::c_int, req: libc::c_ulong, ...) -> libc::c_int;\n \n+\n+    pub fn waitpid(pid: libc::pid_t, status: *mut libc::c_int,\n+                   options: libc::c_int) -> libc::pid_t;\n+\n+    pub fn sigaction(signum: libc::c_int,\n+                     act: *sigaction,\n+                     oldact: *mut sigaction) -> libc::c_int;\n+\n+    pub fn sigaddset(set: *mut sigset_t, signum: libc::c_int) -> libc::c_int;\n+    pub fn sigdelset(set: *mut sigset_t, signum: libc::c_int) -> libc::c_int;\n+    pub fn sigemptyset(set: *mut sigset_t) -> libc::c_int;\n }\n \n #[cfg(target_os = \"macos\")]\n@@ -81,3 +99,94 @@ mod select {\n         set.fds_bits[fd / uint::BITS] |= 1 << (fd % uint::BITS);\n     }\n }\n+\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"android\")]\n+mod signal {\n+    use libc;\n+\n+    pub static SA_NOCLDSTOP: libc::c_ulong = 0x00000001;\n+    pub static SA_NOCLDWAIT: libc::c_ulong = 0x00000002;\n+    pub static SA_NODEFER: libc::c_ulong = 0x40000000;\n+    pub static SA_ONSTACK: libc::c_ulong = 0x08000000;\n+    pub static SA_RESETHAND: libc::c_ulong = 0x80000000;\n+    pub static SA_RESTART: libc::c_ulong = 0x10000000;\n+    pub static SA_SIGINFO: libc::c_ulong = 0x00000004;\n+    pub static SIGCHLD: libc::c_int = 17;\n+\n+    // This definition is not as accurate as it could be, {pid, uid, status} is\n+    // actually a giant union. Currently we're only interested in these fields,\n+    // however.\n+    pub struct siginfo {\n+        si_signo: libc::c_int,\n+        si_errno: libc::c_int,\n+        si_code: libc::c_int,\n+        pub pid: libc::pid_t,\n+        pub uid: libc::uid_t,\n+        pub status: libc::c_int,\n+    }\n+\n+    pub struct sigaction {\n+        pub sa_handler: extern fn(libc::c_int),\n+        pub sa_mask: sigset_t,\n+        pub sa_flags: libc::c_ulong,\n+        sa_restorer: *mut libc::c_void,\n+    }\n+\n+    #[cfg(target_word_size = \"32\")]\n+    pub struct sigset_t {\n+        __val: [libc::c_ulong, ..32],\n+    }\n+    #[cfg(target_word_size = \"64\")]\n+    pub struct sigset_t {\n+        __val: [libc::c_ulong, ..16],\n+    }\n+}\n+\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+mod signal {\n+    use libc;\n+\n+    pub static SA_ONSTACK: libc::c_int = 0x0001;\n+    pub static SA_RESTART: libc::c_int = 0x0002;\n+    pub static SA_RESETHAND: libc::c_int = 0x0004;\n+    pub static SA_NOCLDSTOP: libc::c_int = 0x0008;\n+    pub static SA_NODEFER: libc::c_int = 0x0010;\n+    pub static SA_NOCLDWAIT: libc::c_int = 0x0020;\n+    pub static SA_SIGINFO: libc::c_int = 0x0040;\n+    pub static SIGCHLD: libc::c_int = 20;\n+\n+    #[cfg(target_os = \"macos\")]\n+    pub type sigset_t = u32;\n+    #[cfg(target_os = \"freebsd\")]\n+    pub struct sigset_t {\n+        bits: [u32, ..4],\n+    }\n+\n+    // This structure has more fields, but we're not all that interested in\n+    // them.\n+    pub struct siginfo {\n+        pub si_signo: libc::c_int,\n+        pub si_errno: libc::c_int,\n+        pub si_code: libc::c_int,\n+        pub pid: libc::pid_t,\n+        pub uid: libc::uid_t,\n+        pub status: libc::c_int,\n+    }\n+\n+    #[cfg(target_os = \"macos\")]\n+    pub struct sigaction {\n+        pub sa_handler: extern fn(libc::c_int),\n+        sa_tramp: *mut libc::c_void,\n+        pub sa_mask: sigset_t,\n+        pub sa_flags: libc::c_int,\n+    }\n+\n+    #[cfg(target_os = \"freebsd\")]\n+    pub struct sigaction {\n+        pub sa_handler: extern fn(libc::c_int),\n+        pub sa_flags: libc::c_int,\n+        pub sa_mask: sigset_t,\n+    }\n+}"}, {"sha": "2260d74e1617705c3b3fcfc423f47b0f37d661ec", "filename": "src/libnative/io/helper_thread.rs", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibnative%2Fio%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibnative%2Fio%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fhelper_thread.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -0,0 +1,205 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementation of the helper thread for the timer module\n+//!\n+//! This module contains the management necessary for the timer worker thread.\n+//! This thread is responsible for performing the send()s on channels for timers\n+//! that are using channels instead of a blocking call.\n+//!\n+//! The timer thread is lazily initialized, and it's shut down via the\n+//! `shutdown` function provided. It must be maintained as an invariant that\n+//! `shutdown` is only called when the entire program is finished. No new timers\n+//! can be created in the future and there must be no active timers at that\n+//! time.\n+\n+#![macro_escape]\n+\n+use std::mem;\n+use std::rt::bookkeeping;\n+use std::rt;\n+use std::ty::Unsafe;\n+use std::unstable::mutex::StaticNativeMutex;\n+\n+use task;\n+\n+/// A structure for management of a helper thread.\n+///\n+/// This is generally a static structure which tracks the lifetime of a helper\n+/// thread.\n+///\n+/// The fields of this helper are all public, but they should not be used, this\n+/// is for static initialization.\n+pub struct Helper<M> {\n+    /// Internal lock which protects the remaining fields\n+    pub lock: StaticNativeMutex,\n+\n+    // You'll notice that the remaining fields are Unsafe<T>, and this is\n+    // because all helper thread operations are done through &self, but we need\n+    // these to be mutable (once `lock` is held).\n+\n+    /// Lazily allocated channel to send messages to the helper thread.\n+    pub chan: Unsafe<*mut Sender<M>>,\n+\n+    /// OS handle used to wake up a blocked helper thread\n+    pub signal: Unsafe<uint>,\n+\n+    /// Flag if this helper thread has booted and been initialized yet.\n+    pub initialized: Unsafe<bool>,\n+}\n+\n+macro_rules! helper_init( (static mut $name:ident: Helper<$m:ty>) => (\n+    static mut $name: Helper<$m> = Helper {\n+        lock: ::std::unstable::mutex::NATIVE_MUTEX_INIT,\n+        chan: ::std::ty::Unsafe {\n+            value: 0 as *mut Sender<$m>,\n+            marker1: ::std::kinds::marker::InvariantType,\n+        },\n+        signal: ::std::ty::Unsafe {\n+            value: 0,\n+            marker1: ::std::kinds::marker::InvariantType,\n+        },\n+        initialized: ::std::ty::Unsafe {\n+            value: false,\n+            marker1: ::std::kinds::marker::InvariantType,\n+        },\n+    };\n+) )\n+\n+impl<M: Send> Helper<M> {\n+    /// Lazily boots a helper thread, becoming a no-op if the helper has already\n+    /// been spawned.\n+    ///\n+    /// This function will check to see if the thread has been initialized, and\n+    /// if it has it returns quickly. If initialization has not happened yet,\n+    /// the closure `f` will be run (inside of the initialization lock) and\n+    /// passed to the helper thread in a separate task.\n+    ///\n+    /// This function is safe to be called many times.\n+    pub fn boot<T: Send>(&'static self,\n+                         f: || -> T,\n+                         helper: fn(imp::signal, Receiver<M>, T)) {\n+        unsafe {\n+            let _guard = self.lock.lock();\n+            if !*self.initialized.get() {\n+                let (tx, rx) = channel();\n+                *self.chan.get() = mem::transmute(box tx);\n+                let (receive, send) = imp::new();\n+                *self.signal.get() = send as uint;\n+\n+                let t = f();\n+                task::spawn(proc() {\n+                    bookkeeping::decrement();\n+                    helper(receive, rx, t);\n+                    self.lock.lock().signal()\n+                });\n+\n+                rt::at_exit(proc() { self.shutdown() });\n+                *self.initialized.get() = true;\n+            }\n+        }\n+    }\n+\n+    /// Sends a message to a spawned worker thread.\n+    ///\n+    /// This is only valid if the worker thread has previously booted\n+    pub fn send(&'static self, msg: M) {\n+        unsafe {\n+            let _guard = self.lock.lock();\n+\n+            // Must send and *then* signal to ensure that the child receives the\n+            // message. Otherwise it could wake up and go to sleep before we\n+            // send the message.\n+            assert!(!self.chan.get().is_null());\n+            (**self.chan.get()).send(msg);\n+            imp::signal(*self.signal.get() as imp::signal);\n+        }\n+    }\n+\n+    fn shutdown(&'static self) {\n+        unsafe {\n+            // Shut down, but make sure this is done inside our lock to ensure\n+            // that we'll always receive the exit signal when the thread\n+            // returns.\n+            let guard = self.lock.lock();\n+\n+            // Close the channel by destroying it\n+            let chan: Box<Sender<M>> = mem::transmute(*self.chan.get());\n+            *self.chan.get() = 0 as *mut Sender<M>;\n+            drop(chan);\n+            imp::signal(*self.signal.get() as imp::signal);\n+\n+            // Wait for the child to exit\n+            guard.wait();\n+            drop(guard);\n+\n+            // Clean up after ourselves\n+            self.lock.destroy();\n+            imp::close(*self.signal.get() as imp::signal);\n+            *self.signal.get() = 0;\n+        }\n+    }\n+}\n+\n+#[cfg(unix)]\n+mod imp {\n+    use libc;\n+    use std::os;\n+\n+    use io::file::FileDesc;\n+\n+    pub type signal = libc::c_int;\n+\n+    pub fn new() -> (signal, signal) {\n+        let pipe = os::pipe();\n+        (pipe.input, pipe.out)\n+    }\n+\n+    pub fn signal(fd: libc::c_int) {\n+        FileDesc::new(fd, false).inner_write([0]).unwrap();\n+    }\n+\n+    pub fn close(fd: libc::c_int) {\n+        let _fd = FileDesc::new(fd, true);\n+    }\n+}\n+\n+#[cfg(windows)]\n+mod imp {\n+    use libc::{BOOL, LPCSTR, HANDLE, LPSECURITY_ATTRIBUTES, CloseHandle};\n+    use std::ptr;\n+    use libc;\n+\n+    pub type signal = HANDLE;\n+\n+    pub fn new() -> (HANDLE, HANDLE) {\n+        unsafe {\n+            let handle = CreateEventA(ptr::mut_null(), libc::FALSE, libc::FALSE,\n+                                      ptr::null());\n+            (handle, handle)\n+        }\n+    }\n+\n+    pub fn signal(handle: HANDLE) {\n+        assert!(unsafe { SetEvent(handle) != 0 });\n+    }\n+\n+    pub fn close(handle: HANDLE) {\n+        assert!(unsafe { CloseHandle(handle) != 0 });\n+    }\n+\n+    extern \"system\" {\n+        fn CreateEventA(lpSecurityAttributes: LPSECURITY_ATTRIBUTES,\n+                        bManualReset: BOOL,\n+                        bInitialState: BOOL,\n+                        lpName: LPCSTR) -> HANDLE;\n+        fn SetEvent(hEvent: HANDLE) -> BOOL;\n+    }\n+}"}, {"sha": "a9aca656319efa7a4263131246c4f3412023c0ad", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -40,6 +40,8 @@ use ai = std::io::net::addrinfo;\n pub use self::file::FileDesc;\n pub use self::process::Process;\n \n+mod helper_thread;\n+\n // Native I/O implementations\n pub mod addrinfo;\n pub mod net;\n@@ -75,8 +77,6 @@ pub mod pipe;\n #[cfg(unix)]    #[path = \"c_unix.rs\"]  mod c;\n #[cfg(windows)] #[path = \"c_win32.rs\"] mod c;\n \n-mod timer_helper;\n-\n pub type IoResult<T> = Result<T, IoError>;\n \n fn unimpl() -> IoError {"}, {"sha": "799db64e6889775878386af1bf26ceb6b5913662", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 311, "deletions": 52, "changes": 363, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -8,20 +8,27 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io;\n use libc::{pid_t, c_void, c_int};\n use libc;\n+use std::io;\n+use std::mem;\n use std::os;\n use std::ptr;\n use std::rt::rtio;\n use p = std::io::process;\n \n+\n use super::IoResult;\n use super::file;\n+use super::util;\n \n-#[cfg(windows)] use std::mem;\n #[cfg(windows)] use std::strbuf::StrBuf;\n-#[cfg(not(windows))] use super::retry;\n+#[cfg(unix)] use super::c;\n+#[cfg(unix)] use super::retry;\n+#[cfg(unix)] use io::helper_thread::Helper;\n+\n+#[cfg(unix)]\n+helper_init!(static mut HELPER: Helper<Req>)\n \n /**\n  * A value representing a child process.\n@@ -44,6 +51,14 @@ pub struct Process {\n \n     /// Manually delivered signal\n     exit_signal: Option<int>,\n+\n+    /// Deadline after which wait() will return\n+    deadline: u64,\n+}\n+\n+#[cfg(unix)]\n+enum Req {\n+    NewChild(libc::pid_t, Sender<p::ProcessExit>, u64),\n }\n \n impl Process {\n@@ -116,6 +131,7 @@ impl Process {\n                         handle: res.handle,\n                         exit_code: None,\n                         exit_signal: None,\n+                        deadline: 0,\n                     },\n                     ret_io))\n             }\n@@ -131,11 +147,15 @@ impl Process {\n impl rtio::RtioProcess for Process {\n     fn id(&self) -> pid_t { self.pid }\n \n-    fn wait(&mut self) -> p::ProcessExit {\n+    fn set_timeout(&mut self, timeout: Option<u64>) {\n+        self.deadline = timeout.map(|i| i + ::io::timer::now()).unwrap_or(0);\n+    }\n+\n+    fn wait(&mut self) -> IoResult<p::ProcessExit> {\n         match self.exit_code {\n-            Some(code) => code,\n+            Some(code) => Ok(code),\n             None => {\n-                let code = waitpid(self.pid);\n+                let code = try!(waitpid(self.pid, self.deadline));\n                 // On windows, waitpid will never return a signal. If a signal\n                 // was successfully delivered to the process, however, we can\n                 // consider it as having died via a signal.\n@@ -145,7 +165,7 @@ impl rtio::RtioProcess for Process {\n                     Some(..) => code,\n                 };\n                 self.exit_code = Some(code);\n-                code\n+                Ok(code)\n             }\n         }\n     }\n@@ -762,61 +782,301 @@ fn translate_status(status: c_int) -> p::ProcessExit {\n  * operate on a none-existent process or, even worse, on a newer process\n  * with the same id.\n  */\n-fn waitpid(pid: pid_t) -> p::ProcessExit {\n-    return waitpid_os(pid);\n-\n-    #[cfg(windows)]\n-    fn waitpid_os(pid: pid_t) -> p::ProcessExit {\n-        use libc::types::os::arch::extra::DWORD;\n-        use libc::consts::os::extra::{\n-            SYNCHRONIZE,\n-            PROCESS_QUERY_INFORMATION,\n-            FALSE,\n-            STILL_ACTIVE,\n-            INFINITE,\n-            WAIT_FAILED\n-        };\n-        use libc::funcs::extra::kernel32::{\n-            OpenProcess,\n-            GetExitCodeProcess,\n-            CloseHandle,\n-            WaitForSingleObject\n-        };\n+#[cfg(windows)]\n+fn waitpid(pid: pid_t, deadline: u64) -> IoResult<p::ProcessExit> {\n+    use libc::types::os::arch::extra::DWORD;\n+    use libc::consts::os::extra::{\n+        SYNCHRONIZE,\n+        PROCESS_QUERY_INFORMATION,\n+        FALSE,\n+        STILL_ACTIVE,\n+        INFINITE,\n+        WAIT_TIMEOUT,\n+        WAIT_OBJECT_0,\n+    };\n+    use libc::funcs::extra::kernel32::{\n+        OpenProcess,\n+        GetExitCodeProcess,\n+        CloseHandle,\n+        WaitForSingleObject,\n+    };\n \n-        unsafe {\n+    unsafe {\n+        let process = OpenProcess(SYNCHRONIZE | PROCESS_QUERY_INFORMATION,\n+                                  FALSE,\n+                                  pid as DWORD);\n+        if process.is_null() {\n+            return Err(super::last_error())\n+        }\n \n-            let process = OpenProcess(SYNCHRONIZE | PROCESS_QUERY_INFORMATION,\n-                                      FALSE,\n-                                      pid as DWORD);\n-            if process.is_null() {\n-                fail!(\"failure in OpenProcess: {}\", os::last_os_error());\n+        loop {\n+            let mut status = 0;\n+            if GetExitCodeProcess(process, &mut status) == FALSE {\n+                let err = Err(super::last_error());\n+                assert!(CloseHandle(process) != 0);\n+                return err;\n             }\n-\n-            loop {\n-                let mut status = 0;\n-                if GetExitCodeProcess(process, &mut status) == FALSE {\n-                    assert!(CloseHandle(process) != 0);\n-                    fail!(\"failure in GetExitCodeProcess: {}\", os::last_os_error());\n-                }\n-                if status != STILL_ACTIVE {\n+            if status != STILL_ACTIVE {\n+                assert!(CloseHandle(process) != 0);\n+                return Ok(p::ExitStatus(status as int));\n+            }\n+            let interval = if deadline == 0 {\n+                INFINITE\n+            } else {\n+                let now = ::io::timer::now();\n+                if deadline < now {0} else {(deadline - now) as u32}\n+            };\n+            match WaitForSingleObject(process, interval) {\n+                WAIT_OBJECT_0 => {}\n+                WAIT_TIMEOUT => {\n                     assert!(CloseHandle(process) != 0);\n-                    return p::ExitStatus(status as int);\n+                    return Err(util::timeout(\"process wait timed out\"))\n                 }\n-                if WaitForSingleObject(process, INFINITE) == WAIT_FAILED {\n+                _ => {\n+                    let err = Err(super::last_error());\n                     assert!(CloseHandle(process) != 0);\n-                    fail!(\"failure in WaitForSingleObject: {}\", os::last_os_error());\n+                    return err\n                 }\n             }\n         }\n     }\n+}\n \n-    #[cfg(unix)]\n-    fn waitpid_os(pid: pid_t) -> p::ProcessExit {\n-        use libc::funcs::posix01::wait;\n-        let mut status = 0 as c_int;\n-        match retry(|| unsafe { wait::waitpid(pid, &mut status, 0) }) {\n+#[cfg(unix)]\n+fn waitpid(pid: pid_t, deadline: u64) -> IoResult<p::ProcessExit> {\n+    use std::cmp;\n+    use std::comm;\n+\n+    static mut WRITE_FD: libc::c_int = 0;\n+\n+    let mut status = 0 as c_int;\n+    if deadline == 0 {\n+        return match retry(|| unsafe { c::waitpid(pid, &mut status, 0) }) {\n             -1 => fail!(\"unknown waitpid error: {}\", super::last_error()),\n-            _ => translate_status(status),\n+            _ => Ok(translate_status(status)),\n+        }\n+    }\n+\n+    // On unix, wait() and its friends have no timeout parameters, so there is\n+    // no way to time out a thread in wait(). From some googling and some\n+    // thinking, it appears that there are a few ways to handle timeouts in\n+    // wait(), but the only real reasonable one for a multi-threaded program is\n+    // to listen for SIGCHLD.\n+    //\n+    // With this in mind, the waiting mechanism with a timeout barely uses\n+    // waitpid() at all. There are a few times that waitpid() is invoked with\n+    // WNOHANG, but otherwise all the necessary blocking is done by waiting for\n+    // a SIGCHLD to arrive (and that blocking has a timeout). Note, however,\n+    // that waitpid() is still used to actually reap the child.\n+    //\n+    // Signal handling is super tricky in general, and this is no exception. Due\n+    // to the async nature of SIGCHLD, we use the self-pipe trick to transmit\n+    // data out of the signal handler to the rest of the application. The first\n+    // idea would be to have each thread waiting with a timeout to read this\n+    // output file descriptor, but a write() is akin to a signal(), not a\n+    // broadcast(), so it would only wake up one thread, and possibly the wrong\n+    // thread. Hence a helper thread is used.\n+    //\n+    // The helper thread here is responsible for farming requests for a\n+    // waitpid() with a timeout, and then processing all of the wait requests.\n+    // By guaranteeing that only this helper thread is reading half of the\n+    // self-pipe, we're sure that we'll never lose a SIGCHLD. This helper thread\n+    // is also responsible for select() to wait for incoming messages or\n+    // incoming SIGCHLD messages, along with passing an appropriate timeout to\n+    // select() to wake things up as necessary.\n+    //\n+    // The ordering of the following statements is also very purposeful. First,\n+    // we must be guaranteed that the helper thread is booted and available to\n+    // receive SIGCHLD signals, and then we must also ensure that we do a\n+    // nonblocking waitpid() at least once before we go ask the sigchld helper.\n+    // This prevents the race where the child exits, we boot the helper, and\n+    // then we ask for the child's exit status (never seeing a sigchld).\n+    //\n+    // The actual communication between the helper thread and this thread is\n+    // quite simple, just a channel moving data around.\n+\n+    unsafe { HELPER.boot(register_sigchld, waitpid_helper) }\n+\n+    match waitpid_nowait(pid) {\n+        Some(ret) => return Ok(ret),\n+        None => {}\n+    }\n+\n+    let (tx, rx) = channel();\n+    unsafe { HELPER.send(NewChild(pid, tx, deadline)); }\n+    return match rx.recv_opt() {\n+        Ok(e) => Ok(e),\n+        Err(()) => Err(util::timeout(\"wait timed out\")),\n+    };\n+\n+    // Register a new SIGCHLD handler, returning the reading half of the\n+    // self-pipe plus the old handler registered (return value of sigaction).\n+    fn register_sigchld() -> (libc::c_int, c::sigaction) {\n+        unsafe {\n+            let mut old: c::sigaction = mem::init();\n+            let mut new: c::sigaction = mem::init();\n+            new.sa_handler = sigchld_handler;\n+            new.sa_flags = c::SA_NOCLDSTOP;\n+            assert_eq!(c::sigaction(c::SIGCHLD, &new, &mut old), 0);\n+\n+            let mut pipes = [0, ..2];\n+            assert_eq!(libc::pipe(pipes.as_mut_ptr()), 0);\n+            util::set_nonblocking(pipes[0], true).unwrap();\n+            util::set_nonblocking(pipes[1], true).unwrap();\n+            WRITE_FD = pipes[1];\n+            (pipes[0], old)\n+        }\n+    }\n+\n+    // Helper thread for processing SIGCHLD messages\n+    fn waitpid_helper(input: libc::c_int,\n+                      messages: Receiver<Req>,\n+                      (read_fd, old): (libc::c_int, c::sigaction)) {\n+        util::set_nonblocking(input, true).unwrap();\n+        let mut set: c::fd_set = unsafe { mem::init() };\n+        let mut tv: libc::timeval;\n+        let mut active = Vec::<(libc::pid_t, Sender<p::ProcessExit>, u64)>::new();\n+        let max = cmp::max(input, read_fd) + 1;\n+\n+        'outer: loop {\n+            // Figure out the timeout of our syscall-to-happen. If we're waiting\n+            // for some processes, then they'll have a timeout, otherwise we\n+            // wait indefinitely for a message to arrive.\n+            //\n+            // FIXME: sure would be nice to not have to scan the entire array\n+            let min = active.iter().map(|a| *a.ref2()).enumerate().min_by(|p| {\n+                p.val1()\n+            });\n+            let (p, idx) = match min {\n+                Some((idx, deadline)) => {\n+                    let now = ::io::timer::now();\n+                    let ms = if now < deadline {deadline - now} else {0};\n+                    tv = util::ms_to_timeval(ms);\n+                    (&tv as *_, idx)\n+                }\n+                None => (ptr::null(), -1),\n+            };\n+\n+            // Wait for something to happen\n+            c::fd_set(&mut set, input);\n+            c::fd_set(&mut set, read_fd);\n+            match unsafe { c::select(max, &set, ptr::null(), ptr::null(), p) } {\n+                // interrupted, retry\n+                -1 if os::errno() == libc::EINTR as int => continue,\n+\n+                // We read something, break out and process\n+                1 | 2 => {}\n+\n+                // Timeout, the pending request is removed\n+                0 => {\n+                    drop(active.remove(idx));\n+                    continue\n+                }\n+\n+                n => fail!(\"error in select {} ({})\", os::errno(), n),\n+            }\n+\n+            // Process any pending messages\n+            if drain(input) {\n+                loop {\n+                    match messages.try_recv() {\n+                        Ok(NewChild(pid, tx, deadline)) => {\n+                            active.push((pid, tx, deadline));\n+                        }\n+                        Err(comm::Disconnected) => {\n+                            assert!(active.len() == 0);\n+                            break 'outer;\n+                        }\n+                        Err(comm::Empty) => break,\n+                    }\n+                }\n+            }\n+\n+            // If a child exited (somehow received SIGCHLD), then poll all\n+            // children to see if any of them exited.\n+            //\n+            // We also attempt to be responsible netizens when dealing with\n+            // SIGCHLD by invoking any previous SIGCHLD handler instead of just\n+            // ignoring any previous SIGCHLD handler. Note that we don't provide\n+            // a 1:1 mapping of our handler invocations to the previous handler\n+            // invocations because we drain the `read_fd` entirely. This is\n+            // probably OK because the kernel is already allowed to coalesce\n+            // simultaneous signals, we're just doing some extra coalescing.\n+            //\n+            // Another point of note is that this likely runs the signal handler\n+            // on a different thread than the one that received the signal. I\n+            // *think* this is ok at this time.\n+            //\n+            // The main reason for doing this is to allow stdtest to run native\n+            // tests as well. Both libgreen and libnative are running around\n+            // with process timeouts, but libgreen should get there first\n+            // (currently libuv doesn't handle old signal handlers).\n+            if drain(read_fd) {\n+                let i: uint = unsafe { mem::transmute(old.sa_handler) };\n+                if i != 0 {\n+                    assert!(old.sa_flags & c::SA_SIGINFO == 0);\n+                    (old.sa_handler)(c::SIGCHLD);\n+                }\n+\n+                // FIXME: sure would be nice to not have to scan the entire\n+                //        array...\n+                active.retain(|&(pid, ref tx, _)| {\n+                    match waitpid_nowait(pid) {\n+                        Some(msg) => { tx.send(msg); false }\n+                        None => true,\n+                    }\n+                });\n+            }\n+        }\n+\n+        // Once this helper thread is done, we re-register the old sigchld\n+        // handler and close our intermediate file descriptors.\n+        unsafe {\n+            assert_eq!(c::sigaction(c::SIGCHLD, &old, ptr::mut_null()), 0);\n+            let _ = libc::close(read_fd);\n+            let _ = libc::close(WRITE_FD);\n+            WRITE_FD = -1;\n+        }\n+    }\n+\n+    // Drain all pending data from the file descriptor, returning if any data\n+    // could be drained. This requires that the file descriptor is in\n+    // nonblocking mode.\n+    fn drain(fd: libc::c_int) -> bool {\n+        let mut ret = false;\n+        loop {\n+            let mut buf = [0u8, ..1];\n+            match unsafe {\n+                libc::read(fd, buf.as_mut_ptr() as *mut libc::c_void,\n+                           buf.len() as libc::size_t)\n+            } {\n+                n if n > 0 => { ret = true; }\n+                0 => return true,\n+                -1 if util::wouldblock() => return ret,\n+                n => fail!(\"bad read {} ({})\", os::last_os_error(), n),\n+            }\n+        }\n+    }\n+\n+    // Signal handler for SIGCHLD signals, must be async-signal-safe!\n+    //\n+    // This function will write to the writing half of the \"self pipe\" to wake\n+    // up the helper thread if it's waiting. Note that this write must be\n+    // nonblocking because if it blocks and the reader is the thread we\n+    // interrupted, then we'll deadlock.\n+    //\n+    // When writing, if the write returns EWOULDBLOCK then we choose to ignore\n+    // it. At that point we're guaranteed that there's something in the pipe\n+    // which will wake up the other end at some point, so we just allow this\n+    // signal to be coalesced with the pending signals on the pipe.\n+    extern fn sigchld_handler(_signum: libc::c_int) {\n+        let mut msg = 1;\n+        match unsafe {\n+            libc::write(WRITE_FD, &mut msg as *mut _ as *libc::c_void, 1)\n+        } {\n+            1 => {}\n+            -1 if util::wouldblock() => {} // see above comments\n+            n => fail!(\"bad error on write fd: {} {}\", n, os::errno()),\n         }\n     }\n }\n@@ -830,10 +1090,9 @@ fn waitpid_nowait(pid: pid_t) -> Option<p::ProcessExit> {\n \n     #[cfg(unix)]\n     fn waitpid_os(pid: pid_t) -> Option<p::ProcessExit> {\n-        use libc::funcs::posix01::wait;\n         let mut status = 0 as c_int;\n         match retry(|| unsafe {\n-            wait::waitpid(pid, &mut status, libc::WNOHANG)\n+            c::waitpid(pid, &mut status, c::WNOHANG)\n         }) {\n             n if n == pid => Some(translate_status(status)),\n             0 => None,"}, {"sha": "95b2620f3c7987e1989bc03c0921bbbe21e6d870", "filename": "src/libnative/io/timer_helper.rs", "status": "removed", "additions": 0, "deletions": 149, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/cb115ac2d4f57d8b590c8d46d8f9e2958ed9a527/src%2Flibnative%2Fio%2Ftimer_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb115ac2d4f57d8b590c8d46d8f9e2958ed9a527/src%2Flibnative%2Fio%2Ftimer_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_helper.rs?ref=cb115ac2d4f57d8b590c8d46d8f9e2958ed9a527", "patch": "@@ -1,149 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Implementation of the helper thread for the timer module\n-//!\n-//! This module contains the management necessary for the timer worker thread.\n-//! This thread is responsible for performing the send()s on channels for timers\n-//! that are using channels instead of a blocking call.\n-//!\n-//! The timer thread is lazily initialized, and it's shut down via the\n-//! `shutdown` function provided. It must be maintained as an invariant that\n-//! `shutdown` is only called when the entire program is finished. No new timers\n-//! can be created in the future and there must be no active timers at that\n-//! time.\n-\n-use std::mem;\n-use std::rt::bookkeeping;\n-use std::rt;\n-use std::unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n-\n-use io::timer::{Req, Shutdown};\n-use task;\n-\n-// You'll note that these variables are *not* protected by a lock. These\n-// variables are initialized with a Once before any Timer is created and are\n-// only torn down after everything else has exited. This means that these\n-// variables are read-only during use (after initialization) and both of which\n-// are safe to use concurrently.\n-static mut HELPER_CHAN: *mut Sender<Req> = 0 as *mut Sender<Req>;\n-static mut HELPER_SIGNAL: imp::signal = 0 as imp::signal;\n-\n-static mut TIMER_HELPER_EXIT: StaticNativeMutex = NATIVE_MUTEX_INIT;\n-\n-pub fn boot(helper: fn(imp::signal, Receiver<Req>)) {\n-    static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n-    static mut INITIALIZED: bool = false;\n-\n-    unsafe {\n-        let mut _guard = LOCK.lock();\n-        if !INITIALIZED {\n-            let (tx, rx) = channel();\n-            // promote this to a shared channel\n-            drop(tx.clone());\n-            HELPER_CHAN = mem::transmute(box tx);\n-            let (receive, send) = imp::new();\n-            HELPER_SIGNAL = send;\n-\n-            task::spawn(proc() {\n-                bookkeeping::decrement();\n-                helper(receive, rx);\n-                TIMER_HELPER_EXIT.lock().signal()\n-            });\n-\n-            rt::at_exit(proc() { shutdown() });\n-            INITIALIZED = true;\n-        }\n-    }\n-}\n-\n-pub fn send(req: Req) {\n-    unsafe {\n-        assert!(!HELPER_CHAN.is_null());\n-        (*HELPER_CHAN).send(req);\n-        imp::signal(HELPER_SIGNAL);\n-    }\n-}\n-\n-fn shutdown() {\n-    // Request a shutdown, and then wait for the task to exit\n-    unsafe {\n-        let guard = TIMER_HELPER_EXIT.lock();\n-        send(Shutdown);\n-        guard.wait();\n-        drop(guard);\n-        TIMER_HELPER_EXIT.destroy();\n-    }\n-\n-\n-    // Clean up after ther helper thread\n-    unsafe {\n-        imp::close(HELPER_SIGNAL);\n-        let _chan: Box<Sender<Req>> = mem::transmute(HELPER_CHAN);\n-        HELPER_CHAN = 0 as *mut Sender<Req>;\n-        HELPER_SIGNAL = 0 as imp::signal;\n-    }\n-}\n-\n-#[cfg(unix)]\n-mod imp {\n-    use libc;\n-    use std::os;\n-\n-    use io::file::FileDesc;\n-\n-    pub type signal = libc::c_int;\n-\n-    pub fn new() -> (signal, signal) {\n-        let pipe = os::pipe();\n-        (pipe.input, pipe.out)\n-    }\n-\n-    pub fn signal(fd: libc::c_int) {\n-        FileDesc::new(fd, false).inner_write([0]).unwrap();\n-    }\n-\n-    pub fn close(fd: libc::c_int) {\n-        let _fd = FileDesc::new(fd, true);\n-    }\n-}\n-\n-#[cfg(windows)]\n-mod imp {\n-    use libc::{BOOL, LPCSTR, HANDLE, LPSECURITY_ATTRIBUTES, CloseHandle};\n-    use std::ptr;\n-    use libc;\n-\n-    pub type signal = HANDLE;\n-\n-    pub fn new() -> (HANDLE, HANDLE) {\n-        unsafe {\n-            let handle = CreateEventA(ptr::mut_null(), libc::FALSE, libc::FALSE,\n-                                      ptr::null());\n-            (handle, handle)\n-        }\n-    }\n-\n-    pub fn signal(handle: HANDLE) {\n-        assert!(unsafe { SetEvent(handle) != 0 });\n-    }\n-\n-    pub fn close(handle: HANDLE) {\n-        assert!(unsafe { CloseHandle(handle) != 0 });\n-    }\n-\n-    extern \"system\" {\n-        fn CreateEventA(lpSecurityAttributes: LPSECURITY_ATTRIBUTES,\n-                        bManualReset: BOOL,\n-                        bInitialState: BOOL,\n-                        lpName: LPCSTR) -> HANDLE;\n-        fn SetEvent(hEvent: HANDLE) -> BOOL;\n-    }\n-}"}, {"sha": "2c5b798482777657c11770ffb002ea608d2f6210", "filename": "src/libnative/io/timer_unix.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibnative%2Fio%2Ftimer_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibnative%2Fio%2Ftimer_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_unix.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -52,11 +52,14 @@ use std::os;\n use std::ptr;\n use std::rt::rtio;\n use std::sync::atomics;\n+use std::comm;\n \n use io::IoResult;\n use io::c;\n use io::file::FileDesc;\n-use io::timer_helper;\n+use io::helper_thread::Helper;\n+\n+helper_init!(static mut HELPER: Helper<Req>)\n \n pub struct Timer {\n     id: uint,\n@@ -79,9 +82,6 @@ pub enum Req {\n     // Remove a timer based on its id and then send it back on the channel\n     // provided\n     RemoveTimer(uint, Sender<Box<Inner>>),\n-\n-    // Shut down the loop and then ACK this channel once it's shut down\n-    Shutdown,\n }\n \n // returns the current time (in milliseconds)\n@@ -93,7 +93,7 @@ pub fn now() -> u64 {\n     }\n }\n \n-fn helper(input: libc::c_int, messages: Receiver<Req>) {\n+fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n     let mut set: c::fd_set = unsafe { mem::init() };\n \n     let mut fd = FileDesc::new(input, true);\n@@ -163,7 +163,7 @@ fn helper(input: libc::c_int, messages: Receiver<Req>) {\n             1 => {\n                 loop {\n                     match messages.try_recv() {\n-                        Ok(Shutdown) => {\n+                        Err(comm::Disconnected) => {\n                             assert!(active.len() == 0);\n                             break 'outer;\n                         }\n@@ -202,7 +202,7 @@ fn helper(input: libc::c_int, messages: Receiver<Req>) {\n \n impl Timer {\n     pub fn new() -> IoResult<Timer> {\n-        timer_helper::boot(helper);\n+        unsafe { HELPER.boot(|| {}, helper); }\n \n         static mut ID: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;\n         let id = unsafe { ID.fetch_add(1, atomics::Relaxed) };\n@@ -235,7 +235,7 @@ impl Timer {\n             Some(i) => i,\n             None => {\n                 let (tx, rx) = channel();\n-                timer_helper::send(RemoveTimer(self.id, tx));\n+                unsafe { HELPER.send(RemoveTimer(self.id, tx)); }\n                 rx.recv()\n             }\n         }\n@@ -261,7 +261,7 @@ impl rtio::RtioTimer for Timer {\n         inner.interval = msecs;\n         inner.target = now + msecs;\n \n-        timer_helper::send(NewTimer(inner));\n+        unsafe { HELPER.send(NewTimer(inner)); }\n         return rx;\n     }\n \n@@ -275,7 +275,7 @@ impl rtio::RtioTimer for Timer {\n         inner.interval = msecs;\n         inner.target = now + msecs;\n \n-        timer_helper::send(NewTimer(inner));\n+        unsafe { HELPER.send(NewTimer(inner)); }\n         return rx;\n     }\n }"}, {"sha": "e7130de05c26d3ffd2027b6e8af5858ff21a4f14", "filename": "src/libnative/io/timer_win32.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibnative%2Fio%2Ftimer_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibnative%2Fio%2Ftimer_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_win32.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -23,10 +23,13 @@\n use libc;\n use std::ptr;\n use std::rt::rtio;\n+use std::comm;\n \n-use io::timer_helper;\n+use io::helper_thread::Helper;\n use io::IoResult;\n \n+helper_init!(static mut HELPER: Helper<Req>)\n+\n pub struct Timer {\n     obj: libc::HANDLE,\n     on_worker: bool,\n@@ -35,10 +38,9 @@ pub struct Timer {\n pub enum Req {\n     NewTimer(libc::HANDLE, Sender<()>, bool),\n     RemoveTimer(libc::HANDLE, Sender<()>),\n-    Shutdown,\n }\n \n-fn helper(input: libc::HANDLE, messages: Receiver<Req>) {\n+fn helper(input: libc::HANDLE, messages: Receiver<Req>, _: ()) {\n     let mut objs = vec![input];\n     let mut chans = vec![];\n \n@@ -67,12 +69,12 @@ fn helper(input: libc::HANDLE, messages: Receiver<Req>) {\n                             None => {}\n                         }\n                     }\n-                    Ok(Shutdown) => {\n+                    Err(comm::Disconnected) => {\n                         assert_eq!(objs.len(), 1);\n                         assert_eq!(chans.len(), 0);\n                         break 'outer;\n                     }\n-                    _ => break\n+                    Err(..) => break\n                 }\n             }\n         } else {\n@@ -102,7 +104,7 @@ pub fn now() -> u64 {\n \n impl Timer {\n     pub fn new() -> IoResult<Timer> {\n-        timer_helper::boot(helper);\n+        unsafe { HELPER.boot(|| {}, helper) }\n \n         let obj = unsafe {\n             imp::CreateWaitableTimerA(ptr::mut_null(), 0, ptr::null())\n@@ -124,7 +126,7 @@ impl Timer {\n         if !self.on_worker { return }\n \n         let (tx, rx) = channel();\n-        timer_helper::send(RemoveTimer(self.obj, tx));\n+        unsafe { HELPER.send(RemoveTimer(self.obj, tx)) }\n         rx.recv();\n \n         self.on_worker = false;\n@@ -157,7 +159,7 @@ impl rtio::RtioTimer for Timer {\n                                   ptr::mut_null(), 0)\n         }, 1);\n \n-        timer_helper::send(NewTimer(self.obj, tx, true));\n+        unsafe { HELPER.send(NewTimer(self.obj, tx, true)) }\n         self.on_worker = true;\n         return rx;\n     }\n@@ -173,7 +175,7 @@ impl rtio::RtioTimer for Timer {\n                                   ptr::null(), ptr::mut_null(), 0)\n         }, 1);\n \n-        timer_helper::send(NewTimer(self.obj, tx, false));\n+        unsafe { HELPER.send(NewTimer(self.obj, tx, false)) }\n         self.on_worker = true;\n \n         return rx;"}, {"sha": "8ba06133369245a13d950b838df1d71d150303b7", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -55,6 +55,7 @@\n // NB this crate explicitly does *not* allow glob imports, please seriously\n //    consider whether they're needed before adding that feature here (the\n //    answer is that you don't need them)\n+#![feature(macro_rules)]\n \n extern crate libc;\n "}, {"sha": "ac8da664de751ee71e379c37e2c292a06979ceb4", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -19,6 +19,7 @@ A `BigInt` is a combination of `BigUint` and `Sign`.\n use Integer;\n \n use std::cmp;\n+use std::default::Default;\n use std::fmt;\n use std::from_str::FromStr;\n use std::num::CheckedDiv;\n@@ -112,6 +113,11 @@ impl TotalOrd for BigUint {\n     }\n }\n \n+impl Default for BigUint {\n+    #[inline]\n+    fn default() -> BigUint { BigUint::new(Vec::new()) }\n+}\n+\n impl fmt::Show for BigUint {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f.buf, \"{}\", self.to_str_radix(10))\n@@ -830,6 +836,11 @@ impl TotalOrd for BigInt {\n     }\n }\n \n+impl Default for BigInt {\n+    #[inline]\n+    fn default() -> BigInt { BigInt::new(Zero, Vec::new()) }\n+}\n+\n impl fmt::Show for BigInt {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f.buf, \"{}\", self.to_str_radix(10))"}, {"sha": "04ce4f88831f4d0cd823b8d1c924bf5f54a10c51", "filename": "src/librustc/back/archive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibrustc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibrustc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farchive.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -54,8 +54,8 @@ fn run_ar(sess: &Session, args: &str, cwd: Option<&Path>,\n         cwd: cwd.map(|a| &*a),\n         .. ProcessConfig::new()\n     }) {\n-        Ok(mut prog) => {\n-            let o = prog.wait_with_output();\n+        Ok(prog) => {\n+            let o = prog.wait_with_output().unwrap();\n             if !o.status.success() {\n                 sess.err(format!(\"{} {} failed with: {}\", ar, args.connect(\" \"),\n                                  o.status));"}, {"sha": "f6e6875f0e71fc7f30c195045c621d17a75c3304", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -100,6 +100,7 @@ impl<'a> fold::Folder for StandardLibraryInjector<'a> {\n             });\n         }\n \n+        // `extern crate` must be precede `use` items\n         vis.push_all_move(krate.module.view_items.clone());\n         let new_module = ast::Mod {\n             view_items: vis,\n@@ -130,8 +131,20 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n         if !no_prelude(krate.attrs.as_slice()) {\n             // only add `use std::prelude::*;` if there wasn't a\n             // `#![no_implicit_prelude]` at the crate level.\n+\n+            let mut attrs = krate.attrs.clone();\n+\n+            // fold_mod() will insert glob path.\n+            let globs_attr = attr::mk_attr(attr::mk_list_item(\n+                InternedString::new(\"feature\"),\n+                vec!(\n+                    attr::mk_word_item(InternedString::new(\"globs\")),\n+                )));\n+            attrs.push(globs_attr);\n+\n             ast::Crate {\n                 module: self.fold_mod(&krate.module),\n+                attrs: attrs,\n                 ..krate\n             }\n         } else {\n@@ -175,11 +188,20 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n             span: DUMMY_SP,\n         };\n \n-        let vis = (vec!(vi2)).append(module.view_items.as_slice());\n+        let (crates, uses) = module.view_items.partitioned(|x| {\n+            match x.node {\n+                ast::ViewItemExternCrate(..) => true,\n+                _ => false,\n+            }\n+        });\n+\n+        // add vi2 after any `extern crate` but before any `use`\n+        let mut view_items = crates;\n+        view_items.push(vi2);\n+        view_items.push_all_move(uses);\n \n-        // FIXME #2543: Bad copy.\n         let new_module = ast::Mod {\n-            view_items: vis,\n+            view_items: view_items,\n             ..(*module).clone()\n         };\n         fold::noop_fold_mod(&new_module, self)"}, {"sha": "0c874bd776ed11d1fd8a7e162d4741d3354197b3", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -398,8 +398,7 @@ pub mod llvm {\n         pub fn LLVMIsPackedStruct(StructTy: TypeRef) -> Bool;\n \n         /* Operations on array, pointer, and vector types (sequence types) */\n-        pub fn LLVMArrayType(ElementType: TypeRef, ElementCount: c_uint)\n-                             -> TypeRef;\n+        pub fn LLVMRustArrayType(ElementType: TypeRef, ElementCount: u64) -> TypeRef;\n         pub fn LLVMPointerType(ElementType: TypeRef, AddressSpace: c_uint)\n                                -> TypeRef;\n         pub fn LLVMVectorType(ElementType: TypeRef, ElementCount: c_uint)"}, {"sha": "7da56655378edf7e8d65b5a856143e4b50b33d0d", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -148,6 +148,33 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr, is_const: bool) {\n                 }\n             }\n           }\n+          ExprBlock(ref block) => {\n+            // Check all statements in the block\n+            for stmt in block.stmts.iter() {\n+                let block_span_err = |span|\n+                    v.tcx.sess.span_err(span,\n+                        \"blocks in constants are limited to \\\n+                        items and tail expressions\");\n+                match stmt.node {\n+                    StmtDecl(ref span, _) => {\n+                        match span.node {\n+                            DeclLocal(_) => block_span_err(span.span),\n+\n+                            // Item statements are allowed\n+                            DeclItem(_) => {}\n+                        }\n+                    }\n+                    StmtExpr(ref expr, _) => block_span_err(expr.span),\n+                    StmtSemi(ref semi, _) => block_span_err(semi.span),\n+                    StmtMac(..) => v.tcx.sess.span_bug(e.span,\n+                        \"unexpanded statement macro in const?!\")\n+                }\n+            }\n+            match block.expr {\n+                Some(ref expr) => check_expr(v, &**expr, true),\n+                None => {}\n+            }\n+          }\n           ExprVstore(_, ExprVstoreMutSlice) |\n           ExprVstore(_, ExprVstoreSlice) |\n           ExprVec(_) |"}, {"sha": "b48fddac1a4514cc60a5af3feb72a059ce60b400", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 30, "deletions": 35, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -239,7 +239,15 @@ fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@Pat]) -> useful {\n         return not_useful\n     }\n     let real_pat = match m.iter().find(|r| r.get(0).id != 0) {\n-      Some(r) => *r.get(0), None => v[0]\n+        Some(r) => {\n+            match r.get(0).node {\n+                // An arm of the form `ref x @ sub_pat` has type\n+                // `sub_pat`, not `&sub_pat` as `x` itself does.\n+                PatIdent(BindByRef(_), _, Some(sub)) => sub,\n+                _ => *r.get(0)\n+            }\n+        }\n+        None => v[0]\n     };\n     let left_ty = if real_pat.id == 0 { ty::mk_nil() }\n                   else { ty::node_id_to_type(cx.tcx, real_pat.id) };\n@@ -258,15 +266,15 @@ fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@Pat]) -> useful {\n                                                 val(const_bool(false)),\n                                                 0u, left_ty)\n                       }\n-                      ref u => (*u).clone(),\n+                      u => u,\n                   }\n               }\n               ty::ty_enum(eid, _) => {\n                   for va in (*ty::enum_variants(cx.tcx, eid)).iter() {\n                       match is_useful_specialized(cx, m, v, variant(va.id),\n                                                   va.args.len(), left_ty) {\n                         not_useful => (),\n-                        ref u => return (*u).clone(),\n+                        u => return u,\n                       }\n                   }\n                   not_useful\n@@ -288,7 +296,7 @@ fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@Pat]) -> useful {\n                       for n in iter::range(0u, max_len + 1) {\n                           match is_useful_specialized(cx, m, v, vec(n), n, left_ty) {\n                               not_useful => (),\n-                              ref u => return (*u).clone(),\n+                              u => return u,\n                           }\n                       }\n                       not_useful\n@@ -304,21 +312,21 @@ fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@Pat]) -> useful {\n               }\n             }\n           }\n-          Some(ref ctor) => {\n+          Some(ctor) => {\n             match is_useful(cx,\n                             &m.iter().filter_map(|r| {\n                                 default(cx, r.as_slice())\n                             }).collect::<matrix>(),\n                             v.tail()) {\n-              useful_ => useful(left_ty, (*ctor).clone()),\n-              ref u => (*u).clone(),\n+              useful_ => useful(left_ty, ctor),\n+              u => u,\n             }\n           }\n         }\n       }\n-      Some(ref v0_ctor) => {\n-        let arity = ctor_arity(cx, v0_ctor, left_ty);\n-        is_useful_specialized(cx, m, v, (*v0_ctor).clone(), arity, left_ty)\n+      Some(v0_ctor) => {\n+        let arity = ctor_arity(cx, &v0_ctor, left_ty);\n+        is_useful_specialized(cx, m, v, v0_ctor, arity, left_ty)\n       }\n     }\n }\n@@ -337,7 +345,7 @@ fn is_useful_specialized(cx: &MatchCheckCtxt,\n         cx, &ms, specialize(cx, v, &ctor, arity, lty).unwrap().as_slice());\n     match could_be_useful {\n       useful_ => useful(lty, ctor),\n-      ref u => (*u).clone(),\n+      u => u,\n     }\n }\n \n@@ -408,9 +416,9 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n         let mut found = Vec::new();\n         for r in m.iter() {\n             let r = pat_ctor_id(cx, *r.get(0));\n-            for id in r.iter() {\n-                if !found.contains(id) {\n-                    found.push((*id).clone());\n+            for id in r.move_iter() {\n+                if !found.contains(&id) {\n+                    found.push(id);\n                 }\n             }\n         }\n@@ -812,30 +820,17 @@ fn specialize(cx: &MatchCheckCtxt,\n                         let num_elements = before.len() + after.len();\n                         if num_elements < arity && slice.is_some() {\n                             let mut result = Vec::new();\n-                            for pat in before.iter() {\n-                                result.push((*pat).clone());\n-                            }\n-                            for _ in iter::range(0, arity - num_elements) {\n-                                result.push(wild())\n-                            }\n-                            for pat in after.iter() {\n-                                result.push((*pat).clone());\n-                            }\n-                            for pat in r.tail().iter() {\n-                                result.push((*pat).clone());\n-                            }\n+                            let wilds = Vec::from_elem(arity - num_elements, wild());\n+                            result.push_all_move(before);\n+                            result.push_all_move(wilds);\n+                            result.push_all_move(after);\n+                            result.push_all(r.tail());\n                             Some(result)\n                         } else if num_elements == arity {\n                             let mut result = Vec::new();\n-                            for pat in before.iter() {\n-                                result.push((*pat).clone());\n-                            }\n-                            for pat in after.iter() {\n-                                result.push((*pat).clone());\n-                            }\n-                            for pat in r.tail().iter() {\n-                                result.push((*pat).clone());\n-                            }\n+                            result.push_all_move(before);\n+                            result.push_all_move(after);\n+                            result.push_all(r.tail());\n                             Some(result)\n                         } else {\n                             None"}, {"sha": "aa0b573eba8c819d7ad173a5d3bfa0c48f7cb08d", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -47,7 +47,6 @@ use std::rc::Rc;\n //        fixed-size vectors and strings: [] and \"\"/_\n //        vector and string slices: &[] and &\"\"\n //        tuples: (,)\n-//        records: {...}\n //        enums: foo(...)\n //        floating point literals and operators\n //        & and * pointers\n@@ -241,6 +240,13 @@ impl<'a> ConstEvalVisitor<'a> {\n \n             ast::ExprRepeat(..) => general_const,\n \n+            ast::ExprBlock(ref block) => {\n+                match block.expr {\n+                    Some(ref e) => self.classify(&**e),\n+                    None => integral_const\n+                }\n+            }\n+\n             _ => non_const\n         };\n         self.ccache.insert(did, cn);\n@@ -479,6 +485,12 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n       // If we have a vstore, just keep going; it has to be a string\n       ExprVstore(e, _) => eval_const_expr_partial(tcx, e),\n       ExprParen(e)     => eval_const_expr_partial(tcx, e),\n+      ExprBlock(ref block) => {\n+        match block.expr {\n+            Some(ref expr) => eval_const_expr_partial(tcx, &**expr),\n+            None => Ok(const_int(0i64))\n+        }\n+      }\n       _ => Err(\"unsupported constant expr\".to_strbuf())\n     }\n }"}, {"sha": "1bf4d0a02faf099b642250e456d4a289244237b4", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -46,6 +46,7 @@ use middle::typeck::astconv::{ast_ty_to_ty, AstConv};\n use middle::typeck::infer;\n use middle::typeck;\n use util::ppaux::{ty_to_str};\n+use util::nodemap::NodeSet;\n \n use std::cmp;\n use collections::HashMap;\n@@ -453,10 +454,13 @@ struct Context<'a> {\n     // When recursing into an attributed node of the ast which modifies lint\n     // levels, this stack keeps track of the previous lint levels of whatever\n     // was modified.\n-    lint_stack: Vec<(Lint, level, LintSource)> ,\n+    lint_stack: Vec<(Lint, level, LintSource)>,\n \n     // id of the last visited negated expression\n-    negated_expr_id: ast::NodeId\n+    negated_expr_id: ast::NodeId,\n+\n+    // ids of structs/enums which have been checked for raw_pointer_deriving\n+    checked_raw_pointers: NodeSet,\n }\n \n impl<'a> Context<'a> {\n@@ -1014,10 +1018,26 @@ impl<'a> Visitor<()> for RawPtrDerivingVisitor<'a> {\n     fn visit_block(&mut self, _: &ast::Block, _: ()) {}\n }\n \n-fn check_raw_ptr_deriving(cx: &Context, item: &ast::Item) {\n-    if !attr::contains_name(item.attrs.as_slice(), \"deriving\") {\n+fn check_raw_ptr_deriving(cx: &mut Context, item: &ast::Item) {\n+    if !attr::contains_name(item.attrs.as_slice(), \"automatically_derived\") {\n         return\n     }\n+    let did = match item.node {\n+        ast::ItemImpl(..) => {\n+            match ty::get(ty::node_id_to_type(cx.tcx, item.id)).sty {\n+                ty::ty_enum(did, _) => did,\n+                ty::ty_struct(did, _) => did,\n+                _ => return,\n+            }\n+        }\n+        _ => return,\n+    };\n+    if !ast_util::is_local(did) { return }\n+    let item = match cx.tcx.map.find(did.node) {\n+        Some(ast_map::NodeItem(item)) => item,\n+        _ => return,\n+    };\n+    if !cx.checked_raw_pointers.insert(item.id) { return }\n     match item.node {\n         ast::ItemStruct(..) | ast::ItemEnum(..) => {\n             let mut visitor = RawPtrDerivingVisitor { cx: cx };\n@@ -1848,7 +1868,8 @@ pub fn check_crate(tcx: &ty::ctxt,\n         cur_struct_def_id: -1,\n         is_doc_hidden: false,\n         lint_stack: Vec::new(),\n-        negated_expr_id: -1\n+        negated_expr_id: -1,\n+        checked_raw_pointers: NodeSet::new(),\n     };\n \n     // Install default lint levels, followed by the command line levels, and"}, {"sha": "3cfabf7f96b7f2ff75e5d2bdf23463cba26458f1", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -1611,6 +1611,9 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n         }\n       }\n       ast::ItemStatic(_, m, expr) => {\n+          // Recurse on the expression to catch items in blocks\n+          let mut v = TransItemVisitor{ ccx: ccx };\n+          v.visit_expr(expr, ());\n           consts::trans_const(ccx, m, item.id);\n           // Do static_assert checking. It can't really be done much earlier\n           // because we need to get the value of the bool out of LLVM"}, {"sha": "b5ab0a391f3b176fa8dda9bdb39ede7c9d739910", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -672,6 +672,12 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n               }\n           }\n           ast::ExprParen(e) => { const_expr(cx, e, is_local) }\n+          ast::ExprBlock(ref block) => {\n+            match block.expr {\n+                Some(ref expr) => const_expr(cx, &**expr, is_local),\n+                None => (C_nil(cx), true)\n+            }\n+          }\n           _ => cx.sess().span_bug(e.span,\n                   \"bad constant expression type in consts::const_expr\")\n         };"}, {"sha": "d5a80edfaedd15d24dee9ade3ceb9e1ec1db09c0", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -207,7 +207,7 @@ impl Type {\n     }\n \n     pub fn array(ty: &Type, len: u64) -> Type {\n-        ty!(llvm::LLVMArrayType(ty.to_ref(), len as c_uint))\n+        ty!(llvm::LLVMRustArrayType(ty.to_ref(), len))\n     }\n \n     pub fn vector(ty: &Type, len: u64) -> Type {"}, {"sha": "68f4fd95626dcbd65d8a83c25ce4994c2f8876ed", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -3554,6 +3554,12 @@ pub fn check_const_with_ty(fcx: &FnCtxt,\n                            _: Span,\n                            e: &ast::Expr,\n                            declty: ty::t) {\n+    // Gather locals in statics (because of block expressions).\n+    // This is technically uneccessary because locals in static items are forbidden,\n+    // but prevents type checking from blowing up before const checking can properly\n+    // emit a error.\n+    GatherLocalsVisitor { fcx: fcx }.visit_expr(e, ());\n+\n     check_expr(fcx, e);\n     let cty = fcx.expr_ty(e);\n     demand::suptype(fcx, e.span, declty, cty);"}, {"sha": "f853b0dbad40f9254f3553c958b33da962da1ed8", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -90,7 +90,7 @@ fn get_base_type(inference_context: &InferCtxt,\n     }\n }\n \n-fn type_is_defined_in_local_crate(original_type: t) -> bool {\n+fn type_is_defined_in_local_crate(tcx: &ty::ctxt, original_type: t) -> bool {\n     /*!\n      *\n      * For coherence, when we have `impl Trait for Type`, we need to\n@@ -109,6 +109,14 @@ fn type_is_defined_in_local_crate(original_type: t) -> bool {\n                     found_nominal = true;\n                 }\n             }\n+            ty_uniq(..) => {\n+                match tcx.lang_items.owned_box() {\n+                    Some(did) if did.krate == ast::LOCAL_CRATE => {\n+                        found_nominal = true;\n+                    }\n+                    _ => {}\n+                }\n+            }\n \n             _ => { }\n         }\n@@ -194,11 +202,10 @@ impl<'a> visit::Visitor<()> for PrivilegedScopeVisitor<'a> {\n                 }\n             }\n             ItemImpl(_, Some(ref trait_ref), _, _) => {\n+                let tcx = self.cc.crate_context.tcx;\n                 // `for_ty` is `Type` in `impl Trait for Type`\n-                let for_ty =\n-                    ty::node_id_to_type(self.cc.crate_context.tcx,\n-                                        item.id);\n-                if !type_is_defined_in_local_crate(for_ty) {\n+                let for_ty = ty::node_id_to_type(tcx, item.id);\n+                if !type_is_defined_in_local_crate(tcx, for_ty) {\n                     // This implementation is not in scope of its base\n                     // type. This still might be OK if the trait is\n                     // defined in the same crate."}, {"sha": "95ae05985d38e2954c2ea755657580d3dfc993fb", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -355,26 +355,22 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> StrBuf {\n       ty_bot => \"!\".to_strbuf(),\n       ty_bool => \"bool\".to_strbuf(),\n       ty_char => \"char\".to_strbuf(),\n-      ty_int(t) => ast_util::int_ty_to_str(t, None),\n-      ty_uint(t) => ast_util::uint_ty_to_str(t, None),\n-      ty_float(t) => ast_util::float_ty_to_str(t),\n-      ty_box(typ) => {\n-          (\"@\".to_owned() + ty_to_str(cx, typ).as_slice()).to_strbuf()\n-      }\n-      ty_uniq(typ) => {\n-          (\"~\".to_owned() + ty_to_str(cx, typ).as_slice()).to_strbuf()\n-      }\n-      ty_ptr(ref tm) => {\n-          (\"*\".to_owned() + mt_to_str(cx, tm).as_slice()).to_strbuf()\n-      }\n+      ty_int(t) => ast_util::int_ty_to_str(t, None,\n+                                           ast_util::AutoSuffix).to_strbuf(),\n+      ty_uint(t) => ast_util::uint_ty_to_str(t, None,\n+                                             ast_util::AutoSuffix).to_strbuf(),\n+      ty_float(t) => ast_util::float_ty_to_str(t).to_strbuf(),\n+      ty_box(typ) => format_strbuf!(\"@{}\", ty_to_str(cx, typ)),\n+      ty_uniq(typ) => format_strbuf!(\"~{}\", ty_to_str(cx, typ)),\n+      ty_ptr(ref tm) => format_strbuf!(\"*{}\", mt_to_str(cx, tm)),\n       ty_rptr(r, ref tm) => {\n           let mut buf = region_ptr_to_str(cx, r);\n           buf.push_str(mt_to_str(cx, tm).as_slice());\n           buf\n       }\n       ty_tup(ref elems) => {\n         let strs: Vec<StrBuf> = elems.iter().map(|elem| ty_to_str(cx, *elem)).collect();\n-        (\"(\".to_owned() + strs.connect(\",\") + \")\").to_strbuf()\n+        format_strbuf!(\"({})\", strs.connect(\",\"))\n       }\n       ty_closure(ref f) => {\n           closure_to_str(cx, *f)"}, {"sha": "5d4350f8fb5cd9479191c631f85c2d79e0a1e652", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -26,6 +26,7 @@ use t = syntax::parse::token;\n \n /// Highlights some source code, returning the HTML output.\n pub fn highlight(src: &str, class: Option<&str>) -> StrBuf {\n+    debug!(\"highlighting: ================\\n{}\\n==============\", src);\n     let sess = parse::new_parse_sess();\n     let fm = parse::string_to_filemap(&sess,\n                                       src.to_strbuf(),"}, {"sha": "d6831e225bc2931384cf9a663a44170146e9386b", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -149,6 +149,7 @@ pub fn render(w: &mut io::Writer, s: &str, print_toc: bool) -> fmt::Result {\n             let my_opaque: &MyOpaque = &*((*opaque).opaque as *MyOpaque);\n             slice::raw::buf_as_slice((*text).data, (*text).size as uint, |text| {\n                 let text = str::from_utf8(text).unwrap();\n+                debug!(\"docblock: ==============\\n{}\\n=======\", text);\n                 let mut lines = text.lines().filter(|l| {\n                     stripped_filtered_line(*l).is_none()\n                 });"}, {"sha": "7afac6801519b652fe9453886c004164ced706f9", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 72, "deletions": 9, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -19,7 +19,8 @@ use std::rt::task::BlockedTask;\n use homing::{HomingIO, HomeHandle};\n use pipe::PipeWatcher;\n use super::{UvHandle, UvError, uv_error_to_io_error,\n-            wait_until_woken_after, wakeup};\n+            wait_until_woken_after, wakeup, Loop};\n+use timer::TimerWatcher;\n use uvio::UvIoFactory;\n use uvll;\n \n@@ -32,6 +33,16 @@ pub struct Process {\n \n     /// Collected from the exit_cb\n     exit_status: Option<process::ProcessExit>,\n+\n+    /// Lazily initialized timeout timer\n+    timer: Option<Box<TimerWatcher>>,\n+    timeout_state: TimeoutState,\n+}\n+\n+enum TimeoutState {\n+    NoTimeout,\n+    TimeoutPending,\n+    TimeoutElapsed,\n }\n \n impl Process {\n@@ -92,6 +103,8 @@ impl Process {\n                     home: io_loop.make_handle(),\n                     to_wake: None,\n                     exit_status: None,\n+                    timer: None,\n+                    timeout_state: NoTimeout,\n                 };\n                 match unsafe {\n                     uvll::uv_spawn(io_loop.uv_loop(), handle, &options)\n@@ -223,21 +236,71 @@ impl RtioProcess for Process {\n         }\n     }\n \n-    fn wait(&mut self) -> process::ProcessExit {\n+    fn wait(&mut self) -> Result<process::ProcessExit, IoError> {\n         // Make sure (on the home scheduler) that we have an exit status listed\n         let _m = self.fire_homing_missile();\n         match self.exit_status {\n-            Some(..) => {}\n-            None => {\n-                // If there's no exit code previously listed, then the\n-                // process's exit callback has yet to be invoked. We just\n-                // need to deschedule ourselves and wait to be reawoken.\n+            Some(status) => return Ok(status),\n+            None => {}\n+        }\n+\n+        // If there's no exit code previously listed, then the process's exit\n+        // callback has yet to be invoked. We just need to deschedule ourselves\n+        // and wait to be reawoken.\n+        match self.timeout_state {\n+            NoTimeout | TimeoutPending => {\n                 wait_until_woken_after(&mut self.to_wake, &self.uv_loop(), || {});\n-                assert!(self.exit_status.is_some());\n             }\n+            TimeoutElapsed => {}\n+        }\n+\n+        // If there's still no exit status listed, then we timed out, and we\n+        // need to return.\n+        match self.exit_status {\n+            Some(status) => Ok(status),\n+            None => Err(uv_error_to_io_error(UvError(uvll::ECANCELED)))\n+        }\n+    }\n+\n+    fn set_timeout(&mut self, timeout: Option<u64>) {\n+        let _m = self.fire_homing_missile();\n+        self.timeout_state = NoTimeout;\n+        let ms = match timeout {\n+            Some(ms) => ms,\n+            None => {\n+                match self.timer {\n+                    Some(ref mut timer) => timer.stop(),\n+                    None => {}\n+                }\n+                return\n+            }\n+        };\n+        if self.timer.is_none() {\n+            let loop_ = Loop::wrap(unsafe {\n+                uvll::get_loop_for_uv_handle(self.uv_handle())\n+            });\n+            let mut timer = box TimerWatcher::new_home(&loop_, self.home().clone());\n+            unsafe {\n+                timer.set_data(self as *mut _ as *Process);\n+            }\n+            self.timer = Some(timer);\n         }\n \n-        self.exit_status.unwrap()\n+        let timer = self.timer.get_mut_ref();\n+        timer.stop();\n+        timer.start(timer_cb, ms, 0);\n+        self.timeout_state = TimeoutPending;\n+\n+        extern fn timer_cb(timer: *uvll::uv_timer_t) {\n+            let p: &mut Process = unsafe {\n+                &mut *(uvll::get_data_for_uv_handle(timer) as *mut Process)\n+            };\n+            p.timeout_state = TimeoutElapsed;\n+            match p.to_wake.take() {\n+                Some(task) => { let _t = task.wake().map(|t| t.reawaken()); }\n+                None => {}\n+            }\n+        }\n     }\n }\n "}, {"sha": "f834a158588cde31ab71907da5e7bcaa89bedc91", "filename": "src/libstd/bitflags.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -207,6 +207,13 @@ mod tests {\n         assert_eq!(FlagABC.bits(), 0x00000111);\n     }\n \n+    #[test]\n+    fn test_from_bits() {\n+        assert!(unsafe { Flags::from_bits(0x00000000) } == Flags::empty());\n+        assert!(unsafe { Flags::from_bits(0x00000001) } == FlagA);\n+        assert!(unsafe { Flags::from_bits(0x00000111) } == FlagABC);\n+    }\n+\n     #[test]\n     fn test_is_empty(){\n         assert!(Flags::empty().is_empty());"}, {"sha": "349cac723ff5b3303d487accbcb7283c6fd14599", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 131, "deletions": 59, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -10,6 +10,8 @@\n \n //! Bindings for executing child processes\n \n+#![allow(experimental)]\n+\n use prelude::*;\n \n use fmt;\n@@ -50,7 +52,7 @@ use rt::rtio::{RtioProcess, IoFactory, LocalIo};\n /// };\n ///\n /// let contents = child.stdout.get_mut_ref().read_to_end();\n-/// assert!(child.wait().success());\n+/// assert!(child.wait().unwrap().success());\n /// ```\n pub struct Process {\n     handle: Box<RtioProcess:Send>,\n@@ -284,7 +286,7 @@ impl Process {\n     /// println!(\"stderr: {}\", str::from_utf8_lossy(output.error.as_slice()));\n     /// ```\n     pub fn output(prog: &str, args: &[~str]) -> IoResult<ProcessOutput> {\n-        Process::new(prog, args).map(|mut p| p.wait_with_output())\n+        Process::new(prog, args).and_then(|p| p.wait_with_output())\n     }\n \n     /// Executes a child process and collects its exit status. This will block\n@@ -303,7 +305,7 @@ impl Process {\n     /// println!(\"process exited with: {}\", status);\n     /// ```\n     pub fn status(prog: &str, args: &[~str]) -> IoResult<ProcessExit> {\n-        Process::new(prog, args).map(|mut p| p.wait())\n+        Process::new(prog, args).and_then(|mut p| p.wait())\n     }\n \n     /// Creates a new process with the specified configuration.\n@@ -378,17 +380,72 @@ impl Process {\n     /// after it has been called at least once.\n     ///\n     /// The stdin handle to the child process will be closed before waiting.\n-    pub fn wait(&mut self) -> ProcessExit {\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function can fail if a timeout was previously specified via\n+    /// `set_timeout` and the timeout expires before the child exits.\n+    pub fn wait(&mut self) -> IoResult<ProcessExit> {\n         drop(self.stdin.take());\n         self.handle.wait()\n     }\n \n+    /// Sets a timeout, in milliseconds, for future calls to wait().\n+    ///\n+    /// The argument specified is a relative distance into the future, in\n+    /// milliseconds, after which any call to wait() will return immediately\n+    /// with a timeout error, and all future calls to wait() will not block.\n+    ///\n+    /// A value of `None` will clear any previous timeout, and a value of `Some`\n+    /// will override any previously set timeout.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```no_run\n+    /// # #![allow(experimental)]\n+    /// use std::io::process::{Process, ProcessExit};\n+    /// use std::io::IoResult;\n+    ///\n+    /// fn run_gracefully(prog: &str) -> IoResult<ProcessExit> {\n+    ///     let mut p = try!(Process::new(\"long-running-process\", []));\n+    ///\n+    ///     // give the process 10 seconds to finish completely\n+    ///     p.set_timeout(Some(10_000));\n+    ///     match p.wait() {\n+    ///         Ok(status) => return Ok(status),\n+    ///         Err(..) => {}\n+    ///     }\n+    ///\n+    ///     // Attempt to exit gracefully, but don't wait for it too long\n+    ///     try!(p.signal_exit());\n+    ///     p.set_timeout(Some(1_000));\n+    ///     match p.wait() {\n+    ///         Ok(status) => return Ok(status),\n+    ///         Err(..) => {}\n+    ///     }\n+    ///\n+    ///     // Well, we did our best, forcefully kill the process\n+    ///     try!(p.signal_kill());\n+    ///     p.set_timeout(None);\n+    ///     p.wait()\n+    /// }\n+    /// ```\n+    #[experimental = \"the type of the timeout is likely to change\"]\n+    pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n+        self.handle.set_timeout(timeout_ms)\n+    }\n+\n     /// Simultaneously wait for the child to exit and collect all remaining\n     /// output on the stdout/stderr handles, returning a `ProcessOutput`\n     /// instance.\n     ///\n     /// The stdin handle to the child is closed before waiting.\n-    pub fn wait_with_output(&mut self) -> ProcessOutput {\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function can fail for any of the same reasons that `wait()` can\n+    /// fail.\n+    pub fn wait_with_output(mut self) -> IoResult<ProcessOutput> {\n         drop(self.stdin.take());\n         fn read(stream: Option<io::PipeStream>) -> Receiver<IoResult<Vec<u8>>> {\n             let (tx, rx) = channel();\n@@ -404,11 +461,13 @@ impl Process {\n         let stdout = read(self.stdout.take());\n         let stderr = read(self.stderr.take());\n \n-        let status = self.wait();\n+        let status = try!(self.wait());\n \n-        ProcessOutput { status: status,\n-                        output: stdout.recv().ok().unwrap_or(Vec::new()),\n-                        error:  stderr.recv().ok().unwrap_or(Vec::new()) }\n+        Ok(ProcessOutput {\n+            status: status,\n+            output: stdout.recv().ok().unwrap_or(Vec::new()),\n+            error:  stderr.recv().ok().unwrap_or(Vec::new()),\n+        })\n     }\n }\n \n@@ -421,7 +480,8 @@ impl Drop for Process {\n         drop(self.stderr.take());\n         drop(mem::replace(&mut self.extra_io, Vec::new()));\n \n-        self.wait();\n+        self.set_timeout(None);\n+        let _ = self.wait().unwrap();\n     }\n }\n \n@@ -441,7 +501,7 @@ mod tests {\n         let p = Process::configure(args);\n         assert!(p.is_ok());\n         let mut p = p.unwrap();\n-        assert!(p.wait().success());\n+        assert!(p.wait().unwrap().success());\n     })\n \n     #[cfg(not(target_os=\"android\"))]\n@@ -465,7 +525,7 @@ mod tests {\n         let p = Process::configure(args);\n         assert!(p.is_ok());\n         let mut p = p.unwrap();\n-        assert!(p.wait().matches_exit_status(1));\n+        assert!(p.wait().unwrap().matches_exit_status(1));\n         drop(p.wait().clone());\n     })\n \n@@ -479,7 +539,7 @@ mod tests {\n         let p = Process::configure(args);\n         assert!(p.is_ok());\n         let mut p = p.unwrap();\n-        match p.wait() {\n+        match p.wait().unwrap() {\n             process::ExitSignal(1) => {},\n             result => fail!(\"not terminated by signal 1 (instead, {})\", result),\n         }\n@@ -495,7 +555,7 @@ mod tests {\n         let mut p = p.unwrap();\n         assert!(p.stdout.is_some());\n         let ret = read_all(p.stdout.get_mut_ref() as &mut Reader);\n-        assert!(p.wait().success());\n+        assert!(p.wait().unwrap().success());\n         return ret;\n     }\n \n@@ -536,7 +596,7 @@ mod tests {\n         p.stdin.get_mut_ref().write(\"foobar\".as_bytes()).unwrap();\n         drop(p.stdin.take());\n         let out = read_all(p.stdout.get_mut_ref() as &mut Reader);\n-        assert!(p.wait().success());\n+        assert!(p.wait().unwrap().success());\n         assert_eq!(out, \"foobar\\n\".to_owned());\n     })\n \n@@ -548,7 +608,7 @@ mod tests {\n             .. ProcessConfig::new()\n         };\n         let mut p = Process::configure(args).unwrap();\n-        assert!(p.wait().success());\n+        assert!(p.wait().unwrap().success());\n     })\n \n     #[cfg(windows)]\n@@ -572,7 +632,7 @@ mod tests {\n             .. ProcessConfig::new()\n         };\n         let mut p = Process::configure(args).unwrap();\n-        assert!(p.wait().success());\n+        assert!(p.wait().unwrap().success());\n     })\n \n     #[cfg(unix, not(target_os=\"android\"))]\n@@ -635,21 +695,21 @@ mod tests {\n     #[cfg(not(target_os=\"android\"))]\n     iotest!(fn test_finish_once() {\n         let mut prog = Process::new(\"false\", []).unwrap();\n-        assert!(prog.wait().matches_exit_status(1));\n+        assert!(prog.wait().unwrap().matches_exit_status(1));\n     })\n \n     #[cfg(not(target_os=\"android\"))]\n     iotest!(fn test_finish_twice() {\n         let mut prog = Process::new(\"false\", []).unwrap();\n-        assert!(prog.wait().matches_exit_status(1));\n-        assert!(prog.wait().matches_exit_status(1));\n+        assert!(prog.wait().unwrap().matches_exit_status(1));\n+        assert!(prog.wait().unwrap().matches_exit_status(1));\n     })\n \n     #[cfg(not(target_os=\"android\"))]\n     iotest!(fn test_wait_with_output_once() {\n \n-        let mut prog = Process::new(\"echo\", [\"hello\".to_owned()]).unwrap();\n-        let ProcessOutput {status, output, error} = prog.wait_with_output();\n+        let prog = Process::new(\"echo\", [\"hello\".to_owned()]).unwrap();\n+        let ProcessOutput {status, output, error} = prog.wait_with_output().unwrap();\n         let output_str = str::from_utf8(output.as_slice()).unwrap();\n \n         assert!(status.success());\n@@ -660,30 +720,6 @@ mod tests {\n         }\n     })\n \n-    #[cfg(not(target_os=\"android\"))]\n-    iotest!(fn test_wait_with_output_twice() {\n-        let mut prog = Process::new(\"echo\", [\"hello\".to_owned()]).unwrap();\n-        let ProcessOutput {status, output, error} = prog.wait_with_output();\n-\n-        let output_str = str::from_utf8(output.as_slice()).unwrap();\n-\n-        assert!(status.success());\n-        assert_eq!(output_str.trim().to_owned(), \"hello\".to_owned());\n-        // FIXME #7224\n-        if !running_on_valgrind() {\n-            assert_eq!(error, Vec::new());\n-        }\n-\n-        let ProcessOutput {status, output, error} = prog.wait_with_output();\n-\n-        assert!(status.success());\n-        assert_eq!(output, Vec::new());\n-        // FIXME #7224\n-        if !running_on_valgrind() {\n-            assert_eq!(error, Vec::new());\n-        }\n-    })\n-\n     #[cfg(unix,not(target_os=\"android\"))]\n     pub fn run_pwd(dir: Option<&Path>) -> Process {\n         Process::configure(ProcessConfig {\n@@ -714,9 +750,10 @@ mod tests {\n \n     iotest!(fn test_keep_current_working_dir() {\n         use os;\n-        let mut prog = run_pwd(None);\n+        let prog = run_pwd(None);\n \n-        let output = str::from_utf8(prog.wait_with_output().output.as_slice()).unwrap().to_owned();\n+        let output = str::from_utf8(prog.wait_with_output().unwrap()\n+                                        .output.as_slice()).unwrap().to_owned();\n         let parent_dir = os::getcwd();\n         let child_dir = Path::new(output.trim());\n \n@@ -732,9 +769,10 @@ mod tests {\n         // test changing to the parent of os::getcwd() because we know\n         // the path exists (and os::getcwd() is not expected to be root)\n         let parent_dir = os::getcwd().dir_path();\n-        let mut prog = run_pwd(Some(&parent_dir));\n+        let prog = run_pwd(Some(&parent_dir));\n \n-        let output = str::from_utf8(prog.wait_with_output().output.as_slice()).unwrap().to_owned();\n+        let output = str::from_utf8(prog.wait_with_output().unwrap()\n+                                        .output.as_slice()).unwrap().to_owned();\n         let child_dir = Path::new(output.trim());\n \n         let parent_stat = parent_dir.stat().unwrap();\n@@ -777,8 +815,9 @@ mod tests {\n         use os;\n         if running_on_valgrind() { return; }\n \n-        let mut prog = run_env(None);\n-        let output = str::from_utf8(prog.wait_with_output().output.as_slice()).unwrap().to_owned();\n+        let prog = run_env(None);\n+        let output = str::from_utf8(prog.wait_with_output().unwrap()\n+                                        .output.as_slice()).unwrap().to_owned();\n \n         let r = os::env();\n         for &(ref k, ref v) in r.iter() {\n@@ -791,8 +830,10 @@ mod tests {\n         use os;\n         if running_on_valgrind() { return; }\n \n-        let mut prog = run_env(None);\n-        let output = str::from_utf8(prog.wait_with_output().output.as_slice()).unwrap().to_owned();\n+        let prog = run_env(None);\n+        let output = str::from_utf8(prog.wait_with_output()\n+                                        .unwrap().output.as_slice())\n+                                   .unwrap().to_owned();\n \n         let r = os::env();\n         for &(ref k, ref v) in r.iter() {\n@@ -807,8 +848,8 @@ mod tests {\n     iotest!(fn test_add_to_env() {\n         let new_env = box [(\"RUN_TEST_NEW_ENV\".to_owned(), \"123\".to_owned())];\n \n-        let mut prog = run_env(Some(new_env));\n-        let result = prog.wait_with_output();\n+        let prog = run_env(Some(new_env));\n+        let result = prog.wait_with_output().unwrap();\n         let output = str::from_utf8_lossy(result.output.as_slice()).into_owned();\n \n         assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"),\n@@ -830,26 +871,57 @@ mod tests {\n     iotest!(fn test_kill() {\n         let mut p = sleeper();\n         Process::kill(p.id(), PleaseExitSignal).unwrap();\n-        assert!(!p.wait().success());\n+        assert!(!p.wait().unwrap().success());\n     })\n \n     iotest!(fn test_exists() {\n         let mut p = sleeper();\n         assert!(Process::kill(p.id(), 0).is_ok());\n         p.signal_kill().unwrap();\n-        assert!(!p.wait().success());\n+        assert!(!p.wait().unwrap().success());\n     })\n \n     iotest!(fn test_zero() {\n         let mut p = sleeper();\n         p.signal_kill().unwrap();\n         for _ in range(0, 20) {\n             if p.signal(0).is_err() {\n-                assert!(!p.wait().success());\n+                assert!(!p.wait().unwrap().success());\n                 return\n             }\n             timer::sleep(100);\n         }\n         fail!(\"never saw the child go away\");\n     })\n+\n+    iotest!(fn wait_timeout() {\n+        let mut p = sleeper();\n+        p.set_timeout(Some(10));\n+        assert_eq!(p.wait().err().unwrap().kind, TimedOut);\n+        assert_eq!(p.wait().err().unwrap().kind, TimedOut);\n+        p.signal_kill().unwrap();\n+        p.set_timeout(None);\n+        assert!(p.wait().is_ok());\n+    })\n+\n+    iotest!(fn wait_timeout2() {\n+        let (tx, rx) = channel();\n+        let tx2 = tx.clone();\n+        spawn(proc() {\n+            let mut p = sleeper();\n+            p.set_timeout(Some(10));\n+            assert_eq!(p.wait().err().unwrap().kind, TimedOut);\n+            p.signal_kill().unwrap();\n+            tx.send(());\n+        });\n+        spawn(proc() {\n+            let mut p = sleeper();\n+            p.set_timeout(Some(10));\n+            assert_eq!(p.wait().err().unwrap().kind, TimedOut);\n+            p.signal_kill().unwrap();\n+            tx2.send(());\n+        });\n+        rx.recv();\n+        rx.recv();\n+    })\n }"}, {"sha": "a37f9a516fdb92afda011f05a15d4869ae14ffc4", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -133,14 +133,16 @@ extern crate core;\n #[cfg(test)] pub use ops = realstd::ops;\n #[cfg(test)] pub use cmp = realstd::cmp;\n #[cfg(test)] pub use ty = realstd::ty;\n-#[cfg(test)] pub use owned = realstd::owned;\n+#[cfg(not(stage0), test)] pub use owned = realstd::owned;\n \n #[cfg(not(test))] pub use cmp = core::cmp;\n #[cfg(not(test))] pub use kinds = core::kinds;\n #[cfg(not(test))] pub use ops = core::ops;\n-#[cfg(not(test))] pub use owned = core::owned;\n #[cfg(not(test))] pub use ty = core::ty;\n \n+#[cfg(stage0, test)] pub use owned = realstd::owned;\n+#[cfg(stage0, not(test))] pub use owned = core::owned;\n+\n pub use core::any;\n pub use core::bool;\n pub use core::cell;\n@@ -207,6 +209,8 @@ pub mod ascii;\n \n pub mod rc;\n pub mod gc;\n+#[cfg(not(stage0), not(test))]\n+pub mod owned;\n \n /* Common traits */\n "}, {"sha": "3af12c5154c29d5f08847f5ca209ff53f477781d", "filename": "src/libstd/owned.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibstd%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibstd%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fowned.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -0,0 +1,101 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations on unique pointer types\n+\n+use any::{Any, AnyRefExt};\n+use clone::Clone;\n+use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering};\n+use default::Default;\n+use intrinsics;\n+use mem;\n+use raw::TraitObject;\n+use result::{Ok, Err, Result};\n+\n+/// A value that represents the global exchange heap. This is the default\n+/// place that the `box` keyword allocates into when no place is supplied.\n+///\n+/// The following two examples are equivalent:\n+///\n+///     let foo = box(HEAP) Bar::new(...);\n+///     let foo = box Bar::new(...);\n+#[lang=\"exchange_heap\"]\n+pub static HEAP: () = ();\n+\n+/// A type that represents a uniquely-owned value.\n+#[lang=\"owned_box\"]\n+pub struct Box<T>(*T);\n+\n+impl<T: Default> Default for Box<T> {\n+    fn default() -> Box<T> { box Default::default() }\n+}\n+\n+impl<T: Clone> Clone for Box<T> {\n+    /// Return a copy of the owned box.\n+    #[inline]\n+    fn clone(&self) -> Box<T> { box {(**self).clone()} }\n+\n+    /// Perform copy-assignment from `source` by reusing the existing allocation.\n+    #[inline]\n+    fn clone_from(&mut self, source: &Box<T>) {\n+        (**self).clone_from(&(**source));\n+    }\n+}\n+\n+// box pointers\n+impl<T:Eq> Eq for Box<T> {\n+    #[inline]\n+    fn eq(&self, other: &Box<T>) -> bool { *(*self) == *(*other) }\n+    #[inline]\n+    fn ne(&self, other: &Box<T>) -> bool { *(*self) != *(*other) }\n+}\n+impl<T:Ord> Ord for Box<T> {\n+    #[inline]\n+    fn lt(&self, other: &Box<T>) -> bool { *(*self) < *(*other) }\n+    #[inline]\n+    fn le(&self, other: &Box<T>) -> bool { *(*self) <= *(*other) }\n+    #[inline]\n+    fn ge(&self, other: &Box<T>) -> bool { *(*self) >= *(*other) }\n+    #[inline]\n+    fn gt(&self, other: &Box<T>) -> bool { *(*self) > *(*other) }\n+}\n+impl<T: TotalOrd> TotalOrd for Box<T> {\n+    #[inline]\n+    fn cmp(&self, other: &Box<T>) -> Ordering { (**self).cmp(*other) }\n+}\n+impl<T: TotalEq> TotalEq for Box<T> {}\n+\n+/// Extension methods for an owning `Any` trait object\n+pub trait AnyOwnExt {\n+    /// Returns the boxed value if it is of type `T`, or\n+    /// `Err(Self)` if it isn't.\n+    fn move<T: 'static>(self) -> Result<Box<T>, Self>;\n+}\n+\n+impl AnyOwnExt for Box<Any> {\n+    #[inline]\n+    fn move<T: 'static>(self) -> Result<Box<T>, Box<Any>> {\n+        if self.is::<T>() {\n+            unsafe {\n+                // Get the raw representation of the trait object\n+                let to: TraitObject =\n+                    *mem::transmute::<&Box<Any>, &TraitObject>(&self);\n+\n+                // Prevent destructor on self being run\n+                intrinsics::forget(self);\n+\n+                // Extract the data pointer\n+                Ok(mem::transmute(to.data))\n+            }\n+        } else {\n+            Err(self)\n+        }\n+    }\n+}"}, {"sha": "90f97e59caadad6a4d0960d95fcc2f9d4b2355ee", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -275,7 +275,8 @@ pub trait RtioFileStream {\n pub trait RtioProcess {\n     fn id(&self) -> libc::pid_t;\n     fn kill(&mut self, signal: int) -> IoResult<()>;\n-    fn wait(&mut self) -> ProcessExit;\n+    fn wait(&mut self) -> IoResult<ProcessExit>;\n+    fn set_timeout(&mut self, timeout: Option<u64>);\n }\n \n pub trait RtioPipe {"}, {"sha": "31a2014530607ff5d596d0d6d48e94f599892ce7", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -13,7 +13,6 @@\n //! local storage, and logging. Even a 'freestanding' Rust would likely want\n //! to implement this.\n \n-use any::AnyOwnExt;\n use cleanup;\n use clone::Clone;\n use comm::Sender;\n@@ -24,7 +23,7 @@ use local_data;\n use mem;\n use ops::Drop;\n use option::{Option, Some, None};\n-use owned::Box;\n+use owned::{AnyOwnExt, Box};\n use prelude::drop;\n use result::{Result, Ok, Err};\n use rt::Runtime;"}, {"sha": "fa4cf8e4427d0473b14e10fc5ebf1f1f8f35f101", "filename": "src/libstd/str.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -228,25 +228,25 @@ fn canonical_sort(comb: &mut [(char, u8)]) {\n }\n \n #[deriving(Clone)]\n-enum NormalizationForm {\n-    NFD,\n-    NFKD\n+enum DecompositionType {\n+    Canonical,\n+    Compatible\n }\n \n-/// External iterator for a string's normalization's characters.\n+/// External iterator for a string's decomposition's characters.\n /// Use with the `std::iter` module.\n #[deriving(Clone)]\n-pub struct Normalizations<'a> {\n-    kind: NormalizationForm,\n+pub struct Decompositions<'a> {\n+    kind: DecompositionType,\n     iter: Chars<'a>,\n     buffer: Vec<(char, u8)>,\n     sorted: bool\n }\n \n-impl<'a> Iterator<char> for Normalizations<'a> {\n+impl<'a> Iterator<char> for Decompositions<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<char> {\n-        use unicode::decompose::canonical_combining_class;\n+        use unicode::normalization::canonical_combining_class;\n \n         match self.buffer.as_slice().head() {\n             Some(&(c, 0)) => {\n@@ -262,8 +262,8 @@ impl<'a> Iterator<char> for Normalizations<'a> {\n         }\n \n         let decomposer = match self.kind {\n-            NFD => char::decompose_canonical,\n-            NFKD => char::decompose_compatible\n+            Canonical => char::decompose_canonical,\n+            Compatible => char::decompose_compatible\n         };\n \n         if !self.sorted {\n@@ -887,24 +887,24 @@ pub trait StrAllocating: Str {\n     /// An Iterator over the string in Unicode Normalization Form D\n     /// (canonical decomposition).\n     #[inline]\n-    fn nfd_chars<'a>(&'a self) -> Normalizations<'a> {\n-        Normalizations {\n+    fn nfd_chars<'a>(&'a self) -> Decompositions<'a> {\n+        Decompositions {\n             iter: self.as_slice().chars(),\n             buffer: Vec::new(),\n             sorted: false,\n-            kind: NFD\n+            kind: Canonical\n         }\n     }\n \n     /// An Iterator over the string in Unicode Normalization Form KD\n     /// (compatibility decomposition).\n     #[inline]\n-    fn nfkd_chars<'a>(&'a self) -> Normalizations<'a> {\n-        Normalizations {\n+    fn nfkd_chars<'a>(&'a self) -> Decompositions<'a> {\n+        Decompositions {\n             iter: self.as_slice().chars(),\n             buffer: Vec::new(),\n             sorted: false,\n-            kind: NFKD\n+            kind: Compatible\n         }\n     }\n }"}, {"sha": "7fb61c29112dee8b26ecaaa5b587677240c4a5d4", "filename": "src/libstd/task.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -47,10 +47,11 @@ use rt::local::Local;\n use rt::task::Task;\n use str::{Str, SendStr, IntoMaybeOwned};\n \n-#[cfg(test)] use any::{AnyOwnExt, AnyRefExt};\n+#[cfg(test)] use any::AnyRefExt;\n+#[cfg(test)] use owned::AnyOwnExt;\n+#[cfg(test)] use realstd::result::ResultUnwrap;\n #[cfg(test)] use result;\n #[cfg(test)] use str::StrAllocating;\n-#[cfg(test)] use realstd::result::ResultUnwrap;\n \n /// Indicates the manner in which a task exited.\n ///"}, {"sha": "03c960e96ffe17ebdcd7836f18cf929e5a535282", "filename": "src/libstd/unicode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibstd%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibstd%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funicode.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// The following code was generated by \"src/etc/unicode.py\"\n+// NOTE: The following code was generated by \"src/etc/unicode.py\", do not edit directly\n \n #![allow(missing_doc, non_uppercase_statics)]\n \n-pub mod decompose {\n+pub mod normalization {\n     use option::{Some, None};\n     use slice::ImmutableVector;\n "}, {"sha": "e5ef31a95a38b5bc3c79cecdbbf9e314cc77c35d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -711,7 +711,8 @@ pub enum IntTy {\n \n impl fmt::Show for IntTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}\", ast_util::int_ty_to_str(*self, None))\n+        write!(f.buf, \"{}\",\n+               ast_util::int_ty_to_str(*self, None, ast_util::AutoSuffix))\n     }\n }\n \n@@ -726,7 +727,8 @@ pub enum UintTy {\n \n impl fmt::Show for UintTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}\", ast_util::uint_ty_to_str(*self, None))\n+        write!(f.buf, \"{}\",\n+               ast_util::uint_ty_to_str(*self, None, ast_util::AutoSuffix))\n     }\n }\n "}, {"sha": "fb69e440b2fb4256beb907346c8b7b30cf8e9ae8", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -132,11 +132,19 @@ pub fn is_path(e: @Expr) -> bool {\n     return match e.node { ExprPath(_) => true, _ => false };\n }\n \n+pub enum SuffixMode {\n+    ForceSuffix,\n+    AutoSuffix,\n+}\n+\n // Get a string representation of a signed int type, with its value.\n // We want to avoid \"45int\" and \"-3int\" in favor of \"45\" and \"-3\"\n-pub fn int_ty_to_str(t: IntTy, val: Option<i64>) -> StrBuf {\n+pub fn int_ty_to_str(t: IntTy, val: Option<i64>, mode: SuffixMode) -> StrBuf {\n     let s = match t {\n-        TyI if val.is_some() => \"\",\n+        TyI if val.is_some() => match mode {\n+            AutoSuffix => \"\",\n+            ForceSuffix => \"i\",\n+        },\n         TyI => \"int\",\n         TyI8 => \"i8\",\n         TyI16 => \"i16\",\n@@ -145,7 +153,10 @@ pub fn int_ty_to_str(t: IntTy, val: Option<i64>) -> StrBuf {\n     };\n \n     match val {\n-        Some(n) => format!(\"{}{}\", n, s).to_strbuf(),\n+        // cast to a u64 so we can correctly print INT64_MIN. All integral types\n+        // are parsed as u64, so we wouldn't want to print an extra negative\n+        // sign.\n+        Some(n) => format!(\"{}{}\", n as u64, s).to_strbuf(),\n         None => s.to_strbuf()\n     }\n }\n@@ -161,9 +172,12 @@ pub fn int_ty_max(t: IntTy) -> u64 {\n \n // Get a string representation of an unsigned int type, with its value.\n // We want to avoid \"42uint\" in favor of \"42u\"\n-pub fn uint_ty_to_str(t: UintTy, val: Option<u64>) -> StrBuf {\n+pub fn uint_ty_to_str(t: UintTy, val: Option<u64>, mode: SuffixMode) -> StrBuf {\n     let s = match t {\n-        TyU if val.is_some() => \"u\",\n+        TyU if val.is_some() => match mode {\n+            AutoSuffix => \"\",\n+            ForceSuffix => \"u\",\n+        },\n         TyU => \"uint\",\n         TyU8 => \"u8\",\n         TyU16 => \"u16\","}, {"sha": "6df4da89402199b3f50864a2a12b2faa21ca93ba", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -182,6 +182,7 @@ use std::cell::RefCell;\n use ast;\n use ast::{P, EnumDef, Expr, Ident, Generics, StructDef};\n use ast_util;\n+use attr::AttrMetaMethods;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use codemap;\n@@ -330,21 +331,34 @@ impl<'a> TraitDef<'a> {\n                   _mitem: @ast::MetaItem,\n                   item: @ast::Item,\n                   push: |@ast::Item|) {\n-        match item.node {\n+        let newitem = match item.node {\n             ast::ItemStruct(struct_def, ref generics) => {\n-                push(self.expand_struct_def(cx,\n-                                            struct_def,\n-                                            item.ident,\n-                                            generics));\n+                self.expand_struct_def(cx,\n+                                       struct_def,\n+                                       item.ident,\n+                                       generics)\n             }\n             ast::ItemEnum(ref enum_def, ref generics) => {\n-                push(self.expand_enum_def(cx,\n-                                          enum_def,\n-                                          item.ident,\n-                                          generics));\n+                self.expand_enum_def(cx,\n+                                     enum_def,\n+                                     item.ident,\n+                                     generics)\n             }\n-            _ => ()\n-        }\n+            _ => return\n+        };\n+        // Keep the lint attributes of the previous item to control how the\n+        // generated implementations are linted\n+        let mut attrs = newitem.attrs.clone();\n+        attrs.extend(item.attrs.iter().filter(|a| {\n+            match a.name().get() {\n+                \"allow\" | \"warn\" | \"deny\" | \"forbid\" => true,\n+                _ => false,\n+            }\n+        }).map(|a| a.clone()));\n+        push(@ast::Item {\n+            attrs: attrs,\n+            ..(*newitem).clone()\n+        })\n     }\n \n     /**"}, {"sha": "1898e8bf000a8c581e047f3408c69df4c98f3af5", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -156,7 +156,7 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n             //     }\n             //   }\n \n-            let local_ident = token::gensym_ident(\"i\");\n+            let local_ident = token::gensym_ident(\"__i\"); // FIXME #13573\n             let next_ident = fld.cx.ident_of(\"next\");\n             let none_ident = fld.cx.ident_of(\"None\");\n \n@@ -262,7 +262,8 @@ pub fn expand_item(it: @ast::Item, fld: &mut MacroExpander)\n     let it = expand_item_modifiers(it, fld);\n \n     let mut decorator_items = SmallVector::zero();\n-    for attr in it.attrs.iter().rev() {\n+    let mut new_attrs = Vec::new();\n+    for attr in it.attrs.iter() {\n         let mname = attr.name();\n \n         match fld.extsbox.find(&intern(mname.get())) {\n@@ -286,22 +287,29 @@ pub fn expand_item(it: @ast::Item, fld: &mut MacroExpander)\n \n                 fld.cx.bt_pop();\n             }\n-            _ => {}\n+            _ => new_attrs.push((*attr).clone()),\n         }\n     }\n \n     let mut new_items = match it.node {\n         ast::ItemMac(..) => expand_item_mac(it, fld),\n         ast::ItemMod(_) | ast::ItemForeignMod(_) => {\n             fld.cx.mod_push(it.ident);\n-            let macro_escape = contains_macro_escape(it.attrs.as_slice());\n+            let macro_escape = contains_macro_escape(new_attrs.as_slice());\n             let result = with_exts_frame!(fld.extsbox,\n                                           macro_escape,\n                                           noop_fold_item(it, fld));\n             fld.cx.mod_pop();\n             result\n         },\n-        _ => noop_fold_item(it, fld)\n+        _ => {\n+            let it = @ast::Item {\n+                attrs: new_attrs,\n+                ..(*it).clone()\n+\n+            };\n+            noop_fold_item(it, fld)\n+        }\n     };\n \n     new_items.push_all(decorator_items);"}, {"sha": "92e5f8da6aa7ec78a8f13a3908236f7225d10dfd", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 54, "deletions": 9, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -587,16 +587,64 @@ impl<'a> Parser<'a> {\n                 self.replace_token(token::BINOP(token::OR), lo, self.span.hi)\n             }\n             _ => {\n-                let token_str = self.this_token_to_str();\n-                let found_token =\n+                let found_token = self.this_token_to_str();\n+                let token_str =\n                     Parser::token_to_str(&token::BINOP(token::OR));\n                 self.fatal(format!(\"expected `{}`, found `{}`\",\n-                                   found_token,\n-                                   token_str))\n+                                   token_str, found_token))\n             }\n         }\n     }\n \n+    // Attempt to consume a `<`. If `<<` is seen, replace it with a single\n+    // `<` and continue. If a `<` is not seen, return false.\n+    //\n+    // This is meant to be used when parsing generics on a path to get the\n+    // starting token. The `force` parameter is used to forcefully break up a\n+    // `<<` token. If `force` is false, then `<<` is only broken when a lifetime\n+    // shows up next. For example, consider the expression:\n+    //\n+    //      foo as bar << test\n+    //\n+    // The parser needs to know if `bar <<` is the start of a generic path or if\n+    // it's a left-shift token. If `test` were a lifetime, then it's impossible\n+    // for the token to be a left-shift, but if it's not a lifetime, then it's\n+    // considered a left-shift.\n+    //\n+    // The reason for this is that the only current ambiguity with `<<` is when\n+    // parsing closure types:\n+    //\n+    //      foo::<<'a> ||>();\n+    //      impl Foo<<'a> ||>() { ... }\n+    fn eat_lt(&mut self, force: bool) -> bool {\n+        match self.token {\n+            token::LT => { self.bump(); true }\n+            token::BINOP(token::SHL) => {\n+                let next_lifetime = self.look_ahead(1, |t| match *t {\n+                    token::LIFETIME(..) => true,\n+                    _ => false,\n+                });\n+                if force || next_lifetime {\n+                    let lo = self.span.lo + BytePos(1);\n+                    self.replace_token(token::LT, lo, self.span.hi);\n+                    true\n+                } else {\n+                    false\n+                }\n+            }\n+            _ => false,\n+        }\n+    }\n+\n+    fn expect_lt(&mut self) {\n+        if !self.eat_lt(true) {\n+            let found_token = self.this_token_to_str();\n+            let token_str = Parser::token_to_str(&token::LT);\n+            self.fatal(format!(\"expected `{}`, found `{}`\",\n+                               token_str, found_token))\n+        }\n+    }\n+\n     // Parse a sequence bracketed by `|` and `|`, stopping before the `|`.\n     fn parse_seq_to_before_or<T>(\n                               &mut self,\n@@ -1500,7 +1548,7 @@ impl<'a> Parser<'a> {\n \n             // Parse the `<` before the lifetime and types, if applicable.\n             let (any_lifetime_or_types, lifetimes, types) = {\n-                if mode != NoTypesAllowed && self.eat(&token::LT) {\n+                if mode != NoTypesAllowed && self.eat_lt(false) {\n                     let (lifetimes, types) =\n                         self.parse_generic_values_after_lt();\n                     (true, lifetimes, OwnedSlice::from_vec(types))\n@@ -1948,7 +1996,7 @@ impl<'a> Parser<'a> {\n                     hi = self.span.hi;\n                     self.bump();\n                     let (_, tys) = if self.eat(&token::MOD_SEP) {\n-                        self.expect(&token::LT);\n+                        self.expect_lt();\n                         self.parse_generic_values_after_lt()\n                     } else {\n                         (Vec::new(), Vec::new())\n@@ -2241,9 +2289,6 @@ impl<'a> Parser<'a> {\n               ExprVec(..) if m == MutImmutable => {\n                 ExprVstore(e, ExprVstoreSlice)\n               }\n-              ExprLit(lit) if lit_is_str(lit) && m == MutImmutable => {\n-                ExprVstore(e, ExprVstoreSlice)\n-              }\n               ExprVec(..) if m == MutMutable => {\n                 ExprVstore(e, ExprVstoreMutSlice)\n               }"}, {"sha": "68ce8cb2bc123104c9435fa7c103e170d7460c9b", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -203,9 +203,11 @@ pub fn to_str(t: &Token) -> StrBuf {\n           res.push_char('\\'');\n           res\n       }\n-      LIT_INT(i, t) => ast_util::int_ty_to_str(t, Some(i)),\n-      LIT_UINT(u, t) => ast_util::uint_ty_to_str(t, Some(u)),\n-      LIT_INT_UNSUFFIXED(i) => { i.to_str().to_strbuf() }\n+      LIT_INT(i, t) => ast_util::int_ty_to_str(t, Some(i),\n+                                               ast_util::ForceSuffix),\n+      LIT_UINT(u, t) => ast_util::uint_ty_to_str(t, Some(u),\n+                                                 ast_util::ForceSuffix),\n+      LIT_INT_UNSUFFIXED(i) => { (i as u64).to_str().to_strbuf() }\n       LIT_FLOAT(s, t) => {\n         let mut body = StrBuf::from_str(get_ident(s).get());\n         if body.as_slice().ends_with(\".\") {"}, {"sha": "15b931d58545ebc6406e86d2504307a6abfe28a7", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 59, "deletions": 30, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -168,7 +168,7 @@ pub fn tt_to_str(tt: &ast::TokenTree) -> StrBuf {\n }\n \n pub fn tts_to_str(tts: &[ast::TokenTree]) -> StrBuf {\n-    to_str(|s| s.print_tts(&tts))\n+    to_str(|s| s.print_tts(tts))\n }\n \n pub fn stmt_to_str(stmt: &ast::Stmt) -> StrBuf {\n@@ -247,6 +247,15 @@ pub fn visibility_qualified(vis: ast::Visibility, s: &str) -> StrBuf {\n     }\n }\n \n+fn needs_parentheses(expr: &ast::Expr) -> bool {\n+    match expr.node {\n+        ast::ExprAssign(..) | ast::ExprBinary(..) |\n+        ast::ExprFnBlock(..) | ast::ExprProc(..) |\n+        ast::ExprAssignOp(..) | ast::ExprCast(..) => true,\n+        _ => false,\n+    }\n+}\n+\n impl<'a> State<'a> {\n     pub fn ibox(&mut self, u: uint) -> IoResult<()> {\n         self.boxes.push(pp::Inconsistent);\n@@ -714,7 +723,7 @@ impl<'a> State<'a> {\n                 try!(self.print_ident(item.ident));\n                 try!(self.cbox(indent_unit));\n                 try!(self.popen());\n-                try!(self.print_tts(&(tts.as_slice())));\n+                try!(self.print_tts(tts.as_slice()));\n                 try!(self.pclose());\n                 try!(self.end());\n             }\n@@ -830,9 +839,15 @@ impl<'a> State<'a> {\n     /// expression arguments as expressions). It can be done! I think.\n     pub fn print_tt(&mut self, tt: &ast::TokenTree) -> IoResult<()> {\n         match *tt {\n-            ast::TTDelim(ref tts) => self.print_tts(&(tts.as_slice())),\n+            ast::TTDelim(ref tts) => self.print_tts(tts.as_slice()),\n             ast::TTTok(_, ref tk) => {\n-                word(&mut self.s, parse::token::to_str(tk).as_slice())\n+                try!(word(&mut self.s, parse::token::to_str(tk).as_slice()));\n+                match *tk {\n+                    parse::token::DOC_COMMENT(..) => {\n+                        hardbreak(&mut self.s)\n+                    }\n+                    _ => Ok(())\n+                }\n             }\n             ast::TTSeq(_, ref tts, ref sep, zerok) => {\n                 try!(word(&mut self.s, \"$(\"));\n@@ -856,7 +871,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_tts(&mut self, tts: & &[ast::TokenTree]) -> IoResult<()> {\n+    pub fn print_tts(&mut self, tts: &[ast::TokenTree]) -> IoResult<()> {\n         try!(self.ibox(0));\n         for (i, tt) in tts.iter().enumerate() {\n             if i != 0 {\n@@ -1113,7 +1128,7 @@ impl<'a> State<'a> {\n                 try!(self.print_path(pth, false));\n                 try!(word(&mut self.s, \"!\"));\n                 try!(self.popen());\n-                try!(self.print_tts(&tts.as_slice()));\n+                try!(self.print_tts(tts.as_slice()));\n                 self.pclose()\n             }\n         }\n@@ -1136,6 +1151,18 @@ impl<'a> State<'a> {\n         self.pclose()\n     }\n \n+    pub fn print_expr_maybe_paren(&mut self, expr: &ast::Expr) -> IoResult<()> {\n+        let needs_par = needs_parentheses(expr);\n+        if needs_par {\n+            try!(self.popen());\n+        }\n+        try!(self.print_expr(expr));\n+        if needs_par {\n+            try!(self.pclose());\n+        }\n+        Ok(())\n+    }\n+\n     pub fn print_expr(&mut self, expr: &ast::Expr) -> IoResult<()> {\n         try!(self.maybe_print_comment(expr.span.lo));\n         try!(self.ibox(indent_unit));\n@@ -1209,7 +1236,7 @@ impl<'a> State<'a> {\n                 try!(self.pclose());\n             }\n             ast::ExprCall(func, ref args) => {\n-                try!(self.print_expr(func));\n+                try!(self.print_expr_maybe_paren(func));\n                 try!(self.print_call_post(args.as_slice()));\n             }\n             ast::ExprMethodCall(ident, ref tys, ref args) => {\n@@ -1233,17 +1260,12 @@ impl<'a> State<'a> {\n             }\n             ast::ExprUnary(op, expr) => {\n                 try!(word(&mut self.s, ast_util::unop_to_str(op)));\n-                try!(self.print_expr(expr));\n+                try!(self.print_expr_maybe_paren(expr));\n             }\n             ast::ExprAddrOf(m, expr) => {\n                 try!(word(&mut self.s, \"&\"));\n                 try!(self.print_mutability(m));\n-                // Avoid `& &e` => `&&e`.\n-                match (m, &expr.node) {\n-                    (ast::MutImmutable, &ast::ExprAddrOf(..)) => try!(space(&mut self.s)),\n-                    _ => { }\n-                }\n-                try!(self.print_expr(expr));\n+                try!(self.print_expr_maybe_paren(expr));\n             }\n             ast::ExprLit(lit) => try!(self.print_literal(lit)),\n             ast::ExprCast(expr, ty) => {\n@@ -1474,22 +1496,27 @@ impl<'a> State<'a> {\n                 try!(self.popen());\n                 try!(self.print_string(a.asm.get(), a.asm_str_style));\n                 try!(self.word_space(\":\"));\n-                for &(ref co, o) in a.outputs.iter() {\n-                    try!(self.print_string(co.get(), ast::CookedStr));\n-                    try!(self.popen());\n-                    try!(self.print_expr(o));\n-                    try!(self.pclose());\n-                    try!(self.word_space(\",\"));\n-                }\n+\n+                try!(self.commasep(Inconsistent, a.outputs.as_slice(), |s, &(ref co, o)| {\n+                    try!(s.print_string(co.get(), ast::CookedStr));\n+                    try!(s.popen());\n+                    try!(s.print_expr(o));\n+                    try!(s.pclose());\n+                    Ok(())\n+                }));\n+                try!(space(&mut self.s));\n                 try!(self.word_space(\":\"));\n-                for &(ref co, o) in a.inputs.iter() {\n-                    try!(self.print_string(co.get(), ast::CookedStr));\n-                    try!(self.popen());\n-                    try!(self.print_expr(o));\n-                    try!(self.pclose());\n-                    try!(self.word_space(\",\"));\n-                }\n+\n+                try!(self.commasep(Inconsistent, a.inputs.as_slice(), |s, &(ref co, o)| {\n+                    try!(s.print_string(co.get(), ast::CookedStr));\n+                    try!(s.popen());\n+                    try!(s.print_expr(o));\n+                    try!(s.pclose());\n+                    Ok(())\n+                }));\n+                try!(space(&mut self.s));\n                 try!(self.word_space(\":\"));\n+\n                 try!(self.print_string(a.clobbers.get(), ast::CookedStr));\n                 try!(self.pclose());\n             }\n@@ -2211,11 +2238,13 @@ impl<'a> State<'a> {\n             }\n             ast::LitInt(i, t) => {\n                 word(&mut self.s,\n-                     ast_util::int_ty_to_str(t, Some(i)).as_slice())\n+                     ast_util::int_ty_to_str(t, Some(i),\n+                                             ast_util::AutoSuffix).as_slice())\n             }\n             ast::LitUint(u, t) => {\n                 word(&mut self.s,\n-                     ast_util::uint_ty_to_str(t, Some(u)).as_slice())\n+                     ast_util::uint_ty_to_str(t, Some(u),\n+                                              ast_util::ForceSuffix).as_slice())\n             }\n             ast::LitIntUnsuffixed(i) => {\n                 word(&mut self.s, format!(\"{}\", i))"}, {"sha": "717cd333a79ce800e41dee9ee23fb20871f5b2a1", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -754,3 +754,9 @@ LLVMRustGetSectionName(LLVMSectionIteratorRef SI, const char **ptr) {\n     *ptr = ret.data();\n     return ret.size();\n }\n+\n+// LLVMArrayType function does not support 64-bit ElementCount\n+extern \"C\" LLVMTypeRef\n+LLVMRustArrayType(LLVMTypeRef ElementType, uint64_t ElementCount) {\n+    return wrap(ArrayType::get(unwrap(ElementType), ElementCount));\n+}"}, {"sha": "a3bcbd201e199ef2f130f1bfdacdabdf300d055e", "filename": "src/test/auxiliary/cci_const_block.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Fauxiliary%2Fcci_const_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Fauxiliary%2Fcci_const_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_const_block.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub static BLOCK_FN_DEF: fn(uint) -> uint = {\n+    fn foo(a: uint) -> uint {\n+        a + 10\n+    }\n+    foo\n+};"}, {"sha": "53b371e06cbe0d14f02dcebce2f1cceafff67ef0", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -1,5 +1,3 @@\n-// ignore-pretty\n-\n // Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n@@ -10,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty very bad with line comments\n+\n extern crate collections;\n extern crate rand;\n extern crate time;"}, {"sha": "04032c4aa3903661c0ea30b1639672d67038e34b", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n // ignore-android: FIXME(#10393)\n+// ignore-pretty very bad with line comments\n \n-// ignore-pretty the `let to_child` line gets an extra newline\n // multi tasking k-nucleotide\n \n extern crate collections;"}, {"sha": "1434838e59bce81008381670be25f4a830cc4a95", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // ignore-android see #10393 #13206\n-// ignore-pretty\n \n extern crate sync;\n "}, {"sha": "e17324ee596491dfb58a87439bd880ce37e70060", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty very bad with line comments\n+\n extern crate sync;\n \n use std::io;"}, {"sha": "fdd711d22c760f93e9eb79f1ffb679f0746f0fba", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty very bad with line comments\n // ignore-android doesn't terminate?\n-// ignore-pretty\n \n use std::iter::range_step;\n use std::io::{stdin, stdout, File};"}, {"sha": "58568282e1584ab1c71d89254c1e55233f6577c6", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -1,5 +1,3 @@\n-// ignore-pretty\n-\n // Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n@@ -10,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty very bad with line comments\n+\n #![feature(managed_boxes)]\n \n use std::io;"}, {"sha": "442386e30586eb631cff7f9a4dc925f150fd137c", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -1,5 +1,3 @@\n-// ignore-pretty\n-\n // Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n@@ -17,6 +15,8 @@\n //\n // The filename is a song reference; google it in quotes.\n \n+// ignore-pretty very bad with line comments\n+\n use std::comm;\n use std::os;\n use std::task;"}, {"sha": "6b875ff268dd8dd3926423204b3e7f5378b6a24b", "filename": "src/test/compile-fail/borrowck-lend-flow-match.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-match.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty -- comments are unfaithfully preserved\n-\n #![allow(unused_variable)]\n #![allow(dead_assignment)]\n "}, {"sha": "f33e5e9b02d59d46826147fffc2762980697089b", "filename": "src/test/compile-fail/borrowck-pat-reassign-binding.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-binding.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty -- comments are unfaithfully preserved\n-\n fn main() {\n     let mut x: Option<int> = None;\n     match x {"}, {"sha": "68410ae4fe1965c0ccb3b8b6d44ba6fa1366c493", "filename": "src/test/compile-fail/borrowck-preserve-box-in-field.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-box-in-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-box-in-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-box-in-field.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -1,5 +1,3 @@\n-// ignore-pretty\n-\n // Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT."}, {"sha": "0db097ec003c20665f41a24e4cd24e90769d44c7", "filename": "src/test/compile-fail/borrowck-preserve-box-in-uniq.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-box-in-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-box-in-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-box-in-uniq.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -1,5 +1,3 @@\n-// ignore-pretty\n-\n // Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT."}, {"sha": "cd36d930604621f662f4a073aaee0e87843dc8d1", "filename": "src/test/compile-fail/borrowck-preserve-box.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-box.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -1,5 +1,3 @@\n-// ignore-pretty\n-\n // Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT."}, {"sha": "ca24192e797e23d205a88a5dc0c1ac00e3cec7e0", "filename": "src/test/compile-fail/borrowck-preserve-expl-deref.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-expl-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-expl-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-expl-deref.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -1,5 +1,3 @@\n-// ignore-pretty\n-\n // Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT."}, {"sha": "ace917c704acb7d49922105eabd1929891bfb137", "filename": "src/test/compile-fail/const-block-non-item-statement.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(macro_rules)]\n+\n+static A: uint = { 1; 2 };\n+//~^ ERROR: blocks in constants are limited to items and tail expressions\n+\n+static B: uint = { { } 2 };\n+//~^ ERROR: blocks in constants are limited to items and tail expressions\n+\n+macro_rules! foo {\n+    () => (()) //~ ERROR: blocks in constants are limited to items and tail expressions\n+}\n+static C: uint = { foo!() 2 };\n+\n+static D: uint = { let x = 4; 2 };\n+//~^ ERROR: blocks in constants are limited to items and tail expressions\n+\n+pub fn main() {\n+}"}, {"sha": "70ef4a0c0c3d307e9895ccbe78cc4560f8977ce6", "filename": "src/test/run-fail/run-unexported-tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-fail%2Frun-unexported-tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-fail%2Frun-unexported-tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frun-unexported-tests.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -11,6 +11,7 @@\n // error-pattern:runned an unexported test\n // compile-flags:--test\n // check-stdout\n+// ignore-pretty: does not work well with `--test`\n \n mod m {\n     pub fn exported() { }"}, {"sha": "b628f101fd5766b67e7315d0d5d8291ff5ee2aef", "filename": "src/test/run-fail/test-fail.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-fail%2Ftest-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-fail%2Ftest-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftest-fail.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -11,6 +11,7 @@\n // check-stdout\n // error-pattern:task 'test_foo' failed at\n // compile-flags: --test\n+// ignore-pretty: does not work well with `--test`\n \n #[test]\n fn test_foo() {"}, {"sha": "8c9cd2d63cb4758f4c29f40e3e2435294872a126", "filename": "src/test/run-fail/test-tasks-invalid-value.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-fail%2Ftest-tasks-invalid-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-fail%2Ftest-tasks-invalid-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftest-tasks-invalid-value.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -14,6 +14,7 @@\n // error-pattern:should be a positive integer\n // compile-flags: --test\n // exec-env:RUST_TEST_TASKS=foo\n+// ignore-pretty: does not work well with `--test`\n \n #[test]\n fn do_nothing() {}"}, {"sha": "2d5bbd43e826f23b38212dc5f4e7bf00333546f5", "filename": "src/test/run-pass-fulldeps/quote-unused-sp-no-warning.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass-fulldeps%2Fquote-unused-sp-no-warning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass-fulldeps%2Fquote-unused-sp-no-warning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fquote-unused-sp-no-warning.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n // ignore-android\n+// ignore-pretty: does not work well with `--test`\n+\n #![feature(quote)]\n #![deny(unused_variable)]\n "}, {"sha": "0ef666031114eacaae619625919022eb65fdaf95", "filename": "src/test/run-pass/anon-extern-mod-cross-crate-2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fanon-extern-mod-cross-crate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fanon-extern-mod-cross-crate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fanon-extern-mod-cross-crate-2.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty\n // aux-build:anon-extern-mod-cross-crate-1.rs\n extern crate anonexternmod;\n "}, {"sha": "c32d513f074558aaf5e876016956da7214808805", "filename": "src/test/run-pass/assert-eq-macro-success.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fassert-eq-macro-success.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fassert-eq-macro-success.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassert-eq-macro-success.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(managed_boxes)]\n+\n #[deriving(Eq, Show)]\n struct Point { x : int }\n "}, {"sha": "53fe91cff3745ee9302ae20f29ada0fb0a79dab6", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -50,7 +50,7 @@ fn runtest(me: &str) {\n         env: Some(env.as_slice()),\n         .. ProcessConfig::new()\n     }).unwrap();\n-    let out = p.wait_with_output();\n+    let out = p.wait_with_output().unwrap();\n     assert!(!out.status.success());\n     let s = str::from_utf8(out.error.as_slice()).unwrap();\n     assert!(s.contains(\"stack backtrace\") && s.contains(\"foo::h\"),\n@@ -62,7 +62,7 @@ fn runtest(me: &str) {\n         args: [\"fail\".to_owned()],\n         .. ProcessConfig::new()\n     }).unwrap();\n-    let out = p.wait_with_output();\n+    let out = p.wait_with_output().unwrap();\n     assert!(!out.status.success());\n     let s = str::from_utf8(out.error.as_slice()).unwrap();\n     assert!(!s.contains(\"stack backtrace\") && !s.contains(\"foo::h\"),\n@@ -74,7 +74,7 @@ fn runtest(me: &str) {\n         args: [\"double-fail\".to_owned()],\n         .. ProcessConfig::new()\n     }).unwrap();\n-    let out = p.wait_with_output();\n+    let out = p.wait_with_output().unwrap();\n     assert!(!out.status.success());\n     let s = str::from_utf8(out.error.as_slice()).unwrap();\n     assert!(s.contains(\"stack backtrace\") && s.contains(\"double::h\"),\n@@ -87,7 +87,7 @@ fn runtest(me: &str) {\n         env: Some(env.as_slice()),\n         .. ProcessConfig::new()\n     }).unwrap();\n-    let out = p.wait_with_output();\n+    let out = p.wait_with_output().unwrap();\n     assert!(!out.status.success());\n     let s = str::from_utf8(out.error.as_slice()).unwrap();\n     let mut i = 0;"}, {"sha": "3b2618c060d009cc40e93a9d69a5284835ed8d94", "filename": "src/test/run-pass/big-literals.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fbig-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fbig-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbig-literals.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -1,5 +1,3 @@\n-// ignore-pretty\n-\n // Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n@@ -18,4 +16,5 @@ pub fn main() {\n \n     assert_eq!(-2147483648i32 - 1i32, 2147483647i32);\n     assert_eq!(-9223372036854775808i64 - 1i64, 9223372036854775807i64);\n+    assert_eq!(-9223372036854775808 - 1, 9223372036854775807);\n }"}, {"sha": "69705996faddaf79dc95374845e42711bb397e74", "filename": "src/test/run-pass/binops.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fbinops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fbinops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinops.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -10,6 +10,8 @@\n \n // Binop corner cases\n \n+#![feature(managed_boxes)]\n+\n fn test_nil() {\n     assert_eq!((), ());\n     assert!((!(() != ())));"}, {"sha": "74ce8ef2e453162e18315081926b65adc525b25b", "filename": "src/test/run-pass/borrowck-pat-enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fborrowck-pat-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fborrowck-pat-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-pat-enum.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -1,5 +1,3 @@\n-// ignore-pretty\n-\n // Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n@@ -10,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty\n+\n fn match_ref(v: Option<int>) -> int {\n     match v {\n       Some(ref i) => {"}, {"sha": "10a3db5808e2d0ee1c2b2a83edd272eacf344599", "filename": "src/test/run-pass/box-compare.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fbox-compare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fbox-compare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-compare.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+#![feature(managed_boxes)]\n \n pub fn main() {\n     assert!((@1 < @3));"}, {"sha": "2bb0e6fa19c1590e95e1e0845d639e140c208631", "filename": "src/test/run-pass/closure-syntax.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fclosure-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fclosure-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-syntax.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty #13324\n-\n #![allow(dead_code)]\n \n fn foo<T>() {}\n@@ -45,6 +43,12 @@ fn g<'a>(a: &'a int, f: proc<'b>(&'b int) -> &'b int) -> &'a int {\n     f(a)\n }\n \n+struct A;\n+\n+impl A {\n+    fn foo<T>(&self) {}\n+}\n+\n fn bar<'b>() {\n     foo::<||>();\n     foo::<|| -> ()>();\n@@ -60,17 +64,25 @@ fn bar<'b>() {\n     foo::<proc():Share>();\n     foo::<proc<'a>(int, f32, &'a int):'static + Share -> &'a int>();\n \n+    foo::<<'a>||>();\n+\n     // issue #11209\n     let _: ||: 'b; // for comparison\n     let _: <'a> ||;\n \n     let _: Option<||:'b>;\n-    // let _: Option<<'a>||>;\n+    let _: Option<<'a>||>;\n     let _: Option< <'a>||>;\n \n     // issue #11210\n     let _: ||: 'static;\n+\n+    let a = A;\n+    a.foo::<<'a>||>();\n }\n \n+struct B<T>;\n+impl<'b> B<<'a>||: 'b> {}\n+\n pub fn main() {\n }"}, {"sha": "16360ff08d059af52a1be1772bd3d516a597c8f5", "filename": "src/test/run-pass/const-block-cross-crate-fn.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fconst-block-cross-crate-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fconst-block-cross-crate-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-block-cross-crate-fn.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:cci_const_block.rs\n+\n+extern crate cci_const_block;\n+\n+pub fn main() {\n+    assert_eq!(cci_const_block::BLOCK_FN_DEF(390), 400);\n+}"}, {"sha": "09f26b15734ff22a49a3cd9f09c65b16164b95b9", "filename": "src/test/run-pass/const-block-item-macro-codegen.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fconst-block-item-macro-codegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fconst-block-item-macro-codegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-block-item-macro-codegen.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// General test that function items in static blocks\n+// can be generated with a macro.\n+\n+#![feature(macro_rules)]\n+\n+struct MyType {\n+    desc: &'static str,\n+    data: uint,\n+    code: fn(uint, uint) -> uint\n+}\n+\n+impl MyType {\n+    fn eval(&self, a: uint) -> uint {\n+        (self.code)(self.data, a)\n+    }\n+}\n+\n+macro_rules! codegen {\n+    ($e:expr, $v:expr) => {\n+        {\n+            fn generated(a: uint, b: uint) -> uint {\n+                a - ($e * b)\n+            }\n+            MyType {\n+                desc: \"test\",\n+                data: $v,\n+                code: generated\n+            }\n+        }\n+    }\n+}\n+\n+static GENERATED_CODE_1: MyType = codegen!(2, 100);\n+static GENERATED_CODE_2: MyType = codegen!(5, 1000);\n+\n+pub fn main() {\n+    assert_eq!(GENERATED_CODE_1.eval(10), 80);\n+    assert_eq!(GENERATED_CODE_2.eval(100), 500);\n+}"}, {"sha": "3365f09cd80ab901ab56d8320519bee71921707b", "filename": "src/test/run-pass/const-block-item.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fconst-block-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fconst-block-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-block-item.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(macro_rules)]\n+\n+mod foo {\n+    pub trait Value {\n+        fn value(&self) -> uint;\n+    }\n+}\n+\n+static BLOCK_USE: uint = {\n+    use foo::Value;\n+    100\n+};\n+\n+static BLOCK_PUB_USE: uint = {\n+    pub use foo::Value;\n+    200\n+};\n+\n+static BLOCK_STRUCT_DEF: uint = {\n+    struct Foo {\n+        a: uint\n+    }\n+    Foo{ a: 300 }.a\n+};\n+\n+static BLOCK_FN_DEF: fn(uint) -> uint = {\n+    fn foo(a: uint) -> uint {\n+        a + 10\n+    }\n+    foo\n+};\n+\n+static BLOCK_MACRO_RULES: uint = {\n+    macro_rules! baz {\n+        () => (412)\n+    }\n+    baz!()\n+};\n+\n+pub fn main() {\n+    assert_eq!(BLOCK_USE, 100);\n+    assert_eq!(BLOCK_PUB_USE, 200);\n+    assert_eq!(BLOCK_STRUCT_DEF, 300);\n+    assert_eq!(BLOCK_FN_DEF(390), 400);\n+    assert_eq!(BLOCK_MACRO_RULES, 412);\n+}"}, {"sha": "feac6e68e48ad0ca6b6eed4e342bf57a1a8c195f", "filename": "src/test/run-pass/const-block.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fconst-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fconst-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-block.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -0,0 +1,69 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+#![allow(unused_unsafe)]\n+\n+struct Foo {\n+    a: uint,\n+    b: *()\n+}\n+\n+fn foo<T>(a: T) -> T {\n+    a\n+}\n+\n+static BLOCK_INTEGRAL: uint = { 1 };\n+static BLOCK_EXPLICIT_UNIT: () = { () };\n+static BLOCK_IMPLICIT_UNIT: () = { };\n+static BLOCK_FLOAT: f64 = { 1.0 };\n+static BLOCK_ENUM: Option<uint> = { Some(100) };\n+static BLOCK_STRUCT: Foo = { Foo { a: 12, b: 0 as *() } };\n+static BLOCK_UNSAFE: uint = unsafe { 1000 };\n+\n+// FIXME: #13970\n+// static BLOCK_FN_INFERRED: fn(uint) -> uint = { foo };\n+\n+// FIXME: #13971\n+// static BLOCK_FN: fn(uint) -> uint = { foo::<uint> };\n+\n+// FIXME: #13972\n+// static BLOCK_ENUM_CONSTRUCTOR: fn(uint) -> Option<uint> = { Some };\n+\n+// FIXME: #13973\n+// static BLOCK_UNSAFE_SAFE_PTR: &'static int = unsafe { &*(0xdeadbeef as *int) };\n+// static BLOCK_UNSAFE_SAFE_PTR_2: &'static int = unsafe {\n+//     static X: *int = 0xdeadbeef as *int;\n+//     &*X\n+// };\n+\n+pub fn main() {\n+    assert_eq!(BLOCK_INTEGRAL, 1);\n+    assert_eq!(BLOCK_EXPLICIT_UNIT, ());\n+    assert_eq!(BLOCK_IMPLICIT_UNIT, ());\n+    assert_eq!(BLOCK_FLOAT, 1.0_f64);\n+    assert_eq!(BLOCK_STRUCT.a, 12);\n+    assert_eq!(BLOCK_STRUCT.b, 0 as *());\n+    assert_eq!(BLOCK_ENUM, Some(100));\n+    assert_eq!(BLOCK_UNSAFE, 1000);\n+\n+    // FIXME: #13970\n+    // assert_eq!(BLOCK_FN_INFERRED(300), 300);\n+\n+    // FIXME: #13971\n+    // assert_eq!(BLOCK_FN(300), 300);\n+\n+    // FIXME: #13972\n+    // assert_eq!(BLOCK_ENUM_CONSTRUCTOR(200), Some(200));\n+\n+    // FIXME: #13973\n+    // assert_eq!(BLOCK_UNSAFE_SAFE_PTR as *int as uint, 0xdeadbeef_u);\n+    // assert_eq!(BLOCK_UNSAFE_SAFE_PTR_2 as *int as uint, 0xdeadbeef_u);\n+}"}, {"sha": "01a71d862b4ff9396a89b363277e5947e18ad85c", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -120,7 +120,7 @@ pub fn test_destroy_actually_kills(force: bool) {\n             () = rx1.recv() => {}\n         }\n     });\n-    match p.wait() {\n+    match p.wait().unwrap() {\n         ExitStatus(..) => fail!(\"expected a signal\"),\n         ExitSignal(..) => tx.send(()),\n     }"}, {"sha": "cbf6a1c50df1df125008a2b4ae88c891f85881b0", "filename": "src/test/run-pass/deriving-global.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fderiving-global.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fderiving-global.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-global.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -8,20 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty - does not converge\n-\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-extern crate serialize; // {En,De}codable\n-extern crate rand; // Rand\n+extern crate serialize;\n+extern crate rand;\n \n mod submod {\n     // if any of these are implemented without global calls for any"}, {"sha": "ee90cfd3475b1a87adb269be2f0f71a80173e20f", "filename": "src/test/run-pass/hygienic-labels-in-let.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fhygienic-labels-in-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fhygienic-labels-in-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhygienic-labels-in-let.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty: pprust doesn't print hygiene output\n+\n #![feature(macro_rules)]\n \n macro_rules! loop_x {"}, {"sha": "56d265233baf1b7bc5c904094e9b27d445e32966", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -8,8 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// no-pretty-expanded unnecessary unsafe block generated\n \n-#![feature(macro_rules)]\n+#![feature(macro_rules, managed_boxes)]\n #![deny(warnings)]\n #![allow(unused_must_use)]\n #![allow(deprecated_owned_vector)]\n@@ -76,6 +77,7 @@ pub fn main() {\n     t!(format!(\"{foo} {1} {bar} {0}\", 0, 1, foo=2, bar=3), \"2 1 3 0\");\n     t!(format!(\"{} {0}\", \"a\"), \"a a\");\n     t!(format!(\"{foo_bar}\", foo_bar=1), \"1\");\n+    t!(format!(\"{:d}\", 5 + 5), \"10\");\n \n     // Methods should probably work\n     t!(format!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 0u), \"c0\");"}, {"sha": "ef5ef2f215cc25fdcab8966cc3ff9d75cee4f0cb", "filename": "src/test/run-pass/invoke-external-foreign.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Finvoke-external-foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Finvoke-external-foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finvoke-external-foreign.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty\n // aux-build:foreign_lib.rs\n \n // The purpose of this test is to check that we can"}, {"sha": "fc1825d22cd94f8b6f99e7fd82a2e19eab49c729", "filename": "src/test/run-pass/issue-13304.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13304.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -52,7 +52,7 @@ fn parent(flavor: ~str) {\n     let args = args.as_slice();\n     let mut p = io::Process::new(args[0].as_slice(), [\"child\".to_owned(), flavor]).unwrap();\n     p.stdin.get_mut_ref().write_str(\"test1\\ntest2\\ntest3\").unwrap();\n-    let out = p.wait_with_output();\n+    let out = p.wait_with_output().unwrap();\n     assert!(out.status.success());\n     let s = str::from_utf8(out.output.as_slice()).unwrap();\n     assert_eq!(s, \"test1\\n\\ntest2\\n\\ntest3\\n\");"}, {"sha": "86c9b8c69646941d5f6809ed467018ae989f9661", "filename": "src/test/run-pass/issue-8391.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fissue-8391.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fissue-8391.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8391.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -9,8 +9,9 @@\n // except according to those terms.\n \n fn main() {\n-    let _x = match Some(1) {\n-        _y @ Some(_) => 1,\n+    let x = match Some(1) {\n+        ref _y @ Some(_) => 1,\n         None => 2,\n     };\n+    assert_eq!(x, 1);\n }"}, {"sha": "f87c22bdb57c3d0bf2089514cba17bce176d601e", "filename": "src/test/run-pass/logging-separate-lines.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Flogging-separate-lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Flogging-separate-lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flogging-separate-lines.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -36,7 +36,7 @@ fn main() {\n         env: Some(env.as_slice()),\n         ..ProcessConfig::new()\n     };\n-    let p = Process::configure(config).unwrap().wait_with_output();\n+    let p = Process::configure(config).unwrap().wait_with_output().unwrap();\n     assert!(p.status.success());\n     let mut lines = str::from_utf8(p.error.as_slice()).unwrap().lines();\n     assert!(lines.next().unwrap().contains(\"foo\"));"}, {"sha": "728c0154a90e950d8bf23e520129e588403bd9ed", "filename": "src/test/run-pass/nullable-pointer-iotareduction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n+#![feature(macro_rules, managed_boxes)]\n \n use std::{option, mem};\n "}, {"sha": "0ca8efb3fdc91a986421229429fbe3aaf8a0bf88", "filename": "src/test/run-pass/nullable-pointer-size.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fnullable-pointer-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fnullable-pointer-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnullable-pointer-size.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n+#![feature(macro_rules, managed_boxes)]\n \n use std::mem;\n "}, {"sha": "585ade71fc6037278aef2a9d93733a5b2ec38a0b", "filename": "src/test/run-pass/numeric-method-autoexport.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fnumeric-method-autoexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fnumeric-method-autoexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnumeric-method-autoexport.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -1,5 +1,3 @@\n-// ignore-pretty\n-\n // Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n@@ -10,10 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// no-pretty-expanded\n+\n // This file is intended to test only that methods are automatically\n // reachable for each numeric type, for each exported impl, with no imports\n // necessary. Testing the methods of the impls is done within the source\n // file for each numeric type.\n+\n pub fn main() {\n // ints\n     // num"}, {"sha": "7752aed7236a687616f2e1e04a1e9c7d7e40847b", "filename": "src/test/run-pass/objects-owned-object-borrowed-method-header.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fobjects-owned-object-borrowed-method-header.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fobjects-owned-object-borrowed-method-header.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobjects-owned-object-borrowed-method-header.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -1,5 +1,3 @@\n-// ignore-pretty\n-\n // Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT."}, {"sha": "f41f2619032bc99b60c7d83aaae841b8e0bcafbd", "filename": "src/test/run-pass/process-detach.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fprocess-detach.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fprocess-detach.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-detach.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -54,7 +54,7 @@ fn main() {\n     // Wait for the child process to die (terminate it's stdin and the read\n     // should fail).\n     drop(p.stdin.take());\n-    match p.wait() {\n+    match p.wait().unwrap() {\n         process::ExitStatus(..) => {}\n         process::ExitSignal(..) => fail!()\n     }"}, {"sha": "45af7d5de3481e6b4be3a24b880e1bf5908a4bed", "filename": "src/test/run-pass/process-spawn-with-unicode-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -62,7 +62,7 @@ fn main() {\n             cwd: Some(&cwd),\n             env: Some(my_env.append_one(env).as_slice()),\n             .. ProcessConfig::new()\n-        }).unwrap().wait_with_output();\n+        }).unwrap().wait_with_output().unwrap();\n \n         // display the output\n         assert!(io::stdout().write(p.output.as_slice()).is_ok());"}, {"sha": "2f78513b95cf9c7f132ca72c4d5ecb226d190b7a", "filename": "src/test/run-pass/shebang.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fshebang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fshebang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fshebang.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -9,6 +9,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// pp-exact\n+// ignore-pretty: `expand` addes some preludes before shebang\n \n pub fn main() { println!(\"Hello World\"); }"}, {"sha": "2b42e3ada542879fa083edf961c3e66ea55f0820", "filename": "src/test/run-pass/sigpipe-should-be-ignored.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fsigpipe-should-be-ignored.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fsigpipe-should-be-ignored.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsigpipe-should-be-ignored.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -31,5 +31,5 @@ fn main() {\n     }\n \n     let mut p = Process::new(args[0], [\"test\".to_owned()]).unwrap();\n-    assert!(p.wait().success());\n+    assert!(p.wait().unwrap().success());\n }"}, {"sha": "1204efc29ebd39344ebf1bc758174f627ffc1968", "filename": "src/test/run-pass/super-fast-paren-parsing.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fsuper-fast-paren-parsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fsuper-fast-paren-parsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsuper-fast-paren-parsing.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty\n+// exec-env:RUST_MIN_STACK=8000000\n+//\n+// Big stack is needed for pretty printing, a little sad...\n \n static a: int =\n ((((((((((((((((((((((((((((((((((((((((((((((((((("}, {"sha": "309325ab7db4a1fca09d2efbc931833e2f8a8124", "filename": "src/test/run-pass/test-ignore-cfg.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // compile-flags: --test --cfg ignorecfg\n+// ignore-pretty: does not work well with `--test`\n \n #[test]\n #[ignore(cfg(ignorecfg))]"}, {"sha": "05d5506f0a6b0df599d135befd9596f544789979", "filename": "src/test/run-pass/test-runner-hides-main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Ftest-runner-hides-main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Ftest-runner-hides-main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftest-runner-hides-main.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -10,6 +10,7 @@\n \n // compile-flags:--test\n // ignore-win32 #10872\n+// ignore-pretty: does not work well with `--test`\n \n // Building as a test runner means that a synthetic main will be run,\n // not ours"}, {"sha": "98dd3772a4f9276be8cb9aa836ee6aff114c6120", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -1,5 +1,3 @@\n-// ignore-pretty\n-\n // Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT."}, {"sha": "ae4623c6e66eb3b050c8a2a1645b6652c5a67a2d", "filename": "src/test/run-pass/unit-like-struct-drop-run.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Funit-like-struct-drop-run.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Funit-like-struct-drop-run.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funit-like-struct-drop-run.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -10,7 +10,7 @@\n \n // Make sure the destructor is run for unit-like structs.\n \n-use std::any::AnyOwnExt;\n+use std::owned::AnyOwnExt;\n use std::task;\n \n struct Foo;"}, {"sha": "5116b4e746a05cd066837b497e3fbed7a4f51be6", "filename": "src/test/run-pass/vec-fixed-length.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fvec-fixed-length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b383cab5959b1ec331e1d77583fa944b7fd593/src%2Ftest%2Frun-pass%2Fvec-fixed-length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-fixed-length.rs?ref=b2b383cab5959b1ec331e1d77583fa944b7fd593", "patch": "@@ -8,7 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::mem::size_of;\n+\n pub fn main() {\n     let x: [int, ..4] = [1, 2, 3, 4];\n-    println!(\"{}\", x[0]);\n+    assert_eq!(x[0], 1);\n+    assert_eq!(x[1], 2);\n+    assert_eq!(x[2], 3);\n+    assert_eq!(x[3], 4);\n+\n+    assert_eq!(size_of::<[u8, ..4]>(), 4u);\n+\n+    // FIXME #10183\n+    if cfg!(target_word_size = \"64\") {\n+        assert_eq!(size_of::<[u8, ..(1 << 32)]>(), (1u << 32));\n+    }\n }"}]}