{"sha": "7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmMmQyYWZhOTE5NmJhNjMxNGEyOWU1OGQ1MzI0ZGJkOTkyM2M3NWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-30T07:34:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-30T07:34:19Z"}, "message": "Auto merge of #38697 - alexcrichton:rollup, r=alexcrichton\n\nRollup of 25 pull requests\n\n- Successful merges: #37149, #38491, #38517, #38559, #38587, #38609, #38611, #38622, #38628, #38630, #38631, #38632, #38635, #38647, #38649, #38655, #38659, #38660, #38662, #38665, #38671, #38674, #38676, #38693, #38695\n- Failed merges: #38657, #38680", "tree": {"sha": "483907141a5dcd2cfc7e4ea91f7234d77bddf83b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/483907141a5dcd2cfc7e4ea91f7234d77bddf83b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "html_url": "https://github.com/rust-lang/rust/commit/7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75f5981d4500e52de767d61ec50a34b97be2a301", "url": "https://api.github.com/repos/rust-lang/rust/commits/75f5981d4500e52de767d61ec50a34b97be2a301", "html_url": "https://github.com/rust-lang/rust/commit/75f5981d4500e52de767d61ec50a34b97be2a301"}, {"sha": "e484197482698ee0bb83a66987a5f64c46ae306b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e484197482698ee0bb83a66987a5f64c46ae306b", "html_url": "https://github.com/rust-lang/rust/commit/e484197482698ee0bb83a66987a5f64c46ae306b"}], "stats": {"total": 1322, "additions": 1022, "deletions": 300}, "files": [{"sha": "b19877e38432cddbae19a8149c559443a498f852", "filename": ".travis.yml", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -19,7 +19,8 @@ matrix:\n     - env: IMAGE=i686-gnu-nopt\n     - env: IMAGE=x86_64-freebsd\n     - env: IMAGE=x86_64-gnu\n-    - env: IMAGE=x86_64-gnu-cargotest\n+    - env: IMAGE=x86_64-gnu-full-bootstrap\n+    - env: IMAGE=x86_64-gnu-aux\n     - env: IMAGE=x86_64-gnu-debug\n     - env: IMAGE=x86_64-gnu-nopt\n     - env: IMAGE=x86_64-gnu-make\n@@ -66,10 +67,10 @@ script:\n       if [ \"$ALLOW_PR\" = \"\" ] && [ \"$TRAVIS_BRANCH\" != \"auto\" ]; then\n           echo skipping, not a full build;\n       elif [ \"$TRAVIS_OS_NAME\" = \"osx\" ]; then\n-          git submodule update --init;\n+          git submodule update --init &&\n           src/ci/run.sh;\n       else\n-          git submodule update --init;\n+          git submodule update --init &&\n           src/ci/docker/run.sh $IMAGE;\n       fi\n \n@@ -78,7 +79,7 @@ before_cache:\n   - docker history -q rust-ci |\n     grep -v missing |\n     xargs docker save |\n-    gzip -9 > $HOME/docker/rust-ci.tar.gz\n+    gzip > $HOME/docker/rust-ci.tar.gz\n before_install:\n   - zcat $HOME/docker/rust-ci.tar.gz | docker load || true\n "}, {"sha": "c1218e9c600ce772e82b053083393e84ad44f47c", "filename": "README.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -82,8 +82,9 @@ build.\n    # Install build tools needed for Rust. If you're building a 32-bit compiler,\n    # then replace \"x86_64\" below with \"i686\". If you've already got git, python,\n    # or CMake installed and in PATH you can remove them from this list. Note\n-   # that it is important that the `python2` and `cmake` packages **not** used.\n-   # The build has historically been known to fail with these packages.\n+   # that it is important that you do **not** use the 'python2' and 'cmake'\n+   # packages from the 'msys2' subsystem. The build has historically been known\n+   # to fail with these packages.\n    $ pacman -S git \\\n                make \\\n                diffutils \\"}, {"sha": "a4b5cbc115253f6a1edef11c8a0fc3bd6ad510e7", "filename": "appveyor.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -21,7 +21,7 @@ environment:\n   # MSVC cargotest\n   - MSYS_BITS: 64\n     NO_VENDOR: 1\n-    RUST_CHECK_TARGET: check-cargotest\n+    RUST_CHECK_TARGET: check-aux\n     RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n \n   # 32/64-bit MinGW builds."}, {"sha": "5094e5a764bdfcae3a1624e95a7a19d7ff1c564d", "filename": "configure", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/configure", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -693,6 +693,7 @@ opt_nosave manage-submodules 1 \"let the build manage the git submodules\"\n opt_nosave clang 0 \"prefer clang to gcc for building the runtime\"\n opt_nosave jemalloc 1 \"build liballoc with jemalloc\"\n opt elf-tls 1 \"elf thread local storage on platforms where supported\"\n+opt full-bootstrap 0 \"build three compilers instead of two\"\n \n valopt_nosave prefix \"/usr/local\" \"set installation prefix\"\n valopt_nosave local-rust-root \"/usr/local\" \"set prefix for local rust binary\""}, {"sha": "ec0243908edab1bc1b4eb131ff6d04972eb02d83", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -341,12 +341,22 @@ pub fn krate(build: &Build,\n     println!(\"{} {} stage{} ({} -> {})\", test_kind, name, compiler.stage,\n              compiler.host, target);\n \n+    // If we're not doing a full bootstrap but we're testing a stage2 version of\n+    // libstd, then what we're actually testing is the libstd produced in\n+    // stage1. Reflect that here by updating the compiler that we're working\n+    // with automatically.\n+    let compiler = if build.force_use_stage1(compiler, target) {\n+        Compiler::new(1, compiler.host)\n+    } else {\n+        compiler.clone()\n+    };\n+\n     // Build up the base `cargo test` command.\n     //\n     // Pass in some standard flags then iterate over the graph we've discovered\n     // in `cargo metadata` with the maps above and figure out what `-p`\n     // arguments need to get passed.\n-    let mut cargo = build.cargo(compiler, mode, target, test_kind.subcommand());\n+    let mut cargo = build.cargo(&compiler, mode, target, test_kind.subcommand());\n     cargo.arg(\"--manifest-path\")\n          .arg(build.src.join(path).join(\"Cargo.toml\"))\n          .arg(\"--features\").arg(features);\n@@ -380,7 +390,7 @@ pub fn krate(build: &Build,\n     // Note that to run the compiler we need to run with the *host* libraries,\n     // but our wrapper scripts arrange for that to be the case anyway.\n     let mut dylib_path = dylib_path();\n-    dylib_path.insert(0, build.sysroot_libdir(compiler, target));\n+    dylib_path.insert(0, build.sysroot_libdir(&compiler, target));\n     cargo.env(dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n \n     if target.contains(\"android\") {\n@@ -399,10 +409,10 @@ pub fn krate(build: &Build,\n \n     if target.contains(\"android\") {\n         build.run(&mut cargo);\n-        krate_android(build, compiler, target, mode);\n+        krate_android(build, &compiler, target, mode);\n     } else if target.contains(\"emscripten\") {\n         build.run(&mut cargo);\n-        krate_emscripten(build, compiler, target, mode);\n+        krate_emscripten(build, &compiler, target, mode);\n     } else {\n         cargo.args(&build.flags.cmd.test_args());\n         build.run(&mut cargo);"}, {"sha": "dcccf78893521d73871c748117326e4a78770901", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 61, "deletions": 53, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -33,17 +33,12 @@ use {Build, Compiler, Mode};\n /// This will build the standard library for a particular stage of the build\n /// using the `compiler` targeting the `target` architecture. The artifacts\n /// created will also be linked into the sysroot directory.\n-pub fn std<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n-    println!(\"Building stage{} std artifacts ({} -> {})\", compiler.stage,\n-             compiler.host, target);\n-\n+pub fn std(build: &Build, target: &str, compiler: &Compiler) {\n     let libdir = build.sysroot_libdir(compiler, target);\n-    let _ = fs::remove_dir_all(&libdir);\n     t!(fs::create_dir_all(&libdir));\n \n-    // Some platforms have startup objects that may be required to produce the\n-    // libstd dynamic library, for example.\n-    build_startup_objects(build, target, &libdir);\n+    println!(\"Building stage{} std artifacts ({} -> {})\", compiler.stage,\n+             compiler.host, target);\n \n     let out_dir = build.cargo_out(compiler, Mode::Libstd, target);\n     build.clear_if_dirty(&out_dir, &build.compiler_path(compiler));\n@@ -65,29 +60,30 @@ pub fn std<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n \n     build.run(&mut cargo);\n     update_mtime(&libstd_stamp(build, &compiler, target));\n-    std_link(build, target, compiler.stage, compiler.host);\n }\n \n /// Link all libstd rlibs/dylibs into the sysroot location.\n ///\n-/// Links those artifacts generated in the given `stage` for `target` produced\n-/// by `compiler` into `host`'s sysroot.\n+/// Links those artifacts generated by `compiler` to a the `stage` compiler's\n+/// sysroot for the specified `host` and `target`.\n+///\n+/// Note that this assumes that `compiler` has already generated the libstd\n+/// libraries for `target`, and this method will find them in the relevant\n+/// output directory.\n pub fn std_link(build: &Build,\n-                target: &str,\n-                stage: u32,\n-                host: &str) {\n-    let compiler = Compiler::new(stage, &build.config.build);\n-    let target_compiler = Compiler::new(compiler.stage, host);\n+                compiler: &Compiler,\n+                target_compiler: &Compiler,\n+                target: &str) {\n+    println!(\"Copying stage{} std from stage{} ({} -> {} / {})\",\n+             target_compiler.stage,\n+             compiler.stage,\n+             compiler.host,\n+             target_compiler.host,\n+             target);\n     let libdir = build.sysroot_libdir(&target_compiler, target);\n     let out_dir = build.cargo_out(&compiler, Mode::Libstd, target);\n \n-    // If we're linking one compiler host's output into another, then we weren't\n-    // called from the `std` method above. In that case we clean out what's\n-    // already there.\n-    if host != compiler.host {\n-        let _ = fs::remove_dir_all(&libdir);\n-        t!(fs::create_dir_all(&libdir));\n-    }\n+    t!(fs::create_dir_all(&libdir));\n     add_to_sysroot(&out_dir, &libdir);\n \n     if target.contains(\"musl\") && !target.contains(\"mips\") {\n@@ -110,20 +106,23 @@ fn copy_musl_third_party_objects(build: &Build, target: &str, into: &Path) {\n /// They don't require any library support as they're just plain old object\n /// files, so we just use the nightly snapshot compiler to always build them (as\n /// no other compilers are guaranteed to be available).\n-fn build_startup_objects(build: &Build, target: &str, into: &Path) {\n+pub fn build_startup_objects(build: &Build, for_compiler: &Compiler, target: &str) {\n     if !target.contains(\"pc-windows-gnu\") {\n         return\n     }\n+\n     let compiler = Compiler::new(0, &build.config.build);\n     let compiler_path = build.compiler_path(&compiler);\n+    let into = build.sysroot_libdir(for_compiler, target);\n+    t!(fs::create_dir_all(&into));\n \n     for file in t!(fs::read_dir(build.src.join(\"src/rtstartup\"))) {\n         let file = t!(file);\n         let mut cmd = Command::new(&compiler_path);\n         build.run(cmd.env(\"RUSTC_BOOTSTRAP\", \"1\")\n                      .arg(\"--target\").arg(target)\n                      .arg(\"--emit=obj\")\n-                     .arg(\"--out-dir\").arg(into)\n+                     .arg(\"--out-dir\").arg(&into)\n                      .arg(file.path()));\n     }\n \n@@ -137,7 +136,7 @@ fn build_startup_objects(build: &Build, target: &str, into: &Path) {\n /// This will build libtest and supporting libraries for a particular stage of\n /// the build using the `compiler` targeting the `target` architecture. The\n /// artifacts created will also be linked into the sysroot directory.\n-pub fn test<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n+pub fn test(build: &Build, target: &str, compiler: &Compiler) {\n     println!(\"Building stage{} test artifacts ({} -> {})\", compiler.stage,\n              compiler.host, target);\n     let out_dir = build.cargo_out(compiler, Mode::Libtest, target);\n@@ -147,19 +146,19 @@ pub fn test<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n          .arg(build.src.join(\"src/rustc/test_shim/Cargo.toml\"));\n     build.run(&mut cargo);\n     update_mtime(&libtest_stamp(build, compiler, target));\n-    test_link(build, target, compiler.stage, compiler.host);\n }\n \n-/// Link all libtest rlibs/dylibs into the sysroot location.\n-///\n-/// Links those artifacts generated in the given `stage` for `target` produced\n-/// by `compiler` into `host`'s sysroot.\n+/// Same as `std_link`, only for libtest\n pub fn test_link(build: &Build,\n-                 target: &str,\n-                 stage: u32,\n-                 host: &str) {\n-    let compiler = Compiler::new(stage, &build.config.build);\n-    let target_compiler = Compiler::new(compiler.stage, host);\n+                 compiler: &Compiler,\n+                 target_compiler: &Compiler,\n+                 target: &str) {\n+    println!(\"Copying stage{} test from stage{} ({} -> {} / {})\",\n+             target_compiler.stage,\n+             compiler.stage,\n+             compiler.host,\n+             target_compiler.host,\n+             target);\n     let libdir = build.sysroot_libdir(&target_compiler, target);\n     let out_dir = build.cargo_out(&compiler, Mode::Libtest, target);\n     add_to_sysroot(&out_dir, &libdir);\n@@ -170,7 +169,7 @@ pub fn test_link(build: &Build,\n /// This will build the compiler for a particular stage of the build using\n /// the `compiler` targeting the `target` architecture. The artifacts\n /// created will also be linked into the sysroot directory.\n-pub fn rustc<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n+pub fn rustc(build: &Build, target: &str, compiler: &Compiler) {\n     println!(\"Building stage{} compiler artifacts ({} -> {})\",\n              compiler.stage, compiler.host, target);\n \n@@ -222,20 +221,19 @@ pub fn rustc<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n         cargo.env(\"CFG_DEFAULT_AR\", s);\n     }\n     build.run(&mut cargo);\n-\n-    rustc_link(build, target, compiler.stage, compiler.host);\n }\n \n-/// Link all librustc rlibs/dylibs into the sysroot location.\n-///\n-/// Links those artifacts generated in the given `stage` for `target` produced\n-/// by `compiler` into `host`'s sysroot.\n+/// Same as `std_link`, only for librustc\n pub fn rustc_link(build: &Build,\n-                  target: &str,\n-                  stage: u32,\n-                  host: &str) {\n-    let compiler = Compiler::new(stage, &build.config.build);\n-    let target_compiler = Compiler::new(compiler.stage, host);\n+                  compiler: &Compiler,\n+                  target_compiler: &Compiler,\n+                  target: &str) {\n+    println!(\"Copying stage{} rustc from stage{} ({} -> {} / {})\",\n+             target_compiler.stage,\n+             compiler.stage,\n+             compiler.host,\n+             target_compiler.host,\n+             target);\n     let libdir = build.sysroot_libdir(&target_compiler, target);\n     let out_dir = build.cargo_out(&compiler, Mode::Librustc, target);\n     add_to_sysroot(&out_dir, &libdir);\n@@ -259,6 +257,17 @@ fn compiler_file(compiler: &Path, file: &str) -> PathBuf {\n     PathBuf::from(out.trim())\n }\n \n+pub fn create_sysroot(build: &Build, compiler: &Compiler) {\n+    // nothing to do in stage0\n+    if compiler.stage == 0 {\n+        return\n+    }\n+\n+    let sysroot = build.sysroot(compiler);\n+    let _ = fs::remove_dir_all(&sysroot);\n+    t!(fs::create_dir_all(&sysroot));\n+}\n+\n /// Prepare a new compiler from the artifacts in `stage`\n ///\n /// This will assemble a compiler in `build/$host/stage$stage`. The compiler\n@@ -269,18 +278,17 @@ pub fn assemble_rustc(build: &Build, stage: u32, host: &str) {\n     if stage == 0 {\n         return\n     }\n+\n+    println!(\"Copying stage{} compiler ({})\", stage, host);\n+\n     // The compiler that we're assembling\n     let target_compiler = Compiler::new(stage, host);\n \n     // The compiler that compiled the compiler we're assembling\n     let build_compiler = Compiler::new(stage - 1, &build.config.build);\n \n-    // Clear out old files\n-    let sysroot = build.sysroot(&target_compiler);\n-    let _ = fs::remove_dir_all(&sysroot);\n-    t!(fs::create_dir_all(&sysroot));\n-\n     // Link in all dylibs to the libdir\n+    let sysroot = build.sysroot(&target_compiler);\n     let sysroot_libdir = sysroot.join(libdir(host));\n     t!(fs::create_dir_all(&sysroot_libdir));\n     let src_libdir = build.sysroot_libdir(&build_compiler, host);"}, {"sha": "9767afd73ca5d3f5e16957a0a850165af4730eb0", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -46,6 +46,7 @@ pub struct Config {\n     pub docs: bool,\n     pub vendor: bool,\n     pub target_config: HashMap<String, Target>,\n+    pub full_bootstrap: bool,\n \n     // llvm codegen options\n     pub llvm_assertions: bool,\n@@ -54,6 +55,7 @@ pub struct Config {\n     pub llvm_version_check: bool,\n     pub llvm_static_stdcpp: bool,\n     pub llvm_link_shared: bool,\n+    pub llvm_targets: Option<String>,\n \n     // rust codegen options\n     pub rust_optimize: bool,\n@@ -134,6 +136,7 @@ struct Build {\n     vendor: Option<bool>,\n     nodejs: Option<String>,\n     python: Option<String>,\n+    full_bootstrap: Option<bool>,\n }\n \n /// TOML representation of various global install decisions.\n@@ -152,6 +155,7 @@ struct Llvm {\n     release_debuginfo: Option<bool>,\n     version_check: Option<bool>,\n     static_libstdcpp: Option<bool>,\n+    targets: Option<String>,\n }\n \n #[derive(RustcDecodable)]\n@@ -264,6 +268,7 @@ impl Config {\n         set(&mut config.docs, build.docs);\n         set(&mut config.submodules, build.submodules);\n         set(&mut config.vendor, build.vendor);\n+        set(&mut config.full_bootstrap, build.full_bootstrap);\n \n         if let Some(ref install) = toml.install {\n             config.prefix = install.prefix.clone();\n@@ -285,6 +290,7 @@ impl Config {\n             set(&mut config.llvm_release_debuginfo, llvm.release_debuginfo);\n             set(&mut config.llvm_version_check, llvm.version_check);\n             set(&mut config.llvm_static_stdcpp, llvm.static_libstdcpp);\n+            config.llvm_targets = llvm.targets.clone();\n         }\n \n         if let Some(ref rust) = toml.rust {\n@@ -393,6 +399,7 @@ impl Config {\n                 (\"NINJA\", self.ninja),\n                 (\"CODEGEN_TESTS\", self.codegen_tests),\n                 (\"VENDOR\", self.vendor),\n+                (\"FULL_BOOTSTRAP\", self.full_bootstrap),\n             }\n \n             match key {"}, {"sha": "69210c4959b921e2e649bd62be3b40cbf8afaa51", "filename": "src/bootstrap/config.toml.example", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fbootstrap%2Fconfig.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fbootstrap%2Fconfig.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.toml.example?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -42,6 +42,17 @@\n # example.\n #ninja = false\n \n+# LLVM targets to build support for.\n+# Note: this is NOT related to Rust compilation targets. However, as Rust is\n+# dependent on LLVM for code generation, turning targets off here WILL lead to\n+# the resulting rustc being unable to compile for the disabled architectures.\n+# Also worth pointing out is that, in case support for new targets are added to\n+# LLVM, enabling them here doesn't mean Rust is automatically gaining said\n+# support. You'll need to write a target specification at least, and most\n+# likely, teach rustc about the C ABI of the target. Get in touch with the\n+# Rust team and file an issue if you need assistance in porting!\n+#targets = \"X86;ARM;AArch64;Mips;PowerPC;SystemZ;JSBackend;MSP430;Sparc;NVPTX\"\n+\n # =============================================================================\n # General build configuration options\n # =============================================================================\n@@ -100,6 +111,13 @@\n # Indicate whether the vendored sources are used for Rust dependencies or not\n #vendor = false\n \n+# Typically the build system will build the rust compiler twice. The second\n+# compiler, however, will simply use its own libraries to link against. If you\n+# would rather to perform a full bootstrap, compiling the compiler three times,\n+# then you can set this option to true. You shouldn't ever need to set this\n+# option to true.\n+#full-bootstrap = false\n+\n # =============================================================================\n # General install configuration options\n # ============================================================================="}, {"sha": "4c4462bf1220dd68261bd4a74f517e4b560699a5", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -137,6 +137,11 @@ pub fn std(build: &Build, stage: u32, target: &str) {\n     let out = build.doc_out(target);\n     t!(fs::create_dir_all(&out));\n     let compiler = Compiler::new(stage, &build.config.build);\n+    let compiler = if build.force_use_stage1(&compiler, target) {\n+        Compiler::new(1, compiler.host)\n+    } else {\n+        compiler\n+    };\n     let out_dir = build.stage_out(&compiler, Mode::Libstd)\n                        .join(target).join(\"doc\");\n     let rustdoc = build.rustdoc(&compiler);\n@@ -160,6 +165,11 @@ pub fn test(build: &Build, stage: u32, target: &str) {\n     let out = build.doc_out(target);\n     t!(fs::create_dir_all(&out));\n     let compiler = Compiler::new(stage, &build.config.build);\n+    let compiler = if build.force_use_stage1(&compiler, target) {\n+        Compiler::new(1, compiler.host)\n+    } else {\n+        compiler\n+    };\n     let out_dir = build.stage_out(&compiler, Mode::Libtest)\n                        .join(target).join(\"doc\");\n     let rustdoc = build.rustdoc(&compiler);\n@@ -182,6 +192,11 @@ pub fn rustc(build: &Build, stage: u32, target: &str) {\n     let out = build.doc_out(target);\n     t!(fs::create_dir_all(&out));\n     let compiler = Compiler::new(stage, &build.config.build);\n+    let compiler = if build.force_use_stage1(&compiler, target) {\n+        Compiler::new(1, compiler.host)\n+    } else {\n+        compiler\n+    };\n     let out_dir = build.stage_out(&compiler, Mode::Librustc)\n                        .join(target).join(\"doc\");\n     let rustdoc = build.rustdoc(&compiler);"}, {"sha": "49eaed4c67acd23658b3177a1126df13bf61db8c", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -572,9 +572,7 @@ impl Build {\n         let mut cmd = Command::new(self.tool(&compiler, tool));\n         let host = compiler.host;\n         let mut paths = vec![\n-            self.cargo_out(compiler, Mode::Libstd, host).join(\"deps\"),\n-            self.cargo_out(compiler, Mode::Libtest, host).join(\"deps\"),\n-            self.cargo_out(compiler, Mode::Librustc, host).join(\"deps\"),\n+            self.sysroot_libdir(compiler, compiler.host),\n             self.cargo_out(compiler, Mode::Tool, host).join(\"deps\"),\n         ];\n \n@@ -880,6 +878,30 @@ impl Build {\n     fn python(&self) -> &Path {\n         self.config.python.as_ref().unwrap()\n     }\n+\n+    /// Tests whether the `compiler` compiling for `target` should be forced to\n+    /// use a stage1 compiler instead.\n+    ///\n+    /// Currently, by default, the build system does not perform a \"full\n+    /// bootstrap\" by default where we compile the compiler three times.\n+    /// Instead, we compile the compiler two times. The final stage (stage2)\n+    /// just copies the libraries from the previous stage, which is what this\n+    /// method detects.\n+    ///\n+    /// Here we return `true` if:\n+    ///\n+    /// * The build isn't performing a full bootstrap\n+    /// * The `compiler` is in the final stage, 2\n+    /// * We're not cross-compiling, so the artifacts are already available in\n+    ///   stage1\n+    ///\n+    /// When all of these conditions are met the build will lift artifacts from\n+    /// the previous stage forward.\n+    fn force_use_stage1(&self, compiler: &Compiler, target: &str) -> bool {\n+        !self.config.full_bootstrap &&\n+            compiler.stage >= 2 &&\n+            self.config.host.iter().any(|h| h == target)\n+    }\n }\n \n impl<'a> Compiler<'a> {"}, {"sha": "a3333369930b84244f132b68764718cd7714ac29", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -51,8 +51,16 @@ standalone-docs:\n \t$(Q)$(BOOTSTRAP) doc src/doc $(BOOTSTRAP_ARGS)\n check:\n \t$(Q)$(BOOTSTRAP) test $(BOOTSTRAP_ARGS)\n-check-cargotest:\n-\t$(Q)$(BOOTSTRAP) test src/tools/cargotest $(BOOTSTRAP_ARGS)\n+check-aux:\n+\t$(Q)$(BOOTSTRAP) test \\\n+\t\tsrc/tools/cargotest \\\n+\t\tsrc/test/pretty \\\n+\t\tsrc/test/run-pass/pretty \\\n+\t\tsrc/test/run-fail/pretty \\\n+\t\tsrc/test/run-pass-valgrind/pretty \\\n+\t\tsrc/test/run-pass-fulldeps/pretty \\\n+\t\tsrc/test/run-fail-fulldeps/pretty \\\n+\t\t$(BOOTSTRAP_ARGS)\n dist:\n \t$(Q)$(BOOTSTRAP) dist $(BOOTSTRAP_ARGS)\n distcheck:"}, {"sha": "4b6fef8edc17f9e4465bbc549cb4ccacfafc9037", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -75,13 +75,18 @@ pub fn llvm(build: &Build, target: &str) {\n         (true, true) => \"RelWithDebInfo\",\n     };\n \n+    // NOTE: remember to also update `config.toml.example` when changing the defaults!\n+    let llvm_targets = match build.config.llvm_targets {\n+        Some(ref s) => s,\n+        None => \"X86;ARM;AArch64;Mips;PowerPC;SystemZ;JSBackend;MSP430;Sparc;NVPTX\",\n+    };\n+\n     cfg.target(target)\n        .host(&build.config.build)\n        .out_dir(&dst)\n        .profile(profile)\n        .define(\"LLVM_ENABLE_ASSERTIONS\", assertions)\n-       .define(\"LLVM_TARGETS_TO_BUILD\",\n-               \"X86;ARM;AArch64;Mips;PowerPC;SystemZ;JSBackend;MSP430;Sparc\")\n+       .define(\"LLVM_TARGETS_TO_BUILD\", llvm_targets)\n        .define(\"LLVM_INCLUDE_EXAMPLES\", \"OFF\")\n        .define(\"LLVM_INCLUDE_TESTS\", \"OFF\")\n        .define(\"LLVM_INCLUDE_DOCS\", \"OFF\")"}, {"sha": "7bcfb06f210b9466ecdde9223e3e3605f1985313", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 144, "deletions": 74, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -44,7 +44,7 @@ pub fn run(build: &Build) {\n     rules.run(&steps);\n }\n \n-pub fn build_rules(build: &Build) -> Rules {\n+pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     let mut rules = Rules::new(build);\n \n     // This is the first rule that we're going to define for rustbuild, which is\n@@ -117,6 +117,7 @@ pub fn build_rules(build: &Build) -> Rules {\n \n     // the compiler with no target libraries ready to go\n     rules.build(\"rustc\", \"src/rustc\")\n+         .dep(|s| s.name(\"create-sysroot\").target(s.host))\n          .dep(move |s| {\n              if s.stage == 0 {\n                  Step::noop()\n@@ -151,77 +152,145 @@ pub fn build_rules(build: &Build) -> Rules {\n     // Crate compilations\n     //\n     // Tools used during the build system but not shipped\n+    rules.build(\"create-sysroot\", \"path/to/nowhere\")\n+         .run(move |s| compile::create_sysroot(build, &s.compiler()));\n+\n+    // These rules are \"pseudo rules\" that don't actually do any work\n+    // themselves, but represent a complete sysroot with the relevant compiler\n+    // linked into place.\n+    //\n+    // That is, depending on \"libstd\" means that when the rule is completed then\n+    // the `stage` sysroot for the compiler `host` will be available with a\n+    // standard library built for `target` linked in place. Not all rules need\n+    // the compiler itself to be available, just the standard library, so\n+    // there's a distinction between the two.\n     rules.build(\"libstd\", \"src/libstd\")\n-         .dep(|s| s.name(\"build-crate-std_shim\"));\n+         .dep(|s| s.name(\"rustc\").target(s.host))\n+         .dep(|s| s.name(\"libstd-link\"));\n     rules.build(\"libtest\", \"src/libtest\")\n-         .dep(|s| s.name(\"build-crate-test_shim\"));\n+         .dep(|s| s.name(\"libstd\"))\n+         .dep(|s| s.name(\"libtest-link\"))\n+         .default(true);\n     rules.build(\"librustc\", \"src/librustc\")\n-         .dep(|s| s.name(\"build-crate-rustc-main\"));\n+         .dep(|s| s.name(\"libtest\"))\n+         .dep(|s| s.name(\"librustc-link\"))\n+         .host(true)\n+         .default(true);\n+\n+    // Helper method to define the rules to link a crate into its place in the\n+    // sysroot.\n+    //\n+    // The logic here is a little subtle as there's a few cases to consider.\n+    // Not all combinations of (stage, host, target) actually require something\n+    // to be compiled, but rather libraries could get propagated from a\n+    // different location. For example:\n+    //\n+    // * Any crate with a `host` that's not the build triple will not actually\n+    //   compile something. A different `host` means that the build triple will\n+    //   actually compile the libraries, and then we'll copy them over from the\n+    //   build triple to the `host` directory.\n+    //\n+    // * Some crates aren't even compiled by the build triple, but may be copied\n+    //   from previous stages. For example if we're not doing a full bootstrap\n+    //   then we may just depend on the stage1 versions of libraries to be\n+    //   available to get linked forward.\n+    //\n+    // * Finally, there are some cases, however, which do indeed comiple crates\n+    //   and link them into place afterwards.\n+    //\n+    // The rule definition below mirrors these three cases. The `dep` method\n+    // calculates the correct dependency which either comes from stage1, a\n+    // different compiler, or from actually building the crate itself (the `dep`\n+    // rule). The `run` rule then mirrors these three cases and links the cases\n+    // forward into the compiler sysroot specified from the correct location.\n+    fn crate_rule<'a, 'b>(build: &'a Build,\n+                          rules: &'b mut Rules<'a>,\n+                          krate: &'a str,\n+                          dep: &'a str,\n+                          link: fn(&Build, &Compiler, &Compiler, &str))\n+                          -> RuleBuilder<'a, 'b> {\n+        let mut rule = rules.build(&krate, \"path/to/nowhere\");\n+        rule.dep(move |s| {\n+                if build.force_use_stage1(&s.compiler(), s.target) {\n+                    s.host(&build.config.build).stage(1)\n+                } else if s.host == build.config.build {\n+                    s.name(dep)\n+                } else {\n+                    s.host(&build.config.build)\n+                }\n+            })\n+            .run(move |s| {\n+                if build.force_use_stage1(&s.compiler(), s.target) {\n+                    link(build,\n+                         &s.stage(1).host(&build.config.build).compiler(),\n+                         &s.compiler(),\n+                         s.target)\n+                } else if s.host == build.config.build {\n+                    link(build, &s.compiler(), &s.compiler(), s.target)\n+                } else {\n+                    link(build,\n+                         &s.host(&build.config.build).compiler(),\n+                         &s.compiler(),\n+                         s.target)\n+                }\n+            });\n+            return rule\n+    }\n+\n+    // Similar to the `libstd`, `libtest`, and `librustc` rules above, except\n+    // these rules only represent the libraries being available in the sysroot,\n+    // not the compiler itself. This is done as not all rules need a compiler in\n+    // the sysroot, but may just need the libraries.\n+    //\n+    // All of these rules use the helper definition above.\n+    crate_rule(build,\n+               &mut rules,\n+               \"libstd-link\",\n+               \"build-crate-std_shim\",\n+               compile::std_link)\n+        .dep(|s| s.name(\"startup-objects\"))\n+        .dep(|s| s.name(\"create-sysroot\").target(s.host));\n+    crate_rule(build,\n+               &mut rules,\n+               \"libtest-link\",\n+               \"build-crate-test_shim\",\n+               compile::test_link)\n+        .dep(|s| s.name(\"libstd-link\"));\n+    crate_rule(build,\n+               &mut rules,\n+               \"librustc-link\",\n+               \"build-crate-rustc-main\",\n+               compile::rustc_link)\n+        .dep(|s| s.name(\"libtest-link\"));\n+\n     for (krate, path, _default) in krates(\"std_shim\") {\n         rules.build(&krate.build_step, path)\n+             .dep(|s| s.name(\"startup-objects\"))\n              .dep(move |s| s.name(\"rustc\").host(&build.config.build).target(s.host))\n-             .dep(move |s| {\n-                 if s.host == build.config.build {\n-                     Step::noop()\n-                 } else {\n-                    s.host(&build.config.build)\n-                 }\n-             })\n-             .run(move |s| {\n-                 if s.host == build.config.build {\n-                    compile::std(build, s.target, &s.compiler())\n-                 } else {\n-                    compile::std_link(build, s.target, s.stage, s.host)\n-                 }\n-             });\n+             .run(move |s| compile::std(build, s.target, &s.compiler()));\n     }\n-    for (krate, path, default) in krates(\"test_shim\") {\n+    for (krate, path, _default) in krates(\"test_shim\") {\n         rules.build(&krate.build_step, path)\n-             .dep(|s| s.name(\"libstd\"))\n-             .dep(move |s| {\n-                 if s.host == build.config.build {\n-                    Step::noop()\n-                 } else {\n-                    s.host(&build.config.build)\n-                 }\n-             })\n-             .default(default)\n-             .run(move |s| {\n-                 if s.host == build.config.build {\n-                    compile::test(build, s.target, &s.compiler())\n-                 } else {\n-                    compile::test_link(build, s.target, s.stage, s.host)\n-                 }\n-             });\n+             .dep(|s| s.name(\"libstd-link\"))\n+             .run(move |s| compile::test(build, s.target, &s.compiler()));\n     }\n-    for (krate, path, default) in krates(\"rustc-main\") {\n+    for (krate, path, _default) in krates(\"rustc-main\") {\n         rules.build(&krate.build_step, path)\n-             .dep(|s| s.name(\"libtest\"))\n+             .dep(|s| s.name(\"libtest-link\"))\n              .dep(move |s| s.name(\"llvm\").host(&build.config.build).stage(0))\n-             .dep(move |s| {\n-                 if s.host == build.config.build {\n-                    Step::noop()\n-                 } else {\n-                    s.host(&build.config.build)\n-                 }\n-             })\n-             .host(true)\n-             .default(default)\n-             .run(move |s| {\n-                 if s.host == build.config.build {\n-                    compile::rustc(build, s.target, &s.compiler())\n-                 } else {\n-                    compile::rustc_link(build, s.target, s.stage, s.host)\n-                 }\n-             });\n+             .run(move |s| compile::rustc(build, s.target, &s.compiler()));\n     }\n \n+    rules.build(\"startup-objects\", \"src/rtstartup\")\n+         .dep(|s| s.name(\"create-sysroot\").target(s.host))\n+         .run(move |s| compile::build_startup_objects(build, &s.compiler(), s.target));\n+\n     // ========================================================================\n     // Test targets\n     //\n     // Various unit tests and tests suites we can run\n     {\n-        let mut suite = |name, path, dir, mode| {\n+        let mut suite = |name, path, mode, dir| {\n             rules.test(name, path)\n                  .dep(|s| s.name(\"libtest\"))\n                  .dep(|s| s.name(\"tool-compiletest\").target(s.host))\n@@ -233,9 +302,9 @@ pub fn build_rules(build: &Build) -> Rules {\n                          Step::noop()\n                      }\n                  })\n-                 .default(true)\n+                 .default(mode != \"pretty\") // pretty tests don't run everywhere\n                  .run(move |s| {\n-                     check::compiletest(build, &s.compiler(), s.target, dir, mode)\n+                     check::compiletest(build, &s.compiler(), s.target, mode, dir)\n                  });\n         };\n \n@@ -254,13 +323,6 @@ pub fn build_rules(build: &Build) -> Rules {\n         suite(\"check-incremental\", \"src/test/incremental\", \"incremental\",\n               \"incremental\");\n         suite(\"check-ui\", \"src/test/ui\", \"ui\", \"ui\");\n-        suite(\"check-pretty\", \"src/test/pretty\", \"pretty\", \"pretty\");\n-        suite(\"check-pretty-rpass\", \"src/test/run-pass/pretty\", \"pretty\",\n-              \"run-pass\");\n-        suite(\"check-pretty-rfail\", \"src/test/run-pass/pretty\", \"pretty\",\n-              \"run-fail\");\n-        suite(\"check-pretty-valgrind\", \"src/test/run-pass-valgrind\", \"pretty\",\n-              \"run-pass-valgrind\");\n     }\n \n     if build.config.build.contains(\"msvc\") {\n@@ -290,14 +352,15 @@ pub fn build_rules(build: &Build) -> Rules {\n                                          s.target));\n \n     {\n-        let mut suite = |name, path, dir, mode| {\n+        let mut suite = |name, path, mode, dir| {\n             rules.test(name, path)\n                  .dep(|s| s.name(\"librustc\"))\n+                 .dep(|s| s.name(\"test-helpers\"))\n                  .dep(|s| s.name(\"tool-compiletest\").target(s.host))\n-                 .default(true)\n+                 .default(mode != \"pretty\")\n                  .host(true)\n                  .run(move |s| {\n-                     check::compiletest(build, &s.compiler(), s.target, dir, mode)\n+                     check::compiletest(build, &s.compiler(), s.target, mode, dir)\n                  });\n         };\n \n@@ -307,9 +370,16 @@ pub fn build_rules(build: &Build) -> Rules {\n               \"compile-fail\", \"compile-fail-fulldeps\");\n         suite(\"check-rmake\", \"src/test/run-make\", \"run-make\", \"run-make\");\n         suite(\"check-rustdoc\", \"src/test/rustdoc\", \"rustdoc\", \"rustdoc\");\n-        suite(\"check-pretty-rpass-full\", \"src/test/run-pass-fulldeps\",\n+        suite(\"check-pretty\", \"src/test/pretty\", \"pretty\", \"pretty\");\n+        suite(\"check-pretty-rpass\", \"src/test/run-pass/pretty\", \"pretty\",\n+              \"run-pass\");\n+        suite(\"check-pretty-rfail\", \"src/test/run-fail/pretty\", \"pretty\",\n+              \"run-fail\");\n+        suite(\"check-pretty-valgrind\", \"src/test/run-pass-valgrind/pretty\", \"pretty\",\n+              \"run-pass-valgrind\");\n+        suite(\"check-pretty-rpass-full\", \"src/test/run-pass-fulldeps/pretty\",\n               \"pretty\", \"run-pass-fulldeps\");\n-        suite(\"check-pretty-rfail-full\", \"src/test/run-fail-fulldeps\",\n+        suite(\"check-pretty-rfail-full\", \"src/test/run-fail-fulldeps/pretty\",\n               \"pretty\", \"run-fail-fulldeps\");\n     }\n \n@@ -444,25 +514,25 @@ pub fn build_rules(build: &Build) -> Rules {\n          .run(move |s| doc::standalone(build, s.stage, s.target));\n     rules.doc(\"doc-error-index\", \"src/tools/error_index_generator\")\n          .dep(move |s| s.name(\"tool-error-index\").target(&build.config.build))\n-         .dep(move |s| s.name(\"librustc\"))\n+         .dep(move |s| s.name(\"librustc-link\"))\n          .default(build.config.docs)\n          .host(true)\n          .run(move |s| doc::error_index(build, s.stage, s.target));\n     for (krate, path, default) in krates(\"std_shim\") {\n         rules.doc(&krate.doc_step, path)\n-             .dep(|s| s.name(\"libstd\"))\n+             .dep(|s| s.name(\"libstd-link\"))\n              .default(default && build.config.docs)\n              .run(move |s| doc::std(build, s.stage, s.target));\n     }\n     for (krate, path, default) in krates(\"test_shim\") {\n         rules.doc(&krate.doc_step, path)\n-             .dep(|s| s.name(\"libtest\"))\n+             .dep(|s| s.name(\"libtest-link\"))\n              .default(default && build.config.compiler_docs)\n              .run(move |s| doc::test(build, s.stage, s.target));\n     }\n     for (krate, path, default) in krates(\"rustc-main\") {\n         rules.doc(&krate.doc_step, path)\n-             .dep(|s| s.name(\"librustc\"))\n+             .dep(|s| s.name(\"librustc-link\"))\n              .host(true)\n              .default(default && build.config.compiler_docs)\n              .run(move |s| doc::rustc(build, s.stage, s.target));\n@@ -481,9 +551,9 @@ pub fn build_rules(build: &Build) -> Rules {\n              // for the `rust-std` package, so if this is a host target we\n              // depend on librustc and otherwise we just depend on libtest.\n              if build.config.host.iter().any(|t| t == s.target) {\n-                 s.name(\"librustc\")\n+                 s.name(\"librustc-link\")\n              } else {\n-                 s.name(\"libtest\")\n+                 s.name(\"libtest-link\")\n              }\n          })\n          .default(true)"}, {"sha": "a40e76839eccd8349938fe296bb3a67a0935f564", "filename": "src/ci/docker/arm-android/Dockerfile", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farm-android%2FDockerfile?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -11,7 +11,6 @@ RUN dpkg --add-architecture i386 && \\\n   python2.7 \\\n   git \\\n   cmake \\\n-  ccache \\\n   unzip \\\n   expect \\\n   openjdk-9-jre \\\n@@ -50,5 +49,3 @@ ENV RUST_CONFIGURE_ARGS \\\n       --i686-linux-android-ndk=/android/ndk-x86-9 \\\n       --aarch64-linux-android-ndk=/android/ndk-aarch64\n ENV XPY_CHECK test --target arm-linux-androideabi\n-RUN mkdir /tmp/obj\n-RUN chmod 777 /tmp/obj"}, {"sha": "c5aa323f50cd281adbe462f1f8196f20a6b5cb1c", "filename": "src/ci/docker/cross/Dockerfile", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fci%2Fdocker%2Fcross%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fci%2Fdocker%2Fcross%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fcross%2FDockerfile?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -9,7 +9,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   python2.7 \\\n   git \\\n   cmake \\\n-  ccache \\\n   sudo \\\n   gcc-aarch64-linux-gnu libc6-dev-arm64-cross \\\n   gcc-arm-linux-gnueabi libc6-dev-armel-cross \\\n@@ -70,6 +69,3 @@ ENV AR_s390x_unknown_linux_gnu=s390x-linux-gnu-ar \\\n \n # FIXME(rust-lang/rust#36150): powerpc unfortunately aborts right now\n ENV NO_LLVM_ASSERTIONS=1\n-\n-RUN mkdir /tmp/obj\n-RUN chmod 777 /tmp/obj"}, {"sha": "1ffb24981c59aaa55d501dd3703057f1d12d3a3b", "filename": "src/ci/docker/i686-gnu-nopt/Dockerfile", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -9,7 +9,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   python2.7 \\\n   git \\\n   cmake \\\n-  ccache \\\n   sudo \\\n   gdb \\\n   xz-utils\n@@ -25,5 +24,3 @@ ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n ENV RUST_CONFIGURE_ARGS --build=i686-unknown-linux-gnu --disable-optimize-tests\n ENV RUST_CHECK_TARGET check\n-RUN mkdir /tmp/obj\n-RUN chmod 777 /tmp/obj"}, {"sha": "e4310232d78cf48382fd7b80bdaca5fd4767e296", "filename": "src/ci/docker/i686-gnu/Dockerfile", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -9,7 +9,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   python2.7 \\\n   git \\\n   cmake \\\n-  ccache \\\n   sudo \\\n   gdb \\\n   xz-utils\n@@ -25,5 +24,3 @@ ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n ENV RUST_CONFIGURE_ARGS --build=i686-unknown-linux-gnu\n ENV RUST_CHECK_TARGET check\n-RUN mkdir /tmp/obj\n-RUN chmod 777 /tmp/obj"}, {"sha": "86efa74ba3b6f16c6d216ca0b5f158c0c29307be", "filename": "src/ci/docker/x86_64-freebsd/Dockerfile", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fci%2Fdocker%2Fx86_64-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fci%2Fdocker%2Fx86_64-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-freebsd%2FDockerfile?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -9,7 +9,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   python2.7 \\\n   git \\\n   cmake \\\n-  ccache \\\n   sudo \\\n   bzip2 \\\n   xz-utils \\\n@@ -33,5 +32,3 @@ ENV \\\n \n ENV RUST_CONFIGURE_ARGS --target=x86_64-unknown-freebsd\n ENV RUST_CHECK_TARGET \"\"\n-RUN mkdir /tmp/obj\n-RUN chmod 777 /tmp/obj"}, {"sha": "0ec0bfd18972516508906b7cc0ddbe6031ae93e6", "filename": "src/ci/docker/x86_64-gnu-aux/Dockerfile", "status": "renamed", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fci%2Fdocker%2Fx86_64-gnu-aux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fci%2Fdocker%2Fx86_64-gnu-aux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-aux%2FDockerfile?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -9,7 +9,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   python2.7 \\\n   git \\\n   cmake \\\n-  ccache \\\n   libssl-dev \\\n   sudo \\\n   xz-utils \\\n@@ -25,7 +24,5 @@ RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-ini\n ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu\n-ENV RUST_CHECK_TARGET check-cargotest\n+ENV RUST_CHECK_TARGET check-aux\n ENV NO_VENDOR 1\n-RUN mkdir /tmp/obj\n-RUN chmod 777 /tmp/obj", "previous_filename": "src/ci/docker/x86_64-gnu-cargotest/Dockerfile"}, {"sha": "9ec8c6059ec31b801319d35af804777af9b0682a", "filename": "src/ci/docker/x86_64-gnu-debug/Dockerfile", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -9,7 +9,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   python2.7 \\\n   git \\\n   cmake \\\n-  ccache \\\n   sudo \\\n   gdb \\\n   xz-utils\n@@ -28,5 +27,3 @@ ENV RUST_CONFIGURE_ARGS \\\n       --enable-debug \\\n       --enable-optimize\n ENV RUST_CHECK_TARGET \"\"\n-RUN mkdir /tmp/obj\n-RUN chmod 777 /tmp/obj"}, {"sha": "7c079e45751c1acbdf878693be048e8418656fc8", "filename": "src/ci/docker/x86_64-gnu-full-bootstrap/Dockerfile", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fci%2Fdocker%2Fx86_64-gnu-full-bootstrap%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fci%2Fdocker%2Fx86_64-gnu-full-bootstrap%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-full-bootstrap%2FDockerfile?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -0,0 +1,28 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  gdb \\\n+  xz-utils\n+\n+ENV SCCACHE_DIGEST=7237e38e029342fa27b7ac25412cb9d52554008b12389727320bd533fd7f05b6a96d55485f305caf95e5c8f5f97c3313e10012ccad3e752aba2518f3522ba783\n+RUN curl -L https://api.pub.build.mozilla.org/tooltool/sha512/$SCCACHE_DIGEST | \\\n+      tar xJf - -C /usr/local/bin --strip-components=1\n+\n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n+\n+ENV RUST_CONFIGURE_ARGS \\\n+      --build=x86_64-unknown-linux-gnu \\\n+      --enable-full-bootstrap\n+ENV RUST_CHECK_TARGET \"\""}, {"sha": "aabfc0cd1bd8f2067f7b4ea13d18b56bc738a430", "filename": "src/ci/docker/x86_64-gnu-llvm-3.7/Dockerfile", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.7%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.7%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.7%2FDockerfile?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -9,7 +9,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   python2.7 \\\n   git \\\n   cmake \\\n-  ccache \\\n   sudo \\\n   gdb \\\n   llvm-3.7-tools \\\n@@ -30,5 +29,3 @@ ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\\n       --llvm-root=/usr/lib/llvm-3.7\n ENV RUST_CHECK_TARGET check\n-RUN mkdir /tmp/obj\n-RUN chmod 777 /tmp/obj"}, {"sha": "c6071d704f5f6b7cc66ae6ddded1622e2115690a", "filename": "src/ci/docker/x86_64-gnu-make/Dockerfile", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fci%2Fdocker%2Fx86_64-gnu-make%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fci%2Fdocker%2Fx86_64-gnu-make%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-make%2FDockerfile?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -9,7 +9,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   python2.7 \\\n   git \\\n   cmake \\\n-  ccache \\\n   sudo \\\n   gdb \\\n   xz-utils\n@@ -25,5 +24,3 @@ ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu --disable-rustbuild\n ENV RUST_CHECK_TARGET check\n-RUN mkdir /tmp/obj\n-RUN chmod 777 /tmp/obj"}, {"sha": "d28dc3de1b494bdbfca54481019549f78cd82163", "filename": "src/ci/docker/x86_64-gnu-nopt/Dockerfile", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -9,7 +9,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   python2.7 \\\n   git \\\n   cmake \\\n-  ccache \\\n   sudo \\\n   gdb \\\n   xz-utils\n@@ -25,5 +24,3 @@ ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu --disable-optimize-tests\n ENV RUST_CHECK_TARGET check\n-RUN mkdir /tmp/obj\n-RUN chmod 777 /tmp/obj"}, {"sha": "9d8b75c80c7f242d312b6404800fd968b314d923", "filename": "src/ci/docker/x86_64-gnu/Dockerfile", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -9,7 +9,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   python2.7 \\\n   git \\\n   cmake \\\n-  ccache \\\n   sudo \\\n   gdb \\\n   xz-utils\n@@ -25,5 +24,3 @@ ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu\n ENV RUST_CHECK_TARGET check\n-RUN mkdir /tmp/obj\n-RUN chmod 777 /tmp/obj"}, {"sha": "49954157ec023a539dbd87332180dc321741dcaf", "filename": "src/ci/docker/x86_64-musl/Dockerfile", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fci%2Fdocker%2Fx86_64-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fci%2Fdocker%2Fx86_64-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-musl%2FDockerfile?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -9,7 +9,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   python2.7 \\\n   git \\\n   cmake \\\n-  ccache \\\n   xz-utils \\\n   sudo \\\n   gdb\n@@ -33,6 +32,3 @@ ENV RUST_CONFIGURE_ARGS \\\n ENV RUST_CHECK_TARGET check-stage2-T-x86_64-unknown-linux-musl-H-x86_64-unknown-linux-gnu\n ENV PATH=$PATH:/musl-x86_64/bin\n ENV XPY_CHECK test --target x86_64-unknown-linux-musl\n-\n-RUN mkdir /tmp/obj\n-RUN chmod 777 /tmp/obj"}, {"sha": "115fe1f7662322e56d03dc59395ad208ad4eee08", "filename": "src/doc/book/closures.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fdoc%2Fbook%2Fclosures.md", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fdoc%2Fbook%2Fclosures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fclosures.md?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -283,7 +283,7 @@ fn call_with_one<F>(some_closure: F) -> i32\n #    some_closure(1) }\n ```\n \n-We take one parameter, and it has the type `F`. We also return a `i32`. This part\n+We take one parameter, and it has the type `F`. We also return an `i32`. This part\n isn\u2019t interesting. The next part is:\n \n ```rust\n@@ -293,7 +293,7 @@ isn\u2019t interesting. The next part is:\n ```\n \n Because `Fn` is a trait, we can use it as a bound for our generic type. In\n-this case, our closure takes a `i32` as an argument and returns an `i32`, and\n+this case, our closure takes an `i32` as an argument and returns an `i32`, and\n so the generic bound we use is `Fn(i32) -> i32`.\n \n There\u2019s one other key point here: because we\u2019re bounding a generic with a"}, {"sha": "41457ee67a5fdb2d1fe44c7780d1a4ef58c06fbd", "filename": "src/doc/book/ffi.md", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fdoc%2Fbook%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fdoc%2Fbook%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fffi.md?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -574,6 +574,31 @@ The [`libc` crate on crates.io][libc] includes type aliases and function\n definitions for the C standard library in the `libc` module, and Rust links\n against `libc` and `libm` by default.\n \n+# Variadic functions\n+\n+In C, functions can be 'variadic', meaning they accept a variable number of arguments. This can\n+be achieved in Rust by specifying `...` within the argument list of a foreign function declaration:\n+\n+```no_run\n+extern {\n+    fn foo(x: i32, ...);\n+}\n+\n+fn main() {\n+    unsafe {\n+        foo(10, 20, 30, 40, 50);\n+    }\n+}\n+```\n+\n+Normal Rust functions can *not* be variadic:\n+\n+```ignore\n+// This will not compile\n+\n+fn foo(x: i32, ...) { }\n+```\n+\n # The \"nullable pointer optimization\"\n \n Certain Rust types are defined to never be `null`. This includes references (`&T`,"}, {"sha": "546e66fc8ac02bb7efa753720db987c500fdfef4", "filename": "src/doc/book/lifetimes.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fdoc%2Fbook%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fdoc%2Fbook%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Flifetimes.md?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -128,7 +128,7 @@ _descriptive_, not _prescriptive_. This means that how long a reference is valid\n is determined by the code, not by the annotations. The annotations, however,\n give information about lifetimes to the compiler that uses them to check the\n validity of references. The compiler can do so without annotations in simple\n-cases, but needs the programmers support in complex scenarios.\n+cases, but needs the programmer's support in complex scenarios.\n \n [traits]: traits.html\n "}, {"sha": "e1947310a9a28de758bae61f0c35add5f8450dd9", "filename": "src/doc/book/variable-bindings.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fdoc%2Fbook%2Fvariable-bindings.md", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fdoc%2Fbook%2Fvariable-bindings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fvariable-bindings.md?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -102,7 +102,7 @@ mutation, then the solution is quite easy: add `mut`.\n There are other good reasons to avoid mutable state when possible, but they\u2019re\n out of the scope of this guide. In general, you can often avoid explicit\n mutation, and so it is preferable in Rust. That said, sometimes, mutation is\n-what you need, so it\u2019s not verboten.\n+what you need, so it\u2019s not forbidden.\n \n # Initializing bindings\n "}, {"sha": "9898c31282c34949aa13db715c5b6b27ed12c907", "filename": "src/doc/reference.md", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -1657,6 +1657,15 @@ Functions within external blocks may be called by Rust code, just like\n functions defined in Rust. The Rust compiler automatically translates between\n the Rust ABI and the foreign ABI.\n \n+Functions within external blocks may be variadic by specifying `...` after one\n+or more named arguments in the argument list:\n+\n+```ignore\n+extern {\n+    fn foo(x: i32, ...);\n+}\n+```\n+\n A number of [attributes](#ffi-attributes) control the behavior of external blocks.\n \n By default external blocks assume that the library they are calling uses the"}, {"sha": "1beaaeb5d8718161e5ceba4a42d9d3fe3b903c07", "filename": "src/etc/platform-intrinsics/nvptx/cuda.json", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fetc%2Fplatform-intrinsics%2Fnvptx%2Fcuda.json", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fetc%2Fplatform-intrinsics%2Fnvptx%2Fcuda.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fnvptx%2Fcuda.json?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -0,0 +1,13 @@\n+{\n+    \"intrinsic_prefix\": \"_\",\n+    \"llvm_prefix\": \"llvm.cuda.\",\n+    \"intrinsics\": [\n+        {\n+            \"intrinsic\": \"syncthreads\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"syncthreads\",\n+            \"ret\": \"V\",\n+            \"args\": []\n+        }\n+    ]\n+}"}, {"sha": "80332c54e04141dff0866ad6a104fd6225214418", "filename": "src/etc/platform-intrinsics/nvptx/info.json", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fetc%2Fplatform-intrinsics%2Fnvptx%2Finfo.json", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fetc%2Fplatform-intrinsics%2Fnvptx%2Finfo.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fnvptx%2Finfo.json?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -0,0 +1,7 @@\n+{\n+  \"platform\": \"nvptx\",\n+  \"number_info\": {\n+    \"signed\": {}\n+  },\n+  \"width_info\": {}\n+}"}, {"sha": "33d97f2694699d0069d54266135347efe88acaf4", "filename": "src/etc/platform-intrinsics/nvptx/sreg.json", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fetc%2Fplatform-intrinsics%2Fnvptx%2Fsreg.json", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fetc%2Fplatform-intrinsics%2Fnvptx%2Fsreg.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fnvptx%2Fsreg.json?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -0,0 +1,90 @@\n+{\n+    \"intrinsic_prefix\": \"_\",\n+    \"llvm_prefix\": \"llvm.nvvm.read.ptx.sreg.\",\n+    \"intrinsics\": [\n+        {\n+            \"intrinsic\": \"block_dim_x\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"ntid.x\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"block_dim_y\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"ntid.y\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"block_dim_z\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"ntid.z\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"block_idx_x\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"ctaid.x\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"block_idx_y\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"ctaid.y\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"block_idx_z\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"ctaid.z\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"grid_dim_x\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"nctaid.x\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"grid_dim_y\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"nctaid.y\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"grid_dim_z\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"nctaid.z\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"thread_idx_x\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"tid.x\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"thread_idx_y\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"tid.y\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"thread_idx_z\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"tid.z\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        }\n+    ]\n+}"}, {"sha": "e1a240a0d2ebad258669f4b17edc5614bca190b9", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -55,24 +55,24 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// [`RwLock`][rwlock], or one of the [`Atomic`][atomic] types.\n ///\n /// `Arc` uses atomic operations for reference counting, so `Arc`s can be\n-/// sent between threads. In other words, `Arc<T>` implements [`Send`][send]\n-/// as long as `T` implements `Send` and [`Sync`][sync]. The disadvantage is\n+/// sent between threads. In other words, `Arc<T>` implements [`Send`]\n+/// as long as `T` implements [`Send`] and [`Sync`][sync]. The disadvantage is\n /// that atomic operations are more expensive than ordinary memory accesses.\n /// If you are not sharing reference-counted values between threads, consider\n-/// using [`rc::Rc`][rc] for lower overhead. `Rc` is a safe default, because\n-/// the compiler will catch any attempt to send an `Rc` between threads.\n+/// using [`rc::Rc`] for lower overhead. [`Rc`] is a safe default, because\n+/// the compiler will catch any attempt to send an [`Rc`] between threads.\n /// However, a library might choose `Arc` in order to give library consumers\n /// more flexibility.\n ///\n /// The [`downgrade`][downgrade] method can be used to create a non-owning\n-/// [`Weak`][weak] pointer. A `Weak` pointer can be [`upgrade`][upgrade]d\n-/// to an `Arc`, but this will return [`None`][option] if the value has\n-/// already been dropped.\n+/// [`Weak`][weak] pointer. A [`Weak`][weak] pointer can be [`upgrade`][upgrade]d\n+/// to an `Arc`, but this will return [`None`] if the value has already been\n+/// dropped.\n ///\n /// A cycle between `Arc` pointers will never be deallocated. For this reason,\n-/// `Weak` is used to break cycles. For example, a tree could have strong\n-/// `Arc` pointers from parent nodes to children, and `Weak` pointers from\n-/// children back to their parents.\n+/// [`Weak`][weak] is used to break cycles. For example, a tree could have\n+/// strong `Arc` pointers from parent nodes to children, and [`Weak`][weak]\n+/// pointers from children back to their parents.\n ///\n /// `Arc<T>` automatically dereferences to `T` (via the [`Deref`][deref] trait),\n /// so you can call `T`'s methods on a value of type `Arc<T>`. To avoid name\n@@ -86,22 +86,22 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// Arc::downgrade(&my_arc);\n /// ```\n ///\n-/// `Weak<T>` does not auto-dereference to `T`, because the value may have\n+/// [`Weak<T>`][weak] does not auto-dereference to `T`, because the value may have\n /// already been destroyed.\n ///\n /// [arc]: struct.Arc.html\n /// [weak]: struct.Weak.html\n-/// [rc]: ../../std/rc/struct.Rc.html\n+/// [`Rc`]: ../../std/rc/struct.Rc.html\n /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n /// [mutex]: ../../std/sync/struct.Mutex.html\n /// [rwlock]: ../../std/sync/struct.RwLock.html\n /// [atomic]: ../../std/sync/atomic/index.html\n-/// [send]: ../../std/marker/trait.Send.html\n+/// [`Send`]: ../../std/marker/trait.Send.html\n /// [sync]: ../../std/marker/trait.Sync.html\n /// [deref]: ../../std/ops/trait.Deref.html\n /// [downgrade]: struct.Arc.html#method.downgrade\n /// [upgrade]: struct.Weak.html#method.upgrade\n-/// [option]: ../../std/option/enum.Option.html\n+/// [`None`]: ../../std/option/enum.Option.html#variant.None\n /// [assoc]: ../../book/method-syntax.html#associated-functions\n ///\n /// # Examples\n@@ -127,7 +127,9 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// }\n /// ```\n ///\n-/// Sharing a mutable `AtomicUsize`:\n+/// Sharing a mutable [`AtomicUsize`]:\n+///\n+/// [`AtomicUsize`]: ../../std/sync/atomic/struct.AtomicUsize.html\n ///\n /// ```no_run\n /// use std::sync::Arc;"}, {"sha": "54fb70278cac6818420e1fd879d3c8745a31647d", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -429,7 +429,7 @@ impl PartialOrd for Ordering {\n /// This trait can be used with `#[derive]`. When `derive`d, it will produce a lexicographic\n /// ordering based on the top-to-bottom declaration order of the struct's members.\n ///\n-/// ## How can I implement `Ord`?\n+/// ## How can I implement `PartialOrd`?\n ///\n /// PartialOrd only requires implementation of the `partial_cmp` method, with the others generated\n /// from default implementations."}, {"sha": "752057944715214aa02fbb84308cadb893b04b46", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 123, "deletions": 52, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -237,11 +237,16 @@ impl AtomicBool {\n \n     /// Loads a value from the bool.\n     ///\n-    /// `load` takes an `Ordering` argument which describes the memory ordering of this operation.\n+    /// `load` takes an [`Ordering`] argument which describes the memory ordering\n+    /// of this operation.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `order` is `Release` or `AcqRel`.\n+    /// Panics if `order` is [`Release`] or [`AcqRel`].\n+    ///\n+    /// [`Ordering`]: enum.Ordering.html\n+    /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`AcqRel`]: enum.Ordering.html#variant.Release\n     ///\n     /// # Examples\n     ///\n@@ -260,7 +265,10 @@ impl AtomicBool {\n \n     /// Stores a value into the bool.\n     ///\n-    /// `store` takes an `Ordering` argument which describes the memory ordering of this operation.\n+    /// `store` takes an [`Ordering`] argument which describes the memory ordering\n+    /// of this operation.\n+    ///\n+    /// [`Ordering`]: enum.Ordering.html\n     ///\n     /// # Examples\n     ///\n@@ -286,7 +294,10 @@ impl AtomicBool {\n \n     /// Stores a value into the bool, returning the old value.\n     ///\n-    /// `swap` takes an `Ordering` argument which describes the memory ordering of this operation.\n+    /// `swap` takes an [`Ordering`] argument which describes the memory ordering\n+    /// of this operation.\n+    ///\n+    /// [`Ordering`]: enum.Ordering.html\n     ///\n     /// # Examples\n     ///\n@@ -309,8 +320,10 @@ impl AtomicBool {\n     /// The return value is always the previous value. If it is equal to `current`, then the value\n     /// was updated.\n     ///\n-    /// `compare_and_swap` also takes an `Ordering` argument which describes the memory ordering of\n-    /// this operation.\n+    /// `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n+    /// ordering of this operation.\n+    ///\n+    /// [`Ordering`]: enum.Ordering.html\n     ///\n     /// # Examples\n     ///\n@@ -339,10 +352,15 @@ impl AtomicBool {\n     /// The return value is a result indicating whether the new value was written and containing\n     /// the previous value. On success this value is guaranteed to be equal to `current`.\n     ///\n-    /// `compare_exchange` takes two `Ordering` arguments to describe the memory ordering of this\n-    /// operation. The first describes the required ordering if the operation succeeds while the\n-    /// second describes the required ordering when the operation fails. The failure ordering can't\n-    /// be `Release` or `AcqRel` and must be equivalent or weaker than the success ordering.\n+    /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n+    /// ordering of this operation. The first describes the required ordering if the\n+    /// operation succeeds while the second describes the required ordering when the\n+    /// operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and must\n+    /// be equivalent or weaker than the success ordering.\n+    ///\n+    /// [`Ordering`]: enum.Ordering.html\n+    /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`AcqRel`]: enum.Ordering.html#variant.Release\n     ///\n     /// # Examples\n     ///\n@@ -387,11 +405,15 @@ impl AtomicBool {\n     /// return value is a result indicating whether the new value was written and containing the\n     /// previous value.\n     ///\n-    /// `compare_exchange_weak` takes two `Ordering` arguments to describe the memory\n+    /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n     /// ordering of this operation. The first describes the required ordering if the operation\n     /// succeeds while the second describes the required ordering when the operation fails. The\n-    /// failure ordering can't be `Release` or `AcqRel` and must be equivalent or weaker than the\n-    /// success ordering.\n+    /// failure ordering can't be [`Release`] or [`AcqRel`] and must be equivalent or\n+    /// weaker than the success ordering.\n+    ///\n+    /// [`Ordering`]: enum.Ordering.html\n+    /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`AcqRel`]: enum.Ordering.html#variant.Release\n     ///\n     /// # Examples\n     ///\n@@ -619,11 +641,16 @@ impl<T> AtomicPtr<T> {\n \n     /// Loads a value from the pointer.\n     ///\n-    /// `load` takes an `Ordering` argument which describes the memory ordering of this operation.\n+    /// `load` takes an [`Ordering`] argument which describes the memory ordering\n+    /// of this operation.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `order` is `Release` or `AcqRel`.\n+    /// Panics if `order` is [`Release`] or [`AcqRel`].\n+    ///\n+    /// [`Ordering`]: enum.Ordering.html\n+    /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n     ///\n     /// # Examples\n     ///\n@@ -643,7 +670,10 @@ impl<T> AtomicPtr<T> {\n \n     /// Stores a value into the pointer.\n     ///\n-    /// `store` takes an `Ordering` argument which describes the memory ordering of this operation.\n+    /// `store` takes an [`Ordering`] argument which describes the memory ordering\n+    /// of this operation.\n+    ///\n+    /// [`Ordering`]: enum.Ordering.html\n     ///\n     /// # Examples\n     ///\n@@ -671,7 +701,10 @@ impl<T> AtomicPtr<T> {\n \n     /// Stores a value into the pointer, returning the old value.\n     ///\n-    /// `swap` takes an `Ordering` argument which describes the memory ordering of this operation.\n+    /// `swap` takes an [`Ordering`] argument which describes the memory ordering\n+    /// of this operation.\n+    ///\n+    /// [`Ordering`]: enum.Ordering.html\n     ///\n     /// # Examples\n     ///\n@@ -696,8 +729,10 @@ impl<T> AtomicPtr<T> {\n     /// The return value is always the previous value. If it is equal to `current`, then the value\n     /// was updated.\n     ///\n-    /// `compare_and_swap` also takes an `Ordering` argument which describes the memory ordering of\n-    /// this operation.\n+    /// `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n+    /// ordering of this operation.\n+    ///\n+    /// [`Ordering`]: enum.Ordering.html\n     ///\n     /// # Examples\n     ///\n@@ -726,10 +761,15 @@ impl<T> AtomicPtr<T> {\n     /// The return value is a result indicating whether the new value was written and containing\n     /// the previous value. On success this value is guaranteed to be equal to `current`.\n     ///\n-    /// `compare_exchange` takes two `Ordering` arguments to describe the memory ordering of this\n-    /// operation. The first describes the required ordering if the operation succeeds while the\n-    /// second describes the required ordering when the operation fails. The failure ordering can't\n-    /// be `Release` or `AcqRel` and must be equivalent or weaker than the success ordering.\n+    /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n+    /// ordering of this operation. The first describes the required ordering if\n+    /// the operation succeeds while the second describes the required ordering when\n+    /// the operation fails. The failure ordering can't be [`Release`] or [`AcqRel`]\n+    /// and must be equivalent or weaker than the success ordering.\n+    ///\n+    /// [`Ordering`]: enum.Ordering.html\n+    /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n     ///\n     /// # Examples\n     ///\n@@ -768,16 +808,21 @@ impl<T> AtomicPtr<T> {\n \n     /// Stores a value into the pointer if the current value is the same as the `current` value.\n     ///\n-    /// Unlike `compare_exchange`, this function is allowed to spuriously fail even when the\n+    /// Unlike [`compare_exchange`], this function is allowed to spuriously fail even when the\n     /// comparison succeeds, which can result in more efficient code on some platforms. The\n     /// return value is a result indicating whether the new value was written and containing the\n     /// previous value.\n     ///\n-    /// `compare_exchange_weak` takes two `Ordering` arguments to describe the memory\n+    /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n     /// ordering of this operation. The first describes the required ordering if the operation\n     /// succeeds while the second describes the required ordering when the operation fails. The\n-    /// failure ordering can't be `Release` or `AcqRel` and must be equivalent or weaker than the\n-    /// success ordering.\n+    /// failure ordering can't be [`Release`] or [`AcqRel`] and must be equivalent or\n+    /// weaker than the success ordering.\n+    ///\n+    /// [`compare_exchange`]: #method.compare_exchange\n+    /// [`Ordering`]: enum.Ordering.html\n+    /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n     ///\n     /// # Examples\n     ///\n@@ -913,12 +958,16 @@ macro_rules! atomic_int {\n \n             /// Loads a value from the atomic integer.\n             ///\n-            /// `load` takes an `Ordering` argument which describes the memory ordering of this\n+            /// `load` takes an [`Ordering`] argument which describes the memory ordering of this\n             /// operation.\n             ///\n             /// # Panics\n             ///\n-            /// Panics if `order` is `Release` or `AcqRel`.\n+            /// Panics if `order` is [`Release`] or [`AcqRel`].\n+            ///\n+            /// [`Ordering`]: enum.Ordering.html\n+            /// [`Release`]: enum.Ordering.html#variant.Release\n+            /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n             ///\n             /// # Examples\n             ///\n@@ -937,9 +986,11 @@ macro_rules! atomic_int {\n \n             /// Stores a value into the atomic integer.\n             ///\n-            /// `store` takes an `Ordering` argument which describes the memory ordering of this\n+            /// `store` takes an [`Ordering`] argument which describes the memory ordering of this\n             /// operation.\n             ///\n+            /// [`Ordering`]: enum.Ordering.html\n+            ///\n             /// # Examples\n             ///\n             /// ```\n@@ -962,9 +1013,11 @@ macro_rules! atomic_int {\n \n             /// Stores a value into the atomic integer, returning the old value.\n             ///\n-            /// `swap` takes an `Ordering` argument which describes the memory ordering of this\n+            /// `swap` takes an [`Ordering`] argument which describes the memory ordering of this\n             /// operation.\n             ///\n+            /// [`Ordering`]: enum.Ordering.html\n+            ///\n             /// # Examples\n             ///\n             /// ```\n@@ -986,9 +1039,11 @@ macro_rules! atomic_int {\n             /// The return value is always the previous value. If it is equal to `current`, then the\n             /// value was updated.\n             ///\n-            /// `compare_and_swap` also takes an `Ordering` argument which describes the memory\n+            /// `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n             /// ordering of this operation.\n             ///\n+            /// [`Ordering`]: enum.Ordering.html\n+            ///\n             /// # Examples\n             ///\n             /// ```\n@@ -1024,11 +1079,15 @@ macro_rules! atomic_int {\n             /// containing the previous value. On success this value is guaranteed to be equal to\n             /// `current`.\n             ///\n-            /// `compare_exchange` takes two `Ordering` arguments to describe the memory ordering of\n-            /// this operation. The first describes the required ordering if the operation succeeds\n-            /// while the second describes the required ordering when the operation fails. The\n-            /// failure ordering can't be `Release` or `AcqRel` and must be equivalent or weaker\n-            /// than the success ordering.\n+            /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n+            /// ordering of this operation. The first describes the required ordering if\n+            /// the operation succeeds while the second describes the required ordering when\n+            /// the operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and\n+            /// must be equivalent or weaker than the success ordering.\n+            ///\n+            /// [`Ordering`]: enum.Ordering.html\n+            /// [`Release`]: enum.Ordering.html#variant.Release\n+            /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n             ///\n             /// # Examples\n             ///\n@@ -1062,16 +1121,21 @@ macro_rules! atomic_int {\n             /// Stores a value into the atomic integer if the current value is the same as the\n             /// `current` value.\n             ///\n-            /// Unlike `compare_exchange`, this function is allowed to spuriously fail even when the\n-            /// comparison succeeds, which can result in more efficient code on some platforms. The\n-            /// return value is a result indicating whether the new value was written and containing\n-            /// the previous value.\n+            /// Unlike [`compare_exchange`], this function is allowed to spuriously fail even\n+            /// when the comparison succeeds, which can result in more efficient code on some\n+            /// platforms. The return value is a result indicating whether the new value was\n+            /// written and containing the previous value.\n             ///\n-            /// `compare_exchange_weak` takes two `Ordering` arguments to describe the memory\n+            /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n             /// ordering of this operation. The first describes the required ordering if the\n             /// operation succeeds while the second describes the required ordering when the\n-            /// operation fails. The failure ordering can't be `Release` or `AcqRel` and must be\n-            /// equivalent or weaker than the success ordering.\n+            /// operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and\n+            /// must be equivalent or weaker than the success ordering.\n+            ///\n+            /// [`compare_exchange`]: #method.compare_exchange\n+            /// [`Ordering`]: enum.Ordering.html\n+            /// [`Release`]: enum.Ordering.html#variant.Release\n+            /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n             ///\n             /// # Examples\n             ///\n@@ -1431,24 +1495,31 @@ unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// An atomic fence.\n ///\n-/// A fence 'A' which has `Release` ordering semantics, synchronizes with a\n-/// fence 'B' with (at least) `Acquire` semantics, if and only if there exists\n+/// A fence 'A' which has [`Release`] ordering semantics, synchronizes with a\n+/// fence 'B' with (at least) [`Acquire`] semantics, if and only if there exists\n /// atomic operations X and Y, both operating on some atomic object 'M' such\n /// that A is sequenced before X, Y is synchronized before B and Y observes\n /// the change to M. This provides a happens-before dependence between A and B.\n ///\n-/// Atomic operations with `Release` or `Acquire` semantics can also synchronize\n+/// Atomic operations with [`Release`] or [`Acquire`] semantics can also synchronize\n /// with a fence.\n ///\n-/// A fence which has `SeqCst` ordering, in addition to having both `Acquire`\n-/// and `Release` semantics, participates in the global program order of the\n-/// other `SeqCst` operations and/or fences.\n+/// A fence which has [`SeqCst`] ordering, in addition to having both [`Acquire`]\n+/// and [`Release`] semantics, participates in the global program order of the\n+/// other [`SeqCst`] operations and/or fences.\n ///\n-/// Accepts `Acquire`, `Release`, `AcqRel` and `SeqCst` orderings.\n+/// Accepts [`Acquire`], [`Release`], [`AcqRel`] and [`SeqCst`] orderings.\n ///\n /// # Panics\n ///\n-/// Panics if `order` is `Relaxed`.\n+/// Panics if `order` is [`Relaxed`].\n+///\n+/// [`Ordering`]: enum.Ordering.html\n+/// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+/// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n+/// [`Release`]: enum.Ordering.html#variant.Release\n+/// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+/// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn fence(order: Ordering) {"}, {"sha": "2ee4cc49435611316e1a7e1d3b717dae609c8574", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -96,7 +96,7 @@ fn main() {\n \n     let optional_components =\n         [\"x86\", \"arm\", \"aarch64\", \"mips\", \"powerpc\", \"pnacl\", \"systemz\", \"jsbackend\", \"msp430\",\n-         \"sparc\"];\n+         \"sparc\", \"nvptx\"];\n \n     // FIXME: surely we don't need all these components, right? Stuff like mcjit\n     //        or interpreter the compiler itself never uses."}, {"sha": "c1705815165939b505ed948ab23434f655a145bd", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -42,6 +42,7 @@ pub enum CallConv {\n     X86StdcallCallConv = 64,\n     X86FastcallCallConv = 65,\n     ArmAapcsCallConv = 67,\n+    PtxKernel = 71,\n     X86_64_SysV = 78,\n     X86_64_Win64 = 79,\n     X86_VectorCall = 80,"}, {"sha": "1e45ea083c9e011046d33475e8e0df4852d48161", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -376,6 +376,11 @@ pub fn initialize_available_targets() {\n                  LLVMInitializeSparcTargetMC,\n                  LLVMInitializeSparcAsmPrinter,\n                  LLVMInitializeSparcAsmParser);\n+    init_target!(llvm_component = \"nvptx\",\n+                 LLVMInitializeNVPTXTargetInfo,\n+                 LLVMInitializeNVPTXTarget,\n+                 LLVMInitializeNVPTXTargetMC,\n+                 LLVMInitializeNVPTXAsmPrinter);\n }\n \n pub fn last_error() -> Option<String> {"}, {"sha": "e814050e9609771a0d859249dcd95c173ed7c703", "filename": "src/librustc_platform_intrinsics/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibrustc_platform_intrinsics%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibrustc_platform_intrinsics%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_platform_intrinsics%2Flib.rs?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -95,6 +95,7 @@ static VOID: Type = Type::Void;\n mod x86;\n mod arm;\n mod aarch64;\n+mod nvptx;\n \n impl Intrinsic {\n     pub fn find(name: &str) -> Option<Intrinsic> {\n@@ -104,6 +105,8 @@ impl Intrinsic {\n             arm::find(name)\n         } else if name.starts_with(\"aarch64_\") {\n             aarch64::find(name)\n+        } else if name.starts_with(\"nvptx_\") {\n+            nvptx::find(name)\n         } else {\n             None\n         }"}, {"sha": "82408723ebe6fafe8cf342b58514c1c62cec63b5", "filename": "src/librustc_platform_intrinsics/nvptx.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibrustc_platform_intrinsics%2Fnvptx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibrustc_platform_intrinsics%2Fnvptx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_platform_intrinsics%2Fnvptx.rs?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -0,0 +1,92 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// DO NOT EDIT: autogenerated by etc/platform-intrinsics/generator.py\n+// ignore-tidy-linelength\n+\n+#![allow(unused_imports)]\n+\n+use {Intrinsic, Type};\n+use IntrinsicDef::Named;\n+\n+// The default inlining settings trigger a pathological behaviour in\n+// LLVM, which causes makes compilation very slow. See #28273.\n+#[inline(never)]\n+pub fn find(name: &str) -> Option<Intrinsic> {\n+    if !name.starts_with(\"nvptx\") { return None }\n+    Some(match &name[\"nvptx\".len()..] {\n+        \"_syncthreads\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::VOID,\n+            definition: Named(\"llvm.cuda.syncthreads\")\n+        },\n+        \"_block_dim_x\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.ntid.x\")\n+        },\n+        \"_block_dim_y\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.ntid.y\")\n+        },\n+        \"_block_dim_z\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.ntid.z\")\n+        },\n+        \"_block_idx_x\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.ctaid.x\")\n+        },\n+        \"_block_idx_y\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.ctaid.y\")\n+        },\n+        \"_block_idx_z\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.ctaid.z\")\n+        },\n+        \"_grid_dim_x\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.nctaid.x\")\n+        },\n+        \"_grid_dim_y\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.nctaid.y\")\n+        },\n+        \"_grid_dim_z\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.nctaid.z\")\n+        },\n+        \"_thread_idx_x\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.tid.x\")\n+        },\n+        \"_thread_idx_y\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.tid.y\")\n+        },\n+        \"_thread_idx_z\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.tid.z\")\n+        },\n+        _ => return None,\n+    })\n+}"}, {"sha": "81e4b4d1f21c76c84ed115ac748d519a007617ff", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -25,6 +25,8 @@ use cabi_mips64;\n use cabi_asmjs;\n use cabi_msp430;\n use cabi_sparc;\n+use cabi_nvptx;\n+use cabi_nvptx64;\n use machine::{llalign_of_min, llsize_of, llsize_of_alloc};\n use type_::Type;\n use type_of;\n@@ -353,6 +355,7 @@ impl FnType {\n             Win64 => llvm::X86_64_Win64,\n             SysV64 => llvm::X86_64_SysV,\n             Aapcs => llvm::ArmAapcsCallConv,\n+            PtxKernel => llvm::PtxKernel,\n \n             // These API constants ought to be more specific...\n             Cdecl => llvm::CCallConv,\n@@ -608,6 +611,8 @@ impl FnType {\n             \"wasm32\" => cabi_asmjs::compute_abi_info(ccx, self),\n             \"msp430\" => cabi_msp430::compute_abi_info(ccx, self),\n             \"sparc\" => cabi_sparc::compute_abi_info(ccx, self),\n+            \"nvptx\" => cabi_nvptx::compute_abi_info(ccx, self),\n+            \"nvptx64\" => cabi_nvptx64::compute_abi_info(ccx, self),\n             a => ccx.sess().fatal(&format!(\"unrecognized arch \\\"{}\\\" in target specification\", a))\n         }\n "}, {"sha": "5ece19f764a8ac2572f9161815e7f62a9040c22e", "filename": "src/librustc_trans/cabi_nvptx.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibrustc_trans%2Fcabi_nvptx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibrustc_trans%2Fcabi_nvptx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_nvptx.rs?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Reference: PTX Writer's Guide to Interoperability\n+// http://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability\n+\n+#![allow(non_upper_case_globals)]\n+\n+use llvm::Struct;\n+\n+use abi::{self, ArgType, FnType};\n+use context::CrateContext;\n+use type_::Type;\n+\n+fn ty_size(ty: Type) -> usize {\n+    abi::ty_size(ty, 4)\n+}\n+\n+fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n+    if ret.ty.kind() == Struct && ty_size(ret.ty) > 32 {\n+        ret.make_indirect(ccx);\n+    } else {\n+        ret.extend_integer_width_to(32);\n+    }\n+}\n+\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n+    if arg.ty.kind() == Struct && ty_size(arg.ty) > 32 {\n+        arg.make_indirect(ccx);\n+    } else {\n+        arg.extend_integer_width_to(32);\n+    }\n+}\n+\n+pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+    if !fty.ret.is_ignore() {\n+        classify_ret_ty(ccx, &mut fty.ret);\n+    }\n+\n+    for arg in &mut fty.args {\n+        if arg.is_ignore() {\n+            continue;\n+        }\n+        classify_arg_ty(ccx, arg);\n+    }\n+}"}, {"sha": "880c6cfd7a8ac24387c183f97ef9848bb577ec89", "filename": "src/librustc_trans/cabi_nvptx64.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibrustc_trans%2Fcabi_nvptx64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibrustc_trans%2Fcabi_nvptx64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_nvptx64.rs?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Reference: PTX Writer's Guide to Interoperability\n+// http://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability\n+\n+#![allow(non_upper_case_globals)]\n+\n+use llvm::Struct;\n+\n+use abi::{self, ArgType, FnType};\n+use context::CrateContext;\n+use type_::Type;\n+\n+fn ty_size(ty: Type) -> usize {\n+    abi::ty_size(ty, 8)\n+}\n+\n+fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n+    if ret.ty.kind() == Struct && ty_size(ret.ty) > 64 {\n+        ret.make_indirect(ccx);\n+    } else {\n+        ret.extend_integer_width_to(64);\n+    }\n+}\n+\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n+    if arg.ty.kind() == Struct && ty_size(arg.ty) > 64 {\n+        arg.make_indirect(ccx);\n+    } else {\n+        arg.extend_integer_width_to(64);\n+    }\n+}\n+\n+pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+    if !fty.ret.is_ignore() {\n+        classify_ret_ty(ccx, &mut fty.ret);\n+    }\n+\n+    for arg in &mut fty.args {\n+        if arg.is_ignore() {\n+            continue;\n+        }\n+        classify_arg_ty(ccx, arg);\n+    }\n+}"}, {"sha": "0d3e1853f011eb001cb0f8219e6cf1996b6c3b5a", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -103,6 +103,8 @@ mod cabi_asmjs;\n mod cabi_mips;\n mod cabi_mips64;\n mod cabi_msp430;\n+mod cabi_nvptx;\n+mod cabi_nvptx64;\n mod cabi_powerpc;\n mod cabi_powerpc64;\n mod cabi_s390x;"}, {"sha": "ff7133f5d0c971efec75047d85e6e961eb1a5c19", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -2057,10 +2057,9 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         let item_type = m.type_();\n         let id = derive_id(format!(\"{}.{}\", item_type, name));\n         let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n-        write!(w, \"<h3 id='{id}' class='method stab {stab}'>\\\n+        write!(w, \"<h3 id='{id}' class='method'>\\\n                    <span id='{ns_id}' class='invisible'><code>\",\n                id = id,\n-               stab = m.stability_class(),\n                ns_id = ns_id)?;\n         render_assoc_item(w, m, AssocItemLink::Anchor(Some(&id)), ItemType::Impl)?;\n         write!(w, \"</code>\")?;"}, {"sha": "dcab30aad8385b9c9ed38929c3531007a1740b6d", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -10,8 +10,9 @@\n \n #![unstable(reason = \"not public\", issue = \"0\", feature = \"fd\")]\n \n+use cmp;\n use io::{self, Read};\n-use libc::{self, c_int, c_void};\n+use libc::{self, c_int, c_void, ssize_t};\n use mem;\n use sync::atomic::{AtomicBool, Ordering};\n use sys::cvt;\n@@ -23,6 +24,22 @@ pub struct FileDesc {\n     fd: c_int,\n }\n \n+fn max_len() -> usize {\n+    // The maximum read limit on most posix-like systems is `SSIZE_MAX`,\n+    // with the man page quoting that if the count of bytes to read is\n+    // greater than `SSIZE_MAX` the result is \"unspecified\".\n+    //\n+    // On OSX, however, apparently the 64-bit libc is either buggy or\n+    // intentionally showing odd behavior by rejecting any read with a size\n+    // larger than or equal to INT_MAX. To handle both of these the read\n+    // size is capped on both platforms.\n+    if cfg!(target_os = \"macos\") {\n+        <c_int>::max_value() as usize - 1\n+    } else {\n+        <ssize_t>::max_value() as usize\n+    }\n+}\n+\n impl FileDesc {\n     pub fn new(fd: c_int) -> FileDesc {\n         FileDesc { fd: fd }\n@@ -41,7 +58,7 @@ impl FileDesc {\n         let ret = cvt(unsafe {\n             libc::read(self.fd,\n                        buf.as_mut_ptr() as *mut c_void,\n-                       buf.len())\n+                       cmp::min(buf.len(), max_len()))\n         })?;\n         Ok(ret as usize)\n     }\n@@ -69,7 +86,7 @@ impl FileDesc {\n         unsafe {\n             cvt_pread64(self.fd,\n                         buf.as_mut_ptr() as *mut c_void,\n-                        buf.len(),\n+                        cmp::min(buf.len(), max_len()),\n                         offset as i64)\n                 .map(|n| n as usize)\n         }\n@@ -79,7 +96,7 @@ impl FileDesc {\n         let ret = cvt(unsafe {\n             libc::write(self.fd,\n                         buf.as_ptr() as *const c_void,\n-                        buf.len())\n+                        cmp::min(buf.len(), max_len()))\n         })?;\n         Ok(ret as usize)\n     }\n@@ -102,7 +119,7 @@ impl FileDesc {\n         unsafe {\n             cvt_pwrite64(self.fd,\n                          buf.as_ptr() as *const c_void,\n-                         buf.len(),\n+                         cmp::min(buf.len(), max_len()),\n                          offset as i64)\n                 .map(|n| n as usize)\n         }"}, {"sha": "fdb9483fe1c8b0ed0aab3d708b194460591486ca", "filename": "src/libstd/sys/windows/handle.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -19,7 +19,6 @@ use ptr;\n use sys::c;\n use sys::cvt;\n use sys_common::io::read_to_end_uninitialized;\n-use u32;\n \n /// An owned container for `HANDLE` object, closing them on Drop.\n ///\n@@ -83,9 +82,7 @@ impl RawHandle {\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n         let mut read = 0;\n-        // ReadFile takes a DWORD (u32) for the length so it only supports\n-        // reading u32::MAX bytes at a time.\n-        let len = cmp::min(buf.len(), u32::MAX as usize) as c::DWORD;\n+        let len = cmp::min(buf.len(), <c::DWORD>::max_value() as usize) as c::DWORD;\n         let res = cvt(unsafe {\n             c::ReadFile(self.0, buf.as_mut_ptr() as c::LPVOID,\n                         len, &mut read, ptr::null_mut())\n@@ -181,9 +178,7 @@ impl RawHandle {\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         let mut amt = 0;\n-        // WriteFile takes a DWORD (u32) for the length so it only supports\n-        // writing u32::MAX bytes at a time.\n-        let len = cmp::min(buf.len(), u32::MAX as usize) as c::DWORD;\n+        let len = cmp::min(buf.len(), <c::DWORD>::max_value() as usize) as c::DWORD;\n         cvt(unsafe {\n             c::WriteFile(self.0, buf.as_ptr() as c::LPVOID,\n                          len, &mut amt, ptr::null_mut())"}, {"sha": "81979fd41a6bf6f16ed820eb705973831b46328c", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 58, "deletions": 3, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -216,6 +216,20 @@ pub use self::local::{LocalKey, LocalKeyState};\n \n /// Thread configuration. Provides detailed control over the properties\n /// and behavior of new threads.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::thread;\n+///\n+/// let builder = thread::Builder::new();\n+///\n+/// let handler = builder.spawn(|| {\n+///     // thread code\n+/// }).unwrap();\n+///\n+/// handler.join().unwrap();\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct Builder {\n@@ -228,6 +242,22 @@ pub struct Builder {\n impl Builder {\n     /// Generates the base configuration for spawning a thread, from which\n     /// configuration methods can be chained.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::thread;\n+    ///\n+    /// let builder = thread::Builder::new()\n+    ///                               .name(\"foo\".into())\n+    ///                               .stack_size(10);\n+    ///\n+    /// let handler = builder.spawn(|| {\n+    ///     // thread code\n+    /// }).unwrap();\n+    ///\n+    /// handler.join().unwrap();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> Builder {\n         Builder {\n@@ -241,7 +271,7 @@ impl Builder {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::thread;\n     ///\n     /// let builder = thread::Builder::new()\n@@ -260,6 +290,14 @@ impl Builder {\n     }\n \n     /// Sets the size of the stack for the new thread.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::thread;\n+    ///\n+    /// let builder = thread::Builder::new().stack_size(10);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn stack_size(mut self, size: usize) -> Builder {\n         self.stack_size = Some(size);\n@@ -275,9 +313,26 @@ impl Builder {\n     ///\n     /// # Errors\n     ///\n-    /// Unlike the `spawn` free function, this method yields an\n-    /// `io::Result` to capture any failure to create the thread at\n+    /// Unlike the [`spawn`] free function, this method yields an\n+    /// [`io::Result`] to capture any failure to create the thread at\n     /// the OS level.\n+    ///\n+    /// [`spawn`]: ../../std/thread/fn.spawn.html\n+    /// [`io::Result`]: ../../std/io/type.Result.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::thread;\n+    ///\n+    /// let builder = thread::Builder::new();\n+    ///\n+    /// let handler = builder.spawn(|| {\n+    ///     // thread code\n+    /// }).unwrap();\n+    ///\n+    /// handler.join().unwrap();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn spawn<F, T>(self, f: F) -> io::Result<JoinHandle<T>> where\n         F: FnOnce() -> T, F: Send + 'static, T: Send + 'static"}, {"sha": "0cc62fb43a54d270cbf287167944c44782fd41f1", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -41,6 +41,7 @@ pub enum Abi {\n     Aapcs,\n     Win64,\n     SysV64,\n+    PtxKernel,\n \n     // Multiplatform / generic ABIs\n     Rust,\n@@ -82,6 +83,7 @@ const AbiDatas: &'static [AbiData] = &[\n     AbiData {abi: Abi::Aapcs, name: \"aapcs\", generic: false },\n     AbiData {abi: Abi::Win64, name: \"win64\", generic: false },\n     AbiData {abi: Abi::SysV64, name: \"sysv64\", generic: false },\n+    AbiData {abi: Abi::PtxKernel, name: \"ptx-kernel\", generic: false },\n \n     // Cross-platform ABIs\n     AbiData {abi: Abi::Rust, name: \"Rust\", generic: true },"}, {"sha": "625af803458b5bd939782b4a4dafb698342b9e78", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -318,6 +318,9 @@ declare_features! (\n \n     // Allow safe suggestions for potential type conversions.\n     (active, safe_suggestion, \"1.0.0\", Some(37384)),\n+\n+    // `extern \"ptx-*\" fn()`\n+    (active, abi_ptx, \"1.15.0\", None),\n );\n \n declare_features! (\n@@ -986,7 +989,19 @@ impl<'a> PostExpansionVisitor<'a> {\n                 gate_feature_post!(&self, abi_sysv64, span,\n                                    \"sysv64 ABI is experimental and subject to change\");\n             },\n-            _ => {}\n+            Abi::PtxKernel => {\n+                gate_feature_post!(&self, abi_ptx, span,\n+                                   \"PTX ABIs are experimental and subject to change\");\n+            }\n+            // Stable\n+            Abi::Cdecl |\n+            Abi::Stdcall |\n+            Abi::Fastcall |\n+            Abi::Aapcs |\n+            Abi::Win64 |\n+            Abi::Rust |\n+            Abi::C |\n+            Abi::System => {}\n         }\n     }\n }"}, {"sha": "68cfc7033ef5afa9938e483b13e6603a29e99954", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -190,7 +190,7 @@ impl<T: Write + Send> Terminal for TerminfoTerminal<T> {\n     fn reset(&mut self) -> io::Result<bool> {\n         // are there any terminals that have color/attrs and not sgr0?\n         // Try falling back to sgr, then op\n-        let cmd = match [\"sg0\", \"sgr\", \"op\"]\n+        let cmd = match [\"sgr0\", \"sgr\", \"op\"]\n                             .iter()\n                             .filter_map(|cap| self.ti.strings.get(*cap))\n                             .next() {"}, {"sha": "7304f384c61d601b771a18b4de0c784443e48e0c", "filename": "src/rustllvm/ArchiveWrapper.cpp", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Frustllvm%2FArchiveWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Frustllvm%2FArchiveWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FArchiveWrapper.cpp?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -33,12 +33,15 @@ struct RustArchiveMember {\n \n \n struct RustArchiveIterator {\n+    bool first;\n     Archive::child_iterator cur;\n     Archive::child_iterator end;\n #if LLVM_VERSION_GE(3, 9)\n     Error err;\n \n-    RustArchiveIterator() : err(Error::success()) { }\n+    RustArchiveIterator() : first(true), err(Error::success()) { }\n+#else\n+    RustArchiveIterator() : first(true) { }\n #endif\n };\n \n@@ -120,6 +123,7 @@ LLVMRustArchiveIteratorNew(LLVMRustArchiveRef ra) {\n     rai->cur = ar->child_begin(rai->err);\n     if (rai->err) {\n         LLVMRustSetLastError(toString(std::move(rai->err)).c_str());\n+        delete rai;\n         return NULL;\n     }\n #endif\n@@ -129,27 +133,40 @@ LLVMRustArchiveIteratorNew(LLVMRustArchiveRef ra) {\n \n extern \"C\" LLVMRustArchiveChildConstRef\n LLVMRustArchiveIteratorNext(LLVMRustArchiveIteratorRef rai) {\n+    if (rai->cur == rai->end) return nullptr;\n+\n+    // Advancing the iterator validates the next child, and this can\n+    // uncover an error. LLVM requires that we check all Errors,\n+    // so we only advance the iterator if we actually need to fetch\n+    // the next child.\n+    // This means we must not advance the iterator in the *first* call,\n+    // but instead advance it *before* fetching the child in all later calls.\n+    if (!rai->first) {\n+        ++rai->cur;\n #if LLVM_VERSION_GE(3, 9)\n-    if (rai->err) {\n-        LLVMRustSetLastError(toString(std::move(rai->err)).c_str());\n-        return NULL;\n-    }\n+        if (rai->err) {\n+            LLVMRustSetLastError(toString(std::move(rai->err)).c_str());\n+            return nullptr;\n+        }\n #endif\n-    if (rai->cur == rai->end)\n-        return NULL;\n+    } else {\n+      rai->first = false;\n+    }\n+\n+    if (rai->cur == rai->end) return nullptr;\n+\n #if LLVM_VERSION_EQ(3, 8)\n     const ErrorOr<Archive::Child>* cur = rai->cur.operator->();\n     if (!*cur) {\n         LLVMRustSetLastError(cur->getError().message().c_str());\n-        return NULL;\n+        return nullptr;\n     }\n     const Archive::Child &child = cur->get();\n #else\n     const Archive::Child &child = *rai->cur.operator->();\n #endif\n     Archive::Child *ret = new Archive::Child(child);\n \n-    ++rai->cur;\n     return ret;\n }\n "}, {"sha": "70fe17888e84d6a74fef8daee7ec9c03eeb941d7", "filename": "src/test/ui/codemap_tests/unicode.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.stderr?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -1,4 +1,4 @@\n-error: invalid ABI: expected one of [cdecl, stdcall, fastcall, vectorcall, aapcs, win64, sysv64, Rust, C, system, rust-intrinsic, rust-call, platform-intrinsic], found `\u8def\u6feb\u72fc\u00e1\u0301\u0301`\n+error: invalid ABI: expected one of [cdecl, stdcall, fastcall, vectorcall, aapcs, win64, sysv64, ptx-kernel, Rust, C, system, rust-intrinsic, rust-call, platform-intrinsic], found `\u8def\u6feb\u72fc\u00e1\u0301\u0301`\n   --> $DIR/unicode.rs:11:8\n    |\n 11 | extern \"\u8def\u6feb\u72fc\u00e1\u0301\u0301\" fn foo() {}"}, {"sha": "b4f4d17990536768bf3dc2566b1cd374af00716a", "filename": "src/tools/cargotest/main.rs", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Ftools%2Fcargotest%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Ftools%2Fcargotest%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargotest%2Fmain.rs?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -21,19 +21,38 @@ struct Test {\n     lock: Option<&'static str>,\n }\n \n-const TEST_REPOS: &'static [Test] = &[Test {\n-                                          name: \"cargo\",\n-                                          repo: \"https://github.com/rust-lang/cargo\",\n-                                          sha: \"b7be4f2ef2cf743492edc6dfb55d087ed88f2d76\",\n-                                          lock: None,\n-                                      },\n-                                      Test {\n-                                          name: \"iron\",\n-                                          repo: \"https://github.com/iron/iron\",\n-                                          sha: \"16c858ec2901e2992fe5e529780f59fa8ed12903\",\n-                                          lock: Some(include_str!(\"lockfiles/iron-Cargo.lock\")),\n-                                      }];\n-\n+const TEST_REPOS: &'static [Test] = &[\n+    Test {\n+        name: \"cargo\",\n+        repo: \"https://github.com/rust-lang/cargo\",\n+        sha: \"b7be4f2ef2cf743492edc6dfb55d087ed88f2d76\",\n+        lock: None,\n+    },\n+    Test {\n+        name: \"iron\",\n+        repo: \"https://github.com/iron/iron\",\n+        sha: \"16c858ec2901e2992fe5e529780f59fa8ed12903\",\n+        lock: Some(include_str!(\"lockfiles/iron-Cargo.lock\")),\n+    },\n+    Test {\n+        name: \"ripgrep\",\n+        repo: \"https://github.com/BurntSushi/ripgrep\",\n+        sha: \"b65bb37b14655e1a89c7cd19c8b011ef3e312791\",\n+        lock: None,\n+    },\n+    Test {\n+        name: \"tokei\",\n+        repo: \"https://github.com/Aaronepower/tokei\",\n+        sha: \"5e11c4852fe4aa086b0e4fe5885822fbe57ba928\",\n+        lock: None,\n+    },\n+    Test {\n+        name: \"treeify\",\n+        repo: \"https://github.com/dzamlo/treeify\",\n+        sha: \"999001b223152441198f117a68fb81f57bc086dd\",\n+        lock: None,\n+    },\n+];\n \n fn main() {\n     // One of the projects being tested here is Cargo, and when being tested"}, {"sha": "dbfe1111846a819ed099ae6ff0070859f899f192", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2d2afa9196ba6314a29e58d5324dbd9923c75e/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "patch": "@@ -261,7 +261,23 @@ pub fn run_tests(config: &Config) {\n         // android debug-info test uses remote debugger\n         // so, we test 1 thread at once.\n         // also trying to isolate problems with adb_run_wrapper.sh ilooping\n-        env::set_var(\"RUST_TEST_THREADS\",\"1\");\n+        match config.mode {\n+            // These tests don't actually run code or don't run for android, so\n+            // we don't need to limit ourselves there\n+            Mode::Ui |\n+            Mode::CompileFail |\n+            Mode::ParseFail |\n+            Mode::RunMake |\n+            Mode::Codegen |\n+            Mode::CodegenUnits |\n+            Mode::Pretty |\n+            Mode::Rustdoc => {}\n+\n+            _ => {\n+                env::set_var(\"RUST_TEST_THREADS\", \"1\");\n+            }\n+\n+        }\n     }\n \n     match config.mode {"}]}