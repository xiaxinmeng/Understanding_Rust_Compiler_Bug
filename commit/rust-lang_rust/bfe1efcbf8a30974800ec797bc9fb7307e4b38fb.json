{"sha": "bfe1efcbf8a30974800ec797bc9fb7307e4b38fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmZTFlZmNiZjhhMzA5NzQ4MDBlYzc5N2JjOWZiNzMwN2U0YjM4ZmI=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-12-06T17:13:11Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-12-06T17:13:11Z"}, "message": "stop leaking memory on closure calls", "tree": {"sha": "ddbed8688a31baaec1fbea2e4db70f728624faca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ddbed8688a31baaec1fbea2e4db70f728624faca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bfe1efcbf8a30974800ec797bc9fb7307e4b38fb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJYRvGnAAoJEFbW7qD8Z6xGXc8QAKXfSBFwPFwZPnHn6mbmU+qd\n22yHKYEOHYWY1BvYyO60Lubs8W7ZoH9MM6pcD1oxsv9UsvuhKzR5cWT23H8LZjRu\nwCvnL6hc6xRfKrvwlCbJr7ZbPbTXPYzdHaUOrSZAt4bMSbLZZXI45Enq/WPgFYBJ\nyBUgo4GX7ca4lpMkbXmejfyzBq304OkkWihceFvAoNtDT2CvRnVyBtjDehLO1mO5\nLf0hJF3ZxT18i1f4VUq2zo8/Vrwm8mf7tyzEJ2O+WXC1d0BgcU7hFb7A2RxH0mMP\nIhy+YjSDuOw7cDRNqaD/riIqcV2u5s04HGzHYmipxy4TF5YEwesFyLhxN/JmqO02\n5X/cNglpEKYZjYYPACgx5NcREyB0b3xAJFrLTZ0HFr6emj72p5nmAskMqoNapXom\ncLlpinVYdJyXFU/gs7XKeXb/hygqasqH9s8sWUK5toxCbMsazaf2T7cc7K3onxZS\nunjnijH4cilTxk1fltv4PuvHUkRzYo20LPB5kMSvkcc2oY/bLZFknpaWWHz98UtH\nZNlw2pu7YFr7ZoJ1MfxvIt4Nn261ww/Yl8Exrx8Qo/PVICbQD2E+rRvLjGyUS4IS\ntL/bHUzhWI3IheoiiRhBLoZUV/DTrJrDrsBOzu/Oi1kZ4Fy3Y5TGIHqfoovCi5ww\nEBO/Kp0KUV6WnH71Q9lM\n=fnJO\n-----END PGP SIGNATURE-----", "payload": "tree ddbed8688a31baaec1fbea2e4db70f728624faca\nparent 360ef490f47040e7baac28affb6a0ce531410f2f\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1481044391 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1481044391 +0100\n\nstop leaking memory on closure calls"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bfe1efcbf8a30974800ec797bc9fb7307e4b38fb", "html_url": "https://github.com/rust-lang/rust/commit/bfe1efcbf8a30974800ec797bc9fb7307e4b38fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bfe1efcbf8a30974800ec797bc9fb7307e4b38fb/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "360ef490f47040e7baac28affb6a0ce531410f2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/360ef490f47040e7baac28affb6a0ce531410f2f", "html_url": "https://github.com/rust-lang/rust/commit/360ef490f47040e7baac28affb6a0ce531410f2f"}], "stats": {"total": 78, "additions": 41, "deletions": 37}, "files": [{"sha": "f5da33d4b3782a16018a4da06bfa97159f86f8d7", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bfe1efcbf8a30974800ec797bc9fb7307e4b38fb/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfe1efcbf8a30974800ec797bc9fb7307e4b38fb/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=bfe1efcbf8a30974800ec797bc9fb7307e4b38fb", "patch": "@@ -82,6 +82,12 @@ pub struct Frame<'tcx> {\n     /// Before being initialized, a local is simply marked as None.\n     pub locals: Vec<Option<Value>>,\n \n+    /// Temporaries introduced to save stackframes\n+    /// This is pure interpreter magic and has nothing to do with how rustc does it\n+    /// An example is calling an FnMut closure that has been converted to a FnOnce closure\n+    /// If they are Value::ByRef, their memory will be freed when the stackframe finishes\n+    pub interpreter_temporaries: Vec<Value>,\n+\n     ////////////////////////////////////////////////////////////////////////////////\n     // Current position within the function\n     ////////////////////////////////////////////////////////////////////////////////\n@@ -327,6 +333,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         substs: &'tcx Substs<'tcx>,\n         return_lvalue: Lvalue<'tcx>,\n         return_to_block: StackPopCleanup,\n+        temporaries: Vec<Value>,\n     ) -> EvalResult<'tcx, ()> {\n         ::log_settings::settings().indentation += 1;\n \n@@ -341,6 +348,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             return_to_block: return_to_block,\n             return_lvalue: return_lvalue,\n             locals: locals,\n+            interpreter_temporaries: temporaries,\n             span: span,\n             def_id: def_id,\n             substs: substs,\n@@ -385,9 +393,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             StackPopCleanup::None => {},\n         }\n         // deallocate all locals that are backed by an allocation\n-        for (i, local) in frame.locals.into_iter().enumerate() {\n-            if let Some(Value::ByRef(ptr)) = local {\n-                trace!(\"deallocating local {}: {:?}\", i + 1, ptr);\n+        for local in frame.locals.into_iter().filter_map(|l| l).chain(frame.interpreter_temporaries) {\n+            if let Value::ByRef(ptr) = local {\n                 self.memory.dump(ptr.alloc_id);\n                 match self.memory.deallocate(ptr) {\n                     // Any frozen memory means that it belongs to a constant or something referenced\n@@ -1131,27 +1138,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(new_lvalue)\n     }\n \n-    // FIXME(solson): This method unnecessarily allocates and should not be necessary. We can\n-    // remove it as soon as PrimVal can represent fat pointers.\n-    fn value_to_ptr_dont_use(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Pointer> {\n-        match value {\n-            Value::ByRef(ptr) => Ok(ptr),\n-\n-            Value::ByVal(primval) => {\n-                let ptr = self.alloc_ptr(ty)?;\n-                let kind = self.ty_to_primval_kind(ty)?;\n-                self.memory.write_primval(ptr, primval, kind)?;\n-                Ok(ptr)\n-            }\n-\n-            Value::ByValPair(a, b) => {\n-                let ptr = self.alloc_ptr(ty)?;\n-                self.write_pair_to_ptr(a, b, ptr, ty)?;\n-                Ok(ptr)\n-            }\n-        }\n-    }\n-\n     /// ensures this Value is not a ByRef\n     fn follow_by_ref_value(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         match value {\n@@ -1719,6 +1705,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n         tcx.intern_substs(&[]),\n         Lvalue::from_ptr(Pointer::zst_ptr()),\n         StackPopCleanup::None,\n+        Vec::new(),\n     ).expect(\"could not allocate first stack frame\");\n \n     loop {"}, {"sha": "ff4f3b3aa7003d038b87a74efb05642234d99276", "filename": "src/interpreter/step.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bfe1efcbf8a30974800ec797bc9fb7307e4b38fb/src%2Finterpreter%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfe1efcbf8a30974800ec797bc9fb7307e4b38fb/src%2Finterpreter%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstep.rs?ref=bfe1efcbf8a30974800ec797bc9fb7307e4b38fb", "patch": "@@ -145,7 +145,7 @@ impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n             } else {\n                 StackPopCleanup::None\n             };\n-            this.ecx.push_stack_frame(def_id, span, mir, substs, Lvalue::Global(cid), cleanup)\n+            this.ecx.push_stack_frame(def_id, span, mir, substs, Lvalue::Global(cid), cleanup, Vec::new())\n         });\n     }\n     fn try<F: FnOnce(&mut Self) -> EvalResult<'tcx, ()>>(&mut self, f: F) {\n@@ -194,7 +194,8 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n                                               mir,\n                                               this.substs,\n                                               Lvalue::Global(cid),\n-                                              StackPopCleanup::Freeze)\n+                                              StackPopCleanup::Freeze,\n+                                              Vec::new())\n                 });\n             }\n         }"}, {"sha": "8c7d06af41907fba870ee7fd57c0b933235b69f5", "filename": "src/interpreter/terminator/mod.rs", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bfe1efcbf8a30974800ec797bc9fb7307e4b38fb/src%2Finterpreter%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfe1efcbf8a30974800ec797bc9fb7307e4b38fb/src%2Finterpreter%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fmod.rs?ref=bfe1efcbf8a30974800ec797bc9fb7307e4b38fb", "patch": "@@ -164,6 +164,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 substs,\n                 Lvalue::from_ptr(Pointer::zst_ptr()),\n                 StackPopCleanup::None,\n+                Vec::new(),\n             )?;\n             let mut arg_locals = self.frame().mir.args_iter();\n             let first = arg_locals.next().expect(\"drop impl has self arg\");\n@@ -211,11 +212,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 }\n \n                 // Only trait methods can have a Self parameter.\n-                let (resolved_def_id, resolved_substs) =\n+                let (resolved_def_id, resolved_substs, temporaries) =\n                     if let Some(trait_id) = self.tcx.trait_of_item(def_id) {\n                         self.trait_method(trait_id, def_id, substs, &mut args)?\n                     } else {\n-                        (def_id, substs)\n+                        (def_id, substs, Vec::new())\n                     };\n \n                 let mir = self.load_mir(resolved_def_id)?;\n@@ -235,6 +236,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     resolved_substs,\n                     return_lvalue,\n                     return_to_block,\n+                    temporaries,\n                 )?;\n \n                 let arg_locals = self.frame().mir.args_iter();\n@@ -430,7 +432,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         def_id: DefId,\n         substs: &'tcx Substs<'tcx>,\n         args: &mut Vec<(Value, Ty<'tcx>)>,\n-    ) -> EvalResult<'tcx, (DefId, &'tcx Substs<'tcx>)> {\n+    ) -> EvalResult<'tcx, (DefId, &'tcx Substs<'tcx>, Vec<Value>)> {\n         let trait_ref = ty::TraitRef::from_method(self.tcx, trait_id, substs);\n         let trait_ref = self.tcx.normalize_associated_type(&ty::Binder(trait_ref));\n \n@@ -442,7 +444,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 // and those from the method:\n                 let (did, substs) = find_method(self.tcx, substs, impl_did, vtable_impl.substs, mname);\n \n-                Ok((did, substs))\n+                Ok((did, substs, Vec::new()))\n             }\n \n             traits::VtableClosure(vtable_closure) => {\n@@ -453,6 +455,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let closure_kind = self.tcx.closure_kind(vtable_closure.closure_def_id);\n                 trace!(\"closures {:?}, {:?}\", closure_kind, trait_closure_kind);\n                 self.unpack_fn_args(args)?;\n+                let mut temporaries = Vec::new();\n                 match (closure_kind, trait_closure_kind) {\n                     (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n                     (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n@@ -472,23 +475,36 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                         // Interpreter magic: insert an intermediate pointer, so we can skip the\n                         // intermediate function call.\n-                        // FIXME: this is a memory leak, should probably add the pointer to the\n-                        // current stack.\n-                        let first = self.value_to_ptr_dont_use(args[0].0, args[0].1)?;\n-                        args[0].0 = Value::ByVal(PrimVal::from_ptr(first));\n+                        let ptr = match args[0].0 {\n+                            Value::ByRef(ptr) => ptr,\n+                            Value::ByVal(primval) => {\n+                                let ptr = self.alloc_ptr(args[0].1)?;\n+                                let kind = self.ty_to_primval_kind(args[0].1)?;\n+                                self.memory.write_primval(ptr, primval, kind)?;\n+                                temporaries.push(Value::ByRef(ptr));\n+                                ptr\n+                            },\n+                            Value::ByValPair(a, b) => {\n+                                let ptr = self.alloc_ptr(args[0].1)?;\n+                                self.write_pair_to_ptr(a, b, ptr, args[0].1)?;\n+                                temporaries.push(Value::ByRef(ptr));\n+                                ptr\n+                            },\n+                        };\n+                        args[0].0 = Value::ByVal(PrimVal::from_ptr(ptr));\n                         args[0].1 = self.tcx.mk_mut_ptr(args[0].1);\n                     }\n \n                     _ => bug!(\"cannot convert {:?} to {:?}\", closure_kind, trait_closure_kind),\n                 }\n-                Ok((vtable_closure.closure_def_id, vtable_closure.substs.substs))\n+                Ok((vtable_closure.closure_def_id, vtable_closure.substs.substs, temporaries))\n             }\n \n             traits::VtableFnPointer(vtable_fn_ptr) => {\n                 if let ty::TyFnDef(did, ref substs, _) = vtable_fn_ptr.fn_ty.sty {\n                     args.remove(0);\n                     self.unpack_fn_args(args)?;\n-                    Ok((did, substs))\n+                    Ok((did, substs, Vec::new()))\n                 } else {\n                     bug!(\"VtableFnPointer did not contain a concrete function: {:?}\", vtable_fn_ptr)\n                 }\n@@ -504,7 +520,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     let fn_ptr = self.memory.read_ptr(vtable.offset(offset))?;\n                     let (def_id, substs, _abi, sig) = self.memory.get_fn(fn_ptr.alloc_id)?;\n                     *first_ty = sig.inputs[0];\n-                    Ok((def_id, substs))\n+                    Ok((def_id, substs, Vec::new()))\n                 } else {\n                     Err(EvalError::VtableForArgumentlessMethod)\n                 }"}]}