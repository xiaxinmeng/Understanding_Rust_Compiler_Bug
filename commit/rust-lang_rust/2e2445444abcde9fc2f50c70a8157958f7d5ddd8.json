{"sha": "2e2445444abcde9fc2f50c70a8157958f7d5ddd8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlMjQ0NTQ0NGFiY2RlOWZjMmY1MGM3MGE4MTU3OTU4ZjdkNWRkZDg=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-11-07T11:09:40Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-11-07T11:09:40Z"}, "message": "Merge #207\n\n207: Finish implementing char validation r=aochagavia a=aochagavia\n\nThe only thing missing right now are good integration tests (and maybe more descriptive error messages)\n\nCo-authored-by: Adolfo Ochagav\u00eda <github@adolfo.ochagavia.xyz>", "tree": {"sha": "8c667fc65a65c0e7978add07b72ec532a4b6eb7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c667fc65a65c0e7978add07b72ec532a4b6eb7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e2445444abcde9fc2f50c70a8157958f7d5ddd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e2445444abcde9fc2f50c70a8157958f7d5ddd8", "html_url": "https://github.com/rust-lang/rust/commit/2e2445444abcde9fc2f50c70a8157958f7d5ddd8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e2445444abcde9fc2f50c70a8157958f7d5ddd8/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "a46a07eca33f951b3d445e49dcbff3c53962a8e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/a46a07eca33f951b3d445e49dcbff3c53962a8e0", "html_url": "https://github.com/rust-lang/rust/commit/a46a07eca33f951b3d445e49dcbff3c53962a8e0"}, {"sha": "433a8061910a388f777b839eb67f2582f91b6c7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/433a8061910a388f777b839eb67f2582f91b6c7a", "html_url": "https://github.com/rust-lang/rust/commit/433a8061910a388f777b839eb67f2582f91b6c7a"}], "stats": {"total": 248, "additions": 235, "deletions": 13}, "files": [{"sha": "c1f773055735399ea60a07529371d84b2f9caaa1", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e2445444abcde9fc2f50c70a8157958f7d5ddd8/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2e2445444abcde9fc2f50c70a8157958f7d5ddd8/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=2e2445444abcde9fc2f50c70a8157958f7d5ddd8", "patch": "@@ -671,6 +671,7 @@ dependencies = [\n name = \"ra_syntax\"\n version = \"0.1.0\"\n dependencies = [\n+ \"arrayvec 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"drop_bomb 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itertools 0.7.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "54ee72386170656978c27808aa0cdb06250b06f2", "filename": "crates/ra_syntax/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e2445444abcde9fc2f50c70a8157958f7d5ddd8/crates%2Fra_syntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2e2445444abcde9fc2f50c70a8157958f7d5ddd8/crates%2Fra_syntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2FCargo.toml?ref=2e2445444abcde9fc2f50c70a8157958f7d5ddd8", "patch": "@@ -8,6 +8,7 @@ description = \"Comment and whitespace preserving parser for the Rust langauge\"\n repository = \"https://github.com/rust-analyzer/rust-analyzer\"\n \n [dependencies]\n+arrayvec = \"0.4.7\"\n unicode-xid = \"0.1.0\"\n itertools = \"0.7.8\"\n drop_bomb = \"0.1.4\""}, {"sha": "7e4df51aa892de900e00f31f35cd6836fcbe52d2", "filename": "crates/ra_syntax/src/lexer/ptr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2e2445444abcde9fc2f50c70a8157958f7d5ddd8/crates%2Fra_syntax%2Fsrc%2Flexer%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2445444abcde9fc2f50c70a8157958f7d5ddd8/crates%2Fra_syntax%2Fsrc%2Flexer%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flexer%2Fptr.rs?ref=2e2445444abcde9fc2f50c70a8157958f7d5ddd8", "patch": "@@ -30,8 +30,7 @@ impl<'s> Ptr<'s> {\n     /// Gets the nth character from the current.\n     /// For example, 0 will return the current token, 1 will return the next, etc.\n     pub fn nth(&self, n: u32) -> Option<char> {\n-        let mut chars = self.chars().peekable();\n-        chars.by_ref().nth(n as usize)\n+        self.chars().nth(n as usize)\n     }\n \n     /// Checks whether the current character is `c`."}, {"sha": "54012b7b62dc645d1e533c1bfdb27c965b948a7d", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e2445444abcde9fc2f50c70a8157958f7d5ddd8/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2445444abcde9fc2f50c70a8157958f7d5ddd8/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=2e2445444abcde9fc2f50c70a8157958f7d5ddd8", "patch": "@@ -20,6 +20,7 @@\n #![allow(missing_docs)]\n //#![warn(unreachable_pub)] // rust-lang/rust#47816\n \n+extern crate arrayvec;\n extern crate drop_bomb;\n extern crate itertools;\n extern crate parking_lot;"}, {"sha": "cc53e0abac701b937ea4cee3426a0b31dd151e4a", "filename": "crates/ra_syntax/src/string_lexing/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e2445444abcde9fc2f50c70a8157958f7d5ddd8/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2445444abcde9fc2f50c70a8157958f7d5ddd8/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fmod.rs?ref=2e2445444abcde9fc2f50c70a8157958f7d5ddd8", "patch": "@@ -219,7 +219,7 @@ mod tests {\n \n     #[test]\n     fn test_unicode_escapes() {\n-        let unicode_escapes = &[r\"{DEAD}\", \"{BEEF}\", \"{FF}\", \"\"];\n+        let unicode_escapes = &[r\"{DEAD}\", \"{BEEF}\", \"{FF}\", \"{}\", \"\"];\n         for escape in unicode_escapes {\n             let escape_sequence = format!(r\"'\\u{}'\", escape);\n             let component = closed_char_component(&escape_sequence);"}, {"sha": "cad9544bef9a6765571bb03fa7d03537275d7e2f", "filename": "crates/ra_syntax/src/utils.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e2445444abcde9fc2f50c70a8157958f7d5ddd8/crates%2Fra_syntax%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2445444abcde9fc2f50c70a8157958f7d5ddd8/crates%2Fra_syntax%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Futils.rs?ref=2e2445444abcde9fc2f50c70a8157958f7d5ddd8", "patch": "@@ -1,5 +1,6 @@\n use crate::{File, SyntaxKind, SyntaxNodeRef, WalkEvent};\n use std::fmt::Write;\n+use std::str;\n \n /// Parse a file and create a string representation of the resulting parse tree.\n pub fn dump_tree(syntax: SyntaxNodeRef) -> String {"}, {"sha": "f345dbd6e76474170e0f66d8eadacc1ea33e0ad5", "filename": "crates/ra_syntax/src/validation.rs", "status": "modified", "additions": 203, "deletions": 10, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/2e2445444abcde9fc2f50c70a8157958f7d5ddd8/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2445444abcde9fc2f50c70a8157958f7d5ddd8/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs?ref=2e2445444abcde9fc2f50c70a8157958f7d5ddd8", "patch": "@@ -1,3 +1,7 @@\n+use std::u32;\n+\n+use arrayvec::ArrayString;\n+\n use crate::{\n     algo::visit::{visitor_ctx, VisitorCtx},\n     ast::{self, AstNode},\n@@ -42,18 +46,90 @@ fn validate_char(node: ast::Char, errors: &mut Vec<SyntaxError>) {\n                 }\n             }\n             AsciiCodeEscape => {\n-                // TODO:\n-                // * First digit is octal\n-                // * Second digit is hex\n+                // An AsciiCodeEscape has 4 chars, example: `\\xDD`\n+                if text.len() < 4 {\n+                    errors.push(SyntaxError::new(TooShortAsciiCodeEscape, range));\n+                } else {\n+                    assert!(\n+                        text.chars().count() == 4,\n+                        \"AsciiCodeEscape cannot be longer than 4 chars\"\n+                    );\n+\n+                    match u8::from_str_radix(&text[2..], 16) {\n+                        Ok(code) if code < 128 => { /* Escape code is valid */ }\n+                        Ok(_) => errors.push(SyntaxError::new(AsciiCodeEscapeOutOfRange, range)),\n+                        Err(_) => errors.push(SyntaxError::new(MalformedAsciiCodeEscape, range)),\n+                    }\n+                }\n             }\n             UnicodeEscape => {\n-                // TODO:\n-                // * Only hex digits or underscores allowed\n-                // * Max 6 chars\n-                // * Within allowed range (must be at most 10FFFF)\n+                assert!(&text[..2] == \"\\\\u\", \"UnicodeEscape always starts with \\\\u\");\n+\n+                if text.len() == 2 {\n+                    // No starting `{`\n+                    errors.push(SyntaxError::new(MalformedUnicodeEscape, range));\n+                    return;\n+                }\n+\n+                if text.len() == 3 {\n+                    // Only starting `{`\n+                    errors.push(SyntaxError::new(UnclosedUnicodeEscape, range));\n+                    return;\n+                }\n+\n+                let mut code = ArrayString::<[_; 6]>::new();\n+                let mut closed = false;\n+                for c in text[3..].chars() {\n+                    assert!(!closed, \"no characters after escape is closed\");\n+\n+                    if c.is_digit(16) {\n+                        if code.len() == 6 {\n+                            errors.push(SyntaxError::new(OverlongUnicodeEscape, range));\n+                            return;\n+                        }\n+\n+                        code.push(c);\n+                    } else if c == '_' {\n+                        // Reject leading _\n+                        if code.len() == 0 {\n+                            errors.push(SyntaxError::new(MalformedUnicodeEscape, range));\n+                            return;\n+                        }\n+                    } else if c == '}' {\n+                        closed = true;\n+                    } else {\n+                        errors.push(SyntaxError::new(MalformedUnicodeEscape, range));\n+                        return;\n+                    }\n+                }\n+\n+                if !closed {\n+                    errors.push(SyntaxError::new(UnclosedUnicodeEscape, range))\n+                }\n+\n+                if code.len() == 0 {\n+                    errors.push(SyntaxError::new(EmptyUnicodeEcape, range));\n+                    return;\n+                }\n+\n+                match u32::from_str_radix(&code, 16) {\n+                    Ok(code_u32) if code_u32 > 0x10FFFF => {\n+                        errors.push(SyntaxError::new(UnicodeEscapeOutOfRange, range));\n+                    }\n+                    Ok(_) => {\n+                        // Valid escape code\n+                    }\n+                    Err(_) => {\n+                        errors.push(SyntaxError::new(MalformedUnicodeEscape, range));\n+                    }\n+                }\n+            }\n+            CodePoint => {\n+                // These code points must always be escaped\n+                if text == \"\\t\" || text == \"\\r\" {\n+                    errors.push(SyntaxError::new(UnescapedCodepoint, range));\n+                }\n             }\n-            // Code points are always valid\n-            CodePoint => (),\n         }\n     }\n \n@@ -72,7 +148,124 @@ fn validate_char(node: ast::Char, errors: &mut Vec<SyntaxError>) {\n \n fn is_ascii_escape(code: char) -> bool {\n     match code {\n-        '\\'' | '\"' | 'n' | 'r' | 't' | '0' => true,\n+        '\\\\' | '\\'' | '\"' | 'n' | 'r' | 't' | '0' => true,\n         _ => false,\n     }\n }\n+\n+#[cfg(test)]\n+mod test {\n+    use crate::File;\n+\n+    fn build_file(literal: &str) -> File {\n+        let src = format!(\"const C: char = '{}';\", literal);\n+        File::parse(&src)\n+    }\n+\n+    fn assert_valid_char(literal: &str) {\n+        let file = build_file(literal);\n+        assert!(\n+            file.errors().len() == 0,\n+            \"Errors for literal '{}': {:?}\",\n+            literal,\n+            file.errors()\n+        );\n+    }\n+\n+    fn assert_invalid_char(literal: &str) {\n+        let file = build_file(literal);\n+        assert!(file.errors().len() > 0);\n+    }\n+\n+    #[test]\n+    fn test_ansi_codepoints() {\n+        for byte in 0..=255u8 {\n+            match byte {\n+                b'\\n' | b'\\r' | b'\\t' => assert_invalid_char(&(byte as char).to_string()),\n+                b'\\'' | b'\\\\' => { /* Ignore character close and backslash */ }\n+                _ => assert_valid_char(&(byte as char).to_string()),\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_unicode_codepoints() {\n+        let valid = [\"\u0191\", \"\u30d0\", \"\u30e1\", \"\ufdfd\"];\n+        for c in &valid {\n+            assert_valid_char(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_unicode_multiple_codepoints() {\n+        let invalid = [\"\u0928\u0940\", \"\ud83d\udc68\u200d\ud83d\udc68\u200d\"];\n+        for c in &invalid {\n+            assert_invalid_char(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_valid_ascii_escape() {\n+        let valid = [\n+            r\"\\'\", \"\\\"\", \"\\\\\\\\\", \"\\\\\\\"\", r\"\\n\", r\"\\r\", r\"\\t\", r\"\\0\", \"a\", \"b\",\n+        ];\n+        for c in &valid {\n+            assert_valid_char(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_invalid_ascii_escape() {\n+        let invalid = [r\"\\a\", r\"\\?\", r\"\\\"];\n+        for c in &invalid {\n+            assert_invalid_char(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_valid_ascii_code_escape() {\n+        let valid = [r\"\\x00\", r\"\\x7F\", r\"\\x55\"];\n+        for c in &valid {\n+            assert_valid_char(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_invalid_ascii_code_escape() {\n+        let invalid = [r\"\\x\", r\"\\x7\", r\"\\xF0\"];\n+        for c in &invalid {\n+            assert_invalid_char(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_valid_unicode_escape() {\n+        let valid = [\n+            r\"\\u{FF}\",\n+            r\"\\u{0}\",\n+            r\"\\u{F}\",\n+            r\"\\u{10FFFF}\",\n+            r\"\\u{1_0__FF___FF_____}\",\n+        ];\n+        for c in &valid {\n+            assert_valid_char(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_invalid_unicode_escape() {\n+        let invalid = [\n+            r\"\\u\",\n+            r\"\\u{}\",\n+            r\"\\u{\",\n+            r\"\\u{FF\",\n+            r\"\\u{FFFFFF}\",\n+            r\"\\u{_F}\",\n+            r\"\\u{00FFFFF}\",\n+            r\"\\u{110000}\",\n+        ];\n+        for c in &invalid {\n+            assert_invalid_char(c);\n+        }\n+    }\n+}"}, {"sha": "c524adf3954b34951e79b8e13dfad4421e5e0ada", "filename": "crates/ra_syntax/src/yellow/syntax_error.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2e2445444abcde9fc2f50c70a8157958f7d5ddd8/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2445444abcde9fc2f50c70a8157958f7d5ddd8/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_error.rs?ref=2e2445444abcde9fc2f50c70a8157958f7d5ddd8", "patch": "@@ -34,6 +34,10 @@ impl SyntaxError {\n         }\n     }\n \n+    pub fn kind(&self) -> SyntaxErrorKind {\n+        self.kind.clone()\n+    }\n+\n     pub fn location(&self) -> Location {\n         self.location.clone()\n     }\n@@ -64,11 +68,20 @@ impl fmt::Display for SyntaxError {\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum SyntaxErrorKind {\n     ParseError(ParseError),\n+    UnescapedCodepoint,\n     EmptyChar,\n     UnclosedChar,\n     LongChar,\n     EmptyAsciiEscape,\n     InvalidAsciiEscape,\n+    TooShortAsciiCodeEscape,\n+    AsciiCodeEscapeOutOfRange,\n+    MalformedAsciiCodeEscape,\n+    UnclosedUnicodeEscape,\n+    MalformedUnicodeEscape,\n+    EmptyUnicodeEcape,\n+    OverlongUnicodeEscape,\n+    UnicodeEscapeOutOfRange,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -78,11 +91,24 @@ impl fmt::Display for SyntaxErrorKind {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         use self::SyntaxErrorKind::*;\n         match self {\n+            UnescapedCodepoint => write!(f, \"This codepoint should always be escaped\"),\n             EmptyAsciiEscape => write!(f, \"Empty escape sequence\"),\n             InvalidAsciiEscape => write!(f, \"Invalid escape sequence\"),\n             EmptyChar => write!(f, \"Empty char literal\"),\n             UnclosedChar => write!(f, \"Unclosed char literal\"),\n             LongChar => write!(f, \"Char literal should be one character long\"),\n+            TooShortAsciiCodeEscape => write!(f, \"Escape sequence should have two digits\"),\n+            AsciiCodeEscapeOutOfRange => {\n+                write!(f, \"Escape sequence should be between \\\\x00 and \\\\x7F\")\n+            }\n+            MalformedAsciiCodeEscape => write!(f, \"Escape sequence should be a hexadecimal number\"),\n+            UnclosedUnicodeEscape => write!(f, \"Missing `}}`\"),\n+            MalformedUnicodeEscape => write!(f, \"Malformed unicode escape sequence\"),\n+            EmptyUnicodeEcape => write!(f, \"Empty unicode escape sequence\"),\n+            OverlongUnicodeEscape => {\n+                write!(f, \"Unicode escape sequence should have at most 6 digits\")\n+            }\n+            UnicodeEscapeOutOfRange => write!(f, \"Unicode escape code should be at most 0x10FFFF\"),\n             ParseError(msg) => write!(f, \"{}\", msg.0),\n         }\n     }"}]}