{"sha": "6d36d1a835370a01cbee58aba038ea0bd712c82b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkMzZkMWE4MzUzNzBhMDFjYmVlNThhYmEwMzhlYTBiZDcxMmM4MmI=", "commit": {"author": {"name": "hamidreza kalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2021-07-29T12:08:17Z"}, "committer": {"name": "hamidreza kalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2021-08-08T21:45:10Z"}, "message": "merge XOR_SWAP with MANUAL_SWAP", "tree": {"sha": "a24834d33f14fc62ab83300853a8ae9a2519178e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a24834d33f14fc62ab83300853a8ae9a2519178e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d36d1a835370a01cbee58aba038ea0bd712c82b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d36d1a835370a01cbee58aba038ea0bd712c82b", "html_url": "https://github.com/rust-lang/rust/commit/6d36d1a835370a01cbee58aba038ea0bd712c82b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d36d1a835370a01cbee58aba038ea0bd712c82b/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbb10b87f8e4365298ed33a6ed96bffe66a1951e", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbb10b87f8e4365298ed33a6ed96bffe66a1951e", "html_url": "https://github.com/rust-lang/rust/commit/dbb10b87f8e4365298ed33a6ed96bffe66a1951e"}], "stats": {"total": 412, "additions": 175, "deletions": 237}, "files": [{"sha": "acbefc8064ddaece56e268883775df69ea0b341d", "filename": "CHANGELOG.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6d36d1a835370a01cbee58aba038ea0bd712c82b/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/6d36d1a835370a01cbee58aba038ea0bd712c82b/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=6d36d1a835370a01cbee58aba038ea0bd712c82b", "patch": "@@ -2900,7 +2900,6 @@ Released 2018-09-13\n [`wrong_pub_self_convention`]: https://rust-lang.github.io/rust-clippy/master/index.html#wrong_pub_self_convention\n [`wrong_self_convention`]: https://rust-lang.github.io/rust-clippy/master/index.html#wrong_self_convention\n [`wrong_transmute`]: https://rust-lang.github.io/rust-clippy/master/index.html#wrong_transmute\n-[`xor_swap`]: https://rust-lang.github.io/rust-clippy/master/index.html#xor_swap\n [`zero_divided_by_zero`]: https://rust-lang.github.io/rust-clippy/master/index.html#zero_divided_by_zero\n [`zero_prefixed_literal`]: https://rust-lang.github.io/rust-clippy/master/index.html#zero_prefixed_literal\n [`zero_ptr`]: https://rust-lang.github.io/rust-clippy/master/index.html#zero_ptr"}, {"sha": "f49b382c5ea3bd585936492f43c83e92838453ac", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6d36d1a835370a01cbee58aba038ea0bd712c82b/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d36d1a835370a01cbee58aba038ea0bd712c82b/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=6d36d1a835370a01cbee58aba038ea0bd712c82b", "patch": "@@ -922,7 +922,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL,\n         swap::ALMOST_SWAPPED,\n         swap::MANUAL_SWAP,\n-        swap::XOR_SWAP,\n         tabs_in_doc_comments::TABS_IN_DOC_COMMENTS,\n         temporary_assignment::TEMPORARY_ASSIGNMENT,\n         to_digit_is_some::TO_DIGIT_IS_SOME,\n@@ -1420,7 +1419,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL),\n         LintId::of(swap::ALMOST_SWAPPED),\n         LintId::of(swap::MANUAL_SWAP),\n-        LintId::of(swap::XOR_SWAP),\n         LintId::of(tabs_in_doc_comments::TABS_IN_DOC_COMMENTS),\n         LintId::of(temporary_assignment::TEMPORARY_ASSIGNMENT),\n         LintId::of(to_digit_is_some::TO_DIGIT_IS_SOME),\n@@ -1649,7 +1647,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(strings::STRING_FROM_UTF8_AS_BYTES),\n         LintId::of(strlen_on_c_strings::STRLEN_ON_C_STRINGS),\n         LintId::of(swap::MANUAL_SWAP),\n-        LintId::of(swap::XOR_SWAP),\n         LintId::of(temporary_assignment::TEMPORARY_ASSIGNMENT),\n         LintId::of(transmute::CROSSPOINTER_TRANSMUTE),\n         LintId::of(transmute::TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS),"}, {"sha": "f126908e84b037716fcca1dfca70d532c6734e4c", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 67, "deletions": 192, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/6d36d1a835370a01cbee58aba038ea0bd712c82b/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d36d1a835370a01cbee58aba038ea0bd712c82b/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=6d36d1a835370a01cbee58aba038ea0bd712c82b", "patch": "@@ -2,15 +2,15 @@ use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{differing_macro_contexts, eq_expr_value};\n+use clippy_utils::{can_mut_borrow_both, differing_macro_contexts, eq_expr_value};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Block, Expr, ExprKind, PatKind, QPath, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Spanned;\n-use rustc_span::sym;\n+use rustc_span::{sym, Span};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -65,37 +65,7 @@ declare_clippy_lint! {\n     \"`foo = bar; bar = foo` sequence\"\n }\n \n-declare_clippy_lint! {\n-    /// **What it does:** Checks for uses of xor-based swaps.\n-    ///\n-    /// **Why is this bad?** The `std::mem::swap` function exposes the intent better\n-    /// without deinitializing or copying either variable.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    ///\n-    /// ```rust\n-    /// let mut a = 1;\n-    /// let mut b = 2;\n-    ///\n-    /// a ^= b;\n-    /// b ^= a;\n-    /// a ^= b;\n-    /// ```\n-    ///\n-    /// Use std::mem::swap() instead:\n-    /// ```rust\n-    /// let mut a = 1;\n-    /// let mut b = 2;\n-    /// std::mem::swap(&mut a, &mut b);\n-    /// ```\n-    pub XOR_SWAP,\n-    complexity,\n-    \"xor-based swap of two variables\"\n-}\n-\n-declare_lint_pass!(Swap => [MANUAL_SWAP, ALMOST_SWAPPED, XOR_SWAP]);\n+declare_lint_pass!(Swap => [MANUAL_SWAP, ALMOST_SWAPPED]);\n \n impl<'tcx> LateLintPass<'tcx> for Swap {\n     fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx Block<'_>) {\n@@ -105,6 +75,63 @@ impl<'tcx> LateLintPass<'tcx> for Swap {\n     }\n }\n \n+fn generate_swap_warning(cx: &LateContext<'_>, e1: &Expr<'_>, e2: &Expr<'_>, span: Span, is_xor_based: bool) {\n+    let mut applicability = Applicability::MachineApplicable;\n+\n+    if !can_mut_borrow_both(cx, e1, e2) {\n+        if let ExprKind::Index(lhs1, idx1) = e1.kind {\n+            if let ExprKind::Index(lhs2, idx2) = e2.kind {\n+                if eq_expr_value(cx, lhs1, lhs2) {\n+                    let ty = cx.typeck_results().expr_ty(lhs1).peel_refs();\n+\n+                    if matches!(ty.kind(), ty::Slice(_))\n+                        || matches!(ty.kind(), ty::Array(_, _))\n+                        || is_type_diagnostic_item(cx, ty, sym::vec_type)\n+                        || is_type_diagnostic_item(cx, ty, sym::vecdeque_type)\n+                    {\n+                        let slice = Sugg::hir_with_applicability(cx, lhs1, \"<slice>\", &mut applicability);\n+                        span_lint_and_sugg(\n+                            cx,\n+                            MANUAL_SWAP,\n+                            span,\n+                            &format!(\"this looks like you are swapping elements of `{}` manually\", slice),\n+                            \"try\",\n+                            format!(\n+                                \"{}.swap({}, {})\",\n+                                slice.maybe_par(),\n+                                snippet_with_applicability(cx, idx1.span, \"..\", &mut applicability),\n+                                snippet_with_applicability(cx, idx2.span, \"..\", &mut applicability),\n+                            ),\n+                            applicability,\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+        return;\n+    }\n+\n+    let first = Sugg::hir_with_applicability(cx, e1, \"..\", &mut applicability);\n+    let second = Sugg::hir_with_applicability(cx, e2, \"..\", &mut applicability);\n+    span_lint_and_then(\n+        cx,\n+        MANUAL_SWAP,\n+        span,\n+        &format!(\"this looks like you are swapping `{}` and `{}` manually\", first, second),\n+        |diag| {\n+            diag.span_suggestion(\n+                span,\n+                \"try\",\n+                format!(\"std::mem::swap({}, {})\", first.mut_addr(), second.mut_addr()),\n+                applicability,\n+            );\n+            if !is_xor_based {\n+                diag.note(\"or maybe you should use `std::mem::replace`?\");\n+            }\n+        },\n+    );\n+}\n+\n /// Implementation of the `MANUAL_SWAP` lint.\n fn check_manual_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n     for w in block.stmts.windows(3) {\n@@ -128,123 +155,13 @@ fn check_manual_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n             if eq_expr_value(cx, tmp_init, lhs1);\n             if eq_expr_value(cx, rhs1, lhs2);\n             then {\n-                if let ExprKind::Field(lhs1, _) = lhs1.kind {\n-                    if let ExprKind::Field(lhs2, _) = lhs2.kind {\n-                        if lhs1.hir_id.owner == lhs2.hir_id.owner {\n-                            return;\n-                        }\n-                    }\n-                }\n-\n-                let mut applicability = Applicability::MachineApplicable;\n-\n-                let slice = check_for_slice(cx, lhs1, lhs2);\n-                let (replace, what, sugg) = if let Slice::NotSwappable = slice {\n-                    return;\n-                } else if let Slice::Swappable(slice, idx1, idx2) = slice {\n-                    if let Some(slice) = Sugg::hir_opt(cx, slice) {\n-                        (\n-                            false,\n-                            format!(\" elements of `{}`\", slice),\n-                            format!(\n-                                \"{}.swap({}, {})\",\n-                                slice.maybe_par(),\n-                                snippet_with_applicability(cx, idx1.span, \"..\", &mut applicability),\n-                                snippet_with_applicability(cx, idx2.span, \"..\", &mut applicability),\n-                            ),\n-                        )\n-                    } else {\n-                        (false, String::new(), String::new())\n-                    }\n-                } else if let (Some(first), Some(second)) = (Sugg::hir_opt(cx, lhs1), Sugg::hir_opt(cx, rhs1)) {\n-                    (\n-                        true,\n-                        format!(\" `{}` and `{}`\", first, second),\n-                        format!(\"std::mem::swap({}, {})\", first.mut_addr(), second.mut_addr()),\n-                    )\n-                } else {\n-                    (true, String::new(), String::new())\n-                };\n-\n                 let span = w[0].span.to(second.span);\n-\n-                span_lint_and_then(\n-                    cx,\n-                    MANUAL_SWAP,\n-                    span,\n-                    &format!(\"this looks like you are swapping{} manually\", what),\n-                    |diag| {\n-                        if !sugg.is_empty() {\n-                            diag.span_suggestion(\n-                                span,\n-                                \"try\",\n-                                sugg,\n-                                applicability,\n-                            );\n-\n-                            if replace {\n-                                diag.note(\"or maybe you should use `std::mem::replace`?\");\n-                            }\n-                        }\n-                    }\n-                );\n+                generate_swap_warning(cx, lhs1, lhs2, span, false);\n             }\n         }\n     }\n }\n \n-enum Slice<'a> {\n-    /// `slice.swap(idx1, idx2)` can be used\n-    ///\n-    /// ## Example\n-    ///\n-    /// ```rust\n-    /// # let mut a = vec![0, 1];\n-    /// let t = a[1];\n-    /// a[1] = a[0];\n-    /// a[0] = t;\n-    /// // can be written as\n-    /// a.swap(0, 1);\n-    /// ```\n-    Swappable(&'a Expr<'a>, &'a Expr<'a>, &'a Expr<'a>),\n-    /// The `swap` function cannot be used.\n-    ///\n-    /// ## Example\n-    ///\n-    /// ```rust\n-    /// # let mut a = [vec![1, 2], vec![3, 4]];\n-    /// let t = a[0][1];\n-    /// a[0][1] = a[1][0];\n-    /// a[1][0] = t;\n-    /// ```\n-    NotSwappable,\n-    /// Not a slice\n-    None,\n-}\n-\n-/// Checks if both expressions are index operations into \"slice-like\" types.\n-fn check_for_slice<'a>(cx: &LateContext<'_>, lhs1: &'a Expr<'_>, lhs2: &'a Expr<'_>) -> Slice<'a> {\n-    if let ExprKind::Index(lhs1, idx1) = lhs1.kind {\n-        if let ExprKind::Index(lhs2, idx2) = lhs2.kind {\n-            if eq_expr_value(cx, lhs1, lhs2) {\n-                let ty = cx.typeck_results().expr_ty(lhs1).peel_refs();\n-\n-                if matches!(ty.kind(), ty::Slice(_))\n-                    || matches!(ty.kind(), ty::Array(_, _))\n-                    || is_type_diagnostic_item(cx, ty, sym::vec_type)\n-                    || is_type_diagnostic_item(cx, ty, sym::vecdeque_type)\n-                {\n-                    return Slice::Swappable(lhs1, idx1, idx2);\n-                }\n-            } else {\n-                return Slice::NotSwappable;\n-            }\n-        }\n-    }\n-\n-    Slice::None\n-}\n-\n /// Implementation of the `ALMOST_SWAPPED` lint.\n fn check_suspicious_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n     for w in block.stmts.windows(2) {\n@@ -295,62 +212,20 @@ fn check_suspicious_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n     }\n }\n \n-/// Implementation of the `XOR_SWAP` lint.\n+/// Implementation of the xor case for `MANUAL_SWAP` lint.\n fn check_xor_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n     for window in block.stmts.windows(3) {\n         if_chain! {\n             if let Some((lhs0, rhs0)) = extract_sides_of_xor_assign(&window[0]);\n             if let Some((lhs1, rhs1)) = extract_sides_of_xor_assign(&window[1]);\n             if let Some((lhs2, rhs2)) = extract_sides_of_xor_assign(&window[2]);\n-            if eq_expr_value(cx, lhs0, rhs1)\n-               && eq_expr_value(cx, rhs1, lhs2)\n-               && eq_expr_value(cx, rhs0, lhs1)\n-               && eq_expr_value(cx, lhs1, rhs2);\n+            if eq_expr_value(cx, lhs0, rhs1);\n+            if eq_expr_value(cx, lhs2, rhs1);\n+            if eq_expr_value(cx, lhs1, rhs0);\n+            if eq_expr_value(cx, lhs1, rhs2);\n             then {\n                 let span = window[0].span.to(window[2].span);\n-                let mut applicability = Applicability::MachineApplicable;\n-                match check_for_slice(cx, lhs0, rhs0) {\n-                    Slice::Swappable(slice, idx0, idx1) => {\n-                        if let Some(slice) = Sugg::hir_opt(cx, slice) {\n-                            span_lint_and_sugg(\n-                                cx,\n-                                XOR_SWAP,\n-                                span,\n-                                &format!(\n-                                    \"this xor-based swap of the elements of `{}` can be \\\n-                                    more clearly expressed using `.swap`\",\n-                                    slice\n-                                ),\n-                                \"try\",\n-                                format!(\n-                                    \"{}.swap({}, {})\",\n-                                    slice.maybe_par(),\n-                                    snippet_with_applicability(cx, idx0.span, \"..\", &mut applicability),\n-                                    snippet_with_applicability(cx, idx1.span, \"..\", &mut applicability)\n-                                ),\n-                                applicability\n-                            )\n-                        }\n-                    }\n-                    Slice::None => {\n-                        if let (Some(first), Some(second)) = (Sugg::hir_opt(cx, lhs0), Sugg::hir_opt(cx, rhs0)) {\n-                            span_lint_and_sugg(\n-                                cx,\n-                                XOR_SWAP,\n-                                span,\n-                                &format!(\n-                                    \"this xor-based swap of `{}` and `{}` can be \\\n-                                    more clearly expressed using `std::mem::swap`\",\n-                                    first, second\n-                                ),\n-                                \"try\",\n-                                format!(\"std::mem::swap({}, {})\", first.mut_addr(), second.mut_addr()),\n-                                applicability,\n-                            );\n-                        }\n-                    }\n-                    Slice::NotSwappable => {}\n-                }\n+                generate_swap_warning(cx, lhs0, rhs0, span, true);\n             }\n         };\n     }"}, {"sha": "e930338270cb74c6620e52903ca0a71879a24e1b", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6d36d1a835370a01cbee58aba038ea0bd712c82b/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d36d1a835370a01cbee58aba038ea0bd712c82b/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=6d36d1a835370a01cbee58aba038ea0bd712c82b", "patch": "@@ -558,6 +558,54 @@ pub fn trait_ref_of_method<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Optio\n     None\n }\n \n+/// This method will return tuple of projection stack and root of the expression,\n+/// used in `can_mut_borrow_both`.\n+///\n+/// For example, if `e` represents the `v[0].a.b[x]`\n+/// this method will return a tuple, composed of a `Vec`\n+/// containing the `Expr`s for `v[0], v[0].a, v[0].a.b, v[0].a.b[x]`\n+/// and a `Expr` for root of them, `v`\n+fn projection_stack<'a, 'hir>(mut e: &'a Expr<'hir>) -> (Vec<&'a Expr<'hir>>, &'a Expr<'hir>) {\n+    let mut result = vec![];\n+    let root = loop {\n+        match e.kind {\n+            ExprKind::Index(ep, _) | ExprKind::Field(ep, _) => {\n+                result.push(e);\n+                e = ep;\n+            },\n+            _ => break e,\n+        };\n+    };\n+    result.reverse();\n+    (result, root)\n+}\n+\n+/// Checks if two expressions can be mutably borrowed simultaneously\n+/// and they aren't dependent on borrowing same thing twice\n+pub fn can_mut_borrow_both(cx: &LateContext<'_>, e1: &Expr<'_>, e2: &Expr<'_>) -> bool {\n+    let (s1, r1) = projection_stack(e1);\n+    let (s2, r2) = projection_stack(e2);\n+    if !eq_expr_value(cx, r1, r2) {\n+        return true;\n+    }\n+    for (x1, x2) in s1.iter().zip(s2.iter()) {\n+        match (&x1.kind, &x2.kind) {\n+            (ExprKind::Field(_, i1), ExprKind::Field(_, i2)) => {\n+                if i1 != i2 {\n+                    return true;\n+                }\n+            },\n+            (ExprKind::Index(_, i1), ExprKind::Index(_, i2)) => {\n+                if !eq_expr_value(cx, i1, i2) {\n+                    return false;\n+                }\n+            },\n+            _ => return false,\n+        }\n+    }\n+    false\n+}\n+\n /// Checks if the top level expression can be moved into a closure as is.\n pub fn can_move_expr_to_closure_no_visit(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, jump_targets: &[HirId]) -> bool {\n     match expr.kind {"}, {"sha": "ef518359ec5f373614727442c65526c05a5c1899", "filename": "tests/ui/swap.fixed", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6d36d1a835370a01cbee58aba038ea0bd712c82b/tests%2Fui%2Fswap.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6d36d1a835370a01cbee58aba038ea0bd712c82b/tests%2Fui%2Fswap.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fswap.fixed?ref=6d36d1a835370a01cbee58aba038ea0bd712c82b", "patch": "@@ -6,6 +6,7 @@\n     clippy::no_effect,\n     clippy::redundant_clone,\n     redundant_semicolons,\n+    dead_code,\n     unused_assignments\n )]\n \n@@ -20,9 +21,7 @@ struct Bar {\n fn field() {\n     let mut bar = Bar { a: 1, b: 2 };\n \n-    let temp = bar.a;\n-    bar.a = bar.b;\n-    bar.b = temp;\n+    std::mem::swap(&mut bar.a, &mut bar.b);\n \n     let mut baz = vec![bar.clone(), bar.clone()];\n     let temp = baz[0].a;\n@@ -51,6 +50,7 @@ fn unswappable_slice() {\n     foo[1][0] = temp;\n \n     // swap(foo[0][1], foo[1][0]) would fail\n+    // this could use split_at_mut and mem::swap, but that is not much simpler.\n }\n \n fn vec() {\n@@ -95,20 +95,19 @@ fn xor_unswappable_slice() {\n     foo[0][1] ^= foo[1][0];\n     foo[1][0] ^= foo[0][0];\n     foo[0][1] ^= foo[1][0];\n+\n+    // swap(foo[0][1], foo[1][0]) would fail\n+    // this could use split_at_mut and mem::swap, but that is not much simpler.\n+}\n+\n+fn distinct_slice() {\n+    let foo = &mut [vec![1, 2], vec![3, 4]];\n+    let bar = &mut [vec![1, 2], vec![3, 4]];\n+    std::mem::swap(&mut foo[0][1], &mut bar[1][0]);\n }\n \n #[rustfmt::skip]\n fn main() {\n-    field();\n-    array();\n-    slice();\n-    unswappable_slice();\n-    vec();\n-    xor_swap_locals();\n-    xor_field_swap();\n-    xor_slice_swap();\n-    xor_no_swap();\n-    xor_unswappable_slice();\n \n     let mut a = 42;\n     let mut b = 1337;"}, {"sha": "8518659ccf316dbbf41ce2e9941b3874c5878092", "filename": "tests/ui/swap.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6d36d1a835370a01cbee58aba038ea0bd712c82b/tests%2Fui%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d36d1a835370a01cbee58aba038ea0bd712c82b/tests%2Fui%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fswap.rs?ref=6d36d1a835370a01cbee58aba038ea0bd712c82b", "patch": "@@ -6,6 +6,7 @@\n     clippy::no_effect,\n     clippy::redundant_clone,\n     redundant_semicolons,\n+    dead_code,\n     unused_assignments\n )]\n \n@@ -55,6 +56,7 @@ fn unswappable_slice() {\n     foo[1][0] = temp;\n \n     // swap(foo[0][1], foo[1][0]) would fail\n+    // this could use split_at_mut and mem::swap, but that is not much simpler.\n }\n \n fn vec() {\n@@ -107,20 +109,21 @@ fn xor_unswappable_slice() {\n     foo[0][1] ^= foo[1][0];\n     foo[1][0] ^= foo[0][0];\n     foo[0][1] ^= foo[1][0];\n+\n+    // swap(foo[0][1], foo[1][0]) would fail\n+    // this could use split_at_mut and mem::swap, but that is not much simpler.\n+}\n+\n+fn distinct_slice() {\n+    let foo = &mut [vec![1, 2], vec![3, 4]];\n+    let bar = &mut [vec![1, 2], vec![3, 4]];\n+    let temp = foo[0][1];\n+    foo[0][1] = bar[1][0];\n+    bar[1][0] = temp;\n }\n \n #[rustfmt::skip]\n fn main() {\n-    field();\n-    array();\n-    slice();\n-    unswappable_slice();\n-    vec();\n-    xor_swap_locals();\n-    xor_field_swap();\n-    xor_slice_swap();\n-    xor_no_swap();\n-    xor_unswappable_slice();\n \n     let mut a = 42;\n     let mut b = 1337;"}, {"sha": "614d16ced40f1b5fd02cf899f86f5a0f38a9b6a5", "filename": "tests/ui/swap.stderr", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/6d36d1a835370a01cbee58aba038ea0bd712c82b/tests%2Fui%2Fswap.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d36d1a835370a01cbee58aba038ea0bd712c82b/tests%2Fui%2Fswap.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fswap.stderr?ref=6d36d1a835370a01cbee58aba038ea0bd712c82b", "patch": "@@ -1,57 +1,74 @@\n+error: this looks like you are swapping `bar.a` and `bar.b` manually\n+  --> $DIR/swap.rs:24:5\n+   |\n+LL | /     let temp = bar.a;\n+LL | |     bar.a = bar.b;\n+LL | |     bar.b = temp;\n+   | |________________^ help: try: `std::mem::swap(&mut bar.a, &mut bar.b)`\n+   |\n+   = note: `-D clippy::manual-swap` implied by `-D warnings`\n+   = note: or maybe you should use `std::mem::replace`?\n+\n error: this looks like you are swapping elements of `foo` manually\n-  --> $DIR/swap.rs:35:5\n+  --> $DIR/swap.rs:36:5\n    |\n LL | /     let temp = foo[0];\n LL | |     foo[0] = foo[1];\n LL | |     foo[1] = temp;\n    | |_________________^ help: try: `foo.swap(0, 1)`\n-   |\n-   = note: `-D clippy::manual-swap` implied by `-D warnings`\n \n error: this looks like you are swapping elements of `foo` manually\n-  --> $DIR/swap.rs:44:5\n+  --> $DIR/swap.rs:45:5\n    |\n LL | /     let temp = foo[0];\n LL | |     foo[0] = foo[1];\n LL | |     foo[1] = temp;\n    | |_________________^ help: try: `foo.swap(0, 1)`\n \n error: this looks like you are swapping elements of `foo` manually\n-  --> $DIR/swap.rs:62:5\n+  --> $DIR/swap.rs:64:5\n    |\n LL | /     let temp = foo[0];\n LL | |     foo[0] = foo[1];\n LL | |     foo[1] = temp;\n    | |_________________^ help: try: `foo.swap(0, 1)`\n \n-error: this xor-based swap of `a` and `b` can be more clearly expressed using `std::mem::swap`\n-  --> $DIR/swap.rs:73:5\n+error: this looks like you are swapping `a` and `b` manually\n+  --> $DIR/swap.rs:75:5\n    |\n LL | /     a ^= b;\n LL | |     b ^= a;\n LL | |     a ^= b;\n    | |___________^ help: try: `std::mem::swap(&mut a, &mut b)`\n-   |\n-   = note: `-D clippy::xor-swap` implied by `-D warnings`\n \n-error: this xor-based swap of `bar.a` and `bar.b` can be more clearly expressed using `std::mem::swap`\n-  --> $DIR/swap.rs:81:5\n+error: this looks like you are swapping `bar.a` and `bar.b` manually\n+  --> $DIR/swap.rs:83:5\n    |\n LL | /     bar.a ^= bar.b;\n LL | |     bar.b ^= bar.a;\n LL | |     bar.a ^= bar.b;\n    | |___________________^ help: try: `std::mem::swap(&mut bar.a, &mut bar.b)`\n \n-error: this xor-based swap of the elements of `foo` can be more clearly expressed using `.swap`\n-  --> $DIR/swap.rs:89:5\n+error: this looks like you are swapping elements of `foo` manually\n+  --> $DIR/swap.rs:91:5\n    |\n LL | /     foo[0] ^= foo[1];\n LL | |     foo[1] ^= foo[0];\n LL | |     foo[0] ^= foo[1];\n    | |_____________________^ help: try: `foo.swap(0, 1)`\n \n+error: this looks like you are swapping `foo[0][1]` and `bar[1][0]` manually\n+  --> $DIR/swap.rs:120:5\n+   |\n+LL | /     let temp = foo[0][1];\n+LL | |     foo[0][1] = bar[1][0];\n+LL | |     bar[1][0] = temp;\n+   | |____________________^ help: try: `std::mem::swap(&mut foo[0][1], &mut bar[1][0])`\n+   |\n+   = note: or maybe you should use `std::mem::replace`?\n+\n error: this looks like you are swapping `a` and `b` manually\n-  --> $DIR/swap.rs:131:7\n+  --> $DIR/swap.rs:134:7\n    |\n LL |       ; let t = a;\n    |  _______^\n@@ -62,7 +79,7 @@ LL | |     b = t;\n    = note: or maybe you should use `std::mem::replace`?\n \n error: this looks like you are swapping `c.0` and `a` manually\n-  --> $DIR/swap.rs:140:7\n+  --> $DIR/swap.rs:143:7\n    |\n LL |       ; let t = c.0;\n    |  _______^\n@@ -73,7 +90,7 @@ LL | |     a = t;\n    = note: or maybe you should use `std::mem::replace`?\n \n error: this looks like you are trying to swap `a` and `b`\n-  --> $DIR/swap.rs:128:5\n+  --> $DIR/swap.rs:131:5\n    |\n LL | /     a = b;\n LL | |     b = a;\n@@ -83,13 +100,13 @@ LL | |     b = a;\n    = note: or maybe you should use `std::mem::replace`?\n \n error: this looks like you are trying to swap `c.0` and `a`\n-  --> $DIR/swap.rs:137:5\n+  --> $DIR/swap.rs:140:5\n    |\n LL | /     c.0 = a;\n LL | |     a = c.0;\n    | |___________^ help: try: `std::mem::swap(&mut c.0, &mut a)`\n    |\n    = note: or maybe you should use `std::mem::replace`?\n \n-error: aborting due to 10 previous errors\n+error: aborting due to 12 previous errors\n "}]}