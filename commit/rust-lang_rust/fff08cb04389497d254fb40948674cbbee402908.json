{"sha": "fff08cb04389497d254fb40948674cbbee402908", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmZjA4Y2IwNDM4OTQ5N2QyNTRmYjQwOTQ4Njc0Y2JiZWU0MDI5MDg=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-06-11T21:11:55Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-06-12T10:38:28Z"}, "message": "Run `rustfmt --file-lines ...` for changes from previous commits.", "tree": {"sha": "acf887abc09ef60cbd7e18e733da83c50a4f3939", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/acf887abc09ef60cbd7e18e733da83c50a4f3939"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fff08cb04389497d254fb40948674cbbee402908", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fff08cb04389497d254fb40948674cbbee402908", "html_url": "https://github.com/rust-lang/rust/commit/fff08cb04389497d254fb40948674cbbee402908", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fff08cb04389497d254fb40948674cbbee402908/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21ac960334485bfad6818510bc12dc65129f2c39", "url": "https://api.github.com/repos/rust-lang/rust/commits/21ac960334485bfad6818510bc12dc65129f2c39", "html_url": "https://github.com/rust-lang/rust/commit/21ac960334485bfad6818510bc12dc65129f2c39"}], "stats": {"total": 4344, "additions": 2212, "deletions": 2132}, "files": [{"sha": "a2e7ebfdb0e4b270c190e6190e46941d13fd2d61", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -30,8 +30,7 @@ struct LoopScope {\n     break_index: CFGIndex,    // where to go on a `break`\n }\n \n-pub fn construct<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                           body: &hir::Body) -> CFG {\n+pub fn construct<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, body: &hir::Body) -> CFG {\n     let mut graph = graph::Graph::new();\n     let entry = graph.add_node(CFGNodeData::Entry);\n "}, {"sha": "d25d58bfd1fa65a3769ce3977b26b961304e0492", "filename": "src/librustc/cfg/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fmod.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -49,8 +49,7 @@ pub type CFGNode = graph::Node<CFGNodeData>;\n pub type CFGEdge = graph::Edge<CFGEdgeData>;\n \n impl CFG {\n-    pub fn new<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                         body: &hir::Body) -> CFG {\n+    pub fn new<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, body: &hir::Body) -> CFG {\n         construct::construct(tcx, body)\n     }\n "}, {"sha": "82bba96dd4cc77ce5c9b72eacf94d09a4a13d253", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -480,7 +480,8 @@ trait DepNodeParams<'gcx: 'tcx, 'tcx>: fmt::Debug {\n }\n \n impl<'gcx: 'tcx, 'tcx, T> DepNodeParams<'gcx, 'tcx> for T\n-    where T: HashStable<StableHashingContext<'tcx>> + fmt::Debug\n+where\n+    T: HashStable<StableHashingContext<'tcx>> + fmt::Debug,\n {\n     default const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n "}, {"sha": "40ccd6e7b280a8f6c8d063da423eb2027a45bf46", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -90,7 +90,6 @@ where\n }\n \n impl DepGraph {\n-\n     pub fn new(prev_graph: PreviousDepGraph,\n                prev_work_products: FxHashMap<WorkProductId, WorkProduct>) -> DepGraph {\n         let prev_graph_node_count = prev_graph.node_count();\n@@ -559,7 +558,7 @@ impl DepGraph {\n     pub fn try_mark_green_and_read(\n         &self,\n         tcx: TyCtxt<'_, '_>,\n-        dep_node: &DepNode\n+        dep_node: &DepNode,\n     ) -> Option<(SerializedDepNodeIndex, DepNodeIndex)> {\n         self.try_mark_green(tcx, dep_node).map(|(prev_index, dep_node_index)| {\n             debug_assert!(self.is_green(&dep_node));\n@@ -571,7 +570,7 @@ impl DepGraph {\n     pub fn try_mark_green(\n         &self,\n         tcx: TyCtxt<'_, '_>,\n-        dep_node: &DepNode\n+        dep_node: &DepNode,\n     ) -> Option<(SerializedDepNodeIndex, DepNodeIndex)> {\n         debug_assert!(!dep_node.kind.is_eval_always());\n \n@@ -607,7 +606,7 @@ impl DepGraph {\n         tcx: TyCtxt<'tcx, 'tcx>,\n         data: &DepGraphData,\n         prev_dep_node_index: SerializedDepNodeIndex,\n-        dep_node: &DepNode\n+        dep_node: &DepNode,\n     ) -> Option<DepNodeIndex> {\n         debug!(\"try_mark_previous_green({:?}) - BEGIN\", dep_node);\n "}, {"sha": "62667c957cdc0c2f62aa9e5d4646bbacdba63c8b", "filename": "src/librustc/dep_graph/safe.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fdep_graph%2Fsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fdep_graph%2Fsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fsafe.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -33,8 +33,7 @@ impl DepGraphSafe for DefId {\n \n /// The type context itself can be used to access all kinds of tracked\n /// state, but those accesses should always generate read events.\n-impl<'gcx, 'tcx> DepGraphSafe for TyCtxt<'gcx, 'tcx> {\n-}\n+impl<'gcx, 'tcx> DepGraphSafe for TyCtxt<'gcx, 'tcx> {}\n \n /// Tuples make it easy to build up state.\n impl<A, B> DepGraphSafe for (A, B)"}, {"sha": "d1310771fb353520b75e30a94e6b0edbf41b54df", "filename": "src/librustc/infer/canonical/substitute.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -14,11 +14,7 @@ use crate::ty::{self, TyCtxt};\n impl<'tcx, V> Canonical<'tcx, V> {\n     /// Instantiate the wrapped value, replacing each canonical value\n     /// with the value given in `var_values`.\n-    pub fn substitute(\n-        &self,\n-        tcx: TyCtxt<'_, 'tcx>,\n-        var_values: &CanonicalVarValues<'tcx>,\n-    ) -> V\n+    pub fn substitute(&self, tcx: TyCtxt<'_, 'tcx>, var_values: &CanonicalVarValues<'tcx>) -> V\n     where\n         V: TypeFoldable<'tcx>,\n     {"}, {"sha": "d886efd33915f9a9ee5770ca8012246d8a4a8d11", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -58,12 +58,14 @@ pub enum RelationDir {\n }\n \n impl<'infcx, 'gcx, 'tcx> InferCtxt<'infcx, 'gcx, 'tcx> {\n-    pub fn super_combine_tys<R>(&self,\n-                                relation: &mut R,\n-                                a: Ty<'tcx>,\n-                                b: Ty<'tcx>)\n-                                -> RelateResult<'tcx, Ty<'tcx>>\n-        where R: TypeRelation<'gcx, 'tcx>\n+    pub fn super_combine_tys<R>(\n+        &self,\n+        relation: &mut R,\n+        a: Ty<'tcx>,\n+        b: Ty<'tcx>,\n+    ) -> RelateResult<'tcx, Ty<'tcx>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n     {\n         let a_is_expected = relation.a_is_expected();\n "}, {"sha": "8631236c0e36e8c2f1aa3fd00c4c3188233a640d", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -338,7 +338,10 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n         }\n \n         impl<'gcx, 'tcx, T> fmt::Display for Highlighted<'gcx, 'tcx, T>\n-            where T: for<'a, 'b, 'c> Print<'gcx, 'tcx,\n+        where\n+            T: for<'a, 'b, 'c> Print<\n+                'gcx,\n+                'tcx,\n                 FmtPrinter<'a, 'gcx, 'tcx, &'b mut fmt::Formatter<'c>>,\n                 Error = fmt::Error,\n             >,"}, {"sha": "236ebc19340bb37a5c84213278a3014ace82cc03", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -27,7 +27,7 @@ use crate::ty::TyVar;\n use crate::ty::{self, Ty};\n use crate::ty::relate::{RelateResult, TypeRelation};\n \n-pub trait LatticeDir<'f, 'gcx: 'f+'tcx, 'tcx: 'f> : TypeRelation<'gcx, 'tcx> {\n+pub trait LatticeDir<'f, 'gcx: 'f + 'tcx, 'tcx: 'f>: TypeRelation<'gcx, 'tcx> {\n     fn infcx(&self) -> &'f InferCtxt<'f, 'gcx, 'tcx>;\n \n     fn cause(&self) -> &ObligationCause<'tcx>;"}, {"sha": "c2ae561fcd39fd6f074c70f76442ddac5c51dded", "filename": "src/librustc/infer/outlives/free_region_map.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -28,11 +28,12 @@ impl<'tcx> FreeRegionMap<'tcx> {\n     /// cases, this is more conservative than necessary, in order to\n     /// avoid making arbitrary choices. See\n     /// `TransitiveRelation::postdom_upper_bound` for more details.\n-    pub fn lub_free_regions<'gcx>(&self,\n-                                      tcx: TyCtxt<'gcx, 'tcx>,\n-                                      r_a: Region<'tcx>,\n-                                      r_b: Region<'tcx>)\n-                                      -> Region<'tcx> {\n+    pub fn lub_free_regions<'gcx>(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        r_a: Region<'tcx>,\n+        r_b: Region<'tcx>,\n+    ) -> Region<'tcx> {\n         debug!(\"lub_free_regions(r_a={:?}, r_b={:?})\", r_a, r_b);\n         assert!(is_free(r_a));\n         assert!(is_free(r_b));"}, {"sha": "c6a77a314be6ae067db1c0fa1e5368145b83b55c", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -1423,10 +1423,7 @@ pub fn late_lint_mod<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n     }\n }\n \n-fn late_lint_pass_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    pass: T\n-) {\n+fn late_lint_pass_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tcx, 'tcx>, pass: T) {\n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n \n     let krate = tcx.hir().krate();\n@@ -1461,7 +1458,7 @@ fn late_lint_pass_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n \n fn late_lint_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n     tcx: TyCtxt<'tcx, 'tcx>,\n-    builtin_lints: T\n+    builtin_lints: T,\n ) {\n     let mut passes = tcx.sess.lint_store.borrow().late_passes.lock().take().unwrap();\n "}, {"sha": "5a17eee173d5ab1c5b922ea69ce86df7e2ddddaa", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -766,9 +766,7 @@ pub fn maybe_lint_level_root(tcx: TyCtxt<'_, '_>, id: hir::HirId) -> bool {\n     attrs.iter().any(|attr| Level::from_symbol(attr.name_or_empty()).is_some())\n }\n \n-fn lint_levels<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, cnum: CrateNum)\n-    -> &'tcx LintLevelMap\n-{\n+fn lint_levels<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, cnum: CrateNum) -> &'tcx LintLevelMap {\n     assert_eq!(cnum, LOCAL_CRATE);\n     let mut builder = LintLevelMapBuilder {\n         levels: LintLevelSets::builder(tcx.sess),"}, {"sha": "f258f06b87dccecd1d01ad6f4b66263cac4c24e2", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -211,9 +211,7 @@ pub trait CrateStore {\n     fn crates_untracked(&self) -> Vec<CrateNum>;\n \n     // utility functions\n-    fn encode_metadata<'tcx>(&self,\n-                                 tcx: TyCtxt<'tcx, 'tcx>)\n-                                 -> EncodedMetadata;\n+    fn encode_metadata<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>) -> EncodedMetadata;\n     fn metadata_encoding_version(&self) -> &[u8];\n }\n \n@@ -228,9 +226,7 @@ pub type CrateStoreDyn = dyn CrateStore + sync::Sync;\n // In order to get this left-to-right dependency ordering, we perform a\n // topological sort of all crates putting the leaves at the right-most\n // positions.\n-pub fn used_crates(tcx: TyCtxt<'_, '_>, prefer: LinkagePreference)\n-    -> Vec<(CrateNum, LibSource)>\n-{\n+pub fn used_crates(tcx: TyCtxt<'_, '_>, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)> {\n     let mut libs = tcx.crates()\n         .iter()\n         .cloned()"}, {"sha": "18e19e802e889da4d40f4276d4716e2e89fb516c", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -26,8 +26,7 @@ use syntax_pos;\n // explored. For example, if it's a live Node::Item that is a\n // function, then we should explore its block to check for codes that\n // may need to be marked as live.\n-fn should_explore<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                            hir_id: hir::HirId) -> bool {\n+fn should_explore<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, hir_id: hir::HirId) -> bool {\n     match tcx.hir().find_by_hir_id(hir_id) {\n         Some(Node::Item(..)) |\n         Some(Node::ImplItem(..)) |\n@@ -302,9 +301,11 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     }\n }\n \n-fn has_allow_dead_code_or_lang_attr(tcx: TyCtxt<'_, '_>,\n-                                    id: hir::HirId,\n-                                    attrs: &[ast::Attribute]) -> bool {\n+fn has_allow_dead_code_or_lang_attr(\n+    tcx: TyCtxt<'_, '_>,\n+    id: hir::HirId,\n+    attrs: &[ast::Attribute],\n+) -> bool {\n     if attr::contains_name(attrs, sym::lang) {\n         return true;\n     }\n@@ -451,10 +452,11 @@ fn create_and_seed_worklist<'tcx>(\n     (life_seeder.worklist, life_seeder.struct_constructors)\n }\n \n-fn find_live<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                       access_levels: &privacy::AccessLevels,\n-                       krate: &hir::Crate)\n-                       -> FxHashSet<hir::HirId> {\n+fn find_live<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    access_levels: &privacy::AccessLevels,\n+    krate: &hir::Crate,\n+) -> FxHashSet<hir::HirId> {\n     let (worklist, struct_constructors) = create_and_seed_worklist(tcx, access_levels, krate);\n     let mut symbol_visitor = MarkSymbolVisitor {\n         worklist,"}, {"sha": "2f6a3f2f02721e8ba0563060dbbbcd526a07d995", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -92,9 +92,7 @@ pub fn calculate<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n     sess.dependency_formats.set(fmts);\n }\n \n-fn calculate_type<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                            ty: config::CrateType) -> DependencyList {\n-\n+fn calculate_type<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, ty: config::CrateType) -> DependencyList {\n     let sess = &tcx.sess;\n \n     if !sess.opts.output_types.should_codegen() {\n@@ -242,10 +240,12 @@ fn calculate_type<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n     ret\n }\n \n-fn add_library(tcx: TyCtxt<'_, '_>,\n-               cnum: CrateNum,\n-               link: LinkagePreference,\n-               m: &mut FxHashMap<CrateNum, LinkagePreference>) {\n+fn add_library(\n+    tcx: TyCtxt<'_, '_>,\n+    cnum: CrateNum,\n+    link: LinkagePreference,\n+    m: &mut FxHashMap<CrateNum, LinkagePreference>,\n+) {\n     match m.get(&cnum) {\n         Some(&link2) => {\n             // If the linkages differ, then we'd have two copies of the library"}, {"sha": "9e7af280408bd0bba77ef8306693e1a0f5911d62", "filename": "src/librustc/middle/exported_symbols.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -38,9 +38,7 @@ pub enum ExportedSymbol<'tcx> {\n }\n \n impl<'tcx> ExportedSymbol<'tcx> {\n-    pub fn symbol_name(&self,\n-                       tcx: TyCtxt<'tcx, '_>)\n-                       -> ty::SymbolName {\n+    pub fn symbol_name(&self, tcx: TyCtxt<'tcx, '_>) -> ty::SymbolName {\n         match *self {\n             ExportedSymbol::NonGeneric(def_id) => {\n                 tcx.symbol_name(ty::Instance::mono(tcx, def_id))\n@@ -54,10 +52,11 @@ impl<'tcx> ExportedSymbol<'tcx> {\n         }\n     }\n \n-    pub fn compare_stable(&self,\n-                          tcx: TyCtxt<'tcx, '_>,\n-                          other: &ExportedSymbol<'tcx>)\n-                          -> cmp::Ordering {\n+    pub fn compare_stable(\n+        &self,\n+        tcx: TyCtxt<'tcx, '_>,\n+        other: &ExportedSymbol<'tcx>,\n+    ) -> cmp::Ordering {\n         match *self {\n             ExportedSymbol::NonGeneric(self_def_id) => match *other {\n                 ExportedSymbol::NonGeneric(other_def_id) => {"}, {"sha": "3ed926d758264fbda39cd201deb0ebd06a85d638", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -266,15 +266,15 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx, 'tcx> {\n     ///   `None` means that rvalues will be given more conservative lifetimes.\n     ///\n     /// See also `with_infer`, which is used *during* typeck.\n-    pub fn new(delegate: &'a mut (dyn Delegate<'tcx>+'a),\n-               tcx: TyCtxt<'tcx, 'tcx>,\n-               body_owner: DefId,\n-               param_env: ty::ParamEnv<'tcx>,\n-               region_scope_tree: &'a region::ScopeTree,\n-               tables: &'a ty::TypeckTables<'tcx>,\n-               rvalue_promotable_map: Option<&'tcx ItemLocalSet>)\n-               -> Self\n-    {\n+    pub fn new(\n+        delegate: &'a mut (dyn Delegate<'tcx> + 'a),\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        body_owner: DefId,\n+        param_env: ty::ParamEnv<'tcx>,\n+        region_scope_tree: &'a region::ScopeTree,\n+        tables: &'a ty::TypeckTables<'tcx>,\n+        rvalue_promotable_map: Option<&'tcx ItemLocalSet>,\n+    ) -> Self {\n         ExprUseVisitor {\n             mc: mc::MemCategorizationContext::new(tcx,\n                                                   body_owner,"}, {"sha": "d3ed818c4be4568f575349acd0acea1280e6299b", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -25,7 +25,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n }\n \n struct ItemVisitor<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>\n+    tcx: TyCtxt<'tcx, 'tcx>,\n }\n \n struct ExprVisitor<'tcx> {\n@@ -36,9 +36,7 @@ struct ExprVisitor<'tcx> {\n \n /// If the type is `Option<T>`, it will return `T`, otherwise\n /// the type itself. Works on most `Option`-like types.\n-fn unpack_option_like<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                ty: Ty<'tcx>)\n-                                -> Ty<'tcx> {\n+fn unpack_option_like<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     let (def, substs) = match ty.sty {\n         ty::Adt(def, substs) => (def, substs),\n         _ => return ty"}, {"sha": "92cb407f67d7c47d6f0c45eeabb888bf5b44f723", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -352,12 +352,14 @@ impl IrMaps<'tcx> {\n     }\n }\n \n-fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'tcx>,\n-                          fk: FnKind<'tcx>,\n-                          decl: &'tcx hir::FnDecl,\n-                          body_id: hir::BodyId,\n-                          sp: Span,\n-                          id: hir::HirId) {\n+fn visit_fn<'a, 'tcx: 'a>(\n+    ir: &mut IrMaps<'tcx>,\n+    fk: FnKind<'tcx>,\n+    decl: &'tcx hir::FnDecl,\n+    body_id: hir::BodyId,\n+    sp: Span,\n+    id: hir::HirId,\n+) {\n     debug!(\"visit_fn\");\n \n     // swap in a new set of IR maps for this function body:"}, {"sha": "4b5b901f4703e2750aeec4948d24841d862d01f4", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -287,7 +287,7 @@ impl HirNode for hir::Pat {\n }\n \n #[derive(Clone)]\n-pub struct MemCategorizationContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+pub struct MemCategorizationContext<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     pub tcx: TyCtxt<'gcx, 'tcx>,\n     pub body_owner: DefId,\n     pub upvars: Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>>,\n@@ -339,8 +339,11 @@ impl MutabilityCategory {\n         ret\n     }\n \n-    fn from_local(tcx: TyCtxt<'_, '_>, tables: &ty::TypeckTables<'_>,\n-                  id: ast::NodeId) -> MutabilityCategory {\n+    fn from_local(\n+        tcx: TyCtxt<'_, '_>,\n+        tables: &ty::TypeckTables<'_>,\n+        id: ast::NodeId,\n+    ) -> MutabilityCategory {\n         let ret = match tcx.hir().get(id) {\n             Node::Binding(p) => match p.node {\n                 PatKind::Binding(..) => {\n@@ -400,12 +403,13 @@ impl MutabilityCategory {\n }\n \n impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'tcx, 'tcx>,\n-               body_owner: DefId,\n-               region_scope_tree: &'a region::ScopeTree,\n-               tables: &'a ty::TypeckTables<'tcx>,\n-               rvalue_promotable_map: Option<&'tcx ItemLocalSet>)\n-               -> MemCategorizationContext<'a, 'tcx, 'tcx> {\n+    pub fn new(\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        body_owner: DefId,\n+        region_scope_tree: &'a region::ScopeTree,\n+        tables: &'a ty::TypeckTables<'tcx>,\n+        rvalue_promotable_map: Option<&'tcx ItemLocalSet>,\n+    ) -> MemCategorizationContext<'a, 'tcx, 'tcx> {\n         MemCategorizationContext {\n             tcx,\n             body_owner,"}, {"sha": "b0068a191da4ca8e592c0aecf436cae7a2309b40", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -27,9 +27,7 @@ use crate::hir::intravisit;\n // Returns true if the given item must be inlined because it may be\n // monomorphized or it was marked with `#[inline]`. This will only return\n // true for functions.\n-fn item_might_be_inlined(tcx: TyCtxt<'tcx, 'tcx>,\n-                         item: &hir::Item,\n-                         attrs: CodegenFnAttrs) -> bool {\n+fn item_might_be_inlined(tcx: TyCtxt<'tcx, 'tcx>, item: &hir::Item, attrs: CodegenFnAttrs) -> bool {\n     if attrs.requests_inline() {\n         return true\n     }\n@@ -44,9 +42,11 @@ fn item_might_be_inlined(tcx: TyCtxt<'tcx, 'tcx>,\n     }\n }\n \n-fn method_might_be_inlined<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                     impl_item: &hir::ImplItem,\n-                                     impl_src: DefId) -> bool {\n+fn method_might_be_inlined<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    impl_item: &hir::ImplItem,\n+    impl_src: DefId,\n+) -> bool {\n     let codegen_fn_attrs = tcx.codegen_fn_attrs(impl_item.hir_id.owner_def_id());\n     let generics = tcx.generics_of(tcx.hir().local_def_id_from_hir_id(impl_item.hir_id));\n     if codegen_fn_attrs.requests_inline() || generics.requires_monomorphization(tcx) {"}, {"sha": "5968933721de6c3963cfd723734fa9d771237336", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -646,9 +646,11 @@ impl<'tcx> ScopeTree {\n \n     /// Assuming that the provided region was defined within this `ScopeTree`,\n     /// returns the outermost `Scope` that the region outlives.\n-    pub fn early_free_scope<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>,\n-                                      br: &ty::EarlyBoundRegion)\n-                                      -> Scope {\n+    pub fn early_free_scope<'gcx>(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        br: &ty::EarlyBoundRegion,\n+    ) -> Scope {\n         let param_owner = tcx.parent(br.def_id).unwrap();\n \n         let param_owner_id = tcx.hir().as_local_hir_id(param_owner).unwrap();\n@@ -677,8 +679,7 @@ impl<'tcx> ScopeTree {\n \n     /// Assuming that the provided region was defined within this `ScopeTree`,\n     /// returns the outermost `Scope` that the region outlives.\n-    pub fn free_scope<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>, fr: &ty::FreeRegion)\n-                                 -> Scope {\n+    pub fn free_scope<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>, fr: &ty::FreeRegion) -> Scope {\n         let param_owner = match fr.bound_region {\n             ty::BoundRegion::BrNamed(def_id, _) => {\n                 tcx.parent(def_id).unwrap()\n@@ -734,9 +735,11 @@ impl<'tcx> ScopeTree {\n }\n \n /// Records the lifetime of a local variable as `cx.var_parent`\n-fn record_var_lifetime(visitor: &mut RegionResolutionVisitor<'_>,\n-                       var_id: hir::ItemLocalId,\n-                       _sp: Span) {\n+fn record_var_lifetime(\n+    visitor: &mut RegionResolutionVisitor<'_>,\n+    var_id: hir::ItemLocalId,\n+    _sp: Span,\n+) {\n     match visitor.cx.var_parent {\n         None => {\n             // this can happen in extern fn declarations like\n@@ -977,9 +980,11 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n     visitor.cx = prev_cx;\n }\n \n-fn resolve_local<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>,\n-                           pat: Option<&'tcx hir::Pat>,\n-                           init: Option<&'tcx hir::Expr>) {\n+fn resolve_local<'tcx>(\n+    visitor: &mut RegionResolutionVisitor<'tcx>,\n+    pat: Option<&'tcx hir::Pat>,\n+    init: Option<&'tcx hir::Expr>,\n+) {\n     debug!(\"resolve_local(pat={:?}, init={:?})\", pat, init);\n \n     let blk_scope = visitor.cx.var_parent.map(|(p, _)| p);\n@@ -1130,8 +1135,8 @@ fn resolve_local<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>,\n     fn record_rvalue_scope_if_borrow_expr<'tcx>(\n         visitor: &mut RegionResolutionVisitor<'tcx>,\n         expr: &hir::Expr,\n-        blk_id: Option<Scope>)\n-    {\n+        blk_id: Option<Scope>,\n+    ) {\n         match expr.node {\n             hir::ExprKind::AddrOf(_, ref subexpr) => {\n                 record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id);\n@@ -1178,9 +1183,11 @@ fn resolve_local<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>,\n     ///        | <rvalue>\n     ///\n     /// Note: ET is intended to match \"rvalues or places based on rvalues\".\n-    fn record_rvalue_scope<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>,\n-                                     expr: &hir::Expr,\n-                                     blk_scope: Option<Scope>) {\n+    fn record_rvalue_scope<'tcx>(\n+        visitor: &mut RegionResolutionVisitor<'tcx>,\n+        expr: &hir::Expr,\n+        blk_scope: Option<Scope>,\n+    ) {\n         let mut expr = expr;\n         loop {\n             // Note: give all the expressions matching `ET` with the\n@@ -1327,9 +1334,7 @@ impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n     }\n }\n \n-fn region_scope_tree<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId)\n-    -> &'tcx ScopeTree\n-{\n+fn region_scope_tree<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> &'tcx ScopeTree {\n     let closure_base_def_id = tcx.closure_base_def_id(def_id);\n     if closure_base_def_id != def_id {\n         return tcx.region_scope_tree(closure_base_def_id);"}, {"sha": "edd5cb4541a96fcb7126f8d8cdc4f5297de05640", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -368,10 +368,7 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n /// entire crate. You should not read the result of this query\n /// directly, but rather use `named_region_map`, `is_late_bound_map`,\n /// etc.\n-fn resolve_lifetimes<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    for_krate: CrateNum,\n-) -> &'tcx ResolveLifetimes {\n+fn resolve_lifetimes<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, for_krate: CrateNum) -> &'tcx ResolveLifetimes {\n     assert_eq!(for_krate, LOCAL_CRATE);\n \n     let named_region_map = krate(tcx);\n@@ -1256,9 +1253,7 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n     }\n }\n \n-fn compute_object_lifetime_defaults(\n-    tcx: TyCtxt<'_, '_>,\n-) -> HirIdMap<Vec<ObjectLifetimeDefault>> {\n+fn compute_object_lifetime_defaults(tcx: TyCtxt<'_, '_>) -> HirIdMap<Vec<ObjectLifetimeDefault>> {\n     let mut map = HirIdMap::default();\n     for item in tcx.hir().krate().items.values() {\n         match item.node {"}, {"sha": "dbd008256b0241848ad26cb2b7c173b0978635a4", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -452,7 +452,7 @@ impl<'tcx> Index<'tcx> {\n                                AnnotationKind::Required,\n                                |v| intravisit::walk_crate(v, krate));\n         }\n-        return index\n+        return index;\n     }\n \n     pub fn local_stability(&self, id: HirId) -> Option<&'tcx Stability> {\n@@ -924,7 +924,7 @@ fn unnecessary_stable_feature_lint<'tcx>(\n     tcx: TyCtxt<'tcx, 'tcx>,\n     span: Span,\n     feature: Symbol,\n-    since: Symbol\n+    since: Symbol,\n ) {\n     tcx.lint_hir(lint::builtin::STABLE_FEATURES,\n         hir::CRATE_HIR_ID,"}, {"sha": "009cab3bd0315a234eac7c67766d207b7eaa6559", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -75,18 +75,15 @@ impl<'tcx> fmt::Display for FrameInfo<'tcx> {\n }\n \n impl<'gcx, 'tcx> ConstEvalErr<'tcx> {\n-    pub fn struct_error(&self,\n+    pub fn struct_error(\n+        &self,\n         tcx: TyCtxtAt<'gcx, 'tcx>,\n-        message: &str)\n-        -> Result<DiagnosticBuilder<'tcx>, ErrorHandled>\n-    {\n+        message: &str,\n+    ) -> Result<DiagnosticBuilder<'tcx>, ErrorHandled> {\n         self.struct_generic(tcx, message, None)\n     }\n \n-    pub fn report_as_error(&self,\n-        tcx: TyCtxtAt<'gcx, 'tcx>,\n-        message: &str\n-    ) -> ErrorHandled {\n+    pub fn report_as_error(&self, tcx: TyCtxtAt<'gcx, 'tcx>, message: &str) -> ErrorHandled {\n         let err = self.struct_error(tcx, message);\n         match err {\n             Ok(mut err) => {\n@@ -97,7 +94,8 @@ impl<'gcx, 'tcx> ConstEvalErr<'tcx> {\n         }\n     }\n \n-    pub fn report_as_lint(&self,\n+    pub fn report_as_lint(\n+        &self,\n         tcx: TyCtxtAt<'gcx, 'tcx>,\n         message: &str,\n         lint_root: hir::HirId,\n@@ -172,10 +170,7 @@ impl<'gcx, 'tcx> ConstEvalErr<'tcx> {\n     }\n }\n \n-pub fn struct_error<'gcx, 'tcx>(\n-    tcx: TyCtxtAt<'gcx, 'tcx>,\n-    msg: &str,\n-) -> DiagnosticBuilder<'tcx> {\n+pub fn struct_error<'gcx, 'tcx>(tcx: TyCtxtAt<'gcx, 'tcx>, msg: &str) -> DiagnosticBuilder<'tcx> {\n     struct_span_err!(tcx.sess, tcx.span, E0080, \"{}\", msg)\n }\n "}, {"sha": "f68385ec26759d67914bc25024e26327df4e2eef", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -142,12 +142,10 @@ pub struct AllocDecodingSession<'s> {\n }\n \n impl<'s> AllocDecodingSession<'s> {\n-\n     // Decodes an AllocId in a thread-safe way.\n-    pub fn decode_alloc_id<D>(&self,\n-                                        decoder: &mut D)\n-                                        -> Result<AllocId, D::Error>\n-        where D: TyDecoder<'tcx>,\n+    pub fn decode_alloc_id<D>(&self, decoder: &mut D) -> Result<AllocId, D::Error>\n+    where\n+        D: TyDecoder<'tcx>,\n     {\n         // Read the index of the allocation\n         let idx = decoder.read_u32()? as usize;"}, {"sha": "e73023d9a8cc949229f7b110037a87df42bb56a8", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -3158,7 +3158,7 @@ pub enum ClosureOutlivesSubject<'tcx> {\n \n /*\n  * TypeFoldable implementations for MIR types\n- */\n+*/\n \n CloneTypeFoldableAndLiftImpls! {\n     BlockTailInfo,"}, {"sha": "cf1126efc0f86e5d01caa974c14ed9acdc3e5a00", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -87,9 +87,7 @@ impl<'tcx> MonoItem<'tcx> {\n         }\n     }\n \n-    pub fn instantiation_mode(&self,\n-                          tcx: TyCtxt<'tcx, 'tcx>)\n-                          -> InstantiationMode {\n+    pub fn instantiation_mode(&self, tcx: TyCtxt<'tcx, 'tcx>) -> InstantiationMode {\n         let inline_in_all_cgus =\n             tcx.sess.opts.debugging_opts.inline_in_all_cgus.unwrap_or_else(|| {\n                 tcx.sess.opts.optimize != OptLevel::No\n@@ -195,11 +193,12 @@ impl<'tcx> MonoItem<'tcx> {\n             }\n         };\n \n-        fn to_string_internal<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                        prefix: &str,\n-                                        instance: Instance<'tcx>,\n-                                        debug: bool)\n-                                        -> String {\n+        fn to_string_internal<'tcx>(\n+            tcx: TyCtxt<'tcx, 'tcx>,\n+            prefix: &str,\n+            instance: Instance<'tcx>,\n+            debug: bool,\n+        ) -> String {\n             let mut result = String::with_capacity(32);\n             result.push_str(prefix);\n             let printer = DefPathBasedNames::new(tcx, false, false);\n@@ -369,17 +368,16 @@ impl<'tcx> CodegenUnit<'tcx> {\n             })\n     }\n \n-    pub fn items_in_deterministic_order(&self,\n-                                        tcx: TyCtxt<'tcx, 'tcx>)\n-                                        -> Vec<(MonoItem<'tcx>,\n-                                                (Linkage, Visibility))> {\n+    pub fn items_in_deterministic_order(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+    ) -> Vec<(MonoItem<'tcx>, (Linkage, Visibility))> {\n         // The codegen tests rely on items being process in the same order as\n         // they appear in the file, so for local items, we sort by node_id first\n         #[derive(PartialEq, Eq, PartialOrd, Ord)]\n         pub struct ItemSortKey(Option<HirId>, SymbolName);\n \n-        fn item_sort_key<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                   item: MonoItem<'tcx>) -> ItemSortKey {\n+        fn item_sort_key<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, item: MonoItem<'tcx>) -> ItemSortKey {\n             ItemSortKey(match item {\n                 MonoItem::Fn(ref instance) => {\n                     match instance.def {"}, {"sha": "76d7d98b90256b9c5e4ffbaef7e04f6d3a66cc03", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -33,8 +33,7 @@ impl<'gcx, 'tcx> PlaceTy<'tcx> {\n     /// not carry a `Ty` for `T`.)\n     ///\n     /// Note that the resulting type has not been normalized.\n-    pub fn field_ty(self, tcx: TyCtxt<'gcx, 'tcx>, f: &Field) -> Ty<'tcx>\n-    {\n+    pub fn field_ty(self, tcx: TyCtxt<'gcx, 'tcx>, f: &Field) -> Ty<'tcx> {\n         let answer = match self.ty.sty {\n             ty::Adt(adt_def, substs) => {\n                 let variant_def = match self.variant_index {\n@@ -57,10 +56,7 @@ impl<'gcx, 'tcx> PlaceTy<'tcx> {\n     /// Convenience wrapper around `projection_ty_core` for\n     /// `PlaceElem`, where we can just use the `Ty` that is already\n     /// stored inline on field projection elems.\n-    pub fn projection_ty(self, tcx: TyCtxt<'gcx, 'tcx>,\n-                         elem: &PlaceElem<'tcx>)\n-                         -> PlaceTy<'tcx>\n-    {\n+    pub fn projection_ty(self, tcx: TyCtxt<'gcx, 'tcx>, elem: &PlaceElem<'tcx>) -> PlaceTy<'tcx> {\n         self.projection_ty_core(tcx, elem, |_, _, ty| ty)\n     }\n \n@@ -73,10 +69,11 @@ impl<'gcx, 'tcx> PlaceTy<'tcx> {\n         self,\n         tcx: TyCtxt<'gcx, 'tcx>,\n         elem: &ProjectionElem<V, T>,\n-        mut handle_field: impl FnMut(&Self, &Field, &T) -> Ty<'tcx>)\n-        -> PlaceTy<'tcx>\n+        mut handle_field: impl FnMut(&Self, &Field, &T) -> Ty<'tcx>,\n+    ) -> PlaceTy<'tcx>\n     where\n-        V: ::std::fmt::Debug, T: ::std::fmt::Debug\n+        V: ::std::fmt::Debug,\n+        T: ::std::fmt::Debug,\n     {\n         let answer = match *elem {\n             ProjectionElem::Deref => {\n@@ -122,7 +119,8 @@ BraceStructTypeFoldableImpl! {\n \n impl<'tcx> Place<'tcx> {\n     pub fn ty<'gcx, D>(&self, local_decls: &D, tcx: TyCtxt<'gcx, 'tcx>) -> PlaceTy<'tcx>\n-        where D: HasLocalDecls<'tcx>\n+    where\n+        D: HasLocalDecls<'tcx>,\n     {\n         match *self {\n             Place::Base(PlaceBase::Local(index)) =>\n@@ -142,7 +140,8 @@ pub enum RvalueInitializationState {\n \n impl<'tcx> Rvalue<'tcx> {\n     pub fn ty<'gcx, D>(&self, local_decls: &D, tcx: TyCtxt<'gcx, 'tcx>) -> Ty<'tcx>\n-        where D: HasLocalDecls<'tcx>\n+    where\n+        D: HasLocalDecls<'tcx>,\n     {\n         match *self {\n             Rvalue::Use(ref operand) => operand.ty(local_decls, tcx),\n@@ -223,7 +222,8 @@ impl<'tcx> Rvalue<'tcx> {\n \n impl<'tcx> Operand<'tcx> {\n     pub fn ty<'gcx, D>(&self, local_decls: &D, tcx: TyCtxt<'gcx, 'tcx>) -> Ty<'tcx>\n-        where D: HasLocalDecls<'tcx>\n+    where\n+        D: HasLocalDecls<'tcx>,\n     {\n         match self {\n             &Operand::Copy(ref l) |\n@@ -234,10 +234,12 @@ impl<'tcx> Operand<'tcx> {\n }\n \n impl<'tcx> BinOp {\n-      pub fn ty<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>,\n-                          lhs_ty: Ty<'tcx>,\n-                          rhs_ty: Ty<'tcx>)\n-                          -> Ty<'tcx> {\n+    pub fn ty<'gcx>(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        lhs_ty: Ty<'tcx>,\n+        rhs_ty: Ty<'tcx>,\n+    ) -> Ty<'tcx> {\n         // FIXME: handle SIMD correctly\n         match self {\n             &BinOp::Add | &BinOp::Sub | &BinOp::Mul | &BinOp::Div | &BinOp::Rem |"}, {"sha": "f2c173230765bb9e4b5afe9321d10499382c759f", "filename": "src/librustc/traits/codegen/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -18,11 +18,10 @@ use crate::ty::fold::TypeFoldable;\n /// that type check should guarantee to us that all nested\n /// obligations *could be* resolved if we wanted to.\n /// Assumes that this is run after the entire crate has been successfully type-checked.\n-pub fn codegen_fulfill_obligation<'tcx>(ty: TyCtxt<'tcx, 'tcx>,\n-                                          (param_env, trait_ref):\n-                                          (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>))\n-                                          -> Vtable<'tcx, ()>\n-{\n+pub fn codegen_fulfill_obligation<'tcx>(\n+    ty: TyCtxt<'tcx, 'tcx>,\n+    (param_env, trait_ref): (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>),\n+) -> Vtable<'tcx, ()> {\n     // Remove any references to regions; this helps improve caching.\n     let trait_ref = ty.erase_regions(&trait_ref);\n "}, {"sha": "83f979636416399eba38c4b9511e52a9e0ff6215", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -183,10 +183,10 @@ fn overlap_within_probe(\n     Some(OverlapResult { impl_header, intercrate_ambiguity_causes, involves_placeholder })\n }\n \n-pub fn trait_ref_is_knowable<'gcx, 'tcx>(tcx: TyCtxt<'gcx, 'tcx>,\n-                                             trait_ref: ty::TraitRef<'tcx>)\n-                                             -> Option<Conflict>\n-{\n+pub fn trait_ref_is_knowable<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n+    trait_ref: ty::TraitRef<'tcx>,\n+) -> Option<Conflict> {\n     debug!(\"trait_ref_is_knowable(trait_ref={:?})\", trait_ref);\n     if orphan_check_trait_ref(tcx, trait_ref, InCrate::Remote).is_ok() {\n         // A downstream or cousin crate is allowed to implement some\n@@ -229,9 +229,10 @@ pub fn trait_ref_is_knowable<'gcx, 'tcx>(tcx: TyCtxt<'gcx, 'tcx>,\n     }\n }\n \n-pub fn trait_ref_is_local_or_fundamental<'gcx, 'tcx>(tcx: TyCtxt<'gcx, 'tcx>,\n-                                                         trait_ref: ty::TraitRef<'tcx>)\n-                                                         -> bool {\n+pub fn trait_ref_is_local_or_fundamental<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n+    trait_ref: ty::TraitRef<'tcx>,\n+) -> bool {\n     trait_ref.def_id.krate == LOCAL_CRATE || tcx.has_attr(trait_ref.def_id, sym::fundamental)\n }\n \n@@ -246,10 +247,10 @@ pub enum OrphanCheckErr<'tcx> {\n ///\n /// 1. All type parameters in `Self` must be \"covered\" by some local type constructor.\n /// 2. Some local type must appear in `Self`.\n-pub fn orphan_check<'gcx, 'tcx>(tcx: TyCtxt<'gcx, 'tcx>,\n-                                    impl_def_id: DefId)\n-                                    -> Result<(), OrphanCheckErr<'tcx>>\n-{\n+pub fn orphan_check<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n+    impl_def_id: DefId,\n+) -> Result<(), OrphanCheckErr<'tcx>> {\n     debug!(\"orphan_check({:?})\", impl_def_id);\n \n     // We only except this routine to be invoked on implementations\n@@ -353,11 +354,11 @@ pub fn orphan_check<'gcx, 'tcx>(tcx: TyCtxt<'gcx, 'tcx>,\n ///\n /// Note that this function is never called for types that have both type\n /// parameters and inference variables.\n-fn orphan_check_trait_ref<'tcx>(tcx: TyCtxt<'_, '_>,\n-                                trait_ref: ty::TraitRef<'tcx>,\n-                                in_crate: InCrate)\n-                                -> Result<(), OrphanCheckErr<'tcx>>\n-{\n+fn orphan_check_trait_ref<'tcx>(\n+    tcx: TyCtxt<'_, '_>,\n+    trait_ref: ty::TraitRef<'tcx>,\n+    in_crate: InCrate,\n+) -> Result<(), OrphanCheckErr<'tcx>> {\n     debug!(\"orphan_check_trait_ref(trait_ref={:?}, in_crate={:?})\",\n            trait_ref, in_crate);\n \n@@ -430,8 +431,7 @@ fn orphan_check_trait_ref<'tcx>(tcx: TyCtxt<'_, '_>,\n     }\n }\n \n-fn uncovered_tys<'tcx>(tcx: TyCtxt<'_, '_>, ty: Ty<'tcx>, in_crate: InCrate)\n-                       -> Vec<Ty<'tcx>> {\n+fn uncovered_tys<'tcx>(tcx: TyCtxt<'_, '_>, ty: Ty<'tcx>, in_crate: InCrate) -> Vec<Ty<'tcx>> {\n     if ty_is_local_constructor(ty, in_crate) {\n         vec![]\n     } else if fundamental_ty(ty) {"}, {"sha": "1fb325ae0566989144c31528594f6bc34ec71f8d", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -1242,15 +1242,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         err\n     }\n \n-    fn report_closure_arg_mismatch(&self,\n-                           span: Span,\n-                           found_span: Option<Span>,\n-                           expected_ref: ty::PolyTraitRef<'tcx>,\n-                           found: ty::PolyTraitRef<'tcx>)\n-        -> DiagnosticBuilder<'tcx>\n-    {\n-        fn build_fn_sig_string<'gcx, 'tcx>(tcx: TyCtxt<'gcx, 'tcx>,\n-                                               trait_ref: &ty::TraitRef<'tcx>) -> String {\n+    fn report_closure_arg_mismatch(\n+        &self,\n+        span: Span,\n+        found_span: Option<Span>,\n+        expected_ref: ty::PolyTraitRef<'tcx>,\n+        found: ty::PolyTraitRef<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx> {\n+        fn build_fn_sig_string<'gcx, 'tcx>(\n+            tcx: TyCtxt<'gcx, 'tcx>,\n+            trait_ref: &ty::TraitRef<'tcx>,\n+        ) -> String {\n             let inputs = trait_ref.substs.type_at(1);\n             let sig = if let ty::Tuple(inputs) = inputs.sty {\n                 tcx.mk_fn_sig(\n@@ -1447,10 +1449,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     /// Returns `true` if the trait predicate may apply for *some* assignment\n     /// to the type parameters.\n-    fn predicate_can_apply(&self,\n-                           param_env: ty::ParamEnv<'tcx>,\n-                           pred: ty::PolyTraitRef<'tcx>)\n-                           -> bool {\n+    fn predicate_can_apply(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        pred: ty::PolyTraitRef<'tcx>,\n+    ) -> bool {\n         struct ParamToVarFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n             infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n             var_map: FxHashMap<Ty<'tcx>, Ty<'tcx>>"}, {"sha": "01be8de172c2670d0c6eadcbb3879e921b79590c", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -710,13 +710,13 @@ pub fn type_known_to_meet_bound_modulo_regions<'a, 'gcx, 'tcx>(\n     }\n }\n \n-fn do_normalize_predicates<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                     region_context: DefId,\n-                                     cause: ObligationCause<'tcx>,\n-                                     elaborated_env: ty::ParamEnv<'tcx>,\n-                                     predicates: Vec<ty::Predicate<'tcx>>)\n-                                     -> Result<Vec<ty::Predicate<'tcx>>, ErrorReported>\n-{\n+fn do_normalize_predicates<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    region_context: DefId,\n+    cause: ObligationCause<'tcx>,\n+    elaborated_env: ty::ParamEnv<'tcx>,\n+    predicates: Vec<ty::Predicate<'tcx>>,\n+) -> Result<Vec<ty::Predicate<'tcx>>, ErrorReported> {\n     debug!(\n         \"do_normalize_predicates(predicates={:?}, region_context={:?}, cause={:?})\",\n         predicates,\n@@ -795,12 +795,12 @@ fn do_normalize_predicates<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n \n // FIXME: this is gonna need to be removed ...\n /// Normalizes the parameter environment, reporting errors if they occur.\n-pub fn normalize_param_env_or_error<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                              region_context: DefId,\n-                                              unnormalized_env: ty::ParamEnv<'tcx>,\n-                                              cause: ObligationCause<'tcx>)\n-                                              -> ty::ParamEnv<'tcx>\n-{\n+pub fn normalize_param_env_or_error<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    region_context: DefId,\n+    unnormalized_env: ty::ParamEnv<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+) -> ty::ParamEnv<'tcx> {\n     // I'm not wild about reporting errors here; I'd prefer to\n     // have the errors get reported at a defined place (e.g.,\n     // during typeck). Instead I have all parameter\n@@ -936,10 +936,10 @@ pub fn fully_normalize<'a, 'gcx, 'tcx, T>(\n /// environment. If this returns false, then either normalize\n /// encountered an error or one of the predicates did not hold. Used\n /// when creating vtables to check for unsatisfiable methods.\n-fn normalize_and_test_predicates<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                           predicates: Vec<ty::Predicate<'tcx>>)\n-                                           -> bool\n-{\n+fn normalize_and_test_predicates<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    predicates: Vec<ty::Predicate<'tcx>>,\n+) -> bool {\n     debug!(\"normalize_and_test_predicates(predicates={:?})\",\n            predicates);\n \n@@ -965,10 +965,10 @@ fn normalize_and_test_predicates<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n     result\n }\n \n-fn substitute_normalize_and_test_predicates<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                                      key: (DefId, SubstsRef<'tcx>))\n-                                                      -> bool\n-{\n+fn substitute_normalize_and_test_predicates<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    key: (DefId, SubstsRef<'tcx>),\n+) -> bool {\n     debug!(\"substitute_normalize_and_test_predicates(key={:?})\",\n            key);\n \n@@ -985,9 +985,8 @@ fn substitute_normalize_and_test_predicates<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n #[inline] // FIXME(#35870): avoid closures being unexported due to `impl Trait`.\n fn vtable_methods<'tcx>(\n     tcx: TyCtxt<'tcx, 'tcx>,\n-    trait_ref: ty::PolyTraitRef<'tcx>)\n-    -> &'tcx [Option<(DefId, SubstsRef<'tcx>)>]\n-{\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+) -> &'tcx [Option<(DefId, SubstsRef<'tcx>)>] {\n     debug!(\"vtable_methods({:?})\", trait_ref);\n \n     tcx.arena.alloc_from_iter("}, {"sha": "01b81b182af9627954b03b424e2e8806978f0723", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -84,7 +84,6 @@ pub enum MethodViolationCode {\n }\n \n impl<'tcx> TyCtxt<'tcx, 'tcx> {\n-\n     /// Returns the object safety violations that affect\n     /// astconv -- currently, `Self` in supertraits. This is needed\n     /// because `object_safety_violations` can't be used during\n@@ -703,7 +702,6 @@ impl<'tcx> TyCtxt<'tcx, 'tcx> {\n     }\n }\n \n-pub(super) fn is_object_safe_provider<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                                trait_def_id: DefId) -> bool {\n+pub(super) fn is_object_safe_provider<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, trait_def_id: DefId) -> bool {\n     tcx.object_safety_violations(trait_def_id).is_empty()\n }"}, {"sha": "fe190db5fdbee6cda9ebdfe0fc2a227c7513448c", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -35,12 +35,13 @@ impl OnUnimplementedNote {\n     }\n }\n \n-fn parse_error(tcx: TyCtxt<'_, '_>, span: Span,\n-               message: &str,\n-               label: &str,\n-               note: Option<&str>)\n-               -> ErrorReported\n-{\n+fn parse_error(\n+    tcx: TyCtxt<'_, '_>,\n+    span: Span,\n+    message: &str,\n+    label: &str,\n+    note: Option<&str>,\n+) -> ErrorReported {\n     let mut diag = struct_span_err!(\n         tcx.sess, span, E0232, \"{}\", message);\n     diag.span_label(span, label);\n@@ -52,13 +53,13 @@ fn parse_error(tcx: TyCtxt<'_, '_>, span: Span,\n }\n \n impl<'gcx, 'tcx> OnUnimplementedDirective {\n-    fn parse(tcx: TyCtxt<'gcx, 'tcx>,\n-                 trait_def_id: DefId,\n-                 items: &[NestedMetaItem],\n-                 span: Span,\n-                 is_root: bool)\n-                 -> Result<Self, ErrorReported>\n-    {\n+    fn parse(\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        trait_def_id: DefId,\n+        items: &[NestedMetaItem],\n+        span: Span,\n+        is_root: bool,\n+    ) -> Result<Self, ErrorReported> {\n         let mut errored = false;\n         let mut item_iter = items.iter();\n \n@@ -132,12 +133,11 @@ impl<'gcx, 'tcx> OnUnimplementedDirective {\n         }\n     }\n \n-\n-    pub fn of_item(tcx: TyCtxt<'gcx, 'tcx>,\n-                   trait_def_id: DefId,\n-                   impl_def_id: DefId)\n-                   -> Result<Option<Self>, ErrorReported>\n-    {\n+    pub fn of_item(\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        trait_def_id: DefId,\n+        impl_def_id: DefId,\n+    ) -> Result<Option<Self>, ErrorReported> {\n         let attrs = tcx.get_attrs(impl_def_id);\n \n         let attr = if let Some(item) = attr::find_by_name(&attrs, sym::rustc_on_unimplemented) {\n@@ -164,12 +164,12 @@ impl<'gcx, 'tcx> OnUnimplementedDirective {\n         result\n     }\n \n-    pub fn evaluate(&self,\n-                    tcx: TyCtxt<'gcx, 'tcx>,\n-                    trait_ref: ty::TraitRef<'tcx>,\n-                    options: &[(Symbol, Option<String>)])\n-                    -> OnUnimplementedNote\n-    {\n+    pub fn evaluate(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        trait_ref: ty::TraitRef<'tcx>,\n+        options: &[(Symbol, Option<String>)],\n+    ) -> OnUnimplementedNote {\n         let mut message = None;\n         let mut label = None;\n         let mut note = None;\n@@ -215,12 +215,12 @@ impl<'gcx, 'tcx> OnUnimplementedDirective {\n }\n \n impl<'gcx, 'tcx> OnUnimplementedFormatString {\n-    fn try_parse(tcx: TyCtxt<'gcx, 'tcx>,\n-                     trait_def_id: DefId,\n-                     from: LocalInternedString,\n-                     err_sp: Span)\n-                     -> Result<Self, ErrorReported>\n-    {\n+    fn try_parse(\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        trait_def_id: DefId,\n+        from: LocalInternedString,\n+        err_sp: Span,\n+    ) -> Result<Self, ErrorReported> {\n         let result = OnUnimplementedFormatString(from);\n         result.verify(tcx, trait_def_id, err_sp)?;\n         Ok(result)"}, {"sha": "90df5ed10d78f1657ba7062629ca4191eaa944f1", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -85,12 +85,7 @@ pub struct DropckOutlivesResult<'tcx> {\n }\n \n impl<'tcx> DropckOutlivesResult<'tcx> {\n-    pub fn report_overflows(\n-        &self,\n-        tcx: TyCtxt<'_, 'tcx>,\n-        span: Span,\n-        ty: Ty<'tcx>,\n-    ) {\n+    pub fn report_overflows(&self, tcx: TyCtxt<'_, 'tcx>, span: Span, ty: Ty<'tcx>) {\n         if let Some(overflow_ty) = self.overflows.iter().next() {\n             let mut err = struct_span_err!(\n                 tcx.sess,"}, {"sha": "27891bed2b76ed5421c4b9e209f56080948e1ffb", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -149,10 +149,10 @@ pub fn find_associated_item<'tcx>(\n /// Specialization is determined by the sets of types to which the impls apply;\n /// `impl1` specializes `impl2` if it applies to a subset of the types `impl2` applies\n /// to.\n-pub(super) fn specializes<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                    (impl1_def_id, impl2_def_id): (DefId, DefId))\n-    -> bool\n-{\n+pub(super) fn specializes<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    (impl1_def_id, impl2_def_id): (DefId, DefId),\n+) -> bool {\n     debug!(\"specializes({:?}, {:?})\", impl1_def_id, impl2_def_id);\n \n     // The feature gate should prevent introducing new specializations, but not"}, {"sha": "2e86d40a3ad54c1ca4c7adbe98e8c1126f6efb7c", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -83,9 +83,7 @@ enum Inserted {\n \n impl<'gcx, 'tcx> Children {\n     /// Insert an impl into this set of children without comparing to any existing impls.\n-    fn insert_blindly(&mut self,\n-                      tcx: TyCtxt<'gcx, 'tcx>,\n-                      impl_def_id: DefId) {\n+    fn insert_blindly(&mut self, tcx: TyCtxt<'gcx, 'tcx>, impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n         if let Some(sty) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), false) {\n             debug!(\"insert_blindly: impl_def_id={:?} sty={:?}\", impl_def_id, sty);\n@@ -99,9 +97,7 @@ impl<'gcx, 'tcx> Children {\n     /// Removes an impl from this set of children. Used when replacing\n     /// an impl with a parent. The impl must be present in the list of\n     /// children already.\n-    fn remove_existing(&mut self,\n-                      tcx: TyCtxt<'gcx, 'tcx>,\n-                      impl_def_id: DefId) {\n+    fn remove_existing(&mut self, tcx: TyCtxt<'gcx, 'tcx>, impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n         let vec: &mut Vec<DefId>;\n         if let Some(sty) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), false) {\n@@ -118,12 +114,12 @@ impl<'gcx, 'tcx> Children {\n \n     /// Attempt to insert an impl into this set of children, while comparing for\n     /// specialization relationships.\n-    fn insert(&mut self,\n-              tcx: TyCtxt<'gcx, 'tcx>,\n-              impl_def_id: DefId,\n-              simplified_self: Option<SimplifiedType>)\n-              -> Result<Inserted, OverlapError>\n-    {\n+    fn insert(\n+        &mut self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        impl_def_id: DefId,\n+        simplified_self: Option<SimplifiedType>,\n+    ) -> Result<Inserted, OverlapError> {\n         let mut last_lint = None;\n         let mut replace_children = Vec::new();\n \n@@ -293,10 +289,11 @@ impl<'gcx, 'tcx> Graph {\n     /// Insert a local impl into the specialization graph. If an existing impl\n     /// conflicts with it (has overlap, but neither specializes the other),\n     /// information about the area of overlap is returned in the `Err`.\n-    pub fn insert(&mut self,\n-                  tcx: TyCtxt<'gcx, 'tcx>,\n-                  impl_def_id: DefId)\n-                  -> Result<Option<FutureCompatOverlapError>, OverlapError> {\n+    pub fn insert(\n+        &mut self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        impl_def_id: DefId,\n+    ) -> Result<Option<FutureCompatOverlapError>, OverlapError> {\n         assert!(impl_def_id.is_local());\n \n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n@@ -386,10 +383,12 @@ impl<'gcx, 'tcx> Graph {\n     }\n \n     /// Insert cached metadata mapping from a child impl back to its parent.\n-    pub fn record_impl_from_cstore(&mut self,\n-                                   tcx: TyCtxt<'gcx, 'tcx>,\n-                                   parent: DefId,\n-                                   child: DefId) {\n+    pub fn record_impl_from_cstore(\n+        &mut self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        parent: DefId,\n+        child: DefId,\n+    ) {\n         if self.parent.insert(child, parent).is_some() {\n             bug!(\"When recording an impl from the crate store, information about its parent \\\n                   was already present.\");\n@@ -423,10 +422,7 @@ impl<'gcx, 'tcx> Node {\n     }\n \n     /// Iterate over the items defined directly by the given (impl or trait) node.\n-    pub fn items(\n-        &self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-    ) -> ty::AssocItemsIterator<'gcx, 'tcx> {\n+    pub fn items(&self, tcx: TyCtxt<'gcx, 'tcx>) -> ty::AssocItemsIterator<'gcx, 'tcx> {\n         tcx.associated_items(self.def_id())\n     }\n \n@@ -508,10 +504,11 @@ impl<'gcx, 'tcx> Ancestors<'gcx> {\n \n /// Walk up the specialization ancestors of a given impl, starting with that\n /// impl itself.\n-pub fn ancestors(tcx: TyCtxt<'tcx, '_>,\n-                 trait_def_id: DefId,\n-                 start_from_impl: DefId)\n-                 -> Ancestors<'tcx> {\n+pub fn ancestors(\n+    tcx: TyCtxt<'tcx, '_>,\n+    trait_def_id: DefId,\n+    start_from_impl: DefId,\n+) -> Ancestors<'tcx> {\n     let specialization_graph = tcx.specialization_graph_of(trait_def_id);\n     Ancestors {\n         trait_def_id,"}, {"sha": "c5ff174e944367c5f3e944c9867b12361ee7527b", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -12,9 +12,10 @@ use crate::util::nodemap::FxHashSet;\n \n use super::{Obligation, ObligationCause, PredicateObligation, SelectionContext, Normalized};\n \n-fn anonymize_predicate<'gcx, 'tcx>(tcx: TyCtxt<'gcx, 'tcx>,\n-                                       pred: &ty::Predicate<'tcx>)\n-                                       -> ty::Predicate<'tcx> {\n+fn anonymize_predicate<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n+    pred: &ty::Predicate<'tcx>,\n+) -> ty::Predicate<'tcx> {\n     match *pred {\n         ty::Predicate::Trait(ref data) =>\n             ty::Predicate::Trait(tcx.anonymize_late_bound_regions(data)),\n@@ -95,26 +96,23 @@ pub struct Elaborator<'gcx, 'tcx> {\n \n pub fn elaborate_trait_ref<'gcx, 'tcx>(\n     tcx: TyCtxt<'gcx, 'tcx>,\n-    trait_ref: ty::PolyTraitRef<'tcx>)\n-    -> Elaborator<'gcx, 'tcx>\n-{\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+) -> Elaborator<'gcx, 'tcx> {\n     elaborate_predicates(tcx, vec![trait_ref.to_predicate()])\n }\n \n pub fn elaborate_trait_refs<'gcx, 'tcx>(\n     tcx: TyCtxt<'gcx, 'tcx>,\n-    trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>)\n-    -> Elaborator<'gcx, 'tcx>\n-{\n+    trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n+) -> Elaborator<'gcx, 'tcx> {\n     let predicates = trait_refs.map(|trait_ref| trait_ref.to_predicate()).collect();\n     elaborate_predicates(tcx, predicates)\n }\n \n pub fn elaborate_predicates<'gcx, 'tcx>(\n     tcx: TyCtxt<'gcx, 'tcx>,\n-    mut predicates: Vec<ty::Predicate<'tcx>>)\n-    -> Elaborator<'gcx, 'tcx>\n-{\n+    mut predicates: Vec<ty::Predicate<'tcx>>,\n+) -> Elaborator<'gcx, 'tcx> {\n     let mut visited = PredicateSet::new(tcx);\n     predicates.retain(|pred| visited.insert(pred));\n     Elaborator { stack: predicates, visited }\n@@ -256,15 +254,17 @@ impl Iterator for Elaborator<'gcx, 'tcx> {\n \n pub type Supertraits<'gcx, 'tcx> = FilterToTraits<Elaborator<'gcx, 'tcx>>;\n \n-pub fn supertraits<'gcx, 'tcx>(tcx: TyCtxt<'gcx, 'tcx>,\n-                                    trait_ref: ty::PolyTraitRef<'tcx>)\n-                                    -> Supertraits<'gcx, 'tcx> {\n+pub fn supertraits<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+) -> Supertraits<'gcx, 'tcx> {\n     elaborate_trait_ref(tcx, trait_ref).filter_to_traits()\n }\n \n-pub fn transitive_bounds<'gcx, 'tcx>(tcx: TyCtxt<'gcx, 'tcx>,\n-                                          bounds: impl Iterator<Item = ty::PolyTraitRef<'tcx>>)\n-                                          -> Supertraits<'gcx, 'tcx> {\n+pub fn transitive_bounds<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n+    bounds: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n+) -> Supertraits<'gcx, 'tcx> {\n     elaborate_trait_refs(tcx, bounds).filter_to_traits()\n }\n \n@@ -339,7 +339,7 @@ impl<'tcx> TraitAliasExpansionInfo<'tcx> {\n \n pub fn expand_trait_aliases<'gcx, 'tcx>(\n     tcx: TyCtxt<'gcx, 'tcx>,\n-    trait_refs: impl IntoIterator<Item = (ty::PolyTraitRef<'tcx>, Span)>\n+    trait_refs: impl IntoIterator<Item = (ty::PolyTraitRef<'tcx>, Span)>,\n ) -> TraitAliasExpander<'gcx, 'tcx> {\n     let items: Vec<_> = trait_refs\n         .into_iter()\n@@ -420,10 +420,10 @@ pub struct SupertraitDefIds<'gcx, 'tcx> {\n     visited: FxHashSet<DefId>,\n }\n \n-pub fn supertrait_def_ids<'gcx, 'tcx>(tcx: TyCtxt<'gcx, 'tcx>,\n-                                           trait_def_id: DefId)\n-                                           -> SupertraitDefIds<'gcx, 'tcx>\n-{\n+pub fn supertrait_def_ids<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n+    trait_def_id: DefId,\n+) -> SupertraitDefIds<'gcx, 'tcx> {\n     SupertraitDefIds {\n         tcx,\n         stack: vec![trait_def_id],"}, {"sha": "213f556f9acac168244fa3d2c6b40ddcb23a59e0", "filename": "src/librustc/ty/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2F_match.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -20,7 +20,7 @@ use crate::mir::interpret::ConstValue;\n /// important thing about the result is Ok/Err. Also, matching never\n /// affects any type variables or unification state.\n pub struct Match<'gcx, 'tcx> {\n-    tcx: TyCtxt<'gcx, 'tcx>\n+    tcx: TyCtxt<'gcx, 'tcx>,\n }\n \n impl Match<'gcx, 'tcx> {"}, {"sha": "e1f86bee4babb4ce7192d7c8d8c6cdd35e085ca4", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -104,8 +104,11 @@ pub struct OverloadedDeref<'tcx> {\n }\n \n impl<'gcx, 'tcx> OverloadedDeref<'tcx> {\n-    pub fn method_call(&self, tcx: TyCtxt<'gcx, 'tcx>, source: Ty<'tcx>)\n-                       -> (DefId, SubstsRef<'tcx>) {\n+    pub fn method_call(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        source: Ty<'tcx>,\n+    ) -> (DefId, SubstsRef<'tcx>) {\n         let trait_def_id = match self.mutbl {\n             hir::MutImmutable => tcx.lang_items().deref_trait(),\n             hir::MutMutable => tcx.lang_items().deref_mut_trait()"}, {"sha": "ea5d088d540fda50b3b8056fc56fb94cb1f9aa58", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 37, "deletions": 29, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -132,33 +132,37 @@ pub trait TyDecoder<'tcx>: Decoder {\n \n #[inline]\n pub fn decode_arena_allocable<D, T: ArenaAllocatable + Decodable>(\n-    decoder: &mut D\n+    decoder: &mut D,\n ) -> Result<&'tcx T, D::Error>\n-    where D: TyDecoder<'tcx>,\n+where\n+    D: TyDecoder<'tcx>,\n {\n     Ok(decoder.tcx().arena.alloc(Decodable::decode(decoder)?))\n }\n \n #[inline]\n pub fn decode_arena_allocable_slice<D, T: ArenaAllocatable + Decodable>(\n-    decoder: &mut D\n+    decoder: &mut D,\n ) -> Result<&'tcx [T], D::Error>\n-    where D: TyDecoder<'tcx>,\n+where\n+    D: TyDecoder<'tcx>,\n {\n     Ok(decoder.tcx().arena.alloc_from_iter(<Vec<T> as Decodable>::decode(decoder)?))\n }\n \n #[inline]\n pub fn decode_cnum<D>(decoder: &mut D) -> Result<CrateNum, D::Error>\n-    where D: TyDecoder<'tcx>,\n+where\n+    D: TyDecoder<'tcx>,\n {\n     let cnum = CrateNum::from_u32(u32::decode(decoder)?);\n     Ok(decoder.map_encoded_cnum_to_current(cnum))\n }\n \n #[inline]\n pub fn decode_ty<D>(decoder: &mut D) -> Result<Ty<'tcx>, D::Error>\n-    where D: TyDecoder<'tcx>,\n+where\n+    D: TyDecoder<'tcx>,\n {\n     // Handle shorthands first, if we have an usize > 0x80.\n     if decoder.positioned_at_shorthand() {\n@@ -176,9 +180,9 @@ pub fn decode_ty<D>(decoder: &mut D) -> Result<Ty<'tcx>, D::Error>\n }\n \n #[inline]\n-pub fn decode_predicates<D>(decoder: &mut D)\n-                                      -> Result<ty::GenericPredicates<'tcx>, D::Error>\n-    where D: TyDecoder<'tcx>,\n+pub fn decode_predicates<D>(decoder: &mut D) -> Result<ty::GenericPredicates<'tcx>, D::Error>\n+where\n+    D: TyDecoder<'tcx>,\n {\n     Ok(ty::GenericPredicates {\n         parent: Decodable::decode(decoder)?,\n@@ -201,7 +205,8 @@ pub fn decode_predicates<D>(decoder: &mut D)\n \n #[inline]\n pub fn decode_substs<D>(decoder: &mut D) -> Result<SubstsRef<'tcx>, D::Error>\n-    where D: TyDecoder<'tcx>,\n+where\n+    D: TyDecoder<'tcx>,\n {\n     let len = decoder.read_usize()?;\n     let tcx = decoder.tcx();\n@@ -210,43 +215,46 @@ pub fn decode_substs<D>(decoder: &mut D) -> Result<SubstsRef<'tcx>, D::Error>\n \n #[inline]\n pub fn decode_region<D>(decoder: &mut D) -> Result<ty::Region<'tcx>, D::Error>\n-    where D: TyDecoder<'tcx>,\n+where\n+    D: TyDecoder<'tcx>,\n {\n     Ok(decoder.tcx().mk_region(Decodable::decode(decoder)?))\n }\n \n #[inline]\n-pub fn decode_ty_slice<D>(decoder: &mut D)\n-                                    -> Result<&'tcx ty::List<Ty<'tcx>>, D::Error>\n-    where D: TyDecoder<'tcx>,\n+pub fn decode_ty_slice<D>(decoder: &mut D) -> Result<&'tcx ty::List<Ty<'tcx>>, D::Error>\n+where\n+    D: TyDecoder<'tcx>,\n {\n     let len = decoder.read_usize()?;\n     Ok(decoder.tcx().mk_type_list((0..len).map(|_| Decodable::decode(decoder)))?)\n }\n \n #[inline]\n-pub fn decode_adt_def<D>(decoder: &mut D)\n-                                   -> Result<&'tcx ty::AdtDef, D::Error>\n-    where D: TyDecoder<'tcx>,\n+pub fn decode_adt_def<D>(decoder: &mut D) -> Result<&'tcx ty::AdtDef, D::Error>\n+where\n+    D: TyDecoder<'tcx>,\n {\n     let def_id = DefId::decode(decoder)?;\n     Ok(decoder.tcx().adt_def(def_id))\n }\n \n #[inline]\n-pub fn decode_existential_predicate_slice<D>(decoder: &mut D)\n-    -> Result<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>, D::Error>\n-    where D: TyDecoder<'tcx>,\n+pub fn decode_existential_predicate_slice<D>(\n+    decoder: &mut D,\n+) -> Result<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>, D::Error>\n+where\n+    D: TyDecoder<'tcx>,\n {\n     let len = decoder.read_usize()?;\n     Ok(decoder.tcx()\n               .mk_existential_predicates((0..len).map(|_| Decodable::decode(decoder)))?)\n }\n \n #[inline]\n-pub fn decode_canonical_var_infos<D>(decoder: &mut D)\n-    -> Result<CanonicalVarInfos<'tcx>, D::Error>\n-    where D: TyDecoder<'tcx>,\n+pub fn decode_canonical_var_infos<D>(decoder: &mut D) -> Result<CanonicalVarInfos<'tcx>, D::Error>\n+where\n+    D: TyDecoder<'tcx>,\n {\n     let len = decoder.read_usize()?;\n     let interned: Result<Vec<CanonicalVarInfo>, _> = (0..len).map(|_| Decodable::decode(decoder))\n@@ -256,17 +264,17 @@ pub fn decode_canonical_var_infos<D>(decoder: &mut D)\n }\n \n #[inline]\n-pub fn decode_const<D>(decoder: &mut D)\n-                                 -> Result<&'tcx ty::Const<'tcx>, D::Error>\n-    where D: TyDecoder<'tcx>,\n+pub fn decode_const<D>(decoder: &mut D) -> Result<&'tcx ty::Const<'tcx>, D::Error>\n+where\n+    D: TyDecoder<'tcx>,\n {\n     Ok(decoder.tcx().mk_const(Decodable::decode(decoder)?))\n }\n \n #[inline]\n-pub fn decode_allocation<D>(decoder: &mut D)\n-    -> Result<&'tcx Allocation, D::Error>\n-    where D: TyDecoder<'tcx>,\n+pub fn decode_allocation<D>(decoder: &mut D) -> Result<&'tcx Allocation, D::Error>\n+where\n+    D: TyDecoder<'tcx>,\n {\n     Ok(decoder.tcx().intern_const_alloc(Decodable::decode(decoder)?))\n }"}, {"sha": "4e255edfe85637164a1c1d80c56cc60fd6e43999", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 40, "deletions": 37, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -1678,10 +1678,7 @@ impl<'gcx> GlobalCtxt<'gcx> {\n     /// Call the closure with a local `TyCtxt` using the given arena.\n     /// `interners` is a slot passed so we can create a CtxtInterners\n     /// with the same lifetime as `arena`.\n-    pub fn enter_local<'tcx, F, R>(\n-        &'gcx self,\n-        f: F\n-    ) -> R\n+    pub fn enter_local<'tcx, F, R>(&'gcx self, f: F) -> R\n     where\n         F: FnOnce(TyCtxt<'gcx, 'tcx>) -> R,\n         'gcx: 'tcx,\n@@ -1732,41 +1729,41 @@ pub trait Lift<'tcx>: fmt::Debug {\n macro_rules! nop_lift {\n     ($ty:ty => $lifted:ty) => {\n         impl<'a, 'tcx> Lift<'tcx> for $ty {\n-            type Lifted = $lifted;\n-            fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n-                if tcx.interners.arena.in_arena(*self as *const _) {\n-                    return Some(unsafe { mem::transmute(*self) });\n-                }\n-                // Also try in the global tcx if we're not that.\n-                if !tcx.is_global() {\n-                    self.lift_to_tcx(tcx.global_tcx())\n-                } else {\n-                    None\n+                    type Lifted = $lifted;\n+                    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+                        if tcx.interners.arena.in_arena(*self as *const _) {\n+                            return Some(unsafe { mem::transmute(*self) });\n+                        }\n+                        // Also try in the global tcx if we're not that.\n+                        if !tcx.is_global() {\n+                            self.lift_to_tcx(tcx.global_tcx())\n+                        } else {\n+                            None\n+                        }\n+                    }\n                 }\n-            }\n-        }\n     };\n }\n \n macro_rules! nop_list_lift {\n     ($ty:ty => $lifted:ty) => {\n         impl<'a, 'tcx> Lift<'tcx> for &'a List<$ty> {\n-            type Lifted = &'tcx List<$lifted>;\n-            fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n-                if self.is_empty() {\n-                    return Some(List::empty());\n-                }\n-                if tcx.interners.arena.in_arena(*self as *const _) {\n-                    return Some(unsafe { mem::transmute(*self) });\n-                }\n-                // Also try in the global tcx if we're not that.\n-                if !tcx.is_global() {\n-                    self.lift_to_tcx(tcx.global_tcx())\n-                } else {\n-                    None\n+                    type Lifted = &'tcx List<$lifted>;\n+                    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+                        if self.is_empty() {\n+                            return Some(List::empty());\n+                        }\n+                        if tcx.interners.arena.in_arena(*self as *const _) {\n+                            return Some(unsafe { mem::transmute(*self) });\n+                        }\n+                        // Also try in the global tcx if we're not that.\n+                        if !tcx.is_global() {\n+                            self.lift_to_tcx(tcx.global_tcx())\n+                        } else {\n+                            None\n+                        }\n+                    }\n                 }\n-            }\n-        }\n     };\n }\n \n@@ -1941,7 +1938,8 @@ pub mod tls {\n     /// This happens once per rustc session and TyCtxts only exists\n     /// inside the `f` function.\n     pub fn enter_global<'gcx, F, R>(gcx: &'gcx GlobalCtxt<'gcx>, f: F) -> R\n-        where F: FnOnce(TyCtxt<'gcx, 'gcx>) -> R\n+    where\n+        F: FnOnce(TyCtxt<'gcx, 'gcx>) -> R,\n     {\n         // Update GCX_PTR to indicate there's a GlobalCtxt available\n         GCX_PTR.with(|lock| {\n@@ -1978,7 +1976,8 @@ pub mod tls {\n     /// Creates a TyCtxt and ImplicitCtxt based on the GCX_PTR thread local.\n     /// This is used in the deadlock handler.\n     pub unsafe fn with_global<F, R>(f: F) -> R\n-        where F: for<'gcx, 'tcx> FnOnce(TyCtxt<'gcx, 'tcx>) -> R\n+    where\n+        F: for<'gcx, 'tcx> FnOnce(TyCtxt<'gcx, 'tcx>) -> R,\n     {\n         let gcx = GCX_PTR.with(|lock| *lock.lock());\n         assert!(gcx != 0);\n@@ -2031,7 +2030,8 @@ pub mod tls {\n     /// the current ImplicitCtxt's tcx field.\n     #[inline]\n     pub fn with_related_context<'gcx, 'tcx1, F, R>(tcx: TyCtxt<'gcx, 'tcx1>, f: F) -> R\n-        where F: for<'b, 'tcx2> FnOnce(&ImplicitCtxt<'b, 'gcx, 'tcx2>) -> R\n+    where\n+        F: for<'b, 'tcx2> FnOnce(&ImplicitCtxt<'b, 'gcx, 'tcx2>) -> R,\n     {\n         with_context(|context| {\n             unsafe {\n@@ -2049,7 +2049,8 @@ pub mod tls {\n     /// a different local interner from the current ImplicitCtxt's tcx field.\n     #[inline]\n     pub fn with_fully_related_context<'gcx, 'tcx, F, R>(tcx: TyCtxt<'gcx, 'tcx>, f: F) -> R\n-        where F: for<'b> FnOnce(&ImplicitCtxt<'b, 'gcx, 'tcx>) -> R\n+    where\n+        F: for<'b> FnOnce(&ImplicitCtxt<'b, 'gcx, 'tcx>) -> R,\n     {\n         with_context(|context| {\n             unsafe {\n@@ -2065,7 +2066,8 @@ pub mod tls {\n     /// Panics if there is no ImplicitCtxt available\n     #[inline]\n     pub fn with<F, R>(f: F) -> R\n-        where F: for<'gcx, 'tcx> FnOnce(TyCtxt<'gcx, 'tcx>) -> R\n+    where\n+        F: for<'gcx, 'tcx> FnOnce(TyCtxt<'gcx, 'tcx>) -> R,\n     {\n         with_context(|context| f(context.tcx))\n     }\n@@ -2074,7 +2076,8 @@ pub mod tls {\n     /// The closure is passed None if there is no ImplicitCtxt available\n     #[inline]\n     pub fn with_opt<F, R>(f: F) -> R\n-        where F: for<'gcx, 'tcx> FnOnce(Option<TyCtxt<'gcx, 'tcx>>) -> R\n+    where\n+        F: for<'gcx, 'tcx> FnOnce(Option<TyCtxt<'gcx, 'tcx>>) -> R,\n     {\n         with_context_opt(|opt_context| f(opt_context.map(|context| context.tcx)))\n     }"}, {"sha": "d32ad0f5c6d5053fce055a3f53a06233d26f4043", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -55,11 +55,11 @@ pub enum SimplifiedTypeGen<D>\n /// then we can't say much about whether two types would unify. Put another way,\n /// `can_simplify_params` should be true if type parameters appear free in `ty` and `false` if they\n /// are to be considered bound.\n-pub fn simplify_type<'gcx, 'tcx>(tcx: TyCtxt<'gcx, 'tcx>,\n-                                     ty: Ty<'_>,\n-                                     can_simplify_params: bool)\n-                                     -> Option<SimplifiedType>\n-{\n+pub fn simplify_type<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n+    ty: Ty<'_>,\n+    can_simplify_params: bool,\n+) -> Option<SimplifiedType> {\n     match ty.sty {\n         ty::Bool => Some(BoolSimplifiedType),\n         ty::Char => Some(CharSimplifiedType),"}, {"sha": "c79dad04df6244148e74dabb2e5f97ad50e873e8", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 37, "deletions": 30, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -155,7 +155,7 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n /// default implementation that does an \"identity\" fold. Within each\n /// identity fold, it should invoke `foo.fold_with(self)` to fold each\n /// sub-item.\n-pub trait TypeFolder<'gcx: 'tcx, 'tcx> : Sized {\n+pub trait TypeFolder<'gcx: 'tcx, 'tcx>: Sized {\n     fn tcx<'a>(&'a self) -> TyCtxt<'gcx, 'tcx>;\n \n     fn fold_binder<T>(&mut self, t: &Binder<T>) -> Binder<T>\n@@ -199,9 +199,10 @@ pub trait TypeVisitor<'tcx> : Sized {\n // Some sample folders\n \n pub struct BottomUpFolder<'gcx, 'tcx, F, G, H>\n-    where F: FnMut(Ty<'tcx>) -> Ty<'tcx>,\n-          G: FnMut(ty::Region<'tcx>) -> ty::Region<'tcx>,\n-          H: FnMut(&'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx>,\n+where\n+    F: FnMut(Ty<'tcx>) -> Ty<'tcx>,\n+    G: FnMut(ty::Region<'tcx>) -> ty::Region<'tcx>,\n+    H: FnMut(&'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx>,\n {\n     pub tcx: TyCtxt<'gcx, 'tcx>,\n     pub ty_op: F,\n@@ -210,11 +211,14 @@ pub struct BottomUpFolder<'gcx, 'tcx, F, G, H>\n }\n \n impl<'gcx, 'tcx, F, G, H> TypeFolder<'gcx, 'tcx> for BottomUpFolder<'gcx, 'tcx, F, G, H>\n-    where F: FnMut(Ty<'tcx>) -> Ty<'tcx>,\n-          G: FnMut(ty::Region<'tcx>) -> ty::Region<'tcx>,\n-          H: FnMut(&'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx>,\n+where\n+    F: FnMut(Ty<'tcx>) -> Ty<'tcx>,\n+    G: FnMut(ty::Region<'tcx>) -> ty::Region<'tcx>,\n+    H: FnMut(&'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx>,\n {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> { self.tcx }\n+    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> {\n+        self.tcx\n+        }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         let t = ty.super_fold_with(self);\n@@ -361,7 +365,7 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n /// visited by this folder; only regions that occur free will be\n /// visited by `fld_r`.\n \n-pub struct RegionFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+pub struct RegionFolder<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'gcx, 'tcx>,\n     skipped_regions: &'a mut bool,\n \n@@ -373,10 +377,8 @@ pub struct RegionFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     /// Callback invokes for each free region. The `DebruijnIndex`\n     /// points to the binder *just outside* the ones we have passed\n     /// through.\n-    fold_region_fn: &'a mut (dyn FnMut(\n-        ty::Region<'tcx>,\n-        ty::DebruijnIndex,\n-    ) -> ty::Region<'tcx> + 'a),\n+    fold_region_fn:\n+        &'a mut (dyn FnMut(ty::Region<'tcx>, ty::DebruijnIndex) -> ty::Region<'tcx> + 'a),\n }\n \n impl<'a, 'gcx, 'tcx> RegionFolder<'a, 'gcx, 'tcx> {\n@@ -396,7 +398,9 @@ impl<'a, 'gcx, 'tcx> RegionFolder<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFolder<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> { self.tcx }\n+    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> {\n+        self.tcx\n+        }\n \n     fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n         self.current_index.shift_in(1);\n@@ -445,9 +449,10 @@ impl<'a, 'gcx, 'tcx> BoundVarReplacer<'a, 'gcx, 'tcx> {\n         fld_t: &'a mut G,\n         fld_c: &'a mut H,\n     ) -> Self\n-        where F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n-              G: FnMut(ty::BoundTy) -> Ty<'tcx>,\n-              H: FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::Const<'tcx>,\n+    where\n+        F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n+        G: FnMut(ty::BoundTy) -> Ty<'tcx>,\n+        H: FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::Const<'tcx>,\n     {\n         BoundVarReplacer {\n             tcx,\n@@ -460,7 +465,9 @@ impl<'a, 'gcx, 'tcx> BoundVarReplacer<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for BoundVarReplacer<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> { self.tcx }\n+    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> {\n+        self.tcx\n+        }\n \n     fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n         self.current_index.shift_in(1);\n@@ -741,7 +748,9 @@ impl Shifter<'gcx, 'tcx> {\n }\n \n impl TypeFolder<'gcx, 'tcx> for Shifter<'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> { self.tcx }\n+    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> {\n+        self.tcx\n+        }\n \n     fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n         self.current_index.shift_in(1);\n@@ -820,7 +829,7 @@ impl TypeFolder<'gcx, 'tcx> for Shifter<'gcx, 'tcx> {\n pub fn shift_region<'gcx, 'tcx>(\n     tcx: TyCtxt<'gcx, 'tcx>,\n     region: ty::Region<'tcx>,\n-    amount: u32\n+    amount: u32,\n ) -> ty::Region<'tcx> {\n     match region {\n         ty::ReLateBound(debruijn, br) if amount > 0 => {\n@@ -832,22 +841,20 @@ pub fn shift_region<'gcx, 'tcx>(\n     }\n }\n \n-pub fn shift_vars<'gcx, 'tcx, T>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n-    value: &T,\n-    amount: u32\n-) -> T where T: TypeFoldable<'tcx> {\n+pub fn shift_vars<'gcx, 'tcx, T>(tcx: TyCtxt<'gcx, 'tcx>, value: &T, amount: u32) -> T\n+where\n+    T: TypeFoldable<'tcx>,\n+{\n     debug!(\"shift_vars(value={:?}, amount={})\",\n            value, amount);\n \n     value.fold_with(&mut Shifter::new(tcx, amount, Direction::In))\n }\n \n-pub fn shift_out_vars<'gcx, 'tcx, T>(\n-    tcx: TyCtxt<'gcx, 'tcx>,\n-    value: &T,\n-    amount: u32\n-) -> T where T: TypeFoldable<'tcx> {\n+pub fn shift_out_vars<'gcx, 'tcx, T>(tcx: TyCtxt<'gcx, 'tcx>, value: &T, amount: u32) -> T\n+where\n+    T: TypeFoldable<'tcx>,\n+{\n     debug!(\"shift_out_vars(value={:?}, amount={})\",\n            value, amount);\n "}, {"sha": "023460096a882438158c10be28a9dbdaca94d184", "filename": "src/librustc/ty/inhabitedness/def_id_forest.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -52,17 +52,14 @@ impl<'gcx, 'tcx> DefIdForest {\n     }\n \n     /// Tests whether the forest contains a given DefId.\n-    pub fn contains(&self,\n-                    tcx: TyCtxt<'gcx, 'tcx>,\n-                    id: DefId) -> bool\n-    {\n+    pub fn contains(&self, tcx: TyCtxt<'gcx, 'tcx>, id: DefId) -> bool {\n         self.root_ids.iter().any(|root_id| tcx.is_descendant_of(id, *root_id))\n     }\n \n     /// Calculate the intersection of a collection of forests.\n-    pub fn intersection<I>(tcx: TyCtxt<'gcx, 'tcx>,\n-                           iter: I) -> DefIdForest\n-            where I: IntoIterator<Item=DefIdForest>\n+    pub fn intersection<I>(tcx: TyCtxt<'gcx, 'tcx>, iter: I) -> DefIdForest\n+    where\n+        I: IntoIterator<Item = DefIdForest>,\n     {\n         let mut iter = iter.into_iter();\n         let mut ret = if let Some(first) = iter.next() {\n@@ -97,9 +94,9 @@ impl<'gcx, 'tcx> DefIdForest {\n     }\n \n     /// Calculate the union of a collection of forests.\n-    pub fn union<I>(tcx: TyCtxt<'gcx, 'tcx>,\n-                    iter: I) -> DefIdForest\n-            where I: IntoIterator<Item=DefIdForest>\n+    pub fn union<I>(tcx: TyCtxt<'gcx, 'tcx>, iter: I) -> DefIdForest\n+    where\n+        I: IntoIterator<Item = DefIdForest>,\n     {\n         let mut ret = DefIdForest::empty();\n         let mut next_ret = SmallVec::new();"}, {"sha": "b9e34e0cabc65bb6abfdba305a1b59b7a21028f6", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -108,11 +108,7 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n \n impl<'gcx, 'tcx> AdtDef {\n     /// Calculate the forest of DefIds from which this adt is visibly uninhabited.\n-    fn uninhabited_from(\n-        &self,\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-        substs: SubstsRef<'tcx>) -> DefIdForest\n-    {\n+    fn uninhabited_from(&self, tcx: TyCtxt<'gcx, 'tcx>, substs: SubstsRef<'tcx>) -> DefIdForest {\n         // Non-exhaustive ADTs from other crates are always considered inhabited.\n         if self.is_variant_list_non_exhaustive() && !self.did.is_local() {\n             DefIdForest::empty()\n@@ -130,8 +126,8 @@ impl<'gcx, 'tcx> VariantDef {\n         &self,\n         tcx: TyCtxt<'gcx, 'tcx>,\n         substs: SubstsRef<'tcx>,\n-        adt_kind: AdtKind) -> DefIdForest\n-    {\n+        adt_kind: AdtKind,\n+    ) -> DefIdForest {\n         let is_enum = match adt_kind {\n             // For now, `union`s are never considered uninhabited.\n             // The precise semantics of inhabitedness with respect to unions is currently undecided.\n@@ -182,8 +178,7 @@ impl<'gcx, 'tcx> FieldDef {\n \n impl<'gcx, 'tcx> TyS<'tcx> {\n     /// Calculate the forest of DefIds from which this type is visibly uninhabited.\n-    fn uninhabited_from(&self, tcx: TyCtxt<'gcx, 'tcx>) -> DefIdForest\n-    {\n+    fn uninhabited_from(&self, tcx: TyCtxt<'gcx, 'tcx>) -> DefIdForest {\n         match self.sty {\n             Adt(def, substs) => def.uninhabited_from(tcx, substs),\n "}, {"sha": "16df0da88207b232d9f6fef22fd562d30201268a", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 20, "deletions": 31, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -43,10 +43,7 @@ pub enum InstanceDef<'tcx> {\n }\n \n impl<'tcx> Instance<'tcx> {\n-    pub fn ty(&self,\n-              tcx: TyCtxt<'tcx, 'tcx>)\n-              -> Ty<'tcx>\n-    {\n+    pub fn ty(&self, tcx: TyCtxt<'tcx, 'tcx>) -> Ty<'tcx> {\n         let ty = tcx.type_of(self.def.def_id());\n         tcx.subst_and_normalize_erasing_regions(\n             self.substs,\n@@ -140,10 +137,7 @@ impl<'tcx> InstanceDef<'tcx> {\n         tcx.get_attrs(self.def_id())\n     }\n \n-    pub fn is_inline(\n-        &self,\n-        tcx: TyCtxt<'tcx, 'tcx>\n-    ) -> bool {\n+    pub fn is_inline(&self, tcx: TyCtxt<'tcx, 'tcx>) -> bool {\n         use crate::hir::map::DefPathData;\n         let def_id = match *self {\n             ty::InstanceDef::Item(def_id) => def_id,\n@@ -156,10 +150,7 @@ impl<'tcx> InstanceDef<'tcx> {\n         }\n     }\n \n-    pub fn requires_local(\n-        &self,\n-        tcx: TyCtxt<'tcx, 'tcx>\n-    ) -> bool {\n+    pub fn requires_local(&self, tcx: TyCtxt<'tcx, 'tcx>) -> bool {\n         if self.is_inline(tcx) {\n             return true\n         }\n@@ -245,10 +236,12 @@ impl<'b, 'tcx> Instance<'tcx> {\n     /// Presuming that coherence and type-check have succeeded, if this method is invoked\n     /// in a monomorphic context (i.e., like during codegen), then it is guaranteed to return\n     /// `Some`.\n-    pub fn resolve(tcx: TyCtxt<'tcx, 'tcx>,\n-                   param_env: ty::ParamEnv<'tcx>,\n-                   def_id: DefId,\n-                   substs: SubstsRef<'tcx>) -> Option<Instance<'tcx>> {\n+    pub fn resolve(\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        def_id: DefId,\n+        substs: SubstsRef<'tcx>,\n+    ) -> Option<Instance<'tcx>> {\n         debug!(\"resolve(def_id={:?}, substs={:?})\", def_id, substs);\n         let result = if let Some(trait_def_id) = tcx.trait_of_item(def_id) {\n             debug!(\" => associated item, attempting to find impl in param_env {:#?}\", param_env);\n@@ -297,10 +290,12 @@ impl<'b, 'tcx> Instance<'tcx> {\n         result\n     }\n \n-    pub fn resolve_for_vtable(tcx: TyCtxt<'tcx, 'tcx>,\n-                              param_env: ty::ParamEnv<'tcx>,\n-                              def_id: DefId,\n-                              substs: SubstsRef<'tcx>) -> Option<Instance<'tcx>> {\n+    pub fn resolve_for_vtable(\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        def_id: DefId,\n+        substs: SubstsRef<'tcx>,\n+    ) -> Option<Instance<'tcx>> {\n         debug!(\"resolve(def_id={:?}, substs={:?})\", def_id, substs);\n         let fn_sig = tcx.fn_sig(def_id);\n         let is_vtable_shim =\n@@ -320,9 +315,8 @@ impl<'b, 'tcx> Instance<'tcx> {\n         tcx: TyCtxt<'tcx, 'tcx>,\n         def_id: DefId,\n         substs: ty::ClosureSubsts<'tcx>,\n-        requested_kind: ty::ClosureKind)\n-        -> Instance<'tcx>\n-    {\n+        requested_kind: ty::ClosureKind,\n+    ) -> Instance<'tcx> {\n         let actual_kind = substs.closure_kind(def_id, tcx);\n \n         match needs_fn_once_adapter_shim(actual_kind, requested_kind) {\n@@ -331,11 +325,7 @@ impl<'b, 'tcx> Instance<'tcx> {\n         }\n     }\n \n-    pub fn resolve_drop_in_place(\n-        tcx: TyCtxt<'tcx, 'tcx>,\n-        ty: Ty<'tcx>)\n-        -> ty::Instance<'tcx>\n-    {\n+    pub fn resolve_drop_in_place(tcx: TyCtxt<'tcx, 'tcx>, ty: Ty<'tcx>) -> ty::Instance<'tcx> {\n         let def_id = tcx.require_lang_item(DropInPlaceFnLangItem);\n         let substs = tcx.intern_substs(&[ty.into()]);\n         Instance::resolve(tcx, ty::ParamEnv::reveal_all(), def_id, substs).unwrap()\n@@ -344,9 +334,8 @@ impl<'b, 'tcx> Instance<'tcx> {\n     pub fn fn_once_adapter_instance(\n         tcx: TyCtxt<'tcx, 'tcx>,\n         closure_did: DefId,\n-        substs: ty::ClosureSubsts<'tcx>)\n-        -> Instance<'tcx>\n-    {\n+        substs: ty::ClosureSubsts<'tcx>,\n+    ) -> Instance<'tcx> {\n         debug!(\"fn_once_adapter_shim({:?}, {:?})\",\n                closure_did,\n                substs);"}, {"sha": "efbae81a5dd524e87c217bb0057b0212e6d04e1a", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -28,17 +28,16 @@ use rustc_target::abi::call::{\n     ArgAttribute, ArgAttributes, ArgType, Conv, FnType, IgnoreMode, PassMode, Reg, RegKind\n };\n \n-\n-\n pub trait IntegerExt {\n     fn to_ty<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>, signed: bool) -> Ty<'tcx>;\n     fn from_attr<C: HasDataLayout>(cx: &C, ity: attr::IntType) -> Integer;\n-    fn repr_discr<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                            ty: Ty<'tcx>,\n-                            repr: &ReprOptions,\n-                            min: i128,\n-                            max: i128)\n-                            -> (Integer, bool);\n+    fn repr_discr<'tcx>(\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        ty: Ty<'tcx>,\n+        repr: &ReprOptions,\n+        min: i128,\n+        max: i128,\n+    ) -> (Integer, bool);\n }\n \n impl IntegerExt for Integer {\n@@ -77,12 +76,13 @@ impl IntegerExt for Integer {\n     /// signed discriminant range and #[repr] attribute.\n     /// N.B.: u128 values above i128::MAX will be treated as signed, but\n     /// that shouldn't affect anything, other than maybe debuginfo.\n-    fn repr_discr<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                            ty: Ty<'tcx>,\n-                            repr: &ReprOptions,\n-                            min: i128,\n-                            max: i128)\n-                            -> (Integer, bool) {\n+    fn repr_discr<'tcx>(\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        ty: Ty<'tcx>,\n+        repr: &ReprOptions,\n+        min: i128,\n+        max: i128,\n+    ) -> (Integer, bool) {\n         // Theoretically, negative values could be larger in unsigned representation\n         // than the unsigned representation of the signed minimum. However, if there\n         // are any negative values, the only valid unsigned representation is u128\n@@ -171,10 +171,10 @@ impl<'tcx> fmt::Display for LayoutError<'tcx> {\n     }\n }\n \n-fn layout_raw<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                        query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n-                        -> Result<&'tcx LayoutDetails, LayoutError<'tcx>>\n-{\n+fn layout_raw<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n+) -> Result<&'tcx LayoutDetails, LayoutError<'tcx>> {\n     ty::tls::with_related_context(tcx, move |icx| {\n         let rec_limit = *tcx.sess.recursion_limit.get();\n         let (param_env, ty) = query.into_parts();\n@@ -1604,10 +1604,11 @@ pub enum SizeSkeleton<'tcx> {\n }\n \n impl<'tcx> SizeSkeleton<'tcx> {\n-    pub fn compute(ty: Ty<'tcx>,\n-                   tcx: TyCtxt<'tcx, 'tcx>,\n-                   param_env: ty::ParamEnv<'tcx>)\n-                   -> Result<SizeSkeleton<'tcx>, LayoutError<'tcx>> {\n+    pub fn compute(\n+        ty: Ty<'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> Result<SizeSkeleton<'tcx>, LayoutError<'tcx>> {\n         debug_assert!(!ty.has_infer_types());\n \n         // First try computing a static layout."}, {"sha": "71955764e100b40aefda439a784c307db88115d5", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 67, "deletions": 73, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -957,11 +957,11 @@ impl<'gcx, 'tcx> Generics {\n         false\n     }\n \n-    pub fn region_param(&'tcx self,\n-                        param: &EarlyBoundRegion,\n-                        tcx: TyCtxt<'gcx, 'tcx>)\n-                        -> &'tcx GenericParamDef\n-    {\n+    pub fn region_param(\n+        &'tcx self,\n+        param: &EarlyBoundRegion,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+    ) -> &'tcx GenericParamDef {\n         if let Some(index) = param.index.checked_sub(self.parent_count as u32) {\n             let param = &self.params[index as usize];\n             match param.kind {\n@@ -975,10 +975,11 @@ impl<'gcx, 'tcx> Generics {\n     }\n \n     /// Returns the `GenericParamDef` associated with this `ParamTy`.\n-    pub fn type_param(&'tcx self,\n-                      param: &ParamTy,\n-                      tcx: TyCtxt<'gcx, 'tcx>)\n-                      -> &'tcx GenericParamDef {\n+    pub fn type_param(\n+        &'tcx self,\n+        param: &ParamTy,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+    ) -> &'tcx GenericParamDef {\n         if let Some(index) = param.index.checked_sub(self.parent_count as u32) {\n             let param = &self.params[index as usize];\n             match param.kind {\n@@ -992,10 +993,11 @@ impl<'gcx, 'tcx> Generics {\n     }\n \n     /// Returns the `ConstParameterDef` associated with this `ParamConst`.\n-    pub fn const_param(&'tcx self,\n-                       param: &ParamConst,\n-                       tcx: TyCtxt<'gcx, 'tcx>)\n-                       -> &GenericParamDef {\n+    pub fn const_param(\n+        &'tcx self,\n+        param: &ParamConst,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+    ) -> &GenericParamDef {\n         if let Some(index) = param.index.checked_sub(self.parent_count as u32) {\n             let param = &self.params[index as usize];\n             match param.kind {\n@@ -1020,23 +1022,32 @@ impl<'tcx> serialize::UseSpecializedEncodable for GenericPredicates<'tcx> {}\n impl<'tcx> serialize::UseSpecializedDecodable for GenericPredicates<'tcx> {}\n \n impl<'gcx, 'tcx> GenericPredicates<'tcx> {\n-    pub fn instantiate(&self, tcx: TyCtxt<'gcx, 'tcx>, substs: SubstsRef<'tcx>)\n-                       -> InstantiatedPredicates<'tcx> {\n+    pub fn instantiate(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        substs: SubstsRef<'tcx>,\n+    ) -> InstantiatedPredicates<'tcx> {\n         let mut instantiated = InstantiatedPredicates::empty();\n         self.instantiate_into(tcx, &mut instantiated, substs);\n         instantiated\n     }\n \n-    pub fn instantiate_own(&self, tcx: TyCtxt<'gcx, 'tcx>, substs: SubstsRef<'tcx>)\n-                           -> InstantiatedPredicates<'tcx> {\n+    pub fn instantiate_own(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        substs: SubstsRef<'tcx>,\n+    ) -> InstantiatedPredicates<'tcx> {\n         InstantiatedPredicates {\n             predicates: self.predicates.iter().map(|(p, _)| p.subst(tcx, substs)).collect(),\n         }\n     }\n \n-    fn instantiate_into(&self, tcx: TyCtxt<'gcx, 'tcx>,\n-                        instantiated: &mut InstantiatedPredicates<'tcx>,\n-                        substs: SubstsRef<'tcx>) {\n+    fn instantiate_into(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        instantiated: &mut InstantiatedPredicates<'tcx>,\n+        substs: SubstsRef<'tcx>,\n+    ) {\n         if let Some(def_id) = self.parent {\n             tcx.predicates_of(def_id).instantiate_into(tcx, instantiated, substs);\n         }\n@@ -1045,25 +1056,28 @@ impl<'gcx, 'tcx> GenericPredicates<'tcx> {\n         );\n     }\n \n-    pub fn instantiate_identity(&self, tcx: TyCtxt<'gcx, 'tcx>)\n-                                -> InstantiatedPredicates<'tcx> {\n+    pub fn instantiate_identity(&self, tcx: TyCtxt<'gcx, 'tcx>) -> InstantiatedPredicates<'tcx> {\n         let mut instantiated = InstantiatedPredicates::empty();\n         self.instantiate_identity_into(tcx, &mut instantiated);\n         instantiated\n     }\n \n-    fn instantiate_identity_into(&self, tcx: TyCtxt<'gcx, 'tcx>,\n-                                 instantiated: &mut InstantiatedPredicates<'tcx>) {\n+    fn instantiate_identity_into(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        instantiated: &mut InstantiatedPredicates<'tcx>,\n+    ) {\n         if let Some(def_id) = self.parent {\n             tcx.predicates_of(def_id).instantiate_identity_into(tcx, instantiated);\n         }\n         instantiated.predicates.extend(self.predicates.iter().map(|&(p, _)| p))\n     }\n \n-    pub fn instantiate_supertrait(&self, tcx: TyCtxt<'gcx, 'tcx>,\n-                                  poly_trait_ref: &ty::PolyTraitRef<'tcx>)\n-                                  -> InstantiatedPredicates<'tcx>\n-    {\n+    pub fn instantiate_supertrait(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        poly_trait_ref: &ty::PolyTraitRef<'tcx>,\n+    ) -> InstantiatedPredicates<'tcx> {\n         assert_eq!(self.parent, None);\n         InstantiatedPredicates {\n             predicates: self.predicates.iter().map(|(pred, _)| {\n@@ -1134,10 +1148,11 @@ impl<'gcx, 'tcx> Predicate<'tcx> {\n     /// poly-trait-ref holds. This is slightly different from a normal\n     /// substitution in terms of what happens with bound regions. See\n     /// lengthy comment below for details.\n-    pub fn subst_supertrait(&self, tcx: TyCtxt<'gcx, 'tcx>,\n-                            trait_ref: &ty::PolyTraitRef<'tcx>)\n-                            -> ty::Predicate<'tcx>\n-    {\n+    pub fn subst_supertrait(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        trait_ref: &ty::PolyTraitRef<'tcx>,\n+    ) -> ty::Predicate<'tcx> {\n         // The interaction between HRTB and supertraits is not entirely\n         // obvious. Let me walk you (and myself) through an example.\n         //\n@@ -2140,7 +2155,6 @@ impl ReprOptions {\n     pub fn inhibit_union_abi_opt(&self) -> bool {\n         self.c()\n     }\n-\n }\n \n impl<'gcx, 'tcx> AdtDef {\n@@ -2150,7 +2164,7 @@ impl<'gcx, 'tcx> AdtDef {\n         did: DefId,\n         kind: AdtKind,\n         variants: IndexVec<VariantIdx, VariantDef>,\n-        repr: ReprOptions\n+        repr: ReprOptions,\n     ) -> Self {\n         debug!(\"AdtDef::new({:?}, {:?}, {:?}, {:?})\", did, kind, variants, repr);\n         let mut flags = AdtFlags::NO_ADT_FLAGS;\n@@ -2427,10 +2441,11 @@ impl<'gcx, 'tcx> AdtDef {\n     /// discriminant (the last one before the requested variant),\n     /// assuming there are no constant-evaluation errors there.\n     #[inline]\n-    pub fn discriminant_for_variant(&self,\n-                                    tcx: TyCtxt<'gcx, 'tcx>,\n-                                    variant_index: VariantIdx)\n-                                    -> Discr<'tcx> {\n+    pub fn discriminant_for_variant(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        variant_index: VariantIdx,\n+    ) -> Discr<'tcx> {\n         let (val, offset) = self.discriminant_def_for_variant(variant_index);\n         let explicit_value = val\n             .and_then(|expr_did| self.eval_explicit_discr(tcx, expr_did))\n@@ -2483,10 +2498,7 @@ impl<'gcx, 'tcx> AdtDef {\n         tcx.adt_sized_constraint(self.did).0\n     }\n \n-    fn sized_constraint_for_ty(&self,\n-                               tcx: TyCtxt<'tcx, 'tcx>,\n-                               ty: Ty<'tcx>)\n-                               -> Vec<Ty<'tcx>> {\n+    fn sized_constraint_for_ty(&self, tcx: TyCtxt<'tcx, 'tcx>, ty: Ty<'tcx>) -> Vec<Ty<'tcx>> {\n         let result = match ty.sty {\n             Bool | Char | Int(..) | Uint(..) | Float(..) |\n             RawPtr(..) | Ref(..) | FnDef(..) | FnPtr(_) |\n@@ -2763,9 +2775,7 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     /// Returns an iterator of the `DefId`s for all body-owners in this\n     /// crate. If you would prefer to iterate over the bodies\n     /// themselves, you can do `self.hir().krate().body_ids.iter()`.\n-    pub fn body_owners(\n-        self,\n-    ) -> impl Iterator<Item = DefId> + Captures<'gcx> + 'tcx {\n+    pub fn body_owners(self) -> impl Iterator<Item = DefId> + Captures<'gcx> + 'tcx {\n         self.hir().krate()\n                   .body_ids\n                   .iter()\n@@ -2889,10 +2899,7 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n         })\n     }\n \n-    pub fn associated_items(\n-        self,\n-        def_id: DefId,\n-    ) -> AssocItemsIterator<'gcx, 'tcx> {\n+    pub fn associated_items(self, def_id: DefId) -> AssocItemsIterator<'gcx, 'tcx> {\n         // Ideally, we would use `-> impl Iterator` here, but it falls\n         // afoul of the conservative \"capture [restrictions]\" we put\n         // in place, so we use a hand-written iterator.\n@@ -3176,9 +3183,7 @@ pub struct AdtSizedConstraint<'tcx>(pub &'tcx [Ty<'tcx>]);\n ///       such.\n ///     - a Error, if a type contained itself. The representability\n ///       check should catch this case.\n-fn adt_sized_constraint<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                  def_id: DefId)\n-                                  -> AdtSizedConstraint<'tcx> {\n+fn adt_sized_constraint<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> AdtSizedConstraint<'tcx> {\n     let def = tcx.adt_def(def_id);\n \n     let result = tcx.mk_type_list(def.variants.iter().flat_map(|v| {\n@@ -3192,9 +3197,7 @@ fn adt_sized_constraint<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n     AdtSizedConstraint(result)\n }\n \n-fn associated_item_def_ids<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                     def_id: DefId)\n-                                     -> &'tcx [DefId] {\n+fn associated_item_def_ids<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> &'tcx [DefId] {\n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let item = tcx.hir().expect_item_by_hir_id(id);\n     match item.node {\n@@ -3247,10 +3250,7 @@ pub fn is_impl_trait_defn(tcx: TyCtxt<'_, '_>, def_id: DefId) -> Option<DefId> {\n }\n \n /// See `ParamEnv` struct definition for details.\n-fn param_env<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                       def_id: DefId)\n-                       -> ParamEnv<'tcx>\n-{\n+fn param_env<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> ParamEnv<'tcx> {\n     // The param_env of an impl Trait type is its defining function's param_env\n     if let Some(parent) = is_impl_trait_defn(tcx, def_id) {\n         return param_env(tcx, parent);\n@@ -3285,28 +3285,25 @@ fn param_env<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n     traits::normalize_param_env_or_error(tcx, def_id, unnormalized_env, cause)\n }\n \n-fn crate_disambiguator<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                 crate_num: CrateNum) -> CrateDisambiguator {\n+fn crate_disambiguator<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, crate_num: CrateNum) -> CrateDisambiguator {\n     assert_eq!(crate_num, LOCAL_CRATE);\n     tcx.sess.local_crate_disambiguator()\n }\n \n-fn original_crate_name<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                 crate_num: CrateNum) -> Symbol {\n+fn original_crate_name<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, crate_num: CrateNum) -> Symbol {\n     assert_eq!(crate_num, LOCAL_CRATE);\n     tcx.crate_name.clone()\n }\n \n-fn crate_hash<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                        crate_num: CrateNum)\n-                        -> Svh {\n+fn crate_hash<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, crate_num: CrateNum) -> Svh {\n     assert_eq!(crate_num, LOCAL_CRATE);\n     tcx.hir().crate_hash\n }\n \n-fn instance_def_size_estimate<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                        instance_def: InstanceDef<'tcx>)\n-                                        -> usize {\n+fn instance_def_size_estimate<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    instance_def: InstanceDef<'tcx>,\n+) -> usize {\n     match instance_def {\n         InstanceDef::Item(..) |\n         InstanceDef::DropGlue(..) => {\n@@ -3321,10 +3318,7 @@ fn instance_def_size_estimate<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n /// If `def_id` is an issue 33140 hack impl, returns its self type; otherwise, returns `None`.\n ///\n /// See [`ImplOverlapKind::Issue33140`] for more details.\n-fn issue33140_self_ty<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                def_id: DefId)\n-                                -> Option<Ty<'tcx>>\n-{\n+fn issue33140_self_ty<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Option<Ty<'tcx>> {\n     debug!(\"issue33140_self_ty({:?})\", def_id);\n \n     let trait_ref = tcx.impl_trait_ref(def_id).unwrap_or_else(|| {"}, {"sha": "bd5f33eea7bc529d7f53045545cc954bb3fcc8d9", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -54,14 +54,12 @@ pub(crate) trait QueryDescription<'tcx>: QueryAccessors<'tcx> {\n         false\n     }\n \n-    fn try_load_from_disk(_: TyCtxt<'tcx, 'tcx>,\n-                          _: SerializedDepNodeIndex)\n-                          -> Option<Self::Value> {\n+    fn try_load_from_disk(_: TyCtxt<'tcx, 'tcx>, _: SerializedDepNodeIndex) -> Option<Self::Value> {\n         bug!(\"QueryDescription::load_from_disk() called for an unsupported query.\")\n     }\n }\n \n-impl<'tcx, M: QueryAccessors<'tcx, Key=DefId>> QueryDescription<'tcx> for M {\n+impl<'tcx, M: QueryAccessors<'tcx, Key = DefId>> QueryDescription<'tcx> for M {\n     default fn describe(tcx: TyCtxt<'_, '_>, def_id: DefId) -> Cow<'static, str> {\n         if !tcx.sess.verbose() {\n             format!(\"processing `{}`\", tcx.def_path_str(def_id)).into()"}, {"sha": "f300d82e372e9c079c884df879129c4191a79d46", "filename": "src/librustc/ty/query/job.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -340,7 +340,7 @@ fn connected_to_root<'tcx>(\n fn pick_query<'a, 'tcx, T, F: Fn(&T) -> (Span, Lrc<QueryJob<'tcx>>)>(\n     tcx: TyCtxt<'tcx, '_>,\n     queries: &'a [T],\n-    f: F\n+    f: F,\n ) -> &'a T {\n     // Deterministically pick an entry point\n     // FIXME: Sort this instead\n@@ -366,7 +366,7 @@ fn pick_query<'a, 'tcx, T, F: Fn(&T) -> (Span, Lrc<QueryJob<'tcx>>)>(\n fn remove_cycle<'tcx>(\n     jobs: &mut Vec<Lrc<QueryJob<'tcx>>>,\n     wakelist: &mut Vec<Lrc<QueryWaiter<'tcx>>>,\n-    tcx: TyCtxt<'tcx, '_>\n+    tcx: TyCtxt<'tcx, '_>,\n ) -> bool {\n     let mut visited = FxHashSet::default();\n     let mut stack = Vec::new();"}, {"sha": "af13bbc24efd96099bbdbfd9d7382810972a1c6f", "filename": "src/librustc/ty/query/keys.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -136,7 +136,7 @@ impl<'tcx> Key for (&'tcx ty::Const<'tcx>, mir::Field) {\n     }\n }\n \n-impl<'tcx> Key for ty::PolyTraitRef<'tcx>{\n+impl<'tcx> Key for ty::PolyTraitRef<'tcx> {\n     fn query_crate(&self) -> CrateNum {\n         self.def_id().krate\n     }"}, {"sha": "bc28396a6f9f89601212977b50bcc2fc3b08d3af", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 77, "deletions": 60, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -156,12 +156,14 @@ impl<'sess> OnDiskCache<'sess> {\n         }\n     }\n \n-    pub fn serialize<'tcx, E>(&self,\n-                                  tcx: TyCtxt<'tcx, 'tcx>,\n-                                  encoder: &mut E)\n-                                  -> Result<(), E::Error>\n-        where E: ty_codec::TyEncoder\n-     {\n+    pub fn serialize<'tcx, E>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        encoder: &mut E,\n+    ) -> Result<(), E::Error>\n+    where\n+        E: ty_codec::TyEncoder,\n+    {\n         // Serializing the DepGraph should not modify it:\n         tcx.dep_graph.with_ignore(|| {\n             // Allocate SourceFileIndices\n@@ -326,10 +328,11 @@ impl<'sess> OnDiskCache<'sess> {\n     }\n \n     /// Loads a diagnostic emitted during the previous compilation session.\n-    pub fn load_diagnostics<'tcx>(&self,\n-                                      tcx: TyCtxt<'tcx, 'tcx>,\n-                                      dep_node_index: SerializedDepNodeIndex)\n-                                      -> Vec<Diagnostic> {\n+    pub fn load_diagnostics<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        dep_node_index: SerializedDepNodeIndex,\n+    ) -> Vec<Diagnostic> {\n         let diagnostics: Option<EncodedDiagnostics> = self.load_indexed(\n             tcx,\n             dep_node_index,\n@@ -354,11 +357,13 @@ impl<'sess> OnDiskCache<'sess> {\n \n     /// Returns the cached query result if there is something in the cache for\n     /// the given `SerializedDepNodeIndex`; otherwise returns `None`.\n-    pub fn try_load_query_result<'tcx, T>(&self,\n-                                          tcx: TyCtxt<'tcx, 'tcx>,\n-                                          dep_node_index: SerializedDepNodeIndex)\n-                                          -> Option<T>\n-        where T: Decodable\n+    pub fn try_load_query_result<'tcx, T>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        dep_node_index: SerializedDepNodeIndex,\n+    ) -> Option<T>\n+    where\n+        T: Decodable,\n     {\n         self.load_indexed(tcx,\n                           dep_node_index,\n@@ -382,14 +387,15 @@ impl<'sess> OnDiskCache<'sess> {\n         x.extend(Into::<Vec<_>>::into(diagnostics));\n     }\n \n-    fn load_indexed<'tcx, T>(&self,\n-                             tcx: TyCtxt<'tcx, 'tcx>,\n-                             dep_node_index: SerializedDepNodeIndex,\n-                             index: &FxHashMap<SerializedDepNodeIndex,\n-                                               AbsoluteBytePos>,\n-                             debug_tag: &'static str)\n-                             -> Option<T>\n-        where T: Decodable\n+    fn load_indexed<'tcx, T>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        dep_node_index: SerializedDepNodeIndex,\n+        index: &FxHashMap<SerializedDepNodeIndex, AbsoluteBytePos>,\n+        debug_tag: &'static str,\n+    ) -> Option<T>\n+    where\n+        T: Decodable,\n     {\n         let pos = index.get(&dep_node_index).cloned()?;\n \n@@ -423,10 +429,10 @@ impl<'sess> OnDiskCache<'sess> {\n     // current-session-CrateNum. There might be CrateNums from the previous\n     // Session that don't occur in the current one. For these, the mapping\n     // maps to None.\n-    fn compute_cnum_map(tcx: TyCtxt<'_, '_>,\n-                        prev_cnums: &[(u32, String, CrateDisambiguator)])\n-                        -> IndexVec<CrateNum, Option<CrateNum>>\n-    {\n+    fn compute_cnum_map(\n+        tcx: TyCtxt<'_, '_>,\n+        prev_cnums: &[(u32, String, CrateDisambiguator)],\n+    ) -> IndexVec<CrateNum, Option<CrateNum>> {\n         tcx.dep_graph.with_ignore(|| {\n             let current_cnums = tcx.all_crate_nums(LOCAL_CRATE).iter().map(|&cnum| {\n                 let crate_name = tcx.original_crate_name(cnum)\n@@ -524,7 +530,6 @@ fn decode_tagged<'a, 'tcx, D, T, V>(decoder: &mut D,\n     Ok(value)\n }\n \n-\n impl<'a, 'tcx> ty_codec::TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n     #[inline]\n     fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n@@ -583,7 +588,7 @@ impl<'a, 'tcx> ty_codec::TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n     }\n }\n \n-implement_ty_decoder!( CacheDecoder<'a, 'tcx> );\n+implement_ty_decoder!(CacheDecoder<'a, 'tcx>);\n \n impl<'a, 'tcx> SpecializedDecoder<interpret::AllocId> for CacheDecoder<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<interpret::AllocId, Self::Error> {\n@@ -724,7 +729,8 @@ impl<'a, 'tcx> SpecializedDecoder<Fingerprint> for CacheDecoder<'a, 'tcx> {\n }\n \n impl<'a, 'tcx, T: Decodable> SpecializedDecoder<mir::ClearCrossCrate<T>>\n-for CacheDecoder<'a, 'tcx> {\n+    for CacheDecoder<'a, 'tcx>\n+{\n     #[inline]\n     fn specialized_decode(&mut self) -> Result<mir::ClearCrossCrate<T>, Self::Error> {\n         let discr = u8::decode(self)?;\n@@ -757,7 +763,8 @@ struct CacheEncoder<'a, 'tcx, E: ty_codec::TyEncoder> {\n }\n \n impl<'a, 'tcx, E> CacheEncoder<'a, 'tcx, E>\n-    where E: 'a + ty_codec::TyEncoder\n+where\n+    E: 'a + ty_codec::TyEncoder,\n {\n     fn source_file_index(&mut self, source_file: Lrc<SourceFile>) -> SourceFileIndex {\n         self.file_to_file_index[&(&*source_file as *const SourceFile)]\n@@ -784,7 +791,8 @@ impl<'a, 'tcx, E> CacheEncoder<'a, 'tcx, E>\n }\n \n impl<'a, 'tcx, E> SpecializedEncoder<interpret::AllocId> for CacheEncoder<'a, 'tcx, E>\n-    where E: 'a + ty_codec::TyEncoder\n+where\n+    E: 'a + ty_codec::TyEncoder,\n {\n     fn specialized_encode(&mut self, alloc_id: &interpret::AllocId) -> Result<(), Self::Error> {\n         use std::collections::hash_map::Entry;\n@@ -803,7 +811,8 @@ impl<'a, 'tcx, E> SpecializedEncoder<interpret::AllocId> for CacheEncoder<'a, 't\n }\n \n impl<'a, 'tcx, E> SpecializedEncoder<Span> for CacheEncoder<'a, 'tcx, E>\n-    where E: 'a + ty_codec::TyEncoder\n+where\n+    E: 'a + ty_codec::TyEncoder,\n {\n     fn specialized_encode(&mut self, span: &Span) -> Result<(), Self::Error> {\n \n@@ -859,7 +868,8 @@ impl<'a, 'tcx, E> SpecializedEncoder<Span> for CacheEncoder<'a, 'tcx, E>\n }\n \n impl<'a, 'tcx, E> ty_codec::TyEncoder for CacheEncoder<'a, 'tcx, E>\n-    where E: 'a + ty_codec::TyEncoder\n+where\n+    E: 'a + ty_codec::TyEncoder,\n {\n     #[inline]\n     fn position(&self) -> usize {\n@@ -868,7 +878,8 @@ impl<'a, 'tcx, E> ty_codec::TyEncoder for CacheEncoder<'a, 'tcx, E>\n }\n \n impl<'a, 'tcx, E> SpecializedEncoder<CrateNum> for CacheEncoder<'a, 'tcx, E>\n-    where E: 'a + ty_codec::TyEncoder\n+where\n+    E: 'a + ty_codec::TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self, cnum: &CrateNum) -> Result<(), Self::Error> {\n@@ -877,7 +888,8 @@ impl<'a, 'tcx, E> SpecializedEncoder<CrateNum> for CacheEncoder<'a, 'tcx, E>\n }\n \n impl<'a, 'tcx, E> SpecializedEncoder<Ty<'tcx>> for CacheEncoder<'a, 'tcx, E>\n-    where E: 'a + ty_codec::TyEncoder\n+where\n+    E: 'a + ty_codec::TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self, ty: &Ty<'tcx>) -> Result<(), Self::Error> {\n@@ -886,9 +898,9 @@ impl<'a, 'tcx, E> SpecializedEncoder<Ty<'tcx>> for CacheEncoder<'a, 'tcx, E>\n     }\n }\n \n-impl<'a, 'tcx, E> SpecializedEncoder<ty::GenericPredicates<'tcx>>\n-    for CacheEncoder<'a, 'tcx, E>\n-    where E: 'a + ty_codec::TyEncoder\n+impl<'a, 'tcx, E> SpecializedEncoder<ty::GenericPredicates<'tcx>> for CacheEncoder<'a, 'tcx, E>\n+where\n+    E: 'a + ty_codec::TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self,\n@@ -900,7 +912,8 @@ impl<'a, 'tcx, E> SpecializedEncoder<ty::GenericPredicates<'tcx>>\n }\n \n impl<'a, 'tcx, E> SpecializedEncoder<hir::HirId> for CacheEncoder<'a, 'tcx, E>\n-    where E: 'a + ty_codec::TyEncoder\n+where\n+    E: 'a + ty_codec::TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self, id: &hir::HirId) -> Result<(), Self::Error> {\n@@ -916,9 +929,9 @@ impl<'a, 'tcx, E> SpecializedEncoder<hir::HirId> for CacheEncoder<'a, 'tcx, E>\n     }\n }\n \n-\n impl<'a, 'tcx, E> SpecializedEncoder<DefId> for CacheEncoder<'a, 'tcx, E>\n-    where E: 'a + ty_codec::TyEncoder\n+where\n+    E: 'a + ty_codec::TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self, id: &DefId) -> Result<(), Self::Error> {\n@@ -928,7 +941,8 @@ impl<'a, 'tcx, E> SpecializedEncoder<DefId> for CacheEncoder<'a, 'tcx, E>\n }\n \n impl<'a, 'tcx, E> SpecializedEncoder<LocalDefId> for CacheEncoder<'a, 'tcx, E>\n-    where E: 'a + ty_codec::TyEncoder\n+where\n+    E: 'a + ty_codec::TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self, id: &LocalDefId) -> Result<(), Self::Error> {\n@@ -937,7 +951,8 @@ impl<'a, 'tcx, E> SpecializedEncoder<LocalDefId> for CacheEncoder<'a, 'tcx, E>\n }\n \n impl<'a, 'tcx, E> SpecializedEncoder<DefIndex> for CacheEncoder<'a, 'tcx, E>\n-    where E: 'a + ty_codec::TyEncoder\n+where\n+    E: 'a + ty_codec::TyEncoder,\n {\n     fn specialized_encode(&mut self, _: &DefIndex) -> Result<(), Self::Error> {\n         bug!(\"Encoding DefIndex without context.\")\n@@ -947,7 +962,8 @@ impl<'a, 'tcx, E> SpecializedEncoder<DefIndex> for CacheEncoder<'a, 'tcx, E>\n // NodeIds are not stable across compilation sessions, so we store them in their\n // HirId representation. This allows use to map them to the current NodeId.\n impl<'a, 'tcx, E> SpecializedEncoder<NodeId> for CacheEncoder<'a, 'tcx, E>\n-    where E: 'a + ty_codec::TyEncoder\n+where\n+    E: 'a + ty_codec::TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self, node_id: &NodeId) -> Result<(), Self::Error> {\n@@ -956,18 +972,16 @@ impl<'a, 'tcx, E> SpecializedEncoder<NodeId> for CacheEncoder<'a, 'tcx, E>\n     }\n }\n \n-impl<'a, 'tcx> SpecializedEncoder<Fingerprint>\n-for CacheEncoder<'a, 'tcx, opaque::Encoder>\n-{\n+impl<'a, 'tcx> SpecializedEncoder<Fingerprint> for CacheEncoder<'a, 'tcx, opaque::Encoder> {\n     fn specialized_encode(&mut self, f: &Fingerprint) -> Result<(), Self::Error> {\n         f.encode_opaque(&mut self.encoder)\n     }\n }\n \n-impl<'a, 'tcx, E, T> SpecializedEncoder<mir::ClearCrossCrate<T>>\n-for CacheEncoder<'a, 'tcx, E>\n-    where E: 'a + ty_codec::TyEncoder,\n-          T: Encodable,\n+impl<'a, 'tcx, E, T> SpecializedEncoder<mir::ClearCrossCrate<T>> for CacheEncoder<'a, 'tcx, E>\n+where\n+    E: 'a + ty_codec::TyEncoder,\n+    T: Encodable,\n {\n     #[inline]\n     fn specialized_encode(&mut self,\n@@ -994,7 +1008,8 @@ macro_rules! encoder_methods {\n }\n \n impl<'a, 'tcx, E> Encoder for CacheEncoder<'a, 'tcx, E>\n-    where E: 'a + ty_codec::TyEncoder\n+where\n+    E: 'a + ty_codec::TyEncoder,\n {\n     type Error = E::Error;\n \n@@ -1064,13 +1079,15 @@ impl<'a> SpecializedDecoder<IntEncodedWithFixedSize> for opaque::Decoder<'a> {\n     }\n }\n \n-fn encode_query_results<'a, 'tcx, Q, E>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                              encoder: &mut CacheEncoder<'a, 'tcx, E>,\n-                                              query_result_index: &mut EncodedQueryResultIndex)\n-                                              -> Result<(), E::Error>\n-    where Q: super::config::QueryDescription<'tcx>,\n-          E: 'a + TyEncoder,\n-          Q::Value: Encodable,\n+fn encode_query_results<'a, 'tcx, Q, E>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    encoder: &mut CacheEncoder<'a, 'tcx, E>,\n+    query_result_index: &mut EncodedQueryResultIndex,\n+) -> Result<(), E::Error>\n+where\n+    Q: super::config::QueryDescription<'tcx>,\n+    E: 'a + TyEncoder,\n+    Q::Value: Encodable,\n {\n     let desc = &format!(\"encode_query_results for {}\",\n         unsafe { ::std::intrinsics::type_name::<Q>() });"}, {"sha": "662d653b2a173ad2b755a32fd26a3803f2cde79d", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -256,10 +256,10 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n         self,\n         job: Lrc<QueryJob<'gcx>>,\n         diagnostics: Option<&Lock<ThinVec<Diagnostic>>>,\n-        compute: F)\n-    -> R\n+        compute: F,\n+    ) -> R\n     where\n-        F: for<'lcx> FnOnce(TyCtxt<'gcx, 'lcx>) -> R\n+        F: for<'lcx> FnOnce(TyCtxt<'gcx, 'lcx>) -> R,\n     {\n         // The TyCtxt stored in TLS has the same global interner lifetime\n         // as `self`, so we use `with_related_context` to relate the 'gcx lifetimes\n@@ -285,9 +285,8 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     #[cold]\n     pub(super) fn report_cycle(\n         self,\n-        CycleError { usage, cycle: stack }: CycleError<'gcx>\n-    ) -> DiagnosticBuilder<'tcx>\n-    {\n+        CycleError { usage, cycle: stack }: CycleError<'gcx>,\n+    ) -> DiagnosticBuilder<'tcx> {\n         assert!(!stack.is_empty());\n \n         let fix_span = |span: Span, query: &Query<'gcx>| {\n@@ -1148,10 +1147,7 @@ macro_rules! define_provider_struct {\n /// then `force_from_dep_node()` should not fail for it. Otherwise, you can just\n /// add it to the \"We don't have enough information to reconstruct...\" group in\n /// the match below.\n-pub fn force_from_dep_node<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    dep_node: &DepNode\n-) -> bool {\n+pub fn force_from_dep_node<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, dep_node: &DepNode) -> bool {\n     use crate::dep_graph::RecoverKey;\n \n     // We must avoid ever having to call force_from_dep_node() for a"}, {"sha": "2bd38ff70d4c57eb56aa5098a383758767668bab", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 274, "deletions": 151, "changes": 425, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -22,7 +22,7 @@ pub enum Cause {\n     ExistentialRegionBound, // relating an existential region bound\n }\n \n-pub trait TypeRelation<'gcx: 'tcx, 'tcx> : Sized {\n+pub trait TypeRelation<'gcx: 'tcx, 'tcx>: Sized {\n     fn tcx(&self) -> TyCtxt<'gcx, 'tcx>;\n \n     /// Returns a static string we can use for printouts.\n@@ -94,20 +94,26 @@ pub trait TypeRelation<'gcx: 'tcx, 'tcx> : Sized {\n }\n \n pub trait Relate<'tcx>: TypeFoldable<'tcx> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R, a: &Self, b: &Self)\n-                           -> RelateResult<'tcx, Self>\n-        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a;\n+    fn relate<'a, 'gcx, R>(relation: &mut R, a: &Self, b: &Self) -> RelateResult<'tcx, Self>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a;\n }\n \n ///////////////////////////////////////////////////////////////////////////\n // Relate impls\n \n impl<'tcx> Relate<'tcx> for ty::TypeAndMut<'tcx> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &ty::TypeAndMut<'tcx>,\n-                           b: &ty::TypeAndMut<'tcx>)\n-                           -> RelateResult<'tcx, ty::TypeAndMut<'tcx>>\n-        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &ty::TypeAndMut<'tcx>,\n+        b: &ty::TypeAndMut<'tcx>,\n+    ) -> RelateResult<'tcx, ty::TypeAndMut<'tcx>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         debug!(\"{}.mts({:?}, {:?})\",\n                relation.tag(),\n@@ -127,12 +133,16 @@ impl<'tcx> Relate<'tcx> for ty::TypeAndMut<'tcx> {\n     }\n }\n \n-pub fn relate_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n-                                        variances: Option<&[ty::Variance]>,\n-                                        a_subst: SubstsRef<'tcx>,\n-                                        b_subst: SubstsRef<'tcx>)\n-                                        -> RelateResult<'tcx, SubstsRef<'tcx>>\n-    where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+pub fn relate_substs<'a, 'gcx, 'tcx, R>(\n+    relation: &mut R,\n+    variances: Option<&[ty::Variance]>,\n+    a_subst: SubstsRef<'tcx>,\n+    b_subst: SubstsRef<'tcx>,\n+) -> RelateResult<'tcx, SubstsRef<'tcx>>\n+where\n+    R: TypeRelation<'gcx, 'tcx>,\n+    'gcx: 'a + 'tcx,\n+    'tcx: 'a,\n {\n     let tcx = relation.tcx();\n \n@@ -145,11 +155,15 @@ pub fn relate_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n }\n \n impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &ty::FnSig<'tcx>,\n-                           b: &ty::FnSig<'tcx>)\n-                           -> RelateResult<'tcx, ty::FnSig<'tcx>>\n-        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &ty::FnSig<'tcx>,\n+        b: &ty::FnSig<'tcx>,\n+    ) -> RelateResult<'tcx, ty::FnSig<'tcx>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         let tcx = relation.tcx();\n \n@@ -185,11 +199,15 @@ impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n }\n \n impl<'tcx> Relate<'tcx> for ast::Unsafety {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &ast::Unsafety,\n-                           b: &ast::Unsafety)\n-                           -> RelateResult<'tcx, ast::Unsafety>\n-        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &ast::Unsafety,\n+        b: &ast::Unsafety,\n+    ) -> RelateResult<'tcx, ast::Unsafety>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         if a != b {\n             Err(TypeError::UnsafetyMismatch(expected_found(relation, a, b)))\n@@ -200,11 +218,15 @@ impl<'tcx> Relate<'tcx> for ast::Unsafety {\n }\n \n impl<'tcx> Relate<'tcx> for abi::Abi {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &abi::Abi,\n-                           b: &abi::Abi)\n-                           -> RelateResult<'tcx, abi::Abi>\n-        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &abi::Abi,\n+        b: &abi::Abi,\n+    ) -> RelateResult<'tcx, abi::Abi>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         if a == b {\n             Ok(*a)\n@@ -215,11 +237,15 @@ impl<'tcx> Relate<'tcx> for abi::Abi {\n }\n \n impl<'tcx> Relate<'tcx> for ty::ProjectionTy<'tcx> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &ty::ProjectionTy<'tcx>,\n-                           b: &ty::ProjectionTy<'tcx>)\n-                           -> RelateResult<'tcx, ty::ProjectionTy<'tcx>>\n-        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &ty::ProjectionTy<'tcx>,\n+        b: &ty::ProjectionTy<'tcx>,\n+    ) -> RelateResult<'tcx, ty::ProjectionTy<'tcx>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         if a.item_def_id != b.item_def_id {\n             Err(TypeError::ProjectionMismatched(\n@@ -235,11 +261,15 @@ impl<'tcx> Relate<'tcx> for ty::ProjectionTy<'tcx> {\n }\n \n impl<'tcx> Relate<'tcx> for ty::ExistentialProjection<'tcx> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &ty::ExistentialProjection<'tcx>,\n-                           b: &ty::ExistentialProjection<'tcx>)\n-                           -> RelateResult<'tcx, ty::ExistentialProjection<'tcx>>\n-        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &ty::ExistentialProjection<'tcx>,\n+        b: &ty::ExistentialProjection<'tcx>,\n+    ) -> RelateResult<'tcx, ty::ExistentialProjection<'tcx>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         if a.item_def_id != b.item_def_id {\n             Err(TypeError::ProjectionMismatched(\n@@ -257,11 +287,15 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialProjection<'tcx> {\n }\n \n impl<'tcx> Relate<'tcx> for Vec<ty::PolyExistentialProjection<'tcx>> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &Vec<ty::PolyExistentialProjection<'tcx>>,\n-                           b: &Vec<ty::PolyExistentialProjection<'tcx>>)\n-                           -> RelateResult<'tcx, Vec<ty::PolyExistentialProjection<'tcx>>>\n-        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &Vec<ty::PolyExistentialProjection<'tcx>>,\n+        b: &Vec<ty::PolyExistentialProjection<'tcx>>,\n+    ) -> RelateResult<'tcx, Vec<ty::PolyExistentialProjection<'tcx>>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         // To be compatible, `a` and `b` must be for precisely the\n         // same set of traits and item names. We always require that\n@@ -280,11 +314,15 @@ impl<'tcx> Relate<'tcx> for Vec<ty::PolyExistentialProjection<'tcx>> {\n }\n \n impl<'tcx> Relate<'tcx> for ty::TraitRef<'tcx> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &ty::TraitRef<'tcx>,\n-                           b: &ty::TraitRef<'tcx>)\n-                           -> RelateResult<'tcx, ty::TraitRef<'tcx>>\n-        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &ty::TraitRef<'tcx>,\n+        b: &ty::TraitRef<'tcx>,\n+    ) -> RelateResult<'tcx, ty::TraitRef<'tcx>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         // Different traits cannot be related\n         if a.def_id != b.def_id {\n@@ -297,11 +335,15 @@ impl<'tcx> Relate<'tcx> for ty::TraitRef<'tcx> {\n }\n \n impl<'tcx> Relate<'tcx> for ty::ExistentialTraitRef<'tcx> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &ty::ExistentialTraitRef<'tcx>,\n-                           b: &ty::ExistentialTraitRef<'tcx>)\n-                           -> RelateResult<'tcx, ty::ExistentialTraitRef<'tcx>>\n-        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &ty::ExistentialTraitRef<'tcx>,\n+        b: &ty::ExistentialTraitRef<'tcx>,\n+    ) -> RelateResult<'tcx, ty::ExistentialTraitRef<'tcx>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         // Different traits cannot be related\n         if a.def_id != b.def_id {\n@@ -323,11 +365,15 @@ TupleStructTypeFoldableImpl! {\n }\n \n impl<'tcx> Relate<'tcx> for GeneratorWitness<'tcx> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &GeneratorWitness<'tcx>,\n-                           b: &GeneratorWitness<'tcx>)\n-                           -> RelateResult<'tcx, GeneratorWitness<'tcx>>\n-        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &GeneratorWitness<'tcx>,\n+        b: &GeneratorWitness<'tcx>,\n+    ) -> RelateResult<'tcx, GeneratorWitness<'tcx>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         assert_eq!(a.0.len(), b.0.len());\n         let tcx = relation.tcx();\n@@ -337,11 +383,15 @@ impl<'tcx> Relate<'tcx> for GeneratorWitness<'tcx> {\n }\n \n impl<'tcx> Relate<'tcx> for Ty<'tcx> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &Ty<'tcx>,\n-                           b: &Ty<'tcx>)\n-                           -> RelateResult<'tcx, Ty<'tcx>>\n-        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &Ty<'tcx>,\n+        b: &Ty<'tcx>,\n+    ) -> RelateResult<'tcx, Ty<'tcx>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         relation.tys(a, b)\n     }\n@@ -350,11 +400,15 @@ impl<'tcx> Relate<'tcx> for Ty<'tcx> {\n /// The main \"type relation\" routine. Note that this does not handle\n /// inference artifacts, so you should filter those out before calling\n /// it.\n-pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n-                                           a: Ty<'tcx>,\n-                                           b: Ty<'tcx>)\n-                                           -> RelateResult<'tcx, Ty<'tcx>>\n-    where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(\n+    relation: &mut R,\n+    a: Ty<'tcx>,\n+    b: Ty<'tcx>,\n+) -> RelateResult<'tcx, Ty<'tcx>>\n+where\n+    R: TypeRelation<'gcx, 'tcx>,\n+    'gcx: 'a + 'tcx,\n+    'tcx: 'a,\n {\n     let tcx = relation.tcx();\n     debug!(\"super_relate_tys: a={:?} b={:?}\", a, b);\n@@ -553,10 +607,12 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n pub fn super_relate_consts<'a, 'gcx, 'tcx, R>(\n     relation: &mut R,\n     a: &'tcx ty::Const<'tcx>,\n-    b: &'tcx ty::Const<'tcx>\n+    b: &'tcx ty::Const<'tcx>,\n ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>>\n where\n-    R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    R: TypeRelation<'gcx, 'tcx>,\n+    'gcx: 'a + 'tcx,\n+    'tcx: 'a,\n {\n     let tcx = relation.tcx();\n \n@@ -632,12 +688,12 @@ where\n }\n \n impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &Self,\n-                           b: &Self)\n-        -> RelateResult<'tcx, Self>\n-            where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a {\n-\n+    fn relate<'a, 'gcx, R>(relation: &mut R, a: &Self, b: &Self) -> RelateResult<'tcx, Self>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n+    {\n         if a.len() != b.len() {\n             return Err(TypeError::ExistentialMismatch(expected_found(relation, a, b)));\n         }\n@@ -657,79 +713,103 @@ impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n }\n \n impl<'tcx> Relate<'tcx> for ty::ClosureSubsts<'tcx> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &ty::ClosureSubsts<'tcx>,\n-                           b: &ty::ClosureSubsts<'tcx>)\n-                           -> RelateResult<'tcx, ty::ClosureSubsts<'tcx>>\n-        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &ty::ClosureSubsts<'tcx>,\n+        b: &ty::ClosureSubsts<'tcx>,\n+    ) -> RelateResult<'tcx, ty::ClosureSubsts<'tcx>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         let substs = relate_substs(relation, None, a.substs, b.substs)?;\n         Ok(ty::ClosureSubsts { substs })\n     }\n }\n \n impl<'tcx> Relate<'tcx> for ty::GeneratorSubsts<'tcx> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &ty::GeneratorSubsts<'tcx>,\n-                           b: &ty::GeneratorSubsts<'tcx>)\n-                           -> RelateResult<'tcx, ty::GeneratorSubsts<'tcx>>\n-        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &ty::GeneratorSubsts<'tcx>,\n+        b: &ty::GeneratorSubsts<'tcx>,\n+    ) -> RelateResult<'tcx, ty::GeneratorSubsts<'tcx>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         let substs = relate_substs(relation, None, a.substs, b.substs)?;\n         Ok(ty::GeneratorSubsts { substs })\n     }\n }\n \n impl<'tcx> Relate<'tcx> for SubstsRef<'tcx> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &SubstsRef<'tcx>,\n-                           b: &SubstsRef<'tcx>)\n-                           -> RelateResult<'tcx, SubstsRef<'tcx>>\n-        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &SubstsRef<'tcx>,\n+        b: &SubstsRef<'tcx>,\n+    ) -> RelateResult<'tcx, SubstsRef<'tcx>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         relate_substs(relation, None, a, b)\n     }\n }\n \n impl<'tcx> Relate<'tcx> for ty::Region<'tcx> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &ty::Region<'tcx>,\n-                           b: &ty::Region<'tcx>)\n-                           -> RelateResult<'tcx, ty::Region<'tcx>>\n-        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &ty::Region<'tcx>,\n+        b: &ty::Region<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Region<'tcx>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         relation.regions(*a, *b)\n     }\n }\n \n impl<'tcx> Relate<'tcx> for &'tcx ty::Const<'tcx> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &&'tcx ty::Const<'tcx>,\n-                           b: &&'tcx ty::Const<'tcx>)\n-                           -> RelateResult<'tcx, &'tcx ty::Const<'tcx>>\n-        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &&'tcx ty::Const<'tcx>,\n+        b: &&'tcx ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         relation.consts(*a, *b)\n     }\n }\n \n impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for ty::Binder<T> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &ty::Binder<T>,\n-                           b: &ty::Binder<T>)\n-                           -> RelateResult<'tcx, ty::Binder<T>>\n-        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &ty::Binder<T>,\n+        b: &ty::Binder<T>,\n+    ) -> RelateResult<'tcx, ty::Binder<T>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         relation.binders(a, b)\n     }\n }\n \n impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for Rc<T> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &Rc<T>,\n-                           b: &Rc<T>)\n-                           -> RelateResult<'tcx, Rc<T>>\n-        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(relation: &mut R, a: &Rc<T>, b: &Rc<T>) -> RelateResult<'tcx, Rc<T>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         let a: &T = a;\n         let b: &T = b;\n@@ -738,11 +818,11 @@ impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for Rc<T> {\n }\n \n impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for Box<T> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &Box<T>,\n-                           b: &Box<T>)\n-                           -> RelateResult<'tcx, Box<T>>\n-        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(relation: &mut R, a: &Box<T>, b: &Box<T>) -> RelateResult<'tcx, Box<T>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         let a: &T = a;\n         let b: &T = b;\n@@ -754,10 +834,12 @@ impl<'tcx> Relate<'tcx> for Kind<'tcx> {\n     fn relate<'a, 'gcx, R>(\n         relation: &mut R,\n         a: &Kind<'tcx>,\n-        b: &Kind<'tcx>\n+        b: &Kind<'tcx>,\n     ) -> RelateResult<'tcx, Kind<'tcx>>\n     where\n-        R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a,\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         match (a.unpack(), b.unpack()) {\n             (UnpackedKind::Lifetime(a_lt), UnpackedKind::Lifetime(b_lt)) => {\n@@ -786,9 +868,12 @@ impl<'tcx> Relate<'tcx> for ty::TraitPredicate<'tcx> {\n     fn relate<'a, 'gcx, R>(\n         relation: &mut R,\n         a: &ty::TraitPredicate<'tcx>,\n-        b: &ty::TraitPredicate<'tcx>\n+        b: &ty::TraitPredicate<'tcx>,\n     ) -> RelateResult<'tcx, ty::TraitPredicate<'tcx>>\n-        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'tcx,\n+        'tcx: 'a,\n     {\n         Ok(ty::TraitPredicate {\n             trait_ref: relation.relate(&a.trait_ref, &b.trait_ref)?,\n@@ -802,7 +887,10 @@ impl<'tcx> Relate<'tcx> for ty::ProjectionPredicate<'tcx> {\n         a: &ty::ProjectionPredicate<'tcx>,\n         b: &ty::ProjectionPredicate<'tcx>,\n     ) -> RelateResult<'tcx, ty::ProjectionPredicate<'tcx>>\n-        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'tcx,\n+        'tcx: 'a,\n     {\n         Ok(ty::ProjectionPredicate {\n             projection_ty: relation.relate(&a.projection_ty, &b.projection_ty)?,\n@@ -815,9 +903,12 @@ impl<'tcx> Relate<'tcx> for traits::WhereClause<'tcx> {\n     fn relate<'a, 'gcx, R>(\n         relation: &mut R,\n         a: &traits::WhereClause<'tcx>,\n-        b: &traits::WhereClause<'tcx>\n+        b: &traits::WhereClause<'tcx>,\n     ) -> RelateResult<'tcx, traits::WhereClause<'tcx>>\n-        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'tcx,\n+        'tcx: 'a,\n     {\n         use crate::traits::WhereClause::*;\n         match (a, b) {\n@@ -852,9 +943,12 @@ impl<'tcx> Relate<'tcx> for traits::WellFormed<'tcx> {\n     fn relate<'a, 'gcx, R>(\n         relation: &mut R,\n         a: &traits::WellFormed<'tcx>,\n-        b: &traits::WellFormed<'tcx>\n+        b: &traits::WellFormed<'tcx>,\n     ) -> RelateResult<'tcx, traits::WellFormed<'tcx>>\n-        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'tcx,\n+        'tcx: 'a,\n     {\n         use crate::traits::WellFormed::*;\n         match (a, b) {\n@@ -869,9 +963,12 @@ impl<'tcx> Relate<'tcx> for traits::FromEnv<'tcx> {\n     fn relate<'a, 'gcx, R>(\n         relation: &mut R,\n         a: &traits::FromEnv<'tcx>,\n-        b: &traits::FromEnv<'tcx>\n+        b: &traits::FromEnv<'tcx>,\n     ) -> RelateResult<'tcx, traits::FromEnv<'tcx>>\n-        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'tcx,\n+        'tcx: 'a,\n     {\n         use crate::traits::FromEnv::*;\n         match (a, b) {\n@@ -886,9 +983,12 @@ impl<'tcx> Relate<'tcx> for traits::DomainGoal<'tcx> {\n     fn relate<'a, 'gcx, R>(\n         relation: &mut R,\n         a: &traits::DomainGoal<'tcx>,\n-        b: &traits::DomainGoal<'tcx>\n+        b: &traits::DomainGoal<'tcx>,\n     ) -> RelateResult<'tcx, traits::DomainGoal<'tcx>>\n-        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'tcx,\n+        'tcx: 'a,\n     {\n         use crate::traits::DomainGoal::*;\n         match (a, b) {\n@@ -909,9 +1009,12 @@ impl<'tcx> Relate<'tcx> for traits::Goal<'tcx> {\n     fn relate<'a, 'gcx, R>(\n         relation: &mut R,\n         a: &traits::Goal<'tcx>,\n-        b: &traits::Goal<'tcx>\n+        b: &traits::Goal<'tcx>,\n     ) -> RelateResult<'tcx, traits::Goal<'tcx>>\n-        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'tcx,\n+        'tcx: 'a,\n     {\n         use crate::traits::GoalKind::*;\n         match (a, b) {\n@@ -955,9 +1058,12 @@ impl<'tcx> Relate<'tcx> for traits::Goals<'tcx> {\n     fn relate<'a, 'gcx, R>(\n         relation: &mut R,\n         a: &traits::Goals<'tcx>,\n-        b: &traits::Goals<'tcx>\n+        b: &traits::Goals<'tcx>,\n     ) -> RelateResult<'tcx, traits::Goals<'tcx>>\n-        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'tcx,\n+        'tcx: 'a,\n     {\n         if a.len() != b.len() {\n             return Err(TypeError::Mismatch);\n@@ -973,9 +1079,12 @@ impl<'tcx> Relate<'tcx> for traits::Clause<'tcx> {\n     fn relate<'a, 'gcx, R>(\n         relation: &mut R,\n         a: &traits::Clause<'tcx>,\n-        b: &traits::Clause<'tcx>\n+        b: &traits::Clause<'tcx>,\n     ) -> RelateResult<'tcx, traits::Clause<'tcx>>\n-        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'tcx,\n+        'tcx: 'a,\n     {\n         use crate::traits::Clause::*;\n         match (a, b) {\n@@ -998,9 +1107,12 @@ impl<'tcx> Relate<'tcx> for traits::Clauses<'tcx> {\n     fn relate<'a, 'gcx, R>(\n         relation: &mut R,\n         a: &traits::Clauses<'tcx>,\n-        b: &traits::Clauses<'tcx>\n+        b: &traits::Clauses<'tcx>,\n     ) -> RelateResult<'tcx, traits::Clauses<'tcx>>\n-        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'tcx,\n+        'tcx: 'a,\n     {\n         if a.len() != b.len() {\n             return Err(TypeError::Mismatch);\n@@ -1016,9 +1128,12 @@ impl<'tcx> Relate<'tcx> for traits::ProgramClause<'tcx> {\n     fn relate<'a, 'gcx, R>(\n         relation: &mut R,\n         a: &traits::ProgramClause<'tcx>,\n-        b: &traits::ProgramClause<'tcx>\n+        b: &traits::ProgramClause<'tcx>,\n     ) -> RelateResult<'tcx, traits::ProgramClause<'tcx>>\n-        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'tcx,\n+        'tcx: 'a,\n     {\n         Ok(traits::ProgramClause {\n             goal: relation.relate(&a.goal, &b.goal)?,\n@@ -1032,9 +1147,12 @@ impl<'tcx> Relate<'tcx> for traits::Environment<'tcx> {\n     fn relate<'a, 'gcx, R>(\n         relation: &mut R,\n         a: &traits::Environment<'tcx>,\n-        b: &traits::Environment<'tcx>\n+        b: &traits::Environment<'tcx>,\n     ) -> RelateResult<'tcx, traits::Environment<'tcx>>\n-        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'tcx,\n+        'tcx: 'a,\n     {\n         Ok(traits::Environment {\n             clauses: relation.relate(&a.clauses, &b.clauses)?,\n@@ -1043,14 +1161,18 @@ impl<'tcx> Relate<'tcx> for traits::Environment<'tcx> {\n }\n \n impl<'tcx, G> Relate<'tcx> for traits::InEnvironment<'tcx, G>\n-    where G: Relate<'tcx>\n+where\n+    G: Relate<'tcx>,\n {\n     fn relate<'a, 'gcx, R>(\n         relation: &mut R,\n         a: &traits::InEnvironment<'tcx, G>,\n-        b: &traits::InEnvironment<'tcx, G>\n+        b: &traits::InEnvironment<'tcx, G>,\n     ) -> RelateResult<'tcx, traits::InEnvironment<'tcx, G>>\n-        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'tcx,\n+        'tcx: 'a,\n     {\n         Ok(traits::InEnvironment {\n             environment: relation.relate(&a.environment, &b.environment)?,\n@@ -1062,11 +1184,12 @@ impl<'tcx, G> Relate<'tcx> for traits::InEnvironment<'tcx, G>\n ///////////////////////////////////////////////////////////////////////////\n // Error handling\n \n-pub fn expected_found<'a, 'gcx, 'tcx, R, T>(relation: &mut R,\n-                                            a: &T,\n-                                            b: &T)\n-                                            -> ExpectedFound<T>\n-    where R: TypeRelation<'gcx, 'tcx>, T: Clone, 'gcx: 'a+'tcx, 'tcx: 'a\n+pub fn expected_found<'a, 'gcx, 'tcx, R, T>(relation: &mut R, a: &T, b: &T) -> ExpectedFound<T>\n+where\n+    R: TypeRelation<'gcx, 'tcx>,\n+    T: Clone,\n+    'gcx: 'a + 'tcx,\n+    'tcx: 'a,\n {\n     expected_found_bool(relation.a_is_expected(), a, b)\n }"}, {"sha": "35c61f83fceb2acc80da43f52affe637be2b14fe", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -450,8 +450,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialPredicate<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::TraitPredicate<'a> {\n     type Lifted = ty::TraitPredicate<'tcx>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>)\n-                             -> Option<ty::TraitPredicate<'tcx>> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<ty::TraitPredicate<'tcx>> {\n         tcx.lift(&self.trait_ref).map(|trait_ref| ty::TraitPredicate {\n             trait_ref,\n         })\n@@ -460,8 +459,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::TraitPredicate<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::SubtypePredicate<'a> {\n     type Lifted = ty::SubtypePredicate<'tcx>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>)\n-                             -> Option<ty::SubtypePredicate<'tcx>> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<ty::SubtypePredicate<'tcx>> {\n         tcx.lift(&(self.a, self.b)).map(|(a, b)| ty::SubtypePredicate {\n             a_is_expected: self.a_is_expected,\n             a,\n@@ -470,7 +468,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::SubtypePredicate<'a> {\n     }\n }\n \n-impl<'tcx, A: Copy+Lift<'tcx>, B: Copy+Lift<'tcx>> Lift<'tcx> for ty::OutlivesPredicate<A, B> {\n+impl<'tcx, A: Copy + Lift<'tcx>, B: Copy + Lift<'tcx>> Lift<'tcx> for ty::OutlivesPredicate<A, B> {\n     type Lifted = ty::OutlivesPredicate<A::Lifted, B::Lifted>;\n     fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&(self.0, self.1)).map(|(a, b)| ty::OutlivesPredicate(a, b))\n@@ -479,8 +477,7 @@ impl<'tcx, A: Copy+Lift<'tcx>, B: Copy+Lift<'tcx>> Lift<'tcx> for ty::OutlivesPr\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionTy<'a> {\n     type Lifted = ty::ProjectionTy<'tcx>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>)\n-                             -> Option<ty::ProjectionTy<'tcx>> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<ty::ProjectionTy<'tcx>> {\n         tcx.lift(&self.substs).map(|substs| {\n             ty::ProjectionTy {\n                 item_def_id: self.item_def_id,\n@@ -492,8 +489,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionTy<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionPredicate<'a> {\n     type Lifted = ty::ProjectionPredicate<'tcx>;\n-    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>)\n-                             -> Option<ty::ProjectionPredicate<'tcx>> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<ty::ProjectionPredicate<'tcx>> {\n         tcx.lift(&(self.projection_ty, self.ty)).map(|(projection_ty, ty)| {\n             ty::ProjectionPredicate {\n                 projection_ty,"}, {"sha": "dc2d96ee8b946cb9f5e5edfaf3079561aa1a225e", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 62, "deletions": 56, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -335,9 +335,11 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     }\n \n     #[inline]\n-    pub fn upvar_tys(self, def_id: DefId, tcx: TyCtxt<'_, '_>) ->\n-        impl Iterator<Item=Ty<'tcx>> + 'tcx\n-    {\n+    pub fn upvar_tys(\n+        self,\n+        def_id: DefId,\n+        tcx: TyCtxt<'_, '_>,\n+    ) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n         let SplitClosureSubsts { upvar_kinds, .. } = self.split(def_id, tcx);\n         upvar_kinds.iter().map(|t| {\n             if let UnpackedKind::Type(ty) = t.unpack() {\n@@ -422,9 +424,11 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n     }\n \n     #[inline]\n-    pub fn upvar_tys(self, def_id: DefId, tcx: TyCtxt<'_, '_>) ->\n-        impl Iterator<Item=Ty<'tcx>> + 'tcx\n-    {\n+    pub fn upvar_tys(\n+        self,\n+        def_id: DefId,\n+        tcx: TyCtxt<'_, '_>,\n+    ) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n         let SplitGeneratorSubsts { upvar_kinds, .. } = self.split(def_id, tcx);\n         upvar_kinds.iter().map(|t| {\n             if let UnpackedKind::Type(ty) = t.unpack() {\n@@ -489,7 +493,10 @@ impl<'gcx, 'tcx> GeneratorSubsts<'tcx> {\n     /// out of range.\n     #[inline]\n     pub fn discriminant_for_variant(\n-        &self, def_id: DefId, tcx: TyCtxt<'gcx, 'tcx>, variant_index: VariantIdx\n+        &self,\n+        def_id: DefId,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        variant_index: VariantIdx,\n     ) -> Discr<'tcx> {\n         // Generators don't support explicit discriminant values, so they are\n         // the same as the variant index.\n@@ -501,8 +508,10 @@ impl<'gcx, 'tcx> GeneratorSubsts<'tcx> {\n     /// variant indices.\n     #[inline]\n     pub fn discriminants(\n-        &'tcx self, def_id: DefId, tcx: TyCtxt<'gcx, 'tcx>\n-    ) -> impl Iterator<Item=(VariantIdx, Discr<'tcx>)> + Captures<'gcx> {\n+        &'tcx self,\n+        def_id: DefId,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+    ) -> impl Iterator<Item = (VariantIdx, Discr<'tcx>)> + Captures<'gcx> {\n         self.variant_range(def_id, tcx).map(move |index| {\n             (index, Discr { val: index.as_usize() as u128, ty: self.discr_ty(tcx) })\n         })\n@@ -533,9 +542,11 @@ impl<'gcx, 'tcx> GeneratorSubsts<'tcx> {\n     /// The locals are grouped by their variant number. Note that some locals may\n     /// be repeated in multiple variants.\n     #[inline]\n-    pub fn state_tys(self, def_id: DefId, tcx: TyCtxt<'gcx, 'tcx>) ->\n-        impl Iterator<Item=impl Iterator<Item=Ty<'tcx>> + Captures<'gcx>>\n-    {\n+    pub fn state_tys(\n+        self,\n+        def_id: DefId,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+    ) -> impl Iterator<Item = impl Iterator<Item = Ty<'tcx>> + Captures<'gcx>> {\n         let layout = tcx.generator_layout(def_id);\n         layout.variant_fields.iter().map(move |variant| {\n             variant.iter().map(move |field| {\n@@ -547,9 +558,11 @@ impl<'gcx, 'tcx> GeneratorSubsts<'tcx> {\n     /// This is the types of the fields of a generator which are not stored in a\n     /// variant.\n     #[inline]\n-    pub fn prefix_tys(self, def_id: DefId, tcx: TyCtxt<'gcx, 'tcx>) ->\n-        impl Iterator<Item=Ty<'tcx>>\n-    {\n+    pub fn prefix_tys(\n+        self,\n+        def_id: DefId,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+    ) -> impl Iterator<Item = Ty<'tcx>> {\n         self.upvar_tys(def_id, tcx)\n     }\n }\n@@ -562,9 +575,11 @@ pub enum UpvarSubsts<'tcx> {\n \n impl<'tcx> UpvarSubsts<'tcx> {\n     #[inline]\n-    pub fn upvar_tys(self, def_id: DefId, tcx: TyCtxt<'_, '_>) ->\n-        impl Iterator<Item=Ty<'tcx>> + 'tcx\n-    {\n+    pub fn upvar_tys(\n+        self,\n+        def_id: DefId,\n+        tcx: TyCtxt<'_, '_>,\n+    ) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n         let upvar_kinds = match self {\n             UpvarSubsts::Closure(substs) => substs.split(def_id, tcx).upvar_kinds,\n             UpvarSubsts::Generator(substs) => substs.split(def_id, tcx).upvar_kinds,\n@@ -607,12 +622,10 @@ impl<'gcx, 'tcx> ExistentialPredicate<'tcx> {\n             (AutoTrait(_), _) => Ordering::Greater,\n         }\n     }\n-\n }\n \n impl<'gcx, 'tcx> Binder<ExistentialPredicate<'tcx>> {\n-    pub fn with_self_ty(&self, tcx: TyCtxt<'gcx, 'tcx>, self_ty: Ty<'tcx>)\n-        -> ty::Predicate<'tcx> {\n+    pub fn with_self_ty(&self, tcx: TyCtxt<'gcx, 'tcx>, self_ty: Ty<'tcx>) -> ty::Predicate<'tcx> {\n         use crate::ty::ToPredicate;\n         match *self.skip_binder() {\n             ExistentialPredicate::Trait(tr) => Binder(tr).with_self_ty(tcx, self_ty).to_predicate(),\n@@ -764,10 +777,11 @@ impl<'tcx> TraitRef<'tcx> {\n         self.substs.types()\n     }\n \n-    pub fn from_method(tcx: TyCtxt<'_, 'tcx>,\n-                       trait_id: DefId,\n-                       substs: SubstsRef<'tcx>)\n-                       -> ty::TraitRef<'tcx> {\n+    pub fn from_method(\n+        tcx: TyCtxt<'_, 'tcx>,\n+        trait_id: DefId,\n+        substs: SubstsRef<'tcx>,\n+    ) -> ty::TraitRef<'tcx> {\n         let defs = tcx.generics_of(trait_id);\n \n         ty::TraitRef {\n@@ -817,9 +831,10 @@ impl<'gcx, 'tcx> ExistentialTraitRef<'tcx> {\n         self.substs.types()\n     }\n \n-    pub fn erase_self_ty(tcx: TyCtxt<'gcx, 'tcx>,\n-                         trait_ref: ty::TraitRef<'tcx>)\n-                         -> ty::ExistentialTraitRef<'tcx> {\n+    pub fn erase_self_ty(\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        trait_ref: ty::TraitRef<'tcx>,\n+    ) -> ty::ExistentialTraitRef<'tcx> {\n         // Assert there is a Self.\n         trait_ref.substs.type_at(0);\n \n@@ -833,8 +848,7 @@ impl<'gcx, 'tcx> ExistentialTraitRef<'tcx> {\n     /// we convert the principal trait-ref into a normal trait-ref,\n     /// you must give *some* self type. A common choice is `mk_err()`\n     /// or some placeholder type.\n-    pub fn with_self_ty(&self, tcx: TyCtxt<'gcx, 'tcx>, self_ty: Ty<'tcx>)\n-        -> ty::TraitRef<'tcx>  {\n+    pub fn with_self_ty(&self, tcx: TyCtxt<'gcx, 'tcx>, self_ty: Ty<'tcx>) -> ty::TraitRef<'tcx> {\n         // otherwise the escaping vars would be captured by the binder\n         // debug_assert!(!self_ty.has_escaping_bound_vars());\n \n@@ -856,9 +870,7 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n     /// we convert the principal trait-ref into a normal trait-ref,\n     /// you must give *some* self type. A common choice is `mk_err()`\n     /// or some placeholder type.\n-    pub fn with_self_ty(&self, tcx: TyCtxt<'_, 'tcx>,\n-                        self_ty: Ty<'tcx>)\n-                        -> ty::PolyTraitRef<'tcx>  {\n+    pub fn with_self_ty(&self, tcx: TyCtxt<'_, 'tcx>, self_ty: Ty<'tcx>) -> ty::PolyTraitRef<'tcx> {\n         self.map_bound(|trait_ref| trait_ref.with_self_ty(tcx, self_ty))\n     }\n }\n@@ -992,7 +1004,9 @@ impl<'tcx> ProjectionTy<'tcx> {\n     /// Construct a `ProjectionTy` by searching the trait from `trait_ref` for the\n     /// associated item named `item_name`.\n     pub fn from_ref_and_name(\n-        tcx: TyCtxt<'_, '_>, trait_ref: ty::TraitRef<'tcx>, item_name: Ident\n+        tcx: TyCtxt<'_, '_>,\n+        trait_ref: ty::TraitRef<'tcx>,\n+        item_name: Ident,\n     ) -> ProjectionTy<'tcx> {\n         let item_def_id = tcx.associated_items(trait_ref.def_id).find(|item| {\n             item.kind == ty::AssocKind::Type &&\n@@ -1421,10 +1435,11 @@ impl<'tcx, 'gcx> ExistentialProjection<'tcx> {\n         }\n     }\n \n-    pub fn with_self_ty(&self, tcx: TyCtxt<'gcx, 'tcx>,\n-                        self_ty: Ty<'tcx>)\n-                        -> ty::ProjectionPredicate<'tcx>\n-    {\n+    pub fn with_self_ty(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        self_ty: Ty<'tcx>,\n+    ) -> ty::ProjectionPredicate<'tcx> {\n         // otherwise the escaping regions would be captured by the binders\n         debug_assert!(!self_ty.has_escaping_bound_vars());\n \n@@ -1439,8 +1454,11 @@ impl<'tcx, 'gcx> ExistentialProjection<'tcx> {\n }\n \n impl<'tcx, 'gcx> PolyExistentialProjection<'tcx> {\n-    pub fn with_self_ty(&self, tcx: TyCtxt<'gcx, 'tcx>, self_ty: Ty<'tcx>)\n-        -> ty::PolyProjectionPredicate<'tcx> {\n+    pub fn with_self_ty(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        self_ty: Ty<'tcx>,\n+    ) -> ty::PolyProjectionPredicate<'tcx> {\n         self.map_bound(|p| p.with_self_ty(tcx, self_ty))\n     }\n \n@@ -2099,7 +2117,7 @@ impl<'gcx, 'tcx> TyS<'tcx> {\n     pub fn discriminant_for_variant(\n         &self,\n         tcx: TyCtxt<'gcx, 'tcx>,\n-        variant_index: VariantIdx\n+        variant_index: VariantIdx,\n     ) -> Option<Discr<'tcx>> {\n         match self.sty {\n             TyKind::Adt(adt, _) => Some(adt.discriminant_for_variant(tcx, variant_index)),\n@@ -2239,11 +2257,7 @@ static_assert_size!(Const<'_>, 40);\n \n impl<'tcx> Const<'tcx> {\n     #[inline]\n-    pub fn from_scalar(\n-        tcx: TyCtxt<'_, 'tcx>,\n-        val: Scalar,\n-        ty: Ty<'tcx>,\n-    ) -> &'tcx Self {\n+    pub fn from_scalar(tcx: TyCtxt<'_, 'tcx>, val: Scalar, ty: Ty<'tcx>) -> &'tcx Self {\n         tcx.mk_const(Self {\n             val: ConstValue::Scalar(val),\n             ty,\n@@ -2279,11 +2293,7 @@ impl<'tcx> Const<'tcx> {\n     }\n \n     #[inline]\n-    pub fn to_bits(\n-        &self,\n-        tcx: TyCtxt<'_, 'tcx>,\n-        ty: ParamEnvAnd<'tcx, Ty<'tcx>>,\n-    ) -> Option<u128> {\n+    pub fn to_bits(&self, tcx: TyCtxt<'_, 'tcx>, ty: ParamEnvAnd<'tcx, Ty<'tcx>>) -> Option<u128> {\n         if self.ty != ty.value {\n             return None;\n         }\n@@ -2324,11 +2334,7 @@ impl<'tcx> Const<'tcx> {\n     }\n \n     #[inline]\n-    pub fn unwrap_bits(\n-        &self,\n-        tcx: TyCtxt<'_, '_>,\n-        ty: ParamEnvAnd<'tcx, Ty<'tcx>>,\n-    ) -> u128 {\n+    pub fn unwrap_bits(&self, tcx: TyCtxt<'_, '_>, ty: ParamEnvAnd<'tcx, Ty<'tcx>>) -> u128 {\n         self.assert_bits(tcx, ty).unwrap_or_else(||\n             bug!(\"expected bits of {}, got {:#?}\", ty.value, self))\n     }"}, {"sha": "a47217138aa1a631a8081fafb7f19d13ef3b1438", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 41, "deletions": 39, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -194,10 +194,7 @@ impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n     /// var bound at index `0`. For types, we use a `BoundVar` index equal to\n     /// the type parameter index. For regions, we use the `BoundRegion::BrNamed`\n     /// variant (which has a `DefId`).\n-    pub fn bound_vars_for_item(\n-        tcx: TyCtxt<'gcx, 'tcx>,\n-        def_id: DefId\n-    ) -> SubstsRef<'tcx> {\n+    pub fn bound_vars_for_item(tcx: TyCtxt<'gcx, 'tcx>, def_id: DefId) -> SubstsRef<'tcx> {\n         Self::for_item(tcx, def_id, |param, _| {\n             match param.kind {\n                 ty::GenericParamDefKind::Type { .. } => {\n@@ -233,11 +230,9 @@ impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n     /// The closures get to observe the `InternalSubsts` as they're\n     /// being built, which can be used to correctly\n     /// substitute defaults of generic parameters.\n-    pub fn for_item<F>(tcx: TyCtxt<'gcx, 'tcx>,\n-                       def_id: DefId,\n-                       mut mk_kind: F)\n-                       -> SubstsRef<'tcx>\n-    where F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>\n+    pub fn for_item<F>(tcx: TyCtxt<'gcx, 'tcx>, def_id: DefId, mut mk_kind: F) -> SubstsRef<'tcx>\n+    where\n+        F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>,\n     {\n         let defs = tcx.generics_of(def_id);\n         let count = defs.count();\n@@ -246,12 +241,14 @@ impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n         tcx.intern_substs(&substs)\n     }\n \n-    pub fn extend_to<F>(&self,\n-                        tcx: TyCtxt<'gcx, 'tcx>,\n-                        def_id: DefId,\n-                        mut mk_kind: F)\n-                        -> SubstsRef<'tcx>\n-    where F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>\n+    pub fn extend_to<F>(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        def_id: DefId,\n+        mut mk_kind: F,\n+    ) -> SubstsRef<'tcx>\n+    where\n+        F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>,\n     {\n         Self::for_item(tcx, def_id, |param, substs| {\n             self.get(param.index as usize)\n@@ -260,11 +257,13 @@ impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n         })\n     }\n \n-    fn fill_item<F>(substs: &mut SmallVec<[Kind<'tcx>; 8]>,\n-                    tcx: TyCtxt<'gcx, 'tcx>,\n-                    defs: &ty::Generics,\n-                    mk_kind: &mut F)\n-    where F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>\n+    fn fill_item<F>(\n+        substs: &mut SmallVec<[Kind<'tcx>; 8]>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        defs: &ty::Generics,\n+        mk_kind: &mut F,\n+    ) where\n+        F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>,\n     {\n         if let Some(def_id) = defs.parent {\n             let parent_defs = tcx.generics_of(def_id);\n@@ -372,16 +371,17 @@ impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n     /// in a different item, with `target_substs` as the base for\n     /// the target impl/trait, with the source child-specific\n     /// parameters (e.g., method parameters) on top of that base.\n-    pub fn rebase_onto(&self, tcx: TyCtxt<'gcx, 'tcx>,\n-                       source_ancestor: DefId,\n-                       target_substs: SubstsRef<'tcx>)\n-                       -> SubstsRef<'tcx> {\n+    pub fn rebase_onto(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        source_ancestor: DefId,\n+        target_substs: SubstsRef<'tcx>,\n+    ) -> SubstsRef<'tcx> {\n         let defs = tcx.generics_of(source_ancestor);\n         tcx.mk_substs(target_substs.iter().chain(&self[defs.params.len()..]).cloned())\n     }\n \n-    pub fn truncate_to(&self, tcx: TyCtxt<'gcx, 'tcx>, generics: &ty::Generics)\n-                       -> SubstsRef<'tcx> {\n+    pub fn truncate_to(&self, tcx: TyCtxt<'gcx, 'tcx>, generics: &ty::Generics) -> SubstsRef<'tcx> {\n         tcx.mk_substs(self.iter().take(generics.count()).cloned())\n     }\n }\n@@ -414,23 +414,25 @@ impl<'tcx> serialize::UseSpecializedDecodable for SubstsRef<'tcx> {}\n // there is more information available (for better errors).\n \n pub trait Subst<'tcx>: Sized {\n-    fn subst<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>,\n-                       substs: &[Kind<'tcx>]) -> Self {\n+    fn subst<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>, substs: &[Kind<'tcx>]) -> Self {\n         self.subst_spanned(tcx, substs, None)\n     }\n \n-    fn subst_spanned<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>,\n-                               substs: &[Kind<'tcx>],\n-                               span: Option<Span>)\n-                               -> Self;\n+    fn subst_spanned<'gcx>(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        substs: &[Kind<'tcx>],\n+        span: Option<Span>,\n+    ) -> Self;\n }\n \n-impl<'tcx, T:TypeFoldable<'tcx>> Subst<'tcx> for T {\n-    fn subst_spanned<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>,\n-                               substs: &[Kind<'tcx>],\n-                               span: Option<Span>)\n-                               -> T\n-    {\n+impl<'tcx, T: TypeFoldable<'tcx>> Subst<'tcx> for T {\n+    fn subst_spanned<'gcx>(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        substs: &[Kind<'tcx>],\n+        span: Option<Span>,\n+    ) -> T {\n         let mut folder = SubstFolder { tcx,\n                                        substs,\n                                        span,\n@@ -444,7 +446,7 @@ impl<'tcx, T:TypeFoldable<'tcx>> Subst<'tcx> for T {\n ///////////////////////////////////////////////////////////////////////////\n // The actual substitution engine itself is a type folder.\n \n-struct SubstFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+struct SubstFolder<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'gcx, 'tcx>,\n     substs: &'a [Kind<'tcx>],\n "}, {"sha": "1f99d97605c792327b1088b017bc2aaf3ea75ee2", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -64,9 +64,11 @@ impl<'gcx, 'tcx> TraitDef {\n         }\n     }\n \n-    pub fn ancestors(&self, tcx: TyCtxt<'gcx, 'tcx>,\n-                     of_impl: DefId)\n-                     -> specialization_graph::Ancestors<'gcx> {\n+    pub fn ancestors(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        of_impl: DefId,\n+    ) -> specialization_graph::Ancestors<'gcx> {\n         specialization_graph::ancestors(tcx, self.def_id, of_impl)\n     }\n }\n@@ -148,9 +150,10 @@ impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n }\n \n // Query provider for `trait_impls_of`.\n-pub(super) fn trait_impls_of_provider<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                                trait_id: DefId)\n-                                                -> &'tcx TraitImpls {\n+pub(super) fn trait_impls_of_provider<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    trait_id: DefId,\n+) -> &'tcx TraitImpls {\n     let mut impls = TraitImpls::default();\n \n     {"}, {"sha": "57319db63404a8619bc331d95ce6e4998bcba73c", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 44, "deletions": 53, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -105,8 +105,11 @@ impl<'tcx> Discr<'tcx> {\n \n pub trait IntTypeExt {\n     fn to_ty<'gcx, 'tcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Ty<'tcx>;\n-    fn disr_incr<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>, val: Option<Discr<'tcx>>)\n-                           -> Option<Discr<'tcx>>;\n+    fn disr_incr<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        val: Option<Discr<'tcx>>,\n+    ) -> Option<Discr<'tcx>>;\n     fn initial_discriminant<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>) -> Discr<'tcx>;\n }\n \n@@ -178,10 +181,11 @@ pub enum Representability {\n }\n \n impl<'tcx> ty::ParamEnv<'tcx> {\n-    pub fn can_type_implement_copy(self,\n-                                       tcx: TyCtxt<'tcx, 'tcx>,\n-                                       self_type: Ty<'tcx>)\n-                                       -> Result<(), CopyImplementationError<'tcx>> {\n+    pub fn can_type_implement_copy(\n+        self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        self_type: Ty<'tcx>,\n+    ) -> Result<(), CopyImplementationError<'tcx>> {\n         // FIXME: (@jroesch) float this code up\n         tcx.infer_ctxt().enter(|infcx| {\n             let (adt, substs) = match self_type.sty {\n@@ -695,11 +699,12 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// does copies even when the type actually doesn't satisfy the\n     /// full requirements for the `Copy` trait (cc #29149) -- this\n     /// winds up being reported as an error during NLL borrow check.\n-    pub fn is_copy_modulo_regions(&'tcx self,\n-                                  tcx: TyCtxt<'tcx, 'tcx>,\n-                                  param_env: ty::ParamEnv<'tcx>,\n-                                  span: Span)\n-                                  -> bool {\n+    pub fn is_copy_modulo_regions(\n+        &'tcx self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        span: Span,\n+    ) -> bool {\n         tcx.at(span).is_copy_raw(param_env.and(self))\n     }\n \n@@ -709,10 +714,11 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// over-approximation in generic contexts, where one can have\n     /// strange rules like `<T as Foo<'static>>::Bar: Sized` that\n     /// actually carry lifetime requirements.\n-    pub fn is_sized(&'tcx self,\n-                    tcx_at: TyCtxtAt<'tcx, 'tcx>,\n-                    param_env: ty::ParamEnv<'tcx>)-> bool\n-    {\n+    pub fn is_sized(\n+        &'tcx self,\n+        tcx_at: TyCtxtAt<'tcx, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> bool {\n         tcx_at.is_sized_raw(param_env.and(self))\n     }\n \n@@ -723,11 +729,12 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// optimization as well as the rules around static values. Note\n     /// that the `Freeze` trait is not exposed to end users and is\n     /// effectively an implementation detail.\n-    pub fn is_freeze(&'tcx self,\n-                     tcx: TyCtxt<'tcx, 'tcx>,\n-                     param_env: ty::ParamEnv<'tcx>,\n-                     span: Span)-> bool\n-    {\n+    pub fn is_freeze(\n+        &'tcx self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        span: Span,\n+    ) -> bool {\n         tcx.at(span).is_freeze_raw(param_env.and(self))\n     }\n \n@@ -738,10 +745,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// (Note that this implies that if `ty` has a destructor attached,\n     /// then `needs_drop` will definitely return `true` for `ty`.)\n     #[inline]\n-    pub fn needs_drop(&'tcx self,\n-                      tcx: TyCtxt<'tcx, 'tcx>,\n-                      param_env: ty::ParamEnv<'tcx>)\n-                      -> bool {\n+    pub fn needs_drop(&'tcx self, tcx: TyCtxt<'tcx, 'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n         tcx.needs_drop_raw(param_env.and(self)).0\n     }\n \n@@ -760,11 +764,7 @@ impl<'tcx> ty::TyS<'tcx> {\n \n     /// Check whether a type is representable. This means it cannot contain unboxed\n     /// structural recursion. This check is needed for structs and enums.\n-    pub fn is_representable(&'tcx self,\n-                            tcx: TyCtxt<'tcx, 'tcx>,\n-                            sp: Span)\n-                            -> Representability\n-    {\n+    pub fn is_representable(&'tcx self, tcx: TyCtxt<'tcx, 'tcx>, sp: Span) -> Representability {\n         // Iterate until something non-representable is found\n         fn fold_repr<It: Iterator<Item=Representability>>(iter: It) -> Representability {\n             iter.fold(Representability::Representable, |r1, r2| {\n@@ -779,12 +779,12 @@ impl<'tcx> ty::TyS<'tcx> {\n         }\n \n         fn are_inner_types_recursive<'tcx>(\n-            tcx: TyCtxt<'tcx, 'tcx>, sp: Span,\n+            tcx: TyCtxt<'tcx, 'tcx>,\n+            sp: Span,\n             seen: &mut Vec<Ty<'tcx>>,\n             representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n-            ty: Ty<'tcx>)\n-            -> Representability\n-        {\n+            ty: Ty<'tcx>,\n+        ) -> Representability {\n             match ty.sty {\n                 Tuple(ref ts) => {\n                     // Find non representable\n@@ -843,8 +843,8 @@ impl<'tcx> ty::TyS<'tcx> {\n             sp: Span,\n             seen: &mut Vec<Ty<'tcx>>,\n             representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n-            ty: Ty<'tcx>) -> Representability\n-        {\n+            ty: Ty<'tcx>,\n+        ) -> Representability {\n             debug!(\"is_type_structurally_recursive: {:?} {:?}\", ty, sp);\n             if let Some(representability) = representable_cache.get(ty) {\n                 debug!(\"is_type_structurally_recursive: {:?} {:?} - (cached) {:?}\",\n@@ -864,8 +864,8 @@ impl<'tcx> ty::TyS<'tcx> {\n             sp: Span,\n             seen: &mut Vec<Ty<'tcx>>,\n             representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n-            ty: Ty<'tcx>) -> Representability\n-        {\n+            ty: Ty<'tcx>,\n+        ) -> Representability {\n             match ty.sty {\n                 Adt(def, _) => {\n                     {\n@@ -937,10 +937,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     }\n }\n \n-fn is_copy_raw<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                         query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n-                         -> bool\n-{\n+fn is_copy_raw<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n     let (param_env, ty) = query.into_parts();\n     let trait_def_id = tcx.require_lang_item(lang_items::CopyTraitLangItem);\n     tcx.infer_ctxt()\n@@ -953,10 +950,7 @@ fn is_copy_raw<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n         ))\n }\n \n-fn is_sized_raw<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                          query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n-                          -> bool\n-{\n+fn is_sized_raw<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n     let (param_env, ty) = query.into_parts();\n     let trait_def_id = tcx.require_lang_item(lang_items::SizedTraitLangItem);\n     tcx.infer_ctxt()\n@@ -969,10 +963,7 @@ fn is_sized_raw<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n         ))\n }\n \n-fn is_freeze_raw<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                           query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n-                           -> bool\n-{\n+fn is_freeze_raw<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n     let (param_env, ty) = query.into_parts();\n     let trait_def_id = tcx.require_lang_item(lang_items::FreezeTraitLangItem);\n     tcx.infer_ctxt()\n@@ -988,10 +979,10 @@ fn is_freeze_raw<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n #[derive(Clone, HashStable)]\n pub struct NeedsDrop(pub bool);\n \n-fn needs_drop_raw<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                            query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n-                            -> NeedsDrop\n-{\n+fn needs_drop_raw<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n+) -> NeedsDrop {\n     let (param_env, ty) = query.into_parts();\n \n     let needs_drop = |ty: Ty<'tcx>| -> bool {"}, {"sha": "1ed88f395a9430d3d7f192c68afda94189bef819", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -510,9 +510,8 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n /// `ty::required_region_bounds`, see that for more information.\n pub fn object_region_bounds<'gcx, 'tcx>(\n     tcx: TyCtxt<'gcx, 'tcx>,\n-    existential_predicates: ty::Binder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>)\n-    -> Vec<ty::Region<'tcx>>\n-{\n+    existential_predicates: ty::Binder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>,\n+) -> Vec<ty::Region<'tcx>> {\n     // Since we don't actually *know* the self type for an object,\n     // this \"open(err)\" serves as a kind of dummy standin -- basically\n     // a placeholder type."}, {"sha": "45a92daab0dfb602101ceefbca6e01c9dfb8cd93", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -179,11 +179,13 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n     fn decl_without_init(&mut self, _id: hir::HirId, _span: Span) { }\n }\n \n-pub fn check_loans<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                     dfcx_loans: &LoanDataFlow<'tcx>,\n-                                     move_data: &move_data::FlowedMoveData<'tcx>,\n-                                     all_loans: &[Loan<'tcx>],\n-                                     body: &hir::Body) {\n+pub fn check_loans<'a, 'tcx>(\n+    bccx: &BorrowckCtxt<'a, 'tcx>,\n+    dfcx_loans: &LoanDataFlow<'tcx>,\n+    move_data: &move_data::FlowedMoveData<'tcx>,\n+    all_loans: &[Loan<'tcx>],\n+    body: &hir::Body,\n+) {\n     debug!(\"check_loans(body id={})\", body.value.hir_id);\n \n     let def_id = bccx.tcx.hir().body_owner_def_id(body.id());"}, {"sha": "e8644d2416db7e8f288d391a7a8652907e97d4d6", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -73,9 +73,7 @@ pub struct AnalysisData<'tcx> {\n     pub move_data: move_data::FlowedMoveData<'tcx>,\n }\n \n-fn borrowck<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, owner_def_id: DefId)\n-    -> &'tcx BorrowCheckResult\n-{\n+fn borrowck<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, owner_def_id: DefId) -> &'tcx BorrowCheckResult {\n     assert!(tcx.use_ast_borrowck() || tcx.migrate_borrowck());\n \n     debug!(\"borrowck(body_owner_def_id={:?})\", owner_def_id);\n@@ -141,12 +139,14 @@ fn borrowck<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, owner_def_id: DefId)\n     })\n }\n \n-fn build_borrowck_dataflow_data<'a, 'c, 'tcx, F>(this: &mut BorrowckCtxt<'a, 'tcx>,\n-                                                 force_analysis: bool,\n-                                                 body_id: hir::BodyId,\n-                                                 get_cfg: F)\n-                                                 -> Option<AnalysisData<'tcx>>\n-    where F: FnOnce(&mut BorrowckCtxt<'a, 'tcx>) -> &'c cfg::CFG\n+fn build_borrowck_dataflow_data<'a, 'c, 'tcx, F>(\n+    this: &mut BorrowckCtxt<'a, 'tcx>,\n+    force_analysis: bool,\n+    body_id: hir::BodyId,\n+    get_cfg: F,\n+) -> Option<AnalysisData<'tcx>>\n+where\n+    F: FnOnce(&mut BorrowckCtxt<'a, 'tcx>) -> &'c cfg::CFG,\n {\n     // Check the body of fn items.\n     let (all_loans, move_data) =\n@@ -195,9 +195,8 @@ fn build_borrowck_dataflow_data<'a, 'c, 'tcx, F>(this: &mut BorrowckCtxt<'a, 'tc\n pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n     tcx: TyCtxt<'tcx, 'tcx>,\n     body_id: hir::BodyId,\n-    cfg: &cfg::CFG)\n-    -> (BorrowckCtxt<'a, 'tcx>, AnalysisData<'tcx>)\n-{\n+    cfg: &cfg::CFG,\n+) -> (BorrowckCtxt<'a, 'tcx>, AnalysisData<'tcx>) {\n     let owner_id = tcx.hir().body_owner(body_id);\n     let owner_def_id = tcx.hir().local_def_id(owner_id);\n     let tables = tcx.typeck_tables_of(owner_def_id);\n@@ -238,7 +237,6 @@ pub struct BorrowckCtxt<'a, 'tcx> {\n     signalled_any_error: Cell<SignalledError>,\n }\n \n-\n impl BorrowckCtxt<'_, 'tcx> {\n     fn signal_error(&self) {\n         self.signalled_any_error.set(SignalledError::SawSomeError);\n@@ -390,8 +388,7 @@ pub enum LoanPathElem<'tcx> {\n     LpInterior(Option<DefId>, InteriorKind),\n }\n \n-fn closure_to_block(closure_id: LocalDefId,\n-                    tcx: TyCtxt<'_, '_>) -> HirId {\n+fn closure_to_block(closure_id: LocalDefId, tcx: TyCtxt<'_, '_>) -> HirId {\n     let closure_id = tcx.hir().local_def_id_to_node_id(closure_id);\n     match tcx.hir().get(closure_id) {\n         Node::Expr(expr) => match expr.node {"}, {"sha": "38bf590a36fb8e7fbaab6c8dd871be3fb9dfad3e", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 49, "deletions": 33, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -47,7 +47,7 @@ pub struct FlowedMoveData<'tcx> {\n     // We could (and maybe should, for efficiency) combine both move\n     // and assign data flow into one, but this way it's easier to\n     // distinguish the bits that correspond to moves and assignments.\n-    pub dfcx_assign: AssignDataFlow<'tcx>\n+    pub dfcx_assign: AssignDataFlow<'tcx>,\n }\n \n /// Index into `MoveData.paths`, used like a pointer\n@@ -223,8 +223,7 @@ impl MoveData<'tcx> {\n \n     /// Returns the existing move path index for `lp`, if any, and otherwise adds a new index for\n     /// `lp` and any of its base paths that do not yet have an index.\n-    pub fn move_path(&self, tcx: TyCtxt<'tcx, 'tcx>,\n-                     lp: Rc<LoanPath<'tcx>>) -> MovePathIndex {\n+    pub fn move_path(&self, tcx: TyCtxt<'tcx, 'tcx>, lp: Rc<LoanPath<'tcx>>) -> MovePathIndex {\n         if let Some(&index) = self.path_map.borrow().get(&lp) {\n             return index;\n         }\n@@ -311,10 +310,13 @@ impl MoveData<'tcx> {\n     }\n \n     /// Adds a new move entry for a move of `lp` that occurs at location `id` with kind `kind`.\n-    pub fn add_move(&self, tcx: TyCtxt<'tcx, 'tcx>,\n-                    orig_lp: Rc<LoanPath<'tcx>>,\n-                    id: hir::ItemLocalId,\n-                    kind: MoveKind) {\n+    pub fn add_move(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        orig_lp: Rc<LoanPath<'tcx>>,\n+        id: hir::ItemLocalId,\n+        kind: MoveKind,\n+    ) {\n         // Moving one union field automatically moves all its fields. Also move siblings of\n         // all parent union fields, moves do not propagate upwards automatically.\n         let mut lp = orig_lp.clone();\n@@ -340,10 +342,13 @@ impl MoveData<'tcx> {\n         self.add_move_helper(tcx, orig_lp, id, kind);\n     }\n \n-    fn add_move_helper(&self, tcx: TyCtxt<'tcx, 'tcx>,\n-                       lp: Rc<LoanPath<'tcx>>,\n-                       id: hir::ItemLocalId,\n-                       kind: MoveKind) {\n+    fn add_move_helper(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        lp: Rc<LoanPath<'tcx>>,\n+        id: hir::ItemLocalId,\n+        kind: MoveKind,\n+    ) {\n         debug!(\"add_move(lp={:?}, id={:?}, kind={:?})\",\n                lp,\n                id,\n@@ -365,10 +370,13 @@ impl MoveData<'tcx> {\n \n     /// Adds a new record for an assignment to `lp` that occurs at location `id` with the given\n     /// `span`.\n-    pub fn add_assignment(&self, tcx: TyCtxt<'tcx, 'tcx>,\n-                          lp: Rc<LoanPath<'tcx>>,\n-                          assign_id: hir::ItemLocalId,\n-                          span: Span) {\n+    pub fn add_assignment(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        lp: Rc<LoanPath<'tcx>>,\n+        assign_id: hir::ItemLocalId,\n+        span: Span,\n+    ) {\n         // Assigning to one union field automatically assigns to all its fields.\n         if let LpExtend(ref base_lp, mutbl, LpInterior(opt_variant_id, interior)) = lp.kind {\n             if let ty::Adt(adt_def, _) = base_lp.ty.sty {\n@@ -395,10 +403,13 @@ impl MoveData<'tcx> {\n         self.add_assignment_helper(tcx, lp, assign_id, span);\n     }\n \n-    fn add_assignment_helper(&self, tcx: TyCtxt<'tcx, 'tcx>,\n-                             lp: Rc<LoanPath<'tcx>>,\n-                             assign_id: hir::ItemLocalId,\n-                             span: Span) {\n+    fn add_assignment_helper(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        lp: Rc<LoanPath<'tcx>>,\n+        assign_id: hir::ItemLocalId,\n+        span: Span,\n+    ) {\n         debug!(\"add_assignment(lp={:?}, assign_id={:?}\", lp, assign_id);\n \n         let path_index = self.move_path(tcx, lp.clone());\n@@ -427,10 +438,12 @@ impl MoveData<'tcx> {\n     /// Moves are generated by moves and killed by assignments and\n     /// scoping. Assignments are generated by assignment to variables and\n     /// killed by scoping. See `README.md` for more details.\n-    fn add_gen_kills(&self,\n-                     bccx: &BorrowckCtxt<'_, 'tcx>,\n-                     dfcx_moves: &mut MoveDataFlow<'_>,\n-                     dfcx_assign: &mut AssignDataFlow<'_>) {\n+    fn add_gen_kills(\n+        &self,\n+        bccx: &BorrowckCtxt<'_, 'tcx>,\n+        dfcx_moves: &mut MoveDataFlow<'_>,\n+        dfcx_assign: &mut AssignDataFlow<'_>,\n+    ) {\n         for (i, the_move) in self.moves.borrow().iter().enumerate() {\n             dfcx_moves.add_gen(the_move.id, i);\n         }\n@@ -534,11 +547,13 @@ impl MoveData<'tcx> {\n         ret\n     }\n \n-    fn kill_moves(&self,\n-                  path: MovePathIndex,\n-                  kill_id: hir::ItemLocalId,\n-                  kill_kind: KillFrom,\n-                  dfcx_moves: &mut MoveDataFlow<'_>) {\n+    fn kill_moves(\n+        &self,\n+        path: MovePathIndex,\n+        kill_id: hir::ItemLocalId,\n+        kill_kind: KillFrom,\n+        dfcx_moves: &mut MoveDataFlow<'_>,\n+    ) {\n         // We can only perform kills for paths that refer to a unique location,\n         // since otherwise we may kill a move from one location with an\n         // assignment referring to another location.\n@@ -556,11 +571,12 @@ impl MoveData<'tcx> {\n }\n \n impl<'tcx> FlowedMoveData<'tcx> {\n-    pub fn new(move_data: MoveData<'tcx>,\n-               bccx: &BorrowckCtxt<'_, 'tcx>,\n-               cfg: &cfg::CFG,\n-               body: &hir::Body)\n-               -> FlowedMoveData<'tcx> {\n+    pub fn new(\n+        move_data: MoveData<'tcx>,\n+        bccx: &BorrowckCtxt<'_, 'tcx>,\n+        cfg: &cfg::CFG,\n+        body: &hir::Body,\n+    ) -> FlowedMoveData<'tcx> {\n         let tcx = bccx.tcx;\n \n         let mut dfcx_moves ="}, {"sha": "a42fbb72c03a81ff2da3ac73eb2aa6e3205b2c19", "filename": "src/librustc_borrowck/dataflow.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_borrowck%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_borrowck%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdataflow.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -51,7 +51,6 @@ pub struct DataFlowContext<'tcx, O> {\n     // `id_range`, there is a range of words equal to `words_per_id`.\n     // So, to access the bits for any given id, you take a slice of\n     // the full vector (see the method `compute_id_range()`).\n-\n     /// bits generated as we exit the cfg node. Updated by `add_gen()`.\n     gens: Vec<usize>,\n \n@@ -82,7 +81,7 @@ pub trait DataFlowOperator : BitwiseOperator {\n \n struct PropagationContext<'a, 'tcx, O> {\n     dfcx: &'a mut DataFlowContext<'tcx, O>,\n-    changed: bool\n+    changed: bool,\n }\n \n fn get_cfg_indices<'a>(id: hir::ItemLocalId,\n@@ -98,7 +97,7 @@ impl<'tcx, O: DataFlowOperator> DataFlowContext<'tcx, O> {\n     }\n }\n \n-impl<'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'tcx, O> {\n+impl<'tcx, O: DataFlowOperator> pprust::PpAnn for DataFlowContext<'tcx, O> {\n     fn nested(&self, state: &mut pprust::State<'_>, nested: pprust::Nested) -> io::Result<()> {\n         pprust::PpAnn::nested(self.tcx.hir(), state, nested)\n     }\n@@ -225,12 +224,14 @@ pub enum KillFrom {\n }\n \n impl<'tcx, O: DataFlowOperator> DataFlowContext<'tcx, O> {\n-    pub fn new(tcx: TyCtxt<'tcx, 'tcx>,\n-               analysis_name: &'static str,\n-               body: Option<&hir::Body>,\n-               cfg: &cfg::CFG,\n-               oper: O,\n-               bits_per_id: usize) -> DataFlowContext<'tcx, O> {\n+    pub fn new(\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        analysis_name: &'static str,\n+        body: Option<&hir::Body>,\n+        cfg: &cfg::CFG,\n+        oper: O,\n+        bits_per_id: usize,\n+    ) -> DataFlowContext<'tcx, O> {\n         let usize_bits = mem::size_of::<usize>() * 8;\n         let words_per_id = (bits_per_id + usize_bits - 1) / usize_bits;\n         let num_nodes = cfg.graph.all_nodes().len();"}, {"sha": "1f2480666959e17eca3fdae778344c73c15c35ec", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -61,11 +61,14 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n         }\n     }\n \n-    fn build_set<O:DataFlowOperator, F>(&self,\n-                                        e: EntryOrExit,\n-                                        cfgidx: CFGIndex,\n-                                        dfcx: &DataFlowContext<'tcx, O>,\n-                                        mut to_lp: F) -> String where\n+    fn build_set<O: DataFlowOperator, F>(\n+        &self,\n+        e: EntryOrExit,\n+        cfgidx: CFGIndex,\n+        dfcx: &DataFlowContext<'tcx, O>,\n+        mut to_lp: F,\n+    ) -> String\n+    where\n         F: FnMut(usize) -> Rc<LoanPath<'tcx>>,\n     {\n         let mut saw_some = false;"}, {"sha": "c552cc9223862e780606971f7ba0ae1e8c28b1f1", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -44,7 +44,7 @@ use crate::value::Value;\n pub fn write_compressed_metadata<'a, 'gcx>(\n     tcx: TyCtxt<'gcx, 'gcx>,\n     metadata: &EncodedMetadata,\n-    llvm_module: &mut ModuleLlvm\n+    llvm_module: &mut ModuleLlvm,\n ) {\n     use std::io::Write;\n     use flate2::Compression;"}, {"sha": "0a780fecf41de768019dfa228b38ac0aec57403b", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -47,8 +47,8 @@ pub struct CodegenCx<'ll, 'tcx: 'll> {\n     /// Cache instances of monomorphic and polymorphic items\n     pub instances: RefCell<FxHashMap<Instance<'tcx>, &'ll Value>>,\n     /// Cache generated vtables\n-    pub vtables: RefCell<FxHashMap<\n-            (Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), &'ll Value>>,\n+    pub vtables:\n+        RefCell<FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), &'ll Value>>,\n     /// Cache of constant strings,\n     pub const_cstr_cache: RefCell<FxHashMap<LocalInternedString, &'ll Value>>,\n \n@@ -207,10 +207,11 @@ pub unsafe fn create_module(\n }\n \n impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n-    crate fn new(tcx: TyCtxt<'tcx, 'tcx>,\n-                 codegen_unit: Arc<CodegenUnit<'tcx>>,\n-                 llvm_module: &'ll crate::ModuleLlvm)\n-                 -> Self {\n+    crate fn new(\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        codegen_unit: Arc<CodegenUnit<'tcx>>,\n+        llvm_module: &'ll crate::ModuleLlvm,\n+    ) -> Self {\n         // An interesting part of Windows which MSVC forces our hand on (and\n         // apparently MinGW didn't) is the usage of `dllimport` and `dllexport`\n         // attributes in LLVM IR as well as native dependencies (in C these"}, {"sha": "c4d9f79e8d301e39e2ba302d1768ef408006d3dd", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -894,10 +894,11 @@ fn pointer_type_metadata(\n     }\n }\n \n-pub fn compile_unit_metadata(tcx: TyCtxt<'_, '_>,\n-                             codegen_unit_name: &str,\n-                             debug_context: &CrateDebugContext<'ll, '_>)\n-                             -> &'ll DIDescriptor {\n+pub fn compile_unit_metadata(\n+    tcx: TyCtxt<'_, '_>,\n+    codegen_unit_name: &str,\n+    debug_context: &CrateDebugContext<'ll, '_>,\n+) -> &'ll DIDescriptor {\n     let mut name_in_debuginfo = match tcx.sess.local_crate_source_file {\n         Some(ref path) => path.clone(),\n         None => PathBuf::from(&*tcx.crate_name(LOCAL_CRATE).as_str()),"}, {"sha": "2e922ad5fcd3b8ede9fc4df9f743b132be6daca0", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -111,15 +111,15 @@ impl ExtraBackendMethods for LlvmCodegenBackend {\n         &self,\n         tcx: TyCtxt<'gcx, 'gcx>,\n         metadata: &EncodedMetadata,\n-        llvm_module: &mut ModuleLlvm\n+        llvm_module: &mut ModuleLlvm,\n     ) {\n         base::write_compressed_metadata(tcx, metadata, llvm_module)\n     }\n     fn codegen_allocator<'b, 'gcx>(\n         &self,\n         tcx: TyCtxt<'gcx, 'gcx>,\n         mods: &mut ModuleLlvm,\n-        kind: AllocatorKind\n+        kind: AllocatorKind,\n     ) {\n         unsafe { allocator::codegen(tcx, mods, kind) }\n     }\n@@ -289,7 +289,7 @@ impl CodegenBackend for LlvmCodegenBackend {\n         tcx: TyCtxt<'tcx, 'tcx>,\n         metadata: EncodedMetadata,\n         need_metadata_module: bool,\n-        rx: mpsc::Receiver<Box<dyn Any + Send>>\n+        rx: mpsc::Receiver<Box<dyn Any + Send>>,\n     ) -> Box<dyn Any> {\n         box rustc_codegen_ssa::base::codegen_crate(\n             LlvmCodegenBackend(()), tcx, metadata, need_metadata_module, rx)"}, {"sha": "e1693b7c2ef1b16ac01bb4e8d500139405ad975c", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -46,10 +46,10 @@ pub fn crates_export_threshold(crate_types: &[config::CrateType]) -> SymbolExpor\n     }\n }\n \n-fn reachable_non_generics_provider<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                             cnum: CrateNum)\n-                                             -> &'tcx DefIdMap<SymbolExportLevel>\n-{\n+fn reachable_non_generics_provider<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    cnum: CrateNum,\n+) -> &'tcx DefIdMap<SymbolExportLevel> {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     if !tcx.sess.opts.output_types.should_codegen() {\n@@ -157,9 +157,7 @@ fn reachable_non_generics_provider<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n     tcx.arena.alloc(reachable_non_generics)\n }\n \n-fn is_reachable_non_generic_provider_local<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                                     def_id: DefId)\n-                                                     -> bool {\n+fn is_reachable_non_generic_provider_local<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> bool {\n     let export_threshold = threshold(tcx);\n \n     if let Some(&level) = tcx.reachable_non_generics(def_id.krate).get(&def_id) {\n@@ -169,17 +167,14 @@ fn is_reachable_non_generic_provider_local<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n     }\n }\n \n-fn is_reachable_non_generic_provider_extern<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                                      def_id: DefId)\n-                                                      -> bool {\n+fn is_reachable_non_generic_provider_extern<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> bool {\n     tcx.reachable_non_generics(def_id.krate).contains_key(&def_id)\n }\n \n-fn exported_symbols_provider_local<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                             cnum: CrateNum)\n-                                             -> Arc<Vec<(ExportedSymbol<'tcx>,\n-                                                         SymbolExportLevel)>>\n-{\n+fn exported_symbols_provider_local<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    cnum: CrateNum,\n+) -> Arc<Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)>> {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     if !tcx.sess.opts.output_types.should_codegen() {\n@@ -280,9 +275,8 @@ fn exported_symbols_provider_local<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n \n fn upstream_monomorphizations_provider<'tcx>(\n     tcx: TyCtxt<'tcx, 'tcx>,\n-    cnum: CrateNum)\n-    -> &'tcx DefIdMap<FxHashMap<SubstsRef<'tcx>, CrateNum>>\n-{\n+    cnum: CrateNum,\n+) -> &'tcx DefIdMap<FxHashMap<SubstsRef<'tcx>, CrateNum>> {\n     debug_assert!(cnum == LOCAL_CRATE);\n \n     let cnums = tcx.all_crate_nums(LOCAL_CRATE);\n@@ -330,9 +324,8 @@ fn upstream_monomorphizations_provider<'tcx>(\n \n fn upstream_monomorphizations_for_provider<'tcx>(\n     tcx: TyCtxt<'tcx, 'tcx>,\n-    def_id: DefId)\n-    -> Option<&'tcx FxHashMap<SubstsRef<'tcx>, CrateNum>>\n-{\n+    def_id: DefId,\n+) -> Option<&'tcx FxHashMap<SubstsRef<'tcx>, CrateNum>> {\n     debug_assert!(!def_id.is_local());\n     tcx.upstream_monomorphizations(LOCAL_CRATE).get(&def_id)\n }"}, {"sha": "5a7ca4af4b8678c00703412fd47c34eda7ef894c", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -378,7 +378,7 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n     tcx: TyCtxt<'_, '_>,\n     metadata: EncodedMetadata,\n     coordinator_receive: Receiver<Box<dyn Any + Send>>,\n-    total_cgus: usize\n+    total_cgus: usize,\n ) -> OngoingCodegen<B> {\n     let sess = tcx.sess;\n     let crate_name = tcx.crate_name(LOCAL_CRATE);\n@@ -1005,7 +1005,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n     jobserver: Client,\n     modules_config: Arc<ModuleConfig>,\n     metadata_config: Arc<ModuleConfig>,\n-    allocator_config: Arc<ModuleConfig>\n+    allocator_config: Arc<ModuleConfig>,\n ) -> thread::JoinHandle<Result<CompiledModules, ()>> {\n     let coordinator_send = tcx.tx_to_llvm_workers.lock().clone();\n     let sess = tcx.sess;\n@@ -1861,9 +1861,11 @@ impl<B: ExtraBackendMethods> OngoingCodegen<B> {\n         }, work_products)\n     }\n \n-    pub fn submit_pre_codegened_module_to_llvm(&self,\n-                                                       tcx: TyCtxt<'_, '_>,\n-                                                       module: ModuleCodegen<B::Module>) {\n+    pub fn submit_pre_codegened_module_to_llvm(\n+        &self,\n+        tcx: TyCtxt<'_, '_>,\n+        module: ModuleCodegen<B::Module>,\n+    ) {\n         self.wait_for_signal_to_codegen_item();\n         self.check_for_errors(tcx.sess);\n \n@@ -1913,7 +1915,7 @@ pub fn submit_codegened_module_to_llvm<B: ExtraBackendMethods>(\n     _backend: &B,\n     tcx: TyCtxt<'_, '_>,\n     module: ModuleCodegen<B::Module>,\n-    cost: u64\n+    cost: u64,\n ) {\n     let llvm_work_item = WorkItem::Optimize(module);\n     drop(tcx.tx_to_llvm_workers.lock().send(Box::new(Message::CodegenDone::<B> {\n@@ -1925,7 +1927,7 @@ pub fn submit_codegened_module_to_llvm<B: ExtraBackendMethods>(\n pub fn submit_post_lto_module_to_llvm<B: ExtraBackendMethods>(\n     _backend: &B,\n     tcx: TyCtxt<'_, '_>,\n-    module: CachedModuleCodegen\n+    module: CachedModuleCodegen,\n ) {\n     let llvm_work_item = WorkItem::CopyPostLtoArtifacts(module);\n     drop(tcx.tx_to_llvm_workers.lock().send(Box::new(Message::CodegenDone::<B> {\n@@ -1937,7 +1939,7 @@ pub fn submit_post_lto_module_to_llvm<B: ExtraBackendMethods>(\n pub fn submit_pre_lto_module_to_llvm<B: ExtraBackendMethods>(\n     _backend: &B,\n     tcx: TyCtxt<'_, '_>,\n-    module: CachedModuleCodegen\n+    module: CachedModuleCodegen,\n ) {\n     let filename = pre_lto_bitcode_filename(&module.name);\n     let bc_path = in_incr_comp_dir_sess(tcx.sess, &filename);"}, {"sha": "9c34b5e4f7927da8954988ef6fe2c40a87f9feeb", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -483,9 +483,8 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     tcx: TyCtxt<'tcx, 'tcx>,\n     metadata: EncodedMetadata,\n     need_metadata_module: bool,\n-    rx: mpsc::Receiver<Box<dyn Any + Send>>\n+    rx: mpsc::Receiver<Box<dyn Any + Send>>,\n ) -> OngoingCodegen<B> {\n-\n     check_for_rustc_errors_attr(tcx);\n \n     // Skip crate items and just output metadata in -Z no-codegen mode.\n@@ -776,7 +775,7 @@ impl CrateInfo {\n             info.missing_lang_items.insert(cnum, missing);\n         }\n \n-        return info\n+        return info;\n     }\n }\n \n@@ -850,9 +849,7 @@ pub fn provide_both(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn determine_cgu_reuse<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                 cgu: &CodegenUnit<'tcx>)\n-                                 -> CguReuse {\n+fn determine_cgu_reuse<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, cgu: &CodegenUnit<'tcx>) -> CguReuse {\n     if !tcx.dep_graph.is_fully_enabled() {\n         return CguReuse::No\n     }"}, {"sha": "66baf06bfb46d4372a99495d3633cd7d2270baf7", "filename": "src/librustc_codegen_ssa/common.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcommon.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -122,11 +122,7 @@ mod temp_stable_hash_impls {\n     }\n }\n \n-pub fn langcall(tcx: TyCtxt<'_, '_>,\n-                span: Option<Span>,\n-                msg: &str,\n-                li: LangItem)\n-                -> DefId {\n+pub fn langcall(tcx: TyCtxt<'_, '_>, span: Option<Span>, msg: &str, li: LangItem) -> DefId {\n     tcx.lang_items().require(li).unwrap_or_else(|s| {\n         let msg = format!(\"{} {}\", msg, s);\n         match span {"}, {"sha": "943fd254030d294ed2615e9d9872c964d5c74fc4", "filename": "src/librustc_codegen_ssa/debuginfo/type_names.rs", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -8,10 +8,11 @@ use rustc_data_structures::fx::FxHashSet;\n // any caching, i.e., calling the function twice with the same type will also do\n // the work twice. The `qualified` parameter only affects the first level of the\n // type name, further levels (i.e., type parameters) are always fully qualified.\n-pub fn compute_debuginfo_type_name<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                             t: Ty<'tcx>,\n-                                             qualified: bool)\n-                                             -> String {\n+pub fn compute_debuginfo_type_name<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    t: Ty<'tcx>,\n+    qualified: bool,\n+) -> String {\n     let mut result = String::with_capacity(64);\n     let mut visited = FxHashSet::default();\n     push_debuginfo_type_name(tcx, t, qualified, &mut result, &mut visited);\n@@ -20,12 +21,13 @@ pub fn compute_debuginfo_type_name<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n \n // Pushes the name of the type as it should be stored in debuginfo on the\n // `output` String. See also compute_debuginfo_type_name().\n-pub fn push_debuginfo_type_name<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                          t: Ty<'tcx>,\n-                                          qualified: bool,\n-                                          output: &mut String,\n-                                          visited: &mut FxHashSet<Ty<'tcx>>) {\n-\n+pub fn push_debuginfo_type_name<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    t: Ty<'tcx>,\n+    qualified: bool,\n+    output: &mut String,\n+    visited: &mut FxHashSet<Ty<'tcx>>,\n+) {\n     // When targeting MSVC, emit C++ style type names for compatibility with\n     // .natvis visualizers (and perhaps other existing native debuggers?)\n     let cpp_like_names = tcx.sess.target.target.options.is_like_msvc;\n@@ -208,10 +210,12 @@ pub fn push_debuginfo_type_name<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n         }\n     }\n \n-    fn push_item_name(tcx: TyCtxt<'tcx, 'tcx>,\n-                      def_id: DefId,\n-                      qualified: bool,\n-                      output: &mut String) {\n+    fn push_item_name(\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        def_id: DefId,\n+        qualified: bool,\n+        output: &mut String,\n+    ) {\n         if qualified {\n             output.push_str(&tcx.crate_name(def_id.krate).as_str());\n             for path_element in tcx.def_path(def_id).data {\n@@ -228,10 +232,12 @@ pub fn push_debuginfo_type_name<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n     // reconstructed for items from non-local crates. For local crates, this\n     // would be possible but with inlining and LTO we have to use the least\n     // common denominator - otherwise we would run into conflicts.\n-    fn push_type_params<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                  substs: SubstsRef<'tcx>,\n-                                  output: &mut String,\n-                                  visited: &mut FxHashSet<Ty<'tcx>>) {\n+    fn push_type_params<'tcx>(\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        substs: SubstsRef<'tcx>,\n+        output: &mut String,\n+        visited: &mut FxHashSet<Ty<'tcx>>,\n+    ) {\n         if substs.types().next().is_none() {\n             return;\n         }"}, {"sha": "160e554f8565c1692ba1d25e9fbd2d5fa6f51b17", "filename": "src/librustc_codegen_ssa/traits/backend.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -42,13 +42,9 @@ pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Se\n         &self,\n         tcx: TyCtxt<'gcx, 'gcx>,\n         mods: &mut Self::Module,\n-        kind: AllocatorKind\n-    );\n-    fn compile_codegen_unit<'a, 'tcx: 'a>(\n-        &self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n-        cgu_name: InternedString,\n+        kind: AllocatorKind,\n     );\n+    fn compile_codegen_unit<'a, 'tcx: 'a>(&self, tcx: TyCtxt<'tcx, 'tcx>, cgu_name: InternedString);\n     // If find_features is true this won't access `sess.crate_types` by assuming\n     // that `is_pie_binary` is false. When we discover LLVM target features\n     // `sess.crate_types` is uninitialized so we cannot access it."}, {"sha": "1bf03c0c45c6dbb0888dff541558cc19958f5e8e", "filename": "src/librustc_codegen_utils/codegen_backend.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -6,7 +6,6 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![deny(warnings)]\n-\n #![feature(box_syntax)]\n \n use std::any::Any;\n@@ -39,7 +38,7 @@ pub trait CodegenBackend {\n         tcx: TyCtxt<'tcx, 'tcx>,\n         metadata: EncodedMetadata,\n         need_metadata_module: bool,\n-        rx: mpsc::Receiver<Box<dyn Any + Send>>\n+        rx: mpsc::Receiver<Box<dyn Any + Send>>,\n     ) -> Box<dyn Any>;\n \n     /// This is called on the returned `Box<dyn Any>` from `codegen_backend`"}, {"sha": "4f19a7bbc8b9235f4b853ee2846236e94cc67235", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -154,12 +154,14 @@ pub fn parse_pretty(sess: &Session,\n \n impl PpSourceMode {\n     /// Constructs a `PrinterSupport` object and passes it to `f`.\n-    fn call_with_pp_support<'tcx, A, F>(&self,\n-                                        sess: &'tcx Session,\n-                                        tcx: Option<TyCtxt<'tcx, 'tcx>>,\n-                                        f: F)\n-                                        -> A\n-        where F: FnOnce(&dyn PrinterSupport) -> A\n+    fn call_with_pp_support<'tcx, A, F>(\n+        &self,\n+        sess: &'tcx Session,\n+        tcx: Option<TyCtxt<'tcx, 'tcx>>,\n+        f: F,\n+    ) -> A\n+    where\n+        F: FnOnce(&dyn PrinterSupport) -> A,\n     {\n         match *self {\n             PpmNormal | PpmEveryBodyLoops | PpmExpanded => {\n@@ -186,12 +188,9 @@ impl PpSourceMode {\n             _ => panic!(\"Should use call_with_pp_support_hir\"),\n         }\n     }\n-    fn call_with_pp_support_hir<'tcx, A, F>(\n-        &self,\n-        tcx: TyCtxt<'tcx, 'tcx>,\n-        f: F\n-    ) -> A\n-        where F: FnOnce(&dyn HirPrinterSupport<'_>, &hir::Crate) -> A\n+    fn call_with_pp_support_hir<'tcx, A, F>(&self, tcx: TyCtxt<'tcx, 'tcx>, f: F) -> A\n+    where\n+        F: FnOnce(&dyn HirPrinterSupport<'_>, &hir::Crate) -> A,\n     {\n         match *self {\n             PpmNormal => {\n@@ -454,7 +453,6 @@ impl<'a> pprust::PpAnn for HygieneAnnotation<'a> {\n     }\n }\n \n-\n struct TypedAnnotation<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'tcx, 'tcx>,\n     tables: Cell<&'a ty::TypeckTables<'tcx>>,\n@@ -617,12 +615,13 @@ impl UserIdentifiedItem {\n     }\n }\n \n-fn print_flowgraph<'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n-                                       tcx: TyCtxt<'tcx, 'tcx>,\n-                                       code: blocks::Code<'tcx>,\n-                                       mode: PpFlowGraphMode,\n-                                       mut out: W)\n-                                       -> io::Result<()> {\n+fn print_flowgraph<'tcx, W: Write>(\n+    variants: Vec<borrowck_dot::Variant>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    code: blocks::Code<'tcx>,\n+    mode: PpFlowGraphMode,\n+    mut out: W,\n+) -> io::Result<()> {\n     let body_id = match code {\n         blocks::Code::Expr(expr) => {\n             // Find the function this expression is from.\n@@ -760,7 +759,8 @@ pub fn print_after_hir_lowering<'tcx>(\n     krate: &ast::Crate,\n     ppm: PpMode,\n     opt_uii: Option<UserIdentifiedItem>,\n-    ofile: Option<&Path>) {\n+    ofile: Option<&Path>,\n+) {\n     if ppm.needs_analysis() {\n         abort_on_err(print_with_analysis(\n             tcx,\n@@ -869,7 +869,7 @@ fn print_with_analysis<'tcx>(\n     tcx: TyCtxt<'tcx, 'tcx>,\n     ppm: PpMode,\n     uii: Option<UserIdentifiedItem>,\n-    ofile: Option<&Path>\n+    ofile: Option<&Path>,\n ) -> Result<(), ErrorReported> {\n     let nodeid = if let Some(uii) = uii {\n         debug!(\"pretty printing for {:?}\", uii);"}, {"sha": "0ddcc42ef123cfd6f0ff8e5d501db921e6b98df0", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -184,10 +184,11 @@ impl Visitor<'tcx> for IfThisChanged<'tcx> {\n     }\n }\n \n-fn check_paths<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                         if_this_changed: &Sources,\n-                         then_this_would_need: &Targets)\n-{\n+fn check_paths<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    if_this_changed: &Sources,\n+    then_this_would_need: &Targets,\n+) {\n     // Return early here so as not to construct the query, which is not cheap.\n     if if_this_changed.is_empty() {\n         for &(target_span, _, _, _) in then_this_would_need {"}, {"sha": "f31718fe50776050c669a0accf4b436ee7b96193", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -129,8 +129,7 @@ fn save_in<F>(sess: &Session, path_buf: PathBuf, encode: F)\n     }\n }\n \n-fn encode_dep_graph(tcx: TyCtxt<'_, '_>,\n-                    encoder: &mut Encoder) {\n+fn encode_dep_graph(tcx: TyCtxt<'_, '_>, encoder: &mut Encoder) {\n     // First encode the commandline arguments hash\n     tcx.sess.opts.dep_tracking_hash().encode(encoder).unwrap();\n \n@@ -234,8 +233,7 @@ fn encode_work_product_index(work_products: &FxHashMap<WorkProductId, WorkProduc\n     serialized_products.encode(encoder).unwrap();\n }\n \n-fn encode_query_cache(tcx: TyCtxt<'_, '_>,\n-                      encoder: &mut Encoder) {\n+fn encode_query_cache(tcx: TyCtxt<'_, '_>, encoder: &mut Encoder) {\n     time(tcx.sess, \"serialize query result cache\", || {\n         tcx.serialize_query_result_cache(encoder).unwrap();\n     })"}, {"sha": "d76ae187412133063405ecfda9a816d004fba834", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -798,7 +798,7 @@ declare_box_region_type!(\n impl BoxedGlobalCtxt {\n     pub fn enter<F, R>(&mut self, f: F) -> R\n     where\n-        F: for<'tcx> FnOnce(TyCtxt<'tcx, 'tcx>) -> R\n+        F: for<'tcx> FnOnce(TyCtxt<'tcx, 'tcx>) -> R,\n     {\n         self.access(|gcx| ty::tls::enter_global(gcx, |tcx| f(tcx)))\n     }\n@@ -878,10 +878,7 @@ pub fn create_global_ctxt(\n \n /// Runs the resolution, type-checking, region checking and other\n /// miscellaneous analysis passes on the crate.\n-fn analysis<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    cnum: CrateNum,\n-) -> Result<()> {\n+fn analysis<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, cnum: CrateNum) -> Result<()> {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     let sess = tcx.sess;"}, {"sha": "49f892ac299f4015e64fd559feec64efbdbae3cd", "filename": "src/librustc_interface/proc_macro_decls.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fproc_macro_decls.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -10,10 +10,7 @@ pub fn find<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) -> Option<DefId> {\n     tcx.proc_macro_decls_static(LOCAL_CRATE)\n }\n \n-fn proc_macro_decls_static<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    cnum: CrateNum,\n-) -> Option<DefId> {\n+fn proc_macro_decls_static<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, cnum: CrateNum) -> Option<DefId> {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     let mut finder = Finder { decls: None };"}, {"sha": "edaacf7749407f79fc27af35b1f886a75c60dd99", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -555,11 +555,12 @@ fn ty_is_known_nonnull<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n /// to function pointers, references, core::num::NonZero*,\n /// core::ptr::NonNull, and #[repr(transparent)] newtypes.\n /// FIXME: This duplicates code in codegen.\n-fn is_repr_nullable_ptr<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                  ty: Ty<'tcx>,\n-                                  ty_def: &'tcx ty::AdtDef,\n-                                  substs: SubstsRef<'tcx>)\n-                                  -> bool {\n+fn is_repr_nullable_ptr<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    ty: Ty<'tcx>,\n+    ty_def: &'tcx ty::AdtDef,\n+    substs: SubstsRef<'tcx>,\n+) -> bool {\n     if ty_def.variants.len() != 2 {\n         return false;\n     }"}, {"sha": "8b7dc557c59ca46a160e69241036585c93d56363", "filename": "src/librustc_macros/src/query.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fquery.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -314,7 +314,7 @@ fn process_modifiers(query: &mut Query) -> QueryModifiers {\n fn add_query_description_impl(\n     query: &Query,\n     modifiers: QueryModifiers,\n-    impls: &mut proc_macro2::TokenStream\n+    impls: &mut proc_macro2::TokenStream,\n ) {\n     let name = &query.name;\n     let arg = &query.arg;"}, {"sha": "7d07331cfff70ebc2efc0b15e8493677322533dc", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -550,10 +550,7 @@ impl CrateStore for cstore::CStore {\n         self.do_postorder_cnums_untracked()\n     }\n \n-    fn encode_metadata<'tcx>(&self,\n-                                 tcx: TyCtxt<'tcx, 'tcx>)\n-                                 -> EncodedMetadata\n-    {\n+    fn encode_metadata<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>) -> EncodedMetadata {\n         encoder::encode_metadata(tcx)\n     }\n "}, {"sha": "9ec31e33f9e0652853432e312c54baea3cc5405d", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 39, "deletions": 47, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -55,7 +55,9 @@ pub trait Metadata<'a, 'tcx>: Copy {\n     fn raw_bytes(self) -> &'a [u8];\n     fn cdata(self) -> Option<&'a CrateMetadata> { None }\n     fn sess(self) -> Option<&'a Session> { None }\n-    fn tcx(self) -> Option<TyCtxt<'tcx, 'tcx>> { None }\n+    fn tcx(self) -> Option<TyCtxt<'tcx, 'tcx>> {\n+        None\n+        }\n \n     fn decoder(self, pos: usize) -> DecodeContext<'a, 'tcx> {\n         let tcx = self.tcx();\n@@ -170,7 +172,6 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> TyDecoder<'tcx> for DecodeContext<'a, 'tcx> {\n-\n     #[inline]\n     fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n         self.tcx.expect(\"missing TyCtxt in DecodeContext\")\n@@ -551,7 +552,7 @@ impl<'a, 'tcx> CrateMetadata {\n         item: &Entry<'_>,\n         index: DefIndex,\n         parent_did: DefId,\n-        adt_kind: ty::AdtKind\n+        adt_kind: ty::AdtKind,\n     ) -> ty::VariantDef {\n         let data = match item.kind {\n             EntryKind::Variant(data) |\n@@ -588,10 +589,7 @@ impl<'a, 'tcx> CrateMetadata {\n         )\n     }\n \n-    pub fn get_adt_def(&self,\n-                       item_id: DefIndex,\n-                       tcx: TyCtxt<'tcx, 'tcx>)\n-                       -> &'tcx ty::AdtDef {\n+    pub fn get_adt_def(&self, item_id: DefIndex, tcx: TyCtxt<'tcx, 'tcx>) -> &'tcx ty::AdtDef {\n         let item = self.entry(item_id);\n         let did = self.local_def_id(item_id);\n \n@@ -616,24 +614,27 @@ impl<'a, 'tcx> CrateMetadata {\n         tcx.alloc_adt_def(did, kind, variants, repr)\n     }\n \n-    pub fn get_predicates(&self,\n-                          item_id: DefIndex,\n-                          tcx: TyCtxt<'tcx, 'tcx>)\n-                          -> ty::GenericPredicates<'tcx> {\n+    pub fn get_predicates(\n+        &self,\n+        item_id: DefIndex,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+    ) -> ty::GenericPredicates<'tcx> {\n         self.entry(item_id).predicates.unwrap().decode((self, tcx))\n     }\n \n-    pub fn get_predicates_defined_on(&self,\n-                                   item_id: DefIndex,\n-                                   tcx: TyCtxt<'tcx, 'tcx>)\n-                                   -> ty::GenericPredicates<'tcx> {\n+    pub fn get_predicates_defined_on(\n+        &self,\n+        item_id: DefIndex,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+    ) -> ty::GenericPredicates<'tcx> {\n         self.entry(item_id).predicates_defined_on.unwrap().decode((self, tcx))\n     }\n \n-    pub fn get_super_predicates(&self,\n-                                item_id: DefIndex,\n-                                tcx: TyCtxt<'tcx, 'tcx>)\n-                                -> ty::GenericPredicates<'tcx> {\n+    pub fn get_super_predicates(\n+        &self,\n+        item_id: DefIndex,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+    ) -> ty::GenericPredicates<'tcx> {\n         let super_predicates = match self.entry(item_id).kind {\n             EntryKind::Trait(data) => data.decode(self).super_predicates,\n             EntryKind::TraitAlias(data) => data.decode(self).super_predicates,\n@@ -700,10 +701,11 @@ impl<'a, 'tcx> CrateMetadata {\n         self.get_impl_data(id).coerce_unsized_info\n     }\n \n-    pub fn get_impl_trait(&self,\n-                          id: DefIndex,\n-                          tcx: TyCtxt<'tcx, 'tcx>)\n-                          -> Option<ty::TraitRef<'tcx>> {\n+    pub fn get_impl_trait(\n+        &self,\n+        id: DefIndex,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+    ) -> Option<ty::TraitRef<'tcx>> {\n         self.get_impl_data(id).trait_ref.map(|tr| tr.decode((self, tcx)))\n     }\n \n@@ -720,10 +722,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     /// Iterates over the language items in the given crate.\n-    pub fn get_lang_items(\n-        &self,\n-        tcx: TyCtxt<'tcx, '_>,\n-    ) -> &'tcx [(DefId, usize)] {\n+    pub fn get_lang_items(&self, tcx: TyCtxt<'tcx, '_>) -> &'tcx [(DefId, usize)] {\n         if self.proc_macros.is_some() {\n             // Proc macro crates do not export any lang-items to the target.\n             &[]\n@@ -884,10 +883,11 @@ impl<'a, 'tcx> CrateMetadata {\n         self.maybe_entry(id).and_then(|item| item.decode(self).mir).is_some()\n     }\n \n-    pub fn maybe_get_optimized_mir(&self,\n-                                   tcx: TyCtxt<'tcx, 'tcx>,\n-                                   id: DefIndex)\n-                                   -> Option<Body<'tcx>> {\n+    pub fn maybe_get_optimized_mir(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        id: DefIndex,\n+    ) -> Option<Body<'tcx>> {\n         match self.is_proc_macro(id) {\n             true => None,\n             false => self.entry(id).mir.map(|mir| mir.decode((self, tcx))),\n@@ -1020,7 +1020,7 @@ impl<'a, 'tcx> CrateMetadata {\n     pub fn get_inherent_implementations_for_type(\n         &self,\n         tcx: TyCtxt<'tcx, '_>,\n-        id: DefIndex\n+        id: DefIndex,\n     ) -> &'tcx [DefId] {\n         tcx.arena.alloc_from_iter(self.entry(id)\n                                       .inherent_impls\n@@ -1085,10 +1085,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_foreign_modules(\n-        &self,\n-        tcx: TyCtxt<'tcx, '_>,\n-    ) -> &'tcx [ForeignModule] {\n+    pub fn get_foreign_modules(&self, tcx: TyCtxt<'tcx, '_>) -> &'tcx [ForeignModule] {\n         if self.proc_macros.is_some() {\n             // Proc macro crates do not have any *target* foreign modules.\n             &[]\n@@ -1111,10 +1108,7 @@ impl<'a, 'tcx> CrateMetadata {\n             }))\n     }\n \n-    pub fn get_missing_lang_items(\n-        &self,\n-        tcx: TyCtxt<'tcx, '_>,\n-    ) -> &'tcx [lang_items::LangItem] {\n+    pub fn get_missing_lang_items(&self, tcx: TyCtxt<'tcx, '_>) -> &'tcx [lang_items::LangItem] {\n         if self.proc_macros.is_some() {\n             // Proc macro crates do not depend on any target weak lang-items.\n             &[]\n@@ -1135,9 +1129,10 @@ impl<'a, 'tcx> CrateMetadata {\n         arg_names.decode(self).collect()\n     }\n \n-    pub fn exported_symbols(&self,\n-                            tcx: TyCtxt<'tcx, 'tcx>)\n-                            -> Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)> {\n+    pub fn exported_symbols(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+    ) -> Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)> {\n         if self.proc_macros.is_some() {\n             // If this crate is a custom derive crate, then we're not even going to\n             // link those in so we skip those crates.\n@@ -1192,10 +1187,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn fn_sig(&self,\n-                  id: DefIndex,\n-                  tcx: TyCtxt<'tcx, 'tcx>)\n-                  -> ty::PolyFnSig<'tcx> {\n+    pub fn fn_sig(&self, id: DefIndex, tcx: TyCtxt<'tcx, 'tcx>) -> ty::PolyFnSig<'tcx> {\n         let sig = match self.entry(id).kind {\n             EntryKind::Fn(data) |\n             EntryKind::ForeignFn(data) => data.decode(self).sig,"}, {"sha": "5c73ee43c059c42af3b38837163c558fedd26db3", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -217,8 +217,7 @@ impl<'tcx> SpecializedEncoder<Fingerprint> for EncodeContext<'tcx> {\n     }\n }\n \n-impl<'tcx, T: Encodable> SpecializedEncoder<mir::ClearCrossCrate<T>>\n-for EncodeContext<'tcx> {\n+impl<'tcx, T: Encodable> SpecializedEncoder<mir::ClearCrossCrate<T>> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self,\n                           _: &mir::ClearCrossCrate<T>)\n                           -> Result<(), Self::Error> {\n@@ -233,7 +232,6 @@ impl<'tcx> TyEncoder for EncodeContext<'tcx> {\n }\n \n impl<'tcx> EncodeContext<'tcx> {\n-\n     fn emit_node<F: FnOnce(&mut Self, usize) -> R, R>(&mut self, f: F) -> R {\n         assert_eq!(self.lazy_state, LazyState::NoNode);\n         let pos = self.position();\n@@ -1865,9 +1863,7 @@ impl<'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'tcx> {\n // will allow us to slice the metadata to the precise length that we just\n // generated regardless of trailing bytes that end up in it.\n \n-pub fn encode_metadata<'tcx>(tcx: TyCtxt<'tcx, 'tcx>)\n-                                 -> EncodedMetadata\n-{\n+pub fn encode_metadata<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) -> EncodedMetadata {\n     let mut encoder = opaque::Encoder::new(vec![]);\n     encoder.emit_raw_bytes(METADATA_HEADER);\n "}, {"sha": "63260312fa6dec6005cc2676b5753d24ff0e0d8f", "filename": "src/librustc_metadata/foreign_modules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_metadata%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_metadata%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fforeign_modules.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -9,7 +9,7 @@ pub fn collect<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) -> Vec<ForeignModule> {\n         modules: Vec::new(),\n     };\n     tcx.hir().krate().visit_all_item_likes(&mut collector);\n-    return collector.modules\n+    return collector.modules;\n }\n \n struct Collector<'tcx> {"}, {"sha": "576b0da1fd8e24c4d3c1b6af6193c5f3e2770eb5", "filename": "src/librustc_metadata/link_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_metadata%2Flink_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_metadata%2Flink_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flink_args.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -18,7 +18,7 @@ pub fn collect<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) -> Vec<String> {\n         }\n     }\n \n-    return collector.args\n+    return collector.args;\n }\n \n struct Collector {"}, {"sha": "ef74fdf8a9e540fa62c0d5a93bb4ff203f304fef", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -18,7 +18,7 @@ pub fn collect<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) -> Vec<NativeLibrary> {\n     };\n     tcx.hir().krate().visit_all_item_likes(&mut collector);\n     collector.process_command_line();\n-    return collector.libs\n+    return collector.libs;\n }\n \n pub fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {"}, {"sha": "5accf2abdadbfd65907fa529f86950d0dbaecc75", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -125,9 +125,8 @@ impl<'tcx> BorrowSet<'tcx> {\n         tcx: TyCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n         locals_are_invalidated_at_exit: bool,\n-        move_data: &MoveData<'tcx>\n+        move_data: &MoveData<'tcx>,\n     ) -> Self {\n-\n         let mut visitor = GatherBorrows {\n             tcx,\n             body,"}, {"sha": "978f12af9a1ad366a6102ec85851674c60006ebd", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -22,7 +22,7 @@ pub(super) enum Control {\n }\n \n /// Encapsulates the idea of iterating over every borrow that involves a particular path\n-pub(super) fn each_borrow_involving_path<'tcx, 'gcx: 'tcx, F, I, S> (\n+pub(super) fn each_borrow_involving_path<'tcx, 'gcx: 'tcx, F, I, S>(\n     s: &mut S,\n     tcx: TyCtxt<'gcx, 'tcx>,\n     body: &Body<'tcx>,\n@@ -33,7 +33,7 @@ pub(super) fn each_borrow_involving_path<'tcx, 'gcx: 'tcx, F, I, S> (\n     mut op: F,\n ) where\n     F: FnMut(&mut S, BorrowIndex, &BorrowData<'tcx>) -> Control,\n-    I: Iterator<Item=BorrowIndex>\n+    I: Iterator<Item = BorrowIndex>,\n {\n     let (access, place) = access_place;\n "}, {"sha": "542cdf273695d8cfac34b29bc68c78f5636edfc9", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -15,7 +15,7 @@ crate trait PlaceExt<'tcx> {\n         tcx: TyCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n         locals_state_at_exit: &LocalsStateAtExit,\n-        ) -> bool;\n+    ) -> bool;\n }\n \n impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {"}, {"sha": "579a403f3aca7962808007b5b639290b0c9bfd0c", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -186,7 +186,7 @@ pub fn mir_build<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Body<'tcx> {\n /// can change `'tcx` so we have to transmute afterwards.\n struct GlobalizeMir<'gcx> {\n     tcx: TyCtxt<'gcx, 'gcx>,\n-    span: Span\n+    span: Span,\n }\n \n impl<'gcx: 'tcx, 'tcx> MutVisitor<'tcx> for GlobalizeMir<'gcx> {\n@@ -234,10 +234,11 @@ impl<'gcx: 'tcx, 'tcx> MutVisitor<'tcx> for GlobalizeMir<'gcx> {\n ///////////////////////////////////////////////////////////////////////////\n // BuildMir -- walks a crate, looking for fn items and methods to build MIR from\n \n-fn liberated_closure_env_ty<'gcx, 'tcx>(tcx: TyCtxt<'gcx, 'tcx>,\n-                                            closure_expr_id: hir::HirId,\n-                                            body_id: hir::BodyId)\n-                                            -> Ty<'tcx> {\n+fn liberated_closure_env_ty<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n+    closure_expr_id: hir::HirId,\n+    body_id: hir::BodyId,\n+) -> Ty<'tcx> {\n     let closure_ty = tcx.body_tables(body_id).node_type(closure_expr_id);\n \n     let (closure_def_id, closure_substs) = match closure_ty.sty {\n@@ -551,10 +552,7 @@ macro_rules! unpack {\n     };\n }\n \n-fn should_abort_on_panic<'gcx, 'tcx>(tcx: TyCtxt<'gcx, 'tcx>,\n-                                         fn_def_id: DefId,\n-                                         abi: Abi)\n-                                         -> bool {\n+fn should_abort_on_panic<'gcx, 'tcx>(tcx: TyCtxt<'gcx, 'tcx>, fn_def_id: DefId, abi: Abi) -> bool {\n     // Not callable from C, so we can safely unwind through these\n     if abi == Abi::Rust || abi == Abi::RustCall { return false; }\n "}, {"sha": "fb031f9e7ec164ae59f57d59d733bccb60499887", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -308,9 +308,7 @@ impl interpret::MayLeak for ! {\n     }\n }\n \n-impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx>\n-    for CompileTimeInterpreter<'mir, 'tcx>\n-{\n+impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir, 'tcx> {\n     type MemoryKinds = !;\n     type PointerTag = ();\n \n@@ -454,18 +452,13 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx>\n     }\n \n     #[inline(always)]\n-    fn stack_push(\n-        _ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n-    ) -> InterpResult<'tcx> {\n+    fn stack_push(_ecx: &mut InterpretCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n         Ok(())\n     }\n \n     /// Called immediately before a stack frame gets popped.\n     #[inline(always)]\n-    fn stack_pop(\n-        _ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n-        _extra: (),\n-    ) -> InterpResult<'tcx> {\n+    fn stack_pop(_ecx: &mut InterpretCx<'mir, 'tcx, Self>, _extra: ()) -> InterpResult<'tcx> {\n         Ok(())\n     }\n }\n@@ -511,7 +504,7 @@ pub fn const_variant_index<'tcx>(\n \n pub fn error_to_const_error<'mir, 'tcx>(\n     ecx: &InterpretCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n-    mut error: InterpErrorInfo<'tcx>\n+    mut error: InterpErrorInfo<'tcx>,\n ) -> ConstEvalErr<'tcx> {\n     error.print_backtrace();\n     let stacktrace = ecx.generate_stacktrace(None);"}, {"sha": "dc2893cb3303d16267af74eaf546939af0d9649e", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -46,9 +46,11 @@ pub fn move_path_children_matching<'tcx, F>(move_data: &MoveData<'tcx>,\n /// is no need to maintain separate drop flags to track such state.\n //\n // FIXME: we have to do something for moving slice patterns.\n-fn place_contents_drop_state_cannot_differ<'gcx, 'tcx>(tcx: TyCtxt<'gcx, 'tcx>,\n-                                                            body: &Body<'tcx>,\n-                                                            place: &mir::Place<'tcx>) -> bool {\n+fn place_contents_drop_state_cannot_differ<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n+    body: &Body<'tcx>,\n+    place: &mir::Place<'tcx>,\n+) -> bool {\n     let ty = place.ty(body, tcx).ty;\n     match ty.sty {\n         ty::Array(..) => {\n@@ -77,8 +79,9 @@ pub(crate) fn on_lookup_result_bits<'gcx, 'tcx, F>(\n     body: &Body<'tcx>,\n     move_data: &MoveData<'tcx>,\n     lookup_result: LookupResult,\n-    each_child: F)\n-    where F: FnMut(MovePathIndex)\n+    each_child: F,\n+) where\n+    F: FnMut(MovePathIndex),\n {\n     match lookup_result {\n         LookupResult::Parent(..) => {\n@@ -95,15 +98,16 @@ pub(crate) fn on_all_children_bits<'gcx, 'tcx, F>(\n     body: &Body<'tcx>,\n     move_data: &MoveData<'tcx>,\n     move_path_index: MovePathIndex,\n-    mut each_child: F)\n-    where F: FnMut(MovePathIndex)\n+    mut each_child: F,\n+) where\n+    F: FnMut(MovePathIndex),\n {\n     fn is_terminal_path<'gcx, 'tcx>(\n         tcx: TyCtxt<'gcx, 'tcx>,\n         body: &Body<'tcx>,\n         move_data: &MoveData<'tcx>,\n-        path: MovePathIndex) -> bool\n-    {\n+        path: MovePathIndex,\n+    ) -> bool {\n         place_contents_drop_state_cannot_differ(\n             tcx, body, &move_data.move_paths[path].place)\n     }\n@@ -113,8 +117,9 @@ pub(crate) fn on_all_children_bits<'gcx, 'tcx, F>(\n         body: &Body<'tcx>,\n         move_data: &MoveData<'tcx>,\n         move_path_index: MovePathIndex,\n-        each_child: &mut F)\n-        where F: FnMut(MovePathIndex)\n+        each_child: &mut F,\n+    ) where\n+        F: FnMut(MovePathIndex),\n     {\n         each_child(move_path_index);\n \n@@ -136,8 +141,9 @@ pub(crate) fn on_all_drop_children_bits<'gcx, 'tcx, F>(\n     body: &Body<'tcx>,\n     ctxt: &MoveDataParamEnv<'gcx, 'tcx>,\n     path: MovePathIndex,\n-    mut each_child: F)\n-    where F: FnMut(MovePathIndex)\n+    mut each_child: F,\n+) where\n+    F: FnMut(MovePathIndex),\n {\n     on_all_children_bits(tcx, body, &ctxt.move_data, path, |child| {\n         let place = &ctxt.move_data.move_paths[path].place;\n@@ -158,8 +164,9 @@ pub(crate) fn drop_flag_effects_for_function_entry<'gcx, 'tcx, F>(\n     tcx: TyCtxt<'gcx, 'tcx>,\n     body: &Body<'tcx>,\n     ctxt: &MoveDataParamEnv<'gcx, 'tcx>,\n-    mut callback: F)\n-    where F: FnMut(MovePathIndex, DropFlagState)\n+    mut callback: F,\n+) where\n+    F: FnMut(MovePathIndex, DropFlagState),\n {\n     let move_data = &ctxt.move_data;\n     for arg in body.args_iter() {\n@@ -176,8 +183,9 @@ pub(crate) fn drop_flag_effects_for_location<'gcx, 'tcx, F>(\n     body: &Body<'tcx>,\n     ctxt: &MoveDataParamEnv<'gcx, 'tcx>,\n     loc: Location,\n-    mut callback: F)\n-    where F: FnMut(MovePathIndex, DropFlagState)\n+    mut callback: F,\n+) where\n+    F: FnMut(MovePathIndex, DropFlagState),\n {\n     let move_data = &ctxt.move_data;\n     debug!(\"drop_flag_effects_for_location({:?})\", loc);\n@@ -208,8 +216,9 @@ pub(crate) fn for_location_inits<'gcx, 'tcx, F>(\n     body: &Body<'tcx>,\n     move_data: &MoveData<'tcx>,\n     loc: Location,\n-    mut callback: F)\n-    where F: FnMut(MovePathIndex)\n+    mut callback: F,\n+) where\n+    F: FnMut(MovePathIndex),\n {\n     for ii in &move_data.init_loc_map[loc] {\n         let init = move_data.inits[*ii];"}, {"sha": "4148ffc465cf46d02740691f6a0e125c642b0d86", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -70,11 +70,11 @@ pub struct MaybeInitializedPlaces<'a, 'gcx: 'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx: 'tcx, 'tcx> MaybeInitializedPlaces<'a, 'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'gcx, 'tcx>,\n-               body: &'a Body<'tcx>,\n-               mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n-               -> Self\n-    {\n+    pub fn new(\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        body: &'a Body<'tcx>,\n+        mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n+    ) -> Self {\n         MaybeInitializedPlaces { tcx: tcx, body: body, mdpe: mdpe }\n     }\n }\n@@ -125,11 +125,11 @@ pub struct MaybeUninitializedPlaces<'a, 'gcx: 'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> MaybeUninitializedPlaces<'a, 'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'gcx, 'tcx>,\n-               body: &'a Body<'tcx>,\n-               mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n-               -> Self\n-    {\n+    pub fn new(\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        body: &'a Body<'tcx>,\n+        mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n+    ) -> Self {\n         MaybeUninitializedPlaces { tcx: tcx, body: body, mdpe: mdpe }\n     }\n }\n@@ -179,11 +179,11 @@ pub struct DefinitelyInitializedPlaces<'a, 'gcx: 'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx: 'a> DefinitelyInitializedPlaces<'a, 'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'gcx, 'tcx>,\n-               body: &'a Body<'tcx>,\n-               mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n-               -> Self\n-    {\n+    pub fn new(\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        body: &'a Body<'tcx>,\n+        mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n+    ) -> Self {\n         DefinitelyInitializedPlaces { tcx: tcx, body: body, mdpe: mdpe }\n     }\n }\n@@ -228,11 +228,11 @@ pub struct EverInitializedPlaces<'a, 'gcx: 'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx: 'tcx, 'tcx: 'a> EverInitializedPlaces<'a, 'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'gcx, 'tcx>,\n-               body: &'a Body<'tcx>,\n-               mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n-               -> Self\n-    {\n+    pub fn new(\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        body: &'a Body<'tcx>,\n+        mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n+    ) -> Self {\n         EverInitializedPlaces { tcx: tcx, body: body, mdpe: mdpe }\n     }\n }"}, {"sha": "10e46507d5a26306250bfbcefbb0bfb8b474492a", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -121,29 +121,36 @@ pub struct MoveDataParamEnv<'gcx, 'tcx> {\n     pub(crate) param_env: ty::ParamEnv<'gcx>,\n }\n \n-pub(crate) fn do_dataflow<'a, 'gcx, 'tcx, BD, P>(tcx: TyCtxt<'gcx, 'tcx>,\n-                                                 body: &'a Body<'tcx>,\n-                                                 def_id: DefId,\n-                                                 attributes: &[ast::Attribute],\n-                                                 dead_unwinds: &BitSet<BasicBlock>,\n-                                                 bd: BD,\n-                                                 p: P)\n-                                                 -> DataflowResults<'tcx, BD>\n-    where BD: BitDenotation<'tcx> + InitialFlow,\n-          P: Fn(&BD, BD::Idx) -> DebugFormatted\n+pub(crate) fn do_dataflow<'a, 'gcx, 'tcx, BD, P>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n+    body: &'a Body<'tcx>,\n+    def_id: DefId,\n+    attributes: &[ast::Attribute],\n+    dead_unwinds: &BitSet<BasicBlock>,\n+    bd: BD,\n+    p: P,\n+) -> DataflowResults<'tcx, BD>\n+where\n+    BD: BitDenotation<'tcx> + InitialFlow,\n+    P: Fn(&BD, BD::Idx) -> DebugFormatted,\n {\n     let flow_state = DataflowAnalysis::new(body, dead_unwinds, bd);\n     flow_state.run(tcx, def_id, attributes, p)\n }\n \n-impl<'a, 'gcx: 'tcx, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitDenotation<'tcx>\n+impl<'a, 'gcx: 'tcx, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD>\n+where\n+    BD: BitDenotation<'tcx>,\n {\n-    pub(crate) fn run<P>(self,\n-                         tcx: TyCtxt<'gcx, 'tcx>,\n-                         def_id: DefId,\n-                         attributes: &[ast::Attribute],\n-                         p: P) -> DataflowResults<'tcx, BD>\n-        where P: Fn(&BD, BD::Idx) -> DebugFormatted\n+    pub(crate) fn run<P>(\n+        self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        def_id: DefId,\n+        attributes: &[ast::Attribute],\n+        p: P,\n+    ) -> DataflowResults<'tcx, BD>\n+    where\n+        P: Fn(&BD, BD::Idx) -> DebugFormatted,\n     {\n         let name_found = |sess: &Session, attrs: &[ast::Attribute], name| -> Option<String> {\n             if let Some(item) = has_rustc_mir_with(attrs, name) {"}, {"sha": "3acbf2a2f6987e7fe0d4edb672395f3e6a30940b", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -204,7 +204,7 @@ impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n \n pub(super) fn gather_moves<'gcx, 'tcx>(\n     body: &Body<'tcx>,\n-    tcx: TyCtxt<'gcx, 'tcx>\n+    tcx: TyCtxt<'gcx, 'tcx>,\n ) -> Result<MoveData<'tcx>, (MoveData<'tcx>, Vec<(Place<'tcx>, MoveError<'tcx>)>)> {\n     let mut builder = MoveDataBuilder::new(body, tcx);\n "}, {"sha": "33b8134eec91805752590a78ed1167a3e16a951e", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -306,8 +306,10 @@ impl<'tcx> MoveError<'tcx> {\n }\n \n impl<'gcx, 'tcx> MoveData<'tcx> {\n-    pub fn gather_moves(body: &Body<'tcx>, tcx: TyCtxt<'gcx, 'tcx>)\n-                        -> Result<Self, (Self, Vec<(Place<'tcx>, MoveError<'tcx>)>)> {\n+    pub fn gather_moves(\n+        body: &Body<'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+    ) -> Result<Self, (Self, Vec<(Place<'tcx>, MoveError<'tcx>)>)> {\n         builder::gather_moves(body, tcx)\n     }\n "}, {"sha": "71a274f456a0e2caa28b538add393c68b31f5322", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -195,7 +195,7 @@ pub fn expand_pattern<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>, pat: Pattern<'tcx\n }\n \n struct LiteralExpander<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>\n+    tcx: TyCtxt<'tcx, 'tcx>,\n }\n \n impl LiteralExpander<'tcx> {\n@@ -368,8 +368,10 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n         tcx: TyCtxt<'tcx, 'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         module: DefId,\n-        f: F) -> R\n-        where F: for<'b> FnOnce(MatchCheckCtxt<'b, 'tcx>) -> R\n+        f: F,\n+    ) -> R\n+    where\n+        F: for<'b> FnOnce(MatchCheckCtxt<'b, 'tcx>) -> R,\n     {\n         let pattern_arena = TypedArena::default();\n \n@@ -827,9 +829,7 @@ struct IntRange<'tcx> {\n }\n \n impl<'tcx> IntRange<'tcx> {\n-    fn from_ctor(tcx: TyCtxt<'tcx, 'tcx>,\n-                 ctor: &Constructor<'tcx>)\n-                 -> Option<IntRange<'tcx>> {\n+    fn from_ctor(tcx: TyCtxt<'tcx, 'tcx>, ctor: &Constructor<'tcx>) -> Option<IntRange<'tcx>> {\n         // Floating-point ranges are permitted and we don't want\n         // to consider them when constructing integer ranges.\n         fn is_integral<'tcx>(ty: Ty<'tcx>) -> bool {\n@@ -867,9 +867,7 @@ impl<'tcx> IntRange<'tcx> {\n         }\n     }\n \n-    fn from_pat(tcx: TyCtxt<'tcx, 'tcx>,\n-                mut pat: &Pattern<'tcx>)\n-                -> Option<IntRange<'tcx>> {\n+    fn from_pat(tcx: TyCtxt<'tcx, 'tcx>, mut pat: &Pattern<'tcx>) -> Option<IntRange<'tcx>> {\n         let range = loop {\n             match pat.kind {\n                 box PatternKind::Constant { value } => break ConstantValue(value),\n@@ -917,10 +915,11 @@ impl<'tcx> IntRange<'tcx> {\n \n     /// Returns a collection of ranges that spans the values covered by `ranges`, subtracted\n     /// by the values covered by `self`: i.e., `ranges \\ self` (in set notation).\n-    fn subtract_from(self,\n-                     tcx: TyCtxt<'tcx, 'tcx>,\n-                     ranges: Vec<Constructor<'tcx>>)\n-                     -> Vec<Constructor<'tcx>> {\n+    fn subtract_from(\n+        self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        ranges: Vec<Constructor<'tcx>>,\n+    ) -> Vec<Constructor<'tcx>> {\n         let ranges = ranges.into_iter().filter_map(|r| {\n             IntRange::from_ctor(tcx, &r).map(|i| i.range)\n         });\n@@ -1429,7 +1428,7 @@ fn slice_pat_covered_by_const<'tcx>(\n     const_val: &'tcx ty::Const<'tcx>,\n     prefix: &[Pattern<'tcx>],\n     slice: &Option<Pattern<'tcx>>,\n-    suffix: &[Pattern<'tcx>]\n+    suffix: &[Pattern<'tcx>],\n ) -> Result<bool, ErrorReported> {\n     let data: &[u8] = match (const_val.val, &const_val.ty.sty) {\n         (ConstValue::ByRef(ptr, alloc), ty::Array(t, n)) => {\n@@ -1476,10 +1475,7 @@ fn slice_pat_covered_by_const<'tcx>(\n \n // Whether to evaluate a constructor using exhaustive integer matching. This is true if the\n // constructor is a range or constant with an integer type.\n-fn should_treat_range_exhaustively(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    ctor: &Constructor<'tcx>,\n-) -> bool {\n+fn should_treat_range_exhaustively(tcx: TyCtxt<'tcx, 'tcx>, ctor: &Constructor<'tcx>) -> bool {\n     let ty = match ctor {\n         ConstantValue(value) => value.ty,\n         ConstantRange(_, _, ty, _) => ty,"}, {"sha": "4b6be426e5178c0ffb8d62caab55d872dbeede16", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -335,10 +335,12 @@ pub struct PatternContext<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> Pattern<'tcx> {\n-    pub fn from_hir(tcx: TyCtxt<'tcx, 'tcx>,\n-                    param_env_and_substs: ty::ParamEnvAnd<'tcx, SubstsRef<'tcx>>,\n-                    tables: &'a ty::TypeckTables<'tcx>,\n-                    pat: &'tcx hir::Pat) -> Self {\n+    pub fn from_hir(\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        param_env_and_substs: ty::ParamEnvAnd<'tcx, SubstsRef<'tcx>>,\n+        tables: &'a ty::TypeckTables<'tcx>,\n+        pat: &'tcx hir::Pat,\n+    ) -> Self {\n         let mut pcx = PatternContext::new(tcx, param_env_and_substs, tables);\n         let result = pcx.lower_pattern(pat);\n         if !pcx.errors.is_empty() {\n@@ -351,9 +353,11 @@ impl<'a, 'tcx> Pattern<'tcx> {\n }\n \n impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'tcx, 'tcx>,\n-               param_env_and_substs: ty::ParamEnvAnd<'tcx, SubstsRef<'tcx>>,\n-               tables: &'a ty::TypeckTables<'tcx>) -> Self {\n+    pub fn new(\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        param_env_and_substs: ty::ParamEnvAnd<'tcx, SubstsRef<'tcx>>,\n+        tables: &'a ty::TypeckTables<'tcx>,\n+    ) -> Self {\n         PatternContext {\n             tcx,\n             param_env: param_env_and_substs.param_env,"}, {"sha": "45c1f71e95043a2ae6d777e64b4b72f513904eb7", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -43,10 +43,8 @@ pub struct InterpretCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     pub(crate) stack: Vec<Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>>,\n \n     /// A cache for deduplicating vtables\n-    pub(super) vtables: FxHashMap<\n-        (Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>),\n-        Pointer<M::PointerTag>\n-    >,\n+    pub(super) vtables:\n+        FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), Pointer<M::PointerTag>>,\n }\n \n /// A stack frame.\n@@ -160,17 +158,16 @@ impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout\n-    for InterpretCx<'mir, 'tcx, M>\n-{\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for InterpretCx<'mir, 'tcx, M> {\n     #[inline]\n     fn data_layout(&self) -> &layout::TargetDataLayout {\n         &self.tcx.data_layout\n     }\n }\n \n impl<'mir, 'tcx, M> layout::HasTyCtxt<'tcx> for InterpretCx<'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>\n+where\n+    M: Machine<'mir, 'tcx>,\n {\n     #[inline]\n     fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n@@ -179,16 +176,15 @@ impl<'mir, 'tcx, M> layout::HasTyCtxt<'tcx> for InterpretCx<'mir, 'tcx, M>\n }\n \n impl<'mir, 'tcx, M> layout::HasParamEnv<'tcx> for InterpretCx<'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>\n+where\n+    M: Machine<'mir, 'tcx>,\n {\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.param_env\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf\n-    for InterpretCx<'mir, 'tcx, M>\n-{\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf for InterpretCx<'mir, 'tcx, M> {\n     type Ty = Ty<'tcx>;\n     type TyLayout = InterpResult<'tcx, TyLayout<'tcx>>;\n \n@@ -200,11 +196,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf\n }\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n-    pub fn new(\n-        tcx: TyCtxtAt<'tcx, 'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        machine: M,\n-    ) -> Self {\n+    pub fn new(tcx: TyCtxtAt<'tcx, 'tcx>, param_env: ty::ParamEnv<'tcx>, machine: M) -> Self {\n         InterpretCx {\n             machine,\n             tcx,"}, {"sha": "a44a20adbca0e6b2700533361507fa24b5f152a7", "filename": "src/librustc_mir/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -225,10 +225,7 @@ pub fn type_name<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, ty: Ty<'tcx>) -> &'tcx ty::Const\n }\n \n /// Directly returns an `Allocation` containing an absolute path representation of the given type.\n-pub(super) fn alloc_type_name<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    ty: Ty<'tcx>\n-) -> &'tcx Allocation {\n+pub(super) fn alloc_type_name<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, ty: Ty<'tcx>) -> &'tcx Allocation {\n     let path = AbsolutePathPrinter { tcx, path: String::new() }.print_type(ty).unwrap().path;\n     let alloc = Allocation::from_byte_aligned_bytes(path.into_bytes());\n     tcx.intern_const_alloc(alloc)"}, {"sha": "97e65733bd4094ba1f657133c55eb6d9d3db04e6", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -201,9 +201,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     }\n \n     /// Called immediately before a new stack frame got pushed\n-    fn stack_push(\n-        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n-    ) -> InterpResult<'tcx, Self::FrameExtra>;\n+    fn stack_push(ecx: &mut InterpretCx<'mir, 'tcx, Self>) -> InterpResult<'tcx, Self::FrameExtra>;\n \n     /// Called immediately after a stack frame gets popped\n     fn stack_pop("}, {"sha": "d9f522ab12f24f671254f2735a13f3ff9255f24f", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -69,9 +69,7 @@ pub struct Memory<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     pub(super) tcx: TyCtxtAt<'tcx, 'tcx>,\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout\n-    for Memory<'mir, 'tcx, M>\n-{\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for Memory<'mir, 'tcx, M> {\n     #[inline]\n     fn data_layout(&self) -> &TargetDataLayout {\n         &self.tcx.data_layout\n@@ -80,12 +78,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout\n \n // FIXME: Really we shouldn't clone memory, ever. Snapshot machinery should instead\n // carefully copy only the reachable parts.\n-impl<'mir, 'tcx, M>\n-    Clone\n-for\n-    Memory<'mir, 'tcx, M>\n+impl<'mir, 'tcx, M> Clone for Memory<'mir, 'tcx, M>\n where\n-    M: Machine<'mir, 'tcx, PointerTag=(), AllocExtra=(), MemoryExtra=()>,\n+    M: Machine<'mir, 'tcx, PointerTag = (), AllocExtra = (), MemoryExtra = ()>,\n     M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation)>,\n {\n     fn clone(&self) -> Self {\n@@ -641,7 +636,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n /// Interning (for CTFE)\n impl<'mir, 'tcx, M> Memory<'mir, 'tcx, M>\n where\n-    M: Machine<'mir, 'tcx, PointerTag=(), AllocExtra=(), MemoryExtra=()>,\n+    M: Machine<'mir, 'tcx, PointerTag = (), AllocExtra = (), MemoryExtra = ()>,\n     // FIXME: Working around https://github.com/rust-lang/rust/issues/24159\n     M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation)>,\n {"}, {"sha": "b8bb54815d8bf66ef81e1eb7d48d6ff2eb98538f", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -294,7 +294,7 @@ impl<'mir, 'tcx, Tag, M> InterpretCx<'mir, 'tcx, M>\n where\n     // FIXME: Working around https://github.com/rust-lang/rust/issues/54385\n     Tag: ::std::fmt::Debug + Copy + Eq + Hash + 'static,\n-    M: Machine<'mir, 'tcx, PointerTag=Tag>,\n+    M: Machine<'mir, 'tcx, PointerTag = Tag>,\n     // FIXME: Working around https://github.com/rust-lang/rust/issues/24159\n     M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation<Tag, M::AllocExtra>)>,\n     M::AllocExtra: AllocationExtra<Tag>,\n@@ -396,8 +396,7 @@ where\n     pub fn mplace_array_fields(\n         &self,\n         base: MPlaceTy<'tcx, Tag>,\n-    ) ->\n-        InterpResult<'tcx, impl Iterator<Item=InterpResult<'tcx, MPlaceTy<'tcx, Tag>>> + 'tcx>\n+    ) -> InterpResult<'tcx, impl Iterator<Item = InterpResult<'tcx, MPlaceTy<'tcx, Tag>>> + 'tcx>\n     {\n         let len = base.len(self)?; // also asserts that we have a type where this makes sense\n         let stride = match base.layout.fields {"}, {"sha": "f52fa0cd482725dbae3ad4bc01d7e6a8c81f8a1b", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -43,8 +43,7 @@ pub(crate) struct InfiniteLoopDetector<'mir, 'tcx> {\n     snapshots: FxHashSet<InterpSnapshot<'mir, 'tcx>>,\n }\n \n-impl<'mir, 'tcx> InfiniteLoopDetector<'mir, 'tcx>\n-{\n+impl<'mir, 'tcx> InfiniteLoopDetector<'mir, 'tcx> {\n     pub fn observe_and_analyze(\n         &mut self,\n         tcx: TyCtxt<'tcx, 'tcx>,\n@@ -392,7 +391,7 @@ struct InterpSnapshot<'mir, 'tcx> {\n impl InterpSnapshot<'mir, 'tcx> {\n     fn new(\n         memory: &Memory<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n-        stack: &[Frame<'mir, 'tcx>]\n+        stack: &[Frame<'mir, 'tcx>],\n     ) -> Self {\n         InterpSnapshot {\n             memory: memory.clone(),\n@@ -407,7 +406,6 @@ impl InterpSnapshot<'mir, 'tcx> {\n         // Start with the stack, iterate and recursively snapshot\n         self.stack.iter().map(|frame| frame.snapshot(&self.memory)).collect()\n     }\n-\n }\n \n impl<'mir, 'tcx> Hash for InterpSnapshot<'mir, 'tcx> {"}, {"sha": "8a8cc0fe1d174a3c2da6ad8fb569d53af91a5b24", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -235,8 +235,8 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n     }\n }\n \n-impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>>\n-    ValueVisitor<'mir, 'tcx, M> for ValidityVisitor<'rt, 'mir, 'tcx, M>\n+impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n+    for ValidityVisitor<'rt, 'mir, 'tcx, M>\n {\n     type V = OpTy<'tcx, M::PointerTag>;\n "}, {"sha": "9150f16526ba7ee7c7b6551279c874862eebe4fe", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -14,8 +14,7 @@ use super::{\n // A thing that we can project into, and that has a layout.\n // This wouldn't have to depend on `Machine` but with the current type inference,\n // that's just more convenient to work with (avoids repeating all the `Machine` bounds).\n-pub trait Value<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Copy\n-{\n+pub trait Value<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Copy {\n     /// Gets this value's layout.\n     fn layout(&self) -> TyLayout<'tcx>;\n \n@@ -45,9 +44,7 @@ pub trait Value<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Copy\n \n // Operands and memory-places are both values.\n // Places in general are not due to `place_field` having to do `force_allocation`.\n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M>\n-    for OpTy<'tcx, M::PointerTag>\n-{\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tcx, M::PointerTag> {\n     #[inline(always)]\n     fn layout(&self) -> TyLayout<'tcx> {\n         self.layout\n@@ -84,9 +81,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M>\n         ecx.operand_field(self, field)\n     }\n }\n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M>\n-    for MPlaceTy<'tcx, M::PointerTag>\n-{\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for MPlaceTy<'tcx, M::PointerTag> {\n     #[inline(always)]\n     fn layout(&self) -> TyLayout<'tcx> {\n         self.layout"}, {"sha": "621fb8a4b22b360dc4a4ab973de59cf7c6ce117a", "filename": "src/librustc_mir/lints.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flints.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -7,20 +7,20 @@ use rustc::mir::{self, Body, TerminatorKind};\n use rustc::ty::{self, AssocItem, AssocItemContainer, Instance, TyCtxt};\n use rustc::ty::subst::InternalSubsts;\n \n-pub fn check(tcx: TyCtxt<'tcx, 'tcx>,\n-             body: &Body<'tcx>,\n-             def_id: DefId) {\n+pub fn check(tcx: TyCtxt<'tcx, 'tcx>, body: &Body<'tcx>, def_id: DefId) {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n     if let Some(fn_like_node) = FnLikeNode::from_node(tcx.hir().get_by_hir_id(hir_id)) {\n         check_fn_for_unconditional_recursion(tcx, fn_like_node.kind(), body, def_id);\n     }\n }\n \n-fn check_fn_for_unconditional_recursion(tcx: TyCtxt<'tcx, 'tcx>,\n-                                        fn_kind: FnKind<'_>,\n-                                        body: &Body<'tcx>,\n-                                        def_id: DefId) {\n+fn check_fn_for_unconditional_recursion(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    fn_kind: FnKind<'_>,\n+    body: &Body<'tcx>,\n+    def_id: DefId,\n+) {\n     if let FnKind::Closure(_) = fn_kind {\n         // closures can't recur, so they don't matter.\n         return;"}, {"sha": "0b7dbfeacda594c215ef76dbeba919645965203c", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 73, "deletions": 62, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -281,10 +281,10 @@ impl<'tcx> InliningMap<'tcx> {\n     }\n }\n \n-pub fn collect_crate_mono_items<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                          mode: MonoItemCollectionMode)\n-                                          -> (FxHashSet<MonoItem<'tcx>>,\n-                                                     InliningMap<'tcx>) {\n+pub fn collect_crate_mono_items<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    mode: MonoItemCollectionMode,\n+) -> (FxHashSet<MonoItem<'tcx>>, InliningMap<'tcx>) {\n     let roots = time(tcx.sess, \"collecting roots\", || {\n         collect_roots(tcx, mode)\n     });\n@@ -315,9 +315,10 @@ pub fn collect_crate_mono_items<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n \n // Find all non-generic items by walking the HIR. These items serve as roots to\n // start monomorphizing from.\n-fn collect_roots<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                           mode: MonoItemCollectionMode)\n-                           -> Vec<MonoItem<'tcx>> {\n+fn collect_roots<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    mode: MonoItemCollectionMode,\n+) -> Vec<MonoItem<'tcx>> {\n     debug!(\"Collecting roots\");\n     let mut roots = Vec::new();\n \n@@ -347,11 +348,13 @@ fn collect_roots<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n }\n \n // Collect all monomorphized items reachable from `starting_point`\n-fn collect_items_rec<'a, 'tcx: 'a>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                   starting_point: MonoItem<'tcx>,\n-                                   visited: MTRef<'_, MTLock<FxHashSet<MonoItem<'tcx>>>>,\n-                                   recursion_depths: &mut DefIdMap<usize>,\n-                                   inlining_map: MTRef<'_, MTLock<InliningMap<'tcx>>>) {\n+fn collect_items_rec<'a, 'tcx: 'a>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    starting_point: MonoItem<'tcx>,\n+    visited: MTRef<'_, MTLock<FxHashSet<MonoItem<'tcx>>>>,\n+    recursion_depths: &mut DefIdMap<usize>,\n+    inlining_map: MTRef<'_, MTLock<InliningMap<'tcx>>>,\n+) {\n     if !visited.lock_mut().insert(starting_point.clone()) {\n         // We've been here already, no need to search again.\n         return;\n@@ -413,10 +416,12 @@ fn collect_items_rec<'a, 'tcx: 'a>(tcx: TyCtxt<'tcx, 'tcx>,\n     debug!(\"END collect_items_rec({})\", starting_point.to_string(tcx, true));\n }\n \n-fn record_accesses<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                             caller: MonoItem<'tcx>,\n-                             callees: &[MonoItem<'tcx>],\n-                             inlining_map: MTRef<'_, MTLock<InliningMap<'tcx>>>) {\n+fn record_accesses<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    caller: MonoItem<'tcx>,\n+    callees: &[MonoItem<'tcx>],\n+    inlining_map: MTRef<'_, MTLock<InliningMap<'tcx>>>,\n+) {\n     let is_inlining_candidate = |mono_item: &MonoItem<'tcx>| {\n         mono_item.instantiation_mode(tcx) == InstantiationMode::LocalCopy\n     };\n@@ -429,10 +434,11 @@ fn record_accesses<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n     inlining_map.lock_mut().record_accesses(caller, accesses);\n }\n \n-fn check_recursion_limit<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                   instance: Instance<'tcx>,\n-                                   recursion_depths: &mut DefIdMap<usize>)\n-                                   -> (DefId, usize) {\n+fn check_recursion_limit<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    instance: Instance<'tcx>,\n+    recursion_depths: &mut DefIdMap<usize>,\n+) -> (DefId, usize) {\n     let def_id = instance.def_id();\n     let recursion_depth = recursion_depths.get(&def_id).cloned().unwrap_or(0);\n     debug!(\" => recursion depth={}\", recursion_depth);\n@@ -463,9 +469,7 @@ fn check_recursion_limit<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n     (def_id, recursion_depth)\n }\n \n-fn check_type_length_limit<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                     instance: Instance<'tcx>)\n-{\n+fn check_type_length_limit<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, instance: Instance<'tcx>) {\n     let type_length = instance.substs.types().flat_map(|ty| ty.walk()).count();\n     let const_length = instance.substs.consts().flat_map(|ct| ct.ty.walk()).count();\n     debug!(\" => type length={}, const length={}\", type_length, const_length);\n@@ -679,20 +683,22 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n     }\n }\n \n-fn visit_drop_use<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                            ty: Ty<'tcx>,\n-                            is_direct_call: bool,\n-                            output: &mut Vec<MonoItem<'tcx>>)\n-{\n+fn visit_drop_use<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    ty: Ty<'tcx>,\n+    is_direct_call: bool,\n+    output: &mut Vec<MonoItem<'tcx>>,\n+) {\n     let instance = Instance::resolve_drop_in_place(tcx, ty);\n     visit_instance_use(tcx, instance, is_direct_call, output);\n }\n \n-fn visit_fn_use<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                          ty: Ty<'tcx>,\n-                          is_direct_call: bool,\n-                          output: &mut Vec<MonoItem<'tcx>>)\n-{\n+fn visit_fn_use<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    ty: Ty<'tcx>,\n+    is_direct_call: bool,\n+    output: &mut Vec<MonoItem<'tcx>>,\n+) {\n     if let ty::FnDef(def_id, substs) = ty.sty {\n         let instance = ty::Instance::resolve(tcx,\n                                              ty::ParamEnv::reveal_all(),\n@@ -702,11 +708,12 @@ fn visit_fn_use<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n     }\n }\n \n-fn visit_instance_use<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                instance: ty::Instance<'tcx>,\n-                                is_direct_call: bool,\n-                                output: &mut Vec<MonoItem<'tcx>>)\n-{\n+fn visit_instance_use<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    instance: ty::Instance<'tcx>,\n+    is_direct_call: bool,\n+    output: &mut Vec<MonoItem<'tcx>>,\n+) {\n     debug!(\"visit_item_use({:?}, is_direct_call={:?})\", instance, is_direct_call);\n     if !should_monomorphize_locally(tcx, &instance) {\n         return\n@@ -741,8 +748,7 @@ fn visit_instance_use<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n // Returns true if we should codegen an instance in the local crate.\n // Returns false if we can just link to the upstream crate and therefore don't\n // need a mono item.\n-fn should_monomorphize_locally<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, instance: &Instance<'tcx>)\n-                                         -> bool {\n+fn should_monomorphize_locally<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, instance: &Instance<'tcx>) -> bool {\n     let def_id = match instance.def {\n         ty::InstanceDef::Item(def_id) => def_id,\n         ty::InstanceDef::VtableShim(..) |\n@@ -776,10 +782,11 @@ fn should_monomorphize_locally<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, instance: &Instanc\n     }\n     return true;\n \n-    fn is_available_upstream_generic<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                               def_id: DefId,\n-                                               substs: SubstsRef<'tcx>)\n-                                               -> bool {\n+    fn is_available_upstream_generic<'tcx>(\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        def_id: DefId,\n+        substs: SubstsRef<'tcx>,\n+    ) -> bool {\n         debug_assert!(!def_id.is_local());\n \n         // If we are not in share generics mode, we don't link to upstream\n@@ -841,10 +848,11 @@ fn should_monomorphize_locally<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, instance: &Instanc\n ///\n /// Finally, there is also the case of custom unsizing coercions, e.g., for\n /// smart pointers such as `Rc` and `Arc`.\n-fn find_vtable_types_for_unsizing<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                            source_ty: Ty<'tcx>,\n-                                            target_ty: Ty<'tcx>)\n-                                            -> (Ty<'tcx>, Ty<'tcx>) {\n+fn find_vtable_types_for_unsizing<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    source_ty: Ty<'tcx>,\n+    target_ty: Ty<'tcx>,\n+) -> (Ty<'tcx>, Ty<'tcx>) {\n     let ptr_vtable = |inner_source: Ty<'tcx>, inner_target: Ty<'tcx>| {\n         let type_has_metadata = |ty: Ty<'tcx>| -> bool {\n             use syntax_pos::DUMMY_SP;\n@@ -914,10 +922,12 @@ fn create_fn_mono_item<'tcx>(instance: Instance<'tcx>) -> MonoItem<'tcx> {\n \n /// Creates a `MonoItem` for each method that is referenced by the vtable for\n /// the given trait/impl pair.\n-fn create_mono_items_for_vtable_methods<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                                  trait_ty: Ty<'tcx>,\n-                                                  impl_ty: Ty<'tcx>,\n-                                                  output: &mut Vec<MonoItem<'tcx>>) {\n+fn create_mono_items_for_vtable_methods<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    trait_ty: Ty<'tcx>,\n+    impl_ty: Ty<'tcx>,\n+    output: &mut Vec<MonoItem<'tcx>>,\n+) {\n     assert!(!trait_ty.needs_subst() && !trait_ty.has_escaping_bound_vars() &&\n             !impl_ty.needs_subst() && !impl_ty.has_escaping_bound_vars());\n \n@@ -1112,9 +1122,11 @@ fn item_requires_monomorphization<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId)\n     generics.requires_monomorphization(tcx)\n }\n \n-fn create_mono_items_for_default_impls<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                                 item: &'tcx hir::Item,\n-                                                 output: &mut Vec<MonoItem<'tcx>>) {\n+fn create_mono_items_for_default_impls<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    item: &'tcx hir::Item,\n+    output: &mut Vec<MonoItem<'tcx>>,\n+) {\n     match item.node {\n         hir::ItemKind::Impl(_, _, _, ref generics, .., ref impl_item_refs) => {\n             for param in &generics.params {\n@@ -1207,10 +1219,11 @@ fn collect_miri<'tcx>(\n }\n \n /// Scan the MIR in order to find function calls, closures, and drop-glue\n-fn collect_neighbours<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                instance: Instance<'tcx>,\n-                                output: &mut Vec<MonoItem<'tcx>>)\n-{\n+fn collect_neighbours<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    instance: Instance<'tcx>,\n+    output: &mut Vec<MonoItem<'tcx>>,\n+) {\n     let body = tcx.instance_mir(instance.def);\n \n     MirNeighborCollector {\n@@ -1237,9 +1250,7 @@ fn collect_neighbours<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n     }\n }\n \n-fn def_id_to_string<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                              def_id: DefId)\n-                              -> String {\n+fn def_id_to_string<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> String {\n     let mut output = String::new();\n     let printer = DefPathBasedNames::new(tcx, false, false);\n     printer.push_def_path(def_id, &mut output);"}, {"sha": "1450534af5e5625c49e7c1c0d5b2f769f29a38ae", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -62,9 +62,7 @@ pub trait MonoItemExt<'tcx>: fmt::Debug {\n             }\n         }\n     }\n-    fn instantiation_mode(&self,\n-                          tcx: TyCtxt<'tcx, 'tcx>)\n-                          -> InstantiationMode {\n+    fn instantiation_mode(&self, tcx: TyCtxt<'tcx, 'tcx>) -> InstantiationMode {\n         let inline_in_all_cgus =\n             tcx.sess.opts.debugging_opts.inline_in_all_cgus.unwrap_or_else(|| {\n                 tcx.sess.opts.optimize != OptLevel::No\n@@ -170,11 +168,12 @@ pub trait MonoItemExt<'tcx>: fmt::Debug {\n             }\n         };\n \n-        fn to_string_internal<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                        prefix: &str,\n-                                        instance: Instance<'tcx>,\n-                                        debug: bool)\n-                                        -> String {\n+        fn to_string_internal<'a, 'tcx>(\n+            tcx: TyCtxt<'tcx, 'tcx>,\n+            prefix: &str,\n+            instance: Instance<'tcx>,\n+            debug: bool,\n+        ) -> String {\n             let mut result = String::with_capacity(32);\n             result.push_str(prefix);\n             let printer = DefPathBasedNames::new(tcx, false, false);"}, {"sha": "667c0d7b29c5e0ee7eb61ba449ba3fcc451b888c", "filename": "src/librustc_mir/monomorphize/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -5,10 +5,11 @@ use rustc::ty::{self, Ty, TyCtxt};\n pub mod collector;\n pub mod partitioning;\n \n-pub fn custom_coerce_unsize_info<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                           source_ty: Ty<'tcx>,\n-                                           target_ty: Ty<'tcx>)\n-                                           -> CustomCoerceUnsized {\n+pub fn custom_coerce_unsize_info<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    source_ty: Ty<'tcx>,\n+    target_ty: Ty<'tcx>,\n+) -> CustomCoerceUnsized {\n     let def_id = tcx.lang_items().coerce_unsized_trait().unwrap();\n \n     let trait_ref = ty::Binder::bind(ty::TraitRef {"}, {"sha": "f05ccc45c9c4ccb555bf7af3199138d8317a6419", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 46, "deletions": 36, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -125,12 +125,14 @@ fn fallback_cgu_name(name_builder: &mut CodegenUnitNameBuilder<'_, '_>) -> Inter\n     name_builder.build_cgu_name(LOCAL_CRATE, &[\"fallback\"], Some(\"cgu\"))\n }\n \n-pub fn partition<'tcx, I>(tcx: TyCtxt<'tcx, 'tcx>,\n-                              mono_items: I,\n-                              strategy: PartitioningStrategy,\n-                              inlining_map: &InliningMap<'tcx>)\n-                              -> Vec<CodegenUnit<'tcx>>\n-    where I: Iterator<Item = MonoItem<'tcx>>\n+pub fn partition<'tcx, I>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    mono_items: I,\n+    strategy: PartitioningStrategy,\n+    inlining_map: &InliningMap<'tcx>,\n+) -> Vec<CodegenUnit<'tcx>>\n+where\n+    I: Iterator<Item = MonoItem<'tcx>>,\n {\n     // In the first step, we place all regular monomorphizations into their\n     // respective 'home' codegen unit. Regular monomorphizations are all\n@@ -201,10 +203,12 @@ struct PostInliningPartitioning<'tcx> {\n     internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n }\n \n-fn place_root_mono_items<'tcx, I>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                             mono_items: I)\n-                                             -> PreInliningPartitioning<'tcx>\n-    where I: Iterator<Item = MonoItem<'tcx>>\n+fn place_root_mono_items<'tcx, I>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    mono_items: I,\n+) -> PreInliningPartitioning<'tcx>\n+where\n+    I: Iterator<Item = MonoItem<'tcx>>,\n {\n     let mut roots = FxHashSet::default();\n     let mut codegen_units = FxHashMap::default();\n@@ -463,9 +467,11 @@ fn default_visibility(tcx: TyCtxt<'_, '_>, id: DefId, is_generic: bool) -> Visib\n     }\n }\n \n-fn merge_codegen_units<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                             initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n-                             target_cgu_count: usize) {\n+fn merge_codegen_units<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n+    target_cgu_count: usize,\n+) {\n     assert!(target_cgu_count >= 1);\n     let codegen_units = &mut initial_partitioning.codegen_units;\n \n@@ -585,9 +591,11 @@ fn place_inlined_mono_items<'tcx>(initial_partitioning: PreInliningPartitioning<\n     }\n }\n \n-fn internalize_symbols<'tcx>(_tcx: TyCtxt<'tcx, 'tcx>,\n-                                 partitioning: &mut PostInliningPartitioning<'tcx>,\n-                                 inlining_map: &InliningMap<'tcx>) {\n+fn internalize_symbols<'tcx>(\n+    _tcx: TyCtxt<'tcx, 'tcx>,\n+    partitioning: &mut PostInliningPartitioning<'tcx>,\n+    inlining_map: &InliningMap<'tcx>,\n+) {\n     if partitioning.codegen_units.len() == 1 {\n         // Fast path for when there is only one codegen unit. In this case we\n         // can internalize all candidates, since there is nowhere else they\n@@ -650,9 +658,10 @@ fn internalize_symbols<'tcx>(_tcx: TyCtxt<'tcx, 'tcx>,\n     }\n }\n \n-fn characteristic_def_id_of_mono_item<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                                mono_item: MonoItem<'tcx>)\n-                                                -> Option<DefId> {\n+fn characteristic_def_id_of_mono_item<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    mono_item: MonoItem<'tcx>,\n+) -> Option<DefId> {\n     match mono_item {\n         MonoItem::Fn(instance) => {\n             let def_id = match instance.def {\n@@ -698,12 +707,13 @@ fn characteristic_def_id_of_mono_item<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n \n type CguNameCache = FxHashMap<(DefId, bool), InternedString>;\n \n-fn compute_codegen_unit_name(tcx: TyCtxt<'_, '_>,\n-                             name_builder: &mut CodegenUnitNameBuilder<'_, '_>,\n-                             def_id: DefId,\n-                             volatile: bool,\n-                             cache: &mut CguNameCache)\n-                             -> InternedString {\n+fn compute_codegen_unit_name(\n+    tcx: TyCtxt<'_, '_>,\n+    name_builder: &mut CodegenUnitNameBuilder<'_, '_>,\n+    def_id: DefId,\n+    volatile: bool,\n+    cache: &mut CguNameCache,\n+) -> InternedString {\n     // Find the innermost module that is not nested within a function.\n     let mut current_def_id = def_id;\n     let mut cgu_def_id = None;\n@@ -752,17 +762,17 @@ fn compute_codegen_unit_name(tcx: TyCtxt<'_, '_>,\n     }).clone()\n }\n \n-fn numbered_codegen_unit_name(name_builder: &mut CodegenUnitNameBuilder<'_, '_>,\n-                              index: usize)\n-                              -> InternedString {\n+fn numbered_codegen_unit_name(\n+    name_builder: &mut CodegenUnitNameBuilder<'_, '_>,\n+    index: usize,\n+) -> InternedString {\n     name_builder.build_cgu_name_no_mangle(LOCAL_CRATE, &[\"cgu\"], Some(index))\n }\n \n-fn debug_dump<'a, 'b, 'tcx, I>(tcx: TyCtxt<'tcx, 'tcx>,\n-                               label: &str,\n-                               cgus: I)\n-    where I: Iterator<Item=&'b CodegenUnit<'tcx>>,\n-          'tcx: 'a + 'b\n+fn debug_dump<'a, 'b, 'tcx, I>(tcx: TyCtxt<'tcx, 'tcx>, label: &str, cgus: I)\n+where\n+    I: Iterator<Item = &'b CodegenUnit<'tcx>>,\n+    'tcx: 'a + 'b,\n {\n     if cfg!(debug_assertions) {\n         debug!(\"{}\", label);\n@@ -788,7 +798,8 @@ fn debug_dump<'a, 'b, 'tcx, I>(tcx: TyCtxt<'tcx, 'tcx>,\n \n #[inline(never)] // give this a place in the profiler\n fn assert_symbols_are_distinct<'a, 'tcx: 'a, I>(tcx: TyCtxt<'tcx, 'tcx>, mono_items: I)\n-    where I: Iterator<Item=&'a MonoItem<'tcx>>\n+where\n+    I: Iterator<Item = &'a MonoItem<'tcx>>,\n {\n     let mut symbols: Vec<_> = mono_items.map(|mono_item| {\n         (mono_item, mono_item.symbol_name(tcx))\n@@ -833,8 +844,7 @@ fn assert_symbols_are_distinct<'a, 'tcx: 'a, I>(tcx: TyCtxt<'tcx, 'tcx>, mono_it\n fn collect_and_partition_mono_items<'tcx>(\n     tcx: TyCtxt<'tcx, 'tcx>,\n     cnum: CrateNum,\n-) -> (Arc<DefIdSet>, Arc<Vec<Arc<CodegenUnit<'tcx>>>>)\n-{\n+) -> (Arc<DefIdSet>, Arc<Vec<Arc<CodegenUnit<'tcx>>>>) {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     let collection_mode = match tcx.sess.opts.debugging_opts.print_mono_items {"}, {"sha": "ea11901672a23369bb9fbad7ae73ffa899876b43", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 18, "deletions": 25, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -26,10 +26,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     providers.mir_shims = make_shim;\n }\n \n-fn make_shim<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                       instance: ty::InstanceDef<'tcx>)\n-                       -> &'tcx Body<'tcx>\n-{\n+fn make_shim<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx Body<'tcx> {\n     debug!(\"make_shim({:?})\", instance);\n \n     let mut result = match instance {\n@@ -166,11 +163,11 @@ fn local_decls_for_sig<'tcx>(sig: &ty::FnSig<'tcx>, span: Span)\n         .collect()\n }\n \n-fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                             def_id: DefId,\n-                             ty: Option<Ty<'tcx>>)\n-                             -> Body<'tcx>\n-{\n+fn build_drop_shim<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    def_id: DefId,\n+    ty: Option<Ty<'tcx>>,\n+) -> Body<'tcx> {\n     debug!(\"build_drop_shim(def_id={:?}, ty={:?})\", def_id, ty);\n \n     // Check if this is a generator, if so, return the drop glue for it\n@@ -273,7 +270,9 @@ impl<'a, 'tcx> DropElaborator<'a, 'tcx> for DropShimElaborator<'a, 'tcx> {\n \n     fn patch(&mut self) -> &mut MirPatch<'tcx> { &mut self.patch }\n     fn body(&self) -> &'a Body<'tcx> { self.body }\n-    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> { self.tcx }\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n+        self.tcx\n+        }\n     fn param_env(&self) -> ty::ParamEnv<'tcx> { self.param_env }\n \n     fn drop_style(&self, _path: Self::Path, mode: DropFlagMode) -> DropStyle {\n@@ -306,11 +305,7 @@ impl<'a, 'tcx> DropElaborator<'a, 'tcx> for DropShimElaborator<'a, 'tcx> {\n }\n \n /// Builds a `Clone::clone` shim for `self_ty`. Here, `def_id` is `Clone::clone`.\n-fn build_clone_shim<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                              def_id: DefId,\n-                              self_ty: Ty<'tcx>)\n-                              -> Body<'tcx>\n-{\n+fn build_clone_shim<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -> Body<'tcx> {\n     debug!(\"build_clone_shim(def_id={:?})\", def_id);\n \n     let mut builder = CloneShimBuilder::new(tcx, def_id, self_ty);\n@@ -350,9 +345,7 @@ struct CloneShimBuilder<'tcx> {\n }\n \n impl CloneShimBuilder<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx, 'tcx>,\n-           def_id: DefId,\n-           self_ty: Ty<'tcx>) -> Self {\n+    fn new(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -> Self {\n         // we must subst the self_ty because it's\n         // otherwise going to be TySelf and we can't index\n         // or access fields of a Place of type TySelf.\n@@ -691,13 +684,13 @@ impl CloneShimBuilder<'tcx> {\n ///\n /// If `untuple_args` is a vec of types, the second argument of the\n /// function will be untupled as these types.\n-fn build_call_shim<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                             def_id: DefId,\n-                             rcvr_adjustment: Adjustment,\n-                             call_kind: CallKind,\n-                             untuple_args: Option<&[Ty<'tcx>]>)\n-                             -> Body<'tcx>\n-{\n+fn build_call_shim<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    def_id: DefId,\n+    rcvr_adjustment: Adjustment,\n+    call_kind: CallKind,\n+    untuple_args: Option<&[Ty<'tcx>]>,\n+) -> Body<'tcx> {\n     debug!(\"build_call_shim(def_id={:?}, rcvr_adjustment={:?}, \\\n             call_kind={:?}, untuple_args={:?})\",\n            def_id, rcvr_adjustment, call_kind, untuple_args);"}, {"sha": "56c824167e185bfaa9bec1e9a6a9046f17842611", "filename": "src/librustc_mir/transform/add_call_guards.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -31,10 +31,12 @@ pub use self::AddCallGuards::*;\n  */\n \n impl MirPass for AddCallGuards {\n-    fn run_pass<'tcx>(&self,\n-                          _tcx: TyCtxt<'tcx, 'tcx>,\n-                          _src: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(\n+        &self,\n+        _tcx: TyCtxt<'tcx, 'tcx>,\n+        _src: MirSource<'tcx>,\n+        body: &mut Body<'tcx>,\n+    ) {\n         self.add_call_guards(body);\n     }\n }"}, {"sha": "673b13a22d3d72aef2e93bdf9269ef5933745c2d", "filename": "src/librustc_mir/transform/add_moves_for_packed_drops.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -40,11 +40,7 @@ use crate::util;\n pub struct AddMovesForPackedDrops;\n \n impl MirPass for AddMovesForPackedDrops {\n-    fn run_pass<'tcx>(&self,\n-                          tcx: TyCtxt<'tcx, 'tcx>,\n-                          src: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>)\n-    {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         debug!(\"add_moves_for_packed_drops({:?} @ {:?})\", src, body.span);\n         add_moves_for_packed_drops(tcx, body, src.def_id());\n     }\n@@ -53,18 +49,17 @@ impl MirPass for AddMovesForPackedDrops {\n pub fn add_moves_for_packed_drops<'tcx>(\n     tcx: TyCtxt<'tcx, 'tcx>,\n     body: &mut Body<'tcx>,\n-    def_id: DefId)\n-{\n+    def_id: DefId,\n+) {\n     let patch = add_moves_for_packed_drops_patch(tcx, body, def_id);\n     patch.apply(body);\n }\n \n fn add_moves_for_packed_drops_patch<'tcx>(\n     tcx: TyCtxt<'tcx, 'tcx>,\n     body: &Body<'tcx>,\n-    def_id: DefId)\n-    -> MirPatch<'tcx>\n-{\n+    def_id: DefId,\n+) -> MirPatch<'tcx> {\n     let mut patch = MirPatch::new(body);\n     let param_env = tcx.param_env(def_id);\n \n@@ -96,8 +91,8 @@ fn add_move_for_packed_drop<'tcx>(\n     patch: &mut MirPatch<'tcx>,\n     terminator: &Terminator<'tcx>,\n     loc: Location,\n-    is_cleanup: bool)\n-{\n+    is_cleanup: bool,\n+) {\n     debug!(\"add_move_for_packed_drop({:?} @ {:?})\", terminator, loc);\n     let (location, target, unwind) = match terminator.kind {\n         TerminatorKind::Drop { ref location, target, unwind } =>"}, {"sha": "a67fce9028a324e1983db49d79400780717bdabd", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -74,11 +74,12 @@ fn may_have_reference<'gcx, 'tcx>(ty: Ty<'tcx>, tcx: TyCtxt<'gcx, 'tcx>) -> bool\n }\n \n impl MirPass for AddRetag {\n-    fn run_pass<'tcx>(&self,\n-                          tcx: TyCtxt<'tcx, 'tcx>,\n-                          _src: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>)\n-    {\n+    fn run_pass<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        _src: MirSource<'tcx>,\n+        body: &mut Body<'tcx>,\n+    ) {\n         if !tcx.sess.opts.debugging_opts.mir_emit_retag {\n             return;\n         }"}, {"sha": "0adb37b8722a34bb03475365acb9fe7c13ec9e14", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -480,11 +480,12 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UnusedUnsafeVisitor<'a> {\n     }\n }\n \n-fn check_unused_unsafe<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                 def_id: DefId,\n-                                 used_unsafe: &FxHashSet<hir::HirId>,\n-                                 unsafe_blocks: &'a mut Vec<(hir::HirId, bool)>)\n-{\n+fn check_unused_unsafe<'a, 'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    def_id: DefId,\n+    used_unsafe: &FxHashSet<hir::HirId>,\n+    unsafe_blocks: &'a mut Vec<(hir::HirId, bool)>,\n+) {\n     let body_id =\n         tcx.hir().as_local_hir_id(def_id).and_then(|hir_id| {\n             tcx.hir().maybe_body_owned_by_by_hir_id(hir_id)\n@@ -505,9 +506,7 @@ fn check_unused_unsafe<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n     hir::intravisit::Visitor::visit_body(&mut visitor, body);\n }\n \n-fn unsafety_check_result<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId)\n-                                   -> UnsafetyCheckResult\n-{\n+fn unsafety_check_result<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> UnsafetyCheckResult {\n     debug!(\"unsafety_violations({:?})\", def_id);\n \n     // N.B., this borrow is valid because all the consumers of\n@@ -566,9 +565,11 @@ fn unsafe_derive_on_repr_packed<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) {\n }\n \n /// Returns the `HirId` for an enclosing scope that is also `unsafe`.\n-fn is_enclosed(tcx: TyCtxt<'_, '_>,\n-               used_unsafe: &FxHashSet<hir::HirId>,\n-               id: hir::HirId) -> Option<(String, hir::HirId)> {\n+fn is_enclosed(\n+    tcx: TyCtxt<'_, '_>,\n+    used_unsafe: &FxHashSet<hir::HirId>,\n+    id: hir::HirId,\n+) -> Option<(String, hir::HirId)> {\n     let parent_id = tcx.hir().get_parent_node_by_hir_id(id);\n     if parent_id != id {\n         if used_unsafe.contains(&parent_id) {\n@@ -589,9 +590,7 @@ fn is_enclosed(tcx: TyCtxt<'_, '_>,\n     }\n }\n \n-fn report_unused_unsafe(tcx: TyCtxt<'_, '_>,\n-                        used_unsafe: &FxHashSet<hir::HirId>,\n-                        id: hir::HirId) {\n+fn report_unused_unsafe(tcx: TyCtxt<'_, '_>, used_unsafe: &FxHashSet<hir::HirId>, id: hir::HirId) {\n     let span = tcx.sess.source_map().def_span(tcx.hir().span_by_hir_id(id));\n     let msg = \"unnecessary `unsafe` block\";\n     let mut db = tcx.struct_span_lint_hir(UNUSED_UNSAFE, id, span, msg);"}, {"sha": "fb4fdf73a9389b1a05e763e2071493a8b8487337", "filename": "src/librustc_mir/transform/cleanup_post_borrowck.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -27,10 +27,12 @@ pub struct CleanupNonCodegenStatements;\n pub struct DeleteNonCodegenStatements;\n \n impl MirPass for CleanupNonCodegenStatements {\n-    fn run_pass<'tcx>(&self,\n-                          _tcx: TyCtxt<'tcx, 'tcx>,\n-                          _source: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(\n+        &self,\n+        _tcx: TyCtxt<'tcx, 'tcx>,\n+        _source: MirSource<'tcx>,\n+        body: &mut Body<'tcx>,\n+    ) {\n         let mut delete = DeleteNonCodegenStatements;\n         delete.visit_body(body);\n     }"}, {"sha": "dfc2e7e7c9d86b118d943bacdadd39bcd0e43a49", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -31,10 +31,12 @@ use crate::transform::{MirPass, MirSource};\n pub struct ConstProp;\n \n impl MirPass for ConstProp {\n-    fn run_pass<'tcx>(&self,\n-                          tcx: TyCtxt<'tcx, 'tcx>,\n-                          source: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        source: MirSource<'tcx>,\n+        body: &mut Body<'tcx>,\n+    ) {\n         // will be evaluated by miri and produce its errors there\n         if source.promoted.is_some() {\n             return;\n@@ -599,9 +601,11 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     }\n }\n \n-fn type_size_of<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                          param_env: ty::ParamEnv<'tcx>,\n-                          ty: Ty<'tcx>) -> Option<u64> {\n+fn type_size_of<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> Option<u64> {\n     tcx.layout_of(param_env.and(ty)).ok().map(|layout| layout.size.bytes())\n }\n "}, {"sha": "aeb3ed5a2eca85170db79f3b9bea5b0d6ec6fba3", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -30,10 +30,12 @@ use crate::util::def_use::DefUseAnalysis;\n pub struct CopyPropagation;\n \n impl MirPass for CopyPropagation {\n-    fn run_pass<'tcx>(&self,\n-                          tcx: TyCtxt<'tcx, 'tcx>,\n-                          _source: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        _source: MirSource<'tcx>,\n+        body: &mut Body<'tcx>,\n+    ) {\n         // We only run when the MIR optimization level is > 1.\n         // This avoids a slow pass, and messing up debug info.\n         if tcx.sess.opts.debugging_opts.mir_opt_level <= 1 {"}, {"sha": "87704f12216560463a8989d352eef02848ebd114", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -6,10 +6,12 @@ use crate::util::expand_aggregate;\n pub struct Deaggregator;\n \n impl MirPass for Deaggregator {\n-    fn run_pass<'tcx>(&self,\n-                          tcx: TyCtxt<'tcx, 'tcx>,\n-                          _source: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        _source: MirSource<'tcx>,\n+        body: &mut Body<'tcx>,\n+    ) {\n         let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n         let local_decls = &*local_decls;\n         for bb in basic_blocks {"}, {"sha": "96be0e6f6a9d7cd942ff8ab72446c342210ec1cb", "filename": "src/librustc_mir/transform/dump_mir.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -18,11 +18,12 @@ impl MirPass for Marker {\n         Cow::Borrowed(self.0)\n     }\n \n-    fn run_pass<'tcx>(&self,\n-                          _tcx: TyCtxt<'tcx, 'tcx>,\n-                          _source: MirSource<'tcx>,\n-                          _body: &mut Body<'tcx>)\n-    {\n+    fn run_pass<'tcx>(\n+        &self,\n+        _tcx: TyCtxt<'tcx, 'tcx>,\n+        _source: MirSource<'tcx>,\n+        _body: &mut Body<'tcx>,\n+    ) {\n     }\n }\n \n@@ -37,13 +38,14 @@ impl fmt::Display for Disambiguator {\n     }\n }\n \n-\n-pub fn on_mir_pass<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                             pass_num: &dyn fmt::Display,\n-                             pass_name: &str,\n-                             source: MirSource<'tcx>,\n-                             body: &Body<'tcx>,\n-                             is_after: bool) {\n+pub fn on_mir_pass<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    pass_num: &dyn fmt::Display,\n+    pass_name: &str,\n+    source: MirSource<'tcx>,\n+    body: &Body<'tcx>,\n+    is_after: bool,\n+) {\n     if mir_util::dump_enabled(tcx, pass_name, source) {\n         mir_util::dump_mir(tcx,\n                            Some(pass_num),\n@@ -55,11 +57,7 @@ pub fn on_mir_pass<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n     }\n }\n \n-pub fn emit_mir<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    outputs: &OutputFilenames)\n-    -> io::Result<()>\n-{\n+pub fn emit_mir<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, outputs: &OutputFilenames) -> io::Result<()> {\n     let path = outputs.path(OutputType::Mir);\n     let mut f = File::create(&path)?;\n     mir_util::write_mir_pretty(tcx, None, &mut f)?;"}, {"sha": "bf6237fa91acfe4683a57f89ee4a64bc57132813", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -21,11 +21,7 @@ use syntax_pos::Span;\n pub struct ElaborateDrops;\n \n impl MirPass for ElaborateDrops {\n-    fn run_pass<'tcx>(&self,\n-                          tcx: TyCtxt<'tcx, 'tcx>,\n-                          src: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>)\n-    {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         debug!(\"elaborate_drops({:?} @ {:?})\", src, body.span);\n \n         let def_id = src.def_id();\n@@ -77,13 +73,12 @@ impl MirPass for ElaborateDrops {\n /// Returns the set of basic blocks whose unwind edges are known\n /// to not be reachable, because they are `drop` terminators\n /// that can't drop anything.\n-fn find_dead_unwinds< 'tcx>(\n+fn find_dead_unwinds<'tcx>(\n     tcx: TyCtxt<'tcx, 'tcx>,\n     body: &Body<'tcx>,\n     def_id: hir::def_id::DefId,\n-    env: &MoveDataParamEnv<'tcx, 'tcx>)\n-    -> BitSet<BasicBlock>\n-{\n+    env: &MoveDataParamEnv<'tcx, 'tcx>,\n+) -> BitSet<BasicBlock> {\n     debug!(\"find_dead_unwinds({:?})\", body.span);\n     // We only need to do this pass once, because unwind edges can only\n     // reach cleanup blocks, which can't have unwind edges themselves.\n@@ -141,12 +136,13 @@ struct InitializationData {\n }\n \n impl InitializationData {\n-    fn apply_location<'tcx>(&mut self,\n-                               tcx: TyCtxt<'tcx, 'tcx>,\n-                               body: &Body<'tcx>,\n-                               env: &MoveDataParamEnv<'tcx, 'tcx>,\n-                               loc: Location)\n-    {\n+    fn apply_location<'tcx>(\n+        &mut self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        body: &Body<'tcx>,\n+        env: &MoveDataParamEnv<'tcx, 'tcx>,\n+        loc: Location,\n+    ) {\n         drop_flag_effects_for_location(tcx, body, env, loc, |path, df| {\n             debug!(\"at location {:?}: setting {:?} to {:?}\",\n                    loc, path, df);\n@@ -294,7 +290,7 @@ struct ElaborateDropsCtxt<'a, 'tcx: 'a> {\n     body: &'a Body<'tcx>,\n     env: &'a MoveDataParamEnv<'tcx, 'tcx>,\n     flow_inits: DataflowResults<'tcx, MaybeInitializedPlaces<'a, 'tcx, 'tcx>>,\n-    flow_uninits:  DataflowResults<'tcx, MaybeUninitializedPlaces<'a, 'tcx, 'tcx>>,\n+    flow_uninits: DataflowResults<'tcx, MaybeUninitializedPlaces<'a, 'tcx, 'tcx>>,\n     drop_flags: FxHashMap<MovePathIndex, Local>,\n     patch: MirPatch<'tcx>,\n }"}, {"sha": "39d5770ee9a091ece623992fed352c0dfecfb7c6", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -50,10 +50,7 @@ impl MutVisitor<'tcx> for EraseRegionsVisitor<'tcx> {\n pub struct EraseRegions;\n \n impl MirPass for EraseRegions {\n-    fn run_pass<'tcx>(&self,\n-                          tcx: TyCtxt<'tcx, 'tcx>,\n-                          _: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         EraseRegionsVisitor::new(tcx).visit_body(body);\n     }\n }"}, {"sha": "d369fec8c1e67133454a5be1d01f4ac32265a965", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 57, "deletions": 46, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -311,9 +311,10 @@ impl MutVisitor<'tcx> for TransformVisitor<'tcx> {\n }\n \n fn make_generator_state_argument_indirect<'tcx>(\n-                tcx: TyCtxt<'tcx, 'tcx>,\n-                def_id: DefId,\n-                body: &mut Body<'tcx>) {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    def_id: DefId,\n+    body: &mut Body<'tcx>,\n+) {\n     let gen_ty = body.local_decls.raw[1].ty;\n \n     let region = ty::ReFree(ty::FreeRegion {\n@@ -335,9 +336,7 @@ fn make_generator_state_argument_indirect<'tcx>(\n     DerefArgVisitor.visit_body(body);\n }\n \n-fn make_generator_state_argument_pinned<'tcx>(\n-                tcx: TyCtxt<'tcx, 'tcx>,\n-                body: &mut Body<'tcx>) {\n+fn make_generator_state_argument_pinned<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, body: &mut Body<'tcx>) {\n     let ref_gen_ty = body.local_decls.raw[1].ty;\n \n     let pin_did = tcx.lang_items().pin_type().unwrap();\n@@ -678,16 +677,18 @@ impl<'body, 'tcx: 'body, 's> StorageConflictVisitor<'body, 'tcx, 's> {\n     }\n }\n \n-fn compute_layout<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                            source: MirSource<'tcx>,\n-                            upvars: &Vec<Ty<'tcx>>,\n-                            interior: Ty<'tcx>,\n-                            movable: bool,\n-                            body: &mut Body<'tcx>)\n-    -> (FxHashMap<Local, (Ty<'tcx>, VariantIdx, usize)>,\n-        GeneratorLayout<'tcx>,\n-        FxHashMap<BasicBlock, liveness::LiveVarSet>)\n-{\n+fn compute_layout<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    source: MirSource<'tcx>,\n+    upvars: &Vec<Ty<'tcx>>,\n+    interior: Ty<'tcx>,\n+    movable: bool,\n+    body: &mut Body<'tcx>,\n+) -> (\n+    FxHashMap<Local, (Ty<'tcx>, VariantIdx, usize)>,\n+    GeneratorLayout<'tcx>,\n+    FxHashMap<BasicBlock, liveness::LiveVarSet>,\n+) {\n     // Use a liveness analysis to compute locals which are live across a suspension point\n     let LivenessInfo {\n         live_locals, live_locals_at_suspension_points, storage_conflicts, storage_liveness\n@@ -767,10 +768,12 @@ fn compute_layout<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n     (remap, layout, storage_liveness)\n }\n \n-fn insert_switch<'tcx>(body: &mut Body<'tcx>,\n-                           cases: Vec<(usize, BasicBlock)>,\n-                           transform: &TransformVisitor<'tcx>,\n-                           default: TerminatorKind<'tcx>) {\n+fn insert_switch<'tcx>(\n+    body: &mut Body<'tcx>,\n+    cases: Vec<(usize, BasicBlock)>,\n+    transform: &TransformVisitor<'tcx>,\n+    default: TerminatorKind<'tcx>,\n+) {\n     let default_block = insert_term_block(body, default);\n     let (assign, discr) = transform.get_discr(body);\n     let switch = TerminatorKind::SwitchInt {\n@@ -797,9 +800,7 @@ fn insert_switch<'tcx>(body: &mut Body<'tcx>,\n     }\n }\n \n-fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                       def_id: DefId,\n-                                       body: &mut Body<'tcx>) {\n+fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId, body: &mut Body<'tcx>) {\n     use crate::util::elaborate_drops::{elaborate_drop, Unwind};\n     use crate::util::patch::MirPatch;\n     use crate::shim::DropShimElaborator;\n@@ -849,13 +850,14 @@ fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n }\n \n fn create_generator_drop_shim<'tcx>(\n-                tcx: TyCtxt<'tcx, 'tcx>,\n-                transform: &TransformVisitor<'tcx>,\n-                def_id: DefId,\n-                source: MirSource<'tcx>,\n-                gen_ty: Ty<'tcx>,\n-                body: &Body<'tcx>,\n-                drop_clean: BasicBlock) -> Body<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    transform: &TransformVisitor<'tcx>,\n+    def_id: DefId,\n+    source: MirSource<'tcx>,\n+    gen_ty: Ty<'tcx>,\n+    body: &Body<'tcx>,\n+    drop_clean: BasicBlock,\n+) -> Body<'tcx> {\n     let mut body = body.clone();\n \n     let source_info = source_info(&body);\n@@ -939,9 +941,11 @@ fn insert_term_block<'tcx>(body: &mut Body<'tcx>, kind: TerminatorKind<'tcx>) ->\n     term_block\n }\n \n-fn insert_panic_block<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                body: &mut Body<'tcx>,\n-                                message: AssertMessage<'tcx>) -> BasicBlock {\n+fn insert_panic_block<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    body: &mut Body<'tcx>,\n+    message: AssertMessage<'tcx>,\n+) -> BasicBlock {\n     let assert_block = BasicBlock::new(body.basic_blocks().len());\n     let term = TerminatorKind::Assert {\n         cond: Operand::Constant(box Constant {\n@@ -970,11 +974,12 @@ fn insert_panic_block<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n }\n \n fn create_generator_resume_function<'tcx>(\n-        tcx: TyCtxt<'tcx, 'tcx>,\n-        transform: TransformVisitor<'tcx>,\n-        def_id: DefId,\n-        source: MirSource<'tcx>,\n-        body: &mut Body<'tcx>) {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    transform: TransformVisitor<'tcx>,\n+    def_id: DefId,\n+    source: MirSource<'tcx>,\n+    body: &mut Body<'tcx>,\n+) {\n     // Poison the generator when it unwinds\n     for block in body.basic_blocks_mut() {\n         let source_info = block.terminator().source_info;\n@@ -1042,10 +1047,14 @@ fn insert_clean_drop<'tcx>(body: &mut Body<'tcx>) -> BasicBlock {\n     drop_clean\n }\n \n-fn create_cases<'tcx, F>(body: &mut Body<'tcx>,\n-                          transform: &TransformVisitor<'tcx>,\n-                          target: F) -> Vec<(usize, BasicBlock)>\n-    where F: Fn(&SuspensionPoint) -> Option<BasicBlock> {\n+fn create_cases<'tcx, F>(\n+    body: &mut Body<'tcx>,\n+    transform: &TransformVisitor<'tcx>,\n+    target: F,\n+) -> Vec<(usize, BasicBlock)>\n+where\n+    F: Fn(&SuspensionPoint) -> Option<BasicBlock>,\n+{\n     let source_info = source_info(body);\n \n     transform.suspension_points.iter().filter_map(|point| {\n@@ -1083,10 +1092,12 @@ fn create_cases<'tcx, F>(body: &mut Body<'tcx>,\n }\n \n impl MirPass for StateTransform {\n-    fn run_pass<'tcx>(&self,\n-                    tcx: TyCtxt<'tcx, 'tcx>,\n-                    source: MirSource<'tcx>,\n-                    body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        source: MirSource<'tcx>,\n+        body: &mut Body<'tcx>,\n+    ) {\n         let yield_ty = if let Some(yield_ty) = body.yield_ty {\n             yield_ty\n         } else {"}, {"sha": "55c035f2858a28aef8d1612398d896b687be4c37", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -38,10 +38,12 @@ struct CallSite<'tcx> {\n }\n \n impl MirPass for Inline {\n-    fn run_pass<'tcx>(&self,\n-                          tcx: TyCtxt<'tcx, 'tcx>,\n-                          source: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        source: MirSource<'tcx>,\n+        body: &mut Body<'tcx>,\n+    ) {\n         if tcx.sess.opts.debugging_opts.mir_opt_level >= 2 {\n             Inliner { tcx, source }.run_pass(body);\n         }\n@@ -631,9 +633,11 @@ impl Inliner<'tcx> {\n     }\n }\n \n-fn type_size_of<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                          param_env: ty::ParamEnv<'tcx>,\n-                          ty: Ty<'tcx>) -> Option<u64> {\n+fn type_size_of<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> Option<u64> {\n     tcx.layout_of(param_env.and(ty)).ok().map(|layout| layout.size.bytes())\n }\n \n@@ -643,7 +647,7 @@ fn type_size_of<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n  * Integrates blocks from the callee function into the calling function.\n  * Updates block indices, references to locals and other control flow\n  * stuff.\n- */\n+*/\n struct Integrator<'a, 'tcx: 'a> {\n     block_idx: usize,\n     args: &'a [Local],"}, {"sha": "2194b780ab967d12a6e2463725d828a25edc874c", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -12,10 +12,7 @@ use crate::transform::{MirPass, MirSource};\n pub struct InstCombine;\n \n impl MirPass for InstCombine {\n-    fn run_pass<'tcx>(&self,\n-                          tcx: TyCtxt<'tcx, 'tcx>,\n-                          _: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         // We only run when optimizing MIR (at any level).\n         if tcx.sess.opts.debugging_opts.mir_opt_level == 0 {\n             return"}, {"sha": "34a982f72761fc982c38a74d7ae804927fa6c936", "filename": "src/librustc_mir/transform/lower_128bit.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -10,18 +10,20 @@ use crate::transform::{MirPass, MirSource};\n pub struct Lower128Bit;\n \n impl MirPass for Lower128Bit {\n-    fn run_pass<'tcx>(&self,\n-                          tcx: TyCtxt<'tcx, 'tcx>,\n-                          _src: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        _src: MirSource<'tcx>,\n+        body: &mut Body<'tcx>,\n+    ) {\n         let debugging_override = tcx.sess.opts.debugging_opts.lower_128bit_ops;\n         let target_default = tcx.sess.host.options.i128_lowering;\n         if !debugging_override.unwrap_or(target_default) {\n             return\n         }\n \n         self.lower_128bit_ops(tcx, body);\n-    }\n+}\n }\n \n impl Lower128Bit {\n@@ -126,9 +128,10 @@ fn check_lang_item_type<'tcx, D>(\n     lhs: &Operand<'tcx>,\n     rhs: &Operand<'tcx>,\n     local_decls: &D,\n-    tcx: TyCtxt<'tcx, 'tcx>)\n--> DefId\n-    where D: HasLocalDecls<'tcx>\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+) -> DefId\n+where\n+    D: HasLocalDecls<'tcx>,\n {\n     let did = tcx.require_lang_item(lang_item);\n     let poly_sig = tcx.fn_sig(did);\n@@ -142,9 +145,13 @@ fn check_lang_item_type<'tcx, D>(\n     did\n }\n \n-fn lower_to<'tcx, D>(statement: &Statement<'tcx>, local_decls: &D, tcx: TyCtxt<'tcx, 'tcx>)\n-    -> Option<(LangItem, RhsKind)>\n-    where D: HasLocalDecls<'tcx>\n+fn lower_to<'tcx, D>(\n+    statement: &Statement<'tcx>,\n+    local_decls: &D,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+) -> Option<(LangItem, RhsKind)>\n+where\n+    D: HasLocalDecls<'tcx>,\n {\n     match statement.kind {\n         StatementKind::Assign(_, box Rvalue::BinaryOp(bin_op, ref lhs, _)) => {"}, {"sha": "6f369acec64402466d78825f842f2aea1cb9b116", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -56,8 +56,7 @@ fn is_mir_available<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> bool {\n \n /// Finds the full set of `DefId`s within the current crate that have\n /// MIR associated with them.\n-fn mir_keys<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, krate: CrateNum)\n-                      -> &'tcx DefIdSet {\n+fn mir_keys<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, krate: CrateNum) -> &'tcx DefIdSet {\n     assert_eq!(krate, LOCAL_CRATE);\n \n     let mut set = DefIdSet::default();\n@@ -142,10 +141,12 @@ pub trait MirPass {\n         default_name::<Self>()\n     }\n \n-    fn run_pass<'tcx>(&self,\n-                          tcx: TyCtxt<'tcx, 'tcx>,\n-                          source: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>);\n+    fn run_pass<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        source: MirSource<'tcx>,\n+        body: &mut Body<'tcx>,\n+    );\n }\n \n pub fn run_passes("}, {"sha": "6f3f2269d44d2df0200c2e47ff44ce7a2c1c44f6", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -9,10 +9,7 @@ use crate::transform::{MirPass, MirSource};\n pub struct NoLandingPads;\n \n impl MirPass for NoLandingPads {\n-    fn run_pass<'tcx>(&self,\n-                          tcx: TyCtxt<'tcx, 'tcx>,\n-                          _: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         no_landing_pads(tcx, body)\n     }\n }"}, {"sha": "f3d05f065ce73470761d49ffa4fe90ff5d16d585", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -155,7 +155,7 @@ struct Promoter<'a, 'tcx: 'a> {\n \n     /// If true, all nested temps are also kept in the\n     /// source MIR, not moved to the promoted MIR.\n-    keep_original: bool\n+    keep_original: bool,\n }\n \n impl<'a, 'tcx> Promoter<'a, 'tcx> {\n@@ -369,10 +369,12 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Promoter<'a, 'tcx> {\n     }\n }\n \n-pub fn promote_candidates<'tcx>(body: &mut Body<'tcx>,\n-                                    tcx: TyCtxt<'tcx, 'tcx>,\n-                                    mut temps: IndexVec<Local, TempState>,\n-                                    candidates: Vec<Candidate>) {\n+pub fn promote_candidates<'tcx>(\n+    body: &mut Body<'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    mut temps: IndexVec<Local, TempState>,\n+    candidates: Vec<Candidate>,\n+) {\n     // Visit candidates in reverse, in case they're nested.\n     debug!(\"promote_candidates({:?})\", candidates);\n "}, {"sha": "125411a717d1ef2dcb5250aed0e936fa5505fa25", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -652,11 +652,7 @@ impl Deref for Checker<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Checker<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'tcx, 'tcx>,\n-           def_id: DefId,\n-           body: &'a Body<'tcx>,\n-           mode: Mode)\n-           -> Self {\n+    fn new(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId, body: &'a Body<'tcx>, mode: Mode) -> Self {\n         assert!(def_id.is_local());\n         let mut rpo = traversal::reverse_postorder(body);\n         let temps = promote_consts::collect_temps(body, &mut rpo);\n@@ -1472,9 +1468,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn mir_const_qualif<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                              def_id: DefId)\n-                              -> (u8, &'tcx BitSet<Local>) {\n+fn mir_const_qualif<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> (u8, &'tcx BitSet<Local>) {\n     // N.B., this `borrow()` is guaranteed to be valid (i.e., the value\n     // cannot yet be stolen), because `mir_validated()`, which steals\n     // from `mir_const(), forces this query to execute before\n@@ -1492,10 +1486,7 @@ fn mir_const_qualif<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n pub struct QualifyAndPromoteConstants;\n \n impl MirPass for QualifyAndPromoteConstants {\n-    fn run_pass<'tcx>(&self,\n-                          tcx: TyCtxt<'tcx, 'tcx>,\n-                          src: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         // There's not really any point in promoting errorful MIR.\n         if body.return_ty().references_error() {\n             tcx.sess.delay_span_bug(body.span, \"QualifyAndPromoteConstants: MIR had errors\");"}, {"sha": "7f5afb2394a469a65704ce8ff027dd9436d566e8", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -8,11 +8,7 @@ use syntax_pos::Span;\n \n type McfResult = Result<(), (Span, Cow<'static, str>)>;\n \n-pub fn is_min_const_fn(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    def_id: DefId,\n-    body: &'a Body<'tcx>,\n-) -> McfResult {\n+pub fn is_min_const_fn(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId, body: &'a Body<'tcx>) -> McfResult {\n     let mut current = def_id;\n     loop {\n         let predicates = tcx.predicates_of(current);\n@@ -79,12 +75,7 @@ pub fn is_min_const_fn(\n     Ok(())\n }\n \n-fn check_ty(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    ty: Ty<'tcx>,\n-    span: Span,\n-    fn_def_id: DefId,\n-) -> McfResult {\n+fn check_ty(tcx: TyCtxt<'tcx, 'tcx>, ty: Ty<'tcx>, span: Span, fn_def_id: DefId) -> McfResult {\n     for ty in ty.walk() {\n         match ty.sty {\n             ty::Ref(_, _, hir::Mutability::MutMutable) => return Err(("}, {"sha": "1a23fdce050b0d373e64dfbe10c57a64c544f028", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -9,10 +9,7 @@ use crate::util::patch::MirPatch;\n /// code for these.\n pub struct RemoveNoopLandingPads;\n \n-pub fn remove_noop_landing_pads<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    body: &mut Body<'tcx>)\n-{\n+pub fn remove_noop_landing_pads<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, body: &mut Body<'tcx>) {\n     if tcx.sess.no_landing_pads() {\n         return\n     }\n@@ -22,10 +19,12 @@ pub fn remove_noop_landing_pads<'tcx>(\n }\n \n impl MirPass for RemoveNoopLandingPads {\n-    fn run_pass<'tcx>(&self,\n-                          tcx: TyCtxt<'tcx, 'tcx>,\n-                          _src: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        _src: MirSource<'tcx>,\n+        body: &mut Body<'tcx>,\n+    ) {\n         remove_noop_landing_pads(tcx, body);\n     }\n }"}, {"sha": "1d57f5e27164d76a58614017bfcce0c5b6e2148f", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -25,8 +25,7 @@ use crate::dataflow::has_rustc_mir_with;\n pub struct SanityCheck;\n \n impl MirPass for SanityCheck {\n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>,\n-                          src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let def_id = src.def_id();\n         if !tcx.has_attr(def_id, sym::rustc_mir) {\n             debug!(\"skipping rustc_peek::SanityCheck on {}\", tcx.def_path_str(def_id));\n@@ -84,12 +83,14 @@ impl MirPass for SanityCheck {\n /// (If there are any calls to `rustc_peek` that do not match the\n /// expression form above, then that emits an error as well, but those\n /// errors are not intended to be used for unit tests.)\n-pub fn sanity_check_via_rustc_peek<'tcx, O>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                                body: &Body<'tcx>,\n-                                                def_id: DefId,\n-                                                _attributes: &[ast::Attribute],\n-                                                results: &DataflowResults<'tcx, O>)\n-    where O: BitDenotation<'tcx, Idx=MovePathIndex> + HasMoveData<'tcx>\n+pub fn sanity_check_via_rustc_peek<'tcx, O>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    body: &Body<'tcx>,\n+    def_id: DefId,\n+    _attributes: &[ast::Attribute],\n+    results: &DataflowResults<'tcx, O>,\n+) where\n+    O: BitDenotation<'tcx, Idx = MovePathIndex> + HasMoveData<'tcx>,\n {\n     debug!(\"sanity_check_via_rustc_peek def_id: {:?}\", def_id);\n     // FIXME: this is not DRY. Figure out way to abstract this and\n@@ -101,11 +102,13 @@ pub fn sanity_check_via_rustc_peek<'tcx, O>(tcx: TyCtxt<'tcx, 'tcx>,\n     }\n }\n \n-fn each_block<'tcx, O>(tcx: TyCtxt<'tcx, 'tcx>,\n-                           body: &Body<'tcx>,\n-                           results: &DataflowResults<'tcx, O>,\n-                           bb: mir::BasicBlock) where\n-    O: BitDenotation<'tcx, Idx=MovePathIndex> + HasMoveData<'tcx>\n+fn each_block<'tcx, O>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    body: &Body<'tcx>,\n+    results: &DataflowResults<'tcx, O>,\n+    bb: mir::BasicBlock,\n+) where\n+    O: BitDenotation<'tcx, Idx = MovePathIndex> + HasMoveData<'tcx>,\n {\n     let move_data = results.0.operator.move_data();\n     let mir::BasicBlockData { ref statements, ref terminator, is_cleanup: _ } = body[bb];\n@@ -214,9 +217,10 @@ fn each_block<'tcx, O>(tcx: TyCtxt<'tcx, 'tcx>,\n                                       form `&expr`\"));\n }\n \n-fn is_rustc_peek<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                           terminator: &'a Option<mir::Terminator<'tcx>>)\n-                           -> Option<(&'a [mir::Operand<'tcx>], Span)> {\n+fn is_rustc_peek<'a, 'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    terminator: &'a Option<mir::Terminator<'tcx>>,\n+) -> Option<(&'a [mir::Operand<'tcx>], Span)> {\n     if let Some(mir::Terminator { ref kind, source_info, .. }) = *terminator {\n         if let mir::TerminatorKind::Call { func: ref oper, ref args, .. } = *kind {\n             if let mir::Operand::Constant(ref func) = *oper {"}, {"sha": "ba3a00517ffb036b9cc4de4a6cae58465e24c5ac", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -57,10 +57,12 @@ impl MirPass for SimplifyCfg {\n         Cow::Borrowed(&self.label)\n     }\n \n-    fn run_pass<'tcx>(&self,\n-                          _tcx: TyCtxt<'tcx, 'tcx>,\n-                          _src: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(\n+        &self,\n+        _tcx: TyCtxt<'tcx, 'tcx>,\n+        _src: MirSource<'tcx>,\n+        body: &mut Body<'tcx>,\n+    ) {\n         debug!(\"SimplifyCfg({:?}) - simplifying {:?}\", self.label, body);\n         simplify_cfg(body);\n     }\n@@ -296,10 +298,7 @@ pub fn remove_dead_blocks(body: &mut Body<'_>) {\n pub struct SimplifyLocals;\n \n impl MirPass for SimplifyLocals {\n-    fn run_pass<'tcx>(&self,\n-                          tcx: TyCtxt<'tcx, 'tcx>,\n-                          _: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let mut marker = DeclMarker { locals: BitSet::new_empty(body.local_decls.len()) };\n         marker.visit_body(body);\n         // Return pointer and arguments are always live"}, {"sha": "a1c3fec32fcf1b202c03f363fdae9d4e1f2565bd", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -19,10 +19,12 @@ impl MirPass for SimplifyBranches {\n         Cow::Borrowed(&self.label)\n     }\n \n-    fn run_pass<'tcx>(&self,\n-                          tcx: TyCtxt<'tcx, 'tcx>,\n-                          _src: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        _src: MirSource<'tcx>,\n+        body: &mut Body<'tcx>,\n+    ) {\n         for block in body.basic_blocks_mut() {\n             let terminator = block.terminator_mut();\n             terminator.kind = match terminator.kind {"}, {"sha": "4e961d80f4c826fcb9bdc4416f474901aa1006a6", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -37,10 +37,12 @@ use crate::util::patch::MirPatch;\n pub struct UniformArrayMoveOut;\n \n impl MirPass for UniformArrayMoveOut {\n-    fn run_pass<'tcx>(&self,\n-                          tcx: TyCtxt<'tcx, 'tcx>,\n-                          _src: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        _src: MirSource<'tcx>,\n+        body: &mut Body<'tcx>,\n+    ) {\n         let mut patch = MirPatch::new(body);\n         {\n             let mut visitor = UniformArrayMoveOutVisitor{body, patch: &mut patch, tcx};\n@@ -162,10 +164,12 @@ impl<'a, 'tcx> UniformArrayMoveOutVisitor<'a, 'tcx> {\n pub struct RestoreSubsliceArrayMoveOut;\n \n impl MirPass for RestoreSubsliceArrayMoveOut {\n-    fn run_pass<'tcx>(&self,\n-                          tcx: TyCtxt<'tcx, 'tcx>,\n-                          _src: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        _src: MirSource<'tcx>,\n+        body: &mut Body<'tcx>,\n+    ) {\n         let mut patch = MirPatch::new(body);\n         {\n             let mut visitor = RestoreDataCollector {"}, {"sha": "b23ce28f30120f8f32fa9a2e68182193c810afb7", "filename": "src/librustc_mir/util/alignment.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Falignment.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -4,12 +4,14 @@ use rustc::mir::*;\n /// Returns `true` if this place is allowed to be less aligned\n /// than its containing struct (because it is within a packed\n /// struct).\n-pub fn is_disaligned<'tcx, L>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                  local_decls: &L,\n-                                  param_env: ty::ParamEnv<'tcx>,\n-                                  place: &Place<'tcx>)\n-                                  -> bool\n-    where L: HasLocalDecls<'tcx>\n+pub fn is_disaligned<'tcx, L>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    local_decls: &L,\n+    param_env: ty::ParamEnv<'tcx>,\n+    place: &Place<'tcx>,\n+) -> bool\n+where\n+    L: HasLocalDecls<'tcx>,\n {\n     debug!(\"is_disaligned({:?})\", place);\n     if !is_within_packed(tcx, local_decls, place) {\n@@ -32,11 +34,9 @@ pub fn is_disaligned<'tcx, L>(tcx: TyCtxt<'tcx, 'tcx>,\n     }\n }\n \n-fn is_within_packed<'tcx, L>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                 local_decls: &L,\n-                                 place: &Place<'tcx>)\n-                                 -> bool\n-    where L: HasLocalDecls<'tcx>\n+fn is_within_packed<'tcx, L>(tcx: TyCtxt<'tcx, 'tcx>, local_decls: &L, place: &Place<'tcx>) -> bool\n+where\n+    L: HasLocalDecls<'tcx>,\n {\n     let mut place = place;\n     while let &Place::Projection(box Projection {"}, {"sha": "f6cc1033b777cccc88529e1758c793c198129c91", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -70,7 +70,7 @@ impl Unwind {\n     }\n }\n \n-pub trait DropElaborator<'a, 'tcx: 'a> : fmt::Debug {\n+pub trait DropElaborator<'a, 'tcx: 'a>: fmt::Debug {\n     type Path : Copy + fmt::Debug;\n \n     fn patch(&mut self) -> &mut MirPatch<'tcx>;"}, {"sha": "0746434c184b541c4929d5c996433158545062fb", "filename": "src/librustc_mir/util/graphviz.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -8,11 +8,13 @@ use std::io::{self, Write};\n use super::pretty::dump_mir_def_ids;\n \n /// Write a graphviz DOT graph of a list of MIRs.\n-pub fn write_mir_graphviz<'tcx, W>(tcx: TyCtxt<'_, 'tcx>,\n-                                   single: Option<DefId>,\n-                                   w: &mut W)\n-                                   -> io::Result<()>\n-    where W: Write\n+pub fn write_mir_graphviz<'tcx, W>(\n+    tcx: TyCtxt<'_, 'tcx>,\n+    single: Option<DefId>,\n+    w: &mut W,\n+) -> io::Result<()>\n+where\n+    W: Write,\n {\n     for def_id in dump_mir_def_ids(tcx, single) {\n         let body = &tcx.optimized_mir(def_id);\n@@ -32,11 +34,14 @@ pub fn graphviz_safe_def_name(def_id: DefId) -> String {\n }\n \n /// Write a graphviz DOT graph of the MIR.\n-pub fn write_mir_fn_graphviz<'tcx, W>(tcx: TyCtxt<'_, 'tcx>,\n-                                      def_id: DefId,\n-                                      body: &Body<'_>,\n-                                      w: &mut W) -> io::Result<()>\n-    where W: Write\n+pub fn write_mir_fn_graphviz<'tcx, W>(\n+    tcx: TyCtxt<'_, 'tcx>,\n+    def_id: DefId,\n+    body: &Body<'_>,\n+    w: &mut W,\n+) -> io::Result<()>\n+where\n+    W: Write,\n {\n     writeln!(w, \"digraph Mir_{} {{\", graphviz_safe_def_name(def_id))?;\n \n@@ -133,11 +138,12 @@ fn write_edges<W: Write>(source: BasicBlock, body: &Body<'_>, w: &mut W) -> io::\n /// Write the graphviz DOT label for the overall graph. This is essentially a block of text that\n /// will appear below the graph, showing the type of the `fn` this MIR represents and the types of\n /// all the variables and temporaries.\n-fn write_graph_label<'gcx, 'tcx, W: Write>(tcx: TyCtxt<'gcx, 'tcx>,\n-                                               def_id: DefId,\n-                                               body: &Body<'_>,\n-                                               w: &mut W)\n-                                               -> io::Result<()> {\n+fn write_graph_label<'gcx, 'tcx, W: Write>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n+    def_id: DefId,\n+    body: &Body<'_>,\n+    w: &mut W,\n+) -> io::Result<()> {\n     write!(w, \"    label=<fn {}(\", dot::escape_html(&tcx.def_path_str(def_id)))?;\n \n     // fn argument types."}, {"sha": "845290467b91e5391a879f59b5e6afa5cc8d0cc0", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -39,10 +39,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn const_is_rvalue_promotable_to_static<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                                  def_id: DefId)\n-                                                  -> bool\n-{\n+fn const_is_rvalue_promotable_to_static<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> bool {\n     assert!(def_id.is_local());\n \n     let hir_id = tcx.hir().as_local_hir_id(def_id)\n@@ -51,10 +48,7 @@ fn const_is_rvalue_promotable_to_static<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n     tcx.rvalue_promotable_map(def_id).contains(&body_id.hir_id.local_id)\n }\n \n-fn rvalue_promotable_map<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                   def_id: DefId)\n-                                   -> &'tcx ItemLocalSet\n-{\n+fn rvalue_promotable_map<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> &'tcx ItemLocalSet {\n     let outer_def_id = tcx.closure_base_def_id(def_id);\n     if outer_def_id != def_id {\n         return tcx.rvalue_promotable_map(outer_def_id);"}, {"sha": "f5cb04c743250c781ee3f69c65de29d38b490b76", "filename": "src/librustc_plugin/build.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_plugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_plugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fbuild.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -34,10 +34,7 @@ pub fn find_plugin_registrar<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) -> Option<DefId> {\n     tcx.plugin_registrar_fn(LOCAL_CRATE)\n }\n \n-fn plugin_registrar_fn<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    cnum: CrateNum,\n-) -> Option<DefId> {\n+fn plugin_registrar_fn<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, cnum: CrateNum) -> Option<DefId> {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     let mut finder = RegistrarFinder { registrars: Vec::new() };"}, {"sha": "a2da014c912d1d8392fcaeca4db09c1222a2f5b2", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 37, "deletions": 22, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -74,15 +74,17 @@ trait DefIdVisitor<'tcx> {\n }\n \n struct DefIdVisitorSkeleton<'v, 'tcx, V>\n-    where V: DefIdVisitor<'tcx> + ?Sized\n+where\n+    V: DefIdVisitor<'tcx> + ?Sized,\n {\n     def_id_visitor: &'v mut V,\n     visited_opaque_tys: FxHashSet<DefId>,\n     dummy: PhantomData<TyCtxt<'tcx, 'tcx>>,\n }\n \n impl<'tcx, V> DefIdVisitorSkeleton<'_, 'tcx, V>\n-    where V: DefIdVisitor<'tcx> + ?Sized\n+where\n+    V: DefIdVisitor<'tcx> + ?Sized,\n {\n     fn visit_trait(&mut self, trait_ref: TraitRef<'tcx>) -> bool {\n         let TraitRef { def_id, substs } = trait_ref;\n@@ -125,7 +127,8 @@ impl<'tcx, V> DefIdVisitorSkeleton<'_, 'tcx, V>\n }\n \n impl<'tcx, V> TypeVisitor<'tcx> for DefIdVisitorSkeleton<'_, 'tcx, V>\n-    where V: DefIdVisitor<'tcx> + ?Sized\n+where\n+    V: DefIdVisitor<'tcx> + ?Sized,\n {\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n         let tcx = self.def_id_visitor.tcx();\n@@ -220,8 +223,10 @@ impl<'tcx, V> TypeVisitor<'tcx> for DefIdVisitorSkeleton<'_, 'tcx, V>\n     }\n }\n \n-fn def_id_visibility<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId)\n-                               -> (ty::Visibility, Span, &'static str) {\n+fn def_id_visibility<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    def_id: DefId,\n+) -> (ty::Visibility, Span, &'static str) {\n     match tcx.hir().as_local_hir_id(def_id) {\n         Some(hir_id) => {\n             let vis = match tcx.hir().get_by_hir_id(hir_id) {\n@@ -323,16 +328,20 @@ fn def_id_visibility<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId)\n \n // Set the correct `TypeckTables` for the given `item_id` (or an empty table if\n // there is no `TypeckTables` for the item).\n-fn item_tables<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                         hir_id: hir::HirId,\n-                         empty_tables: &'a ty::TypeckTables<'tcx>)\n-                         -> &'a ty::TypeckTables<'tcx> {\n+fn item_tables<'a, 'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    hir_id: hir::HirId,\n+    empty_tables: &'a ty::TypeckTables<'tcx>,\n+) -> &'a ty::TypeckTables<'tcx> {\n     let def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n     if tcx.has_typeck_tables(def_id) { tcx.typeck_tables_of(def_id) } else { empty_tables }\n }\n \n-fn min<'tcx>(vis1: ty::Visibility, vis2: ty::Visibility, tcx: TyCtxt<'tcx, 'tcx>)\n-                 -> ty::Visibility {\n+fn min<'tcx>(\n+    vis1: ty::Visibility,\n+    vis2: ty::Visibility,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+) -> ty::Visibility {\n     if vis1.is_at_least(vis2, tcx) { vis2 } else { vis1 }\n }\n \n@@ -343,7 +352,7 @@ fn min<'tcx>(vis1: ty::Visibility, vis2: ty::Visibility, tcx: TyCtxt<'tcx, 'tcx>\n /// in crates that have been updated to use pub(restricted).\n ////////////////////////////////////////////////////////////////////////////////\n struct PubRestrictedVisitor<'tcx> {\n-    tcx:  TyCtxt<'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     has_pub_restricted: bool,\n }\n \n@@ -383,8 +392,11 @@ trait VisibilityLike: Sized {\n \n     // Returns an over-approximation (`skip_assoc_tys` = true) of visibility due to\n     // associated types for which we can't determine visibility precisely.\n-    fn of_impl<'a, 'tcx>(hir_id: hir::HirId, tcx: TyCtxt<'tcx, 'tcx>,\n-                         access_levels: &'a AccessLevels) -> Self {\n+    fn of_impl<'a, 'tcx>(\n+        hir_id: hir::HirId,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        access_levels: &'a AccessLevels,\n+    ) -> Self {\n         let mut find = FindMin { tcx, access_levels, min: Self::MAX };\n         let def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n         find.visit(tcx.type_of(def_id));\n@@ -460,8 +472,11 @@ impl EmbargoVisitor<'tcx> {\n         }\n     }\n \n-    fn reach(&mut self, item_id: hir::HirId, access_level: Option<AccessLevel>)\n-             -> ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n+    fn reach(\n+        &mut self,\n+        item_id: hir::HirId,\n+        access_level: Option<AccessLevel>,\n+    ) -> ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n         ReachEverythingInTheInterfaceVisitor {\n             access_level: cmp::min(access_level, Some(AccessLevel::Reachable)),\n             item_def_id: self.tcx.hir().local_def_id_from_hir_id(item_id),\n@@ -1647,8 +1662,11 @@ struct PrivateItemsInPublicInterfacesVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n-    fn check(&self, item_id: hir::HirId, required_visibility: ty::Visibility)\n-             -> SearchInterfaceForPrivateItemsVisitor<'tcx> {\n+    fn check(\n+        &self,\n+        item_id: hir::HirId,\n+        required_visibility: ty::Visibility,\n+    ) -> SearchInterfaceForPrivateItemsVisitor<'tcx> {\n         let mut has_old_errors = false;\n \n         // Slow path taken only if there any errors in the crate.\n@@ -1841,10 +1859,7 @@ fn check_mod_privacy<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, module_def_id: DefId) {\n     intravisit::walk_mod(&mut visitor, module, hir_id);\n }\n \n-fn privacy_access_levels<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    krate: CrateNum,\n-) -> &'tcx AccessLevels {\n+fn privacy_access_levels<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, krate: CrateNum) -> &'tcx AccessLevels {\n     assert_eq!(krate, LOCAL_CRATE);\n \n     // Build up a set of all exported items in the AST. This is a set of all"}, {"sha": "7a519ac2ebea8dad6ecb1cf5fcad74855307bf57", "filename": "src/librustc_traits/chalk_context/mod.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -527,7 +527,7 @@ impl ChalkContextLift<'tcx> for ChalkArenas<'a> {\n \n     fn lift_ex_clause_to_tcx(\n         ex_clause: &ChalkExClause<'a>,\n-        tcx: TyCtxt<'gcx, 'tcx>\n+        tcx: TyCtxt<'gcx, 'tcx>,\n     ) -> Option<Self::LiftedExClause> {\n         Some(ChalkExClause {\n             subst: tcx.lift(&ex_clause.subst)?,\n@@ -539,7 +539,7 @@ impl ChalkContextLift<'tcx> for ChalkArenas<'a> {\n \n     fn lift_delayed_literal_to_tcx(\n         literal: &DelayedLiteral<ChalkArenas<'a>>,\n-        tcx: TyCtxt<'gcx, 'tcx>\n+        tcx: TyCtxt<'gcx, 'tcx>,\n     ) -> Option<Self::LiftedDelayedLiteral> {\n         Some(match literal {\n             DelayedLiteral::CannotProve(()) => DelayedLiteral::CannotProve(()),\n@@ -674,11 +674,8 @@ crate fn provide(p: &mut Providers<'_>) {\n \n crate fn evaluate_goal<'tcx>(\n     tcx: TyCtxt<'tcx, 'tcx>,\n-    goal: ChalkCanonicalGoal<'tcx>\n-) -> Result<\n-    &'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>,\n-    traits::query::NoSolution\n-> {\n+    goal: ChalkCanonicalGoal<'tcx>,\n+) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, traits::query::NoSolution> {\n     use crate::lowering::Lower;\n     use rustc::traits::WellFormed;\n "}, {"sha": "3c9b335e77769528f65cb5255f505d2a185511e9", "filename": "src/librustc_traits/chalk_context/program_clauses/builtin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -18,7 +18,7 @@ fn builtin_impl_clause(\n     tcx: TyCtxt<'_, 'tcx>,\n     ty: Ty<'tcx>,\n     nested: &[Kind<'tcx>],\n-    trait_def_id: DefId\n+    trait_def_id: DefId,\n ) -> ProgramClause<'tcx> {\n     ProgramClause {\n         goal: ty::TraitPredicate {\n@@ -47,7 +47,7 @@ crate fn assemble_builtin_unsize_impls<'tcx>(\n     unsize_def_id: DefId,\n     source: Ty<'tcx>,\n     target: Ty<'tcx>,\n-    clauses: &mut Vec<Clause<'tcx>>\n+    clauses: &mut Vec<Clause<'tcx>>,\n ) {\n     match (&source.sty, &target.sty) {\n         (ty::Dynamic(data_a, ..), ty::Dynamic(data_b, ..)) => {\n@@ -122,7 +122,7 @@ crate fn assemble_builtin_sized_impls<'tcx>(\n     tcx: TyCtxt<'_, 'tcx>,\n     sized_def_id: DefId,\n     ty: Ty<'tcx>,\n-    clauses: &mut Vec<Clause<'tcx>>\n+    clauses: &mut Vec<Clause<'tcx>>,\n ) {\n     let mut push_builtin_impl = |ty: Ty<'tcx>, nested: &[Kind<'tcx>]| {\n         let clause = builtin_impl_clause(tcx, ty, nested, sized_def_id);\n@@ -226,7 +226,7 @@ crate fn assemble_builtin_copy_clone_impls<'tcx>(\n     tcx: TyCtxt<'_, 'tcx>,\n     trait_def_id: DefId,\n     ty: Ty<'tcx>,\n-    clauses: &mut Vec<Clause<'tcx>>\n+    clauses: &mut Vec<Clause<'tcx>>,\n ) {\n     let mut push_builtin_impl = |ty: Ty<'tcx>, nested: &[Kind<'tcx>]| {\n         let clause = builtin_impl_clause(tcx, ty, nested, trait_def_id);"}, {"sha": "ae2283c3672e7c01e0827c2b1f81f5fb3830b97b", "filename": "src/librustc_traits/chalk_context/program_clauses/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -21,7 +21,7 @@ use self::builtin::*;\n fn assemble_clauses_from_impls<'tcx>(\n     tcx: TyCtxt<'_, 'tcx>,\n     trait_def_id: DefId,\n-    clauses: &mut Vec<Clause<'tcx>>\n+    clauses: &mut Vec<Clause<'tcx>>,\n ) {\n     tcx.for_each_impl(trait_def_id, |impl_def_id| {\n         clauses.extend(\n@@ -35,7 +35,7 @@ fn assemble_clauses_from_impls<'tcx>(\n fn assemble_clauses_from_assoc_ty_values<'tcx>(\n     tcx: TyCtxt<'_, 'tcx>,\n     trait_def_id: DefId,\n-    clauses: &mut Vec<Clause<'tcx>>\n+    clauses: &mut Vec<Clause<'tcx>>,\n ) {\n     tcx.for_each_impl(trait_def_id, |impl_def_id| {\n         for def_id in tcx.associated_item_def_ids(impl_def_id).iter() {"}, {"sha": "fd7b5ec55b08bc233789af32aa066b00c4df24e2", "filename": "src/librustc_traits/chalk_context/program_clauses/primitive.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fprimitive.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -17,7 +17,7 @@ use std::iter;\n \n crate fn wf_clause_for_raw_ptr<'tcx>(\n     tcx: TyCtxt<'_, 'tcx>,\n-    mutbl: hir::Mutability\n+    mutbl: hir::Mutability,\n ) -> Clauses<'tcx> {\n     let ptr_ty = generic_types::raw_ptr(tcx, mutbl);\n \n@@ -37,7 +37,7 @@ crate fn wf_clause_for_fn_ptr<'tcx>(\n     arity_and_output: usize,\n     variadic: bool,\n     unsafety: hir::Unsafety,\n-    abi: abi::Abi\n+    abi: abi::Abi,\n ) -> Clauses<'tcx> {\n     let fn_ptr = generic_types::fn_ptr(tcx, arity_and_output, variadic, unsafety, abi);\n \n@@ -84,7 +84,7 @@ crate fn wf_clause_for_slice<'tcx>(tcx: TyCtxt<'_, 'tcx>) -> Clauses<'tcx> {\n \n crate fn wf_clause_for_array<'tcx>(\n     tcx: TyCtxt<'_, 'tcx>,\n-    length: &'tcx ty::Const<'tcx>\n+    length: &'tcx ty::Const<'tcx>,\n ) -> Clauses<'tcx> {\n     let ty = generic_types::bound(tcx, 0);\n     let array_ty = tcx.mk_ty(ty::Array(ty, length));\n@@ -114,10 +114,7 @@ crate fn wf_clause_for_array<'tcx>(\n     tcx.mk_clauses(iter::once(wf_clause))\n }\n \n-crate fn wf_clause_for_tuple<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx>,\n-    arity: usize\n-) -> Clauses<'tcx> {\n+crate fn wf_clause_for_tuple<'tcx>(tcx: TyCtxt<'_, 'tcx>, arity: usize) -> Clauses<'tcx> {\n     let type_list = generic_types::type_list(tcx, arity);\n     let tuple_ty = tcx.mk_ty(ty::Tuple(type_list));\n \n@@ -158,10 +155,7 @@ crate fn wf_clause_for_tuple<'tcx>(\n     tcx.mk_clauses(iter::once(wf_clause))\n }\n \n-crate fn wf_clause_for_ref<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx>,\n-    mutbl: hir::Mutability\n-) -> Clauses<'tcx> {\n+crate fn wf_clause_for_ref<'tcx>(tcx: TyCtxt<'_, 'tcx>, mutbl: hir::Mutability) -> Clauses<'tcx> {\n     let region = tcx.mk_region(\n         ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(0))\n     );\n@@ -185,10 +179,7 @@ crate fn wf_clause_for_ref<'tcx>(\n     tcx.mk_clauses(iter::once(wf_clause))\n }\n \n-crate fn wf_clause_for_fn_def<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx>,\n-    def_id: DefId\n-) -> Clauses<'tcx> {\n+crate fn wf_clause_for_fn_def<'tcx>(tcx: TyCtxt<'_, 'tcx>, def_id: DefId) -> Clauses<'tcx> {\n     let fn_def = generic_types::fn_def(tcx, def_id);\n \n     let wf_clause = ProgramClause {"}, {"sha": "dca7fb0dae3d40aa86113ceb5839d3e852fd26b4", "filename": "src/librustc_traits/generic_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_traits%2Fgeneric_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_traits%2Fgeneric_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fgeneric_types.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -26,7 +26,7 @@ crate fn fn_ptr(\n     arity_and_output: usize,\n     c_variadic: bool,\n     unsafety: hir::Unsafety,\n-    abi: abi::Abi\n+    abi: abi::Abi,\n ) -> Ty<'tcx> {\n     let inputs_and_output = tcx.mk_type_list(\n         (0..arity_and_output).into_iter()"}, {"sha": "1bb04eab4c4bb90c67c872d5c09cef750117b98d", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -26,8 +26,8 @@ fn implied_outlives_bounds<'tcx>(\n     tcx: TyCtxt<'tcx, 'tcx>,\n     goal: CanonicalTyGoal<'tcx>,\n ) -> Result<\n-        &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, Vec<OutlivesBound<'tcx>>>>,\n-        NoSolution,\n+    &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, Vec<OutlivesBound<'tcx>>>>,\n+    NoSolution,\n > {\n     tcx.infer_ctxt()\n        .enter_canonical_trait_query(&goal, |infcx, _fulfill_cx, key| {"}, {"sha": "bab74e80ea6e900b95e6fa8344db751205b511e6", "filename": "src/librustc_traits/lowering/environment.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -160,10 +160,7 @@ crate fn program_clauses_for_env<'tcx>(\n     );\n }\n \n-crate fn environment<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    def_id: DefId\n-) -> Environment<'tcx> {\n+crate fn environment<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Environment<'tcx> {\n     use super::{Lower, IntoFromEnvGoal};\n     use rustc::hir::{Node, TraitItemKind, ImplItemKind, ItemKind, ForeignItemKind};\n "}, {"sha": "59cd58ea23d14bc92d1f46f8f0c3dc64603f8766", "filename": "src/librustc_traits/lowering/mod.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fmod.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -155,10 +155,7 @@ impl<'tcx> IntoWellFormedGoal for DomainGoal<'tcx> {\n     }\n }\n \n-crate fn program_clauses_for<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    def_id: DefId,\n-) -> Clauses<'tcx> {\n+crate fn program_clauses_for<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Clauses<'tcx> {\n     // FIXME(eddyb) this should only be using `def_kind`.\n     match tcx.def_key(def_id).disambiguated_data.data {\n         DefPathData::TypeNs(..) => match tcx.def_kind(def_id) {\n@@ -184,10 +181,7 @@ crate fn program_clauses_for<'tcx>(\n     }\n }\n \n-fn program_clauses_for_trait<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    def_id: DefId,\n-) -> Clauses<'tcx> {\n+fn program_clauses_for_trait<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Clauses<'tcx> {\n     // `trait Trait<P1..Pn> where WC { .. } // P0 == Self`\n \n     // Rule Implemented-From-Env (see rustc guide)\n@@ -343,10 +337,7 @@ fn program_clauses_for_impl(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Clauses<'\n     tcx.mk_clauses(iter::once(Clause::ForAll(ty::Binder::bind(clause))))\n }\n \n-pub fn program_clauses_for_type_def<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    def_id: DefId,\n-) -> Clauses<'tcx> {\n+pub fn program_clauses_for_type_def<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Clauses<'tcx> {\n     // Rule WellFormed-Type\n     //\n     // `struct Ty<P1..Pn> where WC1, ..., WCm`"}, {"sha": "2c9309a1696cfd65210643a491bcb1470caffac1", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -2420,9 +2420,11 @@ impl<'gcx, 'tcx> Bounds<'tcx> {\n     /// where-clauses). Because some of our bounds listings (e.g.,\n     /// regions) don't include the self-type, you must supply the\n     /// self-type here (the `param_ty` parameter).\n-    pub fn predicates(&self, tcx: TyCtxt<'gcx, 'tcx>, param_ty: Ty<'tcx>)\n-                      -> Vec<(ty::Predicate<'tcx>, Span)>\n-    {\n+    pub fn predicates(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        param_ty: Ty<'tcx>,\n+    ) -> Vec<(ty::Predicate<'tcx>, Span)> {\n         // If it could be sized, and is, add the `Sized` predicate.\n         let sized_predicate = self.implicitly_sized.and_then(|span| {\n             tcx.lang_items().sized_trait().map(|sized| {"}, {"sha": "ce92551c0133fab6a569d8e67aab5b495d05f179", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -240,8 +240,10 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n }\n \n pub fn report_autoderef_recursion_limit_error<'gcx, 'tcx>(\n-    tcx: TyCtxt<'gcx, 'tcx>, span: Span, ty: Ty<'tcx>)\n-{\n+    tcx: TyCtxt<'gcx, 'tcx>,\n+    span: Span,\n+    ty: Ty<'tcx>,\n+) {\n     // We've reached the recursion limit, error gracefully.\n     let suggested_limit = *tcx.sess.recursion_limit.get() * 2;\n     let msg = format!(\"reached the recursion limit while auto-dereferencing `{:?}`\","}, {"sha": "32ac7cd69e2e324968a6da49ffafebfeb4693486", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 50, "deletions": 42, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -23,12 +23,14 @@ use super::{Inherited, FnCtxt, potentially_plural_count};\n /// - `trait_m`: the method in the trait\n /// - `impl_trait_ref`: the TraitRef corresponding to the trait implementation\n \n-pub fn compare_impl_method<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                     impl_m: &ty::AssocItem,\n-                                     impl_m_span: Span,\n-                                     trait_m: &ty::AssocItem,\n-                                     impl_trait_ref: ty::TraitRef<'tcx>,\n-                                     trait_item_span: Option<Span>) {\n+pub fn compare_impl_method<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    impl_m: &ty::AssocItem,\n+    impl_m_span: Span,\n+    trait_m: &ty::AssocItem,\n+    impl_trait_ref: ty::TraitRef<'tcx>,\n+    trait_item_span: Option<Span>,\n+) {\n     debug!(\"compare_impl_method(impl_trait_ref={:?})\",\n            impl_trait_ref);\n \n@@ -73,12 +75,13 @@ pub fn compare_impl_method<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n     }\n }\n \n-fn compare_predicate_entailment<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                          impl_m: &ty::AssocItem,\n-                                          impl_m_span: Span,\n-                                          trait_m: &ty::AssocItem,\n-                                          impl_trait_ref: ty::TraitRef<'tcx>)\n-                                          -> Result<(), ErrorReported> {\n+fn compare_predicate_entailment<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    impl_m: &ty::AssocItem,\n+    impl_m_span: Span,\n+    trait_m: &ty::AssocItem,\n+    impl_trait_ref: ty::TraitRef<'tcx>,\n+) -> Result<(), ErrorReported> {\n     let trait_to_impl_substs = impl_trait_ref.substs;\n \n     // This node-id should be used for the `body_id` field on each\n@@ -355,14 +358,15 @@ fn compare_predicate_entailment<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n     })\n }\n \n-fn check_region_bounds_on_impl_method<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                                span: Span,\n-                                                impl_m: &ty::AssocItem,\n-                                                trait_m: &ty::AssocItem,\n-                                                trait_generics: &ty::Generics,\n-                                                impl_generics: &ty::Generics,\n-                                                trait_to_skol_substs: SubstsRef<'tcx>)\n-                                                -> Result<(), ErrorReported> {\n+fn check_region_bounds_on_impl_method<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    span: Span,\n+    impl_m: &ty::AssocItem,\n+    trait_m: &ty::AssocItem,\n+    trait_generics: &ty::Generics,\n+    impl_generics: &ty::Generics,\n+    trait_to_skol_substs: SubstsRef<'tcx>,\n+) -> Result<(), ErrorReported> {\n     let trait_params = trait_generics.own_counts().lifetimes;\n     let impl_params = impl_generics.own_counts().lifetimes;\n \n@@ -495,13 +499,13 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n     }\n }\n \n-fn compare_self_type<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                               impl_m: &ty::AssocItem,\n-                               impl_m_span: Span,\n-                               trait_m: &ty::AssocItem,\n-                               impl_trait_ref: ty::TraitRef<'tcx>)\n-                               -> Result<(), ErrorReported>\n-{\n+fn compare_self_type<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    impl_m: &ty::AssocItem,\n+    impl_m_span: Span,\n+    trait_m: &ty::AssocItem,\n+    impl_trait_ref: ty::TraitRef<'tcx>,\n+) -> Result<(), ErrorReported> {\n     // Try to give more informative error messages about self typing\n     // mismatches.  Note that any mismatch will also be detected\n     // below, where we construct a canonical function type that\n@@ -695,12 +699,13 @@ fn compare_number_of_generics<'tcx>(\n     }\n }\n \n-fn compare_number_of_method_arguments<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                                impl_m: &ty::AssocItem,\n-                                                impl_m_span: Span,\n-                                                trait_m: &ty::AssocItem,\n-                                                trait_item_span: Option<Span>)\n-                                                -> Result<(), ErrorReported> {\n+fn compare_number_of_method_arguments<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    impl_m: &ty::AssocItem,\n+    impl_m_span: Span,\n+    trait_m: &ty::AssocItem,\n+    trait_item_span: Option<Span>,\n+) -> Result<(), ErrorReported> {\n     let impl_m_fty = tcx.fn_sig(impl_m.def_id);\n     let trait_m_fty = tcx.fn_sig(trait_m.def_id);\n     let trait_number_args = trait_m_fty.inputs().skip_binder().len();\n@@ -779,10 +784,11 @@ fn compare_number_of_method_arguments<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n     Ok(())\n }\n \n-fn compare_synthetic_generics<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                        impl_m: &ty::AssocItem,\n-                                        trait_m: &ty::AssocItem)\n-                                        -> Result<(), ErrorReported> {\n+fn compare_synthetic_generics<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    impl_m: &ty::AssocItem,\n+    trait_m: &ty::AssocItem,\n+) -> Result<(), ErrorReported> {\n     // FIXME(chrisvittal) Clean up this function, list of FIXME items:\n     //     1. Better messages for the span labels\n     //     2. Explanation as to what is going on\n@@ -951,11 +957,13 @@ fn compare_synthetic_generics<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n     }\n }\n \n-pub fn compare_const_impl<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                    impl_c: &ty::AssocItem,\n-                                    impl_c_span: Span,\n-                                    trait_c: &ty::AssocItem,\n-                                    impl_trait_ref: ty::TraitRef<'tcx>) {\n+pub fn compare_const_impl<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    impl_c: &ty::AssocItem,\n+    impl_c_span: Span,\n+    trait_c: &ty::AssocItem,\n+    impl_trait_ref: ty::TraitRef<'tcx>,\n+) {\n     debug!(\"compare_const_impl(impl_trait_ref={:?})\", impl_trait_ref);\n \n     tcx.infer_ctxt().enter(|infcx| {"}, {"sha": "0b800fe8247c70b9f345ff240c1477060766a307", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -79,8 +79,7 @@ pub fn intrisic_operation_unsafety(intrinsic: &str) -> hir::Unsafety {\n \n /// Remember to add all intrinsics here, in librustc_codegen_llvm/intrinsic.rs,\n /// and in libcore/intrinsics.rs\n-pub fn check_intrinsic_type<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                      it: &hir::ForeignItem) {\n+pub fn check_intrinsic_type<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, it: &hir::ForeignItem) {\n     let param = |n| tcx.mk_ty_param(n, InternedString::intern(&format!(\"P{}\", n)));\n     let name = it.ident.as_str();\n \n@@ -400,8 +399,7 @@ pub fn check_intrinsic_type<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n }\n \n /// Type-check `extern \"platform-intrinsic\" { ... }` functions.\n-pub fn check_platform_intrinsic_type<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                               it: &hir::ForeignItem) {\n+pub fn check_platform_intrinsic_type<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, it: &hir::ForeignItem) {\n     let param = |n| {\n         let name = InternedString::intern(&format!(\"P{}\", n));\n         tcx.mk_ty_param(n, name)"}, {"sha": "5aab440dc16d094aae1f641c769b196a1aea8cdb", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -395,10 +395,10 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     providers.method_autoderef_steps = method_autoderef_steps;\n }\n \n-fn method_autoderef_steps<'gcx, 'tcx>(tcx: TyCtxt<'gcx, 'gcx>,\n-                                          goal: CanonicalTyGoal<'tcx>)\n-                                          -> MethodAutoderefStepsResult<'gcx>\n-{\n+fn method_autoderef_steps<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'gcx>,\n+    goal: CanonicalTyGoal<'tcx>,\n+) -> MethodAutoderefStepsResult<'gcx> {\n     debug!(\"method_autoderef_steps({:?})\", goal);\n \n     tcx.infer_ctxt().enter_with_canonical(DUMMY_SP, &goal, |ref infcx, goal, inference_vars| {"}, {"sha": "c4157bb60e9da8383d54121775608e275b4716cb", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -817,10 +817,12 @@ fn compute_all_traits<'gcx, 'tcx>(tcx: TyCtxt<'gcx, 'tcx>) -> Vec<DefId> {\n     // Cross-crate:\n \n     let mut external_mods = FxHashSet::default();\n-    fn handle_external_res(tcx: TyCtxt<'_, '_>,\n-                           traits: &mut Vec<DefId>,\n-                           external_mods: &mut FxHashSet<DefId>,\n-                           res: Res) {\n+    fn handle_external_res(\n+        tcx: TyCtxt<'_, '_>,\n+        traits: &mut Vec<DefId>,\n+        external_mods: &mut FxHashSet<DefId>,\n+        res: Res,\n+    ) {\n         match res {\n             Res::Def(DefKind::Trait, def_id) |\n             Res::Def(DefKind::TraitAlias, def_id) => {\n@@ -859,7 +861,7 @@ struct UsePlacementFinder<'tcx, 'gcx> {\n     target_module: hir::HirId,\n     span: Option<Span>,\n     found_use: bool,\n-    tcx: TyCtxt<'gcx, 'tcx>\n+    tcx: TyCtxt<'gcx, 'tcx>,\n }\n \n impl UsePlacementFinder<'tcx, 'gcx> {"}, {"sha": "d62536ccb46696e1c06239667222e037c8e86e5c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 60, "deletions": 70, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -594,8 +594,7 @@ pub struct InheritedBuilder<'gcx, 'tcx> {\n }\n \n impl Inherited<'_, 'gcx, 'tcx> {\n-    pub fn build(tcx: TyCtxt<'gcx, 'gcx>, def_id: DefId)\n-                 -> InheritedBuilder<'gcx, 'tcx> {\n+    pub fn build(tcx: TyCtxt<'gcx, 'gcx>, def_id: DefId) -> InheritedBuilder<'gcx, 'tcx> {\n         let hir_id_root = if def_id.is_local() {\n             let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n             DefId::local(hir_id.owner)\n@@ -612,7 +611,8 @@ impl Inherited<'_, 'gcx, 'tcx> {\n \n impl<'gcx, 'tcx> InheritedBuilder<'gcx, 'tcx> {\n     fn enter<F, R>(&'tcx mut self, f: F) -> R\n-        where F: for<'a> FnOnce(Inherited<'a, 'gcx, 'tcx>) -> R\n+    where\n+        F: for<'a> FnOnce(Inherited<'a, 'gcx, 'tcx>) -> R,\n     {\n         let def_id = self.def_id;\n         self.infcx.enter(|infcx| f(Inherited::new(infcx, def_id)))\n@@ -685,7 +685,9 @@ impl Inherited<'a, 'gcx, 'tcx> {\n     }\n }\n \n-struct CheckItemTypesVisitor<'tcx> { tcx: TyCtxt<'tcx, 'tcx> }\n+struct CheckItemTypesVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+}\n \n impl ItemLikeVisitor<'tcx> for CheckItemTypesVisitor<'tcx> {\n     fn visit_item(&mut self, i: &'tcx hir::Item) {\n@@ -741,9 +743,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn adt_destructor<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                            def_id: DefId)\n-                            -> Option<ty::Destructor> {\n+fn adt_destructor<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Option<ty::Destructor> {\n     tcx.calculate_dtor(def_id, &mut dropck::check_drop_impl)\n }\n \n@@ -756,10 +756,10 @@ fn adt_destructor<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n /// may not succeed. In some cases where this function returns `None`\n /// (notably closures), `typeck_tables(def_id)` would wind up\n /// redirecting to the owning function.\n-fn primary_body_of<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                             id: hir::HirId)\n-                             -> Option<(hir::BodyId, Option<&'tcx hir::FnDecl>)>\n-{\n+fn primary_body_of<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    id: hir::HirId,\n+) -> Option<(hir::BodyId, Option<&'tcx hir::FnDecl>)> {\n     match tcx.hir().get_by_hir_id(id) {\n         Node::Item(item) => {\n             match item.node {\n@@ -797,9 +797,7 @@ fn primary_body_of<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n     }\n }\n \n-fn has_typeck_tables<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                               def_id: DefId)\n-                               -> bool {\n+fn has_typeck_tables<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> bool {\n     // Closures' tables come from their outermost function,\n     // as they are part of the same \"inference environment\".\n     let outer_def_id = tcx.closure_base_def_id(def_id);\n@@ -811,15 +809,11 @@ fn has_typeck_tables<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n     primary_body_of(tcx, id).is_some()\n }\n \n-fn used_trait_imports<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                def_id: DefId)\n-                                -> &'tcx DefIdSet {\n+fn used_trait_imports<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> &'tcx DefIdSet {\n     &*tcx.typeck_tables_of(def_id).used_trait_imports\n }\n \n-fn typeck_tables_of<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                              def_id: DefId)\n-                              -> &'tcx ty::TypeckTables<'tcx> {\n+fn typeck_tables_of<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::TypeckTables<'tcx> {\n     // Closures' tables come from their outermost function,\n     // as they are part of the same \"inference environment\".\n     let outer_def_id = tcx.closure_base_def_id(def_id);\n@@ -1287,9 +1281,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     (fcx, gen_ty)\n }\n \n-fn check_struct<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                          id: hir::HirId,\n-                          span: Span) {\n+fn check_struct<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, id: hir::HirId, span: Span) {\n     let def_id = tcx.hir().local_def_id_from_hir_id(id);\n     let def = tcx.adt_def(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n@@ -1303,9 +1295,7 @@ fn check_struct<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n     check_packed(tcx, span, def_id);\n }\n \n-fn check_union<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                         id: hir::HirId,\n-                         span: Span) {\n+fn check_union<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, id: hir::HirId, span: Span) {\n     let def_id = tcx.hir().local_def_id_from_hir_id(id);\n     let def = tcx.adt_def(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n@@ -1314,12 +1304,7 @@ fn check_union<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n     check_packed(tcx, span, def_id);\n }\n \n-fn check_opaque<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    def_id: DefId,\n-    substs: SubstsRef<'tcx>,\n-    span: Span,\n-) {\n+fn check_opaque<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId, substs: SubstsRef<'tcx>, span: Span) {\n     if let Err(partially_expanded_type) = tcx.try_expand_impl_trait_type(def_id, substs) {\n         let mut err = struct_span_err!(\n             tcx.sess, span, E0720,\n@@ -1472,18 +1457,17 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt<'_, '_>, id: DefId, span: Sp\n     }\n }\n \n-fn check_on_unimplemented<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                    trait_def_id: DefId,\n-                                    item: &hir::Item) {\n+fn check_on_unimplemented<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, trait_def_id: DefId, item: &hir::Item) {\n     let item_def_id = tcx.hir().local_def_id_from_hir_id(item.hir_id);\n     // an error would be reported if this fails.\n     let _ = traits::OnUnimplementedDirective::of_item(tcx, trait_def_id, item_def_id);\n }\n \n-fn report_forbidden_specialization<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                             impl_item: &hir::ImplItem,\n-                                             parent_impl: DefId)\n-{\n+fn report_forbidden_specialization<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    impl_item: &hir::ImplItem,\n+    parent_impl: DefId,\n+) {\n     let mut err = struct_span_err!(\n         tcx.sess, impl_item.span, E0520,\n         \"`{}` specializes an item from a parent `impl`, but \\\n@@ -1506,12 +1490,13 @@ fn report_forbidden_specialization<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n     err.emit();\n }\n \n-fn check_specialization_validity<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                           trait_def: &ty::TraitDef,\n-                                           trait_item: &ty::AssocItem,\n-                                           impl_id: DefId,\n-                                           impl_item: &hir::ImplItem)\n-{\n+fn check_specialization_validity<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    trait_def: &ty::TraitDef,\n+    trait_item: &ty::AssocItem,\n+    impl_id: DefId,\n+    impl_item: &hir::ImplItem,\n+) {\n     let ancestors = trait_def.ancestors(tcx, impl_id);\n \n     let kind = match impl_item.node {\n@@ -1532,11 +1517,13 @@ fn check_specialization_validity<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n \n }\n \n-fn check_impl_items_against_trait<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                            impl_span: Span,\n-                                            impl_id: DefId,\n-                                            impl_trait_ref: ty::TraitRef<'tcx>,\n-                                            impl_item_refs: &[hir::ImplItemRef]) {\n+fn check_impl_items_against_trait<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    impl_span: Span,\n+    impl_id: DefId,\n+    impl_trait_ref: ty::TraitRef<'tcx>,\n+    impl_item_refs: &[hir::ImplItemRef],\n+) {\n     let impl_span = tcx.sess.source_map().def_span(impl_span);\n \n     // If the trait reference itself is erroneous (so the compilation is going\n@@ -1693,10 +1680,7 @@ fn check_impl_items_against_trait<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n /// Checks whether a type can be represented in memory. In particular, it\n /// identifies types that contain themselves without indirection through a\n /// pointer, which would mean their size is unbounded.\n-fn check_representable<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                 sp: Span,\n-                                 item_def_id: DefId)\n-                                 -> bool {\n+fn check_representable<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, sp: Span, item_def_id: DefId) -> bool {\n     let rty = tcx.type_of(item_def_id);\n \n     // Check that it is possible to represent this type. This call identifies\n@@ -1715,7 +1699,7 @@ fn check_representable<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n         }\n         Representability::Representable | Representability::ContainsRecursive => (),\n     }\n-    return true\n+    return true;\n }\n \n pub fn check_simd<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, sp: Span, def_id: DefId) {\n@@ -1771,9 +1755,11 @@ fn check_packed<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, sp: Span, def_id: DefId) {\n     }\n }\n \n-fn check_packed_inner<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                def_id: DefId,\n-                                stack: &mut Vec<DefId>) -> bool {\n+fn check_packed_inner<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    def_id: DefId,\n+    stack: &mut Vec<DefId>,\n+) -> bool {\n     let t = tcx.type_of(def_id);\n     if stack.contains(&def_id) {\n         debug!(\"check_packed_inner: {:?} is recursive\", t);\n@@ -1881,10 +1867,12 @@ fn check_transparent<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, sp: Span, def_id: DefId) {\n }\n \n #[allow(trivial_numeric_casts)]\n-pub fn check_enum<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                            sp: Span,\n-                            vs: &'tcx [hir::Variant],\n-                            id: hir::HirId) {\n+pub fn check_enum<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    sp: Span,\n+    vs: &'tcx [hir::Variant],\n+    id: hir::HirId,\n+) {\n     let def_id = tcx.hir().local_def_id_from_hir_id(id);\n     let def = tcx.adt_def(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n@@ -1945,18 +1933,22 @@ pub fn check_enum<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n     check_transparent(tcx, sp, def_id);\n }\n \n-fn report_unexpected_variant_res<'gcx, 'tcx>(tcx: TyCtxt<'gcx, 'tcx>,\n-                                                 res: Res,\n-                                                 span: Span,\n-                                                 qpath: &QPath) {\n+fn report_unexpected_variant_res<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n+    res: Res,\n+    span: Span,\n+    qpath: &QPath,\n+) {\n     span_err!(tcx.sess, span, E0533,\n               \"expected unit struct/variant or constant, found {} `{}`\",\n               res.descr(),\n               hir::print::to_string(tcx.hir(), |s| s.print_qpath(qpath, false)));\n }\n \n impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> { self.tcx }\n+    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> {\n+        self.tcx\n+        }\n \n     fn get_type_parameter_bounds(&self, _: Span, def_id: DefId)\n                                  -> &'tcx ty::GenericPredicates<'tcx>\n@@ -5700,9 +5692,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub fn check_bounds_are_used<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                       generics: &ty::Generics,\n-                                       ty: Ty<'tcx>) {\n+pub fn check_bounds_are_used<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, generics: &ty::Generics, ty: Ty<'tcx>) {\n     let own_counts = generics.own_counts();\n     debug!(\n         \"check_bounds_are_used(n_tys={}, n_cts={}, ty={:?})\","}, {"sha": "83711a32e23a549a536c447d8b23c07b2f071daf", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 50, "deletions": 36, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -33,9 +33,9 @@ struct CheckWfFcxBuilder<'gcx, 'tcx> {\n }\n \n impl<'gcx, 'tcx> CheckWfFcxBuilder<'gcx, 'tcx> {\n-    fn with_fcx<F>(&'tcx mut self, f: F) where\n-        F: for<'b> FnOnce(&FnCtxt<'b, 'gcx, 'tcx>,\n-                         TyCtxt<'gcx, 'gcx>) -> Vec<Ty<'tcx>>\n+    fn with_fcx<F>(&'tcx mut self, f: F)\n+    where\n+        F: for<'b> FnOnce(&FnCtxt<'b, 'gcx, 'tcx>, TyCtxt<'gcx, 'gcx>) -> Vec<Ty<'tcx>>,\n     {\n         let id = self.id;\n         let span = self.span;\n@@ -178,10 +178,12 @@ pub fn check_impl_item<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) {\n     check_associated_item(tcx, impl_item.hir_id, impl_item.span, method_sig);\n }\n \n-fn check_associated_item<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                   item_id: hir::HirId,\n-                                   span: Span,\n-                                   sig_if_method: Option<&hir::MethodSig>) {\n+fn check_associated_item<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    item_id: hir::HirId,\n+    span: Span,\n+    sig_if_method: Option<&hir::MethodSig>,\n+) {\n     debug!(\"check_associated_item: {:?}\", item_id);\n \n     let code = ObligationCauseCode::MiscObligation;\n@@ -225,13 +227,18 @@ fn check_associated_item<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n     })\n }\n \n-fn for_item<'gcx: 'tcx, 'tcx>(tcx: TyCtxt<'gcx, 'gcx>, item: &hir::Item)\n-                            -> CheckWfFcxBuilder<'gcx, 'tcx> {\n+fn for_item<'gcx: 'tcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'gcx>,\n+    item: &hir::Item,\n+) -> CheckWfFcxBuilder<'gcx, 'tcx> {\n     for_id(tcx, item.hir_id, item.span)\n }\n \n-fn for_id<'gcx: 'tcx, 'tcx>(tcx: TyCtxt<'gcx, 'gcx>, id: hir::HirId, span: Span)\n-                          -> CheckWfFcxBuilder<'gcx, 'tcx> {\n+fn for_id<'gcx: 'tcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'gcx>,\n+    id: hir::HirId,\n+    span: Span,\n+) -> CheckWfFcxBuilder<'gcx, 'tcx> {\n     let def_id = tcx.hir().local_def_id_from_hir_id(id);\n     CheckWfFcxBuilder {\n         inherited: Inherited::build(tcx, def_id),\n@@ -242,9 +249,13 @@ fn for_id<'gcx: 'tcx, 'tcx>(tcx: TyCtxt<'gcx, 'gcx>, id: hir::HirId, span: Span)\n }\n \n /// In a type definition, we check that to ensure that the types of the fields are well-formed.\n-fn check_type_defn<'tcx, F>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                item: &hir::Item, all_sized: bool, mut lookup_fields: F)\n-    where F: for<'fcx, 'gcx, 'tcx2> FnMut(&FnCtxt<'fcx, 'gcx, 'tcx2>) -> Vec<AdtVariant<'tcx2>>\n+fn check_type_defn<'tcx, F>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    item: &hir::Item,\n+    all_sized: bool,\n+    mut lookup_fields: F,\n+) where\n+    F: for<'fcx, 'gcx, 'tcx2> FnMut(&FnCtxt<'fcx, 'gcx, 'tcx2>) -> Vec<AdtVariant<'tcx2>>,\n {\n     for_item(tcx, item).with_fcx(|fcx, fcx_tcx| {\n         let variants = lookup_fields(fcx);\n@@ -380,11 +391,12 @@ fn check_item_type<'tcx>(\n     });\n }\n \n-fn check_impl<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                        item: &hir::Item,\n-                        ast_self_ty: &hir::Ty,\n-                        ast_trait_ref: &Option<hir::TraitRef>)\n-{\n+fn check_impl<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    item: &hir::Item,\n+    ast_self_ty: &hir::Ty,\n+    ast_trait_ref: &Option<hir::TraitRef>,\n+) {\n     debug!(\"check_impl: {:?}\", item);\n \n     for_item(tcx, item).with_fcx(|fcx, tcx| {\n@@ -574,13 +586,14 @@ fn check_where_clauses<'gcx, 'fcx, 'tcx>(\n     }\n }\n \n-fn check_fn_or_method<'fcx, 'gcx, 'tcx>(tcx: TyCtxt<'gcx, 'gcx>,\n-                                            fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n-                                            span: Span,\n-                                            sig: ty::PolyFnSig<'tcx>,\n-                                            def_id: DefId,\n-                                            implied_bounds: &mut Vec<Ty<'tcx>>)\n-{\n+fn check_fn_or_method<'fcx, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'gcx>,\n+    fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n+    span: Span,\n+    sig: ty::PolyFnSig<'tcx>,\n+    def_id: DefId,\n+    implied_bounds: &mut Vec<Ty<'tcx>>,\n+) {\n     let sig = fcx.normalize_associated_types_in(span, &sig);\n     let sig = fcx.tcx.liberate_late_bound_regions(def_id, &sig);\n \n@@ -930,10 +943,11 @@ fn receiver_is_valid<'fcx, 'tcx, 'gcx>(\n     true\n }\n \n-fn check_variances_for_type_defn<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                           item: &hir::Item,\n-                                           hir_generics: &hir::Generics)\n-{\n+fn check_variances_for_type_defn<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    item: &hir::Item,\n+    hir_generics: &hir::Generics,\n+) {\n     let item_def_id = tcx.hir().local_def_id_from_hir_id(item.hir_id);\n     let ty = tcx.type_of(item_def_id);\n     if tcx.has_error_field(ty) {\n@@ -971,10 +985,7 @@ fn check_variances_for_type_defn<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n     }\n }\n \n-fn report_bivariance<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                               span: Span,\n-                               param_name: ast::Name)\n-{\n+fn report_bivariance<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, span: Span, param_name: ast::Name) {\n     let mut err = error_392(tcx, span, param_name);\n \n     let suggested_marker_id = tcx.lang_items().phantom_data();\n@@ -1133,8 +1144,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-fn error_392<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, span: Span, param_name: ast::Name)\n-                       -> DiagnosticBuilder<'tcx> {\n+fn error_392<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    span: Span,\n+    param_name: ast::Name,\n+) -> DiagnosticBuilder<'tcx> {\n     let mut err = struct_span_err!(tcx.sess, span, E0392,\n                   \"parameter `{}` is never used\", param_name);\n     err.span_label(span, \"unused parameter\");"}, {"sha": "1eb3d108f786cf00d2b860db055cbb324e153733", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -28,12 +28,13 @@ pub fn check_trait<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, trait_def_id: DefId) {\n \n struct Checker<'tcx> {\n     tcx: TyCtxt<'tcx, 'tcx>,\n-    trait_def_id: DefId\n+    trait_def_id: DefId,\n }\n \n impl<'tcx> Checker<'tcx> {\n     fn check<F>(&self, trait_def_id: Option<DefId>, mut f: F) -> &Self\n-        where F: FnMut(TyCtxt<'tcx, 'tcx>, DefId)\n+    where\n+        F: FnMut(TyCtxt<'tcx, 'tcx>, DefId),\n     {\n         if Some(self.trait_def_id) == trait_def_id {\n             for &impl_id in self.tcx.hir().trait_impls(self.trait_def_id) {\n@@ -153,10 +154,7 @@ fn visit_implementation_of_coerce_unsized(tcx: TyCtxt<'tcx, 'tcx>, impl_did: Def\n     }\n }\n \n-fn visit_implementation_of_dispatch_from_dyn<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    impl_did: DefId,\n-) {\n+fn visit_implementation_of_dispatch_from_dyn<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, impl_did: DefId) {\n     debug!(\"visit_implementation_of_dispatch_from_dyn: impl_did={:?}\",\n            impl_did);\n     if impl_did.is_local() {\n@@ -324,9 +322,7 @@ fn visit_implementation_of_dispatch_from_dyn<'tcx>(\n     }\n }\n \n-pub fn coerce_unsized_info<'gcx>(gcx: TyCtxt<'gcx, 'gcx>,\n-                                     impl_did: DefId)\n-                                     -> CoerceUnsizedInfo {\n+pub fn coerce_unsized_info<'gcx>(gcx: TyCtxt<'gcx, 'gcx>, impl_did: DefId) -> CoerceUnsizedInfo {\n     debug!(\"compute_coerce_unsized_info(impl_did={:?})\", impl_did);\n     let coerce_unsized_trait = gcx.lang_items().coerce_unsized_trait().unwrap();\n "}, {"sha": "d6c2d56a9adf78ef8f10a8720a190703c7217787", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -17,9 +17,10 @@ use syntax::ast;\n use syntax_pos::Span;\n \n /// On-demand query: yields a map containing all types mapped to their inherent impls.\n-pub fn crate_inherent_impls<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                      crate_num: CrateNum)\n-                                      -> &'tcx CrateInherentImpls {\n+pub fn crate_inherent_impls<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    crate_num: CrateNum,\n+) -> &'tcx CrateInherentImpls {\n     assert_eq!(crate_num, LOCAL_CRATE);\n \n     let krate = tcx.hir().krate();\n@@ -32,9 +33,7 @@ pub fn crate_inherent_impls<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n }\n \n /// On-demand query: yields a vector of the inherent impls for a specific type.\n-pub fn inherent_impls<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                ty_def_id: DefId)\n-                                -> &'tcx [DefId] {\n+pub fn inherent_impls<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, ty_def_id: DefId) -> &'tcx [DefId] {\n     assert!(ty_def_id.is_local());\n \n     // NB. Until we adopt the red-green dep-tracking algorithm (see"}, {"sha": "d557a9c871b121602530b0be9d274b24f2552149", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -5,15 +5,14 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::traits::{self, IntercrateMode};\n use rustc::ty::TyCtxt;\n \n-pub fn crate_inherent_impls_overlap_check<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                                    crate_num: CrateNum) {\n+pub fn crate_inherent_impls_overlap_check<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, crate_num: CrateNum) {\n     assert_eq!(crate_num, LOCAL_CRATE);\n     let krate = tcx.hir().krate();\n     krate.visit_all_item_likes(&mut InherentOverlapChecker { tcx });\n }\n \n struct InherentOverlapChecker<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>\n+    tcx: TyCtxt<'tcx, 'tcx>,\n }\n \n impl InherentOverlapChecker<'tcx> {"}, {"sha": "3be46722ecccda80faaaba02f235b6fc5aa53bcc", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -43,7 +43,7 @@ fn check_impl<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, hir_id: HirId) {\n fn enforce_trait_manually_implementable(\n     tcx: TyCtxt<'_, '_>,\n     impl_def_id: DefId,\n-    trait_def_id: DefId\n+    trait_def_id: DefId,\n ) {\n     let did = Some(trait_def_id);\n     let li = tcx.lang_items();\n@@ -99,7 +99,7 @@ fn enforce_trait_manually_implementable(\n fn enforce_empty_impls_for_marker_traits(\n     tcx: TyCtxt<'_, '_>,\n     impl_def_id: DefId,\n-    trait_def_id: DefId\n+    trait_def_id: DefId,\n ) {\n     if !tcx.trait_def(trait_def_id).is_marker {\n         return;"}, {"sha": "e1af8d8f46f7071bb4b93ee64492a6577e6c9c32", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -381,11 +381,7 @@ impl ItemCtxt<'tcx> {\n /// parameter with ID `param_id`. We use this so as to avoid running\n /// `ast_ty_to_ty`, because we want to avoid triggering an all-out\n /// conversion of the type to avoid inducing unnecessary cycles.\n-fn is_param<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    ast_ty: &hir::Ty,\n-    param_id: hir::HirId,\n-) -> bool {\n+fn is_param<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, ast_ty: &hir::Ty, param_id: hir::HirId) -> bool {\n     if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = ast_ty.node {\n         match path.res {\n             Res::SelfTy(Some(def_id), None) | Res::Def(DefKind::TyParam, def_id) => {\n@@ -578,7 +574,7 @@ fn convert_variant<'tcx>(\n     discr: ty::VariantDiscr,\n     def: &hir::VariantData,\n     adt_kind: ty::AdtKind,\n-    parent_did: DefId\n+    parent_did: DefId,\n ) -> ty::VariantDef {\n     let mut seen_fields: FxHashMap<ast::Ident, Span> = Default::default();\n     let hir_id = tcx.hir().as_local_hir_id(variant_did.unwrap_or(parent_did)).unwrap();\n@@ -779,10 +775,7 @@ fn trait_def<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::TraitDef\n     tcx.arena.alloc(def)\n }\n \n-fn has_late_bound_regions<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    node: Node<'tcx>,\n-) -> Option<Span> {\n+fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, node: Node<'tcx>) -> Option<Span> {\n     struct LateBoundRegionsDetector<'tcx> {\n         tcx: TyCtxt<'tcx, 'tcx>,\n         outer_index: ty::DebruijnIndex,\n@@ -1479,10 +1472,7 @@ pub fn checked_type_of<'tcx>(\n     })\n }\n \n-fn find_existential_constraints<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    def_id: DefId,\n-) -> Ty<'tcx> {\n+fn find_existential_constraints<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n     use rustc::hir::{ImplItem, Item, TraitItem};\n \n     debug!(\"find_existential_constraints({:?})\", def_id);\n@@ -1776,10 +1766,7 @@ fn fn_sig<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> ty::PolyFnSig<'tcx> {\n     }\n }\n \n-fn impl_trait_ref<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    def_id: DefId,\n-) -> Option<ty::TraitRef<'tcx>> {\n+fn impl_trait_ref<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Option<ty::TraitRef<'tcx>> {\n     let icx = ItemCtxt::new(tcx, def_id);\n \n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n@@ -2301,10 +2288,7 @@ fn is_foreign_item<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> bool {\n     }\n }\n \n-fn static_mutability<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx>,\n-    def_id: DefId,\n-) -> Option<hir::Mutability> {\n+fn static_mutability<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Option<hir::Mutability> {\n     match tcx.hir().get_if_local(def_id) {\n         Some(Node::Item(&hir::Item {\n             node: hir::ItemKind::Static(_, mutbl, _), .."}, {"sha": "3d424ce89dbc5c5134bc3670ea6c94c212ef9689", "filename": "src/librustc_typeck/constrained_generic_params.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -86,11 +86,12 @@ impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n     }\n }\n \n-pub fn identify_constrained_generic_params<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                              predicates: &ty::GenericPredicates<'tcx>,\n-                                              impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n-                                              input_parameters: &mut FxHashSet<Parameter>)\n-{\n+pub fn identify_constrained_generic_params<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    predicates: &ty::GenericPredicates<'tcx>,\n+    impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n+    input_parameters: &mut FxHashSet<Parameter>,\n+) {\n     let mut predicates = predicates.predicates.clone();\n     setup_constraining_predicates(tcx, &mut predicates, impl_trait_ref, input_parameters);\n }\n@@ -136,11 +137,12 @@ pub fn identify_constrained_generic_params<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n /// which is determined by 1, which requires `U`, that is determined\n /// by 0. I should probably pick a less tangled example, but I can't\n /// think of any.\n-pub fn setup_constraining_predicates<'tcx>(tcx: TyCtxt<'_, '_>,\n-                                           predicates: &mut [(ty::Predicate<'tcx>, Span)],\n-                                           impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n-                                           input_parameters: &mut FxHashSet<Parameter>)\n-{\n+pub fn setup_constraining_predicates<'tcx>(\n+    tcx: TyCtxt<'_, '_>,\n+    predicates: &mut [(ty::Predicate<'tcx>, Span)],\n+    impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n+    input_parameters: &mut FxHashSet<Parameter>,\n+) {\n     // The canonical way of doing the needed topological sort\n     // would be a DFS, but getting the graph and its ownership\n     // right is annoying, so I am using an in-place fixed-point iteration,"}, {"sha": "e13a664be05644b261f4f9581920b4b907cb2352", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -92,10 +92,11 @@ impl ItemLikeVisitor<'tcx> for ImplWfCheck<'tcx> {\n     fn visit_impl_item(&mut self, _impl_item: &'tcx hir::ImplItem) { }\n }\n \n-fn enforce_impl_params_are_constrained<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                                 impl_def_id: DefId,\n-                                                 impl_item_refs: &[hir::ImplItemRef])\n-{\n+fn enforce_impl_params_are_constrained<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    impl_def_id: DefId,\n+    impl_item_refs: &[hir::ImplItemRef],\n+) {\n     // Every lifetime used in an associated type must be constrained.\n     let impl_self_ty = tcx.type_of(impl_def_id);\n     let impl_generics = tcx.generics_of(impl_def_id);\n@@ -171,11 +172,7 @@ fn enforce_impl_params_are_constrained<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n     // used elsewhere are not projected back out.\n }\n \n-fn report_unused_parameter(tcx: TyCtxt<'_, '_>,\n-                           span: Span,\n-                           kind: &str,\n-                           name: &str)\n-{\n+fn report_unused_parameter(tcx: TyCtxt<'_, '_>, span: Span, kind: &str, name: &str) {\n     struct_span_err!(\n         tcx.sess, span, E0207,\n         \"the {} parameter `{}` is not constrained by the \\\n@@ -186,9 +183,10 @@ fn report_unused_parameter(tcx: TyCtxt<'_, '_>,\n }\n \n /// Enforce that we do not have two items in an impl with the same name.\n-fn enforce_impl_items_are_distinct<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                             impl_item_refs: &[hir::ImplItemRef])\n-{\n+fn enforce_impl_items_are_distinct<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    impl_item_refs: &[hir::ImplItemRef],\n+) {\n     let mut seen_type_items = FxHashMap::default();\n     let mut seen_value_items = FxHashMap::default();\n     for impl_item_ref in impl_item_refs {"}, {"sha": "ce8bb975f986687b252f17e5c95ce999d75070cd", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -124,8 +124,7 @@ pub struct TypeAndSubsts<'tcx> {\n     ty: Ty<'tcx>,\n }\n \n-fn check_type_alias_enum_variants_enabled<'gcx, 'tcx>(tcx: TyCtxt<'gcx, 'tcx>,\n-                                                          span: Span) {\n+fn check_type_alias_enum_variants_enabled<'gcx, 'tcx>(tcx: TyCtxt<'gcx, 'tcx>, span: Span) {\n     if !tcx.features().type_alias_enum_variants {\n         let mut err = tcx.sess.struct_span_err(\n             span,\n@@ -140,22 +139,20 @@ fn check_type_alias_enum_variants_enabled<'gcx, 'tcx>(tcx: TyCtxt<'gcx, 'tcx>,\n     }\n }\n \n-fn require_c_abi_if_c_variadic(tcx: TyCtxt<'_, '_>,\n-                               decl: &hir::FnDecl,\n-                               abi: Abi,\n-                               span: Span) {\n+fn require_c_abi_if_c_variadic(tcx: TyCtxt<'_, '_>, decl: &hir::FnDecl, abi: Abi, span: Span) {\n     if decl.c_variadic && !(abi == Abi::C || abi == Abi::Cdecl) {\n         let mut err = struct_span_err!(tcx.sess, span, E0045,\n             \"C-variadic function must have C or cdecl calling convention\");\n         err.span_label(span, \"C-variadics require C or cdecl calling convention\").emit();\n     }\n }\n \n-fn require_same_types<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                cause: &ObligationCause<'tcx>,\n-                                expected: Ty<'tcx>,\n-                                actual: Ty<'tcx>)\n-                                -> bool {\n+fn require_same_types<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    cause: &ObligationCause<'tcx>,\n+    expected: Ty<'tcx>,\n+    actual: Ty<'tcx>,\n+) -> bool {\n     tcx.infer_ctxt().enter(|ref infcx| {\n         let param_env = ty::ParamEnv::empty();\n         let mut fulfill_cx = TraitEngine::new(infcx.tcx);\n@@ -318,9 +315,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     impl_wf_check::provide(providers);\n }\n \n-pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx, 'tcx>)\n-                             -> Result<(), ErrorReported>\n-{\n+pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) -> Result<(), ErrorReported> {\n     tcx.sess.profiler(|p| p.start_activity(\"type-check crate\"));\n \n     // this ensures that later parts of type checking can assume that items\n@@ -392,8 +387,10 @@ pub fn hir_ty_to_ty<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, hir_ty: &hir::Ty) -> Ty<'tcx>\n     astconv::AstConv::ast_ty_to_ty(&item_cx, hir_ty)\n }\n \n-pub fn hir_trait_to_predicates<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, hir_trait: &hir::TraitRef)\n-        -> (ty::PolyTraitRef<'tcx>, Bounds<'tcx>) {\n+pub fn hir_trait_to_predicates<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    hir_trait: &hir::TraitRef,\n+) -> (ty::PolyTraitRef<'tcx>, Bounds<'tcx>) {\n     // In case there are any projections, etc., find the \"environment\"\n     // def-ID that will be used to determine the traits/predicates in\n     // scope.  This is derived from the enclosing item-like thing."}, {"sha": "22422081bc44e6419ec385217c3a96a42854e953", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -34,17 +34,18 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn crate_variances<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, crate_num: CrateNum)\n-                             -> &'tcx CrateVariancesMap<'tcx> {\n+fn crate_variances<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    crate_num: CrateNum,\n+) -> &'tcx CrateVariancesMap<'tcx> {\n     assert_eq!(crate_num, LOCAL_CRATE);\n     let mut arena = arena::TypedArena::default();\n     let terms_cx = terms::determine_parameters_to_be_inferred(tcx, &mut arena);\n     let constraints_cx = constraints::add_constraints_from_crate(terms_cx);\n     tcx.arena.alloc(solve::solve_constraints(constraints_cx))\n }\n \n-fn variances_of<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, item_def_id: DefId)\n-                          -> &'tcx [ty::Variance] {\n+fn variances_of<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, item_def_id: DefId) -> &'tcx [ty::Variance] {\n     let id = tcx.hir().as_local_hir_id(item_def_id).expect(\"expected local def-id\");\n     let unsupported = || {\n         // Variance not relevant."}, {"sha": "4f8bb0c4e462decb1c3db298a286342fa2508c56", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -64,9 +64,10 @@ pub struct TermsContext<'a, 'tcx: 'a> {\n     pub inferred_terms: Vec<VarianceTermPtr<'a>>,\n }\n \n-pub fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n-                                                     arena: &'a mut TypedArena<VarianceTerm<'a>>)\n-                                                     -> TermsContext<'a, 'tcx> {\n+pub fn determine_parameters_to_be_inferred<'a, 'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    arena: &'a mut TypedArena<VarianceTerm<'a>>,\n+) -> TermsContext<'a, 'tcx> {\n     let mut terms_cx = TermsContext {\n         tcx,\n         arena,"}, {"sha": "f43c2004255058fc29758b7ef974c0a3a347bc6e", "filename": "src/librustc_typeck/variance/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -8,7 +8,7 @@ pub fn test_variance<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n }\n \n struct VarianceTest<'tcx> {\n-    tcx: TyCtxt<'tcx, 'tcx>\n+    tcx: TyCtxt<'tcx, 'tcx>,\n }\n \n impl ItemLikeVisitor<'tcx> for VarianceTest<'tcx> {"}, {"sha": "7ddeac4abca13a8bba7e84417d32447b596c5e3d", "filename": "src/test/ui/pattern/const-pat-ice.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff08cb04389497d254fb40948674cbbee402908/src%2Ftest%2Fui%2Fpattern%2Fconst-pat-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fff08cb04389497d254fb40948674cbbee402908/src%2Ftest%2Fui%2Fpattern%2Fconst-pat-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fconst-pat-ice.stderr?ref=fff08cb04389497d254fb40948674cbbee402908", "patch": "@@ -1,4 +1,4 @@\n-thread 'rustc' panicked at 'assertion failed: rows.iter().all(|r| r.len() == v.len())', src/librustc_mir/hair/pattern/_match.rs:1085:5\n+thread 'rustc' panicked at 'assertion failed: rows.iter().all(|r| r.len() == v.len())', src/librustc_mir/hair/pattern/_match.rs:1084:5\n note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n \n error: internal compiler error: unexpected panic"}]}