{"sha": "7ecc8923dbebe5b47a090e406865cd381e80e220", "node_id": "C_kwDOAAsO6NoAKDdlY2M4OTIzZGJlYmU1YjQ3YTA5MGU0MDY4NjVjZDM4MWU4MGUyMjA", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-08-11T17:17:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-11T17:17:06Z"}, "message": "Rollup merge of #100398 - nnethercote:improve-Zhir-stats, r=michaelwoerister\n\nImprove `-Zhir-stats`\n\nAdd testing, improve coverage, avoid some double counting, and add more detail.\n\nr? `@michaelwoerister`", "tree": {"sha": "34904000d5499174890cc37141adc3d9e515811d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34904000d5499174890cc37141adc3d9e515811d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ecc8923dbebe5b47a090e406865cd381e80e220", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi9TmSCRBK7hj4Ov3rIwAA8akIAFLdZJyjLmabgSQnE8R1tuKS\nR6YgXIJz0jA3M3Oe+6ZOFW+6SVdxNwWGTivRoO9RjwYUWfAkuCfmfSK0V6qmGZzm\n6kc+ezxXtNHNFYSjmkLuyjDmIi1LmmeEJk9FlWDnK1zACHgyM3u5SnakD58EMyvM\nTxORVAI1blYcAdjb6IuWNm8yB1+FkwaGpRdSkrKLJMkVMmpUaixU+NcRq7KXKf3c\nYFm4i9yYZsNJlpLsis8sD5FKZiuRZx6UHsX6O5sEMjM4vQttzlpjtvKBivoT7M+D\nrMqNPwc2kl0CxKSjExNdnCKQHSI/1+CFzSfrWkB2mCi9DbMCfwWBcS0piBMhId8=\n=UAIl\n-----END PGP SIGNATURE-----\n", "payload": "tree 34904000d5499174890cc37141adc3d9e515811d\nparent bc0f9e39f45f48b83d19c56221eac64f14cf23af\nparent 4f8a1702bab38730bf2386e2e3df57b63a768077\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1660238226 +0530\ncommitter GitHub <noreply@github.com> 1660238226 +0530\n\nRollup merge of #100398 - nnethercote:improve-Zhir-stats, r=michaelwoerister\n\nImprove `-Zhir-stats`\n\nAdd testing, improve coverage, avoid some double counting, and add more detail.\n\nr? `@michaelwoerister`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ecc8923dbebe5b47a090e406865cd381e80e220", "html_url": "https://github.com/rust-lang/rust/commit/7ecc8923dbebe5b47a090e406865cd381e80e220", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ecc8923dbebe5b47a090e406865cd381e80e220/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc0f9e39f45f48b83d19c56221eac64f14cf23af", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc0f9e39f45f48b83d19c56221eac64f14cf23af", "html_url": "https://github.com/rust-lang/rust/commit/bc0f9e39f45f48b83d19c56221eac64f14cf23af"}, {"sha": "4f8a1702bab38730bf2386e2e3df57b63a768077", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f8a1702bab38730bf2386e2e3df57b63a768077", "html_url": "https://github.com/rust-lang/rust/commit/4f8a1702bab38730bf2386e2e3df57b63a768077"}], "stats": {"total": 497, "additions": 445, "deletions": 52}, "files": [{"sha": "ec070e6a9c5c63fdaabb85f126de05822fd4e12f", "filename": "compiler/rustc_passes/src/hir_stats.rs", "status": "modified", "additions": 253, "deletions": 52, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/7ecc8923dbebe5b47a090e406865cd381e80e220/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ecc8923dbebe5b47a090e406865cd381e80e220/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs?ref=7ecc8923dbebe5b47a090e406865cd381e80e220", "patch": "@@ -21,21 +21,55 @@ enum Id {\n     None,\n }\n \n-struct NodeData {\n+struct NodeStats {\n     count: usize,\n     size: usize,\n }\n \n+impl NodeStats {\n+    fn new() -> NodeStats {\n+        NodeStats { count: 0, size: 0 }\n+    }\n+}\n+\n+struct Node {\n+    stats: NodeStats,\n+    subnodes: FxHashMap<&'static str, NodeStats>,\n+}\n+\n+impl Node {\n+    fn new() -> Node {\n+        Node { stats: NodeStats::new(), subnodes: FxHashMap::default() }\n+    }\n+}\n+\n+/// This type measures the size of AST and HIR nodes, by implementing the AST\n+/// and HIR `Visitor` traits. But we don't measure every visited type because\n+/// that could cause double counting.\n+///\n+/// For example, `ast::Visitor` has `visit_ident`, but `Ident`s are always\n+/// stored inline within other AST nodes, so we don't implement `visit_ident`\n+/// here. In constrast, we do implement `visit_expr` because `ast::Expr` is\n+/// always stored as `P<ast::Expr>`, and every such expression should be\n+/// measured separately.\n+///\n+/// In general, a `visit_foo` method should be implemented here if the\n+/// corresponding `Foo` type is always stored on its own, e.g.: `P<Foo>`,\n+/// `Box<Foo>`, `Vec<Foo>`, `Box<[Foo]>`.\n+///\n+/// There are some types in the AST and HIR tree that the visitors do not have\n+/// a `visit_*` method for, and so we cannot measure these, which is\n+/// unfortunate.\n struct StatCollector<'k> {\n     krate: Option<Map<'k>>,\n-    data: FxHashMap<&'static str, NodeData>,\n+    nodes: FxHashMap<&'static str, Node>,\n     seen: FxHashSet<Id>,\n }\n \n pub fn print_hir_stats(tcx: TyCtxt<'_>) {\n     let mut collector = StatCollector {\n         krate: Some(tcx.hir()),\n-        data: FxHashMap::default(),\n+        nodes: FxHashMap::default(),\n         seen: FxHashSet::default(),\n     };\n     tcx.hir().walk_toplevel_module(&mut collector);\n@@ -44,49 +78,88 @@ pub fn print_hir_stats(tcx: TyCtxt<'_>) {\n }\n \n pub fn print_ast_stats(krate: &ast::Crate, title: &str) {\n+    use rustc_ast::visit::Visitor;\n+\n     let mut collector =\n-        StatCollector { krate: None, data: FxHashMap::default(), seen: FxHashSet::default() };\n-    ast_visit::walk_crate(&mut collector, krate);\n+        StatCollector { krate: None, nodes: FxHashMap::default(), seen: FxHashSet::default() };\n+    collector.visit_crate(krate);\n     collector.print(title);\n }\n \n impl<'k> StatCollector<'k> {\n-    fn record<T>(&mut self, label: &'static str, id: Id, node: &T) {\n+    // Record a top-level node.\n+    fn record<T>(&mut self, label: &'static str, id: Id, val: &T) {\n+        self.record_inner(label, None, id, val);\n+    }\n+\n+    // Record a two-level entry, with a top-level enum type and a variant.\n+    fn record_variant<T>(&mut self, label1: &'static str, label2: &'static str, id: Id, val: &T) {\n+        self.record_inner(label1, Some(label2), id, val);\n+    }\n+\n+    fn record_inner<T>(\n+        &mut self,\n+        label1: &'static str,\n+        label2: Option<&'static str>,\n+        id: Id,\n+        val: &T,\n+    ) {\n         if id != Id::None && !self.seen.insert(id) {\n             return;\n         }\n \n-        let entry = self.data.entry(label).or_insert(NodeData { count: 0, size: 0 });\n+        let node = self.nodes.entry(label1).or_insert(Node::new());\n+        node.stats.count += 1;\n+        node.stats.size = std::mem::size_of_val(val);\n \n-        entry.count += 1;\n-        entry.size = std::mem::size_of_val(node);\n+        if let Some(label2) = label2 {\n+            let subnode = node.subnodes.entry(label2).or_insert(NodeStats::new());\n+            subnode.count += 1;\n+            subnode.size = std::mem::size_of_val(val);\n+        }\n     }\n \n     fn print(&self, title: &str) {\n-        let mut stats: Vec<_> = self.data.iter().collect();\n-\n-        stats.sort_by_key(|&(_, ref d)| d.count * d.size);\n+        let mut nodes: Vec<_> = self.nodes.iter().collect();\n+        nodes.sort_by_key(|&(_, ref node)| node.stats.count * node.stats.size);\n \n-        let mut total_size = 0;\n+        let total_size = nodes.iter().map(|(_, node)| node.stats.count * node.stats.size).sum();\n \n         eprintln!(\"\\n{}\\n\", title);\n \n         eprintln!(\"{:<18}{:>18}{:>14}{:>14}\", \"Name\", \"Accumulated Size\", \"Count\", \"Item Size\");\n         eprintln!(\"----------------------------------------------------------------\");\n \n-        for (label, data) in stats {\n+        let percent = |m, n| (m * 100) as f64 / n as f64;\n+\n+        for (label, node) in nodes {\n+            let size = node.stats.count * node.stats.size;\n             eprintln!(\n-                \"{:<18}{:>18}{:>14}{:>14}\",\n+                \"{:<18}{:>10} ({:4.1}%){:>14}{:>14}\",\n                 label,\n-                to_readable_str(data.count * data.size),\n-                to_readable_str(data.count),\n-                to_readable_str(data.size)\n+                to_readable_str(size),\n+                percent(size, total_size),\n+                to_readable_str(node.stats.count),\n+                to_readable_str(node.stats.size)\n             );\n-\n-            total_size += data.count * data.size;\n+            if !node.subnodes.is_empty() {\n+                let mut subnodes: Vec<_> = node.subnodes.iter().collect();\n+                subnodes.sort_by_key(|&(_, ref subnode)| subnode.count * subnode.size);\n+\n+                for (label, subnode) in subnodes {\n+                    let size = subnode.count * subnode.size;\n+                    eprintln!(\n+                        \"- {:<18}{:>10} ({:4.1}%){:>14}\",\n+                        label,\n+                        to_readable_str(size),\n+                        percent(size, total_size),\n+                        to_readable_str(subnode.count),\n+                    );\n+                }\n+            }\n         }\n         eprintln!(\"----------------------------------------------------------------\");\n-        eprintln!(\"{:<18}{:>18}\\n\", \"Total\", to_readable_str(total_size));\n+        eprintln!(\"{:<18}{:>10}\\n\", \"Total\", to_readable_str(total_size));\n     }\n }\n \n@@ -228,6 +301,10 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         hir_visit::walk_path(self, path)\n     }\n \n+    // `PathSegment` has one inline use (in `ast::ExprKind::MethodCall`) and\n+    // one non-inline use (in `Path::segments`). The latter case is more common\n+    // than the former case, so we implement this visitor and tolerate the\n+    // double counting in the former case.\n     fn visit_path_segment(&mut self, path_span: Span, path_segment: &'v hir::PathSegment<'v>) {\n         self.record(\"PathSegment\", Id::None, path_segment);\n         hir_visit::walk_path_segment(self, path_span, path_segment)\n@@ -243,14 +320,54 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n     }\n }\n \n+// Used to avoid boilerplate for types with many variants.\n+macro_rules! record_variants {\n+    (\n+        ($self:ident, $val:expr, $kind:expr, $ty:ty, $tykind:ident), // mandatory pieces\n+        [$($variant:ident),*]\n+    ) => {\n+        match $kind {\n+            $(\n+                ast::$tykind::$variant { .. } => {\n+                    $self.record_variant(stringify!($ty), stringify!($variant), Id::None, $val)\n+                }\n+            )*\n+        }\n+    };\n+}\n+\n impl<'v> ast_visit::Visitor<'v> for StatCollector<'v> {\n     fn visit_foreign_item(&mut self, i: &'v ast::ForeignItem) {\n-        self.record(\"ForeignItem\", Id::None, i);\n+        record_variants!(\n+            (self, i, i.kind, ForeignItem, ForeignItemKind),\n+            [Static, Fn, TyAlias, MacCall]\n+        );\n         ast_visit::walk_foreign_item(self, i)\n     }\n \n     fn visit_item(&mut self, i: &'v ast::Item) {\n-        self.record(\"Item\", Id::None, i);\n+        record_variants!(\n+            (self, i, i.kind, Item, ItemKind),\n+            [\n+                ExternCrate,\n+                Use,\n+                Static,\n+                Const,\n+                Fn,\n+                Mod,\n+                ForeignMod,\n+                GlobalAsm,\n+                TyAlias,\n+                Enum,\n+                Struct,\n+                Union,\n+                Trait,\n+                TraitAlias,\n+                Impl,\n+                MacCall,\n+                MacroDef\n+            ]\n+        );\n         ast_visit::walk_item(self, i)\n     }\n \n@@ -265,47 +382,116 @@ impl<'v> ast_visit::Visitor<'v> for StatCollector<'v> {\n     }\n \n     fn visit_stmt(&mut self, s: &'v ast::Stmt) {\n-        self.record(\"Stmt\", Id::None, s);\n+        record_variants!(\n+            (self, s, s.kind, Stmt, StmtKind),\n+            [Local, Item, Expr, Semi, Empty, MacCall]\n+        );\n         ast_visit::walk_stmt(self, s)\n     }\n \n+    fn visit_param(&mut self, p: &'v ast::Param) {\n+        self.record(\"Param\", Id::None, p);\n+        ast_visit::walk_param(self, p)\n+    }\n+\n     fn visit_arm(&mut self, a: &'v ast::Arm) {\n         self.record(\"Arm\", Id::None, a);\n         ast_visit::walk_arm(self, a)\n     }\n \n     fn visit_pat(&mut self, p: &'v ast::Pat) {\n-        self.record(\"Pat\", Id::None, p);\n+        record_variants!(\n+            (self, p, p.kind, Pat, PatKind),\n+            [\n+                Wild,\n+                Ident,\n+                Struct,\n+                TupleStruct,\n+                Or,\n+                Path,\n+                Tuple,\n+                Box,\n+                Ref,\n+                Lit,\n+                Range,\n+                Slice,\n+                Rest,\n+                Paren,\n+                MacCall\n+            ]\n+        );\n         ast_visit::walk_pat(self, p)\n     }\n \n-    fn visit_expr(&mut self, ex: &'v ast::Expr) {\n-        self.record(\"Expr\", Id::None, ex);\n-        ast_visit::walk_expr(self, ex)\n+    fn visit_expr(&mut self, e: &'v ast::Expr) {\n+        record_variants!(\n+            (self, e, e.kind, Expr, ExprKind),\n+            [\n+                Box, Array, ConstBlock, Call, MethodCall, Tup, Binary, Unary, Lit, Cast, Type, Let,\n+                If, While, ForLoop, Loop, Match, Closure, Block, Async, Await, TryBlock, Assign,\n+                AssignOp, Field, Index, Range, Underscore, Path, AddrOf, Break, Continue, Ret,\n+                InlineAsm, MacCall, Struct, Repeat, Paren, Try, Yield, Yeet, Err\n+            ]\n+        );\n+        ast_visit::walk_expr(self, e)\n     }\n \n     fn visit_ty(&mut self, t: &'v ast::Ty) {\n-        self.record(\"Ty\", Id::None, t);\n+        record_variants!(\n+            (self, t, t.kind, Ty, TyKind),\n+            [\n+                Slice,\n+                Array,\n+                Ptr,\n+                Rptr,\n+                BareFn,\n+                Never,\n+                Tup,\n+                Path,\n+                TraitObject,\n+                ImplTrait,\n+                Paren,\n+                Typeof,\n+                Infer,\n+                ImplicitSelf,\n+                MacCall,\n+                Err,\n+                CVarArgs\n+            ]\n+        );\n+\n         ast_visit::walk_ty(self, t)\n     }\n \n+    fn visit_generic_param(&mut self, g: &'v ast::GenericParam) {\n+        self.record(\"GenericParam\", Id::None, g);\n+        ast_visit::walk_generic_param(self, g)\n+    }\n+\n+    fn visit_where_predicate(&mut self, p: &'v ast::WherePredicate) {\n+        record_variants!(\n+            (self, p, p, WherePredicate, WherePredicate),\n+            [BoundPredicate, RegionPredicate, EqPredicate]\n+        );\n+        ast_visit::walk_where_predicate(self, p)\n+    }\n+\n     fn visit_fn(&mut self, fk: ast_visit::FnKind<'v>, s: Span, _: NodeId) {\n         self.record(\"FnDecl\", Id::None, fk.decl());\n         ast_visit::walk_fn(self, fk, s)\n     }\n \n-    fn visit_assoc_item(&mut self, item: &'v ast::AssocItem, ctxt: ast_visit::AssocCtxt) {\n-        let label = match ctxt {\n-            ast_visit::AssocCtxt::Trait => \"TraitItem\",\n-            ast_visit::AssocCtxt::Impl => \"ImplItem\",\n-        };\n-        self.record(label, Id::None, item);\n-        ast_visit::walk_assoc_item(self, item, ctxt);\n+    fn visit_assoc_item(&mut self, i: &'v ast::AssocItem, ctxt: ast_visit::AssocCtxt) {\n+        record_variants!(\n+            (self, i, i.kind, AssocItem, AssocItemKind),\n+            [Const, Fn, TyAlias, MacCall]\n+        );\n+        ast_visit::walk_assoc_item(self, i, ctxt);\n     }\n \n-    fn visit_param_bound(&mut self, bounds: &'v ast::GenericBound, _ctxt: BoundKind) {\n-        self.record(\"GenericBound\", Id::None, bounds);\n-        ast_visit::walk_param_bound(self, bounds)\n+    fn visit_param_bound(&mut self, b: &'v ast::GenericBound, _ctxt: BoundKind) {\n+        record_variants!((self, b, b, GenericBound, GenericBound), [Trait, Outlives]);\n+        ast_visit::walk_param_bound(self, b)\n     }\n \n     fn visit_field_def(&mut self, s: &'v ast::FieldDef) {\n@@ -318,27 +504,42 @@ impl<'v> ast_visit::Visitor<'v> for StatCollector<'v> {\n         ast_visit::walk_variant(self, v)\n     }\n \n-    fn visit_lifetime(&mut self, lifetime: &'v ast::Lifetime, _: ast_visit::LifetimeCtxt) {\n-        self.record(\"Lifetime\", Id::None, lifetime);\n-        ast_visit::walk_lifetime(self, lifetime)\n-    }\n-\n-    fn visit_mac_call(&mut self, mac: &'v ast::MacCall) {\n-        self.record(\"MacCall\", Id::None, mac);\n-        ast_visit::walk_mac(self, mac)\n-    }\n+    // `UseTree` has one inline use (in `ast::ItemKind::Use`) and one\n+    // non-inline use (in `ast::UseTreeKind::Nested). The former case is more\n+    // common, so we don't implement `visit_use_tree` and tolerate the missed\n+    // coverage in the latter case.\n \n     fn visit_path_segment(&mut self, path_span: Span, path_segment: &'v ast::PathSegment) {\n         self.record(\"PathSegment\", Id::None, path_segment);\n         ast_visit::walk_path_segment(self, path_span, path_segment)\n     }\n \n-    fn visit_assoc_constraint(&mut self, constraint: &'v ast::AssocConstraint) {\n-        self.record(\"AssocConstraint\", Id::None, constraint);\n-        ast_visit::walk_assoc_constraint(self, constraint)\n+    // `GenericArgs` has one inline use (in `ast::AssocConstraint::gen_args`) and one\n+    // non-inline use (in `ast::PathSegment::args`). The latter case is more\n+    // common, so we implement `visit_generic_args` and tolerate the double\n+    // counting in the former case.\n+    fn visit_generic_args(&mut self, sp: Span, g: &'v ast::GenericArgs) {\n+        record_variants!((self, g, g, GenericArgs, GenericArgs), [AngleBracketed, Parenthesized]);\n+        ast_visit::walk_generic_args(self, sp, g)\n     }\n \n     fn visit_attribute(&mut self, attr: &'v ast::Attribute) {\n-        self.record(\"Attribute\", Id::None, attr);\n+        record_variants!((self, attr, attr.kind, Attribute, AttrKind), [Normal, DocComment]);\n+        ast_visit::walk_attribute(self, attr)\n+    }\n+\n+    fn visit_expr_field(&mut self, f: &'v ast::ExprField) {\n+        self.record(\"ExprField\", Id::None, f);\n+        ast_visit::walk_expr_field(self, f)\n+    }\n+\n+    fn visit_crate(&mut self, krate: &'v ast::Crate) {\n+        self.record(\"Crate\", Id::None, krate);\n+        ast_visit::walk_crate(self, krate)\n+    }\n+\n+    fn visit_inline_asm(&mut self, asm: &'v ast::InlineAsm) {\n+        self.record(\"InlineAsm\", Id::None, asm);\n+        ast_visit::walk_inline_asm(self, asm)\n     }\n }"}, {"sha": "a24b3ada57e59547d67f0e7761b38984dccdd12f", "filename": "src/test/ui/stats/hir-stats.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7ecc8923dbebe5b47a090e406865cd381e80e220/src%2Ftest%2Fui%2Fstats%2Fhir-stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ecc8923dbebe5b47a090e406865cd381e80e220/src%2Ftest%2Fui%2Fstats%2Fhir-stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstats%2Fhir-stats.rs?ref=7ecc8923dbebe5b47a090e406865cd381e80e220", "patch": "@@ -0,0 +1,41 @@\n+// check-pass\n+// compile-flags: -Zhir-stats\n+// only-x86_64\n+\n+// The aim here is to include at least one of every different type of top-level\n+// AST/HIR node reported by `-Zhir-stats`.\n+\n+#![allow(dead_code)]\n+\n+use std::arch::asm;\n+use std::fmt::Debug;\n+use std::ffi::c_void;\n+\n+extern \"C\" { fn f(p: *mut c_void); }\n+\n+/// An enum.\n+enum E<'a, T: Copy> { A { t: T }, B(&'a u32) }\n+\n+trait Go {\n+    type G: Debug;\n+    fn go(self) -> u32;\n+}\n+\n+impl<'a, T: Copy> Go for E<'a, T> {\n+    type G = bool;\n+    fn go(self) -> u32 {\n+        99\n+    }\n+}\n+\n+fn f2<T>(t: T) where T: Debug {}\n+\n+fn main() {\n+    let x = E::A { t: 3 };\n+    match x {\n+        E::A { .. } => {}\n+        _ => {}\n+    }\n+\n+    unsafe { asm!(\"mov rdi, 1\"); }\n+}"}, {"sha": "f4874408c909400c5ad114e4ea452a261aa34894", "filename": "src/test/ui/stats/hir-stats.stderr", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/7ecc8923dbebe5b47a090e406865cd381e80e220/src%2Ftest%2Fui%2Fstats%2Fhir-stats.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ecc8923dbebe5b47a090e406865cd381e80e220/src%2Ftest%2Fui%2Fstats%2Fhir-stats.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstats%2Fhir-stats.stderr?ref=7ecc8923dbebe5b47a090e406865cd381e80e220", "patch": "@@ -0,0 +1,151 @@\n+\n+PRE EXPANSION AST STATS\n+\n+Name                Accumulated Size         Count     Item Size\n+----------------------------------------------------------------\n+ExprField                 48 ( 0.5%)             1            48\n+GenericArgs               64 ( 0.7%)             1            64\n+- AngleBracketed            64 ( 0.7%)             1\n+Local                     72 ( 0.8%)             1            72\n+WherePredicate            72 ( 0.8%)             1            72\n+- BoundPredicate            72 ( 0.8%)             1\n+Crate                     72 ( 0.8%)             1            72\n+Arm                       96 ( 1.0%)             2            48\n+FieldDef                 160 ( 1.7%)             2            80\n+ForeignItem              160 ( 1.7%)             1           160\n+- Fn                       160 ( 1.7%)             1\n+Stmt                     160 ( 1.7%)             5            32\n+- Local                     32 ( 0.3%)             1\n+- MacCall                   32 ( 0.3%)             1\n+- Expr                      96 ( 1.0%)             3\n+Param                    160 ( 1.7%)             4            40\n+FnDecl                   200 ( 2.2%)             5            40\n+Variant                  240 ( 2.6%)             2           120\n+Block                    288 ( 3.1%)             6            48\n+Attribute                304 ( 3.3%)             2           152\n+- Normal                   152 ( 1.7%)             1\n+- DocComment               152 ( 1.7%)             1\n+GenericBound             352 ( 3.8%)             4            88\n+- Trait                    352 ( 3.8%)             4\n+GenericParam             520 ( 5.7%)             5           104\n+AssocItem                640 ( 7.0%)             4           160\n+- TyAlias                  320 ( 3.5%)             2\n+- Fn                       320 ( 3.5%)             2\n+PathSegment              720 ( 7.9%)            30            24\n+Expr                     832 ( 9.1%)             8           104\n+- Path                     104 ( 1.1%)             1\n+- Match                    104 ( 1.1%)             1\n+- Struct                   104 ( 1.1%)             1\n+- Lit                      208 ( 2.3%)             2\n+- Block                    312 ( 3.4%)             3\n+Pat                      840 ( 9.2%)             7           120\n+- Struct                   120 ( 1.3%)             1\n+- Wild                     120 ( 1.3%)             1\n+- Ident                    600 ( 6.6%)             5\n+Ty                     1_344 (14.7%)            14            96\n+- Rptr                      96 ( 1.0%)             1\n+- Ptr                       96 ( 1.0%)             1\n+- ImplicitSelf             192 ( 2.1%)             2\n+- Path                     960 (10.5%)            10\n+Item                   1_800 (19.7%)             9           200\n+- Trait                    200 ( 2.2%)             1\n+- Enum                     200 ( 2.2%)             1\n+- ForeignMod               200 ( 2.2%)             1\n+- Impl                     200 ( 2.2%)             1\n+- Fn                       400 ( 4.4%)             2\n+- Use                      600 ( 6.6%)             3\n+----------------------------------------------------------------\n+Total                  9_144\n+\n+\n+POST EXPANSION AST STATS\n+\n+Name                Accumulated Size         Count     Item Size\n+----------------------------------------------------------------\n+ExprField                 48 ( 0.5%)             1            48\n+GenericArgs               64 ( 0.6%)             1            64\n+- AngleBracketed            64 ( 0.6%)             1\n+Local                     72 ( 0.7%)             1            72\n+WherePredicate            72 ( 0.7%)             1            72\n+- BoundPredicate            72 ( 0.7%)             1\n+Crate                     72 ( 0.7%)             1            72\n+Arm                       96 ( 0.9%)             2            48\n+InlineAsm                120 ( 1.2%)             1           120\n+FieldDef                 160 ( 1.6%)             2            80\n+ForeignItem              160 ( 1.6%)             1           160\n+- Fn                       160 ( 1.6%)             1\n+Stmt                     160 ( 1.6%)             5            32\n+- Local                     32 ( 0.3%)             1\n+- Semi                      32 ( 0.3%)             1\n+- Expr                      96 ( 0.9%)             3\n+Param                    160 ( 1.6%)             4            40\n+FnDecl                   200 ( 2.0%)             5            40\n+Variant                  240 ( 2.4%)             2           120\n+Block                    288 ( 2.8%)             6            48\n+GenericBound             352 ( 3.5%)             4            88\n+- Trait                    352 ( 3.5%)             4\n+GenericParam             520 ( 5.1%)             5           104\n+Attribute                608 ( 6.0%)             4           152\n+- DocComment               152 ( 1.5%)             1\n+- Normal                   456 ( 4.5%)             3\n+AssocItem                640 ( 6.3%)             4           160\n+- TyAlias                  320 ( 3.2%)             2\n+- Fn                       320 ( 3.2%)             2\n+PathSegment              792 ( 7.8%)            33            24\n+Pat                      840 ( 8.3%)             7           120\n+- Struct                   120 ( 1.2%)             1\n+- Wild                     120 ( 1.2%)             1\n+- Ident                    600 ( 5.9%)             5\n+Expr                     936 ( 9.2%)             9           104\n+- Path                     104 ( 1.0%)             1\n+- Match                    104 ( 1.0%)             1\n+- Struct                   104 ( 1.0%)             1\n+- InlineAsm                104 ( 1.0%)             1\n+- Lit                      208 ( 2.1%)             2\n+- Block                    312 ( 3.1%)             3\n+Ty                     1_344 (13.2%)            14            96\n+- Rptr                      96 ( 0.9%)             1\n+- Ptr                       96 ( 0.9%)             1\n+- ImplicitSelf             192 ( 1.9%)             2\n+- Path                     960 ( 9.5%)            10\n+Item                   2_200 (21.7%)            11           200\n+- Trait                    200 ( 2.0%)             1\n+- Enum                     200 ( 2.0%)             1\n+- ExternCrate              200 ( 2.0%)             1\n+- ForeignMod               200 ( 2.0%)             1\n+- Impl                     200 ( 2.0%)             1\n+- Fn                       400 ( 3.9%)             2\n+- Use                      800 ( 7.9%)             4\n+----------------------------------------------------------------\n+Total                 10_144\n+\n+\n+HIR STATS\n+\n+Name                Accumulated Size         Count     Item Size\n+----------------------------------------------------------------\n+Param                     64 ( 0.7%)             2            32\n+Local                     64 ( 0.7%)             1            64\n+ForeignItem               72 ( 0.7%)             1            72\n+FieldDef                  96 ( 1.0%)             2            48\n+Arm                       96 ( 1.0%)             2            48\n+Stmt                      96 ( 1.0%)             3            32\n+FnDecl                   120 ( 1.2%)             3            40\n+Lifetime                 128 ( 1.3%)             4            32\n+Variant                  160 ( 1.6%)             2            80\n+ImplItem                 176 ( 1.8%)             2            88\n+GenericBound             192 ( 2.0%)             4            48\n+TraitItem                192 ( 2.0%)             2            96\n+WherePredicate           216 ( 2.2%)             3            72\n+Block                    288 ( 3.0%)             6            48\n+QPath                    408 ( 4.2%)            17            24\n+Pat                      440 ( 4.5%)             5            88\n+Attribute                608 ( 6.2%)             4           152\n+Expr                     672 ( 6.9%)            12            56\n+Item                     960 ( 9.9%)            12            80\n+Ty                     1_152 (11.8%)            16            72\n+Path                   1_296 (13.3%)            27            48\n+PathSegment            2_240 (23.0%)            40            56\n+----------------------------------------------------------------\n+Total                  9_736\n+"}]}