{"sha": "cddd85e2f30fb185de55209f5843a235cdc79a88", "node_id": "C_kwDOAAsO6NoAKGNkZGQ4NWUyZjMwZmIxODVkZTU1MjA5ZjU4NDNhMjM1Y2RjNzlhODg", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-04-25T18:18:52Z"}, "committer": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-04-30T14:26:26Z"}, "message": "Move SB diagnostics to a module", "tree": {"sha": "89e4af04b85e4770230a278acee22f9ac4cf2ef6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89e4af04b85e4770230a278acee22f9ac4cf2ef6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cddd85e2f30fb185de55209f5843a235cdc79a88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cddd85e2f30fb185de55209f5843a235cdc79a88", "html_url": "https://github.com/rust-lang/rust/commit/cddd85e2f30fb185de55209f5843a235cdc79a88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cddd85e2f30fb185de55209f5843a235cdc79a88/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5861d137b25997a7f4947fe6046003d2d0facde2", "url": "https://api.github.com/repos/rust-lang/rust/commits/5861d137b25997a7f4947fe6046003d2d0facde2", "html_url": "https://github.com/rust-lang/rust/commit/5861d137b25997a7f4947fe6046003d2d0facde2"}], "stats": {"total": 562, "additions": 311, "deletions": 251}, "files": [{"sha": "56cd3bb83def197ae70d0ad9b0f43e7d28be48c8", "filename": "src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cddd85e2f30fb185de55209f5843a235cdc79a88/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cddd85e2f30fb185de55209f5843a235cdc79a88/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=cddd85e2f30fb185de55209f5843a235cdc79a88", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::ty;\n use rustc_span::{source_map::DUMMY_SP, Span, SpanData, Symbol};\n \n use crate::helpers::HexRange;\n-use crate::stacked_borrows::{AccessKind, SbTag, TagHistory};\n+use crate::stacked_borrows::{diagnostics::TagHistory, AccessKind, SbTag};\n use crate::*;\n \n /// Details of premature program termination."}, {"sha": "a3228f763a8e1c72518e66553daa588011560d41", "filename": "src/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cddd85e2f30fb185de55209f5843a235cdc79a88/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cddd85e2f30fb185de55209f5843a235cdc79a88/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=cddd85e2f30fb185de55209f5843a235cdc79a88", "patch": "@@ -15,8 +15,8 @@ use rustc_target::spec::abi::Abi;\n \n use rustc_session::config::EntryFnType;\n \n-use std::collections::HashSet;\n use rustc_span::DUMMY_SP;\n+use std::collections::HashSet;\n \n use crate::*;\n "}, {"sha": "2fb5dca6dd68f442e235c926fa93a7d6c5a75f89", "filename": "src/machine.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cddd85e2f30fb185de55209f5843a235cdc79a88/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cddd85e2f30fb185de55209f5843a235cdc79a88/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=cddd85e2f30fb185de55209f5843a235cdc79a88", "patch": "@@ -776,6 +776,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n // This is potentially a performance hazard.\n // Factoring it into its own function lets us keep an eye on how much it shows up in a profile.\n+///\n fn set_current_span<'mir, 'tcx: 'mir>(machine: &Evaluator<'mir, 'tcx>) {\n     if let Some(sb) = machine.stacked_borrows.as_ref() {\n         if sb.borrow().current_span != DUMMY_SP {"}, {"sha": "6ffa89087e869cfa3de73431a61886a4d00ff265", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 9, "deletions": 249, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/cddd85e2f30fb185de55209f5843a235cdc79a88/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cddd85e2f30fb185de55209f5843a235cdc79a88/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=cddd85e2f30fb185de55209f5843a235cdc79a88", "patch": "@@ -14,14 +14,18 @@ use rustc_middle::ty::{\n     self,\n     layout::{HasParamEnv, LayoutOf},\n };\n+use rustc_span::Span;\n use rustc_span::DUMMY_SP;\n-use rustc_span::{Span, SpanData};\n use rustc_target::abi::Size;\n use std::collections::HashSet;\n \n-use crate::helpers::HexRange;\n use crate::*;\n \n+pub mod diagnostics;\n+use diagnostics::{AllocHistory, GlobalStateExt, StackExt};\n+\n+use diagnostics::TagHistory;\n+\n pub type PtrId = NonZeroU64;\n pub type CallId = NonZeroU64;\n pub type AllocExtra = Stacks;\n@@ -120,47 +124,6 @@ pub struct GlobalStateInner {\n     pub(crate) current_span: Span,\n }\n \n-#[derive(Debug, Default)]\n-struct AllocHistory {\n-    // The time tags can be compressed down to one bit per event, by just storing a Vec<u8>\n-    // where each bit is set to indicate if the event was a creation or a retag\n-    current_time: usize,\n-    creations: smallvec::SmallVec<[Event; 2]>,\n-    invalidations: smallvec::SmallVec<[Event; 1]>,\n-    protectors: smallvec::SmallVec<[Protection; 1]>,\n-}\n-\n-#[derive(Debug)]\n-struct Protection {\n-    orig_tag: SbTag,\n-    tag: SbTag,\n-    span: Span,\n-}\n-\n-#[derive(Debug)]\n-struct Event {\n-    time: usize,\n-    parent: Option<SbTag>,\n-    tag: SbTag,\n-    range: AllocRange,\n-    span: Span,\n-}\n-\n-pub enum TagHistory {\n-    Tagged {\n-        tag: SbTag,\n-        created: (AllocRange, SpanData),\n-        invalidated: Option<(AllocRange, SpanData)>,\n-        protected: Option<(SbTag, SpanData, SpanData)>,\n-    },\n-    Untagged {\n-        recently_created: Option<(AllocRange, SpanData)>,\n-        recently_invalidated: Option<(AllocRange, SpanData)>,\n-        matching_created: Option<(AllocRange, SpanData)>,\n-        protected: Option<(SbTag, SpanData, SpanData)>,\n-    },\n-}\n-\n /// We need interior mutable access to the global state.\n pub type GlobalState = RefCell<GlobalStateInner>;\n \n@@ -269,144 +232,10 @@ impl GlobalStateInner {\n         self.base_ptr_ids.try_insert(id, tag).unwrap();\n         tag\n     }\n-\n-    fn add_creation(\n-        &mut self,\n-        parent: Option<SbTag>,\n-        tag: SbTag,\n-        alloc: AllocId,\n-        range: AllocRange,\n-    ) {\n-        let extras = self.extras.entry(alloc).or_default();\n-        extras.creations.push(Event {\n-            parent,\n-            tag,\n-            range,\n-            span: self.current_span,\n-            time: extras.current_time,\n-        });\n-        extras.current_time += 1;\n-    }\n-\n-    fn add_invalidation(&mut self, tag: SbTag, alloc: AllocId, range: AllocRange) {\n-        let extras = self.extras.entry(alloc).or_default();\n-        extras.invalidations.push(Event {\n-            parent: None,\n-            tag,\n-            range,\n-            span: self.current_span,\n-            time: extras.current_time,\n-        });\n-        extras.current_time += 1;\n-    }\n-\n-    fn add_protector(&mut self, orig_tag: SbTag, tag: SbTag, alloc: AllocId) {\n-        let extras = self.extras.entry(alloc).or_default();\n-        extras.protectors.push(Protection { orig_tag, tag, span: self.current_span });\n-        extras.current_time += 1;\n-    }\n-\n-    fn get_stack_history(\n-        &self,\n-        tag: SbTag,\n-        alloc: AllocId,\n-        alloc_range: AllocRange,\n-        offset: Size,\n-        protector_tag: Option<SbTag>,\n-    ) -> Option<TagHistory> {\n-        let extras = self.extras.get(&alloc)?;\n-        let protected = protector_tag\n-            .and_then(|protector| {\n-                extras.protectors.iter().find_map(|protection| {\n-                    if protection.tag == protector {\n-                        Some((protection.orig_tag, protection.span.data()))\n-                    } else {\n-                        None\n-                    }\n-                })\n-            })\n-            .and_then(|(tag, call_span)| {\n-                extras.creations.iter().rev().find_map(|event| {\n-                    if event.tag == tag {\n-                        Some((event.parent?, event.span.data(), call_span))\n-                    } else {\n-                        None\n-                    }\n-                })\n-            });\n-        if let SbTag::Tagged(_) = tag {\n-            let get_matching = |events: &[Event]| {\n-                events.iter().rev().find_map(|event| {\n-                    if event.tag == tag { Some((event.range, event.span.data())) } else { None }\n-                })\n-            };\n-            Some(TagHistory::Tagged {\n-                tag,\n-                created: get_matching(&extras.creations)?,\n-                invalidated: get_matching(&extras.invalidations),\n-                protected,\n-            })\n-        } else {\n-            let mut created_time = 0;\n-            // Find the most recently created tag that satsfies this offset\n-            let recently_created = extras.creations.iter().rev().find_map(|event| {\n-                if event.tag == tag && offset >= event.range.start && offset < event.range.end() {\n-                    created_time = event.time;\n-                    Some((event.range, event.span.data()))\n-                } else {\n-                    None\n-                }\n-            });\n-\n-            // Find a different recently created tag that satisfies this whole operation, predates\n-            // the recently created tag, and has a different span.\n-            // We're trying to make a guess at which span the user wanted to provide the tag that\n-            // they're using.\n-            let matching_created = if let Some((_created_range, created_span)) = recently_created {\n-                extras.creations.iter().rev().find_map(|event| {\n-                    if event.tag == tag\n-                        && alloc_range.start >= event.range.start\n-                        && alloc_range.end() <= event.range.end()\n-                        && event.span.data() != created_span\n-                        && event.time != created_time\n-                    {\n-                        Some((event.range, event.span.data()))\n-                    } else {\n-                        None\n-                    }\n-                })\n-            } else {\n-                None\n-            };\n-\n-            let recently_invalidated = if recently_created.is_some() {\n-                // Find the most recent invalidation of this tag which post-dates the creation\n-                let mut found = None;\n-                for event in extras.invalidations.iter().rev() {\n-                    if event.time < created_time {\n-                        break;\n-                    }\n-                    if event.tag == tag && offset >= event.range.start && offset < event.range.end()\n-                    {\n-                        found = Some((event.range, event.span.data()))\n-                    }\n-                }\n-                found\n-            } else {\n-                None\n-            };\n-            Some(TagHistory::Untagged {\n-                recently_created,\n-                matching_created,\n-                recently_invalidated,\n-                protected,\n-            })\n-        }\n-    }\n }\n \n /// Error reporting\n-fn err_sb_ub(\n+pub fn err_sb_ub(\n     msg: String,\n     help: Option<String>,\n     history: Option<TagHistory>,\n@@ -498,7 +327,7 @@ impl<'tcx> Stack {\n     /// `None` during a deallocation.\n     fn check_protector(\n         item: &Item,\n-        provoking_access: Option<(SbTag, AllocId, AllocRange, Size)>, // just for debug printing amd error messages\n+        provoking_access: Option<(SbTag, AllocId, AllocRange, Size)>, // just for debug printing and error messages\n         global: &GlobalStateInner,\n     ) -> InterpResult<'tcx> {\n         if let SbTag::Tagged(id) = item.tag {\n@@ -600,7 +429,7 @@ impl<'tcx> Stack {\n     fn dealloc(\n         &mut self,\n         tag: SbTag,\n-        (alloc_id, alloc_range, offset): (AllocId, AllocRange, Size), // just for debug printing amd error messages\n+        (alloc_id, alloc_range, offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n         global: &GlobalStateInner,\n     ) -> InterpResult<'tcx> {\n         // Step 1: Find granting item.\n@@ -681,75 +510,6 @@ impl<'tcx> Stack {\n \n         Ok(())\n     }\n-\n-    /// Report a descriptive error when `new` could not be granted from `derived_from`.\n-    fn grant_error(\n-        &self,\n-        derived_from: SbTag,\n-        new: Item,\n-        alloc_id: AllocId,\n-        alloc_range: AllocRange,\n-        error_offset: Size,\n-        global: &GlobalStateInner,\n-    ) -> InterpError<'static> {\n-        let action = format!(\n-            \"trying to reborrow {:?} for {:?} permission at {}[{:#x}]\",\n-            derived_from,\n-            new.perm,\n-            alloc_id,\n-            error_offset.bytes(),\n-        );\n-        err_sb_ub(\n-            format!(\"{}{}\", action, self.error_cause(derived_from)),\n-            Some(Self::operation_summary(\"a reborrow\", alloc_id, alloc_range)),\n-            global.get_stack_history(derived_from, alloc_id, alloc_range, error_offset, None),\n-        )\n-    }\n-\n-    /// Report a descriptive error when `access` is not permitted based on `tag`.\n-    fn access_error(\n-        &self,\n-        access: AccessKind,\n-        tag: SbTag,\n-        alloc_id: AllocId,\n-        alloc_range: AllocRange,\n-        error_offset: Size,\n-        global: &GlobalStateInner,\n-    ) -> InterpError<'static> {\n-        let action = format!(\n-            \"attempting a {} using {:?} at {}[{:#x}]\",\n-            access,\n-            tag,\n-            alloc_id,\n-            error_offset.bytes(),\n-        );\n-        err_sb_ub(\n-            format!(\"{}{}\", action, self.error_cause(tag)),\n-            Some(Self::operation_summary(\"an access\", alloc_id, alloc_range)),\n-            global.get_stack_history(tag, alloc_id, alloc_range, error_offset, None),\n-        )\n-    }\n-\n-    fn operation_summary(\n-        operation: &'static str,\n-        alloc_id: AllocId,\n-        alloc_range: AllocRange,\n-    ) -> String {\n-        format!(\n-            \"this error occurs as part of {} at {:?}{}\",\n-            operation,\n-            alloc_id,\n-            HexRange(alloc_range)\n-        )\n-    }\n-\n-    fn error_cause(&self, tag: SbTag) -> &'static str {\n-        if self.borrows.iter().any(|item| item.tag == tag && item.perm != Permission::Disabled) {\n-            \", but that tag only grants SharedReadOnly permission for this location\"\n-        } else {\n-            \", but that tag does not exist in the borrow stack for this location\"\n-        }\n-    }\n }\n // # Stacked Borrows Core End\n "}, {"sha": "d5a65825bc2c5804648d902754b2494abe17b944", "filename": "src/stacked_borrows/diagnostics.rs", "status": "added", "additions": 299, "deletions": 0, "changes": 299, "blob_url": "https://github.com/rust-lang/rust/blob/cddd85e2f30fb185de55209f5843a235cdc79a88/src%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cddd85e2f30fb185de55209f5843a235cdc79a88/src%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fdiagnostics.rs?ref=cddd85e2f30fb185de55209f5843a235cdc79a88", "patch": "@@ -0,0 +1,299 @@\n+use rustc_middle::mir::interpret::{AllocId, AllocRange};\n+use rustc_span::{Span, SpanData};\n+use rustc_target::abi::Size;\n+\n+use crate::helpers::HexRange;\n+use crate::stacked_borrows::{err_sb_ub, AccessKind, GlobalStateInner, Permission};\n+use crate::Item;\n+use crate::SbTag;\n+use crate::Stack;\n+\n+use rustc_middle::mir::interpret::InterpError;\n+\n+#[derive(Debug, Default)]\n+pub struct AllocHistory {\n+    // The time tags can be compressed down to one bit per event, by just storing a Vec<u8>\n+    // where each bit is set to indicate if the event was a creation or a retag\n+    current_time: usize,\n+    creations: smallvec::SmallVec<[Event; 2]>,\n+    invalidations: smallvec::SmallVec<[Event; 1]>,\n+    protectors: smallvec::SmallVec<[Protection; 1]>,\n+}\n+\n+#[derive(Debug)]\n+struct Protection {\n+    orig_tag: SbTag,\n+    tag: SbTag,\n+    span: Span,\n+}\n+\n+#[derive(Debug)]\n+struct Event {\n+    time: usize,\n+    parent: Option<SbTag>,\n+    tag: SbTag,\n+    range: AllocRange,\n+    span: Span,\n+}\n+\n+pub enum TagHistory {\n+    Tagged {\n+        tag: SbTag,\n+        created: (AllocRange, SpanData),\n+        invalidated: Option<(AllocRange, SpanData)>,\n+        protected: Option<(SbTag, SpanData, SpanData)>,\n+    },\n+    Untagged {\n+        recently_created: Option<(AllocRange, SpanData)>,\n+        recently_invalidated: Option<(AllocRange, SpanData)>,\n+        matching_created: Option<(AllocRange, SpanData)>,\n+        protected: Option<(SbTag, SpanData, SpanData)>,\n+    },\n+}\n+\n+pub trait GlobalStateExt {\n+    fn add_creation(\n+        &mut self,\n+        parent: Option<SbTag>,\n+        tag: SbTag,\n+        alloc: AllocId,\n+        range: AllocRange,\n+    );\n+\n+    fn add_invalidation(&mut self, tag: SbTag, alloc: AllocId, range: AllocRange);\n+\n+    fn add_protector(&mut self, orig_tag: SbTag, tag: SbTag, alloc: AllocId);\n+\n+    fn get_stack_history(\n+        &self,\n+        tag: SbTag,\n+        alloc: AllocId,\n+        alloc_range: AllocRange,\n+        offset: Size,\n+        protector_tag: Option<SbTag>,\n+    ) -> Option<TagHistory>;\n+}\n+\n+impl GlobalStateExt for GlobalStateInner {\n+    fn add_creation(\n+        &mut self,\n+        parent: Option<SbTag>,\n+        tag: SbTag,\n+        alloc: AllocId,\n+        range: AllocRange,\n+    ) {\n+        let extras = self.extras.entry(alloc).or_default();\n+        extras.creations.push(Event {\n+            parent,\n+            tag,\n+            range,\n+            span: self.current_span,\n+            time: extras.current_time,\n+        });\n+        extras.current_time += 1;\n+    }\n+\n+    fn add_invalidation(&mut self, tag: SbTag, alloc: AllocId, range: AllocRange) {\n+        let extras = self.extras.entry(alloc).or_default();\n+        extras.invalidations.push(Event {\n+            parent: None,\n+            tag,\n+            range,\n+            span: self.current_span,\n+            time: extras.current_time,\n+        });\n+        extras.current_time += 1;\n+    }\n+\n+    fn add_protector(&mut self, orig_tag: SbTag, tag: SbTag, alloc: AllocId) {\n+        let extras = self.extras.entry(alloc).or_default();\n+        extras.protectors.push(Protection { orig_tag, tag, span: self.current_span });\n+        extras.current_time += 1;\n+    }\n+\n+    fn get_stack_history(\n+        &self,\n+        tag: SbTag,\n+        alloc: AllocId,\n+        alloc_range: AllocRange,\n+        offset: Size,\n+        protector_tag: Option<SbTag>,\n+    ) -> Option<TagHistory> {\n+        let extras = self.extras.get(&alloc)?;\n+        let protected = protector_tag\n+            .and_then(|protector| {\n+                extras.protectors.iter().find_map(|protection| {\n+                    if protection.tag == protector {\n+                        Some((protection.orig_tag, protection.span.data()))\n+                    } else {\n+                        None\n+                    }\n+                })\n+            })\n+            .and_then(|(tag, call_span)| {\n+                extras.creations.iter().rev().find_map(|event| {\n+                    if event.tag == tag {\n+                        Some((event.parent?, event.span.data(), call_span))\n+                    } else {\n+                        None\n+                    }\n+                })\n+            });\n+        if let SbTag::Tagged(_) = tag {\n+            let get_matching = |events: &[Event]| {\n+                events.iter().rev().find_map(|event| {\n+                    if event.tag == tag { Some((event.range, event.span.data())) } else { None }\n+                })\n+            };\n+            Some(TagHistory::Tagged {\n+                tag,\n+                created: get_matching(&extras.creations)?,\n+                invalidated: get_matching(&extras.invalidations),\n+                protected,\n+            })\n+        } else {\n+            let mut created_time = 0;\n+            // Find the most recently created tag that satsfies this offset\n+            let recently_created = extras.creations.iter().rev().find_map(|event| {\n+                if event.tag == tag && offset >= event.range.start && offset < event.range.end() {\n+                    created_time = event.time;\n+                    Some((event.range, event.span.data()))\n+                } else {\n+                    None\n+                }\n+            });\n+\n+            // Find a different recently created tag that satisfies this whole operation, predates\n+            // the recently created tag, and has a different span.\n+            // We're trying to make a guess at which span the user wanted to provide the tag that\n+            // they're using.\n+            let matching_created = if let Some((_created_range, created_span)) = recently_created {\n+                extras.creations.iter().rev().find_map(|event| {\n+                    if event.tag == tag\n+                        && alloc_range.start >= event.range.start\n+                        && alloc_range.end() <= event.range.end()\n+                        && event.span.data() != created_span\n+                        && event.time != created_time\n+                    {\n+                        Some((event.range, event.span.data()))\n+                    } else {\n+                        None\n+                    }\n+                })\n+            } else {\n+                None\n+            };\n+\n+            let recently_invalidated = if recently_created.is_some() {\n+                // Find the most recent invalidation of this tag which post-dates the creation\n+                let mut found = None;\n+                for event in extras.invalidations.iter().rev() {\n+                    if event.time < created_time {\n+                        break;\n+                    }\n+                    if event.tag == tag && offset >= event.range.start && offset < event.range.end()\n+                    {\n+                        found = Some((event.range, event.span.data()))\n+                    }\n+                }\n+                found\n+            } else {\n+                None\n+            };\n+            Some(TagHistory::Untagged {\n+                recently_created,\n+                matching_created,\n+                recently_invalidated,\n+                protected,\n+            })\n+        }\n+    }\n+}\n+\n+pub trait StackExt {\n+    fn grant_error(\n+        &self,\n+        derived_from: SbTag,\n+        new: Item,\n+        alloc_id: AllocId,\n+        alloc_range: AllocRange,\n+        error_offset: Size,\n+        global: &GlobalStateInner,\n+    ) -> InterpError<'static>;\n+\n+    fn access_error(\n+        &self,\n+        access: AccessKind,\n+        tag: SbTag,\n+        alloc_id: AllocId,\n+        alloc_range: AllocRange,\n+        error_offset: Size,\n+        global: &GlobalStateInner,\n+    ) -> InterpError<'static>;\n+}\n+\n+impl StackExt for Stack {\n+    /// Report a descriptive error when `new` could not be granted from `derived_from`.\n+    fn grant_error(\n+        &self,\n+        derived_from: SbTag,\n+        new: Item,\n+        alloc_id: AllocId,\n+        alloc_range: AllocRange,\n+        error_offset: Size,\n+        global: &GlobalStateInner,\n+    ) -> InterpError<'static> {\n+        let action = format!(\n+            \"trying to reborrow {:?} for {:?} permission at {}[{:#x}]\",\n+            derived_from,\n+            new.perm,\n+            alloc_id,\n+            error_offset.bytes(),\n+        );\n+        err_sb_ub(\n+            format!(\"{}{}\", action, error_cause(self, derived_from)),\n+            Some(operation_summary(\"a reborrow\", alloc_id, alloc_range)),\n+            global.get_stack_history(derived_from, alloc_id, alloc_range, error_offset, None),\n+        )\n+    }\n+\n+    /// Report a descriptive error when `access` is not permitted based on `tag`.\n+    fn access_error(\n+        &self,\n+        access: AccessKind,\n+        tag: SbTag,\n+        alloc_id: AllocId,\n+        alloc_range: AllocRange,\n+        error_offset: Size,\n+        global: &GlobalStateInner,\n+    ) -> InterpError<'static> {\n+        let action = format!(\n+            \"attempting a {} using {:?} at {}[{:#x}]\",\n+            access,\n+            tag,\n+            alloc_id,\n+            error_offset.bytes(),\n+        );\n+        err_sb_ub(\n+            format!(\"{}{}\", action, error_cause(self, tag)),\n+            Some(operation_summary(\"an access\", alloc_id, alloc_range)),\n+            global.get_stack_history(tag, alloc_id, alloc_range, error_offset, None),\n+        )\n+    }\n+}\n+\n+fn operation_summary(\n+    operation: &'static str,\n+    alloc_id: AllocId,\n+    alloc_range: AllocRange,\n+) -> String {\n+    format!(\"this error occurs as part of {} at {:?}{}\", operation, alloc_id, HexRange(alloc_range))\n+}\n+\n+fn error_cause(stack: &Stack, tag: SbTag) -> &'static str {\n+    if stack.borrows.iter().any(|item| item.tag == tag && item.perm != Permission::Disabled) {\n+        \", but that tag only grants SharedReadOnly permission for this location\"\n+    } else {\n+        \", but that tag does not exist in the borrow stack for this location\"\n+    }\n+}"}]}