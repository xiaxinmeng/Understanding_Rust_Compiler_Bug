{"sha": "379c255eb926e4bb577121c84437ab3934aa4475", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3OWMyNTVlYjkyNmU0YmI1NzcxMjFjODQ0MzdhYjM5MzRhYTQ0NzU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-04-05T22:33:03Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-04-06T22:41:18Z"}, "message": "linker: Factor out more parts of `linker_with_args` and add some docs", "tree": {"sha": "9c70a4d014c709d741f27a81cba5d683d393048c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c70a4d014c709d741f27a81cba5d683d393048c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/379c255eb926e4bb577121c84437ab3934aa4475", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/379c255eb926e4bb577121c84437ab3934aa4475", "html_url": "https://github.com/rust-lang/rust/commit/379c255eb926e4bb577121c84437ab3934aa4475", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/379c255eb926e4bb577121c84437ab3934aa4475/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd6fa686df4ec661048e39c14c9295a61a19e447", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd6fa686df4ec661048e39c14c9295a61a19e447", "html_url": "https://github.com/rust-lang/rust/commit/fd6fa686df4ec661048e39c14c9295a61a19e447"}], "stats": {"total": 304, "additions": 183, "deletions": 121}, "files": [{"sha": "9a434b39b9a14ec80e518e2c55f950ac60e981c5", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 183, "deletions": 121, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/379c255eb926e4bb577121c84437ab3934aa4475/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/379c255eb926e4bb577121c84437ab3934aa4475/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=379c255eb926e4bb577121c84437ab3934aa4475", "patch": "@@ -1255,6 +1255,87 @@ fn add_post_link_args(cmd: &mut dyn Linker, sess: &'a Session, flavor: LinkerFla\n     }\n }\n \n+/// Add object files containing code from the current crate.\n+fn add_local_crate_regular_objects(cmd: &mut dyn Linker, codegen_results: &CodegenResults) {\n+    for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n+        cmd.add_object(obj);\n+    }\n+}\n+\n+/// Add object files for allocator code linked once for the whole crate tree.\n+fn add_local_crate_allocator_objects(cmd: &mut dyn Linker, codegen_results: &CodegenResults) {\n+    let obj = codegen_results.allocator_module.as_ref().and_then(|m| m.object.as_ref());\n+    if let Some(obj) = obj {\n+        cmd.add_object(obj);\n+    }\n+}\n+\n+/// Add object files containing metadata for the current crate.\n+fn add_local_crate_metadata_objects(\n+    cmd: &mut dyn Linker,\n+    crate_type: config::CrateType,\n+    codegen_results: &CodegenResults,\n+) {\n+    // When linking a dynamic library, we put the metadata into a section of the\n+    // executable. This metadata is in a separate object file from the main\n+    // object file, so we link that in here.\n+    if crate_type == config::CrateType::Dylib || crate_type == config::CrateType::ProcMacro {\n+        let obj = codegen_results.metadata_module.as_ref().and_then(|m| m.object.as_ref());\n+        if let Some(obj) = obj {\n+            cmd.add_object(obj);\n+        }\n+    }\n+}\n+\n+/// Link native libraries corresponding to the current crate and all libraries corresponding to\n+/// all its dependency crates.\n+/// FIXME: Consider combining this with the functions above adding object files for the local crate.\n+fn link_local_crate_native_libs_and_dependent_crate_libs<'a, B: ArchiveBuilder<'a>>(\n+    cmd: &mut dyn Linker,\n+    sess: &'a Session,\n+    crate_type: config::CrateType,\n+    codegen_results: &CodegenResults,\n+    tmpdir: &Path,\n+) {\n+    // Take careful note of the ordering of the arguments we pass to the linker\n+    // here. Linkers will assume that things on the left depend on things to the\n+    // right. Things on the right cannot depend on things on the left. This is\n+    // all formally implemented in terms of resolving symbols (libs on the right\n+    // resolve unknown symbols of libs on the left, but not vice versa).\n+    //\n+    // For this reason, we have organized the arguments we pass to the linker as\n+    // such:\n+    //\n+    // 1. The local object that LLVM just generated\n+    // 2. Local native libraries\n+    // 3. Upstream rust libraries\n+    // 4. Upstream native libraries\n+    //\n+    // The rationale behind this ordering is that those items lower down in the\n+    // list can't depend on items higher up in the list. For example nothing can\n+    // depend on what we just generated (e.g., that'd be a circular dependency).\n+    // Upstream rust libraries are not allowed to depend on our local native\n+    // libraries as that would violate the structure of the DAG, in that\n+    // scenario they are required to link to them as well in a shared fashion.\n+    //\n+    // Note that upstream rust libraries may contain native dependencies as\n+    // well, but they also can't depend on what we just started to add to the\n+    // link line. And finally upstream native libraries can't depend on anything\n+    // in this DAG so far because they're only dylibs and dylibs can only depend\n+    // on other dylibs (e.g., other native deps).\n+    //\n+    // If -Zlink-native-libraries=false is set, then the assumption is that an\n+    // external build system already has the native dependencies defined, and it\n+    // will provide them to the linker itself.\n+    if sess.opts.debugging_opts.link_native_libraries.unwrap_or(true) {\n+        add_local_native_libraries(cmd, sess, codegen_results);\n+    }\n+    add_upstream_rust_crates::<B>(cmd, sess, codegen_results, crate_type, tmpdir);\n+    if sess.opts.debugging_opts.link_native_libraries.unwrap_or(true) {\n+        add_upstream_native_libraries(cmd, sess, codegen_results, crate_type);\n+    }\n+}\n+\n /// Add sysroot and other globally set directories to the directory search list.\n fn add_library_search_dirs(cmd: &mut dyn Linker, sess: &'a Session) {\n     // The default library location, we need this to find the runtime.\n@@ -1271,6 +1352,95 @@ fn add_library_search_dirs(cmd: &mut dyn Linker, sess: &'a Session) {\n     cmd.include_path(&fix_windows_verbatim_for_gcc(&lib_path));\n }\n \n+/// Add options requesting executables to be position-independent or not position-independent.\n+fn add_position_independent_executable_args(\n+    cmd: &mut dyn Linker,\n+    sess: &'a Session,\n+    flavor: LinkerFlavor,\n+    crate_type: config::CrateType,\n+    codegen_results: &CodegenResults,\n+) {\n+    if crate_type != config::CrateType::Executable {\n+        return;\n+    }\n+\n+    let mut position_independent_executable = false;\n+    if sess.target.target.options.position_independent_executables {\n+        let attr_link_args = &*codegen_results.crate_info.link_args;\n+        let mut user_defined_link_args = sess.opts.cg.link_args.iter().chain(attr_link_args);\n+        if is_pic(sess)\n+            && !sess.crt_static(Some(crate_type))\n+            && !user_defined_link_args.any(|x| x == \"-static\")\n+        {\n+            position_independent_executable = true;\n+        }\n+    }\n+\n+    if position_independent_executable {\n+        cmd.position_independent_executable();\n+    } else {\n+        // recent versions of gcc can be configured to generate position\n+        // independent executables by default. We have to pass -no-pie to\n+        // explicitly turn that off. Not applicable to ld.\n+        if sess.target.target.options.linker_is_gnu && flavor != LinkerFlavor::Ld {\n+            cmd.no_position_independent_executable();\n+        }\n+    }\n+}\n+\n+/// Add options making relocation sections in the produced ELF files read-only\n+/// and suppressing lazy binding.\n+fn add_relro_args(cmd: &mut dyn Linker, sess: &'a Session) {\n+    let relro_level = match sess.opts.debugging_opts.relro_level {\n+        Some(level) => level,\n+        None => sess.target.target.options.relro_level,\n+    };\n+    match relro_level {\n+        RelroLevel::Full => {\n+            cmd.full_relro();\n+        }\n+        RelroLevel::Partial => {\n+            cmd.partial_relro();\n+        }\n+        RelroLevel::Off => {\n+            cmd.no_relro();\n+        }\n+        RelroLevel::None => {}\n+    }\n+}\n+\n+/// Add library search paths used at runtime by dynamic linkers.\n+fn add_rpath_args(\n+    cmd: &mut dyn Linker,\n+    sess: &'a Session,\n+    codegen_results: &CodegenResults,\n+    out_filename: &Path,\n+) {\n+    // FIXME (#2397): At some point we want to rpath our guesses as to\n+    // where extern libraries might live, based on the\n+    // addl_lib_search_paths\n+    if sess.opts.cg.rpath {\n+        let target_triple = sess.opts.target_triple.triple();\n+        let mut get_install_prefix_lib_path = || {\n+            let install_prefix = option_env!(\"CFG_PREFIX\").expect(\"CFG_PREFIX\");\n+            let tlib = filesearch::relative_target_lib_path(&sess.sysroot, target_triple);\n+            let mut path = PathBuf::from(install_prefix);\n+            path.push(&tlib);\n+\n+            path\n+        };\n+        let mut rpath_config = RPathConfig {\n+            used_crates: &codegen_results.crate_info.used_crates_dynamic,\n+            out_filename: out_filename.to_path_buf(),\n+            has_rpath: sess.target.target.options.has_rpath,\n+            is_like_osx: sess.target.target.options.is_like_osx,\n+            linker_is_gnu: sess.target.target.options.linker_is_gnu,\n+            get_install_prefix_lib_path: &mut get_install_prefix_lib_path,\n+        };\n+        cmd.args(&rpath::get_rpath_flags(&mut rpath_config));\n+    }\n+}\n+\n /// Produce the linker command line containing linker path and arguments.\n /// `NO-OPT-OUT` marks the arguments that cannot be removed from the command line\n /// by the user without creating a custom target specification.\n@@ -1332,9 +1502,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     add_library_search_dirs(cmd, sess);\n \n     // OBJECT-FILES-YES\n-    for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n-        cmd.add_object(obj);\n-    }\n+    add_local_crate_regular_objects(cmd, codegen_results);\n \n     // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n     cmd.output_filename(out_filename);\n@@ -1353,21 +1521,10 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     cmd.export_symbols(tmpdir, crate_type);\n \n     // OBJECT-FILES-YES\n-    // When linking a dynamic library, we put the metadata into a section of the\n-    // executable. This metadata is in a separate object file from the main\n-    // object file, so we link that in here.\n-    if crate_type == config::CrateType::Dylib || crate_type == config::CrateType::ProcMacro {\n-        let obj = codegen_results.metadata_module.as_ref().and_then(|m| m.object.as_ref());\n-        if let Some(obj) = obj {\n-            cmd.add_object(obj);\n-        }\n-    }\n+    add_local_crate_metadata_objects(cmd, crate_type, codegen_results);\n \n     // OBJECT-FILES-YES\n-    let obj = codegen_results.allocator_module.as_ref().and_then(|m| m.object.as_ref());\n-    if let Some(obj) = obj {\n-        cmd.add_object(obj);\n-    }\n+    add_local_crate_allocator_objects(cmd, codegen_results);\n \n     // OBJECT-FILES-NO, AUDIT-ORDER\n     // FIXME: Order dependent, applies to the following objects. Where should it be placed?\n@@ -1379,53 +1536,10 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     }\n \n     // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n-    if crate_type == config::CrateType::Executable {\n-        let mut position_independent_executable = false;\n-\n-        if sess.target.target.options.position_independent_executables {\n-            if is_pic(sess)\n-                && !sess.crt_static(Some(crate_type))\n-                && !sess\n-                    .opts\n-                    .cg\n-                    .link_args\n-                    .iter()\n-                    .chain(&*codegen_results.crate_info.link_args)\n-                    .any(|x| x == \"-static\")\n-            {\n-                position_independent_executable = true;\n-            }\n-        }\n-\n-        if position_independent_executable {\n-            cmd.position_independent_executable();\n-        } else {\n-            // recent versions of gcc can be configured to generate position\n-            // independent executables by default. We have to pass -no-pie to\n-            // explicitly turn that off. Not applicable to ld.\n-            if sess.target.target.options.linker_is_gnu && flavor != LinkerFlavor::Ld {\n-                cmd.no_position_independent_executable();\n-            }\n-        }\n-    }\n+    add_position_independent_executable_args(cmd, sess, flavor, crate_type, codegen_results);\n \n     // OBJECT-FILES-NO, AUDIT-ORDER\n-    let relro_level = match sess.opts.debugging_opts.relro_level {\n-        Some(level) => level,\n-        None => sess.target.target.options.relro_level,\n-    };\n-    match relro_level {\n-        RelroLevel::Full => {\n-            cmd.full_relro();\n-        }\n-        RelroLevel::Partial => {\n-            cmd.partial_relro();\n-        }\n-        RelroLevel::Off => {\n-            cmd.no_relro();\n-        }\n-        RelroLevel::None => {}\n-    }\n+    add_relro_args(cmd, sess);\n \n     // OBJECT-FILES-NO, AUDIT-ORDER\n     // Pass optimization flags down to the linker.\n@@ -1450,43 +1564,13 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     }\n \n     // OBJECT-FILES-YES\n-    // Take careful note of the ordering of the arguments we pass to the linker\n-    // here. Linkers will assume that things on the left depend on things to the\n-    // right. Things on the right cannot depend on things on the left. This is\n-    // all formally implemented in terms of resolving symbols (libs on the right\n-    // resolve unknown symbols of libs on the left, but not vice versa).\n-    //\n-    // For this reason, we have organized the arguments we pass to the linker as\n-    // such:\n-    //\n-    // 1. The local object that LLVM just generated\n-    // 2. Local native libraries\n-    // 3. Upstream rust libraries\n-    // 4. Upstream native libraries\n-    //\n-    // The rationale behind this ordering is that those items lower down in the\n-    // list can't depend on items higher up in the list. For example nothing can\n-    // depend on what we just generated (e.g., that'd be a circular dependency).\n-    // Upstream rust libraries are not allowed to depend on our local native\n-    // libraries as that would violate the structure of the DAG, in that\n-    // scenario they are required to link to them as well in a shared fashion.\n-    //\n-    // Note that upstream rust libraries may contain native dependencies as\n-    // well, but they also can't depend on what we just started to add to the\n-    // link line. And finally upstream native libraries can't depend on anything\n-    // in this DAG so far because they're only dylibs and dylibs can only depend\n-    // on other dylibs (e.g., other native deps).\n-    //\n-    // If -Zlink-native-libraries=false is set, then the assumption is that an\n-    // external build system already has the native dependencies defined, and it\n-    // will provide them to the linker itself.\n-    if sess.opts.debugging_opts.link_native_libraries.unwrap_or(true) {\n-        add_local_native_libraries(cmd, sess, codegen_results);\n-    }\n-    add_upstream_rust_crates::<B>(cmd, sess, codegen_results, crate_type, tmpdir);\n-    if sess.opts.debugging_opts.link_native_libraries.unwrap_or(true) {\n-        add_upstream_native_libraries(cmd, sess, codegen_results, crate_type);\n-    }\n+    link_local_crate_native_libs_and_dependent_crate_libs::<B>(\n+        cmd,\n+        sess,\n+        crate_type,\n+        codegen_results,\n+        tmpdir,\n+    );\n \n     // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n     // Tell the linker what we're doing.\n@@ -1508,29 +1592,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     }\n \n     // OBJECT-FILES-NO, AUDIT-ORDER\n-    // FIXME (#2397): At some point we want to rpath our guesses as to\n-    // where extern libraries might live, based on the\n-    // addl_lib_search_paths\n-    if sess.opts.cg.rpath {\n-        let target_triple = sess.opts.target_triple.triple();\n-        let mut get_install_prefix_lib_path = || {\n-            let install_prefix = option_env!(\"CFG_PREFIX\").expect(\"CFG_PREFIX\");\n-            let tlib = filesearch::relative_target_lib_path(&sess.sysroot, target_triple);\n-            let mut path = PathBuf::from(install_prefix);\n-            path.push(&tlib);\n-\n-            path\n-        };\n-        let mut rpath_config = RPathConfig {\n-            used_crates: &codegen_results.crate_info.used_crates_dynamic,\n-            out_filename: out_filename.to_path_buf(),\n-            has_rpath: sess.target.target.options.has_rpath,\n-            is_like_osx: sess.target.target.options.is_like_osx,\n-            linker_is_gnu: sess.target.target.options.linker_is_gnu,\n-            get_install_prefix_lib_path: &mut get_install_prefix_lib_path,\n-        };\n-        cmd.args(&rpath::get_rpath_flags(&mut rpath_config));\n-    }\n+    add_rpath_args(cmd, sess, codegen_results, out_filename);\n \n     // OBJECT-FILES-MAYBE, CUSTOMIZATION-POINT\n     add_user_defined_link_args(cmd, sess, codegen_results);"}]}