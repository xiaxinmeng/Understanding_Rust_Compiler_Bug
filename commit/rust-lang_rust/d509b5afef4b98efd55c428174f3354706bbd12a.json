{"sha": "d509b5afef4b98efd55c428174f3354706bbd12a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1MDliNWFmZWY0Yjk4ZWZkNTVjNDI4MTc0ZjMzNTQ3MDZiYmQxMmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-18T18:20:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-18T18:20:40Z"}, "message": "Auto merge of #4274 - daxpedda:implicit_return_fixes, r=flip1995\n\nfalse positives fixes of `implicit_return`\n\n-  Handle returning macro statements properly (remove \"this error originates in a macro outside of the current crate\")\n-  Handle functions that return never type\n-  Handle functions that panic but do not return never type\n\nchangelog: Fix false positives in `implicit_return` lint pertaining to macros and panics", "tree": {"sha": "4275a955cd53d21b613d76dc553d8b514e2589cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4275a955cd53d21b613d76dc553d8b514e2589cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d509b5afef4b98efd55c428174f3354706bbd12a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d509b5afef4b98efd55c428174f3354706bbd12a", "html_url": "https://github.com/rust-lang/rust/commit/d509b5afef4b98efd55c428174f3354706bbd12a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d509b5afef4b98efd55c428174f3354706bbd12a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9ff319f3ec9b3e21fb7398dcf55dfe8c6cb2cff", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9ff319f3ec9b3e21fb7398dcf55dfe8c6cb2cff", "html_url": "https://github.com/rust-lang/rust/commit/e9ff319f3ec9b3e21fb7398dcf55dfe8c6cb2cff"}, {"sha": "9e5e0f8f8425e6421699409a099ac4303162db25", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e5e0f8f8425e6421699409a099ac4303162db25", "html_url": "https://github.com/rust-lang/rust/commit/9e5e0f8f8425e6421699409a099ac4303162db25"}], "stats": {"total": 192, "additions": 118, "deletions": 74}, "files": [{"sha": "4df9789f39dfb1563f99996dfc19f1c49f175ef2", "filename": "clippy_lints/src/implicit_return.rs", "status": "modified", "additions": 91, "deletions": 63, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/d509b5afef4b98efd55c428174f3354706bbd12a/clippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d509b5afef4b98efd55c428174f3354706bbd12a/clippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_return.rs?ref=d509b5afef4b98efd55c428174f3354706bbd12a", "patch": "@@ -1,7 +1,14 @@\n-use crate::utils::{in_macro_or_desugar, is_expn_of, snippet_opt, span_lint_and_then};\n-use rustc::hir::{intravisit::FnKind, Body, ExprKind, FnDecl, HirId, MatchSource};\n-use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use rustc::{declare_lint_pass, declare_tool_lint};\n+use crate::utils::{\n+    in_macro_or_desugar, match_def_path,\n+    paths::{BEGIN_PANIC, BEGIN_PANIC_FMT},\n+    resolve_node, snippet_opt, span_lint_and_then,\n+};\n+use if_chain::if_chain;\n+use rustc::{\n+    declare_lint_pass, declare_tool_lint,\n+    hir::{intravisit::FnKind, Body, Expr, ExprKind, FnDecl, HirId, MatchSource, StmtKind},\n+    lint::{LateContext, LateLintPass, LintArray, LintPass},\n+};\n use rustc_errors::Applicability;\n use syntax::source_map::Span;\n \n@@ -35,71 +42,92 @@ declare_clippy_lint! {\n \n declare_lint_pass!(ImplicitReturn => [IMPLICIT_RETURN]);\n \n-impl ImplicitReturn {\n-    fn lint(cx: &LateContext<'_, '_>, outer_span: syntax_pos::Span, inner_span: syntax_pos::Span, msg: &str) {\n-        span_lint_and_then(cx, IMPLICIT_RETURN, outer_span, \"missing return statement\", |db| {\n-            if let Some(snippet) = snippet_opt(cx, inner_span) {\n-                db.span_suggestion(\n-                    outer_span,\n-                    msg,\n-                    format!(\"return {}\", snippet),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        });\n+static LINT_BREAK: &str = \"change `break` to `return` as shown\";\n+static LINT_RETURN: &str = \"add `return` as shown\";\n+\n+fn lint(cx: &LateContext<'_, '_>, outer_span: Span, inner_span: Span, msg: &str) {\n+    let outer_span = span_to_outer_expn(outer_span);\n+    let inner_span = span_to_outer_expn(inner_span);\n+\n+    span_lint_and_then(cx, IMPLICIT_RETURN, outer_span, \"missing return statement\", |db| {\n+        if let Some(snippet) = snippet_opt(cx, inner_span) {\n+            db.span_suggestion(\n+                outer_span,\n+                msg,\n+                format!(\"return {}\", snippet),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    });\n+}\n+\n+fn span_to_outer_expn(span: Span) -> Span {\n+    if let Some(expr) = span.ctxt().outer_expn_info() {\n+        span_to_outer_expn(expr.call_site)\n+    } else {\n+        span\n     }\n+}\n \n-    fn expr_match(cx: &LateContext<'_, '_>, expr: &rustc::hir::Expr) {\n-        match &expr.node {\n-            // loops could be using `break` instead of `return`\n-            ExprKind::Block(block, ..) | ExprKind::Loop(block, ..) => {\n-                if let Some(expr) = &block.expr {\n-                    Self::expr_match(cx, expr);\n-                }\n-                // only needed in the case of `break` with `;` at the end\n-                else if let Some(stmt) = block.stmts.last() {\n-                    if let rustc::hir::StmtKind::Semi(expr, ..) = &stmt.node {\n-                        // make sure it's a break, otherwise we want to skip\n-                        if let ExprKind::Break(.., break_expr) = &expr.node {\n-                            if let Some(break_expr) = break_expr {\n-                                Self::lint(cx, expr.span, break_expr.span, \"change `break` to `return` as shown\");\n-                            }\n-                        }\n+fn expr_match(cx: &LateContext<'_, '_>, expr: &Expr) {\n+    match &expr.node {\n+        // loops could be using `break` instead of `return`\n+        ExprKind::Block(block, ..) | ExprKind::Loop(block, ..) => {\n+            if let Some(expr) = &block.expr {\n+                expr_match(cx, expr);\n+            }\n+            // only needed in the case of `break` with `;` at the end\n+            else if let Some(stmt) = block.stmts.last() {\n+                if_chain! {\n+                    if let StmtKind::Semi(expr, ..) = &stmt.node;\n+                    // make sure it's a break, otherwise we want to skip\n+                    if let ExprKind::Break(.., break_expr) = &expr.node;\n+                    if let Some(break_expr) = break_expr;\n+                    then {\n+                            lint(cx, expr.span, break_expr.span, LINT_BREAK);\n                     }\n                 }\n-            },\n-            // use `return` instead of `break`\n-            ExprKind::Break(.., break_expr) => {\n-                if let Some(break_expr) = break_expr {\n-                    Self::lint(cx, expr.span, break_expr.span, \"change `break` to `return` as shown\");\n-                }\n-            },\n-            ExprKind::Match(.., arms, source) => {\n-                let check_all_arms = match source {\n-                    MatchSource::IfLetDesugar {\n-                        contains_else_clause: has_else,\n-                    } => *has_else,\n-                    _ => true,\n-                };\n+            }\n+        },\n+        // use `return` instead of `break`\n+        ExprKind::Break(.., break_expr) => {\n+            if let Some(break_expr) = break_expr {\n+                lint(cx, expr.span, break_expr.span, LINT_BREAK);\n+            }\n+        },\n+        ExprKind::Match(.., arms, source) => {\n+            let check_all_arms = match source {\n+                MatchSource::IfLetDesugar {\n+                    contains_else_clause: has_else,\n+                } => *has_else,\n+                _ => true,\n+            };\n \n-                if check_all_arms {\n-                    for arm in arms {\n-                        Self::expr_match(cx, &arm.body);\n-                    }\n-                } else {\n-                    Self::expr_match(cx, &arms.first().expect(\"if let doesn't have a single arm\").body);\n+            if check_all_arms {\n+                for arm in arms {\n+                    expr_match(cx, &arm.body);\n                 }\n-            },\n-            // skip if it already has a return statement\n-            ExprKind::Ret(..) => (),\n-            // everything else is missing `return`\n-            _ => {\n-                // make sure it's not just an unreachable expression\n-                if is_expn_of(expr.span, \"unreachable\").is_none() {\n-                    Self::lint(cx, expr.span, expr.span, \"add `return` as shown\")\n+            } else {\n+                expr_match(cx, &arms.first().expect(\"if let doesn't have a single arm\").body);\n+            }\n+        },\n+        // skip if it already has a return statement\n+        ExprKind::Ret(..) => (),\n+        // make sure it's not a call that panics\n+        ExprKind::Call(expr, ..) => {\n+            if_chain! {\n+                if let ExprKind::Path(qpath) = &expr.node;\n+                if let Some(path_def_id) = resolve_node(cx, qpath, expr.hir_id).opt_def_id();\n+                if match_def_path(cx, path_def_id, &BEGIN_PANIC) ||\n+                    match_def_path(cx, path_def_id, &BEGIN_PANIC_FMT);\n+                then { }\n+                else {\n+                    lint(cx, expr.span, expr.span, LINT_RETURN)\n                 }\n-            },\n-        }\n+            }\n+        },\n+        // everything else is missing `return`\n+        _ => lint(cx, expr.span, expr.span, LINT_RETURN),\n     }\n }\n \n@@ -119,7 +147,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplicitReturn {\n         // checking return type through MIR, HIR is not able to determine inferred closure return types\n         // make sure it's not a macro\n         if !mir.return_ty().is_unit() && !in_macro_or_desugar(span) {\n-            Self::expr_match(cx, &body.value);\n+            expr_match(cx, &body.value);\n         }\n     }\n }"}, {"sha": "47e0679c430d78dd49f4d851f5c3ad1cfae1cbd1", "filename": "tests/ui/implicit_return.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d509b5afef4b98efd55c428174f3354706bbd12a/tests%2Fui%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d509b5afef4b98efd55c428174f3354706bbd12a/tests%2Fui%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_return.rs?ref=d509b5afef4b98efd55c428174f3354706bbd12a", "patch": "@@ -5,6 +5,7 @@ fn test_end_of_fn() -> bool {\n         // no error!\n         return true;\n     }\n+\n     true\n }\n \n@@ -76,6 +77,14 @@ fn test_closure() {\n     let _ = || true;\n }\n \n+fn test_panic() -> bool {\n+    panic!()\n+}\n+\n+fn test_return_macro() -> String {\n+    format!(\"test {}\", \"test\")\n+}\n+\n fn main() {\n     let _ = test_end_of_fn();\n     let _ = test_if_block();\n@@ -86,4 +95,5 @@ fn main() {\n     let _ = test_loop_with_nests();\n     let _ = test_loop_with_if_let();\n     test_closure();\n+    let _ = test_return_macro();\n }"}, {"sha": "41b0873317e8af730370982c157e6abdb1a5e3d9", "filename": "tests/ui/implicit_return.stderr", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d509b5afef4b98efd55c428174f3354706bbd12a/tests%2Fui%2Fimplicit_return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d509b5afef4b98efd55c428174f3354706bbd12a/tests%2Fui%2Fimplicit_return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_return.stderr?ref=d509b5afef4b98efd55c428174f3354706bbd12a", "patch": "@@ -1,64 +1,70 @@\n error: missing return statement\n-  --> $DIR/implicit_return.rs:8:5\n+  --> $DIR/implicit_return.rs:9:5\n    |\n LL |     true\n    |     ^^^^ help: add `return` as shown: `return true`\n    |\n    = note: `-D clippy::implicit-return` implied by `-D warnings`\n \n error: missing return statement\n-  --> $DIR/implicit_return.rs:14:9\n+  --> $DIR/implicit_return.rs:15:9\n    |\n LL |         true\n    |         ^^^^ help: add `return` as shown: `return true`\n \n error: missing return statement\n-  --> $DIR/implicit_return.rs:16:9\n+  --> $DIR/implicit_return.rs:17:9\n    |\n LL |         false\n    |         ^^^^^ help: add `return` as shown: `return false`\n \n error: missing return statement\n-  --> $DIR/implicit_return.rs:24:17\n+  --> $DIR/implicit_return.rs:25:17\n    |\n LL |         true => false,\n    |                 ^^^^^ help: add `return` as shown: `return false`\n \n error: missing return statement\n-  --> $DIR/implicit_return.rs:25:20\n+  --> $DIR/implicit_return.rs:26:20\n    |\n LL |         false => { true },\n    |                    ^^^^ help: add `return` as shown: `return true`\n \n error: missing return statement\n-  --> $DIR/implicit_return.rs:40:9\n+  --> $DIR/implicit_return.rs:41:9\n    |\n LL |         break true;\n    |         ^^^^^^^^^^ help: change `break` to `return` as shown: `return true`\n \n error: missing return statement\n-  --> $DIR/implicit_return.rs:48:13\n+  --> $DIR/implicit_return.rs:49:13\n    |\n LL |             break true;\n    |             ^^^^^^^^^^ help: change `break` to `return` as shown: `return true`\n \n error: missing return statement\n-  --> $DIR/implicit_return.rs:57:13\n+  --> $DIR/implicit_return.rs:58:13\n    |\n LL |             break true;\n    |             ^^^^^^^^^^ help: change `break` to `return` as shown: `return true`\n \n error: missing return statement\n-  --> $DIR/implicit_return.rs:75:18\n+  --> $DIR/implicit_return.rs:76:18\n    |\n LL |     let _ = || { true };\n    |                  ^^^^ help: add `return` as shown: `return true`\n \n error: missing return statement\n-  --> $DIR/implicit_return.rs:76:16\n+  --> $DIR/implicit_return.rs:77:16\n    |\n LL |     let _ = || true;\n    |                ^^^^ help: add `return` as shown: `return true`\n \n-error: aborting due to 10 previous errors\n+error: missing return statement\n+  --> $DIR/implicit_return.rs:85:5\n+   |\n+LL |     format!(\"test {}\", \"test\")\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: add `return` as shown: `return format!(\"test {}\", \"test\")`\n+\n+error: aborting due to 11 previous errors\n "}]}