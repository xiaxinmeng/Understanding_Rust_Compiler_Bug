{"sha": "5a2ca1a6f18aa93d3120761f614ec2d39b4cb1ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhMmNhMWE2ZjE4YWE5M2QzMTIwNzYxZjYxNGVjMmQzOWI0Y2IxYWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-11T17:05:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-11T17:05:36Z"}, "message": "Auto merge of #55657 - davidtwco:issue-55651, r=pnkfelix\n\nNLL Diagnostic Review 3: Unions not reinitialized after assignment into field\n\nFixes #55651, #55652.\n\nThis PR makes two changes:\n\nFirst, it updates the dataflow builder to add an init for the place\ncontaining a union if there is an assignment into the field of\nthat union.\n\nSecond, it stops a \"use of uninitialized\" error occuring when there is an\nassignment into the field of an uninitialized union that was previously\ninitialized. Making this assignment would re-initialize the union, as\ntested in `src/test/ui/borrowck/borrowck-union-move-assign.nll.stderr`.\nThe check for previous initialization ensures that we do not start\nsupporting partial initialization yet (cc #21232, #54499, #54986).\n\nThis PR also fixes #55652 which was marked as requiring investigation\nas the changes in this PR add an error that was previously missing\n(and mentioned in the review comments) and confirms that the error\nthat was present is correct and a result of earlier partial\ninitialization changes in NLL.\n\nr? @pnkfelix (due to earlier work with partial initialization)\ncc @nikomatsakis", "tree": {"sha": "5df8fbca3ae4018fd3303cf22ba4b0fec0299d68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5df8fbca3ae4018fd3303cf22ba4b0fec0299d68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a2ca1a6f18aa93d3120761f614ec2d39b4cb1ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a2ca1a6f18aa93d3120761f614ec2d39b4cb1ac", "html_url": "https://github.com/rust-lang/rust/commit/5a2ca1a6f18aa93d3120761f614ec2d39b4cb1ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a2ca1a6f18aa93d3120761f614ec2d39b4cb1ac/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a88613c86901083dd9f87c43f41d6c0f84f88dee", "url": "https://api.github.com/repos/rust-lang/rust/commits/a88613c86901083dd9f87c43f41d6c0f84f88dee", "html_url": "https://github.com/rust-lang/rust/commit/a88613c86901083dd9f87c43f41d6c0f84f88dee"}, {"sha": "1672c27a7dbeda2ea3b1aa775b259fc90a270870", "url": "https://api.github.com/repos/rust-lang/rust/commits/1672c27a7dbeda2ea3b1aa775b259fc90a270870", "html_url": "https://github.com/rust-lang/rust/commit/1672c27a7dbeda2ea3b1aa775b259fc90a270870"}], "stats": {"total": 152, "additions": 121, "deletions": 31}, "files": [{"sha": "8a32e8f46c290778d4149a575582f830ee78d808", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5a2ca1a6f18aa93d3120761f614ec2d39b4cb1ac/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a2ca1a6f18aa93d3120761f614ec2d39b4cb1ac/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=5a2ca1a6f18aa93d3120761f614ec2d39b4cb1ac", "patch": "@@ -20,6 +20,7 @@ use mir::interpret::{ConstValue, EvalErrorKind, Scalar};\n use mir::visit::MirVisitable;\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::dominators::{dominators, Dominators};\n use rustc_data_structures::graph::{self, GraphPredecessors, GraphSuccessors};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n@@ -2720,6 +2721,36 @@ impl Location {\n         }\n     }\n \n+    /// Returns `true` if `other` is earlier in the control flow graph than `self`.\n+    pub fn is_predecessor_of<'tcx>(&self, other: Location, mir: &Mir<'tcx>) -> bool {\n+        // If we are in the same block as the other location and are an earlier statement\n+        // then we are a predecessor of `other`.\n+        if self.block == other.block && self.statement_index < other.statement_index {\n+            return true;\n+        }\n+\n+        // If we're in another block, then we want to check that block is a predecessor of `other`.\n+        let mut queue: Vec<BasicBlock> = mir.predecessors_for(other.block).clone();\n+        let mut visited = FxHashSet::default();\n+\n+        while let Some(block) = queue.pop() {\n+            // If we haven't visited this block before, then make sure we visit it's predecessors.\n+            if visited.insert(block) {\n+                queue.append(&mut mir.predecessors_for(block).clone());\n+            } else {\n+                continue;\n+            }\n+\n+            // If we found the block that `self` is in, then we are a predecessor of `other` (since\n+            // we found that block by looking at the predecessors of `other`).\n+            if self.block == block {\n+                return true;\n+            }\n+        }\n+\n+        false\n+    }\n+\n     pub fn dominates(&self, other: Location, dominators: &Dominators<BasicBlock>) -> bool {\n         if self.block == other.block {\n             self.statement_index <= other.statement_index"}, {"sha": "eeb111dcd9b83aeeab441bb7c0f921ce66aca47d", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5a2ca1a6f18aa93d3120761f614ec2d39b4cb1ac/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a2ca1a6f18aa93d3120761f614ec2d39b4cb1ac/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=5a2ca1a6f18aa93d3120761f614ec2d39b4cb1ac", "patch": "@@ -1717,12 +1717,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n         }\n \n-        fn check_parent_of_field<'cx, 'gcx, 'tcx>(this: &mut MirBorrowckCtxt<'cx, 'gcx, 'tcx>,\n-                                                  context: Context,\n-                                                  base: &Place<'tcx>,\n-                                                  span: Span,\n-                                                  flow_state: &Flows<'cx, 'gcx, 'tcx>)\n-        {\n+        fn check_parent_of_field<'cx, 'gcx, 'tcx>(\n+            this: &mut MirBorrowckCtxt<'cx, 'gcx, 'tcx>,\n+            context: Context,\n+            base: &Place<'tcx>,\n+            span: Span,\n+            flow_state: &Flows<'cx, 'gcx, 'tcx>,\n+        ) {\n             // rust-lang/rust#21232: Until Rust allows reads from the\n             // initialized parts of partially initialized structs, we\n             // will, starting with the 2018 edition, reject attempts\n@@ -1774,6 +1775,24 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n \n             if let Some((prefix, mpi)) = shortest_uninit_seen {\n+                // Check for a reassignment into a uninitialized field of a union (for example,\n+                // after a move out). In this case, do not report a error here. There is an\n+                // exception, if this is the first assignment into the union (that is, there is\n+                // no move out from an earlier location) then this is an attempt at initialization\n+                // of the union - we should error in that case.\n+                let tcx = this.infcx.tcx;\n+                if let ty::TyKind::Adt(def, _) = base.ty(this.mir, tcx).to_ty(tcx).sty {\n+                    if def.is_union() {\n+                        if this.move_data.path_map[mpi].iter().any(|moi| {\n+                            this.move_data.moves[*moi].source.is_predecessor_of(\n+                                context.loc, this.mir,\n+                            )\n+                        }) {\n+                            return;\n+                        }\n+                    }\n+                }\n+\n                 this.report_use_of_moved_or_uninitialized(\n                     context,\n                     InitializationRequiringAction::PartialAssignment,"}, {"sha": "2399f0bc1a0751d5c31294d18c7bfe27e2a231aa", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5a2ca1a6f18aa93d3120761f614ec2d39b4cb1ac/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a2ca1a6f18aa93d3120761f614ec2d39b4cb1ac/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=5a2ca1a6f18aa93d3120761f614ec2d39b4cb1ac", "patch": "@@ -430,6 +430,20 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n     fn gather_init(&mut self, place: &Place<'tcx>, kind: InitKind) {\n         debug!(\"gather_init({:?}, {:?})\", self.loc, place);\n \n+        let place = match place {\n+            // Check if we are assigning into a field of a union, if so, lookup the place\n+            // of the union so it is marked as initialized again.\n+            Place::Projection(box Projection {\n+                base,\n+                elem: ProjectionElem::Field(_, _),\n+            }) if match base.ty(self.builder.mir, self.builder.tcx).to_ty(self.builder.tcx).sty {\n+                    ty::TyKind::Adt(def, _) if def.is_union() => true,\n+                    _ => false,\n+            } => base,\n+            // Otherwise, lookup the place.\n+            _ => place,\n+        };\n+\n         if let LookupResult::Exact(path) = self.builder.data.rev_lookup.find(place) {\n             let init = self.builder.data.inits.push(Init {\n                 location: InitLocation::Statement(self.loc),"}, {"sha": "a7125450e1c278ce9cc0166d995b2b6f3049ec83", "filename": "src/test/ui/borrowck/borrowck-union-move-assign.nll.stderr", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5a2ca1a6f18aa93d3120761f614ec2d39b4cb1ac/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-move-assign.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5a2ca1a6f18aa93d3120761f614ec2d39b4cb1ac/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-move-assign.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-move-assign.nll.stderr?ref=5a2ca1a6f18aa93d3120761f614ec2d39b4cb1ac", "patch": "@@ -8,28 +8,6 @@ LL |             let a = u.a; //~ ERROR use of moved value: `u.a`\n    |\n    = note: move occurs because `u` has type `U`, which does not implement the `Copy` trait\n \n-error[E0382]: use of moved value: `u`\n-  --> $DIR/borrowck-union-move-assign.rs:33:21\n-   |\n-LL |             let a = u.a;\n-   |                     --- value moved here\n-LL |             u.a = A;\n-LL |             let a = u.a; // OK\n-   |                     ^^^ value used here after move\n-   |\n-   = note: move occurs because `u` has type `U`, which does not implement the `Copy` trait\n-\n-error[E0382]: use of moved value: `u`\n-  --> $DIR/borrowck-union-move-assign.rs:39:21\n-   |\n-LL |             let a = u.a;\n-   |                     --- value moved here\n-LL |             u.b = B;\n-LL |             let a = u.a; // OK\n-   |                     ^^^ value used here after move\n-   |\n-   = note: move occurs because `u` has type `U`, which does not implement the `Copy` trait\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0382`."}, {"sha": "fb1fe27774064cb97ecd35dc1c47cea959a08259", "filename": "src/test/ui/borrowck/reassignment_immutable_fields_overlapping.nll.stderr", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5a2ca1a6f18aa93d3120761f614ec2d39b4cb1ac/src%2Ftest%2Fui%2Fborrowck%2Freassignment_immutable_fields_overlapping.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5a2ca1a6f18aa93d3120761f614ec2d39b4cb1ac/src%2Ftest%2Fui%2Fborrowck%2Freassignment_immutable_fields_overlapping.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Freassignment_immutable_fields_overlapping.nll.stderr?ref=5a2ca1a6f18aa93d3120761f614ec2d39b4cb1ac", "patch": "@@ -4,6 +4,16 @@ error[E0381]: assign to part of possibly uninitialized variable: `x`\n LL |     x.a = 1;  //~ ERROR\n    |     ^^^^^^^ use of possibly uninitialized `x`\n \n-error: aborting due to previous error\n+error[E0594]: cannot assign to `x.b`, as `x` is not declared as mutable\n+  --> $DIR/reassignment_immutable_fields_overlapping.rs:23:5\n+   |\n+LL |     let x: Foo;\n+   |         - help: consider changing this to be mutable: `mut x`\n+LL |     x.a = 1;  //~ ERROR\n+LL |     x.b = 22; //~ ERROR\n+   |     ^^^^^^^^ cannot assign\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0381`.\n+Some errors occurred: E0381, E0594.\n+For more information about an error, try `rustc --explain E0381`."}, {"sha": "b9777831bf620566fb1cbf9dcc40a9ca39a1b115", "filename": "src/test/ui/nll/issue-55651.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5a2ca1a6f18aa93d3120761f614ec2d39b4cb1ac/src%2Ftest%2Fui%2Fnll%2Fissue-55651.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a2ca1a6f18aa93d3120761f614ec2d39b4cb1ac/src%2Ftest%2Fui%2Fnll%2Fissue-55651.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-55651.rs?ref=5a2ca1a6f18aa93d3120761f614ec2d39b4cb1ac", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-pass\n+\n+#![feature(untagged_unions)]\n+\n+struct A;\n+struct B;\n+\n+union U {\n+    a: A,\n+    b: B,\n+}\n+\n+fn main() {\n+    unsafe {\n+        {\n+            let mut u = U { a: A };\n+            let a = u.a;\n+            u.a = A;\n+            let a = u.a; // OK\n+        }\n+        {\n+            let mut u = U { a: A };\n+            let a = u.a;\n+            u.b = B;\n+            let a = u.a; // OK\n+        }\n+    }\n+}"}]}