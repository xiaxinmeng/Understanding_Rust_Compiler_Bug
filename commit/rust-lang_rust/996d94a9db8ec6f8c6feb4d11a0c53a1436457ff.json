{"sha": "996d94a9db8ec6f8c6feb4d11a0c53a1436457ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5NmQ5NGE5ZGI4ZWM2ZjhjNmZlYjRkMTFhMGM1M2ExNDM2NDU3ZmY=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2019-11-08T04:42:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-08T04:42:17Z"}, "message": "Rollup merge of #66056 - petrochenkov:metapriv, r=eddyb\n\nrustc_metadata: Some reorganization of the module structure\n\nThe new structure of `rustc_metadata` (or rather its parts affected by the refactoring) is\n```\n\u251c\u2500\u2500 lib.rs\n\u2514\u2500\u2500 rmeta\n    \u251c\u2500\u2500 decoder\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 cstore_impl.rs\n    \u251c\u2500\u2500 decoder.rs\n    \u251c\u2500\u2500 encoder.rs\n    \u251c\u2500\u2500 mod.rs\n    \u2514\u2500\u2500 table.rs\n```\n\n(`schema` is renamed to `rmeta`.)\n\nThe code inside `rmeta` is pretty self-contained, so we can now privatize almost everything in this module instead of using `pub(crate)`  which was necessary when all these modules accessed their neighbors in the old flat structure.\n\n`encoder` and `decoder` work with structures defined by `rmeta`.\n`table` is a part of `rmeta`.\n`cstore_impl` actively uses decoder methods and exposes their results through very few public methods (`provide` and `_untracked` methods).\n\nr? @eddyb @spastorino", "tree": {"sha": "6bc58052f8208f0166857c371b3e821519ee16e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6bc58052f8208f0166857c371b3e821519ee16e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/996d94a9db8ec6f8c6feb4d11a0c53a1436457ff", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdxPIqCRBK7hj4Ov3rIwAAdHIIAKKx8G4hVWtPLjI+R+nwfHe6\nJpu3PTZ4DQwwpxXoLGB0D6dqq4u//KOox8VmLojBM/n8Sajz51DLz9HGkkWA1CaN\n36m8evecq2RAnA5MzTGMcVvOgGd8PrI0rMtZWp+bQKtUVf5Gbqsn/gMW2UKidu1G\ne3AZi2m8/GZFvBh7zY+NdWixpcqAn7pUlJy8u0TiJ1SziV5vZhSR7hzKirIiC1ER\ngkW7/YBLZSN3tepPttvkkJPV2i+4XH7NT8xlGHSOwum0C2jPyf6+2rxK4eTLlBmr\n4QC0c2toqA2OVbklKGUHo7RZeEFYjnB5bJyZJD3KTbgmZIwvFR1KIM/44Qw2rPg=\n=lP01\n-----END PGP SIGNATURE-----\n", "payload": "tree 6bc58052f8208f0166857c371b3e821519ee16e2\nparent 9dc5d0ec813e6f0c06c3bdd31257d673dd11265f\nparent 5eb1cf16197a8cc38d18e81338f4c148e14ee36f\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1573188137 +0900\ncommitter GitHub <noreply@github.com> 1573188137 +0900\n\nRollup merge of #66056 - petrochenkov:metapriv, r=eddyb\n\nrustc_metadata: Some reorganization of the module structure\n\nThe new structure of `rustc_metadata` (or rather its parts affected by the refactoring) is\n```\n\u251c\u2500\u2500 lib.rs\n\u2514\u2500\u2500 rmeta\n    \u251c\u2500\u2500 decoder\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 cstore_impl.rs\n    \u251c\u2500\u2500 decoder.rs\n    \u251c\u2500\u2500 encoder.rs\n    \u251c\u2500\u2500 mod.rs\n    \u2514\u2500\u2500 table.rs\n```\n\n(`schema` is renamed to `rmeta`.)\n\nThe code inside `rmeta` is pretty self-contained, so we can now privatize almost everything in this module instead of using `pub(crate)`  which was necessary when all these modules accessed their neighbors in the old flat structure.\n\n`encoder` and `decoder` work with structures defined by `rmeta`.\n`table` is a part of `rmeta`.\n`cstore_impl` actively uses decoder methods and exposes their results through very few public methods (`provide` and `_untracked` methods).\n\nr? @eddyb @spastorino\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/996d94a9db8ec6f8c6feb4d11a0c53a1436457ff", "html_url": "https://github.com/rust-lang/rust/commit/996d94a9db8ec6f8c6feb4d11a0c53a1436457ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/996d94a9db8ec6f8c6feb4d11a0c53a1436457ff/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9dc5d0ec813e6f0c06c3bdd31257d673dd11265f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9dc5d0ec813e6f0c06c3bdd31257d673dd11265f", "html_url": "https://github.com/rust-lang/rust/commit/9dc5d0ec813e6f0c06c3bdd31257d673dd11265f"}, {"sha": "5eb1cf16197a8cc38d18e81338f4c148e14ee36f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5eb1cf16197a8cc38d18e81338f4c148e14ee36f", "html_url": "https://github.com/rust-lang/rust/commit/5eb1cf16197a8cc38d18e81338f4c148e14ee36f"}], "stats": {"total": 340, "additions": 171, "deletions": 169}, "files": [{"sha": "05e3ee3322e59d031b96bb805fcde3a50c2cbbcd", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/996d94a9db8ec6f8c6feb4d11a0c53a1436457ff/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996d94a9db8ec6f8c6feb4d11a0c53a1436457ff/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=996d94a9db8ec6f8c6feb4d11a0c53a1436457ff", "patch": "@@ -2,7 +2,7 @@\n \n use crate::cstore::{self, CStore, MetadataBlob};\n use crate::locator::{self, CratePaths};\n-use crate::schema::{CrateRoot, CrateDep};\n+use crate::rmeta::{CrateRoot, CrateDep};\n use rustc_data_structures::sync::{Lock, Once, AtomicCell};\n \n use rustc::hir::def_id::CrateNum;"}, {"sha": "c6c8ee575a98abdda0849974ef1cb4227c89eb45", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/996d94a9db8ec6f8c6feb4d11a0c53a1436457ff/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996d94a9db8ec6f8c6feb4d11a0c53a1436457ff/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=996d94a9db8ec6f8c6feb4d11a0c53a1436457ff", "patch": "@@ -1,7 +1,7 @@\n // The crate store - a central repo for information collected about external\n // crates and libraries\n \n-use crate::schema;\n+use crate::rmeta;\n use rustc::dep_graph::DepNodeIndex;\n use rustc::hir::def_id::{CrateNum, DefIndex};\n use rustc::hir::map::definitions::DefPathTable;\n@@ -17,7 +17,7 @@ use syntax_expand::base::SyntaxExtension;\n use syntax_pos;\n use proc_macro::bridge::client::ProcMacro;\n \n-pub use crate::cstore_impl::{provide, provide_extern};\n+pub use crate::rmeta::{provide, provide_extern};\n \n // A map from external crate numbers (as decoded from some crate file) to\n // local crate numbers (as generated during this session). Each external\n@@ -49,7 +49,7 @@ crate struct CrateMetadata {\n     /// lifetime is only used behind `Lazy`, and therefore acts like an\n     /// universal (`for<'tcx>`), that is paired up with whichever `TyCtxt`\n     /// is being used to decode those values.\n-    crate root: schema::CrateRoot<'static>,\n+    crate root: rmeta::CrateRoot<'static>,\n     /// For each definition in this crate, we encode a key. When the\n     /// crate is loaded, we read all the keys and put them in this\n     /// hashmap, which gives the reverse mapping. This allows us to\n@@ -59,7 +59,7 @@ crate struct CrateMetadata {\n     /// Trait impl data.\n     /// FIXME: Used only from queries and can use query cache,\n     /// so pre-decoding can probably be avoided.\n-    crate trait_impls: FxHashMap<(u32, DefIndex), schema::Lazy<[DefIndex]>>,\n+    crate trait_impls: FxHashMap<(u32, DefIndex), rmeta::Lazy<[DefIndex]>>,\n     /// Proc macro descriptions for this crate, if it's a proc macro crate.\n     crate raw_proc_macros: Option<&'static [ProcMacro]>,\n     /// Source maps for code from the crate."}, {"sha": "ac9d78e9a515c199f5f3477a99e9a48d329b2b82", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/996d94a9db8ec6f8c6feb4d11a0c53a1436457ff/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996d94a9db8ec6f8c6feb4d11a0c53a1436457ff/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=996d94a9db8ec6f8c6feb4d11a0c53a1436457ff", "patch": "@@ -26,15 +26,11 @@ extern crate rustc_data_structures;\n \n pub mod error_codes;\n \n-mod encoder;\n-mod decoder;\n mod dependency_format;\n-mod cstore_impl;\n mod foreign_modules;\n mod link_args;\n mod native_libs;\n-mod schema;\n-mod table;\n+mod rmeta;\n \n pub mod creader;\n pub mod cstore;"}, {"sha": "88d7595b063da20985a6fd004e96fb73552cafb9", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/996d94a9db8ec6f8c6feb4d11a0c53a1436457ff/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996d94a9db8ec6f8c6feb4d11a0c53a1436457ff/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=996d94a9db8ec6f8c6feb4d11a0c53a1436457ff", "patch": "@@ -214,7 +214,7 @@\n \n use crate::cstore::MetadataBlob;\n use crate::creader::Library;\n-use crate::schema::{METADATA_HEADER, rustc_version};\n+use crate::rmeta::{METADATA_HEADER, rustc_version};\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::svh::Svh;"}, {"sha": "40ec04537b0e66b6d17bdf246d4a42f81bea5722", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "renamed", "additions": 60, "deletions": 56, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/996d94a9db8ec6f8c6feb4d11a0c53a1436457ff/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996d94a9db8ec6f8c6feb4d11a0c53a1436457ff/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=996d94a9db8ec6f8c6feb4d11a0c53a1436457ff", "patch": "@@ -1,8 +1,8 @@\n // Decoding metadata from a single crate's metadata\n \n use crate::cstore::{self, CrateMetadata, MetadataBlob};\n-use crate::schema::*;\n-use crate::table::{FixedSizeEncoding, PerDefTable};\n+use crate::rmeta::*;\n+use crate::rmeta::table::{FixedSizeEncoding, PerDefTable};\n \n use rustc_index::vec::IndexVec;\n use rustc_data_structures::sync::Lrc;\n@@ -40,6 +40,10 @@ use syntax_pos::symbol::{Symbol, sym};\n use log::debug;\n use proc_macro::bridge::client::ProcMacro;\n \n+pub use cstore_impl::{provide, provide_extern};\n+\n+mod cstore_impl;\n+\n crate struct DecodeContext<'a, 'tcx> {\n     opaque: opaque::Decoder<'a>,\n     cdata: Option<&'a CrateMetadata>,\n@@ -464,7 +468,7 @@ impl<'tcx> EntryKind<'tcx> {\n }\n \n impl<'a, 'tcx> CrateMetadata {\n-    crate fn is_proc_macro_crate(&self) -> bool {\n+    fn is_proc_macro_crate(&self) -> bool {\n         self.root.proc_macro_decls_static.is_some()\n     }\n \n@@ -507,7 +511,7 @@ impl<'a, 'tcx> CrateMetadata {\n         &self.raw_proc_macros.unwrap()[pos]\n     }\n \n-    crate fn item_name(&self, item_index: DefIndex) -> Symbol {\n+    fn item_name(&self, item_index: DefIndex) -> Symbol {\n         if !self.is_proc_macro(item_index) {\n             self.def_key(item_index)\n                 .disambiguated_data\n@@ -519,7 +523,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn def_kind(&self, index: DefIndex) -> Option<DefKind> {\n+    fn def_kind(&self, index: DefIndex) -> Option<DefKind> {\n         if !self.is_proc_macro(index) {\n             self.kind(index).def_kind()\n         } else {\n@@ -529,11 +533,11 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn get_span(&self, index: DefIndex, sess: &Session) -> Span {\n+    fn get_span(&self, index: DefIndex, sess: &Session) -> Span {\n         self.root.per_def.span.get(self, index).unwrap().decode((self, sess))\n     }\n \n-    crate fn load_proc_macro(&self, id: DefIndex, sess: &Session) -> SyntaxExtension {\n+    fn load_proc_macro(&self, id: DefIndex, sess: &Session) -> SyntaxExtension {\n         let (name, kind, helper_attrs) = match *self.raw_proc_macro(id) {\n             ProcMacro::CustomDerive { trait_name, attributes, client } => {\n                 let helper_attrs =\n@@ -563,7 +567,7 @@ impl<'a, 'tcx> CrateMetadata {\n         )\n     }\n \n-    crate fn get_trait_def(&self, item_id: DefIndex, sess: &Session) -> ty::TraitDef {\n+    fn get_trait_def(&self, item_id: DefIndex, sess: &Session) -> ty::TraitDef {\n         match self.kind(item_id) {\n             EntryKind::Trait(data) => {\n                 let data = data.decode((self, sess));\n@@ -633,7 +637,7 @@ impl<'a, 'tcx> CrateMetadata {\n         )\n     }\n \n-    crate fn get_adt_def(&self, item_id: DefIndex, tcx: TyCtxt<'tcx>) -> &'tcx ty::AdtDef {\n+    fn get_adt_def(&self, item_id: DefIndex, tcx: TyCtxt<'tcx>) -> &'tcx ty::AdtDef {\n         let kind = self.kind(item_id);\n         let did = self.local_def_id(item_id);\n \n@@ -658,15 +662,15 @@ impl<'a, 'tcx> CrateMetadata {\n         tcx.alloc_adt_def(did, adt_kind, variants, repr)\n     }\n \n-    crate fn get_explicit_predicates(\n+    fn get_explicit_predicates(\n         &self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n         self.root.per_def.explicit_predicates.get(self, item_id).unwrap().decode((self, tcx))\n     }\n \n-    crate fn get_inferred_outlives(\n+    fn get_inferred_outlives(\n         &self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n@@ -676,36 +680,36 @@ impl<'a, 'tcx> CrateMetadata {\n         }).unwrap_or_default()\n     }\n \n-    crate fn get_super_predicates(\n+    fn get_super_predicates(\n         &self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n         self.root.per_def.super_predicates.get(self, item_id).unwrap().decode((self, tcx))\n     }\n \n-    crate fn get_generics(&self, item_id: DefIndex, sess: &Session) -> ty::Generics {\n+    fn get_generics(&self, item_id: DefIndex, sess: &Session) -> ty::Generics {\n         self.root.per_def.generics.get(self, item_id).unwrap().decode((self, sess))\n     }\n \n-    crate fn get_type(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n+    fn get_type(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         self.root.per_def.ty.get(self, id).unwrap().decode((self, tcx))\n     }\n \n-    crate fn get_stability(&self, id: DefIndex) -> Option<attr::Stability> {\n+    fn get_stability(&self, id: DefIndex) -> Option<attr::Stability> {\n         match self.is_proc_macro(id) {\n             true => self.root.proc_macro_stability.clone(),\n             false => self.root.per_def.stability.get(self, id).map(|stab| stab.decode(self)),\n         }\n     }\n \n-    crate fn get_deprecation(&self, id: DefIndex) -> Option<attr::Deprecation> {\n+    fn get_deprecation(&self, id: DefIndex) -> Option<attr::Deprecation> {\n         self.root.per_def.deprecation.get(self, id)\n             .filter(|_| !self.is_proc_macro(id))\n             .map(|depr| depr.decode(self))\n     }\n \n-    crate fn get_visibility(&self, id: DefIndex) -> ty::Visibility {\n+    fn get_visibility(&self, id: DefIndex) -> ty::Visibility {\n         match self.is_proc_macro(id) {\n             true => ty::Visibility::Public,\n             false => self.root.per_def.visibility.get(self, id).unwrap().decode(self),\n@@ -719,31 +723,31 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn get_parent_impl(&self, id: DefIndex) -> Option<DefId> {\n+    fn get_parent_impl(&self, id: DefIndex) -> Option<DefId> {\n         self.get_impl_data(id).parent_impl\n     }\n \n-    crate fn get_impl_polarity(&self, id: DefIndex) -> ty::ImplPolarity {\n+    fn get_impl_polarity(&self, id: DefIndex) -> ty::ImplPolarity {\n         self.get_impl_data(id).polarity\n     }\n \n-    crate fn get_impl_defaultness(&self, id: DefIndex) -> hir::Defaultness {\n+    fn get_impl_defaultness(&self, id: DefIndex) -> hir::Defaultness {\n         self.get_impl_data(id).defaultness\n     }\n \n-    crate fn get_coerce_unsized_info(\n+    fn get_coerce_unsized_info(\n         &self,\n         id: DefIndex,\n     ) -> Option<ty::adjustment::CoerceUnsizedInfo> {\n         self.get_impl_data(id).coerce_unsized_info\n     }\n \n-    crate fn get_impl_trait(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Option<ty::TraitRef<'tcx>> {\n+    fn get_impl_trait(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Option<ty::TraitRef<'tcx>> {\n         self.root.per_def.impl_trait_ref.get(self, id).map(|tr| tr.decode((self, tcx)))\n     }\n \n     /// Iterates over all the stability attributes in the given crate.\n-    crate fn get_lib_features(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(ast::Name, Option<ast::Name>)] {\n+    fn get_lib_features(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(ast::Name, Option<ast::Name>)] {\n         // FIXME: For a proc macro crate, not sure whether we should return the \"host\"\n         // features or an empty Vec. Both don't cause ICEs.\n         tcx.arena.alloc_from_iter(self.root\n@@ -752,7 +756,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     /// Iterates over the language items in the given crate.\n-    crate fn get_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(DefId, usize)] {\n+    fn get_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(DefId, usize)] {\n         if self.is_proc_macro_crate() {\n             // Proc macro crates do not export any lang-items to the target.\n             &[]\n@@ -765,7 +769,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     /// Iterates over the diagnostic items in the given crate.\n-    crate fn get_diagnostic_items(\n+    fn get_diagnostic_items(\n         &self,\n         tcx: TyCtxt<'tcx>,\n     ) -> &'tcx FxHashMap<Symbol, DefId> {\n@@ -782,7 +786,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     /// Iterates over each child of the given item.\n-    crate fn each_child_of_item<F>(&self, id: DefIndex, mut callback: F, sess: &Session)\n+    fn each_child_of_item<F>(&self, id: DefIndex, mut callback: F, sess: &Session)\n         where F: FnMut(def::Export<hir::HirId>)\n     {\n         if let Some(proc_macros_ids) = self.root.proc_macro_data.map(|d| d.decode(self)) {\n@@ -921,12 +925,12 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn is_item_mir_available(&self, id: DefIndex) -> bool {\n+    fn is_item_mir_available(&self, id: DefIndex) -> bool {\n         !self.is_proc_macro(id) &&\n             self.root.per_def.mir.get(self, id).is_some()\n     }\n \n-    crate fn get_optimized_mir(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Body<'tcx> {\n+    fn get_optimized_mir(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Body<'tcx> {\n         self.root.per_def.mir.get(self, id)\n             .filter(|_| !self.is_proc_macro(id))\n             .unwrap_or_else(|| {\n@@ -935,7 +939,7 @@ impl<'a, 'tcx> CrateMetadata {\n             .decode((self, tcx))\n     }\n \n-    crate fn get_promoted_mir(\n+    fn get_promoted_mir(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         id: DefIndex,\n@@ -948,7 +952,7 @@ impl<'a, 'tcx> CrateMetadata {\n             .decode((self, tcx))\n     }\n \n-    crate fn mir_const_qualif(&self, id: DefIndex) -> u8 {\n+    fn mir_const_qualif(&self, id: DefIndex) -> u8 {\n         match self.kind(id) {\n             EntryKind::Const(qualif, _) |\n             EntryKind::AssocConst(AssocContainer::ImplDefault, qualif, _) |\n@@ -959,7 +963,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn get_associated_item(&self, id: DefIndex) -> ty::AssocItem {\n+    fn get_associated_item(&self, id: DefIndex) -> ty::AssocItem {\n         let def_key = self.def_key(id);\n         let parent = self.local_def_id(def_key.parent.unwrap());\n         let name = def_key.disambiguated_data.data.get_opt_name().unwrap();\n@@ -992,12 +996,12 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn get_item_variances(&self, id: DefIndex) -> Vec<ty::Variance> {\n+    fn get_item_variances(&self, id: DefIndex) -> Vec<ty::Variance> {\n         self.root.per_def.variances.get(self, id).unwrap_or(Lazy::empty())\n             .decode(self).collect()\n     }\n \n-    crate fn get_ctor_kind(&self, node_id: DefIndex) -> CtorKind {\n+    fn get_ctor_kind(&self, node_id: DefIndex) -> CtorKind {\n         match self.kind(node_id) {\n             EntryKind::Struct(data, _) |\n             EntryKind::Union(data, _) |\n@@ -1006,7 +1010,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn get_ctor_def_id(&self, node_id: DefIndex) -> Option<DefId> {\n+    fn get_ctor_def_id(&self, node_id: DefIndex) -> Option<DefId> {\n         match self.kind(node_id) {\n             EntryKind::Struct(data, _) => {\n                 data.decode(self).ctor.map(|index| self.local_def_id(index))\n@@ -1018,7 +1022,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn get_item_attrs(&self, node_id: DefIndex, sess: &Session) -> Lrc<[ast::Attribute]> {\n+    fn get_item_attrs(&self, node_id: DefIndex, sess: &Session) -> Lrc<[ast::Attribute]> {\n         // The attributes for a tuple struct/variant are attached to the definition, not the ctor;\n         // we assume that someone passing in a tuple struct ctor is actually wanting to\n         // look at the definition\n@@ -1034,7 +1038,7 @@ impl<'a, 'tcx> CrateMetadata {\n             .collect::<Vec<_>>())\n     }\n \n-    crate fn get_struct_field_names(\n+    fn get_struct_field_names(\n         &self,\n         id: DefIndex,\n         sess: &Session,\n@@ -1060,7 +1064,7 @@ impl<'a, 'tcx> CrateMetadata {\n         None\n     }\n \n-    crate fn get_inherent_implementations_for_type(\n+    fn get_inherent_implementations_for_type(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         id: DefIndex,\n@@ -1072,7 +1076,7 @@ impl<'a, 'tcx> CrateMetadata {\n         )\n     }\n \n-    crate fn get_implementations_for_trait(\n+    fn get_implementations_for_trait(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         filter: Option<DefId>,\n@@ -1103,7 +1107,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn get_trait_of_item(&self, id: DefIndex) -> Option<DefId> {\n+    fn get_trait_of_item(&self, id: DefIndex) -> Option<DefId> {\n         let def_key = self.def_key(id);\n         match def_key.disambiguated_data.data {\n             DefPathData::TypeNs(..) | DefPathData::ValueNs(..) => (),\n@@ -1120,7 +1124,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n \n-    crate fn get_native_libraries(&self, sess: &Session) -> Vec<NativeLibrary> {\n+    fn get_native_libraries(&self, sess: &Session) -> Vec<NativeLibrary> {\n         if self.is_proc_macro_crate() {\n             // Proc macro crates do not have any *target* native libraries.\n             vec![]\n@@ -1129,7 +1133,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn get_foreign_modules(&self, tcx: TyCtxt<'tcx>) -> &'tcx [ForeignModule] {\n+    fn get_foreign_modules(&self, tcx: TyCtxt<'tcx>) -> &'tcx [ForeignModule] {\n         if self.is_proc_macro_crate() {\n             // Proc macro crates do not have any *target* foreign modules.\n             &[]\n@@ -1138,7 +1142,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn get_dylib_dependency_formats(\n+    fn get_dylib_dependency_formats(\n         &self,\n         tcx: TyCtxt<'tcx>,\n     ) -> &'tcx [(CrateNum, LinkagePreference)] {\n@@ -1152,7 +1156,7 @@ impl<'a, 'tcx> CrateMetadata {\n             }))\n     }\n \n-    crate fn get_missing_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [lang_items::LangItem] {\n+    fn get_missing_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [lang_items::LangItem] {\n         if self.is_proc_macro_crate() {\n             // Proc macro crates do not depend on any target weak lang-items.\n             &[]\n@@ -1163,7 +1167,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn get_fn_param_names(&self, id: DefIndex) -> Vec<ast::Name> {\n+    fn get_fn_param_names(&self, id: DefIndex) -> Vec<ast::Name> {\n         let param_names = match self.kind(id) {\n             EntryKind::Fn(data) |\n             EntryKind::ForeignFn(data) => data.decode(self).param_names,\n@@ -1173,7 +1177,7 @@ impl<'a, 'tcx> CrateMetadata {\n         param_names.decode(self).collect()\n     }\n \n-    crate fn exported_symbols(\n+    fn exported_symbols(\n         &self,\n         tcx: TyCtxt<'tcx>,\n     ) -> Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)> {\n@@ -1186,22 +1190,22 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn get_rendered_const(&self, id: DefIndex) -> String {\n+    fn get_rendered_const(&self, id: DefIndex) -> String {\n         match self.kind(id) {\n             EntryKind::Const(_, data) |\n             EntryKind::AssocConst(_, _, data) => data.decode(self).0,\n             _ => bug!(),\n         }\n     }\n \n-    crate fn get_macro(&self, id: DefIndex) -> MacroDef {\n+    fn get_macro(&self, id: DefIndex) -> MacroDef {\n         match self.kind(id) {\n             EntryKind::MacroDef(macro_def) => macro_def.decode(self),\n             _ => bug!(),\n         }\n     }\n \n-    crate fn is_const_fn_raw(&self, id: DefIndex) -> bool {\n+    fn is_const_fn_raw(&self, id: DefIndex) -> bool {\n         let constness = match self.kind(id) {\n             EntryKind::Method(data) => data.decode(self).fn_data.constness,\n             EntryKind::Fn(data) => data.decode(self).constness,\n@@ -1211,7 +1215,7 @@ impl<'a, 'tcx> CrateMetadata {\n         constness == hir::Constness::Const\n     }\n \n-    crate fn asyncness(&self, id: DefIndex) -> hir::IsAsync {\n+    fn asyncness(&self, id: DefIndex) -> hir::IsAsync {\n          match self.kind(id) {\n             EntryKind::Fn(data) => data.decode(self).asyncness,\n             EntryKind::Method(data) => data.decode(self).fn_data.asyncness,\n@@ -1220,7 +1224,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn is_foreign_item(&self, id: DefIndex) -> bool {\n+    fn is_foreign_item(&self, id: DefIndex) -> bool {\n         match self.kind(id) {\n             EntryKind::ForeignImmStatic |\n             EntryKind::ForeignMutStatic |\n@@ -1229,7 +1233,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn static_mutability(&self, id: DefIndex) -> Option<hir::Mutability> {\n+    fn static_mutability(&self, id: DefIndex) -> Option<hir::Mutability> {\n         match self.kind(id) {\n             EntryKind::ImmStatic |\n             EntryKind::ForeignImmStatic => Some(hir::MutImmutable),\n@@ -1239,12 +1243,12 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn fn_sig(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n+    fn fn_sig(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n         self.root.per_def.fn_sig.get(self, id).unwrap().decode((self, tcx))\n     }\n \n     #[inline]\n-    crate fn def_key(&self, index: DefIndex) -> DefKey {\n+    fn def_key(&self, index: DefIndex) -> DefKey {\n         let mut key = self.def_path_table.def_key(index);\n         if self.is_proc_macro(index) {\n             let name = self.raw_proc_macro(index).name();\n@@ -1254,13 +1258,13 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     // Returns the path leading to the thing with this `id`.\n-    crate fn def_path(&self, id: DefIndex) -> DefPath {\n+    fn def_path(&self, id: DefIndex) -> DefPath {\n         debug!(\"def_path(cnum={:?}, id={:?})\", self.cnum, id);\n         DefPath::make(self.cnum, id, |parent| self.def_key(parent))\n     }\n \n     #[inline]\n-    crate fn def_path_hash(&self, index: DefIndex) -> DefPathHash {\n+    fn def_path_hash(&self, index: DefIndex) -> DefPathHash {\n         self.def_path_table.def_path_hash(index)\n     }\n \n@@ -1358,7 +1362,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n     /// Get the `DepNodeIndex` corresponding this crate. The result of this\n     /// method is cached in the `dep_node_index` field.\n-    pub(super) fn get_crate_dep_node_index(&self, tcx: TyCtxt<'tcx>) -> DepNodeIndex {\n+    fn get_crate_dep_node_index(&self, tcx: TyCtxt<'tcx>) -> DepNodeIndex {\n         let mut dep_node_index = self.dep_node_index.load();\n \n         if unlikely!(dep_node_index == DepNodeIndex::INVALID) {", "previous_filename": "src/librustc_metadata/decoder.rs"}, {"sha": "6eacfc28de2dbfe7e129b381569a9f6ca3c88248", "filename": "src/librustc_metadata/rmeta/decoder/cstore_impl.rs", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/996d94a9db8ec6f8c6feb4d11a0c53a1436457ff/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996d94a9db8ec6f8c6feb4d11a0c53a1436457ff/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=996d94a9db8ec6f8c6feb4d11a0c53a1436457ff", "patch": "@@ -1,9 +1,8 @@\n use crate::cstore::{self, LoadedMacro};\n-use crate::encoder;\n use crate::link_args;\n use crate::native_libs;\n use crate::foreign_modules;\n-use crate::schema;\n+use crate::rmeta::{self, encoder};\n \n use rustc::ty::query::QueryConfig;\n use rustc::middle::cstore::{CrateSource, CrateStore, DepKind, EncodedMetadata, NativeLibraryKind};\n@@ -529,6 +528,6 @@ impl CrateStore for cstore::CStore {\n \n     fn metadata_encoding_version(&self) -> &[u8]\n     {\n-        schema::METADATA_HEADER\n+        rmeta::METADATA_HEADER\n     }\n }", "previous_filename": "src/librustc_metadata/cstore_impl.rs"}, {"sha": "afc81649e37195e8e33b2fcd7bcd7e2f8380b512", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/996d94a9db8ec6f8c6feb4d11a0c53a1436457ff/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996d94a9db8ec6f8c6feb4d11a0c53a1436457ff/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=996d94a9db8ec6f8c6feb4d11a0c53a1436457ff", "patch": "@@ -1,5 +1,5 @@\n-use crate::schema::*;\n-use crate::table::{FixedSizeEncoding, PerDefTable};\n+use crate::rmeta::*;\n+use crate::rmeta::table::{FixedSizeEncoding, PerDefTable};\n \n use rustc::middle::cstore::{LinkagePreference, NativeLibrary,\n                             EncodedMetadata, ForeignModule};\n@@ -1781,7 +1781,7 @@ impl<'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'tcx> {\n // will allow us to slice the metadata to the precise length that we just\n // generated regardless of trailing bytes that end up in it.\n \n-crate fn encode_metadata(tcx: TyCtxt<'_>) -> EncodedMetadata {\n+pub(super) fn encode_metadata(tcx: TyCtxt<'_>) -> EncodedMetadata {\n     let mut encoder = opaque::Encoder::new(vec![]);\n     encoder.emit_raw_bytes(METADATA_HEADER);\n ", "previous_filename": "src/librustc_metadata/encoder.rs"}, {"sha": "4eabeac6d986911b364ad1b41607f303212d9945", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "renamed", "additions": 89, "deletions": 85, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/996d94a9db8ec6f8c6feb4d11a0c53a1436457ff/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996d94a9db8ec6f8c6feb4d11a0c53a1436457ff/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=996d94a9db8ec6f8c6feb4d11a0c53a1436457ff", "patch": "@@ -1,4 +1,5 @@\n-use crate::table::PerDefTable;\n+use decoder::Metadata;\n+use table::PerDefTable;\n \n use rustc::hir;\n use rustc::hir::def::{self, CtorKind};\n@@ -13,7 +14,6 @@ use rustc::ty::{self, Ty, ReprOptions};\n use rustc_target::spec::{PanicStrategy, TargetTriple};\n use rustc_index::vec::IndexVec;\n use rustc_data_structures::svh::Svh;\n-\n use rustc_serialize::Encodable;\n use syntax::{ast, attr};\n use syntax::edition::Edition;\n@@ -23,6 +23,12 @@ use syntax_pos::{self, Span};\n use std::marker::PhantomData;\n use std::num::NonZeroUsize;\n \n+pub use decoder::{provide, provide_extern};\n+\n+mod decoder;\n+mod encoder;\n+mod table;\n+\n crate fn rustc_version() -> String {\n     format!(\"rustc {}\",\n             option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\"))\n@@ -104,13 +110,13 @@ crate struct Lazy<T, Meta = <T as LazyMeta>::Meta>\n     where T: ?Sized + LazyMeta<Meta = Meta>,\n           Meta: 'static + Copy,\n {\n-    pub position: NonZeroUsize,\n-    pub meta: Meta,\n+    position: NonZeroUsize,\n+    meta: Meta,\n     _marker: PhantomData<T>,\n }\n \n impl<T: ?Sized + LazyMeta> Lazy<T> {\n-     crate fn from_position_and_meta(position: NonZeroUsize, meta: T::Meta) -> Lazy<T> {\n+     fn from_position_and_meta(position: NonZeroUsize, meta: T::Meta) -> Lazy<T> {\n         Lazy {\n             position,\n             meta,\n@@ -120,13 +126,13 @@ impl<T: ?Sized + LazyMeta> Lazy<T> {\n }\n \n impl<T: Encodable> Lazy<T> {\n-    crate fn from_position(position: NonZeroUsize) -> Lazy<T> {\n+    fn from_position(position: NonZeroUsize) -> Lazy<T> {\n         Lazy::from_position_and_meta(position, ())\n     }\n }\n \n impl<T: Encodable> Lazy<[T]> {\n-    crate fn empty() -> Lazy<[T]> {\n+    fn empty() -> Lazy<[T]> {\n         Lazy::from_position_and_meta(NonZeroUsize::new(1).unwrap(), 0)\n     }\n }\n@@ -143,7 +149,7 @@ impl<T: ?Sized + LazyMeta> rustc_serialize::UseSpecializedDecodable for Lazy<T>\n \n /// Encoding / decoding state for `Lazy`.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-crate enum LazyState {\n+enum LazyState {\n     /// Outside of a metadata node.\n     NoNode,\n \n@@ -171,46 +177,46 @@ macro_rules! Lazy {\n crate struct CrateRoot<'tcx> {\n     pub name: Symbol,\n     pub triple: TargetTriple,\n-    pub extra_filename: String,\n+    extra_filename: String,\n     pub hash: Svh,\n     pub disambiguator: CrateDisambiguator,\n     pub panic_strategy: PanicStrategy,\n-    pub edition: Edition,\n+    edition: Edition,\n     pub has_global_allocator: bool,\n-    pub has_panic_handler: bool,\n+    has_panic_handler: bool,\n     pub has_default_lib_allocator: bool,\n-    pub plugin_registrar_fn: Option<DefIndex>,\n-    pub proc_macro_decls_static: Option<DefIndex>,\n-    pub proc_macro_stability: Option<attr::Stability>,\n+    plugin_registrar_fn: Option<DefIndex>,\n+    proc_macro_decls_static: Option<DefIndex>,\n+    proc_macro_stability: Option<attr::Stability>,\n \n     pub crate_deps: Lazy<[CrateDep]>,\n-    pub dylib_dependency_formats: Lazy<[Option<LinkagePreference>]>,\n-    pub lib_features: Lazy<[(Symbol, Option<Symbol>)]>,\n-    pub lang_items: Lazy<[(DefIndex, usize)]>,\n-    pub lang_items_missing: Lazy<[lang_items::LangItem]>,\n-    pub diagnostic_items: Lazy<[(Symbol, DefIndex)]>,\n-    pub native_libraries: Lazy<[NativeLibrary]>,\n-    pub foreign_modules: Lazy<[ForeignModule]>,\n-    pub source_map: Lazy<[syntax_pos::SourceFile]>,\n+    dylib_dependency_formats: Lazy<[Option<LinkagePreference>]>,\n+    lib_features: Lazy<[(Symbol, Option<Symbol>)]>,\n+    lang_items: Lazy<[(DefIndex, usize)]>,\n+    lang_items_missing: Lazy<[lang_items::LangItem]>,\n+    diagnostic_items: Lazy<[(Symbol, DefIndex)]>,\n+    native_libraries: Lazy<[NativeLibrary]>,\n+    foreign_modules: Lazy<[ForeignModule]>,\n+    source_map: Lazy<[syntax_pos::SourceFile]>,\n     pub def_path_table: Lazy<hir::map::definitions::DefPathTable>,\n     pub impls: Lazy<[TraitImpls]>,\n-    pub exported_symbols: Lazy!([(ExportedSymbol<'tcx>, SymbolExportLevel)]),\n+    exported_symbols: Lazy!([(ExportedSymbol<'tcx>, SymbolExportLevel)]),\n     pub interpret_alloc_index: Lazy<[u32]>,\n \n-    pub per_def: LazyPerDefTables<'tcx>,\n+    per_def: LazyPerDefTables<'tcx>,\n \n     /// The DefIndex's of any proc macros delcared by\n     /// this crate\n     pub proc_macro_data: Option<Lazy<[DefIndex]>>,\n \n-    pub compiler_builtins: bool,\n+    compiler_builtins: bool,\n     pub needs_allocator: bool,\n     pub needs_panic_runtime: bool,\n-    pub no_builtins: bool,\n+    no_builtins: bool,\n     pub panic_runtime: bool,\n     pub profiler_runtime: bool,\n     pub sanitizer_runtime: bool,\n-    pub symbol_mangling_version: SymbolManglingVersion,\n+    symbol_mangling_version: SymbolManglingVersion,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -230,35 +236,33 @@ crate struct TraitImpls {\n \n #[derive(RustcEncodable, RustcDecodable)]\n crate struct LazyPerDefTables<'tcx> {\n-    pub kind: Lazy!(PerDefTable<Lazy!(EntryKind<'tcx>)>),\n-    pub visibility: Lazy!(PerDefTable<Lazy<ty::Visibility>>),\n-    pub span: Lazy!(PerDefTable<Lazy<Span>>),\n-    pub attributes: Lazy!(PerDefTable<Lazy<[ast::Attribute]>>),\n-    pub children: Lazy!(PerDefTable<Lazy<[DefIndex]>>),\n-    pub stability: Lazy!(PerDefTable<Lazy<attr::Stability>>),\n-    pub deprecation: Lazy!(PerDefTable<Lazy<attr::Deprecation>>),\n-\n-    pub ty: Lazy!(PerDefTable<Lazy!(Ty<'tcx>)>),\n-    pub fn_sig: Lazy!(PerDefTable<Lazy!(ty::PolyFnSig<'tcx>)>),\n-    pub impl_trait_ref: Lazy!(PerDefTable<Lazy!(ty::TraitRef<'tcx>)>),\n-    pub inherent_impls: Lazy!(PerDefTable<Lazy<[DefIndex]>>),\n-    pub variances: Lazy!(PerDefTable<Lazy<[ty::Variance]>>),\n-    pub generics: Lazy!(PerDefTable<Lazy<ty::Generics>>),\n-    pub explicit_predicates: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n+    kind: Lazy!(PerDefTable<Lazy!(EntryKind<'tcx>)>),\n+    visibility: Lazy!(PerDefTable<Lazy<ty::Visibility>>),\n+    span: Lazy!(PerDefTable<Lazy<Span>>),\n+    attributes: Lazy!(PerDefTable<Lazy<[ast::Attribute]>>),\n+    children: Lazy!(PerDefTable<Lazy<[DefIndex]>>),\n+    stability: Lazy!(PerDefTable<Lazy<attr::Stability>>),\n+    deprecation: Lazy!(PerDefTable<Lazy<attr::Deprecation>>),\n+    ty: Lazy!(PerDefTable<Lazy!(Ty<'tcx>)>),\n+    fn_sig: Lazy!(PerDefTable<Lazy!(ty::PolyFnSig<'tcx>)>),\n+    impl_trait_ref: Lazy!(PerDefTable<Lazy!(ty::TraitRef<'tcx>)>),\n+    inherent_impls: Lazy!(PerDefTable<Lazy<[DefIndex]>>),\n+    variances: Lazy!(PerDefTable<Lazy<[ty::Variance]>>),\n+    generics: Lazy!(PerDefTable<Lazy<ty::Generics>>),\n+    explicit_predicates: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n     // FIXME(eddyb) this would ideally be `Lazy<[...]>` but `ty::Predicate`\n     // doesn't handle shorthands in its own (de)serialization impls,\n     // as it's an `enum` for which we want to derive (de)serialization,\n     // so the `ty::codec` APIs handle the whole `&'tcx [...]` at once.\n     // Also, as an optimization, a missing entry indicates an empty `&[]`.\n-    pub inferred_outlives: Lazy!(PerDefTable<Lazy!(&'tcx [(ty::Predicate<'tcx>, Span)])>),\n-    pub super_predicates: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n-\n-    pub mir: Lazy!(PerDefTable<Lazy!(mir::Body<'tcx>)>),\n-    pub promoted_mir: Lazy!(PerDefTable<Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>),\n+    inferred_outlives: Lazy!(PerDefTable<Lazy!(&'tcx [(ty::Predicate<'tcx>, Span)])>),\n+    super_predicates: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n+    mir: Lazy!(PerDefTable<Lazy!(mir::Body<'tcx>)>),\n+    promoted_mir: Lazy!(PerDefTable<Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>),\n }\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n-crate enum EntryKind<'tcx> {\n+enum EntryKind<'tcx> {\n     Const(ConstQualif, Lazy<RenderedConst>),\n     ImmStatic,\n     MutStatic,\n@@ -293,74 +297,74 @@ crate enum EntryKind<'tcx> {\n \n /// Additional data for EntryKind::Const and EntryKind::AssocConst\n #[derive(Clone, Copy, RustcEncodable, RustcDecodable)]\n-crate struct ConstQualif {\n-    pub mir: u8,\n+struct ConstQualif {\n+    mir: u8,\n }\n \n /// Contains a constant which has been rendered to a String.\n /// Used by rustdoc.\n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct RenderedConst(pub String);\n+struct RenderedConst(String);\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct ModData {\n-    pub reexports: Lazy<[def::Export<hir::HirId>]>,\n+struct ModData {\n+    reexports: Lazy<[def::Export<hir::HirId>]>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct MacroDef {\n-    pub body: String,\n-    pub legacy: bool,\n+struct MacroDef {\n+    body: String,\n+    legacy: bool,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct FnData {\n-    pub asyncness: hir::IsAsync,\n-    pub constness: hir::Constness,\n-    pub param_names: Lazy<[ast::Name]>,\n+struct FnData {\n+    asyncness: hir::IsAsync,\n+    constness: hir::Constness,\n+    param_names: Lazy<[ast::Name]>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct VariantData {\n-    pub ctor_kind: CtorKind,\n-    pub discr: ty::VariantDiscr,\n+struct VariantData {\n+    ctor_kind: CtorKind,\n+    discr: ty::VariantDiscr,\n     /// If this is unit or tuple-variant/struct, then this is the index of the ctor id.\n-    pub ctor: Option<DefIndex>,\n+    ctor: Option<DefIndex>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct TraitData {\n-    pub unsafety: hir::Unsafety,\n-    pub paren_sugar: bool,\n-    pub has_auto_impl: bool,\n-    pub is_marker: bool,\n+struct TraitData {\n+    unsafety: hir::Unsafety,\n+    paren_sugar: bool,\n+    has_auto_impl: bool,\n+    is_marker: bool,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct ImplData {\n-    pub polarity: ty::ImplPolarity,\n-    pub defaultness: hir::Defaultness,\n-    pub parent_impl: Option<DefId>,\n+struct ImplData {\n+    polarity: ty::ImplPolarity,\n+    defaultness: hir::Defaultness,\n+    parent_impl: Option<DefId>,\n \n     /// This is `Some` only for impls of `CoerceUnsized`.\n     // FIXME(eddyb) perhaps compute this on the fly if cheap enough?\n-    pub coerce_unsized_info: Option<ty::adjustment::CoerceUnsizedInfo>,\n+    coerce_unsized_info: Option<ty::adjustment::CoerceUnsizedInfo>,\n }\n \n \n /// Describes whether the container of an associated item\n /// is a trait or an impl and whether, in a trait, it has\n /// a default, or an in impl, whether it's marked \"default\".\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n-crate enum AssocContainer {\n+enum AssocContainer {\n     TraitRequired,\n     TraitWithDefault,\n     ImplDefault,\n     ImplFinal,\n }\n \n impl AssocContainer {\n-    crate fn with_def_id(&self, def_id: DefId) -> ty::AssocItemContainer {\n+    fn with_def_id(&self, def_id: DefId) -> ty::AssocItemContainer {\n         match *self {\n             AssocContainer::TraitRequired |\n             AssocContainer::TraitWithDefault => ty::TraitContainer(def_id),\n@@ -370,7 +374,7 @@ impl AssocContainer {\n         }\n     }\n \n-    crate fn defaultness(&self) -> hir::Defaultness {\n+    fn defaultness(&self) -> hir::Defaultness {\n         match *self {\n             AssocContainer::TraitRequired => hir::Defaultness::Default {\n                 has_value: false,\n@@ -387,17 +391,17 @@ impl AssocContainer {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct MethodData {\n-    pub fn_data: FnData,\n-    pub container: AssocContainer,\n-    pub has_self: bool,\n+struct MethodData {\n+    fn_data: FnData,\n+    container: AssocContainer,\n+    has_self: bool,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct GeneratorData<'tcx> {\n-    pub layout: mir::GeneratorLayout<'tcx>,\n+struct GeneratorData<'tcx> {\n+    layout: mir::GeneratorLayout<'tcx>,\n }\n \n // Tags used for encoding Spans:\n-crate const TAG_VALID_SPAN: u8 = 0;\n-crate const TAG_INVALID_SPAN: u8 = 1;\n+const TAG_VALID_SPAN: u8 = 0;\n+const TAG_INVALID_SPAN: u8 = 1;", "previous_filename": "src/librustc_metadata/schema.rs"}, {"sha": "613d92c6d7b0b9c34aa4dc995bf9f5d0e19eacc8", "filename": "src/librustc_metadata/rmeta/table.rs", "status": "renamed", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/996d94a9db8ec6f8c6feb4d11a0c53a1436457ff/src%2Flibrustc_metadata%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996d94a9db8ec6f8c6feb4d11a0c53a1436457ff/src%2Flibrustc_metadata%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Ftable.rs?ref=996d94a9db8ec6f8c6feb4d11a0c53a1436457ff", "patch": "@@ -1,5 +1,4 @@\n-use crate::decoder::Metadata;\n-use crate::schema::*;\n+use crate::rmeta::*;\n \n use rustc::hir::def_id::{DefId, DefIndex};\n use rustc_serialize::{Encodable, opaque::Encoder};\n@@ -12,7 +11,7 @@ use log::debug;\n /// Used mainly for Lazy positions and lengths.\n /// Unchecked invariant: `Self::default()` should encode as `[0; BYTE_LEN]`,\n /// but this has no impact on safety.\n-crate trait FixedSizeEncoding: Default {\n+pub(super) trait FixedSizeEncoding: Default {\n     const BYTE_LEN: usize;\n \n     // FIXME(eddyb) convert to and from `[u8; Self::BYTE_LEN]` instead,\n@@ -126,7 +125,7 @@ impl<T: Encodable> FixedSizeEncoding for Option<Lazy<[T]>> {\n // FIXME(eddyb) replace `Vec` with `[_]` here, such that `Box<Table<T>>` would be used\n // when building it, and `Lazy<Table<T>>` or `&Table<T>` when reading it.\n // (not sure if that is possible given that the `Vec` is being resized now)\n-crate struct Table<T> where Option<T>: FixedSizeEncoding {\n+pub(super) struct Table<T> where Option<T>: FixedSizeEncoding {\n     // FIXME(eddyb) store `[u8; <Option<T>>::BYTE_LEN]` instead of `u8` in `Vec`,\n     // once that starts being allowed by the compiler (i.e. lazy normalization).\n     bytes: Vec<u8>,\n@@ -143,7 +142,7 @@ impl<T> Default for Table<T> where Option<T>: FixedSizeEncoding {\n }\n \n impl<T> Table<T> where Option<T>: FixedSizeEncoding {\n-    crate fn set(&mut self, i: usize, value: T) {\n+    fn set(&mut self, i: usize, value: T) {\n         // FIXME(eddyb) investigate more compact encodings for sparse tables.\n         // On the PR @michaelwoerister mentioned:\n         // > Space requirements could perhaps be optimized by using the HAMT `popcnt`\n@@ -157,7 +156,7 @@ impl<T> Table<T> where Option<T>: FixedSizeEncoding {\n         Some(value).write_to_bytes_at(&mut self.bytes, i);\n     }\n \n-    crate fn encode(&self, buf: &mut Encoder) -> Lazy<Self> {\n+    fn encode(&self, buf: &mut Encoder) -> Lazy<Self> {\n         let pos = buf.position();\n         buf.emit_raw_bytes(&self.bytes);\n         Lazy::from_position_and_meta(\n@@ -178,7 +177,7 @@ impl<T> LazyMeta for Table<T> where Option<T>: FixedSizeEncoding {\n impl<T> Lazy<Table<T>> where Option<T>: FixedSizeEncoding {\n     /// Given the metadata, extract out the value at a particular index (if any).\n     #[inline(never)]\n-    crate fn get<'a, 'tcx, M: Metadata<'a, 'tcx>>(\n+    fn get<'a, 'tcx, M: Metadata<'a, 'tcx>>(\n         &self,\n         metadata: M,\n         i: usize,\n@@ -194,7 +193,7 @@ impl<T> Lazy<Table<T>> where Option<T>: FixedSizeEncoding {\n /// Like a `Table` but using `DefIndex` instead of `usize` as keys.\n // FIXME(eddyb) replace by making `Table` behave like `IndexVec`,\n // and by using `newtype_index!` to define `DefIndex`.\n-crate struct PerDefTable<T>(Table<T>) where Option<T>: FixedSizeEncoding;\n+pub(super) struct PerDefTable<T>(Table<T>) where Option<T>: FixedSizeEncoding;\n \n impl<T> Default for PerDefTable<T> where Option<T>: FixedSizeEncoding {\n     fn default() -> Self {\n@@ -203,12 +202,12 @@ impl<T> Default for PerDefTable<T> where Option<T>: FixedSizeEncoding {\n }\n \n impl<T> PerDefTable<T> where Option<T>: FixedSizeEncoding {\n-    crate fn set(&mut self, def_id: DefId, value: T) {\n+    pub(super) fn set(&mut self, def_id: DefId, value: T) {\n         assert!(def_id.is_local());\n         self.0.set(def_id.index.index(), value);\n     }\n \n-    crate fn encode(&self, buf: &mut Encoder) -> Lazy<Self> {\n+    pub(super) fn encode(&self, buf: &mut Encoder) -> Lazy<Self> {\n         let lazy = self.0.encode(buf);\n         Lazy::from_position_and_meta(lazy.position, lazy.meta)\n     }\n@@ -229,7 +228,7 @@ impl<T> Lazy<PerDefTable<T>> where Option<T>: FixedSizeEncoding {\n \n     /// Given the metadata, extract out the value at a particular DefIndex (if any).\n     #[inline(never)]\n-    crate fn get<'a, 'tcx, M: Metadata<'a, 'tcx>>(\n+    pub(super) fn get<'a, 'tcx, M: Metadata<'a, 'tcx>>(\n         &self,\n         metadata: M,\n         def_index: DefIndex,", "previous_filename": "src/librustc_metadata/table.rs"}]}