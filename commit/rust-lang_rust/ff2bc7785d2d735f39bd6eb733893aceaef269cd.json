{"sha": "ff2bc7785d2d735f39bd6eb733893aceaef269cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmMmJjNzc4NWQyZDczNWYzOWJkNmViNzMzODkzYWNlYWVmMjY5Y2Q=", "commit": {"author": {"name": "Jan Likar", "email": "likar.jan@gmail.com", "date": "2015-09-30T00:42:52Z"}, "committer": {"name": "Jan Likar", "email": "likar.jan@gmail.com", "date": "2015-09-30T00:42:52Z"}, "message": "Improve \"Variable bindings\" chapter\n\n - Expand the first paragraph\n\n - Improve readability by partitioning the chapter into the following\n   sections: \"Patterns\", \"Type annotations\", \"Mutability\", and\n   \"Initializing bindings\"\n\n - Add \"Scope and shadowing\" section (fix #28177)", "tree": {"sha": "42a204de3bc029660ffc967e3a309253d990b328", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42a204de3bc029660ffc967e3a309253d990b328"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff2bc7785d2d735f39bd6eb733893aceaef269cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff2bc7785d2d735f39bd6eb733893aceaef269cd", "html_url": "https://github.com/rust-lang/rust/commit/ff2bc7785d2d735f39bd6eb733893aceaef269cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff2bc7785d2d735f39bd6eb733893aceaef269cd/comments", "author": {"login": "JanLikar", "id": 4228250, "node_id": "MDQ6VXNlcjQyMjgyNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/4228250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JanLikar", "html_url": "https://github.com/JanLikar", "followers_url": "https://api.github.com/users/JanLikar/followers", "following_url": "https://api.github.com/users/JanLikar/following{/other_user}", "gists_url": "https://api.github.com/users/JanLikar/gists{/gist_id}", "starred_url": "https://api.github.com/users/JanLikar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JanLikar/subscriptions", "organizations_url": "https://api.github.com/users/JanLikar/orgs", "repos_url": "https://api.github.com/users/JanLikar/repos", "events_url": "https://api.github.com/users/JanLikar/events{/privacy}", "received_events_url": "https://api.github.com/users/JanLikar/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JanLikar", "id": 4228250, "node_id": "MDQ6VXNlcjQyMjgyNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/4228250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JanLikar", "html_url": "https://github.com/JanLikar", "followers_url": "https://api.github.com/users/JanLikar/followers", "following_url": "https://api.github.com/users/JanLikar/following{/other_user}", "gists_url": "https://api.github.com/users/JanLikar/gists{/gist_id}", "starred_url": "https://api.github.com/users/JanLikar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JanLikar/subscriptions", "organizations_url": "https://api.github.com/users/JanLikar/orgs", "repos_url": "https://api.github.com/users/JanLikar/repos", "events_url": "https://api.github.com/users/JanLikar/events{/privacy}", "received_events_url": "https://api.github.com/users/JanLikar/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59eb44407652f5b66a66231f12f66f89c5df5c5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/59eb44407652f5b66a66231f12f66f89c5df5c5f", "html_url": "https://github.com/rust-lang/rust/commit/59eb44407652f5b66a66231f12f66f89c5df5c5f"}], "stats": {"total": 99, "additions": 91, "deletions": 8}, "files": [{"sha": "3521c970e72c8f3b76f35835504b14dcb7b1291f", "filename": "src/doc/trpl/variable-bindings.md", "status": "modified", "additions": 91, "deletions": 8, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/ff2bc7785d2d735f39bd6eb733893aceaef269cd/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff2bc7785d2d735f39bd6eb733893aceaef269cd/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md?ref=ff2bc7785d2d735f39bd6eb733893aceaef269cd", "patch": "@@ -1,7 +1,8 @@\n % Variable Bindings\n \n Virtually every non-'Hello World\u2019 Rust program uses *variable bindings*. They\n-look like this:\n+bind some value to a name, so it can be used later. `let` is\n+used to introduce a binding, just like this:\n \n ```rust\n fn main() {\n@@ -13,10 +14,12 @@ Putting `fn main() {` in each example is a bit tedious, so we\u2019ll leave that ou\n in the future. If you\u2019re following along, make sure to edit your `main()`\n function, rather than leaving it off. Otherwise, you\u2019ll get an error.\n \n-In many languages, this is called a *variable*, but Rust\u2019s variable bindings\n-have a few tricks up their sleeves. For example the left-hand side of a `let`\n-expression is a \u2018[pattern][pattern]\u2019, not just a variable name. This means we\n-can do things like:\n+# Patterns\n+\n+In many languages, a variable binding would be called a *variable*, but Rust\u2019s\n+variable bindings have a few tricks up their sleeves. For example the\n+left-hand side of a `let` expression is a \u2018[pattern][pattern]\u2019, not just a\n+variable name. This means we can do things like:\n \n ```rust\n let (x, y) = (1, 2);\n@@ -29,6 +32,8 @@ of our minds as we go forward.\n \n [pattern]: patterns.html\n \n+# Type annotations\n+\n Rust is a statically typed language, which means that we specify our types up\n front, and they\u2019re checked at compile time. So why does our first example\n compile? Well, Rust has this thing called \u2018type inference\u2019. If it can figure\n@@ -63,6 +68,8 @@ Note the similarities between this annotation and the syntax you use with\n occasionally include them to help you understand what the types that Rust\n infers are.\n \n+# Mutability\n+\n By default, bindings are *immutable*. This code will not compile:\n \n ```rust,ignore\n@@ -97,9 +104,11 @@ out of the scope of this guide. In general, you can often avoid explicit\n mutation, and so it is preferable in Rust. That said, sometimes, mutation is\n what you need, so it\u2019s not verboten.\n \n-Let\u2019s get back to bindings. Rust variable bindings have one more aspect that\n-differs from other languages: bindings are required to be initialized with a\n-value before you're allowed to use them.\n+# Initializing bindings\n+\n+Rust variable bindings have one more aspect that differs from other languages:\n+bindings are required to be initialized with a value before you're allowed to\n+use them.\n \n Let\u2019s try it out. Change your `src/main.rs` file to look like this:\n \n@@ -167,3 +176,77 @@ For now, we'll just stick to the default: integers aren't very complicated to\n print.\n \n [format]: ../std/fmt/index.html\n+\n+# Scope and shadowing\n+\n+Let\u2019s get back to bindings. Variable bindings have a scope - they are\n+constrained to live in a block they were defined in. A block is a collection\n+of statements enclosed by `{` and `}`. Function definitions are also blocks!\n+In the following example we define two variable bindings, `x` and `y`, which\n+live in different blocks. `x` can be accessed from inside the `fn main() {}`\n+block, while `y` can be accessed only from inside the inner block:\n+\n+```rust,ignore\n+fn main() {\n+    let x: i32 = 17;\n+    {\n+        let y: i32 = 3;\n+        println!(\"The value of x is {} and value of y is {}\", x, y);\n+    }\n+    println!(\"The value of x is {} and value of y is {}\", x, y); // This won't work\n+}\n+```\n+\n+The first `println!` would print \"The value of x is 17 and the value of y is\n+3\", but this example cannot be compiled successfully, because the second\n+`println!` cannot access the value of `y`, since it is not in scope anymore.\n+Instead we get this error:\n+\n+```bash\n+$ cargo build\n+   Compiling hello v0.1.0 (file:///home/you/projects/hello_world)\n+main.rs:7:62: 7:63 error: unresolved name `y`. Did you mean `x`? [E0425]\n+main.rs:7     println!(\"The value of x is {} and value of y is {}\", x, y); // This won't work\n+                                                                       ^\n+note: in expansion of format_args!\n+<std macros>:2:25: 2:56 note: expansion site\n+<std macros>:1:1: 2:62 note: in expansion of print!\n+<std macros>:3:1: 3:54 note: expansion site\n+<std macros>:1:1: 3:58 note: in expansion of println!\n+main.rs:7:5: 7:65 note: expansion site\n+main.rs:7:62: 7:63 help: run `rustc --explain E0425` to see a detailed explanation\n+error: aborting due to previous error\n+Could not compile `hello`.\n+\n+To learn more, run the command again with --verbose.\n+```\n+\n+Additionaly, variable bindings can be shadowed. This means that a later\n+variable binding with the same name as another binding, that's currently in\n+scope, will override the previous binding.\n+\n+```rust\n+let x: i32 = 8;\n+{\n+    println!(\"{}\", x); // Prints \"8\"\n+    let x = 12;\n+    println!(\"{}\", x); // Prints \"12\"\n+}\n+println!(\"{}\", x); // Prints \"8\"\n+let x =  42;\n+println!(\"{}\", x); // Prints \"42\"\n+```\n+\n+Shadowing and mutable bindings may appear as two sides of the same coin, but\n+they are two distinct concepts that can't always be used interchangeably. For\n+one, shadowing enables us to rebind a name to a value of a different type. It\n+is also possible to change the mutability of a binding.\n+\n+```rust\n+let mut x: i32 = 1;\n+x = 7;\n+let x = x; // x is now immutable and is bound to 7\n+\n+let y = 4;\n+let y = \"I can also be bound to text!\"; // y is now of a different type\n+```"}]}