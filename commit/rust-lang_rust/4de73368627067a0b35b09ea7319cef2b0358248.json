{"sha": "4de73368627067a0b35b09ea7319cef2b0358248", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkZTczMzY4NjI3MDY3YTBiMzViMDllYTczMTljZWYyYjAzNTgyNDg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-20T21:41:48Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-04T13:51:14Z"}, "message": "extend TransitiveRelation with `parents` function", "tree": {"sha": "55402bde5ad398d39e31c998d5937948c34275c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55402bde5ad398d39e31c998d5937948c34275c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4de73368627067a0b35b09ea7319cef2b0358248", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4de73368627067a0b35b09ea7319cef2b0358248", "html_url": "https://github.com/rust-lang/rust/commit/4de73368627067a0b35b09ea7319cef2b0358248", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4de73368627067a0b35b09ea7319cef2b0358248/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "663e7a4f0849896c5a24f0a12b8e7d3b715d75dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/663e7a4f0849896c5a24f0a12b8e7d3b715d75dd", "html_url": "https://github.com/rust-lang/rust/commit/663e7a4f0849896c5a24f0a12b8e7d3b715d75dd"}], "stats": {"total": 130, "additions": 128, "deletions": 2}, "files": [{"sha": "ffbb218dabedff0300393d0a379f5d0b803df5b8", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 128, "deletions": 2, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/4de73368627067a0b35b09ea7319cef2b0358248/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de73368627067a0b35b09ea7319cef2b0358248/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=4de73368627067a0b35b09ea7319cef2b0358248", "patch": "@@ -185,7 +185,14 @@ impl<T: Clone + Debug + Eq + Hash + Clone> TransitiveRelation<T> {\n     /// b -> b1\n     /// ```\n     pub fn postdom_upper_bound(&self, a: &T, b: &T) -> Option<&T> {\n-        let mut mubs = self.minimal_upper_bounds(a, b);\n+        let mubs = self.minimal_upper_bounds(a, b);\n+        self.mutual_immediate_postdominator(mubs)\n+    }\n+\n+    /// Viewing the relation as a graph, computes the \"mutual\n+    /// immediate postdominator\" of a set of points (if one\n+    /// exists). See `postdom_upper_bound` for details.\n+    pub fn mutual_immediate_postdominator<'a>(&'a self, mut mubs: Vec<&'a T>) -> Option<&'a T> {\n         loop {\n             match mubs.len() {\n                 0 => return None,\n@@ -277,6 +284,8 @@ impl<T: Clone + Debug + Eq + Hash + Clone> TransitiveRelation<T> {\n             // After step 3, we know that no element can reach any of\n             // its predecesssors (because of step 2) nor successors\n             // (because we just called `pare_down`)\n+            //\n+            // This same algorithm is used in `parents` below.\n \n             let mut candidates = closure.intersection(a.0, b.0); // (1)\n             pare_down(&mut candidates, closure); // (2)\n@@ -291,6 +300,59 @@ impl<T: Clone + Debug + Eq + Hash + Clone> TransitiveRelation<T> {\n                    .collect()\n     }\n \n+    /// Given an element A, returns the maximal set {B} of elements B\n+    /// such that\n+    ///\n+    /// - A != A\n+    /// - A R B is true\n+    /// - for each i, j: B[i] R B[j] does not hold\n+    ///\n+    /// The intuition is that this moves \"one step up\" through a lattice\n+    /// (where the relation is encoding the `<=` relation for the lattice).\n+    /// So e.g. if the relation is `->` and we have\n+    ///\n+    /// ```\n+    /// a -> b -> d -> f\n+    /// |              ^\n+    /// +--> c -> e ---+\n+    /// ```\n+    ///\n+    /// then `parents(a)` returns `[b, c]`. The `postdom_parent` function\n+    /// would further reduce this to just `f`.\n+    pub fn parents(&self, a: &T) -> Vec<&T> {\n+        let a = match self.index(a) {\n+            Some(a) => a,\n+            None => return vec![]\n+        };\n+\n+        // Steal the algorithm for `minimal_upper_bounds` above, but\n+        // with a slight tweak. In the case where `a R a`, we remove\n+        // that from the set of candidates.\n+        let ancestors = self.with_closure(|closure| {\n+            let mut ancestors = closure.intersection(a.0, a.0);\n+\n+            // Remove anything that can reach `a`. If this is a\n+            // reflexive relation, this will include `a` itself.\n+            ancestors.retain(|&e| !closure.contains(e, a.0));\n+\n+            pare_down(&mut ancestors, closure); // (2)\n+            ancestors.reverse(); // (3a)\n+            pare_down(&mut ancestors, closure); // (3b)\n+            ancestors\n+        });\n+\n+        ancestors.into_iter()\n+                 .rev() // (4)\n+                 .map(|i| &self.elements[i])\n+                 .collect()\n+    }\n+\n+    /// A \"best\" parent in some sense. See `parents` and\n+    /// `postdom_upper_bound` for more details.\n+    pub fn postdom_parent(&self, a: &T) -> Option<&T> {\n+        self.mutual_immediate_postdominator(self.parents(a))\n+    }\n+\n     fn with_closure<OP, R>(&self, op: OP) -> R\n         where OP: FnOnce(&BitMatrix) -> R\n     {\n@@ -469,11 +531,17 @@ fn test_many_steps() {\n }\n \n #[test]\n-fn mubs_triange() {\n+fn mubs_triangle() {\n+    // a -> tcx\n+    //      ^\n+    //      |\n+    //      b\n     let mut relation = TransitiveRelation::new();\n     relation.add(\"a\", \"tcx\");\n     relation.add(\"b\", \"tcx\");\n     assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"tcx\"]);\n+    assert_eq!(relation.parents(&\"a\"), vec![&\"tcx\"]);\n+    assert_eq!(relation.parents(&\"b\"), vec![&\"tcx\"]);\n }\n \n #[test]\n@@ -499,6 +567,9 @@ fn mubs_best_choice1() {\n     relation.add(\"3\", \"2\");\n \n     assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"2\"]);\n+    assert_eq!(relation.parents(&\"0\"), vec![&\"2\"]);\n+    assert_eq!(relation.parents(&\"2\"), vec![&\"1\"]);\n+    assert!(relation.parents(&\"1\").is_empty());\n }\n \n #[test]\n@@ -523,6 +594,9 @@ fn mubs_best_choice2() {\n     relation.add(\"3\", \"2\");\n \n     assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"1\"]);\n+    assert_eq!(relation.parents(&\"0\"), vec![&\"1\"]);\n+    assert_eq!(relation.parents(&\"1\"), vec![&\"2\"]);\n+    assert!(relation.parents(&\"2\").is_empty());\n }\n \n #[test]\n@@ -537,10 +611,15 @@ fn mubs_no_best_choice() {\n     relation.add(\"3\", \"2\");\n \n     assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"1\", &\"2\"]);\n+    assert_eq!(relation.parents(&\"0\"), vec![&\"1\", &\"2\"]);\n+    assert_eq!(relation.parents(&\"3\"), vec![&\"1\", &\"2\"]);\n }\n \n #[test]\n fn mubs_best_choice_scc() {\n+    // in this case, 1 and 2 form a cycle; we pick arbitrarily (but\n+    // consistently).\n+\n     let mut relation = TransitiveRelation::new();\n     relation.add(\"0\", \"1\");\n     relation.add(\"0\", \"2\");\n@@ -552,6 +631,7 @@ fn mubs_best_choice_scc() {\n     relation.add(\"3\", \"2\");\n \n     assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"1\"]);\n+    assert_eq!(relation.parents(&\"0\"), vec![&\"1\"]);\n }\n \n #[test]\n@@ -573,6 +653,8 @@ fn pdub_crisscross() {\n     assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"),\n                vec![&\"a1\", &\"b1\"]);\n     assert_eq!(relation.postdom_upper_bound(&\"a\", &\"b\"), Some(&\"x\"));\n+    assert_eq!(relation.postdom_parent(&\"a\"), Some(&\"x\"));\n+    assert_eq!(relation.postdom_parent(&\"b\"), Some(&\"x\"));\n }\n \n #[test]\n@@ -604,6 +686,9 @@ fn pdub_crisscross_more() {\n     assert_eq!(relation.minimal_upper_bounds(&\"a1\", &\"b1\"),\n                vec![&\"a2\", &\"b2\"]);\n     assert_eq!(relation.postdom_upper_bound(&\"a\", &\"b\"), Some(&\"x\"));\n+\n+    assert_eq!(relation.postdom_parent(&\"a\"), Some(&\"x\"));\n+    assert_eq!(relation.postdom_parent(&\"b\"), Some(&\"x\"));\n }\n \n #[test]\n@@ -621,6 +706,11 @@ fn pdub_lub() {\n \n     assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"x\"]);\n     assert_eq!(relation.postdom_upper_bound(&\"a\", &\"b\"), Some(&\"x\"));\n+\n+    assert_eq!(relation.postdom_parent(&\"a\"), Some(&\"a1\"));\n+    assert_eq!(relation.postdom_parent(&\"b\"), Some(&\"b1\"));\n+    assert_eq!(relation.postdom_parent(&\"a1\"), Some(&\"x\"));\n+    assert_eq!(relation.postdom_parent(&\"b1\"), Some(&\"x\"));\n }\n \n #[test]\n@@ -722,3 +812,39 @@ fn mubs_scc_4() {\n \n     assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"c\"]);\n }\n+\n+#[test]\n+fn parent() {\n+    // An example that was misbehaving in the compiler.\n+    //\n+    // 4 -> 1 -> 3\n+    //   \\  |   /\n+    //    \\ v  /\n+    // 2 -> 0\n+    //\n+    // plus a bunch of self-loops\n+    //\n+    // Here `->` represents `<=` and `0` is `'static`.\n+\n+    let pairs = vec![\n+        (2, /*->*/ 0),\n+        (2, /*->*/ 2),\n+        (0, /*->*/ 0),\n+        (0, /*->*/ 0),\n+        (1, /*->*/ 0),\n+        (1, /*->*/ 1),\n+        (3, /*->*/ 0),\n+        (3, /*->*/ 3),\n+        (4, /*->*/ 0),\n+        (4, /*->*/ 1),\n+        (1, /*->*/ 3),\n+    ];\n+\n+    let mut relation = TransitiveRelation::new();\n+    for (a, b) in pairs {\n+        relation.add(a, b);\n+    }\n+\n+    let p = relation.postdom_parent(&3);\n+    assert_eq!(p, Some(&0));\n+}"}]}