{"sha": "a6a247798619cf513fcab2421bade4dc99994e67", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2YTI0Nzc5ODYxOWNmNTEzZmNhYjI0MjFiYWRlNGRjOTk5OTRlNjc=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2016-11-12T22:30:06Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2016-11-12T22:45:15Z"}, "message": "use write::run_assembler", "tree": {"sha": "882d6586b64244b2e865738d963a76fdf0ddf64e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/882d6586b64244b2e865738d963a76fdf0ddf64e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6a247798619cf513fcab2421bade4dc99994e67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6a247798619cf513fcab2421bade4dc99994e67", "html_url": "https://github.com/rust-lang/rust/commit/a6a247798619cf513fcab2421bade4dc99994e67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6a247798619cf513fcab2421bade4dc99994e67/comments", "author": null, "committer": null, "parents": [{"sha": "fcde9904dbe7c4426a72b39a49b892eadb5a8940", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcde9904dbe7c4426a72b39a49b892eadb5a8940", "html_url": "https://github.com/rust-lang/rust/commit/fcde9904dbe7c4426a72b39a49b892eadb5a8940"}], "stats": {"total": 109, "additions": 26, "deletions": 83}, "files": [{"sha": "cc04582b19e28cf35a6ec277f46138a105726291", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a6a247798619cf513fcab2421bade4dc99994e67/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a247798619cf513fcab2421bade4dc99994e67/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=a6a247798619cf513fcab2421bade4dc99994e67", "patch": "@@ -359,9 +359,10 @@ pub struct TargetOptions {\n     // will 'just work'.\n     pub obj_is_bitcode: bool,\n \n-    // LLVM can't produce object files for MSP430. Instead, we'll make LLVM emit\n-    // assembly and then use `msp430-as` to turn that assembly into an object file\n-    pub obj_needs_as: bool,\n+    // LLVM can't produce object files for this target. Instead, we'll make LLVM\n+    // emit assembly and then use `gcc` to turn that assembly into an object\n+    // file\n+    pub no_integrated_as: bool,\n \n     /// Don't use this field; instead use the `.max_atomic_width()` method.\n     pub max_atomic_width: Option<u64>,\n@@ -420,7 +421,7 @@ impl Default for TargetOptions {\n             allow_asm: true,\n             has_elf_tls: false,\n             obj_is_bitcode: false,\n-            obj_needs_as: false,\n+            no_integrated_as: false,\n             max_atomic_width: None,\n             panic_strategy: PanicStrategy::Unwind,\n             abi_blacklist: vec![],\n@@ -581,7 +582,7 @@ impl Target {\n         key!(exe_allocation_crate);\n         key!(has_elf_tls, bool);\n         key!(obj_is_bitcode, bool);\n-        key!(obj_needs_as, bool);\n+        key!(no_integrated_as, bool);\n         key!(max_atomic_width, Option<u64>);\n         try!(key!(panic_strategy, PanicStrategy));\n \n@@ -741,7 +742,7 @@ impl ToJson for Target {\n         target_option_val!(exe_allocation_crate);\n         target_option_val!(has_elf_tls);\n         target_option_val!(obj_is_bitcode);\n-        target_option_val!(obj_needs_as);\n+        target_option_val!(no_integrated_as);\n         target_option_val!(max_atomic_width);\n         target_option_val!(panic_strategy);\n "}, {"sha": "48bf490d685b10ce58f70d678f2b0ed91ba6b8bb", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a6a247798619cf513fcab2421bade4dc99994e67/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a247798619cf513fcab2421bade4dc99994e67/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=a6a247798619cf513fcab2421bade4dc99994e67", "patch": "@@ -1056,14 +1056,25 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n pub fn phase_5_run_llvm_passes(sess: &Session,\n                                trans: &trans::CrateTranslation,\n                                outputs: &OutputFilenames) -> CompileResult {\n-    if sess.opts.cg.no_integrated_as {\n+    if sess.opts.cg.no_integrated_as || sess.target.target.options.no_integrated_as {\n         let output_types = OutputTypes::new(&[(OutputType::Assembly, None)]);\n         time(sess.time_passes(),\n              \"LLVM passes\",\n              || write::run_passes(sess, trans, &output_types, outputs));\n \n         write::run_assembler(sess, outputs);\n \n+        // HACK the linker expects the object file to be named foo.0.o but\n+        // `run_assembler` produces an object named just foo.o. Rename it if we\n+        // are going to build an executable\n+        if sess.opts.output_types.contains_key(&OutputType::Exe) {\n+            let f = outputs.path(OutputType::Object);\n+            fs::copy(&f,\n+                     f.with_file_name(format!(\"{}.0.o\",\n+                                              f.file_stem().unwrap().to_string_lossy()))).unwrap();\n+            fs::remove_file(f).unwrap();\n+        }\n+\n         // Remove assembly source, unless --save-temps was specified\n         if !sess.opts.cg.save_temps {\n             fs::remove_file(&outputs.temp_path(OutputType::Assembly, None)).unwrap();"}, {"sha": "9012914deeb091f5b51c7bceae2bd987b6e64b39", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 7, "deletions": 76, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/a6a247798619cf513fcab2421bade4dc99994e67/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a247798619cf513fcab2421bade4dc99994e67/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=a6a247798619cf513fcab2421bade4dc99994e67", "patch": "@@ -26,9 +26,6 @@ use errors::emitter::Emitter;\n use syntax_pos::MultiSpan;\n use context::{is_pie_binary, get_reloc_model};\n \n-use std::ascii;\n-use std::char;\n-use std::process::Command;\n use std::ffi::{CStr, CString};\n use std::fs;\n use std::path::{Path, PathBuf};\n@@ -265,9 +262,6 @@ pub struct ModuleConfig {\n     // make the object file bitcode. Provides easy compatibility with\n     // emscripten's ecc compiler, when used as the linker.\n     obj_is_bitcode: bool,\n-    // LLVM can't produce object files for MSP430. Instead, we'll make LLVM emit\n-    // assembly and then use `msp430-as` to turn that assembly into an object file\n-    obj_needs_as: bool,\n }\n \n unsafe impl Send for ModuleConfig { }\n@@ -287,7 +281,6 @@ impl ModuleConfig {\n             emit_asm: false,\n             emit_obj: false,\n             obj_is_bitcode: false,\n-            obj_needs_as: false,\n \n             no_verify: false,\n             no_prepopulate_passes: false,\n@@ -307,7 +300,6 @@ impl ModuleConfig {\n         self.time_passes = sess.time_passes();\n         self.inline_threshold = sess.opts.cg.inline_threshold;\n         self.obj_is_bitcode = sess.target.target.options.obj_is_bitcode;\n-        self.obj_needs_as = sess.target.target.options.obj_needs_as;\n \n         // Copy what clang does by turning on loop vectorization at O2 and\n         // slp vectorization at O3. Otherwise configure other optimization aspects\n@@ -565,13 +557,10 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n     // machine code, instead copy the .o file from the .bc\n     let write_bc = config.emit_bc || config.obj_is_bitcode;\n     let rm_bc = !config.emit_bc && config.obj_is_bitcode;\n-    let write_asm = config.emit_asm || config.obj_needs_as;\n-    let rm_asm = !config.emit_obj && config.obj_needs_as;\n     let write_obj = config.emit_obj && !config.obj_is_bitcode;\n     let copy_bc_to_obj = config.emit_obj && config.obj_is_bitcode;\n \n     let bc_out = output_names.temp_path(OutputType::Bitcode, module_name);\n-    let asm_out = output_names.temp_path(OutputType::Assembly, module_name);\n     let obj_out = output_names.temp_path(OutputType::Object, module_name);\n \n     if write_bc {\n@@ -589,25 +578,27 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n             })\n         }\n \n-        if write_asm {\n+        if config.emit_asm {\n+            let path = output_names.temp_path(OutputType::Assembly, module_name);\n+\n             // We can't use the same module for asm and binary output, because that triggers\n             // various errors like invalid IR or broken binaries, so we might have to clone the\n             // module to produce the asm output\n-            let llmod = if config.emit_obj && !config.obj_needs_as {\n+            let llmod = if config.emit_obj {\n                 llvm::LLVMCloneModule(llmod)\n             } else {\n                 llmod\n             };\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                write_output_file(cgcx.handler, tm, cpm, llmod, &asm_out,\n+                write_output_file(cgcx.handler, tm, cpm, llmod, &path,\n                                   llvm::FileType::AssemblyFile);\n             });\n-            if config.emit_obj && !config.obj_needs_as {\n+            if config.emit_obj {\n                 llvm::LLVMDisposeModule(llmod);\n             }\n         }\n \n-        if write_obj && !config.obj_needs_as {\n+        if write_obj {\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 write_output_file(cgcx.handler, tm, cpm, llmod, &obj_out,\n                                   llvm::FileType::ObjectFile);\n@@ -622,73 +613,13 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n         }\n     }\n \n-    if config.obj_needs_as {\n-        // XXX most of the logic here has been copied from the link_natively\n-        // function (src/librustc_trans/back/link.rs)\n-        // TODO don't hardcode, maybe expose as a `as` field in the target\n-        // specification\n-        // TODO how to properly access `sess` here?\n-        let mut cmd = Command::new(\"msp430-as\");\n-        cmd.arg(\"-o\");\n-        cmd.arg(obj_out);\n-        cmd.arg(&asm_out);\n-\n-        info!(\"{:?}\", &cmd);\n-        // let prog = time(sess.time_passes(), \"running assembler\",\n-        //                 || cmd.output());\n-        let prog = cmd.output();\n-        match prog {\n-            Ok(prog) => {\n-                fn escape_string(s: &[u8]) -> String {\n-                    str::from_utf8(s).map(|s| s.to_owned())\n-                        .unwrap_or_else(|_| {\n-                            let mut x = \"Non-UTF-8 output: \".to_string();\n-                            x.extend(s.iter()\n-                                     .flat_map(|&b| ascii::escape_default(b))\n-                                     .map(|b| char::from_u32(b as u32).unwrap()));\n-                            x\n-                        })\n-                }\n-                if !prog.status.success() {\n-                    let mut output = prog.stderr.clone();\n-                    output.extend_from_slice(&prog.stdout);\n-                    // sess.struct_err(&format!(\"assembling with `msp430-as` failed: {}\",\n-                    //                          prog.status))\n-                    //     .note(&format!(\"{:?}\", &cmd))\n-                    //     .note(&escape_string(&output[..]))\n-                    //     .emit();\n-                    // sess.abort_if_errors();\n-                }\n-                info!(\"linker stderr:\\n{}\", escape_string(&prog.stderr[..]));\n-                info!(\"linker stdout:\\n{}\", escape_string(&prog.stdout[..]));\n-            },\n-            Err(_) => {\n-                // sess.struct_err(&format!(\"could not exec the assembler `msp430-as`: {}\", e))\n-                //     .note(&format!(\"{:?}\", &cmd))\n-                //     .emit();\n-                // if e.kind() == io::ErrorKind::NotFound {\n-                //     sess.note_without_error(\"MSP430 targets depend on the MSP430 assembler \\\n-                //                              but `msp430-as` was not found\");\n-                // }\n-                // sess.abort_if_errors();\n-            },\n-        }\n-    }\n-\n     if rm_bc {\n         debug!(\"removing_bitcode {:?}\", bc_out);\n         if let Err(e) = fs::remove_file(&bc_out) {\n             cgcx.handler.err(&format!(\"failed to remove bitcode: {}\", e));\n         }\n     }\n \n-    if rm_asm {\n-        debug!(\"removing_assembly {:?}\", bc_out);\n-        if let Err(e) = fs::remove_file(&asm_out) {\n-            cgcx.handler.err(&format!(\"failed to remove assembly: {}\", e));\n-        }\n-    }\n-\n     llvm::LLVMRustDisposeTargetMachine(tm);\n }\n "}]}