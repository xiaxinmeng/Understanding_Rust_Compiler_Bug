{"sha": "4fd361343449bcdf7af4642851dc5dbf772f1a68", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmZDM2MTM0MzQ0OWJjZGY3YWY0NjQyODUxZGM1ZGJmNzcyZjFhNjg=", "commit": {"author": {"name": "Pascal Hertleif", "email": "killercup@gmail.com", "date": "2019-02-11T16:18:27Z"}, "committer": {"name": "Pascal Hertleif", "email": "killercup@gmail.com", "date": "2019-02-12T14:02:57Z"}, "message": "Fix some typos", "tree": {"sha": "eacf6870c6fab537d787bc2764901028ce595f0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eacf6870c6fab537d787bc2764901028ce595f0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4fd361343449bcdf7af4642851dc5dbf772f1a68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4fd361343449bcdf7af4642851dc5dbf772f1a68", "html_url": "https://github.com/rust-lang/rust/commit/4fd361343449bcdf7af4642851dc5dbf772f1a68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4fd361343449bcdf7af4642851dc5dbf772f1a68/comments", "author": {"login": "killercup", "id": 20063, "node_id": "MDQ6VXNlcjIwMDYz", "avatar_url": "https://avatars.githubusercontent.com/u/20063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killercup", "html_url": "https://github.com/killercup", "followers_url": "https://api.github.com/users/killercup/followers", "following_url": "https://api.github.com/users/killercup/following{/other_user}", "gists_url": "https://api.github.com/users/killercup/gists{/gist_id}", "starred_url": "https://api.github.com/users/killercup/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killercup/subscriptions", "organizations_url": "https://api.github.com/users/killercup/orgs", "repos_url": "https://api.github.com/users/killercup/repos", "events_url": "https://api.github.com/users/killercup/events{/privacy}", "received_events_url": "https://api.github.com/users/killercup/received_events", "type": "User", "site_admin": false}, "committer": {"login": "killercup", "id": 20063, "node_id": "MDQ6VXNlcjIwMDYz", "avatar_url": "https://avatars.githubusercontent.com/u/20063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killercup", "html_url": "https://github.com/killercup", "followers_url": "https://api.github.com/users/killercup/followers", "following_url": "https://api.github.com/users/killercup/following{/other_user}", "gists_url": "https://api.github.com/users/killercup/gists{/gist_id}", "starred_url": "https://api.github.com/users/killercup/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killercup/subscriptions", "organizations_url": "https://api.github.com/users/killercup/orgs", "repos_url": "https://api.github.com/users/killercup/repos", "events_url": "https://api.github.com/users/killercup/events{/privacy}", "received_events_url": "https://api.github.com/users/killercup/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a36e310229f13d6959d6ce95c99b659700cefc9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a36e310229f13d6959d6ce95c99b659700cefc9a", "html_url": "https://github.com/rust-lang/rust/commit/a36e310229f13d6959d6ce95c99b659700cefc9a"}], "stats": {"total": 134, "additions": 69, "deletions": 65}, "files": [{"sha": "7bd9b5ae6cddd0f73cd4cbd72f00e0188b425da1", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=4fd361343449bcdf7af4642851dc5dbf772f1a68", "patch": "@@ -1,4 +1,4 @@\n-//! `ra_assits` crate provides a bunch of code assists, aslo known as code\n+//! `ra_assits` crate provides a bunch of code assists, also known as code\n //! actions (in LSP) or intentions (in IntelliJ).\n //!\n //! An assist is a micro-refactoring, which is automatically activated in"}, {"sha": "2bed270a1323b598ae08676b74d203425b246034", "filename": "crates/ra_assists/src/remove_dbg.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_assists%2Fsrc%2Fremove_dbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_assists%2Fsrc%2Fremove_dbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fremove_dbg.rs?ref=4fd361343449bcdf7af4642851dc5dbf772f1a68", "patch": "@@ -17,9 +17,9 @@ pub(crate) fn remove_dbg(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist>\n \n     let macro_range = macro_call.syntax().range();\n \n-    // If the cursor is inside the macrocall, we'll try to maintain\n-    // the cursor position by subtracting the length of dbg!( from the start\n-    // of the filerange, otherwise we'll default to using the start of the macrocall\n+    // If the cursor is inside the macro call, we'll try to maintain the cursor\n+    // position by subtracting the length of dbg!( from the start of the file\n+    // range, otherwise we'll default to using the start of the macro call\n     let cursor_pos = {\n         let file_range = ctx.frange.range;\n \n@@ -61,7 +61,7 @@ fn is_valid_macrocall(macro_call: &ast::MacroCall, macro_name: &str) -> Option<b\n     let path = macro_call.path()?;\n     let name_ref = path.segment()?.name_ref()?;\n \n-    // Make sure it is actually a dbg-macrocall, dbg followed by !\n+    // Make sure it is actually a dbg-macro call, dbg followed by !\n     let excl = path.syntax().next_sibling()?;\n \n     if name_ref.text() != macro_name || excl.kind() != EXCL {"}, {"sha": "7420a1976f49a465d7cf0a79e3dd6551d4c03dbb", "filename": "crates/ra_db/src/cancellation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_db%2Fsrc%2Fcancellation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_db%2Fsrc%2Fcancellation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Fcancellation.rs?ref=4fd361343449bcdf7af4642851dc5dbf772f1a68", "patch": "@@ -15,7 +15,7 @@\n //! any background processing (this bit is handled by salsa, see the\n //! `BaseDatabase::check_canceled` method).\n \n-/// An \"error\" signifing that the operation was canceled.\n+/// An \"error\" signifying that the operation was canceled.\n #[derive(Clone, PartialEq, Eq, Hash)]\n pub struct Canceled {\n     _private: (),"}, {"sha": "2ac05c8366f2b4192debca448fb5b7ea88cd4226", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=4fd361343449bcdf7af4642851dc5dbf772f1a68", "patch": "@@ -134,7 +134,7 @@ impl Module {\n \n     /// Topmost parent of this module. Every module has a `crate_root`, but some\n     /// might be missing `krate`. This can happen if a module's file is not included\n-    /// in the module tree of any target in Cargo.toml.\n+    /// in the module tree of any target in `Cargo.toml`.\n     pub fn crate_root(&self, db: &impl PersistentHirDatabase) -> Module {\n         self.crate_root_impl(db)\n     }\n@@ -351,7 +351,7 @@ impl Enum {\n         db.type_for_def((*self).into())\n     }\n \n-    // TODO move to a more general type\n+    // TODO: move to a more general type\n     /// Builds a resolver for type references inside this struct.\n     pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n         // take the outer scope...\n@@ -495,7 +495,7 @@ impl Function {\n         db.generic_params((*self).into())\n     }\n \n-    // TODO move to a more general type for 'body-having' items\n+    // TODO: move to a more general type for 'body-having' items\n     /// Builds a resolver for code inside this item.\n     pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n         // take the outer scope..."}, {"sha": "bb8d50db8ced7cab0bb9445028a00436cbdd63f8", "filename": "crates/ra_hir/src/expr/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs?ref=4fd361343449bcdf7af4642851dc5dbf772f1a68", "patch": "@@ -84,7 +84,7 @@ impl ExprScopes {\n     fn add_bindings(&mut self, body: &Body, scope: ScopeId, pat: PatId) {\n         match &body[pat] {\n             Pat::Bind { name, .. } => {\n-                // bind can have a subpattern, but it's actually not allowed\n+                // bind can have a sub pattern, but it's actually not allowed\n                 // to bind to things in there\n                 let entry = ScopeEntry { name: name.clone(), pat };\n                 self.scopes[scope].entries.push(entry)"}, {"sha": "8d81d5ebfe9aeb4991b154448197fb76362f72b9", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=4fd361343449bcdf7af4642851dc5dbf772f1a68", "patch": "@@ -46,24 +46,24 @@ impl HirInterner {\n /// This module defines a bunch of ids we are using. The most important ones are\n /// probably `HirFileId` and `DefId`.\n \n-/// Input to the analyzer is a set of files, where each file is indentified by\n+/// Input to the analyzer is a set of files, where each file is identified by\n /// `FileId` and contains source code. However, another source of source code in\n /// Rust are macros: each macro can be thought of as producing a \"temporary\n /// file\". To assign an id to such a file, we use the id of the macro call that\n /// produced the file. So, a `HirFileId` is either a `FileId` (source code\n /// written by user), or a `MacroCallId` (source code produced by macro).\n ///\n-/// What is a `MacroCallId`? Simplifying, it's a `HirFileId` of a file containin\n-/// the call plus the offset of the macro call in the file. Note that this is a\n-/// recursive definition! However, the size_of of `HirFileId` is finite\n-/// (because everything bottoms out at the real `FileId`) and small\n+/// What is a `MacroCallId`? Simplifying, it's a `HirFileId` of a file\n+/// containing the call plus the offset of the macro call in the file. Note that\n+/// this is a recursive definition! However, the size_of of `HirFileId` is\n+/// finite (because everything bottoms out at the real `FileId`) and small\n /// (`MacroCallId` uses the location interner).\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct HirFileId(HirFileIdRepr);\n \n impl HirFileId {\n     /// For macro-expansion files, returns the file original source file the\n-    /// expansionoriginated from.\n+    /// expansion originated from.\n     pub fn original_file(self, db: &impl PersistentHirDatabase) -> FileId {\n         match self.0 {\n             HirFileIdRepr::File(file_id) => file_id,\n@@ -324,9 +324,9 @@ impl SourceFileItems {\n \n     fn init(&mut self, source_file: &SourceFile) {\n         // By walking the tree in bread-first order we make sure that parents\n-        // get lower ids then children. That is, addding a new child does not\n+        // get lower ids then children. That is, adding a new child does not\n         // change parent's id. This means that, say, adding a new function to a\n-        // trait does not chage ids of top-level items, which helps caching.\n+        // trait does not change ids of top-level items, which helps caching.\n         bfs(source_file.syntax(), |it| {\n             if let Some(module_item) = ast::ModuleItem::cast(it) {\n                 self.alloc(module_item.syntax());"}, {"sha": "ffb20d56432bc114626bf1d703963c56cd93467a", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=4fd361343449bcdf7af4642851dc5dbf772f1a68", "patch": "@@ -490,7 +490,7 @@ impl ItemMap {\n                 None => {\n                     // we still have path segments left, but the path so far\n                     // didn't resolve in the types namespace => no resolution\n-                    // (don't break here because curr_per_ns might contain\n+                    // (don't break here because `curr_per_ns` might contain\n                     // something in the value namespace, and it would be wrong\n                     // to return that)\n                     return (PerNs::none(), ReachedFixedPoint::No);"}, {"sha": "3cd496d7f53e22e4e801bc535f7a138b65954223", "filename": "crates/ra_hir/src/nameres/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs?ref=4fd361343449bcdf7af4642851dc5dbf772f1a68", "patch": "@@ -208,7 +208,7 @@ impl LoweredModule {\n                 }\n             }\n             ast::ModuleItemKind::Module(_) => {\n-                // modules are handled separately direclty by nameres\n+                // modules are handled separately directly by name res\n             }\n         };\n     }"}, {"sha": "8ed54607aa8d384115e10ad2deae5324aa90d0ab", "filename": "crates/ra_hir/src/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=4fd361343449bcdf7af4642851dc5dbf772f1a68", "patch": "@@ -97,7 +97,7 @@ impl Path {\n                 return Some(q);\n             }\n             // TODO: this bottom up traversal is not too precise.\n-            // Should we handle do a top-down analysiss, recording results?\n+            // Should we handle do a top-down analysis, recording results?\n             let use_tree_list = path.syntax().ancestors().find_map(ast::UseTreeList::cast)?;\n             let use_tree = use_tree_list.parent_use_tree();\n             use_tree.path()"}, {"sha": "2b94931c680d098af6d121a86a8b3792e9276962", "filename": "crates/ra_ide_api/src/completion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_ide_api%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_ide_api%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion.rs?ref=4fd361343449bcdf7af4642851dc5dbf772f1a68", "patch": "@@ -30,7 +30,7 @@ pub use crate::completion::completion_item::{CompletionItem, CompletionItemKind,\n /// incomplete and can look really weird.\n ///\n /// Once the context is collected, we run a series of completion routines which\n-/// look at the context and produce completion items. One subtelty about this\n+/// look at the context and produce completion items. One subtlety about this\n /// phase is that completion engine should not filter by the substring which is\n /// already present, it should give all possible variants for the identifier at\n /// the caret. In other words, for"}, {"sha": "4d6416284837c74b95396b6034e36519d60936fd", "filename": "crates/ra_ide_api/src/completion/complete_fn_param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs?ref=4fd361343449bcdf7af4642851dc5dbf772f1a68", "patch": "@@ -7,7 +7,7 @@ use rustc_hash::FxHashMap;\n \n use crate::completion::{CompletionContext, Completions, CompletionKind, CompletionItem};\n \n-/// Complete repeated parametes, both name and type. For example, if all\n+/// Complete repeated parameters, both name and type. For example, if all\n /// functions in a file have a `spam: &mut Spam` parameter, a completion with\n /// `spam: &mut Spam` insert text/label and `spam` lookup string will be\n /// suggested."}, {"sha": "96ed8c8e9f2e4b786195631414a256d0a184ac7d", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=4fd361343449bcdf7af4642851dc5dbf772f1a68", "patch": "@@ -93,10 +93,10 @@ pub(crate) fn reference_definition(\n                 return Exact(nav);\n             }\n             Some(Resolution::GenericParam(..)) => {\n-                // TODO go to the generic param def\n+                // TODO: go to the generic param def\n             }\n             Some(Resolution::SelfType(_impl_block)) => {\n-                // TODO go to the implemented type\n+                // TODO: go to the implemented type\n             }\n             None => {}\n         }\n@@ -133,8 +133,8 @@ mod tests {\n \n     use crate::mock_analysis::analysis_and_position;\n \n-    fn check_goto(fixuture: &str, expected: &str) {\n-        let (analysis, pos) = analysis_and_position(fixuture);\n+    fn check_goto(fixture: &str, expected: &str) {\n+        let (analysis, pos) = analysis_and_position(fixture);\n \n         let mut navs = analysis.goto_definition(pos).unwrap().unwrap().info;\n         assert_eq!(navs.len(), 1);"}, {"sha": "0888ab6de6a31d365b335c5cb070d1044efb0031", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=4fd361343449bcdf7af4642851dc5dbf772f1a68", "patch": "@@ -71,8 +71,8 @@ pub(crate) fn type_of(db: &RootDatabase, frange: FileRange) -> Option<String> {\n     }\n }\n \n-// FIXME: this should not really use navigation target. Rather, approximatelly\n-// resovled symbol should return a `DefId`.\n+// FIXME: this should not really use navigation target. Rather, approximately\n+// resolved symbol should return a `DefId`.\n fn doc_text_for(db: &RootDatabase, nav: NavigationTarget) -> Option<String> {\n     match (nav.description(db), nav.docs(db)) {\n         (Some(desc), Some(docs)) => Some(\"```rust\\n\".to_string() + &*desc + \"\\n```\\n\\n\" + &*docs),"}, {"sha": "681bd808dd50457a0e240ab5bf2e9c6113c00a34", "filename": "crates/ra_ide_api/src/impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs?ref=4fd361343449bcdf7af4642851dc5dbf772f1a68", "patch": "@@ -78,8 +78,8 @@ fn impls_for_trait(\n mod tests {\n     use crate::mock_analysis::analysis_and_position;\n \n-    fn check_goto(fixuture: &str, expected: &[&str]) {\n-        let (analysis, pos) = analysis_and_position(fixuture);\n+    fn check_goto(fixture: &str, expected: &[&str]) {\n+        let (analysis, pos) = analysis_and_position(fixture);\n \n         let navs = analysis.goto_implementation(pos).unwrap().unwrap().info;\n         assert_eq!(navs.len(), expected.len());"}, {"sha": "de3ec4e0acc13679e9b2570c3e1d4ba2d1cd4a33", "filename": "crates/ra_ide_api/src/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Flib.rs?ref=4fd361343449bcdf7af4642851dc5dbf772f1a68", "patch": "@@ -7,7 +7,7 @@\n //! However, IDE specific bits of the analysis (most notably completion) happen\n //! in this crate.\n //!\n-//! The sibling `ra_ide_api_light` handles thouse bits of IDE functionality\n+//! The sibling `ra_ide_api_light` handles those bits of IDE functionality\n //! which are restricted to a single file and need only syntax.\n \n // For proving that RootDatabase is RefUnwindSafe.\n@@ -67,7 +67,7 @@ pub use ra_db::{\n pub use hir::Documentation;\n \n // We use jemalloc mainly to get heap usage statistics, actual performance\n-// differnece is not measures.\n+// difference is not measures.\n #[cfg(feature = \"jemalloc\")]\n #[global_allocator]\n static ALLOC: jemallocator::Jemalloc = jemallocator::Jemalloc;\n@@ -221,12 +221,12 @@ impl Analysis {\n         self.db.line_index(file_id)\n     }\n \n-    /// Selects the next syntactic nodes encopasing the range.\n+    /// Selects the next syntactic nodes encompassing the range.\n     pub fn extend_selection(&self, frange: FileRange) -> Cancelable<TextRange> {\n         self.with_db(|db| extend_selection::extend_selection(db, frange))\n     }\n \n-    /// Returns position of the mathcing brace (all types of braces are\n+    /// Returns position of the matching brace (all types of braces are\n     /// supported).\n     pub fn matching_brace(&self, position: FilePosition) -> Option<TextUnit> {\n         let file = self.db.parse(position.file_id);\n@@ -316,7 +316,7 @@ impl Analysis {\n         self.with_db(|db| references::find_all_refs(db, position))\n     }\n \n-    /// Returns a short text descrbing element at position.\n+    /// Returns a short text describing element at position.\n     pub fn hover(&self, position: FilePosition) -> Cancelable<Option<RangeInfo<String>>> {\n         self.with_db(|db| hover::hover(db, position))\n     }"}, {"sha": "017ac5de30db35a783f465f8ff030ba10f43d397", "filename": "crates/ra_ide_api/src/mock_analysis.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_ide_api%2Fsrc%2Fmock_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_ide_api%2Fsrc%2Fmock_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fmock_analysis.rs?ref=4fd361343449bcdf7af4642851dc5dbf772f1a68", "patch": "@@ -18,7 +18,7 @@ impl MockAnalysis {\n     }\n     /// Creates `MockAnalysis` using a fixture data in the following format:\n     ///\n-    /// ```notrust\n+    /// ```rust,ignore\n     /// //- /main.rs\n     /// mod foo;\n     /// fn main() {}"}, {"sha": "ca145f3e4ff18adef212f11f264979514f47abae", "filename": "crates/ra_ide_api/src/references.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences.rs?ref=4fd361343449bcdf7af4642851dc5dbf772f1a68", "patch": "@@ -295,17 +295,17 @@ mod tests {\n     fn test_rename(text: &str, new_name: &str, expected: &str) {\n         let (analysis, position) = single_file_with_position(text);\n         let source_change = analysis.rename(position, new_name).unwrap();\n-        let mut text_edit_bulder = ra_text_edit::TextEditBuilder::default();\n+        let mut text_edit_builder = ra_text_edit::TextEditBuilder::default();\n         let mut file_id: Option<FileId> = None;\n         if let Some(change) = source_change {\n             for edit in change.source_file_edits {\n                 file_id = Some(edit.file_id);\n                 for atom in edit.edit.as_atoms() {\n-                    text_edit_bulder.replace(atom.delete, atom.insert.clone());\n+                    text_edit_builder.replace(atom.delete, atom.insert.clone());\n                 }\n             }\n         }\n-        let result = text_edit_bulder.finish().apply(&*analysis.file_text(file_id.unwrap()));\n+        let result = text_edit_builder.finish().apply(&*analysis.file_text(file_id.unwrap()));\n         assert_eq_text!(expected, &*result);\n     }\n }"}, {"sha": "15348124bc2a419531dbcc84208765592d94eaad", "filename": "crates/ra_ide_api/src/symbol_index.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_ide_api%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_ide_api%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsymbol_index.rs?ref=4fd361343449bcdf7af4642851dc5dbf772f1a68", "patch": "@@ -5,20 +5,20 @@\n //! symbols. The backbone of the index is the **awesome** `fst` crate by\n //! @BurntSushi.\n //!\n-//! In a nutshell, you give a set of strings to the `fst`, and it builds a\n+//! In a nutshell, you give a set of strings to `fst`, and it builds a\n //! finite state machine describing this set of strings. The strings which\n //! could fuzzy-match a pattern can also be described by a finite state machine.\n-//! What is freakingly cool is that you can now traverse both state machines in\n+//! What is freaking cool is that you can now traverse both state machines in\n //! lock-step to enumerate the strings which are both in the input set and\n //! fuzz-match the query. Or, more formally, given two languages described by\n-//! fsts, one can build an product fst which describes the intersection of the\n+//! FSTs, one can build a product FST which describes the intersection of the\n //! languages.\n //!\n //! `fst` does not support cheap updating of the index, but it supports unioning\n-//! of state machines. So, to account for changing source code, we build an fst\n-//! for each library (which is assumed to never change) and an fst for each rust\n+//! of state machines. So, to account for changing source code, we build an FST\n+//! for each library (which is assumed to never change) and an FST for each Rust\n //! file in the current workspace, and run a query against the union of all\n-//! those fsts.\n+//! those FSTs.\n use std::{\n     cmp::Ordering,\n     hash::{Hash, Hasher},"}, {"sha": "cdca3cafb22c32f1536aea6f624a536c565749ce", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=4fd361343449bcdf7af4642851dc5dbf772f1a68", "patch": "@@ -109,7 +109,7 @@ mod tests {\n \n     use super::*;\n \n-    // Good first issue (although a slightly chellegning one):\n+    // Good first issue (although a slightly challenging one):\n     //\n     // * Pick a random test from here\n     //   https://github.com/intellij-rust/intellij-rust/blob/c4e9feee4ad46e7953b1948c112533360b6087bb/src/test/kotlin/org/rust/lang/core/macros/RsMacroExpansionTest.kt\n@@ -171,8 +171,8 @@ impl_froms!(TokenTree: Leaf, Subtree);\n \n         let (invocation_tt, _) = ast_to_token_tree(macro_invocation.token_tree().unwrap()).unwrap();\n \n-        let expaned = rules.expand(&invocation_tt).unwrap();\n-        assert_eq!(expaned.to_string(), expansion);\n+        let expanded = rules.expand(&invocation_tt).unwrap();\n+        assert_eq!(expanded.to_string(), expansion);\n     }\n \n     #[test]"}, {"sha": "1acba86ea97df5751f1b87f6c6c2533246d7e6dd", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=4fd361343449bcdf7af4642851dc5dbf772f1a68", "patch": "@@ -58,7 +58,7 @@ fn expand_rule(rule: &crate::Rule, input: &tt::Subtree) -> Option<tt::Subtree> {\n ///\n /// The other side of the puzzle is `expand_subtree`, where we use the bindings\n /// to substitute meta variables in the output template. When expanding, we\n-/// maintain a `nesteing` stack of indicies whihc tells us which occurence from\n+/// maintain a `nesting` stack of indices which tells us which occurrence from\n /// the `Bindings` we should take. We push to the stack when we enter a\n /// repetition.\n ///"}, {"sha": "5866be51960d98b7a3ff02c8826f3b37aa165c80", "filename": "crates/ra_project_model/src/cargo_workspace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs?ref=4fd361343449bcdf7af4642851dc5dbf772f1a68", "patch": "@@ -12,7 +12,7 @@ use crate::Result;\n ///\n /// Note that internally, rust analyzer uses a different structure:\n /// `CrateGraph`. `CrateGraph` is lower-level: it knows only about the crates,\n-/// while this knows about `Pacakges` & `Targets`: purely cargo-related\n+/// while this knows about `Packages` & `Targets`: purely cargo-related\n /// concepts.\n #[derive(Debug, Clone)]\n pub struct CargoWorkspace {"}, {"sha": "3952b200b7da751439ad589f835a40a9eb2b2e96", "filename": "crates/ra_vfs/src/io.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_vfs%2Fsrc%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_vfs%2Fsrc%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Fio.rs?ref=4fd361343449bcdf7af4642851dc5dbf772f1a68", "patch": "@@ -169,7 +169,7 @@ fn convert_notify_event(event: DebouncedEvent, sender: &Sender<(PathBuf, ChangeK\n             // ignore\n         }\n         DebouncedEvent::Rescan => {\n-            // TODO rescan all roots\n+            // TODO: rescan all roots\n         }\n         DebouncedEvent::Create(path) => {\n             sender.send((path, ChangeKind::Create)).unwrap();\n@@ -185,7 +185,7 @@ fn convert_notify_event(event: DebouncedEvent, sender: &Sender<(PathBuf, ChangeK\n             sender.send((dst, ChangeKind::Create)).unwrap();\n         }\n         DebouncedEvent::Error(err, path) => {\n-            // TODO should we reload the file contents?\n+            // TODO: should we reload the file contents?\n             log::warn!(\"watcher error \\\"{}\\\", {:?}\", err, path);\n         }\n     }"}, {"sha": "3dd05197e1a53017678f1380f4c507ad5c34c253", "filename": "crates/ra_vfs/src/lib.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_vfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fra_vfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Flib.rs?ref=4fd361343449bcdf7af4642851dc5dbf772f1a68", "patch": "@@ -7,8 +7,10 @@\n //!\n //! It is also responsible for watching the disk for changes, and for merging\n //! editor state (modified, unsaved files) with disk state.\n-//! TODO: Some LSP clients support watching the disk, so this crate should\n-//! to support custom watcher events (related to https://github.com/rust-analyzer/rust-analyzer/issues/131)\n+//!\n+//! TODO: Some LSP clients support watching the disk, so this crate should to\n+//! support custom watcher events (related to\n+//! <https://github.com/rust-analyzer/rust-analyzer/issues/131>)\n //!\n //! VFS is based on a concept of roots: a set of directories on the file system\n //! which are watched for changes. Typically, there will be a root for each\n@@ -212,12 +214,12 @@ impl Vfs {\n                 let mut cur_files = Vec::new();\n                 // While we were scanning the root in the background, a file might have\n                 // been open in the editor, so we need to account for that.\n-                let exising = self.root2files[root]\n+                let existing = self.root2files[root]\n                     .iter()\n                     .map(|&file| (self.files[file].path.clone(), file))\n                     .collect::<FxHashMap<_, _>>();\n                 for (path, text) in files {\n-                    if let Some(&file) = exising.get(&path) {\n+                    if let Some(&file) = existing.get(&path) {\n                         let text = Arc::clone(&self.files[file].text);\n                         cur_files.push((file, path, text));\n                         continue;\n@@ -322,7 +324,7 @@ impl Vfs {\n         mem::replace(&mut self.pending_changes, Vec::new())\n     }\n \n-    /// Sutdown the VFS and terminate the background watching thread.\n+    /// Shutdown the VFS and terminate the background watching thread.\n     pub fn shutdown(self) -> thread::Result<()> {\n         self.worker.shutdown()\n     }\n@@ -347,7 +349,7 @@ impl Vfs {\n     }\n \n     fn remove_file(&mut self, file: VfsFile) {\n-        //FIXME: use arena with removal\n+        // FIXME: use arena with removal\n         self.files[file].text = Default::default();\n         self.files[file].path = Default::default();\n         let root = self.files[file].root;"}, {"sha": "4d83af00ca9d6f19e179630116419952b64e339d", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=4fd361343449bcdf7af4642851dc5dbf772f1a68", "patch": "@@ -113,9 +113,9 @@ pub struct FixtureEntry {\n     pub text: String,\n }\n \n-/// Parses text wich looks like this:\n+/// Parses text which looks like this:\n ///\n-///  ```notrust\n+///  ```rust,ignore\n ///  //- some meta\n ///  line 1\n ///  line 2"}, {"sha": "10743292616ac7052e25bffbda6ecaa22065650a", "filename": "crates/test_utils/src/marks.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Ftest_utils%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Ftest_utils%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Fmarks.rs?ref=4fd361343449bcdf7af4642851dc5dbf772f1a68", "patch": "@@ -1,10 +1,10 @@\n //! This module implements manually tracked test coverage, which useful for\n //! quickly finding a test responsible for testing a particular bit of code.\n //!\n-//! See https://matklad.github.io/2018/06/18/a-trick-for-test-maintenance.html\n+//! See <https://matklad.github.io/2018/06/18/a-trick-for-test-maintenance.html>\n //! for details, but the TL;DR is that you write your test as\n //!\n-//! ```no-run\n+//! ```rust,no_run\n //! #[test]\n //! fn test_foo() {\n //!     covers!(test_foo);\n@@ -13,7 +13,9 @@\n //!\n //! and in the code under test you write\n //!\n-//! ```no-run\n+//! ```rust,no_run\n+//! # use test_utils::tested_by;\n+//! # fn some_condition() -> bool { true }\n //! fn foo() {\n //!     if some_condition() {\n //!         tested_by!(test_foo);"}, {"sha": "a522a0843d639bb15db88e80cc0cb06a764f58f3", "filename": "crates/thread_worker/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fthread_worker%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd361343449bcdf7af4642851dc5dbf772f1a68/crates%2Fthread_worker%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fthread_worker%2Fsrc%2Flib.rs?ref=4fd361343449bcdf7af4642851dc5dbf772f1a68", "patch": "@@ -65,7 +65,7 @@ impl WorkerHandle {\n     }\n }\n \n-/// Sets up worker channels in a deadlock-avoind way.\n+/// Sets up worker channels in a deadlock-avoiding way.\n /// If one sets both input and output buffers to a fixed size,\n /// a worker might get stuck.\n fn worker_chan<I, O>(buf: usize) -> (Worker<I, O>, Receiver<I>, Sender<O>) {"}]}