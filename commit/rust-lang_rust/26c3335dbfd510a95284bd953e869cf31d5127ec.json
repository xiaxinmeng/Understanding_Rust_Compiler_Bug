{"sha": "26c3335dbfd510a95284bd953e869cf31d5127ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2YzMzMzVkYmZkNTEwYTk1Mjg0YmQ5NTNlODY5Y2YzMWQ1MTI3ZWM=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-03-22T12:13:52Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-03-22T12:13:52Z"}, "message": "Closures work again", "tree": {"sha": "88c1dcb2bf0a01ac6ab4fc91349748a0a348e709", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88c1dcb2bf0a01ac6ab4fc91349748a0a348e709"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26c3335dbfd510a95284bd953e869cf31d5127ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26c3335dbfd510a95284bd953e869cf31d5127ec", "html_url": "https://github.com/rust-lang/rust/commit/26c3335dbfd510a95284bd953e869cf31d5127ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26c3335dbfd510a95284bd953e869cf31d5127ec/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc1b0fb436da6d7e391e14b3a98cd5f96b2726bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc1b0fb436da6d7e391e14b3a98cd5f96b2726bb", "html_url": "https://github.com/rust-lang/rust/commit/dc1b0fb436da6d7e391e14b3a98cd5f96b2726bb"}], "stats": {"total": 373, "additions": 352, "deletions": 21}, "files": [{"sha": "1ec690e620493f5977af066ed152ac479c9bd95d", "filename": "src/eval_context.rs", "status": "modified", "additions": 258, "deletions": 1, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/26c3335dbfd510a95284bd953e869cf31d5127ec/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26c3335dbfd510a95284bd953e869cf31d5127ec/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=26c3335dbfd510a95284bd953e869cf31d5127ec", "patch": "@@ -10,8 +10,11 @@ use rustc::traits::Reveal;\n use rustc::ty::layout::{self, Layout, Size};\n use rustc::ty::subst::{Subst, Substs, Kind};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable, Binder};\n+use rustc::traits;\n use rustc_data_structures::indexed_vec::Idx;\n-use syntax::codemap::{self, DUMMY_SP};\n+use syntax::codemap::{self, DUMMY_SP, Span};\n+use syntax::ast;\n+use syntax::abi::Abi;\n \n use error::{EvalError, EvalResult};\n use lvalue::{Global, GlobalId, Lvalue, LvalueExtra};\n@@ -1701,3 +1704,257 @@ fn needs_fn_once_adapter_shim(actual_closure_kind: ty::ClosureKind,\n         _ => Err(()),\n     }\n }\n+\n+/// The point where linking happens. Resolve a (def_id, substs)\n+/// pair to an instance.\n+pub fn resolve<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    def_id: DefId,\n+    substs: &'tcx Substs<'tcx>\n+) -> ty::Instance<'tcx> {\n+    debug!(\"resolve(def_id={:?}, substs={:?})\",\n+           def_id, substs);\n+    let result = if let Some(trait_def_id) = tcx.trait_of_item(def_id) {\n+        debug!(\" => associated item, attempting to find impl\");\n+        let item = tcx.associated_item(def_id);\n+        resolve_associated_item(tcx, &item, trait_def_id, substs)\n+    } else {\n+        let item_type = def_ty(tcx, def_id, substs);\n+        let def = match item_type.sty {\n+            ty::TyFnDef(_, _, f) if\n+                f.abi() == Abi::RustIntrinsic ||\n+                f.abi() == Abi::PlatformIntrinsic =>\n+            {\n+                debug!(\" => intrinsic\");\n+                ty::InstanceDef::Intrinsic(def_id)\n+            }\n+            _ => {\n+                if Some(def_id) == tcx.lang_items.drop_in_place_fn() {\n+                    let ty = substs.type_at(0);\n+                    if needs_drop_glue(tcx, ty) {\n+                        debug!(\" => nontrivial drop glue\");\n+                        ty::InstanceDef::DropGlue(def_id, Some(ty))\n+                    } else {\n+                        debug!(\" => trivial drop glue\");\n+                        ty::InstanceDef::DropGlue(def_id, None)\n+                    }\n+                } else {\n+                    debug!(\" => free item\");\n+                    ty::InstanceDef::Item(def_id)\n+                }\n+            }\n+        };\n+        ty::Instance { def, substs }\n+    };\n+    debug!(\"resolve(def_id={:?}, substs={:?}) = {}\",\n+           def_id, substs, result);\n+    result\n+}\n+\n+pub fn needs_drop_glue<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, t: Ty<'tcx>) -> bool {\n+    assert!(t.is_normalized_for_trans());\n+\n+    let t = tcx.erase_regions(&t);\n+\n+    // FIXME (#22815): note that type_needs_drop conservatively\n+    // approximates in some cases and may say a type expression\n+    // requires drop glue when it actually does not.\n+    //\n+    // (In this case it is not clear whether any harm is done, i.e.\n+    // erroneously returning `true` in some cases where we could have\n+    // returned `false` does not appear unsound. The impact on\n+    // code quality is unknown at this time.)\n+\n+    let env = tcx.empty_parameter_environment();\n+    if !tcx.type_needs_drop_given_env(t, &env) {\n+        return false;\n+    }\n+    match t.sty {\n+        ty::TyAdt(def, _) if def.is_box() => {\n+            let typ = t.boxed_ty();\n+            if !tcx.type_needs_drop_given_env(typ, &env) && type_is_sized(tcx, typ) {\n+                tcx.infer_ctxt((), traits::Reveal::All).enter(|infcx| {\n+                    let layout = t.layout(&infcx).unwrap();\n+                    if layout.size(&tcx.data_layout).bytes() == 0 {\n+                        // `Box<ZeroSizeType>` does not allocate.\n+                        false\n+                    } else {\n+                        true\n+                    }\n+                })\n+            } else {\n+                true\n+            }\n+        }\n+        _ => true\n+    }\n+}\n+\n+fn resolve_associated_item<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    trait_item: &ty::AssociatedItem,\n+    trait_id: DefId,\n+    rcvr_substs: &'tcx Substs<'tcx>\n+) -> ty::Instance<'tcx> {\n+    let def_id = trait_item.def_id;\n+    debug!(\"resolve_associated_item(trait_item={:?}, \\\n+                                    trait_id={:?}, \\\n+                                    rcvr_substs={:?})\",\n+           def_id, trait_id, rcvr_substs);\n+\n+    let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n+    let vtbl = fulfill_obligation(tcx, DUMMY_SP, ty::Binder(trait_ref));\n+\n+    // Now that we know which impl is being used, we can dispatch to\n+    // the actual function:\n+    match vtbl {\n+        ::rustc::traits::VtableImpl(impl_data) => {\n+            let (def_id, substs) = ::rustc::traits::find_associated_item(\n+                tcx, trait_item, rcvr_substs, &impl_data);\n+            let substs = tcx.erase_regions(&substs);\n+            ty::Instance::new(def_id, substs)\n+        }\n+        ::rustc::traits::VtableClosure(closure_data) => {\n+            let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n+            resolve_closure(tcx, closure_data.closure_def_id, closure_data.substs,\n+                            trait_closure_kind)\n+        }\n+        ::rustc::traits::VtableFnPointer(ref data) => {\n+            ty::Instance {\n+                def: ty::InstanceDef::FnPtrShim(trait_item.def_id, data.fn_ty),\n+                substs: rcvr_substs\n+            }\n+        }\n+        ::rustc::traits::VtableObject(ref data) => {\n+            let index = tcx.get_vtable_index_of_object_method(data, def_id);\n+            ty::Instance {\n+                def: ty::InstanceDef::Virtual(def_id, index),\n+                substs: rcvr_substs\n+            }\n+        }\n+        _ => {\n+            bug!(\"static call to invalid vtable: {:?}\", vtbl)\n+        }\n+    }\n+}\n+\n+pub fn def_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                        def_id: DefId,\n+                        substs: &'tcx Substs<'tcx>)\n+                        -> Ty<'tcx>\n+{\n+    let ty = tcx.item_type(def_id);\n+    apply_param_substs(tcx, substs, &ty)\n+}\n+\n+/// Monomorphizes a type from the AST by first applying the in-scope\n+/// substitutions and then normalizing any associated types.\n+pub fn apply_param_substs<'a, 'tcx, T>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                       param_substs: &Substs<'tcx>,\n+                                       value: &T)\n+                                       -> T\n+    where T: ::rustc::infer::TransNormalize<'tcx>\n+{\n+    debug!(\"apply_param_substs(param_substs={:?}, value={:?})\", param_substs, value);\n+    let substituted = value.subst(tcx, param_substs);\n+    let substituted = tcx.erase_regions(&substituted);\n+    AssociatedTypeNormalizer{ tcx }.fold(&substituted)\n+}\n+\n+\n+struct AssociatedTypeNormalizer<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+}\n+\n+impl<'a, 'tcx> AssociatedTypeNormalizer<'a, 'tcx> {\n+    fn fold<T: TypeFoldable<'tcx>>(&mut self, value: &T) -> T {\n+        if !value.has_projection_types() {\n+            value.clone()\n+        } else {\n+            value.fold_with(self)\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> ::rustc::ty::fold::TypeFolder<'tcx, 'tcx> for AssociatedTypeNormalizer<'a, 'tcx> {\n+    fn tcx<'c>(&'c self) -> TyCtxt<'c, 'tcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        if !ty.has_projection_types() {\n+            ty\n+        } else {\n+            self.tcx.normalize_associated_type(&ty)\n+        }\n+    }\n+}\n+\n+fn type_is_sized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n+    // generics are weird, don't run this function on a generic\n+    assert!(!ty.needs_subst());\n+    ty.is_sized(tcx, &tcx.empty_parameter_environment(), DUMMY_SP)\n+}\n+\n+/// Attempts to resolve an obligation. The result is a shallow vtable resolution -- meaning that we\n+/// do not (necessarily) resolve all nested obligations on the impl. Note that type check should\n+/// guarantee to us that all nested obligations *could be* resolved if we wanted to.\n+fn fulfill_obligation<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                span: Span,\n+                                trait_ref: ty::PolyTraitRef<'tcx>)\n+                                -> traits::Vtable<'tcx, ()>\n+{\n+    // Remove any references to regions; this helps improve caching.\n+    let trait_ref = tcx.erase_regions(&trait_ref);\n+\n+    debug!(\"trans::fulfill_obligation(trait_ref={:?}, def_id={:?})\",\n+            trait_ref, trait_ref.def_id());\n+\n+    // Do the initial selection for the obligation. This yields the\n+    // shallow result we are looking for -- that is, what specific impl.\n+    tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n+        let mut selcx = traits::SelectionContext::new(&infcx);\n+\n+        let obligation_cause = traits::ObligationCause::misc(span,\n+                                                            ast::DUMMY_NODE_ID);\n+        let obligation = traits::Obligation::new(obligation_cause,\n+                                                    trait_ref.to_poly_trait_predicate());\n+\n+        let selection = match selcx.select(&obligation) {\n+            Ok(Some(selection)) => selection,\n+            Ok(None) => {\n+                // Ambiguity can happen when monomorphizing during trans\n+                // expands to some humongo type that never occurred\n+                // statically -- this humongo type can then overflow,\n+                // leading to an ambiguous result. So report this as an\n+                // overflow bug, since I believe this is the only case\n+                // where ambiguity can result.\n+                debug!(\"Encountered ambiguity selecting `{:?}` during trans, \\\n+                        presuming due to overflow\",\n+                        trait_ref);\n+                tcx.sess.span_fatal(span,\n+                    \"reached the recursion limit during monomorphization \\\n+                        (selection ambiguity)\");\n+            }\n+            Err(e) => {\n+                span_bug!(span, \"Encountered error `{:?}` selecting `{:?}` during trans\",\n+                            e, trait_ref)\n+            }\n+        };\n+\n+        debug!(\"fulfill_obligation: selection={:?}\", selection);\n+\n+        // Currently, we use a fulfillment context to completely resolve\n+        // all nested obligations. This is because they can inform the\n+        // inference of the impl's type parameters.\n+        let mut fulfill_cx = traits::FulfillmentContext::new();\n+        let vtable = selection.map(|predicate| {\n+            debug!(\"fulfill_obligation: register_predicate_obligation {:?}\", predicate);\n+            fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+        });\n+        let vtable = infcx.drain_fulfillment_cx_or_panic(span, &mut fulfill_cx, &vtable);\n+\n+        info!(\"Cache miss: {:?} => {:?}\", trait_ref, vtable);\n+        vtable\n+    })\n+}"}, {"sha": "8b5b88322e2e15a1eeee5644ddce83b0f1dd0862", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 94, "deletions": 20, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/26c3335dbfd510a95284bd953e869cf31d5127ec/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26c3335dbfd510a95284bd953e869cf31d5127ec/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=26c3335dbfd510a95284bd953e869cf31d5127ec", "patch": "@@ -1,6 +1,7 @@\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n use rustc::ty::{self, Ty};\n+use rustc::ty::layout::Layout;\n use syntax::codemap::Span;\n use syntax::attr;\n use syntax::abi::Abi;\n@@ -59,21 +60,44 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 };\n \n                 let func_ty = self.operand_ty(func);\n-                let fn_def = match func_ty.sty {\n-                    ty::TyFnPtr(_) => {\n+                let (fn_def, abi) = match func_ty.sty {\n+                    ty::TyFnPtr(sig) => {\n                         let fn_ptr = self.eval_operand_to_primval(func)?.to_ptr()?;\n-                        self.memory.get_fn(fn_ptr.alloc_id)?\n+                        (self.memory.get_fn(fn_ptr.alloc_id)?, sig.abi())\n                     },\n-                    ty::TyFnDef(def_id, substs, _) => ty::Instance::new(def_id, substs),\n+                    ty::TyFnDef(def_id, substs, sig) => (::eval_context::resolve(self.tcx, def_id, substs), sig.abi()),\n                     _ => {\n                         let msg = format!(\"can't handle callee of type {:?}\", func_ty);\n                         return Err(EvalError::Unimplemented(msg));\n                     }\n                 };\n-                self.eval_fn_call(fn_def, destination, args, terminator.source_info.span)?;\n+                self.eval_fn_call(fn_def, destination, args, terminator.source_info.span, abi)?;\n             }\n \n-            Drop { .. } => unreachable!(),\n+            Drop { ref location, target, .. } => {\n+                let lval = self.eval_lvalue(location)?;\n+\n+                let ty = self.lvalue_ty(location);\n+\n+                self.goto_block(target);\n+                let drop_in_place = self.tcx.lang_items.drop_in_place_fn().expect(\"drop_in_place lang item not available\");\n+                let env = self.tcx.empty_parameter_environment();\n+                let def = if self.tcx.type_needs_drop_given_env(ty, &env) {\n+                    ty::InstanceDef::DropGlue(drop_in_place, Some(ty))\n+                } else {\n+                    ty::InstanceDef::DropGlue(drop_in_place, None)\n+                };\n+                let substs = self.substs();\n+                let instance = ty::Instance { substs, def };\n+                let mir = self.load_mir(instance.def)?;\n+                self.push_stack_frame(\n+                    instance,\n+                    terminator.source_info.span,\n+                    mir,\n+                    Lvalue::from_ptr(Pointer::zst_ptr()),\n+                    StackPopCleanup::None,\n+                )?;\n+            }\n \n             Assert { ref cond, expected, ref msg, target, .. } => {\n                 let cond_val = self.eval_operand_to_primval(cond)?.to_bool()?;\n@@ -111,15 +135,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n         arg_operands: &[mir::Operand<'tcx>],\n         span: Span,\n+        abi: Abi,\n     ) -> EvalResult<'tcx> {\n-        let sig = match instance.def.def_ty(self.tcx).sty {\n-            ty::TyFnPtr(bare_sig) => bare_sig,\n-            ty::TyFnDef(_, _, fn_ty) => fn_ty,\n-            ref other => bug!(\"expected function or pointer, got {:?}\", other),\n-        };\n-        match sig.abi() {\n-            Abi::RustIntrinsic => {\n-                let sig = self.erase_lifetimes(&sig);\n+        trace!(\"eval_fn_call: {:#?}\", instance);\n+        match instance.def {\n+            ty::InstanceDef::Intrinsic(..) => {\n+                unimplemented!();\n+                /*let sig = self.erase_lifetimes(&sig);\n                 let ty = sig.output();\n                 let layout = self.type_layout(ty)?;\n                 let (ret, target) = match destination {\n@@ -128,9 +150,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 };\n                 self.call_intrinsic(instance, arg_operands, ret, ty, layout, target)?;\n                 self.dump_local(ret);\n-                Ok(())\n+                Ok(())*/\n             },\n-            Abi::C => {\n+            /*Abi::C => {\n                 let sig = self.erase_lifetimes(&sig);\n                 let ty = sig.output();\n                 let (ret, target) = destination.unwrap();\n@@ -142,22 +164,43 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.dump_local(ret);\n                 self.goto_block(target);\n                 Ok(())\n-            },\n-            Abi::Rust | Abi::RustCall => {\n+            },*/\n+            ty::InstanceDef::ClosureOnceShim{..} => {\n                 let mut args = Vec::new();\n                 for arg in arg_operands {\n                     let arg_val = self.eval_operand(arg)?;\n                     let arg_ty = self.operand_ty(arg);\n                     args.push((arg_val, arg_ty));\n                 }\n+                assert_eq!(abi, Abi::RustCall);\n+                self.eval_fn_call_inner(\n+                    instance,\n+                    destination,\n+                    args,\n+                    span,\n+                )\n+            }\n+            ty::InstanceDef::Item(_) => {\n+                let mut args = Vec::new();\n+                for arg in arg_operands {\n+                    let arg_val = self.eval_operand(arg)?;\n+                    let arg_ty = self.operand_ty(arg);\n+                    args.push((arg_val, arg_ty));\n+                }\n+                match abi {\n+                    Abi::C => unimplemented!(),\n+                    Abi::Rust => {},\n+                    Abi::RustCall => self.unpack_fn_args(&mut args)?,\n+                    _ => unimplemented!(),\n+                }\n                 self.eval_fn_call_inner(\n                     instance,\n                     destination,\n                     args,\n                     span,\n                 )\n             },\n-            other => Err(EvalError::Unimplemented(format!(\"can't handle function with {:?} ABI\", other))),\n+            _ => Err(EvalError::Unimplemented(format!(\"can't handle function with {:?} ABI\", abi))),\n         }\n     }\n \n@@ -168,7 +211,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         args: Vec<(Value, Ty<'tcx>)>,\n         span: Span,\n     ) -> EvalResult<'tcx> {\n-        trace!(\"eval_fn_call_inner: {:#?}, {:#?}\", args, destination);\n+        trace!(\"eval_fn_call_inner: {:#?}, {:#?}, {:#?}\", instance, args, destination);\n+\n+        // Only trait methods can have a Self parameter.\n \n         let mir = match self.load_mir(instance.def) {\n             Ok(mir) => mir,\n@@ -392,4 +437,33 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         // current frame.\n         Ok(())\n     }\n+\n+    pub(crate) fn unpack_fn_args(&self, args: &mut Vec<(Value, Ty<'tcx>)>) -> EvalResult<'tcx> {\n+        if let Some((last, last_ty)) = args.pop() {\n+            let last_layout = self.type_layout(last_ty)?;\n+            match (&last_ty.sty, last_layout) {\n+                (&ty::TyTuple(fields, _),\n+                 &Layout::Univariant { ref variant, .. }) => {\n+                    let offsets = variant.offsets.iter().map(|s| s.bytes());\n+                    match last {\n+                        Value::ByRef(last_ptr) => {\n+                            for (offset, ty) in offsets.zip(fields) {\n+                                let arg = Value::ByRef(last_ptr.offset(offset));\n+                                args.push((arg, ty));\n+                            }\n+                        },\n+                        // propagate undefs\n+                        undef @ Value::ByVal(PrimVal::Undef) => {\n+                            for field_ty in fields {\n+                                args.push((undef, field_ty));\n+                            }\n+                        },\n+                        _ => bug!(\"rust-call ABI tuple argument was {:?}, but {:?} were expected\", last, fields),\n+                    }\n+                }\n+                ty => bug!(\"expected tuple as last argument in function with 'rust-call' ABI, got {:?}\", ty),\n+            }\n+        }\n+        Ok(())\n+    }\n }"}]}