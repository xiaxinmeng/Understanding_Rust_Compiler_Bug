{"sha": "9b85e1cfa5aa2aaa4b5df4359a023ad793983ffc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliODVlMWNmYTVhYTJhYWE0YjVkZjQzNTlhMDIzYWQ3OTM5ODNmZmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-07T21:15:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-07T21:15:30Z"}, "message": "Auto merge of #42840 - arielb1:poison-smoke-and-mirrors, r=nikomatsakis\n\nReplace the global fulfillment cache with the evaluation cache\n\nThis uses the new \"Chalk\" ParamEnv refactoring to check \"global\" predicates in an empty environment, which should be correct because global predicates aren't affected by a consistent environment.\n\nFixes #39970.\nFixes #42796.\n\nr? @nikomatsakis", "tree": {"sha": "387e6830b4ff820d69c40f89a1886a6a7a8dfe81", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/387e6830b4ff820d69c40f89a1886a6a7a8dfe81"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b85e1cfa5aa2aaa4b5df4359a023ad793983ffc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b85e1cfa5aa2aaa4b5df4359a023ad793983ffc", "html_url": "https://github.com/rust-lang/rust/commit/9b85e1cfa5aa2aaa4b5df4359a023ad793983ffc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b85e1cfa5aa2aaa4b5df4359a023ad793983ffc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13157c4ebcca735a0842bd03c3dad1de7c429f9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/13157c4ebcca735a0842bd03c3dad1de7c429f9f", "html_url": "https://github.com/rust-lang/rust/commit/13157c4ebcca735a0842bd03c3dad1de7c429f9f"}, {"sha": "b7b965a3e7f65776fae71beb3bc625081b633563", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7b965a3e7f65776fae71beb3bc625081b633563", "html_url": "https://github.com/rust-lang/rust/commit/b7b965a3e7f65776fae71beb3bc625081b633563"}], "stats": {"total": 408, "additions": 239, "deletions": 169}, "files": [{"sha": "826d4a2815838bbb1c7ac9a059b91e50d3e08851", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 19, "deletions": 112, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/9b85e1cfa5aa2aaa4b5df4359a023ad793983ffc/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b85e1cfa5aa2aaa4b5df4359a023ad793983ffc/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=9b85e1cfa5aa2aaa4b5df4359a023ad793983ffc", "patch": "@@ -8,15 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use dep_graph::DepGraph;\n use infer::{InferCtxt, InferOk};\n-use ty::{self, Ty, TypeFoldable, ToPolyTraitRef, TyCtxt, ToPredicate};\n+use ty::{self, Ty, TypeFoldable, ToPolyTraitRef, ToPredicate};\n use ty::error::ExpectedFound;\n use rustc_data_structures::obligation_forest::{ObligationForest, Error};\n use rustc_data_structures::obligation_forest::{ForestObligation, ObligationProcessor};\n use std::marker::PhantomData;\n use syntax::ast;\n-use util::nodemap::{FxHashSet, NodeMap};\n+use util::nodemap::NodeMap;\n use hir::def_id::DefId;\n \n use super::CodeAmbiguity;\n@@ -34,11 +33,6 @@ impl<'tcx> ForestObligation for PendingPredicateObligation<'tcx> {\n     fn as_predicate(&self) -> &Self::Predicate { &self.obligation.predicate }\n }\n \n-pub struct GlobalFulfilledPredicates<'tcx> {\n-    set: FxHashSet<ty::PolyTraitPredicate<'tcx>>,\n-    dep_graph: DepGraph,\n-}\n-\n /// The fulfillment context is used to drive trait resolution.  It\n /// consists of a list of obligations that must be (eventually)\n /// satisfied. The job is to track which are satisfied, which yielded\n@@ -183,13 +177,6 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n \n         assert!(!infcx.is_in_snapshot());\n \n-        let tcx = infcx.tcx;\n-\n-        if tcx.fulfilled_predicates.borrow().check_duplicate(tcx, &obligation.predicate) {\n-            debug!(\"register_predicate_obligation: duplicate\");\n-            return\n-        }\n-\n         self.predicates.register_obligation(PendingPredicateObligation {\n             obligation,\n             stalled_on: vec![]\n@@ -264,13 +251,6 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n             });\n             debug!(\"select: outcome={:?}\", outcome);\n \n-            // these are obligations that were proven to be true.\n-            for pending_obligation in outcome.completed {\n-                let predicate = &pending_obligation.obligation.predicate;\n-                selcx.tcx().fulfilled_predicates.borrow_mut()\n-                           .add_if_global(selcx.tcx(), predicate);\n-            }\n-\n             errors.extend(\n                 outcome.errors.into_iter()\n                               .map(|e| to_fulfillment_error(e)));\n@@ -318,7 +298,7 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n                                _marker: PhantomData<&'c PendingPredicateObligation<'tcx>>)\n         where I: Clone + Iterator<Item=&'c PendingPredicateObligation<'tcx>>,\n     {\n-        if coinductive_match(self.selcx, cycle.clone()) {\n+        if self.selcx.coinductive_match(cycle.clone().map(|s| s.obligation.predicate)) {\n             debug!(\"process_child_obligations: coinductive match\");\n         } else {\n             let cycle : Vec<_> = cycle.map(|c| c.obligation.clone()).collect();\n@@ -375,21 +355,31 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n \n     match obligation.predicate {\n         ty::Predicate::Trait(ref data) => {\n-            let tcx = selcx.tcx();\n-            if tcx.fulfilled_predicates.borrow().check_duplicate_trait(tcx, data) {\n-                return Ok(Some(vec![]));\n+            let trait_obligation = obligation.with(data.clone());\n+\n+            if data.is_global() {\n+                // no type variables present, can use evaluation for better caching.\n+                // FIXME: consider caching errors too.\n+                if\n+                    // make defaulted unit go through the slow path for better warnings,\n+                    // please remove this when the warnings are removed.\n+                    !trait_obligation.predicate.skip_binder().self_ty().is_defaulted_unit() &&\n+                    selcx.evaluate_obligation_conservatively(&obligation) {\n+                    debug!(\"selecting trait `{:?}` at depth {} evaluated to holds\",\n+                           data, obligation.recursion_depth);\n+                    return Ok(Some(vec![]))\n+                }\n             }\n \n-            let trait_obligation = obligation.with(data.clone());\n             match selcx.select(&trait_obligation) {\n                 Ok(Some(vtable)) => {\n                     debug!(\"selecting trait `{:?}` at depth {} yielded Ok(Some)\",\n-                          data, obligation.recursion_depth);\n+                           data, obligation.recursion_depth);\n                     Ok(Some(vtable.nested_obligations()))\n                 }\n                 Ok(None) => {\n                     debug!(\"selecting trait `{:?}` at depth {} yielded Ok(None)\",\n-                          data, obligation.recursion_depth);\n+                           data, obligation.recursion_depth);\n \n                     // This is a bit subtle: for the most part, the\n                     // only reason we can fail to make progress on\n@@ -549,40 +539,6 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n     }\n }\n \n-/// For defaulted traits, we use a co-inductive strategy to solve, so\n-/// that recursion is ok. This routine returns true if the top of the\n-/// stack (`cycle[0]`):\n-/// - is a defaulted trait, and\n-/// - it also appears in the backtrace at some position `X`; and,\n-/// - all the predicates at positions `X..` between `X` an the top are\n-///   also defaulted traits.\n-fn coinductive_match<'a,'c,'gcx,'tcx,I>(selcx: &mut SelectionContext<'a,'gcx,'tcx>,\n-                                        cycle: I) -> bool\n-    where I: Iterator<Item=&'c PendingPredicateObligation<'tcx>>,\n-          'tcx: 'c\n-{\n-    let mut cycle = cycle;\n-    cycle\n-        .all(|bt_obligation| {\n-            let result = coinductive_obligation(selcx, &bt_obligation.obligation);\n-            debug!(\"coinductive_match: bt_obligation={:?} coinductive={}\",\n-                   bt_obligation, result);\n-            result\n-        })\n-}\n-\n-fn coinductive_obligation<'a,'gcx,'tcx>(selcx: &SelectionContext<'a,'gcx,'tcx>,\n-                                          obligation: &PredicateObligation<'tcx>)\n-                                          -> bool {\n-    match obligation.predicate {\n-        ty::Predicate::Trait(ref data) => {\n-            selcx.tcx().trait_has_default_impl(data.def_id())\n-        }\n-        _ => {\n-            false\n-        }\n-    }\n-}\n \n fn register_region_obligation<'tcx>(t_a: Ty<'tcx>,\n                                     r_b: ty::Region<'tcx>,\n@@ -602,55 +558,6 @@ fn register_region_obligation<'tcx>(t_a: Ty<'tcx>,\n \n }\n \n-impl<'a, 'gcx, 'tcx> GlobalFulfilledPredicates<'gcx> {\n-    pub fn new(dep_graph: DepGraph) -> GlobalFulfilledPredicates<'gcx> {\n-        GlobalFulfilledPredicates {\n-            set: FxHashSet(),\n-            dep_graph,\n-        }\n-    }\n-\n-    pub fn check_duplicate(&self, tcx: TyCtxt, key: &ty::Predicate<'tcx>) -> bool {\n-        if let ty::Predicate::Trait(ref data) = *key {\n-            self.check_duplicate_trait(tcx, data)\n-        } else {\n-            false\n-        }\n-    }\n-\n-    pub fn check_duplicate_trait(&self, tcx: TyCtxt, data: &ty::PolyTraitPredicate<'tcx>) -> bool {\n-        // For the global predicate registry, when we find a match, it\n-        // may have been computed by some other task, so we want to\n-        // add a read from the node corresponding to the predicate\n-        // processing to make sure we get the transitive dependencies.\n-        if self.set.contains(data) {\n-            debug_assert!(data.is_global());\n-            self.dep_graph.read(data.dep_node(tcx));\n-            debug!(\"check_duplicate: global predicate `{:?}` already proved elsewhere\", data);\n-\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n-    fn add_if_global(&mut self, tcx: TyCtxt<'a, 'gcx, 'tcx>, key: &ty::Predicate<'tcx>) {\n-        if let ty::Predicate::Trait(ref data) = *key {\n-            // We only add things to the global predicate registry\n-            // after the current task has proved them, and hence\n-            // already has the required read edges, so we don't need\n-            // to add any more edges here.\n-            if data.is_global() {\n-                if let Some(data) = tcx.lift_to_global(data) {\n-                    if self.set.insert(data.clone()) {\n-                        debug!(\"add_if_global: global predicate `{:?}` added\", data);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n fn to_fulfillment_error<'tcx>(\n     error: Error<PendingPredicateObligation<'tcx>, FulfillmentErrorCode<'tcx>>)\n     -> FulfillmentError<'tcx>"}, {"sha": "e14203b34a18072015a084ab97186a503cb4f593", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b85e1cfa5aa2aaa4b5df4359a023ad793983ffc/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b85e1cfa5aa2aaa4b5df4359a023ad793983ffc/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=9b85e1cfa5aa2aaa4b5df4359a023ad793983ffc", "patch": "@@ -31,7 +31,7 @@ use syntax_pos::{Span, DUMMY_SP};\n pub use self::coherence::orphan_check;\n pub use self::coherence::overlapping_impls;\n pub use self::coherence::OrphanCheckErr;\n-pub use self::fulfill::{FulfillmentContext, GlobalFulfilledPredicates, RegionObligation};\n+pub use self::fulfill::{FulfillmentContext, RegionObligation};\n pub use self::project::MismatchedProjectionTypes;\n pub use self::project::{normalize, normalize_projection_type, Normalized};\n pub use self::project::{ProjectionCache, ProjectionCacheSnapshot, Reveal};"}, {"sha": "452ad43cd699ffe538cfdc70a4892ddf26a709e1", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 159, "deletions": 48, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/9b85e1cfa5aa2aaa4b5df4359a023ad793983ffc/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b85e1cfa5aa2aaa4b5df4359a023ad793983ffc/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=9b85e1cfa5aa2aaa4b5df4359a023ad793983ffc", "patch": "@@ -43,6 +43,7 @@ use middle::lang_items;\n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::snapshot_vec::{SnapshotVecDelegate, SnapshotVec};\n use std::cell::RefCell;\n+use std::cmp;\n use std::fmt;\n use std::marker::PhantomData;\n use std::mem;\n@@ -271,17 +272,101 @@ enum BuiltinImplConditions<'tcx> {\n /// The result of trait evaluation. The order is important\n /// here as the evaluation of a list is the maximum of the\n /// evaluations.\n+///\n+/// The evaluation results are ordered:\n+///     - `EvaluatedToOk` implies `EvaluatedToAmbig` implies `EvaluatedToUnknown`\n+///     - `EvaluatedToErr` implies `EvaluatedToRecur`\n+///     - the \"union\" of evaluation results is equal to their maximum -\n+///     all the \"potential success\" candidates can potentially succeed,\n+///     so they are no-ops when unioned with a definite error, and within\n+///     the categories it's easy to see that the unions are correct.\n enum EvaluationResult {\n     /// Evaluation successful\n     EvaluatedToOk,\n-    /// Evaluation failed because of recursion - treated as ambiguous\n-    EvaluatedToUnknown,\n-    /// Evaluation is known to be ambiguous\n+    /// Evaluation is known to be ambiguous - it *might* hold for some\n+    /// assignment of inference variables, but it might not.\n+    ///\n+    /// While this has the same meaning as `EvaluatedToUnknown` - we can't\n+    /// know whether this obligation holds or not - it is the result we\n+    /// would get with an empty stack, and therefore is cacheable.\n     EvaluatedToAmbig,\n+    /// Evaluation failed because of recursion involving inference\n+    /// variables. We are somewhat imprecise there, so we don't actually\n+    /// know the real result.\n+    ///\n+    /// This can't be trivially cached for the same reason as `EvaluatedToRecur`.\n+    EvaluatedToUnknown,\n+    /// Evaluation failed because we encountered an obligation we are already\n+    /// trying to prove on this branch.\n+    ///\n+    /// We know this branch can't be a part of a minimal proof-tree for\n+    /// the \"root\" of our cycle, because then we could cut out the recursion\n+    /// and maintain a valid proof tree. However, this does not mean\n+    /// that all the obligations on this branch do not hold - it's possible\n+    /// that we entered this branch \"speculatively\", and that there\n+    /// might be some other way to prove this obligation that does not\n+    /// go through this cycle - so we can't cache this as a failure.\n+    ///\n+    /// For example, suppose we have this:\n+    ///\n+    /// ```rust,ignore (pseudo-Rust)\n+    ///     pub trait Trait { fn xyz(); }\n+    ///     // This impl is \"useless\", but we can still have\n+    ///     // an `impl Trait for SomeUnsizedType` somewhere.\n+    ///     impl<T: Trait + Sized> Trait for T { fn xyz() {} }\n+    ///\n+    ///     pub fn foo<T: Trait + ?Sized>() {\n+    ///         <T as Trait>::xyz();\n+    ///     }\n+    /// ```\n+    ///\n+    /// When checking `foo`, we have to prove `T: Trait`. This basically\n+    /// translates into this:\n+    ///\n+    ///     (T: Trait + Sized \u2192_\\impl T: Trait), T: Trait \u22a2 T: Trait\n+    ///\n+    /// When we try to prove it, we first go the first option, which\n+    /// recurses. This shows us that the impl is \"useless\" - it won't\n+    /// tell us that `T: Trait` unless it already implemented `Trait`\n+    /// by some other means. However, that does not prevent `T: Trait`\n+    /// does not hold, because of the bound (which can indeed be satisfied\n+    /// by `SomeUnsizedType` from another crate).\n+    ///\n+    /// FIXME: when an `EvaluatedToRecur` goes past its parent root, we\n+    /// ought to convert it to an `EvaluatedToErr`, because we know\n+    /// there definitely isn't a proof tree for that obligation. Not\n+    /// doing so is still sound - there isn't any proof tree, so the\n+    /// branch still can't be a part of a minimal one - but does not\n+    /// re-enable caching.\n+    EvaluatedToRecur,\n     /// Evaluation failed\n     EvaluatedToErr,\n }\n \n+impl EvaluationResult {\n+    fn may_apply(self) -> bool {\n+        match self {\n+            EvaluatedToOk |\n+            EvaluatedToAmbig |\n+            EvaluatedToUnknown => true,\n+\n+            EvaluatedToErr |\n+            EvaluatedToRecur => false\n+        }\n+    }\n+\n+    fn is_stack_dependent(self) -> bool {\n+        match self {\n+            EvaluatedToUnknown |\n+            EvaluatedToRecur => true,\n+\n+            EvaluatedToOk |\n+            EvaluatedToAmbig |\n+            EvaluatedToErr => false,\n+        }\n+    }\n+}\n+\n #[derive(Clone)]\n pub struct EvaluationCache<'tcx> {\n     hashmap: RefCell<FxHashMap<ty::PolyTraitRef<'tcx>, EvaluationResult>>\n@@ -492,15 +577,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             let eval = self.evaluate_predicate_recursively(stack, obligation);\n             debug!(\"evaluate_predicate_recursively({:?}) = {:?}\",\n                    obligation, eval);\n-            match eval {\n-                EvaluatedToErr => { return EvaluatedToErr; }\n-                EvaluatedToAmbig => { result = EvaluatedToAmbig; }\n-                EvaluatedToUnknown => {\n-                    if result < EvaluatedToUnknown {\n-                        result = EvaluatedToUnknown;\n-                    }\n-                }\n-                EvaluatedToOk => { }\n+            if let EvaluatedToErr = eval {\n+                // fast-path - EvaluatedToErr is the top of the lattice,\n+                // so we don't need to look on the other predicates.\n+                return EvaluatedToErr;\n+            } else {\n+                result = cmp::max(result, eval);\n             }\n         }\n         result\n@@ -514,21 +596,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         debug!(\"evaluate_predicate_recursively({:?})\",\n                obligation);\n \n-        let tcx = self.tcx();\n-\n-        // Check the cache from the tcx of predicates that we know\n-        // have been proven elsewhere. This cache only contains\n-        // predicates that are global in scope and hence unaffected by\n-        // the current environment.\n-        if tcx.fulfilled_predicates.borrow().check_duplicate(tcx, &obligation.predicate) {\n-            return EvaluatedToOk;\n-        }\n-\n         match obligation.predicate {\n             ty::Predicate::Trait(ref t) => {\n                 assert!(!t.has_escaping_regions());\n                 let obligation = obligation.with(t.clone());\n-                self.evaluate_obligation_recursively(previous_stack, &obligation)\n+                self.evaluate_trait_predicate_recursively(previous_stack, obligation)\n             }\n \n             ty::Predicate::Equate(ref p) => {\n@@ -613,15 +685,23 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn evaluate_obligation_recursively<'o>(&mut self,\n-                                           previous_stack: TraitObligationStackList<'o, 'tcx>,\n-                                           obligation: &TraitObligation<'tcx>)\n-                                           -> EvaluationResult\n+    fn evaluate_trait_predicate_recursively<'o>(&mut self,\n+                                                previous_stack: TraitObligationStackList<'o, 'tcx>,\n+                                                mut obligation: TraitObligation<'tcx>)\n+                                                -> EvaluationResult\n     {\n-        debug!(\"evaluate_obligation_recursively({:?})\",\n+        debug!(\"evaluate_trait_predicate_recursively({:?})\",\n                obligation);\n \n-        let stack = self.push_stack(previous_stack, obligation);\n+        if !self.intercrate && obligation.is_global() {\n+            // If a param env is consistent, global obligations do not depend on its particular\n+            // value in order to work, so we can clear out the param env and get better\n+            // caching. (If the current param env is inconsistent, we don't care what happens).\n+            debug!(\"evaluate_trait_predicate_recursively({:?}) - in global\", obligation);\n+            obligation.param_env = ty::ParamEnv::empty(obligation.param_env.reveal);\n+        }\n+\n+        let stack = self.push_stack(previous_stack, &obligation);\n         let fresh_trait_ref = stack.fresh_trait_ref;\n         if let Some(result) = self.check_evaluation_cache(obligation.param_env, fresh_trait_ref) {\n             debug!(\"CACHE HIT: EVAL({:?})={:?}\",\n@@ -676,8 +756,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         }\n         if unbound_input_types &&\n               stack.iter().skip(1).any(\n-                  |prev| self.match_fresh_trait_refs(&stack.fresh_trait_ref,\n-                                                     &prev.fresh_trait_ref))\n+                  |prev| stack.obligation.param_env == prev.obligation.param_env &&\n+                      self.match_fresh_trait_refs(&stack.fresh_trait_ref,\n+                                                  &prev.fresh_trait_ref))\n         {\n             debug!(\"evaluate_stack({:?}) --> unbound argument, recursive --> giving up\",\n                    stack.fresh_trait_ref);\n@@ -703,14 +784,25 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // affect the inferencer state and (b) that if we see two\n         // skolemized types with the same index, they refer to the\n         // same unbound type variable.\n-        if\n+        if let Some(rec_index) =\n             stack.iter()\n             .skip(1) // skip top-most frame\n-            .any(|prev| stack.fresh_trait_ref == prev.fresh_trait_ref)\n+            .position(|prev| stack.obligation.param_env == prev.obligation.param_env &&\n+                      stack.fresh_trait_ref == prev.fresh_trait_ref)\n         {\n             debug!(\"evaluate_stack({:?}) --> recursive\",\n                    stack.fresh_trait_ref);\n-            return EvaluatedToOk;\n+            let cycle = stack.iter().skip(1).take(rec_index+1);\n+            let cycle = cycle.map(|stack| ty::Predicate::Trait(stack.obligation.predicate));\n+            if self.coinductive_match(cycle) {\n+                debug!(\"evaluate_stack({:?}) --> recursive, coinductive\",\n+                       stack.fresh_trait_ref);\n+                return EvaluatedToOk;\n+            } else {\n+                debug!(\"evaluate_stack({:?}) --> recursive, inductive\",\n+                       stack.fresh_trait_ref);\n+                return EvaluatedToRecur;\n+            }\n         }\n \n         match self.candidate_from_obligation(stack) {\n@@ -720,6 +812,33 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// For defaulted traits, we use a co-inductive strategy to solve, so\n+    /// that recursion is ok. This routine returns true if the top of the\n+    /// stack (`cycle[0]`):\n+    /// - is a defaulted trait, and\n+    /// - it also appears in the backtrace at some position `X`; and,\n+    /// - all the predicates at positions `X..` between `X` an the top are\n+    ///   also defaulted traits.\n+    pub fn coinductive_match<I>(&mut self, cycle: I) -> bool\n+        where I: Iterator<Item=ty::Predicate<'tcx>>\n+    {\n+        let mut cycle = cycle;\n+        cycle.all(|predicate| self.coinductive_predicate(predicate))\n+    }\n+\n+    fn coinductive_predicate(&self, predicate: ty::Predicate<'tcx>) -> bool {\n+        let result = match predicate {\n+            ty::Predicate::Trait(ref data) => {\n+                self.tcx().trait_has_default_impl(data.def_id())\n+            }\n+            _ => {\n+                false\n+            }\n+        };\n+        debug!(\"coinductive_predicate({:?}) = {:?}\", predicate, result);\n+        result\n+    }\n+\n     /// Further evaluate `candidate` to decide whether all type parameters match and whether nested\n     /// obligations are met. Returns true if `candidate` remains viable after this further\n     /// scrutiny.\n@@ -754,6 +873,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         if self.can_use_global_caches(param_env) {\n             let cache = self.tcx().evaluation_cache.hashmap.borrow();\n             if let Some(cached) = cache.get(&trait_ref) {\n+                let dep_node = trait_ref\n+                    .to_poly_trait_predicate()\n+                    .dep_node(self.tcx());\n+                self.tcx().hir.dep_graph.read(dep_node);\n                 return Some(cached.clone());\n             }\n         }\n@@ -766,10 +889,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                result: EvaluationResult)\n     {\n         // Avoid caching results that depend on more than just the trait-ref:\n-        // The stack can create EvaluatedToUnknown, and closure signatures\n+        // The stack can create recursion, and closure signatures\n         // being yet uninferred can create \"spurious\" EvaluatedToAmbig\n         // and EvaluatedToOk.\n-        if result == EvaluatedToUnknown ||\n+        if result.is_stack_dependent() ||\n             ((result == EvaluatedToAmbig || result == EvaluatedToOk)\n              && trait_ref.has_closure_types())\n         {\n@@ -3014,15 +3137,3 @@ impl<'o,'tcx> fmt::Debug for TraitObligationStack<'o,'tcx> {\n         write!(f, \"TraitObligationStack({:?})\", self.obligation)\n     }\n }\n-\n-impl EvaluationResult {\n-    fn may_apply(&self) -> bool {\n-        match *self {\n-            EvaluatedToOk |\n-            EvaluatedToAmbig |\n-            EvaluatedToUnknown => true,\n-\n-            EvaluatedToErr => false\n-        }\n-    }\n-}"}, {"sha": "1f20993f96cfda71bee1e0064403575813df121b", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b85e1cfa5aa2aaa4b5df4359a023ad793983ffc/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b85e1cfa5aa2aaa4b5df4359a023ad793983ffc/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=9b85e1cfa5aa2aaa4b5df4359a023ad793983ffc", "patch": "@@ -507,12 +507,6 @@ pub struct GlobalCtxt<'tcx> {\n     /// Merge this with `selection_cache`?\n     pub evaluation_cache: traits::EvaluationCache<'tcx>,\n \n-    /// A set of predicates that have been fulfilled *somewhere*.\n-    /// This is used to avoid duplicate work. Predicates are only\n-    /// added to this set when they mention only \"global\" names\n-    /// (i.e., no type or lifetime parameters).\n-    pub fulfilled_predicates: RefCell<traits::GlobalFulfilledPredicates<'tcx>>,\n-\n     /// Maps Expr NodeId's to `true` iff `&expr` can have 'static lifetime.\n     pub rvalue_promotable_to_static: RefCell<NodeMap<bool>>,\n \n@@ -686,7 +680,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let interners = CtxtInterners::new(arena);\n         let common_types = CommonTypes::new(&interners);\n         let dep_graph = hir.dep_graph.clone();\n-        let fulfilled_predicates = traits::GlobalFulfilledPredicates::new(dep_graph.clone());\n         let max_cnum = s.cstore.crates().iter().map(|c| c.as_usize()).max().unwrap_or(0);\n         let mut providers = IndexVec::from_elem_n(extern_providers, max_cnum + 1);\n         providers[LOCAL_CRATE] = local_providers;\n@@ -735,7 +728,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             named_region_map,\n             trait_map: resolutions.trait_map,\n             export_map: resolutions.export_map,\n-            fulfilled_predicates: RefCell::new(fulfilled_predicates),\n             hir,\n             def_path_hash_to_def_id,\n             maps: maps::Maps::new(providers),"}, {"sha": "65ea1baa4a126e8885472cb3b8213b8b21609867", "filename": "src/test/compile-fail/issue-39970.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9b85e1cfa5aa2aaa4b5df4359a023ad793983ffc/src%2Ftest%2Fcompile-fail%2Fissue-39970.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b85e1cfa5aa2aaa4b5df4359a023ad793983ffc/src%2Ftest%2Fcompile-fail%2Fissue-39970.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-39970.rs?ref=9b85e1cfa5aa2aaa4b5df4359a023ad793983ffc", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Array<'a> {\n+    type Element: 'a;\n+}\n+\n+trait Visit {\n+    fn visit() {}\n+}\n+\n+impl<'a> Array<'a> for () {\n+    type Element = &'a ();\n+}\n+\n+impl Visit for () where\n+    //(): for<'a> Array<'a, Element=&'a ()>, // No ICE\n+    (): for<'a> Array<'a, Element=()>, // ICE\n+{}\n+\n+fn main() {\n+    <() as Visit>::visit();\n+    //~^ ERROR type mismatch resolving `for<'a> <() as Array<'a>>::Element == ()`\n+}"}, {"sha": "10622eccbdcd19d9a47000d82a1661571bca80cb", "filename": "src/test/compile-fail/issue-42796.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9b85e1cfa5aa2aaa4b5df4359a023ad793983ffc/src%2Ftest%2Fcompile-fail%2Fissue-42796.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b85e1cfa5aa2aaa4b5df4359a023ad793983ffc/src%2Ftest%2Fcompile-fail%2Fissue-42796.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-42796.rs?ref=9b85e1cfa5aa2aaa4b5df4359a023ad793983ffc", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait Mirror<Smoke> {\n+    type Image;\n+}\n+\n+impl<T, Smoke> Mirror<Smoke> for T {\n+    type Image = T;\n+}\n+\n+pub fn poison<S>(victim: String) where <String as Mirror<S>>::Image: Copy {\n+    loop { drop(victim); } //~ ERROR use of moved value\n+}\n+\n+fn main() {\n+    let s = \"Hello!\".to_owned();\n+    let mut s_copy = s;\n+    s_copy.push_str(\"World!\");\n+    \"0wned!\".to_owned();\n+    println!(\"{}\", s); //~ ERROR use of moved value\n+}"}]}