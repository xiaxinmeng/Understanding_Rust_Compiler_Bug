{"sha": "240cc81768f678bb4a6f8369080ef77515971963", "node_id": "C_kwDOAAsO6NoAKDI0MGNjODE3NjhmNjc4YmI0YTZmODM2OTA4MGVmNzc1MTU5NzE5NjM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-01-20T06:16:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-20T06:16:09Z"}, "message": "Rollup merge of #106973 - oli-obk:tait_ice_closure_in_impl_header, r=lcnr\n\nDon't treat closures from other crates as local\n\nfixes #104817\n\nr? `@lcnr`\n\nSpecialization can prefer an impl for an opaque type over a blanket impls that also matches. If the blanket impl only applies if an auto-trait applies, we look at the hidden type of the opaque type to see if that implements the auto trait. The hidden type can be a closure or generator, and thus we will end up seeing these types in coherence and have to handle them properly.", "tree": {"sha": "3865dd40c55787cd506df103378cbba565cf9a4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3865dd40c55787cd506df103378cbba565cf9a4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/240cc81768f678bb4a6f8369080ef77515971963", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjyjGpCRBK7hj4Ov3rIwAAkbAIADh/QALfVXNZV1IcnqyHu+mF\nsZ0W89161Za37qwvvGMntD6qgwt3K4DDLeeTZfFM+RHcjS3zXv8okjvtbeeBlt2T\n71tfMCR8zrXtJ5CpzeG3kagnc2Eis637vg2AFgMhcOLhGvg53kP5gUA4rYxcjmWr\nLg9Pb5GyZfACgU5ci38DJh9hCYxaQUDQzMIbHS7xNiKbhX8J0n+gKEIYaABtY1IJ\nzMKwzH393MUhH9YyZZNUjOW4vVet2cdZPw4RX7paUEBY5w/qk/5P/r5iuDeSsVsj\nOsPcBjOFbD7VSqGkT3e/V2ZayZZAmJIHIYdK8H5Km6YfAKzQVKkKUtCJz3B4BuI=\n=Ntvg\n-----END PGP SIGNATURE-----\n", "payload": "tree 3865dd40c55787cd506df103378cbba565cf9a4c\nparent df88f7e02c1e9a1e543e5c4767f0d5212c00182d\nparent 42f1f54a5e15616f23d22d09cbdd510ee3d5f789\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1674195369 +0100\ncommitter GitHub <noreply@github.com> 1674195369 +0100\n\nRollup merge of #106973 - oli-obk:tait_ice_closure_in_impl_header, r=lcnr\n\nDon't treat closures from other crates as local\n\nfixes #104817\n\nr? `@lcnr`\n\nSpecialization can prefer an impl for an opaque type over a blanket impls that also matches. If the blanket impl only applies if an auto-trait applies, we look at the hidden type of the opaque type to see if that implements the auto trait. The hidden type can be a closure or generator, and thus we will end up seeing these types in coherence and have to handle them properly.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/240cc81768f678bb4a6f8369080ef77515971963", "html_url": "https://github.com/rust-lang/rust/commit/240cc81768f678bb4a6f8369080ef77515971963", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/240cc81768f678bb4a6f8369080ef77515971963/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df88f7e02c1e9a1e543e5c4767f0d5212c00182d", "url": "https://api.github.com/repos/rust-lang/rust/commits/df88f7e02c1e9a1e543e5c4767f0d5212c00182d", "html_url": "https://github.com/rust-lang/rust/commit/df88f7e02c1e9a1e543e5c4767f0d5212c00182d"}, {"sha": "42f1f54a5e15616f23d22d09cbdd510ee3d5f789", "url": "https://api.github.com/repos/rust-lang/rust/commits/42f1f54a5e15616f23d22d09cbdd510ee3d5f789", "html_url": "https://github.com/rust-lang/rust/commit/42f1f54a5e15616f23d22d09cbdd510ee3d5f789"}], "stats": {"total": 82, "additions": 58, "deletions": 24}, "files": [{"sha": "225c1050c7c952fc41230b7bdde07365d65ad419", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/240cc81768f678bb4a6f8369080ef77515971963/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/240cc81768f678bb4a6f8369080ef77515971963/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=240cc81768f678bb4a6f8369080ef77515971963", "patch": "@@ -401,12 +401,12 @@ fn resolve_negative_obligation<'tcx>(\n     infcx.resolve_regions(&outlives_env).is_empty()\n }\n \n+#[instrument(level = \"debug\", skip(tcx), ret)]\n pub fn trait_ref_is_knowable<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_ref: ty::TraitRef<'tcx>,\n ) -> Result<(), Conflict> {\n-    debug!(\"trait_ref_is_knowable(trait_ref={:?})\", trait_ref);\n-    if orphan_check_trait_ref(tcx, trait_ref, InCrate::Remote).is_ok() {\n+    if orphan_check_trait_ref(trait_ref, InCrate::Remote).is_ok() {\n         // A downstream or cousin crate is allowed to implement some\n         // substitution of this trait-ref.\n         return Err(Conflict::Downstream);\n@@ -429,11 +429,9 @@ pub fn trait_ref_is_knowable<'tcx>(\n     // and if we are an intermediate owner, then we don't care\n     // about future-compatibility, which means that we're OK if\n     // we are an owner.\n-    if orphan_check_trait_ref(tcx, trait_ref, InCrate::Local).is_ok() {\n-        debug!(\"trait_ref_is_knowable: orphan check passed\");\n+    if orphan_check_trait_ref(trait_ref, InCrate::Local).is_ok() {\n         Ok(())\n     } else {\n-        debug!(\"trait_ref_is_knowable: nonlocal, nonfundamental, unowned\");\n         Err(Conflict::Upstream)\n     }\n }\n@@ -445,6 +443,7 @@ pub fn trait_ref_is_local_or_fundamental<'tcx>(\n     trait_ref.def_id.krate == LOCAL_CRATE || tcx.has_attr(trait_ref.def_id, sym::fundamental)\n }\n \n+#[derive(Debug)]\n pub enum OrphanCheckErr<'tcx> {\n     NonLocalInputType(Vec<(Ty<'tcx>, bool /* Is this the first input type? */)>),\n     UncoveredTy(Ty<'tcx>, Option<Ty<'tcx>>),\n@@ -456,21 +455,20 @@ pub enum OrphanCheckErr<'tcx> {\n ///\n /// 1. All type parameters in `Self` must be \"covered\" by some local type constructor.\n /// 2. Some local type must appear in `Self`.\n+#[instrument(level = \"debug\", skip(tcx), ret)]\n pub fn orphan_check(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Result<(), OrphanCheckErr<'_>> {\n-    debug!(\"orphan_check({:?})\", impl_def_id);\n-\n     // We only except this routine to be invoked on implementations\n     // of a trait, not inherent implementations.\n     let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap().subst_identity();\n-    debug!(\"orphan_check: trait_ref={:?}\", trait_ref);\n+    debug!(?trait_ref);\n \n     // If the *trait* is local to the crate, ok.\n     if trait_ref.def_id.is_local() {\n         debug!(\"trait {:?} is local to current crate\", trait_ref.def_id);\n         return Ok(());\n     }\n \n-    orphan_check_trait_ref(tcx, trait_ref, InCrate::Local)\n+    orphan_check_trait_ref(trait_ref, InCrate::Local)\n }\n \n /// Checks whether a trait-ref is potentially implementable by a crate.\n@@ -559,21 +557,19 @@ pub fn orphan_check(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Result<(), OrphanChe\n ///\n /// Note that this function is never called for types that have both type\n /// parameters and inference variables.\n+#[instrument(level = \"trace\", ret)]\n fn orphan_check_trait_ref<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n     trait_ref: ty::TraitRef<'tcx>,\n     in_crate: InCrate,\n ) -> Result<(), OrphanCheckErr<'tcx>> {\n-    debug!(\"orphan_check_trait_ref(trait_ref={:?}, in_crate={:?})\", trait_ref, in_crate);\n-\n     if trait_ref.needs_infer() && trait_ref.needs_subst() {\n         bug!(\n             \"can't orphan check a trait ref with both params and inference variables {:?}\",\n             trait_ref\n         );\n     }\n \n-    let mut checker = OrphanChecker::new(tcx, in_crate);\n+    let mut checker = OrphanChecker::new(in_crate);\n     match trait_ref.visit_with(&mut checker) {\n         ControlFlow::Continue(()) => Err(OrphanCheckErr::NonLocalInputType(checker.non_local_tys)),\n         ControlFlow::Break(OrphanCheckEarlyExit::ParamTy(ty)) => {\n@@ -592,7 +588,6 @@ fn orphan_check_trait_ref<'tcx>(\n }\n \n struct OrphanChecker<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n     in_crate: InCrate,\n     in_self_ty: bool,\n     /// Ignore orphan check failures and exclusively search for the first\n@@ -602,9 +597,8 @@ struct OrphanChecker<'tcx> {\n }\n \n impl<'tcx> OrphanChecker<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>, in_crate: InCrate) -> Self {\n+    fn new(in_crate: InCrate) -> Self {\n         OrphanChecker {\n-            tcx,\n             in_crate,\n             in_self_ty: true,\n             search_first_local_ty: false,\n@@ -697,13 +691,17 @@ impl<'tcx> TypeVisitor<'tcx> for OrphanChecker<'tcx> {\n                 }\n             }\n             ty::Error(_) => ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty)),\n-            ty::Closure(..) | ty::Generator(..) | ty::GeneratorWitness(..) => {\n-                self.tcx.sess.delay_span_bug(\n-                    DUMMY_SP,\n-                    format!(\"ty_is_local invoked on closure or generator: {:?}\", ty),\n-                );\n-                ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty))\n+            ty::Closure(did, ..) | ty::Generator(did, ..) => {\n+                if self.def_id_is_local(did) {\n+                    ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty))\n+                } else {\n+                    self.found_non_local_ty(ty)\n+                }\n             }\n+            // This should only be created when checking whether we have to check whether some\n+            // auto trait impl applies. There will never be multiple impls, so we can just\n+            // act as if it were a local type here.\n+            ty::GeneratorWitness(_) => ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty)),\n             ty::Alias(ty::Opaque, ..) => {\n                 // This merits some explanation.\n                 // Normally, opaque types are not involved when performing"}, {"sha": "5eb8dc2a4687f53181f707efdea2267c79b558dd", "filename": "tests/ui/coherence/coherence-with-generator.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/240cc81768f678bb4a6f8369080ef77515971963/tests%2Fui%2Fcoherence%2Fcoherence-with-generator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/240cc81768f678bb4a6f8369080ef77515971963/tests%2Fui%2Fcoherence%2Fcoherence-with-generator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcoherence%2Fcoherence-with-generator.rs?ref=240cc81768f678bb4a6f8369080ef77515971963", "patch": "@@ -1,5 +1,11 @@\n // Test that encountering closures during coherence does not cause issues.\n #![feature(type_alias_impl_trait, generators)]\n+#![cfg_attr(specialized, feature(specialization))]\n+#![allow(incomplete_features)]\n+\n+// revisions: stock specialized\n+// [specialized]check-pass\n+\n type OpaqueGenerator = impl Sized;\n fn defining_use() -> OpaqueGenerator {\n     || {\n@@ -13,6 +19,6 @@ struct Wrapper<T>(T);\n trait Trait {}\n impl Trait for Wrapper<OpaqueGenerator> {}\n impl<T: Sync> Trait for Wrapper<T> {}\n-//~^ ERROR conflicting implementations of trait `Trait` for type `Wrapper<OpaqueGenerator>`\n+//[stock]~^ ERROR conflicting implementations of trait `Trait` for type `Wrapper<OpaqueGenerator>`\n \n fn main() {}"}, {"sha": "478ac4912646d8312fc12f9ae782ef5e34138f73", "filename": "tests/ui/coherence/coherence-with-generator.stock.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/240cc81768f678bb4a6f8369080ef77515971963/tests%2Fui%2Fcoherence%2Fcoherence-with-generator.stock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/240cc81768f678bb4a6f8369080ef77515971963/tests%2Fui%2Fcoherence%2Fcoherence-with-generator.stock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcoherence%2Fcoherence-with-generator.stock.stderr?ref=240cc81768f678bb4a6f8369080ef77515971963", "patch": "@@ -1,5 +1,5 @@\n error[E0119]: conflicting implementations of trait `Trait` for type `Wrapper<OpaqueGenerator>`\n-  --> $DIR/coherence-with-generator.rs:15:1\n+  --> $DIR/coherence-with-generator.rs:21:1\n    |\n LL | impl Trait for Wrapper<OpaqueGenerator> {}\n    | --------------------------------------- first implementation here", "previous_filename": "tests/ui/coherence/coherence-with-generator.stderr"}, {"sha": "0d3bace4db1f4baa6414c7d3b85fd5c46704be8c", "filename": "tests/ui/type-alias-impl-trait/issue-104817.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/240cc81768f678bb4a6f8369080ef77515971963/tests%2Fui%2Ftype-alias-impl-trait%2Fissue-104817.rs", "raw_url": "https://github.com/rust-lang/rust/raw/240cc81768f678bb4a6f8369080ef77515971963/tests%2Fui%2Ftype-alias-impl-trait%2Fissue-104817.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fissue-104817.rs?ref=240cc81768f678bb4a6f8369080ef77515971963", "patch": "@@ -0,0 +1,19 @@\n+#![feature(type_alias_impl_trait)]\n+#![cfg_attr(specialized, feature(specialization))]\n+#![allow(incomplete_features)]\n+\n+// revisions: stock specialized\n+// [specialized]check-pass\n+\n+trait OpaqueTrait {}\n+impl<T> OpaqueTrait for T {}\n+type OpaqueType = impl OpaqueTrait;\n+fn mk_opaque() -> OpaqueType {\n+    || 0\n+}\n+trait AnotherTrait {}\n+impl<T: Send> AnotherTrait for T {}\n+impl AnotherTrait for OpaqueType {}\n+//[stock]~^ conflicting implementations of trait `AnotherTrait` for type `OpaqueType`\n+\n+fn main() {}"}, {"sha": "47bae8bd12b6bba1731868e99e29b84fbdf88ad3", "filename": "tests/ui/type-alias-impl-trait/issue-104817.stock.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/240cc81768f678bb4a6f8369080ef77515971963/tests%2Fui%2Ftype-alias-impl-trait%2Fissue-104817.stock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/240cc81768f678bb4a6f8369080ef77515971963/tests%2Fui%2Ftype-alias-impl-trait%2Fissue-104817.stock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fissue-104817.stock.stderr?ref=240cc81768f678bb4a6f8369080ef77515971963", "patch": "@@ -0,0 +1,11 @@\n+error[E0119]: conflicting implementations of trait `AnotherTrait` for type `OpaqueType`\n+  --> $DIR/issue-104817.rs:16:1\n+   |\n+LL | impl<T: Send> AnotherTrait for T {}\n+   | -------------------------------- first implementation here\n+LL | impl AnotherTrait for OpaqueType {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `OpaqueType`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0119`."}]}