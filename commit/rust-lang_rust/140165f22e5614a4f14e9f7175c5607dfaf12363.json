{"sha": "140165f22e5614a4f14e9f7175c5607dfaf12363", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0MDE2NWYyMmU1NjE0YTRmMTRlOWY3MTc1YzU2MDdkZmFmMTIzNjM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-03-17T15:52:37Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-03-30T11:55:29Z"}, "message": "rewrite `ExprArray` processing to use `CoerceMany`", "tree": {"sha": "f0b7b7feafe3d7cd7edcb9e6cf568aada371209f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0b7b7feafe3d7cd7edcb9e6cf568aada371209f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/140165f22e5614a4f14e9f7175c5607dfaf12363", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/140165f22e5614a4f14e9f7175c5607dfaf12363", "html_url": "https://github.com/rust-lang/rust/commit/140165f22e5614a4f14e9f7175c5607dfaf12363", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/140165f22e5614a4f14e9f7175c5607dfaf12363/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16a71cce514f29cb8c532248cf749e26972afb01", "url": "https://api.github.com/repos/rust-lang/rust/commits/16a71cce514f29cb8c532248cf749e26972afb01", "html_url": "https://github.com/rust-lang/rust/commit/16a71cce514f29cb8c532248cf749e26972afb01"}], "stats": {"total": 49, "additions": 20, "deletions": 29}, "files": [{"sha": "73d4e7db1d8423c5b68270ff91d52922b1f3f38c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 20, "deletions": 29, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/140165f22e5614a4f14e9f7175c5607dfaf12363/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/140165f22e5614a4f14e9f7175c5607dfaf12363/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=140165f22e5614a4f14e9f7175c5607dfaf12363", "patch": "@@ -3752,36 +3752,27 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             typ\n           }\n           hir::ExprArray(ref args) => {\n-            let uty = expected.to_option(self).and_then(|uty| {\n-                match uty.sty {\n-                    ty::TyArray(ty, _) | ty::TySlice(ty) => Some(ty),\n-                    _ => None\n-                }\n-            });\n-\n-            let mut unified = self.next_ty_var(TypeVariableOrigin::TypeInference(expr.span));\n-            let coerce_to = uty.unwrap_or(unified);\n-\n-            for (i, e) in args.iter().enumerate() {\n-                let e_ty = self.check_expr_with_hint(e, coerce_to);\n-                let cause = self.misc(e.span);\n-\n-                // Special-case the first element, as it has no \"previous expressions\".\n-                let result = if i == 0 {\n-                    self.try_coerce(e, e_ty, coerce_to)\n-                } else {\n-                    let prev_elems = || args[..i].iter().map(|e| &*e);\n-                    self.try_find_coercion_lub(&cause, prev_elems, unified, e, e_ty)\n-                };\n+              let uty = expected.to_option(self).and_then(|uty| {\n+                  match uty.sty {\n+                      ty::TyArray(ty, _) | ty::TySlice(ty) => Some(ty),\n+                      _ => None\n+                  }\n+              });\n \n-                match result {\n-                    Ok(ty) => unified = ty,\n-                    Err(e) => {\n-                        self.report_mismatched_types(&cause, unified, e_ty, e).emit();\n-                    }\n-                }\n-            }\n-            tcx.mk_array(unified, args.len())\n+              let element_ty = if !args.is_empty() {\n+                  let coerce_to = uty.unwrap_or_else(\n+                      || self.next_ty_var(TypeVariableOrigin::TypeInference(expr.span)));\n+                  let mut coerce = CoerceMany::new(coerce_to);\n+                  for e in args {\n+                      let e_ty = self.check_expr_with_hint(e, coerce_to);\n+                      let cause = self.misc(e.span);\n+                      coerce.coerce(self, &cause, e, e_ty);\n+                  }\n+                  coerce.complete(self)\n+              } else {\n+                  self.next_ty_var(TypeVariableOrigin::TypeInference(expr.span))\n+              };\n+              tcx.mk_array(element_ty, args.len())\n           }\n           hir::ExprRepeat(ref element, count) => {\n             let count = eval_length(self.tcx.global_tcx(), count, \"repeat count\")"}]}