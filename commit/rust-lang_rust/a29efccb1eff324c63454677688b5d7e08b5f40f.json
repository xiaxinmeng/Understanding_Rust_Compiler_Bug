{"sha": "a29efccb1eff324c63454677688b5d7e08b5f40f", "node_id": "C_kwDOAAsO6NoAKGEyOWVmY2NiMWVmZjMyNGM2MzQ1NDY3NzY4OGI1ZDdlMDhiNWY0MGY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-29T07:01:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-29T07:01:58Z"}, "message": "Auto merge of #107435 - matthiaskrgr:rollup-if5h6yu, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #106618 (Disable `linux_ext` in wasm32 and fortanix rustdoc builds.)\n - #107097 (Fix def-use dominance check)\n - #107154 (library/std/sys_common: Define MIN_ALIGN for m68k-unknown-linux-gnu)\n - #107397 (Gracefully exit if --keep-stage flag is used on a clean source tree)\n - #107401 (remove the usize field from CandidateSource::AliasBound)\n - #107413 (make more pleasant to read)\n - #107422 (Also erase substs for new infcx in pin move error)\n - #107425 (Check for missing space between fat arrow and range pattern)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "54e850143adb07bfa0ae0f9c5b440a6736b2ab52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54e850143adb07bfa0ae0f9c5b440a6736b2ab52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a29efccb1eff324c63454677688b5d7e08b5f40f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a29efccb1eff324c63454677688b5d7e08b5f40f", "html_url": "https://github.com/rust-lang/rust/commit/a29efccb1eff324c63454677688b5d7e08b5f40f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a29efccb1eff324c63454677688b5d7e08b5f40f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3cdd0197e78e2ca3403157617709bbfe18a3f0b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cdd0197e78e2ca3403157617709bbfe18a3f0b5", "html_url": "https://github.com/rust-lang/rust/commit/3cdd0197e78e2ca3403157617709bbfe18a3f0b5"}, {"sha": "4e8f7e4fc9d7849227f96cd55e46c0337c3fc416", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e8f7e4fc9d7849227f96cd55e46c0337c3fc416", "html_url": "https://github.com/rust-lang/rust/commit/4e8f7e4fc9d7849227f96cd55e46c0337c3fc416"}], "stats": {"total": 265, "additions": 221, "deletions": 44}, "files": [{"sha": "8c579bac7e8eb471c8dc8690eb7f7c3a7c62c5d1", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a29efccb1eff324c63454677688b5d7e08b5f40f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29efccb1eff324c63454677688b5d7e08b5f40f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=a29efccb1eff324c63454677688b5d7e08b5f40f", "patch": "@@ -1128,8 +1128,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 \"{place_name} {partially_str}moved due to this method call{loop_message}\",\n                             ),\n                         );\n+\n                         let infcx = tcx.infer_ctxt().build();\n+                        // Erase and shadow everything that could be passed to the new infcx.\n                         let ty = tcx.erase_regions(moved_place.ty(self.body, tcx).ty);\n+                        let method_substs = tcx.erase_regions(method_substs);\n+\n                         if let ty::Adt(def, substs) = ty.kind()\n                             && Some(def.did()) == tcx.lang_items().pin_type()\n                             && let ty::Ref(_, _, hir::Mutability::Mut) = substs.type_at(0).kind()"}, {"sha": "32cd3a4efa227e0b0a5a77a1e0b18a25ef417474", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a29efccb1eff324c63454677688b5d7e08b5f40f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29efccb1eff324c63454677688b5d7e08b5f40f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=a29efccb1eff324c63454677688b5d7e08b5f40f", "patch": "@@ -191,7 +191,7 @@ pub unsafe fn create_module<'ll>(\n         //\n         // FIXME(#34960)\n         let cfg_llvm_root = option_env!(\"CFG_LLVM_ROOT\").unwrap_or(\"\");\n-        let custom_llvm_used = cfg_llvm_root.trim() != \"\";\n+        let custom_llvm_used = !cfg_llvm_root.trim().is_empty();\n \n         if !custom_llvm_used && target_data_layout != llvm_data_layout {\n             bug!("}, {"sha": "95aad10fdb0f9852505cd08ebffa88f6f62ac7c2", "filename": "compiler/rustc_codegen_ssa/src/mir/analyze.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a29efccb1eff324c63454677688b5d7e08b5f40f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29efccb1eff324c63454677688b5d7e08b5f40f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs?ref=a29efccb1eff324c63454677688b5d7e08b5f40f", "patch": "@@ -36,7 +36,7 @@ pub fn non_ssa_locals<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n     // Arguments get assigned to by means of the function being called\n     for arg in mir.args_iter() {\n-        analyzer.assign(arg, mir::START_BLOCK.start_location());\n+        analyzer.assign(arg, DefLocation::Argument);\n     }\n \n     // If there exists a local definition that dominates all uses of that local,\n@@ -64,7 +64,22 @@ enum LocalKind {\n     /// A scalar or a scalar pair local that is neither defined nor used.\n     Unused,\n     /// A scalar or a scalar pair local with a single definition that dominates all uses.\n-    SSA(mir::Location),\n+    SSA(DefLocation),\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+enum DefLocation {\n+    Argument,\n+    Body(Location),\n+}\n+\n+impl DefLocation {\n+    fn dominates(self, location: Location, dominators: &Dominators<mir::BasicBlock>) -> bool {\n+        match self {\n+            DefLocation::Argument => true,\n+            DefLocation::Body(def) => def.successor_within_block().dominates(location, dominators),\n+        }\n+    }\n }\n \n struct LocalAnalyzer<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n@@ -74,17 +89,13 @@ struct LocalAnalyzer<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n }\n \n impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n-    fn assign(&mut self, local: mir::Local, location: Location) {\n+    fn assign(&mut self, local: mir::Local, location: DefLocation) {\n         let kind = &mut self.locals[local];\n         match *kind {\n             LocalKind::ZST => {}\n             LocalKind::Memory => {}\n-            LocalKind::Unused => {\n-                *kind = LocalKind::SSA(location);\n-            }\n-            LocalKind::SSA(_) => {\n-                *kind = LocalKind::Memory;\n-            }\n+            LocalKind::Unused => *kind = LocalKind::SSA(location),\n+            LocalKind::SSA(_) => *kind = LocalKind::Memory,\n         }\n     }\n \n@@ -166,7 +177,7 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n         debug!(\"visit_assign(place={:?}, rvalue={:?})\", place, rvalue);\n \n         if let Some(local) = place.as_local() {\n-            self.assign(local, location);\n+            self.assign(local, DefLocation::Body(location));\n             if self.locals[local] != LocalKind::Memory {\n                 let decl_span = self.fx.mir.local_decls[local].source_info.span;\n                 if !self.fx.rvalue_creates_operand(rvalue, decl_span) {\n@@ -189,7 +200,7 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n         match context {\n             PlaceContext::MutatingUse(MutatingUseContext::Call)\n             | PlaceContext::MutatingUse(MutatingUseContext::Yield) => {\n-                self.assign(local, location);\n+                self.assign(local, DefLocation::Body(location));\n             }\n \n             PlaceContext::NonUse(_) | PlaceContext::MutatingUse(MutatingUseContext::Retag) => {}"}, {"sha": "1728ef70cba0a7bd817b4db0a917b9060587c9db", "filename": "compiler/rustc_error_messages/locales/en-US/parse.ftl", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a29efccb1eff324c63454677688b5d7e08b5f40f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/a29efccb1eff324c63454677688b5d7e08b5f40f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl?ref=a29efccb1eff324c63454677688b5d7e08b5f40f", "patch": "@@ -199,6 +199,17 @@ parse_match_arm_body_without_braces = `match` arm body without braces\n         } with a body\n     .suggestion_use_comma_not_semicolon = use a comma to end a `match` arm expression\n \n+parse_inclusive_range_extra_equals = unexpected `=` after inclusive range\n+    .suggestion_remove_eq = use `..=` instead\n+    .note = inclusive ranges end with a single equals sign (`..=`)\n+\n+parse_inclusive_range_match_arrow = unexpected `=>` after open range\n+    .suggestion_add_space = add a space between the pattern and `=>`\n+\n+parse_inclusive_range_no_end = inclusive range with no end\n+    .suggestion_open_range = use `..` instead\n+    .note = inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+\n parse_struct_literal_not_allowed_here = struct literals are not allowed here\n     .suggestion = surround the struct literal with parentheses\n "}, {"sha": "054b41b478d60516d53c729faa2f1ecdcd1bb5d9", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a29efccb1eff324c63454677688b5d7e08b5f40f/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29efccb1eff324c63454677688b5d7e08b5f40f/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=a29efccb1eff324c63454677688b5d7e08b5f40f", "patch": "@@ -649,6 +649,48 @@ pub(crate) struct MatchArmBodyWithoutBraces {\n     pub sub: MatchArmBodyWithoutBracesSugg,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(parse_inclusive_range_extra_equals)]\n+#[note]\n+pub(crate) struct InclusiveRangeExtraEquals {\n+    #[primary_span]\n+    #[suggestion(\n+        suggestion_remove_eq,\n+        style = \"short\",\n+        code = \"..=\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_inclusive_range_match_arrow)]\n+pub(crate) struct InclusiveRangeMatchArrow {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(\n+        suggestion_add_space,\n+        style = \"verbose\",\n+        code = \" \",\n+        applicability = \"machine-applicable\"\n+    )]\n+    pub after_pat: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_inclusive_range_no_end, code = \"E0586\")]\n+#[note]\n+pub(crate) struct InclusiveRangeNoEnd {\n+    #[primary_span]\n+    #[suggestion(\n+        suggestion_open_range,\n+        code = \"..\",\n+        applicability = \"machine-applicable\",\n+        style = \"short\"\n+    )]\n+    pub span: Span,\n+}\n+\n #[derive(Subdiagnostic)]\n pub(crate) enum MatchArmBodyWithoutBracesSugg {\n     #[multipart_suggestion(suggestion_add_braces, applicability = \"machine-applicable\")]"}, {"sha": "17d1e200b41aab6bd677a8e0c9e19d7104194056", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a29efccb1eff324c63454677688b5d7e08b5f40f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29efccb1eff324c63454677688b5d7e08b5f40f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=a29efccb1eff324c63454677688b5d7e08b5f40f", "patch": "@@ -3168,7 +3168,7 @@ impl<'a> Parser<'a> {\n         limits: RangeLimits,\n     ) -> ExprKind {\n         if end.is_none() && limits == RangeLimits::Closed {\n-            self.inclusive_range_with_incorrect_end(self.prev_token.span);\n+            self.inclusive_range_with_incorrect_end();\n             ExprKind::Err\n         } else {\n             ExprKind::Range(start, end, limits)"}, {"sha": "912f7cc14f6cc238589469007013becf9d6239c2", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 30, "deletions": 23, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a29efccb1eff324c63454677688b5d7e08b5f40f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29efccb1eff324c63454677688b5d7e08b5f40f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=a29efccb1eff324c63454677688b5d7e08b5f40f", "patch": "@@ -1,5 +1,7 @@\n use super::{ForceCollect, Parser, PathStyle, TrailingToken};\n-use crate::errors::RemoveLet;\n+use crate::errors::{\n+    InclusiveRangeExtraEquals, InclusiveRangeMatchArrow, InclusiveRangeNoEnd, RemoveLet,\n+};\n use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n use rustc_ast::mut_visit::{noop_visit_pat, MutVisitor};\n use rustc_ast::ptr::P;\n@@ -9,7 +11,7 @@ use rustc_ast::{\n     PatField, PatKind, Path, QSelf, RangeEnd, RangeSyntax,\n };\n use rustc_ast_pretty::pprust;\n-use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, PResult};\n+use rustc_errors::{Applicability, DiagnosticBuilder, ErrorGuaranteed, PResult};\n use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_span::source_map::{respan, Span, Spanned};\n use rustc_span::symbol::{kw, sym, Ident};\n@@ -746,47 +748,52 @@ impl<'a> Parser<'a> {\n             // Parsing e.g. `X..`.\n             if let RangeEnd::Included(_) = re.node {\n                 // FIXME(Centril): Consider semantic errors instead in `ast_validation`.\n-                self.inclusive_range_with_incorrect_end(re.span);\n+                self.inclusive_range_with_incorrect_end();\n             }\n             None\n         };\n         Ok(PatKind::Range(Some(begin), end, re))\n     }\n \n-    pub(super) fn inclusive_range_with_incorrect_end(&mut self, span: Span) {\n+    pub(super) fn inclusive_range_with_incorrect_end(&mut self) {\n         let tok = &self.token;\n-\n+        let span = self.prev_token.span;\n         // If the user typed \"..==\" instead of \"..=\", we want to give them\n         // a specific error message telling them to use \"..=\".\n+        // If they typed \"..=>\", suggest they use \".. =>\".\n         // Otherwise, we assume that they meant to type a half open exclusive\n         // range and give them an error telling them to do that instead.\n-        if matches!(tok.kind, token::Eq) && tok.span.lo() == span.hi() {\n-            let span_with_eq = span.to(tok.span);\n+        let no_space = tok.span.lo() == span.hi();\n+        match tok.kind {\n+            token::Eq if no_space => {\n+                let span_with_eq = span.to(tok.span);\n \n-            // Ensure the user doesn't receive unhelpful unexpected token errors\n-            self.bump();\n-            if self.is_pat_range_end_start(0) {\n-                let _ = self.parse_pat_range_end().map_err(|e| e.cancel());\n-            }\n+                // Ensure the user doesn't receive unhelpful unexpected token errors\n+                self.bump();\n+                if self.is_pat_range_end_start(0) {\n+                    let _ = self.parse_pat_range_end().map_err(|e| e.cancel());\n+                }\n \n-            self.error_inclusive_range_with_extra_equals(span_with_eq);\n-        } else {\n-            self.error_inclusive_range_with_no_end(span);\n+                self.error_inclusive_range_with_extra_equals(span_with_eq);\n+            }\n+            token::Gt if no_space => {\n+                self.error_inclusive_range_match_arrow(span);\n+            }\n+            _ => self.error_inclusive_range_with_no_end(span),\n         }\n     }\n \n     fn error_inclusive_range_with_extra_equals(&self, span: Span) {\n-        self.struct_span_err(span, \"unexpected `=` after inclusive range\")\n-            .span_suggestion_short(span, \"use `..=` instead\", \"..=\", Applicability::MaybeIncorrect)\n-            .note(\"inclusive ranges end with a single equals sign (`..=`)\")\n-            .emit();\n+        self.sess.emit_err(InclusiveRangeExtraEquals { span });\n+    }\n+\n+    fn error_inclusive_range_match_arrow(&self, span: Span) {\n+        let after_pat = span.with_hi(span.hi() - rustc_span::BytePos(1)).shrink_to_hi();\n+        self.sess.emit_err(InclusiveRangeMatchArrow { span, after_pat });\n     }\n \n     fn error_inclusive_range_with_no_end(&self, span: Span) {\n-        struct_span_err!(self.sess.span_diagnostic, span, E0586, \"inclusive range with no end\")\n-            .span_suggestion_short(span, \"use `..` instead\", \"..\", Applicability::MachineApplicable)\n-            .note(\"inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\")\n-            .emit();\n+        self.sess.emit_err(InclusiveRangeNoEnd { span });\n     }\n \n     /// Parse a range-to pattern, `..X` or `..=X` where `X` remains to be parsed."}, {"sha": "e44fd82ba22362d1b26e06032c275027e36c39a2", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a29efccb1eff324c63454677688b5d7e08b5f40f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29efccb1eff324c63454677688b5d7e08b5f40f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=a29efccb1eff324c63454677688b5d7e08b5f40f", "patch": "@@ -78,7 +78,7 @@ pub(super) enum CandidateSource {\n     ///     let _y = x.clone();\n     /// }\n     /// ```\n-    AliasBound(usize),\n+    AliasBound,\n }\n \n pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy + Eq {\n@@ -242,8 +242,6 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             // NOTE: Alternatively we could call `evaluate_goal` here and only have a `Normalized` candidate.\n             // This doesn't work as long as we use `CandidateSource` in winnowing.\n             let goal = goal.with(tcx, goal.predicate.with_self_ty(tcx, normalized_ty));\n-            // FIXME: This is broken if we care about the `usize` of `AliasBound` because the self type\n-            // could be normalized to yet another projection with different item bounds.\n             let normalized_candidates = self.assemble_and_evaluate_candidates(goal);\n             for mut normalized_candidate in normalized_candidates {\n                 normalized_candidate.result =\n@@ -368,15 +366,14 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             ty::Alias(_, alias_ty) => alias_ty,\n         };\n \n-        for (i, (assumption, _)) in self\n+        for (assumption, _) in self\n             .tcx()\n             .bound_explicit_item_bounds(alias_ty.def_id)\n             .subst_iter_copied(self.tcx(), alias_ty.substs)\n-            .enumerate()\n         {\n             match G::consider_assumption(self, goal, assumption) {\n                 Ok(result) => {\n-                    candidates.push(Candidate { source: CandidateSource::AliasBound(i), result })\n+                    candidates.push(Candidate { source: CandidateSource::AliasBound, result })\n                 }\n                 Err(NoSolution) => (),\n             }"}, {"sha": "b175a6dde179f1378ab0570c69607a5bbce246df", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a29efccb1eff324c63454677688b5d7e08b5f40f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29efccb1eff324c63454677688b5d7e08b5f40f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=a29efccb1eff324c63454677688b5d7e08b5f40f", "patch": "@@ -171,7 +171,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             (CandidateSource::Impl(_), _)\n             | (CandidateSource::ParamEnv(_), _)\n             | (CandidateSource::BuiltinImpl, _)\n-            | (CandidateSource::AliasBound(_), _) => unimplemented!(),\n+            | (CandidateSource::AliasBound, _) => unimplemented!(),\n         }\n     }\n }"}, {"sha": "1ea8fb8fd3dcc8d0d40a2c9dd415e46d808bc101", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a29efccb1eff324c63454677688b5d7e08b5f40f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29efccb1eff324c63454677688b5d7e08b5f40f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=a29efccb1eff324c63454677688b5d7e08b5f40f", "patch": "@@ -322,7 +322,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         match (candidate.source, other.source) {\n             (CandidateSource::Impl(_), _)\n             | (CandidateSource::ParamEnv(_), _)\n-            | (CandidateSource::AliasBound(_), _)\n+            | (CandidateSource::AliasBound, _)\n             | (CandidateSource::BuiltinImpl, _) => unimplemented!(),\n         }\n     }"}, {"sha": "b7046dd7c598c923f80b9bf470d957ebd64851f1", "filename": "library/std/src/os/net/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a29efccb1eff324c63454677688b5d7e08b5f40f/library%2Fstd%2Fsrc%2Fos%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29efccb1eff324c63454677688b5d7e08b5f40f/library%2Fstd%2Fsrc%2Fos%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fnet%2Fmod.rs?ref=a29efccb1eff324c63454677688b5d7e08b5f40f", "patch": "@@ -1,4 +1,13 @@\n //! OS-specific networking functionality.\n \n+// See cfg macros in `library/std/src/os/mod.rs` for why these platforms must\n+// be special-cased during rustdoc generation.\n+#[cfg(not(all(\n+    doc,\n+    any(\n+        all(target_arch = \"wasm32\", not(target_os = \"wasi\")),\n+        all(target_vendor = \"fortanix\", target_env = \"sgx\")\n+    )\n+)))]\n #[cfg(any(target_os = \"linux\", target_os = \"android\", doc))]\n pub(super) mod linux_ext;"}, {"sha": "403a5e627f1e7fe6b2b6b71c0c2c13ede23a3f5a", "filename": "library/std/src/sys/common/alloc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a29efccb1eff324c63454677688b5d7e08b5f40f/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29efccb1eff324c63454677688b5d7e08b5f40f/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Falloc.rs?ref=a29efccb1eff324c63454677688b5d7e08b5f40f", "patch": "@@ -7,6 +7,7 @@ use crate::ptr;\n #[cfg(any(\n     target_arch = \"x86\",\n     target_arch = \"arm\",\n+    target_arch = \"m68k\",\n     target_arch = \"mips\",\n     target_arch = \"powerpc\",\n     target_arch = \"powerpc64\","}, {"sha": "522b3b7e851ff725ab97c2c4002eb47aeeb84740", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a29efccb1eff324c63454677688b5d7e08b5f40f/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29efccb1eff324c63454677688b5d7e08b5f40f/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=a29efccb1eff324c63454677688b5d7e08b5f40f", "patch": "@@ -1431,6 +1431,13 @@ impl Build {\n             return Vec::new();\n         }\n \n+        if !stamp.exists() {\n+            eprintln!(\n+                \"Warning: Unable to find the stamp file, did you try to keep a nonexistent build stage?\"\n+            );\n+            crate::detail_exit(1);\n+        }\n+\n         let mut paths = Vec::new();\n         let contents = t!(fs::read(stamp), &stamp);\n         // This is the method we use for extracting paths from the stamp file passed to us. See"}, {"sha": "7ba2b6d857cd0207ae19ee3eee3806ba65ad7f34", "filename": "tests/ui/half-open-range-patterns/half-open-range-pats-inclusive-match-arrow.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a29efccb1eff324c63454677688b5d7e08b5f40f/tests%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-inclusive-match-arrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29efccb1eff324c63454677688b5d7e08b5f40f/tests%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-inclusive-match-arrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-inclusive-match-arrow.rs?ref=a29efccb1eff324c63454677688b5d7e08b5f40f", "patch": "@@ -0,0 +1,8 @@\n+fn main() {\n+    let x = 42;\n+    match x {\n+        0..=73 => {},\n+        74..=> {},   //~ ERROR unexpected `=>` after open range\n+                     //~^ ERROR expected one of `=>`, `if`, or `|`, found `>`\n+    }\n+}"}, {"sha": "9ba6d15113cd648775785808181b66bb0782d73c", "filename": "tests/ui/half-open-range-patterns/half-open-range-pats-inclusive-match-arrow.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a29efccb1eff324c63454677688b5d7e08b5f40f/tests%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-inclusive-match-arrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a29efccb1eff324c63454677688b5d7e08b5f40f/tests%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-inclusive-match-arrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-inclusive-match-arrow.stderr?ref=a29efccb1eff324c63454677688b5d7e08b5f40f", "patch": "@@ -0,0 +1,19 @@\n+error: unexpected `=>` after open range\n+  --> $DIR/half-open-range-pats-inclusive-match-arrow.rs:5:11\n+   |\n+LL |         74..=> {},\n+   |           ^^^\n+   |\n+help: add a space between the pattern and `=>`\n+   |\n+LL |         74.. => {},\n+   |             +\n+\n+error: expected one of `=>`, `if`, or `|`, found `>`\n+  --> $DIR/half-open-range-pats-inclusive-match-arrow.rs:5:14\n+   |\n+LL |         74..=> {},\n+   |              ^ expected one of `=>`, `if`, or `|`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "5e2f10cefe92b9b22d9193f5dab13386f5e3fb56", "filename": "tests/ui/mir/mir_codegen_ssa.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a29efccb1eff324c63454677688b5d7e08b5f40f/tests%2Fui%2Fmir%2Fmir_codegen_ssa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29efccb1eff324c63454677688b5d7e08b5f40f/tests%2Fui%2Fmir%2Fmir_codegen_ssa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmir%2Fmir_codegen_ssa.rs?ref=a29efccb1eff324c63454677688b5d7e08b5f40f", "patch": "@@ -0,0 +1,19 @@\n+// build-pass\n+// compile-flags: --crate-type=lib\n+#![feature(custom_mir, core_intrinsics)]\n+use std::intrinsics::mir::*;\n+\n+#[custom_mir(dialect = \"runtime\", phase = \"optimized\")]\n+pub fn f(a: u32) -> u32 {\n+    mir!(\n+        let x: u32;\n+        {\n+            // Previously code generation failed with ICE \"use of .. before def ...\" because the\n+            // definition of x was incorrectly identified as dominating the use of x located in the\n+            // same statement:\n+            x = x + a;\n+            RET = x;\n+            Return()\n+        }\n+    )\n+}"}, {"sha": "0b9a3bae9619ce82cfd4af40de89fba768657a4f", "filename": "tests/ui/moves/pin-mut-reborrow-infer-var-issue-107419.fixed", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a29efccb1eff324c63454677688b5d7e08b5f40f/tests%2Fui%2Fmoves%2Fpin-mut-reborrow-infer-var-issue-107419.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a29efccb1eff324c63454677688b5d7e08b5f40f/tests%2Fui%2Fmoves%2Fpin-mut-reborrow-infer-var-issue-107419.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmoves%2Fpin-mut-reborrow-infer-var-issue-107419.fixed?ref=a29efccb1eff324c63454677688b5d7e08b5f40f", "patch": "@@ -0,0 +1,11 @@\n+// run-rustfix\n+use std::pin::Pin;\n+\n+fn foo(_: &mut ()) {}\n+\n+fn main() {\n+    let mut uwu = ();\n+    let mut r = Pin::new(&mut uwu);\n+    foo(r.as_mut().get_mut());\n+    foo(r.get_mut()); //~ ERROR use of moved value\n+}"}, {"sha": "0e952b06ee118164e148c4e5ca2a3a56a5f974f6", "filename": "tests/ui/moves/pin-mut-reborrow-infer-var-issue-107419.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a29efccb1eff324c63454677688b5d7e08b5f40f/tests%2Fui%2Fmoves%2Fpin-mut-reborrow-infer-var-issue-107419.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29efccb1eff324c63454677688b5d7e08b5f40f/tests%2Fui%2Fmoves%2Fpin-mut-reborrow-infer-var-issue-107419.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmoves%2Fpin-mut-reborrow-infer-var-issue-107419.rs?ref=a29efccb1eff324c63454677688b5d7e08b5f40f", "patch": "@@ -0,0 +1,11 @@\n+// run-rustfix\n+use std::pin::Pin;\n+\n+fn foo(_: &mut ()) {}\n+\n+fn main() {\n+    let mut uwu = ();\n+    let mut r = Pin::new(&mut uwu);\n+    foo(r.get_mut());\n+    foo(r.get_mut()); //~ ERROR use of moved value\n+}"}, {"sha": "7e513b73c21b219b9c61c10efeccaea093205266", "filename": "tests/ui/moves/pin-mut-reborrow-infer-var-issue-107419.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a29efccb1eff324c63454677688b5d7e08b5f40f/tests%2Fui%2Fmoves%2Fpin-mut-reborrow-infer-var-issue-107419.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a29efccb1eff324c63454677688b5d7e08b5f40f/tests%2Fui%2Fmoves%2Fpin-mut-reborrow-infer-var-issue-107419.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmoves%2Fpin-mut-reborrow-infer-var-issue-107419.stderr?ref=a29efccb1eff324c63454677688b5d7e08b5f40f", "patch": "@@ -0,0 +1,20 @@\n+error[E0382]: use of moved value: `r`\n+  --> $DIR/pin-mut-reborrow-infer-var-issue-107419.rs:10:9\n+   |\n+LL |     let mut r = Pin::new(&mut uwu);\n+   |         ----- move occurs because `r` has type `Pin<&mut ()>`, which does not implement the `Copy` trait\n+LL |     foo(r.get_mut());\n+   |           --------- `r` moved due to this method call\n+LL |     foo(r.get_mut());\n+   |         ^ value used here after move\n+   |\n+note: `Pin::<&'a mut T>::get_mut` takes ownership of the receiver `self`, which moves `r`\n+  --> $SRC_DIR/core/src/pin.rs:LL:COL\n+help: consider reborrowing the `Pin` instead of moving it\n+   |\n+LL |     foo(r.as_mut().get_mut());\n+   |           +++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0382`."}]}