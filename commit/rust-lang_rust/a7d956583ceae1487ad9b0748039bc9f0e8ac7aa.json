{"sha": "a7d956583ceae1487ad9b0748039bc9f0e8ac7aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3ZDk1NjU4M2NlYWUxNDg3YWQ5YjA3NDgwMzliYzlmMGU4YWM3YWE=", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-10-30T23:09:05Z"}, "committer": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-11-06T02:24:18Z"}, "message": "Responded to all feedback as of 2020-10-30", "tree": {"sha": "18fbdf8ee28787e044247590ed4f3119aee5ba70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18fbdf8ee28787e044247590ed4f3119aee5ba70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7d956583ceae1487ad9b0748039bc9f0e8ac7aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7d956583ceae1487ad9b0748039bc9f0e8ac7aa", "html_url": "https://github.com/rust-lang/rust/commit/a7d956583ceae1487ad9b0748039bc9f0e8ac7aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7d956583ceae1487ad9b0748039bc9f0e8ac7aa/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1973f84ebbb3b2bb4b9a1488b6553ac46b2db8d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/1973f84ebbb3b2bb4b9a1488b6553ac46b2db8d4", "html_url": "https://github.com/rust-lang/rust/commit/1973f84ebbb3b2bb4b9a1488b6553ac46b2db8d4"}], "stats": {"total": 575, "additions": 367, "deletions": 208}, "files": [{"sha": "d6c2f7f7aaf1d8812f67b581cb1a2a491012e73c", "filename": "compiler/rustc_mir/src/transform/coverage/counters.rs", "status": "modified", "additions": 151, "deletions": 146, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/a7d956583ceae1487ad9b0748039bc9f0e8ac7aa/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fcounters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d956583ceae1487ad9b0748039bc9f0e8ac7aa/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fcounters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fcounters.rs?ref=a7d956583ceae1487ad9b0748039bc9f0e8ac7aa", "patch": "@@ -12,16 +12,6 @@ use rustc_data_structures::graph::WithNumNodes;\n use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::coverage::*;\n \n-// When evaluating an expression operand to determine if it references a `Counter` or an\n-// `Expression`, the range of counter or expression IDs must be known in order to answer the\n-// question: \"Does this ID fall inside the range of counters,\" for example. If \"yes,\" the ID refers\n-// to a counter, otherwise the ID refers to an expression.\n-//\n-// But in situations where the range is not currently known, the only fallback is to assume a\n-// specific range limit. `MAX_COUNTER_GUARD` enforces a limit on the number of counters, and\n-// therefore a limit on the range of counter IDs.\n-pub(crate) const MAX_COUNTER_GUARD: u32 = (u32::MAX / 2) + 1;\n-\n /// Manages the counter and expression indexes/IDs to generate `CoverageKind` components for MIR\n /// `Coverage` statements.\n pub(crate) struct CoverageCounters {\n@@ -105,7 +95,6 @@ impl CoverageCounters {\n     /// Counter IDs start from one and go up.\n     fn next_counter(&mut self) -> CounterValueReference {\n         assert!(self.next_counter_id < u32::MAX - self.num_expressions);\n-        assert!(self.next_counter_id <= MAX_COUNTER_GUARD);\n         let next = self.next_counter_id;\n         self.next_counter_id += 1;\n         CounterValueReference::from(next)\n@@ -131,6 +120,7 @@ struct BcbCounters<'a> {\n     basic_coverage_blocks: &'a mut CoverageGraph,\n }\n \n+// FIXME(richkadel): Add unit tests for `BcbCounters` functions/algorithms.\n impl<'a> BcbCounters<'a> {\n     fn new(\n         coverage_counters: &'a mut CoverageCounters,\n@@ -139,7 +129,7 @@ impl<'a> BcbCounters<'a> {\n         Self { coverage_counters, basic_coverage_blocks }\n     }\n \n-    /// If two `CoverageGraph` branch from another `BasicCoverageBlock`, one of the branches\n+    /// If two `BasicCoverageBlock`s branch from another `BasicCoverageBlock`, one of the branches\n     /// can be counted by `Expression` by subtracting the other branch from the branching\n     /// block. Otherwise, the `BasicCoverageBlock` executed the least should have the `Counter`.\n     /// One way to predict which branch executes the least is by considering loops. A loop is exited\n@@ -162,10 +152,16 @@ impl<'a> BcbCounters<'a> {\n             bcbs_with_coverage.insert(covspan.bcb);\n         }\n \n-        // FIXME(richkadel): Add more comments to explain the logic here and in the rest of this\n-        // function, and refactor this function to break it up into smaller functions that are\n-        // easier to understand.\n-\n+        // Walk the `CoverageGraph`. For each `BasicCoverageBlock` node with an associated\n+        // `CoverageSpan`, add a counter. If the `BasicCoverageBlock` branches, add a counter or\n+        // expression to each branch `BasicCoverageBlock` (if the branch BCB has only one incoming\n+        // edge) or edge from the branching BCB to the branch BCB (if the branch BCB has multiple\n+        // incoming edges).\n+        //\n+        // The `TraverseCoverageGraphWithLoops` traversal ensures that, when a loop is encountered,\n+        // all `BasicCoverageBlock` nodes in the loop are visited before visiting any node outside\n+        // the loop. The `traversal` state includes a `context_stack`, providing a way to know if\n+        // the current BCB is in one or more nested loops or not.\n         let mut traversal = TraverseCoverageGraphWithLoops::new(&self.basic_coverage_blocks);\n         while let Some(bcb) = traversal.next(self.basic_coverage_blocks) {\n             if bcbs_with_coverage.contains(bcb) {\n@@ -220,11 +216,20 @@ impl<'a> BcbCounters<'a> {\n                 .join(\"\\n  \"),\n         );\n \n+        // Use the `traversal` state to decide if a subset of the branches exit a loop, making it\n+        // likely that branch is executed less than branches that do not exit the same loop. In this\n+        // case, any branch that does not exit the loop (and has not already been assigned a\n+        // counter) should be counted by expression, if possible. (If a preferred expression branch\n+        // is not selected based on the loop context, select any branch without an existing\n+        // counter.)\n         let expression_branch = self.choose_preferred_expression_branch(traversal, &branches);\n-        // Assign a Counter or Expression to each branch, plus additional\n-        // `Expression`s, as needed, to sum up intermediate results.\n+\n+        // Assign a Counter or Expression to each branch, plus additional `Expression`s, as needed,\n+        // to sum up intermediate results.\n         let mut some_sumup_counter_operand = None;\n         for branch in branches {\n+            // Skip the selected `expression_branch`, if any. It's expression will be assigned after\n+            // all others.\n             if branch != expression_branch {\n                 let branch_counter_operand = if branch.is_only_path_to_target() {\n                     debug!(\n@@ -263,6 +268,9 @@ impl<'a> BcbCounters<'a> {\n                 }\n             }\n         }\n+\n+        // Assign the final expression to the `expression_branch` by subtracting the total of all\n+        // other branches from the counter of the branching BCB.\n         let sumup_counter_operand =\n             some_sumup_counter_operand.expect(\"sumup_counter_operand should have a value\");\n         debug!(\n@@ -301,99 +309,99 @@ impl<'a> BcbCounters<'a> {\n         collect_intermediate_expressions: &mut Vec<CoverageKind>,\n         debug_indent_level: usize,\n     ) -> Result<ExpressionOperandId, Error> {\n-        Ok({\n-            if let Some(counter_kind) = self.basic_coverage_blocks[bcb].counter() {\n+        // If the BCB already has a counter, return it.\n+        if let Some(counter_kind) = self.basic_coverage_blocks[bcb].counter() {\n+            debug!(\n+                \"{}{:?} already has a counter: {}\",\n+                NESTED_INDENT.repeat(debug_indent_level),\n+                bcb,\n+                self.format_counter(counter_kind),\n+            );\n+            return Ok(counter_kind.as_operand_id());\n+        }\n+\n+        // A BCB with only one incoming edge gets a simple `Counter` (via `make_counter()`).\n+        // Also, a BCB that loops back to itself gets a simple `Counter`. This may indicate the\n+        // program results in a tight infinite loop, but it should still compile.\n+        let one_path_to_target = self.bcb_has_one_path_to_target(bcb);\n+        if one_path_to_target || self.bcb_predecessors(bcb).contains(&bcb) {\n+            let counter_kind = self.coverage_counters.make_counter(|| Some(format!(\"{:?}\", bcb)));\n+            if one_path_to_target {\n                 debug!(\n-                    \"{}{:?} already has a counter: {}\",\n+                    \"{}{:?} gets a new counter: {}\",\n                     NESTED_INDENT.repeat(debug_indent_level),\n                     bcb,\n-                    self.format_counter(counter_kind),\n+                    self.format_counter(&counter_kind),\n                 );\n-                counter_kind.as_operand_id()\n             } else {\n-                let one_path_to_target = self.bcb_has_one_path_to_target(bcb);\n-                if one_path_to_target || self.bcb_predecessors(bcb).contains(&bcb) {\n-                    let counter_kind =\n-                        self.coverage_counters.make_counter(|| Some(format!(\"{:?}\", bcb)));\n-                    if one_path_to_target {\n-                        debug!(\n-                            \"{}{:?} gets a new counter: {}\",\n-                            NESTED_INDENT.repeat(debug_indent_level),\n-                            bcb,\n-                            self.format_counter(&counter_kind),\n-                        );\n-                    } else {\n-                        debug!(\n-                            \"{}{:?} has itself as its own predecessor. It can't be part of its own \\\n-                            Expression sum, so it will get its own new counter: {}. (Note, the \\\n-                            compiled code will generate an infinite loop.)\",\n-                            NESTED_INDENT.repeat(debug_indent_level),\n-                            bcb,\n-                            self.format_counter(&counter_kind),\n-                        );\n-                    }\n-                    self.basic_coverage_blocks[bcb].set_counter(counter_kind)?\n-                } else {\n-                    let mut predecessors = self.bcb_predecessors(bcb).clone().into_iter();\n-                    debug!(\n-                        \"{}{:?} has multiple incoming edges and will get an expression that sums \\\n-                        them up...\",\n-                        NESTED_INDENT.repeat(debug_indent_level),\n-                        bcb,\n-                    );\n-                    let first_edge_counter_operand = self\n-                        .recursive_get_or_make_edge_counter_operand(\n-                            predecessors.next().unwrap(),\n-                            bcb,\n-                            collect_intermediate_expressions,\n-                            debug_indent_level + 1,\n-                        )?;\n-                    let mut some_sumup_edge_counter_operand = None;\n-                    for predecessor in predecessors {\n-                        let edge_counter_operand = self\n-                            .recursive_get_or_make_edge_counter_operand(\n-                                predecessor,\n-                                bcb,\n-                                collect_intermediate_expressions,\n-                                debug_indent_level + 1,\n-                            )?;\n-                        if let Some(sumup_edge_counter_operand) =\n-                            some_sumup_edge_counter_operand.replace(edge_counter_operand)\n-                        {\n-                            let intermediate_expression = self.coverage_counters.make_expression(\n-                                sumup_edge_counter_operand,\n-                                Op::Add,\n-                                edge_counter_operand,\n-                                || None,\n-                            );\n-                            debug!(\n-                                \"{}new intermediate expression: {}\",\n-                                NESTED_INDENT.repeat(debug_indent_level),\n-                                self.format_counter(&intermediate_expression)\n-                            );\n-                            let intermediate_expression_operand =\n-                                intermediate_expression.as_operand_id();\n-                            collect_intermediate_expressions.push(intermediate_expression);\n-                            some_sumup_edge_counter_operand\n-                                .replace(intermediate_expression_operand);\n-                        }\n-                    }\n-                    let counter_kind = self.coverage_counters.make_expression(\n-                        first_edge_counter_operand,\n-                        Op::Add,\n-                        some_sumup_edge_counter_operand.unwrap(),\n-                        || Some(format!(\"{:?}\", bcb)),\n-                    );\n-                    debug!(\n-                        \"{}{:?} gets a new counter (sum of predecessor counters): {}\",\n-                        NESTED_INDENT.repeat(debug_indent_level),\n-                        bcb,\n-                        self.format_counter(&counter_kind)\n-                    );\n-                    self.basic_coverage_blocks[bcb].set_counter(counter_kind)?\n-                }\n+                debug!(\n+                    \"{}{:?} has itself as its own predecessor. It can't be part of its own \\\n+                    Expression sum, so it will get its own new counter: {}. (Note, the compiled \\\n+                    code will generate an infinite loop.)\",\n+                    NESTED_INDENT.repeat(debug_indent_level),\n+                    bcb,\n+                    self.format_counter(&counter_kind),\n+                );\n             }\n-        })\n+            return self.basic_coverage_blocks[bcb].set_counter(counter_kind);\n+        }\n+\n+        // A BCB with multiple incoming edges can compute its count by `Expression`, summing up the\n+        // counters and/or expressions of its incoming edges. This will recursively get or create\n+        // counters for those incoming edges first, then call `make_expression()` to sum them up,\n+        // with additional intermediate expressions as needed.\n+        let mut predecessors = self.bcb_predecessors(bcb).clone().into_iter();\n+        debug!(\n+            \"{}{:?} has multiple incoming edges and will get an expression that sums them up...\",\n+            NESTED_INDENT.repeat(debug_indent_level),\n+            bcb,\n+        );\n+        let first_edge_counter_operand = self.recursive_get_or_make_edge_counter_operand(\n+            predecessors.next().unwrap(),\n+            bcb,\n+            collect_intermediate_expressions,\n+            debug_indent_level + 1,\n+        )?;\n+        let mut some_sumup_edge_counter_operand = None;\n+        for predecessor in predecessors {\n+            let edge_counter_operand = self.recursive_get_or_make_edge_counter_operand(\n+                predecessor,\n+                bcb,\n+                collect_intermediate_expressions,\n+                debug_indent_level + 1,\n+            )?;\n+            if let Some(sumup_edge_counter_operand) =\n+                some_sumup_edge_counter_operand.replace(edge_counter_operand)\n+            {\n+                let intermediate_expression = self.coverage_counters.make_expression(\n+                    sumup_edge_counter_operand,\n+                    Op::Add,\n+                    edge_counter_operand,\n+                    || None,\n+                );\n+                debug!(\n+                    \"{}new intermediate expression: {}\",\n+                    NESTED_INDENT.repeat(debug_indent_level),\n+                    self.format_counter(&intermediate_expression)\n+                );\n+                let intermediate_expression_operand = intermediate_expression.as_operand_id();\n+                collect_intermediate_expressions.push(intermediate_expression);\n+                some_sumup_edge_counter_operand.replace(intermediate_expression_operand);\n+            }\n+        }\n+        let counter_kind = self.coverage_counters.make_expression(\n+            first_edge_counter_operand,\n+            Op::Add,\n+            some_sumup_edge_counter_operand.unwrap(),\n+            || Some(format!(\"{:?}\", bcb)),\n+        );\n+        debug!(\n+            \"{}{:?} gets a new counter (sum of predecessor counters): {}\",\n+            NESTED_INDENT.repeat(debug_indent_level),\n+            bcb,\n+            self.format_counter(&counter_kind)\n+        );\n+        self.basic_coverage_blocks[bcb].set_counter(counter_kind)\n     }\n \n     fn get_or_make_edge_counter_operand(\n@@ -417,46 +425,44 @@ impl<'a> BcbCounters<'a> {\n         collect_intermediate_expressions: &mut Vec<CoverageKind>,\n         debug_indent_level: usize,\n     ) -> Result<ExpressionOperandId, Error> {\n-        Ok({\n-            let successors = self.bcb_successors(from_bcb).iter();\n-            if successors.len() > 1 {\n-                if let Some(counter_kind) =\n-                    self.basic_coverage_blocks[to_bcb].edge_counter_from(from_bcb)\n-                {\n-                    debug!(\n-                        \"{}Edge {:?}->{:?} already has a counter: {}\",\n-                        NESTED_INDENT.repeat(debug_indent_level),\n-                        from_bcb,\n-                        to_bcb,\n-                        self.format_counter(counter_kind)\n-                    );\n-                    counter_kind.as_operand_id()\n-                } else {\n-                    let counter_kind = self\n-                        .coverage_counters\n-                        .make_counter(|| Some(format!(\"{:?}->{:?}\", from_bcb, to_bcb)));\n-                    debug!(\n-                        \"{}Edge {:?}->{:?} gets a new counter: {}\",\n-                        NESTED_INDENT.repeat(debug_indent_level),\n-                        from_bcb,\n-                        to_bcb,\n-                        self.format_counter(&counter_kind)\n-                    );\n-                    self.basic_coverage_blocks[to_bcb]\n-                        .set_edge_counter_from(from_bcb, counter_kind)?\n-                }\n-            } else {\n-                self.recursive_get_or_make_counter_operand(\n-                    from_bcb,\n-                    collect_intermediate_expressions,\n-                    debug_indent_level + 1,\n-                )?\n-            }\n-        })\n+        // If the source BCB has only one successor (assumed to be the given target), an edge\n+        // counter is unnecessary. Just get or make a counter for the source BCB.\n+        let successors = self.bcb_successors(from_bcb).iter();\n+        if successors.len() == 1 {\n+            return self.recursive_get_or_make_counter_operand(\n+                from_bcb,\n+                collect_intermediate_expressions,\n+                debug_indent_level + 1,\n+            );\n+        }\n+\n+        // If the edge already has a counter, return it.\n+        if let Some(counter_kind) = self.basic_coverage_blocks[to_bcb].edge_counter_from(from_bcb) {\n+            debug!(\n+                \"{}Edge {:?}->{:?} already has a counter: {}\",\n+                NESTED_INDENT.repeat(debug_indent_level),\n+                from_bcb,\n+                to_bcb,\n+                self.format_counter(counter_kind)\n+            );\n+            return Ok(counter_kind.as_operand_id());\n+        }\n+\n+        // Make a new counter to count this edge.\n+        let counter_kind =\n+            self.coverage_counters.make_counter(|| Some(format!(\"{:?}->{:?}\", from_bcb, to_bcb)));\n+        debug!(\n+            \"{}Edge {:?}->{:?} gets a new counter: {}\",\n+            NESTED_INDENT.repeat(debug_indent_level),\n+            from_bcb,\n+            to_bcb,\n+            self.format_counter(&counter_kind)\n+        );\n+        self.basic_coverage_blocks[to_bcb].set_edge_counter_from(from_bcb, counter_kind)\n     }\n \n-    /// Select a branch for the expression, either the recommended `reloop_branch`, or\n-    /// if none was found, select any branch.\n+    /// Select a branch for the expression, either the recommended `reloop_branch`, or if none was\n+    /// found, select any branch.\n     fn choose_preferred_expression_branch(\n         &self,\n         traversal: &TraverseCoverageGraphWithLoops,\n@@ -493,9 +499,8 @@ impl<'a> BcbCounters<'a> {\n         }\n     }\n \n-    /// At most one of the branches (or its edge, from the branching_bcb,\n-    /// if the branch has multiple incoming edges) can have a counter computed by\n-    /// expression.\n+    /// At most, one of the branches (or its edge, from the branching_bcb, if the branch has\n+    /// multiple incoming edges) can have a counter computed by expression.\n     ///\n     /// If at least one of the branches leads outside of a loop (`found_loop_exit` is\n     /// true), and at least one other branch does not exit the loop (the first of which"}, {"sha": "cc697dfd7fe280d37e438dbbca6159b65d19c605", "filename": "compiler/rustc_mir/src/transform/coverage/debug.rs", "status": "modified", "additions": 120, "deletions": 9, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/a7d956583ceae1487ad9b0748039bc9f0e8ac7aa/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d956583ceae1487ad9b0748039bc9f0e8ac7aa/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs?ref=a7d956583ceae1487ad9b0748039bc9f0e8ac7aa", "patch": "@@ -1,3 +1,113 @@\n+//! The `InstrumentCoverage` MIR pass implementation includes debugging tools and options\n+//! to help developers understand and/or improve the analysis and instrumentation of a MIR.\n+//!\n+//! To enable coverage, include the rustc command line option:\n+//!\n+//!   * `-Z instrument-coverage`\n+//!\n+//! MIR Dump Files, with additional `CoverageGraph` graphviz and `CoverageSpan` spanview\n+//! ------------------------------------------------------------------------------------\n+//!\n+//! Additional debugging options include:\n+//!\n+//!   * `-Z dump-mir=InstrumentCoverage` - Generate `.mir` files showing the state of the MIR,\n+//!     before and after the `InstrumentCoverage` pass, for each compiled function.\n+//!\n+//!   * `-Z dump-mir-graphviz` - If `-Z dump-mir` is also enabled for the current MIR node path,\n+//!     each MIR dump is accompanied by a before-and-after graphical view of the MIR, in Graphviz\n+//!     `.dot` file format (which can be visually rendered as a graph using any of a number of free\n+//!     Graphviz viewers and IDE extensions).\n+//!\n+//!     For the `InstrumentCoverage` pass, this option also enables generation of an additional\n+//!     Graphviz `.dot` file for each function, rendering the `CoverageGraph`: the control flow\n+//!     graph (CFG) of `BasicCoverageBlocks` (BCBs), as nodes, internally labeled to show the\n+//!     `CoverageSpan`-based MIR elements each BCB represents (`BasicBlock`s, `Statement`s and\n+//!     `Terminator`s), assigned coverage counters and/or expressions, and edge counters, as needed.\n+//!\n+//!     (Note the additional option, `-Z graphviz-dark-mode`, can be added, to change the rendered\n+//!     output from its default black-on-white background to a dark color theme, if desired.)\n+//!\n+//!   * `-Z dump-mir-spanview` - If `-Z dump-mir` is also enabled for the current MIR node path,\n+//!     each MIR dump is accompanied by a before-and-after `.html` document showing the function's\n+//!     original source code, highlighted by it's MIR spans, at the `statement`-level (by default),\n+//!     `terminator` only, or encompassing span for the `Terminator` plus all `Statement`s, in each\n+//!     `block` (`BasicBlock`).\n+//!\n+//!     For the `InstrumentCoverage` pass, this option also enables generation of an additional\n+//!     spanview `.html` file for each function, showing the aggregated `CoverageSpan`s that will\n+//!     require counters (or counter expressions) for accurate coverage analysis.\n+//!\n+//! Debug Logging\n+//! -------------\n+//!\n+//! The `InstrumentCoverage` pass includes debug logging messages at various phases and decision\n+//! points, which can be enabled via environment variable:\n+//!\n+//! ```shell\n+//! RUSTC_LOG=rustc_mir::transform::coverage=debug\n+//! ```\n+//!\n+//! Other module paths with coverage-related debug logs may also be of interest, particularly for\n+//! debugging the coverage map data, injected as global variables in the LLVM IR (during rustc's\n+//! code generation pass). For example:\n+//!\n+//! ```shell\n+//! RUSTC_LOG=rustc_mir::transform::coverage,rustc_codegen_ssa::coverageinfo,rustc_codegen_llvm::coverageinfo=debug\n+//! ```\n+//!\n+//! Coverage Debug Options\n+//! ---------------------------------\n+//!\n+//! Additional debugging options can be enabled using the environment variable:\n+//!\n+//! ```shell\n+//! RUSTC_COVERAGE_DEBUG_OPTIONS=<options>\n+//! ```\n+//!\n+//! These options are comma-separated, and specified in the format `option-name=value`. For example:\n+//!\n+//! ```shell\n+//! $ RUSTC_COVERAGE_DEBUG_OPTIONS=counter-format=id+operation,allow-unused-expressions=yes cargo build\n+//! ```\n+//!\n+//! Coverage debug options include:\n+//!\n+//!   * `allow-unused-expressions=yes` or `no` (default: `no`)\n+//!\n+//!     The `InstrumentCoverage` algorithms _should_ only create and assign expressions to a\n+//!     `BasicCoverageBlock`, or an incoming edge, if that expression is either (a) required to\n+//!     count a `CoverageSpan`, or (b) a dependency of some other required counter expression.\n+//!\n+//!     If an expression is generated that does not map to a `CoverageSpan` or dependency, this\n+//!     probably indicates there was a bug in the algorithm that creates and assigns counters\n+//!     and expressions.\n+//!\n+//!     When this kind of bug is encountered, the rustc compiler will panic by default. Setting:\n+//!     `allow-unused-expressions=yes` will log a warning message instead of panicking (effectively\n+//!     ignoring the unused expressions), which may be helpful when debugging the root cause of\n+//!     the problem.\n+//!\n+//!   * `counter-format=<choices>`, where `<choices>` can be any plus-separated combination of `id`,\n+//!     `block`, and/or `operation` (default: `block+operation`)\n+//!\n+//!     This option effects both the `CoverageGraph` (graphviz `.dot` files) and debug logging, when\n+//!     generating labels for counters and expressions.\n+//!\n+//!     Depending on the values and combinations, counters can be labeled by:\n+//!\n+//!         * `id` - counter or expression ID (ascending counter IDs, starting at 1, or descending\n+//!           expression IDs, starting at `u32:MAX`)\n+//!         * `block` - the `BasicCoverageBlock` label (for example, `bcb0`) or edge label (for\n+//!           example `bcb0->bcb1`), for counters or expressions assigned to count a\n+//!           `BasicCoverageBlock` or edge. Intermediate expressions (not directly associated with\n+//!           a BCB or edge) will be labeled by their expression ID, unless `operation` is also\n+//!           specified.\n+//!         * `operation` - applied to expressions only, labels include the left-hand-side counter\n+//!           or expression label (lhs operand), the operator (`+` or `-`), and the right-hand-side\n+//!           counter or expression (rhs operand). Expression operand labels are generated\n+//!           recursively, generating labels with nested operations, enclosed in parentheses\n+//!           (for example: `bcb2 + (bcb0 - bcb1)`).\n+\n use super::graph::{BasicCoverageBlock, BasicCoverageBlockData, CoverageGraph};\n use super::spans::CoverageSpan;\n \n@@ -20,21 +130,19 @@ const RUSTC_COVERAGE_DEBUG_OPTIONS: &str = \"RUSTC_COVERAGE_DEBUG_OPTIONS\";\n pub(crate) fn debug_options<'a>() -> &'a DebugOptions {\n     static DEBUG_OPTIONS: SyncOnceCell<DebugOptions> = SyncOnceCell::new();\n \n-    &DEBUG_OPTIONS.get_or_init(|| DebugOptions::new())\n+    &DEBUG_OPTIONS.get_or_init(|| DebugOptions::from_env())\n }\n \n /// Parses and maintains coverage-specific debug options captured from the environment variable\n-/// \"RUSTC_COVERAGE_DEBUG_OPTIONS\", if set. Options can be set on the command line by, for example:\n-///\n-///     $ RUSTC_COVERAGE_DEBUG_OPTIONS=counter-format=block,allow_unused_expressions=n cargo build\n+/// \"RUSTC_COVERAGE_DEBUG_OPTIONS\", if set.\n #[derive(Debug, Clone)]\n pub(crate) struct DebugOptions {\n     pub allow_unused_expressions: bool,\n     counter_format: ExpressionFormat,\n }\n \n impl DebugOptions {\n-    fn new() -> Self {\n+    fn from_env() -> Self {\n         let mut allow_unused_expressions = true;\n         let mut counter_format = ExpressionFormat::default();\n \n@@ -152,10 +260,11 @@ impl DebugCounters {\n     }\n \n     pub fn enable(&mut self) {\n+        debug_assert!(!self.is_enabled());\n         self.some_counters.replace(FxHashMap::default());\n     }\n \n-    pub fn is_enabled(&mut self) -> bool {\n+    pub fn is_enabled(&self) -> bool {\n         self.some_counters.is_some()\n     }\n \n@@ -294,12 +403,13 @@ impl GraphvizData {\n     }\n \n     pub fn enable(&mut self) {\n+        debug_assert!(!self.is_enabled());\n         self.some_bcb_to_coverage_spans_with_counters = Some(FxHashMap::default());\n         self.some_bcb_to_dependency_counters = Some(FxHashMap::default());\n         self.some_edge_to_counter = Some(FxHashMap::default());\n     }\n \n-    pub fn is_enabled(&mut self) -> bool {\n+    pub fn is_enabled(&self) -> bool {\n         self.some_bcb_to_coverage_spans_with_counters.is_some()\n     }\n \n@@ -399,11 +509,12 @@ impl UsedExpressions {\n     }\n \n     pub fn enable(&mut self) {\n+        debug_assert!(!self.is_enabled());\n         self.some_used_expression_operands = Some(FxHashMap::default());\n         self.some_unused_expressions = Some(Vec::new());\n     }\n \n-    pub fn is_enabled(&mut self) -> bool {\n+    pub fn is_enabled(&self) -> bool {\n         self.some_used_expression_operands.is_some()\n     }\n \n@@ -416,7 +527,7 @@ impl UsedExpressions {\n         }\n     }\n \n-    pub fn expression_is_used(&mut self, expression: &CoverageKind) -> bool {\n+    pub fn expression_is_used(&self, expression: &CoverageKind) -> bool {\n         if let Some(used_expression_operands) = self.some_used_expression_operands.as_ref() {\n             used_expression_operands.contains_key(&expression.as_operand_id())\n         } else {"}, {"sha": "c2ed2cbb10002abd7632f86db2f19f0c904e3aed", "filename": "compiler/rustc_mir/src/transform/coverage/graph.rs", "status": "modified", "additions": 45, "deletions": 21, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a7d956583ceae1487ad9b0748039bc9f0e8ac7aa/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d956583ceae1487ad9b0748039bc9f0e8ac7aa/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fgraph.rs?ref=a7d956583ceae1487ad9b0748039bc9f0e8ac7aa", "patch": "@@ -82,6 +82,8 @@ impl CoverageGraph {\n         // each block terminator's `successors()`. Coverage spans must map to actual source code,\n         // so compiler generated blocks and paths can be ignored. To that end, the CFG traversal\n         // intentionally omits unwind paths.\n+        // FIXME(#78544): MIR InstrumentCoverage: Improve coverage of `#[should_panic]` tests and\n+        // `catch_unwind()` handlers.\n         let mir_cfg_without_unwind = ShortCircuitPreorder::new(&mir_body, bcb_filtered_successors);\n \n         let mut basic_blocks = Vec::new();\n@@ -288,7 +290,8 @@ rustc_index::newtype_index! {\n ///   * The BCB CFG ignores (trims) branches not relevant to coverage, such as unwind-related code,\n ///     that is injected by the Rust compiler but has no physical source code to count. This also\n ///     means a BasicBlock with a `Call` terminator can be merged into its primary successor target\n-///     block, in the same BCB.\n+///     block, in the same BCB. (But, note: Issue #78544: \"MIR InstrumentCoverage: Improve coverage\n+///     of `#[should_panic]` tests and `catch_unwind()` handlers\")\n ///   * Some BasicBlock terminators support Rust-specific concerns--like borrow-checking--that are\n ///     not relevant to coverage analysis. `FalseUnwind`, for example, can be treated the same as\n ///     a `Goto`, and merged with its successor into the same BCB.\n@@ -329,7 +332,6 @@ impl BasicCoverageBlockData {\n         &mir_body[self.last_bb()].terminator()\n     }\n \n-    #[inline(always)]\n     pub fn set_counter(\n         &mut self,\n         counter_kind: CoverageKind,\n@@ -342,16 +344,15 @@ impl BasicCoverageBlockData {\n             \"attempt to add a `Counter` to a BCB target with existing incoming edge counters\"\n         );\n         let operand = counter_kind.as_operand_id();\n-        let expect_none = self.counter_kind.replace(counter_kind);\n-        if expect_none.is_some() {\n-            return Error::from_string(format!(\n+        if let Some(replaced) = self.counter_kind.replace(counter_kind) {\n+            Error::from_string(format!(\n                 \"attempt to set a BasicCoverageBlock coverage counter more than once; \\\n                 {:?} already had counter {:?}\",\n-                self,\n-                expect_none.unwrap(),\n-            ));\n+                self, replaced,\n+            ))\n+        } else {\n+            Ok(operand)\n         }\n-        Ok(operand)\n     }\n \n     #[inline(always)]\n@@ -364,7 +365,6 @@ impl BasicCoverageBlockData {\n         self.counter_kind.take()\n     }\n \n-    #[inline(always)]\n     pub fn set_edge_counter_from(\n         &mut self,\n         from_bcb: BasicCoverageBlock,\n@@ -383,22 +383,22 @@ impl BasicCoverageBlockData {\n             }\n         }\n         let operand = counter_kind.as_operand_id();\n-        let expect_none = self\n+        if let Some(replaced) = self\n             .edge_from_bcbs\n             .get_or_insert_with(|| FxHashMap::default())\n-            .insert(from_bcb, counter_kind);\n-        if expect_none.is_some() {\n-            return Error::from_string(format!(\n+            .insert(from_bcb, counter_kind)\n+        {\n+            Error::from_string(format!(\n                 \"attempt to set an edge counter more than once; from_bcb: \\\n                 {:?} already had counter {:?}\",\n-                from_bcb,\n-                expect_none.unwrap(),\n-            ));\n+                from_bcb, replaced,\n+            ))\n+        } else {\n+            Ok(operand)\n         }\n-        Ok(operand)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn edge_counter_from(&self, from_bcb: BasicCoverageBlock) -> Option<&CoverageKind> {\n         if let Some(edge_from_bcbs) = &self.edge_from_bcbs {\n             edge_from_bcbs.get(&from_bcb)\n@@ -407,7 +407,7 @@ impl BasicCoverageBlockData {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn take_edge_counters(\n         &mut self,\n     ) -> Option<impl Iterator<Item = (BasicCoverageBlock, CoverageKind)>> {\n@@ -476,6 +476,9 @@ impl std::fmt::Debug for BcbBranch {\n     }\n }\n \n+// Returns the `Terminator`s non-unwind successors.\n+// FIXME(#78544): MIR InstrumentCoverage: Improve coverage of `#[should_panic]` tests and\n+// `catch_unwind()` handlers.\n fn bcb_filtered_successors<'a, 'tcx>(\n     body: &'tcx &'a mir::Body<'tcx>,\n     term_kind: &'tcx TerminatorKind<'tcx>,\n@@ -495,6 +498,7 @@ fn bcb_filtered_successors<'a, 'tcx>(\n /// Maintains separate worklists for each loop in the BasicCoverageBlock CFG, plus one for the\n /// CoverageGraph outside all loops. This supports traversing the BCB CFG in a way that\n /// ensures a loop is completely traversed before processing Blocks after the end of the loop.\n+// FIXME(richkadel): Add unit tests for TraversalContext.\n #[derive(Debug)]\n pub(crate) struct TraversalContext {\n     /// From one or more backedges returning to a loop header.\n@@ -644,7 +648,27 @@ fn find_loop_backedges(\n     let num_bcbs = basic_coverage_blocks.num_nodes();\n     let mut backedges = IndexVec::from_elem_n(Vec::<BasicCoverageBlock>::new(), num_bcbs);\n \n-    // Identify loops by their backedges\n+    // Identify loops by their backedges.\n+    //\n+    // The computational complexity is bounded by: n(s) x d where `n` is the number of\n+    // `BasicCoverageBlock` nodes (the simplified/reduced representation of the CFG derived from the\n+    // MIR); `s` is the average number of successors per node (which is most likely less than 2, and\n+    // independent of the size of the function, so it can be treated as a constant);\n+    // and `d` is the average number of dominators per node.\n+    //\n+    // The average number of dominators depends on the size and complexity of the function, and\n+    // nodes near the start of the function's control flow graph typically have less dominators\n+    // than nodes near the end of the CFG. Without doing a detailed mathematical analysis, I\n+    // think the resulting complexity has the characteristics of O(n log n).\n+    //\n+    // The overall complexity appears to be comparable to many other MIR transform algorithms, and I\n+    // don't expect that this function is creating a performance hot spot, but if this becomes an\n+    // issue, there may be ways to optimize the `is_dominated_by` algorithm (as indicated by an\n+    // existing `FIXME` comment in that code), or possibly ways to optimize it's usage here, perhaps\n+    // by keeping track of results for visited `BasicCoverageBlock`s if they can be used to short\n+    // circuit downstream `is_dominated_by` checks.\n+    //\n+    // For now, that kind of optimization seems unnecessarily complicated.\n     for (bcb, _) in basic_coverage_blocks.iter_enumerated() {\n         for &successor in &basic_coverage_blocks.successors[bcb] {\n             if basic_coverage_blocks.is_dominated_by(bcb, successor) {"}, {"sha": "c55349239b0344fdf0362afc5e6e20ae9d5136c7", "filename": "compiler/rustc_mir/src/transform/coverage/mod.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a7d956583ceae1487ad9b0748039bc9f0e8ac7aa/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d956583ceae1487ad9b0748039bc9f0e8ac7aa/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs?ref=a7d956583ceae1487ad9b0748039bc9f0e8ac7aa", "patch": "@@ -74,9 +74,6 @@ impl<'tcx> MirPass<'tcx> for InstrumentCoverage {\n             trace!(\"InstrumentCoverage skipped for {:?} (not an FnLikeNode)\", mir_source.def_id());\n             return;\n         }\n-        // FIXME(richkadel): By comparison, the MIR pass `ConstProp` includes associated constants,\n-        // with functions, methods, and closures. I assume Miri is used for associated constants as\n-        // well. If not, we may need to include them here too.\n \n         trace!(\"InstrumentCoverage starting for {:?}\", mir_source.def_id());\n         Instrumentor::new(&self.name(), tcx, mir_body).inject_counters();\n@@ -121,7 +118,10 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n         let mut graphviz_data = debug::GraphvizData::new();\n         let mut debug_used_expressions = debug::UsedExpressions::new();\n \n-        let dump_graphviz = tcx.sess.opts.debugging_opts.dump_mir_graphviz;\n+        let dump_mir = pretty::dump_enabled(tcx, self.pass_name, def_id);\n+        let dump_graphviz = dump_mir && tcx.sess.opts.debugging_opts.dump_mir_graphviz;\n+        let dump_spanview = dump_mir && tcx.sess.opts.debugging_opts.dump_mir_spanview.is_some();\n+\n         if dump_graphviz {\n             graphviz_data.enable();\n             self.coverage_counters.enable_debug();\n@@ -139,7 +139,7 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n             &self.basic_coverage_blocks,\n         );\n \n-        if pretty::dump_enabled(tcx, self.pass_name, def_id) {\n+        if dump_spanview {\n             debug::dump_coverage_spanview(\n                 tcx,\n                 self.mir_body,\n@@ -174,6 +174,13 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n                 ////////////////////////////////////////////////////\n                 // Remove the counter or edge counter from of each `CoverageSpan`s associated\n                 // `BasicCoverageBlock`, and inject a `Coverage` statement into the MIR.\n+                //\n+                // `Coverage` statements injected from `CoverageSpan`s will include the code regions\n+                // (source code start and end positions) to be counted by the associated counter.\n+                //\n+                // These `CoverageSpan`-associated counters are removed from their associated\n+                // `BasicCoverageBlock`s so that the only remaining counters in the `CoverageGraph`\n+                // are indirect counters (to be injected next, without associated code regions).\n                 self.inject_coverage_span_counters(\n                     coverage_spans,\n                     &mut graphviz_data,\n@@ -262,6 +269,8 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n                 bug!(\"Every BasicCoverageBlock should have a Counter or Expression\");\n             };\n             graphviz_data.add_bcb_coverage_span_with_counter(bcb, &covspan, &counter_kind);\n+            // FIXME(#78542): Can spans for `TerminatorKind::Goto` be improved to avoid special\n+            // cases?\n             let some_code_region = if self.is_code_region_redundant(bcb, span, body_span) {\n                 None\n             } else {\n@@ -280,6 +289,7 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n     ///\n     /// If this method returns `true`, the counter (which other `Expressions` may depend on) is\n     /// still injected, but without an associated code region.\n+    // FIXME(#78542): Can spans for `TerminatorKind::Goto` be improved to avoid special cases?\n     fn is_code_region_redundant(\n         &self,\n         bcb: BasicCoverageBlock,"}, {"sha": "e86bb96d29c30937432d71ba0327c37e4a624015", "filename": "compiler/rustc_mir/src/transform/coverage/query.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a7d956583ceae1487ad9b0748039bc9f0e8ac7aa/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d956583ceae1487ad9b0748039bc9f0e8ac7aa/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fquery.rs?ref=a7d956583ceae1487ad9b0748039bc9f0e8ac7aa", "patch": "@@ -1,5 +1,3 @@\n-use super::counters;\n-\n use rustc_middle::mir::coverage::*;\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::{Coverage, CoverageInfo, Location};\n@@ -44,11 +42,16 @@ struct CoverageVisitor {\n }\n \n impl CoverageVisitor {\n+    /// Updates `num_counters` to the maximum encountered zero-based counter_id plus 1. Note the\n+    /// final computed number of counters should be the number of all `CoverageKind::Counter`\n+    /// statements in the MIR *plus one* for the implicit `ZERO` counter.\n     #[inline(always)]\n     fn update_num_counters(&mut self, counter_id: u32) {\n         self.info.num_counters = std::cmp::max(self.info.num_counters, counter_id + 1);\n     }\n \n+    /// Computes an expression index for each expression ID, and updates `num_expressions` to the\n+    /// maximum encountered index plus 1.\n     #[inline(always)]\n     fn update_num_expressions(&mut self, expression_id: u32) {\n         let expression_index = u32::MAX - expression_id;\n@@ -59,10 +62,18 @@ impl CoverageVisitor {\n         if operand_id >= self.info.num_counters {\n             let operand_as_expression_index = u32::MAX - operand_id;\n             if operand_as_expression_index >= self.info.num_expressions {\n-                if operand_id <= counters::MAX_COUNTER_GUARD {\n-                    // Since the complete range of counter and expression IDs is not known here, the\n-                    // only way to determine if the ID is a counter ID or an expression ID is to\n-                    // assume a maximum possible counter ID value.\n+                // The operand ID is outside the known range of counter IDs and also outside the\n+                // known range of expression IDs. In either case, the result of a missing operand\n+                // (if and when used in an expression) will be zero, so from a computation\n+                // perspective, it doesn't matter whether it is interepretted as a counter or an\n+                // expression.\n+                //\n+                // However, the `num_counters` and `num_expressions` query results are used to\n+                // allocate arrays when generating the coverage map (during codegen), so choose\n+                // the type that grows either `num_counters` or `num_expressions` the least.\n+                if operand_id - self.info.num_counters\n+                    < operand_as_expression_index - self.info.num_expressions\n+                {\n                     self.update_num_counters(operand_id)\n                 } else {\n                     self.update_num_expressions(operand_id)\n@@ -100,7 +111,8 @@ fn coverageinfo_from_mir<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> CoverageInfo\n     let mir_body = tcx.optimized_mir(def_id);\n \n     let mut coverage_visitor = CoverageVisitor {\n-        info: CoverageInfo { num_counters: 0, num_expressions: 0 },\n+        // num_counters always has at least the `ZERO` counter.\n+        info: CoverageInfo { num_counters: 1, num_expressions: 0 },\n         add_missing_operands: false,\n     };\n "}, {"sha": "cda4fc125442f9bfb539d6f880d153665371d4c7", "filename": "compiler/rustc_mir/src/transform/coverage/spans.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a7d956583ceae1487ad9b0748039bc9f0e8ac7aa/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d956583ceae1487ad9b0748039bc9f0e8ac7aa/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs?ref=a7d956583ceae1487ad9b0748039bc9f0e8ac7aa", "patch": "@@ -656,7 +656,9 @@ fn filtered_statement_span(statement: &'a Statement<'tcx>, body_span: Span) -> O\n         // Ignore `Nop`s\n         | StatementKind::Nop => None,\n \n-        // FIXME(richkadel): Look into a possible issue assigning the span to a\n+        // FIXME(#78546): MIR InstrumentCoverage - Can the source_info.span for `FakeRead`\n+        // statements be more consistent?\n+        //\n         // FakeReadCause::ForGuardBinding, in this example:\n         //     match somenum {\n         //         x if x < 1 => { ... }\n@@ -669,15 +671,7 @@ fn filtered_statement_span(statement: &'a Statement<'tcx>, body_span: Span) -> O\n         //     _4 = &_1; (at the span for the first `x`)\n         // and `_1` is the `Place` for `somenum`.\n         //\n-        // The arm code BasicBlock already has its own assignment for `x` itself, `_3 = 1`, and I've\n-        // decided it's reasonable for that span (even though outside the arm code) to be part of\n-        // the counted coverage of the arm code execution, but I can't justify including the literal\n-        // `1` in the arm code. I'm pretty sure that, if the `FakeRead(ForGuardBinding)` has a\n-        // purpose in codegen, it's probably in the right BasicBlock, but if so, the `Statement`s\n-        // `source_info.span` can't be right.\n-        //\n-        // Consider correcting the span assignment, assuming there is a better solution, and see if\n-        // the following pattern can be removed here:\n+        // If and when the Issue is resolved, remove this special case match pattern:\n         StatementKind::FakeRead(cause, _) if cause == FakeReadCause::ForGuardBinding => None,\n \n         // Retain spans from all other statements\n@@ -710,13 +704,7 @@ fn filtered_terminator_span(terminator: &'a Terminator<'tcx>, body_span: Span) -\n         // `FalseEdge`.\n         | TerminatorKind::FalseEdge { .. } => None,\n \n-        // FIXME(richkadel): Note that `Goto` was initially filtered out (by returning `None`, as\n-        // with the `TerminatorKind`s above) because its `Span` was way to broad to be beneficial,\n-        // and, at the time, `Goto` didn't seem to provide any additional contributions to the\n-        // coverage analysis. Upon further review, `Goto` terminated blocks do appear to benefit\n-        // the coverage analysis, and the BCB CFG. To overcome the issues with the `Spans`, the\n-        // coverage algorithms--and the final coverage map generation--include some exceptional\n-        // behaviors.\n+        // FIXME(#78542): Can spans for `TerminatorKind::Goto` be improved to avoid special cases?\n         //\n         // `Goto`s are often the targets of `SwitchInt` branches, and certain important\n         // optimizations to replace some `Counter`s with `Expression`s require a separate\n@@ -750,7 +738,7 @@ fn filtered_terminator_span(terminator: &'a Terminator<'tcx>, body_span: Span) -\n     }\n }\n \n-#[inline(always)]\n+#[inline]\n fn function_source_span(span: Span, body_span: Span) -> Span {\n     let span = original_sp(span, body_span).with_ctxt(SyntaxContext::root());\n     if body_span.contains(span) { span } else { body_span }"}, {"sha": "ceed730e25b08a1d5f2b0066235f64b0203575e6", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a7d956583ceae1487ad9b0748039bc9f0e8ac7aa/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d956583ceae1487ad9b0748039bc9f0e8ac7aa/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=a7d956583ceae1487ad9b0748039bc9f0e8ac7aa", "patch": "@@ -887,12 +887,15 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n     dump_mir_exclude_pass_number: bool = (false, parse_bool, [UNTRACKED],\n         \"exclude the pass number when dumping MIR (used in tests) (default: no)\"),\n     dump_mir_graphviz: bool = (false, parse_bool, [UNTRACKED],\n-        \"in addition to `.mir` files, create graphviz `.dot` files (default: no)\"),\n+        \"in addition to `.mir` files, create graphviz `.dot` files (and with \\\n+        `-Z instrument-coverage`, also create a `.dot` file for the MIR-derived \\\n+        coverage graph) (default: no)\"),\n     dump_mir_spanview: Option<MirSpanview> = (None, parse_mir_spanview, [UNTRACKED],\n         \"in addition to `.mir` files, create `.html` files to view spans for \\\n         all `statement`s (including terminators), only `terminator` spans, or \\\n         computed `block` spans (one span encompassing a block's terminator and \\\n-        all statements).\"),\n+        all statements). If `-Z instrument-coverage` is also enabled, create \\\n+        an additional `.html` file showing the computed coverage spans.\"),\n     emit_future_incompat_report: bool = (false, parse_bool, [UNTRACKED],\n         \"emits a future-incompatibility report for lints (RFC 2834)\"),\n     emit_stack_sizes: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "ec93ca4725e37a20b5139a66db468ad2e191e07d", "filename": "src/test/run-make-fulldeps/coverage-spanview-base/Makefile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7d956583ceae1487ad9b0748039bc9f0e8ac7aa/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview-base%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/a7d956583ceae1487ad9b0748039bc9f0e8ac7aa/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview-base%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview-base%2FMakefile?ref=a7d956583ceae1487ad9b0748039bc9f0e8ac7aa", "patch": "@@ -26,6 +26,7 @@ endif\n \t\t\t-Zinstrument-coverage \\\n \t\t\t-Clink-dead-code=$(LINK_DEAD_CODE) \\\n \t\t\t-Zdump-mir=InstrumentCoverage \\\n+\t\t\t-Zdump-mir-spanview \\\n \t\t\t-Zdump-mir-dir=\"$(TMPDIR)\"/mir_dump.$@\n \n \tfor path in \"$(TMPDIR)\"/mir_dump.$@/*; do \\"}, {"sha": "17f7696a8cf1dc0ccbe70821d37a590ff8d2008d", "filename": "src/test/run-make-fulldeps/coverage/coverage_tools.mk", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a7d956583ceae1487ad9b0748039bc9f0e8ac7aa/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fcoverage_tools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/a7d956583ceae1487ad9b0748039bc9f0e8ac7aa/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fcoverage_tools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fcoverage_tools.mk?ref=a7d956583ceae1487ad9b0748039bc9f0e8ac7aa", "patch": "@@ -37,3 +37,8 @@ endif\n # tests can be simplified to always test with `-C link-dead-code`.\n \n UNAME = $(shell uname)\n+\n+# FIXME(richkadel): Can any of the features tested by `run-make-fulldeps/coverage-*` tests be tested\n+# just as completely by more focused unit tests of the code logic itself, to reduce the number of\n+# test result files generated and maintained, and to help identify specific test failures and root\n+# causes more easily?"}]}