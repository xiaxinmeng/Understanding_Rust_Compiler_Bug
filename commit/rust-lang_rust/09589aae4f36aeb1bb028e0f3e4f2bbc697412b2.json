{"sha": "09589aae4f36aeb1bb028e0f3e4f2bbc697412b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5NTg5YWFlNGYzNmFlYjFiYjAyOGUwZjNlNGYyYmJjNjk3NDEyYjI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-18T23:29:56Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-26T21:01:21Z"}, "message": "librustc: De-`@mut` `FnCtxt`.", "tree": {"sha": "acca9a816d20e61c8364c1e6ccd4506afb640c09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/acca9a816d20e61c8364c1e6ccd4506afb640c09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09589aae4f36aeb1bb028e0f3e4f2bbc697412b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09589aae4f36aeb1bb028e0f3e4f2bbc697412b2", "html_url": "https://github.com/rust-lang/rust/commit/09589aae4f36aeb1bb028e0f3e4f2bbc697412b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09589aae4f36aeb1bb028e0f3e4f2bbc697412b2/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9432327c4bacaccbf7602f916f450ab27dbe49e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9432327c4bacaccbf7602f916f450ab27dbe49e", "html_url": "https://github.com/rust-lang/rust/commit/c9432327c4bacaccbf7602f916f450ab27dbe49e"}], "stats": {"total": 206, "additions": 104, "deletions": 102}, "files": [{"sha": "28df3fa6654c3af65ffda8a5d6623191ce135e11", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09589aae4f36aeb1bb028e0f3e4f2bbc697412b2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09589aae4f36aeb1bb028e0f3e4f2bbc697412b2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=09589aae4f36aeb1bb028e0f3e4f2bbc697412b2", "patch": "@@ -25,7 +25,7 @@ use syntax::parse::token;\n use syntax::codemap::Span;\n use syntax::print::pprust;\n \n-pub fn check_match(fcx: @mut FnCtxt,\n+pub fn check_match(fcx: @FnCtxt,\n                    expr: @ast::Expr,\n                    discrim: @ast::Expr,\n                    arms: &[ast::Arm]) {\n@@ -102,7 +102,7 @@ pub fn check_match(fcx: @mut FnCtxt,\n }\n \n pub struct pat_ctxt {\n-    fcx: @mut FnCtxt,\n+    fcx: @FnCtxt,\n     map: PatIdMap,\n }\n "}, {"sha": "64b08d481e19618d1c248da9538853c04d577d6e", "filename": "src/librustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/09589aae4f36aeb1bb028e0f3e4f2bbc697412b2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09589aae4f36aeb1bb028e0f3e4f2bbc697412b2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=09589aae4f36aeb1bb028e0f3e4f2bbc697412b2", "patch": "@@ -20,17 +20,17 @@ use syntax::codemap::Span;\n \n // Requires that the two types unify, and prints an error message if they\n // don't.\n-pub fn suptype(fcx: @mut FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n+pub fn suptype(fcx: @FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n     suptype_with_fn(fcx, sp, false, expected, actual,\n         |sp, e, a, s| { fcx.report_mismatched_types(sp, e, a, s) })\n }\n \n-pub fn subtype(fcx: @mut FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n+pub fn subtype(fcx: @FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n     suptype_with_fn(fcx, sp, true, actual, expected,\n         |sp, a, e, s| { fcx.report_mismatched_types(sp, e, a, s) })\n }\n \n-pub fn suptype_with_fn(fcx: @mut FnCtxt,\n+pub fn suptype_with_fn(fcx: @FnCtxt,\n                        sp: Span,\n                        b_is_expected: bool,\n                        ty_a: ty::t,\n@@ -46,7 +46,7 @@ pub fn suptype_with_fn(fcx: @mut FnCtxt,\n     }\n }\n \n-pub fn eqtype(fcx: @mut FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n+pub fn eqtype(fcx: @FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n     match infer::mk_eqty(fcx.infcx(), false, infer::Misc(sp), actual, expected) {\n         Ok(()) => { /* ok */ }\n         Err(ref err) => {\n@@ -56,10 +56,7 @@ pub fn eqtype(fcx: @mut FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n }\n \n // Checks that the type `actual` can be coerced to `expected`.\n-pub fn coerce(fcx: @mut FnCtxt,\n-              sp: Span,\n-              expected: ty::t,\n-              expr: @ast::Expr) {\n+pub fn coerce(fcx: @FnCtxt, sp: Span, expected: ty::t, expr: @ast::Expr) {\n     let expr_ty = fcx.expr_ty(expr);\n     match fcx.mk_assignty(expr, expr_ty, expected) {\n       result::Ok(()) => { /* ok */ }"}, {"sha": "3838dce9472cc0bdafd1b2c06b7efc7208c24670", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/09589aae4f36aeb1bb028e0f3e4f2bbc697412b2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09589aae4f36aeb1bb028e0f3e4f2bbc697412b2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=09589aae4f36aeb1bb028e0f3e4f2bbc697412b2", "patch": "@@ -118,7 +118,7 @@ pub enum AutoderefReceiverFlag {\n }\n \n pub fn lookup(\n-        fcx: @mut FnCtxt,\n+        fcx: @FnCtxt,\n \n         // In a call `a.b::<X, Y, ...>(...)`:\n         expr: @ast::Expr,                   // The expression `a.b(...)`.\n@@ -168,7 +168,7 @@ pub fn lookup(\n }\n \n pub struct LookupContext<'a> {\n-    fcx: @mut FnCtxt,\n+    fcx: @FnCtxt,\n     expr: @ast::Expr,\n     self_expr: @ast::Expr,\n     callee_id: NodeId,\n@@ -1245,7 +1245,7 @@ impl<'a> LookupContext<'a> {\n             }\n         }\n \n-        fn rcvr_matches_ty(fcx: @mut FnCtxt,\n+        fn rcvr_matches_ty(fcx: @FnCtxt,\n                            rcvr_ty: ty::t,\n                            candidate: &Candidate) -> bool {\n             match candidate.rcvr_match_condition {"}, {"sha": "e3b1b6edfd7687abd3532b36f0c541bdbe2936de", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 76, "deletions": 71, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/09589aae4f36aeb1bb028e0f3e4f2bbc697412b2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09589aae4f36aeb1bb028e0f3e4f2bbc697412b2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=09589aae4f36aeb1bb028e0f3e4f2bbc697412b2", "patch": "@@ -110,6 +110,7 @@ use util::common::{block_query, indenter, loop_query};\n use util::ppaux::UserString;\n use util::ppaux;\n \n+use std::cell::{Cell, RefCell};\n use std::hashmap::HashMap;\n use std::result;\n use std::util::replace;\n@@ -226,7 +227,7 @@ pub struct FnCtxt {\n     err_count_on_creation: uint,\n \n     ret_ty: ty::t,\n-    ps: PurityState,\n+    ps: RefCell<PurityState>,\n \n     // Sometimes we generate region pointers where the precise region\n     // to use is not known. For example, an expression like `&x.f`\n@@ -241,7 +242,7 @@ pub struct FnCtxt {\n     // inference selects the ultimate value.  Finally, borrowck is\n     // charged with guaranteeing that the value whose address was taken\n     // can actually be made to live as long as it needs to live.\n-    region_lb: ast::NodeId,\n+    region_lb: Cell<ast::NodeId>,\n \n     // Says whether we're inside a for loop, in a do block\n     // or neither. Helps with error messages involving the\n@@ -274,17 +275,17 @@ impl Inherited {\n pub fn blank_fn_ctxt(ccx: @mut CrateCtxt,\n                      rty: ty::t,\n                      region_bnd: ast::NodeId)\n-                     -> @mut FnCtxt {\n+                     -> @FnCtxt {\n     // It's kind of a kludge to manufacture a fake function context\n     // and statement context, but we might as well do write the code only once\n     let param_env = ty::ParameterEnvironment { free_substs: substs::empty(),\n                                                self_param_bound: None,\n                                                type_param_bounds: ~[] };\n-    @mut FnCtxt {\n+    @FnCtxt {\n         err_count_on_creation: ccx.tcx.sess.err_count(),\n         ret_ty: rty,\n-        ps: PurityState::function(ast::impure_fn, 0),\n-        region_lb: region_bnd,\n+        ps: RefCell::new(PurityState::function(ast::impure_fn, 0)),\n+        region_lb: Cell::new(region_bnd),\n         fn_kind: Vanilla,\n         inh: @Inherited::new(ccx.tcx, param_env),\n         ccx: ccx\n@@ -339,7 +340,7 @@ pub fn check_bare_fn(ccx: @mut CrateCtxt,\n }\n \n struct GatherLocalsVisitor {\n-                     fcx: @mut FnCtxt,\n+                     fcx: @FnCtxt,\n                      tcx: ty::ctxt,\n }\n \n@@ -414,7 +415,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n                 id: ast::NodeId,\n                 body: ast::P<ast::Block>,\n                 fn_kind: FnKind,\n-                inherited: @Inherited) -> @mut FnCtxt\n+                inherited: @Inherited) -> @FnCtxt\n {\n     /*!\n      * Helper used by check_bare_fn and check_expr_fn.  Does the\n@@ -457,12 +458,12 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n \n     // Create the function context.  This is either derived from scratch or,\n     // in the case of function expressions, based on the outer context.\n-    let fcx: @mut FnCtxt = {\n-        @mut FnCtxt {\n+    let fcx: @FnCtxt = {\n+        @FnCtxt {\n             err_count_on_creation: err_count_on_creation,\n             ret_ty: ret_ty,\n-            ps: PurityState::function(purity, id),\n-            region_lb: body.id,\n+            ps: RefCell::new(PurityState::function(purity, id)),\n+            region_lb: Cell::new(body.id),\n             fn_kind: fn_kind,\n             inh: inherited,\n             ccx: ccx\n@@ -496,7 +497,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n \n     return fcx;\n \n-    fn gather_locals(fcx: @mut FnCtxt,\n+    fn gather_locals(fcx: @FnCtxt,\n                      decl: &ast::fn_decl,\n                      body: ast::P<ast::Block>,\n                      arg_tys: &[ty::t],\n@@ -1089,7 +1090,7 @@ impl FnCtxt {\n     }\n \n     pub fn block_region(&self) -> ty::Region {\n-        ty::ReScope(self.region_lb)\n+        ty::ReScope(self.region_lb.get())\n     }\n \n     #[inline]\n@@ -1143,7 +1144,7 @@ impl FnCtxt {\n     pub fn write_bot(&self, node_id: ast::NodeId) {\n         self.write_ty(node_id, ty::mk_bot());\n     }\n-    pub fn write_error(@mut self, node_id: ast::NodeId) {\n+    pub fn write_error(&self, node_id: ast::NodeId) {\n         self.write_ty(node_id, ty::mk_err());\n     }\n \n@@ -1257,11 +1258,11 @@ impl FnCtxt {\n         infer::mk_subr(self.infcx(), a_is_expected, origin, sub, sup)\n     }\n \n-    pub fn with_region_lb<R>(@mut self, lb: ast::NodeId, f: || -> R) -> R {\n-        let old_region_lb = self.region_lb;\n-        self.region_lb = lb;\n+    pub fn with_region_lb<R>(&self, lb: ast::NodeId, f: || -> R) -> R {\n+        let old_region_lb = self.region_lb.get();\n+        self.region_lb.set(lb);\n         let v = f();\n-        self.region_lb = old_region_lb;\n+        self.region_lb.set(old_region_lb);\n         v\n     }\n \n@@ -1294,7 +1295,7 @@ impl FnCtxt {\n     }\n }\n \n-pub fn do_autoderef(fcx: @mut FnCtxt, sp: Span, t: ty::t) -> (ty::t, uint) {\n+pub fn do_autoderef(fcx: @FnCtxt, sp: Span, t: ty::t) -> (ty::t, uint) {\n     /*!\n      *\n      * Autoderefs the type `t` as many times as possible, returning\n@@ -1351,7 +1352,7 @@ pub fn do_autoderef(fcx: @mut FnCtxt, sp: Span, t: ty::t) -> (ty::t, uint) {\n }\n \n // AST fragment checking\n-pub fn check_lit(fcx: @mut FnCtxt, lit: @ast::lit) -> ty::t {\n+pub fn check_lit(fcx: @FnCtxt, lit: @ast::lit) -> ty::t {\n     let tcx = fcx.ccx.tcx;\n \n     match lit.node {\n@@ -1390,34 +1391,34 @@ pub fn valid_range_bounds(ccx: @mut CrateCtxt,\n }\n \n pub fn check_expr_has_type(\n-    fcx: @mut FnCtxt, expr: @ast::Expr,\n+    fcx: @FnCtxt, expr: @ast::Expr,\n     expected: ty::t) {\n     check_expr_with_unifier(fcx, expr, Some(expected), || {\n         demand::suptype(fcx, expr.span, expected, fcx.expr_ty(expr));\n     });\n }\n \n pub fn check_expr_coercable_to_type(\n-    fcx: @mut FnCtxt, expr: @ast::Expr,\n+    fcx: @FnCtxt, expr: @ast::Expr,\n     expected: ty::t) {\n     check_expr_with_unifier(fcx, expr, Some(expected), || {\n         demand::coerce(fcx, expr.span, expected, expr)\n     });\n }\n \n pub fn check_expr_with_hint(\n-    fcx: @mut FnCtxt, expr: @ast::Expr,\n+    fcx: @FnCtxt, expr: @ast::Expr,\n     expected: ty::t) {\n     check_expr_with_unifier(fcx, expr, Some(expected), || ())\n }\n \n pub fn check_expr_with_opt_hint(\n-    fcx: @mut FnCtxt, expr: @ast::Expr,\n+    fcx: @FnCtxt, expr: @ast::Expr,\n     expected: Option<ty::t>)  {\n     check_expr_with_unifier(fcx, expr, expected, || ())\n }\n \n-pub fn check_expr(fcx: @mut FnCtxt, expr: @ast::Expr)  {\n+pub fn check_expr(fcx: @FnCtxt, expr: @ast::Expr)  {\n     check_expr_with_unifier(fcx, expr, None, || ())\n }\n \n@@ -1489,7 +1490,7 @@ fn generics_of_static_method_container(type_context: ty::ctxt,\n \n // Verifies that type parameters supplied in paths are in the right\n // locations.\n-fn check_type_parameter_positions_in_path(function_context: @mut FnCtxt,\n+fn check_type_parameter_positions_in_path(function_context: @FnCtxt,\n                                           path: &ast::Path,\n                                           def: ast::Def) {\n     // We only care about checking the case in which the path has two or\n@@ -1623,14 +1624,14 @@ fn check_type_parameter_positions_in_path(function_context: @mut FnCtxt,\n /// Note that inspecting a type's structure *directly* may expose the fact\n /// that there are actually multiple representations for both `ty_err` and\n /// `ty_bot`, so avoid that when err and bot need to be handled differently.\n-pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n+pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                                expr: @ast::Expr,\n                                expected: Option<ty::t>,\n                                unifier: ||) {\n     debug!(\">> typechecking\");\n \n     fn check_method_argument_types(\n-        fcx: @mut FnCtxt,\n+        fcx: @FnCtxt,\n         sp: Span,\n         method_fn_ty: ty::t,\n         callee_expr: @ast::Expr,\n@@ -1659,7 +1660,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         }\n     }\n \n-    fn check_argument_types(fcx: @mut FnCtxt,\n+    fn check_argument_types(fcx: @FnCtxt,\n                             sp: Span,\n                             fn_inputs: &[ty::t],\n                             callee_expr: @ast::Expr,\n@@ -1809,7 +1810,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     }\n \n     // A generic function for checking assignment expressions\n-    fn check_assignment(fcx: @mut FnCtxt,\n+    fn check_assignment(fcx: @FnCtxt,\n                         lhs: @ast::Expr,\n                         rhs: @ast::Expr,\n                         id: ast::NodeId) {\n@@ -1820,7 +1821,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         // The callee checks for bot / err, we don't need to\n     }\n \n-    fn write_call(fcx: @mut FnCtxt,\n+    fn write_call(fcx: @FnCtxt,\n                   call_expr: @ast::Expr,\n                   output: ty::t,\n                   sugar: ast::CallSugar) {\n@@ -1841,7 +1842,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     }\n \n     // A generic function for doing all of the checking for call expressions\n-    fn check_call(fcx: @mut FnCtxt,\n+    fn check_call(fcx: @FnCtxt,\n                   callee_id: ast::NodeId,\n                   call_expr: @ast::Expr,\n                   f: @ast::Expr,\n@@ -1903,7 +1904,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     }\n \n     // Checks a method call.\n-    fn check_method_call(fcx: @mut FnCtxt,\n+    fn check_method_call(fcx: @FnCtxt,\n                          callee_id: ast::NodeId,\n                          expr: @ast::Expr,\n                          rcvr: @ast::Expr,\n@@ -1963,7 +1964,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n     // A generic function for checking the then and else in an if\n     // or if-check\n-    fn check_then_else(fcx: @mut FnCtxt,\n+    fn check_then_else(fcx: @FnCtxt,\n                        cond_expr: @ast::Expr,\n                        then_blk: &ast::Block,\n                        opt_else_expr: Option<@ast::Expr>,\n@@ -2002,7 +2003,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         fcx.write_ty(id, if_ty);\n     }\n \n-    fn lookup_op_method(fcx: @mut FnCtxt,\n+    fn lookup_op_method(fcx: @FnCtxt,\n                         callee_id: ast::NodeId,\n                         op_ex: @ast::Expr,\n                         self_ex: @ast::Expr,\n@@ -2040,7 +2041,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     }\n \n     // could be either a expr_binop or an expr_assign_binop\n-    fn check_binop(fcx: @mut FnCtxt,\n+    fn check_binop(fcx: @FnCtxt,\n                    callee_id: ast::NodeId,\n                    expr: @ast::Expr,\n                    op: ast::BinOp,\n@@ -2128,7 +2129,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         }\n     }\n \n-    fn check_user_binop(fcx: @mut FnCtxt,\n+    fn check_user_binop(fcx: @FnCtxt,\n                         callee_id: ast::NodeId,\n                         ex: @ast::Expr,\n                         lhs_expr: @ast::Expr,\n@@ -2170,7 +2171,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         ty::mk_err()\n     }\n \n-    fn check_user_unop(fcx: @mut FnCtxt,\n+    fn check_user_unop(fcx: @FnCtxt,\n                        callee_id: ast::NodeId,\n                        op_str: &str,\n                        mname: &str,\n@@ -2196,7 +2197,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     // resolution is not possible (e.g., no constraints yet present), just\n     // returns `none`.\n     fn unpack_expected<O>(\n-                       fcx: @mut FnCtxt,\n+                       fcx: @FnCtxt,\n                        expected: Option<ty::t>,\n                        unpack: |&ty::sty| -> Option<O>)\n                        -> Option<O> {\n@@ -2211,7 +2212,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         }\n     }\n \n-    fn check_expr_fn(fcx: @mut FnCtxt,\n+    fn check_expr_fn(fcx: @FnCtxt,\n                      expr: @ast::Expr,\n                      ast_sigil_opt: Option<ast::Sigil>,\n                      decl: &ast::fn_decl,\n@@ -2306,7 +2307,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         fcx.write_ty(expr.id, fty);\n \n         let (inherited_purity, id) =\n-            ty::determine_inherited_purity((fcx.ps.purity, fcx.ps.def),\n+            ty::determine_inherited_purity((fcx.ps.get().purity,\n+                                            fcx.ps.get().def),\n                                            (purity, expr.id),\n                                            sigil);\n \n@@ -2316,7 +2318,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n \n     // Check field access expressions\n-    fn check_field(fcx: @mut FnCtxt,\n+    fn check_field(fcx: @FnCtxt,\n                    expr: @ast::Expr,\n                    base: @ast::Expr,\n                    field: ast::Name,\n@@ -2387,7 +2389,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         fcx.write_error(expr.id);\n     }\n \n-    fn check_struct_or_variant_fields(fcx: @mut FnCtxt,\n+    fn check_struct_or_variant_fields(fcx: @FnCtxt,\n                                       struct_ty: ty::t,\n                                       span: Span,\n                                       class_id: ast::DefId,\n@@ -2480,7 +2482,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         }\n     }\n \n-    fn check_struct_constructor(fcx: @mut FnCtxt,\n+    fn check_struct_constructor(fcx: @FnCtxt,\n                                 id: ast::NodeId,\n                                 span: codemap::Span,\n                                 class_id: ast::DefId,\n@@ -2538,7 +2540,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         fcx.write_ty(id, struct_type);\n     }\n \n-    fn check_struct_enum_variant(fcx: @mut FnCtxt,\n+    fn check_struct_enum_variant(fcx: @FnCtxt,\n                                  id: ast::NodeId,\n                                  span: codemap::Span,\n                                  enum_id: ast::DefId,\n@@ -3069,7 +3071,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                 _ => false\n                             }\n                         }\n-                        fn types_compatible(fcx: @mut FnCtxt, sp: Span,\n+                        fn types_compatible(fcx: @FnCtxt, sp: Span,\n                                             t1: ty::t, t2: ty::t) -> bool {\n                             if !is_vec(t1) {\n                                 false\n@@ -3257,7 +3259,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     unifier();\n }\n \n-pub fn require_integral(fcx: @mut FnCtxt, sp: Span, t: ty::t) {\n+pub fn require_integral(fcx: @FnCtxt, sp: Span, t: ty::t) {\n     if !type_is_integral(fcx, sp, t) {\n         fcx.type_error_message(sp, |actual| {\n             format!(\"mismatched types: expected integral type but found `{}`\",\n@@ -3266,15 +3268,15 @@ pub fn require_integral(fcx: @mut FnCtxt, sp: Span, t: ty::t) {\n     }\n }\n \n-pub fn check_decl_initializer(fcx: @mut FnCtxt,\n+pub fn check_decl_initializer(fcx: @FnCtxt,\n                               nid: ast::NodeId,\n                               init: @ast::Expr)\n                             {\n     let local_ty = fcx.local_ty(init.span, nid);\n     check_expr_coercable_to_type(fcx, init, local_ty)\n }\n \n-pub fn check_decl_local(fcx: @mut FnCtxt, local: @ast::Local)  {\n+pub fn check_decl_local(fcx: @FnCtxt, local: @ast::Local)  {\n     let tcx = fcx.ccx.tcx;\n \n     let t = fcx.local_ty(local.span, local.id);\n@@ -3302,7 +3304,7 @@ pub fn check_decl_local(fcx: @mut FnCtxt, local: @ast::Local)  {\n     }\n }\n \n-pub fn check_stmt(fcx: @mut FnCtxt, stmt: @ast::Stmt)  {\n+pub fn check_stmt(fcx: @FnCtxt, stmt: @ast::Stmt)  {\n     let node_id;\n     let mut saw_bot = false;\n     let mut saw_err = false;\n@@ -3347,7 +3349,7 @@ pub fn check_stmt(fcx: @mut FnCtxt, stmt: @ast::Stmt)  {\n     }\n }\n \n-pub fn check_block_no_value(fcx: @mut FnCtxt, blk: &ast::Block)  {\n+pub fn check_block_no_value(fcx: @FnCtxt, blk: &ast::Block)  {\n     check_block_with_expected(fcx, blk, Some(ty::mk_nil()));\n     let blkty = fcx.node_ty(blk.id);\n     if ty::type_is_error(blkty) {\n@@ -3362,15 +3364,18 @@ pub fn check_block_no_value(fcx: @mut FnCtxt, blk: &ast::Block)  {\n     }\n }\n \n-pub fn check_block(fcx0: @mut FnCtxt, blk: &ast::Block)  {\n+pub fn check_block(fcx0: @FnCtxt, blk: &ast::Block)  {\n     check_block_with_expected(fcx0, blk, None)\n }\n \n-pub fn check_block_with_expected(fcx: @mut FnCtxt,\n+pub fn check_block_with_expected(fcx: @FnCtxt,\n                                  blk: &ast::Block,\n                                  expected: Option<ty::t>) {\n-    let purity_state = fcx.ps.recurse(blk);\n-    let prev = replace(&mut fcx.ps, purity_state);\n+    let prev = {\n+        let mut fcx_ps = fcx.ps.borrow_mut();\n+        let purity_state = fcx_ps.get().recurse(blk);\n+        replace(fcx_ps.get(), purity_state)\n+    };\n \n     fcx.with_region_lb(blk.id, || {\n         let mut warned = false;\n@@ -3427,7 +3432,7 @@ pub fn check_block_with_expected(fcx: @mut FnCtxt,\n         };\n     });\n \n-    fcx.ps = prev;\n+    fcx.ps.set(prev);\n }\n \n pub fn check_const(ccx: @mut CrateCtxt,\n@@ -3440,7 +3445,7 @@ pub fn check_const(ccx: @mut CrateCtxt,\n     check_const_with_ty(fcx, sp, e, declty);\n }\n \n-pub fn check_const_with_ty(fcx: @mut FnCtxt,\n+pub fn check_const_with_ty(fcx: @FnCtxt,\n                            _: Span,\n                            e: @ast::Expr,\n                            declty: ty::t) {\n@@ -3642,12 +3647,12 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n     check_instantiable(ccx.tcx, sp, id);\n }\n \n-pub fn lookup_def(fcx: @mut FnCtxt, sp: Span, id: ast::NodeId) -> ast::Def {\n+pub fn lookup_def(fcx: @FnCtxt, sp: Span, id: ast::NodeId) -> ast::Def {\n     lookup_def_ccx(fcx.ccx, sp, id)\n }\n \n // Returns the type parameter count and the type for the given definition.\n-pub fn ty_param_bounds_and_ty_for_def(fcx: @mut FnCtxt,\n+pub fn ty_param_bounds_and_ty_for_def(fcx: @FnCtxt,\n                                       sp: Span,\n                                       defn: ast::Def)\n                                    -> ty_param_bounds_and_ty {\n@@ -3697,7 +3702,7 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: @mut FnCtxt,\n \n // Instantiates the given path, which must refer to an item with the given\n // number of type parameters and type.\n-pub fn instantiate_path(fcx: @mut FnCtxt,\n+pub fn instantiate_path(fcx: @FnCtxt,\n                         pth: &ast::Path,\n                         tpt: ty_param_bounds_and_ty,\n                         def: ast::Def,\n@@ -3812,7 +3817,7 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n \n // Resolves `typ` by a single level if `typ` is a type variable.  If no\n // resolution is possible, then an error is reported.\n-pub fn structurally_resolved_type(fcx: @mut FnCtxt, sp: Span, tp: ty::t)\n+pub fn structurally_resolved_type(fcx: @FnCtxt, sp: Span, tp: ty::t)\n                                -> ty::t {\n     match infer::resolve_type(fcx.infcx(), tp, force_tvar) {\n         Ok(t_s) if !ty::type_is_ty_var(t_s) => t_s,\n@@ -3827,47 +3832,47 @@ pub fn structurally_resolved_type(fcx: @mut FnCtxt, sp: Span, tp: ty::t)\n }\n \n // Returns the one-level-deep structure of the given type.\n-pub fn structure_of<'a>(fcx: @mut FnCtxt, sp: Span, typ: ty::t)\n+pub fn structure_of<'a>(fcx: @FnCtxt, sp: Span, typ: ty::t)\n                         -> &'a ty::sty {\n     &ty::get(structurally_resolved_type(fcx, sp, typ)).sty\n }\n \n-pub fn type_is_integral(fcx: @mut FnCtxt, sp: Span, typ: ty::t) -> bool {\n+pub fn type_is_integral(fcx: @FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_integral(typ_s);\n }\n \n-pub fn type_is_scalar(fcx: @mut FnCtxt, sp: Span, typ: ty::t) -> bool {\n+pub fn type_is_scalar(fcx: @FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_scalar(typ_s);\n }\n \n-pub fn type_is_char(fcx: @mut FnCtxt, sp: Span, typ: ty::t) -> bool {\n+pub fn type_is_char(fcx: @FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_char(typ_s);\n }\n \n-pub fn type_is_bare_fn(fcx: @mut FnCtxt, sp: Span, typ: ty::t) -> bool {\n+pub fn type_is_bare_fn(fcx: @FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_bare_fn(typ_s);\n }\n \n-pub fn type_is_unsafe_ptr(fcx: @mut FnCtxt, sp: Span, typ: ty::t) -> bool {\n+pub fn type_is_unsafe_ptr(fcx: @FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_unsafe_ptr(typ_s);\n }\n \n-pub fn type_is_region_ptr(fcx: @mut FnCtxt, sp: Span, typ: ty::t) -> bool {\n+pub fn type_is_region_ptr(fcx: @FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_region_ptr(typ_s);\n }\n \n-pub fn type_is_c_like_enum(fcx: @mut FnCtxt, sp: Span, typ: ty::t) -> bool {\n+pub fn type_is_c_like_enum(fcx: @FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_c_like_enum(fcx.ccx.tcx, typ_s);\n }\n \n-pub fn ast_expr_vstore_to_vstore(fcx: @mut FnCtxt,\n+pub fn ast_expr_vstore_to_vstore(fcx: @FnCtxt,\n                                  e: @ast::Expr,\n                                  v: ast::ExprVstore)\n                               -> ty::vstore {"}, {"sha": "490405bb49d4380e47c57e0390aa192b5060cdeb", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09589aae4f36aeb1bb028e0f3e4f2bbc697412b2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09589aae4f36aeb1bb028e0f3e4f2bbc697412b2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=09589aae4f36aeb1bb028e0f3e4f2bbc697412b2", "patch": "@@ -47,14 +47,14 @@ use syntax::visit;\n use syntax::visit::Visitor;\n \n pub struct Rcx {\n-    fcx: @mut FnCtxt,\n+    fcx: @FnCtxt,\n     errors_reported: uint,\n \n     // id of innermost fn or loop\n     repeating_scope: ast::NodeId,\n }\n \n-fn encl_region_of_def(fcx: @mut FnCtxt, def: ast::Def) -> ty::Region {\n+fn encl_region_of_def(fcx: @FnCtxt, def: ast::Def) -> ty::Region {\n     let tcx = fcx.tcx();\n     match def {\n         DefLocal(node_id, _) | DefArg(node_id, _) |\n@@ -141,7 +141,7 @@ impl Rcx {\n     }\n }\n \n-pub fn regionck_expr(fcx: @mut FnCtxt, e: @ast::Expr) {\n+pub fn regionck_expr(fcx: @FnCtxt, e: @ast::Expr) {\n     let mut rcx = Rcx { fcx: fcx, errors_reported: 0,\n                          repeating_scope: e.id };\n     let rcx = &mut rcx;\n@@ -152,7 +152,7 @@ pub fn regionck_expr(fcx: @mut FnCtxt, e: @ast::Expr) {\n     fcx.infcx().resolve_regions();\n }\n \n-pub fn regionck_fn(fcx: @mut FnCtxt, blk: ast::P<ast::Block>) {\n+pub fn regionck_fn(fcx: @FnCtxt, blk: ast::P<ast::Block>) {\n     let mut rcx = Rcx { fcx: fcx, errors_reported: 0,\n                          repeating_scope: blk.id };\n     let rcx = &mut rcx;"}, {"sha": "cae7eff325b38aa2c81f5b6fcedb93b836bdaca2", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/09589aae4f36aeb1bb028e0f3e4f2bbc697412b2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09589aae4f36aeb1bb028e0f3e4f2bbc697412b2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=09589aae4f36aeb1bb028e0f3e4f2bbc697412b2", "patch": "@@ -528,7 +528,7 @@ fn connect_trait_tps(vcx: &VtableContext,\n     relate_trait_refs(vcx, location_info, impl_trait_ref, trait_ref);\n }\n \n-fn insert_vtables(fcx: @mut FnCtxt,\n+fn insert_vtables(fcx: @FnCtxt,\n                   callee_id: ast::NodeId,\n                   vtables: vtable_res) {\n     debug!(\"insert_vtables(callee_id={}, vtables={:?})\",\n@@ -550,7 +550,7 @@ pub fn location_info_for_item(item: @ast::item) -> LocationInfo {\n }\n \n pub fn early_resolve_expr(ex: @ast::Expr,\n-                          fcx: @mut FnCtxt,\n+                          fcx: @FnCtxt,\n                           is_early: bool) {\n     debug!(\"vtable: early_resolve_expr() ex with id {:?} (early: {}): {}\",\n            ex.id, is_early, expr_to_str(ex, fcx.tcx().sess.intr()));\n@@ -715,7 +715,7 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n     }\n }\n \n-fn resolve_expr(fcx: @mut FnCtxt,\n+fn resolve_expr(fcx: @FnCtxt,\n                 ex: @ast::Expr) {\n     let mut fcx = fcx;\n     early_resolve_expr(ex, fcx, false);\n@@ -776,7 +776,7 @@ pub fn resolve_impl(ccx: @mut CrateCtxt,\n     ccx.tcx.impl_vtables.insert(impl_def_id, res);\n }\n \n-impl visit::Visitor<()> for @mut FnCtxt {\n+impl visit::Visitor<()> for @FnCtxt {\n     fn visit_expr(&mut self, ex:@ast::Expr, _:()) {\n         resolve_expr(*self, ex);\n     }\n@@ -787,7 +787,7 @@ impl visit::Visitor<()> for @mut FnCtxt {\n \n // Detect points where a trait-bounded type parameter is\n // instantiated, resolve the impls for the parameters.\n-pub fn resolve_in_block(fcx: @mut FnCtxt, bl: ast::P<ast::Block>) {\n+pub fn resolve_in_block(fcx: @FnCtxt, bl: ast::P<ast::Block>) {\n     let mut fcx = fcx;\n     visit::walk_block(&mut fcx, bl, ());\n }"}, {"sha": "acccbb310d2eb3f4bf9817488adeccd5659dc229", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/09589aae4f36aeb1bb028e0f3e4f2bbc697412b2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09589aae4f36aeb1bb028e0f3e4f2bbc697412b2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=09589aae4f36aeb1bb028e0f3e4f2bbc697412b2", "patch": "@@ -32,7 +32,7 @@ use syntax::print::pprust::pat_to_str;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n-fn resolve_type_vars_in_type(fcx: @mut FnCtxt, sp: Span, typ: ty::t)\n+fn resolve_type_vars_in_type(fcx: @FnCtxt, sp: Span, typ: ty::t)\n                           -> Option<ty::t> {\n     if !ty::type_needs_infer(typ) { return Some(typ); }\n     match resolve_type(fcx.infcx(), typ, resolve_all | force_all) {\n@@ -50,7 +50,7 @@ fn resolve_type_vars_in_type(fcx: @mut FnCtxt, sp: Span, typ: ty::t)\n     }\n }\n \n-fn resolve_type_vars_in_types(fcx: @mut FnCtxt, sp: Span, tys: &[ty::t])\n+fn resolve_type_vars_in_types(fcx: @FnCtxt, sp: Span, tys: &[ty::t])\n                           -> ~[ty::t] {\n     tys.map(|t| {\n         match resolve_type_vars_in_type(fcx, sp, *t) {\n@@ -60,7 +60,7 @@ fn resolve_type_vars_in_types(fcx: @mut FnCtxt, sp: Span, tys: &[ty::t])\n     })\n }\n \n-fn resolve_method_map_entry(fcx: @mut FnCtxt, sp: Span, id: ast::NodeId) {\n+fn resolve_method_map_entry(fcx: @FnCtxt, sp: Span, id: ast::NodeId) {\n     // Resolve any method map entry\n     match fcx.inh.method_map.find(&id) {\n         None => {}\n@@ -80,7 +80,7 @@ fn resolve_method_map_entry(fcx: @mut FnCtxt, sp: Span, id: ast::NodeId) {\n     }\n }\n \n-fn resolve_vtable_map_entry(fcx: @mut FnCtxt, sp: Span, id: ast::NodeId) {\n+fn resolve_vtable_map_entry(fcx: @FnCtxt, sp: Span, id: ast::NodeId) {\n     // Resolve any method map entry\n     match fcx.inh.vtable_map.find(&id) {\n         None => {}\n@@ -93,12 +93,12 @@ fn resolve_vtable_map_entry(fcx: @mut FnCtxt, sp: Span, id: ast::NodeId) {\n         }\n     }\n \n-    fn resolve_origins(fcx: @mut FnCtxt, sp: Span,\n+    fn resolve_origins(fcx: @FnCtxt, sp: Span,\n                        vtbls: vtable_res) -> vtable_res {\n         @vtbls.map(|os| @os.map(|o| resolve_origin(fcx, sp, o)))\n     }\n \n-    fn resolve_origin(fcx: @mut FnCtxt,\n+    fn resolve_origin(fcx: @FnCtxt,\n                       sp: Span,\n                       origin: &vtable_origin) -> vtable_origin {\n         match origin {\n@@ -208,7 +208,7 @@ fn maybe_resolve_type_vars_for_node(wbcx: &mut WbCtxt,\n }\n \n struct WbCtxt {\n-    fcx: @mut FnCtxt,\n+    fcx: @FnCtxt,\n \n     // As soon as we hit an error we have to stop resolving\n     // the entire function.\n@@ -329,14 +329,14 @@ impl Visitor<()> for WbCtxt {\n     fn visit_ty(&mut self, _t: &ast::Ty, _:()) {}\n }\n \n-pub fn resolve_type_vars_in_expr(fcx: @mut FnCtxt, e: @ast::Expr) -> bool {\n+pub fn resolve_type_vars_in_expr(fcx: @FnCtxt, e: @ast::Expr) -> bool {\n     let mut wbcx = WbCtxt { fcx: fcx, success: true };\n     let wbcx = &mut wbcx;\n     wbcx.visit_expr(e, ());\n     return wbcx.success;\n }\n \n-pub fn resolve_type_vars_in_fn(fcx: @mut FnCtxt,\n+pub fn resolve_type_vars_in_fn(fcx: @FnCtxt,\n                                decl: &ast::fn_decl,\n                                blk: ast::P<ast::Block>,\n                                self_info: Option<SelfInfo>) -> bool {"}]}