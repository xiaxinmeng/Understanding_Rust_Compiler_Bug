{"sha": "648a8e314ad28293b721888839c3ac6a0184cf22", "node_id": "C_kwDOAAsO6NoAKDY0OGE4ZTMxNGFkMjgyOTNiNzIxODg4ODM5YzNhYzZhMDE4NGNmMjI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-02-26T06:52:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-26T06:52:44Z"}, "message": "Rollup merge of #94306 - Mark-Simulacrum:dom-fixups, r=jackh726\n\nAvoid exhausting stack space in dominator compression\n\nDoesn't add a test case -- I ended up running into this while playing with the generated example from #43578, which we could do with a run-make test (to avoid checking a large code snippet into tree), but I suspect we don't want to wait for it to compile (locally it takes ~14s -- not terrible, but doesn't seem worth it to me). In practice stack space exhaustion is difficult to test for, too, since if we set the bound too low a different call structure above us (e.g., a nearer ensure_sufficient_stack call) would let the test pass even with the old impl, most likely.\n\nLocally it seems like this manages to perform approximately equivalently to the recursion, but will run perf to confirm.", "tree": {"sha": "509d8bc2da1015a7950ae99be0405e79629cdc0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/509d8bc2da1015a7950ae99be0405e79629cdc0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/648a8e314ad28293b721888839c3ac6a0184cf22", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiGc48CRBK7hj4Ov3rIwAAqpgIAKwH9n6Pp46084aBIWcc8cVs\nH+DnV7AwpEdZHAUlnlnof3VcW+c3ZCq9Z5O7F9635v/d8/94q1xhXTtkwof1EC7k\nipMF4QioRCfimVSWcyZyQ2kV63Jlw4yT4Sl3qXG8qg6RVcVnztMXRFuWtsuwrsyX\n8y3956JDtGq39yV8FNLVoPJ+HRctiom0yhMYYnELPeb0E+FRFoSkexP5PHuqAIVk\n61MkbtmxGGDaOxVUOKpBopFPbFZga6II/ACh6rwmRemQjlzQtMhW+3/wQSLbCbgM\nkbcwHX8Scnmeuhy5r1VZ9uNDnK9HSzjD8/rlCJADxdhxfSEJpmAIUFmgSL0cj3Q=\n=JF5W\n-----END PGP SIGNATURE-----\n", "payload": "tree 509d8bc2da1015a7950ae99be0405e79629cdc0c\nparent d6ca3885842d5ad282d9631fb4c94a1ba9227434\nparent 4d89292785653e399512d85f95a9870836ec9632\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1645858364 +0100\ncommitter GitHub <noreply@github.com> 1645858364 +0100\n\nRollup merge of #94306 - Mark-Simulacrum:dom-fixups, r=jackh726\n\nAvoid exhausting stack space in dominator compression\n\nDoesn't add a test case -- I ended up running into this while playing with the generated example from #43578, which we could do with a run-make test (to avoid checking a large code snippet into tree), but I suspect we don't want to wait for it to compile (locally it takes ~14s -- not terrible, but doesn't seem worth it to me). In practice stack space exhaustion is difficult to test for, too, since if we set the bound too low a different call structure above us (e.g., a nearer ensure_sufficient_stack call) would let the test pass even with the old impl, most likely.\n\nLocally it seems like this manages to perform approximately equivalently to the recursion, but will run perf to confirm.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/648a8e314ad28293b721888839c3ac6a0184cf22", "html_url": "https://github.com/rust-lang/rust/commit/648a8e314ad28293b721888839c3ac6a0184cf22", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/648a8e314ad28293b721888839c3ac6a0184cf22/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6ca3885842d5ad282d9631fb4c94a1ba9227434", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6ca3885842d5ad282d9631fb4c94a1ba9227434", "html_url": "https://github.com/rust-lang/rust/commit/d6ca3885842d5ad282d9631fb4c94a1ba9227434"}, {"sha": "4d89292785653e399512d85f95a9870836ec9632", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d89292785653e399512d85f95a9870836ec9632", "html_url": "https://github.com/rust-lang/rust/commit/4d89292785653e399512d85f95a9870836ec9632"}], "stats": {"total": 16, "additions": 13, "deletions": 3}, "files": [{"sha": "00913a483db0efe6bc39aeb1743f30ee2351181b", "filename": "compiler/rustc_data_structures/src/graph/dominators/mod.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/648a8e314ad28293b721888839c3ac6a0184cf22/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/648a8e314ad28293b721888839c3ac6a0184cf22/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs?ref=648a8e314ad28293b721888839c3ac6a0184cf22", "patch": "@@ -241,9 +241,19 @@ fn compress(\n     v: PreorderIndex,\n ) {\n     assert!(is_processed(v, lastlinked));\n-    let u = ancestor[v];\n-    if is_processed(u, lastlinked) {\n-        compress(ancestor, lastlinked, semi, label, u);\n+    // Compute the processed list of ancestors\n+    //\n+    // We use a heap stack here to avoid recursing too deeply, exhausting the\n+    // stack space.\n+    let mut stack: smallvec::SmallVec<[_; 8]> = smallvec::smallvec![v];\n+    let mut u = ancestor[v];\n+    while is_processed(u, lastlinked) {\n+        stack.push(u);\n+        u = ancestor[u];\n+    }\n+\n+    // Then in reverse order, popping the stack\n+    for &[v, u] in stack.array_windows().rev() {\n         if semi[label[u]] < semi[label[v]] {\n             label[v] = label[u];\n         }"}]}