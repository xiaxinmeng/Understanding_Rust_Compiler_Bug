{"sha": "c20ba9cdae257c70c934e2c9dc1a77c1798d8113", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyMGJhOWNkYWUyNTdjNzBjOTM0ZTJjOWRjMWE3N2MxNzk4ZDgxMTM=", "commit": {"author": {"name": "ltdk", "email": "usr@ltdk.xyz", "date": "2020-10-24T04:45:41Z"}, "committer": {"name": "ltdk", "email": "usr@ltdk.xyz", "date": "2021-03-28T21:38:25Z"}, "message": "Add escape_default method to u8 and [u8]", "tree": {"sha": "5bfe69b72db26981d752207762c5b820328afc0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5bfe69b72db26981d752207762c5b820328afc0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c20ba9cdae257c70c934e2c9dc1a77c1798d8113", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c20ba9cdae257c70c934e2c9dc1a77c1798d8113", "html_url": "https://github.com/rust-lang/rust/commit/c20ba9cdae257c70c934e2c9dc1a77c1798d8113", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c20ba9cdae257c70c934e2c9dc1a77c1798d8113/comments", "author": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a20eb6a9da36c88ee929826c4f1eb8d7ea393b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a20eb6a9da36c88ee929826c4f1eb8d7ea393b2", "html_url": "https://github.com/rust-lang/rust/commit/4a20eb6a9da36c88ee929826c4f1eb8d7ea393b2"}], "stats": {"total": 121, "additions": 121, "deletions": 0}, "files": [{"sha": "6032dc9a2d371c610829b79f2a4c748cee1a9c15", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c20ba9cdae257c70c934e2c9dc1a77c1798d8113/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20ba9cdae257c70c934e2c9dc1a77c1798d8113/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=c20ba9cdae257c70c934e2c9dc1a77c1798d8113", "patch": "@@ -2,6 +2,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+use crate::ascii;\n use crate::intrinsics;\n use crate::mem;\n use crate::str::FromStr;\n@@ -661,6 +662,31 @@ impl u8 {\n     pub const fn is_ascii_control(&self) -> bool {\n         matches!(*self, b'\\0'..=b'\\x1F' | b'\\x7F')\n     }\n+\n+    /// Returns an iterator that produces an escaped version of a `u8`,\n+    /// treating it as an ASCII character.\n+    ///\n+    /// The behavior is identical to [`ascii::escape_default`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(inherent_ascii_escape)]\n+    ///\n+    /// assert_eq!(\"0\", b'0'.escape_ascii().to_string());\n+    /// assert_eq!(\"\\\\t\", b'\\t'.escape_ascii().to_string());\n+    /// assert_eq!(\"\\\\r\", b'\\r'.escape_ascii().to_string());\n+    /// assert_eq!(\"\\\\n\", b'\\n'.escape_ascii().to_string());\n+    /// assert_eq!(\"\\\\'\", b'\\''.escape_ascii().to_string());\n+    /// assert_eq!(\"\\\\\\\"\", b'\"'.escape_ascii().to_string());\n+    /// assert_eq!(\"\\\\\\\\\", b'\\\\'.escape_ascii().to_string());\n+    /// assert_eq!(\"\\\\x9d\", b'\\x9d'.escape_ascii().to_string());\n+    /// ```\n+    #[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\n+    #[inline]\n+    pub fn escape_ascii(&self) -> ascii::EscapeDefault {\n+        ascii::escape_default(*self)\n+    }\n }\n \n #[lang = \"u16\"]"}, {"sha": "22fa08b97957019843051e19c9b8a1d4f6f4ef0a", "filename": "library/core/src/slice/ascii.rs", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/c20ba9cdae257c70c934e2c9dc1a77c1798d8113/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20ba9cdae257c70c934e2c9dc1a77c1798d8113/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs?ref=c20ba9cdae257c70c934e2c9dc1a77c1798d8113", "patch": "@@ -1,7 +1,10 @@\n //! Operations on ASCII `[u8]`.\n \n+use crate::ascii;\n+use crate::fmt::{self, Write};\n use crate::iter;\n use crate::mem;\n+use crate::ops;\n \n #[lang = \"slice_u8\"]\n #[cfg(not(test))]\n@@ -56,6 +59,95 @@ impl [u8] {\n             byte.make_ascii_lowercase();\n         }\n     }\n+\n+    /// Returns an iterator that produces an escaped version of this slice,\n+    /// treating it as an ASCII string.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(inherent_ascii_escape)]\n+    ///\n+    /// let s = b\"0\\t\\r\\n'\\\"\\\\\\x9d\";\n+    /// let escaped = s.escape_ascii().to_string();\n+    /// assert_eq!(escaped, \"0\\\\t\\\\r\\\\n\\\\'\\\\\\\"\\\\\\\\\\\\x9d\");\n+    /// ```\n+    #[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\n+    pub fn escape_ascii(&self) -> EscapeAscii<'_> {\n+        EscapeAscii { inner: self.iter().flat_map(EscapeByte) }\n+    }\n+}\n+\n+impl_fn_for_zst! {\n+    #[derive(Clone)]\n+    struct EscapeByte impl Fn = |byte: &u8| -> ascii::EscapeDefault {\n+        ascii::escape_default(*byte)\n+    };\n+}\n+\n+/// An iterator over the escaped version of a byte slice.\n+///\n+/// This `struct` is created by the [`slice::escape_ascii`] method. See its\n+/// documentation for more information.\n+#[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\n+#[derive(Clone)]\n+pub struct EscapeAscii<'a> {\n+    inner: iter::FlatMap<super::Iter<'a, u8>, ascii::EscapeDefault, EscapeByte>,\n+}\n+\n+#[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\n+impl<'a> iter::Iterator for EscapeAscii<'a> {\n+    type Item = u8;\n+    #[inline]\n+    fn next(&mut self) -> Option<u8> {\n+        self.inner.next()\n+    }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: ops::Try<Ok = Acc>,\n+    {\n+        self.inner.try_fold(init, fold)\n+    }\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.inner.fold(init, fold)\n+    }\n+    #[inline]\n+    fn last(mut self) -> Option<u8> {\n+        self.next_back()\n+    }\n+}\n+\n+#[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\n+impl<'a> iter::DoubleEndedIterator for EscapeAscii<'a> {\n+    fn next_back(&mut self) -> Option<u8> {\n+        self.inner.next_back()\n+    }\n+}\n+#[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\n+impl<'a> iter::ExactSizeIterator for EscapeAscii<'a> {}\n+#[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\n+impl<'a> iter::FusedIterator for EscapeAscii<'a> {}\n+#[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\n+impl<'a> fmt::Display for EscapeAscii<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.clone().try_for_each(|b| f.write_char(b as char))\n+    }\n+}\n+#[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\n+impl<'a> fmt::Debug for EscapeAscii<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.pad(\"EscapeAscii { .. }\")\n+    }\n }\n \n /// Returns `true` if any byte in the word `v` is nonascii (>= 128). Snarfed"}, {"sha": "59fad8c813c733e0ad3a6b6b6ae48c50d8819600", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c20ba9cdae257c70c934e2c9dc1a77c1798d8113/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20ba9cdae257c70c934e2c9dc1a77c1798d8113/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=c20ba9cdae257c70c934e2c9dc1a77c1798d8113", "patch": "@@ -81,6 +81,9 @@ pub use index::SliceIndex;\n #[unstable(feature = \"slice_range\", issue = \"76393\")]\n pub use index::range;\n \n+#[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\n+pub use ascii::EscapeAscii;\n+\n #[lang = \"slice\"]\n #[cfg(not(test))]\n impl<T> [T] {"}]}