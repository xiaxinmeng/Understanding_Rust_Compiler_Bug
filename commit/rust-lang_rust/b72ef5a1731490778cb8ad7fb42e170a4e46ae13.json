{"sha": "b72ef5a1731490778cb8ad7fb42e170a4e46ae13", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3MmVmNWExNzMxNDkwNzc4Y2I4YWQ3ZmI0MmUxNzBhNGU0NmFlMTM=", "commit": {"author": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-29T09:41:06Z"}, "committer": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-30T10:40:39Z"}, "message": "new lint: loop-match-break, which could be while-let (fixes #118)", "tree": {"sha": "1076cc8b99106c4699b71ac9f5f48819f08aae32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1076cc8b99106c4699b71ac9f5f48819f08aae32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b72ef5a1731490778cb8ad7fb42e170a4e46ae13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b72ef5a1731490778cb8ad7fb42e170a4e46ae13", "html_url": "https://github.com/rust-lang/rust/commit/b72ef5a1731490778cb8ad7fb42e170a4e46ae13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b72ef5a1731490778cb8ad7fb42e170a4e46ae13/comments", "author": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92563a99703ad11d3b5dbc7eb804728a5cb11223", "url": "https://api.github.com/repos/rust-lang/rust/commits/92563a99703ad11d3b5dbc7eb804728a5cb11223", "html_url": "https://github.com/rust-lang/rust/commit/92563a99703ad11d3b5dbc7eb804728a5cb11223"}], "stats": {"total": 144, "additions": 129, "deletions": 15}, "files": [{"sha": "92a03b3153012d0eff05b033e14a2ef55707ec51", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b72ef5a1731490778cb8ad7fb42e170a4e46ae13/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/b72ef5a1731490778cb8ad7fb42e170a4e46ae13/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=b72ef5a1731490778cb8ad7fb42e170a4e46ae13", "patch": "@@ -4,7 +4,7 @@\n A collection of lints that give helpful tips to newbies and catch oversights.\n \n ##Lints\n-There are 49 lints included in this crate:\n+There are 50 lints included in this crate:\n \n name                                                                                                 | default | meaning\n -----------------------------------------------------------------------------------------------------|---------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -56,6 +56,7 @@ name\n [toplevel_ref_arg](https://github.com/Manishearth/rust-clippy/wiki#toplevel_ref_arg)                 | warn    | a function argument is declared `ref` (i.e. `fn foo(ref x: u8)`, but not `fn foo((ref x, ref y): (u8, u8))`)\n [type_complexity](https://github.com/Manishearth/rust-clippy/wiki#type_complexity)                   | warn    | usage of very complex types; recommends factoring out parts into `type` definitions\n [unit_cmp](https://github.com/Manishearth/rust-clippy/wiki#unit_cmp)                                 | warn    | comparing unit values (which is always `true` or `false`, respectively)\n+[while_let_loop](https://github.com/Manishearth/rust-clippy/wiki#while_let_loop)                     | warn    | `loop { if let { ... } else break }` can be written as a `while let` loop\n [zero_width_space](https://github.com/Manishearth/rust-clippy/wiki#zero_width_space)                 | deny    | using a zero-width space in a string literal, which is confusing\n \n More to come, please [file an issue](https://github.com/Manishearth/rust-clippy/issues) if you have ideas!"}, {"sha": "d69d352abc646e17b63ea619759116ad149f5ae1", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b72ef5a1731490778cb8ad7fb42e170a4e46ae13/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b72ef5a1731490778cb8ad7fb42e170a4e46ae13/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=b72ef5a1731490778cb8ad7fb42e170a4e46ae13", "patch": "@@ -96,6 +96,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         loops::EXPLICIT_ITER_LOOP,\n         loops::ITER_NEXT_LOOP,\n         loops::NEEDLESS_RANGE_LOOP,\n+        loops::WHILE_LET_LOOP,\n         matches::MATCH_REF_PATS,\n         matches::SINGLE_MATCH,\n         methods::OPTION_UNWRAP_USED,"}, {"sha": "eba706ed7e157445707c1b46c0b130100ef17e0b", "filename": "src/loops.rs", "status": "modified", "additions": 62, "deletions": 3, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/b72ef5a1731490778cb8ad7fb42e170a4e46ae13/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b72ef5a1731490778cb8ad7fb42e170a4e46ae13/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=b72ef5a1731490778cb8ad7fb42e170a4e46ae13", "patch": "@@ -4,7 +4,8 @@ use syntax::visit::{Visitor, walk_expr};\n use rustc::middle::ty;\n use std::collections::HashSet;\n \n-use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type, walk_ptrs_ty};\n+use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type, walk_ptrs_ty,\n+            in_external_macro, expr_block, span_help_and_lint};\n use utils::{VEC_PATH, LL_PATH};\n \n declare_lint!{ pub NEEDLESS_RANGE_LOOP, Warn,\n@@ -16,12 +17,16 @@ declare_lint!{ pub EXPLICIT_ITER_LOOP, Warn,\n declare_lint!{ pub ITER_NEXT_LOOP, Warn,\n                \"for-looping over `_.next()` which is probably not intended\" }\n \n+declare_lint!{ pub WHILE_LET_LOOP, Warn,\n+               \"`loop { if let { ... } else break }` can be written as a `while let` loop\" }\n+\n #[derive(Copy, Clone)]\n pub struct LoopsPass;\n \n impl LintPass for LoopsPass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(NEEDLESS_RANGE_LOOP, EXPLICIT_ITER_LOOP, ITER_NEXT_LOOP)\n+        lint_array!(NEEDLESS_RANGE_LOOP, EXPLICIT_ITER_LOOP, ITER_NEXT_LOOP,\n+                    WHILE_LET_LOOP)\n     }\n \n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n@@ -36,7 +41,8 @@ impl LintPass for LoopsPass {\n                     walk_expr(&mut visitor, body);\n                     // linting condition: we only indexed one variable\n                     if visitor.indexed.len() == 1 {\n-                        let indexed = visitor.indexed.into_iter().next().expect(\"Len was nonzero, but no contents found\");\n+                        let indexed = visitor.indexed.into_iter().next().expect(\n+                            \"Len was nonzero, but no contents found\");\n                         if visitor.nonindex {\n                             span_lint(cx, NEEDLESS_RANGE_LOOP, expr.span, &format!(\n                                 \"the loop variable `{}` is used to index `{}`. Consider using \\\n@@ -77,6 +83,34 @@ impl LintPass for LoopsPass {\n                 }\n             }\n         }\n+        // check for `loop { if let {} else break }` that could be `while let`\n+        // (also matches explicit \"match\" instead of \"if let\")\n+        if let ExprLoop(ref block, _) = expr.node {\n+            // extract a single expression\n+            if let Some(inner) = extract_single_expr(block) {\n+                if let ExprMatch(ref matchexpr, ref arms, ref source) = inner.node {\n+                    // ensure \"if let\" compatible match structure\n+                    match *source {\n+                        MatchSource::Normal | MatchSource::IfLetDesugar{..} => if\n+                            arms.len() == 2 &&\n+                            arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n+                            arms[1].pats.len() == 1 && arms[1].guard.is_none() &&\n+                            // finally, check for \"break\" in the second clause\n+                            is_break_expr(&arms[1].body)\n+                        {\n+                            if in_external_macro(cx, expr.span) { return; }\n+                            span_help_and_lint(cx, WHILE_LET_LOOP, expr.span,\n+                                               \"this loop could be written as a `while let` loop\",\n+                                               &format!(\"try\\nwhile let {} = {} {}\",\n+                                                        snippet(cx, arms[0].pats[0].span, \"..\"),\n+                                                        snippet(cx, matchexpr.span, \"..\"),\n+                                                        expr_block(cx, &arms[0].body, \"..\")));\n+                        },\n+                        _ => ()\n+                    }\n+                }\n+            }\n+        }\n     }\n }\n \n@@ -158,3 +192,28 @@ fn is_array(ty: ty::Ty) -> bool {\n         _ => false\n     }\n }\n+\n+/// If block consists of a single expression (with or without semicolon), return it.\n+fn extract_single_expr(block: &Block) -> Option<&Expr> {\n+    match (&block.stmts.len(), &block.expr) {\n+        (&1, &None) => match block.stmts[0].node {\n+            StmtExpr(ref expr, _) |\n+            StmtSemi(ref expr, _) => Some(expr),\n+            _ => None,\n+        },\n+        (&0, &Some(ref expr)) => Some(expr),\n+        _ => None\n+    }\n+}\n+\n+/// Return true if expr contains a single break expr (maybe within a block).\n+fn is_break_expr(expr: &Expr) -> bool {\n+    match expr.node {\n+        ExprBreak(None) => true,\n+        ExprBlock(ref b) => match extract_single_expr(b) {\n+            Some(ref subexpr) => is_break_expr(subexpr),\n+            None => false,\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "3d04c9210ce6ce6d659330dc7a418c9892e11318", "filename": "src/matches.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b72ef5a1731490778cb8ad7fb42e170a4e46ae13/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b72ef5a1731490778cb8ad7fb42e170a4e46ae13/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=b72ef5a1731490778cb8ad7fb42e170a4e46ae13", "patch": "@@ -1,10 +1,8 @@\n use rustc::lint::*;\n use syntax::ast;\n use syntax::ast::*;\n-use std::borrow::Cow;\n \n-use utils::{snippet, snippet_block};\n-use utils::{span_lint, span_help_and_lint, in_external_macro};\n+use utils::{snippet, span_lint, span_help_and_lint, in_external_macro, expr_block};\n \n declare_lint!(pub SINGLE_MATCH, Warn,\n               \"a match statement with a single nontrivial arm (i.e, where the other arm \\\n@@ -38,21 +36,14 @@ impl LintPass for MatchPass {\n                 is_unit_expr(&arms[1].body)\n             {\n                 if in_external_macro(cx, expr.span) {return;}\n-                let body_code = snippet_block(cx, arms[0].body.span, \"..\");\n-                let body_code = if let ExprBlock(_) = arms[0].body.node {\n-                    body_code\n-                } else {\n-                    Cow::Owned(format!(\"{{ {} }}\", body_code))\n-                };\n                 span_help_and_lint(cx, SINGLE_MATCH, expr.span,\n                       \"you seem to be trying to use match for \\\n                       destructuring a single pattern. Did you mean to \\\n                       use `if let`?\",\n                       &format!(\"try\\nif let {} = {} {}\",\n                                snippet(cx, arms[0].pats[0].span, \"..\"),\n                                snippet(cx, ex.span, \"..\"),\n-                               body_code)\n-                );\n+                               expr_block(cx, &arms[0].body, \"..\")));\n             }\n \n             // check preconditions for MATCH_REF_PATS"}, {"sha": "f16387f606db61d55525fd668419bd9571c07238", "filename": "src/utils.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b72ef5a1731490778cb8ad7fb42e170a4e46ae13/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b72ef5a1731490778cb8ad7fb42e170a4e46ae13/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=b72ef5a1731490778cb8ad7fb42e170a4e46ae13", "patch": "@@ -103,6 +103,16 @@ pub fn snippet_block<'a>(cx: &Context, span: Span, default: &'a str) -> Cow<'a,\n     trim_multiline(snip, true)\n }\n \n+/// Like snippet_block, but add braces if the expr is not an ExprBlock\n+pub fn expr_block<'a>(cx: &Context, expr: &Expr, default: &'a str) -> Cow<'a, str> {\n+    let code = snippet_block(cx, expr.span, default);\n+    if let ExprBlock(_) = expr.node {\n+        code\n+    } else {\n+        Cow::Owned(format!(\"{{ {} }}\", code))\n+    }\n+}\n+\n /// Trim indentation from a multiline string\n /// with possibility of ignoring the first line\n pub fn trim_multiline(s: Cow<str>, ignore_first: bool) -> Cow<str> {"}, {"sha": "bc09168fad039bae561155672d478bf535bf2202", "filename": "tests/compile-fail/while_loop.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b72ef5a1731490778cb8ad7fb42e170a4e46ae13/tests%2Fcompile-fail%2Fwhile_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b72ef5a1731490778cb8ad7fb42e170a4e46ae13/tests%2Fcompile-fail%2Fwhile_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fwhile_loop.rs?ref=b72ef5a1731490778cb8ad7fb42e170a4e46ae13", "patch": "@@ -0,0 +1,52 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+#[deny(while_let_loop)]\n+fn main() {\n+    let y = Some(true);\n+    loop { //~ERROR\n+        if let Some(_x) = y {\n+            let _v = 1;\n+        } else {\n+            break;\n+        }\n+    }\n+    loop { //~ERROR\n+        if let Some(_x) = y {\n+            let _v = 1;\n+        } else {\n+            break\n+        }\n+    }\n+    loop { // no error, break is not in else clause\n+        if let Some(_x) = y {\n+            let _v = 1;\n+        }\n+        break;\n+    }\n+    loop { //~ERROR\n+        match y {\n+            Some(_x) => true,\n+            None => break\n+        };\n+    }\n+    loop { // no error, match is not the only statement\n+        match y {\n+            Some(_x) => true,\n+            None => break\n+        };\n+        let _x = 1;\n+    }\n+    loop { // no error, else branch does something other than break\n+        match y {\n+            Some(_x) => true,\n+            _ => {\n+                let _z = 1;\n+                break;\n+            }\n+        };\n+    }\n+    while let Some(x) = y { // no error, obviously\n+        println!(\"{}\", x);\n+    }\n+}"}]}