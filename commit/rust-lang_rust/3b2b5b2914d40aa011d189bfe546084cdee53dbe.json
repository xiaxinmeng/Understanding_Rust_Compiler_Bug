{"sha": "3b2b5b2914d40aa011d189bfe546084cdee53dbe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiMmI1YjI5MTRkNDBhYTAxMWQxODliZmU1NDYwODRjZGVlNTNkYmU=", "commit": {"author": {"name": "Jon Gjengset", "email": "jon@thesquareplanet.com", "date": "2021-01-25T00:43:54Z"}, "committer": {"name": "Jon Gjengset", "email": "jon@thesquareplanet.com", "date": "2021-03-28T19:37:09Z"}, "message": "Remove P: Unpin bound on impl Future for Pin\n\nThe `Unpin` bound was originally added in #56939 following the\nrecommendation of @withoutboats in\nhttps://github.com/rust-lang/rust/issues/55766#issue-378417538\n\nThat comment does not give explicit justification for why the bound\nshould be added. The relevant context was:\n\n> [ ] Remove `impl<P> Unpin for Pin<P>`\n>\n> This impl is not justified by our standard justification for unpin\n> impls: there is no pointer direction between `Pin<P>` and `P`. Its\n> usefulness is covered by the impls for pointers themselves.\n>\n> This futures impl (link to the impl changed in this PR) will need to\n> change to add a `P: Unpin` bound.\n\nThe decision to remove the unconditional impl of `Unpin for Pin` is\nsound (these days there is just an auto-impl for when `P: Unpin`). But,\nI think the decision to also add the `Unpin` bound for `impl Future` may\nhave been unnecessary. Or if that's not the case, I'd be very interested\nto have the argument for why written down somewhere. The bound _appears_\nto not be needed, since the presence of a `Pin<P>` should indicate that\nit's safe to project to `Pin<&mut P::Target>` just like for\n`Pin::as_mut`.", "tree": {"sha": "5d23738c950c4a4df4561f2582c8933c9e859084", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d23738c950c4a4df4561f2582c8933c9e859084"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b2b5b2914d40aa011d189bfe546084cdee53dbe", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYKAB0WIQRIAlMG/9GjsFwKNi2GO0ihHCONWgUCYGDa5gAKCRCGO0ihHCON\nWo4BAP98VDH0o8xFAALQDbWuV4m6gJCtfgBWQzV1v4QTJ3PPswD5AQaeyP3kmykO\n7LAqYhJnG5WoAMdzzwhVwXVDbTUEOAE=\n=NNhX\n-----END PGP SIGNATURE-----", "payload": "tree 5d23738c950c4a4df4561f2582c8933c9e859084\nparent 0239876020e9a44593e7946af92b35728eede5ae\nauthor Jon Gjengset <jon@thesquareplanet.com> 1611535434 -0800\ncommitter Jon Gjengset <jon@thesquareplanet.com> 1616960229 -0700\n\nRemove P: Unpin bound on impl Future for Pin\n\nThe `Unpin` bound was originally added in #56939 following the\nrecommendation of @withoutboats in\nhttps://github.com/rust-lang/rust/issues/55766#issue-378417538\n\nThat comment does not give explicit justification for why the bound\nshould be added. The relevant context was:\n\n> [ ] Remove `impl<P> Unpin for Pin<P>`\n>\n> This impl is not justified by our standard justification for unpin\n> impls: there is no pointer direction between `Pin<P>` and `P`. Its\n> usefulness is covered by the impls for pointers themselves.\n>\n> This futures impl (link to the impl changed in this PR) will need to\n> change to add a `P: Unpin` bound.\n\nThe decision to remove the unconditional impl of `Unpin for Pin` is\nsound (these days there is just an auto-impl for when `P: Unpin`). But,\nI think the decision to also add the `Unpin` bound for `impl Future` may\nhave been unnecessary. Or if that's not the case, I'd be very interested\nto have the argument for why written down somewhere. The bound _appears_\nto not be needed, since the presence of a `Pin<P>` should indicate that\nit's safe to project to `Pin<&mut P::Target>` just like for\n`Pin::as_mut`.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b2b5b2914d40aa011d189bfe546084cdee53dbe", "html_url": "https://github.com/rust-lang/rust/commit/3b2b5b2914d40aa011d189bfe546084cdee53dbe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b2b5b2914d40aa011d189bfe546084cdee53dbe/comments", "author": {"login": "jonhoo", "id": 176295, "node_id": "MDQ6VXNlcjE3NjI5NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/176295?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonhoo", "html_url": "https://github.com/jonhoo", "followers_url": "https://api.github.com/users/jonhoo/followers", "following_url": "https://api.github.com/users/jonhoo/following{/other_user}", "gists_url": "https://api.github.com/users/jonhoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonhoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonhoo/subscriptions", "organizations_url": "https://api.github.com/users/jonhoo/orgs", "repos_url": "https://api.github.com/users/jonhoo/repos", "events_url": "https://api.github.com/users/jonhoo/events{/privacy}", "received_events_url": "https://api.github.com/users/jonhoo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonhoo", "id": 176295, "node_id": "MDQ6VXNlcjE3NjI5NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/176295?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonhoo", "html_url": "https://github.com/jonhoo", "followers_url": "https://api.github.com/users/jonhoo/followers", "following_url": "https://api.github.com/users/jonhoo/following{/other_user}", "gists_url": "https://api.github.com/users/jonhoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonhoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonhoo/subscriptions", "organizations_url": "https://api.github.com/users/jonhoo/orgs", "repos_url": "https://api.github.com/users/jonhoo/repos", "events_url": "https://api.github.com/users/jonhoo/events{/privacy}", "received_events_url": "https://api.github.com/users/jonhoo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0239876020e9a44593e7946af92b35728eede5ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/0239876020e9a44593e7946af92b35728eede5ae", "html_url": "https://github.com/rust-lang/rust/commit/0239876020e9a44593e7946af92b35728eede5ae"}], "stats": {"total": 43, "additions": 41, "deletions": 2}, "files": [{"sha": "5a07c4ab22f3be0bd7c81aab7b031e6d3777ccd8", "filename": "library/core/src/future/future.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b2b5b2914d40aa011d189bfe546084cdee53dbe/library%2Fcore%2Fsrc%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b2b5b2914d40aa011d189bfe546084cdee53dbe/library%2Fcore%2Fsrc%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Ffuture.rs?ref=3b2b5b2914d40aa011d189bfe546084cdee53dbe", "patch": "@@ -111,11 +111,11 @@ impl<F: ?Sized + Future + Unpin> Future for &mut F {\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n impl<P> Future for Pin<P>\n where\n-    P: Unpin + ops::DerefMut<Target: Future>,\n+    P: ops::DerefMut<Target: Future>,\n {\n     type Output = <<P as ops::Deref>::Target as Future>::Output;\n \n     fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n-        Pin::get_mut(self).as_mut().poll(cx)\n+        <P::Target as Future>::poll(self.as_deref_mut(), cx)\n     }\n }"}, {"sha": "07424e18e4e2b72deeb639df84fcd15480c2ba0f", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3b2b5b2914d40aa011d189bfe546084cdee53dbe/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b2b5b2914d40aa011d189bfe546084cdee53dbe/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=3b2b5b2914d40aa011d189bfe546084cdee53dbe", "patch": "@@ -127,6 +127,7 @@\n #![feature(no_core)]\n #![feature(auto_traits)]\n #![cfg_attr(bootstrap, feature(or_patterns))]\n+#![feature(pin_deref_mut)]\n #![feature(prelude_import)]\n #![cfg_attr(not(bootstrap), feature(ptr_metadata))]\n #![feature(repr_simd, platform_intrinsics)]"}, {"sha": "bc562153713be2dd513f266524d5bf215196d2ca", "filename": "library/core/src/pin.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3b2b5b2914d40aa011d189bfe546084cdee53dbe/library%2Fcore%2Fsrc%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b2b5b2914d40aa011d189bfe546084cdee53dbe/library%2Fcore%2Fsrc%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpin.rs?ref=3b2b5b2914d40aa011d189bfe546084cdee53dbe", "patch": "@@ -793,6 +793,44 @@ impl<T: ?Sized> Pin<&'static T> {\n     }\n }\n \n+impl<'a, P: DerefMut> Pin<&'a mut Pin<P>> {\n+    /// Gets a pinned mutable reference from this nested pinned pointer.\n+    ///\n+    /// This is a generic method to go from `Pin<&mut Pin<Pointer<T>>>` to `Pin<&mut T>`. It is\n+    /// safe because the existence of a `Pin<Pointer<T>>` ensures that the pointee, `T`, cannot\n+    /// move in the future, and this method does not enable the pointee to move. \"Malicious\"\n+    /// implementations of `Pointer::DerefMut` are likewise ruled out by the contract of\n+    /// `Pin::new_unchecked`.\n+    #[unstable(feature = \"pin_deref_mut\", issue = \"none\")]\n+    #[inline(always)]\n+    pub fn as_deref_mut(self) -> Pin<&'a mut P::Target> {\n+        // SAFETY: What we're asserting here is that going from\n+        //\n+        //     Pin<&mut Pin<P>>\n+        //\n+        // to\n+        //\n+        //     Pin<&mut P::Target>\n+        //\n+        // is safe.\n+        //\n+        // We need to ensure that two things hold for that to be the case:\n+        //\n+        // 1) Once we give out a `Pin<&mut P::Target>`, an `&mut P::Target` will not be given out.\n+        // 2) By giving out a `Pin<&mut P::Target>`, we do not risk of violating `Pin<&mut Pin<P>>`\n+        //\n+        // The existence of `Pin<P>` is sufficient to guarantee #1: since we already have a\n+        // `Pin<P>`, it must already uphold the pinning guarantees, which must mean that\n+        // `Pin<&mut P::Target>` does as well, since `Pin::as_mut` is safe. We do not have to rely\n+        // on the fact that P is _also_ pinned.\n+        //\n+        // For #2, we need to ensure that code given a `Pin<&mut P::Target>` cannot cause the\n+        // `Pin<P>` to move? That is not possible, since `Pin<&mut P::Target>` no longer retains\n+        // any access to the `P` itself, much less the `Pin<P>`.\n+        unsafe { self.get_unchecked_mut() }.as_mut()\n+    }\n+}\n+\n impl<T: ?Sized> Pin<&'static mut T> {\n     /// Get a pinned mutable reference from a static mutable reference.\n     ///"}]}