{"sha": "b1c8835a0ffb201f2b5a3c3742021056e1d2afe9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxYzg4MzVhMGZmYjIwMWYyYjVhM2MzNzQyMDIxMDU2ZTFkMmFmZTk=", "commit": {"author": {"name": "Giacomo Stevanato", "email": "giaco.stevanato@gmail.com", "date": "2021-05-12T09:36:07Z"}, "committer": {"name": "Giacomo Stevanato", "email": "giaco.stevanato@gmail.com", "date": "2021-05-12T09:36:07Z"}, "message": "Add more precise span informations to generic types", "tree": {"sha": "9872666b6e1368a4a94f54c1c3a0defccf2661e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9872666b6e1368a4a94f54c1c3a0defccf2661e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1c8835a0ffb201f2b5a3c3742021056e1d2afe9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1c8835a0ffb201f2b5a3c3742021056e1d2afe9", "html_url": "https://github.com/rust-lang/rust/commit/b1c8835a0ffb201f2b5a3c3742021056e1d2afe9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1c8835a0ffb201f2b5a3c3742021056e1d2afe9/comments", "author": {"login": "SkiFire13", "id": 9020423, "node_id": "MDQ6VXNlcjkwMjA0MjM=", "avatar_url": "https://avatars.githubusercontent.com/u/9020423?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SkiFire13", "html_url": "https://github.com/SkiFire13", "followers_url": "https://api.github.com/users/SkiFire13/followers", "following_url": "https://api.github.com/users/SkiFire13/following{/other_user}", "gists_url": "https://api.github.com/users/SkiFire13/gists{/gist_id}", "starred_url": "https://api.github.com/users/SkiFire13/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SkiFire13/subscriptions", "organizations_url": "https://api.github.com/users/SkiFire13/orgs", "repos_url": "https://api.github.com/users/SkiFire13/repos", "events_url": "https://api.github.com/users/SkiFire13/events{/privacy}", "received_events_url": "https://api.github.com/users/SkiFire13/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SkiFire13", "id": 9020423, "node_id": "MDQ6VXNlcjkwMjA0MjM=", "avatar_url": "https://avatars.githubusercontent.com/u/9020423?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SkiFire13", "html_url": "https://github.com/SkiFire13", "followers_url": "https://api.github.com/users/SkiFire13/followers", "following_url": "https://api.github.com/users/SkiFire13/following{/other_user}", "gists_url": "https://api.github.com/users/SkiFire13/gists{/gist_id}", "starred_url": "https://api.github.com/users/SkiFire13/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SkiFire13/subscriptions", "organizations_url": "https://api.github.com/users/SkiFire13/orgs", "repos_url": "https://api.github.com/users/SkiFire13/repos", "events_url": "https://api.github.com/users/SkiFire13/events{/privacy}", "received_events_url": "https://api.github.com/users/SkiFire13/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba8d7e2cb7cfc87070585c17cd0aa4ae7f091a08", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba8d7e2cb7cfc87070585c17cd0aa4ae7f091a08", "html_url": "https://github.com/rust-lang/rust/commit/ba8d7e2cb7cfc87070585c17cd0aa4ae7f091a08"}], "stats": {"total": 119, "additions": 66, "deletions": 53}, "files": [{"sha": "ac69fa202025035b20fc33d03a37eed1425dfcb0", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c8835a0ffb201f2b5a3c3742021056e1d2afe9/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c8835a0ffb201f2b5a3c3742021056e1d2afe9/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=b1c8835a0ffb201f2b5a3c3742021056e1d2afe9", "patch": "@@ -278,7 +278,7 @@ impl ParenthesizedArgs {\n             .cloned()\n             .map(|input| AngleBracketedArg::Arg(GenericArg::Type(input)))\n             .collect();\n-        AngleBracketedArgs { span: self.span, args }\n+        AngleBracketedArgs { span: self.inputs_span, args }\n     }\n }\n "}, {"sha": "fe4459ccdc0dfb028356ec65772df64212e1965c", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b1c8835a0ffb201f2b5a3c3742021056e1d2afe9/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c8835a0ffb201f2b5a3c3742021056e1d2afe9/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=b1c8835a0ffb201f2b5a3c3742021056e1d2afe9", "patch": "@@ -62,7 +62,7 @@ use rustc_span::edition::Edition;\n use rustc_span::hygiene::ExpnId;\n use rustc_span::source_map::{respan, DesugaringKind};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::Span;\n+use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::abi::Abi;\n \n use smallvec::{smallvec, SmallVec};\n@@ -2084,6 +2084,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             args: &[],\n             bindings: arena_vec![self; self.output_ty_binding(span, output_ty)],\n             parenthesized: false,\n+            span_ext: DUMMY_SP,\n         });\n \n         hir::GenericBound::LangItemTrait(\n@@ -2788,6 +2789,7 @@ struct GenericArgsCtor<'hir> {\n     args: SmallVec<[hir::GenericArg<'hir>; 4]>,\n     bindings: &'hir [hir::TypeBinding<'hir>],\n     parenthesized: bool,\n+    span: Span,\n }\n \n impl<'hir> GenericArgsCtor<'hir> {\n@@ -2800,6 +2802,7 @@ impl<'hir> GenericArgsCtor<'hir> {\n             args: arena.alloc_from_iter(self.args),\n             bindings: self.bindings,\n             parenthesized: self.parenthesized,\n+            span_ext: self.span,\n         }\n     }\n }"}, {"sha": "fe9f1fb20f05608fe21bc43ffe957ee80a52d6ea", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 44, "deletions": 23, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/b1c8835a0ffb201f2b5a3c3742021056e1d2afe9/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c8835a0ffb201f2b5a3c3742021056e1d2afe9/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=b1c8835a0ffb201f2b5a3c3742021056e1d2afe9", "patch": "@@ -10,7 +10,7 @@ use rustc_hir::GenericArg;\n use rustc_session::lint::builtin::ELIDED_LIFETIMES_IN_PATHS;\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_span::symbol::Ident;\n-use rustc_span::Span;\n+use rustc_span::{BytePos, Span, DUMMY_SP};\n \n use smallvec::smallvec;\n use tracing::debug;\n@@ -267,23 +267,34 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 },\n             }\n         } else {\n-            self.lower_angle_bracketed_parameter_data(&Default::default(), param_mode, itctx)\n+            (\n+                GenericArgsCtor {\n+                    args: Default::default(),\n+                    bindings: &[],\n+                    parenthesized: false,\n+                    span: path_span.shrink_to_hi(),\n+                },\n+                param_mode == ParamMode::Optional,\n+            )\n         };\n \n         let has_lifetimes =\n             generic_args.args.iter().any(|arg| matches!(arg, GenericArg::Lifetime(_)));\n-        let first_generic_span = generic_args\n-            .args\n-            .iter()\n-            .map(|a| a.span())\n-            .chain(generic_args.bindings.iter().map(|b| b.span))\n-            .next();\n         if !generic_args.parenthesized && !has_lifetimes {\n+            // Note: these spans are used for diagnostics when they can't be inferred.\n+            // See rustc_resolve::late::lifetimes::LifetimeContext::add_missing_lifetime_specifiers_label\n+            let elided_lifetime_span = if generic_args.span.is_empty() {\n+                // If there are no brackets, use the identifier span.\n+                segment.ident.span\n+            } else if generic_args.is_empty() {\n+                // If there are brackets, but not generic arguments, then use the opening bracket\n+                generic_args.span.with_hi(generic_args.span.lo() + BytePos(1))\n+            } else {\n+                // Else use an empty span right after the opening bracket.\n+                generic_args.span.with_lo(generic_args.span.lo() + BytePos(1)).shrink_to_lo()\n+            };\n             generic_args.args = self\n-                .elided_path_lifetimes(\n-                    first_generic_span.map_or(segment.ident.span, |s| s.shrink_to_lo()),\n-                    expected_lifetimes,\n-                )\n+                .elided_path_lifetimes(elided_lifetime_span, expected_lifetimes)\n                 .map(GenericArg::Lifetime)\n                 .chain(generic_args.args.into_iter())\n                 .collect();\n@@ -292,15 +303,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 let no_non_lt_args = generic_args.args.len() == expected_lifetimes;\n                 let no_bindings = generic_args.bindings.is_empty();\n                 let (incl_angl_brckt, insertion_sp, suggestion) = if no_non_lt_args && no_bindings {\n-                    // If there are no (non-implicit) generic args or associated type\n-                    // bindings, our suggestion includes the angle brackets.\n+                    // If there are no generic args, our suggestion can include the angle brackets.\n                     (true, path_span.shrink_to_hi(), format!(\"<{}>\", anon_lt_suggestion))\n                 } else {\n-                    // Otherwise (sorry, this is kind of gross) we need to infer the\n-                    // place to splice in the `'_, ` from the generics that do exist.\n-                    let first_generic_span = first_generic_span\n-                        .expect(\"already checked that non-lifetime args or bindings exist\");\n-                    (false, first_generic_span.shrink_to_lo(), format!(\"{}, \", anon_lt_suggestion))\n+                    // Otherwise we'll insert a `'_, ` right after the opening bracket.\n+                    let span = generic_args\n+                        .span\n+                        .with_lo(generic_args.span.lo() + BytePos(1))\n+                        .shrink_to_lo();\n+                    (false, span, format!(\"{}, \", anon_lt_suggestion))\n                 };\n                 match self.anonymous_lifetime_mode {\n                     // In create-parameter mode we error here because we don't want to support\n@@ -362,7 +373,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             hir_id: Some(id),\n             res: Some(self.lower_res(res)),\n             infer_args,\n-            args: if generic_args.is_empty() {\n+            args: if generic_args.is_empty() && generic_args.span.is_empty() {\n                 None\n             } else {\n                 Some(self.arena.alloc(generic_args.into_generic_args(self.arena)))\n@@ -395,7 +406,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n             AngleBracketedArg::Arg(_) => None,\n         }));\n-        let ctor = GenericArgsCtor { args, bindings, parenthesized: false };\n+        let ctor = GenericArgsCtor { args, bindings, parenthesized: false, span: data.span };\n         (ctor, !has_non_lt_args && param_mode == ParamMode::Optional)\n     }\n \n@@ -420,7 +431,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             let args = smallvec![GenericArg::Type(this.ty_tup(*inputs_span, inputs))];\n             let binding = this.output_ty_binding(output_ty.span, output_ty);\n             (\n-                GenericArgsCtor { args, bindings: arena_vec![this; binding], parenthesized: true },\n+                GenericArgsCtor {\n+                    args,\n+                    bindings: arena_vec![this; binding],\n+                    parenthesized: true,\n+                    span: data.inputs_span,\n+                },\n                 false,\n             )\n         })\n@@ -436,7 +452,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let kind = hir::TypeBindingKind::Equality { ty };\n         let args = arena_vec![self;];\n         let bindings = arena_vec![self;];\n-        let gen_args = self.arena.alloc(hir::GenericArgs { args, bindings, parenthesized: false });\n+        let gen_args = self.arena.alloc(hir::GenericArgs {\n+            args,\n+            bindings,\n+            parenthesized: false,\n+            span_ext: DUMMY_SP,\n+        });\n         hir::TypeBinding { hir_id: self.next_id(), gen_args, span, ident, kind }\n     }\n }"}, {"sha": "e689ae4d81db703aa64f88b8a1c8a3193bcc04c1", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b1c8835a0ffb201f2b5a3c3742021056e1d2afe9/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c8835a0ffb201f2b5a3c3742021056e1d2afe9/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=b1c8835a0ffb201f2b5a3c3742021056e1d2afe9", "patch": "@@ -12,7 +12,7 @@ pub use rustc_ast::{CaptureBy, Movability, Mutability};\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_data_structures::sync::{par_for_each_in, Send, Sync};\n use rustc_macros::HashStable_Generic;\n-use rustc_span::source_map::{SourceMap, Spanned};\n+use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{def_id::LocalDefId, BytePos};\n use rustc_span::{MultiSpan, Span, DUMMY_SP};\n@@ -314,11 +314,18 @@ pub struct GenericArgs<'hir> {\n     /// This is required mostly for pretty-printing and diagnostics,\n     /// but also for changing lifetime elision rules to be \"function-like\".\n     pub parenthesized: bool,\n+    /// The span encompassing arguments and the surrounding brackets `<>` or `()`\n+    ///       Foo<A, B, AssocTy = D>           Fn(T, U, V) -> W\n+    ///          ^^^^^^^^^^^^^^^^^^^             ^^^^^^^^^\n+    /// Note that this may be:\n+    /// - empty, if there are no generic brackets (but there may be hidden lifetimes)\n+    /// - dummy, if this was generated while desugaring\n+    pub span_ext: Span,\n }\n \n impl GenericArgs<'_> {\n     pub const fn none() -> Self {\n-        Self { args: &[], bindings: &[], parenthesized: false }\n+        Self { args: &[], bindings: &[], parenthesized: false, span_ext: DUMMY_SP }\n     }\n \n     pub fn inputs(&self) -> &[Ty<'_>] {\n@@ -356,33 +363,17 @@ impl GenericArgs<'_> {\n         own_counts\n     }\n \n+    /// The span encompassing the text inside the surrounding brackets.\n+    /// It will also include bindings if they aren't in the form `-> Ret`\n+    /// Returns `None` if the span is empty (e.g. no brackets) or dummy\n     pub fn span(&self) -> Option<Span> {\n-        self.args\n-            .iter()\n-            .filter(|arg| !arg.is_synthetic())\n-            .map(|arg| arg.span())\n-            .reduce(|span1, span2| span1.to(span2))\n+        let span_ext = self.span_ext()?;\n+        Some(span_ext.with_lo(span_ext.lo() + BytePos(1)).with_hi(span_ext.hi() - BytePos(1)))\n     }\n \n     /// Returns span encompassing arguments and their surrounding `<>` or `()`\n-    pub fn span_ext(&self, sm: &SourceMap) -> Option<Span> {\n-        let mut span = self.span()?;\n-\n-        let (o, c) = if self.parenthesized { ('(', ')') } else { ('<', '>') };\n-\n-        if let Ok(snippet) = sm.span_to_snippet(span) {\n-            let snippet = snippet.as_bytes();\n-\n-            if snippet[0] != (o as u8) || snippet[snippet.len() - 1] != (c as u8) {\n-                span = sm.span_extend_to_prev_char(span, o, true);\n-                span = span.with_lo(span.lo() - BytePos(1));\n-\n-                span = sm.span_extend_to_next_char(span, c, true);\n-                span = span.with_hi(span.hi() + BytePos(1));\n-            }\n-        }\n-\n-        Some(span)\n+    pub fn span_ext(&self) -> Option<Span> {\n+        Some(self.span_ext).filter(|span| !span.is_empty())\n     }\n \n     pub fn is_empty(&self) -> bool {"}, {"sha": "7635ca1ae27a13e05a6db2ba1c5ff07e5f41824f", "filename": "compiler/rustc_typeck/src/structured_errors/wrong_number_of_generic_args.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1c8835a0ffb201f2b5a3c3742021056e1d2afe9/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c8835a0ffb201f2b5a3c3742021056e1d2afe9/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs?ref=b1c8835a0ffb201f2b5a3c3742021056e1d2afe9", "patch": "@@ -695,13 +695,11 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n         };\n \n         if remove_entire_generics {\n-            let sm = self.tcx.sess.source_map();\n-\n             let span = self\n                 .path_segment\n                 .args\n                 .unwrap()\n-                .span_ext(sm)\n+                .span_ext()\n                 .unwrap()\n                 .with_lo(self.path_segment.ident.span.hi());\n "}]}