{"sha": "9110a38cbfd801983a838775c690c83e9189b4c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxMTBhMzhjYmZkODAxOTgzYTgzODc3NWM2OTBjODNlOTE4OWI0YzM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-16T23:48:30Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-24T21:21:57Z"}, "message": "Remove rt::io::support\n\nThis removes the PathLike trait associated with this \"support module\". This is\nyet another \"container of bytes\" trait, so I didn't want to duplicate what\nalready exists throughout libstd. In actuality, we're going to pass of C strings\nto the libuv APIs, so instead the arguments are now bound with the 'ToCStr'\ntrait instead.\n\nAdditionally, a layer of complexity was removed by immediately converting these\ntype-generic parameters into CStrings to get handed off to libuv apis.", "tree": {"sha": "d4bdc0b6ee4dae3e40916dab864fcb06b2f10cb7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4bdc0b6ee4dae3e40916dab864fcb06b2f10cb7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9110a38cbfd801983a838775c690c83e9189b4c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9110a38cbfd801983a838775c690c83e9189b4c3", "html_url": "https://github.com/rust-lang/rust/commit/9110a38cbfd801983a838775c690c83e9189b4c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9110a38cbfd801983a838775c690c83e9189b4c3/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0cad9847652088b35ee4c13c04539ca3a67611f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cad9847652088b35ee4c13c04539ca3a67611f7", "html_url": "https://github.com/rust-lang/rust/commit/0cad9847652088b35ee4c13c04539ca3a67611f7"}], "stats": {"total": 339, "additions": 131, "deletions": 208}, "files": [{"sha": "ba64a71553f6e1e50ee61610ef59403c24465410", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9110a38cbfd801983a838775c690c83e9189b4c3/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9110a38cbfd801983a838775c690c83e9189b4c3/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=9110a38cbfd801983a838775c690c83e9189b4c3", "patch": "@@ -348,13 +348,56 @@ impl<'self> Iterator<libc::c_char> for CStringIterator<'self> {\n     }\n }\n \n+/// Parses a C \"multistring\", eg windows env values or\n+/// the req->ptr result in a uv_fs_readdir() call.\n+///\n+/// Optionally, a `count` can be passed in, limiting the\n+/// parsing to only being done `count`-times.\n+///\n+/// The specified closure is invoked with each string that\n+/// is found, and the number of strings found is returned.\n+pub unsafe fn from_c_multistring(buf: *libc::c_char,\n+                                 count: Option<uint>,\n+                                 f: &fn(&CString)) -> uint {\n+\n+    let mut curr_ptr: uint = buf as uint;\n+    let mut ctr = 0;\n+    let (limited_count, limit) = match count {\n+        Some(limit) => (true, limit),\n+        None => (false, 0)\n+    };\n+    while ((limited_count && ctr < limit) || !limited_count)\n+          && *(curr_ptr as *libc::c_char) != 0 as libc::c_char {\n+        let cstr = CString::new(curr_ptr as *libc::c_char, false);\n+        f(&cstr);\n+        curr_ptr += cstr.len() + 1;\n+        ctr += 1;\n+    }\n+    return ctr;\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n     use libc;\n     use ptr;\n     use option::{Some, None};\n \n+    #[test]\n+    fn test_str_multistring_parsing() {\n+        unsafe {\n+            let input = bytes!(\"zero\", \"\\x00\", \"one\", \"\\x00\", \"\\x00\");\n+            let ptr = vec::raw::to_ptr(input);\n+            let expected = [\"zero\", \"one\"];\n+            let mut it = expected.iter();\n+            let result = do from_c_multistring(ptr as *libc::c_char, None) |c| {\n+                assert_eq!(c.as_str(), expected.next().unwrap());\n+            };\n+            assert_eq!(result, 2);\n+            assert!(it.next().is_none());\n+        }\n+    }\n+\n     #[test]\n     fn test_str_to_c_str() {\n         do \"\".to_c_str().with_ref |buf| {"}, {"sha": "65190c5d8d623e8968fec34a1b8effe6d78d60cd", "filename": "src/libstd/os.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9110a38cbfd801983a838775c690c83e9189b4c3/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9110a38cbfd801983a838775c690c83e9189b4c3/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=9110a38cbfd801983a838775c690c83e9189b4c3", "patch": "@@ -62,7 +62,7 @@ pub fn close(fd: c_int) -> c_int {\n // which are for Windows and for non-Windows, if necessary.\n // See https://github.com/mozilla/rust/issues/9822 for more information.\n \n-pub mod rustrt {\n+mod rustrt {\n     use libc::{c_char, c_int};\n     use libc;\n \n@@ -200,7 +200,10 @@ pub fn env() -> ~[(~str,~str)] {\n                 fail!(\"os::env() failure getting env string from OS: {}\",\n                        os::last_os_error());\n             }\n-            let result = str::raw::from_c_multistring(ch as *libc::c_char, None);\n+            let mut result = ~[];\n+            do c_str::from_c_multistring(ch as *libc::c_char, None) |cstr| {\n+                result.push(cstr.as_str().to_owned());\n+            };\n             FreeEnvironmentStringsA(ch);\n             result\n         }"}, {"sha": "cc39db44431539de3c842dbf12e7fd53ed471047", "filename": "src/libstd/rt/io/file.rs", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9110a38cbfd801983a838775c690c83e9189b4c3/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9110a38cbfd801983a838775c690c83e9189b4c3/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffile.rs?ref=9110a38cbfd801983a838775c690c83e9189b4c3", "patch": "@@ -15,7 +15,8 @@ with regular files & directories on a filesystem.\n \n At the top-level of the module are a set of freestanding functions,\n associated with various filesystem operations. They all operate\n-on a `PathLike` object.\n+on a `ToCStr` object. This trait is already defined for common\n+objects such as strings and `Path` instances.\n \n All operations in this module, including those as part of `FileStream` et al\n block the task during execution. Most will raise `std::rt::io::{io_error,read_error}`\n@@ -30,7 +31,7 @@ free function counterparts.\n */\n \n use prelude::*;\n-use super::support::PathLike;\n+use c_str::ToCStr;\n use super::{Reader, Writer, Seek};\n use super::{SeekStyle, Read, Write};\n use rt::rtio::{RtioFileStream, IoFactory, IoFactoryObject};\n@@ -48,7 +49,6 @@ use path::Path;\n ///\n ///     use std;\n ///     use std::path::Path;\n-///     use std::rt::io::support::PathLike;\n ///     use std::rt::io::file::open;\n ///     use std::rt::io::{FileMode, FileAccess};\n ///\n@@ -87,13 +87,13 @@ use path::Path;\n /// * Attempting to open a file with a `FileAccess` that the user lacks permissions\n ///   for\n /// * Filesystem-level errors (full disk, etc)\n-pub fn open<P: PathLike>(path: &P,\n-                         mode: FileMode,\n-                         access: FileAccess\n-                        ) -> Option<FileStream> {\n+pub fn open<P: ToCStr>(path: &P,\n+                       mode: FileMode,\n+                       access: FileAccess\n+                       ) -> Option<FileStream> {\n     let open_result = unsafe {\n         let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-        (*io).fs_open(path, mode, access)\n+        (*io).fs_open(&path.to_c_str(), mode, access)\n     };\n     match open_result {\n         Ok(fd) => Some(FileStream {\n@@ -113,7 +113,6 @@ pub fn open<P: PathLike>(path: &P,\n ///\n ///     use std;\n ///     use std::path::Path;\n-///     use std::rt::io::support::PathLike;\n ///     use std::rt::io::file::unlink;\n ///\n ///     let p = &Path(\"/some/file/path.txt\");\n@@ -129,10 +128,10 @@ pub fn open<P: PathLike>(path: &P,\n ///\n /// This function will raise an `io_error` condition if the user lacks permissions to\n /// remove the file or if some other filesystem-level error occurs\n-pub fn unlink<P: PathLike>(path: &P) {\n+pub fn unlink<P: ToCStr>(path: &P) {\n     let unlink_result = unsafe {\n         let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-        (*io).fs_unlink(path)\n+        (*io).fs_unlink(&path.to_c_str())\n     };\n     match unlink_result {\n         Ok(_) => (),\n@@ -148,7 +147,6 @@ pub fn unlink<P: PathLike>(path: &P) {\n ///\n ///     use std;\n ///     use std::path::Path;\n-///     use std::rt::io::support::PathLike;\n ///     use std::rt::io::file::mkdir;\n ///\n ///     let p = &Path(\"/some/dir\");\n@@ -159,10 +157,10 @@ pub fn unlink<P: PathLike>(path: &P) {\n ///\n /// This call will raise an `io_error` condition if the user lacks permissions to make a\n /// new directory at the provided path, or if the directory already exists\n-pub fn mkdir<P: PathLike>(path: &P) {\n+pub fn mkdir<P: ToCStr>(path: &P) {\n     let mkdir_result = unsafe {\n         let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-        (*io).fs_mkdir(path)\n+        (*io).fs_mkdir(&path.to_c_str())\n     };\n     match mkdir_result {\n         Ok(_) => (),\n@@ -178,7 +176,6 @@ pub fn mkdir<P: PathLike>(path: &P) {\n ///\n ///     use std;\n ///     use std::path::Path;\n-///     use std::rt::io::support::PathLike;\n ///     use std::rt::io::file::rmdir;\n ///\n ///     let p = &Path(\"/some/dir\");\n@@ -189,10 +186,10 @@ pub fn mkdir<P: PathLike>(path: &P) {\n ///\n /// This call will raise an `io_error` condition if the user lacks permissions to remove the\n /// directory at the provided path, or if the directory isn't empty\n-pub fn rmdir<P: PathLike>(path: &P) {\n+pub fn rmdir<P: ToCStr>(path: &P) {\n     let rmdir_result = unsafe {\n         let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-        (*io).fs_rmdir(path)\n+        (*io).fs_rmdir(&path.to_c_str())\n     };\n     match rmdir_result {\n         Ok(_) => (),\n@@ -204,16 +201,15 @@ pub fn rmdir<P: PathLike>(path: &P) {\n \n /// Get information on the file, directory, etc at the provided path\n ///\n-/// Given a `rt::io::support::PathLike`, query the file system to get\n-/// information about a file, directory, etc.\n+/// Given a path, query the file system to get information about a file,\n+/// directory, etc.\n ///\n /// Returns a `Some(std::rt::io::PathInfo)` on success\n ///\n /// # Example\n ///\n ///     use std;\n ///     use std::path::Path;\n-///     use std::rt::io::support::PathLike;\n ///     use std::rt::io::file::stat;\n ///\n ///     let p = &Path(\"/some/file/path.txt\");\n@@ -238,10 +234,10 @@ pub fn rmdir<P: PathLike>(path: &P) {\n /// This call will raise an `io_error` condition if the user lacks the requisite\n /// permissions to perform a `stat` call on the given path or if there is no\n /// entry in the filesystem at the provided path.\n-pub fn stat<P: PathLike>(path: &P) -> Option<FileStat> {\n+pub fn stat<P: ToCStr>(path: &P) -> Option<FileStat> {\n     let open_result = unsafe {\n         let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-        (*io).fs_stat(path)\n+        (*io).fs_stat(&path.to_c_str())\n     };\n     match open_result {\n         Ok(p) => {\n@@ -260,7 +256,6 @@ pub fn stat<P: PathLike>(path: &P) -> Option<FileStat> {\n ///\n ///     use std;\n ///     use std::path::Path;\n-///     use std::rt::io::support::PathLike;\n ///     use std::rt::io::file::readdir;\n ///\n ///     fn visit_dirs(dir: &Path, cb: &fn(&Path)) {\n@@ -279,10 +274,10 @@ pub fn stat<P: PathLike>(path: &P) -> Option<FileStat> {\n /// Will raise an `io_error` condition if the provided `path` doesn't exist,\n /// the process lacks permissions to view the contents or if the `path` points\n /// at a non-directory file\n-pub fn readdir<P: PathLike>(path: &P) -> Option<~[Path]> {\n+pub fn readdir<P: ToCStr>(path: &P) -> Option<~[Path]> {\n     let readdir_result = unsafe {\n         let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-        (*io).fs_readdir(path, 0)\n+        (*io).fs_readdir(&path.to_c_str(), 0)\n     };\n     match readdir_result {\n         Ok(p) => {"}, {"sha": "cb6361ff4e3c9f490b3fc67dba959048c87db594", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9110a38cbfd801983a838775c690c83e9189b4c3/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9110a38cbfd801983a838775c690c83e9189b4c3/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=9110a38cbfd801983a838775c690c83e9189b4c3", "patch": "@@ -298,10 +298,6 @@ pub mod comm_adapters;\n /// Extension traits\n pub mod extensions;\n \n-/// Non-I/O things needed by the I/O module\n-// XXX: shouldn this really be pub?\n-pub mod support;\n-\n /// Basic Timer\n pub mod timer;\n "}, {"sha": "fe045bff0507e630d3e61ac1013f16820e477ccf", "filename": "src/libstd/rt/io/net/unix.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9110a38cbfd801983a838775c690c83e9189b4c3/src%2Flibstd%2Frt%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9110a38cbfd801983a838775c690c83e9189b4c3/src%2Flibstd%2Frt%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Funix.rs?ref=9110a38cbfd801983a838775c690c83e9189b4c3", "patch": "@@ -24,7 +24,7 @@ instances as clients.\n \n use prelude::*;\n \n-use super::super::support::PathLike;\n+use c_str::ToCStr;\n use rt::rtio::{IoFactory, IoFactoryObject, RtioUnixListener};\n use rt::rtio::{RtioUnixAcceptor, RtioPipe, RtioUnixListenerObject};\n use rt::io::pipe::PipeStream;\n@@ -59,7 +59,7 @@ impl UnixStream {\n     ///     let mut stream = UnixStream::connect(&server);\n     ///     stream.write([1, 2, 3]);\n     ///\n-    pub fn connect<P: PathLike>(path: &P) -> Option<UnixStream> {\n+    pub fn connect<P: ToCStr>(path: &P) -> Option<UnixStream> {\n         let pipe = unsafe {\n             let io: *mut IoFactoryObject = Local::unsafe_borrow();\n             (*io).unix_connect(path)\n@@ -112,7 +112,7 @@ impl UnixListener {\n     ///         client.write([1, 2, 3, 4]);\n     ///     }\n     ///\n-    pub fn bind<P: PathLike>(path: &P) -> Option<UnixListener> {\n+    pub fn bind<P: ToCStr>(path: &P) -> Option<UnixListener> {\n         let listener = unsafe {\n             let io: *mut IoFactoryObject = Local::unsafe_borrow();\n             (*io).unix_bind(path)"}, {"sha": "31040bc51a135ec47a7d3e2a32e557e7c55bf40d", "filename": "src/libstd/rt/io/support.rs", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0cad9847652088b35ee4c13c04539ca3a67611f7/src%2Flibstd%2Frt%2Fio%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cad9847652088b35ee4c13c04539ca3a67611f7/src%2Flibstd%2Frt%2Fio%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fsupport.rs?ref=0cad9847652088b35ee4c13c04539ca3a67611f7", "patch": "@@ -1,42 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use path::*;\n-\n-pub trait PathLike {\n-    fn path_as_str<T>(&self, f: &fn(&str) -> T) -> T;\n-}\n-\n-impl<'self> PathLike for &'self str {\n-    fn path_as_str<T>(&self, f: &fn(&str) -> T) -> T {\n-        f(*self)\n-    }\n-}\n-\n-impl PathLike for Path {\n-    fn path_as_str<T>(&self, f: &fn(&str) -> T) -> T {\n-        let s = self.as_str().unwrap();\n-        f(s)\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use path::*;\n-    use super::PathLike;\n-\n-    #[test]\n-    fn path_like_smoke_test() {\n-        let expected = if cfg!(unix) { \"/home\" } else { \"C:\\\\\" };\n-        let path = Path::new(expected);\n-        path.path_as_str(|p| assert!(p == expected));\n-        path.path_as_str(|p| assert!(p == expected));\n-    }\n-}"}, {"sha": "c889355f3531c59633f9830cbba308cfa04666cc", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9110a38cbfd801983a838775c690c83e9189b4c3/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9110a38cbfd801983a838775c690c83e9189b4c3/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=9110a38cbfd801983a838775c690c83e9189b4c3", "patch": "@@ -12,14 +12,14 @@ use libc;\n use option::*;\n use result::*;\n use libc::c_int;\n+use c_str::CString;\n \n use ai = rt::io::net::addrinfo;\n use rt::io::IoError;\n use super::io::process::ProcessConfig;\n use super::io::net::ip::{IpAddr, SocketAddr};\n use rt::uv::uvio;\n use path::Path;\n-use super::io::support::PathLike;\n use super::io::{SeekStyle};\n use super::io::{FileMode, FileAccess, FileStat};\n \n@@ -65,15 +65,14 @@ pub trait IoFactory {\n     fn udp_bind(&mut self, addr: SocketAddr) -> Result<~RtioUdpSocket, IoError>;\n     fn timer_init(&mut self) -> Result<~RtioTimer, IoError>;\n     fn fs_from_raw_fd(&mut self, fd: c_int, close_on_drop: bool) -> ~RtioFileStream;\n-    fn fs_open<P: PathLike>(&mut self, path: &P, fm: FileMode, fa: FileAccess)\n+    fn fs_open(&mut self, path: &CString, fm: FileMode, fa: FileAccess)\n         -> Result<~RtioFileStream, IoError>;\n-    fn fs_unlink<P: PathLike>(&mut self, path: &P) -> Result<(), IoError>;\n     fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n                           hint: Option<ai::Hint>) -> Result<~[ai::Info], IoError>;\n-    fn fs_stat<P: PathLike>(&mut self, path: &P) -> Result<FileStat, IoError>;\n-    fn fs_mkdir<P: PathLike>(&mut self, path: &P) -> Result<(), IoError>;\n-    fn fs_rmdir<P: PathLike>(&mut self, path: &P) -> Result<(), IoError>;\n-    fn fs_readdir<P: PathLike>(&mut self, path: &P, flags: c_int) ->\n+    fn fs_stat(&mut self, path: &CString) -> Result<FileStat, IoError>;\n+    fn fs_mkdir(&mut self, path: &CString) -> Result<(), IoError>;\n+    fn fs_rmdir(&mut self, path: &CString) -> Result<(), IoError>;\n+    fn fs_readdir(&mut self, path: &CString, flags: c_int) ->\n         Result<~[Path], IoError>;\n     fn spawn(&mut self, config: ProcessConfig)\n             -> Result<(~RtioProcess, ~[Option<~RtioPipe>]), IoError>;"}, {"sha": "07a22bc00e3a05bf83d02b6e9d3621073d25cb0a", "filename": "src/libstd/rt/uv/file.rs", "status": "modified", "additions": 33, "deletions": 51, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/9110a38cbfd801983a838775c690c83e9189b4c3/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9110a38cbfd801983a838775c690c83e9189b4c3/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ffile.rs?ref=9110a38cbfd801983a838775c690c83e9189b4c3", "patch": "@@ -10,12 +10,13 @@\n \n use prelude::*;\n use ptr::null;\n+use c_str;\n+use c_str::CString;\n use libc::c_void;\n use rt::uv::{Request, NativeHandle, Loop, FsCallback, Buf,\n              status_to_maybe_uv_error, UvError};\n use rt::uv::uvll;\n use rt::uv::uvll::*;\n-use super::super::io::support::PathLike;\n use cast::transmute;\n use libc;\n use libc::{c_int};\n@@ -36,73 +37,63 @@ impl FsRequest {\n         fs_req\n     }\n \n-    pub fn open<P: PathLike>(self, loop_: &Loop, path: &P, flags: int, mode: int,\n-               cb: FsCallback) {\n+    pub fn open(self, loop_: &Loop, path: &CString, flags: int, mode: int,\n+                cb: FsCallback) {\n         let complete_cb_ptr = {\n             let mut me = self;\n             me.req_boilerplate(Some(cb))\n         };\n-        path.path_as_str(|p| {\n-            p.with_c_str(|p| unsafe {\n+        path.with_ref(|p| unsafe {\n             uvll::fs_open(loop_.native_handle(),\n                           self.native_handle(), p, flags, mode, complete_cb_ptr)\n-            })\n         });\n     }\n \n-    pub fn open_sync<P: PathLike>(self, loop_: &Loop, path: &P,\n-                                  flags: int, mode: int) -> Result<c_int, UvError> {\n+    pub fn open_sync(self, loop_: &Loop, path: &CString,\n+                     flags: int, mode: int) -> Result<c_int, UvError> {\n         let complete_cb_ptr = {\n             let mut me = self;\n             me.req_boilerplate(None)\n         };\n-        let result = path.path_as_str(|p| {\n-            p.with_c_str(|p| unsafe {\n+        let result = path.with_ref(|p| unsafe {\n             uvll::fs_open(loop_.native_handle(),\n                     self.native_handle(), p, flags, mode, complete_cb_ptr)\n-            })\n         });\n         self.sync_cleanup(result)\n     }\n \n-    pub fn unlink<P: PathLike>(self, loop_: &Loop, path: &P, cb: FsCallback) {\n+    pub fn unlink(self, loop_: &Loop, path: &CString, cb: FsCallback) {\n         let complete_cb_ptr = {\n             let mut me = self;\n             me.req_boilerplate(Some(cb))\n         };\n-        path.path_as_str(|p| {\n-            p.with_c_str(|p| unsafe {\n-                uvll::fs_unlink(loop_.native_handle(),\n-                              self.native_handle(), p, complete_cb_ptr)\n-            })\n+        path.with_ref(|p| unsafe {\n+            uvll::fs_unlink(loop_.native_handle(),\n+                          self.native_handle(), p, complete_cb_ptr)\n         });\n     }\n \n-    pub fn unlink_sync<P: PathLike>(self, loop_: &Loop, path: &P)\n+    pub fn unlink_sync(self, loop_: &Loop, path: &CString)\n       -> Result<c_int, UvError> {\n         let complete_cb_ptr = {\n             let mut me = self;\n             me.req_boilerplate(None)\n         };\n-        let result = path.path_as_str(|p| {\n-            p.with_c_str(|p| unsafe {\n-                uvll::fs_unlink(loop_.native_handle(),\n-                              self.native_handle(), p, complete_cb_ptr)\n-            })\n+        let result = path.with_ref(|p| unsafe {\n+            uvll::fs_unlink(loop_.native_handle(),\n+                          self.native_handle(), p, complete_cb_ptr)\n         });\n         self.sync_cleanup(result)\n     }\n \n-    pub fn stat<P: PathLike>(self, loop_: &Loop, path: &P, cb: FsCallback) {\n+    pub fn stat(self, loop_: &Loop, path: &CString, cb: FsCallback) {\n         let complete_cb_ptr = {\n             let mut me = self;\n             me.req_boilerplate(Some(cb))\n         };\n-        path.path_as_str(|p| {\n-            p.with_c_str(|p| unsafe {\n-                uvll::fs_stat(loop_.native_handle(),\n-                              self.native_handle(), p, complete_cb_ptr)\n-            })\n+        path.with_ref(|p| unsafe {\n+            uvll::fs_stat(loop_.native_handle(),\n+                          self.native_handle(), p, complete_cb_ptr)\n         });\n     }\n \n@@ -186,43 +177,37 @@ impl FsRequest {\n         self.sync_cleanup(result)\n     }\n \n-    pub fn mkdir<P: PathLike>(self, loop_: &Loop, path: &P, mode: int, cb: FsCallback) {\n+    pub fn mkdir(self, loop_: &Loop, path: &CString, mode: int, cb: FsCallback) {\n         let complete_cb_ptr = {\n             let mut me = self;\n             me.req_boilerplate(Some(cb))\n         };\n-        path.path_as_str(|p| {\n-            p.with_c_str(|p| unsafe {\n+        path.with_ref(|p| unsafe {\n             uvll::fs_mkdir(loop_.native_handle(),\n                           self.native_handle(), p, mode, complete_cb_ptr)\n-            })\n         });\n     }\n \n-    pub fn rmdir<P: PathLike>(self, loop_: &Loop, path: &P, cb: FsCallback) {\n+    pub fn rmdir(self, loop_: &Loop, path: &CString, cb: FsCallback) {\n         let complete_cb_ptr = {\n             let mut me = self;\n             me.req_boilerplate(Some(cb))\n         };\n-        path.path_as_str(|p| {\n-            p.with_c_str(|p| unsafe {\n+        path.with_ref(|p| unsafe {\n             uvll::fs_rmdir(loop_.native_handle(),\n                           self.native_handle(), p, complete_cb_ptr)\n-            })\n         });\n     }\n \n-    pub fn readdir<P: PathLike>(self, loop_: &Loop, path: &P,\n-                                flags: c_int, cb: FsCallback) {\n+    pub fn readdir(self, loop_: &Loop, path: &CString,\n+                   flags: c_int, cb: FsCallback) {\n         let complete_cb_ptr = {\n             let mut me = self;\n             me.req_boilerplate(Some(cb))\n         };\n-        path.path_as_str(|p| {\n-            p.with_c_str(|p| unsafe {\n+        path.with_ref(|p| unsafe {\n             uvll::fs_readdir(loop_.native_handle(),\n                           self.native_handle(), p, flags, complete_cb_ptr)\n-            })\n         });\n     }\n \n@@ -286,13 +271,11 @@ impl FsRequest {\n         }\n     }\n \n-    pub fn get_paths(&mut self) -> ~[~str] {\n+    pub fn each_path(&mut self, f: &fn(&CString)) {\n         use str;\n         let ptr = self.get_ptr();\n         match self.get_result() {\n-            n if (n <= 0) => {\n-                ~[]\n-            },\n+            n if (n <= 0) => {}\n             n => {\n                 let n_len = n as uint;\n                 // we pass in the len that uv tells us is there\n@@ -301,11 +284,10 @@ impl FsRequest {\n                 // correctly delimited and we stray into garbage memory?\n                 // in any case, passing Some(n_len) fixes it and ensures\n                 // good results\n-                let raw_path_strs = unsafe {\n-                    str::raw::from_c_multistring(ptr as *libc::c_char, Some(n_len)) };\n-                let raw_len = raw_path_strs.len();\n-                assert_eq!(raw_len, n_len);\n-                raw_path_strs\n+                unsafe {\n+                    c_str::from_c_multistring(ptr as *libc::c_char,\n+                                              Some(n_len), f);\n+                }\n             }\n         }\n     }"}, {"sha": "b0cdce7dd935d3798f8f6a7dd47fe0e0c018cb0d", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9110a38cbfd801983a838775c690c83e9189b4c3/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9110a38cbfd801983a838775c690c83e9189b4c3/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=9110a38cbfd801983a838775c690c83e9189b4c3", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use c_str::ToCStr;\n+use c_str::{ToCStr, CString};\n use cast::transmute;\n use cast;\n use cell::Cell;\n@@ -36,7 +36,6 @@ use rt::uv::net::{UvIpv4SocketAddr, UvIpv6SocketAddr};\n use rt::uv::addrinfo::{GetAddrInfoRequest, accum_addrinfo};\n use unstable::sync::Exclusive;\n use path::{GenericPath, Path};\n-use super::super::io::support::PathLike;\n use libc::{lseek, off_t, O_CREAT, O_APPEND, O_TRUNC, O_RDWR, O_RDONLY, O_WRONLY,\n           S_IRUSR, S_IWUSR, S_IRWXU};\n use rt::io::{FileMode, FileAccess, OpenOrCreate, Open, Create,\n@@ -415,9 +414,9 @@ impl UvIoFactory {\n \n /// Helper for a variety of simple uv_fs_* functions that\n /// have no ret val\n-fn uv_fs_helper<P: PathLike>(loop_: &mut Loop, path: &P,\n-                             cb: ~fn(&mut FsRequest, &mut Loop, &P,\n-                                     ~fn(&FsRequest, Option<UvError>)))\n+fn uv_fs_helper(loop_: &mut Loop, path: &CString,\n+                cb: ~fn(&mut FsRequest, &mut Loop, &CString,\n+                        ~fn(&FsRequest, Option<UvError>)))\n         -> Result<(), IoError> {\n     let result_cell = Cell::new_empty();\n     let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n@@ -553,7 +552,7 @@ impl IoFactory for UvIoFactory {\n         ~UvFileStream::new(loop_, fd, close_on_drop, home) as ~RtioFileStream\n     }\n \n-    fn fs_open<P: PathLike>(&mut self, path: &P, fm: FileMode, fa: FileAccess)\n+    fn fs_open(&mut self, path: &CString, fm: FileMode, fa: FileAccess)\n         -> Result<~RtioFileStream, IoError> {\n         let mut flags = match fm {\n             Open => 0,\n@@ -608,14 +607,14 @@ impl IoFactory for UvIoFactory {\n         return result_cell.take();\n     }\n \n-    fn fs_unlink<P: PathLike>(&mut self, path: &P) -> Result<(), IoError> {\n+    fn fs_unlink(&mut self, path: &CString) -> Result<(), IoError> {\n         do uv_fs_helper(self.uv_loop(), path) |unlink_req, l, p, cb| {\n             do unlink_req.unlink(l, p) |req, err| {\n                 cb(req, err)\n             };\n         }\n     }\n-    fn fs_stat<P: PathLike>(&mut self, path: &P) -> Result<FileStat, IoError> {\n+    fn fs_stat(&mut self, path: &CString) -> Result<FileStat, IoError> {\n         use str::StrSlice;\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<FileStat,\n@@ -627,14 +626,13 @@ impl IoFactory for UvIoFactory {\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n                 let path = path_cell.take();\n-                let path_str = path.path_as_str(|p| p.to_owned());\n-                do stat_req.stat(self.uv_loop(), path)\n-                      |req,err| {\n+                let path_instance = Cell::new(Path::new(path.as_bytes()));\n+                do stat_req.stat(self.uv_loop(), path) |req,err| {\n                     let res = match err {\n                         None => {\n                             let stat = req.get_stat();\n                             Ok(FileStat {\n-                                path: Path::new(path_str.as_slice()),\n+                                path: path_instance.take(),\n                                 is_file: stat.is_file(),\n                                 is_dir: stat.is_dir(),\n                                 device: stat.st_dev,\n@@ -694,22 +692,22 @@ impl IoFactory for UvIoFactory {\n         assert!(!result_cell.is_empty());\n         return result_cell.take();\n     }\n-    fn fs_mkdir<P: PathLike>(&mut self, path: &P) -> Result<(), IoError> {\n+    fn fs_mkdir(&mut self, path: &CString) -> Result<(), IoError> {\n         let mode = S_IRWXU as int;\n         do uv_fs_helper(self.uv_loop(), path) |mkdir_req, l, p, cb| {\n             do mkdir_req.mkdir(l, p, mode as int) |req, err| {\n                 cb(req, err)\n             };\n         }\n     }\n-    fn fs_rmdir<P: PathLike>(&mut self, path: &P) -> Result<(), IoError> {\n+    fn fs_rmdir(&mut self, path: &CString) -> Result<(), IoError> {\n         do uv_fs_helper(self.uv_loop(), path) |rmdir_req, l, p, cb| {\n             do rmdir_req.rmdir(l, p) |req, err| {\n                 cb(req, err)\n             };\n         }\n     }\n-    fn fs_readdir<P: PathLike>(&mut self, path: &P, flags: c_int) ->\n+    fn fs_readdir(&mut self, path: &CString, flags: c_int) ->\n         Result<~[Path], IoError> {\n         use str::StrSlice;\n         let result_cell = Cell::new_empty();\n@@ -722,17 +720,14 @@ impl IoFactory for UvIoFactory {\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n                 let path = path_cell.take();\n-                let path_str = path.path_as_str(|p| p.to_owned());\n-                do stat_req.readdir(self.uv_loop(), path, flags)\n-                      |req,err| {\n+                let path_parent = Cell::new(Path::new(path.as_bytes()));\n+                do stat_req.readdir(self.uv_loop(), path, flags) |req,err| {\n+                    let parent = path_parent.take();\n                     let res = match err {\n                         None => {\n-                            let rel_paths = req.get_paths();\n                             let mut paths = ~[];\n-                            for r in rel_paths.iter() {\n-                                let mut p = Path::new(path_str.as_slice());\n-                                p.push(r.as_slice());\n-                                paths.push(p);\n+                            do req.each_path |rel_path| {\n+                                paths.push(parent.join(rel_path.as_bytes()));\n                             }\n                             Ok(paths)\n                         },\n@@ -2417,20 +2412,20 @@ fn file_test_uvio_full_simple_impl() {\n         {\n             let create_fm = Create;\n             let create_fa = ReadWrite;\n-            let mut fd = (*io).fs_open(&Path::new(path), create_fm, create_fa).unwrap();\n+            let mut fd = (*io).fs_open(&path.to_c_str(), create_fm, create_fa).unwrap();\n             let write_buf = write_val.as_bytes();\n             fd.write(write_buf);\n         }\n         {\n             let ro_fm = Open;\n             let ro_fa = Read;\n-            let mut fd = (*io).fs_open(&Path::new(path), ro_fm, ro_fa).unwrap();\n+            let mut fd = (*io).fs_open(&path.to_c_str(), ro_fm, ro_fa).unwrap();\n             let mut read_vec = [0, .. 1028];\n             let nread = fd.read(read_vec).unwrap();\n             let read_val = str::from_utf8(read_vec.slice(0, nread as uint));\n             assert!(read_val == write_val.to_owned());\n         }\n-        (*io).fs_unlink(&Path::new(path));\n+        (*io).fs_unlink(&path.to_c_str());\n     }\n }\n "}, {"sha": "3c89c12dbfa185bbcf32f708a9c59904ba9c9445", "filename": "src/libstd/str.rs", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9110a38cbfd801983a838775c690c83e9189b4c3/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9110a38cbfd801983a838775c690c83e9189b4c3/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=9110a38cbfd801983a838775c690c83e9189b4c3", "patch": "@@ -1172,34 +1172,6 @@ pub mod raw {\n         vec::raw::set_len(as_owned_vec(s), new_len)\n     }\n \n-    /// Parses a C \"multistring\", eg windows env values or\n-    /// the req->ptr result in a uv_fs_readdir() call.\n-    /// Optionally, a `count` can be passed in, limiting the\n-    /// parsing to only being done `count`-times.\n-    #[inline]\n-    pub unsafe fn from_c_multistring(buf: *libc::c_char, count: Option<uint>) -> ~[~str] {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        let mut curr_ptr: uint = buf as uint;\n-        let mut result = ~[];\n-        let mut ctr = 0;\n-        let (limited_count, limit) = match count {\n-            Some(limit) => (true, limit),\n-            None => (false, 0)\n-        };\n-        while(((limited_count && ctr < limit) || !limited_count)\n-              && *(curr_ptr as *libc::c_char) != 0 as libc::c_char) {\n-            let env_pair = from_c_str(\n-                curr_ptr as *libc::c_char);\n-            result.push(env_pair);\n-            curr_ptr +=\n-                libc::strlen(curr_ptr as *libc::c_char) as uint\n-                + 1;\n-            ctr += 1;\n-        }\n-        result\n-    }\n-\n     /// Sets the length of a string\n     ///\n     /// This will explicitly set the size of the string, without actually\n@@ -1214,26 +1186,6 @@ pub mod raw {\n             assert_eq!(c, ~\"AAA\");\n         }\n     }\n-\n-    #[test]\n-    fn test_str_multistring_parsing() {\n-        use option::None;\n-        unsafe {\n-            let input = bytes!(\"zero\", \"\\x00\", \"one\", \"\\x00\", \"\\x00\");\n-            let ptr = vec::raw::to_ptr(input);\n-            let result = from_c_multistring(ptr as *libc::c_char, None);\n-            assert!(result.len() == 2);\n-            let mut ctr = 0;\n-            for x in result.iter() {\n-                match ctr {\n-                    0 => assert_eq!(x, &~\"zero\"),\n-                    1 => assert_eq!(x, &~\"one\"),\n-                    _ => fail!(\"shouldn't happen!\")\n-                }\n-                ctr += 1;\n-            }\n-        }\n-    }\n }\n \n /*"}]}