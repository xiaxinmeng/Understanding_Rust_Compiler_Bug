{"sha": "afe257554c30693f545c50fd864b137023deb76a", "node_id": "C_kwDOAAsO6NoAKGFmZTI1NzU1NGMzMDY5M2Y1NDVjNTBmZDg2NGIxMzcwMjNkZWI3NmE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-03-12T19:44:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-12T19:44:50Z"}, "message": "Rollup merge of #109009 - notriddle:notriddle/edit-distance, r=GuillaumeGomez\n\nrustdoc: use restricted Damerau-Levenshtein distance for search\n\nBased on https://github.com/rust-lang/rust/pull/108200, for the same rationale.\n\n> This replaces the existing Levenshtein algorithm with the Damerau-Levenshtein algorithm. This means that \"ab\" to \"ba\" is one change (a transposition) instead of two (a deletion and insertion). More specifically, this is a restricted implementation, in that \"ca\" to \"abc\" cannot be performed as \"ca\" \u2192 \"ac\" \u2192 \"abc\", as there is an insertion in the middle of a transposition. I believe that errors like that are sufficiently rare that it's not worth taking into account.\n\nBefore this change, searching [`prinltn!`] listed `print!` first, followed by `println!`. With this change, `println!` matches more closely.\n\n[`prinltn!`]: https://doc.rust-lang.org/nightly/std/?search=prinltn!", "tree": {"sha": "0aa09d39d215192506cecfb3d19a7f96000f8b5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0aa09d39d215192506cecfb3d19a7f96000f8b5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afe257554c30693f545c50fd864b137023deb76a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkDiuyCRBK7hj4Ov3rIwAAMSEIAJ/aS0XB3tZWHrbnLOQNn3+c\nMd51N2E2WUpVgvizD5s7omHkrfsOgpVBqMqG844uiQgoHoVM2j6HY4DtvovLLS4k\nNM2EQ0lkSDwVCKLVwhs9d2eRnbUC7Eh1c1FLruIbh1br8JM7CpMIH4jtQUQuGXv3\nahjcU/owHQOoRAD99wARUdG1CbTHOxUTEs3NWzvrsiactVJbIoJFfZxqI4oyzK8G\n+/mz+tIFwzIf4PfSKDSQ1XKYhdYzBfDQaJtykpml51Ko5U7NLRfHQm/Jr4XCjaG2\n/amaquTGa1QfQMUHYHTqZXpycSpsA31ecDOPzRSvRFQpH9MhcGm0SMpnojz53T0=\n=B+16\n-----END PGP SIGNATURE-----\n", "payload": "tree 0aa09d39d215192506cecfb3d19a7f96000f8b5d\nparent f41796e6b48d15f5680efe413b6322494fecc66d\nparent ce795d9ca88bc676aa22efcf2292c475cd1ae39e\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1678650290 +0100\ncommitter GitHub <noreply@github.com> 1678650290 +0100\n\nRollup merge of #109009 - notriddle:notriddle/edit-distance, r=GuillaumeGomez\n\nrustdoc: use restricted Damerau-Levenshtein distance for search\n\nBased on https://github.com/rust-lang/rust/pull/108200, for the same rationale.\n\n> This replaces the existing Levenshtein algorithm with the Damerau-Levenshtein algorithm. This means that \"ab\" to \"ba\" is one change (a transposition) instead of two (a deletion and insertion). More specifically, this is a restricted implementation, in that \"ca\" to \"abc\" cannot be performed as \"ca\" \u2192 \"ac\" \u2192 \"abc\", as there is an insertion in the middle of a transposition. I believe that errors like that are sufficiently rare that it's not worth taking into account.\n\nBefore this change, searching [`prinltn!`] listed `print!` first, followed by `println!`. With this change, `println!` matches more closely.\n\n[`prinltn!`]: https://doc.rust-lang.org/nightly/std/?search=prinltn!\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afe257554c30693f545c50fd864b137023deb76a", "html_url": "https://github.com/rust-lang/rust/commit/afe257554c30693f545c50fd864b137023deb76a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afe257554c30693f545c50fd864b137023deb76a/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f41796e6b48d15f5680efe413b6322494fecc66d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f41796e6b48d15f5680efe413b6322494fecc66d", "html_url": "https://github.com/rust-lang/rust/commit/f41796e6b48d15f5680efe413b6322494fecc66d"}, {"sha": "ce795d9ca88bc676aa22efcf2292c475cd1ae39e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce795d9ca88bc676aa22efcf2292c475cd1ae39e", "html_url": "https://github.com/rust-lang/rust/commit/ce795d9ca88bc676aa22efcf2292c475cd1ae39e"}], "stats": {"total": 384, "additions": 235, "deletions": 149}, "files": [{"sha": "c71ce2c3001384a97dc2d25457b722e89557e643", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 223, "deletions": 149, "changes": 372, "blob_url": "https://github.com/rust-lang/rust/blob/afe257554c30693f545c50fd864b137023deb76a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/afe257554c30693f545c50fd864b137023deb76a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=afe257554c30693f545c50fd864b137023deb76a", "patch": "@@ -76,39 +76,111 @@ function printTab(nb) {\n }\n \n /**\n- * A function to compute the Levenshtein distance between two strings\n- * Licensed under the Creative Commons Attribution-ShareAlike 3.0 Unported\n- * Full License can be found at http://creativecommons.org/licenses/by-sa/3.0/legalcode\n- * This code is an unmodified version of the code written by Marco de Wit\n- * and was found at https://stackoverflow.com/a/18514751/745719\n+ * The [edit distance] is a metric for measuring the difference between two strings.\n+ *\n+ * [edit distance]: https://en.wikipedia.org/wiki/Edit_distance\n  */\n-const levenshtein_row2 = [];\n-function levenshtein(s1, s2) {\n-    if (s1 === s2) {\n-        return 0;\n-    }\n-    const s1_len = s1.length, s2_len = s2.length;\n-    if (s1_len && s2_len) {\n-        let i1 = 0, i2 = 0, a, b, c, c2;\n-        const row = levenshtein_row2;\n-        while (i1 < s1_len) {\n-            row[i1] = ++i1;\n-        }\n-        while (i2 < s2_len) {\n-            c2 = s2.charCodeAt(i2);\n-            a = i2;\n-            ++i2;\n-            b = i2;\n-            for (i1 = 0; i1 < s1_len; ++i1) {\n-                c = a + (s1.charCodeAt(i1) !== c2 ? 1 : 0);\n-                a = row[i1];\n-                b = b < a ? (b < c ? b + 1 : c) : (a < c ? a + 1 : c);\n-                row[i1] = b;\n-            }\n-        }\n-        return b;\n-    }\n-    return s1_len + s2_len;\n+\n+/*\n+ * This function was translated, mostly line-for-line, from\n+ * https://github.com/rust-lang/rust/blob/ff4b772f805ec1e/compiler/rustc_span/src/edit_distance.rs\n+ *\n+ * The current implementation is the restricted Damerau-Levenshtein algorithm. It is restricted\n+ * because it does not permit modifying characters that have already been transposed. The specific\n+ * algorithm should not matter to the caller of the methods, which is why it is not noted in the\n+ * documentation.\n+ */\n+const editDistanceState = {\n+    current: [],\n+    prev: [],\n+    prevPrev: [],\n+    calculate: function calculate(a, b, limit) {\n+        // Ensure that `b` is the shorter string, minimizing memory use.\n+        if (a.length < b.length) {\n+            const aTmp = a;\n+            a = b;\n+            b = aTmp;\n+        }\n+\n+        const minDist = a.length - b.length;\n+        // If we know the limit will be exceeded, we can return early.\n+        if (minDist > limit) {\n+            return limit + 1;\n+        }\n+\n+        // Strip common prefix.\n+        // We know that `b` is the shorter string, so we don't need to check\n+        // `a.length`.\n+        while (b.length > 0 && b[0] === a[0]) {\n+            a = a.substring(1);\n+            b = b.substring(1);\n+        }\n+        // Strip common suffix.\n+        while (b.length > 0 && b[b.length - 1] === a[a.length - 1]) {\n+            a = a.substring(0, a.length - 1);\n+            b = b.substring(0, b.length - 1);\n+        }\n+\n+        // If either string is empty, the distance is the length of the other.\n+        // We know that `b` is the shorter string, so we don't need to check `a`.\n+        if (b.length === 0) {\n+            return minDist;\n+        }\n+\n+        const aLength = a.length;\n+        const bLength = b.length;\n+\n+        for (let i = 0; i <= bLength; ++i) {\n+            this.current[i] = 0;\n+            this.prev[i] = i;\n+            this.prevPrev[i] = Number.MAX_VALUE;\n+        }\n+\n+        // row by row\n+        for (let i = 1; i <= aLength; ++i) {\n+            this.current[0] = i;\n+            const aIdx = i - 1;\n+\n+            // column by column\n+            for (let j = 1; j <= bLength; ++j) {\n+                const bIdx = j - 1;\n+\n+                // There is no cost to substitute a character with itself.\n+                const substitutionCost = a[aIdx] === b[bIdx] ? 0 : 1;\n+\n+                this.current[j] = Math.min(\n+                    // deletion\n+                    this.prev[j] + 1,\n+                    // insertion\n+                    this.current[j - 1] + 1,\n+                    // substitution\n+                    this.prev[j - 1] + substitutionCost\n+                );\n+\n+                if ((i > 1) && (j > 1) && (a[aIdx] === b[bIdx - 1]) && (a[aIdx - 1] === b[bIdx])) {\n+                    // transposition\n+                    this.current[j] = Math.min(\n+                        this.current[j],\n+                        this.prevPrev[j - 2] + 1\n+                    );\n+                }\n+            }\n+\n+            // Rotate the buffers, reusing the memory\n+            const prevPrevTmp = this.prevPrev;\n+            this.prevPrev = this.prev;\n+            this.prev = this.current;\n+            this.current = prevPrevTmp;\n+        }\n+\n+        // `prev` because we already rotated the buffers.\n+        const distance = this.prev[bLength];\n+        return distance <= limit ? distance : (limit + 1);\n+    },\n+};\n+\n+function editDistance(a, b, limit) {\n+    return editDistanceState.calculate(a, b, limit);\n }\n \n function initSearch(rawSearchIndex) {\n@@ -802,7 +874,7 @@ function initSearch(rawSearchIndex) {\n             for (const result of results) {\n                 if (result.id > -1) {\n                     const obj = searchIndex[result.id];\n-                    obj.lev = result.lev;\n+                    obj.dist = result.dist;\n                     const res = buildHrefAndPath(obj);\n                     obj.displayPath = pathSplitter(res[0]);\n                     obj.fullPath = obj.displayPath + obj.name;\n@@ -860,8 +932,8 @@ function initSearch(rawSearchIndex) {\n \n                 // Sort by distance in the path part, if specified\n                 // (less changes required to match means higher rankings)\n-                a = aaa.path_lev;\n-                b = bbb.path_lev;\n+                a = aaa.path_dist;\n+                b = bbb.path_dist;\n                 if (a !== b) {\n                     return a - b;\n                 }\n@@ -875,8 +947,8 @@ function initSearch(rawSearchIndex) {\n \n                 // Sort by distance in the name part, the last part of the path\n                 // (less changes required to match means higher rankings)\n-                a = (aaa.lev);\n-                b = (bbb.lev);\n+                a = (aaa.dist);\n+                b = (bbb.dist);\n                 if (a !== b) {\n                     return a - b;\n                 }\n@@ -968,19 +1040,20 @@ function initSearch(rawSearchIndex) {\n \n         /**\n          * This function checks if the object (`row`) generics match the given type (`elem`)\n-         * generics. If there are no generics on `row`, `defaultLev` is returned.\n+         * generics. If there are no generics on `row`, `defaultDistance` is returned.\n          *\n-         * @param {Row} row            - The object to check.\n-         * @param {QueryElement} elem  - The element from the parsed query.\n-         * @param {integer} defaultLev - This is the value to return in case there are no generics.\n+         * @param {Row} row                 - The object to check.\n+         * @param {QueryElement} elem       - The element from the parsed query.\n+         * @param {integer} defaultDistance - This is the value to return in case there are no\n+         *                                    generics.\n          *\n-         * @return {integer}           - Returns the best match (if any) or `maxLevDistance + 1`.\n+         * @return {integer}           - Returns the best match (if any) or `maxEditDistance + 1`.\n          */\n-        function checkGenerics(row, elem, defaultLev, maxLevDistance) {\n+        function checkGenerics(row, elem, defaultDistance, maxEditDistance) {\n             if (row.generics.length === 0) {\n-                return elem.generics.length === 0 ? defaultLev : maxLevDistance + 1;\n+                return elem.generics.length === 0 ? defaultDistance : maxEditDistance + 1;\n             } else if (row.generics.length > 0 && row.generics[0].name === null) {\n-                return checkGenerics(row.generics[0], elem, defaultLev, maxLevDistance);\n+                return checkGenerics(row.generics[0], elem, defaultDistance, maxEditDistance);\n             }\n             // The names match, but we need to be sure that all generics kinda\n             // match as well.\n@@ -991,8 +1064,9 @@ function initSearch(rawSearchIndex) {\n                     elem_name = entry.name;\n                     if (elem_name === \"\") {\n                         // Pure generic, needs to check into it.\n-                        if (checkGenerics(entry, elem, maxLevDistance + 1, maxLevDistance) !== 0) {\n-                            return maxLevDistance + 1;\n+                        if (checkGenerics(entry, elem, maxEditDistance + 1, maxEditDistance)\n+                            !== 0) {\n+                            return maxEditDistance + 1;\n                         }\n                         continue;\n                     }\n@@ -1019,7 +1093,7 @@ function initSearch(rawSearchIndex) {\n                         }\n                     }\n                     if (match === null) {\n-                        return maxLevDistance + 1;\n+                        return maxEditDistance + 1;\n                     }\n                     elems[match] -= 1;\n                     if (elems[match] === 0) {\n@@ -1028,7 +1102,7 @@ function initSearch(rawSearchIndex) {\n                 }\n                 return 0;\n             }\n-            return maxLevDistance + 1;\n+            return maxEditDistance + 1;\n         }\n \n         /**\n@@ -1038,17 +1112,17 @@ function initSearch(rawSearchIndex) {\n           * @param {Row} row\n           * @param {QueryElement} elem    - The element from the parsed query.\n           *\n-          * @return {integer} - Returns a Levenshtein distance to the best match.\n+          * @return {integer} - Returns an edit distance to the best match.\n           */\n-        function checkIfInGenerics(row, elem, maxLevDistance) {\n-            let lev = maxLevDistance + 1;\n+        function checkIfInGenerics(row, elem, maxEditDistance) {\n+            let dist = maxEditDistance + 1;\n             for (const entry of row.generics) {\n-                lev = Math.min(checkType(entry, elem, true, maxLevDistance), lev);\n-                if (lev === 0) {\n+                dist = Math.min(checkType(entry, elem, true, maxEditDistance), dist);\n+                if (dist === 0) {\n                     break;\n                 }\n             }\n-            return lev;\n+            return dist;\n         }\n \n         /**\n@@ -1059,21 +1133,21 @@ function initSearch(rawSearchIndex) {\n           * @param {QueryElement} elem      - The element from the parsed query.\n           * @param {boolean} literalSearch\n           *\n-          * @return {integer} - Returns a Levenshtein distance to the best match. If there is\n-          *                     no match, returns `maxLevDistance + 1`.\n+          * @return {integer} - Returns an edit distance to the best match. If there is\n+          *                     no match, returns `maxEditDistance + 1`.\n           */\n-        function checkType(row, elem, literalSearch, maxLevDistance) {\n+        function checkType(row, elem, literalSearch, maxEditDistance) {\n             if (row.name === null) {\n                 // This is a pure \"generic\" search, no need to run other checks.\n                 if (row.generics.length > 0) {\n-                    return checkIfInGenerics(row, elem, maxLevDistance);\n+                    return checkIfInGenerics(row, elem, maxEditDistance);\n                 }\n-                return maxLevDistance + 1;\n+                return maxEditDistance + 1;\n             }\n \n-            let lev = levenshtein(row.name, elem.name);\n+            let dist = editDistance(row.name, elem.name, maxEditDistance);\n             if (literalSearch) {\n-                if (lev !== 0) {\n+                if (dist !== 0) {\n                     // The name didn't match, let's try to check if the generics do.\n                     if (elem.generics.length === 0) {\n                         const checkGeneric = row.generics.length > 0;\n@@ -1082,44 +1156,44 @@ function initSearch(rawSearchIndex) {\n                             return 0;\n                         }\n                     }\n-                    return maxLevDistance + 1;\n+                    return maxEditDistance + 1;\n                 } else if (elem.generics.length > 0) {\n-                    return checkGenerics(row, elem, maxLevDistance + 1, maxLevDistance);\n+                    return checkGenerics(row, elem, maxEditDistance + 1, maxEditDistance);\n                 }\n                 return 0;\n             } else if (row.generics.length > 0) {\n                 if (elem.generics.length === 0) {\n-                    if (lev === 0) {\n+                    if (dist === 0) {\n                         return 0;\n                     }\n                     // The name didn't match so we now check if the type we're looking for is inside\n                     // the generics!\n-                    lev = Math.min(lev, checkIfInGenerics(row, elem, maxLevDistance));\n-                    return lev;\n-                } else if (lev > maxLevDistance) {\n+                    dist = Math.min(dist, checkIfInGenerics(row, elem, maxEditDistance));\n+                    return dist;\n+                } else if (dist > maxEditDistance) {\n                     // So our item's name doesn't match at all and has generics.\n                     //\n                     // Maybe it's present in a sub generic? For example \"f<A<B<C>>>()\", if we're\n                     // looking for \"B<C>\", we'll need to go down.\n-                    return checkIfInGenerics(row, elem, maxLevDistance);\n+                    return checkIfInGenerics(row, elem, maxEditDistance);\n                 } else {\n                     // At this point, the name kinda match and we have generics to check, so\n                     // let's go!\n-                    const tmp_lev = checkGenerics(row, elem, lev, maxLevDistance);\n-                    if (tmp_lev > maxLevDistance) {\n-                        return maxLevDistance + 1;\n+                    const tmp_dist = checkGenerics(row, elem, dist, maxEditDistance);\n+                    if (tmp_dist > maxEditDistance) {\n+                        return maxEditDistance + 1;\n                     }\n                     // We compute the median value of both checks and return it.\n-                    return (tmp_lev + lev) / 2;\n+                    return (tmp_dist + dist) / 2;\n                 }\n             } else if (elem.generics.length > 0) {\n                 // In this case, we were expecting generics but there isn't so we simply reject this\n                 // one.\n-                return maxLevDistance + 1;\n+                return maxEditDistance + 1;\n             }\n             // No generics on our query or on the target type so we can return without doing\n             // anything else.\n-            return lev;\n+            return dist;\n         }\n \n         /**\n@@ -1129,27 +1203,27 @@ function initSearch(rawSearchIndex) {\n          * @param {QueryElement} elem    - The element from the parsed query.\n          * @param {integer} typeFilter\n          *\n-         * @return {integer} - Returns a Levenshtein distance to the best match. If there is no\n-         *                      match, returns `maxLevDistance + 1`.\n+         * @return {integer} - Returns an edit distance to the best match. If there is no\n+         *                      match, returns `maxEditDistance + 1`.\n          */\n-        function findArg(row, elem, typeFilter, maxLevDistance) {\n-            let lev = maxLevDistance + 1;\n+        function findArg(row, elem, typeFilter, maxEditDistance) {\n+            let dist = maxEditDistance + 1;\n \n             if (row && row.type && row.type.inputs && row.type.inputs.length > 0) {\n                 for (const input of row.type.inputs) {\n                     if (!typePassesFilter(typeFilter, input.ty)) {\n                         continue;\n                     }\n-                    lev = Math.min(\n-                        lev,\n-                        checkType(input, elem, parsedQuery.literalSearch, maxLevDistance)\n+                    dist = Math.min(\n+                        dist,\n+                        checkType(input, elem, parsedQuery.literalSearch, maxEditDistance)\n                     );\n-                    if (lev === 0) {\n+                    if (dist === 0) {\n                         return 0;\n                     }\n                 }\n             }\n-            return parsedQuery.literalSearch ? maxLevDistance + 1 : lev;\n+            return parsedQuery.literalSearch ? maxEditDistance + 1 : dist;\n         }\n \n         /**\n@@ -1159,35 +1233,35 @@ function initSearch(rawSearchIndex) {\n          * @param {QueryElement} elem   - The element from the parsed query.\n          * @param {integer} typeFilter\n          *\n-         * @return {integer} - Returns a Levenshtein distance to the best match. If there is no\n-         *                      match, returns `maxLevDistance + 1`.\n+         * @return {integer} - Returns an edit distance to the best match. If there is no\n+         *                      match, returns `maxEditDistance + 1`.\n          */\n-        function checkReturned(row, elem, typeFilter, maxLevDistance) {\n-            let lev = maxLevDistance + 1;\n+        function checkReturned(row, elem, typeFilter, maxEditDistance) {\n+            let dist = maxEditDistance + 1;\n \n             if (row && row.type && row.type.output.length > 0) {\n                 const ret = row.type.output;\n                 for (const ret_ty of ret) {\n                     if (!typePassesFilter(typeFilter, ret_ty.ty)) {\n                         continue;\n                     }\n-                    lev = Math.min(\n-                        lev,\n-                        checkType(ret_ty, elem, parsedQuery.literalSearch, maxLevDistance)\n+                    dist = Math.min(\n+                        dist,\n+                        checkType(ret_ty, elem, parsedQuery.literalSearch, maxEditDistance)\n                     );\n-                    if (lev === 0) {\n+                    if (dist === 0) {\n                         return 0;\n                     }\n                 }\n             }\n-            return parsedQuery.literalSearch ? maxLevDistance + 1 : lev;\n+            return parsedQuery.literalSearch ? maxEditDistance + 1 : dist;\n         }\n \n-        function checkPath(contains, ty, maxLevDistance) {\n+        function checkPath(contains, ty, maxEditDistance) {\n             if (contains.length === 0) {\n                 return 0;\n             }\n-            let ret_lev = maxLevDistance + 1;\n+            let ret_dist = maxEditDistance + 1;\n             const path = ty.path.split(\"::\");\n \n             if (ty.parent && ty.parent.name) {\n@@ -1197,27 +1271,27 @@ function initSearch(rawSearchIndex) {\n             const length = path.length;\n             const clength = contains.length;\n             if (clength > length) {\n-                return maxLevDistance + 1;\n+                return maxEditDistance + 1;\n             }\n             for (let i = 0; i < length; ++i) {\n                 if (i + clength > length) {\n                     break;\n                 }\n-                let lev_total = 0;\n+                let dist_total = 0;\n                 let aborted = false;\n                 for (let x = 0; x < clength; ++x) {\n-                    const lev = levenshtein(path[i + x], contains[x]);\n-                    if (lev > maxLevDistance) {\n+                    const dist = editDistance(path[i + x], contains[x], maxEditDistance);\n+                    if (dist > maxEditDistance) {\n                         aborted = true;\n                         break;\n                     }\n-                    lev_total += lev;\n+                    dist_total += dist;\n                 }\n                 if (!aborted) {\n-                    ret_lev = Math.min(ret_lev, Math.round(lev_total / clength));\n+                    ret_dist = Math.min(ret_dist, Math.round(dist_total / clength));\n                 }\n             }\n-            return ret_lev;\n+            return ret_dist;\n         }\n \n         function typePassesFilter(filter, type) {\n@@ -1312,40 +1386,40 @@ function initSearch(rawSearchIndex) {\n          * This function adds the given result into the provided `results` map if it matches the\n          * following condition:\n          *\n-         * * If it is a \"literal search\" (`parsedQuery.literalSearch`), then `lev` must be 0.\n-         * * If it is not a \"literal search\", `lev` must be <= `maxLevDistance`.\n+         * * If it is a \"literal search\" (`parsedQuery.literalSearch`), then `dist` must be 0.\n+         * * If it is not a \"literal search\", `dist` must be <= `maxEditDistance`.\n          *\n          * The `results` map contains information which will be used to sort the search results:\n          *\n          * * `fullId` is a `string`` used as the key of the object we use for the `results` map.\n          * * `id` is the index in both `searchWords` and `searchIndex` arrays for this element.\n          * * `index` is an `integer`` used to sort by the position of the word in the item's name.\n-         * * `lev` is the main metric used to sort the search results.\n-         * * `path_lev` is zero if a single-component search query is used, otherwise it's the\n+         * * `dist` is the main metric used to sort the search results.\n+         * * `path_dist` is zero if a single-component search query is used, otherwise it's the\n          *   distance computed for everything other than the last path component.\n          *\n          * @param {Results} results\n          * @param {string} fullId\n          * @param {integer} id\n          * @param {integer} index\n-         * @param {integer} lev\n-         * @param {integer} path_lev\n+         * @param {integer} dist\n+         * @param {integer} path_dist\n          */\n-        function addIntoResults(results, fullId, id, index, lev, path_lev, maxLevDistance) {\n-            const inBounds = lev <= maxLevDistance || index !== -1;\n-            if (lev === 0 || (!parsedQuery.literalSearch && inBounds)) {\n+        function addIntoResults(results, fullId, id, index, dist, path_dist, maxEditDistance) {\n+            const inBounds = dist <= maxEditDistance || index !== -1;\n+            if (dist === 0 || (!parsedQuery.literalSearch && inBounds)) {\n                 if (results[fullId] !== undefined) {\n                     const result = results[fullId];\n-                    if (result.dontValidate || result.lev <= lev) {\n+                    if (result.dontValidate || result.dist <= dist) {\n                         return;\n                     }\n                 }\n                 results[fullId] = {\n                     id: id,\n                     index: index,\n                     dontValidate: parsedQuery.literalSearch,\n-                    lev: lev,\n-                    path_lev: path_lev,\n+                    dist: dist,\n+                    path_dist: path_dist,\n                 };\n             }\n         }\n@@ -1354,7 +1428,7 @@ function initSearch(rawSearchIndex) {\n          * This function is called in case the query is only one element (with or without generics).\n          * This element will be compared to arguments' and returned values' items and also to items.\n          *\n-         * Other important thing to note: since there is only one element, we use levenshtein\n+         * Other important thing to note: since there is only one element, we use edit\n          * distance for name comparisons.\n          *\n          * @param {Row} row\n@@ -1372,22 +1446,22 @@ function initSearch(rawSearchIndex) {\n             results_others,\n             results_in_args,\n             results_returned,\n-            maxLevDistance\n+            maxEditDistance\n         ) {\n             if (!row || (filterCrates !== null && row.crate !== filterCrates)) {\n                 return;\n             }\n-            let lev, index = -1, path_lev = 0;\n+            let dist, index = -1, path_dist = 0;\n             const fullId = row.id;\n             const searchWord = searchWords[pos];\n \n-            const in_args = findArg(row, elem, parsedQuery.typeFilter, maxLevDistance);\n-            const returned = checkReturned(row, elem, parsedQuery.typeFilter, maxLevDistance);\n+            const in_args = findArg(row, elem, parsedQuery.typeFilter, maxEditDistance);\n+            const returned = checkReturned(row, elem, parsedQuery.typeFilter, maxEditDistance);\n \n-            // path_lev is 0 because no parent path information is currently stored\n+            // path_dist is 0 because no parent path information is currently stored\n             // in the search index\n-            addIntoResults(results_in_args, fullId, pos, -1, in_args, 0, maxLevDistance);\n-            addIntoResults(results_returned, fullId, pos, -1, returned, 0, maxLevDistance);\n+            addIntoResults(results_in_args, fullId, pos, -1, in_args, 0, maxEditDistance);\n+            addIntoResults(results_returned, fullId, pos, -1, returned, 0, maxEditDistance);\n \n             if (!typePassesFilter(parsedQuery.typeFilter, row.ty)) {\n                 return;\n@@ -1411,34 +1485,34 @@ function initSearch(rawSearchIndex) {\n             // No need to check anything else if it's a \"pure\" generics search.\n             if (elem.name.length === 0) {\n                 if (row.type !== null) {\n-                    lev = checkGenerics(row.type, elem, maxLevDistance + 1, maxLevDistance);\n-                    // path_lev is 0 because we know it's empty\n-                    addIntoResults(results_others, fullId, pos, index, lev, 0, maxLevDistance);\n+                    dist = checkGenerics(row.type, elem, maxEditDistance + 1, maxEditDistance);\n+                    // path_dist is 0 because we know it's empty\n+                    addIntoResults(results_others, fullId, pos, index, dist, 0, maxEditDistance);\n                 }\n                 return;\n             }\n \n             if (elem.fullPath.length > 1) {\n-                path_lev = checkPath(elem.pathWithoutLast, row, maxLevDistance);\n-                if (path_lev > maxLevDistance) {\n+                path_dist = checkPath(elem.pathWithoutLast, row, maxEditDistance);\n+                if (path_dist > maxEditDistance) {\n                     return;\n                 }\n             }\n \n             if (parsedQuery.literalSearch) {\n                 if (searchWord === elem.name) {\n-                    addIntoResults(results_others, fullId, pos, index, 0, path_lev);\n+                    addIntoResults(results_others, fullId, pos, index, 0, path_dist);\n                 }\n                 return;\n             }\n \n-            lev = levenshtein(searchWord, elem.pathLast);\n+            dist = editDistance(searchWord, elem.pathLast, maxEditDistance);\n \n-            if (index === -1 && lev + path_lev > maxLevDistance) {\n+            if (index === -1 && dist + path_dist > maxEditDistance) {\n                 return;\n             }\n \n-            addIntoResults(results_others, fullId, pos, index, lev, path_lev, maxLevDistance);\n+            addIntoResults(results_others, fullId, pos, index, dist, path_dist, maxEditDistance);\n         }\n \n         /**\n@@ -1450,22 +1524,22 @@ function initSearch(rawSearchIndex) {\n          * @param {integer} pos      - Position in the `searchIndex`.\n          * @param {Object} results\n          */\n-        function handleArgs(row, pos, results, maxLevDistance) {\n+        function handleArgs(row, pos, results, maxEditDistance) {\n             if (!row || (filterCrates !== null && row.crate !== filterCrates)) {\n                 return;\n             }\n \n-            let totalLev = 0;\n-            let nbLev = 0;\n+            let totalDist = 0;\n+            let nbDist = 0;\n \n             // If the result is too \"bad\", we return false and it ends this search.\n             function checkArgs(elems, callback) {\n                 for (const elem of elems) {\n                     // There is more than one parameter to the query so all checks should be \"exact\"\n-                    const lev = callback(row, elem, NO_TYPE_FILTER, maxLevDistance);\n-                    if (lev <= 1) {\n-                        nbLev += 1;\n-                        totalLev += lev;\n+                    const dist = callback(row, elem, NO_TYPE_FILTER, maxEditDistance);\n+                    if (dist <= 1) {\n+                        nbDist += 1;\n+                        totalDist += dist;\n                     } else {\n                         return false;\n                     }\n@@ -1479,11 +1553,11 @@ function initSearch(rawSearchIndex) {\n                 return;\n             }\n \n-            if (nbLev === 0) {\n+            if (nbDist === 0) {\n                 return;\n             }\n-            const lev = Math.round(totalLev / nbLev);\n-            addIntoResults(results, row.id, pos, 0, lev, 0, maxLevDistance);\n+            const dist = Math.round(totalDist / nbDist);\n+            addIntoResults(results, row.id, pos, 0, dist, 0, maxEditDistance);\n         }\n \n         function innerRunQuery() {\n@@ -1496,7 +1570,7 @@ function initSearch(rawSearchIndex) {\n             for (const elem of parsedQuery.returned) {\n                 queryLen += elem.name.length;\n             }\n-            const maxLevDistance = Math.floor(queryLen / 3);\n+            const maxEditDistance = Math.floor(queryLen / 3);\n \n             if (parsedQuery.foundElems === 1) {\n                 if (parsedQuery.elems.length === 1) {\n@@ -1511,7 +1585,7 @@ function initSearch(rawSearchIndex) {\n                             results_others,\n                             results_in_args,\n                             results_returned,\n-                            maxLevDistance\n+                            maxEditDistance\n                         );\n                     }\n                 } else if (parsedQuery.returned.length === 1) {\n@@ -1523,14 +1597,14 @@ function initSearch(rawSearchIndex) {\n                             row,\n                             elem,\n                             parsedQuery.typeFilter,\n-                            maxLevDistance\n+                            maxEditDistance\n                         );\n-                        addIntoResults(results_others, row.id, i, -1, in_returned, maxLevDistance);\n+                        addIntoResults(results_others, row.id, i, -1, in_returned, maxEditDistance);\n                     }\n                 }\n             } else if (parsedQuery.foundElems > 0) {\n                 for (i = 0, nSearchWords = searchWords.length; i < nSearchWords; ++i) {\n-                    handleArgs(searchIndex[i], i, results_others, maxLevDistance);\n+                    handleArgs(searchIndex[i], i, results_others, maxEditDistance);\n                 }\n             }\n         }\n@@ -1568,7 +1642,7 @@ function initSearch(rawSearchIndex) {\n      *\n      * @return {boolean}       - Whether the result is valid or not\n      */\n-    function validateResult(name, path, keys, parent, maxLevDistance) {\n+    function validateResult(name, path, keys, parent, maxEditDistance) {\n         if (!keys || !keys.length) {\n             return true;\n         }\n@@ -1582,8 +1656,8 @@ function initSearch(rawSearchIndex) {\n                 // next if there is a parent, check for exact parent match\n                 (parent !== undefined && parent.name !== undefined &&\n                     parent.name.toLowerCase().indexOf(key) > -1) ||\n-                // lastly check to see if the name was a levenshtein match\n-                levenshtein(name, key) <= maxLevDistance)) {\n+                // lastly check to see if the name was an editDistance match\n+                editDistance(name, key, maxEditDistance) <= maxEditDistance)) {\n                 return false;\n             }\n         }"}, {"sha": "7ca3ab8e563330c020be4f442072c11b041ed77b", "filename": "tests/rustdoc-js-std/println-typo.js", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/afe257554c30693f545c50fd864b137023deb76a/tests%2Frustdoc-js-std%2Fprintln-typo.js", "raw_url": "https://github.com/rust-lang/rust/raw/afe257554c30693f545c50fd864b137023deb76a/tests%2Frustdoc-js-std%2Fprintln-typo.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js-std%2Fprintln-typo.js?ref=afe257554c30693f545c50fd864b137023deb76a", "patch": "@@ -0,0 +1,12 @@\n+// exact-check\n+\n+const QUERY = 'prinltn';\n+const FILTER_CRATE = 'std';\n+\n+const EXPECTED = {\n+    'others': [\n+        { 'path': 'std', 'name': 'println' },\n+        { 'path': 'std', 'name': 'print' },\n+        { 'path': 'std', 'name': 'eprintln' },\n+    ],\n+};"}]}