{"sha": "fe1165f5610a5c35ec94e3524200977fdf64ef0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlMTE2NWY1NjEwYTVjMzVlYzk0ZTM1MjQyMDA5NzdmZGY2NGVmMGM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-10T03:04:15Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-10T03:05:41Z"}, "message": "Tighten up language surrounding declarations, assignments, inits, lvals.", "tree": {"sha": "d543aeda58381b95ba54b5572b5770e549e2ed04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d543aeda58381b95ba54b5572b5770e549e2ed04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe1165f5610a5c35ec94e3524200977fdf64ef0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe1165f5610a5c35ec94e3524200977fdf64ef0c", "html_url": "https://github.com/rust-lang/rust/commit/fe1165f5610a5c35ec94e3524200977fdf64ef0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe1165f5610a5c35ec94e3524200977fdf64ef0c/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e325d029d4c0a0102de0000963cad7282f9f9ddd", "url": "https://api.github.com/repos/rust-lang/rust/commits/e325d029d4c0a0102de0000963cad7282f9f9ddd", "html_url": "https://github.com/rust-lang/rust/commit/e325d029d4c0a0102de0000963cad7282f9f9ddd"}], "stats": {"total": 64, "additions": 22, "deletions": 42}, "files": [{"sha": "7c859f90ebef10c72d45bc282436bbb5d20df3ba", "filename": "doc/rust.md", "status": "modified", "additions": 22, "deletions": 42, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/fe1165f5610a5c35ec94e3524200977fdf64ef0c/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/fe1165f5610a5c35ec94e3524200977fdf64ef0c/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=fe1165f5610a5c35ec94e3524200977fdf64ef0c", "patch": "@@ -1435,27 +1435,11 @@ let_decl : \"let\" pat [':' type ] ? [ init ] ? ';' ;\n init : [ '=' | '<-' ] expr ;\n ~~~~~~~~\n \n-\n-A _slot declaration_ has one of two forms:\n-\n-* `let` `pattern` `optional-init`;\n-* `let` `pattern` : `type` `optional-init`;\n-\n-Where `type` is a type expression, `pattern` is an irrefutable pattern (often\n-just the name of a single slot), and `optional-init` is an optional\n-initializer. If present, the initializer consists of either an assignment\n-operator (`=`) or move operator (`<-`), followed by an expression.\n-\n-Both forms introduce a new slot into the enclosing block scope. The new slot\n-is visible from the point of declaration until the end of the enclosing block\n-scope.\n-\n-The former form, with no type annotation, causes the compiler to infer the\n-static type of the slot through unification with the types of values assigned\n-to the slot in the remaining code in the block scope. Inference only occurs on\n-frame-local variable, not argument slots. Function signatures must\n-always declare types for all argument slots.\n-\n+A _slot declaration_ introduces a new set of slots, given by a pattern.\n+The pattern may be followed by a type annotation, and/or an initializer expression.\n+When no type annotation is given, the compiler will infer the type,\n+or signal an error if insufficient type information is available for definite inference.\n+Any slots introduced by a slot declaration are visible from the point of declaration until the end of the enclosing block scope.\n \n ### Expression statements\n \n@@ -1487,7 +1471,8 @@ The evaluation of an expression depends both on its own category and the context\n Path, field and index expressions are lvalues.\n All other expressions are rvalues.\n \n-The left operand of an assignment expression and the operand of the borrow operator are lvalue contexts.\n+The left operand of an assignment, compound-assignment, or binary move expression is an lvalue context,\n+as is the single operand of a borrow, unary copy or move expression, and _both_ operands of a swap expression.\n All other expression contexts are rvalue contexts.\n \n When an lvalue is evaluated in an _lvalue context_, it denotes a memory location;\n@@ -1572,9 +1557,8 @@ myrecord.myfield;\n {a: 10, b: 20}.a;\n ~~~~~~~~\n \n-A field access on a record is an _lval_ referring to the value of that\n-field. When the field is mutable, it can be\n-[assigned](#assignment-expressions) to.\n+A field access on a record is an [lvalue](#lvalues-rvalues-and-temporaries) referring to the value of that field.\n+When the field is mutable, it can be [assigned](#assignment-expressions) to.\n \n When the type of the expression to the left of the dot is a boxed\n record, it is automatically derferenced to make the field access\n@@ -1615,7 +1599,7 @@ idx_expr : expr '[' expr ']'\n \n [Vector](#vector-types)-typed expressions can be indexed by writing a\n square-bracket-enclosed expression (the index) after them. When the\n-vector is mutable, the resulting _lval_ can be assigned to.\n+vector is mutable, the resulting [lvalue](#lvalues-rvalues-and-temporaries) can be assigned to.\n \n Indices are zero-based, and may be of any integral type. Vector access\n is bounds-checked at run-time. When the check fails, it will put the\n@@ -1641,7 +1625,7 @@ operators, before the expression they apply to.\n `*`\n   : Dereference. When applied to a [box](#box-types) or\n     [resource](#resources) type, it accesses the inner value. For\n-    mutable boxes, the resulting _lval_ can be assigned to. For\n+    mutable boxes, the resulting [lvalue](#lvalues-rvalues-and-temporaries) can be assigned to. For\n     [enums](#enumerated-types) that have only a single variant,\n     containing a single parameter, the dereference operator accesses\n     this parameter.\n@@ -1762,11 +1746,11 @@ types.\n \n #### Binary move expressions\n \n-A _binary move expression_ consists of an *lval* followed by a left-pointing\n-arrow (`<-`) and an *rval* expression.\n+A _binary move expression_ consists of an [lvalue](#lvalues-rvalues-and-temporaries) followed by a left-pointing\n+arrow (`<-`) and an [rvalue](#lvalues-rvalues-and-temporaries) expression.\n \n-Evaluating a move expression causes, as a side effect, the *rval* to be\n-*moved* into the *lval*. If the *rval* was itself an *lval*, it must be a\n+Evaluating a move expression causes, as a side effect, the rvalue to be\n+*moved* into the lvalue. If the rvalue was itself an lvalue, it must be a\n local variable, as it will be de-initialized in the process.\n \n Evaluating a move expression does not change reference counts, nor does it\n@@ -1792,17 +1776,13 @@ y.z <- c;\n \n #### Swap expressions\n \n-A _swap expression_ consists of an *lval* followed by a bi-directional arrow\n-(`<->`) and another *lval* expression.\n+A _swap expression_ consists of an [lvalue](#lvalues-rvalues-and-temporaries) followed by a bi-directional arrow (`<->`) and another [lvalue](#lvalues-rvalues-and-temporaries).\n \n-Evaluating a swap expression causes, as a side effect, the values held in the\n-left-hand-side and right-hand-side *lvals* to be exchanged indivisibly.\n+Evaluating a swap expression causes, as a side effect, the values held in the left-hand-side and right-hand-side [lvalues](#lvalues-rvalues-and-temporaries) to be exchanged indivisibly.\n \n-Evaluating a swap expression neither changes reference counts nor deeply\n-copies any unique structure pointed to by the moved\n-*rval*. Instead, the swap expression represents an indivisible *exchange of\n-ownership* between the right-hand-side and the left-hand-side of the\n-expression. No allocation or destruction is entailed.\n+Evaluating a swap expression neither changes reference counts nor deeply copies any unique structure pointed to by the moved [rvalue](#lvalues-rvalues-and-temporaries).\n+Instead, the swap expression represents an indivisible *exchange of ownership* between the right-hand-side and the left-hand-side of the expression.\n+No allocation or destruction is entailed.\n \n An example of three different swap expressions:\n \n@@ -1821,8 +1801,8 @@ y.z <-> b.c;\n \n #### Assignment expressions\n \n-An _assignment expression_ consists of an *lval* expression followed by an\n-equals sign (`=`) and an *rval* expression.\n+An _assignment expression_ consists of an [lvalue](#lvalues-rvalues-and-temporaries) expression followed by an\n+equals sign (`=`) and an [rvalue](#lvalues-rvalues-and-temporaries) expression.\n \n Evaluating an assignment expression is equivalent to evaluating a [binary move\n expression](#binary-move-expressions) applied to a [unary copy"}]}