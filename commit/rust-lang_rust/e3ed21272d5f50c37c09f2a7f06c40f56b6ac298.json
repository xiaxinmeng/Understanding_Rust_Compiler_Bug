{"sha": "e3ed21272d5f50c37c09f2a7f06c40f56b6ac298", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzZWQyMTI3MmQ1ZjUwYzM3YzA5ZjJhN2YwNmM0MGY1NmI2YWMyOTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-01T13:26:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-01T13:26:10Z"}, "message": "Auto merge of #46236 - davidtwco:issue-46023, r=arielb1\n\nMIR-borrowck: immutable unique closure upvars can be mutated\n\nFixes #46023 and #46160 (see [this comment](https://github.com/rust-lang/rust/pull/46236#issuecomment-347204874)).", "tree": {"sha": "4061fce192f00bab4e228c9d268fe1e8a1d7fc33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4061fce192f00bab4e228c9d268fe1e8a1d7fc33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3ed21272d5f50c37c09f2a7f06c40f56b6ac298", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3ed21272d5f50c37c09f2a7f06c40f56b6ac298", "html_url": "https://github.com/rust-lang/rust/commit/e3ed21272d5f50c37c09f2a7f06c40f56b6ac298", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3ed21272d5f50c37c09f2a7f06c40f56b6ac298/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "315fbf7518dbcace5b92eabab746ba0a2c5531fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/315fbf7518dbcace5b92eabab746ba0a2c5531fa", "html_url": "https://github.com/rust-lang/rust/commit/315fbf7518dbcace5b92eabab746ba0a2c5531fa"}, {"sha": "c6b1ba56d7635a4a70b5bf390413944a86744e15", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6b1ba56d7635a4a70b5bf390413944a86744e15", "html_url": "https://github.com/rust-lang/rust/commit/c6b1ba56d7635a4a70b5bf390413944a86744e15"}], "stats": {"total": 139, "additions": 89, "deletions": 50}, "files": [{"sha": "151a3d52a4667150eb641104dc72d7d13a8a9b29", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3ed21272d5f50c37c09f2a7f06c40f56b6ac298/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3ed21272d5f50c37c09f2a7f06c40f56b6ac298/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=e3ed21272d5f50c37c09f2a7f06c40f56b6ac298", "patch": "@@ -31,7 +31,7 @@ impl_stable_hash_for!(struct mir::LocalDecl<'tcx> {\n     lexical_scope,\n     is_user_variable\n });\n-impl_stable_hash_for!(struct mir::UpvarDecl { debug_name, by_ref });\n+impl_stable_hash_for!(struct mir::UpvarDecl { debug_name, by_ref, mutability });\n impl_stable_hash_for!(struct mir::BasicBlockData<'tcx> { statements, terminator, is_cleanup });\n impl_stable_hash_for!(struct mir::UnsafetyViolation { source_info, description, kind });\n impl_stable_hash_for!(struct mir::UnsafetyCheckResult { violations, unsafe_blocks });"}, {"sha": "42d8ae172edd0c91e03a508cd3072655b11fde47", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3ed21272d5f50c37c09f2a7f06c40f56b6ac298/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3ed21272d5f50c37c09f2a7f06c40f56b6ac298/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=e3ed21272d5f50c37c09f2a7f06c40f56b6ac298", "patch": "@@ -546,7 +546,9 @@ pub struct UpvarDecl {\n     pub debug_name: Name,\n \n     /// If true, the capture is behind a reference.\n-    pub by_ref: bool\n+    pub by_ref: bool,\n+\n+    pub mutability: Mutability,\n }\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "642df2e179f603360c8e3884098485346919c397", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 50, "deletions": 47, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/e3ed21272d5f50c37c09f2a7f06c40f56b6ac298/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3ed21272d5f50c37c09f2a7f06c40f56b6ac298/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=e3ed21272d5f50c37c09f2a7f06c40f56b6ac298", "patch": "@@ -761,47 +761,34 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let move_data = self.move_data;\n \n         // determine if this path has a non-mut owner (and thus needs checking).\n-        let mut l = lvalue;\n-        loop {\n-            match *l {\n-                Lvalue::Projection(ref proj) => {\n-                    l = &proj.base;\n-                    continue;\n-                }\n-                Lvalue::Local(local) => {\n-                    match self.mir.local_decls[local].mutability {\n-                        Mutability::Not => break, // needs check\n-                        Mutability::Mut => return,\n-                    }\n-                }\n-                Lvalue::Static(ref static_) => {\n-                    // mutation of non-mut static is always illegal,\n-                    // independent of dataflow. However it will be catched by\n-                    // `check_access_permissions()`, we call delay_span_bug here\n-                    // to be sure that no case has been missed\n-                    if !self.tcx.is_static_mut(static_.def_id) {\n-                        let item_msg = match self.describe_lvalue(lvalue) {\n-                            Some(name) => format!(\"immutable static item `{}`\", name),\n-                            None => \"immutable static item\".to_owned()\n-                        };\n-                        self.tcx.sess.delay_span_bug(span,\n-                            &format!(\"cannot assign to {}, should have been caught by \\\n-                            `check_access_permissions()`\", item_msg));\n-                    }\n-                    return;\n-                }\n-            }\n+        if let Ok(()) = self.is_mutable(lvalue, LocalMutationIsAllowed::No) {\n+            return;\n         }\n \n-        if let Some(mpi) = self.move_path_for_lvalue(lvalue) {\n-            for ii in &move_data.init_path_map[mpi] {\n-                if flow_state.ever_inits.curr_state.contains(ii) {\n-                    let first_assign_span = self.move_data.inits[*ii].span;\n-                    self.report_illegal_reassignment(\n-                        context, (lvalue, span), first_assign_span);\n-                    break;\n+        if let Err(_) = self.is_mutable(lvalue, LocalMutationIsAllowed::Yes) {\n+            return;\n+        }\n+\n+        match self.move_path_closest_to(lvalue) {\n+            Ok(mpi) => {\n+                for ii in &move_data.init_path_map[mpi] {\n+                    if flow_state.ever_inits.curr_state.contains(ii) {\n+                        let first_assign_span = self.move_data.inits[*ii].span;\n+                        self.report_illegal_reassignment(\n+                            context, (lvalue, span), first_assign_span);\n+                        break;\n+                    }\n                 }\n-            }\n+            },\n+            Err(NoMovePathFound::ReachedStatic) => {\n+                let item_msg = match self.describe_lvalue(lvalue) {\n+                    Some(name) => format!(\"immutable static item `{}`\", name),\n+                    None => \"immutable static item\".to_owned()\n+                };\n+                self.tcx.sess.delay_span_bug(span,\n+                    &format!(\"cannot assign to {}, should have been caught by \\\n+                    `check_access_permissions()`\", item_msg));\n+            },\n         }\n     }\n \n@@ -1108,20 +1095,21 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     ProjectionElem::Deref => {\n                         let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n \n-                        // `Box<T>` owns its content, so mutable if its location is mutable\n-                        if base_ty.is_box() {\n-                            return self.is_mutable(&proj.base, LocalMutationIsAllowed::No);\n-                        }\n-\n-                        // Otherwise we check the kind of deref to decide\n+                        // Check the kind of deref to decide\n                         match base_ty.sty {\n                             ty::TyRef(_, tnm) => {\n                                 match tnm.mutbl {\n                                     // Shared borrowed data is never mutable\n                                     hir::MutImmutable => Err(lvalue),\n                                     // Mutably borrowed data is mutable, but only if we have a\n                                     // unique path to the `&mut`\n-                                    hir::MutMutable => self.is_unique(&proj.base),\n+                                    hir::MutMutable => {\n+                                        if self.is_upvar_field_projection(&proj.base).is_some() {\n+                                            self.is_mutable(&proj.base, is_local_mutation_allowed)\n+                                        } else {\n+                                            self.is_unique(&proj.base)\n+                                        }\n+                                    },\n                                 }\n                             },\n                             ty::TyRawPtr(tnm) => {\n@@ -1133,8 +1121,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     hir::MutMutable => Ok(()),\n                                 }\n                             },\n+                            // `Box<T>` owns its content, so mutable if its location is mutable\n+                            _ if base_ty.is_box() =>\n+                                self.is_mutable(&proj.base, LocalMutationIsAllowed::No),\n                             // Deref should only be for reference, pointers or boxes\n-                            _ => bug!(\"Deref of unexpected type: {:?}\", base_ty)\n+                            _ => bug!(\"Deref of unexpected type: {:?}\", base_ty),\n                         }\n                     },\n                     // All other projections are owned by their base path, so mutable if\n@@ -1143,8 +1134,20 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     ProjectionElem::Index(..) |\n                     ProjectionElem::ConstantIndex{..} |\n                     ProjectionElem::Subslice{..} |\n-                    ProjectionElem::Downcast(..) =>\n+                    ProjectionElem::Downcast(..) => {\n+                        let field_projection = self.is_upvar_field_projection(lvalue);\n+\n+                        if let Some(field) = field_projection {\n+                            let decl = &self.mir.upvar_decls[field.index()];\n+\n+                            return match decl.mutability {\n+                                Mutability::Mut => self.is_unique(&proj.base),\n+                                Mutability::Not => Err(lvalue),\n+                            };\n+                        }\n+\n                         self.is_mutable(&proj.base, LocalMutationIsAllowed::No)\n+                    }\n                 }\n             }\n         }"}, {"sha": "3ffcf2998c6def2e667271569c365086e7111dea", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e3ed21272d5f50c37c09f2a7f06c40f56b6ac298/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3ed21272d5f50c37c09f2a7f06c40f56b6ac298/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=e3ed21272d5f50c37c09f2a7f06c40f56b6ac298", "patch": "@@ -443,10 +443,20 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n             let mut decl = UpvarDecl {\n                 debug_name: keywords::Invalid.name(),\n                 by_ref,\n+                mutability: Mutability::Not,\n             };\n             if let Some(hir::map::NodeBinding(pat)) = tcx.hir.find(var_id) {\n                 if let hir::PatKind::Binding(_, _, ref ident, _) = pat.node {\n                     decl.debug_name = ident.node;\n+\n+                    let bm = *hir.tables.pat_binding_modes()\n+                                        .get(pat.hir_id)\n+                                        .expect(\"missing binding mode\");\n+                    if bm == ty::BindByValue(hir::MutMutable) {\n+                        decl.mutability = Mutability::Mut;\n+                    } else {\n+                        decl.mutability = Mutability::Not;\n+                    }\n                 }\n             }\n             decl\n@@ -571,7 +581,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n \n             self.local_decls.push(LocalDecl {\n-                mutability: Mutability::Not,\n+                mutability: Mutability::Mut,\n                 ty,\n                 source_info: SourceInfo {\n                     scope: ARGUMENT_VISIBILITY_SCOPE,"}, {"sha": "d51d92570fd67d4b0bca5ca1c0b186ad666285d4", "filename": "src/test/compile-fail/issue-46023.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e3ed21272d5f50c37c09f2a7f06c40f56b6ac298/src%2Ftest%2Fcompile-fail%2Fissue-46023.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3ed21272d5f50c37c09f2a7f06c40f56b6ac298/src%2Ftest%2Fcompile-fail%2Fissue-46023.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-46023.rs?ref=e3ed21272d5f50c37c09f2a7f06c40f56b6ac298", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck=mir\n+\n+fn main() {\n+    let x = 0;\n+\n+    (move || {\n+        x = 1;\n+        //[mir]~^ ERROR cannot assign to immutable item `x` [E0594]\n+        //[ast]~^^ ERROR cannot assign to captured outer variable in an `FnMut` closure [E0594]\n+    })()\n+}"}, {"sha": "9f34ad6726cb66d7551168770c0b710398772245", "filename": "src/test/run-pass/issue-16671.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3ed21272d5f50c37c09f2a7f06c40f56b6ac298/src%2Ftest%2Frun-pass%2Fissue-16671.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3ed21272d5f50c37c09f2a7f06c40f56b6ac298/src%2Ftest%2Frun-pass%2Fissue-16671.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16671.rs?ref=e3ed21272d5f50c37c09f2a7f06c40f56b6ac298", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//compile-flags: -Z borrowck=compare -Z emit-end-regions\n+\n #![deny(warnings)]\n \n fn foo<F: FnOnce()>(_f: F) { }"}]}