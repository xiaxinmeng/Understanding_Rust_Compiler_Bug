{"sha": "5530858a081e1890a7078506fa11f063ade3366b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1MzA4NThhMDgxZTE4OTBhNzA3ODUwNmZhMTFmMDYzYWRlMzM2NmI=", "commit": {"author": {"name": "The8472", "email": "git@infinite-source.de", "date": "2020-01-28T14:14:55Z"}, "committer": {"name": "The8472", "email": "git@infinite-source.de", "date": "2020-09-03T18:59:31Z"}, "message": "generalize in-place collect to types of same size and alignment", "tree": {"sha": "5e3cb20f4efff7d6b622184c676606239decede5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e3cb20f4efff7d6b622184c676606239decede5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5530858a081e1890a7078506fa11f063ade3366b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5530858a081e1890a7078506fa11f063ade3366b", "html_url": "https://github.com/rust-lang/rust/commit/5530858a081e1890a7078506fa11f063ade3366b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5530858a081e1890a7078506fa11f063ade3366b/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa34b39cd6c2fc05f29d8c20518ef45b5317b9b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa34b39cd6c2fc05f29d8c20518ef45b5317b9b3", "html_url": "https://github.com/rust-lang/rust/commit/fa34b39cd6c2fc05f29d8c20518ef45b5317b9b3"}], "stats": {"total": 57, "additions": 34, "deletions": 23}, "files": [{"sha": "40aa4d850f59ddc0798b156ae97f67a8e5c6a006", "filename": "library/alloc/src/collections/binary_heap.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5530858a081e1890a7078506fa11f063ade3366b/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5530858a081e1890a7078506fa11f063ade3366b/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs?ref=5530858a081e1890a7078506fa11f063ade3366b", "patch": "@@ -1186,8 +1186,10 @@ unsafe impl<T> SourceIter for IntoIter<T> {\n #[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n unsafe impl<I> InPlaceIterable for IntoIter<I> {}\n \n-impl<I> AsIntoIter<I> for IntoIter<I> {\n-    fn as_into_iter(&mut self) -> &mut vec::IntoIter<I> {\n+impl<I> AsIntoIter for IntoIter<I> {\n+    type Item = I;\n+\n+    fn as_into_iter(&mut self) -> &mut vec::IntoIter<Self::Item> {\n         &mut self.iter\n     }\n }"}, {"sha": "db0127624190616264c663d3b1aee3e667d3d959", "filename": "library/alloc/src/vec.rs", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5530858a081e1890a7078506fa11f063ade3366b/library%2Falloc%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5530858a081e1890a7078506fa11f063ade3366b/library%2Falloc%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec.rs?ref=5530858a081e1890a7078506fa11f063ade3366b", "patch": "@@ -2240,23 +2240,28 @@ fn write_in_place_with_drop<T>(\n     }\n }\n \n-// Further specialization potential once\n-// https://github.com/rust-lang/rust/issues/62645 has been solved:\n-// T can be split into IN and OUT which only need to have the same size and alignment\n impl<T, I> SpecFrom<T, I> for Vec<T>\n where\n-    I: Iterator<Item = T> + InPlaceIterable + SourceIter<Source: AsIntoIter<T>>,\n+    I: Iterator<Item = T> + InPlaceIterable + SourceIter<Source: AsIntoIter>,\n {\n     default fn from_iter(mut iterator: I) -> Self {\n-        // This specialization only makes sense if we're juggling real allocations.\n-        // Additionally some of the pointer arithmetic would panic on ZSTs.\n-        if mem::size_of::<T>() == 0 {\n+        // Additional requirements which cannot expressed via trait bounds. We rely on const eval\n+        // instead:\n+        // a) no ZSTs as there would be no allocation to reuse and pointer arithmetic would panic\n+        // b) size match as required by Alloc contract\n+        // c) alignments match as required by Alloc contract\n+        if mem::size_of::<T>() == 0\n+            || mem::size_of::<T>()\n+                != mem::size_of::<<<I as SourceIter>::Source as AsIntoIter>::Item>()\n+            || mem::align_of::<T>()\n+                != mem::align_of::<<<I as SourceIter>::Source as AsIntoIter>::Item>()\n+        {\n             return SpecFromNested::from_iter(iterator);\n         }\n \n-        let (src_buf, src_end, cap) = {\n-            let inner = unsafe { iterator.as_inner().as_into_iter() };\n-            (inner.buf.as_ptr(), inner.end, inner.cap)\n+        let (src_buf, dst_buf, dst_end, cap) = unsafe {\n+            let inner = iterator.as_inner().as_into_iter();\n+            (inner.buf.as_ptr(), inner.buf.as_ptr() as *mut T, inner.end as *const T, inner.cap)\n         };\n \n         // use try-fold\n@@ -2266,15 +2271,15 @@ where\n         let dst = if mem::needs_drop::<T>() {\n             // special-case drop handling since it forces us to lug that extra field around which\n             // can inhibit optimizations\n-            let sink = InPlaceDrop { inner: src_buf, dst: src_buf };\n+            let sink = InPlaceDrop { inner: dst_buf, dst: dst_buf };\n             let sink = iterator\n-                .try_fold::<_, _, Result<_, !>>(sink, write_in_place_with_drop(src_end))\n+                .try_fold::<_, _, Result<_, !>>(sink, write_in_place_with_drop(dst_end))\n                 .unwrap();\n             // iteration succeeded, don't drop head\n             let sink = mem::ManuallyDrop::new(sink);\n             sink.dst\n         } else {\n-            iterator.try_fold::<_, _, Result<_, !>>(src_buf, write_in_place(src_end)).unwrap()\n+            iterator.try_fold::<_, _, Result<_, !>>(dst_buf, write_in_place(dst_end)).unwrap()\n         };\n \n         let src = unsafe { iterator.as_inner().as_into_iter() };\n@@ -2289,8 +2294,8 @@ where\n         src.forget_in_place();\n \n         let vec = unsafe {\n-            let len = dst.offset_from(src_buf) as usize;\n-            Vec::from_raw_parts(src_buf, len, cap)\n+            let len = dst.offset_from(dst_buf) as usize;\n+            Vec::from_raw_parts(dst_buf, len, cap)\n         };\n \n         vec\n@@ -3010,12 +3015,15 @@ unsafe impl<T> SourceIter for IntoIter<T> {\n }\n \n // internal helper trait for in-place iteration specialization.\n-pub(crate) trait AsIntoIter<T> {\n-    fn as_into_iter(&mut self) -> &mut IntoIter<T>;\n+pub(crate) trait AsIntoIter {\n+    type Item;\n+    fn as_into_iter(&mut self) -> &mut IntoIter<Self::Item>;\n }\n \n-impl<T> AsIntoIter<T> for IntoIter<T> {\n-    fn as_into_iter(&mut self) -> &mut IntoIter<T> {\n+impl<T> AsIntoIter for IntoIter<T> {\n+    type Item = T;\n+\n+    fn as_into_iter(&mut self) -> &mut IntoIter<Self::Item> {\n         self\n     }\n }"}, {"sha": "3464b7511819250d4cb207455de4e3dd59d65882", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5530858a081e1890a7078506fa11f063ade3366b/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5530858a081e1890a7078506fa11f063ade3366b/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=5530858a081e1890a7078506fa11f063ade3366b", "patch": "@@ -820,11 +820,12 @@ fn test_from_iter_specialization_with_iterator_adapters() {\n         .zip(std::iter::repeat(1usize))\n         .map(|(a, b)| a + b)\n         .peekable()\n-        .skip(1);\n+        .skip(1)\n+        .map(|e| std::num::NonZeroUsize::new(e));\n     assert_in_place_trait(&iter);\n     let sink = iter.collect::<Vec<_>>();\n     let sinkptr = sink.as_ptr();\n-    assert_eq!(srcptr, sinkptr);\n+    assert_eq!(srcptr, sinkptr as *const usize);\n }\n \n #[test]"}]}