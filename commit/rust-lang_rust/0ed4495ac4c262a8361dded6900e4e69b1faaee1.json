{"sha": "0ed4495ac4c262a8361dded6900e4e69b1faaee1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlZDQ0OTVhYzRjMjYyYTgzNjFkZGVkNjkwMGU0ZTY5YjFmYWFlZTE=", "commit": {"author": {"name": "Seo Sanghyeon", "email": "sanxiyn@gmail.com", "date": "2013-05-07T17:09:19Z"}, "committer": {"name": "Seo Sanghyeon", "email": "sanxiyn@gmail.com", "date": "2013-05-07T17:09:19Z"}, "message": "Generate LLVM SIMD vector types", "tree": {"sha": "83745aff9825ef4c8e6fe7dd923fee02b86e5827", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83745aff9825ef4c8e6fe7dd923fee02b86e5827"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ed4495ac4c262a8361dded6900e4e69b1faaee1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ed4495ac4c262a8361dded6900e4e69b1faaee1", "html_url": "https://github.com/rust-lang/rust/commit/0ed4495ac4c262a8361dded6900e4e69b1faaee1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ed4495ac4c262a8361dded6900e4e69b1faaee1/comments", "author": {"login": "sanxiyn", "id": 45249, "node_id": "MDQ6VXNlcjQ1MjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/45249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sanxiyn", "html_url": "https://github.com/sanxiyn", "followers_url": "https://api.github.com/users/sanxiyn/followers", "following_url": "https://api.github.com/users/sanxiyn/following{/other_user}", "gists_url": "https://api.github.com/users/sanxiyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/sanxiyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sanxiyn/subscriptions", "organizations_url": "https://api.github.com/users/sanxiyn/orgs", "repos_url": "https://api.github.com/users/sanxiyn/repos", "events_url": "https://api.github.com/users/sanxiyn/events{/privacy}", "received_events_url": "https://api.github.com/users/sanxiyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sanxiyn", "id": 45249, "node_id": "MDQ6VXNlcjQ1MjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/45249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sanxiyn", "html_url": "https://github.com/sanxiyn", "followers_url": "https://api.github.com/users/sanxiyn/followers", "following_url": "https://api.github.com/users/sanxiyn/following{/other_user}", "gists_url": "https://api.github.com/users/sanxiyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/sanxiyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sanxiyn/subscriptions", "organizations_url": "https://api.github.com/users/sanxiyn/orgs", "repos_url": "https://api.github.com/users/sanxiyn/repos", "events_url": "https://api.github.com/users/sanxiyn/events{/privacy}", "received_events_url": "https://api.github.com/users/sanxiyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "784e8369caf0e04fb7fe5a5330f286aa195dfb82", "url": "https://api.github.com/repos/rust-lang/rust/commits/784e8369caf0e04fb7fe5a5330f286aa195dfb82", "html_url": "https://github.com/rust-lang/rust/commit/784e8369caf0e04fb7fe5a5330f286aa195dfb82"}], "stats": {"total": 70, "additions": 55, "deletions": 15}, "files": [{"sha": "b8e0b58f86634c00726ecc66d8c21e8c2fdaab13", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/0ed4495ac4c262a8361dded6900e4e69b1faaee1/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed4495ac4c262a8361dded6900e4e69b1faaee1/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=0ed4495ac4c262a8361dded6900e4e69b1faaee1", "patch": "@@ -155,9 +155,15 @@ pub fn sizing_type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n         }\n \n         ty::ty_struct(did, _) => {\n-            let repr = adt::represent_type(cx, t);\n-            let packed = ty::lookup_packed(cx.tcx, did);\n-            T_struct(adt::sizing_fields_of(cx, repr), packed)\n+            if ty::type_is_simd(cx.tcx, t) {\n+                let et = ty::simd_type(cx.tcx, t);\n+                let n = ty::simd_size(cx.tcx, t);\n+                T_vector(type_of(cx, et), n)\n+            } else {\n+                let repr = adt::represent_type(cx, t);\n+                let packed = ty::lookup_packed(cx.tcx, did);\n+                T_struct(adt::sizing_fields_of(cx, repr), packed)\n+            }\n         }\n \n         ty::ty_self(_) | ty::ty_infer(*) | ty::ty_param(*) | ty::ty_err(*) => {\n@@ -263,14 +269,19 @@ pub fn type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n       }\n       ty::ty_opaque_closure_ptr(_) => T_opaque_box_ptr(cx),\n       ty::ty_struct(did, ref substs) => {\n-        // Only create the named struct, but don't fill it in. We fill it\n-        // in *after* placing it into the type cache. This prevents\n-        // infinite recursion with recursive struct types.\n-\n-        common::T_named_struct(llvm_type_name(cx,\n-                                              a_struct,\n-                                              did,\n-                                              /*bad*/ copy substs.tps))\n+        if ty::type_is_simd(cx.tcx, t) {\n+          let et = ty::simd_type(cx.tcx, t);\n+          let n = ty::simd_size(cx.tcx, t);\n+          T_vector(type_of(cx, et), n)\n+        } else {\n+          // Only create the named struct, but don't fill it in. We fill it\n+          // in *after* placing it into the type cache. This prevents\n+          // infinite recursion with recursive struct types.\n+          T_named_struct(llvm_type_name(cx,\n+                                        a_struct,\n+                                        did,\n+                                        /*bad*/ copy substs.tps))\n+        }\n       }\n       ty::ty_self(*) => cx.tcx.sess.unimpl(~\"type_of: ty_self\"),\n       ty::ty_infer(*) => cx.tcx.sess.bug(~\"type_of with ty_infer\"),\n@@ -289,10 +300,12 @@ pub fn type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n       }\n \n       ty::ty_struct(did, _) => {\n-        let repr = adt::represent_type(cx, t);\n-        let packed = ty::lookup_packed(cx.tcx, did);\n-        common::set_struct_body(llty, adt::fields_of(cx, repr),\n-                                packed);\n+        if !ty::type_is_simd(cx.tcx, t) {\n+          let repr = adt::represent_type(cx, t);\n+          let packed = ty::lookup_packed(cx.tcx, did);\n+          common::set_struct_body(llty, adt::fields_of(cx, repr),\n+                                  packed);\n+        }\n       }\n       _ => ()\n     }"}, {"sha": "4d1d271698c42f779b49d8aeab5636772c2ce5f8", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0ed4495ac4c262a8361dded6900e4e69b1faaee1/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed4495ac4c262a8361dded6900e4e69b1faaee1/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=0ed4495ac4c262a8361dded6900e4e69b1faaee1", "patch": "@@ -1567,6 +1567,13 @@ pub fn type_is_sequence(ty: t) -> bool {\n     }\n }\n \n+pub fn type_is_simd(cx: ctxt, ty: t) -> bool {\n+    match get(ty).sty {\n+        ty_struct(did, _) => lookup_simd(cx, did),\n+        _ => false\n+    }\n+}\n+\n pub fn type_is_str(ty: t) -> bool {\n     match get(ty).sty {\n       ty_estr(_) => true,\n@@ -1583,6 +1590,26 @@ pub fn sequence_element_type(cx: ctxt, ty: t) -> t {\n     }\n }\n \n+pub fn simd_type(cx: ctxt, ty: t) -> t {\n+    match get(ty).sty {\n+        ty_struct(did, ref substs) => {\n+            let fields = lookup_struct_fields(cx, did);\n+            lookup_field_type(cx, did, fields[0].id, substs)\n+        }\n+        _ => fail!(~\"simd_type called on invalid type\")\n+    }\n+}\n+\n+pub fn simd_size(cx: ctxt, ty: t) -> uint {\n+    match get(ty).sty {\n+        ty_struct(did, _) => {\n+            let fields = lookup_struct_fields(cx, did);\n+            fields.len()\n+        }\n+        _ => fail!(~\"simd_size called on invalid type\")\n+    }\n+}\n+\n pub fn get_element_type(ty: t, i: uint) -> t {\n     match get(ty).sty {\n       ty_tup(ref ts) => return ts[i],"}]}