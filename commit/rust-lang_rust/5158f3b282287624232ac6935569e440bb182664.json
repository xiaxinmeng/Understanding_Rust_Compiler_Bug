{"sha": "5158f3b282287624232ac6935569e440bb182664", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxNThmM2IyODIyODc2MjQyMzJhYzY5MzU1NjllNDQwYmIxODI2NjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-06T13:21:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-06T13:21:25Z"}, "message": "Auto merge of #33138 - arielb1:sized-shortcut, r=nikomatsakis\n\nShort-cut `T: Sized` trait selection for ADTs\n\nBasically avoids all nested obligations when checking whether an ADT is sized - this speeds up typeck by ~15%\n\nThe refactoring fixed #32963, but I also want to make `Copy` not object-safe (will commit that soon).\n\nFixes #33201\n\nr? @nikomatsakis", "tree": {"sha": "8a0d041a345b5f548b3b1b7ebbfb9459abddf311", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a0d041a345b5f548b3b1b7ebbfb9459abddf311"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5158f3b282287624232ac6935569e440bb182664", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5158f3b282287624232ac6935569e440bb182664", "html_url": "https://github.com/rust-lang/rust/commit/5158f3b282287624232ac6935569e440bb182664", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5158f3b282287624232ac6935569e440bb182664/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a36c41912ba91435d75ab5702ed8bc30116565fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/a36c41912ba91435d75ab5702ed8bc30116565fe", "html_url": "https://github.com/rust-lang/rust/commit/a36c41912ba91435d75ab5702ed8bc30116565fe"}, {"sha": "238e4ee104179c5a6beb5bb25ffe28a3fd77bff5", "url": "https://api.github.com/repos/rust-lang/rust/commits/238e4ee104179c5a6beb5bb25ffe28a3fd77bff5", "html_url": "https://github.com/rust-lang/rust/commit/238e4ee104179c5a6beb5bb25ffe28a3fd77bff5"}], "stats": {"total": 1258, "additions": 845, "deletions": 413}, "files": [{"sha": "a881b539cedebf0ba5dbb4b2c6342f458c6c89ba", "filename": "src/libcore/num/bignum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Flibcore%2Fnum%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Flibcore%2Fnum%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fbignum.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -33,7 +33,7 @@ use mem;\n use intrinsics;\n \n /// Arithmetic operations required by bignums.\n-pub trait FullOps {\n+pub trait FullOps: Sized {\n     /// Returns `(carry', v')` such that `carry' * 2^W + v' = self + other + carry`,\n     /// where `W` is the number of bits in `Self`.\n     fn full_add(self, other: Self, carry: bool) -> (bool /*carry*/, Self);"}, {"sha": "85b4b4f59c49a1f9076b7bfdb3f56f38446aecee", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -88,6 +88,7 @@ pub enum DepNode<D: Clone + Debug> {\n     ImplOrTraitItems(D),\n     ItemSignature(D),\n     FieldTy(D),\n+    SizedConstraint(D),\n     TraitItemDefIds(D),\n     InherentImpls(D),\n     ImplItems(D),\n@@ -193,6 +194,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             ImplOrTraitItems(ref d) => op(d).map(ImplOrTraitItems),\n             ItemSignature(ref d) => op(d).map(ItemSignature),\n             FieldTy(ref d) => op(d).map(FieldTy),\n+            SizedConstraint(ref d) => op(d).map(SizedConstraint),\n             TraitItemDefIds(ref d) => op(d).map(TraitItemDefIds),\n             InherentImpls(ref d) => op(d).map(InherentImpls),\n             ImplItems(ref d) => op(d).map(ImplItems),"}, {"sha": "6da4c44fe9ad11c1dea4a1c95754b004ee59a936", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -814,6 +814,17 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         r\n     }\n \n+    // Execute `f` in a snapshot, and commit the bindings it creates\n+    pub fn in_snapshot<T, F>(&self, f: F) -> T where\n+        F: FnOnce(&CombinedSnapshot) -> T\n+    {\n+        debug!(\"in_snapshot()\");\n+        let snapshot = self.start_snapshot();\n+        let r = f(&snapshot);\n+        self.commit_from(snapshot);\n+        r\n+    }\n+\n     /// Execute `f` and commit only the region bindings if successful.\n     /// The function f must be very careful not to leak any non-region\n     /// variables that get created."}, {"sha": "6dd98425df3175cd8e5f4f38e6518ec098814c21", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -185,6 +185,18 @@ declare_lint! {\n     \"detects super or self keywords at the beginning of global path\"\n }\n \n+declare_lint! {\n+    pub UNSIZED_IN_TUPLE,\n+    Warn,\n+    \"unsized types in the interior of a tuple were erroneously allowed\"\n+}\n+\n+declare_lint! {\n+    pub OBJECT_UNSAFE_FRAGMENT,\n+    Warn,\n+    \"object-unsafe non-principal fragments in object types were erroneously allowed\"\n+}\n+\n /// Does nothing as a lint pass, but registers some `Lint`s\n /// which are used by other parts of the compiler.\n #[derive(Copy, Clone)]\n@@ -220,7 +232,9 @@ impl LintPass for HardwiredLints {\n             TRANSMUTE_FROM_FN_ITEM_TYPES,\n             OVERLAPPING_INHERENT_IMPLS,\n             RENAMED_AND_REMOVED_LINTS,\n-            SUPER_OR_SELF_IN_GLOBAL_PATH\n+            SUPER_OR_SELF_IN_GLOBAL_PATH,\n+            UNSIZED_IN_TUPLE,\n+            OBJECT_UNSAFE_FRAGMENT\n         )\n     }\n }"}, {"sha": "758fb7a81fd94537360865650899ad8359c6c15b", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -56,6 +56,7 @@ impl FreeRegionMap {\n             match *predicate {\n                 ty::Predicate::Projection(..) |\n                 ty::Predicate::Trait(..) |\n+                ty::Predicate::Rfc1592(..) |\n                 ty::Predicate::Equate(..) |\n                 ty::Predicate::WellFormed(..) |\n                 ty::Predicate::ObjectSafe(..) |"}, {"sha": "b89ce2ce3b2cf312528dbe7234fd2b07f28599da", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 116, "deletions": 40, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -36,37 +36,51 @@ use util::nodemap::{FnvHashMap, FnvHashSet};\n use std::cmp;\n use std::fmt;\n use syntax::attr::{AttributeMethods, AttrMetaMethods};\n+use syntax::ast;\n use syntax::codemap::Span;\n use syntax::errors::DiagnosticBuilder;\n \n #[derive(Debug, PartialEq, Eq, Hash)]\n pub struct TraitErrorKey<'tcx> {\n     span: Span,\n+    warning_node_id: Option<ast::NodeId>,\n     predicate: ty::Predicate<'tcx>\n }\n \n impl<'tcx> TraitErrorKey<'tcx> {\n     fn from_error<'a>(infcx: &InferCtxt<'a, 'tcx>,\n-                      e: &FulfillmentError<'tcx>) -> Self {\n+                      e: &FulfillmentError<'tcx>,\n+                      warning_node_id: Option<ast::NodeId>) -> Self {\n         let predicate =\n             infcx.resolve_type_vars_if_possible(&e.obligation.predicate);\n         TraitErrorKey {\n             span: e.obligation.cause.span,\n-            predicate: infcx.tcx.erase_regions(&predicate)\n+            predicate: infcx.tcx.erase_regions(&predicate),\n+            warning_node_id: warning_node_id\n         }\n     }\n }\n \n pub fn report_fulfillment_errors<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                            errors: &Vec<FulfillmentError<'tcx>>) {\n     for error in errors {\n-        report_fulfillment_error(infcx, error);\n+        report_fulfillment_error(infcx, error, None);\n+    }\n+}\n+\n+pub fn report_fulfillment_errors_as_warnings<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                                       errors: &Vec<FulfillmentError<'tcx>>,\n+                                                       node_id: ast::NodeId)\n+{\n+    for error in errors {\n+        report_fulfillment_error(infcx, error, Some(node_id));\n     }\n }\n \n fn report_fulfillment_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                      error: &FulfillmentError<'tcx>) {\n-    let error_key = TraitErrorKey::from_error(infcx, error);\n+                                      error: &FulfillmentError<'tcx>,\n+                                      warning_node_id: Option<ast::NodeId>) {\n+    let error_key = TraitErrorKey::from_error(infcx, error, warning_node_id);\n     debug!(\"report_fulfillment_errors({:?}) - key={:?}\",\n            error, error_key);\n     if !infcx.reported_trait_errors.borrow_mut().insert(error_key) {\n@@ -75,10 +89,10 @@ fn report_fulfillment_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     }\n     match error.code {\n         FulfillmentErrorCode::CodeSelectionError(ref e) => {\n-            report_selection_error(infcx, &error.obligation, e);\n+            report_selection_error(infcx, &error.obligation, e, warning_node_id);\n         }\n         FulfillmentErrorCode::CodeProjectionError(ref e) => {\n-            report_projection_error(infcx, &error.obligation, e);\n+            report_projection_error(infcx, &error.obligation, e, warning_node_id);\n         }\n         FulfillmentErrorCode::CodeAmbiguity => {\n             maybe_report_ambiguity(infcx, &error.obligation);\n@@ -88,18 +102,29 @@ fn report_fulfillment_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n \n pub fn report_projection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                          obligation: &PredicateObligation<'tcx>,\n-                                         error: &MismatchedProjectionTypes<'tcx>)\n+                                         error: &MismatchedProjectionTypes<'tcx>,\n+                                         warning_node_id: Option<ast::NodeId>)\n {\n     let predicate =\n         infcx.resolve_type_vars_if_possible(&obligation.predicate);\n \n     if !predicate.references_error() {\n-        let mut err = struct_span_err!(infcx.tcx.sess, obligation.cause.span, E0271,\n-            \"type mismatch resolving `{}`: {}\",\n-            predicate,\n-            error.err);\n-        note_obligation_cause(infcx, &mut err, obligation);\n-        err.emit();\n+        if let Some(warning_node_id) = warning_node_id {\n+            infcx.tcx.sess.add_lint(\n+                ::lint::builtin::UNSIZED_IN_TUPLE,\n+                warning_node_id,\n+                obligation.cause.span,\n+                format!(\"type mismatch resolving `{}`: {}\",\n+                        predicate,\n+                        error.err));\n+        } else {\n+            let mut err = struct_span_err!(infcx.tcx.sess, obligation.cause.span, E0271,\n+                                           \"type mismatch resolving `{}`: {}\",\n+                                           predicate,\n+                                           error.err);\n+            note_obligation_cause(infcx, &mut err, obligation);\n+            err.emit();\n+        }\n     }\n }\n \n@@ -383,7 +408,8 @@ pub fn recursive_type_with_infinite_size_error<'tcx>(tcx: &TyCtxt<'tcx>,\n \n pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                         obligation: &PredicateObligation<'tcx>,\n-                                        error: &SelectionError<'tcx>)\n+                                        error: &SelectionError<'tcx>,\n+                                        warning_node_id: Option<ast::NodeId>)\n {\n     match *error {\n         SelectionError::Unimplemented => {\n@@ -401,6 +427,17 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n \n                         if !infcx.tcx.sess.has_errors() || !trait_predicate.references_error() {\n                             let trait_ref = trait_predicate.to_poly_trait_ref();\n+\n+                            if let Some(warning_node_id) = warning_node_id {\n+                                infcx.tcx.sess.add_lint(\n+                                    ::lint::builtin::UNSIZED_IN_TUPLE,\n+                                    warning_node_id,\n+                                    obligation.cause.span,\n+                                    format!(\"the trait bound `{}` is not satisfied\",\n+                                            trait_ref.to_predicate()));\n+                                return;\n+                            }\n+\n                             let mut err = struct_span_err!(\n                                 infcx.tcx.sess, obligation.cause.span, E0277,\n                                 \"the trait bound `{}` is not satisfied\",\n@@ -480,12 +517,15 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                     ty::Predicate::ObjectSafe(trait_def_id) => {\n                         let violations = object_safety_violations(\n                             infcx.tcx, trait_def_id);\n-                        let mut err = report_object_safety_error(infcx.tcx,\n-                                                                 obligation.cause.span,\n-                                                                 trait_def_id,\n-                                                                 violations);\n-                        note_obligation_cause(infcx, &mut err, obligation);\n-                        err.emit();\n+                        let err = report_object_safety_error(infcx.tcx,\n+                                                             obligation.cause.span,\n+                                                             trait_def_id,\n+                                                             warning_node_id,\n+                                                             violations);\n+                        if let Some(mut err) = err {\n+                            note_obligation_cause(infcx, &mut err, obligation);\n+                            err.emit();\n+                        }\n                     }\n \n                     ty::Predicate::ClosureKind(closure_def_id, kind) => {\n@@ -514,6 +554,13 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                             \"WF predicate not satisfied for {:?}\",\n                             ty);\n                     }\n+\n+                    ty::Predicate::Rfc1592(ref data) => {\n+                        span_bug!(\n+                            obligation.cause.span,\n+                            \"RFC1592 predicate not satisfied for {:?}\",\n+                            data);\n+                    }\n                 }\n             }\n         }\n@@ -537,58 +584,84 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n \n         TraitNotObjectSafe(did) => {\n             let violations = object_safety_violations(infcx.tcx, did);\n-            let mut err = report_object_safety_error(infcx.tcx, obligation.cause.span, did,\n-                                                     violations);\n-            note_obligation_cause(infcx, &mut err, obligation);\n-            err.emit();\n+            let err = report_object_safety_error(infcx.tcx, obligation.cause.span, did,\n+                                                 warning_node_id,\n+                                                 violations);\n+            if let Some(mut err) = err {\n+                note_obligation_cause(infcx, &mut err, obligation);\n+                err.emit();\n+            }\n         }\n     }\n }\n \n pub fn report_object_safety_error<'tcx>(tcx: &TyCtxt<'tcx>,\n                                         span: Span,\n                                         trait_def_id: DefId,\n+                                        warning_node_id: Option<ast::NodeId>,\n                                         violations: Vec<ObjectSafetyViolation>)\n-                                        -> DiagnosticBuilder<'tcx>\n+                                        -> Option<DiagnosticBuilder<'tcx>>\n {\n-    let mut err = struct_span_err!(\n-        tcx.sess, span, E0038,\n-        \"the trait `{}` cannot be made into an object\",\n-        tcx.item_path_str(trait_def_id));\n+    let mut err = match warning_node_id {\n+        Some(_) => None,\n+        None => {\n+            Some(struct_span_err!(\n+                tcx.sess, span, E0038,\n+                \"the trait `{}` cannot be made into an object\",\n+                tcx.item_path_str(trait_def_id)))\n+        }\n+    };\n \n     let mut reported_violations = FnvHashSet();\n     for violation in violations {\n         if !reported_violations.insert(violation.clone()) {\n             continue;\n         }\n-        match violation {\n+        let buf;\n+        let note = match violation {\n             ObjectSafetyViolation::SizedSelf => {\n-                err.note(\"the trait cannot require that `Self : Sized`\");\n+                \"the trait cannot require that `Self : Sized`\"\n             }\n \n             ObjectSafetyViolation::SupertraitSelf => {\n-                err.note(\"the trait cannot use `Self` as a type parameter \\\n-                          in the supertrait listing\");\n+                \"the trait cannot use `Self` as a type parameter \\\n+                     in the supertrait listing\"\n             }\n \n             ObjectSafetyViolation::Method(method,\n                                           MethodViolationCode::StaticMethod) => {\n-                err.note(&format!(\"method `{}` has no receiver\",\n-                         method.name));\n+                buf = format!(\"method `{}` has no receiver\",\n+                              method.name);\n+                &buf\n             }\n \n             ObjectSafetyViolation::Method(method,\n                                           MethodViolationCode::ReferencesSelf) => {\n-                err.note(&format!(\"method `{}` references the `Self` type \\\n+                buf = format!(\"method `{}` references the `Self` type \\\n                                    in its arguments or return type\",\n-                                  method.name));\n+                              method.name);\n+                &buf\n             }\n \n             ObjectSafetyViolation::Method(method,\n                                           MethodViolationCode::Generic) => {\n-                err.note(&format!(\"method `{}` has generic type parameters\",\n-                                  method.name));\n+                buf = format!(\"method `{}` has generic type parameters\",\n+                              method.name);\n+                &buf\n             }\n+        };\n+        match (warning_node_id, &mut err) {\n+            (Some(node_id), &mut None) => {\n+                tcx.sess.add_lint(\n+                    ::lint::builtin::OBJECT_UNSAFE_FRAGMENT,\n+                    node_id,\n+                    span,\n+                    note.to_string());\n+            }\n+            (None, &mut Some(ref mut err)) => {\n+                err.note(note);\n+            }\n+            _ => unreachable!()\n         }\n     }\n     err\n@@ -764,6 +837,9 @@ fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n         ObligationCauseCode::SliceOrArrayElem => {\n             err.note(\"slice and array elements must have `Sized` type\");\n         }\n+        ObligationCauseCode::TupleElem => {\n+            err.note(\"tuple elements must have `Sized` type\");\n+        }\n         ObligationCauseCode::ProjectionWf(data) => {\n             err.note(&format!(\"required so that the projection `{}` is well-formed\",\n                               data));"}, {"sha": "a184e951b834cf725f389bfccc715591349af926", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 47, "deletions": 7, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -13,6 +13,7 @@ use infer::{InferCtxt, InferOk};\n use ty::{self, Ty, TyCtxt, TypeFoldable, ToPolyTraitRef};\n use rustc_data_structures::obligation_forest::{Backtrace, ObligationForest, Error};\n use std::iter;\n+use std::mem;\n use syntax::ast;\n use util::common::ErrorReported;\n use util::nodemap::{FnvHashMap, FnvHashSet, NodeMap};\n@@ -70,6 +71,9 @@ pub struct FulfillmentContext<'tcx> {\n     predicates: ObligationForest<PendingPredicateObligation<'tcx>,\n                                  LocalFulfilledPredicates<'tcx>>,\n \n+    // A list of new obligations due to RFC1592.\n+    rfc1592_obligations: Vec<PredicateObligation<'tcx>>,\n+\n     // A set of constraints that regionck must validate. Each\n     // constraint has the form `T:'a`, meaning \"some type `T` must\n     // outlive the lifetime 'a\". These constraints derive from\n@@ -116,6 +120,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             duplicate_set: LocalFulfilledPredicates::new(),\n             predicates: ObligationForest::new(),\n+            rfc1592_obligations: Vec::new(),\n             region_obligations: NodeMap(),\n         }\n     }\n@@ -197,6 +202,13 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         self.predicates.push_tree(obligation, LocalFulfilledPredicates::new());\n     }\n \n+    pub fn register_rfc1592_obligation<'a>(&mut self,\n+                                           _infcx: &InferCtxt<'a,'tcx>,\n+                                           obligation: PredicateObligation<'tcx>)\n+    {\n+        self.rfc1592_obligations.push(obligation);\n+    }\n+\n     pub fn region_obligations(&self,\n                               body_id: ast::NodeId)\n                               -> &[RegionObligation<'tcx>]\n@@ -207,11 +219,26 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         }\n     }\n \n+    pub fn select_rfc1592_obligations<'a>(&mut self,\n+                                      infcx: &InferCtxt<'a,'tcx>)\n+                                      -> Result<(),Vec<FulfillmentError<'tcx>>>\n+    {\n+        while !self.rfc1592_obligations.is_empty() {\n+            for obligation in mem::replace(&mut self.rfc1592_obligations, Vec::new()) {\n+                self.register_predicate_obligation(infcx, obligation);\n+            }\n+\n+            self.select_all_or_error(infcx)?;\n+        }\n+\n+        Ok(())\n+    }\n     pub fn select_all_or_error<'a>(&mut self,\n                                    infcx: &InferCtxt<'a,'tcx>)\n                                    -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         self.select_where_possible(infcx)?;\n+\n         let errors: Vec<_> =\n             self.predicates.to_errors(CodeAmbiguity)\n                            .into_iter()\n@@ -279,12 +306,14 @@ impl<'tcx> FulfillmentContext<'tcx> {\n             // Process pending obligations.\n             let outcome = {\n                 let region_obligations = &mut self.region_obligations;\n+                let rfc1592_obligations = &mut self.rfc1592_obligations;\n                 self.predicates.process_obligations(\n                     |obligation, tree, backtrace| process_predicate(selcx,\n-                                                                     tree,\n-                                                                     obligation,\n-                                                                     backtrace,\n-                                                                     region_obligations))\n+                                                                    tree,\n+                                                                    obligation,\n+                                                                    backtrace,\n+                                                                    region_obligations,\n+                                                                    rfc1592_obligations))\n             };\n \n             debug!(\"select: outcome={:?}\", outcome);\n@@ -321,11 +350,13 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                               tree_cache: &mut LocalFulfilledPredicates<'tcx>,\n                               pending_obligation: &mut PendingPredicateObligation<'tcx>,\n                               backtrace: Backtrace<PendingPredicateObligation<'tcx>>,\n-                              region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n+                              region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>,\n+                              rfc1592_obligations: &mut Vec<PredicateObligation<'tcx>>)\n                               -> Result<Option<Vec<PendingPredicateObligation<'tcx>>>,\n                                         FulfillmentErrorCode<'tcx>>\n {\n-    match process_predicate1(selcx, pending_obligation, region_obligations) {\n+    match process_predicate1(selcx, pending_obligation, region_obligations,\n+                             rfc1592_obligations) {\n         Ok(Some(v)) => process_child_obligations(selcx,\n                                                  tree_cache,\n                                                  &pending_obligation.obligation,\n@@ -507,7 +538,8 @@ fn trait_ref_type_vars<'a, 'tcx>(selcx: &mut SelectionContext<'a, 'tcx>,\n /// - `Err` if the predicate does not hold\n fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                                pending_obligation: &mut PendingPredicateObligation<'tcx>,\n-                               region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n+                               region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>,\n+                               rfc1592_obligations: &mut Vec<PredicateObligation<'tcx>>)\n                                -> Result<Option<Vec<PredicateObligation<'tcx>>>,\n                                          FulfillmentErrorCode<'tcx>>\n {\n@@ -677,6 +709,14 @@ fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                 s => Ok(s)\n             }\n         }\n+\n+        ty::Predicate::Rfc1592(ref inner) => {\n+            rfc1592_obligations.push(PredicateObligation {\n+                predicate: ty::Predicate::clone(inner),\n+                ..obligation.clone()\n+            });\n+            Ok(Some(vec![]))\n+        }\n     }\n }\n "}, {"sha": "7da95b6646ae32b87796edb64b4a01f62038a6b9", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -28,6 +28,7 @@ use syntax::codemap::{Span, DUMMY_SP};\n pub use self::error_reporting::TraitErrorKey;\n pub use self::error_reporting::recursive_type_with_infinite_size_error;\n pub use self::error_reporting::report_fulfillment_errors;\n+pub use self::error_reporting::report_fulfillment_errors_as_warnings;\n pub use self::error_reporting::report_overflow_error;\n pub use self::error_reporting::report_overflow_error_cycle;\n pub use self::error_reporting::report_selection_error;\n@@ -106,9 +107,12 @@ pub enum ObligationCauseCode<'tcx> {\n     /// Not well classified or should be obvious from span.\n     MiscObligation,\n \n-    /// This is the trait reference from the given projection\n+    /// A slice or array is WF only if `T: Sized`\n     SliceOrArrayElem,\n \n+    /// A tuple is WF only if its middle elements are Sized\n+    TupleElem,\n+\n     /// This is the trait reference from the given projection\n     ProjectionWf(ty::ProjectionTy<'tcx>),\n "}, {"sha": "59db68b1c3c292300fb6764ca09bdad57033f397", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -166,6 +166,7 @@ pub fn supertraits_reference_self<'tcx>(tcx: &TyCtxt<'tcx>,\n                 ty::Predicate::TypeOutlives(..) |\n                 ty::Predicate::RegionOutlives(..) |\n                 ty::Predicate::ClosureKind(..) |\n+                ty::Predicate::Rfc1592(..) |\n                 ty::Predicate::Equate(..) => {\n                     false\n                 }\n@@ -204,6 +205,7 @@ fn generics_require_sized_self<'tcx>(tcx: &TyCtxt<'tcx>,\n                 }\n                 ty::Predicate::Projection(..) |\n                 ty::Predicate::Trait(..) |\n+                ty::Predicate::Rfc1592(..) |\n                 ty::Predicate::Equate(..) |\n                 ty::Predicate::RegionOutlives(..) |\n                 ty::Predicate::WellFormed(..) |"}, {"sha": "138ca7a0f350a4a857f085a1f72c186229250846", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 185, "deletions": 296, "changes": 481, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -13,7 +13,6 @@\n pub use self::MethodMatchResult::*;\n pub use self::MethodMatchedData::*;\n use self::SelectionCandidate::*;\n-use self::BuiltinBoundConditions::*;\n use self::EvaluationResult::*;\n \n use super::coherence;\n@@ -50,7 +49,6 @@ use std::fmt;\n use std::rc::Rc;\n use syntax::abi::Abi;\n use hir;\n-use util::common::ErrorReported;\n use util::nodemap::FnvHashMap;\n \n pub struct SelectionContext<'cx, 'tcx:'cx> {\n@@ -188,7 +186,7 @@ pub enum MethodMatchedData {\n /// parameter environment.\n #[derive(PartialEq,Eq,Debug,Clone)]\n enum SelectionCandidate<'tcx> {\n-    BuiltinCandidate(ty::BuiltinBound),\n+    BuiltinCandidate { has_nested: bool },\n     ParamCandidate(ty::PolyTraitRef<'tcx>),\n     ImplCandidate(DefId),\n     DefaultImplCandidate(DefId),\n@@ -232,10 +230,18 @@ struct EvaluatedCandidate<'tcx> {\n     evaluation: EvaluationResult,\n }\n \n-enum BuiltinBoundConditions<'tcx> {\n-    If(ty::Binder<Vec<Ty<'tcx>>>),\n-    ParameterBuiltin,\n-    AmbiguousBuiltin\n+/// When does the builtin impl for `T: Trait` apply?\n+enum BuiltinImplConditions<'tcx> {\n+    /// The impl is conditional on T1,T2,.. : Trait\n+    Where(ty::Binder<Vec<Ty<'tcx>>>),\n+    /// There is no built-in impl. There may be some other\n+    /// candidate (a where-clause or user-defined impl).\n+    None,\n+    /// There is *no* impl for this, builtin or not. Ignore\n+    /// all where-clauses.\n+    Never,\n+    /// It is unknown whether there is an impl.\n+    Ambiguous\n }\n \n #[derive(Copy, Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]\n@@ -412,6 +418,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         match obligation.predicate {\n+            ty::Predicate::Rfc1592(..) => EvaluatedToOk,\n+\n             ty::Predicate::Trait(ref t) => {\n                 assert!(!t.has_escaping_regions());\n                 let obligation = obligation.with(t.clone());\n@@ -993,15 +1001,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.assemble_candidates_from_impls(obligation, &mut candidates)?;\n \n                 // For other types, we'll use the builtin rules.\n-                self.assemble_builtin_bound_candidates(ty::BoundCopy,\n-                                                       obligation,\n-                                                       &mut candidates)?;\n+                let copy_conditions = self.copy_conditions(obligation);\n+                self.assemble_builtin_bound_candidates(copy_conditions, &mut candidates)?;\n             }\n-            Some(bound @ ty::BoundSized) => {\n+            Some(ty::BoundSized) => {\n                 // Sized is never implementable by end-users, it is\n                 // always automatically computed.\n-                self.assemble_builtin_bound_candidates(bound,\n-                                                       obligation,\n+                let sized_conditions = self.sized_conditions(obligation);\n+                self.assemble_builtin_bound_candidates(sized_conditions,\n                                                        &mut candidates)?;\n             }\n \n@@ -1394,7 +1401,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return;\n         }\n \n-        self.infcx.commit_if_ok(|snapshot| {\n+        self.infcx.in_snapshot(|snapshot| {\n             let (self_ty, _) =\n                 self.infcx().skolemize_late_bound_regions(&obligation.self_ty(), snapshot);\n             let poly_trait_ref = match self_ty.sty {\n@@ -1405,7 +1412,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                 debug!(\"assemble_candidates_from_object_ty: matched builtin bound, \\\n                                         pushing candidate\");\n                                 candidates.vec.push(BuiltinObjectCandidate);\n-                                return Ok(());\n+                                return;\n                             }\n                         }\n                         _ => {}\n@@ -1416,10 +1423,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ty::TyInfer(ty::TyVar(_)) => {\n                     debug!(\"assemble_candidates_from_object_ty: ambiguous\");\n                     candidates.ambiguous = true; // could wind up being an object type\n-                    return Ok(());\n+                    return;\n                 }\n                 _ => {\n-                    return Ok(());\n+                    return;\n                 }\n             };\n \n@@ -1447,9 +1454,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             } else if upcast_trait_refs == 1 {\n                 candidates.vec.push(ObjectCandidate);\n             }\n-\n-            Ok::<(),()>(())\n-        }).unwrap();\n+        })\n     }\n \n     /// Search for unsizing that might apply to `obligation`.\n@@ -1570,7 +1575,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 BuiltinObjectCandidate |\n                 BuiltinUnsizeCandidate |\n                 DefaultImplObjectCandidate(..) |\n-                BuiltinCandidate(..) => {\n+                BuiltinCandidate { .. } => {\n                     // We have a where-clause so don't go around looking\n                     // for impls.\n                     true\n@@ -1608,229 +1613,131 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // those will hopefully change to library-defined traits in the\n     // future.\n \n+    // HACK: if this returns an error, selection exits without considering\n+    // other impls.\n     fn assemble_builtin_bound_candidates<'o>(&mut self,\n-                                             bound: ty::BuiltinBound,\n-                                             obligation: &TraitObligation<'tcx>,\n+                                             conditions: BuiltinImplConditions<'tcx>,\n                                              candidates: &mut SelectionCandidateSet<'tcx>)\n                                              -> Result<(),SelectionError<'tcx>>\n     {\n-        match self.builtin_bound(bound, obligation) {\n-            Ok(If(..)) => {\n-                debug!(\"builtin_bound: bound={:?}\",\n-                       bound);\n-                candidates.vec.push(BuiltinCandidate(bound));\n+        match conditions {\n+            BuiltinImplConditions::Where(nested) => {\n+                debug!(\"builtin_bound: nested={:?}\", nested);\n+                candidates.vec.push(BuiltinCandidate {\n+                    has_nested: nested.skip_binder().len() > 0\n+                });\n                 Ok(())\n             }\n-            Ok(ParameterBuiltin) => { Ok(()) }\n-            Ok(AmbiguousBuiltin) => {\n+            BuiltinImplConditions::None => { Ok(()) }\n+            BuiltinImplConditions::Ambiguous => {\n                 debug!(\"assemble_builtin_bound_candidates: ambiguous builtin\");\n                 Ok(candidates.ambiguous = true)\n             }\n-            Err(e) => { Err(e) }\n+            BuiltinImplConditions::Never => { Err(Unimplemented) }\n         }\n     }\n \n-    fn builtin_bound(&mut self,\n-                     bound: ty::BuiltinBound,\n-                     obligation: &TraitObligation<'tcx>)\n-                     -> Result<BuiltinBoundConditions<'tcx>,SelectionError<'tcx>>\n+    fn sized_conditions(&mut self, obligation: &TraitObligation<'tcx>)\n+                     -> BuiltinImplConditions<'tcx>\n     {\n-        // Note: these tests operate on types that may contain bound\n-        // regions. To be proper, we ought to skolemize here, but we\n-        // forego the skolemization and defer it until the\n-        // confirmation step.\n+        use self::BuiltinImplConditions::{Ambiguous, None, Never, Where};\n \n-        let self_ty = self.infcx.shallow_resolve(obligation.predicate.0.self_ty());\n-        return match self_ty.sty {\n-            ty::TyInfer(ty::IntVar(_)) |\n-            ty::TyInfer(ty::FloatVar(_)) |\n-            ty::TyUint(_) |\n-            ty::TyInt(_) |\n-            ty::TyBool |\n-            ty::TyFloat(_) |\n-            ty::TyFnDef(..) |\n-            ty::TyFnPtr(_) |\n-            ty::TyChar => {\n+        // NOTE: binder moved to (*)\n+        let self_ty = self.infcx.shallow_resolve(\n+            obligation.predicate.skip_binder().self_ty());\n+\n+        match self_ty.sty {\n+            ty::TyInfer(ty::IntVar(_)) | ty::TyInfer(ty::FloatVar(_)) |\n+            ty::TyUint(_) | ty::TyInt(_) | ty::TyBool | ty::TyFloat(_) |\n+            ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyRawPtr(..) |\n+            ty::TyChar | ty::TyBox(_) | ty::TyRef(..) |\n+            ty::TyArray(..) | ty::TyClosure(..) |\n+            ty::TyError => {\n                 // safe for everything\n-                ok_if(Vec::new())\n+                Where(ty::Binder(Vec::new()))\n             }\n \n-            ty::TyBox(_) => {  // Box<T>\n-                match bound {\n-                    ty::BoundCopy => Err(Unimplemented),\n-\n-                    ty::BoundSized => ok_if(Vec::new()),\n+            ty::TyStr | ty::TySlice(_) | ty::TyTrait(..) => Never,\n \n-                    ty::BoundSync | ty::BoundSend => {\n-                        bug!(\"Send/Sync shouldn't occur in builtin_bounds()\");\n-                    }\n-                }\n+            ty::TyTuple(ref tys) => {\n+                // FIXME(#33242) we only need to constrain the last field\n+                Where(ty::Binder(tys.clone()))\n             }\n \n-            ty::TyRawPtr(..) => {     // *const T, *mut T\n-                match bound {\n-                    ty::BoundCopy | ty::BoundSized => ok_if(Vec::new()),\n-\n-                    ty::BoundSync | ty::BoundSend => {\n-                        bug!(\"Send/Sync shouldn't occur in builtin_bounds()\");\n-                    }\n-                }\n+            ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n+                let sized_crit = def.sized_constraint(self.tcx());\n+                // (*) binder moved here\n+                Where(ty::Binder(match sized_crit.sty {\n+                    ty::TyTuple(ref tys) => tys.to_owned().subst(self.tcx(), substs),\n+                    ty::TyBool => vec![],\n+                    _ => vec![sized_crit.subst(self.tcx(), substs)]\n+                }))\n             }\n \n-            ty::TyTrait(ref data) => {\n-                match bound {\n-                    ty::BoundSized => Err(Unimplemented),\n-                    ty::BoundCopy => {\n-                        if data.bounds.builtin_bounds.contains(&bound) {\n-                            ok_if(Vec::new())\n-                        } else {\n-                            // Recursively check all supertraits to find out if any further\n-                            // bounds are required and thus we must fulfill.\n-                            let principal =\n-                                data.principal_trait_ref_with_self_ty(self.tcx(),\n-                                                                      self.tcx().types.err);\n-                            let copy_def_id = obligation.predicate.def_id();\n-                            for tr in util::supertraits(self.tcx(), principal) {\n-                                if tr.def_id() == copy_def_id {\n-                                    return ok_if(Vec::new())\n-                                }\n-                            }\n+            ty::TyProjection(_) | ty::TyParam(_) => None,\n+            ty::TyInfer(ty::TyVar(_)) => Ambiguous,\n \n-                            Err(Unimplemented)\n-                        }\n-                    }\n-                    ty::BoundSync | ty::BoundSend => {\n-                        bug!(\"Send/Sync shouldn't occur in builtin_bounds()\");\n-                    }\n-                }\n+            ty::TyInfer(ty::FreshTy(_))\n+            | ty::TyInfer(ty::FreshIntTy(_))\n+            | ty::TyInfer(ty::FreshFloatTy(_)) => {\n+                bug!(\"asked to assemble builtin bounds of unexpected type: {:?}\",\n+                     self_ty);\n             }\n+        }\n+    }\n \n-            ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl }) => {\n-                // &mut T or &T\n-                match bound {\n-                    ty::BoundCopy => {\n-                        match mutbl {\n-                            // &mut T is affine and hence never `Copy`\n-                            hir::MutMutable => Err(Unimplemented),\n-\n-                            // &T is always copyable\n-                            hir::MutImmutable => ok_if(Vec::new()),\n-                        }\n-                    }\n-\n-                    ty::BoundSized => ok_if(Vec::new()),\n+    fn copy_conditions(&mut self, obligation: &TraitObligation<'tcx>)\n+                     -> BuiltinImplConditions<'tcx>\n+    {\n+        // NOTE: binder moved to (*)\n+        let self_ty = self.infcx.shallow_resolve(\n+            obligation.predicate.skip_binder().self_ty());\n \n-                    ty::BoundSync | ty::BoundSend => {\n-                        bug!(\"Send/Sync shouldn't occur in builtin_bounds()\");\n-                    }\n-                }\n-            }\n+        use self::BuiltinImplConditions::{Ambiguous, None, Never, Where};\n \n-            ty::TyArray(element_ty, _) => {\n-                // [T; n]\n-                match bound {\n-                    ty::BoundCopy => ok_if(vec![element_ty]),\n-                    ty::BoundSized => ok_if(Vec::new()),\n-                    ty::BoundSync | ty::BoundSend => {\n-                        bug!(\"Send/Sync shouldn't occur in builtin_bounds()\");\n-                    }\n-                }\n+        match self_ty.sty {\n+            ty::TyInfer(ty::IntVar(_)) | ty::TyInfer(ty::FloatVar(_)) |\n+            ty::TyUint(_) | ty::TyInt(_) | ty::TyBool | ty::TyFloat(_) |\n+            ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyChar |\n+            ty::TyRawPtr(..) | ty::TyError |\n+            ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n+                Where(ty::Binder(Vec::new()))\n             }\n \n-            ty::TyStr | ty::TySlice(_) => {\n-                match bound {\n-                    ty::BoundSync | ty::BoundSend => {\n-                        bug!(\"Send/Sync shouldn't occur in builtin_bounds()\");\n-                    }\n-\n-                    ty::BoundCopy | ty::BoundSized => Err(Unimplemented),\n-                }\n+            ty::TyBox(_) | ty::TyTrait(..) | ty::TyStr | ty::TySlice(..) |\n+            ty::TyClosure(..) |\n+            ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n+                Never\n             }\n \n-            // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n-            ty::TyTuple(ref tys) => ok_if(tys.clone()),\n-\n-            ty::TyClosure(_, ref substs) => {\n-                // FIXME -- This case is tricky. In the case of by-ref\n-                // closures particularly, we need the results of\n-                // inference to decide how to reflect the type of each\n-                // upvar (the upvar may have type `T`, but the runtime\n-                // type could be `&mut`, `&`, or just `T`). For now,\n-                // though, we'll do this unsoundly and assume that all\n-                // captures are by value. Really what we ought to do\n-                // is reserve judgement and then intertwine this\n-                // analysis with closure inference.\n-\n-                // Unboxed closures shouldn't be\n-                // implicitly copyable\n-                if bound == ty::BoundCopy {\n-                    return Ok(ParameterBuiltin);\n-                }\n-\n-                // Upvars are always local variables or references to\n-                // local variables, and local variables cannot be\n-                // unsized, so the closure struct as a whole must be\n-                // Sized.\n-                if bound == ty::BoundSized {\n-                    return ok_if(Vec::new());\n-                }\n-\n-                ok_if(substs.upvar_tys.clone())\n+            ty::TyArray(element_ty, _) => {\n+                // (*) binder moved here\n+                Where(ty::Binder(vec![element_ty]))\n             }\n \n-            ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n-                let types: Vec<Ty> = def.all_fields().map(|f| {\n-                    f.ty(self.tcx(), substs)\n-                }).collect();\n-                nominal(bound, types)\n+            ty::TyTuple(ref tys) => {\n+                // (*) binder moved here\n+                Where(ty::Binder(tys.clone()))\n             }\n \n-            ty::TyProjection(_) | ty::TyParam(_) => {\n-                // Note: A type parameter is only considered to meet a\n-                // particular bound if there is a where clause telling\n-                // us that it does, and that case is handled by\n-                // `assemble_candidates_from_caller_bounds()`.\n-                Ok(ParameterBuiltin)\n+            ty::TyStruct(..) | ty::TyEnum(..) | ty::TyProjection(..) | ty::TyParam(..) => {\n+                // Fallback to whatever user-defined impls exist in this case.\n+                None\n             }\n \n             ty::TyInfer(ty::TyVar(_)) => {\n                 // Unbound type variable. Might or might not have\n                 // applicable impls and so forth, depending on what\n                 // those type variables wind up being bound to.\n-                debug!(\"assemble_builtin_bound_candidates: ambiguous builtin\");\n-                Ok(AmbiguousBuiltin)\n+                Ambiguous\n             }\n \n-            ty::TyError => ok_if(Vec::new()),\n-\n             ty::TyInfer(ty::FreshTy(_))\n             | ty::TyInfer(ty::FreshIntTy(_))\n             | ty::TyInfer(ty::FreshFloatTy(_)) => {\n                 bug!(\"asked to assemble builtin bounds of unexpected type: {:?}\",\n                      self_ty);\n             }\n-        };\n-\n-        fn ok_if<'tcx>(v: Vec<Ty<'tcx>>)\n-                       -> Result<BuiltinBoundConditions<'tcx>, SelectionError<'tcx>> {\n-            Ok(If(ty::Binder(v)))\n-        }\n-\n-        fn nominal<'cx, 'tcx>(bound: ty::BuiltinBound,\n-                              types: Vec<Ty<'tcx>>)\n-                              -> Result<BuiltinBoundConditions<'tcx>, SelectionError<'tcx>>\n-        {\n-            // First check for markers and other nonsense.\n-            match bound {\n-                // Fallback to whatever user-defined impls exist in this case.\n-                ty::BoundCopy => Ok(ParameterBuiltin),\n-\n-                // Sized if all the component types are sized.\n-                ty::BoundSized => ok_if(types),\n-\n-                // Shouldn't be coming through here.\n-                ty::BoundSend | ty::BoundSync => bug!(),\n-            }\n         }\n     }\n \n@@ -1916,20 +1823,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn collect_predicates_for_types(&mut self,\n-                                    obligation: &TraitObligation<'tcx>,\n+                                    cause: ObligationCause<'tcx>,\n+                                    recursion_depth: usize,\n                                     trait_def_id: DefId,\n                                     types: ty::Binder<Vec<Ty<'tcx>>>)\n                                     -> Vec<PredicateObligation<'tcx>>\n     {\n-        let derived_cause = match self.tcx().lang_items.to_builtin_kind(trait_def_id) {\n-            Some(_) => {\n-                self.derived_cause(obligation, BuiltinDerivedObligation)\n-            },\n-            None => {\n-                self.derived_cause(obligation, ImplDerivedObligation)\n-            }\n-        };\n-\n         // Because the types were potentially derived from\n         // higher-ranked obligations they may reference late-bound\n         // regions. For example, `for<'a> Foo<&'a int> : Copy` would\n@@ -1944,40 +1843,28 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // 2. Produce something like `&'0 int : Copy`\n         // 3. Re-bind the regions back to `for<'a> &'a int : Copy`\n \n-        // Move the binder into the individual types\n-        let bound_types: Vec<ty::Binder<Ty<'tcx>>> =\n-            types.skip_binder()\n-                 .iter()\n-                 .map(|&nested_ty| ty::Binder(nested_ty))\n-                 .collect();\n+        types.skip_binder().into_iter().flat_map(|ty| { // binder moved -\\\n+            let ty: ty::Binder<Ty<'tcx>> = ty::Binder(ty); // <----------/\n \n-        // For each type, produce a vector of resulting obligations\n-        let obligations: Result<Vec<Vec<_>>, _> = bound_types.iter().map(|nested_ty| {\n-            self.infcx.commit_if_ok(|snapshot| {\n+            self.infcx.in_snapshot(|snapshot| {\n                 let (skol_ty, skol_map) =\n-                    self.infcx().skolemize_late_bound_regions(nested_ty, snapshot);\n+                    self.infcx().skolemize_late_bound_regions(&ty, snapshot);\n                 let Normalized { value: normalized_ty, mut obligations } =\n                     project::normalize_with_depth(self,\n-                                                  obligation.cause.clone(),\n-                                                  obligation.recursion_depth + 1,\n+                                                  cause.clone(),\n+                                                  recursion_depth,\n                                                   &skol_ty);\n                 let skol_obligation =\n                     util::predicate_for_trait_def(self.tcx(),\n-                                                  derived_cause.clone(),\n+                                                  cause.clone(),\n                                                   trait_def_id,\n-                                                  obligation.recursion_depth + 1,\n+                                                  recursion_depth,\n                                                   normalized_ty,\n                                                   vec![]);\n                 obligations.push(skol_obligation);\n-                Ok(self.infcx().plug_leaks(skol_map, snapshot, &obligations))\n+                self.infcx().plug_leaks(skol_map, snapshot, &obligations)\n             })\n-        }).collect();\n-\n-        // Flatten those vectors (couldn't do it above due `collect`)\n-        match obligations {\n-            Ok(obligations) => obligations.into_iter().flat_map(|o| o).collect(),\n-            Err(ErrorReported) => Vec::new(),\n-        }\n+        }).collect()\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -1997,9 +1884,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                candidate);\n \n         match candidate {\n-            BuiltinCandidate(builtin_bound) => {\n+            BuiltinCandidate { has_nested } => {\n                 Ok(VtableBuiltin(\n-                    self.confirm_builtin_candidate(obligation, builtin_bound)?))\n+                    self.confirm_builtin_candidate(obligation, has_nested)))\n             }\n \n             ParamCandidate(param) => {\n@@ -2018,9 +1905,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             ImplCandidate(impl_def_id) => {\n-                let vtable_impl =\n-                    self.confirm_impl_candidate(obligation, impl_def_id)?;\n-                Ok(VtableImpl(vtable_impl))\n+                Ok(VtableImpl(self.confirm_impl_candidate(obligation, impl_def_id)))\n             }\n \n             ClosureCandidate(closure_def_id, substs, kind) => {\n@@ -2064,14 +1949,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn confirm_projection_candidate(&mut self,\n                                     obligation: &TraitObligation<'tcx>)\n     {\n-        let _: Result<(),()> =\n-            self.infcx.commit_if_ok(|snapshot| {\n-                let result =\n-                    self.match_projection_obligation_against_bounds_from_trait(obligation,\n-                                                                               snapshot);\n-                assert!(result);\n-                Ok(())\n-            });\n+        self.infcx.in_snapshot(|snapshot| {\n+            let result =\n+                self.match_projection_obligation_against_bounds_from_trait(obligation,\n+                                                                           snapshot);\n+            assert!(result);\n+        })\n     }\n \n     fn confirm_param_candidate(&mut self,\n@@ -2099,45 +1982,40 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn confirm_builtin_candidate(&mut self,\n                                  obligation: &TraitObligation<'tcx>,\n-                                 bound: ty::BuiltinBound)\n-                                 -> Result<VtableBuiltinData<PredicateObligation<'tcx>>,\n-                                           SelectionError<'tcx>>\n+                                 has_nested: bool)\n+                                 -> VtableBuiltinData<PredicateObligation<'tcx>>\n     {\n-        debug!(\"confirm_builtin_candidate({:?})\",\n-               obligation);\n-\n-        match self.builtin_bound(bound, obligation)? {\n-            If(nested) => Ok(self.vtable_builtin_data(obligation, bound, nested)),\n-            AmbiguousBuiltin | ParameterBuiltin => {\n-                span_bug!(\n-                    obligation.cause.span,\n-                    \"builtin bound for {:?} was ambig\",\n-                    obligation);\n-            }\n-        }\n-    }\n-\n-    fn vtable_builtin_data(&mut self,\n-                           obligation: &TraitObligation<'tcx>,\n-                           bound: ty::BuiltinBound,\n-                           nested: ty::Binder<Vec<Ty<'tcx>>>)\n-                           -> VtableBuiltinData<PredicateObligation<'tcx>>\n-    {\n-        debug!(\"vtable_builtin_data(obligation={:?}, bound={:?}, nested={:?})\",\n-               obligation, bound, nested);\n+        debug!(\"confirm_builtin_candidate({:?}, {:?})\",\n+               obligation, has_nested);\n+\n+        let obligations = if has_nested {\n+            let trait_def = obligation.predicate.def_id();\n+            let conditions = match trait_def {\n+                _ if Some(trait_def) == self.tcx().lang_items.sized_trait() => {\n+                    self.sized_conditions(obligation)\n+                }\n+                _ if Some(trait_def) == self.tcx().lang_items.copy_trait() => {\n+                    self.copy_conditions(obligation)\n+                }\n+                _ => bug!(\"unexpected builtin trait {:?}\", trait_def)\n+            };\n+            let nested = match conditions {\n+                BuiltinImplConditions::Where(nested) => nested,\n+                _ => bug!(\"obligation {:?} had matched a builtin impl but now doesn't\",\n+                          obligation)\n+            };\n \n-        let trait_def = match self.tcx().lang_items.from_builtin_kind(bound) {\n-            Ok(def_id) => def_id,\n-            Err(_) => {\n-                bug!(\"builtin trait definition not found\");\n-            }\n+            let cause = self.derived_cause(obligation, BuiltinDerivedObligation);\n+            self.collect_predicates_for_types(cause,\n+                                              obligation.recursion_depth+1,\n+                                              trait_def,\n+                                              nested)\n+        } else {\n+            vec![]\n         };\n \n-        let obligations = self.collect_predicates_for_types(obligation, trait_def, nested);\n-\n-        debug!(\"vtable_builtin_data: obligations={:?}\",\n+        debug!(\"confirm_builtin_candidate: obligations={:?}\",\n                obligations);\n-\n         VtableBuiltinData { nested: obligations }\n     }\n \n@@ -2205,28 +2083,31 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                            nested: ty::Binder<Vec<Ty<'tcx>>>)\n                            -> VtableDefaultImplData<PredicateObligation<'tcx>>\n     {\n-        debug!(\"vtable_default_impl_data: nested={:?}\", nested);\n+        debug!(\"vtable_default_impl: nested={:?}\", nested);\n \n-        let mut obligations = self.collect_predicates_for_types(obligation,\n-                                                                trait_def_id,\n-                                                                nested);\n+        let cause = self.derived_cause(obligation, BuiltinDerivedObligation);\n+        let mut obligations = self.collect_predicates_for_types(\n+            cause,\n+            obligation.recursion_depth+1,\n+            trait_def_id,\n+            nested);\n \n-        let trait_obligations: Result<Vec<_>,()> = self.infcx.commit_if_ok(|snapshot| {\n+        let trait_obligations = self.infcx.in_snapshot(|snapshot| {\n             let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n             let (trait_ref, skol_map) =\n                 self.infcx().skolemize_late_bound_regions(&poly_trait_ref, snapshot);\n-            Ok(self.impl_or_trait_obligations(obligation.cause.clone(),\n-                                              obligation.recursion_depth + 1,\n-                                              trait_def_id,\n-                                              &trait_ref.substs,\n-                                              skol_map,\n-                                              snapshot))\n+            let cause = self.derived_cause(obligation, ImplDerivedObligation);\n+            self.impl_or_trait_obligations(cause,\n+                                           obligation.recursion_depth + 1,\n+                                           trait_def_id,\n+                                           &trait_ref.substs,\n+                                           skol_map,\n+                                           snapshot)\n         });\n \n-        // no Errors in that code above\n-        obligations.append(&mut trait_obligations.unwrap());\n+        obligations.extend(trait_obligations);\n \n-        debug!(\"vtable_default_impl_data: obligations={:?}\", obligations);\n+        debug!(\"vtable_default_impl: obligations={:?}\", obligations);\n \n         VtableDefaultImplData {\n             trait_def_id: trait_def_id,\n@@ -2237,22 +2118,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn confirm_impl_candidate(&mut self,\n                               obligation: &TraitObligation<'tcx>,\n                               impl_def_id: DefId)\n-                              -> Result<VtableImplData<'tcx, PredicateObligation<'tcx>>,\n-                                        SelectionError<'tcx>>\n+                              -> VtableImplData<'tcx, PredicateObligation<'tcx>>\n     {\n         debug!(\"confirm_impl_candidate({:?},{:?})\",\n                obligation,\n                impl_def_id);\n \n         // First, create the substitutions by matching the impl again,\n         // this time not in a probe.\n-        self.infcx.commit_if_ok(|snapshot| {\n+        self.infcx.in_snapshot(|snapshot| {\n             let (substs, skol_map) =\n                 self.rematch_impl(impl_def_id, obligation,\n                                   snapshot);\n             debug!(\"confirm_impl_candidate substs={:?}\", substs);\n-            Ok(self.vtable_impl(impl_def_id, substs, obligation.cause.clone(),\n-                                obligation.recursion_depth + 1, skol_map, snapshot))\n+            let cause = self.derived_cause(obligation, ImplDerivedObligation);\n+            self.vtable_impl(impl_def_id, substs, cause,\n+                             obligation.recursion_depth + 1,\n+                             skol_map, snapshot)\n         })\n     }\n \n@@ -2507,9 +2389,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             // T -> Trait.\n             (_, &ty::TyTrait(ref data)) => {\n-                let object_did = data.principal_def_id();\n-                if !object_safety::is_object_safe(tcx, object_did) {\n-                    return Err(TraitNotObjectSafe(object_did));\n+                let mut object_dids = Some(data.principal_def_id()).into_iter();\n+                // FIXME(#33243)\n+//                    data.bounds.builtin_bounds.iter().flat_map(|bound| {\n+//                        tcx.lang_items.from_builtin_kind(bound).ok()\n+//                    })\n+//                    .chain(Some(data.principal_def_id()));\n+                if let Some(did) = object_dids.find(|did| {\n+                    !object_safety::is_object_safe(tcx, *did)\n+                }) {\n+                    return Err(TraitNotObjectSafe(did))\n                 }\n \n                 let cause = ObligationCause::new(obligation.cause.span,"}, {"sha": "d82f9d7549d907e1f3a151825c5d660c1d819096", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 37, "deletions": 26, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -18,6 +18,39 @@ use util::nodemap::FnvHashSet;\n \n use super::{Obligation, ObligationCause, PredicateObligation, SelectionContext, Normalized};\n \n+fn anonymize_predicate<'tcx>(tcx: &TyCtxt<'tcx>, pred: &ty::Predicate<'tcx>)\n+                             -> ty::Predicate<'tcx> {\n+    match *pred {\n+        ty::Predicate::Trait(ref data) =>\n+            ty::Predicate::Trait(tcx.anonymize_late_bound_regions(data)),\n+\n+        ty::Predicate::Rfc1592(ref data) =>\n+            ty::Predicate::Rfc1592(Box::new(anonymize_predicate(tcx, data))),\n+\n+        ty::Predicate::Equate(ref data) =>\n+            ty::Predicate::Equate(tcx.anonymize_late_bound_regions(data)),\n+\n+        ty::Predicate::RegionOutlives(ref data) =>\n+            ty::Predicate::RegionOutlives(tcx.anonymize_late_bound_regions(data)),\n+\n+        ty::Predicate::TypeOutlives(ref data) =>\n+            ty::Predicate::TypeOutlives(tcx.anonymize_late_bound_regions(data)),\n+\n+        ty::Predicate::Projection(ref data) =>\n+            ty::Predicate::Projection(tcx.anonymize_late_bound_regions(data)),\n+\n+        ty::Predicate::WellFormed(data) =>\n+            ty::Predicate::WellFormed(data),\n+\n+        ty::Predicate::ObjectSafe(data) =>\n+            ty::Predicate::ObjectSafe(data),\n+\n+        ty::Predicate::ClosureKind(closure_def_id, kind) =>\n+            ty::Predicate::ClosureKind(closure_def_id, kind)\n+    }\n+}\n+\n+\n struct PredicateSet<'a,'tcx:'a> {\n     tcx: &'a TyCtxt<'tcx>,\n     set: FnvHashSet<ty::Predicate<'tcx>>,\n@@ -39,32 +72,7 @@ impl<'a,'tcx> PredicateSet<'a,'tcx> {\n         //\n         // to be considered equivalent. So normalize all late-bound\n         // regions before we throw things into the underlying set.\n-        let normalized_pred = match *pred {\n-            ty::Predicate::Trait(ref data) =>\n-                ty::Predicate::Trait(self.tcx.anonymize_late_bound_regions(data)),\n-\n-            ty::Predicate::Equate(ref data) =>\n-                ty::Predicate::Equate(self.tcx.anonymize_late_bound_regions(data)),\n-\n-            ty::Predicate::RegionOutlives(ref data) =>\n-                ty::Predicate::RegionOutlives(self.tcx.anonymize_late_bound_regions(data)),\n-\n-            ty::Predicate::TypeOutlives(ref data) =>\n-                ty::Predicate::TypeOutlives(self.tcx.anonymize_late_bound_regions(data)),\n-\n-            ty::Predicate::Projection(ref data) =>\n-                ty::Predicate::Projection(self.tcx.anonymize_late_bound_regions(data)),\n-\n-            ty::Predicate::WellFormed(data) =>\n-                ty::Predicate::WellFormed(data),\n-\n-            ty::Predicate::ObjectSafe(data) =>\n-                ty::Predicate::ObjectSafe(data),\n-\n-            ty::Predicate::ClosureKind(closure_def_id, kind) =>\n-                ty::Predicate::ClosureKind(closure_def_id, kind)\n-        };\n-        self.set.insert(normalized_pred)\n+        self.set.insert(anonymize_predicate(self.tcx, pred))\n     }\n }\n \n@@ -143,6 +151,9 @@ impl<'cx, 'tcx> Elaborator<'cx, 'tcx> {\n \n                 self.stack.extend(predicates);\n             }\n+            ty::Predicate::Rfc1592(..) => {\n+                // Nothing to elaborate.\n+            }\n             ty::Predicate::WellFormed(..) => {\n                 // Currently, we do not elaborate WF predicates,\n                 // although we easily could."}, {"sha": "8fcbc0629523d9efa62a8b63415704d4e2b9a924", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -329,7 +329,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         where F : FnMut(ty::BoundRegion) -> ty::Region,\n               T : TypeFoldable<'tcx>,\n     {\n-        debug!(\"replace_late_bound_regions({:?})\", value);\n         let mut replacer = RegionReplacer::new(self, &mut f);\n         let result = value.skip_binder().fold_with(&mut replacer);\n         (result, replacer.map)\n@@ -444,8 +443,6 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionReplacer<'a, 'tcx>\n     fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n         match r {\n             ty::ReLateBound(debruijn, br) if debruijn.depth == self.current_depth => {\n-                debug!(\"RegionReplacer.fold_region({:?}) folding region (current_depth={})\",\n-                       r, self.current_depth);\n                 let fld_r = &mut self.fld_r;\n                 let region = *self.map.entry(br).or_insert_with(|| fld_r(br));\n                 if let ty::ReLateBound(debruijn1, br) = region {"}, {"sha": "3e3dae3b3e9855441ba2f40ccd03cba066c7ee6b", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 191, "deletions": 1, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -804,6 +804,9 @@ pub enum Predicate<'tcx> {\n     /// would be the parameters in the `TypeSpace`.\n     Trait(PolyTraitPredicate<'tcx>),\n \n+    /// A predicate created by RFC1592\n+    Rfc1592(Box<Predicate<'tcx>>),\n+\n     /// where `T1 == T2`.\n     Equate(PolyEquatePredicate<'tcx>),\n \n@@ -904,6 +907,8 @@ impl<'tcx> Predicate<'tcx> {\n         match *self {\n             Predicate::Trait(ty::Binder(ref data)) =>\n                 Predicate::Trait(ty::Binder(data.subst(tcx, substs))),\n+            Predicate::Rfc1592(ref pi) =>\n+                Predicate::Rfc1592(Box::new(pi.subst_supertrait(tcx, trait_ref))),\n             Predicate::Equate(ty::Binder(ref data)) =>\n                 Predicate::Equate(ty::Binder(data.subst(tcx, substs))),\n             Predicate::RegionOutlives(ty::Binder(ref data)) =>\n@@ -1083,6 +1088,9 @@ impl<'tcx> Predicate<'tcx> {\n             ty::Predicate::Trait(ref data) => {\n                 data.0.trait_ref.substs.types.as_slice().to_vec()\n             }\n+            ty::Predicate::Rfc1592(ref data) => {\n+                return data.walk_tys()\n+            }\n             ty::Predicate::Equate(ty::Binder(ref data)) => {\n                 vec![data.0, data.1]\n             }\n@@ -1123,6 +1131,7 @@ impl<'tcx> Predicate<'tcx> {\n             Predicate::Trait(ref t) => {\n                 Some(t.to_poly_trait_ref())\n             }\n+            Predicate::Rfc1592(..) |\n             Predicate::Projection(..) |\n             Predicate::Equate(..) |\n             Predicate::RegionOutlives(..) |\n@@ -1498,6 +1507,7 @@ pub struct AdtDefData<'tcx, 'container: 'tcx> {\n     pub variants: Vec<VariantDefData<'tcx, 'container>>,\n     destructor: Cell<Option<DefId>>,\n     flags: Cell<AdtFlags>,\n+    sized_constraint: ivar::TyIVar<'tcx, 'container>,\n }\n \n impl<'tcx, 'container> PartialEq for AdtDefData<'tcx, 'container> {\n@@ -1575,7 +1585,8 @@ impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n             did: did,\n             variants: variants,\n             flags: Cell::new(flags),\n-            destructor: Cell::new(None)\n+            destructor: Cell::new(None),\n+            sized_constraint: ivar::TyIVar::new(),\n         }\n     }\n \n@@ -1716,6 +1727,185 @@ impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n             None => NoDtor,\n         }\n     }\n+\n+    /// Returns a simpler type such that `Self: Sized` if and only\n+    /// if that type is Sized, or `TyErr` if this type is recursive.\n+    ///\n+    /// HACK: instead of returning a list of types, this function can\n+    /// return a tuple. In that case, the result is Sized only if\n+    /// all elements of the tuple are Sized.\n+    ///\n+    /// This is generally the `struct_tail` if this is a struct, or a\n+    /// tuple of them if this is an enum.\n+    ///\n+    /// Oddly enough, checking that the sized-constraint is Sized is\n+    /// actually more expressive than checking all members:\n+    /// the Sized trait is inductive, so an associated type that references\n+    /// Self would prevent its containing ADT from being Sized.\n+    ///\n+    /// Due to normalization being eager, this applies even if\n+    /// the associated type is behind a pointer, e.g. issue #31299.\n+    pub fn sized_constraint(&self, tcx: &ty::TyCtxt<'tcx>) -> Ty<'tcx> {\n+        let dep_node = DepNode::SizedConstraint(self.did);\n+        match self.sized_constraint.get(dep_node) {\n+            None => {\n+                let this = tcx.lookup_adt_def_master(self.did);\n+                this.calculate_sized_constraint_inner(tcx, &mut Vec::new());\n+                self.sized_constraint(tcx)\n+            }\n+            Some(ty) => ty\n+        }\n+    }\n+}\n+\n+impl<'tcx> AdtDefData<'tcx, 'tcx> {\n+    /// Calculates the Sized-constraint.\n+    ///\n+    /// As the Sized-constraint of enums can be a *set* of types,\n+    /// the Sized-constraint may need to be a set also. Because introducing\n+    /// a new type of IVar is currently a complex affair, the Sized-constraint\n+    /// may be a tuple.\n+    ///\n+    /// In fact, there are only a few options for the constraint:\n+    ///     - `bool`, if the type is always Sized\n+    ///     - an obviously-unsized type\n+    ///     - a type parameter or projection whose Sizedness can't be known\n+    ///     - a tuple of type parameters or projections, if there are multiple\n+    ///       such.\n+    ///     - a TyError, if a type contained itself. The representability\n+    ///       check should catch this case.\n+    fn calculate_sized_constraint_inner(&'tcx self, tcx: &ty::TyCtxt<'tcx>,\n+                                        stack: &mut Vec<AdtDefMaster<'tcx>>)\n+    {\n+\n+        let dep_node = DepNode::SizedConstraint(self.did);\n+\n+        if self.sized_constraint.get(dep_node).is_some() {\n+            return;\n+        }\n+\n+        if stack.contains(&self) {\n+            debug!(\"calculate_sized_constraint: {:?} is recursive\", self);\n+            // This should be reported as an error by `check_representable`.\n+            //\n+            // Consider the type as Sized in the meanwhile to avoid\n+            // further errors.\n+            self.sized_constraint.fulfill(dep_node, tcx.types.err);\n+            return;\n+        }\n+\n+        stack.push(self);\n+\n+        let tys : Vec<_> =\n+            self.variants.iter().flat_map(|v| {\n+                v.fields.last()\n+            }).flat_map(|f| {\n+                self.sized_constraint_for_ty(tcx, stack, f.unsubst_ty())\n+            }).collect();\n+\n+        let self_ = stack.pop().unwrap();\n+        assert_eq!(self_, self);\n+\n+        let ty = match tys.len() {\n+            _ if tys.references_error() => tcx.types.err,\n+            0 => tcx.types.bool,\n+            1 => tys[0],\n+            _ => tcx.mk_tup(tys)\n+        };\n+\n+        match self.sized_constraint.get(dep_node) {\n+            Some(old_ty) => {\n+                debug!(\"calculate_sized_constraint: {:?} recurred\", self);\n+                assert_eq!(old_ty, tcx.types.err)\n+            }\n+            None => {\n+                debug!(\"calculate_sized_constraint: {:?} => {:?}\", self, ty);\n+                self.sized_constraint.fulfill(dep_node, ty)\n+            }\n+        }\n+    }\n+\n+    fn sized_constraint_for_ty(\n+        &'tcx self,\n+        tcx: &ty::TyCtxt<'tcx>,\n+        stack: &mut Vec<AdtDefMaster<'tcx>>,\n+        ty: Ty<'tcx>\n+    ) -> Vec<Ty<'tcx>> {\n+        let result = match ty.sty {\n+            TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n+            TyBox(..) | TyRawPtr(..) | TyRef(..) | TyFnDef(..) | TyFnPtr(_) |\n+            TyArray(..) | TyClosure(..) => {\n+                vec![]\n+            }\n+\n+            TyStr | TyTrait(..) | TySlice(_) | TyError => {\n+                // these are never sized - return the target type\n+                vec![ty]\n+            }\n+\n+            TyTuple(ref tys) => {\n+                // FIXME(#33242) we only need to constrain the last field\n+                tys.iter().flat_map(|ty| {\n+                    self.sized_constraint_for_ty(tcx, stack, ty)\n+                }).collect()\n+            }\n+\n+            TyEnum(adt, substs) | TyStruct(adt, substs) => {\n+                // recursive case\n+                let adt = tcx.lookup_adt_def_master(adt.did);\n+                adt.calculate_sized_constraint_inner(tcx, stack);\n+                let adt_ty =\n+                    adt.sized_constraint\n+                    .unwrap(DepNode::SizedConstraint(adt.did))\n+                    .subst(tcx, substs);\n+                debug!(\"sized_constraint_for_ty({:?}) intermediate = {:?}\",\n+                       ty, adt_ty);\n+                if let ty::TyTuple(ref tys) = adt_ty.sty {\n+                    tys.iter().flat_map(|ty| {\n+                        self.sized_constraint_for_ty(tcx, stack, ty)\n+                    }).collect()\n+                } else {\n+                    self.sized_constraint_for_ty(tcx, stack, adt_ty)\n+                }\n+            }\n+\n+            TyProjection(..) => {\n+                // must calculate explicitly.\n+                // FIXME: consider special-casing always-Sized projections\n+                vec![ty]\n+            }\n+\n+            TyParam(..) => {\n+                // perf hack: if there is a `T: Sized` bound, then\n+                // we know that `T` is Sized and do not need to check\n+                // it on the impl.\n+\n+                let sized_trait = match tcx.lang_items.sized_trait() {\n+                    Some(x) => x,\n+                    _ => return vec![ty]\n+                };\n+                let sized_predicate = Binder(TraitRef {\n+                    def_id: sized_trait,\n+                    substs: tcx.mk_substs(Substs::new_trait(\n+                        vec![], vec![], ty\n+                    ))\n+                }).to_predicate();\n+                let predicates = tcx.lookup_predicates(self.did).predicates;\n+                if predicates.into_iter().any(|p| p == sized_predicate) {\n+                    vec![]\n+                } else {\n+                    vec![ty]\n+                }\n+            }\n+\n+            TyInfer(..) => {\n+                bug!(\"unexpected type `{:?}` in sized_constraint_for_ty\",\n+                     ty)\n+            }\n+        };\n+        debug!(\"sized_constraint_for_ty({:?}) = {:?}\", ty, result);\n+        result\n+    }\n }\n \n impl<'tcx, 'container> VariantDefData<'tcx, 'container> {"}, {"sha": "ac3dfa82bd6d235b441bc0aa96cfc7e9cc532831", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -634,6 +634,8 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n         match *self {\n             ty::Predicate::Trait(ref a) =>\n                 ty::Predicate::Trait(a.fold_with(folder)),\n+            ty::Predicate::Rfc1592(ref a) =>\n+                ty::Predicate::Rfc1592(a.fold_with(folder)),\n             ty::Predicate::Equate(ref binder) =>\n                 ty::Predicate::Equate(binder.fold_with(folder)),\n             ty::Predicate::RegionOutlives(ref binder) =>\n@@ -654,6 +656,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         match *self {\n             ty::Predicate::Trait(ref a) => a.visit_with(visitor),\n+            ty::Predicate::Rfc1592(ref a) => a.visit_with(visitor),\n             ty::Predicate::Equate(ref binder) => binder.visit_with(visitor),\n             ty::Predicate::RegionOutlives(ref binder) => binder.visit_with(visitor),\n             ty::Predicate::TypeOutlives(ref binder) => binder.visit_with(visitor),"}, {"sha": "b6bd8f5f55fba6dc5bc2b3693cbe90df65aec337", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -299,6 +299,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 match predicate {\n                     ty::Predicate::Projection(..) |\n                     ty::Predicate::Trait(..) |\n+                    ty::Predicate::Rfc1592(..) |\n                     ty::Predicate::Equate(..) |\n                     ty::Predicate::WellFormed(..) |\n                     ty::Predicate::ObjectSafe(..) |"}, {"sha": "609252f948ab3ff9c9a8525a8415a8497d626241", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 54, "deletions": 16, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -94,6 +94,9 @@ pub fn predicate_obligations<'a,'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n         }\n         ty::Predicate::ClosureKind(..) => {\n         }\n+        ty::Predicate::Rfc1592(ref data) => {\n+            bug!(\"RFC1592 predicate `{:?}` in predicate_obligations\", data);\n+        }\n     }\n \n     wf.normalize()\n@@ -155,6 +158,7 @@ pub fn implied_bounds<'a,'tcx>(\n                 assert!(!obligation.has_escaping_regions());\n                 match obligation.predicate {\n                     ty::Predicate::Trait(..) |\n+                    ty::Predicate::Rfc1592(..) |\n                     ty::Predicate::Equate(..) |\n                     ty::Predicate::Projection(..) |\n                     ty::Predicate::ClosureKind(..) |\n@@ -280,11 +284,35 @@ impl<'a,'tcx> WfPredicates<'a,'tcx> {\n         }\n     }\n \n+    fn require_sized(&mut self, subty: Ty<'tcx>, cause: traits::ObligationCauseCode<'tcx>,\n+                     rfc1592: bool) {\n+        if !subty.has_escaping_regions() {\n+            let cause = self.cause(cause);\n+            match traits::trait_ref_for_builtin_bound(self.infcx.tcx,\n+                                                      ty::BoundSized,\n+                                                      subty) {\n+                Ok(trait_ref) => {\n+                    let predicate = trait_ref.to_predicate();\n+                    let predicate = if rfc1592 {\n+                        ty::Predicate::Rfc1592(box predicate)\n+                    } else {\n+                        predicate\n+                    };\n+                    self.out.push(\n+                        traits::Obligation::new(cause,\n+                                                predicate));\n+                }\n+                Err(ErrorReported) => { }\n+            }\n+        }\n+    }\n+\n     /// Push new obligations into `out`. Returns true if it was able\n     /// to generate all the predicates needed to validate that `ty0`\n     /// is WF. Returns false if `ty0` is an unresolved type variable,\n     /// in which case we are not able to simplify at all.\n     fn compute(&mut self, ty0: Ty<'tcx>) -> bool {\n+        let tcx = self.infcx.tcx;\n         let mut subtys = ty0.walk();\n         while let Some(ty) = subtys.next() {\n             match ty.sty {\n@@ -301,23 +329,18 @@ impl<'a,'tcx> WfPredicates<'a,'tcx> {\n \n                 ty::TySlice(subty) |\n                 ty::TyArray(subty, _) => {\n-                    if !subty.has_escaping_regions() {\n-                        let cause = self.cause(traits::SliceOrArrayElem);\n-                        match traits::trait_ref_for_builtin_bound(self.infcx.tcx,\n-                                                                  ty::BoundSized,\n-                                                                  subty) {\n-                            Ok(trait_ref) => {\n-                                self.out.push(\n-                                    traits::Obligation::new(cause,\n-                                                            trait_ref.to_predicate()));\n-                            }\n-                            Err(ErrorReported) => { }\n+                    self.require_sized(subty, traits::SliceOrArrayElem, false);\n+                }\n+\n+                ty::TyTuple(ref tys) => {\n+                    if let Some((_last, rest)) = tys.split_last() {\n+                        for elem in rest {\n+                            self.require_sized(elem, traits::TupleElem, true);\n                         }\n                     }\n                 }\n \n                 ty::TyBox(_) |\n-                ty::TyTuple(_) |\n                 ty::TyRawPtr(_) => {\n                     // simple cases that are WF if their type args are WF\n                 }\n@@ -374,10 +397,25 @@ impl<'a,'tcx> WfPredicates<'a,'tcx> {\n                     // checking those\n \n                     let cause = self.cause(traits::MiscObligation);\n-                    self.out.push(\n-                        traits::Obligation::new(\n-                            cause,\n-                            ty::Predicate::ObjectSafe(data.principal_def_id())));\n+\n+                    // FIXME(#33243): remove RFC1592\n+                    self.out.push(traits::Obligation::new(\n+                        cause.clone(),\n+                        ty::Predicate::ObjectSafe(data.principal_def_id())\n+                    ));\n+                    let component_traits =\n+                        data.bounds.builtin_bounds.iter().flat_map(|bound| {\n+                            tcx.lang_items.from_builtin_kind(bound).ok()\n+                        });\n+//                        .chain(Some(data.principal_def_id()));\n+                    self.out.extend(\n+                        component_traits.map(|did| { traits::Obligation::new(\n+                            cause.clone(),\n+                            ty::Predicate::Rfc1592(\n+                                box ty::Predicate::ObjectSafe(did)\n+                            )\n+                        )})\n+                    );\n                 }\n \n                 // Inference variables are the complicated case, since we don't"}, {"sha": "728306b25ddc7c2245f13acc749461e705f3aafa", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -459,6 +459,9 @@ impl<'tcx> fmt::Debug for ty::Predicate<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             ty::Predicate::Trait(ref a) => write!(f, \"{:?}\", a),\n+            ty::Predicate::Rfc1592(ref a) => {\n+                write!(f, \"RFC1592({:?})\", a)\n+            }\n             ty::Predicate::Equate(ref pair) => write!(f, \"{:?}\", pair),\n             ty::Predicate::RegionOutlives(ref pair) => write!(f, \"{:?}\", pair),\n             ty::Predicate::TypeOutlives(ref pair) => write!(f, \"{:?}\", pair),\n@@ -493,7 +496,7 @@ impl fmt::Debug for ty::BoundRegion {\n             BrAnon(n) => write!(f, \"BrAnon({:?})\", n),\n             BrFresh(n) => write!(f, \"BrFresh({:?})\", n),\n             BrNamed(did, name) => {\n-                write!(f, \"BrNamed({:?}, {:?})\", did, name)\n+                write!(f, \"BrNamed({:?}:{:?}, {:?})\", did.krate, did.index, name)\n             }\n             BrEnv => \"BrEnv\".fmt(f),\n         }\n@@ -1056,6 +1059,7 @@ impl<'tcx> fmt::Display for ty::Predicate<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             ty::Predicate::Trait(ref data) => write!(f, \"{}\", data),\n+            ty::Predicate::Rfc1592(ref data) => write!(f, \"{}\", data),\n             ty::Predicate::Equate(ref predicate) => write!(f, \"{}\", predicate),\n             ty::Predicate::RegionOutlives(ref predicate) => write!(f, \"{}\", predicate),\n             ty::Predicate::TypeOutlives(ref predicate) => write!(f, \"{}\", predicate),"}, {"sha": "26f512e0613389082954275c766fd6d68bef44bd", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -42,7 +42,7 @@ fn read_u32v_be(dst: &mut[u32], input: &[u8]) {\n     }\n }\n \n-trait ToBits {\n+trait ToBits: Sized {\n     /// Convert the value in bytes to the number of bits, a tuple where the 1st item is the\n     /// high-order value and the 2nd item is the low order value.\n     fn to_bits(self) -> (Self, Self);"}, {"sha": "e0abe1aebd28df246b5dc5c3dd31a9e37f5ed024", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -190,6 +190,14 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             id: LintId::of(ILLEGAL_STRUCT_OR_ENUM_CONSTANT_PATTERN),\n             reference: \"RFC 1445 <https://github.com/rust-lang/rfcs/pull/1445>\",\n         },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(UNSIZED_IN_TUPLE),\n+            reference: \"issue #33242 <https://github.com/rust-lang/rust/issues/33242>\",\n+        },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(OBJECT_UNSAFE_FRAGMENT),\n+            reference: \"issue #33243 <https://github.com/rust-lang/rust/issues/33243>\",\n+        }\n         ]);\n \n     // We have one lint pass defined specially"}, {"sha": "57aa347847e15ad66d4e7de4b2e7d438f8b18db1", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -449,6 +449,9 @@ pub fn enc_predicate<'a, 'tcx>(w: &mut Cursor<Vec<u8>>,\n                                p: &ty::Predicate<'tcx>)\n {\n     match *p {\n+        ty::Predicate::Rfc1592(..) => {\n+            bug!(\"RFC1592 predicate in metadata `{:?}`\", p);\n+        }\n         ty::Predicate::Trait(ref trait_ref) => {\n             write!(w, \"t\");\n             enc_trait_ref(w, cx, trait_ref.0.trait_ref);"}, {"sha": "6fb9739fca4f464ed12ded481ad61a974a3850b0", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -277,6 +277,9 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n                 traits::report_fulfillment_errors(&infcx, errors);\n             }\n         }\n+        if let Err(ref errors) = fulfillment_cx.select_rfc1592_obligations(&infcx) {\n+            traits::report_fulfillment_errors_as_warnings(&infcx, errors, e.id);\n+        }\n     }\n }\n "}, {"sha": "5e07011d5bafdf085e913bc6a9304c71a07f62e1", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -1143,8 +1143,8 @@ fn make_object_type<'tcx>(this: &AstConv<'tcx>,\n         traits::astconv_object_safety_violations(tcx, principal.def_id());\n     if !object_safety_violations.is_empty() {\n         traits::report_object_safety_error(\n-            tcx, span, principal.def_id(), object_safety_violations)\n-            .emit();\n+            tcx, span, principal.def_id(), None, object_safety_violations)\n+            .unwrap().emit();\n         return tcx.types.err;\n     }\n "}, {"sha": "b84ded1ea7acf6f2ef38133116c21d8f4936a01b", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -179,6 +179,7 @@ fn deduce_expectations_from_obligations<'a,'tcx>(\n                 ty::Predicate::TypeOutlives(..) => None,\n                 ty::Predicate::WellFormed(..) => None,\n                 ty::Predicate::ObjectSafe(..) => None,\n+                ty::Predicate::Rfc1592(..) => None,\n \n                 // NB: This predicate is created by breaking down a\n                 // `ClosureType: FnFoo()` predicate, where"}, {"sha": "6c8d437f429f9b9ed19c36e00d9d9a6d5ee7b188", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -477,7 +477,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n                 // Object safety violations or miscellaneous.\n                 Err(err) => {\n-                    report_selection_error(self.fcx.infcx(), &obligation, &err);\n+                    report_selection_error(self.fcx.infcx(), &obligation, &err, None);\n                     // Treat this like an obligation and follow through\n                     // with the unsizing - the lack of a coercion should\n                     // be silent, as it causes a type mismatch later."}, {"sha": "b9fda2104546b44aec23a7f36bc7a4bfafcf0081", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -114,6 +114,11 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n         return Err(());\n     }\n \n+    if let Err(ref errors) = fulfillment_cx.select_rfc1592_obligations(&infcx) {\n+        traits::report_fulfillment_errors_as_warnings(&infcx, errors,\n+                                                      drop_impl_node_id);\n+    }\n+\n     let free_regions = FreeRegionMap::new();\n     infcx.resolve_regions_and_report_errors(&free_regions, drop_impl_node_id);\n     Ok(())"}, {"sha": "8a71debdf206ba9bb05c6645bbe83d7f278344af", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -492,6 +492,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                     ty::Predicate::WellFormed(..) |\n                     ty::Predicate::ObjectSafe(..) |\n                     ty::Predicate::ClosureKind(..) |\n+                    ty::Predicate::Rfc1592(..) |\n                     ty::Predicate::TypeOutlives(..) => {\n                         None\n                     }"}, {"sha": "6599199c239af625bfd7e5fc03e085981b864859", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -1989,13 +1989,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // upvar inference should have ensured that all deferred call\n         // resolutions are handled by now.\n         assert!(self.inh.deferred_call_resolutions.borrow().is_empty());\n+        let infcx = self.infcx();\n \n         self.select_all_obligations_and_apply_defaults();\n \n         let mut fulfillment_cx = self.inh.fulfillment_cx.borrow_mut();\n-        match fulfillment_cx.select_all_or_error(self.infcx()) {\n+        match fulfillment_cx.select_all_or_error(infcx) {\n             Ok(()) => { }\n-            Err(errors) => { report_fulfillment_errors(self.infcx(), &errors); }\n+            Err(errors) => { report_fulfillment_errors(infcx, &errors); }\n+        }\n+\n+        if let Err(ref errors) = fulfillment_cx.select_rfc1592_obligations(infcx) {\n+            traits::report_fulfillment_errors_as_warnings(infcx, errors, self.body_id);\n         }\n     }\n "}, {"sha": "4dd093e2e4bfdcca1796b14f08e408f602de9160", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -450,6 +450,7 @@ impl<'tcx> GetTypeParameterBounds<'tcx> for ty::GenericPredicates<'tcx> {\n                     ty::Predicate::TypeOutlives(ref data) => {\n                         data.skip_binder().0.is_param(def.space, def.index)\n                     }\n+                    ty::Predicate::Rfc1592(..) |\n                     ty::Predicate::Equate(..) |\n                     ty::Predicate::RegionOutlives(..) |\n                     ty::Predicate::WellFormed(..) |"}, {"sha": "398781e14052ff633ee5be1639093df42a3ef803", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -866,6 +866,7 @@ impl<'a> Clean<WherePredicate> for ty::Predicate<'a> {\n             Predicate::WellFormed(_) => panic!(\"not user writable\"),\n             Predicate::ObjectSafe(_) => panic!(\"not user writable\"),\n             Predicate::ClosureKind(..) => panic!(\"not user writable\"),\n+            Predicate::Rfc1592(..) => panic!(\"not user writable\"),\n         }\n     }\n }"}, {"sha": "f39fb0e31c6ee570089ac16b8dc1674e7f2f7e60", "filename": "src/test/compile-fail/issue-17431-2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Ftest%2Fcompile-fail%2Fissue-17431-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Ftest%2Fcompile-fail%2Fissue-17431-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17431-2.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n struct Baz { q: Option<Foo> }\n+//~^ ERROR recursive type `Baz` has infinite size\n \n struct Foo { q: Option<Baz> }\n //~^ ERROR recursive type `Foo` has infinite size"}, {"sha": "1c9e588cb2cd18c051d904b69947ff8c549c4b41", "filename": "src/test/compile-fail/issue-20692.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Ftest%2Fcompile-fail%2Fissue-20692.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Ftest%2Fcompile-fail%2Fissue-20692.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20692.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -14,6 +14,7 @@ fn f<T: Array>(x: &T) {\n     let _ = x\n     //~^ ERROR `Array` cannot be made into an object\n     //~| NOTE the trait cannot require that `Self : Sized`\n+    //~| NOTE requirements on the impl of `std::ops::CoerceUnsized<&Array>`\n     as\n     &Array;\n     //~^ ERROR `Array` cannot be made into an object"}, {"sha": "2919b0b3caca6b2ae82de94b8ab7092afd4619b5", "filename": "src/test/compile-fail/issue-26548.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Ftest%2Fcompile-fail%2Fissue-26548.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Ftest%2Fcompile-fail%2Fissue-26548.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26548.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// error-pattern: overflow representing the type `S`\n+\n trait Mirror { type It: ?Sized; }\n impl<T: ?Sized> Mirror for T { type It = Self; }\n struct S(Option<<S as Mirror>::It>);\n-//~^ ERROR recursive type `S` has infinite size\n \n fn main() {\n     let _s = S(None);"}, {"sha": "c4e8f7661175236022333fef3788f65467ccf9c9", "filename": "src/test/compile-fail/issue-32963.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Ftest%2Fcompile-fail%2Fissue-32963.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Ftest%2Fcompile-fail%2Fissue-32963.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32963.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::mem;\n+\n+trait Misc {}\n+\n+fn size_of_copy<T: Copy+?Sized>() -> usize { mem::size_of::<T>() }\n+\n+fn main() {\n+    size_of_copy::<Misc+Copy>();\n+    //~^ ERROR `Misc + Copy: std::marker::Copy` is not satisfied\n+}"}, {"sha": "747fe2d2046aecc75a3578d64fc9c62e0309f9e0", "filename": "src/test/compile-fail/kindck-copy.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -45,15 +45,15 @@ fn test<'a,T,U:Copy>(_: &'a isize) {\n \n     // borrowed object types are generally ok\n     assert_copy::<&'a Dummy>();\n-    assert_copy::<&'a (Dummy+Copy)>();\n-    assert_copy::<&'static (Dummy+Copy)>();\n+    assert_copy::<&'a (Dummy+Send)>();\n+    assert_copy::<&'static (Dummy+Send)>();\n \n     // owned object types are not ok\n     assert_copy::<Box<Dummy>>(); //~ ERROR : std::marker::Copy` is not satisfied\n-    assert_copy::<Box<Dummy+Copy>>(); //~ ERROR : std::marker::Copy` is not satisfied\n+    assert_copy::<Box<Dummy+Send>>(); //~ ERROR : std::marker::Copy` is not satisfied\n \n     // mutable object types are not ok\n-    assert_copy::<&'a mut (Dummy+Copy)>();  //~ ERROR : std::marker::Copy` is not satisfied\n+    assert_copy::<&'a mut (Dummy+Send)>();  //~ ERROR : std::marker::Copy` is not satisfied\n \n     // unsafe ptrs are ok\n     assert_copy::<*const isize>();"}, {"sha": "2a0773af73bbfef375ec0aa7aaf296d7de7412b5", "filename": "src/test/compile-fail/range-1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange-1.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -23,5 +23,4 @@ pub fn main() {\n     let arr: &[_] = &[1, 2, 3];\n     let range = *arr..;\n     //~^ ERROR `[_]: std::marker::Sized` is not satisfied\n-    //~| ERROR `[_]: std::marker::Sized` is not satisfied\n }"}, {"sha": "e766f977200c3c4724cafb47a8670aed20f2dd74", "filename": "src/test/compile-fail/rfc1592-deprecated.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Ftest%2Fcompile-fail%2Frfc1592-deprecated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Ftest%2Fcompile-fail%2Frfc1592-deprecated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc1592-deprecated.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt;\n+\n+#[deny(warnings)] trait Foo { fn foo(&self) -> (Self, Self); }\n+//~^ ERROR the trait bound `Self: std::marker::Sized` is not satisfied\n+//~| WARNING hard error\n+\n+impl<T: Copy> Foo for T {\n+    fn foo(&self) -> (Self, Self) {\n+        (*self, *self)\n+    }\n+}\n+\n+#[deny(warnings)]\n+fn main() {\n+    assert_eq!((11).foo(), (11, 11));\n+\n+    let junk: Box<fmt::Debug+Sized> = Box::new(42);\n+    //~^ ERROR the trait cannot require that `Self : Sized`\n+    //~| WARNING hard error\n+    let f = format!(\"{:?}\", junk);\n+    assert_eq!(f, \"42\");\n+}"}, {"sha": "712b4ac22f068f890bcc9f2f2d9a7cf06d7ec64e", "filename": "src/test/compile-fail/sized-cycle-note.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Ftest%2Fcompile-fail%2Fsized-cycle-note.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Ftest%2Fcompile-fail%2Fsized-cycle-note.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsized-cycle-note.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -17,14 +17,9 @@\n // 2. it should elaborate the steps that led to the cycle.\n \n struct Baz { q: Option<Foo> }\n-\n+//~^ ERROR recursive type `Baz` has infinite size\n struct Foo { q: Option<Baz> }\n //~^ ERROR recursive type `Foo` has infinite size\n-//~| NOTE type `Foo` is embedded within `std::option::Option<Foo>`...\n-//~| NOTE ...which in turn is embedded within `std::option::Option<Foo>`...\n-//~| NOTE ...which in turn is embedded within `Baz`...\n-//~| NOTE ...which in turn is embedded within `std::option::Option<Baz>`...\n-//~| NOTE ...which in turn is embedded within `Foo`, completing the cycle.\n \n impl Foo { fn bar(&self) {} }\n "}, {"sha": "d40c12f67a08da43a38d3eadf754ab8a5601c78e", "filename": "src/test/compile-fail/unsized6.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Ftest%2Fcompile-fail%2Funsized6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Ftest%2Fcompile-fail%2Funsized6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized6.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -14,9 +14,9 @@ trait T {}\n \n fn f1<X: ?Sized>(x: &X) {\n     let _: X; // <-- this is OK, no bindings created, no initializer.\n-    let _: (isize, (X, isize)); // same\n+    let _: (isize, (X, isize));\n     let y: X; //~ERROR `X: std::marker::Sized` is not satisfied\n-    let y: (isize, (X, isize)); //~ERROR `X: std::marker::Sized` is not satisfied\n+    let y: (isize, (X, usize)); //~ERROR `X: std::marker::Sized` is not satisfied\n }\n fn f2<X: ?Sized + T>(x: &X) {\n     let y: X; //~ERROR `X: std::marker::Sized` is not satisfied"}, {"sha": "6c04e66068e60b5547dc1021005227e18c28cbea", "filename": "src/test/run-pass/issue-31299.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Ftest%2Frun-pass%2Fissue-31299.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Ftest%2Frun-pass%2Fissue-31299.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-31299.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #31299. This was generating an overflow error\n+// because of eager normalization:\n+//\n+// proving `M: Sized` requires\n+// - proving `PtrBack<Vec<M>>: Sized` requires\n+//   - normalizing `Vec<<Vec<M> as Front>::Back>>: Sized` requires\n+//     - proving `Vec<M>: Front` requires\n+//       - `M: Sized` <-- cycle!\n+//\n+// If we skip the normalization step, though, everything goes fine.\n+//\n+// This could be fixed by implementing lazy normalization everywhere.\n+//\n+// However, we want this to work before then. For that, when checking\n+// whether a type is Sized we only check that the tails are Sized. As\n+// PtrBack does not have a tail, we don't need to normalize anything\n+// and this compiles\n+\n+trait Front {\n+    type Back;\n+}\n+\n+impl<T> Front for Vec<T> {\n+    type Back = Vec<T>;\n+}\n+\n+struct PtrBack<T: Front>(Vec<T::Back>);\n+\n+struct M(PtrBack<Vec<M>>);\n+\n+fn main() {\n+    std::mem::size_of::<M>();\n+}"}, {"sha": "81bf02587896fbac62b953d7986e0fc7db914067", "filename": "src/test/run-pass/rfc1592-deprecated.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5158f3b282287624232ac6935569e440bb182664/src%2Ftest%2Frun-pass%2Frfc1592-deprecated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5158f3b282287624232ac6935569e440bb182664/src%2Ftest%2Frun-pass%2Frfc1592-deprecated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc1592-deprecated.rs?ref=5158f3b282287624232ac6935569e440bb182664", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt;\n+\n+trait Foo {\n+    fn foo(&self) -> (Self, Self);\n+}\n+\n+impl<T: Copy> Foo for T {\n+    fn foo(&self) -> (Self, Self) {\n+        (*self, *self)\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!((11).foo(), (11, 11));\n+\n+    let junk: Box<fmt::Debug+Sized> = Box::new(42);\n+    let f = format!(\"{:?}\", junk);\n+    assert_eq!(f, \"42\");\n+}"}]}