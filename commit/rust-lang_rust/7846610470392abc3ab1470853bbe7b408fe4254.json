{"sha": "7846610470392abc3ab1470853bbe7b408fe4254", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4NDY2MTA0NzAzOTJhYmMzYWIxNDcwODUzYmJlN2I0MDhmZTQyNTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-07T12:09:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-07T12:09:11Z"}, "message": "Auto merge of #37817 - alexcrichton:rustbuild-default, r=brson\n\nmk: Switch rustbuild to the default build system\n\nThis commit switches the default build system for Rust from the makefiles to\nrustbuild. The rustbuild build system has been in development for almost a year\nnow and has become quite mature over time. This commit is an implementation of\nthe proposal on [internals] which slates deletion of the makefiles on\n2017-02-02.\n\n[internals]: https://internals.rust-lang.org/t/proposal-for-promoting-rustbuild-to-official-status/4368\n\nThis commit also updates various documentation in `README.md`,\n`CONTRIBUTING.md`, `src/bootstrap/README.md`, and throughout the source code of\nrustbuild itself.", "tree": {"sha": "0ba16998dbd81071574432acce3dc00fca71e074", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ba16998dbd81071574432acce3dc00fca71e074"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7846610470392abc3ab1470853bbe7b408fe4254", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7846610470392abc3ab1470853bbe7b408fe4254", "html_url": "https://github.com/rust-lang/rust/commit/7846610470392abc3ab1470853bbe7b408fe4254", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7846610470392abc3ab1470853bbe7b408fe4254/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5938eba4e30b766751483e93776a87a4db1681f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/5938eba4e30b766751483e93776a87a4db1681f4", "html_url": "https://github.com/rust-lang/rust/commit/5938eba4e30b766751483e93776a87a4db1681f4"}, {"sha": "0e272de69f4a9c889e5f1a024a88b3e1f60cb6c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e272de69f4a9c889e5f1a024a88b3e1f60cb6c5", "html_url": "https://github.com/rust-lang/rust/commit/0e272de69f4a9c889e5f1a024a88b3e1f60cb6c5"}], "stats": {"total": 1055, "additions": 757, "deletions": 298}, "files": [{"sha": "996e5ec07b5453d3eec7d76f9567dd49070792ad", "filename": ".travis.yml", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7846610470392abc3ab1470853bbe7b408fe4254/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/7846610470392abc3ab1470853bbe7b408fe4254/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=7846610470392abc3ab1470853bbe7b408fe4254", "patch": "@@ -1,4 +1,4 @@\n-language: rust\n+language: minimal\n sudo: required\n dist: trusty\n services:\n@@ -20,7 +20,7 @@ matrix:\n     - env: IMAGE=x86_64-gnu-cargotest\n     - env: IMAGE=x86_64-gnu-debug\n     - env: IMAGE=x86_64-gnu-nopt\n-    - env: IMAGE=x86_64-gnu-rustbuild\n+    - env: IMAGE=x86_64-gnu-make\n     - env: IMAGE=x86_64-gnu-llvm-3.7 ALLOW_PR=1 RUST_BACKTRACE=1\n     - env: IMAGE=x86_64-musl\n \n@@ -39,7 +39,7 @@ matrix:\n       install: brew install ccache\n     - env: >\n         RUST_CHECK_TARGET=check\n-        RUST_CONFIGURE_ARGS=--target=x86_64-apple-darwin --enable-rustbuild\n+        RUST_CONFIGURE_ARGS=--target=x86_64-apple-darwin --disable-rustbuild\n         SRC=.\n       os: osx\n       install: brew install ccache\n@@ -51,17 +51,16 @@ matrix:\n       install: brew install ccache\n \n script:\n-  - if [ -z \"$ALLOW_PR\" ] && [ \"$TRAVIS_BRANCH\" != \"auto\" ]; then\n-        echo skipping, not a full build;\n-    elif [ -z \"$ENABLE_AUTO\" ] then\n-        echo skipping, not quite ready yet\n-    elif [ \"$TRAVIS_OS_NAME\" = \"osx\" ]; then\n-        git submodule update --init;\n-        src/ci/run.sh;\n-    else\n-        git submodule update --init;\n-        src/ci/docker/run.sh $IMAGE;\n-    fi\n+  - >\n+      if [ \"$ALLOW_PR\" = \"\" ] && [ \"$TRAVIS_BRANCH\" != \"auto\" ]; then\n+          echo skipping, not a full build;\n+      elif [ \"$TRAVIS_OS_NAME\" = \"osx\" ]; then\n+          git submodule update --init;\n+          src/ci/run.sh;\n+      else\n+          git submodule update --init;\n+          src/ci/docker/run.sh $IMAGE;\n+      fi\n \n # Save tagged docker images we created and load them if they're available\n before_cache:"}, {"sha": "20a0bd2e256d921352de2d102bb041dfc5fe4907", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 111, "deletions": 40, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/7846610470392abc3ab1470853bbe7b408fe4254/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/7846610470392abc3ab1470853bbe7b408fe4254/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=7846610470392abc3ab1470853bbe7b408fe4254", "patch": "@@ -86,13 +86,17 @@ benchmarks, generate documentation, install a fresh build of Rust, and more.\n It's your best friend when working on Rust, allowing you to compile & test\n your contributions before submission.\n \n-All the configuration for the build system lives in [the `mk` directory][mkdir]\n-in the project root. It can be hard to follow in places, as it uses some\n-advanced Make features which make for some challenging reading. If you have\n-questions on the build system internals, try asking in\n-[`#rust-internals`][pound-rust-internals].\n+The build system lives in [the `src/bootstrap` directory][bootstrap] in the\n+project root. Our build system is itself written in Rust and is based on Cargo\n+to actually build all the compiler's crates. If you have questions on the build\n+system internals, try asking in [`#rust-internals`][pound-rust-internals].\n \n-[mkdir]: https://github.com/rust-lang/rust/tree/master/mk/\n+[bootstrap]: https://github.com/rust-lang/rust/tree/master/src/bootstrap/\n+\n+> **Note**: the build system was recently rewritten from a jungle of makefiles\n+> to the current incarnation you'll see in `src/bootstrap`. If you experience\n+> bugs you can temporarily revert back to the makefiles with\n+> `--disable-rustbuild` passed to `./configure`.\n \n ### Configuration\n \n@@ -119,42 +123,111 @@ configuration used later in the build process. Some options to note:\n \n To see a full list of options, run `./configure --help`.\n \n-### Useful Targets\n-\n-Some common make targets are:\n-\n-- `make tips` - show useful targets, variables and other tips for working with\n-   the build system.\n-- `make rustc-stage1` - build up to (and including) the first stage. For most\n-  cases we don't need to build the stage2 compiler, so we can save time by not\n-  building it. The stage1 compiler is a fully functioning compiler and\n-  (probably) will be enough to determine if your change works as expected.\n-- `make $host/stage1/bin/rustc` - Where $host is a target triple like x86_64-unknown-linux-gnu.\n-  This will build just rustc, without libstd. This is the fastest way to recompile after\n-  you changed only rustc source code. Note however that the resulting rustc binary\n-  won't have a stdlib to link against by default. You can build libstd once with\n-  `make rustc-stage1`, rustc will pick it up afterwards. libstd is only guaranteed to\n-  work if recompiled, so if there are any issues recompile it.\n-- `make check` - build the full compiler & run all tests (takes a while). This\n+### Building\n+\n+Although the `./configure` script will generate a `Makefile`, this is actually\n+just a thin veneer over the actual build system driver, `x.py`. This file, at\n+the root of the repository, is used to build, test, and document various parts\n+of the compiler. You can execute it as:\n+\n+```sh\n+python x.py build\n+```\n+\n+On some systems you can also use the shorter version:\n+\n+```sh\n+./x.py build\n+```\n+\n+To learn more about the driver and top-level targets, you can execute:\n+\n+```sh\n+python x.py --help\n+```\n+\n+The general format for the driver script is:\n+\n+```sh\n+python x.py <command> [<directory>]\n+```\n+\n+Some example commands are `build`, `test`, and `doc`. These will build, test,\n+and document the specified directory. The second argument, `<directory>`, is\n+optional and defaults to working over the entire compiler. If specified,\n+however, only that specific directory will be built. For example:\n+\n+```sh\n+# build the entire compiler\n+python x.py build\n+\n+# build all documentation\n+python x.py doc\n+\n+# run all test suites\n+python x.py test\n+\n+# build only the standard library\n+python x.py build src/libstd\n+\n+# test only one particular test suite\n+python x.py test src/test/rustdoc\n+\n+# build only the stage0 libcore library\n+python x.py build src/libcore --stage 0\n+```\n+\n+You can explore the build system throught the various `--help` pages for each\n+subcommand. For example to learn more about a command you can run:\n+\n+```\n+python x.py build --help\n+```\n+\n+To learn about all possible rules you can execute, run:\n+\n+```\n+python x.py build --help --verbose\n+```\n+\n+### Useful commands\n+\n+Some common invocations of `x.py` are:\n+\n+- `x.py build --help` - show the help message and explain the subcommand\n+- `x.py build src/libtest --stage 1` - build up to (and including) the first\n+  stage. For most cases we don't need to build the stage2 compiler, so we can\n+  save time by not building it. The stage1 compiler is a fully functioning\n+  compiler and (probably) will be enough to determine if your change works as\n+  expected.\n+- `x.py build src/rustc --stage 1` - This will build just rustc, without libstd.\n+  This is the fastest way to recompile after you changed only rustc source code.\n+  Note however that the resulting rustc binary won't have a stdlib to link\n+  against by default. You can build libstd once with `x.py build src/libstd`,\n+  but it is is only guaranteed to work if recompiled, so if there are any issues\n+  recompile it.\n+- `x.py test` - build the full compiler & run all tests (takes a while). This\n   is what gets run by the continuous integration system against your pull\n   request. You should run this before submitting to make sure your tests pass\n   & everything builds in the correct manner.\n-- `make check-stage1-std NO_REBUILD=1` - test the standard library without\n-  rebuilding the entire compiler\n-- `make check TESTNAME=<substring-of-test-name>` - Run a matching set of tests.\n+- `x.py test src/libstd --stage 1` - test the standard library without\n+  recompiling stage 2.\n+- `x.py test src/test/run-pass --filter TESTNAME` - Run a matching set of tests.\n   - `TESTNAME` should be a substring of the tests to match against e.g. it could\n     be the fully qualified test name, or just a part of it.\n     `TESTNAME=collections::hash::map::test_map::test_capacity_not_less_than_len`\n     or `TESTNAME=test_capacity_not_less_than_len`.\n-- `make check-stage1-rpass TESTNAME=<substring-of-test-name>` - Run a single\n-  rpass test with the stage1 compiler (this will be quicker than running the\n-  command above as we only build the stage1 compiler, not the entire thing).\n-  You can also leave off the `-rpass` to run all stage1 test types.\n-- `make check-stage1-coretest` - Run stage1 tests in `libcore`.\n-- `make tidy` - Check that the source code is in compliance with Rust's style\n-  guidelines. There is no official document describing Rust's full guidelines \n-  as of yet, but basic rules like 4 spaces for indentation and no more than 99\n-  characters in a single line should be kept in mind when writing code.\n+- `x.py test src/test/run-pass --stage 1 --filter <substring-of-test-name>` -\n+  Run a single rpass test with the stage1 compiler (this will be quicker than\n+  running the command above as we only build the stage1 compiler, not the entire\n+  thing).  You can also leave off the directory argument to run all stage1 test\n+  types.\n+- `x.py test src/libcore --stage 1` - Run stage1 tests in `libcore`.\n+- `x.py test src/tools/tidy` - Check that the source code is in compliance with\n+  Rust's style guidelines. There is no official document describing Rust's full\n+  guidelines as of yet, but basic rules like 4 spaces for indentation and no\n+  more than 99 characters in a single line should be kept in mind when writing\n+  code.\n \n ## Pull Requests\n \n@@ -172,19 +245,17 @@ amount of time you have to wait. You need to have built the compiler at least\n once before running these will work, but that\u2019s only one full build rather than\n one each time.\n \n-    $ make -j8 rustc-stage1 && make check-stage1\n+    $ python x.py test --stage 1\n \n is one such example, which builds just `rustc`, and then runs the tests. If\n you\u2019re adding something to the standard library, try\n \n-    $ make -j8 check-stage1-std NO_REBUILD=1\n-\n-This will not rebuild the compiler, but will run the tests.\n+    $ python x.py test src/libstd --stage 1\n \n Please make sure your pull request is in compliance with Rust's style\n guidelines by running\n \n-    $ make tidy\n+    $ python x.py test src/tools/tidy\n \n Make this check before every pull request (and every new commit in a pull\n request) ; you can add [git hooks](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks)"}, {"sha": "2133b17de0fbbe214a26807b540b9804520afb56", "filename": "README.md", "status": "modified", "additions": 13, "deletions": 33, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7846610470392abc3ab1470853bbe7b408fe4254/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/7846610470392abc3ab1470853bbe7b408fe4254/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=7846610470392abc3ab1470853bbe7b408fe4254", "patch": "@@ -36,16 +36,14 @@ Read [\"Installing Rust\"] from [The Book].\n \n     ```sh\n     $ ./configure\n-    $ make && make install\n+    $ make && sudo make install\n     ```\n \n-    > ***Note:*** You may need to use `sudo make install` if you do not\n-    > normally have permission to modify the destination directory. The\n-    > install locations can be adjusted by passing a `--prefix` argument\n-    > to `configure`. Various other options are also supported \u2013 pass\n+    > ***Note:*** Install locations can be adjusted by passing a `--prefix`\n+    > argument to `configure`. Various other options are also supported \u2013 pass\n     > `--help` for more information on them.\n \n-    When complete, `make install` will place several programs into\n+    When complete, `sudo make install` will place several programs into\n     `/usr/local/bin`: `rustc`, the Rust compiler, and `rustdoc`, the\n     API-documentation tool. This install does not include [Cargo],\n     Rust's package manager, which you may also want to build.\n@@ -108,30 +106,22 @@ MSVC builds of Rust additionally require an installation of Visual Studio 2013\n (or later) so `rustc` can use its linker. Make sure to check the \u201cC++ tools\u201d\n option.\n \n-With these dependencies installed, the build takes two steps:\n+With these dependencies installed, you can build the compiler in a `cmd.exe`\n+shell with:\n \n ```sh\n-$ ./configure\n-$ make && make install\n+> python x.py build\n ```\n \n-#### MSVC with rustbuild\n-\n-The old build system, based on makefiles, is currently being rewritten into a\n-Rust-based build system called rustbuild. This can be used to bootstrap the\n-compiler on MSVC without needing to install MSYS or MinGW. All you need are\n-[Python 2](https://www.python.org/downloads/),\n-[CMake](https://cmake.org/download/), and\n-[Git](https://git-scm.com/downloads) in your PATH (make sure you do not use the\n-ones from MSYS if you have it installed). You'll also need Visual Studio 2013 or\n-newer with the C++ tools. Then all you need to do is to kick off rustbuild.\n+If you're running inside of an msys shell, however, you can run:\n \n-```\n-python x.py build\n+```sh\n+$ ./configure --build=x86_64-pc-windows-msvc\n+$ make && make install\n ```\n \n-Currently rustbuild only works with some known versions of Visual Studio. If you\n-have a more recent version installed that a part of rustbuild doesn't understand\n+Currently building Rust only works with some known versions of Visual Studio. If\n+you have a more recent version installed the build system doesn't understand\n then you may need to force rustbuild to use an older version. This can be done\n by manually calling the appropriate vcvars file before running the bootstrap.\n \n@@ -149,16 +139,6 @@ $ ./configure\n $ make docs\n ```\n \n-Building the documentation requires building the compiler, so the above\n-details will apply. Once you have the compiler built, you can\n-\n-```sh\n-$ make docs NO_REBUILD=1\n-```\n-\n-To make sure you don\u2019t re-build the compiler because you made a change\n-to some documentation.\n-\n The generated documentation will appear in a top-level `doc` directory,\n created by the `make` rule.\n "}, {"sha": "bf75439b74a47d31438043106387235b2ce429b7", "filename": "appveyor.yml", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7846610470392abc3ab1470853bbe7b408fe4254/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/7846610470392abc3ab1470853bbe7b408fe4254/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=7846610470392abc3ab1470853bbe7b408fe4254", "patch": "@@ -2,25 +2,22 @@ environment:\n   matrix:\n   # 32/64 bit MSVC\n   - MSYS_BITS: 64\n-    TARGET: x86_64-pc-windows-msvc\n-    CHECK: check\n-    CONFIGURE_ARGS: --enable-llvm-assertions --enable-debug-assertions\n+    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n+    RUST_CHECK_TARGET: check\n   - MSYS_BITS: 32\n-    TARGET: i686-pc-windows-msvc\n-    CHECK: check\n-    CONFIGURE_ARGS: --enable-llvm-assertions --enable-debug-assertions\n+    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n+    RUST_CHECK_TARGET: check\n \n-  # MSVC rustbuild\n+  # MSVC makefiles\n   - MSYS_BITS: 64\n-    CONFIGURE_ARGS: --enable-rustbuild --enable-llvm-assertions --enable-debug-assertions\n-    TARGET: x86_64-pc-windows-msvc\n-    CHECK: check\n+    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --disable-rustbuild\n+    RUST_CHECK_TARGET: check\n \n   # MSVC cargotest\n   - MSYS_BITS: 64\n-    CONFIGURE_ARGS: --enable-rustbuild --enable-llvm-assertions --enable-debug-assertions\n-    TARGET: x86_64-pc-windows-msvc\n-    CHECK: check-cargotest\n+    NO_VENDOR: 1\n+    RUST_CHECK_TARGET: check-cargotest\n+    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n \n   # 32/64-bit MinGW builds.\n   #\n@@ -47,24 +44,22 @@ environment:\n   # *not* use debug assertions and llvm assertions. This is because they take\n   # too long on appveyor and this is tested by rustbuild below.\n   - MSYS_BITS: 32\n-    TARGET: i686-pc-windows-gnu\n-    CHECK: check\n+    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n+    RUST_CHECK_TARGET: check\n     MINGW_URL: https://s3.amazonaws.com/rust-lang-ci\n     MINGW_ARCHIVE: i686-4.9.2-release-win32-dwarf-rt_v4-rev4.7z\n     MINGW_DIR: mingw32\n \n   - MSYS_BITS: 32\n-    CONFIGURE_ARGS: --enable-rustbuild --enable-llvm-assertions --enable-debug-assertions\n-    TARGET: i686-pc-windows-gnu\n-    CHECK: check\n+    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu --disable-rustbuild\n+    RUST_CHECK_TARGET: check\n     MINGW_URL: https://s3.amazonaws.com/rust-lang-ci\n     MINGW_ARCHIVE: i686-4.9.2-release-win32-dwarf-rt_v4-rev4.7z\n     MINGW_DIR: mingw32\n \n   - MSYS_BITS: 64\n-    CONFIGURE_ARGS: --enable-llvm-assertions --enable-debug-assertions\n-    TARGET: x86_64-pc-windows-gnu\n-    CHECK: check\n+    RUST_CHECK_TARGET: check\n+    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu\n     MINGW_URL: https://s3.amazonaws.com/rust-lang-ci\n     MINGW_ARCHIVE: x86_64-4.9.2-release-win32-seh-rt_v4-rev4.7z\n     MINGW_DIR: mingw64\n@@ -90,15 +85,20 @@ install:\n   - if NOT defined MINGW_URL set PATH=C:\\msys64\\mingw%MSYS_BITS%\\bin;C:\\msys64\\usr\\bin;%PATH%\n \n test_script:\n-  - sh ./configure\n-          %CONFIGURE_ARGS%\n-          --build=%TARGET%\n-  - bash -c \"make -j$(nproc)\"\n-  - bash -c \"make %CHECK% -j$(nproc)\"\n+  - git submodule update --init\n+  - set SRC=.\n+  - set NO_CCACHE=1\n+  - sh src/ci/run.sh\n \n cache:\n-  - build/%TARGET%/llvm -> src/rustllvm/llvm-auto-clean-trigger\n-  - \"%TARGET%/llvm -> src/rustllvm/llvm-auto-clean-trigger\"\n+  - \"build/i686-pc-windows-gnu/llvm -> src/rustllvm/llvm-auto-clean-trigger\"\n+  - \"build/x86_64-pc-windows-gnu/llvm -> src/rustllvm/llvm-auto-clean-trigger\"\n+  - \"build/i686-pc-windows-msvc/llvm -> src/rustllvm/llvm-auto-clean-trigger\"\n+  - \"build/x86_64-pc-windows-msvc/llvm -> src/rustllvm/llvm-auto-clean-trigger\"\n+  - \"i686-pc-windows-gnu/llvm -> src/rustllvm/llvm-auto-clean-trigger\"\n+  - \"x86_64-pc-windows-gnu/llvm -> src/rustllvm/llvm-auto-clean-trigger\"\n+  - \"i686-pc-windows-msvc/llvm -> src/rustllvm/llvm-auto-clean-trigger\"\n+  - \"x86_64-pc-windows-msvc/llvm -> src/rustllvm/llvm-auto-clean-trigger\"\n \n branches:\n   only:"}, {"sha": "a287291c2809c1260f8cafe0918593f724da617a", "filename": "configure", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7846610470392abc3ab1470853bbe7b408fe4254/configure", "raw_url": "https://github.com/rust-lang/rust/raw/7846610470392abc3ab1470853bbe7b408fe4254/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=7846610470392abc3ab1470853bbe7b408fe4254", "patch": "@@ -631,7 +631,7 @@ opt stage0-landing-pads 1 \"enable landing pads during bootstrap with stage0\"\n opt dist-host-only 0 \"only install bins for the host architecture\"\n opt inject-std-version 1 \"inject the current compiler version of libstd into programs\"\n opt llvm-version-check 1 \"check if the LLVM version is supported, build anyway\"\n-opt rustbuild 0 \"use the rust and cargo based build system\"\n+opt rustbuild 1 \"use the rust and cargo based build system\"\n opt codegen-tests 1 \"run the src/test/codegen tests\"\n opt option-checking 1 \"complain about unrecognized options in this configure script\"\n opt ninja 0 \"build LLVM using the Ninja generator (for MSVC, requires building in the correct environment)\"\n@@ -664,11 +664,11 @@ valopt armv7-linux-androideabi-ndk \"\" \"armv7-linux-androideabi NDK standalone pa\n valopt aarch64-linux-android-ndk \"\" \"aarch64-linux-android NDK standalone path\"\n valopt nacl-cross-path  \"\" \"NaCl SDK path (Pepper Canary is recommended). Must be absolute!\"\n valopt musl-root \"/usr/local\" \"MUSL root installation directory (deprecated)\"\n-valopt musl-root-x86_64 \"/usr/local\" \"x86_64-unknown-linux-musl install directory\"\n-valopt musl-root-i686 \"/usr/local\" \"i686-unknown-linux-musl install directory\"\n-valopt musl-root-arm \"/usr/local\" \"arm-unknown-linux-musleabi install directory\"\n-valopt musl-root-armhf \"/usr/local\" \"arm-unknown-linux-musleabihf install directory\"\n-valopt musl-root-armv7 \"/usr/local\" \"armv7-unknown-linux-musleabihf install directory\"\n+valopt musl-root-x86_64 \"\" \"x86_64-unknown-linux-musl install directory\"\n+valopt musl-root-i686 \"\" \"i686-unknown-linux-musl install directory\"\n+valopt musl-root-arm \"\" \"arm-unknown-linux-musleabi install directory\"\n+valopt musl-root-armhf \"\" \"arm-unknown-linux-musleabihf install directory\"\n+valopt musl-root-armv7 \"\" \"armv7-unknown-linux-musleabihf install directory\"\n valopt extra-filename \"\" \"Additional data that is hashed and passed to the -C extra-filename flag\"\n \n if [ -e ${CFG_SRC_DIR}.git ]\n@@ -1374,7 +1374,7 @@ then\n     fi\n fi\n \n-if [ -z \"$CFG_ENABLE_RUSTBUILD\" ]; then\n+if [ -n \"$CFG_DISABLE_RUSTBUILD\" ]; then\n \n   step_msg \"making directories\"\n \n@@ -1474,7 +1474,7 @@ fi\n step_msg \"configuring submodules\"\n \n # Have to be in the top of src directory for this\n-if [ -z \"$CFG_DISABLE_MANAGE_SUBMODULES\" ] && [ -z \"$CFG_ENABLE_RUSTBUILD\" ]\n+if [ -z \"$CFG_DISABLE_MANAGE_SUBMODULES\" ] && [ -n \"$CFG_DISABLE_RUSTBUILD\" ]\n then\n     cd ${CFG_SRC_DIR}\n \n@@ -1546,7 +1546,7 @@ do\n         ;;\n     esac\n \n-    if [ -n \"$CFG_ENABLE_RUSTBUILD\" ]\n+    if [ -z \"$CFG_DISABLE_RUSTBUILD\" ]\n     then\n         msg \"not configuring LLVM, rustbuild in use\"\n         do_reconfigure=0\n@@ -1871,7 +1871,7 @@ do\n     putvar $CFG_LLVM_INST_DIR\n done\n \n-if [ -n \"$CFG_ENABLE_RUSTBUILD\" ]\n+if [ -z \"$CFG_DISABLE_RUSTBUILD\" ]\n then\n     INPUT_MAKEFILE=src/bootstrap/mk/Makefile.in\n else\n@@ -1890,5 +1890,22 @@ else\n     step_msg \"complete\"\n fi\n \n-msg \"run \\`make help\\`\"\n+if [ -z \"$CFG_DISABLE_RUSTBUILD\" ]; then\n+    msg \"NOTE you have now configured rust to use a rewritten build system\"\n+    msg \"     called rustbuild, and as a result this may have bugs that \"\n+    msg \"     you did not see before. If you experience any issues you can\"\n+    msg \"     go back to the old build system with --disable-rustbuild and\"\n+    msg \"     please feel free to report any bugs!\"\n+    msg \"\"\n+    msg \"run \\`python x.py --help\\`\"\n+else\n+    warn \"the makefile-based build system is deprecated in favor of rustbuild\"\n+    msg \"\"\n+    msg \"It is recommended you avoid passing --disable-rustbuild to get your\"\n+    msg \"build working as the makefiles will be deleted on 2017-02-02. If you\"\n+    msg \"encounter bugs with rustbuild please file issues against rust-lang/rust\"\n+    msg \"\"\n+    msg \"run \\`make help\\`\"\n+fi\n+\n msg"}, {"sha": "d0b501e4d89697895bbc011af8dddacd295ee329", "filename": "src/bootstrap/README.md", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fbootstrap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fbootstrap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FREADME.md?ref=7846610470392abc3ab1470853bbe7b408fe4254", "patch": "@@ -66,17 +66,6 @@ The script accepts commands, flags, and filters to determine what to do:\n * `doc` - a command for building documentation. Like above can take arguments\n   for what to document.\n \n-If you're more used to `./configure` and `make`, however, then you can also\n-configure the build system to use rustbuild instead of the old makefiles:\n-\n-```\n-./configure --enable-rustbuild\n-make\n-```\n-\n-Afterwards the `Makefile` which is generated will have a few commands like\n-`make check`, `make tidy`, etc.\n-\n ## Configuring rustbuild\n \n There are currently two primary methods for configuring the rustbuild build\n@@ -90,6 +79,13 @@ be found at `src/bootstrap/config.toml.example`, and the configuration file\n can also be passed as `--config path/to/config.toml` if the build system is\n being invoked manually (via the python script).\n \n+Finally, rustbuild makes use of the [gcc-rs crate] which has [its own\n+method][env-vars] of configuring C compilers and C flags via environment\n+variables.\n+\n+[gcc-rs crate]: https://github.com/alexcrichton/gcc-rs\n+[env-vars]: https://github.com/alexcrichton/gcc-rs#external-configuration-via-environment-variables\n+\n ## Build stages\n \n The rustbuild build system goes through a few phases to actually build the\n@@ -273,16 +269,17 @@ After that, each module in rustbuild should have enough documentation to keep\n you up and running. Some general areas that you may be interested in modifying\n are:\n \n-* Adding a new build tool? Take a look at `build/step.rs` for examples of other\n-  tools, as well as `build/mod.rs`.\n+* Adding a new build tool? Take a look at `bootstrap/step.rs` for examples of\n+  other tools.\n * Adding a new compiler crate? Look no further! Adding crates can be done by\n   adding a new directory with `Cargo.toml` followed by configuring all\n   `Cargo.toml` files accordingly.\n * Adding a new dependency from crates.io? We're still working on that, so hold\n   off on that for now.\n-* Adding a new configuration option? Take a look at `build/config.rs` or perhaps\n-  `build/flags.rs` and then modify the build elsewhere to read that option.\n-* Adding a sanity check? Take a look at `build/sanity.rs`.\n+* Adding a new configuration option? Take a look at `bootstrap/config.rs` or\n+  perhaps `bootstrap/flags.rs` and then modify the build elsewhere to read that\n+  option.\n+* Adding a sanity check? Take a look at `bootstrap/sanity.rs`.\n \n If you have any questions feel free to reach out on `#rust-internals` on IRC or\n open an issue in the bug tracker!"}, {"sha": "0dda7f12007a4b281dd963dee9cd9d17b399fca3", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 67, "deletions": 26, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=7846610470392abc3ab1470853bbe7b408fe4254", "patch": "@@ -30,50 +30,60 @@ def get(url, path, verbose=False):\n         sha_path = sha_file.name\n \n     try:\n-        download(sha_path, sha_url, verbose)\n+        download(sha_path, sha_url, False, verbose)\n         if os.path.exists(path):\n             if verify(path, sha_path, False):\n-                print(\"using already-download file \" + path)\n+                if verbose:\n+                    print(\"using already-download file \" + path)\n                 return\n             else:\n-                print(\"ignoring already-download file \" + path + \" due to failed verification\")\n+                if verbose:\n+                    print(\"ignoring already-download file \" + path + \" due to failed verification\")\n                 os.unlink(path)\n-        download(temp_path, url, verbose)\n-        if not verify(temp_path, sha_path, True):\n+        download(temp_path, url, True, verbose)\n+        if not verify(temp_path, sha_path, verbose):\n             raise RuntimeError(\"failed verification\")\n-        print(\"moving {} to {}\".format(temp_path, path))\n+        if verbose:\n+            print(\"moving {} to {}\".format(temp_path, path))\n         shutil.move(temp_path, path)\n     finally:\n-        delete_if_present(sha_path)\n-        delete_if_present(temp_path)\n+        delete_if_present(sha_path, verbose)\n+        delete_if_present(temp_path, verbose)\n \n \n-def delete_if_present(path):\n+def delete_if_present(path, verbose):\n     if os.path.isfile(path):\n-        print(\"removing \" + path)\n+        if verbose:\n+            print(\"removing \" + path)\n         os.unlink(path)\n \n \n-def download(path, url, verbose):\n-    print(\"downloading {} to {}\".format(url, path))\n+def download(path, url, probably_big, verbose):\n+    if probably_big or verbose:\n+        print(\"downloading {}\".format(url))\n     # see http://serverfault.com/questions/301128/how-to-download\n     if sys.platform == 'win32':\n         run([\"PowerShell.exe\", \"/nologo\", \"-Command\",\n              \"(New-Object System.Net.WebClient)\"\n              \".DownloadFile('{}', '{}')\".format(url, path)],\n             verbose=verbose)\n     else:\n-        run([\"curl\", \"-o\", path, url], verbose=verbose)\n+        if probably_big or verbose:\n+            option = \"-#\"\n+        else:\n+            option = \"-s\"\n+        run([\"curl\", option, \"-Sf\", \"-o\", path, url], verbose=verbose)\n \n \n def verify(path, sha_path, verbose):\n-    print(\"verifying \" + path)\n+    if verbose:\n+        print(\"verifying \" + path)\n     with open(path, \"rb\") as f:\n         found = hashlib.sha256(f.read()).hexdigest()\n     with open(sha_path, \"r\") as f:\n         expected, _ = f.readline().split()\n     verified = found == expected\n-    if not verified and verbose:\n+    if not verified:\n         print(\"invalid checksum:\\n\"\n                \"    found:    {}\\n\"\n                \"    expected: {}\".format(found, expected))\n@@ -144,6 +154,7 @@ def download_stage0(self):\n \n         if self.rustc().startswith(self.bin_root()) and \\\n                 (not os.path.exists(self.rustc()) or self.rustc_out_of_date()):\n+            self.print_what_it_means_to_bootstrap()\n             if os.path.exists(self.bin_root()):\n                 shutil.rmtree(self.bin_root())\n             channel = self.stage0_rustc_channel()\n@@ -167,6 +178,7 @@ def download_stage0(self):\n \n         if self.cargo().startswith(self.bin_root()) and \\\n                 (not os.path.exists(self.cargo()) or self.cargo_out_of_date()):\n+            self.print_what_it_means_to_bootstrap()\n             channel = self.stage0_cargo_channel()\n             filename = \"cargo-{}-{}.tar.gz\".format(channel, self.build)\n             url = \"https://static.rust-lang.org/cargo-dist/\" + self.stage0_cargo_date()\n@@ -251,7 +263,27 @@ def exe_suffix(self):\n         else:\n             return ''\n \n+    def print_what_it_means_to_bootstrap(self):\n+        if hasattr(self, 'printed'):\n+            return\n+        self.printed = True\n+        if os.path.exists(self.bootstrap_binary()):\n+            return\n+        if not '--help' in sys.argv or len(sys.argv) == 1:\n+            return\n+\n+        print('info: the build system for Rust is written in Rust, so this')\n+        print('      script is now going to download a stage0 rust compiler')\n+        print('      and then compile the build system itself')\n+        print('')\n+        print('info: in the meantime you can read more about rustbuild at')\n+        print('      src/bootstrap/README.md before the download finishes')\n+\n+    def bootstrap_binary(self):\n+        return os.path.join(self.build_dir, \"bootstrap/debug/bootstrap\")\n+\n     def build_bootstrap(self):\n+        self.print_what_it_means_to_bootstrap()\n         build_dir = os.path.join(self.build_dir, \"bootstrap\")\n         if self.clean and os.path.exists(build_dir):\n             shutil.rmtree(build_dir)\n@@ -408,22 +440,31 @@ def main():\n     rb.use_vendored_sources = '\\nvendor = true' in rb.config_toml or \\\n                               'CFG_ENABLE_VENDOR' in rb.config_mk\n \n+    if 'SUDO_USER' in os.environ:\n+        if os.environ['USER'] != os.environ['SUDO_USER']:\n+            rb.use_vendored_sources = True\n+            print('info: looks like you are running this command under `sudo`')\n+            print('      and so in order to preserve your $HOME this will now')\n+            print('      use vendored sources by default. Note that if this')\n+            print('      does not work you should run a normal build first')\n+            print('      before running a command like `sudo make intall`')\n+\n     if rb.use_vendored_sources:\n         if not os.path.exists('.cargo'):\n             os.makedirs('.cargo')\n-        f = open('.cargo/config','w')\n-        f.write(\"\"\"\n-            [source.crates-io]\n-            replace-with = 'vendored-sources'\n-            registry = 'https://example.com'\n-\n-            [source.vendored-sources]\n-            directory = '{}/src/vendor'\n-        \"\"\".format(rb.rust_root))\n-        f.close()\n+        with open('.cargo/config','w') as f:\n+            f.write(\"\"\"\n+                [source.crates-io]\n+                replace-with = 'vendored-sources'\n+                registry = 'https://example.com'\n+\n+                [source.vendored-sources]\n+                directory = '{}/src/vendor'\n+            \"\"\".format(rb.rust_root))\n     else:\n         if os.path.exists('.cargo'):\n             shutil.rmtree('.cargo')\n+\n     data = stage0_data(rb.rust_root)\n     rb._rustc_channel, rb._rustc_date = data['rustc'].split('-', 1)\n     rb._cargo_channel, rb._cargo_date = data['cargo'].split('-', 1)\n@@ -438,7 +479,7 @@ def main():\n     sys.stdout.flush()\n \n     # Run the bootstrap\n-    args = [os.path.join(rb.build_dir, \"bootstrap/debug/bootstrap\")]\n+    args = [rb.bootstrap_binary()]\n     args.extend(sys.argv[1:])\n     env = os.environ.copy()\n     env[\"BUILD\"] = rb.build"}, {"sha": "aa70e24d95222ee5d608d9a887927e957ef919d9", "filename": "src/bootstrap/cc.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fbootstrap%2Fcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fbootstrap%2Fcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc.rs?ref=7846610470392abc3ab1470853bbe7b408fe4254", "patch": "@@ -51,7 +51,7 @@ pub fn find(build: &mut Build) {\n         if let Some(cc) = config.and_then(|c| c.cc.as_ref()) {\n             cfg.compiler(cc);\n         } else {\n-            set_compiler(&mut cfg, \"gcc\", target, config);\n+            set_compiler(&mut cfg, \"gcc\", target, config, build);\n         }\n \n         let compiler = cfg.get_compiler();\n@@ -72,7 +72,7 @@ pub fn find(build: &mut Build) {\n         if let Some(cxx) = config.and_then(|c| c.cxx.as_ref()) {\n             cfg.compiler(cxx);\n         } else {\n-            set_compiler(&mut cfg, \"g++\", host, config);\n+            set_compiler(&mut cfg, \"g++\", host, config, build);\n         }\n         let compiler = cfg.get_compiler();\n         build.verbose(&format!(\"CXX_{} = {:?}\", host, compiler.path()));\n@@ -83,7 +83,8 @@ pub fn find(build: &mut Build) {\n fn set_compiler(cfg: &mut gcc::Config,\n                 gnu_compiler: &str,\n                 target: &str,\n-                config: Option<&Target>) {\n+                config: Option<&Target>,\n+                build: &Build) {\n     match target {\n         // When compiling for android we may have the NDK configured in the\n         // config.toml in which case we look there. Otherwise the default\n@@ -119,6 +120,22 @@ fn set_compiler(cfg: &mut gcc::Config,\n             }\n         }\n \n+        \"mips-unknown-linux-musl\" => {\n+            cfg.compiler(\"mips-linux-musl-gcc\");\n+        }\n+        \"mipsel-unknown-linux-musl\" => {\n+            cfg.compiler(\"mipsel-linux-musl-gcc\");\n+        }\n+\n+        t if t.contains(\"musl\") => {\n+            if let Some(root) = build.musl_root(target) {\n+                let guess = root.join(\"bin/musl-gcc\");\n+                if guess.exists() {\n+                    cfg.compiler(guess);\n+                }\n+            }\n+        }\n+\n         _ => {}\n     }\n }"}, {"sha": "c5675fd46cbe07f4cedfeb0bed4047ab439eb424", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=7846610470392abc3ab1470853bbe7b408fe4254", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Implementation of the various `check-*` targets of the build system.\n+//! Implementation of the test-related targets of the build system.\n //!\n //! This file implements the various regression test suites that we execute on\n //! our CI.\n@@ -62,6 +62,8 @@ impl fmt::Display for TestKind {\n pub fn linkcheck(build: &Build, stage: u32, host: &str) {\n     println!(\"Linkcheck stage{} ({})\", stage, host);\n     let compiler = Compiler::new(stage, host);\n+\n+    let _time = util::timeit();\n     build.run(build.tool_cmd(&compiler, \"linkchecker\")\n                    .arg(build.out.join(host).join(\"doc\")));\n }\n@@ -87,6 +89,7 @@ pub fn cargotest(build: &Build, stage: u32, host: &str) {\n     let out_dir = build.out.join(\"ct\");\n     t!(fs::create_dir_all(&out_dir));\n \n+    let _time = util::timeit();\n     build.run(build.tool_cmd(compiler, \"cargotest\")\n                    .env(\"PATH\", newpath)\n                    .arg(&build.cargo)\n@@ -119,7 +122,8 @@ pub fn compiletest(build: &Build,\n                    target: &str,\n                    mode: &str,\n                    suite: &str) {\n-    println!(\"Check compiletest {} ({} -> {})\", suite, compiler.host, target);\n+    println!(\"Check compiletest suite={} mode={} ({} -> {})\",\n+             suite, mode, compiler.host, target);\n     let mut cmd = build.tool_cmd(compiler, \"compiletest\");\n \n     // compiletest currently has... a lot of arguments, so let's just pass all\n@@ -213,6 +217,9 @@ pub fn compiletest(build: &Build,\n \n     // Running a C compiler on MSVC requires a few env vars to be set, to be\n     // sure to set them here.\n+    //\n+    // Note that if we encounter `PATH` we make sure to append to our own `PATH`\n+    // rather than stomp over it.\n     if target.contains(\"msvc\") {\n         for &(ref k, ref v) in build.cc[target].0.env() {\n             if k != \"PATH\" {\n@@ -221,6 +228,7 @@ pub fn compiletest(build: &Build,\n         }\n     }\n     cmd.env(\"RUSTC_BOOTSTRAP\", \"1\");\n+    build.add_rust_test_threads(&mut cmd);\n \n     cmd.arg(\"--adb-path\").arg(\"adb\");\n     cmd.arg(\"--adb-test-dir\").arg(ADB_TEST_DIR);\n@@ -232,6 +240,7 @@ pub fn compiletest(build: &Build,\n         cmd.arg(\"--android-cross-path\").arg(\"\");\n     }\n \n+    let _time = util::timeit();\n     build.run(&mut cmd);\n }\n \n@@ -244,6 +253,7 @@ pub fn docs(build: &Build, compiler: &Compiler) {\n     // Do a breadth-first traversal of the `src/doc` directory and just run\n     // tests for all files that end in `*.md`\n     let mut stack = vec![build.src.join(\"src/doc\")];\n+    let _time = util::timeit();\n \n     while let Some(p) = stack.pop() {\n         if p.is_dir() {\n@@ -272,6 +282,8 @@ pub fn error_index(build: &Build, compiler: &Compiler) {\n     let dir = testdir(build, compiler.host);\n     t!(fs::create_dir_all(&dir));\n     let output = dir.join(\"error-index.md\");\n+\n+    let _time = util::timeit();\n     build.run(build.tool_cmd(compiler, \"error_index_generator\")\n                    .arg(\"markdown\")\n                    .arg(&output)\n@@ -283,6 +295,7 @@ pub fn error_index(build: &Build, compiler: &Compiler) {\n fn markdown_test(build: &Build, compiler: &Compiler, markdown: &Path) {\n     let mut cmd = Command::new(build.rustdoc(compiler));\n     build.add_rustc_lib_path(compiler, &mut cmd);\n+    build.add_rust_test_threads(&mut cmd);\n     cmd.arg(\"--test\");\n     cmd.arg(markdown);\n \n@@ -366,16 +379,25 @@ pub fn krate(build: &Build,\n     dylib_path.insert(0, build.sysroot_libdir(compiler, target));\n     cargo.env(dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n \n+    if target.contains(\"android\") {\n+        cargo.arg(\"--no-run\");\n+    } else if target.contains(\"emscripten\") {\n+        cargo.arg(\"--no-run\");\n+    }\n+\n+    cargo.arg(\"--\");\n+\n     if build.config.quiet_tests {\n-        cargo.arg(\"--\");\n         cargo.arg(\"--quiet\");\n     }\n \n+    let _time = util::timeit();\n+\n     if target.contains(\"android\") {\n-        build.run(cargo.arg(\"--no-run\"));\n+        build.run(&mut cargo);\n         krate_android(build, compiler, target, mode);\n     } else if target.contains(\"emscripten\") {\n-        build.run(cargo.arg(\"--no-run\"));\n+        build.run(&mut cargo);\n         krate_emscripten(build, compiler, target, mode);\n     } else {\n         cargo.args(&build.flags.cmd.test_args());\n@@ -402,14 +424,17 @@ fn krate_android(build: &Build,\n                           target,\n                           compiler.host,\n                           test_file_name);\n+        let quiet = if build.config.quiet_tests { \"--quiet\" } else { \"\" };\n         let program = format!(\"(cd {dir}; \\\n                                 LD_LIBRARY_PATH=./{target} ./{test} \\\n                                     --logfile {log} \\\n+                                    {quiet} \\\n                                     {args})\",\n                               dir = ADB_TEST_DIR,\n                               target = target,\n                               test = test_file_name,\n                               log = log,\n+                              quiet = quiet,\n                               args = build.flags.cmd.test_args().join(\" \"));\n \n         let output = output(Command::new(\"adb\").arg(\"shell\").arg(&program));\n@@ -438,18 +463,13 @@ fn krate_emscripten(build: &Build,\n          let test_file_name = test.to_string_lossy().into_owned();\n          println!(\"running {}\", test_file_name);\n          let nodejs = build.config.nodejs.as_ref().expect(\"nodejs not configured\");\n-         let status = Command::new(nodejs)\n-             .arg(&test_file_name)\n-             .stderr(::std::process::Stdio::inherit())\n-             .status();\n-         match status {\n-             Ok(status) => {\n-                 if !status.success() {\n-                     panic!(\"some tests failed\");\n-                 }\n-             }\n-             Err(e) => panic!(format!(\"failed to execute command: {}\", e)),\n-         };\n+         let mut cmd = Command::new(nodejs);\n+         cmd.arg(&test_file_name)\n+            .stderr(::std::process::Stdio::inherit());\n+         if build.config.quiet_tests {\n+             cmd.arg(\"--quiet\");\n+         }\n+         build.run(&mut cmd);\n      }\n  }\n "}, {"sha": "e7655458aed8a71128437a1ff921b5bfa39a3417", "filename": "src/bootstrap/clean.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fbootstrap%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fbootstrap%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fclean.rs?ref=7846610470392abc3ab1470853bbe7b408fe4254", "patch": "@@ -46,6 +46,9 @@ fn rm_rf(build: &Build, path: &Path) {\n     if !path.exists() {\n         return\n     }\n+    if path.is_file() {\n+        return do_op(path, \"remove file\", |p| fs::remove_file(p));\n+    }\n \n     for file in t!(fs::read_dir(path)) {\n         let file = t!(file).path();"}, {"sha": "7a2d56fc5d3cc87dbea07c046e2fffba709b6261", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=7846610470392abc3ab1470853bbe7b408fe4254", "patch": "@@ -239,6 +239,7 @@ To learn more about a subcommand, run `./x.py <command> -h`\n                     install: m.opt_present(\"install\"),\n                 }\n             }\n+            \"--help\" => usage(0, &opts),\n             cmd => {\n                 println!(\"unknown command: {}\", cmd);\n                 usage(1, &opts);"}, {"sha": "912b5864c818bfc25c561b632fe813857c05520a", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 91, "deletions": 5, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=7846610470392abc3ab1470853bbe7b408fe4254", "patch": "@@ -13,9 +13,56 @@\n //! This module, and its descendants, are the implementation of the Rust build\n //! system. Most of this build system is backed by Cargo but the outer layer\n //! here serves as the ability to orchestrate calling Cargo, sequencing Cargo\n-//! builds, building artifacts like LLVM, etc.\n+//! builds, building artifacts like LLVM, etc. The goals of rustbuild are:\n //!\n-//! More documentation can be found in each respective module below.\n+//! * To be an easily understandable, easily extensible, and maintainable build\n+//!   system.\n+//! * Leverage standard tools in the Rust ecosystem to build the compiler, aka\n+//!   crates.io and Cargo.\n+//! * A standard interface to build across all platforms, including MSVC\n+//!\n+//! ## Architecture\n+//!\n+//! Although this build system defers most of the complicated logic to Cargo\n+//! itself, it still needs to maintain a list of targets and dependencies which\n+//! it can itself perform. Rustbuild is made up of a list of rules with\n+//! dependencies amongst them (created in the `step` module) and then knows how\n+//! to execute each in sequence. Each time rustbuild is invoked, it will simply\n+//! iterate through this list of steps and execute each serially in turn.  For\n+//! each step rustbuild relies on the step internally being incremental and\n+//! parallel. Note, though, that the `-j` parameter to rustbuild gets forwarded\n+//! to appropriate test harnesses and such.\n+//!\n+//! Most of the \"meaty\" steps that matter are backed by Cargo, which does indeed\n+//! have its own parallelism and incremental management. Later steps, like\n+//! tests, aren't incremental and simply run the entire suite currently.\n+//!\n+//! When you execute `x.py build`, the steps which are executed are:\n+//!\n+//! * First, the python script is run. This will automatically download the\n+//!   stage0 rustc and cargo according to `src/stage0.txt`, or using the cached\n+//!   versions if they're available. These are then used to compile rustbuild\n+//!   itself (using Cargo). Finally, control is then transferred to rustbuild.\n+//!\n+//! * Rustbuild takes over, performs sanity checks, probes the environment,\n+//!   reads configuration, builds up a list of steps, and then starts executing\n+//!   them.\n+//!\n+//! * The stage0 libstd is compiled\n+//! * The stage0 libtest is compiled\n+//! * The stage0 librustc is compiled\n+//! * The stage1 compiler is assembled\n+//! * The stage1 libstd, libtest, librustc are compiled\n+//! * The stage2 compiler is assembled\n+//! * The stage2 libstd, libtest, librustc are compiled\n+//!\n+//! Each step is driven by a separate Cargo project and rustbuild orchestrates\n+//! copying files between steps and otherwise preparing for Cargo to run.\n+//!\n+//! ## Further information\n+//!\n+//! More documentation can be found in each respective module below, and you can\n+//! also check out the `src/bootstrap/README.md` file for more information.\n \n extern crate build_helper;\n extern crate cmake;\n@@ -28,6 +75,7 @@ extern crate toml;\n \n use std::collections::HashMap;\n use std::env;\n+use std::ffi::OsString;\n use std::fs::{self, File};\n use std::path::{Component, PathBuf, Path};\n use std::process::Command;\n@@ -128,6 +176,7 @@ pub struct Build {\n     cc: HashMap<String, (gcc::Tool, Option<PathBuf>)>,\n     cxx: HashMap<String, gcc::Tool>,\n     crates: HashMap<String, Crate>,\n+    is_sudo: bool,\n }\n \n #[derive(Debug)]\n@@ -187,6 +236,16 @@ impl Build {\n         };\n         let local_rebuild = config.local_rebuild;\n \n+        let is_sudo = match env::var_os(\"SUDO_USER\") {\n+            Some(sudo_user) => {\n+                match env::var_os(\"USER\") {\n+                    Some(user) => user != sudo_user,\n+                    None => false,\n+                }\n+            }\n+            None => false,\n+        };\n+\n         Build {\n             flags: flags,\n             config: config,\n@@ -208,6 +267,7 @@ impl Build {\n             crates: HashMap::new(),\n             lldb_version: None,\n             lldb_python_dir: None,\n+            is_sudo: is_sudo,\n         }\n     }\n \n@@ -414,7 +474,7 @@ impl Build {\n         // how the actual compiler itself is called.\n         //\n         // These variables are primarily all read by\n-        // src/bootstrap/{rustc,rustdoc.rs}\n+        // src/bootstrap/bin/{rustc.rs,rustdoc.rs}\n         cargo.env(\"RUSTC\", self.out.join(\"bootstrap/debug/rustc\"))\n              .env(\"RUSTC_REAL\", self.compiler_path(compiler))\n              .env(\"RUSTC_STAGE\", stage.to_string())\n@@ -435,6 +495,7 @@ impl Build {\n \n         // Enable usage of unstable features\n         cargo.env(\"RUSTC_BOOTSTRAP\", \"1\");\n+        self.add_rust_test_threads(&mut cargo);\n \n         // Specify some various options for build scripts used throughout\n         // the build.\n@@ -458,7 +519,7 @@ impl Build {\n         if self.config.rust_optimize && cmd != \"bench\" {\n             cargo.arg(\"--release\");\n         }\n-        if self.config.vendor {\n+        if self.config.vendor || self.is_sudo {\n             cargo.arg(\"--frozen\");\n         }\n         return cargo\n@@ -492,12 +553,30 @@ impl Build {\n     fn tool_cmd(&self, compiler: &Compiler, tool: &str) -> Command {\n         let mut cmd = Command::new(self.tool(&compiler, tool));\n         let host = compiler.host;\n-        let paths = vec![\n+        let mut paths = vec![\n             self.cargo_out(compiler, Mode::Libstd, host).join(\"deps\"),\n             self.cargo_out(compiler, Mode::Libtest, host).join(\"deps\"),\n             self.cargo_out(compiler, Mode::Librustc, host).join(\"deps\"),\n             self.cargo_out(compiler, Mode::Tool, host).join(\"deps\"),\n         ];\n+\n+        // On MSVC a tool may invoke a C compiler (e.g. compiletest in run-make\n+        // mode) and that C compiler may need some extra PATH modification. Do\n+        // so here.\n+        if compiler.host.contains(\"msvc\") {\n+            let curpaths = env::var_os(\"PATH\").unwrap_or(OsString::new());\n+            let curpaths = env::split_paths(&curpaths).collect::<Vec<_>>();\n+            for &(ref k, ref v) in self.cc[compiler.host].0.env() {\n+                if k != \"PATH\" {\n+                    continue\n+                }\n+                for path in env::split_paths(v) {\n+                    if !curpaths.contains(&path) {\n+                        paths.push(path);\n+                    }\n+                }\n+            }\n+        }\n         add_lib_path(paths, &mut cmd);\n         return cmd\n     }\n@@ -651,6 +730,13 @@ impl Build {\n         add_lib_path(vec![self.rustc_libdir(compiler)], cmd);\n     }\n \n+    /// Adds the `RUST_TEST_THREADS` env var if necessary\n+    fn add_rust_test_threads(&self, cmd: &mut Command) {\n+        if env::var_os(\"RUST_TEST_THREADS\").is_none() {\n+            cmd.env(\"RUST_TEST_THREADS\", self.jobs().to_string());\n+        }\n+    }\n+\n     /// Returns the compiler's libdir where it stores the dynamic libraries that\n     /// it itself links against.\n     ///"}, {"sha": "b165048b7b6c76ea7b781f677bbd955133b60522", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=7846610470392abc3ab1470853bbe7b408fe4254", "patch": "@@ -23,9 +23,14 @@ all:\n \t$(Q)$(BOOTSTRAP) build $(BOOTSTRAP_ARGS)\n \t$(Q)$(BOOTSTRAP) doc $(BOOTSTRAP_ARGS)\n \n-# Don\u2019t use $(Q) here, always show how to invoke the bootstrap script directly\n help:\n-\t$(BOOTSTRAP) --help\n+\t$(Q)echo 'Welcome to the rustbuild build system!'\n+\t$(Q)echo\n+\t$(Q)echo This makefile is a thin veneer over the ./x.py script located\n+\t$(Q)echo in this directory. To get the full power of the build system\n+\t$(Q)echo you can run x.py directly.\n+\t$(Q)echo\n+\t$(Q)echo To learn more run \\`./x.py --help\\`\n \n clean:\n \t$(Q)$(BOOTSTRAP) clean $(BOOTSTRAP_ARGS)\n@@ -51,15 +56,14 @@ check-cargotest:\n dist:\n \t$(Q)$(BOOTSTRAP) dist $(BOOTSTRAP_ARGS)\n install:\n-ifeq (root user, $(USER) $(patsubst %,user,$(SUDO_USER)))\n-\t$(Q)echo \"'sudo make install' is not supported currently.\"\n-else\n \t$(Q)$(BOOTSTRAP) dist --install $(BOOTSTRAP_ARGS)\n-endif\n tidy:\n \t$(Q)$(BOOTSTRAP) test src/tools/tidy $(BOOTSTRAP_ARGS) --stage 0\n \n-check-stage2-android:\n-\t$(Q)$(BOOTSTRAP) --step check-target --target arm-linux-androideabi\n+check-stage2-T-arm-linux-androideabi-H-x86_64-unknown-linux-gnu:\n+\t$(Q)$(BOOTSTRAP) test --target arm-linux-androideabi\n+check-stage2-T-x86_64-unknown-linux-musl-H-x86_64-unknown-linux-gnu:\n+\t$(Q)$(BOOTSTRAP) test --target x86_64-unknown-linux-gnu\n+\n \n .PHONY: dist"}, {"sha": "ffa3fe1cbf2fd54d10af32fc9a47a7c0b18fce5b", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=7846610470392abc3ab1470853bbe7b408fe4254", "patch": "@@ -28,7 +28,7 @@ use cmake;\n use gcc;\n \n use Build;\n-use util::up_to_date;\n+use util::{self, up_to_date};\n \n /// Compile LLVM for `target`.\n pub fn llvm(build: &Build, target: &str) {\n@@ -58,6 +58,7 @@ pub fn llvm(build: &Build, target: &str) {\n \n     println!(\"Building LLVM for {}\", target);\n \n+    let _time = util::timeit();\n     let _ = fs::remove_dir_all(&dst.join(\"build\"));\n     t!(fs::create_dir_all(&dst.join(\"build\")));\n     let assertions = if build.config.llvm_assertions {\"ON\"} else {\"OFF\"};\n@@ -158,6 +159,17 @@ pub fn test_helpers(build: &Build, target: &str) {\n     println!(\"Building test helpers\");\n     t!(fs::create_dir_all(&dst));\n     let mut cfg = gcc::Config::new();\n+\n+    // We may have found various cross-compilers a little differently due to our\n+    // extra configuration, so inform gcc of these compilers. Note, though, that\n+    // on MSVC we still need gcc's detection of env vars (ugh).\n+    if !target.contains(\"msvc\") {\n+        if let Some(ar) = build.ar(target) {\n+            cfg.archiver(ar);\n+        }\n+        cfg.compiler(build.cc(target));\n+    }\n+\n     cfg.cargo_metadata(false)\n        .out_dir(&dst)\n        .target(target)"}, {"sha": "f3fe22698bb9099bffd8683f15a308944680db30", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=7846610470392abc3ab1470853bbe7b408fe4254", "patch": "@@ -41,10 +41,14 @@ pub fn check(build: &mut Build) {\n         }\n     }\n     let have_cmd = |cmd: &OsStr| {\n-        for path in env::split_paths(&path).map(|p| p.join(cmd)) {\n-            if fs::metadata(&path).is_ok() ||\n-               fs::metadata(path.with_extension(\"exe\")).is_ok() {\n-                return Some(path);\n+        for path in env::split_paths(&path) {\n+            let target = path.join(cmd);\n+            let mut cmd_alt = cmd.to_os_string();\n+            cmd_alt.push(\".exe\");\n+            if target.exists() ||\n+               target.with_extension(\"exe\").exists() ||\n+               target.join(cmd_alt).exists() {\n+                return Some(target);\n             }\n         }\n         return None;"}, {"sha": "ca169bd146ccb16050c6afc8dea7ebbbe96ef042", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 234, "deletions": 62, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=7846610470392abc3ab1470853bbe7b408fe4254", "patch": "@@ -8,6 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Definition of steps of the build system.\n+//!\n+//! This is where some of the real meat of rustbuild is located, in how we\n+//! define targets and the dependencies amongst them. This file can sort of be\n+//! viewed as just defining targets in a makefile which shell out to predefined\n+//! functions elsewhere about how to execute the target.\n+//!\n+//! The primary function here you're likely interested in is the `build_rules`\n+//! function. This will create a `Rules` structure which basically just lists\n+//! everything that rustbuild can do. Each rule has a human-readable name, a\n+//! path associated with it, some dependencies, and then a closure of how to\n+//! actually perform the rule.\n+//!\n+//! All steps below are defined in self-contained units, so adding a new target\n+//! to the build system should just involve adding the meta information here\n+//! along with the actual implementation elsewhere. You can find more comments\n+//! about how to define rules themselves below.\n+\n use std::collections::{HashMap, HashSet};\n use std::mem;\n \n@@ -20,51 +38,98 @@ use install;\n use native;\n use {Compiler, Build, Mode};\n \n-#[derive(PartialEq, Eq, Hash, Clone, Debug)]\n-struct Step<'a> {\n-    name: &'a str,\n-    stage: u32,\n-    host: &'a str,\n-    target: &'a str,\n-}\n-\n-impl<'a> Step<'a> {\n-    fn name(&self, name: &'a str) -> Step<'a> {\n-        Step { name: name, ..*self }\n-    }\n-\n-    fn stage(&self, stage: u32) -> Step<'a> {\n-        Step { stage: stage, ..*self }\n-    }\n-\n-    fn host(&self, host: &'a str) -> Step<'a> {\n-        Step { host: host, ..*self }\n-    }\n-\n-    fn target(&self, target: &'a str) -> Step<'a> {\n-        Step { target: target, ..*self }\n-    }\n-\n-    fn compiler(&self) -> Compiler<'a> {\n-        Compiler::new(self.stage, self.host)\n-    }\n-}\n-\n pub fn run(build: &Build) {\n     let rules = build_rules(build);\n     let steps = rules.plan();\n     rules.run(&steps);\n }\n \n pub fn build_rules(build: &Build) -> Rules {\n-    let mut rules: Rules = Rules::new(build);\n+    let mut rules = Rules::new(build);\n+\n+    // This is the first rule that we're going to define for rustbuild, which is\n+    // used to compile LLVM itself. All rules are added through the `rules`\n+    // structure created above and are configured through a builder-style\n+    // interface.\n+    //\n+    // First up we see the `build` method. This represents a rule that's part of\n+    // the top-level `build` subcommand. For example `./x.py build` is what this\n+    // is associating with. Note that this is normally only relevant if you flag\n+    // a rule as `default`, which we'll talk about later.\n+    //\n+    // Next up we'll see two arguments to this method:\n+    //\n+    // * `llvm` - this is the \"human readable\" name of this target. This name is\n+    //            not accessed anywhere outside this file itself (e.g. not in\n+    //            the CLI nor elsewhere in rustbuild). The purpose of this is to\n+    //            easily define dependencies between rules. That is, other rules\n+    //            will depend on this with the name \"llvm\".\n+    // * `src/llvm` - this is the relevant path to the rule that we're working\n+    //                with. This path is the engine behind how commands like\n+    //                `./x.py build src/llvm` work. This should typically point\n+    //                to the relevant component, but if there's not really a\n+    //                path to be assigned here you can pass something like\n+    //                `path/to/nowhere` to ignore it.\n+    //\n+    // After we create the rule with the `build` method we can then configure\n+    // various aspects of it. For example this LLVM rule uses `.host(true)` to\n+    // flag that it's a rule only for host targets. In other words, LLVM isn't\n+    // compiled for targets configured through `--target` (e.g. those we're just\n+    // building a standard library for).\n+    //\n+    // Next up the `dep` method will add a dependency to this rule. The closure\n+    // is yielded the step that represents executing the `llvm` rule itself\n+    // (containing information like stage, host, target, ...) and then it must\n+    // return a target that the step depends on. Here LLVM is actually\n+    // interesting where a cross-compiled LLVM depends on the host LLVM, but\n+    // otherwise it has no dependencies.\n+    //\n+    // To handle this we do a bit of dynamic dispatch to see what the dependency\n+    // is. If we're building a LLVM for the build triple, then we don't actually\n+    // have any dependencies! To do that we return a dependency on the \"dummy\"\n+    // target which does nothing.\n+    //\n+    // If we're build a cross-compiled LLVM, however, we need to assemble the\n+    // libraries from the previous compiler. This step has the same name as\n+    // ours (llvm) but we want it for a different target, so we use the\n+    // builder-style methods on `Step` to configure this target to the build\n+    // triple.\n+    //\n+    // Finally, to finish off this rule, we define how to actually execute it.\n+    // That logic is all defined in the `native` module so we just delegate to\n+    // the relevant function there. The argument to the closure passed to `run`\n+    // is a `Step` (defined below) which encapsulates information like the\n+    // stage, target, host, etc.\n+    rules.build(\"llvm\", \"src/llvm\")\n+         .host(true)\n+         .dep(move |s| {\n+             if s.target == build.config.build {\n+                 dummy(s, build)\n+             } else {\n+                 s.target(&build.config.build)\n+             }\n+         })\n+         .run(move |s| native::llvm(build, s.target));\n+\n+    // Ok! After that example rule  that's hopefully enough to explain what's\n+    // going on here. You can check out the API docs below and also see a bunch\n+    // more examples of rules directly below as well.\n+\n     // dummy rule to do nothing, useful when a dep maps to no deps\n     rules.build(\"dummy\", \"path/to/nowhere\");\n-    fn dummy<'a>(s: &Step<'a>, build: &'a Build) -> Step<'a> {\n-        s.name(\"dummy\").stage(0)\n-         .target(&build.config.build)\n-         .host(&build.config.build)\n-    }\n+\n+    // the compiler with no target libraries ready to go\n+    rules.build(\"rustc\", \"src/rustc\")\n+         .dep(move |s| {\n+             if s.stage == 0 {\n+                 dummy(s, build)\n+             } else {\n+                 s.name(\"librustc\")\n+                  .host(&build.config.build)\n+                  .stage(s.stage - 1)\n+             }\n+         })\n+         .run(move |s| compile::assemble_rustc(build, s.stage, s.target));\n \n     // Helper for loading an entire DAG of crates, rooted at `name`\n     let krates = |name: &str| {\n@@ -85,28 +150,6 @@ pub fn build_rules(build: &Build) -> Rules {\n         return ret\n     };\n \n-    rules.build(\"rustc\", \"path/to/nowhere\")\n-         .dep(move |s| {\n-             if s.stage == 0 {\n-                 dummy(s, build)\n-             } else {\n-                 s.name(\"librustc\")\n-                  .host(&build.config.build)\n-                  .stage(s.stage - 1)\n-             }\n-         })\n-         .run(move |s| compile::assemble_rustc(build, s.stage, s.target));\n-    rules.build(\"llvm\", \"src/llvm\")\n-         .host(true)\n-         .dep(move |s| {\n-             if s.target == build.config.build {\n-                 dummy(s, build)\n-             } else {\n-                 s.target(&build.config.build)\n-             }\n-         })\n-         .run(move |s| native::llvm(build, s.target));\n-\n     // ========================================================================\n     // Crate compilations\n     //\n@@ -337,10 +380,10 @@ pub fn build_rules(build: &Build) -> Rules {\n          .host(true)\n          .run(move |s| check::cargotest(build, s.stage, s.target));\n     rules.test(\"check-tidy\", \"src/tools/tidy\")\n-         .dep(|s| s.name(\"tool-tidy\"))\n+         .dep(|s| s.name(\"tool-tidy\").stage(0))\n          .default(true)\n          .host(true)\n-         .run(move |s| check::tidy(build, s.stage, s.target));\n+         .run(move |s| check::tidy(build, 0, s.target));\n     rules.test(\"check-error-index\", \"src/tools/error_index_generator\")\n          .dep(|s| s.name(\"libstd\"))\n          .dep(|s| s.name(\"tool-error-index\").host(s.host))\n@@ -457,16 +500,89 @@ pub fn build_rules(build: &Build) -> Rules {\n          .run(move |s| install::install(build, s.stage, s.target));\n \n     rules.verify();\n-    return rules\n+    return rules;\n+\n+    fn dummy<'a>(s: &Step<'a>, build: &'a Build) -> Step<'a> {\n+        s.name(\"dummy\").stage(0)\n+         .target(&build.config.build)\n+         .host(&build.config.build)\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Hash, Clone, Debug)]\n+struct Step<'a> {\n+    /// Human readable name of the rule this step is executing. Possible names\n+    /// are all defined above in `build_rules`.\n+    name: &'a str,\n+\n+    /// The stage this step is executing in. This is typically 0, 1, or 2.\n+    stage: u32,\n+\n+    /// This step will likely involve a compiler, and the target that compiler\n+    /// itself is built for is called the host, this variable. Typically this is\n+    /// the target of the build machine itself.\n+    host: &'a str,\n+\n+    /// The target that this step represents generating. If you're building a\n+    /// standard library for a new suite of targets, for example, this'll be set\n+    /// to those targets.\n+    target: &'a str,\n+}\n+\n+impl<'a> Step<'a> {\n+    /// Creates a new step which is the same as this, except has a new name.\n+    fn name(&self, name: &'a str) -> Step<'a> {\n+        Step { name: name, ..*self }\n+    }\n+\n+    /// Creates a new step which is the same as this, except has a new stage.\n+    fn stage(&self, stage: u32) -> Step<'a> {\n+        Step { stage: stage, ..*self }\n+    }\n+\n+    /// Creates a new step which is the same as this, except has a new host.\n+    fn host(&self, host: &'a str) -> Step<'a> {\n+        Step { host: host, ..*self }\n+    }\n+\n+    /// Creates a new step which is the same as this, except has a new target.\n+    fn target(&self, target: &'a str) -> Step<'a> {\n+        Step { target: target, ..*self }\n+    }\n+\n+    /// Returns the `Compiler` structure that this step corresponds to.\n+    fn compiler(&self) -> Compiler<'a> {\n+        Compiler::new(self.stage, self.host)\n+    }\n }\n \n struct Rule<'a> {\n+    /// The human readable name of this target, defined in `build_rules`.\n     name: &'a str,\n+\n+    /// The path associated with this target, used in the `./x.py` driver for\n+    /// easy and ergonomic specification of what to do.\n     path: &'a str,\n+\n+    /// The \"kind\" of top-level command that this rule is associated with, only\n+    /// relevant if this is a default rule.\n     kind: Kind,\n+\n+    /// List of dependencies this rule has. Each dependency is a function from a\n+    /// step that's being executed to another step that should be executed.\n     deps: Vec<Box<Fn(&Step<'a>) -> Step<'a> + 'a>>,\n+\n+    /// How to actually execute this rule. Takes a step with contextual\n+    /// information and then executes it.\n     run: Box<Fn(&Step<'a>) + 'a>,\n+\n+    /// Whether or not this is a \"default\" rule. That basically means that if\n+    /// you run, for example, `./x.py test` whether it's included or not.\n     default: bool,\n+\n+    /// Whether or not this is a \"host\" rule, or in other words whether this is\n+    /// only intended for compiler hosts and not for targets that are being\n+    /// generated.\n     host: bool,\n }\n \n@@ -493,6 +609,8 @@ impl<'a> Rule<'a> {\n     }\n }\n \n+/// Builder pattern returned from the various methods on `Rules` which will add\n+/// the rule to the internal list on `Drop`.\n struct RuleBuilder<'a: 'b, 'b> {\n     rules: &'b mut Rules<'a>,\n     rule: Rule<'a>,\n@@ -554,26 +672,35 @@ impl<'a> Rules<'a> {\n         }\n     }\n \n+    /// Creates a new rule of `Kind::Build` with the specified human readable\n+    /// name and path associated with it.\n+    ///\n+    /// The builder returned should be configured further with information such\n+    /// as how to actually run this rule.\n     fn build<'b>(&'b mut self, name: &'a str, path: &'a str)\n                  -> RuleBuilder<'a, 'b> {\n         self.rule(name, path, Kind::Build)\n     }\n \n+    /// Same as `build`, but for `Kind::Test`.\n     fn test<'b>(&'b mut self, name: &'a str, path: &'a str)\n                 -> RuleBuilder<'a, 'b> {\n         self.rule(name, path, Kind::Test)\n     }\n \n+    /// Same as `build`, but for `Kind::Bench`.\n     fn bench<'b>(&'b mut self, name: &'a str, path: &'a str)\n                 -> RuleBuilder<'a, 'b> {\n         self.rule(name, path, Kind::Bench)\n     }\n \n+    /// Same as `build`, but for `Kind::Doc`.\n     fn doc<'b>(&'b mut self, name: &'a str, path: &'a str)\n                -> RuleBuilder<'a, 'b> {\n         self.rule(name, path, Kind::Doc)\n     }\n \n+    /// Same as `build`, but for `Kind::Dist`.\n     fn dist<'b>(&'b mut self, name: &'a str, path: &'a str)\n                 -> RuleBuilder<'a, 'b> {\n         self.rule(name, path, Kind::Dist)\n@@ -634,6 +761,31 @@ invalid rule dependency graph detected, was a rule added and maybe typo'd?\n     /// Construct the top-level build steps that we're going to be executing,\n     /// given the subcommand that our build is performing.\n     fn plan(&self) -> Vec<Step<'a>> {\n+        // Ok, the logic here is pretty subtle, and involves quite a few\n+        // conditionals. The basic idea here is to:\n+        //\n+        // 1. First, filter all our rules to the relevant ones. This means that\n+        //    the command specified corresponds to one of our `Kind` variants,\n+        //    and we filter all rules based on that.\n+        //\n+        // 2. Next, we determine which rules we're actually executing. If a\n+        //    number of path filters were specified on the command line we look\n+        //    for those, otherwise we look for anything tagged `default`.\n+        //\n+        // 3. Finally, we generate some steps with host and target information.\n+        //\n+        // The last step is by far the most complicated and subtle. The basic\n+        // thinking here is that we want to take the cartesian product of\n+        // specified hosts and targets and build rules with that. The list of\n+        // hosts and targets, if not specified, come from the how this build was\n+        // configured. If the rule we're looking at is a host-only rule the we\n+        // ignore the list of targets and instead consider the list of hosts\n+        // also the list of targets.\n+        //\n+        // Once the host and target lists are generated we take the cartesian\n+        // product of the two and then create a step based off them. Note that\n+        // the stage each step is associated was specified with the `--step`\n+        // flag on the command line.\n         let (kind, paths) = match self.build.flags.cmd {\n             Subcommand::Build { ref paths } => (Kind::Build, &paths[..]),\n             Subcommand::Doc { ref paths } => (Kind::Doc, &paths[..]),\n@@ -664,7 +816,18 @@ invalid rule dependency graph detected, was a rule added and maybe typo'd?\n             } else {\n                 &self.build.config.target\n             };\n-            let arr = if rule.host {hosts} else {targets};\n+            // If --target was specified but --host wasn't specified, don't run\n+            // any host-only tests\n+            let arr = if rule.host {\n+                if self.build.flags.target.len() > 0 &&\n+                   self.build.flags.host.len() == 0 {\n+                    &hosts[..0]\n+                } else {\n+                    hosts\n+                }\n+            } else {\n+                targets\n+            };\n \n             hosts.iter().flat_map(move |host| {\n                 arr.iter().map(move |target| {\n@@ -705,6 +868,15 @@ invalid rule dependency graph detected, was a rule added and maybe typo'd?\n         }\n     }\n \n+    /// Performs topological sort of dependencies rooted at the `step`\n+    /// specified, pushing all results onto the `order` vector provided.\n+    ///\n+    /// In other words, when this method returns, the `order` vector will\n+    /// contain a list of steps which if executed in order will eventually\n+    /// complete the `step` specified as well.\n+    ///\n+    /// The `added` set specified here is the set of steps that are already\n+    /// present in `order` (and hence don't need to be added again).\n     fn fill(&self,\n             step: Step<'a>,\n             order: &mut Vec<Step<'a>>,"}, {"sha": "cb5b456a0f2fe9c63c7d6fc899669d0ec2ac064e", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=7846610470392abc3ab1470853bbe7b408fe4254", "patch": "@@ -18,6 +18,7 @@ use std::ffi::OsString;\n use std::fs;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n+use std::time::Instant;\n \n use filetime::FileTime;\n \n@@ -189,3 +190,19 @@ pub fn push_exe_path(mut buf: PathBuf, components: &[&str]) -> PathBuf {\n \n     buf\n }\n+\n+pub struct TimeIt(Instant);\n+\n+/// Returns an RAII structure that prints out how long it took to drop.\n+pub fn timeit() -> TimeIt {\n+    TimeIt(Instant::now())\n+}\n+\n+impl Drop for TimeIt {\n+    fn drop(&mut self) {\n+        let time = self.0.elapsed();\n+        println!(\"\\tfinished in {}.{:03}\",\n+                 time.as_secs(),\n+                 time.subsec_nanos() / 1_000_000);\n+    }\n+}"}, {"sha": "121c0263cbccb5f62b73a53a2f29257e75f4ebc7", "filename": "src/ci/docker/arm-android/Dockerfile", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farm-android%2FDockerfile?ref=7846610470392abc3ab1470853bbe7b408fe4254", "patch": "@@ -9,7 +9,6 @@ RUN dpkg --add-architecture i386 && \\\n   curl \\\n   ca-certificates \\\n   python2.7 \\\n-  python-minimal \\\n   git \\\n   cmake \\\n   ccache \\\n@@ -39,8 +38,7 @@ ENV RUST_CONFIGURE_ARGS \\\n       --arm-linux-androideabi-ndk=/android/ndk-arm-9 \\\n       --armv7-linux-androideabi-ndk=/android/ndk-arm-9 \\\n       --i686-linux-android-ndk=/android/ndk-x86-9 \\\n-      --aarch64-linux-android-ndk=/android/ndk-aarch64 \\\n-      --enable-rustbuild\n-ENV RUST_CHECK_TARGET check-stage2-android\n+      --aarch64-linux-android-ndk=/android/ndk-aarch64\n+ENV XPY_CHECK test --target arm-linux-androideabi\n RUN mkdir /tmp/obj\n RUN chmod 777 /tmp/obj"}, {"sha": "b7b23d74c9dadaa49c3345609dd8ee32b339c56b", "filename": "src/ci/docker/cross/Dockerfile", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fci%2Fdocker%2Fcross%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fci%2Fdocker%2Fcross%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fcross%2FDockerfile?ref=7846610470392abc3ab1470853bbe7b408fe4254", "patch": "@@ -7,7 +7,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   curl \\\n   ca-certificates \\\n   python2.7 \\\n-  python-minimal \\\n   git \\\n   cmake \\\n   ccache \\"}, {"sha": "ff5345d3aac9d5c133be0b7ac7968a1bf93c47a2", "filename": "src/ci/docker/run.sh", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fci%2Fdocker%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fci%2Fdocker%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Frun.sh?ref=7846610470392abc3ab1470853bbe7b408fe4254", "patch": "@@ -19,17 +19,21 @@ ci_dir=\"`dirname $docker_dir`\"\n src_dir=\"`dirname $ci_dir`\"\n root_dir=\"`dirname $src_dir`\"\n \n-docker build \\\n+docker \\\n+  build \\\n   --rm \\\n   -t rust-ci \\\n   \"`dirname \"$script\"`/$image\"\n \n mkdir -p $HOME/.ccache\n mkdir -p $HOME/.cargo\n+mkdir -p $root_dir/obj\n \n-exec docker run \\\n+exec docker \\\n+  run \\\n   --volume \"$root_dir:/checkout:ro\" \\\n-  --workdir /tmp/obj \\\n+  --volume \"$root_dir/obj:/checkout/obj\" \\\n+  --workdir /checkout/obj \\\n   --env SRC=/checkout \\\n   --env CCACHE_DIR=/ccache \\\n   --volume \"$HOME/.ccache:/ccache\" \\"}, {"sha": "a3a52f9e6ff95fcb8522993675a3b677c6d161ff", "filename": "src/ci/docker/x86_64-freebsd/Dockerfile", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fci%2Fdocker%2Fx86_64-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fci%2Fdocker%2Fx86_64-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-freebsd%2FDockerfile?ref=7846610470392abc3ab1470853bbe7b408fe4254", "patch": "@@ -7,7 +7,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   curl \\\n   ca-certificates \\\n   python2.7 \\\n-  python-minimal \\\n   git \\\n   cmake \\\n   ccache \\\n@@ -23,7 +22,7 @@ ENV \\\n     AR_x86_64_unknown_freebsd=x86_64-unknown-freebsd10-ar \\\n     CC_x86_64_unknown_freebsd=x86_64-unknown-freebsd10-gcc\n \n-ENV RUST_CONFIGURE_ARGS --target=x86_64-unknown-freebsd --enable-rustbuild\n+ENV RUST_CONFIGURE_ARGS --target=x86_64-unknown-freebsd\n ENV RUST_CHECK_TARGET \"\"\n RUN mkdir /tmp/obj\n RUN chmod 777 /tmp/obj"}, {"sha": "107e2bf8a121e2bb92e6b949915f24fda341529a", "filename": "src/ci/docker/x86_64-gnu-cargotest/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fci%2Fdocker%2Fx86_64-gnu-cargotest%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fci%2Fdocker%2Fx86_64-gnu-cargotest%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-cargotest%2FDockerfile?ref=7846610470392abc3ab1470853bbe7b408fe4254", "patch": "@@ -7,14 +7,14 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   curl \\\n   ca-certificates \\\n   python2.7 \\\n-  python-minimal \\\n   git \\\n   cmake \\\n   ccache \\\n   libssl-dev \\\n   sudo\n \n-ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu --enable-rustbuild\n+ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu\n ENV RUST_CHECK_TARGET check-cargotest\n+ENV NO_VENDOR 1\n RUN mkdir /tmp/obj\n RUN chmod 777 /tmp/obj"}, {"sha": "c27e3d1325fe8570c7cbea4f7eb0b1edaeafabc8", "filename": "src/ci/docker/x86_64-gnu-llvm-3.7/Dockerfile", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.7%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.7%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.7%2FDockerfile?ref=7846610470392abc3ab1470853bbe7b408fe4254", "patch": "@@ -7,7 +7,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   curl \\\n   ca-certificates \\\n   python2.7 \\\n-  python2.7-minimal \\\n   git \\\n   cmake \\\n   ccache \\\n@@ -19,7 +18,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n \n ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\\n-      --enable-rustbuild \\\n       --llvm-root=/usr/lib/llvm-3.7\n ENV RUST_CHECK_TARGET check\n RUN mkdir /tmp/obj"}, {"sha": "93229b2a0103e91ade2b026cc4721714ea33d923", "filename": "src/ci/docker/x86_64-gnu-make/Dockerfile", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fci%2Fdocker%2Fx86_64-gnu-make%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fci%2Fdocker%2Fx86_64-gnu-make%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-make%2FDockerfile?ref=7846610470392abc3ab1470853bbe7b408fe4254", "patch": "@@ -7,14 +7,13 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   curl \\\n   ca-certificates \\\n   python2.7 \\\n-  python-minimal \\\n   git \\\n   cmake \\\n   ccache \\\n   sudo \\\n   gdb\n \n-ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu --enable-rustbuild\n+ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu --disable-rustbuild\n ENV RUST_CHECK_TARGET check\n RUN mkdir /tmp/obj\n RUN chmod 777 /tmp/obj", "previous_filename": "src/ci/docker/x86_64-gnu-rustbuild/Dockerfile"}, {"sha": "967940fb1f3ae093b2caf604f9e2ac95d856816a", "filename": "src/ci/docker/x86_64-musl/Dockerfile", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fci%2Fdocker%2Fx86_64-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fci%2Fdocker%2Fx86_64-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-musl%2FDockerfile?ref=7846610470392abc3ab1470853bbe7b408fe4254", "patch": "@@ -20,8 +20,10 @@ RUN sh /build/build-musl.sh && rm -rf /build\n \n ENV RUST_CONFIGURE_ARGS \\\n       --target=x86_64-unknown-linux-musl \\\n-      --musl-root=/musl-x86_64\n+      --musl-root-x86_64=/musl-x86_64\n ENV RUST_CHECK_TARGET check-stage2-T-x86_64-unknown-linux-musl-H-x86_64-unknown-linux-gnu\n+ENV PATH=$PATH:/musl-x86_64/bin\n+ENV XPY_CHECK test --target x86_64-unknown-linux-musl\n \n RUN mkdir /tmp/obj\n RUN chmod 777 /tmp/obj"}, {"sha": "10f2d15da343c08cba2670cfb8f54efb8befec33", "filename": "src/ci/run.sh", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=7846610470392abc3ab1470853bbe7b408fe4254", "patch": "@@ -14,12 +14,20 @@ set -e\n if [ \"$LOCAL_USER_ID\" != \"\" ]; then\n   useradd --shell /bin/bash -u $LOCAL_USER_ID -o -c \"\" -m user\n   export HOME=/home/user\n-  export LOCAL_USER_ID=\n-  exec sudo -E -u user env PATH=$PATH \"$0\"\n+  unset LOCAL_USER_ID\n+  exec su --preserve-environment -c \"env PATH=$PATH \\\"$0\\\"\" user\n fi\n \n if [ \"$NO_LLVM_ASSERTIONS\" = \"\" ]; then\n-  LLVM_ASSERTIONS=--enable-llvm-assertions\n+  ENABLE_LLVM_ASSERTIONS=--enable-llvm-assertions\n+fi\n+\n+if [ \"$NO_VENDOR\" = \"\" ]; then\n+  ENABLE_VENDOR=--enable-vendor\n+fi\n+\n+if [ \"$NO_CCACHE\" = \"\" ]; then\n+  ENABLE_CCACHE=--enable-ccache\n fi\n \n set -ex\n@@ -28,9 +36,9 @@ $SRC/configure \\\n   --disable-manage-submodules \\\n   --enable-debug-assertions \\\n   --enable-quiet-tests \\\n-  --enable-ccache \\\n-  --enable-vendor \\\n-  $LLVM_ASSERTIONS \\\n+  $ENABLE_CCACHE \\\n+  $ENABLE_VENDOR \\\n+  $ENABLE_LLVM_ASSERTIONS \\\n   $RUST_CONFIGURE_ARGS\n \n if [ \"$TRAVIS_OS_NAME\" = \"osx\" ]; then\n@@ -41,4 +49,8 @@ fi\n \n make -j $ncpus tidy\n make -j $ncpus\n-exec make $RUST_CHECK_TARGET -j $ncpus\n+if [ ! -z \"$XPY_CHECK\" ]; then\n+  exec python2.7 $SRC/x.py $XPY_CHECK\n+else\n+  exec make $RUST_CHECK_TARGET -j $ncpus\n+fi"}, {"sha": "fc849e7a50cc40abda3fbdcff2b756189d8a2057", "filename": "src/liballoc_jemalloc/build.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fliballoc_jemalloc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846610470392abc3ab1470853bbe7b408fe4254/src%2Fliballoc_jemalloc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Fbuild.rs?ref=7846610470392abc3ab1470853bbe7b408fe4254", "patch": "@@ -151,11 +151,17 @@ fn main() {\n     cmd.arg(format!(\"--build={}\", build_helper::gnu_target(&host)));\n \n     run(&mut cmd);\n-    run(Command::new(\"make\")\n-        .current_dir(&build_dir)\n-        .arg(\"build_lib_static\")\n-        .arg(\"-j\")\n-        .arg(env::var(\"NUM_JOBS\").expect(\"NUM_JOBS was not set\")));\n+    let mut make = Command::new(\"make\");\n+    make.current_dir(&build_dir)\n+        .arg(\"build_lib_static\");\n+\n+    // mingw make seems... buggy? unclear...\n+    if !host.contains(\"windows\") {\n+        make.arg(\"-j\")\n+            .arg(env::var(\"NUM_JOBS\").expect(\"NUM_JOBS was not set\"));\n+    }\n+\n+    run(&mut make);\n \n     if target.contains(\"windows\") {\n         println!(\"cargo:rustc-link-lib=static=jemalloc\");"}, {"sha": "2d832fcdf2ad05d08dfbf0b7219c85e22eef58d9", "filename": "src/rustllvm/llvm-auto-clean-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7846610470392abc3ab1470853bbe7b408fe4254/src%2Frustllvm%2Fllvm-auto-clean-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/7846610470392abc3ab1470853bbe7b408fe4254/src%2Frustllvm%2Fllvm-auto-clean-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-auto-clean-trigger?ref=7846610470392abc3ab1470853bbe7b408fe4254", "patch": "@@ -1,4 +1,4 @@\n # If this file is modified, then llvm will be forcibly cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n-2016-12-01\n+2016-12-06"}, {"sha": "85c63e184fe255610af84ad7b7e6d4c9d9e51fdb", "filename": "src/test/run-pass/no-stdio.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7846610470392abc3ab1470853bbe7b408fe4254/src%2Ftest%2Frun-pass%2Fno-stdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846610470392abc3ab1470853bbe7b408fe4254/src%2Ftest%2Frun-pass%2Fno-stdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fno-stdio.rs?ref=7846610470392abc3ab1470853bbe7b408fe4254", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // ignore-emscripten\n+// ignore-android\n \n #![feature(libc)]\n "}]}