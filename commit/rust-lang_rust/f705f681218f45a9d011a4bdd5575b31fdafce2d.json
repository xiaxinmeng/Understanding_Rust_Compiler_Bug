{"sha": "f705f681218f45a9d011a4bdd5575b31fdafce2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3MDVmNjgxMjE4ZjQ1YTlkMDExYTRiZGQ1NTc1YjMxZmRhZmNlMmQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-11-11T02:01:56Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-11-11T02:02:08Z"}, "message": "rt: Remove rust_aio.cpp. Bitrotted.", "tree": {"sha": "8c0dff73074a3197ef5721fd5ad78450b6e2cb59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c0dff73074a3197ef5721fd5ad78450b6e2cb59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f705f681218f45a9d011a4bdd5575b31fdafce2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f705f681218f45a9d011a4bdd5575b31fdafce2d", "html_url": "https://github.com/rust-lang/rust/commit/f705f681218f45a9d011a4bdd5575b31fdafce2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f705f681218f45a9d011a4bdd5575b31fdafce2d/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c108aade9e7666bf8d984115f6c44a5f7cf5907", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c108aade9e7666bf8d984115f6c44a5f7cf5907", "html_url": "https://github.com/rust-lang/rust/commit/6c108aade9e7666bf8d984115f6c44a5f7cf5907"}], "stats": {"total": 336, "additions": 0, "deletions": 336}, "files": [{"sha": "5aa1a390dfae1e440b89b383cef73f8ba0021c80", "filename": "mk/rt.mk", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f705f681218f45a9d011a4bdd5575b31fdafce2d/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/f705f681218f45a9d011a4bdd5575b31fdafce2d/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=f705f681218f45a9d011a4bdd5575b31fdafce2d", "patch": "@@ -48,7 +48,6 @@ RUNTIME_CS_$(1) := \\\n               rt/rust_chan.cpp \\\n               rt/rust_port.cpp \\\n               rt/rust_upcall.cpp \\\n-              rt/rust_aio.cpp \\\n               rt/rust_log.cpp \\\n               rt/rust_timer.cpp \\\n               rt/circular_buffer.cpp \\"}, {"sha": "3b2040476d0dd61c61d407cb68c3562576742039", "filename": "src/rt/rust_aio.cpp", "status": "removed", "additions": 0, "deletions": 325, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/6c108aade9e7666bf8d984115f6c44a5f7cf5907/src%2Frt%2Frust_aio.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6c108aade9e7666bf8d984115f6c44a5f7cf5907/src%2Frt%2Frust_aio.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_aio.cpp?ref=6c108aade9e7666bf8d984115f6c44a5f7cf5907", "patch": "@@ -1,325 +0,0 @@\n-// Disable libev prototypes - they will make inline compatibility functions\n-// which are unused and so trigger a warning in gcc since -Wall is on.\n-#define EV_PROTOTYPES 0\n-#include \"uv.h\"\n-\n-#include \"rust_internal.h\"\n-#include \"rust_scheduler.h\"\n-#include \"rust_upcall.h\"\n-\n-#ifdef __GNUC__\n-#define LOG_CALLBACK_ENTRY(p) \\\n-    LOG(iotask, callback, \"> IO CALLBACK %s %p\", __FUNCTION__, p)\n-#else\n-#define LOG_CALLBACK_ENTRY(p) \\\n-    LOG(iotask, callback, \"> IO CALLBACK %s:%d %p\", __FILE__, __LINE__, p)\n-#endif\n-\n-// The primary task which is running the event loop. This is used to dispatch\n-// all the notifications back to rust so we clone all passed in channels to\n-// this task.\n-static rust_task *iotask = NULL;\n-\n-struct socket_data : public task_owned<socket_data> {\n-  // Either the task that the connection attempt was made from or the task\n-  // that the server was spawned on.\n-  rust_task *task;\n-  // Channel for reporting the status of a connection attempt\n-  // For connections from servers, this is always null\n-  // For server sockets, this is used to send the notification that the server\n-  // was closed.\n-  rust_chan *chan;\n-  // Channel to a port which receives bytes from this socket\n-  rust_chan *reader;\n-  uv_tcp_t socket;\n-\n-  ~socket_data() {\n-    if (chan)\n-      chan->deref();\n-    if (reader)\n-      reader->deref();\n-  }\n-\n-  void send_result(void *data) {\n-    chan->port->send(&data);\n-    chan->deref();\n-    chan = NULL;\n-  }\n-};\n-\n-struct req_connect : public uv_connect_t, public task_owned<req_connect> {};\n-struct req_write : public uv_write_t, public task_owned<req_write> {};\n-\n-extern \"C\" CDECL void aio_close_socket(socket_data *);\n-\n-static uv_idle_s idle_handler;\n-\n-static void idle_callback(uv_idle_t* handle, int status) {\n-  rust_task *task = reinterpret_cast<rust_task*>(handle->data);\n-  task->yield();\n-}\n-\n-extern \"C\" CDECL void aio_init() {\n-  rust_task *task = rust_scheduler::get_task();\n-  LOG_UPCALL_ENTRY(task);\n-  iotask = task;\n-  uv_idle_init(uv_default_loop(), &idle_handler);\n-  uv_idle_start(&idle_handler, idle_callback);\n-}\n-\n-extern \"C\" CDECL void aio_run() {\n-  rust_task *task = rust_scheduler::get_task();\n-  LOG_UPCALL_ENTRY(task);\n-  idle_handler.data = task;\n-  uv_run(uv_default_loop());\n-}\n-\n-void nop_close(uv_handle_t* handle) {}\n-\n-extern \"C\" CDECL void aio_stop() {\n-  rust_task *task = rust_scheduler::get_task();\n-  LOG_UPCALL_ENTRY(task);\n-  uv_close((uv_handle_t*)&idle_handler, nop_close);\n-}\n-\n-static socket_data *make_socket(rust_task *task, rust_chan *chan) {\n-  socket_data *data = new (task, \"make_socket\") socket_data;\n-  if (!data ||\n-      uv_tcp_init(uv_default_loop(), &data->socket)) {\n-    return NULL;\n-  }\n-  data->socket.data = data;\n-  data->task = task;\n-  // Connections from servers don't have a channel\n-  if (chan) {\n-    data->chan = chan->clone(iotask);\n-  } else {\n-    data->chan = NULL;\n-  }\n-  data->socket.data = data;\n-  data->reader = NULL;\n-  return data;\n-}\n-\n-// We allocate the requested space + rust_vec but return a pointer at a\n-// +rust_vec offset so that it writes the bytes to the correct location.\n-static uv_buf_t alloc_buffer(uv_handle_t *socket, size_t suggested_size) {\n-  LOG_CALLBACK_ENTRY(socket);\n-  uv_buf_t buf;\n-  size_t actual_size = suggested_size + sizeof (rust_vec);\n-  socket_data *data = (socket_data*)socket->data;\n-  char *base =\n-    reinterpret_cast<char*>(data->task->kernel->malloc(actual_size,\n-                                                       \"read buffer\"));\n-  buf.base = base + sizeof (rust_vec);\n-  buf.len = suggested_size;\n-  return buf;\n-}\n-\n-static void read_progress(uv_stream_t *socket, ssize_t nread, uv_buf_t buf) {\n-  LOG_CALLBACK_ENTRY(socket);\n-  socket_data *data = (socket_data*)socket->data;\n-  I(data->task->sched, data->reader != NULL);\n-  I(data->task->sched, nread <= ssize_t(buf.len));\n-\n-  rust_vec *v = reinterpret_cast<rust_vec*>(\n-      reinterpret_cast<char*>(buf.base) - sizeof (rust_vec));\n-  v->alloc = buf.len;\n-\n-  switch (nread) {\n-    case -1: // End of stream\n-      v->fill = 0;\n-      uv_read_stop(socket);\n-      break;\n-    case 0: // Nothing read\n-      data->task->kernel->free(v);\n-      return;\n-    default: // Got nread bytes\n-      v->fill = nread;\n-      break;\n-  }\n-  data->reader->port->send(v);\n-}\n-\n-static void new_connection(uv_stream_t *socket, int status) {\n-  LOG_CALLBACK_ENTRY(socket);\n-  socket_data *server = (socket_data*)socket->data;\n-  I(server->task->sched, (uv_tcp_t*)socket == &server->socket);\n-  // Connections from servers don't have a channel\n-  socket_data *client = make_socket(server->task, NULL);\n-  if (!client) {\n-    server->task->fail();\n-    return;\n-  }\n-  if (uv_accept(socket, (uv_stream_t*)&client->socket)) {\n-    aio_close_socket(client);\n-    server->task->fail();\n-    return;\n-  }\n-  server->chan->port->send(&client);\n-}\n-\n-extern \"C\" CDECL socket_data *aio_serve(const char *ip, int port,\n-                                        chan_handle *_chan) {\n-  rust_task *task = rust_scheduler::get_task();\n-  LOG_UPCALL_ENTRY(task);\n-  rust_chan *chan = task->get_chan_by_handle(_chan);\n-  if(!chan) return NULL;\n-  struct sockaddr_in addr = uv_ip4_addr(const_cast<char*>(ip), port);\n-  socket_data *server = make_socket(iotask, chan);\n-  if (!server)\n-    goto oom;\n-  if (uv_tcp_bind(&server->socket, addr) ||\n-      uv_listen((uv_stream_t*)&server->socket, 128, new_connection)) {\n-    aio_close_socket(server);\n-    chan->deref();\n-    return NULL;\n-  }\n-  chan->deref();\n-  return server;\n-oom:\n-  chan->deref();\n-  task->fail();\n-  return NULL;\n-}\n-\n-static void free_socket(uv_handle_t *handle) {\n-  LOG_CALLBACK_ENTRY(socket);\n-  uv_tcp_t *socket = (uv_tcp_t*)handle;\n-  socket_data *data = (socket_data*)socket->data;\n-  I(data->task->sched, socket == &data->socket);\n-  // For client sockets, send a 0-size buffer to indicate that we're done\n-  // reading and should send the close notification.\n-  if (data->reader) {\n-    if (data->reader->is_associated()) {\n-      uv_buf_t buf = alloc_buffer((uv_handle_t*)socket, 0);\n-      read_progress((uv_stream_t*)socket, -1, buf);\n-      uv_read_stop((uv_stream_t*)socket);\n-    }\n-  } else {\n-    // This is a server socket\n-    bool closed = true;\n-    I(data->task->sched, data->chan != NULL);\n-    data->task->kill();\n-    data->chan->port->send(&closed);\n-  }\n-  delete data;\n-}\n-\n-extern \"C\" CDECL void aio_close_socket(socket_data *client) {\n-  rust_task *task = rust_scheduler::get_task();\n-  LOG_UPCALL_ENTRY(task);\n-  uv_close((uv_handle_t*)&client->socket, free_socket);\n-}\n-\n-extern \"C\" CDECL void aio_close_server(socket_data *server,\n-                                       chan_handle *_chan) {\n-  rust_task *task = rust_scheduler::get_task();\n-  LOG_UPCALL_ENTRY(task);\n-  rust_chan *chan = task->get_chan_by_handle(_chan);\n-  if(!chan) return;\n-  // XXX: hax until rust_task::kill\n-  // send null and the receiver knows to call back into native code to check\n-  void* null_client = NULL;\n-  server->chan->port->send(&null_client);\n-  server->chan->deref();\n-  server->chan = chan->clone(iotask);\n-  aio_close_socket(server);\n-  chan->deref();\n-}\n-\n-extern \"C\" CDECL bool aio_is_null_client(socket_data *server) {\n-  rust_task *task = rust_scheduler::get_task();\n-  LOG_UPCALL_ENTRY(task);\n-  return server == NULL;\n-}\n-\n-static void connection_complete(uv_connect_t *req, int status) {\n-  LOG_CALLBACK_ENTRY(socket);\n-  socket_data *client = (socket_data*)req->data;\n-  client->send_result(client);\n-  free(req);\n-}\n-\n-extern \"C\" CDECL void aio_connect(const char *host, int port,\n-                                  chan_handle *_chan) {\n-  rust_task *task = rust_scheduler::get_task();\n-  LOG_UPCALL_ENTRY(task);\n-  rust_chan *chan = task->get_chan_by_handle(_chan);\n-  uv_connect_t *req = NULL;\n-  if(!chan) return;\n-  struct sockaddr_in addr = uv_ip4_addr(const_cast<char*>(host), port);\n-  socket_data *client = make_socket(iotask, NULL);\n-  if (!client) {\n-    goto oom_client;\n-  }\n-  req = (uv_connect_t*)client->task->malloc(\n-      sizeof(uv_connect_t), \"connection request\");\n-  if (!req) {\n-    goto oom_req;\n-  }\n-  req->data = client;\n-  if (0 == uv_tcp_connect(req, &client->socket, addr, connection_complete)) {\n-      chan->deref();\n-      return;\n-  }\n-  free(req);\n-oom_req:\n-  aio_close_socket(client);\n-oom_client:\n-  chan->deref();\n-  task->fail();\n-  return;\n-}\n-\n-static void write_complete(uv_write_t *req, int status) {\n-  LOG_CALLBACK_ENTRY(socket);\n-  bool success = status == 0;\n-  socket_data *client = (socket_data*)req->data;\n-  client->send_result(&success);\n-  free(req);\n-}\n-\n-extern \"C\" CDECL void aio_writedata(socket_data *data, char *buf,\n-                                    size_t size, chan_handle *_chan) {\n-  rust_task *task = rust_scheduler::get_task();\n-  LOG_UPCALL_ENTRY(task);\n-  rust_chan *chan = task->get_chan_by_handle(_chan);\n-  uv_write_t *req;\n-  if(!chan) return;\n-\n-  // uv_buf_t is defined backwards on win32...\n-  // maybe an indication we shouldn't be building directly?\n-#if defined(__WIN32__)\n-  uv_buf_t buffer = { size, buf };\n-#else\n-  uv_buf_t buffer = { buf, size };\n-#endif\n-\n-  req = (uv_write_t*)data->task->malloc(sizeof(uv_write_t), \"write request\");\n-  if (!req) {\n-    goto fail;\n-  }\n-  req->data = data;\n-  if (uv_write(req, (uv_stream_t*)&data->socket, &buffer, 1,\n-               write_complete)) {\n-    free(req);\n-    goto fail;\n-  }\n-  chan->deref();\n-  return;\n-fail:\n-  chan->deref();\n-  task->fail();\n-}\n-\n-extern \"C\" CDECL void aio_read(socket_data *data, chan_handle *_chan) {\n-  rust_task *task = rust_scheduler::get_task();\n-  LOG_UPCALL_ENTRY(task);\n-  rust_chan *reader = task->get_chan_by_handle(_chan);\n-  if(!reader) return;\n-  I(task->sched, data->reader == NULL);\n-  data->reader = reader->clone(iotask);\n-  uv_read_start((uv_stream_t*)&data->socket, alloc_buffer, read_progress);\n-  reader->deref();\n-}"}, {"sha": "b5546d356c39efa8df6b6deb3e63f1e96af48e50", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f705f681218f45a9d011a4bdd5575b31fdafce2d/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/f705f681218f45a9d011a4bdd5575b31fdafce2d/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=f705f681218f45a9d011a4bdd5575b31fdafce2d", "patch": "@@ -1,13 +1,3 @@\n-aio_close_socket\n-aio_close_server\n-aio_connect\n-aio_init\n-aio_is_null_client\n-aio_read\n-aio_run\n-aio_serve\n-aio_stop\n-aio_writedata\n align_of\n chan_id_send\n check_claims"}]}