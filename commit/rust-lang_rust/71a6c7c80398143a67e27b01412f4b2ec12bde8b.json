{"sha": "71a6c7c80398143a67e27b01412f4b2ec12bde8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxYTZjN2M4MDM5ODE0M2E2N2UyN2IwMTQxMmY0YjJlYzEyYmRlOGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-25T04:34:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-25T04:34:58Z"}, "message": "Auto merge of #87381 - Aaron1011:note-semi-trailing-macro, r=petrochenkov\n\nDisplay an extra note for trailing semicolon lint with trailing macro\n\nCurrently, we parse macros at the end of a block\n(e.g. `fn foo() { my_macro!() }`) as expressions, rather than\nstatements. This means that a macro invoked in this position\ncannot expand to items or semicolon-terminated expressions.\n\nIn the future, we might want to start parsing these kinds of macros\nas statements. This would make expansion more 'token-based'\n(i.e. macro expansion behaves (almost) as if you just textually\nreplaced the macro invocation with its output). However,\nthis is a breaking change (see PR #78991), so it will require\nfurther discussion.\n\nSince the current behavior will not be changing any time soon,\nwe need to address the interaction with the\n`SEMICOLON_IN_EXPRESSIONS_FROM_MACROS` lint. Since we are parsing\nthe result of macro expansion as an expression, we will emit a lint\nif there's a trailing semicolon in the macro output. However, this\nresults in a somewhat confusing message for users, since it visually\nlooks like there should be no problem with having a semicolon\nat the end of a block\n(e.g. `fn foo() { my_macro!() }` => `fn foo() { produced_expr; }`)\n\nTo help reduce confusion, this commit adds a note explaining\nthat the macro is being interpreted as an expression. Additionally,\nwe suggest adding a semicolon after the macro *invocation* - this\nwill cause us to parse the macro call as a statement. We do *not*\nuse a structured suggestion for this, since the user may actually\nwant to remove the semicolon from the macro definition (allowing\nthe block to evaluate to the expression produced by the macro).", "tree": {"sha": "05d20053efc3cccecae937fe8794a1ee29ea0bc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05d20053efc3cccecae937fe8794a1ee29ea0bc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71a6c7c80398143a67e27b01412f4b2ec12bde8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71a6c7c80398143a67e27b01412f4b2ec12bde8b", "html_url": "https://github.com/rust-lang/rust/commit/71a6c7c80398143a67e27b01412f4b2ec12bde8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71a6c7c80398143a67e27b01412f4b2ec12bde8b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f63ec777bcfdedb752f55ac676ac0724c6cef47e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f63ec777bcfdedb752f55ac676ac0724c6cef47e", "html_url": "https://github.com/rust-lang/rust/commit/f63ec777bcfdedb752f55ac676ac0724c6cef47e"}, {"sha": "0df5ac8269d021f0601cdeac3f7d45bc4e7446b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/0df5ac8269d021f0601cdeac3f7d45bc4e7446b4", "html_url": "https://github.com/rust-lang/rust/commit/0df5ac8269d021f0601cdeac3f7d45bc4e7446b4"}], "stats": {"total": 46, "additions": 41, "deletions": 5}, "files": [{"sha": "b454737fb8077db26141b7af2738028004327eaa", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71a6c7c80398143a67e27b01412f4b2ec12bde8b/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71a6c7c80398143a67e27b01412f4b2ec12bde8b/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=71a6c7c80398143a67e27b01412f4b2ec12bde8b", "patch": "@@ -929,6 +929,7 @@ pub struct ExpansionData {\n     pub prior_type_ascription: Option<(Span, bool)>,\n     /// Some parent node that is close to this macro call\n     pub lint_node_id: NodeId,\n+    pub is_trailing_mac: bool,\n }\n \n type OnExternModLoaded<'a> =\n@@ -979,6 +980,7 @@ impl<'a> ExtCtxt<'a> {\n                 dir_ownership: DirOwnership::Owned { relative: None },\n                 prior_type_ascription: None,\n                 lint_node_id: ast::CRATE_NODE_ID,\n+                is_trailing_mac: false,\n             },\n             force_mode: false,\n             expansions: FxHashMap::default(),"}, {"sha": "09beda33483745b0c85d7b120a1265dde17a76e3", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/71a6c7c80398143a67e27b01412f4b2ec12bde8b/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71a6c7c80398143a67e27b01412f4b2ec12bde8b/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=71a6c7c80398143a67e27b01412f4b2ec12bde8b", "patch": "@@ -1328,14 +1328,30 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n             return placeholder;\n         }\n \n+        // The only way that we can end up with a `MacCall` expression statement,\n+        // (as opposed to a `StmtKind::MacCall`) is if we have a macro as the\n+        // traiing expression in a block (e.g. `fn foo() { my_macro!() }`).\n+        // Record this information, so that we can report a more specific\n+        // `SEMICOLON_IN_EXPRESSIONS_FROM_MACROS` lint if needed.\n+        // See #78991 for an investigation of treating macros in this position\n+        // as statements, rather than expressions, during parsing.\n+        if let StmtKind::Expr(expr) = &stmt.kind {\n+            if matches!(**expr, ast::Expr { kind: ast::ExprKind::MacCall(..), .. }) {\n+                self.cx.current_expansion.is_trailing_mac = true;\n+            }\n+        }\n+\n         // The placeholder expander gives ids to statements, so we avoid folding the id here.\n         // We don't use `assign_id!` - it will be called when we visit statement's contents\n         // (e.g. an expression, item, or local)\n         let ast::Stmt { id, kind, span } = stmt;\n-        noop_flat_map_stmt_kind(kind, self)\n+        let res = noop_flat_map_stmt_kind(kind, self)\n             .into_iter()\n             .map(|kind| ast::Stmt { id, kind, span })\n-            .collect()\n+            .collect();\n+\n+        self.cx.current_expansion.is_trailing_mac = false;\n+        res\n     }\n \n     fn visit_block(&mut self, block: &mut P<Block>) {"}, {"sha": "b97593b92b35523d635aab358e5e60a6e507af99", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/71a6c7c80398143a67e27b01412f4b2ec12bde8b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71a6c7c80398143a67e27b01412f4b2ec12bde8b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=71a6c7c80398143a67e27b01412f4b2ec12bde8b", "patch": "@@ -43,6 +43,7 @@ crate struct ParserAnyMacro<'a> {\n     /// The ident of the macro we're parsing\n     macro_ident: Ident,\n     lint_node_id: NodeId,\n+    is_trailing_mac: bool,\n     arm_span: Span,\n }\n \n@@ -116,8 +117,14 @@ fn emit_frag_parse_err(\n \n impl<'a> ParserAnyMacro<'a> {\n     crate fn make(mut self: Box<ParserAnyMacro<'a>>, kind: AstFragmentKind) -> AstFragment {\n-        let ParserAnyMacro { site_span, macro_ident, ref mut parser, lint_node_id, arm_span } =\n-            *self;\n+        let ParserAnyMacro {\n+            site_span,\n+            macro_ident,\n+            ref mut parser,\n+            lint_node_id,\n+            arm_span,\n+            is_trailing_mac,\n+        } = *self;\n         let snapshot = &mut parser.clone();\n         let fragment = match parse_ast_fragment(parser, kind) {\n             Ok(f) => f,\n@@ -131,11 +138,12 @@ impl<'a> ParserAnyMacro<'a> {\n         // `macro_rules! m { () => { panic!(); } }` isn't parsed by `.parse_expr()`,\n         // but `m!()` is allowed in expression positions (cf. issue #34706).\n         if kind == AstFragmentKind::Expr && parser.token == token::Semi {\n-            parser.sess.buffer_lint(\n+            parser.sess.buffer_lint_with_diagnostic(\n                 SEMICOLON_IN_EXPRESSIONS_FROM_MACROS,\n                 parser.token.span,\n                 lint_node_id,\n                 \"trailing semicolon in macro used in expression position\",\n+                BuiltinLintDiagnostics::TrailingMacro(is_trailing_mac, macro_ident),\n             );\n             parser.bump();\n         }\n@@ -301,6 +309,7 @@ fn generic_extension<'cx>(\n                     site_span: sp,\n                     macro_ident: name,\n                     lint_node_id: cx.current_expansion.lint_node_id,\n+                    is_trailing_mac: cx.current_expansion.is_trailing_mac,\n                     arm_span,\n                 });\n             }"}, {"sha": "ad8a41a56cc16287799824e5ea34ed0bb6dad769", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71a6c7c80398143a67e27b01412f4b2ec12bde8b/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71a6c7c80398143a67e27b01412f4b2ec12bde8b/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=71a6c7c80398143a67e27b01412f4b2ec12bde8b", "patch": "@@ -744,6 +744,12 @@ pub trait LintContext: Sized {\n                         &format!(\"the built-in attribute `{attr_name}` will be ignored, since it's applied to the macro invocation `{macro_name}`\")\n                     );\n                 }\n+                BuiltinLintDiagnostics::TrailingMacro(is_trailing, name) => {\n+                    if is_trailing {\n+                        db.note(\"macro invocations at the end of a block are treated as expressions\");\n+                        db.note(&format!(\"to ignore the value produced by the macro, add a semicolon after the invocation of `{name}`\"));\n+                    }\n+                }\n             }\n             // Rewrap `db`, and pass control to the user.\n             decorate(LintDiagnosticBuilder::new(db));"}, {"sha": "6c38b8f5bc0a14c84fd5fe14939fc5461f312b41", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71a6c7c80398143a67e27b01412f4b2ec12bde8b/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71a6c7c80398143a67e27b01412f4b2ec12bde8b/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=71a6c7c80398143a67e27b01412f4b2ec12bde8b", "patch": "@@ -303,6 +303,7 @@ pub enum BuiltinLintDiagnostics {\n     ProcMacroBackCompat(String),\n     OrPatternsBackCompat(Span, String),\n     ReservedPrefix(Span),\n+    TrailingMacro(bool, Ident),\n }\n \n /// Lints that are buffered up early on in the `Session` before the"}, {"sha": "84ad32bddd55b3991f6099d97af6402271df8abc", "filename": "src/test/ui/lint/semicolon-in-expressions-from-macros/semicolon-in-expressions-from-macros.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71a6c7c80398143a67e27b01412f4b2ec12bde8b/src%2Ftest%2Fui%2Flint%2Fsemicolon-in-expressions-from-macros%2Fsemicolon-in-expressions-from-macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/71a6c7c80398143a67e27b01412f4b2ec12bde8b/src%2Ftest%2Fui%2Flint%2Fsemicolon-in-expressions-from-macros%2Fsemicolon-in-expressions-from-macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fsemicolon-in-expressions-from-macros%2Fsemicolon-in-expressions-from-macros.stderr?ref=71a6c7c80398143a67e27b01412f4b2ec12bde8b", "patch": "@@ -14,6 +14,8 @@ LL | #![warn(semicolon_in_expressions_from_macros)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #79813 <https://github.com/rust-lang/rust/issues/79813>\n+   = note: macro invocations at the end of a block are treated as expressions\n+   = note: to ignore the value produced by the macro, add a semicolon after the invocation of `foo`\n    = note: this warning originates in the macro `foo` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n warning: trailing semicolon in macro used in expression position"}]}