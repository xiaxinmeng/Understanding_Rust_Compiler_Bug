{"sha": "a1b33b4fdc74e0a0b9e48a7f0fd5909d5984979a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExYjMzYjRmZGM3NGUwYTBiOWU0OGE3ZjBmZDU5MDlkNTk4NDk3OWE=", "commit": {"author": {"name": "Peter Atashian", "email": "retep998@gmail.com", "date": "2016-06-28T20:29:58Z"}, "committer": {"name": "Peter Atashian", "email": "retep998@gmail.com", "date": "2016-06-28T20:29:58Z"}, "message": "Make MSVC detection ludicrously robust\nShould fix a few more edge cases\n\nFixes https://github.com/rust-lang/rust/issues/31151\nFixes https://github.com/rust-lang/rust/issues/32159\nFixes https://github.com/rust-lang/rust/issues/34484\nImproves https://github.com/rust-lang/rust-packaging/issues/50\n\nSigned-off-by: Peter Atashian <retep998@gmail.com>", "tree": {"sha": "397055d7b74e1fc8ec3977884282844a838af796", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/397055d7b74e1fc8ec3977884282844a838af796"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1b33b4fdc74e0a0b9e48a7f0fd5909d5984979a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2\n\niQEcBAABCAAGBQJXct5KAAoJEN4E2eJ1WbyKG2IIAJEEOSHtUiZI1rXRb49gpNFX\nWHQud7VQem4dRrpUGWTGX6E0sZBCe7MN2HoahVsSvCyyjV4BFLjWKSHaatki+dDQ\n1Sc0iXoAeq44XW4FmdzTcpj66a7URYjK6e7F6Cg5yRokPG/HtJ57IZoV3G6H0skb\nvZKTAO7GsyjY+Js6h5zzQOtmOyKxkTadaYkowk8UnYA1htO6umpP5BOA9m6cfq04\nAQO7pUAPJEWkGq/2Fy9yEFrHQteG42Jo8OtJX+IdzGmVlo/Q3yxPFunrVAYjSaZQ\n2osT1F6kVv9DzKcvgtN9EBn7QscrcQGqKhxpD3TfgM4P38AeG1u+XyKy/+Ag+tg=\n=/dQX\n-----END PGP SIGNATURE-----", "payload": "tree 397055d7b74e1fc8ec3977884282844a838af796\nparent 126af085be2b760b859d073d8aff164572ef7d4a\nauthor Peter Atashian <retep998@gmail.com> 1467145798 -0400\ncommitter Peter Atashian <retep998@gmail.com> 1467145798 -0400\n\nMake MSVC detection ludicrously robust\nShould fix a few more edge cases\n\nFixes https://github.com/rust-lang/rust/issues/31151\nFixes https://github.com/rust-lang/rust/issues/32159\nFixes https://github.com/rust-lang/rust/issues/34484\nImproves https://github.com/rust-lang/rust-packaging/issues/50\n\nSigned-off-by: Peter Atashian <retep998@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1b33b4fdc74e0a0b9e48a7f0fd5909d5984979a", "html_url": "https://github.com/rust-lang/rust/commit/a1b33b4fdc74e0a0b9e48a7f0fd5909d5984979a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1b33b4fdc74e0a0b9e48a7f0fd5909d5984979a/comments", "author": {"login": "retep998", "id": 666308, "node_id": "MDQ6VXNlcjY2NjMwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/666308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/retep998", "html_url": "https://github.com/retep998", "followers_url": "https://api.github.com/users/retep998/followers", "following_url": "https://api.github.com/users/retep998/following{/other_user}", "gists_url": "https://api.github.com/users/retep998/gists{/gist_id}", "starred_url": "https://api.github.com/users/retep998/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/retep998/subscriptions", "organizations_url": "https://api.github.com/users/retep998/orgs", "repos_url": "https://api.github.com/users/retep998/repos", "events_url": "https://api.github.com/users/retep998/events{/privacy}", "received_events_url": "https://api.github.com/users/retep998/received_events", "type": "User", "site_admin": false}, "committer": {"login": "retep998", "id": 666308, "node_id": "MDQ6VXNlcjY2NjMwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/666308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/retep998", "html_url": "https://github.com/retep998", "followers_url": "https://api.github.com/users/retep998/followers", "following_url": "https://api.github.com/users/retep998/following{/other_user}", "gists_url": "https://api.github.com/users/retep998/gists{/gist_id}", "starred_url": "https://api.github.com/users/retep998/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/retep998/subscriptions", "organizations_url": "https://api.github.com/users/retep998/orgs", "repos_url": "https://api.github.com/users/retep998/repos", "events_url": "https://api.github.com/users/retep998/events{/privacy}", "received_events_url": "https://api.github.com/users/retep998/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "126af085be2b760b859d073d8aff164572ef7d4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/126af085be2b760b859d073d8aff164572ef7d4a", "html_url": "https://github.com/rust-lang/rust/commit/126af085be2b760b859d073d8aff164572ef7d4a"}], "stats": {"total": 441, "additions": 260, "deletions": 181}, "files": [{"sha": "70968f19177925e9fad1ef845299517b0f0a9a66", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a1b33b4fdc74e0a0b9e48a7f0fd5909d5984979a/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1b33b4fdc74e0a0b9e48a7f0fd5909d5984979a/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=a1b33b4fdc74e0a0b9e48a7f0fd5909d5984979a", "patch": "@@ -136,14 +136,17 @@ pub fn build_link_meta<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     return r;\n }\n \n-pub fn get_linker(sess: &Session) -> (String, Command) {\n+// The third parameter is for an extra path to add to PATH for MSVC\n+// cross linkers for host toolchain DLL dependencies\n+pub fn get_linker(sess: &Session) -> (String, Command, Option<PathBuf>) {\n     if let Some(ref linker) = sess.opts.cg.linker {\n-        (linker.clone(), Command::new(linker))\n+        (linker.clone(), Command::new(linker), None)\n     } else if sess.target.target.options.is_like_msvc {\n-        (\"link.exe\".to_string(), msvc::link_exe_cmd(sess))\n+        let (cmd, host) = msvc::link_exe_cmd(sess);\n+        (\"link.exe\".to_string(), cmd, host)\n     } else {\n         (sess.target.target.options.linker.clone(),\n-         Command::new(&sess.target.target.options.linker))\n+         Command::new(&sess.target.target.options.linker), None)\n     }\n }\n \n@@ -153,17 +156,15 @@ pub fn get_ar_prog(sess: &Session) -> String {\n     })\n }\n \n-fn command_path(sess: &Session) -> OsString {\n+fn command_path(sess: &Session, extra: Option<PathBuf>) -> OsString {\n     // The compiler's sysroot often has some bundled tools, so add it to the\n     // PATH for the child.\n     let mut new_path = sess.host_filesearch(PathKind::All)\n                            .get_tools_search_paths();\n     if let Some(path) = env::var_os(\"PATH\") {\n         new_path.extend(env::split_paths(&path));\n     }\n-    if sess.target.target.options.is_like_msvc {\n-        new_path.extend(msvc::host_dll_path());\n-    }\n+    new_path.extend(extra);\n     env::join_paths(new_path).unwrap()\n }\n \n@@ -379,7 +380,7 @@ fn archive_config<'a>(sess: &'a Session,\n         src: input.map(|p| p.to_path_buf()),\n         lib_search_paths: archive_search_paths(sess),\n         ar_prog: get_ar_prog(sess),\n-        command_path: command_path(sess),\n+        command_path: command_path(sess, None),\n     }\n }\n \n@@ -616,8 +617,8 @@ fn link_natively(sess: &Session,\n     info!(\"preparing {:?} from {:?} to {:?}\", crate_type, objects, out_filename);\n \n     // The invocations of cc share some flags across platforms\n-    let (pname, mut cmd) = get_linker(sess);\n-    cmd.env(\"PATH\", command_path(sess));\n+    let (pname, mut cmd, extra) = get_linker(sess);\n+    cmd.env(\"PATH\", command_path(sess, extra));\n \n     let root = sess.target_filesearch(PathKind::Native).get_lib_path();\n     cmd.args(&sess.target.target.options.pre_link_args);\n@@ -682,10 +683,15 @@ fn link_natively(sess: &Session,\n             info!(\"linker stdout:\\n{}\", escape_string(&prog.stdout[..]));\n         },\n         Err(e) => {\n-            // Trying to diagnose https://github.com/rust-lang/rust/issues/33844\n             sess.struct_err(&format!(\"could not exec the linker `{}`: {}\", pname, e))\n                 .note(&format!(\"{:?}\", &cmd))\n                 .emit();\n+            if sess.target.target.options.is_like_msvc && e.kind() == io::ErrorKind::NotFound {\n+                sess.note_without_error(\"the msvc targets depend on the msvc linker \\\n+                    but `link.exe` was not found\");\n+                sess.note_without_error(\"please ensure that VS 2013 or VS 2015 was installed \\\n+                    with the Visual C++ option\");\n+            }\n             sess.abort_if_errors();\n         }\n     }"}, {"sha": "c10312a8e17103f1d147367224e4c6e07db49df4", "filename": "src/librustc_trans/back/msvc/arch.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a1b33b4fdc74e0a0b9e48a7f0fd5909d5984979a/src%2Flibrustc_trans%2Fback%2Fmsvc%2Farch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1b33b4fdc74e0a0b9e48a7f0fd5909d5984979a/src%2Flibrustc_trans%2Fback%2Fmsvc%2Farch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fmsvc%2Farch.rs?ref=a1b33b4fdc74e0a0b9e48a7f0fd5909d5984979a", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(non_camel_case_types, non_snake_case)]\n+\n+use libc::c_void;\n+use std::mem;\n+\n+type DWORD = u32;\n+type WORD = u16;\n+type LPVOID = *mut c_void;\n+type DWORD_PTR = usize;\n+\n+const PROCESSOR_ARCHITECTURE_INTEL: WORD = 0;\n+const PROCESSOR_ARCHITECTURE_AMD64: WORD = 9;\n+\n+#[repr(C)]\n+struct SYSTEM_INFO {\n+    wProcessorArchitecture: WORD,\n+    _wReserved: WORD,\n+    _dwPageSize: DWORD,\n+    _lpMinimumApplicationAddress: LPVOID,\n+    _lpMaximumApplicationAddress: LPVOID,\n+    _dwActiveProcessorMask: DWORD_PTR,\n+    _dwNumberOfProcessors: DWORD,\n+    _dwProcessorType: DWORD,\n+    _dwAllocationGranularity: DWORD,\n+    _wProcessorLevel: WORD,\n+    _wProcessorRevision: WORD,\n+}\n+\n+extern \"system\" {\n+    fn GetNativeSystemInfo(lpSystemInfo: *mut SYSTEM_INFO);\n+}\n+\n+pub enum Arch {\n+    X86,\n+    Amd64,\n+}\n+\n+pub fn host_arch() -> Option<Arch> {\n+    let mut info = unsafe { mem::zeroed() };\n+    unsafe { GetNativeSystemInfo(&mut info) };\n+    match info.wProcessorArchitecture {\n+        PROCESSOR_ARCHITECTURE_INTEL => Some(Arch::X86),\n+        PROCESSOR_ARCHITECTURE_AMD64 => Some(Arch::Amd64),\n+        _ => None,\n+    }\n+}"}, {"sha": "16aef6ee8ca3543047ba07c85d867f9eae1de881", "filename": "src/librustc_trans/back/msvc/mod.rs", "status": "modified", "additions": 185, "deletions": 168, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/a1b33b4fdc74e0a0b9e48a7f0fd5909d5984979a/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1b33b4fdc74e0a0b9e48a7f0fd5909d5984979a/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fmod.rs?ref=a1b33b4fdc74e0a0b9e48a7f0fd5909d5984979a", "patch": "@@ -31,8 +31,18 @@\n //! paths/files is based on Microsoft's logic in their vcvars bat files, but\n //! comments can also be found below leading through the various code paths.\n \n+// A simple macro to make this option mess easier to read\n+macro_rules! otry {\n+    ($expr:expr) => (match $expr {\n+        Some(val) => val,\n+        None => return None,\n+    })\n+}\n+\n #[cfg(windows)]\n mod registry;\n+#[cfg(windows)]\n+mod arch;\n \n #[cfg(windows)]\n mod platform {\n@@ -42,212 +52,223 @@ mod platform {\n     use std::path::{Path, PathBuf};\n     use std::process::Command;\n     use session::Session;\n-    use super::registry::{LOCAL_MACHINE};\n+    use super::arch::{host_arch, Arch};\n+    use super::registry::LOCAL_MACHINE;\n \n-    // Cross toolchains depend on dlls from the host toolchain\n-    // We can't just add it to the Command's PATH in `link_exe_cmd` because it\n-    // is later overridden so we publicly expose it here instead\n-    pub fn host_dll_path() -> Option<PathBuf> {\n-        get_vc_dir().and_then(|(_, vcdir)| {\n-            host_dll_subdir().map(|sub| {\n-                vcdir.join(\"bin\").join(sub)\n+    // First we need to figure out whether the environment is already correctly\n+    // configured by vcvars. We do this by looking at the environment variable\n+    // `VCINSTALLDIR` which is always set by vcvars, and unlikely to be set\n+    // otherwise. If it is defined, then we find `link.exe` in `PATH and trust\n+    // that everything else is configured correctly.\n+    //\n+    // If `VCINSTALLDIR` wasn't defined (or we couldn't find the linker where\n+    // it claimed it should be), then we resort to finding everything\n+    // ourselves. First we find where the latest version of MSVC is installed\n+    // and what version it is. Then based on the version we find the\n+    // appropriate SDKs.\n+    //\n+    // If despite our best efforts we are still unable to find MSVC then we\n+    // just blindly call `link.exe` and hope for the best.\n+    //\n+    // This code only supports VC 11 through 15. For versions older than that\n+    // the user will need to manually execute the appropriate vcvars bat file\n+    // and it should hopefully work.\n+    //\n+    // The second member of the tuple we return is the directory for the host\n+    // linker toolchain, which is necessary when using the cross linkers.\n+    pub fn link_exe_cmd(sess: &Session) -> (Command, Option<PathBuf>) {\n+        let arch = &sess.target.target.arch;\n+        env::var_os(\"VCINSTALLDIR\").and_then(|_| {\n+            debug!(\"Detected that vcvars was already run.\");\n+            let path = otry!(env::var_os(\"PATH\"));\n+            // Mingw has its own link which is not the link we want so we\n+            // look for `cl.exe` too as a precaution.\n+            env::split_paths(&path).find(|path| {\n+                path.join(\"cl.exe\").is_file()\n+                    && path.join(\"link.exe\").is_file()\n+            }).map(|path| {\n+                (Command::new(path.join(\"link.exe\")), None)\n             })\n+        }).or_else(|| {\n+            None.or_else(|| {\n+                find_msvc_latest(arch, \"15.0\")\n+            }).or_else(|| {\n+                find_msvc_latest(arch, \"14.0\")\n+            }).or_else(|| {\n+                find_msvc_12(arch)\n+            }).or_else(|| {\n+                find_msvc_11(arch)\n+            }).map(|(cmd, path)| (cmd, Some(path)))\n+        }).unwrap_or_else(|| {\n+            debug!(\"Failed to locate linker.\");\n+            (Command::new(\"link.exe\"), None)\n         })\n     }\n \n-    pub fn link_exe_cmd(sess: &Session) -> Command {\n-        let arch = &sess.target.target.arch;\n-        let (binsub, libsub, vclibsub) =\n-            match (bin_subdir(arch), lib_subdir(arch), vc_lib_subdir(arch)) {\n-            (Some(x), Some(y), Some(z)) => (x, y, z),\n-            _ => return Command::new(\"link.exe\"),\n-        };\n+    // For MSVC 14 or newer we need to find the Universal CRT as well as either\n+    // the Windows 10 SDK or Windows 8.1 SDK.\n+    fn find_msvc_latest(arch: &str, ver: &str) -> Option<(Command, PathBuf)> {\n+        let vcdir = otry!(get_vc_dir(ver));\n+        let (mut cmd, host) = otry!(get_linker(&vcdir, arch));\n+        let sub = otry!(lib_subdir(arch));\n+        let ucrt = otry!(get_ucrt_dir());\n+        debug!(\"Found Universal CRT {:?}\", ucrt);\n+        add_lib(&mut cmd, &ucrt.join(\"ucrt\").join(sub));\n+        if let Some(dir) = get_sdk10_dir() {\n+            debug!(\"Found Win10 SDK {:?}\", dir);\n+            add_lib(&mut cmd, &dir.join(\"um\").join(sub));\n+        } else if let Some(dir) = get_sdk81_dir() {\n+            debug!(\"Found Win8.1 SDK {:?}\", dir);\n+            add_lib(&mut cmd, &dir.join(\"um\").join(sub));\n+        } else {\n+            return None\n+        }\n+        Some((cmd, host))\n+    }\n \n-        // First we need to figure out whether the environment is already correctly\n-        // configured by vcvars. We do this by looking at the environment variable\n-        // `VCINSTALLDIR` which is always set by vcvars, and unlikely to be set\n-        // otherwise. If it is defined, then we derive the path to `link.exe` from\n-        // that and trust that everything else is configured correctly.\n-        //\n-        // If `VCINSTALLDIR` wasn't defined (or we couldn't find the linker where it\n-        // claimed it should be), then we resort to finding everything ourselves.\n-        // First we find where the latest version of MSVC is installed and what\n-        // version it is. Then based on the version we find the appropriate SDKs.\n-        //\n-        // For MSVC 14 (VS 2015) we look for the Win10 SDK and failing that we look\n-        // for the Win8.1 SDK. We also look for the Universal CRT.\n-        //\n-        // For MSVC 12 (VS 2013) we look for the Win8.1 SDK.\n-        //\n-        // For MSVC 11 (VS 2012) we look for the Win8 SDK.\n-        //\n-        // For all other versions the user has to execute the appropriate vcvars bat\n-        // file themselves to configure the environment.\n-        //\n-        // If despite our best efforts we are still unable to find MSVC then we just\n-        // blindly call `link.exe` and hope for the best.\n-        return env::var_os(\"VCINSTALLDIR\").and_then(|dir| {\n-            debug!(\"Environment already configured by user. Assuming it works.\");\n-            let mut p = PathBuf::from(dir);\n-            p.push(\"bin\");\n-            p.push(binsub);\n-            p.push(\"link.exe\");\n-            if !p.is_file() { return None }\n-            Some(Command::new(p))\n-        }).or_else(|| {\n-            get_vc_dir().and_then(|(ver, vcdir)| {\n-                debug!(\"Found VC installation directory {:?}\", vcdir);\n-                let linker = vcdir.clone().join(\"bin\").join(binsub).join(\"link.exe\");\n-                if !linker.is_file() { return None }\n-                let mut cmd = Command::new(linker);\n-                add_lib(&mut cmd, &vcdir.join(\"lib\").join(vclibsub));\n-                if ver == \"14.0\" {\n-                    if let Some(dir) = get_ucrt_dir() {\n-                        debug!(\"Found Universal CRT {:?}\", dir);\n-                        add_lib(&mut cmd, &dir.join(\"ucrt\").join(libsub));\n-                    }\n-                    if let Some(dir) = get_sdk10_dir() {\n-                        debug!(\"Found Win10 SDK {:?}\", dir);\n-                        add_lib(&mut cmd, &dir.join(\"um\").join(libsub));\n-                    } else if let Some(dir) = get_sdk81_dir() {\n-                        debug!(\"Found Win8.1 SDK {:?}\", dir);\n-                        add_lib(&mut cmd, &dir.join(\"um\").join(libsub));\n-                    }\n-                } else if ver == \"12.0\" {\n-                    if let Some(dir) = get_sdk81_dir() {\n-                        debug!(\"Found Win8.1 SDK {:?}\", dir);\n-                        add_lib(&mut cmd, &dir.join(\"um\").join(libsub));\n-                    }\n-                } else { // ver == \"11.0\"\n-                    if let Some(dir) = get_sdk8_dir() {\n-                        debug!(\"Found Win8 SDK {:?}\", dir);\n-                        add_lib(&mut cmd, &dir.join(\"um\").join(libsub));\n-                    }\n-                }\n-                Some(cmd)\n-            })\n-        }).unwrap_or_else(|| {\n-            debug!(\"Failed to locate linker.\");\n-            Command::new(\"link.exe\")\n-        });\n+    // For MSVC 12 we need to find the Windows 8.1 SDK.\n+    fn find_msvc_12(arch: &str) -> Option<(Command, PathBuf)> {\n+        let vcdir = otry!(get_vc_dir(\"12.0\"));\n+        let (mut cmd, host) = otry!(get_linker(&vcdir, arch));\n+        let sub = otry!(lib_subdir(arch));\n+        let sdk81 = otry!(get_sdk81_dir());\n+        debug!(\"Found Win8.1 SDK {:?}\", sdk81);\n+        add_lib(&mut cmd, &sdk81.join(\"um\").join(sub));\n+        Some((cmd, host))\n+    }\n+\n+    // For MSVC 11 we need to find the Windows 8 SDK.\n+    fn find_msvc_11(arch: &str) -> Option<(Command, PathBuf)> {\n+        let vcdir = otry!(get_vc_dir(\"11.0\"));\n+        let (mut cmd, host) = otry!(get_linker(&vcdir, arch));\n+        let sub = otry!(lib_subdir(arch));\n+        let sdk8 = otry!(get_sdk8_dir());\n+        debug!(\"Found Win8 SDK {:?}\", sdk8);\n+        add_lib(&mut cmd, &sdk8.join(\"um\").join(sub));\n+        Some((cmd, host))\n     }\n-    // A convenience function to make the above code simpler\n+\n+    // A convenience function to append library paths.\n     fn add_lib(cmd: &mut Command, lib: &Path) {\n         let mut arg: OsString = \"/LIBPATH:\".into();\n         arg.push(lib);\n         cmd.arg(arg);\n     }\n \n-    // To find MSVC we look in a specific registry key for the newest of the\n-    // three versions that we support.\n-    fn get_vc_dir() -> Option<(&'static str, PathBuf)> {\n-        LOCAL_MACHINE.open(r\"SOFTWARE\\Microsoft\\VisualStudio\\SxS\\VC7\".as_ref())\n-        .ok().and_then(|key| {\n-            [\"14.0\", \"12.0\", \"11.0\"].iter().filter_map(|ver| {\n-                key.query_str(ver).ok().map(|p| (*ver, p.into()))\n-            }).next()\n-        })\n+    // Given a possible MSVC installation directory, we look for the linker and\n+    // then add the MSVC library path.\n+    fn get_linker(path: &Path, arch: &str) -> Option<(Command, PathBuf)> {\n+        debug!(\"Looking for linker in {:?}\", path);\n+        bin_subdir(arch).into_iter().map(|(sub, host)| {\n+            (path.join(\"bin\").join(sub).join(\"link.exe\"),\n+             path.join(\"bin\").join(host))\n+        }).filter(|&(ref path, _)| {\n+            path.is_file()\n+        }).map(|(path, host)| {\n+            (Command::new(path), host)\n+        }).filter_map(|(mut cmd, host)| {\n+            let sub = otry!(vc_lib_subdir(arch));\n+            add_lib(&mut cmd, &path.join(\"lib\").join(sub));\n+            Some((cmd, host))\n+        }).next()\n+    }\n+\n+    // To find MSVC we look in a specific registry key for the version we are\n+    // trying to find.\n+    fn get_vc_dir(ver: &str) -> Option<PathBuf> {\n+        let key = otry!(LOCAL_MACHINE\n+            .open(r\"SOFTWARE\\Microsoft\\VisualStudio\\SxS\\VC7\".as_ref()).ok());\n+        let path = otry!(key.query_str(ver).ok());\n+        Some(path.into())\n     }\n \n     // To find the Universal CRT we look in a specific registry key for where\n     // all the Universal CRTs are located and then sort them asciibetically to\n     // find the newest version. While this sort of sorting isn't ideal,  it is\n     // what vcvars does so that's good enough for us.\n     fn get_ucrt_dir() -> Option<PathBuf> {\n-        LOCAL_MACHINE.open(r\"SOFTWARE\\Microsoft\\Windows Kits\\Installed Roots\".as_ref())\n-        .ok().and_then(|key| {\n-            key.query_str(\"KitsRoot10\").ok()\n-        }).and_then(|root| {\n-            fs::read_dir(Path::new(&root).join(\"Lib\")).ok()\n-        }).and_then(|readdir| {\n-            let mut dirs: Vec<_> = readdir.filter_map(|dir| {\n-                dir.ok()\n-            }).map(|dir| {\n-                dir.path()\n-            }).filter(|dir| {\n-                dir.components().last().and_then(|c| {\n-                    c.as_os_str().to_str()\n-                }).map(|c| c.starts_with(\"10.\")).unwrap_or(false)\n-            }).collect();\n-            dirs.sort();\n-            dirs.pop()\n-        })\n+        let key = otry!(LOCAL_MACHINE\n+            .open(r\"SOFTWARE\\Microsoft\\Windows Kits\\Installed Roots\".as_ref()).ok());\n+        let root = otry!(key.query_str(\"KitsRoot10\").ok());\n+        let readdir = otry!(fs::read_dir(Path::new(&root).join(\"lib\")).ok());\n+        readdir.filter_map(|dir| {\n+            dir.ok()\n+        }).map(|dir| {\n+            dir.path()\n+        }).filter(|dir| {\n+            dir.components().last().and_then(|c| {\n+                c.as_os_str().to_str()\n+            }).map(|c| {\n+                c.starts_with(\"10.\") && dir.join(\"ucrt\").is_dir()\n+            }).unwrap_or(false)\n+        }).max()\n     }\n \n     // Vcvars finds the correct version of the Windows 10 SDK by looking\n-    // for the include um/Windows.h because sometimes a given version will\n+    // for the include `um\\Windows.h` because sometimes a given version will\n     // only have UCRT bits without the rest of the SDK. Since we only care about\n-    // libraries and not includes, we just look for the folder `um` in the lib\n-    // section. Like we do for the Universal CRT, we sort the possibilities\n+    // libraries and not includes, we instead look for `um\\x64\\kernel32.lib`.\n+    // Since the 32-bit and 64-bit libraries are always installed together we\n+    // only need to bother checking x64, making this code a tiny bit simpler.\n+    // Like we do for the Universal CRT, we sort the possibilities\n     // asciibetically to find the newest one as that is what vcvars does.\n     fn get_sdk10_dir() -> Option<PathBuf> {\n-        LOCAL_MACHINE.open(r\"SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows\\v10.0\".as_ref())\n-        .ok().and_then(|key| {\n-            key.query_str(\"InstallationFolder\").ok()\n-        }).and_then(|root| {\n-            fs::read_dir(Path::new(&root).join(\"lib\")).ok()\n-        }).and_then(|readdir| {\n-            let mut dirs: Vec<_> = readdir.filter_map(|dir| dir.ok())\n-                .map(|dir| dir.path()).collect();\n-            dirs.sort();\n-            dirs.into_iter().rev().filter(|dir| {\n-                dir.join(\"um\").is_dir()\n-            }).next()\n-        })\n+        let key = otry!(LOCAL_MACHINE\n+            .open(r\"SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows\\v10.0\".as_ref()).ok());\n+        let root = otry!(key.query_str(\"InstallationFolder\").ok());\n+        let readdir = otry!(fs::read_dir(Path::new(&root).join(\"lib\")).ok());\n+        let mut dirs: Vec<_> = readdir.filter_map(|dir| dir.ok())\n+            .map(|dir| dir.path()).collect();\n+        dirs.sort();\n+        dirs.into_iter().rev().filter(|dir| {\n+            dir.join(\"um\").join(\"x64\").join(\"kernel32.lib\").is_file()\n+        }).next()\n     }\n \n     // Interestingly there are several subdirectories, `win7` `win8` and\n     // `winv6.3`. Vcvars seems to only care about `winv6.3` though, so the same\n     // applies to us. Note that if we were targetting kernel mode drivers\n     // instead of user mode applications, we would care.\n     fn get_sdk81_dir() -> Option<PathBuf> {\n-        LOCAL_MACHINE.open(r\"SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows\\v8.1\".as_ref())\n-        .ok().and_then(|key| {\n-            key.query_str(\"InstallationFolder\").ok()\n-        }).map(|root| {\n-            Path::new(&root).join(\"lib\").join(\"winv6.3\")\n-        })\n+        let key = otry!(LOCAL_MACHINE\n+            .open(r\"SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows\\v8.1\".as_ref()).ok());\n+        let root = otry!(key.query_str(\"InstallationFolder\").ok());\n+        Some(Path::new(&root).join(\"lib\").join(\"winv6.3\"))\n     }\n \n     fn get_sdk8_dir() -> Option<PathBuf> {\n-        LOCAL_MACHINE.open(r\"SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows\\v8.0\".as_ref())\n-        .ok().and_then(|key| {\n-            key.query_str(\"InstallationFolder\").ok()\n-        }).map(|root| {\n-            Path::new(&root).join(\"lib\").join(\"win8\")\n-        })\n+        let key = otry!(LOCAL_MACHINE\n+            .open(r\"SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows\\v8.0\".as_ref()).ok());\n+        let root = otry!(key.query_str(\"InstallationFolder\").ok());\n+        Some(Path::new(&root).join(\"lib\").join(\"win8\"))\n     }\n \n     // When choosing the linker toolchain to use, we have to choose the one\n     // which matches the host architecture. Otherwise we end up in situations\n     // where someone on 32-bit Windows is trying to cross compile to 64-bit and\n     // it tries to invoke the native 64-bit linker which won't work.\n     //\n-    // FIXME - This currently functions based on the host architecture of rustc\n-    // itself but it should instead detect the bitness of the OS itself.\n+    // For the return value of this function, the first member of the tuple is\n+    // the folder of the linker we will be invoking, while the second member\n+    // is the folder of the host toolchain for that linker which is essential\n+    // when using a cross linker. We return a Vec since on x64 there are often\n+    // two linkers that can target the architecture we desire. The 64-bit host\n+    // linker is preferred, and hence first, due to 64-bit allowing it more\n+    // address space to work with and potentially being faster.\n     //\n     // FIXME - Figure out what happens when the host architecture is arm.\n-    //\n-    // FIXME - Some versions of MSVC may not come with all these toolchains.\n-    // Consider returning an array of toolchains and trying them one at a time\n-    // until the linker is found.\n-    fn bin_subdir(arch: &str) -> Option<&'static str> {\n-        if cfg!(target_arch = \"x86_64\") {\n-            match arch {\n-                \"x86\" => Some(\"amd64_x86\"),\n-                \"x86_64\" => Some(\"amd64\"),\n-                \"arm\" => Some(\"amd64_arm\"),\n-                _ => None,\n-            }\n-        } else if cfg!(target_arch = \"x86\") {\n-            match arch {\n-                \"x86\" => Some(\"\"),\n-                \"x86_64\" => Some(\"x86_amd64\"),\n-                \"arm\" => Some(\"x86_arm\"),\n-                _ => None,\n-            }\n-        } else { None }\n+    fn bin_subdir(arch: &str) -> Vec<(&'static str, &'static str)> {\n+        match (arch, host_arch()) {\n+            (\"x86\", Some(Arch::X86)) => vec![(\"\", \"\")],\n+            (\"x86\", Some(Arch::Amd64)) => vec![(\"amd64_x86\", \"amd64\"), (\"\", \"\")],\n+            (\"x86_64\", Some(Arch::X86)) => vec![(\"x86_amd64\", \"\")],\n+            (\"x86_64\", Some(Arch::Amd64)) => vec![(\"amd64\", \"amd64\"), (\"x86_amd64\", \"\")],\n+            (\"arm\", Some(Arch::X86)) => vec![(\"x86_arm\", \"\")],\n+            (\"arm\", Some(Arch::Amd64)) => vec![(\"amd64_arm\", \"amd64\"), (\"x86_arm\", \"\")],\n+            _ => vec![],\n+        }\n     }\n+\n     fn lib_subdir(arch: &str) -> Option<&'static str> {\n         match arch {\n             \"x86\" => Some(\"x86\"),\n@@ -256,6 +277,7 @@ mod platform {\n             _ => None,\n         }\n     }\n+\n     // MSVC's x86 libraries are not in a subfolder\n     fn vc_lib_subdir(arch: &str) -> Option<&'static str> {\n         match arch {\n@@ -265,11 +287,6 @@ mod platform {\n             _ => None,\n         }\n     }\n-    fn host_dll_subdir() -> Option<&'static str> {\n-        if cfg!(target_arch = \"x86_64\") { Some(\"amd64\") }\n-        else if cfg!(target_arch = \"x86\") { Some(\"\") }\n-        else { None }\n-    }\n }\n \n // If we're not on Windows, then there's no registry to search through and MSVC\n@@ -279,9 +296,9 @@ mod platform {\n     use std::path::PathBuf;\n     use std::process::Command;\n     use session::Session;\n-    pub fn link_exe_cmd(_sess: &Session) -> Command {\n-        Command::new(\"link.exe\")\n+    pub fn link_exe_cmd(_sess: &Session) -> (Command, Option<PathBuf>) {\n+        (Command::new(\"link.exe\"), None)\n     }\n-    pub fn host_dll_path() -> Option<PathBuf> { None }\n }\n+\n pub use self::platform::*;"}, {"sha": "59f8728fa4526b553f110c84a63cc16c3cf65f7d", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1b33b4fdc74e0a0b9e48a7f0fd5909d5984979a/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1b33b4fdc74e0a0b9e48a7f0fd5909d5984979a/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=a1b33b4fdc74e0a0b9e48a7f0fd5909d5984979a", "patch": "@@ -970,7 +970,7 @@ fn run_work_multithreaded(sess: &Session,\n }\n \n pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n-    let (pname, mut cmd) = get_linker(sess);\n+    let (pname, mut cmd, _) = get_linker(sess);\n \n     cmd.arg(\"-c\").arg(\"-o\").arg(&outputs.path(OutputType::Object))\n                            .arg(&outputs.temp_path(OutputType::Assembly));"}]}