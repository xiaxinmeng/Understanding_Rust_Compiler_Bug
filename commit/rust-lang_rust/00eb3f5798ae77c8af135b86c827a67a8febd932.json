{"sha": "00eb3f5798ae77c8af135b86c827a67a8febd932", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwZWIzZjU3OThhZTc3YzhhZjEzNWI4NmM4MjdhNjdhOGZlYmQ5MzI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-11T02:35:59Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-11T02:36:33Z"}, "message": "rustc: Sketch out translation of interior vector literals and take/drop glue", "tree": {"sha": "6aaa49d89c58b2678e5c435326bd74d608e96089", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6aaa49d89c58b2678e5c435326bd74d608e96089"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00eb3f5798ae77c8af135b86c827a67a8febd932", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00eb3f5798ae77c8af135b86c827a67a8febd932", "html_url": "https://github.com/rust-lang/rust/commit/00eb3f5798ae77c8af135b86c827a67a8febd932", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00eb3f5798ae77c8af135b86c827a67a8febd932/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0a80104a31ae82c336299de44f4bc9959eedc95", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0a80104a31ae82c336299de44f4bc9959eedc95", "html_url": "https://github.com/rust-lang/rust/commit/b0a80104a31ae82c336299de44f4bc9959eedc95"}], "stats": {"total": 274, "additions": 251, "deletions": 23}, "files": [{"sha": "106aba39be6fd15196c20e31e1b8ce80e3bf584f", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/00eb3f5798ae77c8af135b86c827a67a8febd932/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00eb3f5798ae77c8af135b86c827a67a8febd932/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=00eb3f5798ae77c8af135b86c827a67a8febd932", "patch": "@@ -66,6 +66,17 @@ const int closure_elt_target = 1;\n const int closure_elt_bindings = 2;\n const int closure_elt_ty_params = 3;\n \n+const uint ivec_default_size = 16u;\n+\n+const uint ivec_elt_len = 0u;\n+const uint ivec_elt_alen = 1u;\n+const uint ivec_elt_elems = 2u;\n+const uint ivec_heap_stub_elt_zero = 0u;\n+const uint ivec_heap_stub_elt_alen = 1u;\n+const uint ivec_heap_stub_elt_ptr = 2u;\n+const uint ivec_heap_elt_len = 0u;\n+const uint ivec_heap_elt_elems = 1u;\n+\n \n const int worst_case_glue_call_args = 7;\n "}, {"sha": "8f891b73f1c8d30e373c6760d6831e7d71648af4", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 223, "deletions": 12, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/00eb3f5798ae77c8af135b86c827a67a8febd932/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00eb3f5798ae77c8af135b86c827a67a8febd932/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=00eb3f5798ae77c8af135b86c827a67a8febd932", "patch": "@@ -572,22 +572,28 @@ fn T_opaque_vec_ptr() -> TypeRef {\n // Interior vector.\n //\n // TODO: Support user-defined vector sizes.\n-fn T_ivec(TypeRef t) -> TypeRef {\n-    ret T_struct([T_int(),          // Length (\"fill\")\n-                  T_int(),          // Alloc (if zero, it's heapified)\n-                  T_array(t, 16u)   // Body elements\n-                  ]);\n+fn T_ivec() -> TypeRef {\n+    ret T_struct([T_int(),          // Length (\"fill\"; if zero, heapified)\n+                  T_int(),          // Alloc\n+                  T_array(T_i8(), abi::ivec_default_size)]);  // Body elements\n }\n \n // Interior vector on the heap. Cast to this when the allocated length (second\n // element of T_ivec above) is zero.\n fn T_ivec_heap(TypeRef t) -> TypeRef {\n-    ret T_struct([T_int(),          // Length (\"fill\")\n-                  T_int(),          // Alloc (zero in this case)\n-                  T_ptr(T_struct([T_int(),              // Real alloc\n+    ret T_struct([T_int(),          // Length (zero)\n+                  T_int(),          // Alloc\n+                  T_ptr(T_struct([T_int(),              // Real length\n                                   T_array(t, 0u)]))]);  // Body elements\n }\n \n+fn T_opaque_ivec_heap() -> TypeRef {\n+    ret T_struct([T_int(),          // Length (zero)\n+                  T_int(),          // Alloc\n+                  T_ptr(T_struct([T_int(),                  // Real length\n+                                  T_array(T_i8(), 0u)]))]); // Body elements\n+}\n+\n fn T_str() -> TypeRef {\n     ret T_vec(T_i8());\n }\n@@ -862,7 +868,7 @@ fn type_of_inner(&@crate_ctxt cx, &span sp, &ty::t t) -> TypeRef {\n         }\n         case (ty::ty_char) { llty = T_char(); }\n         case (ty::ty_str) { llty = T_ptr(T_str()); }\n-        case (ty::ty_istr) { llty = T_ivec(T_i8()); }\n+        case (ty::ty_istr) { llty = T_ivec(); }\n         case (ty::ty_tag(_, _)) {\n             if (ty::type_has_dynamic_size(cx.tcx, t)) {\n                 llty = T_opaque_tag(cx.tn);\n@@ -878,7 +884,7 @@ fn type_of_inner(&@crate_ctxt cx, &span sp, &ty::t t) -> TypeRef {\n             llty = T_ptr(T_vec(type_of_inner(cx, sp, mt.ty)));\n         }\n         case (ty::ty_ivec(?mt)) {\n-            llty = T_ivec(type_of_inner(cx, sp, mt.ty));\n+            llty = T_ivec();\n         }\n         case (ty::ty_ptr(?mt)) {\n             llty = T_ptr(type_of_inner(cx, sp, mt.ty));\n@@ -989,6 +995,13 @@ fn type_of_ty_param_count_and_ty(@local_ctxt lcx, &span sp,\n     ret type_of(lcx.ccx, sp, tpt._1);\n }\n \n+fn type_of_or_i8(&@block_ctxt bcx, ty::t typ) -> TypeRef {\n+    if (ty::type_has_dynamic_size(bcx.fcx.lcx.ccx.tcx, typ)) {\n+        ret T_i8();\n+    }\n+    ret type_of(bcx.fcx.lcx.ccx, bcx.sp, typ);\n+}\n+\n \n // Name sanitation. LLVM will happily accept identifiers with weird names, but\n // gas doesn't!\n@@ -1058,6 +1071,10 @@ fn C_int(int i) -> ValueRef {\n     ret C_integral(T_int(), i as uint, True);\n }\n \n+fn C_uint(uint i) -> ValueRef {\n+    ret C_integral(T_int(), i, False);\n+}\n+\n fn C_u8(uint i) -> ValueRef {\n     ret C_integral(T_i8(), i, False);\n }\n@@ -2635,6 +2652,64 @@ fn make_numerical_cmp_glue(&@block_ctxt cx, ValueRef lhs, ValueRef rhs,\n     r.bcx.build.RetVoid();\n }\n \n+// Returns the length of an interior vector and a pointer to its first\n+// element, in that order.\n+fn get_ivec_len_and_data(&@block_ctxt bcx, ValueRef v, ty::t unit_ty) ->\n+        tup(ValueRef, ValueRef, @block_ctxt) {\n+    auto llunitty = type_of_or_i8(bcx, unit_ty);\n+\n+    auto stack_len = bcx.build.Load(bcx.build.GEP(v,\n+        [C_int(0), C_uint(abi::ivec_elt_len)]));\n+    auto stack_elem = bcx.build.GEP(v, [C_int(0),\n+                                        C_uint(abi::ivec_elt_elems)]);\n+    stack_elem = bcx.build.PointerCast(stack_elem, T_ptr(llunitty));\n+\n+    auto on_heap = bcx.build.ICmp(lib::llvm::LLVMIntEQ, stack_len, C_int(0));\n+\n+    auto on_heap_cx = new_sub_block_ctxt(bcx, \"on_heap\");\n+    auto next_cx = new_sub_block_ctxt(bcx, \"next\");\n+    bcx.build.CondBr(on_heap, on_heap_cx.llbb, next_cx.llbb);\n+\n+    auto heap_stub = on_heap_cx.build.PointerCast(v,\n+        T_ptr(T_ivec_heap(llunitty)));\n+    auto heap_ptr = on_heap_cx.build.Load(on_heap_cx.build.GEP(\n+        heap_stub, [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)]));\n+\n+    // Check whether the heap pointer is null. If it is, the vector length is\n+    // truly zero.\n+    auto llstubty = T_ivec_heap(llunitty);\n+    auto llheapptrty = struct_elt(llstubty, abi::ivec_heap_stub_elt_ptr);\n+    auto heap_ptr_is_null = on_heap_cx.build.ICmp(lib::llvm::LLVMIntEQ,\n+        heap_ptr, C_null(T_ptr(llheapptrty)));\n+\n+    auto zero_len_cx = new_sub_block_ctxt(bcx, \"zero_len\");\n+    auto nonzero_len_cx = new_sub_block_ctxt(bcx, \"nonzero_len\");\n+    on_heap_cx.build.CondBr(heap_ptr_is_null, zero_len_cx.llbb,\n+                            nonzero_len_cx.llbb);\n+\n+    // Technically this context is unnecessary, but it makes this function\n+    // clearer.\n+    auto zero_len = C_int(0);\n+    auto zero_elem = C_null(T_ptr(llunitty));\n+    zero_len_cx.build.Br(next_cx.llbb);\n+\n+    // If we're here, then we actually have a heapified vector.\n+    auto heap_len = nonzero_len_cx.build.Load(nonzero_len_cx.build.GEP(\n+        heap_ptr, [C_int(0), C_uint(abi::ivec_heap_elt_len)]));\n+    auto heap_elem = nonzero_len_cx.build.GEP(heap_ptr,\n+        [C_int(0), C_uint(abi::ivec_heap_elt_elems), C_int(0)]);\n+    nonzero_len_cx.build.Br(next_cx.llbb);\n+\n+    // Now we can figure out the length of `v` and get a pointer to its first\n+    // element.\n+    auto len = next_cx.build.Phi(T_int(), [stack_len, zero_len, heap_len],\n+        [bcx.llbb, zero_len_cx.llbb, nonzero_len_cx.llbb]);\n+    auto elem = next_cx.build.Phi(T_ptr(llunitty),\n+        [stack_elem, zero_elem, heap_elem],\n+        [bcx.llbb, zero_len_cx.llbb, nonzero_len_cx.llbb]);\n+    ret tup(len, elem, next_cx);\n+}\n+\n type val_pair_fn = fn(&@block_ctxt cx, ValueRef dst, ValueRef src) -> result;\n \n type val_and_ty_fn = fn(&@block_ctxt cx, ValueRef v, ty::t t) -> result;\n@@ -2666,7 +2741,6 @@ fn iter_structural_ty_full(&@block_ctxt cx,\n                            &ty::t t,\n                            &val_pair_and_ty_fn f)\n     -> result {\n-    let result r = res(cx, C_nil());\n \n     fn iter_boxpp(@block_ctxt cx,\n                   ValueRef box_a_cell,\n@@ -2687,6 +2761,45 @@ fn iter_structural_ty_full(&@block_ctxt cx,\n         ret res(next_cx, C_nil());\n     }\n \n+    fn iter_ivec(@block_ctxt bcx,\n+                 ValueRef av,\n+                 ValueRef bv,\n+                 ty::t unit_ty,\n+                 &val_pair_and_ty_fn f) -> result {\n+        // FIXME: \"unimplemented rebinding existing function\" workaround\n+        fn adapter(&@block_ctxt bcx, ValueRef av, ValueRef bv, ty::t unit_ty,\n+                   val_pair_and_ty_fn f) -> result {\n+            ret f(bcx, av, bv, unit_ty);\n+        }\n+\n+        auto llunitty = type_of_or_i8(bcx, unit_ty);\n+\n+        auto rslt = size_of(bcx, unit_ty);\n+        auto unit_sz = rslt.val;\n+        bcx = rslt.bcx;\n+\n+        auto a_len_and_data = get_ivec_len_and_data(bcx, av, unit_ty);\n+        auto a_len = a_len_and_data._0;\n+        auto a_elem = a_len_and_data._1;\n+        bcx = a_len_and_data._2;\n+\n+        auto b_len_and_data = get_ivec_len_and_data(bcx, bv, unit_ty);\n+        auto b_len = b_len_and_data._0;\n+        auto b_elem = b_len_and_data._1;\n+        bcx = b_len_and_data._2;\n+\n+        // Calculate the last pointer address we want to handle.\n+        auto len = umin(bcx, a_len, b_len);\n+        auto b_elem_i8 = bcx.build.PointerCast(b_elem, T_ptr(T_i8()));\n+        auto b_end_i8 = bcx.build.GEP(b_elem_i8, [len]);\n+        auto b_end = bcx.build.PointerCast(b_end_i8, T_ptr(llunitty));\n+\n+        // Now perform the iteration.\n+        auto vpf = bind adapter(_, _, _, unit_ty, f);\n+        ret iter_sequence_raw(bcx, a_elem, b_elem, b_end, unit_sz, vpf);\n+    }\n+\n+    let result r = res(cx, C_nil());\n     alt (ty::struct(cx.fcx.lcx.ccx.tcx, t)) {\n         case (ty::ty_tup(?args)) {\n             let int i = 0;\n@@ -2831,6 +2944,13 @@ fn iter_structural_ty_full(&@block_ctxt cx,\n                                  C_int(abi::obj_field_box)]);\n             ret iter_boxpp(cx, box_cell_a, box_cell_b, f);\n         }\n+        case (ty::ty_ivec(?unit_tm)) {\n+            ret iter_ivec(cx, av, bv, unit_tm.ty, f);\n+        }\n+        case (ty::ty_istr) {\n+            auto unit_ty = ty::mk_mach(cx.fcx.lcx.ccx.tcx, common::ty_u8);\n+            ret iter_ivec(cx, av, bv, unit_ty, f);\n+        }\n         case (_) {\n             cx.fcx.lcx.ccx.sess.unimpl(\"type in iter_structural_ty_full\");\n         }\n@@ -5475,6 +5595,93 @@ fn trans_vec(&@block_ctxt cx, &vec[@ast::expr] args,\n     ret res(bcx, vec_val);\n }\n \n+fn trans_ivec(@block_ctxt bcx, &vec[@ast::expr] args, &ast::ann ann)\n+        -> result {\n+    auto typ = node_ann_type(bcx.fcx.lcx.ccx, ann);\n+    auto unit_ty;\n+    alt (ty::struct(bcx.fcx.lcx.ccx.tcx, typ)) {\n+        case (ty::ty_ivec(?mt)) { unit_ty = mt.ty; }\n+        case (_) { bcx.fcx.lcx.ccx.sess.bug(\"non-ivec type in trans_ivec\"); }\n+    }\n+\n+    auto rslt = size_of(bcx, unit_ty);\n+    auto unit_sz = rslt.val;\n+    bcx = rslt.bcx;\n+    rslt = align_of(bcx, unit_ty);\n+    auto unit_align = rslt.val;\n+    bcx = rslt.bcx;\n+\n+    auto llunitty = type_of_or_i8(bcx, unit_ty);\n+    auto llvecptr = alloca(bcx, T_ivec());\n+    auto lllen = bcx.build.Mul(C_uint(vec::len(args)), unit_sz);\n+\n+    // Allocate the vector pieces and store length and allocated length.\n+    auto llfirsteltptr;\n+    if (vec::len(args) > 0u && vec::len(args) < abi::ivec_default_size) {\n+        // Interior case.\n+        bcx.build.Store(lllen, bcx.build.GEP(llvecptr,\n+            [C_int(0), C_uint(abi::ivec_elt_len)]));\n+        bcx.build.Store(C_uint(abi::ivec_elt_alen), bcx.build.GEP(llvecptr,\n+            [C_int(0), C_uint(abi::ivec_elt_alen)]));\n+        llfirsteltptr = bcx.build.GEP(llvecptr,\n+            [C_int(0), C_uint(abi::ivec_elt_elems)]);\n+    } else {\n+        // Heap case.\n+        auto llstubty = T_ivec_heap(llunitty);\n+        auto llstubptr = bcx.build.PointerCast(llvecptr, T_ptr(llstubty));\n+\n+        bcx.build.Store(C_int(0), bcx.build.GEP(llstubptr,\n+            [C_int(0), C_uint(abi::ivec_heap_stub_elt_zero)]));\n+        bcx.build.Store(C_uint(abi::ivec_elt_alen), bcx.build.GEP(llstubptr,\n+            [C_int(0), C_uint(abi::ivec_heap_stub_elt_alen)]));\n+\n+        auto llheapty = struct_elt(llstubty, abi::ivec_heap_stub_elt_ptr);\n+\n+        if (vec::len(args) == 0u) {\n+            // Null heap pointer indicates a zero-length vector.\n+            bcx.build.Store(C_null(T_ptr(llheapty)), bcx.build.GEP(llstubptr,\n+                [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)]));\n+            llfirsteltptr = C_null(T_ptr(llunitty));\n+        } else {\n+            auto llheapsz = bcx.build.Add(llsize_of(llheapty), lllen);\n+            rslt = trans_raw_malloc(bcx, llheapty, llheapsz);\n+            bcx = rslt.bcx;\n+            auto llheapptr = rslt.val;\n+\n+            bcx.build.Store(llheapptr, bcx.build.GEP(llstubptr,\n+                [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)]));\n+            bcx.build.Store(lllen, bcx.build.GEP(llheapptr,\n+                [C_int(0), C_uint(abi::ivec_heap_elt_len)]));\n+            llfirsteltptr = bcx.build.GEP(llheapptr,\n+                [C_int(0), C_uint(abi::ivec_heap_elt_elems)]);\n+        }\n+    }\n+\n+    llfirsteltptr = bcx.build.PointerCast(llfirsteltptr, T_ptr(llunitty));\n+\n+    // Store the individual elements.\n+    auto i = 0u;\n+    for (@ast::expr e in args) {\n+        rslt = trans_expr(bcx, e);\n+        bcx = rslt.bcx;\n+        auto llsrc = rslt.val;\n+\n+        auto lleltptr;\n+        if (ty::type_has_dynamic_size(bcx.fcx.lcx.ccx.tcx, unit_ty)) {\n+            lleltptr = bcx.build.GEP(llfirsteltptr,\n+                [bcx.build.Mul(C_uint(i), unit_align)]);\n+        } else {\n+            lleltptr = bcx.build.GEP(llfirsteltptr, [C_uint(i)]);\n+        }\n+\n+        bcx = copy_val(bcx, INIT, lleltptr, llsrc, unit_ty).bcx;\n+\n+        i += 1u;\n+    }\n+\n+    ret res(bcx, llvecptr);\n+}\n+\n fn trans_rec(&@block_ctxt cx, &vec[ast::field] fields,\n              &option::t[@ast::expr] base, &ast::ann ann) -> result {\n \n@@ -5649,10 +5856,14 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output)\n             ret trans_cast(cx, e, ann);\n         }\n \n-        case (ast::expr_vec(?args, _, _, ?ann)) {\n+        case (ast::expr_vec(?args, _, ast::sk_rc, ?ann)) {\n             ret trans_vec(cx, args, ann);\n         }\n \n+        case (ast::expr_vec(?args, _, ast::sk_unique, ?ann)) {\n+            ret trans_ivec(cx, args, ann);\n+        }\n+\n         case (ast::expr_tup(?args, ?ann)) {\n             ret trans_tup(cx, args, ann);\n         }"}, {"sha": "e2c40b4bfe9180defacfcdd708e3c974bf6f873a", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/00eb3f5798ae77c8af135b86c827a67a8febd932/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00eb3f5798ae77c8af135b86c827a67a8febd932/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=00eb3f5798ae77c8af135b86c827a67a8febd932", "patch": "@@ -742,31 +742,37 @@ fn type_is_bool(&ctxt cx, &t ty) -> bool {\n \n fn type_is_structural(&ctxt cx, &t ty) -> bool {\n     alt (struct(cx, ty)) {\n-        case (ty_tup(_))    { ret true; }\n-        case (ty_rec(_))    { ret true; }\n-        case (ty_tag(_,_))  { ret true; }\n+        case (ty_tup(_))        { ret true; }\n+        case (ty_rec(_))        { ret true; }\n+        case (ty_tag(_,_))      { ret true; }\n         case (ty_fn(_,_,_,_,_)) { ret true; }\n-        case (ty_obj(_))    { ret true; }\n-        case (_)            { ret false; }\n+        case (ty_obj(_))        { ret true; }\n+        case (ty_ivec(_))       { ret true; }\n+        case (ty_istr)          { ret true; }\n+        case (_)                { ret false; }\n     }\n }\n \n fn type_is_sequence(&ctxt cx, &t ty) -> bool {\n     alt (struct(cx, ty)) {\n-        case (ty_str)    { ret true; }\n+        case (ty_str)       { ret true; }\n+        case (ty_istr)      { ret true; }\n         case (ty_vec(_))    { ret true; }\n+        case (ty_ivec(_))   { ret true; }\n         case (_)            { ret false; }\n     }\n }\n \n fn sequence_element_type(&ctxt cx, &t ty) -> t {\n     alt (struct(cx, ty)) {\n-        case (ty_str)      { ret mk_mach(cx, common::ty_u8); }\n-        case (ty_vec(?mt)) { ret mt.ty; }\n-        // NB: This is not exhaustive.\n+        case (ty_str)       { ret mk_mach(cx, common::ty_u8); }\n+        case (ty_istr)      { ret mk_mach(cx, common::ty_u8); }\n+        case (ty_vec(?mt))  { ret mt.ty; }\n+        case (ty_ivec(?mt)) { ret mt.ty; }\n+        case (_) {\n+            cx.sess.bug(\"sequence_element_type called on non-sequence value\");\n+        }\n     }\n-\n-    cx.sess.bug(\"sequence_element_type called on non-sequence value\");\n }\n \n fn type_is_tup_like(&ctxt cx, &t ty) -> bool {"}]}