{"sha": "e2bb98001e5946c35952f3e1cd0b8cfbe3915cc1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyYmI5ODAwMWU1OTQ2YzM1OTUyZjNlMWNkMGI4Y2ZiZTM5MTVjYzE=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2011-05-20T22:56:23Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-27T02:42:32Z"}, "message": "Part one of adding globbing to resolve.rs: build up glob links. (Part two will follow those links if non-glob resolution fails.)", "tree": {"sha": "f570cc6f4cc9488b8bc5d786cfd1e9e7fde2fd25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f570cc6f4cc9488b8bc5d786cfd1e9e7fde2fd25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2bb98001e5946c35952f3e1cd0b8cfbe3915cc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2bb98001e5946c35952f3e1cd0b8cfbe3915cc1", "html_url": "https://github.com/rust-lang/rust/commit/e2bb98001e5946c35952f3e1cd0b8cfbe3915cc1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2bb98001e5946c35952f3e1cd0b8cfbe3915cc1/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f11f846ead52b974e8ae97a5ae532d70bea66677", "url": "https://api.github.com/repos/rust-lang/rust/commits/f11f846ead52b974e8ae97a5ae532d70bea66677", "html_url": "https://github.com/rust-lang/rust/commit/f11f846ead52b974e8ae97a5ae532d70bea66677"}], "stats": {"total": 140, "additions": 119, "deletions": 21}, "files": [{"sha": "9453f7da941c165a1265eb246f986c2708234469", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 119, "deletions": 21, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/e2bb98001e5946c35952f3e1cd0b8cfbe3915cc1/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2bb98001e5946c35952f3e1cd0b8cfbe3915cc1/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=e2bb98001e5946c35952f3e1cd0b8cfbe3915cc1", "patch": "@@ -74,9 +74,18 @@ tag mod_index_entry {\n     mie_tag_variant(@ast::item /* tag item */, uint /* variant index */);\n }\n type mod_index = hashmap[ident,list[mod_index_entry]];\n-type indexed_mod = rec(option::t[ast::_mod] m, mod_index index);\n+\n+type indexed_mod = rec(option::t[ast::_mod] m, \n+                       mod_index index, vec[@i_m] glob_imports);\n /* native modules can't contain tags, and we don't store their ASTs because we\n    only need to look at them to determine exports, which they can't control.*/\n+// It should be safe to use index to memoize lookups of globbed names.\n+\n+//FIXME: this only exists because we can't yet write recursive types unless\n+//the recursion passes through a tag.\n+tag i_m {\n+    i_m(indexed_mod);\n+}\n \n type crate_map = hashmap[uint,ast::crate_num];\n \n@@ -116,46 +125,95 @@ fn resolve_crate(session sess, @ast::crate crate) -> def_map {\n     ret e.def_map;\n }\n \n+\n // Locate all modules and imports and index them, so that the next passes can\n // resolve through them.\n \n fn map_crate(&@env e, &ast::crate c) {\n+\n+    // First, find all the modules, and index the names that they contain\n+\n     auto cell = @mutable nil[scope];\n-    auto v = rec(visit_crate_pre = bind push_env_for_crate(cell, _),\n-                 visit_crate_post = bind pop_env_for_crate(cell, _),\n-                 visit_view_item_pre = bind visit_view_item(e, cell, _),\n-                 visit_item_pre = bind visit_item(e, cell, _),\n-                 visit_item_post = bind pop_env_for_item(cell, _)\n-                 with walk::default_visitor());\n+    auto index_names = \n+        rec(visit_crate_pre = bind push_env_for_crate(cell, _),\n+            visit_crate_post = bind pop_env_for_crate(cell, _),\n+            visit_view_item_pre = bind index_vi(e, cell, _),\n+            visit_item_pre = bind index_i(e, cell, _),\n+            visit_item_post = bind pop_env_for_item(cell, _)\n+            with walk::default_visitor());\n     // Register the top-level mod\n     e.mod_map.insert(-1, @rec(m=some(c.node.module),\n-                              index=index_mod(c.node.module)));\n-    walk::walk_crate(v, c);\n+                              index=index_mod(c.node.module),\n+                              glob_imports=vec::empty[@i_m]()));\n+    walk::walk_crate(index_names, c);\n \n-    fn visit_view_item(@env e, @mutable list[scope] sc, &@ast::view_item i) {\n+    fn index_vi(@env e, @mutable list[scope] sc, &@ast::view_item i) {\n         alt (i.node) {\n             case (ast::view_item_import(_, ?ids, ?defid)) {\n                 e.imports.insert(defid._1, todo(i, *sc));\n             }\n             case (_) {}\n         }\n     }\n-    fn visit_item(@env e, @mutable list[scope] sc, &@ast::item i) {\n+    fn index_i(@env e, @mutable list[scope] sc, &@ast::item i) {\n         push_env_for_item(sc, i);\n         alt (i.node) {\n             case (ast::item_mod(_, ?md, ?defid)) {\n-                auto index = index_mod(md);\n-                e.mod_map.insert(defid._1, @rec(m=some(md),\n-                                                index=index));\n+                e.mod_map.insert(defid._1, \n+                                 @rec(m=some(md), index=index_mod(md),\n+                                      glob_imports=vec::empty[@i_m]()));\n             }\n             case (ast::item_native_mod(_, ?nmd, ?defid)) {\n-                auto index = index_nmod(nmd);\n-                e.mod_map.insert(defid._1, @rec(m=none[ast::_mod],\n-                                                index=index));\n+                e.mod_map.insert(defid._1, \n+                                 @rec(m=none[ast::_mod], \n+                                      index=index_nmod(nmd),\n+                                      glob_imports=vec::empty[@i_m]()));\n             }\n             case (_) {}\n         }\n     }\n+\n+    // Next, assemble the links for globbed imports.\n+    \n+    let @indexed_mod cur_mod = e.mod_map.get(-1);\n+\n+    cell = @mutable nil[scope];\n+    auto link_globs = \n+        rec(visit_crate_pre = bind push_env_for_crate(cell, _),\n+            visit_crate_post = bind pop_env_for_crate(cell, _),\n+            visit_view_item_pre = bind link_glob(e, cell, cur_mod, _),\n+            visit_item_pre = bind enter_i(e, cell, cur_mod, _),\n+            visit_item_post = bind pop_env_for_item(cell, _)\n+            with walk::default_visitor());\n+    walk::walk_crate(link_globs, c);\n+    \n+    fn enter_i(@env e, @mutable list[scope] sc, @indexed_mod cur_mod, \n+               &@ast::item i) {\n+        push_env_for_item(sc,i);\n+        alt(i.node) {\n+            case (ast::item_mod(_, _, ?defid)) {\n+                cur_mod = e.mod_map.get(defid._1);\n+            }\n+            case (ast::item_native_mod(_, _, ?defid)) {\n+                cur_mod = e.mod_map.get(defid._1);\n+            }\n+            case (_) {}\n+        }\n+    }\n+        \n+    fn link_glob(@env e, @mutable list[scope] sc, @indexed_mod cur_mod,\n+                 &@ast::view_item vi) {\n+        alt (vi.node) {\n+            //if it really is a glob import, that is\n+            case (ast::view_item_import_glob(?path, _)) {\n+                cur_mod.glob_imports += \n+                    [follow_import(*e, *sc, path, vi.span)];\n+            }\n+            case (_) {}\n+        }\n+        \n+    }\n+    \n }\n \n fn resolve_imports(&env e) {\n@@ -312,6 +370,39 @@ fn pop_env_for_arm(@mutable list[scope] sc, &ast::arm p) {\n     *sc = std::list::cdr(*sc);\n }\n \n+\n+//HERE\n+fn follow_import(&env e, &list[scope] sc, vec[ident] path, &span sp) \n+    -> @i_m {\n+    auto path_len = vec::len(path);\n+    auto dcur = lookup_in_scope_strict(e, sc, sp, path.(0), ns_module);\n+    auto i = 1u;\n+    while (true) {\n+        if (i == path_len) { break; }\n+        dcur = lookup_in_mod_strict(e, dcur, sp, path.(i),\n+                                    ns_module, outside);\n+        i += 1u;\n+    }\n+\n+    alt (dcur) {\n+        case (ast::def_mod(?def_id)) {\n+            //TODO: is this sane?\n+            ret @i_m(*e.mod_map.get(def_id._1));\n+        }\n+        case (ast::def_native_mod(?def_id)) {\n+            ret @i_m(*e.mod_map.get(def_id._1));\n+        }\n+        case (_) {\n+            e.sess.span_err(sp, str::connect(path, \"::\") \n+                            + \" does not name a module.\");\n+            fail;\n+        }\n+    }\n+}\n+\n+\n+\n+\n // Import resolution\n \n fn resolve_import(&env e, &@ast::view_item it, &list[scope] sc) {\n@@ -719,6 +810,9 @@ fn found_view_item(&env e, @ast::view_item vi, namespace ns)\n         case (ast::view_item_import(_, _, ?defid)) {\n             ret lookup_import(e, defid, ns);\n         }\n+        case (ast::view_item_import_glob(_, ?defid)) {\n+            ret none[def]; //TODO: think about this. Is it correct?\n+        }\n     }\n }\n \n@@ -813,12 +907,13 @@ fn lookup_in_local_native_mod(&env e, def_id defid, &ident id, namespace ns)\n \n // Module indexing\n \n-fn add_to_index[T](&hashmap[ident,list[T]] index, &ident id, &T ent) {\n+fn add_to_index(&hashmap[ident,list[mod_index_entry]] index, &ident id, \n+                &mod_index_entry ent) {\n     alt (index.find(id)) {\n-        case (none[list[T]]) {\n-            index.insert(id, cons(ent, @nil[T]));\n+        case (none[list[mod_index_entry]]) {\n+            index.insert(id, cons(ent, @nil[mod_index_entry]));\n         }\n-        case (some[list[T]](?prev)) {\n+        case (some[list[mod_index_entry]](?prev)) {\n             index.insert(id, cons(ent, @prev));\n         }\n     }\n@@ -835,6 +930,9 @@ fn index_mod(&ast::_mod md) -> mod_index {\n             case(ast::view_item_import(?def_ident,_,_)) {\n                 add_to_index(index, def_ident, mie_view_item(it));\n             }\n+            case(ast::view_item_import_glob(?path,_)) {\n+                //globbed imports have to be resolved lazily.\n+            }\n             case(ast::view_item_export(_)) {}\n         }\n     }"}]}