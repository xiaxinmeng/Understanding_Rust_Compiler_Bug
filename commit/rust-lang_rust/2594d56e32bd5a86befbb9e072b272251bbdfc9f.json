{"sha": "2594d56e32bd5a86befbb9e072b272251bbdfc9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1OTRkNTZlMzJiZDVhODZiZWZiYjllMDcyYjI3MjI1MWJiZGZjOWY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-12T10:16:02Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-18T15:24:55Z"}, "message": "Introduce the new phantomdata/phantomfn markers and integrate them\ninto variance inference; fix various bugs in variance inference\nso that it considers the correct set of constraints; modify infer to\nconsider the results of variance inference for type arguments.", "tree": {"sha": "c148c43dbd60003daed4036757391b1358bd69a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c148c43dbd60003daed4036757391b1358bd69a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2594d56e32bd5a86befbb9e072b272251bbdfc9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2594d56e32bd5a86befbb9e072b272251bbdfc9f", "html_url": "https://github.com/rust-lang/rust/commit/2594d56e32bd5a86befbb9e072b272251bbdfc9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2594d56e32bd5a86befbb9e072b272251bbdfc9f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "html_url": "https://github.com/rust-lang/rust/commit/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5"}], "stats": {"total": 2025, "additions": 1522, "deletions": 503}, "files": [{"sha": "a2c1bbc03317e9da08451e0b2b2d6194d385568b", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -16,7 +16,7 @@ use any;\n use cell::{Cell, RefCell, Ref, RefMut, BorrowState};\n use char::CharExt;\n use iter::{Iterator, IteratorExt};\n-use marker::{Copy, Sized};\n+use marker::{Copy, PhantomData, Sized};\n use mem;\n use option::Option;\n use option::Option::{Some, None};\n@@ -914,6 +914,11 @@ impl Debug for () {\n         f.pad(\"()\")\n     }\n }\n+impl<T> Debug for PhantomData<T> {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        f.pad(\"PhantomData\")\n+    }\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Copy + Debug> Debug for Cell<T> {"}, {"sha": "5c7ec423e7c9a167d9ae4c7ff4151b95424b3af3", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 85, "deletions": 210, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -26,6 +26,10 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use clone::Clone;\n+use cmp;\n+use option::Option;\n+use hash::Hash;\n+use hash::Hasher;\n \n /// Types able to be transferred across thread boundaries.\n #[unstable(feature = \"core\",\n@@ -42,15 +46,15 @@ pub unsafe trait Send: 'static {\n #[lang=\"send\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be sent between threads safely\"]\n #[cfg(not(stage0))]\n-pub unsafe trait Send {\n+pub unsafe trait Send : MarkerTrait {\n     // empty.\n }\n \n /// Types with a constant size known at compile-time.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang=\"sized\"]\n #[rustc_on_unimplemented = \"`{Self}` does not have a constant size known at compile-time\"]\n-pub trait Sized {\n+pub trait Sized : MarkerTrait {\n     // Empty.\n }\n \n@@ -155,7 +159,7 @@ pub trait Sized {\n /// change: that second example would fail to compile if we made `Foo` non-`Copy`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang=\"copy\"]\n-pub trait Copy {\n+pub trait Copy : MarkerTrait {\n     // Empty.\n }\n \n@@ -208,216 +212,10 @@ pub trait Copy {\n            reason = \"will be overhauled with new lifetime rules; see RFC 458\")]\n #[lang=\"sync\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be shared between threads safely\"]\n-pub unsafe trait Sync {\n+pub unsafe trait Sync : MarkerTrait {\n     // Empty\n }\n \n-/// A marker type that indicates to the compiler that the instances\n-/// of the type itself owns instances of the type parameter `T`.\n-///\n-/// This is used to indicate that one or more instances of the type\n-/// `T` could be dropped when instances of the type itself is dropped,\n-/// though that may not be apparent from the other structure of the\n-/// type itself. For example, the type may hold a `*mut T`, which the\n-/// compiler does not automatically treat as owned.\n-#[unstable(feature = \"core\",\n-           reason = \"Newly added to deal with scoping and destructor changes\")]\n-#[lang=\"phantom_data\"]\n-#[derive(PartialEq, Eq, PartialOrd, Ord)]\n-pub struct PhantomData<T: ?Sized>;\n-\n-impl<T: ?Sized> Copy for PhantomData<T> {}\n-impl<T: ?Sized> Clone for PhantomData<T> {\n-    fn clone(&self) -> PhantomData<T> { *self }\n-}\n-\n-/// A marker type whose type parameter `T` is considered to be\n-/// covariant with respect to the type itself. This is (typically)\n-/// used to indicate that an instance of the type `T` is being stored\n-/// into memory and read from, even though that may not be apparent.\n-///\n-/// For more information about variance, refer to this Wikipedia\n-/// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n-///\n-/// *Note:* It is very unusual to have to add a covariant constraint.\n-/// If you are not sure, you probably want to use `InvariantType`.\n-///\n-/// # Example\n-///\n-/// Given a struct `S` that includes a type parameter `T`\n-/// but does not actually *reference* that type parameter:\n-///\n-/// ```ignore\n-/// use std::mem;\n-///\n-/// struct S<T> { x: *() }\n-/// fn get<T>(s: &S<T>) -> T {\n-///    unsafe {\n-///        let x: *T = mem::transmute(s.x);\n-///        *x\n-///    }\n-/// }\n-/// ```\n-///\n-/// The type system would currently infer that the value of\n-/// the type parameter `T` is irrelevant, and hence a `S<int>` is\n-/// a subtype of `S<Box<int>>` (or, for that matter, `S<U>` for\n-/// any `U`). But this is incorrect because `get()` converts the\n-/// `*()` into a `*T` and reads from it. Therefore, we should include the\n-/// a marker field `CovariantType<T>` to inform the type checker that\n-/// `S<T>` is a subtype of `S<U>` if `T` is a subtype of `U`\n-/// (for example, `S<&'static int>` is a subtype of `S<&'a int>`\n-/// for some lifetime `'a`, but not the other way around).\n-#[unstable(feature = \"core\",\n-           reason = \"likely to change with new variance strategy\")]\n-#[lang=\"covariant_type\"]\n-#[derive(PartialEq, Eq, PartialOrd, Ord)]\n-pub struct CovariantType<T: ?Sized>;\n-\n-impl<T: ?Sized> Copy for CovariantType<T> {}\n-impl<T: ?Sized> Clone for CovariantType<T> {\n-    fn clone(&self) -> CovariantType<T> { *self }\n-}\n-\n-/// A marker type whose type parameter `T` is considered to be\n-/// contravariant with respect to the type itself. This is (typically)\n-/// used to indicate that an instance of the type `T` will be consumed\n-/// (but not read from), even though that may not be apparent.\n-///\n-/// For more information about variance, refer to this Wikipedia\n-/// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n-///\n-/// *Note:* It is very unusual to have to add a contravariant constraint.\n-/// If you are not sure, you probably want to use `InvariantType`.\n-///\n-/// # Example\n-///\n-/// Given a struct `S` that includes a type parameter `T`\n-/// but does not actually *reference* that type parameter:\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// struct S<T> { x: *const () }\n-/// fn get<T>(s: &S<T>, v: T) {\n-///    unsafe {\n-///        let x: fn(T) = mem::transmute(s.x);\n-///        x(v)\n-///    }\n-/// }\n-/// ```\n-///\n-/// The type system would currently infer that the value of\n-/// the type parameter `T` is irrelevant, and hence a `S<int>` is\n-/// a subtype of `S<Box<int>>` (or, for that matter, `S<U>` for\n-/// any `U`). But this is incorrect because `get()` converts the\n-/// `*()` into a `fn(T)` and then passes a value of type `T` to it.\n-///\n-/// Supplying a `ContravariantType` marker would correct the\n-/// problem, because it would mark `S` so that `S<T>` is only a\n-/// subtype of `S<U>` if `U` is a subtype of `T`; given that the\n-/// function requires arguments of type `T`, it must also accept\n-/// arguments of type `U`, hence such a conversion is safe.\n-#[unstable(feature = \"core\",\n-           reason = \"likely to change with new variance strategy\")]\n-#[lang=\"contravariant_type\"]\n-#[derive(PartialEq, Eq, PartialOrd, Ord)]\n-pub struct ContravariantType<T: ?Sized>;\n-\n-impl<T: ?Sized> Copy for ContravariantType<T> {}\n-impl<T: ?Sized> Clone for ContravariantType<T> {\n-    fn clone(&self) -> ContravariantType<T> { *self }\n-}\n-\n-/// A marker type whose type parameter `T` is considered to be\n-/// invariant with respect to the type itself. This is (typically)\n-/// used to indicate that instances of the type `T` may be read or\n-/// written, even though that may not be apparent.\n-///\n-/// For more information about variance, refer to this Wikipedia\n-/// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n-///\n-/// # Example\n-///\n-/// The Cell type is an example of an `InvariantType` which uses unsafe\n-/// code to achieve \"interior\" mutability:\n-///\n-/// ```\n-/// struct Cell<T> { value: T }\n-/// ```\n-///\n-/// The type system would infer that `value` is only read here\n-/// and never written, but in fact `Cell` uses unsafe code to achieve\n-/// interior mutability. In order to get correct behavior, the\n-/// `InvariantType` marker must be applied.\n-#[unstable(feature = \"core\",\n-           reason = \"likely to change with new variance strategy\")]\n-#[lang=\"invariant_type\"]\n-#[derive(PartialEq, Eq, PartialOrd, Ord)]\n-pub struct InvariantType<T: ?Sized>;\n-\n-#[unstable(feature = \"core\",\n-           reason = \"likely to change with new variance strategy\")]\n-impl<T: ?Sized> Copy for InvariantType<T> {}\n-#[unstable(feature = \"core\",\n-           reason = \"likely to change with new variance strategy\")]\n-impl<T: ?Sized> Clone for InvariantType<T> {\n-    fn clone(&self) -> InvariantType<T> { *self }\n-}\n-\n-/// As `CovariantType`, but for lifetime parameters. Using\n-/// `CovariantLifetime<'a>` indicates that it is ok to substitute\n-/// a *longer* lifetime for `'a` than the one you originally\n-/// started with (e.g., you could convert any lifetime `'foo` to\n-/// `'static`). You almost certainly want `ContravariantLifetime`\n-/// instead, or possibly `InvariantLifetime`. The only case where\n-/// it would be appropriate is that you have a (type-casted, and\n-/// hence hidden from the type system) function pointer with a\n-/// signature like `fn(&'a T)` (and no other uses of `'a`). In\n-/// this case, it is ok to substitute a larger lifetime for `'a`\n-/// (e.g., `fn(&'static T)`), because the function is only\n-/// becoming more selective in terms of what it accepts as\n-/// argument.\n-///\n-/// For more information about variance, refer to this Wikipedia\n-/// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n-#[unstable(feature = \"core\",\n-           reason = \"likely to change with new variance strategy\")]\n-#[lang=\"covariant_lifetime\"]\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n-pub struct CovariantLifetime<'a>;\n-\n-/// As `ContravariantType`, but for lifetime parameters. Using\n-/// `ContravariantLifetime<'a>` indicates that it is ok to\n-/// substitute a *shorter* lifetime for `'a` than the one you\n-/// originally started with (e.g., you could convert `'static` to\n-/// any lifetime `'foo`). This is appropriate for cases where you\n-/// have an unsafe pointer that is actually a pointer into some\n-/// memory with lifetime `'a`, and thus you want to limit the\n-/// lifetime of your data structure to `'a`. An example of where\n-/// this is used is the iterator for vectors.\n-///\n-/// For more information about variance, refer to this Wikipedia\n-/// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n-#[unstable(feature = \"core\",\n-           reason = \"likely to change with new variance strategy\")]\n-#[lang=\"contravariant_lifetime\"]\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n-pub struct ContravariantLifetime<'a>;\n-\n-/// As `InvariantType`, but for lifetime parameters. Using\n-/// `InvariantLifetime<'a>` indicates that it is not ok to\n-/// substitute any other lifetime for `'a` besides its original\n-/// value. This is appropriate for cases where you have an unsafe\n-/// pointer that is actually a pointer into memory with lifetime `'a`,\n-/// and this pointer is itself stored in an inherently mutable\n-/// location (such as a `Cell`).\n-#[unstable(feature = \"core\",\n-           reason = \"likely to change with new variance strategy\")]\n-#[lang=\"invariant_lifetime\"]\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n-pub struct InvariantLifetime<'a>;\n-\n /// A type which is considered \"not POD\", meaning that it is not\n /// implicitly copyable. This is typically embedded in other types to\n /// ensure that they are never copied, even if they lack a destructor.\n@@ -435,6 +233,83 @@ pub struct NoCopy;\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n pub struct Managed;\n \n+macro_rules! impls{\n+    ($t: ident) => (\n+        impl<T:?Sized, S: Hasher> Hash<S> for $t<T> {\n+            #[inline]\n+            fn hash(&self, _: &mut S) {\n+            }\n+        }\n+\n+        impl<T:?Sized> cmp::PartialEq for $t<T> {\n+            fn eq(&self, _other: &$t<T>) -> bool {\n+                true\n+            }\n+        }\n+\n+        impl<T:?Sized> cmp::Eq for $t<T> {\n+        }\n+\n+        impl<T:?Sized> cmp::PartialOrd for $t<T> {\n+            fn partial_cmp(&self, _other: &$t<T>) -> Option<cmp::Ordering> {\n+                Option::Some(cmp::Ordering::Equal)\n+            }\n+        }\n+\n+        impl<T:?Sized> cmp::Ord for $t<T> {\n+            fn cmp(&self, _other: &$t<T>) -> cmp::Ordering {\n+                cmp::Ordering::Equal\n+            }\n+        }\n+\n+        impl<T:?Sized> Copy for $t<T> { }\n+\n+        impl<T:?Sized> Clone for $t<T> {\n+            fn clone(&self) -> $t<T> {\n+                $t\n+            }\n+        }\n+        )\n+}\n+\n+/// `MarkerTrait` is intended to be used as the supertrait for traits\n+/// that don't have any methods but instead serve just to designate\n+/// categories of types. An example would be the `Send` trait, which\n+/// indicates types that are sendable: `Send` does not itself offer\n+/// any methods, but instead is used to gate access to data.\n+///\n+/// FIXME. Better documentation needed here!\n+pub trait MarkerTrait : PhantomFn<Self> { }\n+impl<T:?Sized> MarkerTrait for T { }\n+\n+/// `PhantomFn` is a marker trait for use with traits that do not\n+/// include any methods.\n+///\n+/// FIXME. Better documentation needed here!\n+#[lang=\"phantom_fn\"]\n+pub trait PhantomFn<A:?Sized,R:?Sized=()> { }\n+\n+#[cfg(stage0)] // built into the trait matching system after stage0\n+impl<A:?Sized, R:?Sized, U:?Sized> PhantomFn<A,R> for U { }\n+\n+/// Specific to stage0. You should not be seeing these docs!\n+#[cfg(stage0)]\n+#[lang=\"covariant_type\"] // only relevant to stage0\n+pub struct PhantomData<T:?Sized>;\n+\n+/// `PhantomData` is a way to tell the compiler about fake fields.\n+/// The idea is that if the compiler encounters a `PhantomData<T>`\n+/// instance, it will behave *as if* an instance of the type `T` were\n+/// present for the purpose of various automatic analyses.\n+///\n+/// FIXME. Better documentation needed here!\n+#[cfg(not(stage0))]\n+#[lang=\"phantom_data\"]\n+pub struct PhantomData<T:?Sized>;\n+\n+impls! { PhantomData }\n+\n+\n #[cfg(not(stage0))]\n mod impls {\n     use super::{Send, Sync, Sized};"}, {"sha": "0589aa03014addd6554bc2c2130fe9cdbe91f6f2", "filename": "src/librustc/middle/infer/bivariate.rs", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -0,0 +1,128 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::ty::{BuiltinBounds};\n+use middle::ty::{self, Ty};\n+use middle::ty::TyVar;\n+use middle::infer::combine::*;\n+use middle::infer::{cres};\n+use middle::infer::type_variable::{BiTo};\n+use util::ppaux::{Repr};\n+\n+use syntax::ast::{Unsafety};\n+\n+pub struct Bivariate<'f, 'tcx: 'f> {\n+    fields: CombineFields<'f, 'tcx>\n+}\n+\n+#[allow(non_snake_case)]\n+pub fn Bivariate<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Bivariate<'f, 'tcx> {\n+    Bivariate { fields: cf }\n+}\n+\n+impl<'f, 'tcx> Combine<'tcx> for Bivariate<'f, 'tcx> {\n+    fn tag(&self) -> String { \"Bivariate\".to_string() }\n+    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx> { &self.fields }\n+\n+    fn tys_with_variance(&self, v: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n+                         -> cres<'tcx, Ty<'tcx>>\n+    {\n+        match v {\n+            ty::Invariant => self.equate().tys(a, b),\n+            ty::Covariant => self.tys(a, b),\n+            ty::Contravariant => self.tys(a, b),\n+            ty::Bivariant => self.tys(a, b),\n+        }\n+    }\n+\n+    fn regions_with_variance(&self, v: ty::Variance, a: ty::Region, b: ty::Region)\n+                             -> cres<'tcx, ty::Region>\n+    {\n+        match v {\n+            ty::Invariant => self.equate().regions(a, b),\n+            ty::Covariant => self.regions(a, b),\n+            ty::Contravariant => self.regions(a, b),\n+            ty::Bivariant => self.regions(a, b),\n+        }\n+    }\n+\n+    fn regions(&self, a: ty::Region, _: ty::Region) -> cres<'tcx, ty::Region> {\n+        Ok(a)\n+    }\n+\n+    fn mts(&self, a: &ty::mt<'tcx>, b: &ty::mt<'tcx>) -> cres<'tcx, ty::mt<'tcx>> {\n+        debug!(\"mts({} <: {})\",\n+               a.repr(self.fields.infcx.tcx),\n+               b.repr(self.fields.infcx.tcx));\n+\n+        if a.mutbl != b.mutbl { return Err(ty::terr_mutability); }\n+        let t = try!(self.tys(a.ty, b.ty));\n+        Ok(ty::mt { mutbl: a.mutbl, ty: t })\n+    }\n+\n+    fn unsafeties(&self, a: Unsafety, b: Unsafety) -> cres<'tcx, Unsafety> {\n+        if a != b {\n+            Err(ty::terr_unsafety_mismatch(expected_found(self, a, b)))\n+        } else {\n+            Ok(a)\n+        }\n+    }\n+\n+    fn builtin_bounds(&self,\n+                      a: BuiltinBounds,\n+                      b: BuiltinBounds)\n+                      -> cres<'tcx, BuiltinBounds>\n+    {\n+        if a != b {\n+            Err(ty::terr_builtin_bounds(expected_found(self, a, b)))\n+        } else {\n+            Ok(a)\n+        }\n+    }\n+\n+    fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n+        debug!(\"{}.tys({}, {})\", self.tag(),\n+               a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));\n+        if a == b { return Ok(a); }\n+\n+        let infcx = self.fields.infcx;\n+        let a = infcx.type_variables.borrow().replace_if_possible(a);\n+        let b = infcx.type_variables.borrow().replace_if_possible(b);\n+        match (&a.sty, &b.sty) {\n+            (&ty::ty_infer(TyVar(a_id)), &ty::ty_infer(TyVar(b_id))) => {\n+                infcx.type_variables.borrow_mut().relate_vars(a_id, BiTo, b_id);\n+                Ok(a)\n+            }\n+\n+            (&ty::ty_infer(TyVar(a_id)), _) => {\n+                try!(self.fields.instantiate(b, BiTo, a_id));\n+                Ok(a)\n+            }\n+\n+            (_, &ty::ty_infer(TyVar(b_id))) => {\n+                try!(self.fields.instantiate(a, BiTo, b_id));\n+                Ok(a)\n+            }\n+\n+            _ => {\n+                super_tys(self, a, b)\n+            }\n+        }\n+    }\n+\n+    fn binders<T>(&self, a: &ty::Binder<T>, b: &ty::Binder<T>) -> cres<'tcx, ty::Binder<T>>\n+        where T : Combineable<'tcx>\n+    {\n+        let a1 = ty::erase_late_bound_regions(self.tcx(), a);\n+        let b1 = ty::erase_late_bound_regions(self.tcx(), b);\n+        let c = try!(Combineable::combine(self, &a1, &b1));\n+        Ok(ty::Binder(c))\n+    }\n+}"}, {"sha": "0eeafb767d8a625d2792a3c393f4888aec8cf68c", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 76, "deletions": 70, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -32,14 +32,15 @@\n // is also useful to track which value is the \"expected\" value in\n // terms of error reporting.\n \n+use super::bivariate::Bivariate;\n use super::equate::Equate;\n use super::glb::Glb;\n use super::lub::Lub;\n use super::sub::Sub;\n use super::unify::InferCtxtMethodsForSimplyUnifiableTypes;\n use super::{InferCtxt, cres};\n use super::{MiscVariable, TypeTrace};\n-use super::type_variable::{RelationDir, EqTo, SubtypeOf, SupertypeOf};\n+use super::type_variable::{RelationDir, BiTo, EqTo, SubtypeOf, SupertypeOf};\n \n use middle::subst;\n use middle::subst::{ErasedRegions, NonerasedRegions, Substs};\n@@ -48,7 +49,7 @@ use middle::ty::{IntType, UintType};\n use middle::ty::{BuiltinBounds};\n use middle::ty::{self, Ty};\n use middle::ty_fold;\n-use middle::ty_fold::{TypeFoldable};\n+use middle::ty_fold::{TypeFolder, TypeFoldable};\n use util::ppaux::Repr;\n \n use std::rc::Rc;\n@@ -58,48 +59,44 @@ use syntax::abi;\n use syntax::codemap::Span;\n \n pub trait Combine<'tcx> : Sized {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx>;\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.infcx().tcx }\n     fn tag(&self) -> String;\n-    fn a_is_expected(&self) -> bool;\n-    fn trace(&self) -> TypeTrace<'tcx>;\n \n-    fn equate<'a>(&'a self) -> Equate<'a, 'tcx>;\n-    fn sub<'a>(&'a self) -> Sub<'a, 'tcx>;\n-    fn lub<'a>(&'a self) -> Lub<'a, 'tcx>;\n-    fn glb<'a>(&'a self) -> Glb<'a, 'tcx>;\n+    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx>;\n+\n+    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields().infcx }\n+    fn a_is_expected(&self) -> bool { self.fields().a_is_expected }\n+    fn trace(&self) -> TypeTrace<'tcx> { self.fields().trace.clone() }\n+    fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { self.fields().equate() }\n+    fn bivariate<'a>(&'a self) -> Bivariate<'a, 'tcx> { self.fields().bivariate() }\n+\n+    fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { self.fields().sub() }\n+    fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields().clone()) }\n+    fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields().clone()) }\n \n     fn mts(&self, a: &ty::mt<'tcx>, b: &ty::mt<'tcx>) -> cres<'tcx, ty::mt<'tcx>>;\n-    fn contratys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>>;\n+\n+    fn tys_with_variance(&self, variance: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n+                         -> cres<'tcx, Ty<'tcx>>;\n+\n     fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>>;\n \n-    fn tps(&self,\n-           _: subst::ParamSpace,\n-           as_: &[Ty<'tcx>],\n-           bs: &[Ty<'tcx>])\n-           -> cres<'tcx, Vec<Ty<'tcx>>> {\n-        // FIXME -- In general, we treat variance a bit wrong\n-        // here. For historical reasons, we treat tps and Self\n-        // as invariant. This is overly conservative.\n-\n-        if as_.len() != bs.len() {\n-            return Err(ty::terr_ty_param_size(expected_found(self,\n-                                                             as_.len(),\n-                                                             bs.len())));\n-        }\n+    fn regions_with_variance(&self, variance: ty::Variance, a: ty::Region, b: ty::Region)\n+                             -> cres<'tcx, ty::Region>;\n \n-        try!(as_.iter().zip(bs.iter())\n-                .map(|(a, b)| self.equate().tys(*a, *b))\n-                .collect::<cres<Vec<Ty>>>());\n-        Ok(as_.to_vec())\n-    }\n+    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region>;\n \n     fn substs(&self,\n               item_def_id: ast::DefId,\n               a_subst: &subst::Substs<'tcx>,\n               b_subst: &subst::Substs<'tcx>)\n               -> cres<'tcx, subst::Substs<'tcx>>\n     {\n+        debug!(\"substs: item_def_id={} a_subst={} b_subst={}\",\n+               item_def_id.repr(self.infcx().tcx),\n+               a_subst.repr(self.infcx().tcx),\n+               b_subst.repr(self.infcx().tcx));\n+\n         let variances = if self.infcx().tcx.variance_computed.get() {\n             Some(ty::item_variances(self.infcx().tcx, item_def_id))\n         } else {\n@@ -119,7 +116,8 @@ pub trait Combine<'tcx> : Sized {\n         for &space in &subst::ParamSpace::all() {\n             let a_tps = a_subst.types.get_slice(space);\n             let b_tps = b_subst.types.get_slice(space);\n-            let tps = try!(self.tps(space, a_tps, b_tps));\n+            let t_variances = variances.map(|v| v.types.get_slice(space));\n+            let tps = try!(relate_type_params(self, t_variances, a_tps, b_tps));\n             substs.types.replace(space, tps);\n         }\n \n@@ -132,20 +130,7 @@ pub trait Combine<'tcx> : Sized {\n                 for &space in &subst::ParamSpace::all() {\n                     let a_regions = a.get_slice(space);\n                     let b_regions = b.get_slice(space);\n-\n-                    let mut invariance = Vec::new();\n-                    let r_variances = match variances {\n-                        Some(variances) => {\n-                            variances.regions.get_slice(space)\n-                        }\n-                        None => {\n-                            for _ in a_regions {\n-                                invariance.push(ty::Invariant);\n-                            }\n-                            &invariance[]\n-                        }\n-                    };\n-\n+                    let r_variances = variances.map(|v| v.regions.get_slice(space));\n                     let regions = try!(relate_region_params(self,\n                                                             r_variances,\n                                                             a_regions,\n@@ -157,13 +142,34 @@ pub trait Combine<'tcx> : Sized {\n \n         return Ok(substs);\n \n+        fn relate_type_params<'tcx, C: Combine<'tcx>>(this: &C,\n+                                                      variances: Option<&[ty::Variance]>,\n+                                                      a_tys: &[Ty<'tcx>],\n+                                                      b_tys: &[Ty<'tcx>])\n+                                                      -> cres<'tcx, Vec<Ty<'tcx>>>\n+        {\n+            if a_tys.len() != b_tys.len() {\n+                return Err(ty::terr_ty_param_size(expected_found(this,\n+                                                                 a_tys.len(),\n+                                                                 b_tys.len())));\n+            }\n+\n+            range(0, a_tys.len()).map(|i| {\n+                let a_ty = a_tys[i];\n+                let b_ty = b_tys[i];\n+                let v = variances.map_or(ty::Invariant, |v| v[i]);\n+                this.tys_with_variance(v, a_ty, b_ty)\n+            }).collect()\n+        }\n+\n         fn relate_region_params<'tcx, C: Combine<'tcx>>(this: &C,\n-                                                        variances: &[ty::Variance],\n+                                                        variances: Option<&[ty::Variance]>,\n                                                         a_rs: &[ty::Region],\n                                                         b_rs: &[ty::Region])\n-                                                        -> cres<'tcx, Vec<ty::Region>> {\n+                                                        -> cres<'tcx, Vec<ty::Region>>\n+        {\n             let tcx = this.infcx().tcx;\n-            let num_region_params = variances.len();\n+            let num_region_params = a_rs.len();\n \n             debug!(\"relate_region_params(\\\n                    a_rs={}, \\\n@@ -173,22 +179,18 @@ pub trait Combine<'tcx> : Sized {\n                    b_rs.repr(tcx),\n                    variances.repr(tcx));\n \n-            assert_eq!(num_region_params, a_rs.len());\n+            assert_eq!(num_region_params,\n+                       variances.map_or(num_region_params,\n+                                        |v| v.len()));\n+\n             assert_eq!(num_region_params, b_rs.len());\n-            let mut rs = vec!();\n-            for i in 0..num_region_params {\n+\n+            (0..a_rs.len()).map(|i| {\n                 let a_r = a_rs[i];\n                 let b_r = b_rs[i];\n-                let variance = variances[i];\n-                let r = match variance {\n-                    ty::Invariant => this.equate().regions(a_r, b_r),\n-                    ty::Covariant => this.regions(a_r, b_r),\n-                    ty::Contravariant => this.contraregions(a_r, b_r),\n-                    ty::Bivariant => Ok(a_r),\n-                };\n-                rs.push(try!(r));\n-            }\n-            Ok(rs)\n+                let variance = variances.map_or(ty::Invariant, |v| v[i]);\n+                this.regions_with_variance(variance, a_r, b_r)\n+            }).collect()\n         }\n     }\n \n@@ -241,7 +243,7 @@ pub trait Combine<'tcx> : Sized {\n     }\n \n     fn args(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n-        self.contratys(a, b).and_then(|t| Ok(t))\n+        self.tys_with_variance(ty::Contravariant, a, b).and_then(|t| Ok(t))\n     }\n \n     fn unsafeties(&self, a: Unsafety, b: Unsafety) -> cres<'tcx, Unsafety>;\n@@ -309,7 +311,7 @@ pub trait Combine<'tcx> : Sized {\n                           b: &ty::ExistentialBounds<'tcx>)\n                           -> cres<'tcx, ty::ExistentialBounds<'tcx>>\n     {\n-        let r = try!(self.contraregions(a.region_bound, b.region_bound));\n+        let r = try!(self.regions_with_variance(ty::Contravariant, a.region_bound, b.region_bound));\n         let nb = try!(self.builtin_bounds(a.builtin_bounds, b.builtin_bounds));\n         let pb = try!(self.projection_bounds(&a.projection_bounds, &b.projection_bounds));\n         Ok(ty::ExistentialBounds { region_bound: r,\n@@ -322,11 +324,6 @@ pub trait Combine<'tcx> : Sized {\n                       b: ty::BuiltinBounds)\n                       -> cres<'tcx, ty::BuiltinBounds>;\n \n-    fn contraregions(&self, a: ty::Region, b: ty::Region)\n-                  -> cres<'tcx, ty::Region>;\n-\n-    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region>;\n-\n     fn trait_refs(&self,\n                   a: &ty::TraitRef<'tcx>,\n                   b: &ty::TraitRef<'tcx>)\n@@ -540,7 +537,8 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n       }\n \n       (&ty::ty_rptr(a_r, ref a_mt), &ty::ty_rptr(b_r, ref b_mt)) => {\n-            let r = try!(this.contraregions(*a_r, *b_r));\n+            let r = try!(this.regions_with_variance(ty::Contravariant, *a_r, *b_r));\n+\n             // FIXME(14985)  If we have mutable references to trait objects, we\n             // used to use covariant subtyping. I have preserved this behaviour,\n             // even though it is probably incorrect. So don't go down the usual\n@@ -644,6 +642,10 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n         Equate((*self).clone())\n     }\n \n+    fn bivariate(&self) -> Bivariate<'f, 'tcx> {\n+        Bivariate((*self).clone())\n+    }\n+\n     fn sub(&self) -> Sub<'f, 'tcx> {\n         Sub((*self).clone())\n     }\n@@ -697,7 +699,7 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n                         EqTo => {\n                             self.generalize(a_ty, b_vid, false)\n                         }\n-                        SupertypeOf | SubtypeOf => {\n+                        BiTo | SupertypeOf | SubtypeOf => {\n                             self.generalize(a_ty, b_vid, true)\n                         }\n                     });\n@@ -721,6 +723,10 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n             // to associate causes/spans with each of the relations in\n             // the stack to get this right.\n             match dir {\n+                BiTo => {\n+                    try!(self.bivariate().tys(a_ty, b_ty));\n+                }\n+\n                 EqTo => {\n                     try!(self.equate().tys(a_ty, b_ty));\n                 }\n@@ -730,7 +736,7 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n                 }\n \n                 SupertypeOf => {\n-                    try!(self.sub().contratys(a_ty, b_ty));\n+                    try!(self.sub().tys_with_variance(ty::Contravariant, a_ty, b_ty));\n                 }\n             }\n         }"}, {"sha": "7194e20b0cf655224c08530e4f569c158d197cab", "filename": "src/librustc/middle/infer/equate.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -13,11 +13,7 @@ use middle::ty::{self, Ty};\n use middle::ty::TyVar;\n use middle::infer::combine::*;\n use middle::infer::{cres};\n-use middle::infer::glb::Glb;\n-use middle::infer::InferCtxt;\n-use middle::infer::lub::Lub;\n-use middle::infer::sub::Sub;\n-use middle::infer::{TypeTrace, Subtype};\n+use middle::infer::{Subtype};\n use middle::infer::type_variable::{EqTo};\n use util::ppaux::{Repr};\n \n@@ -33,21 +29,20 @@ pub fn Equate<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Equate<'f, 'tcx> {\n }\n \n impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields.infcx }\n-    fn tag(&self) -> String { \"eq\".to_string() }\n-    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n-    fn trace(&self) -> TypeTrace<'tcx> { self.fields.trace.clone() }\n+    fn tag(&self) -> String { \"Equate\".to_string() }\n+    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx> { &self.fields }\n \n-    fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { Equate(self.fields.clone()) }\n-    fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { Sub(self.fields.clone()) }\n-    fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields.clone()) }\n-    fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields.clone()) }\n-\n-    fn contratys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n+    fn tys_with_variance(&self, _: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n+                         -> cres<'tcx, Ty<'tcx>>\n+    {\n+        // Once we're equating, it doesn't matter what the variance is.\n         self.tys(a, b)\n     }\n \n-    fn contraregions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region> {\n+    fn regions_with_variance(&self, _: ty::Variance, a: ty::Region, b: ty::Region)\n+                             -> cres<'tcx, ty::Region>\n+    {\n+        // Once we're equating, it doesn't matter what the variance is.\n         self.regions(a, b)\n     }\n "}, {"sha": "33303808e84910ebb7062c4bf9147451ee7aaecd", "filename": "src/librustc/middle/infer/glb.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -10,12 +10,9 @@\n \n use super::combine::*;\n use super::lattice::*;\n-use super::equate::Equate;\n use super::higher_ranked::HigherRankedRelations;\n-use super::lub::Lub;\n-use super::sub::Sub;\n-use super::{cres, InferCtxt};\n-use super::{TypeTrace, Subtype};\n+use super::{cres};\n+use super::Subtype;\n \n use middle::ty::{BuiltinBounds};\n use middle::ty::{self, Ty};\n@@ -34,15 +31,30 @@ pub fn Glb<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Glb<'f, 'tcx> {\n }\n \n impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields.infcx }\n-    fn tag(&self) -> String { \"glb\".to_string() }\n-    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n-    fn trace(&self) -> TypeTrace<'tcx> { self.fields.trace.clone() }\n+    fn tag(&self) -> String { \"Glb\".to_string() }\n+    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx> { &self.fields }\n \n-    fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { Equate(self.fields.clone()) }\n-    fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { Sub(self.fields.clone()) }\n-    fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields.clone()) }\n-    fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields.clone()) }\n+    fn tys_with_variance(&self, v: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n+                         -> cres<'tcx, Ty<'tcx>>\n+    {\n+        match v {\n+            ty::Invariant => self.equate().tys(a, b),\n+            ty::Covariant => self.tys(a, b),\n+            ty::Bivariant => self.bivariate().tys(a, b),\n+            ty::Contravariant => self.lub().tys(a, b),\n+        }\n+    }\n+\n+    fn regions_with_variance(&self, v: ty::Variance, a: ty::Region, b: ty::Region)\n+                             -> cres<'tcx, ty::Region>\n+    {\n+        match v {\n+            ty::Invariant => self.equate().regions(a, b),\n+            ty::Covariant => self.regions(a, b),\n+            ty::Bivariant => self.bivariate().regions(a, b),\n+            ty::Contravariant => self.lub().regions(a, b),\n+        }\n+    }\n \n     fn mts(&self, a: &ty::mt<'tcx>, b: &ty::mt<'tcx>) -> cres<'tcx, ty::mt<'tcx>> {\n         let tcx = self.fields.infcx.tcx;\n@@ -75,10 +87,6 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n         }\n     }\n \n-    fn contratys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n-        self.lub().tys(a, b)\n-    }\n-\n     fn unsafeties(&self, a: Unsafety, b: Unsafety) -> cres<'tcx, Unsafety> {\n         match (a, b) {\n           (Unsafety::Normal, _) | (_, Unsafety::Normal) => Ok(Unsafety::Normal),\n@@ -104,11 +112,6 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n         Ok(self.fields.infcx.region_vars.glb_regions(Subtype(self.trace()), a, b))\n     }\n \n-    fn contraregions(&self, a: ty::Region, b: ty::Region)\n-                    -> cres<'tcx, ty::Region> {\n-        self.lub().regions(a, b)\n-    }\n-\n     fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n         super_lattice_tys(self, a, b)\n     }"}, {"sha": "3570effa9fa709ff2de3c304db15f75f6dd4d428", "filename": "src/librustc/middle/infer/lub.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -9,13 +9,10 @@\n // except according to those terms.\n \n use super::combine::*;\n-use super::equate::Equate;\n-use super::glb::Glb;\n use super::higher_ranked::HigherRankedRelations;\n use super::lattice::*;\n-use super::sub::Sub;\n-use super::{cres, InferCtxt};\n-use super::{TypeTrace, Subtype};\n+use super::{cres};\n+use super::{Subtype};\n \n use middle::ty::{BuiltinBounds};\n use middle::ty::{self, Ty};\n@@ -34,15 +31,30 @@ pub fn Lub<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Lub<'f, 'tcx> {\n }\n \n impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields.infcx }\n-    fn tag(&self) -> String { \"lub\".to_string() }\n-    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n-    fn trace(&self) -> TypeTrace<'tcx> { self.fields.trace.clone() }\n+    fn tag(&self) -> String { \"Lub\".to_string() }\n+    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx> { &self.fields }\n \n-    fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { Equate(self.fields.clone()) }\n-    fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { Sub(self.fields.clone()) }\n-    fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields.clone()) }\n-    fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields.clone()) }\n+    fn tys_with_variance(&self, v: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n+                         -> cres<'tcx, Ty<'tcx>>\n+    {\n+        match v {\n+            ty::Invariant => self.equate().tys(a, b),\n+            ty::Covariant => self.tys(a, b),\n+            ty::Bivariant => self.bivariate().tys(a, b),\n+            ty::Contravariant => self.glb().tys(a, b),\n+        }\n+    }\n+\n+    fn regions_with_variance(&self, v: ty::Variance, a: ty::Region, b: ty::Region)\n+                             -> cres<'tcx, ty::Region>\n+    {\n+        match v {\n+            ty::Invariant => self.equate().regions(a, b),\n+            ty::Covariant => self.regions(a, b),\n+            ty::Bivariant => self.bivariate().regions(a, b),\n+            ty::Contravariant => self.glb().regions(a, b),\n+        }\n+    }\n \n     fn mts(&self, a: &ty::mt<'tcx>, b: &ty::mt<'tcx>) -> cres<'tcx, ty::mt<'tcx>> {\n         let tcx = self.tcx();\n@@ -70,10 +82,6 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n         }\n     }\n \n-    fn contratys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n-        self.glb().tys(a, b)\n-    }\n-\n     fn unsafeties(&self, a: Unsafety, b: Unsafety) -> cres<'tcx, Unsafety> {\n         match (a, b) {\n           (Unsafety::Unsafe, _) | (_, Unsafety::Unsafe) => Ok(Unsafety::Unsafe),\n@@ -90,11 +98,6 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n         Ok(a.intersection(b))\n     }\n \n-    fn contraregions(&self, a: ty::Region, b: ty::Region)\n-                    -> cres<'tcx, ty::Region> {\n-        self.glb().regions(a, b)\n-    }\n-\n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),"}, {"sha": "3cffe4c0fda408c09957db7a107fdb51fef591b1", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -45,6 +45,7 @@ use self::lub::Lub;\n use self::unify::{UnificationTable, InferCtxtMethodsForSimplyUnifiableTypes};\n use self::error_reporting::ErrorReporting;\n \n+pub mod bivariate;\n pub mod combine;\n pub mod equate;\n pub mod error_reporting;"}, {"sha": "bfe5ba4c4c5d2df06139a10045e14711f836a095", "filename": "src/librustc/middle/infer/sub.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -10,12 +10,8 @@\n \n use super::combine::*;\n use super::{cres, CresCompare};\n-use super::equate::Equate;\n-use super::glb::Glb;\n use super::higher_ranked::HigherRankedRelations;\n-use super::InferCtxt;\n-use super::lub::Lub;\n-use super::{TypeTrace, Subtype};\n+use super::{Subtype};\n use super::type_variable::{SubtypeOf, SupertypeOf};\n \n use middle::ty::{BuiltinBounds};\n@@ -37,28 +33,31 @@ pub fn Sub<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Sub<'f, 'tcx> {\n }\n \n impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields.infcx }\n-    fn tag(&self) -> String { \"sub\".to_string() }\n-    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n-    fn trace(&self) -> TypeTrace<'tcx> { self.fields.trace.clone() }\n-\n-    fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { Equate(self.fields.clone()) }\n-    fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { Sub(self.fields.clone()) }\n-    fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields.clone()) }\n-    fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields.clone()) }\n-\n-    fn contratys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n-        Sub(self.fields.switch_expected()).tys(b, a)\n+    fn tag(&self) -> String { \"Sub\".to_string() }\n+    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx> { &self.fields }\n+\n+    fn tys_with_variance(&self, v: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n+                         -> cres<'tcx, Ty<'tcx>>\n+    {\n+        // Once we're equating, it doesn't matter what the variance is.\n+        match v {\n+            ty::Invariant => self.equate().tys(a, b),\n+            ty::Covariant => self.tys(a, b),\n+            ty::Bivariant => self.bivariate().tys(a, b),\n+            ty::Contravariant => Sub(self.fields.switch_expected()).tys(b, a),\n+        }\n     }\n \n-    fn contraregions(&self, a: ty::Region, b: ty::Region)\n-                     -> cres<'tcx, ty::Region> {\n-                         let opp = CombineFields {\n-                             a_is_expected: !self.fields.a_is_expected,\n-                             ..self.fields.clone()\n-                         };\n-                         Sub(opp).regions(b, a)\n-                     }\n+    fn regions_with_variance(&self, v: ty::Variance, a: ty::Region, b: ty::Region)\n+                             -> cres<'tcx, ty::Region>\n+    {\n+        match v {\n+            ty::Invariant => self.equate().regions(a, b),\n+            ty::Covariant => self.regions(a, b),\n+            ty::Bivariant => self.bivariate().regions(a, b),\n+            ty::Contravariant => Sub(self.fields.switch_expected()).regions(b, a),\n+        }\n+    }\n \n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region> {\n         debug!(\"{}.regions({}, {})\","}, {"sha": "4b9718b4f6ce7d7c71ae8f1594904d41a6584ac2", "filename": "src/librustc/middle/infer/type_variable.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -48,15 +48,16 @@ type Relation = (RelationDir, ty::TyVid);\n \n #[derive(Copy, PartialEq, Debug)]\n pub enum RelationDir {\n-    SubtypeOf, SupertypeOf, EqTo\n+    SubtypeOf, SupertypeOf, EqTo, BiTo\n }\n \n impl RelationDir {\n     fn opposite(self) -> RelationDir {\n         match self {\n             SubtypeOf => SupertypeOf,\n             SupertypeOf => SubtypeOf,\n-            EqTo => EqTo\n+            EqTo => EqTo,\n+            BiTo => BiTo,\n         }\n     }\n }"}, {"sha": "acebb97a0c13f95f682170dfbeacb11f691fbd4f", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -312,16 +312,9 @@ lets_do_this! {\n     ExchangeHeapLangItem,            \"exchange_heap\",           exchange_heap;\n     OwnedBoxLangItem,                \"owned_box\",               owned_box;\n \n+    PhantomFnItem,                   \"phantom_fn\",              phantom_fn;\n     PhantomDataItem,                 \"phantom_data\",            phantom_data;\n \n-    CovariantTypeItem,               \"covariant_type\",          covariant_type;\n-    ContravariantTypeItem,           \"contravariant_type\",      contravariant_type;\n-    InvariantTypeItem,               \"invariant_type\",          invariant_type;\n-\n-    CovariantLifetimeItem,           \"covariant_lifetime\",      covariant_lifetime;\n-    ContravariantLifetimeItem,       \"contravariant_lifetime\",  contravariant_lifetime;\n-    InvariantLifetimeItem,           \"invariant_lifetime\",      invariant_lifetime;\n-\n     NoCopyItem,                      \"no_copy_bound\",           no_copy_bound;\n     ManagedItem,                     \"managed_bound\",           managed_bound;\n "}, {"sha": "ac8f7783eb82bd2880e423efd5b2d09fc2c7ce9b", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -133,6 +133,7 @@ pub enum MethodMatchedData {\n /// parameters) that would have to be inferred from the impl.\n #[derive(PartialEq,Eq,Debug,Clone)]\n enum SelectionCandidate<'tcx> {\n+    PhantomFnCandidate,\n     BuiltinCandidate(ty::BuiltinBound),\n     ParamCandidate(ty::PolyTraitRef<'tcx>),\n     ImplCandidate(ast::DefId),\n@@ -795,15 +796,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                stack: &TraitObligationStack<'o, 'tcx>)\n                                -> Result<SelectionCandidateSet<'tcx>, SelectionError<'tcx>>\n     {\n-        // Check for overflow.\n-\n         let TraitObligationStack { obligation, .. } = *stack;\n \n         let mut candidates = SelectionCandidateSet {\n             vec: Vec::new(),\n             ambiguous: false\n         };\n \n+        // Check for the `PhantomFn` trait. This is really just a special annotation that\n+        // *always* be considered to match, no matter what the type parameters etc.\n+        if self.tcx().lang_items.phantom_fn() == Some(obligation.predicate.def_id()) {\n+            candidates.vec.push(PhantomFnCandidate);\n+            return Ok(candidates);\n+        }\n+\n         // Other bounds. Consider both in-scope bounds from fn decl\n         // and applicable impls. There is a certain set of precedence rules here.\n \n@@ -1673,6 +1679,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     try!(self.confirm_builtin_candidate(obligation, builtin_bound))))\n             }\n \n+            PhantomFnCandidate |\n             ErrorCandidate => {\n                 Ok(VtableBuiltin(VtableBuiltinData { nested: VecPerParamSpace::empty() }))\n             }\n@@ -2339,6 +2346,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n impl<'tcx> Repr<'tcx> for SelectionCandidate<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n+            PhantomFnCandidate => format!(\"PhantomFnCandidate\"),\n             ErrorCandidate => format!(\"ErrorCandidate\"),\n             BuiltinCandidate(b) => format!(\"BuiltinCandidate({:?})\", b),\n             ParamCandidate(ref a) => format!(\"ParamCandidate({})\", a.repr(tcx)),"}, {"sha": "f40add8e2c0abd8882de2a89cab04064b8519a9d", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::ty::{self};\n+\n+use std::collections::HashSet;\n+use std::rc::Rc;\n+\n+pub fn identify_constrained_type_params<'tcx>(_tcx: &ty::ctxt<'tcx>,\n+                                              predicates: &[ty::Predicate<'tcx>],\n+                                              impl_trait_ref: Option<Rc<ty::TraitRef<'tcx>>>,\n+                                              input_parameters: &mut HashSet<ty::ParamTy>)\n+{\n+    loop {\n+        let num_inputs = input_parameters.len();\n+\n+        let projection_predicates =\n+            predicates.iter()\n+            .filter_map(|predicate| {\n+                match *predicate {\n+                    // Ignore higher-ranked binders. For the purposes\n+                    // of this check, they don't matter because they\n+                    // only affect named regions, and we're just\n+                    // concerned about type parameters here.\n+                    ty::Predicate::Projection(ref data) => Some(data.0.clone()),\n+                    _ => None,\n+                }\n+            });\n+\n+        for projection in projection_predicates {\n+            // Special case: watch out for some kind of sneaky attempt\n+            // to project out an associated type defined by this very trait.\n+            if Some(projection.projection_ty.trait_ref.clone()) == impl_trait_ref {\n+                continue;\n+            }\n+\n+            let relies_only_on_inputs =\n+                projection.projection_ty.trait_ref.input_types()\n+                                                  .iter()\n+                                                  .flat_map(|t| t.walk())\n+                                                  .filter_map(|t| t.as_opt_param_ty())\n+                                                  .all(|t| input_parameters.contains(&t));\n+\n+            if relies_only_on_inputs {\n+                input_parameters.extend(\n+                    projection.ty.walk().filter_map(|t| t.as_opt_param_ty()));\n+            }\n+        }\n+\n+        if input_parameters.len() == num_inputs {\n+            break;\n+        }\n+    }\n+}"}, {"sha": "be7138d54f8d09230238cee1afa2c8af4a262838", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 259, "deletions": 125, "changes": 384, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -187,6 +187,22 @@\n //!   and the definition-site variance of the [corresponding] type parameter\n //!   of a class `C` is `V1`, then the variance of `X` in the type expression\n //!   `C<E>` is `V3 = V1.xform(V2)`.\n+//!\n+//! ### Constraints\n+//!\n+//! If I have a struct or enum with where clauses:\n+//!\n+//!     struct Foo<T:Bar> { ... }\n+//!\n+//! you might wonder whether the variance of `T` with respect to `Bar`\n+//! affects the variance `T` with respect to `Foo`. I claim no.  The\n+//! reason: assume that `T` is invariant w/r/t `Bar` but covariant w/r/t\n+//! `Foo`. And then we have a `Foo<X>` that is upcast to `Foo<Y>`, where\n+//! `X <: Y`. However, while `X : Bar`, `Y : Bar` does not hold.  In that\n+//! case, the upcast will be illegal, but not because of a variance\n+//! failure, but rather because the target type `Foo<Y>` is itself just\n+//! not well-formed. Basically we get to assume well-formedness of all\n+//! types involved before considering variance.\n \n use self::VarianceTerm::*;\n use self::ParamKind::*;\n@@ -199,7 +215,6 @@ use middle::subst::{ParamSpace, FnSpace, TypeSpace, SelfSpace, VecPerParamSpace}\n use middle::ty::{self, Ty};\n use std::fmt;\n use std::rc::Rc;\n-use std::iter::repeat;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util;\n@@ -258,6 +273,11 @@ struct TermsContext<'a, 'tcx: 'a> {\n \n     empty_variances: Rc<ty::ItemVariances>,\n \n+    // For marker types, UnsafeCell, and other lang items where\n+    // variance is hardcoded, records the item-id and the hardcoded\n+    // variance.\n+    lang_items: Vec<(ast::NodeId, Vec<ty::Variance>)>,\n+\n     // Maps from the node id of a type/generic parameter to the\n     // corresponding inferred index.\n     inferred_map: NodeMap<InferredIndex>,\n@@ -269,7 +289,7 @@ struct TermsContext<'a, 'tcx: 'a> {\n #[derive(Copy, Debug, PartialEq)]\n enum ParamKind {\n     TypeParam,\n-    RegionParam\n+    RegionParam,\n }\n \n struct InferredInfo<'a> {\n@@ -279,6 +299,11 @@ struct InferredInfo<'a> {\n     index: uint,\n     param_id: ast::NodeId,\n     term: VarianceTermPtr<'a>,\n+\n+    // Initial value to use for this parameter when inferring\n+    // variance. For most parameters, this is Bivariant. But for lang\n+    // items and input type parameters on traits, it is different.\n+    initial_variance: ty::Variance,\n }\n \n fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n@@ -291,6 +316,8 @@ fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n         inferred_map: NodeMap(),\n         inferred_infos: Vec::new(),\n \n+        lang_items: lang_items(tcx),\n+\n         // cache and share the variance struct used for items with\n         // no type/region parameters\n         empty_variances: Rc::new(ty::ItemVariances {\n@@ -304,7 +331,68 @@ fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n     terms_cx\n }\n \n+fn lang_items(tcx: &ty::ctxt) -> Vec<(ast::NodeId,Vec<ty::Variance>)> {\n+    let all = vec![\n+        (tcx.lang_items.phantom_fn(), vec![ty::Contravariant, ty::Covariant]),\n+        (tcx.lang_items.phantom_data(), vec![ty::Covariant]),\n+        (tcx.lang_items.unsafe_cell_type(), vec![ty::Invariant])];\n+\n+    all.into_iter()\n+       .filter(|&(ref d,_)| d.is_some())\n+       .filter(|&(ref d,_)| d.as_ref().unwrap().krate == ast::LOCAL_CRATE)\n+       .map(|(d, v)| (d.unwrap().node, v))\n+       .collect()\n+}\n+\n impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n+    fn add_inferreds_for_item(&mut self,\n+                              item_id: ast::NodeId,\n+                              has_self: bool,\n+                              generics: &ast::Generics)\n+    {\n+        /*!\n+         * Add \"inferreds\" for the generic parameters declared on this\n+         * item. This has a lot of annoying parameters because we are\n+         * trying to drive this from the AST, rather than the\n+         * ty::Generics, so that we can get span info -- but this\n+         * means we must accommodate syntactic distinctions.\n+         */\n+\n+        // NB: In the code below for writing the results back into the\n+        // tcx, we rely on the fact that all inferreds for a particular\n+        // item are assigned continuous indices.\n+\n+        let inferreds_on_entry = self.num_inferred();\n+\n+        if has_self {\n+            self.add_inferred(item_id, TypeParam, SelfSpace, 0, item_id);\n+        }\n+\n+        for (i, p) in generics.lifetimes.iter().enumerate() {\n+            let id = p.lifetime.id;\n+            self.add_inferred(item_id, RegionParam, TypeSpace, i, id);\n+        }\n+\n+        for (i, p) in generics.ty_params.iter().enumerate() {\n+            self.add_inferred(item_id, TypeParam, TypeSpace, i, p.id);\n+        }\n+\n+        // If this item has no type or lifetime parameters,\n+        // then there are no variances to infer, so just\n+        // insert an empty entry into the variance map.\n+        // Arguably we could just leave the map empty in this\n+        // case but it seems cleaner to be able to distinguish\n+        // \"invalid item id\" from \"item id with no\n+        // parameters\".\n+        if self.num_inferred() == inferreds_on_entry {\n+            let newly_added =\n+                self.tcx.item_variance_map.borrow_mut().insert(\n+                    ast_util::local_def(item_id),\n+                    self.empty_variances.clone()).is_none();\n+            assert!(newly_added);\n+        }\n+    }\n+\n     fn add_inferred(&mut self,\n                     item_id: ast::NodeId,\n                     kind: ParamKind,\n@@ -313,21 +401,48 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n                     param_id: ast::NodeId) {\n         let inf_index = InferredIndex(self.inferred_infos.len());\n         let term = self.arena.alloc(InferredTerm(inf_index));\n+        let initial_variance = self.pick_initial_variance(item_id, space, index);\n         self.inferred_infos.push(InferredInfo { item_id: item_id,\n                                                 kind: kind,\n                                                 space: space,\n                                                 index: index,\n                                                 param_id: param_id,\n-                                                term: term });\n+                                                term: term,\n+                                                initial_variance: initial_variance });\n         let newly_added = self.inferred_map.insert(param_id, inf_index).is_none();\n         assert!(newly_added);\n \n-        debug!(\"add_inferred(item_id={}, \\\n+        debug!(\"add_inferred(item_path={}, \\\n+                item_id={}, \\\n                 kind={:?}, \\\n+                space={:?}, \\\n                 index={}, \\\n-                param_id={},\n-                inf_index={:?})\",\n-                item_id, kind, index, param_id, inf_index);\n+                param_id={}, \\\n+                inf_index={:?}, \\\n+                initial_variance={:?})\",\n+               ty::item_path_str(self.tcx, ast_util::local_def(item_id)),\n+               item_id, kind, space, index, param_id, inf_index,\n+               initial_variance);\n+    }\n+\n+    fn pick_initial_variance(&self,\n+                             item_id: ast::NodeId,\n+                             space: ParamSpace,\n+                             index: uint)\n+                             -> ty::Variance\n+    {\n+        match space {\n+            SelfSpace | FnSpace => {\n+                ty::Bivariant\n+            }\n+\n+            TypeSpace => {\n+                match self.lang_items.iter().find(|&&(n, _)| n == item_id) {\n+                    Some(&(_, ref variances)) => variances[index],\n+                    None => ty::Bivariant\n+                }\n+            }\n+        }\n     }\n \n     fn num_inferred(&self) -> uint {\n@@ -339,44 +454,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for TermsContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item) {\n         debug!(\"add_inferreds for item {}\", item.repr(self.tcx));\n \n-        let inferreds_on_entry = self.num_inferred();\n-\n-        // NB: In the code below for writing the results back into the\n-        // tcx, we rely on the fact that all inferreds for a particular\n-        // item are assigned continuous indices.\n-        match item.node {\n-            ast::ItemTrait(..) => {\n-                self.add_inferred(item.id, TypeParam, SelfSpace, 0, item.id);\n-            }\n-            _ => { }\n-        }\n-\n         match item.node {\n             ast::ItemEnum(_, ref generics) |\n-            ast::ItemStruct(_, ref generics) |\n+            ast::ItemStruct(_, ref generics) => {\n+                self.add_inferreds_for_item(item.id, false, generics);\n+            }\n             ast::ItemTrait(_, ref generics, _, _) => {\n-                for (i, p) in generics.lifetimes.iter().enumerate() {\n-                    let id = p.lifetime.id;\n-                    self.add_inferred(item.id, RegionParam, TypeSpace, i, id);\n-                }\n-                for (i, p) in generics.ty_params.iter().enumerate() {\n-                    self.add_inferred(item.id, TypeParam, TypeSpace, i, p.id);\n-                }\n-\n-                // If this item has no type or lifetime parameters,\n-                // then there are no variances to infer, so just\n-                // insert an empty entry into the variance map.\n-                // Arguably we could just leave the map empty in this\n-                // case but it seems cleaner to be able to distinguish\n-                // \"invalid item id\" from \"item id with no\n-                // parameters\".\n-                if self.num_inferred() == inferreds_on_entry {\n-                    let newly_added = self.tcx.item_variance_map.borrow_mut().insert(\n-                        ast_util::local_def(item.id),\n-                        self.empty_variances.clone()).is_none();\n-                    assert!(newly_added);\n-                }\n-\n+                self.add_inferreds_for_item(item.id, true, generics);\n                 visit::walk_item(self, item);\n             }\n \n@@ -404,16 +488,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for TermsContext<'a, 'tcx> {\n struct ConstraintContext<'a, 'tcx: 'a> {\n     terms_cx: TermsContext<'a, 'tcx>,\n \n-    // These are the def-id of the std::marker::InvariantType,\n-    // std::marker::InvariantLifetime, and so on. The arrays\n-    // are indexed by the `ParamKind` (type, lifetime, self). Note\n-    // that there are no marker types for self, so the entries for\n-    // self are always None.\n-    invariant_lang_items: [Option<ast::DefId>; 2],\n-    covariant_lang_items: [Option<ast::DefId>; 2],\n-    contravariant_lang_items: [Option<ast::DefId>; 2],\n-    unsafe_cell_lang_item: Option<ast::DefId>,\n-\n     // These are pointers to common `ConstantTerm` instances\n     covariant: VarianceTermPtr<'a>,\n     contravariant: VarianceTermPtr<'a>,\n@@ -433,40 +507,14 @@ struct Constraint<'a> {\n \n fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>,\n                                         krate: &ast::Crate)\n-                                        -> ConstraintContext<'a, 'tcx> {\n-    let mut invariant_lang_items = [None; 2];\n-    let mut covariant_lang_items = [None; 2];\n-    let mut contravariant_lang_items = [None; 2];\n-\n-    covariant_lang_items[TypeParam as uint] =\n-        terms_cx.tcx.lang_items.covariant_type();\n-    covariant_lang_items[RegionParam as uint] =\n-        terms_cx.tcx.lang_items.covariant_lifetime();\n-\n-    contravariant_lang_items[TypeParam as uint] =\n-        terms_cx.tcx.lang_items.contravariant_type();\n-    contravariant_lang_items[RegionParam as uint] =\n-        terms_cx.tcx.lang_items.contravariant_lifetime();\n-\n-    invariant_lang_items[TypeParam as uint] =\n-        terms_cx.tcx.lang_items.invariant_type();\n-    invariant_lang_items[RegionParam as uint] =\n-        terms_cx.tcx.lang_items.invariant_lifetime();\n-\n-    let unsafe_cell_lang_item = terms_cx.tcx.lang_items.unsafe_cell_type();\n-\n+                                        -> ConstraintContext<'a, 'tcx>\n+{\n     let covariant = terms_cx.arena.alloc(ConstantTerm(ty::Covariant));\n     let contravariant = terms_cx.arena.alloc(ConstantTerm(ty::Contravariant));\n     let invariant = terms_cx.arena.alloc(ConstantTerm(ty::Invariant));\n     let bivariant = terms_cx.arena.alloc(ConstantTerm(ty::Bivariant));\n     let mut constraint_cx = ConstraintContext {\n         terms_cx: terms_cx,\n-\n-        invariant_lang_items: invariant_lang_items,\n-        covariant_lang_items: covariant_lang_items,\n-        contravariant_lang_items: contravariant_lang_items,\n-        unsafe_cell_lang_item: unsafe_cell_lang_item,\n-\n         covariant: covariant,\n         contravariant: contravariant,\n         invariant: invariant,\n@@ -487,7 +535,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n \n         match item.node {\n             ast::ItemEnum(ref enum_definition, _) => {\n-                let generics = &ty::lookup_item_type(tcx, did).generics;\n+                let scheme = ty::lookup_item_type(tcx, did);\n+\n+                // Not entirely obvious: constraints on structs/enums do not\n+                // affect the variance of their type parameters. See discussion\n+                // in comment at top of module.\n+                //\n+                // self.add_constraints_from_generics(&scheme.generics);\n \n                 // Hack: If we directly call `ty::enum_variants`, it\n                 // annoyingly takes it upon itself to run off and\n@@ -505,29 +559,48 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n                                                           &**ast_variant,\n                                                           /*discriminant*/ 0);\n                     for arg_ty in &variant.args {\n-                        self.add_constraints_from_ty(generics, *arg_ty, self.covariant);\n+                        self.add_constraints_from_ty(&scheme.generics, *arg_ty, self.covariant);\n                     }\n                 }\n             }\n \n             ast::ItemStruct(..) => {\n-                let generics = &ty::lookup_item_type(tcx, did).generics;\n+                let scheme = ty::lookup_item_type(tcx, did);\n+\n+                // Not entirely obvious: constraints on structs/enums do not\n+                // affect the variance of their type parameters. See discussion\n+                // in comment at top of module.\n+                //\n+                // self.add_constraints_from_generics(&scheme.generics);\n+\n                 let struct_fields = ty::lookup_struct_fields(tcx, did);\n                 for field_info in &struct_fields {\n                     assert_eq!(field_info.id.krate, ast::LOCAL_CRATE);\n                     let field_ty = ty::node_id_to_type(tcx, field_info.id.node);\n-                    self.add_constraints_from_ty(generics, field_ty, self.covariant);\n+                    self.add_constraints_from_ty(&scheme.generics, field_ty, self.covariant);\n                 }\n             }\n \n             ast::ItemTrait(..) => {\n+                let trait_def = ty::lookup_trait_def(tcx, did);\n+                let predicates = ty::predicates(tcx, ty::mk_self_type(tcx), &trait_def.bounds);\n+                self.add_constraints_from_predicates(&trait_def.generics,\n+                                                     &predicates[],\n+                                                     self.covariant);\n+\n                 let trait_items = ty::trait_items(tcx, did);\n                 for trait_item in &*trait_items {\n                     match *trait_item {\n                         ty::MethodTraitItem(ref method) => {\n-                            self.add_constraints_from_sig(&method.generics,\n-                                                          &method.fty.sig,\n-                                                          self.covariant);\n+                            self.add_constraints_from_predicates(\n+                                &method.generics,\n+                                method.predicates.predicates.get_slice(FnSpace),\n+                                self.contravariant);\n+\n+                            self.add_constraints_from_sig(\n+                                &method.generics,\n+                                &method.fty.sig,\n+                                self.covariant);\n                         }\n                         ty::TypeTraitItem(_) => {}\n                     }\n@@ -544,9 +617,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n             ast::ItemTy(..) |\n             ast::ItemImpl(..) |\n             ast::ItemMac(..) => {\n-                visit::walk_item(self, item);\n             }\n         }\n+\n+        visit::walk_item(self, item);\n     }\n }\n \n@@ -648,15 +722,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                          -> VarianceTermPtr<'a> {\n         assert_eq!(param_def_id.krate, item_def_id.krate);\n \n-        if self.invariant_lang_items[kind as uint] == Some(item_def_id) {\n-            self.invariant\n-        } else if self.covariant_lang_items[kind as uint] == Some(item_def_id) {\n-            self.covariant\n-        } else if self.contravariant_lang_items[kind as uint] == Some(item_def_id) {\n-            self.contravariant\n-        } else if kind == TypeParam && Some(item_def_id) == self.unsafe_cell_lang_item {\n-            self.invariant\n-        } else if param_def_id.krate == ast::LOCAL_CRATE {\n+        if param_def_id.krate == ast::LOCAL_CRATE {\n             // Parameter on an item defined within current crate:\n             // variance not yet inferred, so return a symbolic\n             // variance.\n@@ -724,14 +790,35 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         }\n     }\n \n+    fn add_constraints_from_trait_ref(&mut self,\n+                                      generics: &ty::Generics<'tcx>,\n+                                      trait_ref: &ty::TraitRef<'tcx>,\n+                                      variance: VarianceTermPtr<'a>) {\n+        debug!(\"add_constraints_from_trait_ref: trait_ref={} variance={:?}\",\n+               trait_ref.repr(self.tcx()),\n+               variance);\n+\n+        let trait_def = ty::lookup_trait_def(self.tcx(), trait_ref.def_id);\n+\n+        self.add_constraints_from_substs(\n+            generics,\n+            trait_ref.def_id,\n+            trait_def.generics.types.as_slice(),\n+            trait_def.generics.regions.as_slice(),\n+            trait_ref.substs,\n+            variance);\n+    }\n+\n     /// Adds constraints appropriate for an instance of `ty` appearing\n     /// in a context with the generics defined in `generics` and\n     /// ambient variance `variance`\n     fn add_constraints_from_ty(&mut self,\n                                generics: &ty::Generics<'tcx>,\n                                ty: Ty<'tcx>,\n                                variance: VarianceTermPtr<'a>) {\n-        debug!(\"add_constraints_from_ty(ty={})\", ty.repr(self.tcx()));\n+        debug!(\"add_constraints_from_ty(ty={}, variance={:?})\",\n+               ty.repr(self.tcx()),\n+               variance);\n \n         match ty.sty {\n             ty::ty_bool |\n@@ -754,6 +841,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.add_constraints_from_ty(generics, typ, variance);\n             }\n \n+\n             ty::ty_ptr(ref mt) => {\n                 self.add_constraints_from_mt(generics, mt, variance);\n             }\n@@ -797,27 +885,16 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::ty_trait(ref data) => {\n-                let trait_ref = data.principal_trait_ref_with_self_ty(self.tcx(),\n-                                                                      self.tcx().types.err);\n-                let trait_def = ty::lookup_trait_def(self.tcx(), trait_ref.def_id());\n-\n-                // Traits never declare region parameters in the self\n-                // space nor anything in the fn space.\n-                assert!(trait_def.generics.regions.is_empty_in(subst::SelfSpace));\n-                assert!(trait_def.generics.types.is_empty_in(subst::FnSpace));\n-                assert!(trait_def.generics.regions.is_empty_in(subst::FnSpace));\n+                let poly_trait_ref =\n+                    data.principal_trait_ref_with_self_ty(self.tcx(),\n+                                                          self.tcx().types.err);\n \n                 // The type `Foo<T+'a>` is contravariant w/r/t `'a`:\n                 let contra = self.contravariant(variance);\n                 self.add_constraints_from_region(generics, data.bounds.region_bound, contra);\n \n-                self.add_constraints_from_substs(\n-                    generics,\n-                    trait_ref.def_id(),\n-                    trait_def.generics.types.get_slice(subst::TypeSpace),\n-                    trait_def.generics.regions.get_slice(subst::TypeSpace),\n-                    trait_ref.substs(),\n-                    variance);\n+                // Ignore the SelfSpace, it is erased.\n+                self.add_constraints_from_trait_ref(generics, &*poly_trait_ref.0, variance);\n \n                 let projections = data.projection_bounds_with_self_ty(self.tcx(),\n                                                                       self.tcx().types.err);\n@@ -845,7 +922,12 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.add_constraints_from_sig(generics, sig, variance);\n             }\n \n-            ty::ty_infer(..) | ty::ty_err => {\n+            ty::ty_err => {\n+                // we encounter this when walking the trait references for object\n+                // types, where we use ty_err as the Self type\n+            }\n+\n+            ty::ty_infer(..) => {\n                 self.tcx().sess.bug(\n                     &format!(\"unexpected type encountered in \\\n                             variance inference: {}\",\n@@ -864,14 +946,19 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                    region_param_defs: &[ty::RegionParameterDef],\n                                    substs: &subst::Substs<'tcx>,\n                                    variance: VarianceTermPtr<'a>) {\n-        debug!(\"add_constraints_from_substs(def_id={:?})\", def_id);\n+        debug!(\"add_constraints_from_substs(def_id={}, substs={}, variance={:?})\",\n+               def_id.repr(self.tcx()),\n+               substs.repr(self.tcx()),\n+               variance);\n \n         for p in type_param_defs {\n             let variance_decl =\n                 self.declared_variance(p.def_id, def_id, TypeParam,\n                                        p.space, p.index as uint);\n             let variance_i = self.xform(variance, variance_decl);\n             let substs_ty = *substs.types.get(p.space, p.index as uint);\n+            debug!(\"add_constraints_from_substs: variance_decl={:?} variance_i={:?}\",\n+                   variance_decl, variance_i);\n             self.add_constraints_from_ty(generics, substs_ty, variance_i);\n         }\n \n@@ -885,6 +972,51 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         }\n     }\n \n+    fn add_constraints_from_predicates(&mut self,\n+                                       generics: &ty::Generics<'tcx>,\n+                                       predicates: &[ty::Predicate<'tcx>],\n+                                       variance: VarianceTermPtr<'a>) {\n+        debug!(\"add_constraints_from_generics({})\",\n+               generics.repr(self.tcx()));\n+\n+        for predicate in predicates.iter() {\n+            match *predicate {\n+                ty::Predicate::Trait(ty::Binder(ref data)) => {\n+                    self.add_constraints_from_trait_ref(generics, &*data.trait_ref, variance);\n+                }\n+\n+                ty::Predicate::Equate(ty::Binder(ref data)) => {\n+                    self.add_constraints_from_ty(generics, data.0, variance);\n+                    self.add_constraints_from_ty(generics, data.1, variance);\n+                }\n+\n+                ty::Predicate::TypeOutlives(ty::Binder(ref data)) => {\n+                    self.add_constraints_from_ty(generics, data.0, variance);\n+\n+                    let variance_r = self.xform(variance, self.contravariant);\n+                    self.add_constraints_from_region(generics, data.1, variance_r);\n+                }\n+\n+                ty::Predicate::RegionOutlives(ty::Binder(ref data)) => {\n+                    // `'a : 'b` is still true if 'a gets bigger\n+                    self.add_constraints_from_region(generics, data.0, variance);\n+\n+                    // `'a : 'b` is still true if 'b gets smaller\n+                    let variance_r = self.xform(variance, self.contravariant);\n+                    self.add_constraints_from_region(generics, data.1, variance_r);\n+                }\n+\n+                ty::Predicate::Projection(ty::Binder(ref data)) => {\n+                    self.add_constraints_from_trait_ref(generics,\n+                                                        &*data.projection_ty.trait_ref,\n+                                                        variance);\n+\n+                    self.add_constraints_from_ty(generics, data.ty, self.invariant);\n+                }\n+            }\n+        }\n+    }\n+\n     /// Adds constraints appropriate for a function with signature\n     /// `sig` appearing in a context with ambient variance `variance`\n     fn add_constraints_from_sig(&mut self,\n@@ -969,7 +1101,12 @@ struct SolveContext<'a, 'tcx: 'a> {\n \n fn solve_constraints(constraints_cx: ConstraintContext) {\n     let ConstraintContext { terms_cx, constraints, .. } = constraints_cx;\n-    let solutions: Vec<_> = repeat(ty::Bivariant).take(terms_cx.num_inferred()).collect();\n+\n+    let solutions =\n+        terms_cx.inferred_infos.iter()\n+                               .map(|ii| ii.initial_variance)\n+                               .collect();\n+\n     let mut solutions_cx = SolveContext {\n         terms_cx: terms_cx,\n         constraints: constraints,\n@@ -1034,20 +1171,16 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n             let mut types = VecPerParamSpace::empty();\n             let mut regions = VecPerParamSpace::empty();\n \n-            while index < num_inferred &&\n-                  inferred_infos[index].item_id == item_id {\n+            while index < num_inferred && inferred_infos[index].item_id == item_id {\n                 let info = &inferred_infos[index];\n                 let variance = solutions[index];\n                 debug!(\"Index {} Info {} / {:?} / {:?} Variance {:?}\",\n                        index, info.index, info.kind, info.space, variance);\n                 match info.kind {\n-                    TypeParam => {\n-                        types.push(info.space, variance);\n-                    }\n-                    RegionParam => {\n-                        regions.push(info.space, variance);\n-                    }\n+                    TypeParam => { types.push(info.space, variance); }\n+                    RegionParam => { regions.push(info.space, variance); }\n                 }\n+\n                 index += 1;\n             }\n \n@@ -1144,3 +1277,4 @@ fn glb(v1: ty::Variance, v2: ty::Variance) -> ty::Variance {\n         (x, ty::Bivariant) | (ty::Bivariant, x) => x,\n     }\n }\n+"}, {"sha": "3330e1d0d51b036273edf2e797bdc1cc3b924c40", "filename": "src/test/compile-fail/variance-contravariant-arg-object.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-arg-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-arg-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-arg-object.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+trait Get<T> : 'static {\n+    fn get(&self, t: T);\n+}\n+\n+fn get_min_from_max<'min, 'max>(v: Box<Get<&'max i32>>)\n+                                -> Box<Get<&'min i32>>\n+    where 'max : 'min\n+{\n+    v //~ ERROR mismatched types\n+}\n+\n+fn get_max_from_min<'min, 'max, G>(v: Box<Get<&'min i32>>)\n+                                   -> Box<Get<&'max i32>>\n+    where 'max : 'min\n+{\n+    v\n+}\n+\n+fn main() { }"}, {"sha": "caaad4014adfa73f301ce8ca16753e9658a61960", "filename": "src/test/compile-fail/variance-contravariant-arg-trait-match.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-arg-trait-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-arg-trait-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-arg-trait-match.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+trait Get<T> {\n+    fn get(&self, t: T);\n+}\n+\n+fn get_min_from_max<'min, 'max, G>()\n+    where 'max : 'min, G : Get<&'max i32>\n+{\n+    impls_get::<G,&'min i32>() //~ ERROR mismatched types\n+}\n+\n+fn get_max_from_min<'min, 'max, G>()\n+    where 'max : 'min, G : Get<&'min i32>\n+{\n+    impls_get::<G,&'max i32>()\n+}\n+\n+fn impls_get<G,T>() where G : Get<T> { }\n+\n+fn main() { }"}, {"sha": "013511ed517a87cd4f1f4d915e320c9316310c0e", "filename": "src/test/compile-fail/variance-contravariant-self-trait-match.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-self-trait-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-self-trait-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-self-trait-match.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+trait Get {\n+    fn get(&self);\n+}\n+\n+fn get_min_from_max<'min, 'max, G>()\n+    where 'max : 'min, G : 'max, &'max G : Get\n+{\n+    impls_get::<&'min G>(); //~ ERROR mismatched types\n+}\n+\n+fn get_max_from_min<'min, 'max, G>()\n+    where 'max : 'min, G : 'max, &'min G : Get\n+{\n+    impls_get::<&'max G>();\n+}\n+\n+fn impls_get<G>() where G : Get { }\n+\n+fn main() { }"}, {"sha": "828c987c0821226720bce8c24b0ae92df5ae2228", "filename": "src/test/compile-fail/variance-covariant-arg-object.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-arg-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-arg-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-arg-object.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+trait Get<T> : 'static {\n+    fn get(&self) -> T;\n+}\n+\n+fn get_min_from_max<'min, 'max>(v: Box<Get<&'max i32>>)\n+                                -> Box<Get<&'min i32>>\n+    where 'max : 'min\n+{\n+    v\n+}\n+\n+fn get_max_from_min<'min, 'max, G>(v: Box<Get<&'min i32>>)\n+                                   -> Box<Get<&'max i32>>\n+    where 'max : 'min\n+{\n+    v //~ ERROR mismatched types\n+}\n+\n+fn main() { }"}, {"sha": "17761b9c0b19e7bf13d8092e0074cd73fb7ca78c", "filename": "src/test/compile-fail/variance-covariant-arg-trait-match.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-arg-trait-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-arg-trait-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-arg-trait-match.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+trait Get<T> {\n+    fn get(&self) -> T;\n+}\n+\n+fn get_min_from_max<'min, 'max, G>()\n+    where 'max : 'min, G : Get<&'max i32>\n+{\n+    impls_get::<G,&'min i32>()\n+}\n+\n+fn get_max_from_min<'min, 'max, G>()\n+    where 'max : 'min, G : Get<&'min i32>\n+{\n+    impls_get::<G,&'max i32>() //~ ERROR mismatched types\n+}\n+\n+fn impls_get<G,T>() where G : Get<T> { }\n+\n+fn main() { }"}, {"sha": "4e94a3eeb46e6de5295ed4647182a3c3da9491a8", "filename": "src/test/compile-fail/variance-covariant-self-trait-match.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-self-trait-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-self-trait-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-self-trait-match.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+trait Get {\n+    fn get() -> Self;\n+}\n+\n+fn get_min_from_max<'min, 'max, G>()\n+    where 'max : 'min, G : 'max, &'max G : Get\n+{\n+    impls_get::<&'min G>();\n+}\n+\n+fn get_max_from_min<'min, 'max, G>()\n+    where 'max : 'min, G : 'max, &'min G : Get\n+{\n+    impls_get::<&'max G>(); //~ ERROR mismatched types\n+}\n+\n+fn impls_get<G>() where G : Get { }\n+\n+fn main() { }"}, {"sha": "9edb510b826a12df92df2fe2ea40966ca9ac98fa", "filename": "src/test/compile-fail/variance-invariant-arg-object.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-invariant-arg-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-invariant-arg-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-invariant-arg-object.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+trait Get<T> : 'static {\n+    fn get(&self, t: T) -> T;\n+}\n+\n+fn get_min_from_max<'min, 'max>(v: Box<Get<&'max i32>>)\n+                                -> Box<Get<&'min i32>>\n+    where 'max : 'min\n+{\n+    v //~ ERROR mismatched types\n+}\n+\n+fn get_max_from_min<'min, 'max, G>(v: Box<Get<&'min i32>>)\n+                                   -> Box<Get<&'max i32>>\n+    where 'max : 'min\n+{\n+    v //~ ERROR mismatched types\n+}\n+\n+fn main() { }"}, {"sha": "45fed0b083dc1d47cfd83ef49688e00d8568a680", "filename": "src/test/compile-fail/variance-invariant-arg-trait-match.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-invariant-arg-trait-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-invariant-arg-trait-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-invariant-arg-trait-match.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+trait Get<T> {\n+    fn get(&self, t: T) -> T;\n+}\n+\n+fn get_min_from_max<'min, 'max, G>()\n+    where 'max : 'min, G : Get<&'max i32>\n+{\n+    impls_get::<G,&'min i32>() //~ ERROR mismatched types\n+}\n+\n+fn get_max_from_min<'min, 'max, G>()\n+    where 'max : 'min, G : Get<&'min i32>\n+{\n+    impls_get::<G,&'max i32>() //~ ERROR mismatched types\n+}\n+\n+fn impls_get<G,T>() where G : Get<T> { }\n+\n+fn main() { }"}, {"sha": "b46cd302ae5ea83ce1b6d2546295c358001aa148", "filename": "src/test/compile-fail/variance-invariant-self-trait-match.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-invariant-self-trait-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-invariant-self-trait-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-invariant-self-trait-match.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+trait Get {\n+    fn get(&self) -> Self;\n+}\n+\n+fn get_min_from_max<'min, 'max, G>()\n+    where 'max : 'min, &'max G : Get\n+{\n+    impls_get::<&'min G>(); //~ ERROR mismatched types\n+}\n+\n+fn get_max_from_min<'min, 'max, G>()\n+    where 'max : 'min, &'min G : Get\n+{\n+    impls_get::<&'max G>(); //~ ERROR mismatched types\n+}\n+\n+fn impls_get<G>() where G : Get { }\n+\n+fn main() { }"}, {"sha": "396e77652067d5c10c91b4c910285f34fceefbb5", "filename": "src/test/compile-fail/variance-regions-unused-direct.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-regions-unused-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-regions-unused-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-unused-direct.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that disallow lifetime parameters that are unused.\n+\n+use std::marker;\n+\n+struct Bivariant<'a>; //~ ERROR parameter `'a` is never used\n+\n+struct Struct<'a, 'd> { //~ ERROR parameter `'d` is never used\n+    field: &'a [i32]\n+}\n+\n+trait Trait<'a, 'd> { //~ ERROR parameter `'d` is never used\n+    fn method(&'a self);\n+}\n+\n+fn main() {}"}, {"sha": "2d234ed7b57812ef0b7dfa1a9ab5519bd0d7fe69", "filename": "src/test/compile-fail/variance-regions-unused-indirect.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-regions-unused-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-regions-unused-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-unused-indirect.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that disallow lifetime parameters that are unused.\n+\n+enum Foo<'a> { //~ ERROR parameter `'a` is never used\n+    Foo1(Bar<'a>)\n+}\n+\n+enum Bar<'a> { //~ ERROR parameter `'a` is never used\n+    Bar1(Foo<'a>)\n+}\n+\n+fn main() {}"}, {"sha": "661979479237e7829f3cadbe674d3f9b023c02fd", "filename": "src/test/compile-fail/variance-trait-bounds.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(bivariance)]\n+#![allow(dead_code)]\n+\n+// Check that bounds on type parameters (other than `Self`) do not\n+// influence variance.\n+\n+#[rustc_variance]\n+trait Getter<T> { //~ ERROR types=[[+];[-];[]]\n+    fn get(&self) -> T;\n+}\n+\n+#[rustc_variance]\n+trait Setter<T> { //~ ERROR types=[[-];[-];[]]\n+    fn get(&self, T);\n+}\n+\n+#[rustc_variance]\n+struct TestStruct<U,T:Setter<U>> { //~ ERROR types=[[+, +];[];[]]\n+    t: T, u: U\n+}\n+\n+#[rustc_variance]\n+enum TestEnum<U,T:Setter<U>> {//~ ERROR types=[[*, +];[];[]]\n+    //~^ ERROR parameter `U` is never used\n+    Foo(T)\n+}\n+\n+#[rustc_variance]\n+trait TestTrait<U,T:Setter<U>> { //~ ERROR types=[[-, +];[-];[]]\n+    fn getter(&self, u: U) -> T;\n+}\n+\n+#[rustc_variance]\n+trait TestTrait2<U> : Getter<U> { //~ ERROR types=[[+];[-];[]]\n+}\n+\n+#[rustc_variance]\n+trait TestTrait3<U> { //~ ERROR types=[[-];[-];[]]\n+    fn getter<T:Getter<U>>(&self);\n+}\n+\n+#[rustc_variance]\n+struct TestContraStruct<U,T:Setter<U>> { //~ ERROR types=[[*, +];[];[]]\n+    //~^ ERROR parameter `U` is never used\n+    t: T\n+}\n+\n+#[rustc_variance]\n+struct TestBox<U,T:Getter<U>+Setter<U>> { //~ ERROR types=[[*, +];[];[]]\n+    //~^ ERROR parameter `U` is never used\n+    t: T\n+}\n+\n+pub fn main() { }"}, {"sha": "c60649878feaf077cbfe5f24160696451fb487e5", "filename": "src/test/compile-fail/variance-types-bounds.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-types-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-types-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-types-bounds.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we correctly infer variance for type parameters in\n+// various types and traits.\n+\n+#[rustc_variance]\n+struct TestImm<A, B> { //~ ERROR types=[[+, +];[];[]]\n+    x: A,\n+    y: B,\n+}\n+\n+#[rustc_variance]\n+struct TestMut<A, B:'static> { //~ ERROR types=[[+, o];[];[]]\n+    x: A,\n+    y: &'static mut B,\n+}\n+\n+#[rustc_variance]\n+struct TestIndirect<A:'static, B:'static> { //~ ERROR types=[[+, o];[];[]]\n+    m: TestMut<A, B>\n+}\n+\n+#[rustc_variance]\n+struct TestIndirect2<A:'static, B:'static> { //~ ERROR types=[[o, o];[];[]]\n+    n: TestMut<A, B>,\n+    m: TestMut<B, A>\n+}\n+\n+#[rustc_variance]\n+trait Getter<A> { //~ ERROR types=[[+];[-];[]]\n+    fn get(&self) -> A;\n+}\n+\n+#[rustc_variance]\n+trait Setter<A> { //~ ERROR types=[[-];[o];[]]\n+    fn set(&mut self, a: A);\n+}\n+\n+#[rustc_variance]\n+trait GetterSetter<A> { //~ ERROR types=[[o];[o];[]]\n+    fn get(&self) -> A;\n+    fn set(&mut self, a: A);\n+}\n+\n+#[rustc_variance]\n+trait GetterInTypeBound<A> { //~ ERROR types=[[-];[-];[]]\n+    // Here, the use of `A` in the method bound *does* affect\n+    // variance.  Think of it as if the method requested a dictionary\n+    // for `T:Getter<A>`.  Since this dictionary is an input, it is\n+    // contravariant, and the Getter is covariant w/r/t A, yielding an\n+    // overall contravariant result.\n+    fn do_it<T:Getter<A>>(&self);\n+}\n+\n+#[rustc_variance]\n+trait SetterInTypeBound<A> { //~ ERROR types=[[+];[-];[]]\n+    fn do_it<T:Setter<A>>(&self);\n+}\n+\n+#[rustc_variance]\n+struct TestObject<A, R> { //~ ERROR types=[[-, +];[];[]]\n+    n: Box<Setter<A>+Send>,\n+    m: Box<Getter<R>+Send>,\n+}\n+\n+fn main() {}"}, {"sha": "6f6dd72769283299d7948db13da56bddb568e1af", "filename": "src/test/compile-fail/variance-types.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-types.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(bivariance)]\n+#![allow(dead_code)]\n+\n+use std::cell::Cell;\n+\n+// Check that a type parameter which is only used in a trait bound is\n+// not considered bivariant.\n+\n+#[rustc_variance]\n+struct InvariantMut<'a,A:'a,B:'a> { //~ ERROR types=[[o, o];[];[]], regions=[[-];[];[]]\n+    t: &'a mut (A,B)\n+}\n+\n+#[rustc_variance]\n+struct InvariantCell<A> { //~ ERROR types=[[o];[];[]]\n+    t: Cell<A>\n+}\n+\n+#[rustc_variance]\n+struct InvariantIndirect<A> { //~ ERROR types=[[o];[];[]]\n+    t: InvariantCell<A>\n+}\n+\n+#[rustc_variance]\n+struct Covariant<A> { //~ ERROR types=[[+];[];[]]\n+    t: A, u: fn() -> A\n+}\n+\n+#[rustc_variance]\n+struct Contravariant<A> { //~ ERROR types=[[-];[];[]]\n+    t: fn(A)\n+}\n+\n+#[rustc_variance]\n+enum Enum<A,B,C> { //~ ERROR types=[[+, -, o];[];[]]\n+    Foo(Covariant<A>),\n+    Bar(Contravariant<B>),\n+    Zed(Covariant<C>,Contravariant<C>)\n+}\n+\n+pub fn main() { }"}, {"sha": "5f504226370a45cff2b3fa55e3f81184a14935fb", "filename": "src/test/compile-fail/variance-unused-region-param.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-unused-region-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-unused-region-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-unused-region-param.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we report an error for unused type parameters in types.\n+\n+struct SomeStruct<'a> { x: u32 } //~ ERROR parameter `'a` is never used\n+enum SomeEnum<'a> { Nothing } //~ ERROR parameter `'a` is never used\n+trait SomeTrait<'a> { fn foo(&self); } //~ ERROR parameter `'a` is never used\n+\n+fn main() {}"}, {"sha": "2e867ec3c9384892a7aa5dbf6442eaadff55eb9d", "filename": "src/test/compile-fail/variance-unused-type-param.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-unused-type-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-unused-type-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-unused-type-param.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+// Test that we report an error for unused type parameters in types and traits,\n+// and that we offer a helpful suggestion.\n+\n+struct SomeStruct<A> { x: u32 }\n+//~^ ERROR parameter `A` is never used\n+//~| HELP PhantomData\n+\n+enum SomeEnum<A> { Nothing }\n+//~^ ERROR parameter `A` is never used\n+//~| HELP PhantomData\n+\n+trait SomeTrait<A> { fn foo(&self); }\n+//~^ ERROR parameter `A` is never used\n+//~| HELP PhantomFn\n+\n+// Here T might *appear* used, but in fact it isn't.\n+enum ListCell<T> {\n+//~^ ERROR parameter `T` is never used\n+//~| HELP PhantomData\n+    Cons(Box<ListCell<T>>),\n+    Nil\n+}\n+\n+fn main() {}"}, {"sha": "21a9e2477df7c5ea51bf38ec090fe8d335b0e22f", "filename": "src/test/compile-fail/variance-use-contravariant-struct-1.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-use-contravariant-struct-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-use-contravariant-struct-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-use-contravariant-struct-1.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test various uses of structs with distint variances to make sure\n+// they permit lifetimes to be approximated as expected.\n+\n+struct SomeStruct<T>(fn(T));\n+\n+fn foo<'min,'max>(v: SomeStruct<&'max ()>)\n+                  -> SomeStruct<&'min ()>\n+    where 'max : 'min\n+{\n+    v //~ ERROR mismatched types\n+}\n+\n+#[rustc_error]\n+fn main() { }"}, {"sha": "dd80ac91683b4ed323c12499f72026b29ed268a5", "filename": "src/test/compile-fail/variance-use-contravariant-struct-2.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-use-contravariant-struct-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-use-contravariant-struct-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-use-contravariant-struct-2.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test various uses of structs with distint variances to make sure\n+// they permit lifetimes to be approximated as expected.\n+\n+#![allow(dead_code)]\n+\n+struct SomeStruct<T>(fn(T));\n+\n+fn bar<'min,'max>(v: SomeStruct<&'min ()>)\n+                  -> SomeStruct<&'max ()>\n+    where 'max : 'min\n+{\n+    v\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "2631cfc05e81de646f2c245ae69834e688c3b166", "filename": "src/test/compile-fail/variance-use-covariant-struct-1.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-use-covariant-struct-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-use-covariant-struct-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-use-covariant-struct-1.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a covariant struct does not permit the lifetime of a\n+// reference to be enlarged.\n+\n+struct SomeStruct<T>(T);\n+\n+fn foo<'min,'max>(v: SomeStruct<&'min ()>)\n+                  -> SomeStruct<&'max ()>\n+    where 'max : 'min\n+{\n+    v //~ ERROR mismatched types\n+}\n+\n+fn main() { }"}, {"sha": "f85f7bb6a384fbfcf165945727ab3f2259f365bd", "filename": "src/test/compile-fail/variance-use-covariant-struct-2.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-use-covariant-struct-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-use-covariant-struct-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-use-covariant-struct-2.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a covariant struct permits the lifetime of a reference to\n+// be shortened.\n+\n+#![allow(dead_code)]\n+\n+struct SomeStruct<T>(T);\n+\n+fn foo<'min,'max>(v: SomeStruct<&'max ()>)\n+                  -> SomeStruct<&'min ()>\n+    where 'max : 'min\n+{\n+    v\n+}\n+\n+#[rustc_error] fn main() { } //~ ERROR compilation successful"}, {"sha": "b544ef00fc0a3d50b6de726a6ac0fd2acfb74234", "filename": "src/test/compile-fail/variance-use-invariant-struct-1.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-use-invariant-struct-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Fcompile-fail%2Fvariance-use-invariant-struct-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-use-invariant-struct-1.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test various uses of structs with distint variances to make sure\n+// they permit lifetimes to be approximated as expected.\n+\n+struct SomeStruct<T>(*mut T);\n+\n+fn foo<'min,'max>(v: SomeStruct<&'max ()>)\n+                  -> SomeStruct<&'min ()>\n+    where 'max : 'min\n+{\n+    v //~ ERROR mismatched types\n+}\n+\n+fn bar<'min,'max>(v: SomeStruct<&'min ()>)\n+                  -> SomeStruct<&'max ()>\n+    where 'max : 'min\n+{\n+    v //~ ERROR mismatched types\n+}\n+\n+#[rustc_error]\n+fn main() { }"}, {"sha": "948d68e0ccd7d7d84c402166413f4aa1c5ed8129", "filename": "src/test/run-pass/variance-intersection-of-ref-and-opt-ref.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Frun-pass%2Fvariance-intersection-of-ref-and-opt-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Frun-pass%2Fvariance-intersection-of-ref-and-opt-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvariance-intersection-of-ref-and-opt-ref.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Elaborated version of the opening example from RFC 738. This failed\n+// to compile before variance because invariance of `Option` prevented\n+// us from approximating the lifetimes of `field1` and `field2` to a\n+// common intersection.\n+\n+#![allow(dead_code)]\n+\n+struct List<'l> {\n+    field1: &'l i32,\n+    field2: Option<&'l i32>,\n+}\n+\n+fn foo(field1: &i32, field2: Option<&i32>) -> i32 {\n+    let list = List { field1: field1, field2: field2 };\n+    *list.field1 + list.field2.cloned().unwrap_or(0)\n+}\n+\n+fn main() {\n+    let x = 22;\n+    let y = Some(3);\n+    let z = None;\n+    assert_eq!(foo(&x, y.as_ref()), 25);\n+    assert_eq!(foo(&x, z.as_ref()), 22);\n+}"}, {"sha": "10441bee3cb9ff8381434ea6c040c4cf1c2e8d31", "filename": "src/test/run-pass/variance-trait-matching.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Frun-pass%2Fvariance-trait-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Frun-pass%2Fvariance-trait-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvariance-trait-matching.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+// Get<T> is covariant in T\n+trait Get<T> {\n+    fn get(&self) -> T;\n+}\n+\n+struct Cloner<T:Clone> {\n+    t: T\n+}\n+\n+impl<T:Clone> Get<T> for Cloner<T> {\n+    fn get(&self) -> T {\n+        self.t.clone()\n+    }\n+}\n+\n+fn get<'a, G>(get: &G) -> i32\n+    where G : Get<&'a i32>\n+{\n+    // This call only type checks if we can use `G : Get<&'a i32>` as\n+    // evidence that `G : Get<&'b i32>` where `'a : 'b`.\n+    pick(get, &22)\n+}\n+\n+fn pick<'b, G>(get: &'b G, if_odd: &'b i32) -> i32\n+    where G : Get<&'b i32>\n+{\n+    let v = *get.get();\n+    if v % 2 != 0 { v } else { *if_odd }\n+}\n+\n+fn main() {\n+    let x = Cloner { t: &23 };\n+    let y = get(&x);\n+    assert_eq!(y, 23);\n+}\n+\n+"}, {"sha": "caec6df5a4d81a56c5c16da8999f8a11786209e4", "filename": "src/test/run-pass/variance-vec-covariant.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Frun-pass%2Fvariance-vec-covariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2594d56e32bd5a86befbb9e072b272251bbdfc9f/src%2Ftest%2Frun-pass%2Fvariance-vec-covariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvariance-vec-covariant.rs?ref=2594d56e32bd5a86befbb9e072b272251bbdfc9f", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that vec is now covariant in its argument type.\n+\n+#![allow(dead_code)]\n+\n+fn foo<'a,'b>(v1: Vec<&'a i32>, v2: Vec<&'b i32>) -> i32 {\n+    bar(v1, v2).cloned().unwrap_or(0) // only type checks if we can intersect 'a and 'b\n+}\n+\n+fn bar<'c>(v1: Vec<&'c i32>, v2: Vec<&'c i32>) -> Option<&'c i32> {\n+    v1.get(0).cloned().or_else(|| v2.get(0).cloned())\n+}\n+\n+fn main() {\n+    let x = 22;\n+    let y = 44;\n+    assert_eq!(foo(vec![&x], vec![&y]), 22);\n+    assert_eq!(foo(vec![&y], vec![&x]), 44);\n+}"}]}