{"sha": "2dd94c133ead2cd62636a876d6d72a2a00348943", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkZDk0YzEzM2VhZDJjZDYyNjM2YTg3NmQ2ZDcyYTJhMDAzNDg5NDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-25T00:00:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-25T00:00:17Z"}, "message": "Auto merge of #55915 - oli-obk:miri_engine_refactoring, r=RalfJung\n\nMiri engine refactoring\n\nnext small step of https://github.com/rust-lang/rust/pull/55293\n\nr? @RalfJung", "tree": {"sha": "aa9669b7e22c97ceede28a2785c09d4a70a7c3ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa9669b7e22c97ceede28a2785c09d4a70a7c3ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2dd94c133ead2cd62636a876d6d72a2a00348943", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2dd94c133ead2cd62636a876d6d72a2a00348943", "html_url": "https://github.com/rust-lang/rust/commit/2dd94c133ead2cd62636a876d6d72a2a00348943", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2dd94c133ead2cd62636a876d6d72a2a00348943/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "edaac35d67bed09260dc0c318acc5212fb66246e", "url": "https://api.github.com/repos/rust-lang/rust/commits/edaac35d67bed09260dc0c318acc5212fb66246e", "html_url": "https://github.com/rust-lang/rust/commit/edaac35d67bed09260dc0c318acc5212fb66246e"}, {"sha": "b853252bcdb2ded2b049d833c51a993fe0ed40f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/b853252bcdb2ded2b049d833c51a993fe0ed40f8", "html_url": "https://github.com/rust-lang/rust/commit/b853252bcdb2ded2b049d833c51a993fe0ed40f8"}], "stats": {"total": 1106, "additions": 613, "deletions": 493}, "files": [{"sha": "dc9296b81e223dd9beb212158c3972902f6e7d10", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2dd94c133ead2cd62636a876d6d72a2a00348943/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2dd94c133ead2cd62636a876d6d72a2a00348943/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=2dd94c133ead2cd62636a876d6d72a2a00348943", "patch": "@@ -306,7 +306,7 @@ dependencies = [\n  \"clippy-mini-macro-test 0.2.0\",\n  \"clippy_dev 0.0.1\",\n  \"clippy_lints 0.0.212\",\n- \"compiletest_rs 0.3.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiletest_rs 0.3.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"derive-new 0.5.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -423,7 +423,7 @@ dependencies = [\n \n [[package]]\n name = \"compiletest_rs\"\n-version = \"0.3.16\"\n+version = \"0.3.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"diff 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1315,7 +1315,7 @@ dependencies = [\n  \"byteorder 1.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cargo_metadata 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"colored 1.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"compiletest_rs 0.3.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiletest_rs 0.3.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.5.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"vergen 3.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3274,7 +3274,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum colored 1.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b0aa3473e85a3161b59845d6096b289bb577874cafeaf75ea1b1beaa6572c7fc\"\n \"checksum commoncrypto 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d056a8586ba25a1e4d61cb090900e495952c7886786fc55f909ab2f819b69007\"\n \"checksum commoncrypto-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1fed34f46747aa73dfaa578069fd8279d2818ade2b55f38f22a9401c7f4083e2\"\n-\"checksum compiletest_rs 0.3.16 (registry+https://github.com/rust-lang/crates.io-index)\" = \"75e809f56d6aa9575b67924b0af686c4f4c1380314f47947e235e9ff7fa94bed\"\n+\"checksum compiletest_rs 0.3.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"89747fe073b7838343bd2c2445e7a7c2e0d415598f8925f0fa9205b9cdfc48cb\"\n \"checksum core-foundation 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cc3532ec724375c7cb7ff0a097b714fde180bb1f6ed2ab27cfcd99ffca873cd2\"\n \"checksum core-foundation-sys 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a3fb15cdbdd9cf8b82d97d0296bb5cd3631bba58d6e31650a002a8e7fb5721f9\"\n \"checksum crossbeam 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"24ce9782d4d5c53674646a6a4c1863a21a8fc0cb649b3c94dfc16e45071dea19\""}, {"sha": "c612d6ad1bb24fe4dfc12df1bd932c995472bed9", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 417, "deletions": 1, "changes": 418, "blob_url": "https://github.com/rust-lang/rust/blob/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=2dd94c133ead2cd62636a876d6d72a2a00348943", "patch": "@@ -10,14 +10,18 @@\n \n //! The virtual memory representation of the MIR interpreter\n \n-use super::{Pointer, EvalResult, AllocId};\n+use super::{\n+    Pointer, EvalResult, AllocId, ScalarMaybeUndef, write_target_uint, read_target_uint, Scalar,\n+    truncate,\n+};\n \n use ty::layout::{Size, Align};\n use syntax::ast::Mutability;\n use std::iter;\n use mir;\n use std::ops::{Deref, DerefMut};\n use rustc_data_structures::sorted_map::SortedMap;\n+use rustc_target::abi::HasDataLayout;\n \n /// Used by `check_bounds` to indicate whether the pointer needs to be just inbounds\n /// or also inbounds of a *live* allocation.\n@@ -49,6 +53,418 @@ pub struct Allocation<Tag=(),Extra=()> {\n     pub extra: Extra,\n }\n \n+/// Alignment and bounds checks\n+impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n+    /// Check if the pointer is \"in-bounds\". Notice that a pointer pointing at the end\n+    /// of an allocation (i.e., at the first *inaccessible* location) *is* considered\n+    /// in-bounds!  This follows C's/LLVM's rules.\n+    /// If you want to check bounds before doing a memory access, better use `check_bounds`.\n+    pub fn check_bounds_ptr(\n+        &self,\n+        ptr: Pointer<Tag>,\n+    ) -> EvalResult<'tcx> {\n+        let allocation_size = self.bytes.len() as u64;\n+        ptr.check_in_alloc(Size::from_bytes(allocation_size), InboundsCheck::Live)\n+    }\n+\n+    /// Check if the memory range beginning at `ptr` and of size `Size` is \"in-bounds\".\n+    #[inline(always)]\n+    pub fn check_bounds(\n+        &self,\n+        cx: &impl HasDataLayout,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+    ) -> EvalResult<'tcx> {\n+        // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n+        self.check_bounds_ptr(ptr.offset(size, cx)?)\n+    }\n+}\n+\n+/// Byte accessors\n+impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n+    /// The last argument controls whether we error out when there are undefined\n+    /// or pointer bytes.  You should never call this, call `get_bytes` or\n+    /// `get_bytes_with_undef_and_ptr` instead,\n+    ///\n+    /// This function also guarantees that the resulting pointer will remain stable\n+    /// even when new allocations are pushed to the `HashMap`. `copy_repeatedly` relies\n+    /// on that.\n+    fn get_bytes_internal(\n+        &self,\n+        cx: &impl HasDataLayout,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+        check_defined_and_ptr: bool,\n+    ) -> EvalResult<'tcx, &[u8]> {\n+        self.check_bounds(cx, ptr, size)?;\n+\n+        if check_defined_and_ptr {\n+            self.check_defined(ptr, size)?;\n+            self.check_relocations(cx, ptr, size)?;\n+        } else {\n+            // We still don't want relocations on the *edges*\n+            self.check_relocation_edges(cx, ptr, size)?;\n+        }\n+\n+        AllocationExtra::memory_read(self, ptr, size)?;\n+\n+        assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n+        assert_eq!(size.bytes() as usize as u64, size.bytes());\n+        let offset = ptr.offset.bytes() as usize;\n+        Ok(&self.bytes[offset..offset + size.bytes() as usize])\n+    }\n+\n+    #[inline]\n+    pub fn get_bytes(\n+        &self,\n+        cx: &impl HasDataLayout,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+    ) -> EvalResult<'tcx, &[u8]> {\n+        self.get_bytes_internal(cx, ptr, size, true)\n+    }\n+\n+    /// It is the caller's responsibility to handle undefined and pointer bytes.\n+    /// However, this still checks that there are no relocations on the *edges*.\n+    #[inline]\n+    pub fn get_bytes_with_undef_and_ptr(\n+        &self,\n+        cx: &impl HasDataLayout,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+    ) -> EvalResult<'tcx, &[u8]> {\n+        self.get_bytes_internal(cx, ptr, size, false)\n+    }\n+\n+    /// Just calling this already marks everything as defined and removes relocations,\n+    /// so be sure to actually put data there!\n+    pub fn get_bytes_mut(\n+        &mut self,\n+        cx: &impl HasDataLayout,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+    ) -> EvalResult<'tcx, &mut [u8]> {\n+        assert_ne!(size.bytes(), 0, \"0-sized accesses should never even get a `Pointer`\");\n+        self.check_bounds(cx, ptr, size)?;\n+\n+        self.mark_definedness(ptr, size, true)?;\n+        self.clear_relocations(cx, ptr, size)?;\n+\n+        AllocationExtra::memory_written(self, ptr, size)?;\n+\n+        assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n+        assert_eq!(size.bytes() as usize as u64, size.bytes());\n+        let offset = ptr.offset.bytes() as usize;\n+        Ok(&mut self.bytes[offset..offset + size.bytes() as usize])\n+    }\n+}\n+\n+/// Reading and writing\n+impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n+    /// Reads bytes until a `0` is encountered. Will error if the end of the allocation is reached\n+    /// before a `0` is found.\n+    pub fn read_c_str(\n+        &self,\n+        cx: &impl HasDataLayout,\n+        ptr: Pointer<Tag>,\n+    ) -> EvalResult<'tcx, &[u8]> {\n+        assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n+        let offset = ptr.offset.bytes() as usize;\n+        match self.bytes[offset..].iter().position(|&c| c == 0) {\n+            Some(size) => {\n+                let p1 = Size::from_bytes((size + 1) as u64);\n+                self.check_relocations(cx, ptr, p1)?;\n+                self.check_defined(ptr, p1)?;\n+                Ok(&self.bytes[offset..offset + size])\n+            }\n+            None => err!(UnterminatedCString(ptr.erase_tag())),\n+        }\n+    }\n+\n+    /// Validates that `ptr.offset` and `ptr.offset + size` do not point to the middle of a\n+    /// relocation. If `allow_ptr_and_undef` is `false`, also enforces that the memory in the\n+    /// given range contains neither relocations nor undef bytes.\n+    pub fn check_bytes(\n+        &self,\n+        cx: &impl HasDataLayout,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+        allow_ptr_and_undef: bool,\n+    ) -> EvalResult<'tcx> {\n+        // Check bounds and relocations on the edges\n+        self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n+        // Check undef and ptr\n+        if !allow_ptr_and_undef {\n+            self.check_defined(ptr, size)?;\n+            self.check_relocations(cx, ptr, size)?;\n+        }\n+        Ok(())\n+    }\n+\n+    /// Writes `src` to the memory starting at `ptr.offset`.\n+    ///\n+    /// Will do bounds checks on the allocation.\n+    pub fn write_bytes(\n+        &mut self,\n+        cx: &impl HasDataLayout,\n+        ptr: Pointer<Tag>,\n+        src: &[u8],\n+    ) -> EvalResult<'tcx> {\n+        let bytes = self.get_bytes_mut(cx, ptr, Size::from_bytes(src.len() as u64))?;\n+        bytes.clone_from_slice(src);\n+        Ok(())\n+    }\n+\n+    /// Sets `count` bytes starting at `ptr.offset` with `val`. Basically `memset`.\n+    pub fn write_repeat(\n+        &mut self,\n+        cx: &impl HasDataLayout,\n+        ptr: Pointer<Tag>,\n+        val: u8,\n+        count: Size\n+    ) -> EvalResult<'tcx> {\n+        let bytes = self.get_bytes_mut(cx, ptr, count)?;\n+        for b in bytes {\n+            *b = val;\n+        }\n+        Ok(())\n+    }\n+\n+    /// Read a *non-ZST* scalar\n+    ///\n+    /// zsts can't be read out of two reasons:\n+    /// * byteorder cannot work with zero element buffers\n+    /// * in oder to obtain a `Pointer` we need to check for ZSTness anyway due to integer pointers\n+    ///   being valid for ZSTs\n+    ///\n+    /// Note: This function does not do *any* alignment checks, you need to do these before calling\n+    pub fn read_scalar(\n+        &self,\n+        cx: &impl HasDataLayout,\n+        ptr: Pointer<Tag>,\n+        size: Size\n+    ) -> EvalResult<'tcx, ScalarMaybeUndef<Tag>> {\n+        // get_bytes_unchecked tests relocation edges\n+        let bytes = self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n+        // Undef check happens *after* we established that the alignment is correct.\n+        // We must not return Ok() for unaligned pointers!\n+        if self.check_defined(ptr, size).is_err() {\n+            // this inflates undefined bytes to the entire scalar, even if only a few\n+            // bytes are undefined\n+            return Ok(ScalarMaybeUndef::Undef);\n+        }\n+        // Now we do the actual reading\n+        let bits = read_target_uint(cx.data_layout().endian, bytes).unwrap();\n+        // See if we got a pointer\n+        if size != cx.data_layout().pointer_size {\n+            // *Now* better make sure that the inside also is free of relocations.\n+            self.check_relocations(cx, ptr, size)?;\n+        } else {\n+            match self.relocations.get(&ptr.offset) {\n+                Some(&(tag, alloc_id)) => {\n+                    let ptr = Pointer::new_with_tag(alloc_id, Size::from_bytes(bits as u64), tag);\n+                    return Ok(ScalarMaybeUndef::Scalar(ptr.into()))\n+                }\n+                None => {},\n+            }\n+        }\n+        // We don't. Just return the bits.\n+        Ok(ScalarMaybeUndef::Scalar(Scalar::from_uint(bits, size)))\n+    }\n+\n+    /// Note: This function does not do *any* alignment checks, you need to do these before calling\n+    pub fn read_ptr_sized(\n+        &self,\n+        cx: &impl HasDataLayout,\n+        ptr: Pointer<Tag>,\n+    ) -> EvalResult<'tcx, ScalarMaybeUndef<Tag>> {\n+        self.read_scalar(cx, ptr, cx.data_layout().pointer_size)\n+    }\n+\n+    /// Write a *non-ZST* scalar\n+    ///\n+    /// zsts can't be read out of two reasons:\n+    /// * byteorder cannot work with zero element buffers\n+    /// * in oder to obtain a `Pointer` we need to check for ZSTness anyway due to integer pointers\n+    ///   being valid for ZSTs\n+    ///\n+    /// Note: This function does not do *any* alignment checks, you need to do these before calling\n+    pub fn write_scalar(\n+        &mut self,\n+        cx: &impl HasDataLayout,\n+        ptr: Pointer<Tag>,\n+        val: ScalarMaybeUndef<Tag>,\n+        type_size: Size,\n+    ) -> EvalResult<'tcx> {\n+        let val = match val {\n+            ScalarMaybeUndef::Scalar(scalar) => scalar,\n+            ScalarMaybeUndef::Undef => return self.mark_definedness(ptr, type_size, false),\n+        };\n+\n+        let bytes = match val {\n+            Scalar::Ptr(val) => {\n+                assert_eq!(type_size, cx.data_layout().pointer_size);\n+                val.offset.bytes() as u128\n+            }\n+\n+            Scalar::Bits { bits, size } => {\n+                assert_eq!(size as u64, type_size.bytes());\n+                debug_assert_eq!(truncate(bits, Size::from_bytes(size.into())), bits,\n+                    \"Unexpected value of size {} when writing to memory\", size);\n+                bits\n+            },\n+        };\n+\n+        {\n+            let endian = cx.data_layout().endian;\n+            let dst = self.get_bytes_mut(cx, ptr, type_size)?;\n+            write_target_uint(endian, dst, bytes).unwrap();\n+        }\n+\n+        // See if we have to also write a relocation\n+        match val {\n+            Scalar::Ptr(val) => {\n+                self.relocations.insert(\n+                    ptr.offset,\n+                    (val.tag, val.alloc_id),\n+                );\n+            }\n+            _ => {}\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Note: This function does not do *any* alignment checks, you need to do these before calling\n+    pub fn write_ptr_sized(\n+        &mut self,\n+        cx: &impl HasDataLayout,\n+        ptr: Pointer<Tag>,\n+        val: ScalarMaybeUndef<Tag>\n+    ) -> EvalResult<'tcx> {\n+        let ptr_size = cx.data_layout().pointer_size;\n+        self.write_scalar(cx, ptr.into(), val, ptr_size)\n+    }\n+}\n+\n+/// Relocations\n+impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n+    /// Return all relocations overlapping with the given ptr-offset pair.\n+    pub fn relocations(\n+        &self,\n+        cx: &impl HasDataLayout,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+    ) -> &[(Size, (Tag, AllocId))] {\n+        // We have to go back `pointer_size - 1` bytes, as that one would still overlap with\n+        // the beginning of this range.\n+        let start = ptr.offset.bytes().saturating_sub(cx.data_layout().pointer_size.bytes() - 1);\n+        let end = ptr.offset + size; // this does overflow checking\n+        self.relocations.range(Size::from_bytes(start)..end)\n+    }\n+\n+    /// Check that there are no relocations overlapping with the given range.\n+    #[inline(always)]\n+    fn check_relocations(\n+        &self,\n+        cx: &impl HasDataLayout,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+    ) -> EvalResult<'tcx> {\n+        if self.relocations(cx, ptr, size).is_empty() {\n+            Ok(())\n+        } else {\n+            err!(ReadPointerAsBytes)\n+        }\n+    }\n+\n+    /// Remove all relocations inside the given range.\n+    /// If there are relocations overlapping with the edges, they\n+    /// are removed as well *and* the bytes they cover are marked as\n+    /// uninitialized.  This is a somewhat odd \"spooky action at a distance\",\n+    /// but it allows strictly more code to run than if we would just error\n+    /// immediately in that case.\n+    fn clear_relocations(\n+        &mut self,\n+        cx: &impl HasDataLayout,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+    ) -> EvalResult<'tcx> {\n+        // Find the start and end of the given range and its outermost relocations.\n+        let (first, last) = {\n+            // Find all relocations overlapping the given range.\n+            let relocations = self.relocations(cx, ptr, size);\n+            if relocations.is_empty() {\n+                return Ok(());\n+            }\n+\n+            (relocations.first().unwrap().0,\n+             relocations.last().unwrap().0 + cx.data_layout().pointer_size)\n+        };\n+        let start = ptr.offset;\n+        let end = start + size;\n+\n+        // Mark parts of the outermost relocations as undefined if they partially fall outside the\n+        // given range.\n+        if first < start {\n+            self.undef_mask.set_range(first, start, false);\n+        }\n+        if last > end {\n+            self.undef_mask.set_range(end, last, false);\n+        }\n+\n+        // Forget all the relocations.\n+        self.relocations.remove_range(first..last);\n+\n+        Ok(())\n+    }\n+\n+    /// Error if there are relocations overlapping with the edges of the\n+    /// given memory range.\n+    #[inline]\n+    fn check_relocation_edges(\n+        &self,\n+        cx: &impl HasDataLayout,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+    ) -> EvalResult<'tcx> {\n+        self.check_relocations(cx, ptr, Size::ZERO)?;\n+        self.check_relocations(cx, ptr.offset(size, cx)?, Size::ZERO)?;\n+        Ok(())\n+    }\n+}\n+\n+\n+/// Undefined bytes\n+impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n+    /// Checks that a range of bytes is defined. If not, returns the `ReadUndefBytes`\n+    /// error which will report the first byte which is undefined.\n+    #[inline]\n+    fn check_defined(&self, ptr: Pointer<Tag>, size: Size) -> EvalResult<'tcx> {\n+        self.undef_mask.is_range_defined(\n+            ptr.offset,\n+            ptr.offset + size,\n+        ).or_else(|idx| err!(ReadUndefBytes(idx)))\n+    }\n+\n+    pub fn mark_definedness(\n+        &mut self,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+        new_state: bool,\n+    ) -> EvalResult<'tcx> {\n+        if size.bytes() == 0 {\n+            return Ok(());\n+        }\n+        self.undef_mask.set_range(\n+            ptr.offset,\n+            ptr.offset + size,\n+            new_state,\n+        );\n+        Ok(())\n+    }\n+}\n+\n pub trait AllocationExtra<Tag>: ::std::fmt::Debug + Default + Clone {\n     /// Hook for performing extra checks on a memory read access.\n     ///"}, {"sha": "a046825f088bb327e92f31d4fbd2daf822aa7fa0", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=2dd94c133ead2cd62636a876d6d72a2a00348943", "patch": "@@ -2,7 +2,7 @@ use mir;\n use ty::layout::{self, HasDataLayout, Size};\n \n use super::{\n-    AllocId, EvalResult,\n+    AllocId, EvalResult, InboundsCheck,\n };\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -148,4 +148,21 @@ impl<'tcx, Tag> Pointer<Tag> {\n     pub fn erase_tag(self) -> Pointer {\n         Pointer { alloc_id: self.alloc_id, offset: self.offset, tag: () }\n     }\n+\n+    #[inline(always)]\n+    pub fn check_in_alloc(\n+        self,\n+        allocation_size: Size,\n+        check: InboundsCheck,\n+    ) -> EvalResult<'tcx, ()> {\n+        if self.offset > allocation_size {\n+            err!(PointerOutOfBounds {\n+                ptr: self.erase_tag(),\n+                check,\n+                allocation_size,\n+            })\n+        } else {\n+            Ok(())\n+        }\n+    }\n }"}, {"sha": "c673b57a66f5fbd7983a71ca4ed7b7de66878ee4", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 36, "deletions": 423, "changes": 459, "blob_url": "https://github.com/rust-lang/rust/blob/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=2dd94c133ead2cd62636a876d6d72a2a00348943", "patch": "@@ -21,16 +21,16 @@ use std::ptr;\n use std::borrow::Cow;\n \n use rustc::ty::{self, Instance, ParamEnv, query::TyCtxtAt};\n-use rustc::ty::layout::{self, Align, TargetDataLayout, Size, HasDataLayout};\n+use rustc::ty::layout::{Align, TargetDataLayout, Size, HasDataLayout};\n pub use rustc::mir::interpret::{truncate, write_target_uint, read_target_uint};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n \n use syntax::ast::Mutability;\n \n use super::{\n-    Pointer, AllocId, Allocation, GlobalId, AllocationExtra, InboundsCheck,\n+    Pointer, AllocId, Allocation, GlobalId, AllocationExtra,\n     EvalResult, Scalar, EvalErrorKind, AllocType, PointerArithmetic,\n-    Machine, AllocMap, MayLeak, ScalarMaybeUndef, ErrorHandled,\n+    Machine, AllocMap, MayLeak, ErrorHandled, InboundsCheck,\n };\n \n #[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]\n@@ -251,9 +251,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             Scalar::Ptr(ptr) => {\n                 // check this is not NULL -- which we can ensure only if this is in-bounds\n                 // of some (potentially dead) allocation.\n-                self.check_bounds_ptr(ptr, InboundsCheck::MaybeDead)?;\n-                // data required for alignment check\n-                let (_, align) = self.get_size_and_align(ptr.alloc_id);\n+                let align = self.check_bounds_ptr_maybe_dead(ptr)?;\n                 (ptr.offset.bytes(), align)\n             }\n             Scalar::Bits { bits, size } => {\n@@ -287,44 +285,19 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     /// Check if the pointer is \"in-bounds\". Notice that a pointer pointing at the end\n     /// of an allocation (i.e., at the first *inaccessible* location) *is* considered\n-    /// in-bounds!  This follows C's/LLVM's rules.  `check` indicates whether we\n-    /// additionally require the pointer to be pointing to a *live* (still allocated)\n-    /// allocation.\n-    /// If you want to check bounds before doing a memory access, better use `check_bounds`.\n-    pub fn check_bounds_ptr(\n+    /// in-bounds!  This follows C's/LLVM's rules.\n+    /// This function also works for deallocated allocations.\n+    /// Use `.get(ptr.alloc_id)?.check_bounds_ptr(ptr)` if you want to force the allocation\n+    /// to still be live.\n+    /// If you want to check bounds before doing a memory access, better first obtain\n+    /// an `Allocation` and call `check_bounds`.\n+    pub fn check_bounds_ptr_maybe_dead(\n         &self,\n         ptr: Pointer<M::PointerTag>,\n-        check: InboundsCheck,\n-    ) -> EvalResult<'tcx> {\n-        let allocation_size = match check {\n-            InboundsCheck::Live => {\n-                let alloc = self.get(ptr.alloc_id)?;\n-                alloc.bytes.len() as u64\n-            }\n-            InboundsCheck::MaybeDead => {\n-                self.get_size_and_align(ptr.alloc_id).0.bytes()\n-            }\n-        };\n-        if ptr.offset.bytes() > allocation_size {\n-            return err!(PointerOutOfBounds {\n-                ptr: ptr.erase_tag(),\n-                check,\n-                allocation_size: Size::from_bytes(allocation_size),\n-            });\n-        }\n-        Ok(())\n-    }\n-\n-    /// Check if the memory range beginning at `ptr` and of size `Size` is \"in-bounds\".\n-    #[inline(always)]\n-    pub fn check_bounds(\n-        &self,\n-        ptr: Pointer<M::PointerTag>,\n-        size: Size,\n-        check: InboundsCheck,\n-    ) -> EvalResult<'tcx> {\n-        // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n-        self.check_bounds_ptr(ptr.offset(size, &*self)?, check)\n+    ) -> EvalResult<'tcx, Align> {\n+        let (allocation_size, align) = self.get_size_and_align(ptr.alloc_id);\n+        ptr.check_in_alloc(allocation_size, InboundsCheck::MaybeDead)?;\n+        Ok(align)\n     }\n }\n \n@@ -609,87 +582,19 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     }\n }\n \n-/// Byte accessors\n+/// Byte Accessors\n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n-    /// The last argument controls whether we error out when there are undefined\n-    /// or pointer bytes.  You should never call this, call `get_bytes` or\n-    /// `get_bytes_with_undef_and_ptr` instead,\n-    ///\n-    /// This function also guarantees that the resulting pointer will remain stable\n-    /// even when new allocations are pushed to the `HashMap`. `copy_repeatedly` relies\n-    /// on that.\n-    fn get_bytes_internal(\n+    pub fn read_bytes(\n         &self,\n-        ptr: Pointer<M::PointerTag>,\n+        ptr: Scalar<M::PointerTag>,\n         size: Size,\n-        align: Align,\n-        check_defined_and_ptr: bool,\n     ) -> EvalResult<'tcx, &[u8]> {\n-        assert_ne!(size.bytes(), 0, \"0-sized accesses should never even get a `Pointer`\");\n-        self.check_align(ptr.into(), align)?;\n-        self.check_bounds(ptr, size, InboundsCheck::Live)?;\n-\n-        if check_defined_and_ptr {\n-            self.check_defined(ptr, size)?;\n-            self.check_relocations(ptr, size)?;\n+        if size.bytes() == 0 {\n+            Ok(&[])\n         } else {\n-            // We still don't want relocations on the *edges*\n-            self.check_relocation_edges(ptr, size)?;\n+            let ptr = ptr.to_ptr()?;\n+            self.get(ptr.alloc_id)?.get_bytes(self, ptr, size)\n         }\n-\n-        let alloc = self.get(ptr.alloc_id)?;\n-        AllocationExtra::memory_read(alloc, ptr, size)?;\n-\n-        assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n-        assert_eq!(size.bytes() as usize as u64, size.bytes());\n-        let offset = ptr.offset.bytes() as usize;\n-        Ok(&alloc.bytes[offset..offset + size.bytes() as usize])\n-    }\n-\n-    #[inline]\n-    fn get_bytes(\n-        &self,\n-        ptr: Pointer<M::PointerTag>,\n-        size: Size,\n-        align: Align\n-    ) -> EvalResult<'tcx, &[u8]> {\n-        self.get_bytes_internal(ptr, size, align, true)\n-    }\n-\n-    /// It is the caller's responsibility to handle undefined and pointer bytes.\n-    /// However, this still checks that there are no relocations on the *edges*.\n-    #[inline]\n-    fn get_bytes_with_undef_and_ptr(\n-        &self,\n-        ptr: Pointer<M::PointerTag>,\n-        size: Size,\n-        align: Align\n-    ) -> EvalResult<'tcx, &[u8]> {\n-        self.get_bytes_internal(ptr, size, align, false)\n-    }\n-\n-    /// Just calling this already marks everything as defined and removes relocations,\n-    /// so be sure to actually put data there!\n-    fn get_bytes_mut(\n-        &mut self,\n-        ptr: Pointer<M::PointerTag>,\n-        size: Size,\n-        align: Align,\n-    ) -> EvalResult<'tcx, &mut [u8]> {\n-        assert_ne!(size.bytes(), 0, \"0-sized accesses should never even get a `Pointer`\");\n-        self.check_align(ptr.into(), align)?;\n-        self.check_bounds(ptr, size, InboundsCheck::Live)?;\n-\n-        self.mark_definedness(ptr, size, true)?;\n-        self.clear_relocations(ptr, size)?;\n-\n-        let alloc = self.get_mut(ptr.alloc_id)?;\n-        AllocationExtra::memory_written(alloc, ptr, size)?;\n-\n-        assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n-        assert_eq!(size.bytes() as usize as u64, size.bytes());\n-        let offset = ptr.offset.bytes() as usize;\n-        Ok(&mut alloc.bytes[offset..offset + size.bytes() as usize])\n     }\n }\n \n@@ -766,10 +671,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         length: u64,\n         nonoverlapping: bool,\n     ) -> EvalResult<'tcx> {\n+        self.check_align(src, src_align)?;\n+        self.check_align(dest, dest_align)?;\n         if size.bytes() == 0 {\n-            // Nothing to do for ZST, other than checking alignment and non-NULLness.\n-            self.check_align(src, src_align)?;\n-            self.check_align(dest, dest_align)?;\n+            // Nothing to do for ZST, other than checking alignment and\n+            // non-NULLness which already happened.\n             return Ok(());\n         }\n         let src = src.to_ptr()?;\n@@ -781,7 +687,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         // (`get_bytes_with_undef_and_ptr` below checks that there are no\n         // relocations overlapping the edges; those would not be handled correctly).\n         let relocations = {\n-            let relocations = self.relocations(src, size)?;\n+            let relocations = self.get(src.alloc_id)?.relocations(self, src, size);\n             let mut new_relocations = Vec::with_capacity(relocations.len() * (length as usize));\n             for i in 0..length {\n                 new_relocations.extend(\n@@ -797,9 +703,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             new_relocations\n         };\n \n-        // This also checks alignment, and relocation edges on the src.\n-        let src_bytes = self.get_bytes_with_undef_and_ptr(src, size, src_align)?.as_ptr();\n-        let dest_bytes = self.get_bytes_mut(dest, size * length, dest_align)?.as_mut_ptr();\n+        let tcx = self.tcx.tcx;\n+\n+        // This checks relocation edges on the src.\n+        let src_bytes = self.get(src.alloc_id)?\n+            .get_bytes_with_undef_and_ptr(&tcx, src, size)?\n+            .as_ptr();\n+        let dest_bytes = self.get_mut(dest.alloc_id)?\n+            .get_bytes_mut(&tcx, dest, size * length)?\n+            .as_mut_ptr();\n \n         // SAFE: The above indexing would have panicked if there weren't at least `size` bytes\n         // behind `src` and `dest`. Also, we use the overlapping-safe `ptr::copy` if `src` and\n@@ -840,276 +752,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n         Ok(())\n     }\n-\n-    pub fn read_c_str(&self, ptr: Pointer<M::PointerTag>) -> EvalResult<'tcx, &[u8]> {\n-        let alloc = self.get(ptr.alloc_id)?;\n-        assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n-        let offset = ptr.offset.bytes() as usize;\n-        match alloc.bytes[offset..].iter().position(|&c| c == 0) {\n-            Some(size) => {\n-                let p1 = Size::from_bytes((size + 1) as u64);\n-                self.check_relocations(ptr, p1)?;\n-                self.check_defined(ptr, p1)?;\n-                Ok(&alloc.bytes[offset..offset + size])\n-            }\n-            None => err!(UnterminatedCString(ptr.erase_tag())),\n-        }\n-    }\n-\n-    pub fn check_bytes(\n-        &self,\n-        ptr: Scalar<M::PointerTag>,\n-        size: Size,\n-        allow_ptr_and_undef: bool,\n-    ) -> EvalResult<'tcx> {\n-        // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n-        let align = Align::from_bytes(1).unwrap();\n-        if size.bytes() == 0 {\n-            self.check_align(ptr, align)?;\n-            return Ok(());\n-        }\n-        let ptr = ptr.to_ptr()?;\n-        // Check bounds, align and relocations on the edges\n-        self.get_bytes_with_undef_and_ptr(ptr, size, align)?;\n-        // Check undef and ptr\n-        if !allow_ptr_and_undef {\n-            self.check_defined(ptr, size)?;\n-            self.check_relocations(ptr, size)?;\n-        }\n-        Ok(())\n-    }\n-\n-    pub fn read_bytes(&self, ptr: Scalar<M::PointerTag>, size: Size) -> EvalResult<'tcx, &[u8]> {\n-        // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n-        let align = Align::from_bytes(1).unwrap();\n-        if size.bytes() == 0 {\n-            self.check_align(ptr, align)?;\n-            return Ok(&[]);\n-        }\n-        self.get_bytes(ptr.to_ptr()?, size, align)\n-    }\n-\n-    pub fn write_bytes(&mut self, ptr: Scalar<M::PointerTag>, src: &[u8]) -> EvalResult<'tcx> {\n-        // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n-        let align = Align::from_bytes(1).unwrap();\n-        if src.is_empty() {\n-            self.check_align(ptr, align)?;\n-            return Ok(());\n-        }\n-        let bytes = self.get_bytes_mut(ptr.to_ptr()?, Size::from_bytes(src.len() as u64), align)?;\n-        bytes.clone_from_slice(src);\n-        Ok(())\n-    }\n-\n-    pub fn write_repeat(\n-        &mut self,\n-        ptr: Scalar<M::PointerTag>,\n-        val: u8,\n-        count: Size\n-    ) -> EvalResult<'tcx> {\n-        // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n-        let align = Align::from_bytes(1).unwrap();\n-        if count.bytes() == 0 {\n-            self.check_align(ptr, align)?;\n-            return Ok(());\n-        }\n-        let bytes = self.get_bytes_mut(ptr.to_ptr()?, count, align)?;\n-        for b in bytes {\n-            *b = val;\n-        }\n-        Ok(())\n-    }\n-\n-    /// Read a *non-ZST* scalar\n-    pub fn read_scalar(\n-        &self,\n-        ptr: Pointer<M::PointerTag>,\n-        ptr_align: Align,\n-        size: Size\n-    ) -> EvalResult<'tcx, ScalarMaybeUndef<M::PointerTag>> {\n-        // get_bytes_unchecked tests alignment and relocation edges\n-        let bytes = self.get_bytes_with_undef_and_ptr(\n-            ptr, size, ptr_align.min(self.int_align(size))\n-        )?;\n-        // Undef check happens *after* we established that the alignment is correct.\n-        // We must not return Ok() for unaligned pointers!\n-        if self.check_defined(ptr, size).is_err() {\n-            // this inflates undefined bytes to the entire scalar, even if only a few\n-            // bytes are undefined\n-            return Ok(ScalarMaybeUndef::Undef);\n-        }\n-        // Now we do the actual reading\n-        let bits = read_target_uint(self.tcx.data_layout.endian, bytes).unwrap();\n-        // See if we got a pointer\n-        if size != self.pointer_size() {\n-            // *Now* better make sure that the inside also is free of relocations.\n-            self.check_relocations(ptr, size)?;\n-        } else {\n-            let alloc = self.get(ptr.alloc_id)?;\n-            match alloc.relocations.get(&ptr.offset) {\n-                Some(&(tag, alloc_id)) => {\n-                    let ptr = Pointer::new_with_tag(alloc_id, Size::from_bytes(bits as u64), tag);\n-                    return Ok(ScalarMaybeUndef::Scalar(ptr.into()))\n-                }\n-                None => {},\n-            }\n-        }\n-        // We don't. Just return the bits.\n-        Ok(ScalarMaybeUndef::Scalar(Scalar::from_uint(bits, size)))\n-    }\n-\n-    pub fn read_ptr_sized(\n-        &self,\n-        ptr: Pointer<M::PointerTag>,\n-        ptr_align: Align\n-    ) -> EvalResult<'tcx, ScalarMaybeUndef<M::PointerTag>> {\n-        self.read_scalar(ptr, ptr_align, self.pointer_size())\n-    }\n-\n-    /// Write a *non-ZST* scalar\n-    pub fn write_scalar(\n-        &mut self,\n-        ptr: Pointer<M::PointerTag>,\n-        ptr_align: Align,\n-        val: ScalarMaybeUndef<M::PointerTag>,\n-        type_size: Size,\n-    ) -> EvalResult<'tcx> {\n-        let val = match val {\n-            ScalarMaybeUndef::Scalar(scalar) => scalar,\n-            ScalarMaybeUndef::Undef => return self.mark_definedness(ptr, type_size, false),\n-        };\n-\n-        let bytes = match val {\n-            Scalar::Ptr(val) => {\n-                assert_eq!(type_size, self.pointer_size());\n-                val.offset.bytes() as u128\n-            }\n-\n-            Scalar::Bits { bits, size } => {\n-                assert_eq!(size as u64, type_size.bytes());\n-                debug_assert_eq!(truncate(bits, Size::from_bytes(size.into())), bits,\n-                    \"Unexpected value of size {} when writing to memory\", size);\n-                bits\n-            },\n-        };\n-\n-        {\n-            // get_bytes_mut checks alignment\n-            let endian = self.tcx.data_layout.endian;\n-            let dst = self.get_bytes_mut(ptr, type_size, ptr_align)?;\n-            write_target_uint(endian, dst, bytes).unwrap();\n-        }\n-\n-        // See if we have to also write a relocation\n-        match val {\n-            Scalar::Ptr(val) => {\n-                self.get_mut(ptr.alloc_id)?.relocations.insert(\n-                    ptr.offset,\n-                    (val.tag, val.alloc_id),\n-                );\n-            }\n-            _ => {}\n-        }\n-\n-        Ok(())\n-    }\n-\n-    pub fn write_ptr_sized(\n-        &mut self,\n-        ptr: Pointer<M::PointerTag>,\n-        ptr_align: Align,\n-        val: ScalarMaybeUndef<M::PointerTag>\n-    ) -> EvalResult<'tcx> {\n-        let ptr_size = self.pointer_size();\n-        self.write_scalar(ptr.into(), ptr_align, val, ptr_size)\n-    }\n-\n-    fn int_align(&self, size: Size) -> Align {\n-        // We assume pointer-sized integers have the same alignment as pointers.\n-        // We also assume signed and unsigned integers of the same size have the same alignment.\n-        let ity = match size.bytes() {\n-            1 => layout::I8,\n-            2 => layout::I16,\n-            4 => layout::I32,\n-            8 => layout::I64,\n-            16 => layout::I128,\n-            _ => bug!(\"bad integer size: {}\", size.bytes()),\n-        };\n-        ity.align(self).abi\n-    }\n-}\n-\n-/// Relocations\n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n-    /// Return all relocations overlapping with the given ptr-offset pair.\n-    fn relocations(\n-        &self,\n-        ptr: Pointer<M::PointerTag>,\n-        size: Size,\n-    ) -> EvalResult<'tcx, &[(Size, (M::PointerTag, AllocId))]> {\n-        // We have to go back `pointer_size - 1` bytes, as that one would still overlap with\n-        // the beginning of this range.\n-        let start = ptr.offset.bytes().saturating_sub(self.pointer_size().bytes() - 1);\n-        let end = ptr.offset + size; // this does overflow checking\n-        Ok(self.get(ptr.alloc_id)?.relocations.range(Size::from_bytes(start)..end))\n-    }\n-\n-    /// Check that there ar eno relocations overlapping with the given range.\n-    #[inline(always)]\n-    fn check_relocations(&self, ptr: Pointer<M::PointerTag>, size: Size) -> EvalResult<'tcx> {\n-        if self.relocations(ptr, size)?.len() != 0 {\n-            err!(ReadPointerAsBytes)\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n-    /// Remove all relocations inside the given range.\n-    /// If there are relocations overlapping with the edges, they\n-    /// are removed as well *and* the bytes they cover are marked as\n-    /// uninitialized.  This is a somewhat odd \"spooky action at a distance\",\n-    /// but it allows strictly more code to run than if we would just error\n-    /// immediately in that case.\n-    fn clear_relocations(&mut self, ptr: Pointer<M::PointerTag>, size: Size) -> EvalResult<'tcx> {\n-        // Find the start and end of the given range and its outermost relocations.\n-        let (first, last) = {\n-            // Find all relocations overlapping the given range.\n-            let relocations = self.relocations(ptr, size)?;\n-            if relocations.is_empty() {\n-                return Ok(());\n-            }\n-\n-            (relocations.first().unwrap().0,\n-             relocations.last().unwrap().0 + self.pointer_size())\n-        };\n-        let start = ptr.offset;\n-        let end = start + size;\n-\n-        let alloc = self.get_mut(ptr.alloc_id)?;\n-\n-        // Mark parts of the outermost relocations as undefined if they partially fall outside the\n-        // given range.\n-        if first < start {\n-            alloc.undef_mask.set_range(first, start, false);\n-        }\n-        if last > end {\n-            alloc.undef_mask.set_range(end, last, false);\n-        }\n-\n-        // Forget all the relocations.\n-        alloc.relocations.remove_range(first..last);\n-\n-        Ok(())\n-    }\n-\n-    /// Error if there are relocations overlapping with the edges of the\n-    /// given memory range.\n-    #[inline]\n-    fn check_relocation_edges(&self, ptr: Pointer<M::PointerTag>, size: Size) -> EvalResult<'tcx> {\n-        self.check_relocations(ptr, Size::ZERO)?;\n-        self.check_relocations(ptr.offset(size, self)?, Size::ZERO)?;\n-        Ok(())\n-    }\n }\n \n /// Undefined bytes\n@@ -1141,33 +783,4 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n         Ok(())\n     }\n-\n-    /// Checks that a range of bytes is defined. If not, returns the `ReadUndefBytes`\n-    /// error which will report the first byte which is undefined.\n-    #[inline]\n-    fn check_defined(&self, ptr: Pointer<M::PointerTag>, size: Size) -> EvalResult<'tcx> {\n-        let alloc = self.get(ptr.alloc_id)?;\n-        alloc.undef_mask.is_range_defined(\n-            ptr.offset,\n-            ptr.offset + size,\n-        ).or_else(|idx| err!(ReadUndefBytes(idx)))\n-    }\n-\n-    pub fn mark_definedness(\n-        &mut self,\n-        ptr: Pointer<M::PointerTag>,\n-        size: Size,\n-        new_state: bool,\n-    ) -> EvalResult<'tcx> {\n-        if size.bytes() == 0 {\n-            return Ok(());\n-        }\n-        let alloc = self.get_mut(ptr.alloc_id)?;\n-        alloc.undef_mask.set_range(\n-            ptr.offset,\n-            ptr.offset + size,\n-            new_state,\n-        );\n-        Ok(())\n-    }\n }"}, {"sha": "539bc6d965fd6bbf1b6196f03a217eadd78ab597", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=2dd94c133ead2cd62636a876d6d72a2a00348943", "patch": "@@ -19,7 +19,7 @@ use rustc::ty::layout::{self, Size, LayoutOf, TyLayout, HasDataLayout, IntegerEx\n use rustc::mir::interpret::{\n     GlobalId, AllocId,\n     ConstValue, Pointer, Scalar,\n-    EvalResult, EvalErrorKind, InboundsCheck,\n+    EvalResult, EvalErrorKind,\n };\n use super::{EvalContext, Machine, MemPlace, MPlaceTy, MemoryKind};\n pub use rustc::mir::interpret::ScalarMaybeUndef;\n@@ -275,10 +275,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             return Ok(Some(Immediate::Scalar(Scalar::zst().into())));\n         }\n \n+        // check for integer pointers before alignment to report better errors\n         let ptr = ptr.to_ptr()?;\n+        self.memory.check_align(ptr.into(), ptr_align)?;\n         match mplace.layout.abi {\n             layout::Abi::Scalar(..) => {\n-                let scalar = self.memory.read_scalar(ptr, ptr_align, mplace.layout.size)?;\n+                let scalar = self.memory\n+                    .get(ptr.alloc_id)?\n+                    .read_scalar(self, ptr, mplace.layout.size)?;\n                 Ok(Some(Immediate::Scalar(scalar)))\n             }\n             layout::Abi::ScalarPair(ref a, ref b) => {\n@@ -287,9 +291,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 let a_ptr = ptr;\n                 let b_offset = a_size.align_to(b.align(self).abi);\n                 assert!(b_offset.bytes() > 0); // we later use the offset to test which field to use\n-                let b_ptr = ptr.offset(b_offset, self)?.into();\n-                let a_val = self.memory.read_scalar(a_ptr, ptr_align, a_size)?;\n-                let b_val = self.memory.read_scalar(b_ptr, ptr_align, b_size)?;\n+                let b_ptr = ptr.offset(b_offset, self)?;\n+                let a_val = self.memory\n+                    .get(ptr.alloc_id)?\n+                    .read_scalar(self, a_ptr, a_size)?;\n+                let b_align = ptr_align.restrict_for_offset(b_offset);\n+                self.memory.check_align(b_ptr.into(), b_align)?;\n+                let b_val = self.memory\n+                    .get(ptr.alloc_id)?\n+                    .read_scalar(self, b_ptr, b_size)?;\n                 Ok(Some(Immediate::ScalarPair(a_val, b_val)))\n             }\n             _ => Ok(None),\n@@ -637,7 +647,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                     ScalarMaybeUndef::Scalar(Scalar::Ptr(ptr)) => {\n                         // The niche must be just 0 (which an inbounds pointer value never is)\n                         let ptr_valid = niche_start == 0 && variants_start == variants_end &&\n-                            self.memory.check_bounds_ptr(ptr, InboundsCheck::MaybeDead).is_ok();\n+                            self.memory.check_bounds_ptr_maybe_dead(ptr).is_ok();\n                         if !ptr_valid {\n                             return err!(InvalidDiscriminant(raw_discr.erase_tag()));\n                         }"}, {"sha": "0fd1a993cbd9095017c1e53fea62ff5e05c783e4", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 48, "deletions": 30, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=2dd94c133ead2cd62636a876d6d72a2a00348943", "patch": "@@ -159,6 +159,19 @@ impl<Tag> MemPlace<Tag> {\n             Some(meta) => Immediate::ScalarPair(self.ptr.into(), meta.into()),\n         }\n     }\n+\n+    pub fn offset(\n+        self,\n+        offset: Size,\n+        meta: Option<Scalar<Tag>>,\n+        cx: &impl HasDataLayout,\n+    ) -> EvalResult<'tcx, Self> {\n+        Ok(MemPlace {\n+            ptr: self.ptr.ptr_offset(offset, cx)?,\n+            align: self.align.restrict_for_offset(offset),\n+            meta,\n+        })\n+    }\n }\n \n impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n@@ -174,6 +187,19 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n         }\n     }\n \n+    pub fn offset(\n+        self,\n+        offset: Size,\n+        meta: Option<Scalar<Tag>>,\n+        layout: TyLayout<'tcx>,\n+        cx: &impl HasDataLayout,\n+    ) -> EvalResult<'tcx, Self> {\n+        Ok(MPlaceTy {\n+            mplace: self.mplace.offset(offset, meta, cx)?,\n+            layout,\n+        })\n+    }\n+\n     #[inline]\n     fn from_aligned_ptr(ptr: Pointer<Tag>, layout: TyLayout<'tcx>) -> Self {\n         MPlaceTy { mplace: MemPlace::from_ptr(ptr, layout.align.abi), layout }\n@@ -367,13 +393,9 @@ where\n             (None, offset)\n         };\n \n-        let ptr = base.ptr.ptr_offset(offset, self)?;\n-        let align = base.align\n-            // We do not look at `base.layout.align` nor `field_layout.align`, unlike\n-            // codegen -- mostly to see if we can get away with that\n-            .restrict_for_offset(offset); // must be last thing that happens\n-\n-        Ok(MPlaceTy { mplace: MemPlace { ptr, align, meta }, layout: field_layout })\n+        // We do not look at `base.layout.align` nor `field_layout.align`, unlike\n+        // codegen -- mostly to see if we can get away with that\n+        base.offset(offset, meta, field_layout, self)\n     }\n \n     // Iterates over all fields of an array. Much more efficient than doing the\n@@ -391,13 +413,7 @@ where\n         };\n         let layout = base.layout.field(self, 0)?;\n         let dl = &self.tcx.data_layout;\n-        Ok((0..len).map(move |i| {\n-            let ptr = base.ptr.ptr_offset(i * stride, dl)?;\n-            Ok(MPlaceTy {\n-                mplace: MemPlace { ptr, align: base.align, meta: None },\n-                layout\n-            })\n-        }))\n+        Ok((0..len).map(move |i| base.offset(i * stride, None, layout, dl)))\n     }\n \n     pub fn mplace_subslice(\n@@ -416,7 +432,6 @@ where\n                 stride * from,\n             _ => bug!(\"Unexpected layout of index access: {:#?}\", base.layout),\n         };\n-        let ptr = base.ptr.ptr_offset(from_offset, self)?;\n \n         // Compute meta and new layout\n         let inner_len = len - to - from;\n@@ -433,11 +448,7 @@ where\n                 bug!(\"cannot subslice non-array type: `{:?}`\", base.layout.ty),\n         };\n         let layout = self.layout_of(ty)?;\n-\n-        Ok(MPlaceTy {\n-            mplace: MemPlace { ptr, align: base.align, meta },\n-            layout\n-        })\n+        base.offset(from_offset, meta, layout, self)\n     }\n \n     pub fn mplace_downcast(\n@@ -713,11 +724,13 @@ where\n \n         // Nothing to do for ZSTs, other than checking alignment\n         if dest.layout.is_zst() {\n-            self.memory.check_align(ptr, ptr_align)?;\n-            return Ok(());\n+            return self.memory.check_align(ptr, ptr_align);\n         }\n \n+        // check for integer pointers before alignment to report better errors\n         let ptr = ptr.to_ptr()?;\n+        self.memory.check_align(ptr.into(), ptr_align)?;\n+        let tcx = &*self.tcx;\n         // FIXME: We should check that there are dest.layout.size many bytes available in\n         // memory.  The code below is not sufficient, with enough padding it might not\n         // cover all the bytes!\n@@ -728,9 +741,8 @@ where\n                     _ => bug!(\"write_immediate_to_mplace: invalid Scalar layout: {:#?}\",\n                             dest.layout)\n                 }\n-\n-                self.memory.write_scalar(\n-                    ptr, ptr_align.min(dest.layout.align.abi), scalar, dest.layout.size\n+                self.memory.get_mut(ptr.alloc_id)?.write_scalar(\n+                    tcx, ptr, scalar, dest.layout.size\n                 )\n             }\n             Immediate::ScalarPair(a_val, b_val) => {\n@@ -740,16 +752,22 @@ where\n                               dest.layout)\n                 };\n                 let (a_size, b_size) = (a.size(self), b.size(self));\n-                let (a_align, b_align) = (a.align(self).abi, b.align(self).abi);\n-                let b_offset = a_size.align_to(b_align);\n-                let b_ptr = ptr.offset(b_offset, self)?.into();\n+                let b_offset = a_size.align_to(b.align(self).abi);\n+                let b_align = ptr_align.restrict_for_offset(b_offset);\n+                let b_ptr = ptr.offset(b_offset, self)?;\n+\n+                self.memory.check_align(b_ptr.into(), b_align)?;\n \n                 // It is tempting to verify `b_offset` against `layout.fields.offset(1)`,\n                 // but that does not work: We could be a newtype around a pair, then the\n                 // fields do not match the `ScalarPair` components.\n \n-                self.memory.write_scalar(ptr, ptr_align.min(a_align), a_val, a_size)?;\n-                self.memory.write_scalar(b_ptr, ptr_align.min(b_align), b_val, b_size)\n+                self.memory\n+                    .get_mut(ptr.alloc_id)?\n+                    .write_scalar(tcx, ptr, a_val, a_size)?;\n+                self.memory\n+                    .get_mut(b_ptr.alloc_id)?\n+                    .write_scalar(tcx, b_ptr, b_val, b_size)\n             }\n         }\n     }"}, {"sha": "617d204fe1042a8ea59a1c9ddfa38b1532150aa4", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=2dd94c133ead2cd62636a876d6d72a2a00348943", "patch": "@@ -401,12 +401,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             // cannot use the shim here, because that will only result in infinite recursion\n             ty::InstanceDef::Virtual(_, idx) => {\n                 let ptr_size = self.pointer_size();\n-                let ptr_align = self.tcx.data_layout.pointer_align.abi;\n                 let ptr = self.deref_operand(args[0])?;\n                 let vtable = ptr.vtable()?;\n-                let fn_ptr = self.memory.read_ptr_sized(\n+                self.memory.check_align(vtable.into(), self.tcx.data_layout.pointer_align.abi)?;\n+                let fn_ptr = self.memory.get(vtable.alloc_id)?.read_ptr_sized(\n+                    self,\n                     vtable.offset(ptr_size * (idx as u64 + 3), self)?,\n-                    ptr_align\n                 )?.to_ptr()?;\n                 let instance = self.memory.get_fn(fn_ptr)?;\n "}, {"sha": "bda585b8eda349f82ad817601495994f14af6b55", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=2dd94c133ead2cd62636a876d6d72a2a00348943", "patch": "@@ -55,23 +55,34 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             ptr_align,\n             MemoryKind::Vtable,\n         )?.with_default_tag();\n+        let tcx = &*self.tcx;\n \n-        let drop = ::monomorphize::resolve_drop_in_place(*self.tcx, ty);\n+        let drop = ::monomorphize::resolve_drop_in_place(*tcx, ty);\n         let drop = self.memory.create_fn_alloc(drop).with_default_tag();\n-        self.memory.write_ptr_sized(vtable, ptr_align, Scalar::Ptr(drop).into())?;\n+        // no need to do any alignment checks on the memory accesses below, because we know the\n+        // allocation is correctly aligned as we created it above. Also we're only offsetting by\n+        // multiples of `ptr_align`, which means that it will stay aligned to `ptr_align`.\n+        self.memory\n+            .get_mut(vtable.alloc_id)?\n+            .write_ptr_sized(tcx, vtable, Scalar::Ptr(drop).into())?;\n \n         let size_ptr = vtable.offset(ptr_size, self)?;\n-        self.memory.write_ptr_sized(size_ptr, ptr_align, Scalar::from_uint(size, ptr_size).into())?;\n+        self.memory\n+            .get_mut(size_ptr.alloc_id)?\n+            .write_ptr_sized(tcx, size_ptr, Scalar::from_uint(size, ptr_size).into())?;\n         let align_ptr = vtable.offset(ptr_size * 2, self)?;\n-        self.memory.write_ptr_sized(align_ptr, ptr_align,\n-            Scalar::from_uint(align, ptr_size).into())?;\n+        self.memory\n+            .get_mut(align_ptr.alloc_id)?\n+            .write_ptr_sized(tcx, align_ptr, Scalar::from_uint(align, ptr_size).into())?;\n \n         for (i, method) in methods.iter().enumerate() {\n             if let Some((def_id, substs)) = *method {\n                 let instance = self.resolve(def_id, substs)?;\n                 let fn_ptr = self.memory.create_fn_alloc(instance).with_default_tag();\n                 let method_ptr = vtable.offset(ptr_size * (3 + i as u64), self)?;\n-                self.memory.write_ptr_sized(method_ptr, ptr_align, Scalar::Ptr(fn_ptr).into())?;\n+                self.memory\n+                    .get_mut(method_ptr.alloc_id)?\n+                    .write_ptr_sized(tcx, method_ptr, Scalar::Ptr(fn_ptr).into())?;\n             }\n         }\n \n@@ -87,8 +98,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         vtable: Pointer<M::PointerTag>,\n     ) -> EvalResult<'tcx, (ty::Instance<'tcx>, ty::Ty<'tcx>)> {\n         // we don't care about the pointee type, we just want a pointer\n-        let pointer_align = self.tcx.data_layout.pointer_align.abi;\n-        let drop_fn = self.memory.read_ptr_sized(vtable, pointer_align)?.to_ptr()?;\n+        self.memory.check_align(vtable.into(), self.tcx.data_layout.pointer_align.abi)?;\n+        let drop_fn = self.memory\n+            .get(vtable.alloc_id)?\n+            .read_ptr_sized(self, vtable)?\n+            .to_ptr()?;\n         let drop_instance = self.memory.get_fn(drop_fn)?;\n         trace!(\"Found drop fn: {:?}\", drop_instance);\n         let fn_sig = drop_instance.ty(*self.tcx).fn_sig(*self.tcx);\n@@ -103,12 +117,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         vtable: Pointer<M::PointerTag>,\n     ) -> EvalResult<'tcx, (Size, Align)> {\n         let pointer_size = self.pointer_size();\n-        let pointer_align = self.tcx.data_layout.pointer_align.abi;\n-        let size = self.memory.read_ptr_sized(vtable.offset(pointer_size, self)?,pointer_align)?\n+        self.memory.check_align(vtable.into(), self.tcx.data_layout.pointer_align.abi)?;\n+        let alloc = self.memory.get(vtable.alloc_id)?;\n+        let size = alloc.read_ptr_sized(self, vtable.offset(pointer_size, self)?)?\n             .to_bits(pointer_size)? as u64;\n-        let align = self.memory.read_ptr_sized(\n+        let align = alloc.read_ptr_sized(\n+            self,\n             vtable.offset(pointer_size * 2, self)?,\n-            pointer_align\n         )?.to_bits(pointer_size)? as u64;\n         Ok((Size::from_bytes(size), Align::from_bytes(align).unwrap()))\n     }"}, {"sha": "ed4cb65ea74b17136279b46742ae1b5053ff7b26", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=2dd94c133ead2cd62636a876d6d72a2a00348943", "patch": "@@ -17,11 +17,11 @@ use rustc::ty::layout::{self, Size, Align, TyLayout, LayoutOf, VariantIdx};\n use rustc::ty;\n use rustc_data_structures::fx::FxHashSet;\n use rustc::mir::interpret::{\n-    Scalar, AllocType, EvalResult, EvalErrorKind, InboundsCheck,\n+    Scalar, AllocType, EvalResult, EvalErrorKind,\n };\n \n use super::{\n-    OpTy, MPlaceTy, Machine, EvalContext, ValueVisitor\n+    OpTy, Machine, EvalContext, ValueVisitor,\n };\n \n macro_rules! validation_failure {\n@@ -396,7 +396,9 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                         // Maintain the invariant that the place we are checking is\n                         // already verified to be in-bounds.\n                         try_validation!(\n-                            self.ecx.memory.check_bounds(ptr, size, InboundsCheck::Live),\n+                            self.ecx.memory\n+                                .get(ptr.alloc_id)?\n+                                .check_bounds(self.ecx, ptr, size),\n                             \"dangling (not entirely in bounds) reference\", self.path);\n                     }\n                     // Check if we have encountered this pointer+layout combination\n@@ -520,20 +522,25 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                     _ => false,\n                 }\n             } => {\n-                let mplace = if op.layout.is_zst() {\n-                    // it's a ZST, the memory content cannot matter\n-                    MPlaceTy::dangling(op.layout, self.ecx)\n-                } else {\n-                    // non-ZST array/slice/str cannot be immediate\n-                    op.to_mem_place()\n-                };\n+                // bailing out for zsts is ok, since the array element type can only be int/float\n+                if op.layout.is_zst() {\n+                    return Ok(());\n+                }\n+                // non-ZST array cannot be immediate, slices are never immediate\n+                let mplace = op.to_mem_place();\n                 // This is the length of the array/slice.\n                 let len = mplace.len(self.ecx)?;\n+                // zero length slices have nothing to be checked\n+                if len == 0 {\n+                    return Ok(());\n+                }\n                 // This is the element type size.\n                 let ty_size = self.ecx.layout_of(tys)?.size;\n                 // This is the size in bytes of the whole array.\n                 let size = ty_size * len;\n \n+                let ptr = mplace.ptr.to_ptr()?;\n+\n                 // NOTE: Keep this in sync with the handling of integer and float\n                 // types above, in `visit_primitive`.\n                 // In run-time mode, we accept pointers in here.  This is actually more\n@@ -543,8 +550,9 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                 // to reject those pointers, we just do not have the machinery to\n                 // talk about parts of a pointer.\n                 // We also accept undef, for consistency with the type-based checks.\n-                match self.ecx.memory.check_bytes(\n-                    mplace.ptr,\n+                match self.ecx.memory.get(ptr.alloc_id)?.check_bytes(\n+                    self.ecx,\n+                    ptr,\n                     size,\n                     /*allow_ptr_and_undef*/!self.const_mode,\n                 ) {"}, {"sha": "afa2c6a5b9e1c4fb143d3b1edfdb6c32ab9f1c6d", "filename": "src/test/ui/consts/int_ptr_for_zst_slices.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Ftest%2Fui%2Fconsts%2Fint_ptr_for_zst_slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Ftest%2Fui%2Fconsts%2Fint_ptr_for_zst_slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fint_ptr_for_zst_slices.rs?ref=2dd94c133ead2cd62636a876d6d72a2a00348943", "patch": "@@ -0,0 +1,7 @@\n+// compile-pass\n+\n+#![feature(const_raw_ptr_deref)]\n+\n+const FOO: &str = unsafe { &*(1_usize as *const [u8; 0] as *const [u8] as *const str) };\n+\n+fn main() {}"}, {"sha": "9610b7b22f161a843833a1f6bf708e5fe1e6a30a", "filename": "src/test/ui/consts/validate_never_arrays.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.rs?ref=2dd94c133ead2cd62636a876d6d72a2a00348943", "patch": "@@ -0,0 +1,5 @@\n+#![feature(const_raw_ptr_deref, never_type)]\n+\n+const FOO: &[!; 1] = unsafe { &*(1_usize as *const [!; 1]) }; //~ ERROR undefined behavior\n+\n+fn main() {}"}, {"sha": "0b639240bb3483dd4e87c25c7387d29076d13c02", "filename": "src/test/ui/consts/validate_never_arrays.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2dd94c133ead2cd62636a876d6d72a2a00348943/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.stderr?ref=2dd94c133ead2cd62636a876d6d72a2a00348943", "patch": "@@ -0,0 +1,11 @@\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/validate_never_arrays.rs:3:1\n+   |\n+LL | const FOO: &[!; 1] = unsafe { &*(1_usize as *const [!; 1]) }; //~ ERROR undefined behavior\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of an uninhabited type at .<deref>[0]\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "32e93ed7762e5aa1a721636096848fc3c7bc7218", "filename": "src/tools/miri", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri?ref=2dd94c133ead2cd62636a876d6d72a2a00348943", "patch": "@@ -1 +1 @@\n-Subproject commit bbb1d80703f272a5592ceeb3832a489776512251\n+Subproject commit 32e93ed7762e5aa1a721636096848fc3c7bc7218"}]}