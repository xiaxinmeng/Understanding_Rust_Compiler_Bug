{"sha": "f676f2265b6473c4e84f38c0384ed1f6e3211255", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2NzZmMjI2NWI2NDczYzRlODRmMzhjMDM4NGVkMWY2ZTMyMTEyNTU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-05-15T15:23:26Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-05-15T16:12:58Z"}, "message": "make writes act stack-like", "tree": {"sha": "23f93214b66b777f1102ab45cefa94acec41eaa7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23f93214b66b777f1102ab45cefa94acec41eaa7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f676f2265b6473c4e84f38c0384ed1f6e3211255", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f676f2265b6473c4e84f38c0384ed1f6e3211255", "html_url": "https://github.com/rust-lang/rust/commit/f676f2265b6473c4e84f38c0384ed1f6e3211255", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f676f2265b6473c4e84f38c0384ed1f6e3211255/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77737cdb2909a44b040015ed5f3dea4e24b766cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/77737cdb2909a44b040015ed5f3dea4e24b766cf", "html_url": "https://github.com/rust-lang/rust/commit/77737cdb2909a44b040015ed5f3dea4e24b766cf"}], "stats": {"total": 59, "additions": 42, "deletions": 17}, "files": [{"sha": "2f082bcc4c058a91b33f1f46747a9faa70a1dc22", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 32, "deletions": 17, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f676f2265b6473c4e84f38c0384ed1f6e3211255/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f676f2265b6473c4e84f38c0384ed1f6e3211255/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=f676f2265b6473c4e84f38c0384ed1f6e3211255", "patch": "@@ -256,20 +256,33 @@ impl Permission {\n \n /// Core per-location operations: access, dealloc, reborrow.\n impl<'tcx> Stack {\n-    /// Find the item granting the given kind of access to the given tag, and where that item is in the stack.\n-    fn find_granting(&self, access: AccessKind, tag: Tag) -> Option<(usize, Permission)> {\n-        self.borrows.iter()\n+    /// Find the item granting the given kind of access to the given tag, and where\n+    /// *the first incompatible item above it* is on the stack.\n+    fn find_granting(&self, access: AccessKind, tag: Tag) -> Option<(Permission, usize)> {\n+        let (perm, idx) = self.borrows.iter()\n             .enumerate() // we also need to know *where* in the stack\n             .rev() // search top-to-bottom\n             // Return permission of first item that grants access.\n             // We require a permission with the right tag, ensuring U3 and F3.\n             .find_map(|(idx, item)|\n                 if item.perm.grants(access) && tag == item.tag {\n-                    Some((idx, item.perm))\n+                    Some((item.perm, idx))\n                 } else {\n                     None\n                 }\n-            )\n+            )?;\n+\n+        let mut first_incompatible_idx = idx+1;\n+        while let Some(item) = self.borrows.get(first_incompatible_idx) {\n+            if perm.compatible_with(access, item.perm) {\n+                // Keep this, check next.\n+                first_incompatible_idx += 1;\n+            } else {\n+                // Found it!\n+                break;\n+            }\n+        }\n+        return Some((perm, first_incompatible_idx));\n     }\n \n     /// Test if a memory `access` using pointer tagged `tag` is granted.\n@@ -279,31 +292,30 @@ impl<'tcx> Stack {\n         access: AccessKind,\n         tag: Tag,\n         global: &GlobalState,\n-    ) -> EvalResult<'tcx, usize> {\n+    ) -> EvalResult<'tcx> {\n         // Two main steps: Find granting item, remove all incompatible items above.\n \n         // Step 1: Find granting item.\n-        let (granting_idx, granting_perm) = self.find_granting(access, tag)\n+        let (granting_perm, first_incompatible_idx) = self.find_granting(access, tag)\n             .ok_or_else(|| InterpError::MachineError(format!(\n                 \"no item granting {} access to tag {} found in borrow stack\",\n                 access, tag,\n             )))?;\n \n         // Step 2: Remove everything incompatible above them.  Make sure we do not remove protected\n         // items.\n-        // We do *not* maintain a stack discipline here.  We could, in principle, decide to only\n-        // keep the items immediately above `granting_idx` that are compatible, and then pop the rest.\n-        // However, that kills off entire \"branches\" of pointer derivation too easily:\n+        // For writes, this is a simple stack. For reads, however, it is not:\n         // in `let raw = &mut *x as *mut _; let _val = *x;`, the second statement would pop the `Unique`\n         // from the reborrow of the first statement, and subsequently also pop the `SharedReadWrite` for `raw`.\n         // This pattern occurs a lot in the standard library: create a raw pointer, then also create a shared\n         // reference and use that.\n         {\n             // Implemented with indices because there does not seem to be a nice iterator and range-based\n             // API for this.\n-            let mut cur = granting_idx + 1;\n+            let mut cur = first_incompatible_idx;\n             while let Some(item) = self.borrows.get(cur) {\n-                if granting_perm.compatible_with(access, item.perm) {\n+                // If this is a read, we double-check if we really want to kill this.\n+                if access == AccessKind::Read && granting_perm.compatible_with(access, item.perm) {\n                     // Keep this, check next.\n                     cur += 1;\n                 } else {\n@@ -323,7 +335,7 @@ impl<'tcx> Stack {\n         }\n \n         // Done.\n-        return Ok(granting_idx);\n+        Ok(())\n     }\n \n     /// Deallocate a location: Like a write access, but also there must be no\n@@ -391,7 +403,7 @@ impl<'tcx> Stack {\n         };\n         // Now we figure out which item grants our parent (`derived_from`) this kind of access.\n         // We use that to determine where to put the new item.\n-        let (derived_from_idx, _) = self.find_granting(access, derived_from)\n+        let (_, first_incompatible_idx) = self.find_granting(access, derived_from)\n             .ok_or_else(|| InterpError::MachineError(format!(\n                 \"no item to reborrow for {:?} from tag {} found in borrow stack\", new.perm, derived_from,\n             )))?;\n@@ -412,14 +424,17 @@ impl<'tcx> Stack {\n             // and we'd allow write access without invalidating frozen shared references!\n             // This ensures F2b for `SharedReadWrite` by adding the new item below any\n             // potentially existing `SharedReadOnly`.\n-            derived_from_idx + 1\n+            first_incompatible_idx\n         } else {\n             // A \"safe\" reborrow for a pointer that actually expects some aliasing guarantees.\n             // Here, creating a reference actually counts as an access, and pops incompatible\n             // stuff off the stack.\n             // This ensures F2b for `Unique`, by removing offending `SharedReadOnly`.\n-            let check_idx = self.access(access, derived_from, global)?;\n-            assert_eq!(check_idx, derived_from_idx, \"somehow we saw different items??\");\n+            self.access(access, derived_from, global)?;\n+            if access == AccessKind::Write {\n+                // For write accesses, the position is the same as what it would have been weakly!\n+                assert_eq!(first_incompatible_idx, self.borrows.len());\n+            }\n \n             // We insert \"as far up as possible\": We know only compatible items are remaining\n             // on top of `derived_from`, and we want the new item at the top so that we"}, {"sha": "dd9fce110c2d304b250891b846dc692459f4eb40", "filename": "tests/compile-fail/stacked_borrows/interior_mut1.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f676f2265b6473c4e84f38c0384ed1f6e3211255/tests%2Fcompile-fail%2Fstacked_borrows%2Finterior_mut1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f676f2265b6473c4e84f38c0384ed1f6e3211255/tests%2Fcompile-fail%2Fstacked_borrows%2Finterior_mut1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Finterior_mut1.rs?ref=f676f2265b6473c4e84f38c0384ed1f6e3211255", "patch": "@@ -0,0 +1,10 @@\n+use std::cell::UnsafeCell;\n+\n+fn main() { unsafe {\n+    let c = &UnsafeCell::new(UnsafeCell::new(0));\n+    let inner_uniq = &mut *c.get();\n+    let inner_shr = &*inner_uniq; // a SharedRW with a tag\n+    *c.get() = UnsafeCell::new(1); // invalidates the SharedRW\n+    let _val = *inner_shr.get(); //~ ERROR borrow stack\n+    let _val = *inner_uniq.get();\n+} }"}]}