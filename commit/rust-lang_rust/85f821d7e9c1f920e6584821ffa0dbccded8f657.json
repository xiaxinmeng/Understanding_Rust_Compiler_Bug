{"sha": "85f821d7e9c1f920e6584821ffa0dbccded8f657", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1ZjgyMWQ3ZTljMWY5MjBlNjU4NDgyMWZmYTBkYmNjZGVkOGY2NTc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-29T18:48:43Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-01T07:58:03Z"}, "message": "unify checks on memory access and reborrowing, and update for Machine trait change", "tree": {"sha": "41ce07bf96f62ecae3f7fdc6c06b8e1bb002b9aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41ce07bf96f62ecae3f7fdc6c06b8e1bb002b9aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85f821d7e9c1f920e6584821ffa0dbccded8f657", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85f821d7e9c1f920e6584821ffa0dbccded8f657", "html_url": "https://github.com/rust-lang/rust/commit/85f821d7e9c1f920e6584821ffa0dbccded8f657", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85f821d7e9c1f920e6584821ffa0dbccded8f657/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bba3c49e844895cdc32dc6ea1acbf0c6555beefd", "url": "https://api.github.com/repos/rust-lang/rust/commits/bba3c49e844895cdc32dc6ea1acbf0c6555beefd", "html_url": "https://github.com/rust-lang/rust/commit/bba3c49e844895cdc32dc6ea1acbf0c6555beefd"}], "stats": {"total": 192, "additions": 137, "deletions": 55}, "files": [{"sha": "b397e9a6d224bd234de0a8de15c706344686d330", "filename": "src/lib.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/85f821d7e9c1f920e6584821ffa0dbccded8f657/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f821d7e9c1f920e6584821ffa0dbccded8f657/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=85f821d7e9c1f920e6584821ffa0dbccded8f657", "patch": "@@ -452,21 +452,30 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n     }\n \n     #[inline(always)]\n-    fn memory_accessed(\n+    fn memory_read(\n         alloc: &Allocation<Borrow, Self::AllocExtra>,\n         ptr: Pointer<Borrow>,\n         size: Size,\n-        access: MemoryAccess,\n     ) -> EvalResult<'tcx> {\n-        alloc.extra.memory_accessed(ptr, size, access)\n+        alloc.extra.memory_read(ptr, size)\n+    }\n+\n+    #[inline(always)]\n+    fn memory_written(\n+        alloc: &mut Allocation<Borrow, Self::AllocExtra>,\n+        ptr: Pointer<Borrow>,\n+        size: Size,\n+    ) -> EvalResult<'tcx> {\n+        alloc.extra.memory_written(ptr, size)\n     }\n \n     #[inline(always)]\n     fn memory_deallocated(\n         alloc: &mut Allocation<Borrow, Self::AllocExtra>,\n         ptr: Pointer<Borrow>,\n+        size: Size,\n     ) -> EvalResult<'tcx> {\n-        alloc.extra.memory_deallocated(ptr)\n+        alloc.extra.memory_deallocated(ptr, size)\n     }\n \n     #[inline(always)]"}, {"sha": "baeb04b44ea755f8b3bd3fa0fc9ea4a403ba4059", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 73, "deletions": 48, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/85f821d7e9c1f920e6584821ffa0dbccded8f657/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f821d7e9c1f920e6584821ffa0dbccded8f657/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=85f821d7e9c1f920e6584821ffa0dbccded8f657", "patch": "@@ -4,7 +4,7 @@ use rustc::ty::{self, Ty, layout::Size};\n use rustc::hir;\n \n use super::{\n-    MemoryAccess, MemoryKind, MiriMemoryKind, RangeMap, EvalResult, AllocId,\n+    MemoryKind, MiriMemoryKind, RangeMap, EvalResult, AllocId,\n     Pointer, PlaceTy,\n };\n \n@@ -126,6 +126,13 @@ impl Default for Stack {\n     }\n }\n \n+impl Stack {\n+    #[inline(always)]\n+    fn is_frozen(&self) -> bool {\n+        self.frozen_since.is_some()\n+    }\n+}\n+\n /// Extra per-allocation state\n #[derive(Clone, Debug, Default)]\n pub struct Stacks {\n@@ -206,16 +213,23 @@ impl<'tcx> Stack {\n         match action {\n             None => {}, // nothing to do\n             Some(top) => {\n+                if self.frozen_since.is_some() {\n+                    trace!(\"reactivate: Unfreezing\");\n+                }\n                 self.frozen_since = None;\n-                self.borrows.truncate(top+1);\n+                for itm in self.borrows.drain(top+1..).rev() {\n+                    trace!(\"reactivate: Popping {:?}\", itm);\n+                }\n             }\n         }\n \n         Ok(())\n     }\n \n     /// Initiate `bor`; mostly this means freezing or pushing.\n-    fn initiate(&mut self, bor: Borrow) -> EvalResult<'tcx> {\n+    /// This operation cannot fail; it is up to the caller to ensure that the precondition\n+    /// is met: We cannot push onto frozen stacks.\n+    fn initiate(&mut self, bor: Borrow) {\n         match bor {\n             Borrow::Frz(t) => {\n                 match self.frozen_since {\n@@ -241,11 +255,10 @@ impl<'tcx> Stack {\n                         // from it is fine with this as well.\n                         trace!(\"initiate: Initiating a raw on a frozen location, not doing a thing\"),\n                     Some(_) =>\n-                        return err!(MachineError(format!(\"Trying to mutate frozen location\")))\n+                        bug!(\"Trying to mutate frozen location\")\n                 }\n             }\n         }\n-        Ok(())\n     }\n }\n \n@@ -259,49 +272,27 @@ impl State {\n \n /// Higher-level operations\n impl<'tcx> Stacks {\n-    pub fn memory_accessed(\n-        &self,\n-        ptr: Pointer<Borrow>,\n-        size: Size,\n-        access: MemoryAccess,\n-    ) -> EvalResult<'tcx> {\n-        trace!(\"memory_accessed({:?}) with tag {:?}: {:?}, size {}\", access, ptr.tag, ptr, size.bytes());\n-        let mut stacks = self.stacks.borrow_mut();\n-        for stack in stacks.iter_mut(ptr.offset, size) {\n-            // FIXME: Compare this with what the blog post says.\n-            stack.reactivate(ptr.tag, /*force_mut*/access == MemoryAccess::Write)?;\n-        }\n-        Ok(())\n-    }\n-\n-    pub fn memory_deallocated(\n-        &mut self,\n-        ptr: Pointer<Borrow>,\n-    ) -> EvalResult<'tcx> {\n-        trace!(\"memory_deallocated with tag {:?}: {:?}\", ptr.tag, ptr);\n-        let stacks = self.stacks.get_mut();\n-        for stack in stacks.iter_mut_all() {\n-            // This is like mutating.\n-            stack.reactivate(ptr.tag, /*force_mut*/true)?;\n-        }\n-        Ok(())\n-    }\n-\n-    fn reborrow(\n+    /// The single most operation: Make sure that using `ptr` as `ref_kind` is okay,\n+    /// and if `new_bor` is present then make that the new current borrow.\n+    fn use_and_maybe_re_borrow(\n         &self,\n         ptr: Pointer<Borrow>,\n         size: Size,\n-        new_bor: Borrow,\n-        permit_redundant: bool,\n+        ref_kind: RefKind,\n+        new_bor: Option<Borrow>,\n     ) -> EvalResult<'tcx> {\n+        trace!(\"use_and_maybe_re_borrow of tag {:?} as {:?}, new {:?}: {:?}, size {}\",\n+            ptr.tag, ref_kind, new_bor, ptr, size.bytes());\n         let mut stacks = self.stacks.borrow_mut();\n         for stack in stacks.iter_mut(ptr.offset, size) {\n-            if permit_redundant && stack.check(new_bor) {\n-                // The new borrow is already active!  This can happen when creating multiple\n-                // shared references from the same mutable reference.  Do nothing.\n-                trace!(\"reborrow: New borrow {:?} is already active, not doing a thing\", new_bor);\n+            if ref_kind == RefKind::Shr && stack.is_frozen() {\n+                // Location already frozen.  We don't want to unfreeze, but make sure\n+                // the ref makes some sense.\n+                if let Err(err) = stack.reactivatable(ptr.tag, /*force_mut*/false) {\n+                    return err!(MachineError(err));\n+                }\n             } else {\n-                // If we are creating a uniq ref, we certainly want to unfreeze.\n+                // If we are creating a mutable ref, we certainly want to unfreeze.\n                 // Even if we are doing so from a raw.\n                 // Notice that if this is a local, whenever we access it directly the\n                 // tag here will be the bottommost `Uniq` for that local.  That `Uniq`\n@@ -312,14 +303,47 @@ impl<'tcx> Stacks {\n                 // `reset` which the blog post [1] says to perform when accessing a local.\n                 //\n                 // [1] https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html\n-                stack.reactivate(ptr.tag, /*force_mut*/new_bor.is_uniq())?;\n-                stack.initiate(new_bor)?;\n+                let force_mut = ref_kind == RefKind::Mut;\n+                stack.reactivate(ptr.tag, force_mut)?;\n+            }\n+            if let Some(new_bor) = new_bor {\n+                stack.initiate(new_bor);\n             }\n         }\n \n         Ok(())\n     }\n \n+    #[inline(always)]\n+    pub fn memory_read(\n+        &self,\n+        ptr: Pointer<Borrow>,\n+        size: Size,\n+    ) -> EvalResult<'tcx> {\n+        // Reads behave exactly like the first half of a reborrow-to-shr\n+        self.use_and_maybe_re_borrow(ptr, size, RefKind::Shr, None)\n+    }\n+\n+    #[inline(always)]\n+    pub fn memory_written(\n+        &mut self,\n+        ptr: Pointer<Borrow>,\n+        size: Size,\n+    ) -> EvalResult<'tcx> {\n+        // Writes behave exactly like the first half of a reborrow-to-mut\n+        self.use_and_maybe_re_borrow(ptr, size, RefKind::Mut, None)\n+    }\n+\n+    pub fn memory_deallocated(\n+        &mut self,\n+        ptr: Pointer<Borrow>,\n+        size: Size,\n+    ) -> EvalResult<'tcx> {\n+        // This is like mutating\n+        self.use_and_maybe_re_borrow(ptr, size, RefKind::Mut, None)\n+        // FIXME: Error out of there are any barriers?\n+    }\n+\n     /// Pushes the first borrow to the stacks, must be a mutable one.\n     pub fn first_borrow(\n         &mut self,\n@@ -398,8 +422,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n         // Update the stacks.  We cannot use `get_mut` becuse this might be immutable\n         // memory.\n         let alloc = self.memory().get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n-        let permit_redundant = ref_kind == RefKind::Shr; // redundant shared refs are okay\n-        alloc.extra.reborrow(ptr, size, new_bor, permit_redundant)?;\n+        alloc.extra.use_and_maybe_re_borrow(ptr, size, ref_kind, Some(new_bor))?;\n \n         Ok(new_bor)\n     }\n@@ -411,10 +434,12 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n     fn tag_dereference(\n         &self,\n         ptr: Pointer<Borrow>,\n-        _pointee_ty: Ty<'tcx>,\n+        pointee_ty: Ty<'tcx>,\n         size: Size,\n         ref_kind: RefKind,\n     ) -> EvalResult<'tcx, Borrow> {\n+        trace!(\"tag_reference: Accessing reference ({:?}) for {:?} (pointee {}, size {})\",\n+            ref_kind, ptr, pointee_ty, size.bytes());\n         // In principle we should not have to do anything here.  However, with transmutes involved,\n         // it can happen that the tag of `ptr` does not actually match `ref_kind`, and we\n         // should adjust for that.\n@@ -506,12 +531,12 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             _ => return Ok(()), // don't do a thing\n         };\n         // We want to reborrow the reference stored there. This will call the hooks\n-        // above.  First deref.\n+        // above.  First deref, which will call `tag_dereference`.\n         // (This is somewhat redundant because validation already did the same thing,\n         // but what can you do.)\n         let val = self.read_value(self.place_to_op(place)?)?;\n         let dest = self.ref_to_mplace(val)?;\n-        // Now put a new ref into the old place.\n+        // Now put a new ref into the old place, which will call `tag_reference`.\n         // FIXME: Honor `fn_entry`!\n         let val = self.create_ref(dest, Some(mutbl))?;\n         self.write_value(val, place)?;"}, {"sha": "f0e696c457cb31c6fb3903bab312bd975fbe2823", "filename": "tests/compile-fail/stacked_borrows/illegal_read1.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/85f821d7e9c1f920e6584821ffa0dbccded8f657/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f821d7e9c1f920e6584821ffa0dbccded8f657/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read1.rs?ref=85f821d7e9c1f920e6584821ffa0dbccded8f657", "patch": "@@ -0,0 +1,15 @@\n+// A callee may not read the destination of our `&mut` without\n+// us noticing.\n+\n+fn main() {\n+    let mut x = 15;\n+    let xraw = &mut x as *mut _;\n+    let xref = unsafe { &mut *xraw }; // derived from raw, so using raw is still okay...\n+    callee(xraw);\n+    let _val = *xref; // ...but any use of raw will invalidate our ref.\n+    //~^ ERROR: Mut reference with non-reactivatable tag\n+}\n+\n+fn callee(xraw: *mut i32) {\n+    let _val = unsafe { *xraw };\n+}"}, {"sha": "ec59c57d31b7225543b3d423392b73c5b9895384", "filename": "tests/compile-fail/stacked_borrows/illegal_read2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/85f821d7e9c1f920e6584821ffa0dbccded8f657/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f821d7e9c1f920e6584821ffa0dbccded8f657/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read2.rs?ref=85f821d7e9c1f920e6584821ffa0dbccded8f657", "patch": "@@ -0,0 +1,18 @@\n+// A callee may not read the destination of our `&mut` without\n+// us noticing.\n+\n+fn main() {\n+    let mut x = 15;\n+    let xraw = &mut x as *mut _;\n+    let xref = unsafe { &mut *xraw }; // derived from raw, so using raw is still okay...\n+    callee(xraw);\n+    let _val = *xref; // ...but any use of raw will invalidate our ref.\n+    //~^ ERROR: Mut reference with non-reactivatable tag\n+}\n+\n+fn callee(xraw: *mut i32) {\n+    // We are a bit sneaky: We first create a shared ref, exploiting the reborrowing rules,\n+    // and then we read through that.\n+    let shr = unsafe { &*xraw };\n+    let _val = *shr;\n+}"}, {"sha": "4b5d08c03a4791e21d50b16457a667ecb71b351f", "filename": "tests/compile-fail/stacked_borrows/illegal_write5.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/85f821d7e9c1f920e6584821ffa0dbccded8f657/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f821d7e9c1f920e6584821ffa0dbccded8f657/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write5.rs?ref=85f821d7e9c1f920e6584821ffa0dbccded8f657", "patch": "@@ -0,0 +1,15 @@\n+// A callee may not write to the destination of our `&mut` without\n+// us noticing.\n+\n+fn main() {\n+    let mut x = 15;\n+    let xraw = &mut x as *mut _;\n+    let xref = unsafe { &mut *xraw }; // derived from raw, so using raw is still okay...\n+    callee(xraw);\n+    let _val = *xref; // ...but any use of raw will invalidate our ref.\n+    //~^ ERROR: Mut reference with non-reactivatable tag\n+}\n+\n+fn callee(xraw: *mut i32) {\n+    unsafe { *xraw = 15 };\n+}"}, {"sha": "b4b180e350f1f556116e0110ef3447b427eb6b6f", "filename": "tests/compile-fail/stacked_borrows/load_invalid_shr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85f821d7e9c1f920e6584821ffa0dbccded8f657/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_shr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f821d7e9c1f920e6584821ffa0dbccded8f657/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_shr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_shr.rs?ref=85f821d7e9c1f920e6584821ffa0dbccded8f657", "patch": "@@ -4,6 +4,6 @@ fn main() {\n     let xraw = x as *mut _;\n     let xref = unsafe { &*xraw };\n     let xref_in_mem = Box::new(xref);\n-    let _val = *x; // invalidate xraw\n+    *x = 42; // invalidate xraw\n     let _val = *xref_in_mem; //~ ERROR Shr reference with non-reactivatable tag: Location should be frozen\n }"}, {"sha": "477c86f6060d634d77b99e3c820061ed2a92f9f6", "filename": "tests/compile-fail/stacked_borrows/pass_invalid_shr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85f821d7e9c1f920e6584821ffa0dbccded8f657/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_shr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f821d7e9c1f920e6584821ffa0dbccded8f657/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_shr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_shr.rs?ref=85f821d7e9c1f920e6584821ffa0dbccded8f657", "patch": "@@ -5,6 +5,6 @@ fn main() {\n     let x = &mut 42;\n     let xraw = &*x as *const _;\n     let xref = unsafe { &*xraw };\n-    let _val = *x; // invalidate xraw\n+    *x = 42; // invalidate xraw\n     foo(xref); //~ ERROR Shr reference with non-reactivatable tag: Location should be frozen\n }"}, {"sha": "954b5ec8e592007911a68a21feae21cd87f60bdf", "filename": "tests/compile-fail/stacked_borrows/return_invalid_shr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85f821d7e9c1f920e6584821ffa0dbccded8f657/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85f821d7e9c1f920e6584821ffa0dbccded8f657/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr.rs?ref=85f821d7e9c1f920e6584821ffa0dbccded8f657", "patch": "@@ -2,7 +2,7 @@\n fn foo(x: &mut (i32, i32)) -> &i32 {\n     let xraw = x as *mut (i32, i32);\n     let ret = unsafe { &(*xraw).1 };\n-    let _val = *x; // invalidate xraw and its children\n+    x.1 = 42; // invalidate xraw on the 2nd field\n     ret //~ ERROR Shr reference with non-reactivatable tag: Location should be frozen\n }\n "}]}