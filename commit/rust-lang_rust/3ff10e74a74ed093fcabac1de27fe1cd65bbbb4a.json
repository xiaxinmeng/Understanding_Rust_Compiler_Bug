{"sha": "3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmZjEwZTc0YTc0ZWQwOTNmY2FiYWMxZGUyN2ZlMWNkNjViYmJiNGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-04T20:07:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-04T20:07:04Z"}, "message": "Auto merge of #79286 - TimDiekmann:rename-allocref, r=Lokathor,Wodann,m-ou-se\n\nRename `AllocRef` to `Allocator` and `(de)alloc` to `(de)allocate`\n\nCalling `Box::alloc_ref` and `Vec::alloc_ref` sounds like allocating a reference. To solve this ambiguity, this renames `AllocRef` to `Allocator` and `alloc` to `allocate`. For a more detailed explaination see https://github.com/rust-lang/wg-allocators/issues/76.\n\ncloses https://github.com/rust-lang/wg-allocators/issues/76\n\nr? `@KodrAus`\n`@rustbot` modify labels: +A-allocators +T-libs\n`@rustbot` ping wg-allocators", "tree": {"sha": "13efed968ba1fcd1ca8a4ceeb2fdd3c5297863ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/13efed968ba1fcd1ca8a4ceeb2fdd3c5297863ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a", "html_url": "https://github.com/rust-lang/rust/commit/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2218520b8adf8b8e64b817537d9eb0a84840e2f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/2218520b8adf8b8e64b817537d9eb0a84840e2f1", "html_url": "https://github.com/rust-lang/rust/commit/2218520b8adf8b8e64b817537d9eb0a84840e2f1"}, {"sha": "9274b37d99f608e5fde569788ee79bd72fc3cf13", "url": "https://api.github.com/repos/rust-lang/rust/commits/9274b37d99f608e5fde569788ee79bd72fc3cf13", "html_url": "https://github.com/rust-lang/rust/commit/9274b37d99f608e5fde569788ee79bd72fc3cf13"}], "stats": {"total": 672, "additions": 337, "deletions": 335}, "files": [{"sha": "4fbcc4590f1a99a0fac42b6b8f97bb5801f5046e", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a", "patch": "@@ -38,7 +38,7 @@ extern \"Rust\" {\n \n /// The global memory allocator.\n ///\n-/// This type implements the [`AllocRef`] trait by forwarding calls\n+/// This type implements the [`Allocator`] trait by forwarding calls\n /// to the allocator registered with the `#[global_allocator]` attribute\n /// if there is one, or the `std` crate\u2019s default.\n ///\n@@ -59,7 +59,7 @@ pub use std::alloc::Global;\n /// if there is one, or the `std` crate\u2019s default.\n ///\n /// This function is expected to be deprecated in favor of the `alloc` method\n-/// of the [`Global`] type when it and the [`AllocRef`] trait become stable.\n+/// of the [`Global`] type when it and the [`Allocator`] trait become stable.\n ///\n /// # Safety\n ///\n@@ -93,7 +93,7 @@ pub unsafe fn alloc(layout: Layout) -> *mut u8 {\n /// if there is one, or the `std` crate\u2019s default.\n ///\n /// This function is expected to be deprecated in favor of the `dealloc` method\n-/// of the [`Global`] type when it and the [`AllocRef`] trait become stable.\n+/// of the [`Global`] type when it and the [`Allocator`] trait become stable.\n ///\n /// # Safety\n ///\n@@ -111,7 +111,7 @@ pub unsafe fn dealloc(ptr: *mut u8, layout: Layout) {\n /// if there is one, or the `std` crate\u2019s default.\n ///\n /// This function is expected to be deprecated in favor of the `realloc` method\n-/// of the [`Global`] type when it and the [`AllocRef`] trait become stable.\n+/// of the [`Global`] type when it and the [`Allocator`] trait become stable.\n ///\n /// # Safety\n ///\n@@ -129,7 +129,7 @@ pub unsafe fn realloc(ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8\n /// if there is one, or the `std` crate\u2019s default.\n ///\n /// This function is expected to be deprecated in favor of the `alloc_zeroed` method\n-/// of the [`Global`] type when it and the [`AllocRef`] trait become stable.\n+/// of the [`Global`] type when it and the [`Allocator`] trait become stable.\n ///\n /// # Safety\n ///\n@@ -170,7 +170,7 @@ impl Global {\n         }\n     }\n \n-    // SAFETY: Same as `AllocRef::grow`\n+    // SAFETY: Same as `Allocator::grow`\n     #[inline]\n     unsafe fn grow_impl(\n         &self,\n@@ -211,7 +211,7 @@ impl Global {\n             old_size => unsafe {\n                 let new_ptr = self.alloc_impl(new_layout, zeroed)?;\n                 ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), old_size);\n-                self.dealloc(ptr, old_layout);\n+                self.deallocate(ptr, old_layout);\n                 Ok(new_ptr)\n             },\n         }\n@@ -220,19 +220,19 @@ impl Global {\n \n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n #[cfg(not(test))]\n-unsafe impl AllocRef for Global {\n+unsafe impl Allocator for Global {\n     #[inline]\n-    fn alloc(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n+    fn allocate(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n         self.alloc_impl(layout, false)\n     }\n \n     #[inline]\n-    fn alloc_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n+    fn allocate_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n         self.alloc_impl(layout, true)\n     }\n \n     #[inline]\n-    unsafe fn dealloc(&self, ptr: NonNull<u8>, layout: Layout) {\n+    unsafe fn deallocate(&self, ptr: NonNull<u8>, layout: Layout) {\n         if layout.size() != 0 {\n             // SAFETY: `layout` is non-zero in size,\n             // other conditions must be upheld by the caller\n@@ -277,7 +277,7 @@ unsafe impl AllocRef for Global {\n         match new_layout.size() {\n             // SAFETY: conditions must be upheld by the caller\n             0 => unsafe {\n-                self.dealloc(ptr, old_layout);\n+                self.deallocate(ptr, old_layout);\n                 Ok(NonNull::slice_from_raw_parts(new_layout.dangling(), 0))\n             },\n \n@@ -297,9 +297,9 @@ unsafe impl AllocRef for Global {\n             // `new_ptr`. Thus, the call to `copy_nonoverlapping` is safe. The safety contract\n             // for `dealloc` must be upheld by the caller.\n             new_size => unsafe {\n-                let new_ptr = self.alloc(new_layout)?;\n+                let new_ptr = self.allocate(new_layout)?;\n                 ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), new_size);\n-                self.dealloc(ptr, old_layout);\n+                self.deallocate(ptr, old_layout);\n                 Ok(new_ptr)\n             },\n         }\n@@ -313,7 +313,7 @@ unsafe impl AllocRef for Global {\n #[inline]\n unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n     let layout = unsafe { Layout::from_size_align_unchecked(size, align) };\n-    match Global.alloc(layout) {\n+    match Global.allocate(layout) {\n         Ok(ptr) => ptr.as_mut_ptr(),\n         Err(_) => handle_alloc_error(layout),\n     }\n@@ -322,16 +322,16 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n #[cfg_attr(not(test), lang = \"box_free\")]\n #[inline]\n // This signature has to be the same as `Box`, otherwise an ICE will happen.\n-// When an additional parameter to `Box` is added (like `A: AllocRef`), this has to be added here as\n+// When an additional parameter to `Box` is added (like `A: Allocator`), this has to be added here as\n // well.\n-// For example if `Box` is changed to  `struct Box<T: ?Sized, A: AllocRef>(Unique<T>, A)`,\n-// this function has to be changed to `fn box_free<T: ?Sized, A: AllocRef>(Unique<T>, A)` as well.\n-pub(crate) unsafe fn box_free<T: ?Sized, A: AllocRef>(ptr: Unique<T>, alloc: A) {\n+// For example if `Box` is changed to  `struct Box<T: ?Sized, A: Allocator>(Unique<T>, A)`,\n+// this function has to be changed to `fn box_free<T: ?Sized, A: Allocator>(Unique<T>, A)` as well.\n+pub(crate) unsafe fn box_free<T: ?Sized, A: Allocator>(ptr: Unique<T>, alloc: A) {\n     unsafe {\n         let size = size_of_val(ptr.as_ref());\n         let align = min_align_of_val(ptr.as_ref());\n         let layout = Layout::from_size_align_unchecked(size, align);\n-        alloc.dealloc(ptr.cast().into(), layout)\n+        alloc.deallocate(ptr.cast().into(), layout)\n     }\n }\n "}, {"sha": "94e05fa448f86e6e03207dd6442fcdae06bbc357", "filename": "library/alloc/src/alloc/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/library%2Falloc%2Fsrc%2Falloc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/library%2Falloc%2Fsrc%2Falloc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc%2Ftests.rs?ref=3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a", "patch": "@@ -9,15 +9,15 @@ fn allocate_zeroed() {\n     unsafe {\n         let layout = Layout::from_size_align(1024, 1).unwrap();\n         let ptr =\n-            Global.alloc_zeroed(layout.clone()).unwrap_or_else(|_| handle_alloc_error(layout));\n+            Global.allocate_zeroed(layout.clone()).unwrap_or_else(|_| handle_alloc_error(layout));\n \n         let mut i = ptr.as_non_null_ptr().as_ptr();\n         let end = i.add(layout.size());\n         while i < end {\n             assert_eq!(*i, 0);\n             i = i.offset(1);\n         }\n-        Global.dealloc(ptr.as_non_null_ptr(), layout);\n+        Global.deallocate(ptr.as_non_null_ptr(), layout);\n     }\n }\n "}, {"sha": "a6360f25eca3166afa0eded97e8bf6e12728a8bf", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 67, "deletions": 66, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a", "patch": "@@ -153,7 +153,7 @@ use core::pin::Pin;\n use core::ptr::{self, Unique};\n use core::task::{Context, Poll};\n \n-use crate::alloc::{handle_alloc_error, AllocRef, Global, Layout};\n+use crate::alloc::{handle_alloc_error, Allocator, Global, Layout};\n use crate::borrow::Cow;\n use crate::raw_vec::RawVec;\n use crate::str::from_boxed_utf8_unchecked;\n@@ -167,7 +167,7 @@ use crate::vec::Vec;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Box<\n     T: ?Sized,\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: AllocRef = Global,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n >(Unique<T>, A);\n \n impl<T> Box<T> {\n@@ -243,7 +243,7 @@ impl<T> Box<T> {\n     }\n }\n \n-impl<T, A: AllocRef> Box<T, A> {\n+impl<T, A: Allocator> Box<T, A> {\n     /// Allocates memory in the given allocator then places `x` into it.\n     ///\n     /// This doesn't actually allocate if `T` is zero-sized.\n@@ -291,7 +291,7 @@ impl<T, A: AllocRef> Box<T, A> {\n     // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit_in(alloc: A) -> Box<mem::MaybeUninit<T>, A> {\n         let layout = Layout::new::<mem::MaybeUninit<T>>();\n-        let ptr = alloc.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout)).cast();\n+        let ptr = alloc.allocate(layout).unwrap_or_else(|_| handle_alloc_error(layout)).cast();\n         unsafe { Box::from_raw_in(ptr.as_ptr(), alloc) }\n     }\n \n@@ -319,7 +319,8 @@ impl<T, A: AllocRef> Box<T, A> {\n     // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_zeroed_in(alloc: A) -> Box<mem::MaybeUninit<T>, A> {\n         let layout = Layout::new::<mem::MaybeUninit<T>>();\n-        let ptr = alloc.alloc_zeroed(layout).unwrap_or_else(|_| handle_alloc_error(layout)).cast();\n+        let ptr =\n+            alloc.allocate_zeroed(layout).unwrap_or_else(|_| handle_alloc_error(layout)).cast();\n         unsafe { Box::from_raw_in(ptr.as_ptr(), alloc) }\n     }\n \n@@ -339,7 +340,7 @@ impl<T, A: AllocRef> Box<T, A> {\n     /// This conversion does not allocate on the heap and happens in place.\n     #[unstable(feature = \"box_into_boxed_slice\", issue = \"71582\")]\n     pub fn into_boxed_slice(boxed: Self) -> Box<[T], A> {\n-        let (raw, alloc) = Box::into_raw_with_alloc(boxed);\n+        let (raw, alloc) = Box::into_raw_with_allocator(boxed);\n         unsafe { Box::from_raw_in(raw as *mut [T; 1], alloc) }\n     }\n }\n@@ -394,7 +395,7 @@ impl<T> Box<[T]> {\n     }\n }\n \n-impl<T, A: AllocRef> Box<[T], A> {\n+impl<T, A: Allocator> Box<[T], A> {\n     /// Constructs a new boxed slice with uninitialized contents in the provided allocator.\n     ///\n     /// # Examples\n@@ -450,7 +451,7 @@ impl<T, A: AllocRef> Box<[T], A> {\n     }\n }\n \n-impl<T, A: AllocRef> Box<mem::MaybeUninit<T>, A> {\n+impl<T, A: Allocator> Box<mem::MaybeUninit<T>, A> {\n     /// Converts to `Box<T, A>`.\n     ///\n     /// # Safety\n@@ -482,12 +483,12 @@ impl<T, A: AllocRef> Box<mem::MaybeUninit<T>, A> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     #[inline]\n     pub unsafe fn assume_init(self) -> Box<T, A> {\n-        let (raw, alloc) = Box::into_raw_with_alloc(self);\n+        let (raw, alloc) = Box::into_raw_with_allocator(self);\n         unsafe { Box::from_raw_in(raw as *mut T, alloc) }\n     }\n }\n \n-impl<T, A: AllocRef> Box<[mem::MaybeUninit<T>], A> {\n+impl<T, A: Allocator> Box<[mem::MaybeUninit<T>], A> {\n     /// Converts to `Box<[T], A>`.\n     ///\n     /// # Safety\n@@ -521,7 +522,7 @@ impl<T, A: AllocRef> Box<[mem::MaybeUninit<T>], A> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     #[inline]\n     pub unsafe fn assume_init(self) -> Box<[T], A> {\n-        let (raw, alloc) = Box::into_raw_with_alloc(self);\n+        let (raw, alloc) = Box::into_raw_with_allocator(self);\n         unsafe { Box::from_raw_in(raw as *mut [T], alloc) }\n     }\n }\n@@ -575,7 +576,7 @@ impl<T: ?Sized> Box<T> {\n     }\n }\n \n-impl<T: ?Sized, A: AllocRef> Box<T, A> {\n+impl<T: ?Sized, A: Allocator> Box<T, A> {\n     /// Constructs a box from a raw pointer in the given allocator.\n     ///\n     /// After calling this function, the raw pointer is owned by the\n@@ -594,24 +595,24 @@ impl<T: ?Sized, A: AllocRef> Box<T, A> {\n     /// # Examples\n     ///\n     /// Recreate a `Box` which was previously converted to a raw pointer\n-    /// using [`Box::into_raw_with_alloc`]:\n+    /// using [`Box::into_raw_with_allocator`]:\n     /// ```\n     /// #![feature(allocator_api)]\n     ///\n     /// use std::alloc::System;\n     ///\n     /// let x = Box::new_in(5, System);\n-    /// let (ptr, alloc) = Box::into_raw_with_alloc(x);\n+    /// let (ptr, alloc) = Box::into_raw_with_allocator(x);\n     /// let x = unsafe { Box::from_raw_in(ptr, alloc) };\n     /// ```\n     /// Manually create a `Box` from scratch by using the system allocator:\n     /// ```\n     /// #![feature(allocator_api, slice_ptr_get)]\n     ///\n-    /// use std::alloc::{AllocRef, Layout, System};\n+    /// use std::alloc::{Allocator, Layout, System};\n     ///\n     /// unsafe {\n-    ///     let ptr = System.alloc(Layout::new::<i32>())?.as_mut_ptr();\n+    ///     let ptr = System.allocate(Layout::new::<i32>())?.as_mut_ptr();\n     ///     // In general .write is required to avoid attempting to destruct\n     ///     // the (uninitialized) previous contents of `ptr`, though for this\n     ///     // simple example `*ptr = 5` would have worked as well.\n@@ -671,7 +672,7 @@ impl<T: ?Sized, A: AllocRef> Box<T, A> {\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n     pub fn into_raw(b: Self) -> *mut T {\n-        Self::into_raw_with_alloc(b).0\n+        Self::into_raw_with_allocator(b).0\n     }\n \n     /// Consumes the `Box`, returning a wrapped raw pointer and the allocator.\n@@ -687,7 +688,7 @@ impl<T: ?Sized, A: AllocRef> Box<T, A> {\n     /// the cleanup.\n     ///\n     /// Note: this is an associated function, which means that you have\n-    /// to call it as `Box::into_raw_with_alloc(b)` instead of `b.into_raw_with_alloc()`. This\n+    /// to call it as `Box::into_raw_with_allocator(b)` instead of `b.into_raw_with_allocator()`. This\n     /// is so that there is no conflict with a method on the inner type.\n     ///\n     /// # Examples\n@@ -699,30 +700,30 @@ impl<T: ?Sized, A: AllocRef> Box<T, A> {\n     /// use std::alloc::System;\n     ///\n     /// let x = Box::new_in(String::from(\"Hello\"), System);\n-    /// let (ptr, alloc) = Box::into_raw_with_alloc(x);\n+    /// let (ptr, alloc) = Box::into_raw_with_allocator(x);\n     /// let x = unsafe { Box::from_raw_in(ptr, alloc) };\n     /// ```\n     /// Manual cleanup by explicitly running the destructor and deallocating\n     /// the memory:\n     /// ```\n     /// #![feature(allocator_api)]\n     ///\n-    /// use std::alloc::{AllocRef, Layout, System};\n+    /// use std::alloc::{Allocator, Layout, System};\n     /// use std::ptr::{self, NonNull};\n     ///\n     /// let x = Box::new_in(String::from(\"Hello\"), System);\n-    /// let (ptr, alloc) = Box::into_raw_with_alloc(x);\n+    /// let (ptr, alloc) = Box::into_raw_with_allocator(x);\n     /// unsafe {\n     ///     ptr::drop_in_place(ptr);\n     ///     let non_null = NonNull::new_unchecked(ptr);\n-    ///     alloc.dealloc(non_null.cast(), Layout::new::<String>());\n+    ///     alloc.deallocate(non_null.cast(), Layout::new::<String>());\n     /// }\n     /// ```\n     ///\n     /// [memory layout]: self#memory-layout\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     #[inline]\n-    pub fn into_raw_with_alloc(b: Self) -> (*mut T, A) {\n+    pub fn into_raw_with_allocator(b: Self) -> (*mut T, A) {\n         let (leaked, alloc) = Box::into_unique(b);\n         (leaked.as_ptr(), alloc)\n     }\n@@ -747,11 +748,11 @@ impl<T: ?Sized, A: AllocRef> Box<T, A> {\n     /// Returns a reference to the underlying allocator.\n     ///\n     /// Note: this is an associated function, which means that you have\n-    /// to call it as `Box::alloc_ref(&b)` instead of `b.alloc_ref()`. This\n+    /// to call it as `Box::allocator(&b)` instead of `b.allocator()`. This\n     /// is so that there is no conflict with a method on the inner type.\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     #[inline]\n-    pub fn alloc_ref(b: &Self) -> &A {\n+    pub fn allocator(b: &Self) -> &A {\n         &b.1\n     }\n \n@@ -817,7 +818,7 @@ impl<T: ?Sized, A: AllocRef> Box<T, A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<#[may_dangle] T: ?Sized, A: AllocRef> Drop for Box<T, A> {\n+unsafe impl<#[may_dangle] T: ?Sized, A: Allocator> Drop for Box<T, A> {\n     fn drop(&mut self) {\n         // FIXME: Do nothing, drop is currently performed by compiler.\n     }\n@@ -846,7 +847,7 @@ impl Default for Box<str> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Clone, A: AllocRef + Clone> Clone for Box<T, A> {\n+impl<T: Clone, A: Allocator + Clone> Clone for Box<T, A> {\n     /// Returns a new box with a `clone()` of this box's contents.\n     ///\n     /// # Examples\n@@ -900,7 +901,7 @@ impl Clone for Box<str> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized + PartialEq, A: AllocRef> PartialEq for Box<T, A> {\n+impl<T: ?Sized + PartialEq, A: Allocator> PartialEq for Box<T, A> {\n     #[inline]\n     fn eq(&self, other: &Self) -> bool {\n         PartialEq::eq(&**self, &**other)\n@@ -911,7 +912,7 @@ impl<T: ?Sized + PartialEq, A: AllocRef> PartialEq for Box<T, A> {\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized + PartialOrd, A: AllocRef> PartialOrd for Box<T, A> {\n+impl<T: ?Sized + PartialOrd, A: Allocator> PartialOrd for Box<T, A> {\n     #[inline]\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n         PartialOrd::partial_cmp(&**self, &**other)\n@@ -934,24 +935,24 @@ impl<T: ?Sized + PartialOrd, A: AllocRef> PartialOrd for Box<T, A> {\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized + Ord, A: AllocRef> Ord for Box<T, A> {\n+impl<T: ?Sized + Ord, A: Allocator> Ord for Box<T, A> {\n     #[inline]\n     fn cmp(&self, other: &Self) -> Ordering {\n         Ord::cmp(&**self, &**other)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized + Eq, A: AllocRef> Eq for Box<T, A> {}\n+impl<T: ?Sized + Eq, A: Allocator> Eq for Box<T, A> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized + Hash, A: AllocRef> Hash for Box<T, A> {\n+impl<T: ?Sized + Hash, A: Allocator> Hash for Box<T, A> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         (**self).hash(state);\n     }\n }\n \n #[stable(feature = \"indirect_hasher_impl\", since = \"1.22.0\")]\n-impl<T: ?Sized + Hasher, A: AllocRef> Hasher for Box<T, A> {\n+impl<T: ?Sized + Hasher, A: Allocator> Hasher for Box<T, A> {\n     fn finish(&self) -> u64 {\n         (**self).finish()\n     }\n@@ -1016,7 +1017,7 @@ impl<T> From<T> for Box<T> {\n }\n \n #[stable(feature = \"pin\", since = \"1.33.0\")]\n-impl<T: ?Sized, A: AllocRef> From<Box<T, A>> for Pin<Box<T, A>>\n+impl<T: ?Sized, A: Allocator> From<Box<T, A>> for Pin<Box<T, A>>\n where\n     A: 'static,\n {\n@@ -1094,7 +1095,7 @@ impl From<Cow<'_, str>> for Box<str> {\n }\n \n #[stable(feature = \"boxed_str_conv\", since = \"1.19.0\")]\n-impl<A: AllocRef> From<Box<str, A>> for Box<[u8], A> {\n+impl<A: Allocator> From<Box<str, A>> for Box<[u8], A> {\n     /// Converts a `Box<str>` into a `Box<[u8]>`\n     ///\n     /// This conversion does not allocate on the heap and happens in place.\n@@ -1113,7 +1114,7 @@ impl<A: AllocRef> From<Box<str, A>> for Box<[u8], A> {\n     /// ```\n     #[inline]\n     fn from(s: Box<str, A>) -> Self {\n-        let (raw, alloc) = Box::into_raw_with_alloc(s);\n+        let (raw, alloc) = Box::into_raw_with_allocator(s);\n         unsafe { Box::from_raw_in(raw as *mut [u8], alloc) }\n     }\n }\n@@ -1147,7 +1148,7 @@ impl<T, const N: usize> TryFrom<Box<[T]>> for Box<[T; N]> {\n     }\n }\n \n-impl<A: AllocRef> Box<dyn Any, A> {\n+impl<A: Allocator> Box<dyn Any, A> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Attempt to downcast the box to a concrete type.\n@@ -1170,7 +1171,7 @@ impl<A: AllocRef> Box<dyn Any, A> {\n     pub fn downcast<T: Any>(self) -> Result<Box<T, A>, Self> {\n         if self.is::<T>() {\n             unsafe {\n-                let (raw, alloc): (*mut dyn Any, _) = Box::into_raw_with_alloc(self);\n+                let (raw, alloc): (*mut dyn Any, _) = Box::into_raw_with_allocator(self);\n                 Ok(Box::from_raw_in(raw as *mut T, alloc))\n             }\n         } else {\n@@ -1179,7 +1180,7 @@ impl<A: AllocRef> Box<dyn Any, A> {\n     }\n }\n \n-impl<A: AllocRef> Box<dyn Any + Send, A> {\n+impl<A: Allocator> Box<dyn Any + Send, A> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Attempt to downcast the box to a concrete type.\n@@ -1202,7 +1203,7 @@ impl<A: AllocRef> Box<dyn Any + Send, A> {\n     pub fn downcast<T: Any>(self) -> Result<Box<T, A>, Self> {\n         if self.is::<T>() {\n             unsafe {\n-                let (raw, alloc): (*mut (dyn Any + Send), _) = Box::into_raw_with_alloc(self);\n+                let (raw, alloc): (*mut (dyn Any + Send), _) = Box::into_raw_with_allocator(self);\n                 Ok(Box::from_raw_in(raw as *mut T, alloc))\n             }\n         } else {\n@@ -1212,21 +1213,21 @@ impl<A: AllocRef> Box<dyn Any + Send, A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::Display + ?Sized, A: AllocRef> fmt::Display for Box<T, A> {\n+impl<T: fmt::Display + ?Sized, A: Allocator> fmt::Display for Box<T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Display::fmt(&**self, f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::Debug + ?Sized, A: AllocRef> fmt::Debug for Box<T, A> {\n+impl<T: fmt::Debug + ?Sized, A: Allocator> fmt::Debug for Box<T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Debug::fmt(&**self, f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized, A: AllocRef> fmt::Pointer for Box<T, A> {\n+impl<T: ?Sized, A: Allocator> fmt::Pointer for Box<T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // It's not possible to extract the inner Uniq directly from the Box,\n         // instead we cast it to a *const which aliases the Unique\n@@ -1236,7 +1237,7 @@ impl<T: ?Sized, A: AllocRef> fmt::Pointer for Box<T, A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized, A: AllocRef> Deref for Box<T, A> {\n+impl<T: ?Sized, A: Allocator> Deref for Box<T, A> {\n     type Target = T;\n \n     fn deref(&self) -> &T {\n@@ -1245,17 +1246,17 @@ impl<T: ?Sized, A: AllocRef> Deref for Box<T, A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized, A: AllocRef> DerefMut for Box<T, A> {\n+impl<T: ?Sized, A: Allocator> DerefMut for Box<T, A> {\n     fn deref_mut(&mut self) -> &mut T {\n         &mut **self\n     }\n }\n \n #[unstable(feature = \"receiver_trait\", issue = \"none\")]\n-impl<T: ?Sized, A: AllocRef> Receiver for Box<T, A> {}\n+impl<T: ?Sized, A: Allocator> Receiver for Box<T, A> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator + ?Sized, A: AllocRef> Iterator for Box<I, A> {\n+impl<I: Iterator + ?Sized, A: Allocator> Iterator for Box<I, A> {\n     type Item = I::Item;\n     fn next(&mut self) -> Option<I::Item> {\n         (**self).next()\n@@ -1276,7 +1277,7 @@ trait BoxIter {\n     fn last(self) -> Option<Self::Item>;\n }\n \n-impl<I: Iterator + ?Sized, A: AllocRef> BoxIter for Box<I, A> {\n+impl<I: Iterator + ?Sized, A: Allocator> BoxIter for Box<I, A> {\n     type Item = I::Item;\n     default fn last(self) -> Option<I::Item> {\n         #[inline]\n@@ -1291,14 +1292,14 @@ impl<I: Iterator + ?Sized, A: AllocRef> BoxIter for Box<I, A> {\n /// Specialization for sized `I`s that uses `I`s implementation of `last()`\n /// instead of the default.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator, A: AllocRef> BoxIter for Box<I, A> {\n+impl<I: Iterator, A: Allocator> BoxIter for Box<I, A> {\n     fn last(self) -> Option<I::Item> {\n         (*self).last()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: DoubleEndedIterator + ?Sized, A: AllocRef> DoubleEndedIterator for Box<I, A> {\n+impl<I: DoubleEndedIterator + ?Sized, A: Allocator> DoubleEndedIterator for Box<I, A> {\n     fn next_back(&mut self) -> Option<I::Item> {\n         (**self).next_back()\n     }\n@@ -1307,7 +1308,7 @@ impl<I: DoubleEndedIterator + ?Sized, A: AllocRef> DoubleEndedIterator for Box<I\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: ExactSizeIterator + ?Sized, A: AllocRef> ExactSizeIterator for Box<I, A> {\n+impl<I: ExactSizeIterator + ?Sized, A: Allocator> ExactSizeIterator for Box<I, A> {\n     fn len(&self) -> usize {\n         (**self).len()\n     }\n@@ -1317,10 +1318,10 @@ impl<I: ExactSizeIterator + ?Sized, A: AllocRef> ExactSizeIterator for Box<I, A>\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I: FusedIterator + ?Sized, A: AllocRef> FusedIterator for Box<I, A> {}\n+impl<I: FusedIterator + ?Sized, A: Allocator> FusedIterator for Box<I, A> {}\n \n #[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n-impl<Args, F: FnOnce<Args> + ?Sized, A: AllocRef> FnOnce<Args> for Box<F, A> {\n+impl<Args, F: FnOnce<Args> + ?Sized, A: Allocator> FnOnce<Args> for Box<F, A> {\n     type Output = <F as FnOnce<Args>>::Output;\n \n     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output {\n@@ -1329,21 +1330,21 @@ impl<Args, F: FnOnce<Args> + ?Sized, A: AllocRef> FnOnce<Args> for Box<F, A> {\n }\n \n #[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n-impl<Args, F: FnMut<Args> + ?Sized, A: AllocRef> FnMut<Args> for Box<F, A> {\n+impl<Args, F: FnMut<Args> + ?Sized, A: Allocator> FnMut<Args> for Box<F, A> {\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output {\n         <F as FnMut<Args>>::call_mut(self, args)\n     }\n }\n \n #[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n-impl<Args, F: Fn<Args> + ?Sized, A: AllocRef> Fn<Args> for Box<F, A> {\n+impl<Args, F: Fn<Args> + ?Sized, A: Allocator> Fn<Args> for Box<F, A> {\n     extern \"rust-call\" fn call(&self, args: Args) -> Self::Output {\n         <F as Fn<Args>>::call(self, args)\n     }\n }\n \n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<T: ?Sized + Unsize<U>, U: ?Sized, A: AllocRef> CoerceUnsized<Box<U, A>> for Box<T, A> {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized, A: Allocator> CoerceUnsized<Box<U, A>> for Box<T, A> {}\n \n #[unstable(feature = \"dispatch_from_dyn\", issue = \"none\")]\n impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Box<U>> for Box<T, Global> {}\n@@ -1356,9 +1357,9 @@ impl<I> FromIterator<I> for Box<[I]> {\n }\n \n #[stable(feature = \"box_slice_clone\", since = \"1.3.0\")]\n-impl<T: Clone, A: AllocRef + Clone> Clone for Box<[T], A> {\n+impl<T: Clone, A: Allocator + Clone> Clone for Box<[T], A> {\n     fn clone(&self) -> Self {\n-        let alloc = Box::alloc_ref(self).clone();\n+        let alloc = Box::allocator(self).clone();\n         self.to_vec_in(alloc).into_boxed_slice()\n     }\n \n@@ -1372,28 +1373,28 @@ impl<T: Clone, A: AllocRef + Clone> Clone for Box<[T], A> {\n }\n \n #[stable(feature = \"box_borrow\", since = \"1.1.0\")]\n-impl<T: ?Sized, A: AllocRef> borrow::Borrow<T> for Box<T, A> {\n+impl<T: ?Sized, A: Allocator> borrow::Borrow<T> for Box<T, A> {\n     fn borrow(&self) -> &T {\n         &**self\n     }\n }\n \n #[stable(feature = \"box_borrow\", since = \"1.1.0\")]\n-impl<T: ?Sized, A: AllocRef> borrow::BorrowMut<T> for Box<T, A> {\n+impl<T: ?Sized, A: Allocator> borrow::BorrowMut<T> for Box<T, A> {\n     fn borrow_mut(&mut self) -> &mut T {\n         &mut **self\n     }\n }\n \n #[stable(since = \"1.5.0\", feature = \"smart_ptr_as_ref\")]\n-impl<T: ?Sized, A: AllocRef> AsRef<T> for Box<T, A> {\n+impl<T: ?Sized, A: Allocator> AsRef<T> for Box<T, A> {\n     fn as_ref(&self) -> &T {\n         &**self\n     }\n }\n \n #[stable(since = \"1.5.0\", feature = \"smart_ptr_as_ref\")]\n-impl<T: ?Sized, A: AllocRef> AsMut<T> for Box<T, A> {\n+impl<T: ?Sized, A: Allocator> AsMut<T> for Box<T, A> {\n     fn as_mut(&mut self) -> &mut T {\n         &mut **self\n     }\n@@ -1422,10 +1423,10 @@ impl<T: ?Sized, A: AllocRef> AsMut<T> for Box<T, A> {\n  *  could have a method to project a Pin<T> from it.\n  */\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n-impl<T: ?Sized, A: AllocRef> Unpin for Box<T, A> where A: 'static {}\n+impl<T: ?Sized, A: Allocator> Unpin for Box<T, A> where A: 'static {}\n \n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n-impl<G: ?Sized + Generator<R> + Unpin, R, A: AllocRef> Generator<R> for Box<G, A>\n+impl<G: ?Sized + Generator<R> + Unpin, R, A: Allocator> Generator<R> for Box<G, A>\n where\n     A: 'static,\n {\n@@ -1438,7 +1439,7 @@ where\n }\n \n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n-impl<G: ?Sized + Generator<R>, R, A: AllocRef> Generator<R> for Pin<Box<G, A>>\n+impl<G: ?Sized + Generator<R>, R, A: Allocator> Generator<R> for Pin<Box<G, A>>\n where\n     A: 'static,\n {\n@@ -1451,7 +1452,7 @@ where\n }\n \n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n-impl<F: ?Sized + Future + Unpin, A: AllocRef> Future for Box<F, A>\n+impl<F: ?Sized + Future + Unpin, A: Allocator> Future for Box<F, A>\n where\n     A: 'static,\n {"}, {"sha": "31809fde57b7a1a6e601487dc8369f74429c7c8f", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a", "patch": "@@ -36,7 +36,7 @@ use core::marker::PhantomData;\n use core::mem::{self, MaybeUninit};\n use core::ptr::{self, NonNull};\n \n-use crate::alloc::{AllocRef, Global, Layout};\n+use crate::alloc::{Allocator, Global, Layout};\n use crate::boxed::Box;\n \n const B: usize = 6;\n@@ -195,7 +195,7 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n         self.borrow_mut().clear_parent_link();\n \n         unsafe {\n-            Global.dealloc(top.cast(), Layout::new::<InternalNode<K, V>>());\n+            Global.deallocate(top.cast(), Layout::new::<InternalNode<K, V>>());\n         }\n     }\n }\n@@ -449,7 +449,7 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n         let node = self.node;\n         let ret = self.ascend().ok();\n         unsafe {\n-            Global.dealloc(\n+            Global.deallocate(\n                 node.cast(),\n                 if height > 0 {\n                     Layout::new::<InternalNode<K, V>>()\n@@ -1407,9 +1407,9 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n \n                 left_node.correct_childrens_parent_links(left_len + 1..=left_len + 1 + right_len);\n \n-                Global.dealloc(right_node.node.cast(), Layout::new::<InternalNode<K, V>>());\n+                Global.deallocate(right_node.node.cast(), Layout::new::<InternalNode<K, V>>());\n             } else {\n-                Global.dealloc(right_node.node.cast(), Layout::new::<LeafNode<K, V>>());\n+                Global.deallocate(right_node.node.cast(), Layout::new::<LeafNode<K, V>>());\n             }\n \n             let new_idx = match track_edge_idx {"}, {"sha": "edee439ad8dfaf7227b2ca4e4cf0c164b7a0c729", "filename": "library/alloc/src/raw_vec.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/library%2Falloc%2Fsrc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/library%2Falloc%2Fsrc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fraw_vec.rs?ref=3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a", "patch": "@@ -9,7 +9,7 @@ use core::ops::Drop;\n use core::ptr::{self, NonNull, Unique};\n use core::slice;\n \n-use crate::alloc::{handle_alloc_error, AllocRef, Global, Layout};\n+use crate::alloc::{handle_alloc_error, Allocator, Global, Layout};\n use crate::boxed::Box;\n use crate::collections::TryReserveError::{self, *};\n \n@@ -46,7 +46,7 @@ enum AllocInit {\n /// `usize::MAX`. This means that you need to be careful when round-tripping this type with a\n /// `Box<[T]>`, since `capacity()` won't yield the length.\n #[allow(missing_debug_implementations)]\n-pub struct RawVec<T, A: AllocRef = Global> {\n+pub struct RawVec<T, A: Allocator = Global> {\n     ptr: Unique<T>,\n     cap: usize,\n     alloc: A,\n@@ -113,7 +113,7 @@ impl<T> RawVec<T, Global> {\n     }\n }\n \n-impl<T, A: AllocRef> RawVec<T, A> {\n+impl<T, A: Allocator> RawVec<T, A> {\n     /// Like `new`, but parameterized over the choice of allocator for\n     /// the returned `RawVec`.\n     #[rustc_allow_const_fn_unstable(const_fn)]\n@@ -139,7 +139,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     /// Converts a `Box<[T]>` into a `RawVec<T>`.\n     pub fn from_box(slice: Box<[T], A>) -> Self {\n         unsafe {\n-            let (slice, alloc) = Box::into_raw_with_alloc(slice);\n+            let (slice, alloc) = Box::into_raw_with_allocator(slice);\n             RawVec::from_raw_parts_in(slice.as_mut_ptr(), slice.len(), alloc)\n         }\n     }\n@@ -185,8 +185,8 @@ impl<T, A: AllocRef> RawVec<T, A> {\n                 Err(_) => capacity_overflow(),\n             }\n             let result = match init {\n-                AllocInit::Uninitialized => alloc.alloc(layout),\n-                AllocInit::Zeroed => alloc.alloc_zeroed(layout),\n+                AllocInit::Uninitialized => alloc.allocate(layout),\n+                AllocInit::Zeroed => alloc.allocate_zeroed(layout),\n             };\n             let ptr = match result {\n                 Ok(ptr) => ptr,\n@@ -232,7 +232,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     }\n \n     /// Returns a shared reference to the allocator backing this `RawVec`.\n-    pub fn alloc_ref(&self) -> &A {\n+    pub fn allocator(&self) -> &A {\n         &self.alloc\n     }\n \n@@ -359,7 +359,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     }\n }\n \n-impl<T, A: AllocRef> RawVec<T, A> {\n+impl<T, A: Allocator> RawVec<T, A> {\n     /// Returns if the buffer needs to grow to fulfill the needed extra capacity.\n     /// Mainly used to make inlining reserve-calls possible without inlining `grow`.\n     fn needs_to_grow(&self, len: usize, additional: usize) -> bool {\n@@ -471,7 +471,7 @@ fn finish_grow<A>(\n     alloc: &mut A,\n ) -> Result<NonNull<[u8]>, TryReserveError>\n where\n-    A: AllocRef,\n+    A: Allocator,\n {\n     // Check for the error here to minimize the size of `RawVec::grow_*`.\n     let new_layout = new_layout.map_err(|_| CapacityOverflow)?;\n@@ -486,17 +486,17 @@ where\n             alloc.grow(ptr, old_layout, new_layout)\n         }\n     } else {\n-        alloc.alloc(new_layout)\n+        alloc.allocate(new_layout)\n     };\n \n     memory.map_err(|_| AllocError { layout: new_layout, non_exhaustive: () })\n }\n \n-unsafe impl<#[may_dangle] T, A: AllocRef> Drop for RawVec<T, A> {\n+unsafe impl<#[may_dangle] T, A: Allocator> Drop for RawVec<T, A> {\n     /// Frees the memory owned by the `RawVec` *without* trying to drop its contents.\n     fn drop(&mut self) {\n         if let Some((ptr, layout)) = self.current_memory() {\n-            unsafe { self.alloc.dealloc(ptr, layout) }\n+            unsafe { self.alloc.deallocate(ptr, layout) }\n         }\n     }\n }"}, {"sha": "8c15a24409bab17793101ddfc1e174cd8edad0a7", "filename": "library/alloc/src/raw_vec/tests.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/library%2Falloc%2Fsrc%2Fraw_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/library%2Falloc%2Fsrc%2Fraw_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fraw_vec%2Ftests.rs?ref=3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a", "patch": "@@ -20,22 +20,22 @@ fn allocator_param() {\n     struct BoundedAlloc {\n         fuel: Cell<usize>,\n     }\n-    unsafe impl AllocRef for BoundedAlloc {\n-        fn alloc(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n+    unsafe impl Allocator for BoundedAlloc {\n+        fn allocate(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n             let size = layout.size();\n             if size > self.fuel.get() {\n                 return Err(AllocError);\n             }\n-            match Global.alloc(layout) {\n+            match Global.allocate(layout) {\n                 ok @ Ok(_) => {\n                     self.fuel.set(self.fuel.get() - size);\n                     ok\n                 }\n                 err @ Err(_) => err,\n             }\n         }\n-        unsafe fn dealloc(&self, ptr: NonNull<u8>, layout: Layout) {\n-            unsafe { Global.dealloc(ptr, layout) }\n+        unsafe fn deallocate(&self, ptr: NonNull<u8>, layout: Layout) {\n+            unsafe { Global.deallocate(ptr, layout) }\n         }\n     }\n "}, {"sha": "a96be57143d385cba2ace97e9e9f6a7ac5d1b1d6", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a", "patch": "@@ -262,7 +262,7 @@ use core::pin::Pin;\n use core::ptr::{self, NonNull};\n use core::slice::from_raw_parts_mut;\n \n-use crate::alloc::{box_free, handle_alloc_error, AllocError, AllocRef, Global, Layout};\n+use crate::alloc::{box_free, handle_alloc_error, AllocError, Allocator, Global, Layout};\n use crate::borrow::{Cow, ToOwned};\n use crate::string::String;\n use crate::vec::Vec;\n@@ -416,7 +416,7 @@ impl<T> Rc<T> {\n         unsafe {\n             Rc::from_ptr(Rc::allocate_for_layout(\n                 Layout::new::<T>(),\n-                |layout| Global.alloc(layout),\n+                |layout| Global.allocate(layout),\n                 |mem| mem as *mut RcBox<mem::MaybeUninit<T>>,\n             ))\n         }\n@@ -447,7 +447,7 @@ impl<T> Rc<T> {\n         unsafe {\n             Rc::from_ptr(Rc::allocate_for_layout(\n                 Layout::new::<T>(),\n-                |layout| Global.alloc_zeroed(layout),\n+                |layout| Global.allocate_zeroed(layout),\n                 |mem| mem as *mut RcBox<mem::MaybeUninit<T>>,\n             ))\n         }\n@@ -555,7 +555,7 @@ impl<T> Rc<[T]> {\n         unsafe {\n             Rc::from_ptr(Rc::allocate_for_layout(\n                 Layout::array::<T>(len).unwrap(),\n-                |layout| Global.alloc_zeroed(layout),\n+                |layout| Global.allocate_zeroed(layout),\n                 |mem| {\n                     ptr::slice_from_raw_parts_mut(mem as *mut T, len)\n                         as *mut RcBox<[mem::MaybeUninit<T>]>\n@@ -1040,7 +1040,7 @@ impl<T: ?Sized> Rc<T> {\n         unsafe {\n             Self::allocate_for_layout(\n                 Layout::for_value(&*ptr),\n-                |layout| Global.alloc(layout),\n+                |layout| Global.allocate(layout),\n                 |mem| set_data_ptr(ptr as *mut T, mem) as *mut RcBox<T>,\n             )\n         }\n@@ -1075,7 +1075,7 @@ impl<T> Rc<[T]> {\n         unsafe {\n             Self::allocate_for_layout(\n                 Layout::array::<T>(len).unwrap(),\n-                |layout| Global.alloc(layout),\n+                |layout| Global.allocate(layout),\n                 |mem| ptr::slice_from_raw_parts_mut(mem as *mut T, len) as *mut RcBox<[T]>,\n             )\n         }\n@@ -1125,7 +1125,7 @@ impl<T> Rc<[T]> {\n                     let slice = from_raw_parts_mut(self.elems, self.n_elems);\n                     ptr::drop_in_place(slice);\n \n-                    Global.dealloc(self.mem, self.layout);\n+                    Global.deallocate(self.mem, self.layout);\n                 }\n             }\n         }\n@@ -1225,7 +1225,7 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Rc<T> {\n                 self.inner().dec_weak();\n \n                 if self.inner().weak() == 0 {\n-                    Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()));\n+                    Global.deallocate(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()));\n                 }\n             }\n         }\n@@ -2040,7 +2040,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n         // the strong pointers have disappeared.\n         if inner.weak() == 0 {\n             unsafe {\n-                Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()));\n+                Global.deallocate(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()));\n             }\n         }\n     }"}, {"sha": "064700fc72c95154a98209ce4bb88d75749ddb43", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a", "patch": "@@ -87,7 +87,7 @@ use core::cmp::Ordering::{self, Less};\n use core::mem::{self, size_of};\n use core::ptr;\n \n-use crate::alloc::{AllocRef, Global};\n+use crate::alloc::{Allocator, Global};\n use crate::borrow::ToOwned;\n use crate::boxed::Box;\n use crate::vec::Vec;\n@@ -138,41 +138,41 @@ pub use hack::to_vec;\n // `core::slice::SliceExt` - we need to supply these functions for the\n // `test_permutations` test\n mod hack {\n-    use core::alloc::AllocRef;\n+    use core::alloc::Allocator;\n \n     use crate::boxed::Box;\n     use crate::vec::Vec;\n \n     // We shouldn't add inline attribute to this since this is used in\n     // `vec!` macro mostly and causes perf regression. See #71204 for\n     // discussion and perf results.\n-    pub fn into_vec<T, A: AllocRef>(b: Box<[T], A>) -> Vec<T, A> {\n+    pub fn into_vec<T, A: Allocator>(b: Box<[T], A>) -> Vec<T, A> {\n         unsafe {\n             let len = b.len();\n-            let (b, alloc) = Box::into_raw_with_alloc(b);\n+            let (b, alloc) = Box::into_raw_with_allocator(b);\n             Vec::from_raw_parts_in(b as *mut T, len, len, alloc)\n         }\n     }\n \n     #[inline]\n-    pub fn to_vec<T: ConvertVec, A: AllocRef>(s: &[T], alloc: A) -> Vec<T, A> {\n+    pub fn to_vec<T: ConvertVec, A: Allocator>(s: &[T], alloc: A) -> Vec<T, A> {\n         T::to_vec(s, alloc)\n     }\n \n     pub trait ConvertVec {\n-        fn to_vec<A: AllocRef>(s: &[Self], alloc: A) -> Vec<Self, A>\n+        fn to_vec<A: Allocator>(s: &[Self], alloc: A) -> Vec<Self, A>\n         where\n             Self: Sized;\n     }\n \n     impl<T: Clone> ConvertVec for T {\n         #[inline]\n-        default fn to_vec<A: AllocRef>(s: &[Self], alloc: A) -> Vec<Self, A> {\n-            struct DropGuard<'a, T, A: AllocRef> {\n+        default fn to_vec<A: Allocator>(s: &[Self], alloc: A) -> Vec<Self, A> {\n+            struct DropGuard<'a, T, A: Allocator> {\n                 vec: &'a mut Vec<T, A>,\n                 num_init: usize,\n             }\n-            impl<'a, T, A: AllocRef> Drop for DropGuard<'a, T, A> {\n+            impl<'a, T, A: Allocator> Drop for DropGuard<'a, T, A> {\n                 #[inline]\n                 fn drop(&mut self) {\n                     // SAFETY:\n@@ -203,7 +203,7 @@ mod hack {\n \n     impl<T: Copy> ConvertVec for T {\n         #[inline]\n-        fn to_vec<A: AllocRef>(s: &[Self], alloc: A) -> Vec<Self, A> {\n+        fn to_vec<A: Allocator>(s: &[Self], alloc: A) -> Vec<Self, A> {\n             let mut v = Vec::with_capacity_in(s.len(), alloc);\n             // SAFETY:\n             // allocated above with the capacity of `s`, and initialize to `s.len()` in\n@@ -464,7 +464,7 @@ impl<T> [T] {\n     /// ```\n     #[inline]\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    pub fn to_vec_in<A: AllocRef>(&self, alloc: A) -> Vec<T, A>\n+    pub fn to_vec_in<A: Allocator>(&self, alloc: A) -> Vec<T, A>\n     where\n         T: Clone,\n     {\n@@ -488,7 +488,7 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn into_vec<A: AllocRef>(self: Box<Self, A>) -> Vec<T, A> {\n+    pub fn into_vec<A: Allocator>(self: Box<Self, A>) -> Vec<T, A> {\n         // N.B., see the `hack` module in this file for more details.\n         hack::into_vec(self)\n     }"}, {"sha": "9d478a302e96c01aaa740ce0bb6128933975226e", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a", "patch": "@@ -22,7 +22,7 @@ use core::slice::from_raw_parts_mut;\n use core::sync::atomic;\n use core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\n \n-use crate::alloc::{box_free, handle_alloc_error, AllocError, AllocRef, Global, Layout};\n+use crate::alloc::{box_free, handle_alloc_error, AllocError, Allocator, Global, Layout};\n use crate::borrow::{Cow, ToOwned};\n use crate::boxed::Box;\n use crate::rc::is_dangling;\n@@ -434,7 +434,7 @@ impl<T> Arc<T> {\n         unsafe {\n             Arc::from_ptr(Arc::allocate_for_layout(\n                 Layout::new::<T>(),\n-                |layout| Global.alloc(layout),\n+                |layout| Global.allocate(layout),\n                 |mem| mem as *mut ArcInner<mem::MaybeUninit<T>>,\n             ))\n         }\n@@ -465,7 +465,7 @@ impl<T> Arc<T> {\n         unsafe {\n             Arc::from_ptr(Arc::allocate_for_layout(\n                 Layout::new::<T>(),\n-                |layout| Global.alloc_zeroed(layout),\n+                |layout| Global.allocate_zeroed(layout),\n                 |mem| mem as *mut ArcInner<mem::MaybeUninit<T>>,\n             ))\n         }\n@@ -572,7 +572,7 @@ impl<T> Arc<[T]> {\n         unsafe {\n             Arc::from_ptr(Arc::allocate_for_layout(\n                 Layout::array::<T>(len).unwrap(),\n-                |layout| Global.alloc_zeroed(layout),\n+                |layout| Global.allocate_zeroed(layout),\n                 |mem| {\n                     ptr::slice_from_raw_parts_mut(mem as *mut T, len)\n                         as *mut ArcInner<[mem::MaybeUninit<T>]>\n@@ -1015,7 +1015,7 @@ impl<T: ?Sized> Arc<T> {\n         unsafe {\n             Self::allocate_for_layout(\n                 Layout::for_value(&*ptr),\n-                |layout| Global.alloc(layout),\n+                |layout| Global.allocate(layout),\n                 |mem| set_data_ptr(ptr as *mut T, mem) as *mut ArcInner<T>,\n             )\n         }\n@@ -1050,7 +1050,7 @@ impl<T> Arc<[T]> {\n         unsafe {\n             Self::allocate_for_layout(\n                 Layout::array::<T>(len).unwrap(),\n-                |layout| Global.alloc(layout),\n+                |layout| Global.allocate(layout),\n                 |mem| ptr::slice_from_raw_parts_mut(mem as *mut T, len) as *mut ArcInner<[T]>,\n             )\n         }\n@@ -1102,7 +1102,7 @@ impl<T> Arc<[T]> {\n                     let slice = from_raw_parts_mut(self.elems, self.n_elems);\n                     ptr::drop_in_place(slice);\n \n-                    Global.dealloc(self.mem, self.layout);\n+                    Global.deallocate(self.mem, self.layout);\n                 }\n             }\n         }\n@@ -1925,7 +1925,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n \n         if inner.weak.fetch_sub(1, Release) == 1 {\n             acquire!(inner.weak);\n-            unsafe { Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref())) }\n+            unsafe { Global.deallocate(self.ptr.cast(), Layout::for_value(self.ptr.as_ref())) }\n         }\n     }\n }"}, {"sha": "9fffb47aa597573e1279e9c7c5845f5fe4712cc2", "filename": "library/alloc/src/vec.rs", "status": "modified", "additions": 113, "deletions": 111, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/library%2Falloc%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/library%2Falloc%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec.rs?ref=3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a", "patch": "@@ -68,7 +68,7 @@ use core::ops::{self, Index, IndexMut, Range, RangeBounds};\n use core::ptr::{self, NonNull};\n use core::slice::{self, SliceIndex};\n \n-use crate::alloc::{AllocRef, Global};\n+use crate::alloc::{Allocator, Global};\n use crate::borrow::{Cow, ToOwned};\n use crate::boxed::Box;\n use crate::collections::TryReserveError;\n@@ -298,7 +298,7 @@ use crate::raw_vec::RawVec;\n /// [`&`]: ../../std/primitive.reference.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"vec_type\")]\n-pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: AllocRef = Global> {\n+pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n     buf: RawVec<T, A>,\n     len: usize,\n }\n@@ -433,7 +433,7 @@ impl<T> Vec<T> {\n     }\n }\n \n-impl<T, A: AllocRef> Vec<T, A> {\n+impl<T, A: Allocator> Vec<T, A> {\n     /// Constructs a new, empty `Vec<T, A>`.\n     ///\n     /// The vector will not allocate until elements are pushed onto it.\n@@ -555,7 +555,7 @@ impl<T, A: AllocRef> Vec<T, A> {\n     /// let p = v.as_mut_ptr();\n     /// let len = v.len();\n     /// let cap = v.capacity();\n-    /// let alloc = v.alloc_ref();\n+    /// let alloc = v.allocator();\n     ///\n     /// unsafe {\n     ///     // Overwrite memory with 4, 5, 6\n@@ -656,7 +656,7 @@ impl<T, A: AllocRef> Vec<T, A> {\n         let len = me.len();\n         let capacity = me.capacity();\n         let ptr = me.as_mut_ptr();\n-        let alloc = unsafe { ptr::read(me.alloc_ref()) };\n+        let alloc = unsafe { ptr::read(me.allocator()) };\n         (ptr, len, capacity, alloc)\n     }\n \n@@ -1058,8 +1058,8 @@ impl<T, A: AllocRef> Vec<T, A> {\n     /// Returns a reference to the underlying allocator.\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     #[inline]\n-    pub fn alloc_ref(&self) -> &A {\n-        self.buf.alloc_ref()\n+    pub fn allocator(&self) -> &A {\n+        self.buf.allocator()\n     }\n \n     /// Forces the length of the vector to `new_len`.\n@@ -1620,12 +1620,12 @@ impl<T, A: AllocRef> Vec<T, A> {\n             // the new vector can take over the original buffer and avoid the copy\n             return mem::replace(\n                 self,\n-                Vec::with_capacity_in(self.capacity(), self.alloc_ref().clone()),\n+                Vec::with_capacity_in(self.capacity(), self.allocator().clone()),\n             );\n         }\n \n         let other_len = self.len - at;\n-        let mut other = Vec::with_capacity_in(other_len, self.alloc_ref().clone());\n+        let mut other = Vec::with_capacity_in(other_len, self.allocator().clone());\n \n         // Unsafely `set_len` and copy items to `other`.\n         unsafe {\n@@ -1749,7 +1749,7 @@ impl<T, A: AllocRef> Vec<T, A> {\n     }\n }\n \n-impl<T: Clone, A: AllocRef> Vec<T, A> {\n+impl<T: Clone, A: Allocator> Vec<T, A> {\n     /// Resizes the `Vec` in-place so that `len` is equal to `new_len`.\n     ///\n     /// If `new_len` is greater than `len`, the `Vec` is extended by the\n@@ -1844,7 +1844,7 @@ impl<T, F: FnMut() -> T> ExtendWith<T> for ExtendFunc<F> {\n     }\n }\n \n-impl<T, A: AllocRef> Vec<T, A> {\n+impl<T, A: Allocator> Vec<T, A> {\n     /// Extend the vector by `n` values, using the given generator.\n     fn extend_with<E: ExtendWith<T>>(&mut self, n: usize, mut value: E) {\n         self.reserve(n);\n@@ -1904,7 +1904,7 @@ impl Drop for SetLenOnDrop<'_> {\n     }\n }\n \n-impl<T: PartialEq, A: AllocRef> Vec<T, A> {\n+impl<T: PartialEq, A: Allocator> Vec<T, A> {\n     /// Removes consecutive repeated elements in the vector according to the\n     /// [`PartialEq`] trait implementation.\n     ///\n@@ -1926,7 +1926,7 @@ impl<T: PartialEq, A: AllocRef> Vec<T, A> {\n     }\n }\n \n-impl<T, A: AllocRef> Vec<T, A> {\n+impl<T, A: Allocator> Vec<T, A> {\n     /// Removes the first instance of `item` from the vector if the item exists.\n     ///\n     /// This method will be removed soon.\n@@ -1959,17 +1959,17 @@ pub fn from_elem<T: Clone>(elem: T, n: usize) -> Vec<T> {\n \n #[doc(hidden)]\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-pub fn from_elem_in<T: Clone, A: AllocRef>(elem: T, n: usize, alloc: A) -> Vec<T, A> {\n+pub fn from_elem_in<T: Clone, A: Allocator>(elem: T, n: usize, alloc: A) -> Vec<T, A> {\n     <T as SpecFromElem>::from_elem(elem, n, alloc)\n }\n \n // Specialization trait used for Vec::from_elem\n trait SpecFromElem: Sized {\n-    fn from_elem<A: AllocRef>(elem: Self, n: usize, alloc: A) -> Vec<Self, A>;\n+    fn from_elem<A: Allocator>(elem: Self, n: usize, alloc: A) -> Vec<Self, A>;\n }\n \n impl<T: Clone> SpecFromElem for T {\n-    default fn from_elem<A: AllocRef>(elem: Self, n: usize, alloc: A) -> Vec<Self, A> {\n+    default fn from_elem<A: Allocator>(elem: Self, n: usize, alloc: A) -> Vec<Self, A> {\n         let mut v = Vec::with_capacity_in(n, alloc);\n         v.extend_with(n, ExtendElement(elem));\n         v\n@@ -1978,7 +1978,7 @@ impl<T: Clone> SpecFromElem for T {\n \n impl SpecFromElem for i8 {\n     #[inline]\n-    fn from_elem<A: AllocRef>(elem: i8, n: usize, alloc: A) -> Vec<i8, A> {\n+    fn from_elem<A: Allocator>(elem: i8, n: usize, alloc: A) -> Vec<i8, A> {\n         if elem == 0 {\n             return Vec { buf: RawVec::with_capacity_zeroed_in(n, alloc), len: n };\n         }\n@@ -1993,7 +1993,7 @@ impl SpecFromElem for i8 {\n \n impl SpecFromElem for u8 {\n     #[inline]\n-    fn from_elem<A: AllocRef>(elem: u8, n: usize, alloc: A) -> Vec<u8, A> {\n+    fn from_elem<A: Allocator>(elem: u8, n: usize, alloc: A) -> Vec<u8, A> {\n         if elem == 0 {\n             return Vec { buf: RawVec::with_capacity_zeroed_in(n, alloc), len: n };\n         }\n@@ -2008,7 +2008,7 @@ impl SpecFromElem for u8 {\n \n impl<T: Clone + IsZero> SpecFromElem for T {\n     #[inline]\n-    fn from_elem<A: AllocRef>(elem: T, n: usize, alloc: A) -> Vec<T, A> {\n+    fn from_elem<A: Allocator>(elem: T, n: usize, alloc: A) -> Vec<T, A> {\n         if elem.is_zero() {\n             return Vec { buf: RawVec::with_capacity_zeroed_in(n, alloc), len: n };\n         }\n@@ -2093,7 +2093,7 @@ unsafe impl<T: ?Sized> IsZero for Option<Box<T>> {\n ////////////////////////////////////////////////////////////////////////////////\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, A: AllocRef> ops::Deref for Vec<T, A> {\n+impl<T, A: Allocator> ops::Deref for Vec<T, A> {\n     type Target = [T];\n \n     fn deref(&self) -> &[T] {\n@@ -2102,17 +2102,17 @@ impl<T, A: AllocRef> ops::Deref for Vec<T, A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, A: AllocRef> ops::DerefMut for Vec<T, A> {\n+impl<T, A: Allocator> ops::DerefMut for Vec<T, A> {\n     fn deref_mut(&mut self) -> &mut [T] {\n         unsafe { slice::from_raw_parts_mut(self.as_mut_ptr(), self.len) }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Clone, A: AllocRef + Clone> Clone for Vec<T, A> {\n+impl<T: Clone, A: Allocator + Clone> Clone for Vec<T, A> {\n     #[cfg(not(test))]\n     fn clone(&self) -> Self {\n-        let alloc = self.alloc_ref().clone();\n+        let alloc = self.allocator().clone();\n         <[T]>::to_vec_in(&**self, alloc)\n     }\n \n@@ -2122,7 +2122,7 @@ impl<T: Clone, A: AllocRef + Clone> Clone for Vec<T, A> {\n     // NB see the slice::hack module in slice.rs for more information\n     #[cfg(test)]\n     fn clone(&self) -> Self {\n-        let alloc = self.alloc_ref().clone();\n+        let alloc = self.allocator().clone();\n         crate::slice::to_vec(&**self, alloc)\n     }\n \n@@ -2141,7 +2141,7 @@ impl<T: Clone, A: AllocRef + Clone> Clone for Vec<T, A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Hash, A: AllocRef> Hash for Vec<T, A> {\n+impl<T: Hash, A: Allocator> Hash for Vec<T, A> {\n     #[inline]\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         Hash::hash(&**self, state)\n@@ -2153,7 +2153,7 @@ impl<T: Hash, A: AllocRef> Hash for Vec<T, A> {\n     message = \"vector indices are of type `usize` or ranges of `usize`\",\n     label = \"vector indices are of type `usize` or ranges of `usize`\"\n )]\n-impl<T, I: SliceIndex<[T]>, A: AllocRef> Index<I> for Vec<T, A> {\n+impl<T, I: SliceIndex<[T]>, A: Allocator> Index<I> for Vec<T, A> {\n     type Output = I::Output;\n \n     #[inline]\n@@ -2167,7 +2167,7 @@ impl<T, I: SliceIndex<[T]>, A: AllocRef> Index<I> for Vec<T, A> {\n     message = \"vector indices are of type `usize` or ranges of `usize`\",\n     label = \"vector indices are of type `usize` or ranges of `usize`\"\n )]\n-impl<T, I: SliceIndex<[T]>, A: AllocRef> IndexMut<I> for Vec<T, A> {\n+impl<T, I: SliceIndex<[T]>, A: Allocator> IndexMut<I> for Vec<T, A> {\n     #[inline]\n     fn index_mut(&mut self, index: I) -> &mut Self::Output {\n         IndexMut::index_mut(&mut **self, index)\n@@ -2183,7 +2183,7 @@ impl<T> FromIterator<T> for Vec<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, A: AllocRef> IntoIterator for Vec<T, A> {\n+impl<T, A: Allocator> IntoIterator for Vec<T, A> {\n     type Item = T;\n     type IntoIter = IntoIter<T, A>;\n \n@@ -2204,7 +2204,7 @@ impl<T, A: AllocRef> IntoIterator for Vec<T, A> {\n     fn into_iter(self) -> IntoIter<T, A> {\n         unsafe {\n             let mut me = ManuallyDrop::new(self);\n-            let alloc = ptr::read(me.alloc_ref());\n+            let alloc = ptr::read(me.allocator());\n             let begin = me.as_mut_ptr();\n             let end = if mem::size_of::<T>() == 0 {\n                 arith_offset(begin as *const i8, me.len() as isize) as *const T\n@@ -2225,7 +2225,7 @@ impl<T, A: AllocRef> IntoIterator for Vec<T, A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T, A: AllocRef> IntoIterator for &'a Vec<T, A> {\n+impl<'a, T, A: Allocator> IntoIterator for &'a Vec<T, A> {\n     type Item = &'a T;\n     type IntoIter = slice::Iter<'a, T>;\n \n@@ -2235,7 +2235,7 @@ impl<'a, T, A: AllocRef> IntoIterator for &'a Vec<T, A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T, A: AllocRef> IntoIterator for &'a mut Vec<T, A> {\n+impl<'a, T, A: Allocator> IntoIterator for &'a mut Vec<T, A> {\n     type Item = &'a mut T;\n     type IntoIter = slice::IterMut<'a, T>;\n \n@@ -2245,7 +2245,7 @@ impl<'a, T, A: AllocRef> IntoIterator for &'a mut Vec<T, A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, A: AllocRef> Extend<T> for Vec<T, A> {\n+impl<T, A: Allocator> Extend<T> for Vec<T, A> {\n     #[inline]\n     fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n         <Self as SpecExtend<T, I::IntoIter>>::spec_extend(self, iter.into_iter())\n@@ -2533,7 +2533,7 @@ trait SpecExtend<T, I> {\n     fn spec_extend(&mut self, iter: I);\n }\n \n-impl<T, I, A: AllocRef> SpecExtend<T, I> for Vec<T, A>\n+impl<T, I, A: Allocator> SpecExtend<T, I> for Vec<T, A>\n where\n     I: Iterator<Item = T>,\n {\n@@ -2542,7 +2542,7 @@ where\n     }\n }\n \n-impl<T, I, A: AllocRef> SpecExtend<T, I> for Vec<T, A>\n+impl<T, I, A: Allocator> SpecExtend<T, I> for Vec<T, A>\n where\n     I: TrustedLen<Item = T>,\n {\n@@ -2575,7 +2575,7 @@ where\n     }\n }\n \n-impl<T, A: AllocRef> SpecExtend<T, IntoIter<T>> for Vec<T, A> {\n+impl<T, A: Allocator> SpecExtend<T, IntoIter<T>> for Vec<T, A> {\n     fn spec_extend(&mut self, mut iterator: IntoIter<T>) {\n         unsafe {\n             self.append_elements(iterator.as_slice() as _);\n@@ -2584,7 +2584,7 @@ impl<T, A: AllocRef> SpecExtend<T, IntoIter<T>> for Vec<T, A> {\n     }\n }\n \n-impl<'a, T: 'a, I, A: AllocRef + 'a> SpecExtend<&'a T, I> for Vec<T, A>\n+impl<'a, T: 'a, I, A: Allocator + 'a> SpecExtend<&'a T, I> for Vec<T, A>\n where\n     I: Iterator<Item = &'a T>,\n     T: Clone,\n@@ -2594,7 +2594,7 @@ where\n     }\n }\n \n-impl<'a, T: 'a, A: AllocRef + 'a> SpecExtend<&'a T, slice::Iter<'a, T>> for Vec<T, A>\n+impl<'a, T: 'a, A: Allocator + 'a> SpecExtend<&'a T, slice::Iter<'a, T>> for Vec<T, A>\n where\n     T: Copy,\n {\n@@ -2604,7 +2604,7 @@ where\n     }\n }\n \n-impl<T, A: AllocRef> Vec<T, A> {\n+impl<T, A: Allocator> Vec<T, A> {\n     // leaf method to which various SpecFrom/SpecExtend implementations delegate when\n     // they have no further optimizations to apply\n     fn extend_desugared<I: Iterator<Item = T>>(&mut self, mut iterator: I) {\n@@ -2739,7 +2739,7 @@ impl<T, A: AllocRef> Vec<T, A> {\n ///\n /// [`copy_from_slice`]: ../../std/primitive.slice.html#method.copy_from_slice\n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n-impl<'a, T: Copy + 'a, A: AllocRef + 'a> Extend<&'a T> for Vec<T, A> {\n+impl<'a, T: Copy + 'a, A: Allocator + 'a> Extend<&'a T> for Vec<T, A> {\n     fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.spec_extend(iter.into_iter())\n     }\n@@ -2771,18 +2771,18 @@ macro_rules! __impl_slice_eq1 {\n     }\n }\n \n-__impl_slice_eq1! { [A: AllocRef] Vec<T, A>, Vec<U, A>, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n-__impl_slice_eq1! { [A: AllocRef] Vec<T, A>, &[U], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n-__impl_slice_eq1! { [A: AllocRef] Vec<T, A>, &mut [U], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n-__impl_slice_eq1! { [A: AllocRef] &[T], Vec<U, A>, #[stable(feature = \"partialeq_vec_for_ref_slice\", since = \"1.46.0\")] }\n-__impl_slice_eq1! { [A: AllocRef] &mut [T], Vec<U, A>, #[stable(feature = \"partialeq_vec_for_ref_slice\", since = \"1.46.0\")] }\n-__impl_slice_eq1! { [A: AllocRef] Vec<T, A>, [U], #[stable(feature = \"partialeq_vec_for_slice\", since = \"1.48.0\")]  }\n-__impl_slice_eq1! { [A: AllocRef] [T], Vec<U, A>, #[stable(feature = \"partialeq_vec_for_slice\", since = \"1.48.0\")]  }\n-__impl_slice_eq1! { [A: AllocRef] Cow<'_, [T]>, Vec<U, A> where T: Clone, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n+__impl_slice_eq1! { [A: Allocator] Vec<T, A>, Vec<U, A>, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n+__impl_slice_eq1! { [A: Allocator] Vec<T, A>, &[U], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n+__impl_slice_eq1! { [A: Allocator] Vec<T, A>, &mut [U], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n+__impl_slice_eq1! { [A: Allocator] &[T], Vec<U, A>, #[stable(feature = \"partialeq_vec_for_ref_slice\", since = \"1.46.0\")] }\n+__impl_slice_eq1! { [A: Allocator] &mut [T], Vec<U, A>, #[stable(feature = \"partialeq_vec_for_ref_slice\", since = \"1.46.0\")] }\n+__impl_slice_eq1! { [A: Allocator] Vec<T, A>, [U], #[stable(feature = \"partialeq_vec_for_slice\", since = \"1.48.0\")]  }\n+__impl_slice_eq1! { [A: Allocator] [T], Vec<U, A>, #[stable(feature = \"partialeq_vec_for_slice\", since = \"1.48.0\")]  }\n+__impl_slice_eq1! { [A: Allocator] Cow<'_, [T]>, Vec<U, A> where T: Clone, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n __impl_slice_eq1! { [] Cow<'_, [T]>, &[U] where T: Clone, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n __impl_slice_eq1! { [] Cow<'_, [T]>, &mut [U] where T: Clone, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n-__impl_slice_eq1! { [A: AllocRef, const N: usize] Vec<T, A>, [U; N], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n-__impl_slice_eq1! { [A: AllocRef, const N: usize] Vec<T, A>, &[U; N], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n+__impl_slice_eq1! { [A: Allocator, const N: usize] Vec<T, A>, [U; N], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n+__impl_slice_eq1! { [A: Allocator, const N: usize] Vec<T, A>, &[U; N], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n \n // NOTE: some less important impls are omitted to reduce code bloat\n // FIXME(Centril): Reconsider this?\n@@ -2796,27 +2796,27 @@ __impl_slice_eq1! { [A: AllocRef, const N: usize] Vec<T, A>, &[U; N], #[stable(f\n \n /// Implements comparison of vectors, [lexicographically](core::cmp::Ord#lexicographical-comparison).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: PartialOrd, A: AllocRef> PartialOrd for Vec<T, A> {\n+impl<T: PartialOrd, A: Allocator> PartialOrd for Vec<T, A> {\n     #[inline]\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n         PartialOrd::partial_cmp(&**self, &**other)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Eq, A: AllocRef> Eq for Vec<T, A> {}\n+impl<T: Eq, A: Allocator> Eq for Vec<T, A> {}\n \n /// Implements ordering of vectors, [lexicographically](core::cmp::Ord#lexicographical-comparison).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Ord, A: AllocRef> Ord for Vec<T, A> {\n+impl<T: Ord, A: Allocator> Ord for Vec<T, A> {\n     #[inline]\n     fn cmp(&self, other: &Self) -> Ordering {\n         Ord::cmp(&**self, &**other)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<#[may_dangle] T, A: AllocRef> Drop for Vec<T, A> {\n+unsafe impl<#[may_dangle] T, A: Allocator> Drop for Vec<T, A> {\n     fn drop(&mut self) {\n         unsafe {\n             // use drop for [T]\n@@ -2837,35 +2837,35 @@ impl<T> Default for Vec<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::Debug, A: AllocRef> fmt::Debug for Vec<T, A> {\n+impl<T: fmt::Debug, A: Allocator> fmt::Debug for Vec<T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Debug::fmt(&**self, f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, A: AllocRef> AsRef<Vec<T, A>> for Vec<T, A> {\n+impl<T, A: Allocator> AsRef<Vec<T, A>> for Vec<T, A> {\n     fn as_ref(&self) -> &Vec<T, A> {\n         self\n     }\n }\n \n #[stable(feature = \"vec_as_mut\", since = \"1.5.0\")]\n-impl<T, A: AllocRef> AsMut<Vec<T, A>> for Vec<T, A> {\n+impl<T, A: Allocator> AsMut<Vec<T, A>> for Vec<T, A> {\n     fn as_mut(&mut self) -> &mut Vec<T, A> {\n         self\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, A: AllocRef> AsRef<[T]> for Vec<T, A> {\n+impl<T, A: Allocator> AsRef<[T]> for Vec<T, A> {\n     fn as_ref(&self) -> &[T] {\n         self\n     }\n }\n \n #[stable(feature = \"vec_as_mut\", since = \"1.5.0\")]\n-impl<T, A: AllocRef> AsMut<[T]> for Vec<T, A> {\n+impl<T, A: Allocator> AsMut<[T]> for Vec<T, A> {\n     fn as_mut(&mut self) -> &mut [T] {\n         self\n     }\n@@ -2920,7 +2920,7 @@ where\n // note: test pulls in libstd, which causes errors here\n #[cfg(not(test))]\n #[stable(feature = \"vec_from_box\", since = \"1.18.0\")]\n-impl<T, A: AllocRef> From<Box<[T], A>> for Vec<T, A> {\n+impl<T, A: Allocator> From<Box<[T], A>> for Vec<T, A> {\n     fn from(s: Box<[T], A>) -> Self {\n         let len = s.len();\n         Self { buf: RawVec::from_box(s), len }\n@@ -2930,7 +2930,7 @@ impl<T, A: AllocRef> From<Box<[T], A>> for Vec<T, A> {\n // note: test pulls in libstd, which causes errors here\n #[cfg(not(test))]\n #[stable(feature = \"box_from_vec\", since = \"1.20.0\")]\n-impl<T, A: AllocRef> From<Vec<T, A>> for Box<[T], A> {\n+impl<T, A: Allocator> From<Vec<T, A>> for Box<[T], A> {\n     fn from(v: Vec<T, A>) -> Self {\n         v.into_boxed_slice()\n     }\n@@ -2944,7 +2944,7 @@ impl From<&str> for Vec<u8> {\n }\n \n #[stable(feature = \"array_try_from_vec\", since = \"1.48.0\")]\n-impl<T, A: AllocRef, const N: usize> TryFrom<Vec<T, A>> for [T; N] {\n+impl<T, A: Allocator, const N: usize> TryFrom<Vec<T, A>> for [T; N] {\n     type Error = Vec<T, A>;\n \n     /// Gets the entire contents of the `Vec<T>` as an array,\n@@ -3045,8 +3045,10 @@ where\n /// let iter: std::vec::IntoIter<_> = v.into_iter();\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct IntoIter<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: AllocRef = Global>\n-{\n+pub struct IntoIter<\n+    T,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+> {\n     buf: NonNull<T>,\n     phantom: PhantomData<T>,\n     cap: usize,\n@@ -3056,13 +3058,13 @@ pub struct IntoIter<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A\n }\n \n #[stable(feature = \"vec_intoiter_debug\", since = \"1.13.0\")]\n-impl<T: fmt::Debug, A: AllocRef> fmt::Debug for IntoIter<T, A> {\n+impl<T: fmt::Debug, A: Allocator> fmt::Debug for IntoIter<T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"IntoIter\").field(&self.as_slice()).finish()\n     }\n }\n \n-impl<T, A: AllocRef> IntoIter<T, A> {\n+impl<T, A: Allocator> IntoIter<T, A> {\n     /// Returns the remaining items of this iterator as a slice.\n     ///\n     /// # Examples\n@@ -3100,7 +3102,7 @@ impl<T, A: AllocRef> IntoIter<T, A> {\n     /// Returns a reference to the underlying allocator.\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     #[inline]\n-    pub fn alloc_ref(&self) -> &A {\n+    pub fn allocator(&self) -> &A {\n         &self.alloc\n     }\n \n@@ -3126,19 +3128,19 @@ impl<T, A: AllocRef> IntoIter<T, A> {\n }\n \n #[stable(feature = \"vec_intoiter_as_ref\", since = \"1.46.0\")]\n-impl<T, A: AllocRef> AsRef<[T]> for IntoIter<T, A> {\n+impl<T, A: Allocator> AsRef<[T]> for IntoIter<T, A> {\n     fn as_ref(&self) -> &[T] {\n         self.as_slice()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Send, A: AllocRef + Send> Send for IntoIter<T, A> {}\n+unsafe impl<T: Send, A: Allocator + Send> Send for IntoIter<T, A> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Sync, A: AllocRef> Sync for IntoIter<T, A> {}\n+unsafe impl<T: Sync, A: Allocator> Sync for IntoIter<T, A> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, A: AllocRef> Iterator for IntoIter<T, A> {\n+impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n     type Item = T;\n \n     #[inline]\n@@ -3195,7 +3197,7 @@ impl<T, A: AllocRef> Iterator for IntoIter<T, A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, A: AllocRef> DoubleEndedIterator for IntoIter<T, A> {\n+impl<T, A: Allocator> DoubleEndedIterator for IntoIter<T, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         if self.end == self.ptr {\n@@ -3215,23 +3217,23 @@ impl<T, A: AllocRef> DoubleEndedIterator for IntoIter<T, A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, A: AllocRef> ExactSizeIterator for IntoIter<T, A> {\n+impl<T, A: Allocator> ExactSizeIterator for IntoIter<T, A> {\n     fn is_empty(&self) -> bool {\n         self.ptr == self.end\n     }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T, A: AllocRef> FusedIterator for IntoIter<T, A> {}\n+impl<T, A: Allocator> FusedIterator for IntoIter<T, A> {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<T, A: AllocRef> TrustedLen for IntoIter<T, A> {}\n+unsafe impl<T, A: Allocator> TrustedLen for IntoIter<T, A> {}\n \n #[doc(hidden)]\n #[unstable(issue = \"none\", feature = \"std_internals\")]\n // T: Copy as approximation for !Drop since get_unchecked does not advance self.ptr\n // and thus we can't implement drop-handling\n-unsafe impl<T, A: AllocRef> TrustedRandomAccess for IntoIter<T, A>\n+unsafe impl<T, A: Allocator> TrustedRandomAccess for IntoIter<T, A>\n where\n     T: Copy,\n {\n@@ -3241,7 +3243,7 @@ where\n }\n \n #[stable(feature = \"vec_into_iter_clone\", since = \"1.8.0\")]\n-impl<T: Clone, A: AllocRef + Clone> Clone for IntoIter<T, A> {\n+impl<T: Clone, A: Allocator + Clone> Clone for IntoIter<T, A> {\n     #[cfg(not(test))]\n     fn clone(&self) -> Self {\n         self.as_slice().to_vec_in(self.alloc.clone()).into_iter()\n@@ -3253,11 +3255,11 @@ impl<T: Clone, A: AllocRef + Clone> Clone for IntoIter<T, A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<#[may_dangle] T, A: AllocRef> Drop for IntoIter<T, A> {\n+unsafe impl<#[may_dangle] T, A: Allocator> Drop for IntoIter<T, A> {\n     fn drop(&mut self) {\n-        struct DropGuard<'a, T, A: AllocRef>(&'a mut IntoIter<T, A>);\n+        struct DropGuard<'a, T, A: Allocator>(&'a mut IntoIter<T, A>);\n \n-        impl<T, A: AllocRef> Drop for DropGuard<'_, T, A> {\n+        impl<T, A: Allocator> Drop for DropGuard<'_, T, A> {\n             fn drop(&mut self) {\n                 unsafe {\n                     // `IntoIter::alloc` is not used anymore after this\n@@ -3278,10 +3280,10 @@ unsafe impl<#[may_dangle] T, A: AllocRef> Drop for IntoIter<T, A> {\n }\n \n #[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<T, A: AllocRef> InPlaceIterable for IntoIter<T, A> {}\n+unsafe impl<T, A: Allocator> InPlaceIterable for IntoIter<T, A> {}\n \n #[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<T, A: AllocRef> SourceIter for IntoIter<T, A> {\n+unsafe impl<T, A: Allocator> SourceIter for IntoIter<T, A> {\n     type Source = Self;\n \n     #[inline]\n@@ -3320,7 +3322,7 @@ impl<T> AsIntoIter for IntoIter<T> {\n pub struct Drain<\n     'a,\n     T: 'a,\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: AllocRef + 'a = Global,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator + 'a = Global,\n > {\n     /// Index of tail to preserve\n     tail_start: usize,\n@@ -3332,13 +3334,13 @@ pub struct Drain<\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<T: fmt::Debug, A: AllocRef> fmt::Debug for Drain<'_, T, A> {\n+impl<T: fmt::Debug, A: Allocator> fmt::Debug for Drain<'_, T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"Drain\").field(&self.iter.as_slice()).finish()\n     }\n }\n \n-impl<'a, T, A: AllocRef> Drain<'a, T, A> {\n+impl<'a, T, A: Allocator> Drain<'a, T, A> {\n     /// Returns the remaining items of this iterator as a slice.\n     ///\n     /// # Examples\n@@ -3358,25 +3360,25 @@ impl<'a, T, A: AllocRef> Drain<'a, T, A> {\n     /// Returns a reference to the underlying allocator.\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     #[inline]\n-    pub fn alloc_ref(&self) -> &A {\n-        unsafe { self.vec.as_ref().alloc_ref() }\n+    pub fn allocator(&self) -> &A {\n+        unsafe { self.vec.as_ref().allocator() }\n     }\n }\n \n #[stable(feature = \"vec_drain_as_slice\", since = \"1.46.0\")]\n-impl<'a, T, A: AllocRef> AsRef<[T]> for Drain<'a, T, A> {\n+impl<'a, T, A: Allocator> AsRef<[T]> for Drain<'a, T, A> {\n     fn as_ref(&self) -> &[T] {\n         self.as_slice()\n     }\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-unsafe impl<T: Sync, A: Sync + AllocRef> Sync for Drain<'_, T, A> {}\n+unsafe impl<T: Sync, A: Sync + Allocator> Sync for Drain<'_, T, A> {}\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-unsafe impl<T: Send, A: Send + AllocRef> Send for Drain<'_, T, A> {}\n+unsafe impl<T: Send, A: Send + Allocator> Send for Drain<'_, T, A> {}\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T, A: AllocRef> Iterator for Drain<'_, T, A> {\n+impl<T, A: Allocator> Iterator for Drain<'_, T, A> {\n     type Item = T;\n \n     #[inline]\n@@ -3390,21 +3392,21 @@ impl<T, A: AllocRef> Iterator for Drain<'_, T, A> {\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T, A: AllocRef> DoubleEndedIterator for Drain<'_, T, A> {\n+impl<T, A: Allocator> DoubleEndedIterator for Drain<'_, T, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         self.iter.next_back().map(|elt| unsafe { ptr::read(elt as *const _) })\n     }\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T, A: AllocRef> Drop for Drain<'_, T, A> {\n+impl<T, A: Allocator> Drop for Drain<'_, T, A> {\n     fn drop(&mut self) {\n         /// Continues dropping the remaining elements in the `Drain`, then moves back the\n         /// un-`Drain`ed elements to restore the original `Vec`.\n-        struct DropGuard<'r, 'a, T, A: AllocRef>(&'r mut Drain<'a, T, A>);\n+        struct DropGuard<'r, 'a, T, A: Allocator>(&'r mut Drain<'a, T, A>);\n \n-        impl<'r, 'a, T, A: AllocRef> Drop for DropGuard<'r, 'a, T, A> {\n+        impl<'r, 'a, T, A: Allocator> Drop for DropGuard<'r, 'a, T, A> {\n             fn drop(&mut self) {\n                 // Continue the same loop we have below. If the loop already finished, this does\n                 // nothing.\n@@ -3440,17 +3442,17 @@ impl<T, A: AllocRef> Drop for Drain<'_, T, A> {\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T, A: AllocRef> ExactSizeIterator for Drain<'_, T, A> {\n+impl<T, A: Allocator> ExactSizeIterator for Drain<'_, T, A> {\n     fn is_empty(&self) -> bool {\n         self.iter.is_empty()\n     }\n }\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<T, A: AllocRef> TrustedLen for Drain<'_, T, A> {}\n+unsafe impl<T, A: Allocator> TrustedLen for Drain<'_, T, A> {}\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T, A: AllocRef> FusedIterator for Drain<'_, T, A> {}\n+impl<T, A: Allocator> FusedIterator for Drain<'_, T, A> {}\n \n /// A splicing iterator for `Vec`.\n ///\n@@ -3469,14 +3471,14 @@ impl<T, A: AllocRef> FusedIterator for Drain<'_, T, A> {}\n pub struct Splice<\n     'a,\n     I: Iterator + 'a,\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: AllocRef + 'a = Global,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator + 'a = Global,\n > {\n     drain: Drain<'a, I::Item, A>,\n     replace_with: I,\n }\n \n #[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n-impl<I: Iterator, A: AllocRef> Iterator for Splice<'_, I, A> {\n+impl<I: Iterator, A: Allocator> Iterator for Splice<'_, I, A> {\n     type Item = I::Item;\n \n     fn next(&mut self) -> Option<Self::Item> {\n@@ -3489,17 +3491,17 @@ impl<I: Iterator, A: AllocRef> Iterator for Splice<'_, I, A> {\n }\n \n #[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n-impl<I: Iterator, A: AllocRef> DoubleEndedIterator for Splice<'_, I, A> {\n+impl<I: Iterator, A: Allocator> DoubleEndedIterator for Splice<'_, I, A> {\n     fn next_back(&mut self) -> Option<Self::Item> {\n         self.drain.next_back()\n     }\n }\n \n #[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n-impl<I: Iterator, A: AllocRef> ExactSizeIterator for Splice<'_, I, A> {}\n+impl<I: Iterator, A: Allocator> ExactSizeIterator for Splice<'_, I, A> {}\n \n #[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n-impl<I: Iterator, A: AllocRef> Drop for Splice<'_, I, A> {\n+impl<I: Iterator, A: Allocator> Drop for Splice<'_, I, A> {\n     fn drop(&mut self) {\n         self.drain.by_ref().for_each(drop);\n \n@@ -3540,7 +3542,7 @@ impl<I: Iterator, A: AllocRef> Drop for Splice<'_, I, A> {\n }\n \n /// Private helper methods for `Splice::drop`\n-impl<T, A: AllocRef> Drain<'_, T, A> {\n+impl<T, A: Allocator> Drain<'_, T, A> {\n     /// The range from `self.vec.len` to `self.tail_start` contains elements\n     /// that have been moved out.\n     /// Fill that range as much as possible with new elements from the `replace_with` iterator.\n@@ -3599,7 +3601,7 @@ pub struct DrainFilter<\n     'a,\n     T,\n     F,\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: AllocRef = Global,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n > where\n     F: FnMut(&mut T) -> bool,\n {\n@@ -3620,20 +3622,20 @@ pub struct DrainFilter<\n     panic_flag: bool,\n }\n \n-impl<T, F, A: AllocRef> DrainFilter<'_, T, F, A>\n+impl<T, F, A: Allocator> DrainFilter<'_, T, F, A>\n where\n     F: FnMut(&mut T) -> bool,\n {\n     /// Returns a reference to the underlying allocator.\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     #[inline]\n-    pub fn alloc_ref(&self) -> &A {\n-        self.vec.alloc_ref()\n+    pub fn allocator(&self) -> &A {\n+        self.vec.allocator()\n     }\n }\n \n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-impl<T, F, A: AllocRef> Iterator for DrainFilter<'_, T, F, A>\n+impl<T, F, A: Allocator> Iterator for DrainFilter<'_, T, F, A>\n where\n     F: FnMut(&mut T) -> bool,\n {\n@@ -3671,19 +3673,19 @@ where\n }\n \n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-impl<T, F, A: AllocRef> Drop for DrainFilter<'_, T, F, A>\n+impl<T, F, A: Allocator> Drop for DrainFilter<'_, T, F, A>\n where\n     F: FnMut(&mut T) -> bool,\n {\n     fn drop(&mut self) {\n-        struct BackshiftOnDrop<'a, 'b, T, F, A: AllocRef>\n+        struct BackshiftOnDrop<'a, 'b, T, F, A: Allocator>\n         where\n             F: FnMut(&mut T) -> bool,\n         {\n             drain: &'b mut DrainFilter<'a, T, F, A>,\n         }\n \n-        impl<'a, 'b, T, F, A: AllocRef> Drop for BackshiftOnDrop<'a, 'b, T, F, A>\n+        impl<'a, 'b, T, F, A: Allocator> Drop for BackshiftOnDrop<'a, 'b, T, F, A>\n         where\n             F: FnMut(&mut T) -> bool,\n         {"}, {"sha": "246b341eeb3870ce6f90873c17383df0e52ac238", "filename": "library/alloc/tests/heap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/library%2Falloc%2Ftests%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/library%2Falloc%2Ftests%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fheap.rs?ref=3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a", "patch": "@@ -1,4 +1,4 @@\n-use std::alloc::{AllocRef, Global, Layout, System};\n+use std::alloc::{Allocator, Global, Layout, System};\n \n /// Issue #45955 and #62251.\n #[test]\n@@ -11,7 +11,7 @@ fn std_heap_overaligned_request() {\n     check_overalign_requests(Global)\n }\n \n-fn check_overalign_requests<T: AllocRef>(allocator: T) {\n+fn check_overalign_requests<T: Allocator>(allocator: T) {\n     for &align in &[4, 8, 16, 32] {\n         // less than and bigger than `MIN_ALIGN`\n         for &size in &[align / 2, align - 1] {\n@@ -20,7 +20,7 @@ fn check_overalign_requests<T: AllocRef>(allocator: T) {\n             unsafe {\n                 let pointers: Vec<_> = (0..iterations)\n                     .map(|_| {\n-                        allocator.alloc(Layout::from_size_align(size, align).unwrap()).unwrap()\n+                        allocator.allocate(Layout::from_size_align(size, align).unwrap()).unwrap()\n                     })\n                     .collect();\n                 for &ptr in &pointers {\n@@ -33,7 +33,7 @@ fn check_overalign_requests<T: AllocRef>(allocator: T) {\n \n                 // Clean up\n                 for &ptr in &pointers {\n-                    allocator.dealloc(\n+                    allocator.deallocate(\n                         ptr.as_non_null_ptr(),\n                         Layout::from_size_align(size, align).unwrap(),\n                     )"}, {"sha": "57c6624b64f9e6cf120bb1d1ba4a71e277a3a25a", "filename": "library/core/src/alloc/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs?ref=3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a", "patch": "@@ -19,7 +19,7 @@ const fn size_align<T>() -> (usize, usize) {\n /// even though `GlobalAlloc` requires that all memory requests\n /// be non-zero in size. A caller must either ensure that conditions\n /// like this are met, use specific allocators with looser\n-/// requirements, or use the more lenient `AllocRef` interface.)\n+/// requirements, or use the more lenient `Allocator` interface.)\n #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n #[lang = \"alloc_layout\"]"}, {"sha": "045eb58d0135a6c7f0df4ca315b525cbc2e50fc8", "filename": "library/core/src/alloc/mod.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs?ref=3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a", "patch": "@@ -40,14 +40,14 @@ impl fmt::Display for AllocError {\n     }\n }\n \n-/// An implementation of `AllocRef` can allocate, grow, shrink, and deallocate arbitrary blocks of\n+/// An implementation of `Allocator` can allocate, grow, shrink, and deallocate arbitrary blocks of\n /// data described via [`Layout`][].\n ///\n-/// `AllocRef` is designed to be implemented on ZSTs, references, or smart pointers because having\n+/// `Allocator` is designed to be implemented on ZSTs, references, or smart pointers because having\n /// an allocator like `MyAlloc([u8; N])` cannot be moved, without updating the pointers to the\n /// allocated memory.\n ///\n-/// Unlike [`GlobalAlloc`][], zero-sized allocations are allowed in `AllocRef`. If an underlying\n+/// Unlike [`GlobalAlloc`][], zero-sized allocations are allowed in `Allocator`. If an underlying\n /// allocator does not support this (like jemalloc) or return a null pointer (such as\n /// `libc::malloc`), this must be caught by the implementation.\n ///\n@@ -56,18 +56,18 @@ impl fmt::Display for AllocError {\n /// Some of the methods require that a memory block be *currently allocated* via an allocator. This\n /// means that:\n ///\n-/// * the starting address for that memory block was previously returned by [`alloc`], [`grow`], or\n+/// * the starting address for that memory block was previously returned by [`allocate`], [`grow`], or\n ///   [`shrink`], and\n ///\n /// * the memory block has not been subsequently deallocated, where blocks are either deallocated\n-///   directly by being passed to [`dealloc`] or were changed by being passed to [`grow`] or\n+///   directly by being passed to [`deallocate`] or were changed by being passed to [`grow`] or\n ///   [`shrink`] that returns `Ok`. If `grow` or `shrink` have returned `Err`, the passed pointer\n ///   remains valid.\n ///\n-/// [`alloc`]: AllocRef::alloc\n-/// [`grow`]: AllocRef::grow\n-/// [`shrink`]: AllocRef::shrink\n-/// [`dealloc`]: AllocRef::dealloc\n+/// [`allocate`]: Allocator::allocate\n+/// [`grow`]: Allocator::grow\n+/// [`shrink`]: Allocator::shrink\n+/// [`deallocate`]: Allocator::deallocate\n ///\n /// ### Memory fitting\n ///\n@@ -79,7 +79,7 @@ impl fmt::Display for AllocError {\n ///\n /// * The provided [`layout.size()`] must fall in the range `min ..= max`, where:\n ///   - `min` is the size of the layout most recently used to allocate the block, and\n-///   - `max` is the latest actual size returned from [`alloc`], [`grow`], or [`shrink`].\n+///   - `max` is the latest actual size returned from [`allocate`], [`grow`], or [`shrink`].\n ///\n /// [`layout.align()`]: Layout::align\n /// [`layout.size()`]: Layout::size\n@@ -97,7 +97,7 @@ impl fmt::Display for AllocError {\n ///\n /// [*currently allocated*]: #currently-allocated-memory\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-pub unsafe trait AllocRef {\n+pub unsafe trait Allocator {\n     /// Attempts to allocate a block of memory.\n     ///\n     /// On success, returns a [`NonNull<[u8]>`][NonNull] meeting the size and alignment guarantees of `layout`.\n@@ -118,9 +118,9 @@ pub unsafe trait AllocRef {\n     /// call the [`handle_alloc_error`] function, rather than directly invoking `panic!` or similar.\n     ///\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    fn alloc(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError>;\n+    fn allocate(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError>;\n \n-    /// Behaves like `alloc`, but also ensures that the returned memory is zero-initialized.\n+    /// Behaves like `allocate`, but also ensures that the returned memory is zero-initialized.\n     ///\n     /// # Errors\n     ///\n@@ -135,8 +135,8 @@ pub unsafe trait AllocRef {\n     /// call the [`handle_alloc_error`] function, rather than directly invoking `panic!` or similar.\n     ///\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    fn alloc_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n-        let ptr = self.alloc(layout)?;\n+    fn allocate_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n+        let ptr = self.allocate(layout)?;\n         // SAFETY: `alloc` returns a valid memory block\n         unsafe { ptr.as_non_null_ptr().as_ptr().write_bytes(0, ptr.len()) }\n         Ok(ptr)\n@@ -151,7 +151,7 @@ pub unsafe trait AllocRef {\n     ///\n     /// [*currently allocated*]: #currently-allocated-memory\n     /// [*fit*]: #memory-fitting\n-    unsafe fn dealloc(&self, ptr: NonNull<u8>, layout: Layout);\n+    unsafe fn deallocate(&self, ptr: NonNull<u8>, layout: Layout);\n \n     /// Attempts to extend the memory block.\n     ///\n@@ -200,7 +200,7 @@ pub unsafe trait AllocRef {\n             \"`new_layout.size()` must be greater than or equal to `old_layout.size()`\"\n         );\n \n-        let new_ptr = self.alloc(new_layout)?;\n+        let new_ptr = self.allocate(new_layout)?;\n \n         // SAFETY: because `new_layout.size()` must be greater than or equal to\n         // `old_layout.size()`, both the old and new memory allocation are valid for reads and\n@@ -209,7 +209,7 @@ pub unsafe trait AllocRef {\n         // safe. The safety contract for `dealloc` must be upheld by the caller.\n         unsafe {\n             ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), old_layout.size());\n-            self.dealloc(ptr, old_layout);\n+            self.deallocate(ptr, old_layout);\n         }\n \n         Ok(new_ptr)\n@@ -261,7 +261,7 @@ pub unsafe trait AllocRef {\n             \"`new_layout.size()` must be greater than or equal to `old_layout.size()`\"\n         );\n \n-        let new_ptr = self.alloc_zeroed(new_layout)?;\n+        let new_ptr = self.allocate_zeroed(new_layout)?;\n \n         // SAFETY: because `new_layout.size()` must be greater than or equal to\n         // `old_layout.size()`, both the old and new memory allocation are valid for reads and\n@@ -270,7 +270,7 @@ pub unsafe trait AllocRef {\n         // safe. The safety contract for `dealloc` must be upheld by the caller.\n         unsafe {\n             ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), old_layout.size());\n-            self.dealloc(ptr, old_layout);\n+            self.deallocate(ptr, old_layout);\n         }\n \n         Ok(new_ptr)\n@@ -323,7 +323,7 @@ pub unsafe trait AllocRef {\n             \"`new_layout.size()` must be smaller than or equal to `old_layout.size()`\"\n         );\n \n-        let new_ptr = self.alloc(new_layout)?;\n+        let new_ptr = self.allocate(new_layout)?;\n \n         // SAFETY: because `new_layout.size()` must be lower than or equal to\n         // `old_layout.size()`, both the old and new memory allocation are valid for reads and\n@@ -332,40 +332,40 @@ pub unsafe trait AllocRef {\n         // safe. The safety contract for `dealloc` must be upheld by the caller.\n         unsafe {\n             ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), new_layout.size());\n-            self.dealloc(ptr, old_layout);\n+            self.deallocate(ptr, old_layout);\n         }\n \n         Ok(new_ptr)\n     }\n \n-    /// Creates a \"by reference\" adaptor for this instance of `AllocRef`.\n+    /// Creates a \"by reference\" adaptor for this instance of `Allocator`.\n     ///\n-    /// The returned adaptor also implements `AllocRef` and will simply borrow this.\n+    /// The returned adaptor also implements `Allocator` and will simply borrow this.\n     #[inline(always)]\n     fn by_ref(&self) -> &Self {\n         self\n     }\n }\n \n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-unsafe impl<A> AllocRef for &A\n+unsafe impl<A> Allocator for &A\n where\n-    A: AllocRef + ?Sized,\n+    A: Allocator + ?Sized,\n {\n     #[inline]\n-    fn alloc(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n-        (**self).alloc(layout)\n+    fn allocate(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n+        (**self).allocate(layout)\n     }\n \n     #[inline]\n-    fn alloc_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n-        (**self).alloc_zeroed(layout)\n+    fn allocate_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n+        (**self).allocate_zeroed(layout)\n     }\n \n     #[inline]\n-    unsafe fn dealloc(&self, ptr: NonNull<u8>, layout: Layout) {\n+    unsafe fn deallocate(&self, ptr: NonNull<u8>, layout: Layout) {\n         // SAFETY: the safety contract must be upheld by the caller\n-        unsafe { (**self).dealloc(ptr, layout) }\n+        unsafe { (**self).deallocate(ptr, layout) }\n     }\n \n     #[inline]"}, {"sha": "d849008b880309ffa0a99492cdc23892379da751", "filename": "library/core/src/ptr/non_null.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs?ref=3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a", "patch": "@@ -439,11 +439,11 @@ impl<T> NonNull<[T]> {\n     /// ```rust\n     /// #![feature(allocator_api, ptr_as_uninit)]\n     ///\n-    /// use std::alloc::{AllocRef, Layout, Global};\n+    /// use std::alloc::{Allocator, Layout, Global};\n     /// use std::mem::MaybeUninit;\n     /// use std::ptr::NonNull;\n     ///\n-    /// let memory: NonNull<[u8]> = Global.alloc(Layout::new::<[u8; 32]>())?;\n+    /// let memory: NonNull<[u8]> = Global.allocate(Layout::new::<[u8; 32]>())?;\n     /// // This is safe as `memory` is valid for reads and writes for `memory.len()` many bytes.\n     /// // Note that calling `memory.as_mut()` is not allowed here as the content may be uninitialized.\n     /// # #[allow(unused_variables)]"}, {"sha": "819d57a934dc4c852bed504d551eef7d2400eef1", "filename": "library/std/src/alloc.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/library%2Fstd%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/library%2Fstd%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Falloc.rs?ref=3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a", "patch": "@@ -149,7 +149,7 @@ impl System {\n         }\n     }\n \n-    // SAFETY: Same as `AllocRef::grow`\n+    // SAFETY: Same as `Allocator::grow`\n     #[inline]\n     unsafe fn grow_impl(\n         &self,\n@@ -190,29 +190,29 @@ impl System {\n             old_size => unsafe {\n                 let new_ptr = self.alloc_impl(new_layout, zeroed)?;\n                 ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), old_size);\n-                AllocRef::dealloc(&self, ptr, old_layout);\n+                Allocator::deallocate(&self, ptr, old_layout);\n                 Ok(new_ptr)\n             },\n         }\n     }\n }\n \n-// The AllocRef impl checks the layout size to be non-zero and forwards to the GlobalAlloc impl,\n+// The Allocator impl checks the layout size to be non-zero and forwards to the GlobalAlloc impl,\n // which is in `std::sys::*::alloc`.\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-unsafe impl AllocRef for System {\n+unsafe impl Allocator for System {\n     #[inline]\n-    fn alloc(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n+    fn allocate(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n         self.alloc_impl(layout, false)\n     }\n \n     #[inline]\n-    fn alloc_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n+    fn allocate_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n         self.alloc_impl(layout, true)\n     }\n \n     #[inline]\n-    unsafe fn dealloc(&self, ptr: NonNull<u8>, layout: Layout) {\n+    unsafe fn deallocate(&self, ptr: NonNull<u8>, layout: Layout) {\n         if layout.size() != 0 {\n             // SAFETY: `layout` is non-zero in size,\n             // other conditions must be upheld by the caller\n@@ -257,7 +257,7 @@ unsafe impl AllocRef for System {\n         match new_layout.size() {\n             // SAFETY: conditions must be upheld by the caller\n             0 => unsafe {\n-                AllocRef::dealloc(&self, ptr, old_layout);\n+                Allocator::deallocate(&self, ptr, old_layout);\n                 Ok(NonNull::slice_from_raw_parts(new_layout.dangling(), 0))\n             },\n \n@@ -277,9 +277,9 @@ unsafe impl AllocRef for System {\n             // `new_ptr`. Thus, the call to `copy_nonoverlapping` is safe. The safety contract\n             // for `dealloc` must be upheld by the caller.\n             new_size => unsafe {\n-                let new_ptr = AllocRef::alloc(&self, new_layout)?;\n+                let new_ptr = Allocator::allocate(&self, new_layout)?;\n                 ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), new_size);\n-                AllocRef::dealloc(&self, ptr, old_layout);\n+                Allocator::deallocate(&self, ptr, old_layout);\n                 Ok(new_ptr)\n             },\n         }"}, {"sha": "10cbc23c427f059f19cf978747466daf16bdb4fc", "filename": "src/test/ui/allocator/custom.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs?ref=3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a", "patch": "@@ -8,9 +8,8 @@\n \n extern crate helper;\n \n-use std::alloc::{self, AllocRef, Global, Layout, System};\n+use std::alloc::{self, Allocator, Global, Layout, System};\n use std::sync::atomic::{AtomicUsize, Ordering};\n-use std::ptr::NonNull;\n \n static HITS: AtomicUsize = AtomicUsize::new(0);\n \n@@ -24,7 +23,7 @@ unsafe impl alloc::GlobalAlloc for A {\n \n     unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n         HITS.fetch_add(1, Ordering::SeqCst);\n-        AllocRef::dealloc(&System, NonNull::new(ptr).unwrap(), layout)\n+        alloc::GlobalAlloc::dealloc(&System, ptr, layout)\n     }\n }\n \n@@ -39,10 +38,10 @@ fn main() {\n     unsafe {\n         let layout = Layout::from_size_align(4, 2).unwrap();\n \n-        let memory = Global.alloc(layout.clone()).unwrap();\n+        let memory = Global.allocate(layout.clone()).unwrap();\n         helper::work_with(&memory);\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 1);\n-        Global.dealloc(memory.as_non_null_ptr(), layout);\n+        Global.deallocate(memory.as_non_null_ptr(), layout);\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 2);\n \n         let s = String::with_capacity(10);\n@@ -51,10 +50,10 @@ fn main() {\n         drop(s);\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 4);\n \n-        let memory = System.alloc(layout.clone()).unwrap();\n-        assert_eq!(HITS.load(Ordering::SeqCst), n + 4);\n+        let memory = System.allocate(layout.clone()).unwrap();\n         helper::work_with(&memory);\n-        System.dealloc(memory.as_non_null_ptr(), layout);\n+        assert_eq!(HITS.load(Ordering::SeqCst), n + 4);\n+        System.deallocate(memory.as_non_null_ptr(), layout);\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 4);\n     }\n }"}, {"sha": "edd4df75e8b836cf2af730fbac7cee71dbbc0e02", "filename": "src/test/ui/allocator/xcrate-use.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/src%2Ftest%2Fui%2Fallocator%2Fxcrate-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/src%2Ftest%2Fui%2Fallocator%2Fxcrate-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Fxcrate-use.rs?ref=3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a", "patch": "@@ -10,7 +10,7 @@\n extern crate custom;\n extern crate helper;\n \n-use std::alloc::{AllocRef, Global, Layout, System};\n+use std::alloc::{Allocator, Global, Layout, System};\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n #[global_allocator]\n@@ -21,16 +21,16 @@ fn main() {\n         let n = GLOBAL.0.load(Ordering::SeqCst);\n         let layout = Layout::from_size_align(4, 2).unwrap();\n \n-        let memory = Global.alloc(layout.clone()).unwrap();\n+        let memory = Global.allocate(layout.clone()).unwrap();\n         helper::work_with(&memory);\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 1);\n-        Global.dealloc(memory.as_non_null_ptr(), layout);\n+        Global.deallocate(memory.as_non_null_ptr(), layout);\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 2);\n \n-        let memory = System.alloc(layout.clone()).unwrap();\n+        let memory = System.allocate(layout.clone()).unwrap();\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 2);\n         helper::work_with(&memory);\n-        System.dealloc(memory.as_non_null_ptr(), layout);\n+        System.deallocate(memory.as_non_null_ptr(), layout);\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 2);\n     }\n }"}, {"sha": "4c43e6a182dc91d96be6f1c4674f0f3040713690", "filename": "src/test/ui/associated-types/defaults-wf.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-wf.stderr?ref=3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a", "patch": "@@ -6,7 +6,7 @@ LL |     type Ty = Vec<[u8]>;\n    | \n   ::: $SRC_DIR/alloc/src/vec.rs:LL:COL\n    |\n-LL | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: AllocRef = Global> {\n+LL | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n    |                - required by this bound in `Vec`\n    |\n    = help: the trait `Sized` is not implemented for `[u8]`"}, {"sha": "60a5bb9f7866694c691577de408f469102de7e41", "filename": "src/test/ui/bad/bad-sized.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/src%2Ftest%2Fui%2Fbad%2Fbad-sized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/src%2Ftest%2Fui%2Fbad%2Fbad-sized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbad%2Fbad-sized.stderr?ref=3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a", "patch": "@@ -17,7 +17,7 @@ LL |     let x: Vec<dyn Trait + Sized> = Vec::new();\n    | \n   ::: $SRC_DIR/alloc/src/vec.rs:LL:COL\n    |\n-LL | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: AllocRef = Global> {\n+LL | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n    |                - required by this bound in `Vec`\n    |\n    = help: the trait `Sized` is not implemented for `dyn Trait`"}, {"sha": "3f0f39f448b91887d652634bb8f055f60623d7ba", "filename": "src/test/ui/box/leak-alloc.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/src%2Ftest%2Fui%2Fbox%2Fleak-alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/src%2Ftest%2Fui%2Fbox%2Fleak-alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbox%2Fleak-alloc.rs?ref=3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a", "patch": "@@ -1,26 +1,26 @@\n #![feature(allocator_api)]\n \n-use std::alloc::{AllocError, AllocRef, Layout, System};\n+use std::alloc::{AllocError, Allocator, Layout, System};\n use std::ptr::NonNull;\n \n use std::boxed::Box;\n \n-struct Allocator {}\n+struct Alloc {}\n \n-unsafe impl AllocRef for Allocator {\n-    fn alloc(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n-        System.alloc(layout)\n+unsafe impl Allocator for Alloc {\n+    fn allocate(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n+        System.allocate(layout)\n     }\n \n-    unsafe fn dealloc(&self, ptr: NonNull<u8>, layout: Layout) {\n-        System.dealloc(ptr, layout)\n+    unsafe fn deallocate(&self, ptr: NonNull<u8>, layout: Layout) {\n+        System.deallocate(ptr, layout)\n     }\n }\n \n fn use_value(_: u32) {}\n \n fn main() {\n-    let alloc = Allocator {};\n+    let alloc = Alloc {};\n     let boxed = Box::new_in(10, alloc.by_ref());\n     let theref = Box::leak(boxed);\n     drop(alloc);"}, {"sha": "68551f437759176e9eec88e03cf2912428a77a62", "filename": "src/test/ui/error-codes/e0119/conflict-with-std.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/src%2Ftest%2Fui%2Ferror-codes%2Fe0119%2Fconflict-with-std.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/src%2Ftest%2Fui%2Ferror-codes%2Fe0119%2Fconflict-with-std.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2Fe0119%2Fconflict-with-std.stderr?ref=3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a", "patch": "@@ -6,7 +6,7 @@ LL | impl AsRef<Q> for Box<Q> {\n    |\n    = note: conflicting implementation in crate `alloc`:\n            - impl<T, A> AsRef<T> for Box<T, A>\n-             where A: AllocRef, T: ?Sized;\n+             where A: Allocator, T: ?Sized;\n \n error[E0119]: conflicting implementations of trait `std::convert::From<S>` for type `S`:\n   --> $DIR/conflict-with-std.rs:12:1"}, {"sha": "3f7226c79bf2afecf421bd3b4aef361b291c0d9a", "filename": "src/test/ui/issues/issue-20433.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/src%2Ftest%2Fui%2Fissues%2Fissue-20433.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/src%2Ftest%2Fui%2Fissues%2Fissue-20433.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20433.stderr?ref=3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a", "patch": "@@ -6,7 +6,7 @@ LL |     fn iceman(c: Vec<[i32]>) {}\n    | \n   ::: $SRC_DIR/alloc/src/vec.rs:LL:COL\n    |\n-LL | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: AllocRef = Global> {\n+LL | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n    |                - required by this bound in `Vec`\n    |\n    = help: the trait `Sized` is not implemented for `[i32]`"}, {"sha": "cde285f73d6b80fbeeac985dd1692931f797d10d", "filename": "src/test/ui/issues/issue-41974.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/src%2Ftest%2Fui%2Fissues%2Fissue-41974.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/src%2Ftest%2Fui%2Fissues%2Fissue-41974.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-41974.stderr?ref=3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a", "patch": "@@ -6,7 +6,7 @@ LL | impl<T> Drop for T where T: A {\n    |\n    = note: conflicting implementation in crate `alloc`:\n            - impl<T, A> Drop for Box<T, A>\n-             where A: AllocRef, T: ?Sized;\n+             where A: Allocator, T: ?Sized;\n    = note: downstream crates may implement trait `A` for type `std::boxed::Box<_, _>`\n \n error[E0120]: the `Drop` trait may only be implemented for structs, enums, and unions"}, {"sha": "92d98c16c60d8a363dfb79282c319fb8ebeea4e1", "filename": "src/test/ui/realloc-16687.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/src%2Ftest%2Fui%2Frealloc-16687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/src%2Ftest%2Fui%2Frealloc-16687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frealloc-16687.rs?ref=3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a", "patch": "@@ -7,7 +7,7 @@\n #![feature(allocator_api)]\n #![feature(slice_ptr_get)]\n \n-use std::alloc::{handle_alloc_error, AllocRef, Global, Layout};\n+use std::alloc::{handle_alloc_error, Allocator, Global, Layout};\n use std::ptr::{self, NonNull};\n \n fn main() {\n@@ -42,7 +42,7 @@ unsafe fn test_triangle() -> bool {\n             println!(\"allocate({:?})\", layout);\n         }\n \n-        let ptr = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n+        let ptr = Global.allocate(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n \n         if PRINT {\n             println!(\"allocate({:?}) = {:?}\", layout, ptr);\n@@ -56,7 +56,7 @@ unsafe fn test_triangle() -> bool {\n             println!(\"deallocate({:?}, {:?}\", ptr, layout);\n         }\n \n-        Global.dealloc(NonNull::new_unchecked(ptr), layout);\n+        Global.deallocate(NonNull::new_unchecked(ptr), layout);\n     }\n \n     unsafe fn reallocate(ptr: *mut u8, old: Layout, new: Layout) -> *mut u8 {"}, {"sha": "9d0ca76e4095d3739c707c15ac436e2faf0a033b", "filename": "src/test/ui/regions/regions-mock-codegen.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/src%2Ftest%2Fui%2Fregions%2Fregions-mock-codegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/src%2Ftest%2Fui%2Fregions%2Fregions-mock-codegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-mock-codegen.rs?ref=3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a", "patch": "@@ -4,7 +4,7 @@\n // pretty-expanded FIXME #23616\n #![feature(allocator_api)]\n \n-use std::alloc::{handle_alloc_error, AllocRef, Global, Layout};\n+use std::alloc::{handle_alloc_error, Allocator, Global, Layout};\n use std::ptr::NonNull;\n \n struct arena(());\n@@ -22,23 +22,23 @@ struct Ccx {\n     x: isize,\n }\n \n-fn alloc(_bcx: &arena) -> &Bcx<'_> {\n+fn allocate(_bcx: &arena) -> &Bcx<'_> {\n     unsafe {\n         let layout = Layout::new::<Bcx>();\n-        let ptr = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n+        let ptr = Global.allocate(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n         &*(ptr.as_ptr() as *const _)\n     }\n }\n \n fn h<'a>(bcx: &'a Bcx<'a>) -> &'a Bcx<'a> {\n-    return alloc(bcx.fcx.arena);\n+    return allocate(bcx.fcx.arena);\n }\n \n fn g(fcx: &Fcx) {\n     let bcx = Bcx { fcx };\n     let bcx2 = h(&bcx);\n     unsafe {\n-        Global.dealloc(NonNull::new_unchecked(bcx2 as *const _ as *mut _), Layout::new::<Bcx>());\n+        Global.deallocate(NonNull::new_unchecked(bcx2 as *const _ as *mut _), Layout::new::<Bcx>());\n     }\n }\n "}, {"sha": "09cbb8753387af8e954fcfea0556d1cd3b81e215", "filename": "src/test/ui/unique-object-noncopyable.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/src%2Ftest%2Fui%2Funique-object-noncopyable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/src%2Ftest%2Fui%2Funique-object-noncopyable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funique-object-noncopyable.stderr?ref=3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a", "patch": "@@ -22,7 +22,7 @@ LL |       fn clone(&self) -> Self;\n    |\n LL | / pub struct Box<\n LL | |     T: ?Sized,\n-LL | |     #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: AllocRef = Global,\n+LL | |     #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n LL | | >(Unique<T>, A);\n    | |________________- doesn't satisfy `Box<dyn Foo>: Clone`\n    |"}, {"sha": "bc081024182af0134f098ff6df49ac313a569acf", "filename": "src/test/ui/unique-pinned-nocopy.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/src%2Ftest%2Fui%2Funique-pinned-nocopy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a/src%2Ftest%2Fui%2Funique-pinned-nocopy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funique-pinned-nocopy.stderr?ref=3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a", "patch": "@@ -19,7 +19,7 @@ LL |       fn clone(&self) -> Self;\n    |\n LL | / pub struct Box<\n LL | |     T: ?Sized,\n-LL | |     #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: AllocRef = Global,\n+LL | |     #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n LL | | >(Unique<T>, A);\n    | |________________- doesn't satisfy `Box<R>: Clone`\n    |"}]}