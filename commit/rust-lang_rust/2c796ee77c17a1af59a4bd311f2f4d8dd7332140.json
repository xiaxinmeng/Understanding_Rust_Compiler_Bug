{"sha": "2c796ee77c17a1af59a4bd311f2f4d8dd7332140", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjNzk2ZWU3N2MxN2ExYWY1OWE0YmQzMTFmMmY0ZDhkZDczMzIxNDA=", "commit": {"author": {"name": "Martin Habovstiak", "email": "martin.habovstiak@gmail.com", "date": "2019-12-24T15:08:30Z"}, "committer": {"name": "Martin Habovstiak", "email": "martin.habovstiak@gmail.com", "date": "2019-12-26T19:18:31Z"}, "message": "Use NonNull in slice::Iter and slice::IterMut.\n\n`ptr` of `slice::Iter` and `slice::IterMut` can never be null, but this\nfact wasn't exploited for layout optimizations. By changing `ptr` from\n`*<mutability> T` to `NonNull<T>`, the compiler can now optimize layout\nof `Option<Iter<'a, T>>`.", "tree": {"sha": "d88bed8a1b9be30059c3d761da30efcdecb49d36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d88bed8a1b9be30059c3d761da30efcdecb49d36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c796ee77c17a1af59a4bd311f2f4d8dd7332140", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c796ee77c17a1af59a4bd311f2f4d8dd7332140", "html_url": "https://github.com/rust-lang/rust/commit/2c796ee77c17a1af59a4bd311f2f4d8dd7332140", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c796ee77c17a1af59a4bd311f2f4d8dd7332140/comments", "author": {"login": "Kixunil", "id": 1178779, "node_id": "MDQ6VXNlcjExNzg3Nzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1178779?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kixunil", "html_url": "https://github.com/Kixunil", "followers_url": "https://api.github.com/users/Kixunil/followers", "following_url": "https://api.github.com/users/Kixunil/following{/other_user}", "gists_url": "https://api.github.com/users/Kixunil/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kixunil/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kixunil/subscriptions", "organizations_url": "https://api.github.com/users/Kixunil/orgs", "repos_url": "https://api.github.com/users/Kixunil/repos", "events_url": "https://api.github.com/users/Kixunil/events{/privacy}", "received_events_url": "https://api.github.com/users/Kixunil/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kixunil", "id": 1178779, "node_id": "MDQ6VXNlcjExNzg3Nzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1178779?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kixunil", "html_url": "https://github.com/Kixunil", "followers_url": "https://api.github.com/users/Kixunil/followers", "following_url": "https://api.github.com/users/Kixunil/following{/other_user}", "gists_url": "https://api.github.com/users/Kixunil/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kixunil/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kixunil/subscriptions", "organizations_url": "https://api.github.com/users/Kixunil/orgs", "repos_url": "https://api.github.com/users/Kixunil/repos", "events_url": "https://api.github.com/users/Kixunil/events{/privacy}", "received_events_url": "https://api.github.com/users/Kixunil/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed33453a37d602f34cc40c205f9b9b8a8aff88b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed33453a37d602f34cc40c205f9b9b8a8aff88b5", "html_url": "https://github.com/rust-lang/rust/commit/ed33453a37d602f34cc40c205f9b9b8a8aff88b5"}], "stats": {"total": 47, "additions": 25, "deletions": 22}, "files": [{"sha": "9b4d201573238379000589ce7a39e6ac4382e1a1", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/2c796ee77c17a1af59a4bd311f2f4d8dd7332140/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c796ee77c17a1af59a4bd311f2f4d8dd7332140/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=2c796ee77c17a1af59a4bd311f2f4d8dd7332140", "patch": "@@ -34,7 +34,7 @@ use crate::mem;\n use crate::ops::{self, FnMut, Range};\n use crate::option::Option;\n use crate::option::Option::{None, Some};\n-use crate::ptr;\n+use crate::ptr::{self, NonNull};\n use crate::result::Result;\n use crate::result::Result::{Err, Ok};\n \n@@ -628,7 +628,7 @@ impl<T> [T] {\n                 ptr.add(self.len())\n             };\n \n-            Iter { ptr, end, _marker: marker::PhantomData }\n+            Iter { ptr: NonNull::new_unchecked(ptr as *mut T), end, _marker: marker::PhantomData }\n         }\n     }\n \n@@ -656,7 +656,7 @@ impl<T> [T] {\n                 ptr.add(self.len())\n             };\n \n-            IterMut { ptr, end, _marker: marker::PhantomData }\n+            IterMut { ptr: NonNull::new_unchecked(ptr), end, _marker: marker::PhantomData }\n         }\n     }\n \n@@ -3095,7 +3095,7 @@ macro_rules! is_empty {\n     // The way we encode the length of a ZST iterator, this works both for ZST\n     // and non-ZST.\n     ($self: ident) => {\n-        $self.ptr == $self.end\n+        $self.ptr.as_ptr() as *const T == $self.end\n     };\n }\n // To get rid of some bounds checks (see `position`), we compute the length in a somewhat\n@@ -3105,17 +3105,17 @@ macro_rules! len {\n         #![allow(unused_unsafe)] // we're sometimes used within an unsafe block\n \n         let start = $self.ptr;\n-        let size = size_from_ptr(start);\n+        let size = size_from_ptr(start.as_ptr());\n         if size == 0 {\n             // This _cannot_ use `unchecked_sub` because we depend on wrapping\n             // to represent the length of long ZST slice iterators.\n-            ($self.end as usize).wrapping_sub(start as usize)\n+            ($self.end as usize).wrapping_sub(start.as_ptr() as usize)\n         } else {\n             // We know that `start <= end`, so can do better than `offset_from`,\n             // which needs to deal in signed.  By setting appropriate flags here\n             // we can tell LLVM this, which helps it remove bounds checks.\n             // SAFETY: By the type invariant, `start <= end`\n-            let diff = unsafe { unchecked_sub($self.end as usize, start as usize) };\n+            let diff = unsafe { unchecked_sub($self.end as usize, start.as_ptr() as usize) };\n             // By also telling LLVM that the pointers are apart by an exact\n             // multiple of the type size, it can optimize `len() == 0` down to\n             // `start == end` instead of `(end - start) < size`.\n@@ -3161,7 +3161,7 @@ macro_rules! iterator {\n             // Helper function for creating a slice from the iterator.\n             #[inline(always)]\n             fn make_slice(&self) -> &'a [T] {\n-                unsafe { from_raw_parts(self.ptr, len!(self)) }\n+                unsafe { from_raw_parts(self.ptr.as_ptr(), len!(self)) }\n             }\n \n             // Helper function for moving the start of the iterator forwards by `offset` elements,\n@@ -3171,10 +3171,10 @@ macro_rules! iterator {\n             unsafe fn post_inc_start(&mut self, offset: isize) -> * $raw_mut T {\n                 if mem::size_of::<T>() == 0 {\n                     zst_shrink!(self, offset);\n-                    self.ptr\n+                    self.ptr.as_ptr()\n                 } else {\n-                    let old = self.ptr;\n-                    self.ptr = self.ptr.offset(offset);\n+                    let old = self.ptr.as_ptr();\n+                    self.ptr = NonNull::new_unchecked(self.ptr.as_ptr().offset(offset));\n                     old\n                 }\n             }\n@@ -3186,7 +3186,7 @@ macro_rules! iterator {\n             unsafe fn pre_dec_end(&mut self, offset: isize) -> * $raw_mut T {\n                 if mem::size_of::<T>() == 0 {\n                     zst_shrink!(self, offset);\n-                    self.ptr\n+                    self.ptr.as_ptr()\n                 } else {\n                     self.end = self.end.offset(-offset);\n                     self.end\n@@ -3215,7 +3215,7 @@ macro_rules! iterator {\n             fn next(&mut self) -> Option<$elem> {\n                 // could be implemented with slices, but this avoids bounds checks\n                 unsafe {\n-                    assume(!self.ptr.is_null());\n+                    assume(!self.ptr.as_ptr().is_null());\n                     if mem::size_of::<T>() != 0 {\n                         assume(!self.end.is_null());\n                     }\n@@ -3245,9 +3245,12 @@ macro_rules! iterator {\n                     if mem::size_of::<T>() == 0 {\n                         // We have to do it this way as `ptr` may never be 0, but `end`\n                         // could be (due to wrapping).\n-                        self.end = self.ptr;\n+                        self.end = self.ptr.as_ptr();\n                     } else {\n-                        self.ptr = self.end;\n+                        unsafe {\n+                            // End can't be 0 if T isn't ZST because ptr isn't 0 and end >= ptr\n+                            self.ptr = NonNull::new_unchecked(self.end as *mut T);\n+                        }\n                     }\n                     return None;\n                 }\n@@ -3308,7 +3311,7 @@ macro_rules! iterator {\n             fn next_back(&mut self) -> Option<$elem> {\n                 // could be implemented with slices, but this avoids bounds checks\n                 unsafe {\n-                    assume(!self.ptr.is_null());\n+                    assume(!self.ptr.as_ptr().is_null());\n                     if mem::size_of::<T>() != 0 {\n                         assume(!self.end.is_null());\n                     }\n@@ -3324,7 +3327,7 @@ macro_rules! iterator {\n             fn nth_back(&mut self, n: usize) -> Option<$elem> {\n                 if n >= len!(self) {\n                     // This iterator is now empty.\n-                    self.end = self.ptr;\n+                    self.end = self.ptr.as_ptr();\n                     return None;\n                 }\n                 // We are in bounds. `pre_dec_end` does the right thing even for ZSTs.\n@@ -3365,7 +3368,7 @@ macro_rules! iterator {\n /// [slices]: ../../std/primitive.slice.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n-    ptr: *const T,\n+    ptr: NonNull<T>,\n     end: *const T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that\n     // ptr == end is a quick test for the Iterator being empty, that works\n     // for both ZST and non-ZST.\n@@ -3467,7 +3470,7 @@ impl<T> AsRef<[T]> for Iter<'_, T> {\n /// [slices]: ../../std/primitive.slice.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> {\n-    ptr: *mut T,\n+    ptr: NonNull<T>,\n     end: *mut T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that\n     // ptr == end is a quick test for the Iterator being empty, that works\n     // for both ZST and non-ZST.\n@@ -3522,7 +3525,7 @@ impl<'a, T> IterMut<'a, T> {\n     /// ```\n     #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n     pub fn into_slice(self) -> &'a mut [T] {\n-        unsafe { from_raw_parts_mut(self.ptr, len!(self)) }\n+        unsafe { from_raw_parts_mut(self.ptr.as_ptr(), len!(self)) }\n     }\n \n     /// Views the underlying data as a subslice of the original data.\n@@ -5682,7 +5685,7 @@ impl_marker_for!(BytewiseEquality,\n #[doc(hidden)]\n unsafe impl<'a, T> TrustedRandomAccess for Iter<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a T {\n-        &*self.ptr.add(i)\n+        &*self.ptr.as_ptr().add(i)\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -5692,7 +5695,7 @@ unsafe impl<'a, T> TrustedRandomAccess for Iter<'a, T> {\n #[doc(hidden)]\n unsafe impl<'a, T> TrustedRandomAccess for IterMut<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut T {\n-        &mut *self.ptr.add(i)\n+        &mut *self.ptr.as_ptr().add(i)\n     }\n     fn may_have_side_effect() -> bool {\n         false"}]}