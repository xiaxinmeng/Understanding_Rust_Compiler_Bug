{"sha": "903851f785aaa01b5ae2e9648a2fd1256eea2ba5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwMzg1MWY3ODVhYWEwMWI1YWUyZTk2NDhhMmZkMTI1NmVlYTJiYTU=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-08-01T19:38:02Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-08-03T22:00:27Z"}, "message": "Highlight closure spans for borrow and initialization errors", "tree": {"sha": "1d274cf1f414f9728f2782a02733c6251331725e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d274cf1f414f9728f2782a02733c6251331725e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/903851f785aaa01b5ae2e9648a2fd1256eea2ba5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/903851f785aaa01b5ae2e9648a2fd1256eea2ba5", "html_url": "https://github.com/rust-lang/rust/commit/903851f785aaa01b5ae2e9648a2fd1256eea2ba5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/903851f785aaa01b5ae2e9648a2fd1256eea2ba5/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e031b0907e90fc083e4f1f7c6a7f62e98325a9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e031b0907e90fc083e4f1f7c6a7f62e98325a9a", "html_url": "https://github.com/rust-lang/rust/commit/7e031b0907e90fc083e4f1f7c6a7f62e98325a9a"}], "stats": {"total": 603, "additions": 403, "deletions": 200}, "files": [{"sha": "aabed6686858fddf6fe579d235b019a4130454f0", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 359, "deletions": 160, "changes": 519, "blob_url": "https://github.com/rust-lang/rust/blob/903851f785aaa01b5ae2e9648a2fd1256eea2ba5/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/903851f785aaa01b5ae2e9648a2fd1256eea2ba5/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=903851f785aaa01b5ae2e9648a2fd1256eea2ba5", "patch": "@@ -10,13 +10,14 @@\n \n use borrow_check::WriteKind;\n use rustc::middle::region::ScopeTree;\n+use rustc::mir::VarBindingForm;\n use rustc::mir::{BindingForm, BorrowKind, ClearCrossCrate, Field, Local};\n use rustc::mir::{LocalDecl, LocalKind, Location, Operand, Place};\n use rustc::mir::{ProjectionElem, Rvalue, Statement, StatementKind};\n-use rustc::mir::VarBindingForm;\n use rustc::ty;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::sync::Lrc;\n+use rustc_errors::DiagnosticBuilder;\n use syntax_pos::Span;\n \n use super::borrow_set::BorrowData;\n@@ -30,12 +31,17 @@ use util::borrowck_errors::{BorrowckErrors, Origin};\n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     pub(super) fn report_use_of_moved_or_uninitialized(\n         &mut self,\n-        _context: Context,\n+        context: Context,\n         desired_action: InitializationRequiringAction,\n         (place, span): (&Place<'tcx>, Span),\n         mpi: MovePathIndex,\n         curr_move_out: &FlowAtLocation<MovingOutStatements<'_, 'gcx, 'tcx>>,\n     ) {\n+        let use_spans = self\n+            .move_spans(place, context.loc)\n+            .or_else(|| self.borrow_spans(span, context.loc));\n+        let span = use_spans.args_or_use();\n+\n         let mois = self.move_data.path_map[mpi]\n             .iter()\n             .filter(|moi| curr_move_out.contains(moi))\n@@ -58,16 +64,21 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 Some(name) => format!(\"`{}`\", name),\n                 None => \"value\".to_owned(),\n             };\n-            let mut err = self.tcx\n-                .cannot_act_on_uninitialized_variable(\n-                    span,\n-                    desired_action.as_noun(),\n-                    &self\n-                        .describe_place_with_options(place, IncludingDowncast(true))\n-                        .unwrap_or(\"_\".to_owned()),\n-                    Origin::Mir,\n-                );\n+            let mut err = self.tcx.cannot_act_on_uninitialized_variable(\n+                span,\n+                desired_action.as_noun(),\n+                &self\n+                    .describe_place_with_options(place, IncludingDowncast(true))\n+                    .unwrap_or(\"_\".to_owned()),\n+                Origin::Mir,\n+            );\n             err.span_label(span, format!(\"use of possibly uninitialized {}\", item_msg));\n+\n+            use_spans.var_span_label(\n+                &mut err,\n+                format!(\"{} occurs due to use in closure\", desired_action.as_noun()),\n+            );\n+\n             err.buffer(&mut self.errors_buffer);\n         } else {\n             let msg = \"\"; //FIXME: add \"partially \" or \"collaterally \"\n@@ -82,11 +93,18 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             let mut is_loop_move = false;\n             for moi in &mois {\n-                let move_msg = \"\"; //FIXME: add \" (into closure)\"\n-                let move_span = self\n-                    .mir\n-                    .source_info(self.move_data.moves[**moi].source)\n-                    .span;\n+                let move_out = self.move_data.moves[**moi];\n+                let moved_place = &self.move_data.move_paths[move_out.path].place;\n+\n+                let move_spans = self.move_spans(moved_place, move_out.source);\n+                let move_span = move_spans.args_or_use();\n+\n+                let move_msg = if move_spans.for_closure() {\n+                    \" into closure\"\n+                } else {\n+                    \"\"\n+                };\n+\n                 if span == move_span {\n                     err.span_label(\n                         span,\n@@ -95,8 +113,15 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     is_loop_move = true;\n                 } else {\n                     err.span_label(move_span, format!(\"value moved{} here\", move_msg));\n+                    move_spans.var_span_label(&mut err, \"variable moved due to use in closure\");\n                 };\n             }\n+\n+            use_spans.var_span_label(\n+                &mut err,\n+                format!(\"{} occurs due to use in closure\", desired_action.as_noun()),\n+            );\n+\n             if !is_loop_move {\n                 err.span_label(\n                     span,\n@@ -150,7 +175,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     pub(super) fn report_move_out_while_borrowed(\n         &mut self,\n         context: Context,\n-        (place, span): (&Place<'tcx>, Span),\n+        (place, _span): (&Place<'tcx>, Span),\n         borrow: &BorrowData<'tcx>,\n     ) {\n         let tcx = self.tcx;\n@@ -162,109 +187,64 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Some(name) => format!(\"`{}`\", name),\n             None => \"value\".to_owned(),\n         };\n+\n+        let borrow_spans = self.retrieve_borrow_spans(borrow);\n+        let borrow_span = borrow_spans.args_or_use();\n+\n+        let move_spans = self.move_spans(place, context.loc);\n+        let span = move_spans.args_or_use();\n+\n         let mut err = tcx.cannot_move_when_borrowed(\n             span,\n             &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n             Origin::Mir,\n         );\n-        err.span_label(\n-            self.retrieve_borrow_span(borrow),\n-            format!(\"borrow of {} occurs here\", borrow_msg),\n-        );\n+        err.span_label(borrow_span, format!(\"borrow of {} occurs here\", borrow_msg));\n         err.span_label(span, format!(\"move out of {} occurs here\", value_msg));\n+\n+        borrow_spans.var_span_label(&mut err, \"borrow occurs due to use in closure\");\n+\n+        move_spans.var_span_label(&mut err, \"move occurs due to use in closure\");\n+\n         self.explain_why_borrow_contains_point(context, borrow, None, &mut err);\n         err.buffer(&mut self.errors_buffer);\n     }\n \n     pub(super) fn report_use_while_mutably_borrowed(\n         &mut self,\n         context: Context,\n-        (place, span): (&Place<'tcx>, Span),\n+        (place, _span): (&Place<'tcx>, Span),\n         borrow: &BorrowData<'tcx>,\n     ) {\n         let tcx = self.tcx;\n+\n+        let borrow_spans = self.retrieve_borrow_spans(borrow);\n+        let borrow_span = borrow_spans.args_or_use();\n+\n+        // Conflicting borrows are reported separately, so only check for move\n+        // captures.\n+        let use_spans = self.move_spans(place, context.loc);\n+        let span = use_spans.var_or_use();\n+\n         let mut err = tcx.cannot_use_when_mutably_borrowed(\n             span,\n             &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n-            self.retrieve_borrow_span(borrow),\n+            borrow_span,\n             &self\n                 .describe_place(&borrow.borrowed_place)\n                 .unwrap_or(\"_\".to_owned()),\n             Origin::Mir,\n         );\n \n-        self.explain_why_borrow_contains_point(context, borrow, None, &mut err);\n-        err.buffer(&mut self.errors_buffer);\n-    }\n-\n-    /// Finds the span of arguments of a closure (within `maybe_closure_span`) and its usage of\n-    /// the local assigned at `location`.\n-    /// This is done by searching in statements succeeding `location`\n-    /// and originating from `maybe_closure_span`.\n-    pub(super) fn find_closure_span(\n-        &self,\n-        maybe_closure_span: Span,\n-        location: Location,\n-    ) -> Option<(Span, Span)> {\n-        use rustc::hir::ExprKind::Closure;\n-        use rustc::mir::AggregateKind;\n-\n-        let local = match self.mir[location.block]\n-            .statements\n-            .get(location.statement_index)\n-        {\n-            Some(&Statement {\n-                kind: StatementKind::Assign(Place::Local(local), _),\n-                ..\n-            }) => local,\n-            _ => return None,\n-        };\n-\n-        for stmt in &self.mir[location.block].statements[location.statement_index + 1..] {\n-            if maybe_closure_span != stmt.source_info.span {\n-                break;\n-            }\n+        borrow_spans.var_span_label(&mut err, {\n+            let place = &borrow.borrowed_place;\n+            let desc_place = self.describe_place(place).unwrap_or(\"_\".to_owned());\n \n-            if let StatementKind::Assign(_, Rvalue::Aggregate(ref kind, ref places)) = stmt.kind {\n-                if let AggregateKind::Closure(def_id, _) = **kind {\n-                    debug!(\"find_closure_span: found closure {:?}\", places);\n+            format!(\"borrow occurs due to use of `{}` in closure\", desc_place)\n+        });\n \n-                    return if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n-                        let args_span = if let Closure(_, _, _, span, _) =\n-                            self.tcx.hir.expect_expr(node_id).node\n-                        {\n-                            span\n-                        } else {\n-                            return None;\n-                        };\n-\n-                        self.tcx\n-                            .with_freevars(node_id, |freevars| {\n-                                for (v, place) in freevars.iter().zip(places) {\n-                                    match *place {\n-                                        Operand::Copy(Place::Local(l))\n-                                        | Operand::Move(Place::Local(l)) if local == l =>\n-                                        {\n-                                            debug!(\n-                                                \"find_closure_span: found captured local {:?}\",\n-                                                l\n-                                            );\n-                                            return Some(v.span);\n-                                        }\n-                                        _ => {}\n-                                    }\n-                                }\n-                                None\n-                            })\n-                            .map(|var_span| (args_span, var_span))\n-                    } else {\n-                        None\n-                    };\n-                }\n-            }\n-        }\n-\n-        None\n+        self.explain_why_borrow_contains_point(context, borrow, None, &mut err);\n+        err.buffer(&mut self.errors_buffer);\n     }\n \n     pub(super) fn report_conflicting_borrow(\n@@ -274,14 +254,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         gen_borrow_kind: BorrowKind,\n         issued_borrow: &BorrowData<'tcx>,\n     ) {\n-        let issued_span = self.retrieve_borrow_span(issued_borrow);\n+        let issued_spans = self.retrieve_borrow_spans(issued_borrow);\n+        let issued_span = issued_spans.args_or_use();\n \n-        let new_closure_span = self.find_closure_span(span, context.loc);\n-        let span = new_closure_span.map(|(args, _)| args).unwrap_or(span);\n-        let old_closure_span = self.find_closure_span(issued_span, issued_borrow.reserve_location);\n-        let issued_span = old_closure_span\n-            .map(|(args, _)| args)\n-            .unwrap_or(issued_span);\n+        let borrow_spans = self.borrow_spans(span, context.loc);\n+        let span = borrow_spans.args_or_use();\n \n         let desc_place = self.describe_place(place).unwrap_or(\"_\".to_owned());\n         let tcx = self.tcx;\n@@ -368,23 +345,28 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             (BorrowKind::Shared, _, _, BorrowKind::Shared, _, _) => unreachable!(),\n         };\n \n-        if let Some((_, var_span)) = old_closure_span {\n-            let place = &issued_borrow.borrowed_place;\n-            let desc_place = self.describe_place(place).unwrap_or(\"_\".to_owned());\n-\n-            err.span_label(\n-                var_span,\n+        if issued_spans == borrow_spans {\n+            borrow_spans.var_span_label(\n+                &mut err,\n                 format!(\n-                    \"previous borrow occurs due to use of `{}` in closure\",\n+                    \"borrows occur due to use of `{}` in closure\",\n                     desc_place\n                 ),\n             );\n-        }\n+        } else {\n+            let borrow_place = &issued_borrow.borrowed_place;\n+            let borrow_place_desc = self.describe_place(borrow_place).unwrap_or(\"_\".to_owned());\n+            issued_spans.var_span_label(\n+                &mut err,\n+                format!(\n+                    \"first borrow occurs due to use of `{}` in closure\",\n+                    borrow_place_desc\n+                ),\n+            );\n \n-        if let Some((_, var_span)) = new_closure_span {\n-            err.span_label(\n-                var_span,\n-                format!(\"borrow occurs due to use of `{}` in closure\", desc_place),\n+            borrow_spans.var_span_label(\n+                &mut err,\n+                format!(\"second borrow occurs due to use of `{}` in closure\", desc_place),\n             );\n         }\n \n@@ -407,7 +389,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             .last()\n             .unwrap();\n \n-        let borrow_span = self.mir.source_info(borrow.reserve_location).span;\n+        let borrow_spans = self.retrieve_borrow_spans(borrow);\n+        let borrow_span = borrow_spans.var_or_use();\n+\n         let proper_span = match *root_place {\n             Place::Local(local) => self.mir.local_decls[local].source_info.span,\n             _ => drop_span,\n@@ -427,30 +411,30 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         self.access_place_error_reported\n             .insert((root_place.clone(), borrow_span));\n \n-        match &self.describe_place(&borrow.borrowed_place) {\n-            Some(name) => {\n-                self.report_local_value_does_not_live_long_enough(\n-                    context,\n-                    name,\n-                    &scope_tree,\n-                    &borrow,\n-                    drop_span,\n-                    borrow_span,\n-                    proper_span,\n-                    kind.map(|k| (k, place_span.0)),\n-                );\n-            }\n-            None => {\n-                self.report_temporary_value_does_not_live_long_enough(\n-                    context,\n-                    &scope_tree,\n-                    &borrow,\n-                    drop_span,\n-                    borrow_span,\n-                    proper_span,\n-                );\n-            }\n-        }\n+        let mut err = match &self.describe_place(&borrow.borrowed_place) {\n+            Some(name) => self.report_local_value_does_not_live_long_enough(\n+                context,\n+                name,\n+                &scope_tree,\n+                &borrow,\n+                drop_span,\n+                borrow_span,\n+                proper_span,\n+                kind.map(|k| (k, place_span.0)),\n+            ),\n+            None => self.report_temporary_value_does_not_live_long_enough(\n+                context,\n+                &scope_tree,\n+                &borrow,\n+                drop_span,\n+                borrow_span,\n+                proper_span,\n+            ),\n+        };\n+\n+        borrow_spans.args_span_label(&mut err, \"value captured here\");\n+\n+        err.buffer(&mut self.errors_buffer);\n     }\n \n     fn report_local_value_does_not_live_long_enough(\n@@ -463,7 +447,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         borrow_span: Span,\n         _proper_span: Span,\n         kind_place: Option<(WriteKind, &Place<'tcx>)>,\n-    ) {\n+    ) -> DiagnosticBuilder<'cx> {\n         debug!(\n             \"report_local_value_does_not_live_long_enough(\\\n              {:?}, {:?}, {:?}, {:?}, {:?}, {:?}\\\n@@ -481,7 +465,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         );\n \n         self.explain_why_borrow_contains_point(context, borrow, kind_place, &mut err);\n-        err.buffer(&mut self.errors_buffer);\n+        err\n     }\n \n     fn report_temporary_value_does_not_live_long_enough(\n@@ -492,7 +476,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         drop_span: Span,\n         _borrow_span: Span,\n         proper_span: Span,\n-    ) {\n+    ) -> DiagnosticBuilder<'cx> {\n         debug!(\n             \"report_temporary_value_does_not_live_long_enough(\\\n              {:?}, {:?}, {:?}, {:?}, {:?}\\\n@@ -507,7 +491,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         err.span_label(drop_span, \"temporary value only lives until here\");\n \n         self.explain_why_borrow_contains_point(context, borrow, None, &mut err);\n-        err.buffer(&mut self.errors_buffer);\n+        err\n     }\n \n     pub(super) fn report_illegal_mutation_of_borrowed(\n@@ -516,14 +500,19 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         (place, span): (&Place<'tcx>, Span),\n         loan: &BorrowData<'tcx>,\n     ) {\n+        let loan_spans = self.retrieve_borrow_spans(loan);\n+        let loan_span = loan_spans.args_or_use();\n+\n         let tcx = self.tcx;\n         let mut err = tcx.cannot_assign_to_borrowed(\n             span,\n-            self.retrieve_borrow_span(loan),\n+            loan_span,\n             &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n             Origin::Mir,\n         );\n \n+        loan_spans.var_span_label(&mut err, \"borrow occurs due to use in closure\");\n+\n         self.explain_why_borrow_contains_point(context, loan, None, &mut err);\n \n         err.buffer(&mut self.errors_buffer);\n@@ -556,12 +545,22 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // PATTERN;) then make the error refer to that local, rather than the\n         // place being assigned later.\n         let (place_description, assigned_span) = match local_decl {\n-            Some(LocalDecl { is_user_variable: Some(ClearCrossCrate::Clear), .. })\n-            | Some(LocalDecl { is_user_variable: Some(ClearCrossCrate::Set(\n-                BindingForm::Var(VarBindingForm {\n-                    opt_match_place: None, ..\n-            }))), ..})\n-            | Some(LocalDecl { is_user_variable: None, .. })\n+            Some(LocalDecl {\n+                is_user_variable: Some(ClearCrossCrate::Clear),\n+                ..\n+            })\n+            | Some(LocalDecl {\n+                is_user_variable:\n+                    Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+                        opt_match_place: None,\n+                        ..\n+                    }))),\n+                ..\n+            })\n+            | Some(LocalDecl {\n+                is_user_variable: None,\n+                ..\n+            })\n             | None => (self.describe_place(place), assigned_span),\n             Some(decl) => (self.describe_place(err_place), decl.source_info.span),\n         };\n@@ -647,8 +646,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Place::Projection(ref proj) => {\n                 match proj.elem {\n                     ProjectionElem::Deref => {\n-                        let upvar_field_projection = place.is_upvar_field_projection(\n-                            self.mir, &self.tcx);\n+                        let upvar_field_projection =\n+                            place.is_upvar_field_projection(self.mir, &self.tcx);\n                         if let Some(field) = upvar_field_projection {\n                             let var_index = field.index();\n                             let name = self.mir.upvar_decls[var_index].debug_name.to_string();\n@@ -666,8 +665,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     &including_downcast,\n                                 )?;\n                             } else if let Place::Local(local) = proj.base {\n-                                if let Some(ClearCrossCrate::Set(BindingForm::RefForGuard))\n-                                    = self.mir.local_decls[local].is_user_variable {\n+                                if let Some(ClearCrossCrate::Set(BindingForm::RefForGuard)) =\n+                                    self.mir.local_decls[local].is_user_variable\n+                                {\n                                     self.append_place_to_string(\n                                         &proj.base,\n                                         buf,\n@@ -708,8 +708,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     ProjectionElem::Field(field, _ty) => {\n                         autoderef = true;\n \n-                        let upvar_field_projection = place.is_upvar_field_projection(\n-                            self.mir, &self.tcx);\n+                        let upvar_field_projection =\n+                            place.is_upvar_field_projection(self.mir, &self.tcx);\n                         if let Some(field) = upvar_field_projection {\n                             let var_index = field.index();\n                             let name = self.mir.upvar_decls[var_index].debug_name.to_string();\n@@ -810,7 +810,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 ty::TyAdt(def, _) => if def.is_enum() {\n                     field.index().to_string()\n                 } else {\n-                    def.non_enum_variant().fields[field.index()].ident.to_string()\n+                    def.non_enum_variant().fields[field.index()]\n+                        .ident\n+                        .to_string()\n                 },\n                 ty::TyTuple(_) => field.index().to_string(),\n                 ty::TyRef(_, ty, _) | ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n@@ -839,11 +841,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    // Retrieve span of given borrow from the current MIR representation\n-    crate fn retrieve_borrow_span(&self, borrow: &BorrowData) -> Span {\n-        self.mir.source_info(borrow.reserve_location).span\n-    }\n-\n     // Retrieve type of a place for the current MIR representation\n     fn retrieve_type_for_place(&self, place: &Place<'tcx>) -> Option<ty::Ty> {\n         match place {\n@@ -860,3 +857,205 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n     }\n }\n+\n+// The span(s) associated to a use of a place.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub(super) enum UseSpans {\n+    // The access is caused by capturing a variable for a closure.\n+    ClosureUse {\n+        // The span of the args of the closure, including the `move` keyword if\n+        // it's present.\n+        args_span: Span,\n+        // The span of the first use of the captured variable inside the closure.\n+        var_span: Span\n+    },\n+    // This access has a single span associated to it: common case.\n+    OtherUse(Span),\n+}\n+\n+impl UseSpans {\n+    pub(super) fn args_or_use(self) -> Span {\n+        match self {\n+            UseSpans::ClosureUse {\n+                args_span: span, ..\n+            }\n+            | UseSpans::OtherUse(span) => span,\n+        }\n+    }\n+\n+    pub(super) fn var_or_use(self) -> Span {\n+        match self {\n+            UseSpans::ClosureUse { var_span: span, .. } | UseSpans::OtherUse(span) => span,\n+        }\n+    }\n+\n+    // Add a span label to the arguments of the closure, if it exists.\n+    pub(super) fn args_span_label(self, err: &mut DiagnosticBuilder, message: impl Into<String>) {\n+        if let UseSpans::ClosureUse { args_span, .. } = self {\n+            err.span_label(args_span, message);\n+        }\n+    }\n+\n+    // Add a span label to the use of the captured variable, if it exists.\n+    pub(super) fn var_span_label(self, err: &mut DiagnosticBuilder, message: impl Into<String>) {\n+        if let UseSpans::ClosureUse { var_span, .. } = self {\n+            err.span_label(var_span, message);\n+        }\n+    }\n+\n+    pub(super) fn for_closure(self) -> bool {\n+        match self {\n+            UseSpans::ClosureUse { .. } => true,\n+            UseSpans::OtherUse(_) => false,\n+        }\n+    }\n+\n+    pub(super) fn or_else<F>(self, if_other: F) -> Self\n+    where\n+        F: FnOnce() -> Self,\n+    {\n+        match self {\n+            closure @ UseSpans::ClosureUse { .. } => closure,\n+            UseSpans::OtherUse(_) => if_other(),\n+        }\n+    }\n+}\n+\n+impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n+    /// Finds the spans associated to a move or copy of move_place at location.\n+    pub(super) fn move_spans(\n+        &self,\n+        moved_place: &Place<'tcx>, // Could also be an upvar.\n+        location: Location,\n+    ) -> UseSpans {\n+        use self::UseSpans::*;\n+        use rustc::hir::ExprKind::Closure;\n+        use rustc::mir::AggregateKind;\n+\n+        let stmt = match self.mir[location.block]\n+            .statements\n+            .get(location.statement_index)\n+        {\n+            Some(stmt) => stmt,\n+            None => return OtherUse(self.mir.source_info(location).span),\n+        };\n+\n+        if let StatementKind::Assign(_, Rvalue::Aggregate(ref kind, ref places)) = stmt.kind {\n+            if let AggregateKind::Closure(def_id, _) = **kind {\n+                debug!(\"find_closure_move_span: found closure {:?}\", places);\n+\n+                if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n+                    if let Closure(_, _, _, args_span, _) = self.tcx.hir.expect_expr(node_id).node {\n+                        if let Some(var_span) = self.tcx.with_freevars(node_id, |freevars| {\n+                            for (v, place) in freevars.iter().zip(places) {\n+                                match place {\n+                                    Operand::Copy(place) | Operand::Move(place)\n+                                        if moved_place == place =>\n+                                    {\n+                                        debug!(\n+                                            \"find_closure_move_span: found captured local {:?}\",\n+                                            place\n+                                        );\n+                                        return Some(v.span);\n+                                    }\n+                                    _ => {}\n+                                }\n+                            }\n+                            None\n+                        }) {\n+                            return ClosureUse {\n+                                args_span,\n+                                var_span,\n+                            };\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return OtherUse(stmt.source_info.span);\n+    }\n+\n+    /// Finds the span of arguments of a closure (within `maybe_closure_span`)\n+    /// and its usage of the local assigned at `location`.\n+    /// This is done by searching in statements succeeding `location`\n+    /// and originating from `maybe_closure_span`.\n+    pub(super) fn borrow_spans(&self, use_span: Span, location: Location) -> UseSpans {\n+        use self::UseSpans::*;\n+        use rustc::hir::ExprKind::Closure;\n+        use rustc::mir::AggregateKind;\n+\n+        let local = match self.mir[location.block]\n+            .statements\n+            .get(location.statement_index)\n+        {\n+            Some(&Statement {\n+                kind: StatementKind::Assign(Place::Local(local), _),\n+                ..\n+            }) => local,\n+            _ => return OtherUse(use_span),\n+        };\n+\n+        if self.mir.local_kind(local) != LocalKind::Temp {\n+            // operands are always temporaries.\n+            return OtherUse(use_span);\n+        }\n+\n+        for stmt in &self.mir[location.block].statements[location.statement_index + 1..] {\n+            if let StatementKind::Assign(_, Rvalue::Aggregate(ref kind, ref places)) = stmt.kind {\n+                if let AggregateKind::Closure(def_id, _) = **kind {\n+                    debug!(\"find_closure_borrow_span: found closure {:?}\", places);\n+\n+                    return if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n+                        let args_span = if let Closure(_, _, _, span, _) =\n+                            self.tcx.hir.expect_expr(node_id).node\n+                        {\n+                            span\n+                        } else {\n+                            return OtherUse(use_span);\n+                        };\n+\n+                        self.tcx\n+                            .with_freevars(node_id, |freevars| {\n+                                for (v, place) in freevars.iter().zip(places) {\n+                                    match *place {\n+                                        Operand::Copy(Place::Local(l))\n+                                        | Operand::Move(Place::Local(l))\n+                                            if local == l =>\n+                                        {\n+                                            debug!(\n+                                                \"find_closure_borrow_span: found captured local \\\n+                                                 {:?}\",\n+                                                l\n+                                            );\n+                                            return Some(v.span);\n+                                        }\n+                                        _ => {}\n+                                    }\n+                                }\n+                                None\n+                            }).map(|var_span| ClosureUse {\n+                                args_span,\n+                                var_span,\n+                            }).unwrap_or(OtherUse(use_span))\n+                    } else {\n+                        OtherUse(use_span)\n+                    };\n+                }\n+            }\n+\n+            if use_span != stmt.source_info.span {\n+                break;\n+            }\n+        }\n+\n+        OtherUse(use_span)\n+    }\n+\n+    /// Helper to retrieve span(s) of given borrow from the current MIR\n+    /// representation\n+    pub(super) fn retrieve_borrow_spans(&self, borrow: &BorrowData) -> UseSpans {\n+        let span = self.mir.source_info(borrow.reserve_location).span;\n+        self.borrow_spans(span, borrow.reserve_location)\n+    }\n+}"}, {"sha": "320d3a47203210e24611283560011f267f8b2e9b", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/903851f785aaa01b5ae2e9648a2fd1256eea2ba5/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/903851f785aaa01b5ae2e9648a2fd1256eea2ba5/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=903851f785aaa01b5ae2e9648a2fd1256eea2ba5", "patch": "@@ -1542,7 +1542,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         if borrow_of_local_data(&borrow.borrowed_place) {\n             let err = self.tcx\n                 .cannot_borrow_across_generator_yield(\n-                    self.retrieve_borrow_span(borrow),\n+                    self.retrieve_borrow_spans(borrow).var_or_use(),\n                     yield_span,\n                     Origin::Mir,\n                 );"}, {"sha": "e8862320ddf3fcc83ce454ad0b92cae14743edd7", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/903851f785aaa01b5ae2e9648a2fd1256eea2ba5/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/903851f785aaa01b5ae2e9648a2fd1256eea2ba5/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=903851f785aaa01b5ae2e9648a2fd1256eea2ba5", "patch": "@@ -160,7 +160,6 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n         let act;\n         let acted_on;\n \n-\n         let span = match error_access {\n             AccessKind::Move => {\n                 err = self.tcx\n@@ -180,31 +179,23 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 act = \"borrow as mutable\";\n                 acted_on = \"borrowed as mutable\";\n \n-                let closure_span = self.find_closure_span(span, location);\n-                if let Some((args, var)) = closure_span {\n-                    err = self.tcx.cannot_borrow_path_as_mutable_because(\n-                        args,\n-                        &item_msg,\n-                        &reason,\n-                        Origin::Mir,\n-                    );\n-                    err.span_label(\n-                        var,\n-                        format!(\n-                            \"mutable borrow occurs due to use of `{}` in closure\",\n-                            self.describe_place(access_place).unwrap(),\n-                        ),\n-                    );\n-                    args\n-                } else {\n-                    err = self.tcx.cannot_borrow_path_as_mutable_because(\n-                        span,\n-                        &item_msg,\n-                        &reason,\n-                        Origin::Mir,\n-                    );\n-                    span\n-                }\n+                let borrow_spans = self.borrow_spans(span, location);\n+                let borrow_span = borrow_spans.args_or_use();\n+                err = self.tcx.cannot_borrow_path_as_mutable_because(\n+                    borrow_span,\n+                    &item_msg,\n+                    &reason,\n+                    Origin::Mir,\n+                );\n+                borrow_spans.var_span_label(\n+                    &mut err,\n+                    format!(\n+                        \"mutable borrow occurs due to use of `{}` in closure\",\n+                        // always Some() if the message is printed.\n+                        self.describe_place(access_place).unwrap_or(String::new()),\n+                    )\n+                );\n+                borrow_span\n             }\n         };\n "}, {"sha": "5098b24adc367507e756324a682e14f7234122ec", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/903851f785aaa01b5ae2e9648a2fd1256eea2ba5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/903851f785aaa01b5ae2e9648a2fd1256eea2ba5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=903851f785aaa01b5ae2e9648a2fd1256eea2ba5", "patch": "@@ -62,18 +62,24 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         );\n \n         match find_use::find(mir, regioncx, tcx, region_sub, context.loc) {\n-            Some(Cause::LiveVar(_local, location)) => {\n-                if self.is_borrow_location_in_loop(context.loc) {\n-                    err.span_label(\n-                        mir.source_info(location).span,\n-                        \"borrow used here in later iteration of loop\".to_string(),\n-                    );\n+            Some(Cause::LiveVar(local, location)) => {\n+                let span = mir.source_info(location).span;\n+                let spans = self.move_spans(&Place::Local(local), location)\n+                    .or_else(|| self.borrow_spans(span, location));\n+                let message = if self.is_borrow_location_in_loop(context.loc) {\n+                    if spans.for_closure() {\n+                        \"borrow captured here by closure in later iteration of loop\"\n+                    } else {\n+                        \"borrow used here in later iteration of loop\"\n+                    }\n                 } else {\n-                    err.span_label(\n-                        mir.source_info(location).span,\n-                        \"borrow later used here\".to_string(),\n-                    );\n-                }\n+                    if spans.for_closure() {\n+                        \"borrow later captured here by closure\"\n+                    } else {\n+                        \"borrow later used here\"\n+                    }\n+                };\n+                err.span_label(spans.var_or_use(), message);\n             }\n \n             Some(Cause::DropVar(local, location)) => match &mir.local_decls[local].name {"}, {"sha": "0a53361df6e95b70c53a1e1b69b7bfde5ed13d35", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/903851f785aaa01b5ae2e9648a2fd1256eea2ba5/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/903851f785aaa01b5ae2e9648a2fd1256eea2ba5/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=903851f785aaa01b5ae2e9648a2fd1256eea2ba5", "patch": "@@ -203,8 +203,15 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n             desc,\n             OGN = o\n         );\n-        err.span_label(old_loan_span, \"first closure is constructed here\");\n-        err.span_label(new_loan_span, \"second closure is constructed here\");\n+        if old_loan_span == new_loan_span {\n+            err.span_label(\n+                old_loan_span,\n+                \"closures are constructed here in different iterations of loop\"\n+            );\n+        } else {\n+            err.span_label(old_loan_span, \"first closure is constructed here\");\n+            err.span_label(new_loan_span, \"second closure is constructed here\");\n+        }\n         if let Some(old_load_end_span) = old_load_end_span {\n             err.span_label(old_load_end_span, \"borrow from first closure ends here\");\n         }"}]}