{"sha": "88b65c9e2b42d663bca64c935350d6e96f0b9c4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4YjY1YzllMmI0MmQ2NjNiY2E2NGM5MzUzNTBkNmU5NmYwYjljNGU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-03-17T09:18:01Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-03-17T09:18:01Z"}, "message": "Refactor the emit_vtable_methods code to be a bit cleaner in its use of\niterators.", "tree": {"sha": "17d956a17990c6bf78bf47efc2da6effda68dc6a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17d956a17990c6bf78bf47efc2da6effda68dc6a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88b65c9e2b42d663bca64c935350d6e96f0b9c4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88b65c9e2b42d663bca64c935350d6e96f0b9c4e", "html_url": "https://github.com/rust-lang/rust/commit/88b65c9e2b42d663bca64c935350d6e96f0b9c4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88b65c9e2b42d663bca64c935350d6e96f0b9c4e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "883551b1d739993dffcba01ee9ea3237cf406d9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/883551b1d739993dffcba01ee9ea3237cf406d9a", "html_url": "https://github.com/rust-lang/rust/commit/883551b1d739993dffcba01ee9ea3237cf406d9a"}], "stats": {"total": 99, "additions": 65, "deletions": 34}, "files": [{"sha": "09a252a8e46842915c3eb0dbb27d12f529d42eb7", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 65, "deletions": 34, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/88b65c9e2b42d663bca64c935350d6e96f0b9c4e/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b65c9e2b42d663bca64c935350d6e96f0b9c4e/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=88b65c9e2b42d663bca64c935350d6e96f0b9c4e", "patch": "@@ -771,9 +771,15 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                  impl_id: ast::DefId,\n                                  substs: subst::Substs<'tcx>,\n                                  param_substs: &'tcx subst::Substs<'tcx>)\n-                                 -> Vec<ValueRef> {\n+                                 -> Vec<ValueRef>\n+{\n     let tcx = ccx.tcx();\n \n+    debug!(\"emit_vtable_methods(impl_id={}, substs={}, param_substs={})\",\n+           impl_id.repr(tcx),\n+           substs.repr(tcx),\n+           param_substs.repr(tcx));\n+\n     let trt_id = match ty::impl_trait_ref(tcx, impl_id) {\n         Some(t_id) => t_id.def_id,\n         None       => ccx.sess().bug(\"make_impl_vtable: don't know how to \\\n@@ -783,41 +789,66 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     ty::populate_implementations_for_trait_if_necessary(tcx, trt_id);\n \n     let trait_item_def_ids = ty::trait_item_def_ids(tcx, trt_id);\n-    trait_item_def_ids.iter().flat_map(|method_def_id| {\n-        let method_def_id = method_def_id.def_id();\n-        let name = ty::impl_or_trait_item(tcx, method_def_id).name();\n-        // The substitutions we have are on the impl, so we grab\n-        // the method type from the impl to substitute into.\n-        let m_id = method_with_name(ccx, impl_id, name);\n-        let ti = ty::impl_or_trait_item(tcx, m_id);\n-        match ti {\n-            ty::MethodTraitItem(m) => {\n-                debug!(\"(making impl vtable) emitting method {} at subst {}\",\n-                       m.repr(tcx),\n-                       substs.repr(tcx));\n-                if m.generics.has_type_params(subst::FnSpace) ||\n-                    ty::type_has_self(ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(m.fty.clone())))\n-                {\n-                    debug!(\"(making impl vtable) method has self or type \\\n-                            params: {}\",\n-                           token::get_name(name));\n-                    Some(C_null(Type::nil(ccx).ptr_to())).into_iter()\n-                } else {\n-                    let fn_ref = trans_fn_ref_with_substs(\n-                        ccx,\n-                        m_id,\n-                        ExprId(0),\n-                        param_substs,\n-                        substs.clone()).val;\n-\n-                    Some(fn_ref).into_iter()\n-                }\n+    trait_item_def_ids\n+        .iter()\n+\n+        // Filter out the associated types.\n+        .filter_map(|item_def_id| {\n+            match *item_def_id {\n+                ty::MethodTraitItemId(def_id) => Some(def_id),\n+                ty::TypeTraitItemId(_) => None,\n             }\n-            ty::TypeTraitItem(_) => {\n-                None.into_iter()\n+        })\n+\n+        // Now produce pointers for each remaining method. If the\n+        // method could never be called from this object, just supply\n+        // null.\n+        .map(|trait_method_def_id| {\n+            debug!(\"emit_vtable_methods: trait_method_def_id={}\",\n+                   trait_method_def_id.repr(tcx));\n+\n+            let trait_method_type = match ty::impl_or_trait_item(tcx, trait_method_def_id) {\n+                ty::MethodTraitItem(m) => m,\n+                ty::TypeTraitItem(_) => ccx.sess().bug(\"should be a method, not assoc type\")\n+            };\n+            let name = trait_method_type.name;\n+\n+            debug!(\"emit_vtable_methods: trait_method_type={}\",\n+                   trait_method_type.repr(tcx));\n+\n+            // The substitutions we have are on the impl, so we grab\n+            // the method type from the impl to substitute into.\n+            let impl_method_def_id = method_with_name(ccx, impl_id, name);\n+            let impl_method_type = match ty::impl_or_trait_item(tcx, impl_method_def_id) {\n+                ty::MethodTraitItem(m) => m,\n+                ty::TypeTraitItem(_) => ccx.sess().bug(\"should be a method, not assoc type\")\n+            };\n+\n+            debug!(\"emit_vtable_methods: m={}\",\n+                   impl_method_type.repr(tcx));\n+\n+            let nullptr = C_null(Type::nil(ccx).ptr_to());\n+\n+            if impl_method_type.generics.has_type_params(subst::FnSpace) {\n+                debug!(\"emit_vtable_methods: generic\");\n+                return nullptr;\n             }\n-        }\n-    }).collect()\n+\n+            let bare_fn_ty =\n+                ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(impl_method_type.fty.clone()));\n+            if ty::type_has_self(bare_fn_ty) {\n+                debug!(\"emit_vtable_methods: type_has_self {}\",\n+                       bare_fn_ty.repr(tcx));\n+                return nullptr;\n+            }\n+\n+            trans_fn_ref_with_substs(ccx,\n+                                     impl_method_def_id,\n+                                     ExprId(0),\n+                                     param_substs,\n+                                     substs.clone()).val\n+        })\n+        .collect()\n }\n \n /// Generates the code to convert from a pointer (`Box<T>`, `&T`, etc) into an object"}]}