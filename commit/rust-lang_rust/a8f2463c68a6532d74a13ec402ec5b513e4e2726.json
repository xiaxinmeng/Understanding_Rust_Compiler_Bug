{"sha": "a8f2463c68a6532d74a13ec402ec5b513e4e2726", "node_id": "C_kwDOAAsO6NoAKGE4ZjI0NjNjNjhhNjUzMmQ3NGExM2VjNDAyZWM1YjUxM2U0ZTI3MjY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-09T19:05:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-09T19:05:08Z"}, "message": "Auto merge of #88379 - camelid:cleanup-clean, r=jyn514\n\nrustdoc: Cleanup various `clean` types\n\nCleanup various `clean` types.", "tree": {"sha": "0b64e33cb595b05854eb72987cb755d017656561", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b64e33cb595b05854eb72987cb755d017656561"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8f2463c68a6532d74a13ec402ec5b513e4e2726", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8f2463c68a6532d74a13ec402ec5b513e4e2726", "html_url": "https://github.com/rust-lang/rust/commit/a8f2463c68a6532d74a13ec402ec5b513e4e2726", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8f2463c68a6532d74a13ec402ec5b513e4e2726/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc8ad24020a160e1acd7ac9f7671947dcc01264c", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc8ad24020a160e1acd7ac9f7671947dcc01264c", "html_url": "https://github.com/rust-lang/rust/commit/bc8ad24020a160e1acd7ac9f7671947dcc01264c"}, {"sha": "ebbcafbfa3d7dde58a548621a2003d26c1005fd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebbcafbfa3d7dde58a548621a2003d26c1005fd4", "html_url": "https://github.com/rust-lang/rust/commit/ebbcafbfa3d7dde58a548621a2003d26c1005fd4"}], "stats": {"total": 929, "additions": 415, "deletions": 514}, "files": [{"sha": "f9d1666977134f70fda11a90096bbd3fd25d7473", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 143, "deletions": 179, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/a8f2463c68a6532d74a13ec402ec5b513e4e2726/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f2463c68a6532d74a13ec402ec5b513e4e2726/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=a8f2463c68a6532d74a13ec402ec5b513e4e2726", "patch": "@@ -118,7 +118,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 span: Span::dummy(),\n                 unsafety: hir::Unsafety::Normal,\n                 generics: new_generics,\n-                trait_: Some(trait_ref.clean(self.cx).get_trait_type().unwrap()),\n+                trait_: Some(trait_ref.clean(self.cx)),\n                 for_: ty.clean(self.cx),\n                 items: Vec::new(),\n                 negative_polarity,\n@@ -166,16 +166,16 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             .clone()\n     }\n \n-    // This method calculates two things: Lifetime constraints of the form 'a: 'b,\n-    // and region constraints of the form ReVar: 'a\n-    //\n-    // This is essentially a simplified version of lexical_region_resolve. However,\n-    // handle_lifetimes determines what *needs be* true in order for an impl to hold.\n-    // lexical_region_resolve, along with much of the rest of the compiler, is concerned\n-    // with determining if a given set up constraints/predicates *are* met, given some\n-    // starting conditions (e.g., user-provided code). For this reason, it's easier\n-    // to perform the calculations we need on our own, rather than trying to make\n-    // existing inference/solver code do what we want.\n+    /// This method calculates two things: Lifetime constraints of the form `'a: 'b`,\n+    /// and region constraints of the form `RegionVid: 'a`\n+    ///\n+    /// This is essentially a simplified version of lexical_region_resolve. However,\n+    /// handle_lifetimes determines what *needs be* true in order for an impl to hold.\n+    /// lexical_region_resolve, along with much of the rest of the compiler, is concerned\n+    /// with determining if a given set up constraints/predicates *are* met, given some\n+    /// starting conditions (e.g., user-provided code). For this reason, it's easier\n+    /// to perform the calculations we need on our own, rather than trying to make\n+    /// existing inference/solver code do what we want.\n     fn handle_lifetimes<'cx>(\n         regions: &RegionConstraintData<'cx>,\n         names_map: &FxHashMap<Symbol, Lifetime>,\n@@ -353,48 +353,35 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 if let Some(data) = ty_to_fn.get(&ty) {\n                     let (poly_trait, output) =\n                         (data.0.as_ref().unwrap().clone(), data.1.as_ref().cloned().map(Box::new));\n-                    let new_ty = match poly_trait.trait_ {\n-                        Type::ResolvedPath { ref path, ref did } => {\n-                            let mut new_path = path.clone();\n-                            let last_segment =\n-                                new_path.segments.pop().expect(\"segments were empty\");\n-\n-                            let (old_input, old_output) = match last_segment.args {\n-                                GenericArgs::AngleBracketed { args, .. } => {\n-                                    let types = args\n-                                        .iter()\n-                                        .filter_map(|arg| match arg {\n-                                            GenericArg::Type(ty) => Some(ty.clone()),\n-                                            _ => None,\n-                                        })\n-                                        .collect();\n-                                    (types, None)\n-                                }\n-                                GenericArgs::Parenthesized { inputs, output, .. } => {\n-                                    (inputs, output)\n-                                }\n-                            };\n+                    let mut new_path = poly_trait.trait_.clone();\n+                    let last_segment = new_path.segments.pop().expect(\"segments were empty\");\n+\n+                    let (old_input, old_output) = match last_segment.args {\n+                        GenericArgs::AngleBracketed { args, .. } => {\n+                            let types = args\n+                                .iter()\n+                                .filter_map(|arg| match arg {\n+                                    GenericArg::Type(ty) => Some(ty.clone()),\n+                                    _ => None,\n+                                })\n+                                .collect();\n+                            (types, None)\n+                        }\n+                        GenericArgs::Parenthesized { inputs, output } => (inputs, output),\n+                    };\n \n-                            if old_output.is_some() && old_output != output {\n-                                panic!(\n-                                    \"Output mismatch for {:?} {:?} {:?}\",\n-                                    ty, old_output, data.1\n-                                );\n-                            }\n+                    if old_output.is_some() && old_output != output {\n+                        panic!(\"Output mismatch for {:?} {:?} {:?}\", ty, old_output, data.1);\n+                    }\n \n-                            let new_params =\n-                                GenericArgs::Parenthesized { inputs: old_input, output };\n+                    let new_params = GenericArgs::Parenthesized { inputs: old_input, output };\n \n-                            new_path\n-                                .segments\n-                                .push(PathSegment { name: last_segment.name, args: new_params });\n+                    new_path\n+                        .segments\n+                        .push(PathSegment { name: last_segment.name, args: new_params });\n \n-                            Type::ResolvedPath { path: new_path, did: *did }\n-                        }\n-                        _ => panic!(\"Unexpected data: {:?}, {:?}\", ty, data),\n-                    };\n                     bounds.insert(GenericBound::TraitBound(\n-                        PolyTrait { trait_: new_ty, generic_params: poly_trait.generic_params },\n+                        PolyTrait { trait_: new_path, generic_params: poly_trait.generic_params },\n                         hir::TraitBoundModifier::None,\n                     ));\n                 }\n@@ -423,15 +410,15 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             .collect()\n     }\n \n-    // Converts the calculated ParamEnv and lifetime information to a clean::Generics, suitable for\n-    // display on the docs page. Cleaning the Predicates produces sub-optimal `WherePredicate`s,\n-    // so we fix them up:\n-    //\n-    // * Multiple bounds for the same type are coalesced into one: e.g., 'T: Copy', 'T: Debug'\n-    // becomes 'T: Copy + Debug'\n-    // * Fn bounds are handled specially - instead of leaving it as 'T: Fn(), <T as Fn::Output> =\n-    // K', we use the dedicated syntax 'T: Fn() -> K'\n-    // * We explicitly add a '?Sized' bound if we didn't find any 'Sized' predicates for a type\n+    /// Converts the calculated `ParamEnv` and lifetime information to a [`clean::Generics`](Generics), suitable for\n+    /// display on the docs page. Cleaning the `Predicates` produces sub-optimal [`WherePredicate`]s,\n+    /// so we fix them up:\n+    ///\n+    /// * Multiple bounds for the same type are coalesced into one: e.g., `T: Copy`, `T: Debug`\n+    /// becomes `T: Copy + Debug`\n+    /// * `Fn` bounds are handled specially - instead of leaving it as `T: Fn(), <T as Fn::Output> =\n+    /// K`, we use the dedicated syntax `T: Fn() -> K`\n+    /// * We explicitly add a `?Sized` bound if we didn't find any `Sized` predicates for a type\n     fn param_env_to_generics(\n         &mut self,\n         item_def_id: DefId,\n@@ -476,7 +463,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         let mut has_sized = FxHashSet::default();\n         let mut ty_to_bounds: FxHashMap<_, FxHashSet<_>> = Default::default();\n         let mut lifetime_to_bounds: FxHashMap<_, FxHashSet<_>> = Default::default();\n-        let mut ty_to_traits: FxHashMap<Type, FxHashSet<Type>> = Default::default();\n+        let mut ty_to_traits: FxHashMap<Type, FxHashSet<Path>> = Default::default();\n \n         let mut ty_to_fn: FxHashMap<Type, (Option<PolyTrait>, Option<Type>)> = Default::default();\n \n@@ -511,11 +498,11 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                     if b.is_sized_bound(self.cx) {\n                         has_sized.insert(ty.clone());\n                     } else if !b\n-                        .get_trait_type()\n-                        .and_then(|t| {\n+                        .get_trait_path()\n+                        .and_then(|trait_| {\n                             ty_to_traits\n                                 .get(&ty)\n-                                .map(|bounds| bounds.contains(&strip_type(t.clone())))\n+                                .map(|bounds| bounds.contains(&strip_path_generics(trait_.clone())))\n                         })\n                         .unwrap_or(false)\n                     {\n@@ -532,7 +519,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                                 // that we don't end up with duplicate bounds (e.g., for<'b, 'b>)\n                                 for_generics.extend(p.generic_params.clone());\n                                 p.generic_params = for_generics.into_iter().collect();\n-                                self.is_fn_ty(&p.trait_)\n+                                self.is_fn_trait(&p.trait_)\n                             }\n                             _ => false,\n                         };\n@@ -558,78 +545,59 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                     match lhs {\n                         Type::QPath { name: left_name, ref self_type, ref trait_, .. } => {\n                             let ty = &*self_type;\n-                            match **trait_ {\n-                                Type::ResolvedPath { path: ref trait_path, ref did } => {\n-                                    let mut new_trait_path = trait_path.clone();\n-\n-                                    if self.is_fn_ty(trait_) && left_name == sym::Output {\n-                                        ty_to_fn\n-                                            .entry(*ty.clone())\n-                                            .and_modify(|e| *e = (e.0.clone(), Some(rhs.clone())))\n-                                            .or_insert((None, Some(rhs)));\n-                                        continue;\n-                                    }\n-\n-                                    let args = &mut new_trait_path\n-                                        .segments\n-                                        .last_mut()\n-                                        .expect(\"segments were empty\")\n-                                        .args;\n-\n-                                    match args {\n-                                        // Convert something like '<T as Iterator::Item> = u8'\n-                                        // to 'T: Iterator<Item=u8>'\n-                                        GenericArgs::AngleBracketed {\n-                                            ref mut bindings, ..\n-                                        } => {\n-                                            bindings.push(TypeBinding {\n-                                                name: left_name,\n-                                                kind: TypeBindingKind::Equality { ty: rhs },\n-                                            });\n-                                        }\n-                                        GenericArgs::Parenthesized { .. } => {\n-                                            existing_predicates.push(WherePredicate::EqPredicate {\n-                                                lhs: lhs.clone(),\n-                                                rhs,\n-                                            });\n-                                            continue; // If something other than a Fn ends up\n-                                            // with parenthesis, leave it alone\n-                                        }\n-                                    }\n-\n-                                    let bounds = ty_to_bounds.entry(*ty.clone()).or_default();\n-\n-                                    bounds.insert(GenericBound::TraitBound(\n-                                        PolyTrait {\n-                                            trait_: Type::ResolvedPath {\n-                                                path: new_trait_path,\n-                                                did: *did,\n-                                            },\n-                                            generic_params: Vec::new(),\n-                                        },\n-                                        hir::TraitBoundModifier::None,\n-                                    ));\n-\n-                                    // Remove any existing 'plain' bound (e.g., 'T: Iterator`) so\n-                                    // that we don't see a\n-                                    // duplicate bound like `T: Iterator + Iterator<Item=u8>`\n-                                    // on the docs page.\n-                                    bounds.remove(&GenericBound::TraitBound(\n-                                        PolyTrait {\n-                                            trait_: *trait_.clone(),\n-                                            generic_params: Vec::new(),\n-                                        },\n-                                        hir::TraitBoundModifier::None,\n-                                    ));\n-                                    // Avoid creating any new duplicate bounds later in the outer\n-                                    // loop\n-                                    ty_to_traits\n-                                        .entry(*ty.clone())\n-                                        .or_default()\n-                                        .insert(*trait_.clone());\n+                            let mut new_trait = trait_.clone();\n+\n+                            if self.is_fn_trait(trait_) && left_name == sym::Output {\n+                                ty_to_fn\n+                                    .entry(*ty.clone())\n+                                    .and_modify(|e| *e = (e.0.clone(), Some(rhs.clone())))\n+                                    .or_insert((None, Some(rhs)));\n+                                continue;\n+                            }\n+\n+                            let args = &mut new_trait\n+                                .segments\n+                                .last_mut()\n+                                .expect(\"segments were empty\")\n+                                .args;\n+\n+                            match args {\n+                                // Convert something like '<T as Iterator::Item> = u8'\n+                                // to 'T: Iterator<Item=u8>'\n+                                GenericArgs::AngleBracketed { ref mut bindings, .. } => {\n+                                    bindings.push(TypeBinding {\n+                                        name: left_name,\n+                                        kind: TypeBindingKind::Equality { ty: rhs },\n+                                    });\n+                                }\n+                                GenericArgs::Parenthesized { .. } => {\n+                                    existing_predicates.push(WherePredicate::EqPredicate {\n+                                        lhs: lhs.clone(),\n+                                        rhs,\n+                                    });\n+                                    continue; // If something other than a Fn ends up\n+                                    // with parenthesis, leave it alone\n                                 }\n-                                _ => panic!(\"Unexpected trait {:?} for {:?}\", trait_, item_def_id),\n                             }\n+\n+                            let bounds = ty_to_bounds.entry(*ty.clone()).or_default();\n+\n+                            bounds.insert(GenericBound::TraitBound(\n+                                PolyTrait { trait_: new_trait, generic_params: Vec::new() },\n+                                hir::TraitBoundModifier::None,\n+                            ));\n+\n+                            // Remove any existing 'plain' bound (e.g., 'T: Iterator`) so\n+                            // that we don't see a\n+                            // duplicate bound like `T: Iterator + Iterator<Item=u8>`\n+                            // on the docs page.\n+                            bounds.remove(&GenericBound::TraitBound(\n+                                PolyTrait { trait_: trait_.clone(), generic_params: Vec::new() },\n+                                hir::TraitBoundModifier::None,\n+                            ));\n+                            // Avoid creating any new duplicate bounds later in the outer\n+                            // loop\n+                            ty_to_traits.entry(*ty.clone()).or_default().insert(trait_.clone());\n                         }\n                         _ => panic!(\"Unexpected LHS {:?} for {:?}\", lhs, item_def_id),\n                     }\n@@ -664,11 +632,11 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         Generics { params: generic_params, where_predicates: existing_predicates }\n     }\n \n-    // Ensure that the predicates are in a consistent order. The precise\n-    // ordering doesn't actually matter, but it's important that\n-    // a given set of predicates always appears in the same order -\n-    // both for visual consistency between 'rustdoc' runs, and to\n-    // make writing tests much easier\n+    /// Ensure that the predicates are in a consistent order. The precise\n+    /// ordering doesn't actually matter, but it's important that\n+    /// a given set of predicates always appears in the same order -\n+    /// both for visual consistency between 'rustdoc' runs, and to\n+    /// make writing tests much easier\n     #[inline]\n     fn sort_where_predicates(&self, mut predicates: &mut Vec<WherePredicate>) {\n         // We should never have identical bounds - and if we do,\n@@ -677,11 +645,11 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         self.unstable_debug_sort(&mut predicates);\n     }\n \n-    // Ensure that the bounds are in a consistent order. The precise\n-    // ordering doesn't actually matter, but it's important that\n-    // a given set of bounds always appears in the same order -\n-    // both for visual consistency between 'rustdoc' runs, and to\n-    // make writing tests much easier\n+    /// Ensure that the bounds are in a consistent order. The precise\n+    /// ordering doesn't actually matter, but it's important that\n+    /// a given set of bounds always appears in the same order -\n+    /// both for visual consistency between 'rustdoc' runs, and to\n+    /// make writing tests much easier\n     #[inline]\n     fn sort_where_bounds(&self, mut bounds: &mut Vec<GenericBound>) {\n         // We should never have identical bounds - and if we do,\n@@ -690,47 +658,43 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         self.unstable_debug_sort(&mut bounds);\n     }\n \n-    // This might look horrendously hacky, but it's actually not that bad.\n-    //\n-    // For performance reasons, we use several different FxHashMaps\n-    // in the process of computing the final set of where predicates.\n-    // However, the iteration order of a HashMap is completely unspecified.\n-    // In fact, the iteration of an FxHashMap can even vary between platforms,\n-    // since FxHasher has different behavior for 32-bit and 64-bit platforms.\n-    //\n-    // Obviously, it's extremely undesirable for documentation rendering\n-    // to be dependent on the platform it's run on. Apart from being confusing\n-    // to end users, it makes writing tests much more difficult, as predicates\n-    // can appear in any order in the final result.\n-    //\n-    // To solve this problem, we sort WherePredicates and GenericBounds\n-    // by their Debug string. The thing to keep in mind is that we don't really\n-    // care what the final order is - we're synthesizing an impl or bound\n-    // ourselves, so any order can be considered equally valid. By sorting the\n-    // predicates and bounds, however, we ensure that for a given codebase, all\n-    // auto-trait impls always render in exactly the same way.\n-    //\n-    // Using the Debug implementation for sorting prevents us from needing to\n-    // write quite a bit of almost entirely useless code (e.g., how should two\n-    // Types be sorted relative to each other). It also allows us to solve the\n-    // problem for both WherePredicates and GenericBounds at the same time. This\n-    // approach is probably somewhat slower, but the small number of items\n-    // involved (impls rarely have more than a few bounds) means that it\n-    // shouldn't matter in practice.\n+    /// This might look horrendously hacky, but it's actually not that bad.\n+    ///\n+    /// For performance reasons, we use several different FxHashMaps\n+    /// in the process of computing the final set of where predicates.\n+    /// However, the iteration order of a HashMap is completely unspecified.\n+    /// In fact, the iteration of an FxHashMap can even vary between platforms,\n+    /// since FxHasher has different behavior for 32-bit and 64-bit platforms.\n+    ///\n+    /// Obviously, it's extremely undesirable for documentation rendering\n+    /// to be dependent on the platform it's run on. Apart from being confusing\n+    /// to end users, it makes writing tests much more difficult, as predicates\n+    /// can appear in any order in the final result.\n+    ///\n+    /// To solve this problem, we sort WherePredicates and GenericBounds\n+    /// by their Debug string. The thing to keep in mind is that we don't really\n+    /// care what the final order is - we're synthesizing an impl or bound\n+    /// ourselves, so any order can be considered equally valid. By sorting the\n+    /// predicates and bounds, however, we ensure that for a given codebase, all\n+    /// auto-trait impls always render in exactly the same way.\n+    ///\n+    /// Using the Debug implementation for sorting prevents us from needing to\n+    /// write quite a bit of almost entirely useless code (e.g., how should two\n+    /// Types be sorted relative to each other). It also allows us to solve the\n+    /// problem for both WherePredicates and GenericBounds at the same time. This\n+    /// approach is probably somewhat slower, but the small number of items\n+    /// involved (impls rarely have more than a few bounds) means that it\n+    /// shouldn't matter in practice.\n     fn unstable_debug_sort<T: Debug>(&self, vec: &mut Vec<T>) {\n         vec.sort_by_cached_key(|x| format!(\"{:?}\", x))\n     }\n \n-    fn is_fn_ty(&self, ty: &Type) -> bool {\n+    fn is_fn_trait(&self, path: &Path) -> bool {\n         let tcx = self.cx.tcx;\n-        match ty {\n-            &Type::ResolvedPath { did, .. } => {\n-                did == tcx.require_lang_item(LangItem::Fn, None)\n-                    || did == tcx.require_lang_item(LangItem::FnMut, None)\n-                    || did == tcx.require_lang_item(LangItem::FnOnce, None)\n-            }\n-            _ => false,\n-        }\n+        let did = path.def_id();\n+        did == tcx.require_lang_item(LangItem::Fn, None)\n+            || did == tcx.require_lang_item(LangItem::FnMut, None)\n+            || did == tcx.require_lang_item(LangItem::FnOnce, None)\n     }\n }\n \n@@ -741,7 +705,7 @@ fn region_name(region: Region<'_>) -> Option<Symbol> {\n     }\n }\n \n-// Replaces all ReVars in a type with ty::Region's, using the provided map\n+/// Replaces all [`ty::RegionVid`]s in a type with [`ty::Region`]s, using the provided map.\n struct RegionReplacer<'a, 'tcx> {\n     vid_to_region: &'a FxHashMap<ty::RegionVid, ty::Region<'tcx>>,\n     tcx: TyCtxt<'tcx>,"}, {"sha": "dd0cbb1b952d33592b03c6617e91129a4f0571b0", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8f2463c68a6532d74a13ec402ec5b513e4e2726/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f2463c68a6532d74a13ec402ec5b513e4e2726/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=a8f2463c68a6532d74a13ec402ec5b513e4e2726", "patch": "@@ -115,7 +115,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                             .clean(self.cx),\n                         // FIXME(eddyb) compute both `trait_` and `for_` from\n                         // the post-inference `trait_ref`, as it's more accurate.\n-                        trait_: Some(trait_ref.clean(self.cx).get_trait_type().unwrap()),\n+                        trait_: Some(trait_ref.clean(self.cx)),\n                         for_: ty.clean(self.cx),\n                         items: self\n                             .cx"}, {"sha": "e11b802a09a3b9d3961083494b9705b99f3535b7", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a8f2463c68a6532d74a13ec402ec5b513e4e2726/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f2463c68a6532d74a13ec402ec5b513e4e2726/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=a8f2463c68a6532d74a13ec402ec5b513e4e2726", "patch": "@@ -446,20 +446,26 @@ crate fn build_impl(\n         ),\n     };\n     let polarity = tcx.impl_polarity(did);\n-    let trait_ = associated_trait.clean(cx).map(|bound| match bound {\n-        clean::GenericBound::TraitBound(polyt, _) => polyt.trait_,\n-        clean::GenericBound::Outlives(..) => unreachable!(),\n-    });\n-    if trait_.def_id() == tcx.lang_items().deref_trait() {\n+    let trait_ = associated_trait.clean(cx);\n+    if trait_.as_ref().map(|t| t.def_id()) == tcx.lang_items().deref_trait() {\n         super::build_deref_target_impls(cx, &trait_items, ret);\n     }\n \n     // Return if the trait itself or any types of the generic parameters are doc(hidden).\n-    let mut stack: Vec<&Type> = trait_.iter().collect();\n-    stack.push(&for_);\n+    let mut stack: Vec<&Type> = vec![&for_];\n+\n+    if let Some(did) = trait_.as_ref().map(|t| t.def_id()) {\n+        if tcx.get_attrs(did).lists(sym::doc).has_word(sym::hidden) {\n+            return;\n+        }\n+    }\n+    if let Some(generics) = trait_.as_ref().and_then(|t| t.generics()) {\n+        stack.extend(generics);\n+    }\n+\n     while let Some(ty) = stack.pop() {\n         if let Some(did) = ty.def_id() {\n-            if cx.tcx.get_attrs(did).lists(sym::doc).has_word(sym::hidden) {\n+            if tcx.get_attrs(did).lists(sym::doc).has_word(sym::hidden) {\n                 return;\n             }\n         }\n@@ -468,14 +474,14 @@ crate fn build_impl(\n         }\n     }\n \n-    if let Some(trait_did) = trait_.def_id() {\n-        record_extern_trait(cx, trait_did);\n+    if let Some(did) = trait_.as_ref().map(|t| t.def_id()) {\n+        record_extern_trait(cx, did);\n     }\n \n     let (merged_attrs, cfg) = merge_attrs(cx, parent_module.into(), load_attrs(cx, did), attrs);\n     trace!(\"merged_attrs={:?}\", merged_attrs);\n \n-    trace!(\"build_impl: impl {:?} for {:?}\", trait_.def_id(), for_.def_id());\n+    trace!(\"build_impl: impl {:?} for {:?}\", trait_.as_ref().map(|t| t.def_id()), for_.def_id());\n     ret.push(clean::Item::from_def_id_and_attrs_and_parts(\n         did,\n         None,\n@@ -526,7 +532,6 @@ fn build_module(\n                         item.ident.name,\n                         clean::ImportSource {\n                             path: clean::Path {\n-                                global: false,\n                                 res,\n                                 segments: vec![clean::PathSegment {\n                                     name: prim_ty.as_sym(),\n@@ -621,30 +626,23 @@ fn filter_non_trait_generics(trait_did: DefId, mut g: clean::Generics) -> clean:\n                 ref mut bounds,\n                 ..\n             } if *s == kw::SelfUpper => {\n-                bounds.retain(|bound| match *bound {\n-                    clean::GenericBound::TraitBound(\n-                        clean::PolyTrait { trait_: clean::ResolvedPath { did, .. }, .. },\n-                        _,\n-                    ) => did != trait_did,\n+                bounds.retain(|bound| match bound {\n+                    clean::GenericBound::TraitBound(clean::PolyTrait { trait_, .. }, _) => {\n+                        trait_.def_id() != trait_did\n+                    }\n                     _ => true,\n                 });\n             }\n             _ => {}\n         }\n     }\n \n-    g.where_predicates.retain(|pred| match *pred {\n+    g.where_predicates.retain(|pred| match pred {\n         clean::WherePredicate::BoundPredicate {\n-            ty:\n-                clean::QPath {\n-                    self_type: box clean::Generic(ref s),\n-                    trait_: box clean::ResolvedPath { did, .. },\n-                    name: ref _name,\n-                    ..\n-                },\n-            ref bounds,\n+            ty: clean::QPath { self_type: box clean::Generic(ref s), trait_, name: _, .. },\n+            bounds,\n             ..\n-        } => !(bounds.is_empty() || *s == kw::SelfUpper && did == trait_did),\n+        } => !(bounds.is_empty() || *s == kw::SelfUpper && trait_.def_id() == trait_did),\n         _ => true,\n     });\n     g"}, {"sha": "9d102d6878370dea44d839c83b57e15d9feeafde", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 26, "deletions": 42, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/a8f2463c68a6532d74a13ec402ec5b513e4e2726/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f2463c68a6532d74a13ec402ec5b513e4e2726/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=a8f2463c68a6532d74a13ec402ec5b513e4e2726", "patch": "@@ -152,8 +152,8 @@ impl Clean<GenericBound> for hir::GenericBound<'_> {\n     }\n }\n \n-impl Clean<Type> for (ty::TraitRef<'_>, &[TypeBinding]) {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n+impl Clean<Path> for (ty::TraitRef<'_>, &[TypeBinding]) {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Path {\n         let (trait_ref, bounds) = *self;\n         let kind = cx.tcx.def_kind(trait_ref.def_id).into();\n         if !matches!(kind, ItemType::Trait | ItemType::TraitAlias) {\n@@ -168,16 +168,13 @@ impl Clean<Type> for (ty::TraitRef<'_>, &[TypeBinding]) {\n \n         debug!(\"ty::TraitRef\\n  subst: {:?}\\n\", trait_ref.substs);\n \n-        ResolvedPath { path, did: trait_ref.def_id }\n+        path\n     }\n }\n \n-impl<'tcx> Clean<GenericBound> for ty::TraitRef<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> GenericBound {\n-        GenericBound::TraitBound(\n-            PolyTrait { trait_: (*self, &[][..]).clean(cx), generic_params: vec![] },\n-            hir::TraitBoundModifier::None,\n-        )\n+impl Clean<Path> for ty::TraitRef<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Path {\n+        (*self, &[][..]).clean(cx)\n     }\n }\n \n@@ -384,16 +381,13 @@ impl<'tcx> Clean<WherePredicate> for ty::ProjectionPredicate<'tcx> {\n impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n         let lifted = self.lift_to_tcx(cx.tcx).unwrap();\n-        let trait_ = match lifted.trait_ref(cx.tcx).clean(cx) {\n-            GenericBound::TraitBound(t, _) => t.trait_,\n-            GenericBound::Outlives(_) => panic!(\"cleaning a trait got a lifetime\"),\n-        };\n+        let trait_ = lifted.trait_ref(cx.tcx).clean(cx);\n         let self_type = self.self_ty().clean(cx);\n         Type::QPath {\n             name: cx.tcx.associated_item(self.item_def_id).ident.name,\n             self_def_id: self_type.def_id(),\n             self_type: box self_type,\n-            trait_: box trait_,\n+            trait_,\n         }\n     }\n }\n@@ -896,10 +890,11 @@ impl Clean<bool> for hir::IsAuto {\n     }\n }\n \n-impl Clean<Type> for hir::TraitRef<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n+impl Clean<Path> for hir::TraitRef<'_> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Path {\n         let path = self.path.clean(cx);\n-        resolve_type(cx, path)\n+        register_res(cx, path.res);\n+        path\n     }\n }\n \n@@ -1105,9 +1100,8 @@ impl Clean<Item> for ty::AssocItem {\n                             if *name != my_name {\n                                 return None;\n                             }\n-                            match **trait_ {\n-                                ResolvedPath { did, .. } if did == self.container.id() => {}\n-                                _ => return None,\n+                            if trait_.def_id() != self.container.id() {\n+                                return None;\n                             }\n                             match **self_type {\n                                 Generic(ref s) if *s == kw::SelfUpper => {}\n@@ -1273,19 +1267,18 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n                 return normalized_value.clean(cx);\n             }\n \n-            let segments = if p.is_global() { &p.segments[1..] } else { &p.segments };\n-            let trait_segments = &segments[..segments.len() - 1];\n+            let trait_segments = &p.segments[..p.segments.len() - 1];\n             let trait_def = cx.tcx.associated_item(p.res.def_id()).container.id();\n-            let trait_path = self::Path {\n-                global: p.is_global(),\n+            let trait_ = self::Path {\n                 res: Res::Def(DefKind::Trait, trait_def),\n                 segments: trait_segments.clean(cx),\n             };\n+            register_res(cx, trait_.res);\n             Type::QPath {\n                 name: p.segments.last().expect(\"segments were empty\").ident.name,\n                 self_def_id: Some(DefId::local(qself.hir_id.owner.local_def_index)),\n                 self_type: box qself.clean(cx),\n-                trait_: box resolve_type(cx, trait_path),\n+                trait_,\n             }\n         }\n         hir::QPath::TypeRelative(ref qself, ref segment) => {\n@@ -1296,12 +1289,13 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n                 ty::Error(_) => return Type::Infer,\n                 _ => bug!(\"clean: expected associated type, found `{:?}`\", ty),\n             };\n-            let trait_path = hir::Path { span, res, segments: &[] }.clean(cx);\n+            let trait_ = hir::Path { span, res, segments: &[] }.clean(cx);\n+            register_res(cx, trait_.res);\n             Type::QPath {\n                 name: segment.ident.name,\n                 self_def_id: res.opt_def_id(),\n                 self_type: box qself.clean(cx),\n-                trait_: box resolve_type(cx, trait_path),\n+                trait_,\n             }\n         }\n         hir::QPath::LangItem(..) => bug!(\"clean: requiring documentation of lang item\"),\n@@ -1470,10 +1464,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                     let empty = cx.tcx.intern_substs(&[]);\n                     let path = external_path(cx, did, false, vec![], empty);\n                     inline::record_extern_fqn(cx, did, ItemType::Trait);\n-                    let bound = PolyTrait {\n-                        trait_: ResolvedPath { path, did },\n-                        generic_params: Vec::new(),\n-                    };\n+                    let bound = PolyTrait { trait_: path, generic_params: Vec::new() };\n                     bounds.push(bound);\n                 }\n \n@@ -1486,10 +1477,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 }\n \n                 let path = external_path(cx, did, false, bindings, substs);\n-                bounds.insert(\n-                    0,\n-                    PolyTrait { trait_: ResolvedPath { path, did }, generic_params: Vec::new() },\n-                );\n+                bounds.insert(0, PolyTrait { trait_: path, generic_params: Vec::new() });\n \n                 DynTrait(bounds, lifetime)\n             }\n@@ -1728,11 +1716,7 @@ impl Clean<Variant> for hir::VariantData<'_> {\n \n impl Clean<Path> for hir::Path<'_> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Path {\n-        Path {\n-            global: self.is_global(),\n-            res: self.res,\n-            segments: if self.is_global() { &self.segments[1..] } else { &self.segments }.clean(cx),\n-        }\n+        Path { res: self.res, segments: self.segments.clean(cx) }\n     }\n }\n \n@@ -1898,7 +1882,7 @@ fn clean_impl(impl_: &hir::Impl<'_>, hir_id: hir::HirId, cx: &mut DocContext<'_>\n \n     // If this impl block is an implementation of the Deref trait, then we\n     // need to try inlining the target's inherent impl blocks as well.\n-    if trait_.def_id() == tcx.lang_items().deref_trait() {\n+    if trait_.as_ref().map(|t| t.def_id()) == tcx.lang_items().deref_trait() {\n         build_deref_target_impls(cx, &items, &mut ret);\n     }\n \n@@ -1907,7 +1891,7 @@ fn clean_impl(impl_: &hir::Impl<'_>, hir_id: hir::HirId, cx: &mut DocContext<'_>\n         DefKind::TyAlias => Some(tcx.type_of(did).clean(cx)),\n         _ => None,\n     });\n-    let mut make_item = |trait_: Option<Type>, for_: Type, items: Vec<Item>| {\n+    let mut make_item = |trait_: Option<Path>, for_: Type, items: Vec<Item>| {\n         let kind = ImplItem(Impl {\n             span: types::rustc_span(tcx.hir().local_def_id(hir_id).to_def_id(), tcx),\n             unsafety: impl_.unsafety,"}, {"sha": "4c81e75e8d6304b49b8055d90f75fcb0a7c98c4a", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8f2463c68a6532d74a13ec402ec5b513e4e2726/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f2463c68a6532d74a13ec402ec5b513e4e2726/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=a8f2463c68a6532d74a13ec402ec5b513e4e2726", "patch": "@@ -99,17 +99,13 @@ crate fn merge_bounds(\n             clean::GenericBound::TraitBound(ref mut tr, _) => tr,\n             clean::GenericBound::Outlives(..) => return false,\n         };\n-        let (did, path) = match trait_ref.trait_ {\n-            clean::ResolvedPath { did, ref mut path, .. } => (did, path),\n-            _ => return false,\n-        };\n         // If this QPath's trait `trait_did` is the same as, or a supertrait\n         // of, the bound's trait `did` then we can keep going, otherwise\n         // this is just a plain old equality bound.\n-        if !trait_is_same_or_supertrait(cx, did, trait_did) {\n+        if !trait_is_same_or_supertrait(cx, trait_ref.trait_.def_id(), trait_did) {\n             return false;\n         }\n-        let last = path.segments.last_mut().expect(\"segments were empty\");\n+        let last = trait_ref.trait_.segments.last_mut().expect(\"segments were empty\");\n         match last.args {\n             PP::AngleBracketed { ref mut bindings, .. } => {\n                 bindings.push(clean::TypeBinding {"}, {"sha": "d4cea8b4a9d289cb757b8a699555a69835c1562a", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 78, "deletions": 71, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/a8f2463c68a6532d74a13ec402ec5b513e4e2726/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f2463c68a6532d74a13ec402ec5b513e4e2726/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=a8f2463c68a6532d74a13ec402ec5b513e4e2726", "patch": "@@ -120,8 +120,7 @@ crate struct Crate {\n     crate module: Item,\n     crate externs: Vec<ExternalCrate>,\n     crate primitives: ThinVec<(DefId, PrimitiveType)>,\n-    // These are later on moved into `CACHEKEY`, leaving the map empty.\n-    // Only here so that they can be filtered through the rustdoc passes.\n+    /// Only here so that they can be filtered through the rustdoc passes.\n     crate external_traits: Rc<RefCell<FxHashMap<DefId, TraitWithExtraInfo>>>,\n     crate collapsed: bool,\n }\n@@ -1147,15 +1146,15 @@ impl GenericBound {\n         let path = external_path(cx, did, false, vec![], empty);\n         inline::record_extern_fqn(cx, did, ItemType::Trait);\n         GenericBound::TraitBound(\n-            PolyTrait { trait_: ResolvedPath { path, did }, generic_params: Vec::new() },\n+            PolyTrait { trait_: path, generic_params: Vec::new() },\n             hir::TraitBoundModifier::Maybe,\n         )\n     }\n \n     crate fn is_sized_bound(&self, cx: &DocContext<'_>) -> bool {\n         use rustc_hir::TraitBoundModifier as TBM;\n         if let GenericBound::TraitBound(PolyTrait { ref trait_, .. }, TBM::None) = *self {\n-            if trait_.def_id() == cx.tcx.lang_items().sized_trait() {\n+            if Some(trait_.def_id()) == cx.tcx.lang_items().sized_trait() {\n                 return true;\n             }\n         }\n@@ -1169,7 +1168,7 @@ impl GenericBound {\n         None\n     }\n \n-    crate fn get_trait_type(&self) -> Option<Type> {\n+    crate fn get_trait_path(&self) -> Option<Path> {\n         if let GenericBound::TraitBound(PolyTrait { ref trait_, .. }, _) = *self {\n             Some(trait_.clone())\n         } else {\n@@ -1401,53 +1400,53 @@ crate struct TraitAlias {\n /// A trait reference, which may have higher ranked lifetimes.\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n crate struct PolyTrait {\n-    crate trait_: Type,\n+    crate trait_: Path,\n     crate generic_params: Vec<GenericParamDef>,\n }\n \n-/// A representation of a type suitable for hyperlinking purposes. Ideally, one can get the original\n-/// type out of the AST/`TyCtxt` given one of these, if more information is needed. Most\n-/// importantly, it does not preserve mutability or boxes.\n+/// Rustdoc's representation of types, mostly based on the [`hir::Ty`].\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n crate enum Type {\n-    /// Structs/enums/traits (most that would be an `hir::TyKind::Path`).\n-    ResolvedPath {\n-        path: Path,\n-        did: DefId,\n-    },\n-    /// `dyn for<'a> Trait<'a> + Send + 'static`\n+    /// A named type, which could be a trait.\n+    ///\n+    /// This is mostly Rustdoc's version of [`hir::Path`]. It has to be different because Rustdoc's [`PathSegment`] can contain cleaned generics.\n+    ResolvedPath { path: Path, did: DefId },\n+    /// A `dyn Trait` object: `dyn for<'a> Trait<'a> + Send + 'static`\n     DynTrait(Vec<PolyTrait>, Option<Lifetime>),\n-    /// For parameterized types, so the consumer of the JSON don't go\n-    /// looking for types which don't exist anywhere.\n+    /// A type parameter.\n     Generic(Symbol),\n-    /// Primitives are the fixed-size numeric types (plus int/usize/float), char,\n-    /// arrays, slices, and tuples.\n+    /// A primitive (aka, builtin) type.\n     Primitive(PrimitiveType),\n-    /// `extern \"ABI\" fn`\n+    /// A function pointer: `extern \"ABI\" fn(...) -> ...`\n     BareFunction(Box<BareFunctionDecl>),\n+    /// A tuple type: `(i32, &str)`.\n     Tuple(Vec<Type>),\n+    /// A slice type (does *not* include the `&`): `[i32]`\n     Slice(Box<Type>),\n-    /// The `String` field is about the size or the constant representing the array's length.\n+    /// An array type.\n+    ///\n+    /// The `String` field is a stringified version of the array's length parameter.\n     Array(Box<Type>, String),\n+    /// A raw pointer type: `*const i32`, `*mut i32`\n     RawPointer(Mutability, Box<Type>),\n-    BorrowedRef {\n-        lifetime: Option<Lifetime>,\n-        mutability: Mutability,\n-        type_: Box<Type>,\n-    },\n+    /// A reference type: `&i32`, `&'a mut Foo`\n+    BorrowedRef { lifetime: Option<Lifetime>, mutability: Mutability, type_: Box<Type> },\n \n-    // `<Type as Trait>::Name`\n+    /// A qualified path to an associated item: `<Type as Trait>::Name`\n     QPath {\n         name: Symbol,\n         self_type: Box<Type>,\n+        /// FIXME: This is a hack that should be removed; see [this discussion][1].\n+        ///\n+        /// [1]: https://github.com/rust-lang/rust/pull/85479#discussion_r635729093\n         self_def_id: Option<DefId>,\n-        trait_: Box<Type>,\n+        trait_: Path,\n     },\n \n-    // `_`\n+    /// A type that is inferred: `_`\n     Infer,\n \n-    // `impl TraitA + TraitB + ...`\n+    /// An `impl Trait`: `impl TraitA + TraitB + ...`\n     ImplTrait(Vec<GenericBound>),\n }\n \n@@ -1514,34 +1513,8 @@ impl Type {\n     }\n \n     crate fn generics(&self) -> Option<Vec<&Type>> {\n-        match *self {\n-            ResolvedPath { ref path, .. } => path.segments.last().and_then(|seg| {\n-                if let GenericArgs::AngleBracketed { ref args, .. } = seg.args {\n-                    Some(\n-                        args.iter()\n-                            .filter_map(|arg| match arg {\n-                                GenericArg::Type(ty) => Some(ty),\n-                                _ => None,\n-                            })\n-                            .collect(),\n-                    )\n-                } else {\n-                    None\n-                }\n-            }),\n-            _ => None,\n-        }\n-    }\n-\n-    crate fn bindings(&self) -> Option<&[TypeBinding]> {\n-        match *self {\n-            ResolvedPath { ref path, .. } => path.segments.last().and_then(|seg| {\n-                if let GenericArgs::AngleBracketed { ref bindings, .. } = seg.args {\n-                    Some(&**bindings)\n-                } else {\n-                    None\n-                }\n-            }),\n+        match self {\n+            ResolvedPath { path, .. } => path.generics(),\n             _ => None,\n         }\n     }\n@@ -1559,17 +1532,13 @@ impl Type {\n             QPath { self_type, trait_, name, .. } => (self_type, trait_, name),\n             _ => return None,\n         };\n-        let trait_did = match **trait_ {\n-            ResolvedPath { did, .. } => did,\n-            _ => return None,\n-        };\n-        Some((&self_, trait_did, *name))\n+        Some((&self_, trait_.def_id(), *name))\n     }\n \n     fn inner_def_id(&self, cache: Option<&Cache>) -> Option<DefId> {\n         let t: PrimitiveType = match *self {\n             ResolvedPath { did, .. } => return Some(did),\n-            DynTrait(ref bounds, _) => return bounds[0].trait_.inner_def_id(cache),\n+            DynTrait(ref bounds, _) => return Some(bounds[0].trait_.def_id()),\n             Primitive(p) => return cache.and_then(|c| c.primitive_locations.get(&p).cloned()),\n             BorrowedRef { type_: box Generic(..), .. } => PrimitiveType::Reference,\n             BorrowedRef { ref type_, .. } => return type_.inner_def_id(cache),\n@@ -1601,8 +1570,12 @@ impl GetDefId for Type {\n     }\n }\n \n-/// N.B. this has to be different from `hir::PrimTy` because it also includes types that aren't\n-/// paths, like `Unit`.\n+/// A primitive (aka, builtin) type.\n+///\n+/// This represents things like `i32`, `str`, etc.\n+///\n+/// N.B. This has to be different from [`hir::PrimTy`] because it also includes types that aren't\n+/// paths, like [`Self::Unit`].\n #[derive(Clone, PartialEq, Eq, Hash, Copy, Debug)]\n crate enum PrimitiveType {\n     Isize,\n@@ -2000,12 +1973,15 @@ impl Span {\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n crate struct Path {\n-    crate global: bool,\n     crate res: Res,\n     crate segments: Vec<PathSegment>,\n }\n \n impl Path {\n+    crate fn def_id(&self) -> DefId {\n+        self.res.def_id()\n+    }\n+\n     crate fn last(&self) -> Symbol {\n         self.segments.last().expect(\"segments were empty\").name\n     }\n@@ -2015,8 +1991,11 @@ impl Path {\n     }\n \n     crate fn whole_name(&self) -> String {\n-        String::from(if self.global { \"::\" } else { \"\" })\n-            + &self.segments.iter().map(|s| s.name.to_string()).collect::<Vec<_>>().join(\"::\")\n+        self.segments\n+            .iter()\n+            .map(|s| if s.name == kw::PathRoot { String::new() } else { s.name.to_string() })\n+            .intersperse(\"::\".into())\n+            .collect()\n     }\n \n     /// Checks if this is a `T::Name` path for an associated type.\n@@ -2028,6 +2007,33 @@ impl Path {\n             _ => false,\n         }\n     }\n+\n+    crate fn generics(&self) -> Option<Vec<&Type>> {\n+        self.segments.last().and_then(|seg| {\n+            if let GenericArgs::AngleBracketed { ref args, .. } = seg.args {\n+                Some(\n+                    args.iter()\n+                        .filter_map(|arg| match arg {\n+                            GenericArg::Type(ty) => Some(ty),\n+                            _ => None,\n+                        })\n+                        .collect(),\n+                )\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+\n+    crate fn bindings(&self) -> Option<&[TypeBinding]> {\n+        self.segments.last().and_then(|seg| {\n+            if let GenericArgs::AngleBracketed { ref bindings, .. } = seg.args {\n+                Some(&**bindings)\n+            } else {\n+                None\n+            }\n+        })\n+    }\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n@@ -2171,7 +2177,7 @@ crate struct Impl {\n     crate span: Span,\n     crate unsafety: hir::Unsafety,\n     crate generics: Generics,\n-    crate trait_: Option<Type>,\n+    crate trait_: Option<Path>,\n     crate for_: Type,\n     crate items: Vec<Item>,\n     crate negative_polarity: bool,\n@@ -2182,7 +2188,8 @@ crate struct Impl {\n impl Impl {\n     crate fn provided_trait_methods(&self, tcx: TyCtxt<'_>) -> FxHashSet<Symbol> {\n         self.trait_\n-            .def_id()\n+            .as_ref()\n+            .map(|t| t.def_id())\n             .map(|did| tcx.provided_trait_methods(did).map(|meth| meth.ident.name).collect())\n             .unwrap_or_default()\n     }"}, {"sha": "de43daff6f0d7c8416420d53ee86103a2a4f892a", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 4, "deletions": 36, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a8f2463c68a6532d74a13ec402ec5b513e4e2726/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f2463c68a6532d74a13ec402ec5b513e4e2726/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=a8f2463c68a6532d74a13ec402ec5b513e4e2726", "patch": "@@ -2,7 +2,7 @@ use crate::clean::auto_trait::AutoTraitFinder;\n use crate::clean::blanket_impl::BlanketImplFinder;\n use crate::clean::{\n     inline, Clean, Crate, ExternalCrate, Generic, GenericArg, GenericArgs, ImportSource, Item,\n-    ItemKind, Lifetime, Path, PathSegment, PolyTrait, Primitive, PrimitiveType, ResolvedPath, Type,\n+    ItemKind, Lifetime, Path, PathSegment, Primitive, PrimitiveType, ResolvedPath, Type,\n     TypeBinding, Visibility,\n };\n use crate::core::DocContext;\n@@ -147,7 +147,6 @@ pub(super) fn external_path(\n     let def_kind = cx.tcx.def_kind(did);\n     let name = cx.tcx.item_name(did);\n     Path {\n-        global: false,\n         res: Res::Def(def_kind, did),\n         segments: vec![PathSegment {\n             name,\n@@ -156,39 +155,8 @@ pub(super) fn external_path(\n     }\n }\n \n-crate fn strip_type(ty: Type) -> Type {\n-    match ty {\n-        Type::ResolvedPath { path, did } => Type::ResolvedPath { path: strip_path(&path), did },\n-        Type::DynTrait(mut bounds, lt) => {\n-            let first = bounds.remove(0);\n-            let stripped_trait = strip_type(first.trait_);\n-\n-            bounds.insert(\n-                0,\n-                PolyTrait { trait_: stripped_trait, generic_params: first.generic_params },\n-            );\n-            Type::DynTrait(bounds, lt)\n-        }\n-        Type::Tuple(inner_tys) => {\n-            Type::Tuple(inner_tys.iter().map(|t| strip_type(t.clone())).collect())\n-        }\n-        Type::Slice(inner_ty) => Type::Slice(Box::new(strip_type(*inner_ty))),\n-        Type::Array(inner_ty, s) => Type::Array(Box::new(strip_type(*inner_ty)), s),\n-        Type::RawPointer(m, inner_ty) => Type::RawPointer(m, Box::new(strip_type(*inner_ty))),\n-        Type::BorrowedRef { lifetime, mutability, type_ } => {\n-            Type::BorrowedRef { lifetime, mutability, type_: Box::new(strip_type(*type_)) }\n-        }\n-        Type::QPath { name, self_type, trait_, self_def_id } => Type::QPath {\n-            name,\n-            self_def_id,\n-            self_type: Box::new(strip_type(*self_type)),\n-            trait_: Box::new(strip_type(*trait_)),\n-        },\n-        _ => ty,\n-    }\n-}\n-\n-crate fn strip_path(path: &Path) -> Path {\n+/// Remove the generic arguments from a path.\n+crate fn strip_path_generics(path: Path) -> Path {\n     let segments = path\n         .segments\n         .iter()\n@@ -198,7 +166,7 @@ crate fn strip_path(path: &Path) -> Path {\n         })\n         .collect();\n \n-    Path { global: path.global, res: path.res, segments }\n+    Path { res: path.res, segments }\n }\n \n crate fn qpath_to_string(p: &hir::QPath<'_>) -> String {"}, {"sha": "8b883ffaaf095cb4419f12f96bab71f6807b4002", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a8f2463c68a6532d74a13ec402ec5b513e4e2726/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f2463c68a6532d74a13ec402ec5b513e4e2726/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=a8f2463c68a6532d74a13ec402ec5b513e4e2726", "patch": "@@ -203,7 +203,9 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n         // masked crate then remove it completely.\n         if let clean::ImplItem(ref i) = *item.kind {\n             if self.cache.masked_crates.contains(&item.def_id.krate())\n-                || i.trait_.def_id().map_or(false, |d| self.cache.masked_crates.contains(&d.krate))\n+                || i.trait_\n+                    .as_ref()\n+                    .map_or(false, |t| self.cache.masked_crates.contains(&t.def_id().krate))\n                 || i.for_.def_id().map_or(false, |d| self.cache.masked_crates.contains(&d.krate))\n             {\n                 return None;\n@@ -223,11 +225,11 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n \n         // Collect all the implementors of traits.\n         if let clean::ImplItem(ref i) = *item.kind {\n-            if let Some(did) = i.trait_.def_id() {\n+            if let Some(trait_) = &i.trait_ {\n                 if i.blanket_impl.is_none() {\n                     self.cache\n                         .implementors\n-                        .entry(did)\n+                        .entry(trait_.def_id())\n                         .or_default()\n                         .push(Impl { impl_item: item.clone() });\n                 }\n@@ -402,12 +404,8 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                     }\n                     clean::DynTrait(ref bounds, _)\n                     | clean::BorrowedRef { type_: box clean::DynTrait(ref bounds, _), .. } => {\n-                        if let Some(did) = bounds[0].trait_.def_id() {\n-                            self.cache.parent_stack.push(did);\n-                            true\n-                        } else {\n-                            false\n-                        }\n+                        self.cache.parent_stack.push(bounds[0].trait_.def_id());\n+                        true\n                     }\n                     ref t => {\n                         let prim_did = t\n@@ -441,9 +439,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                 }\n                 clean::DynTrait(ref bounds, _)\n                 | clean::BorrowedRef { type_: box clean::DynTrait(ref bounds, _), .. } => {\n-                    if let Some(did) = bounds[0].trait_.def_id() {\n-                        dids.insert(did);\n-                    }\n+                    dids.insert(bounds[0].trait_.def_id());\n                 }\n                 ref t => {\n                     let did = t"}, {"sha": "4f0c5a9edee7185581c71bd1846d0151105f015a", "filename": "src/librustdoc/formats/mod.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a8f2463c68a6532d74a13ec402ec5b513e4e2726/src%2Flibrustdoc%2Fformats%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f2463c68a6532d74a13ec402ec5b513e4e2726/src%2Flibrustdoc%2Fformats%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fmod.rs?ref=a8f2463c68a6532d74a13ec402ec5b513e4e2726", "patch": "@@ -7,14 +7,12 @@ use rustc_hir::def_id::DefId;\n crate use renderer::{run_format, FormatRenderer};\n \n use crate::clean;\n-use crate::clean::types::GetDefId;\n-use crate::formats::cache::Cache;\n \n /// Specifies whether rendering directly implemented trait items or ones from a certain Deref\n /// impl.\n crate enum AssocItemRender<'a> {\n     All,\n-    DerefFor { trait_: &'a clean::Type, type_: &'a clean::Type, deref_mut_: bool },\n+    DerefFor { trait_: &'a clean::Path, type_: &'a clean::Type, deref_mut_: bool },\n }\n \n /// For different handling of associated items from the Deref target of a type rather than the type\n@@ -40,10 +38,6 @@ impl Impl {\n     }\n \n     crate fn trait_did(&self) -> Option<DefId> {\n-        self.inner_impl().trait_.def_id()\n-    }\n-\n-    crate fn trait_did_full(&self, cache: &Cache) -> Option<DefId> {\n-        self.inner_impl().trait_.def_id_full(cache)\n+        self.inner_impl().trait_.as_ref().map(|t| t.def_id())\n     }\n }"}, {"sha": "f2751947c7eb95a6db9b8d8154e11e7e17228f84", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 36, "deletions": 39, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/a8f2463c68a6532d74a13ec402ec5b513e4e2726/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f2463c68a6532d74a13ec402ec5b513e4e2726/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=a8f2463c68a6532d74a13ec402ec5b513e4e2726", "patch": "@@ -18,9 +18,7 @@ use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::CRATE_DEF_INDEX;\n use rustc_target::spec::abi::Abi;\n \n-use crate::clean::{\n-    self, utils::find_nearest_parent_module, ExternalCrate, GetDefId, ItemId, PrimitiveType,\n-};\n+use crate::clean::{self, utils::find_nearest_parent_module, ExternalCrate, ItemId, PrimitiveType};\n use crate::formats::item_type::ItemType;\n use crate::html::escape::Escape;\n use crate::html::render::cache::ExternalLocation;\n@@ -914,15 +912,10 @@ fn fmt_type<'cx>(\n             }\n         }\n         clean::QPath { ref name, ref self_type, ref trait_, ref self_def_id } => {\n-            let should_show_cast = match *trait_ {\n-                box clean::ResolvedPath { ref path, .. } => {\n-                    !path.segments.is_empty()\n-                        && self_def_id\n-                            .zip(trait_.def_id())\n-                            .map_or(!self_type.is_self_type(), |(id, trait_)| id != trait_)\n-                }\n-                _ => true,\n-            };\n+            let should_show_cast = !trait_.segments.is_empty()\n+                && self_def_id\n+                    .zip(Some(trait_.def_id()))\n+                    .map_or(!self_type.is_self_type(), |(id, trait_)| id != trait_);\n             if f.alternate() {\n                 if should_show_cast {\n                     write!(f, \"<{:#} as {:#}>::\", self_type.print(cx), trait_.print(cx))?\n@@ -936,36 +929,31 @@ fn fmt_type<'cx>(\n                     write!(f, \"{}::\", self_type.print(cx))?\n                 }\n             };\n-            match *trait_ {\n-                // It's pretty unsightly to look at `<A as B>::C` in output, and\n-                // we've got hyperlinking on our side, so try to avoid longer\n-                // notation as much as possible by making `C` a hyperlink to trait\n-                // `B` to disambiguate.\n-                //\n-                // FIXME: this is still a lossy conversion and there should probably\n-                //        be a better way of representing this in general? Most of\n-                //        the ugliness comes from inlining across crates where\n-                //        everything comes in as a fully resolved QPath (hard to\n-                //        look at).\n-                box clean::ResolvedPath { did, .. } => {\n-                    match href(did, cx) {\n-                        Ok((ref url, _, ref path)) if !f.alternate() => {\n-                            write!(\n-                                f,\n-                                \"<a class=\\\"type\\\" href=\\\"{url}#{shortty}.{name}\\\" \\\n+            // It's pretty unsightly to look at `<A as B>::C` in output, and\n+            // we've got hyperlinking on our side, so try to avoid longer\n+            // notation as much as possible by making `C` a hyperlink to trait\n+            // `B` to disambiguate.\n+            //\n+            // FIXME: this is still a lossy conversion and there should probably\n+            //        be a better way of representing this in general? Most of\n+            //        the ugliness comes from inlining across crates where\n+            //        everything comes in as a fully resolved QPath (hard to\n+            //        look at).\n+            match href(trait_.def_id(), cx) {\n+                Ok((ref url, _, ref path)) if !f.alternate() => {\n+                    write!(\n+                        f,\n+                        \"<a class=\\\"type\\\" href=\\\"{url}#{shortty}.{name}\\\" \\\n                                     title=\\\"type {path}::{name}\\\">{name}</a>\",\n-                                url = url,\n-                                shortty = ItemType::AssocType,\n-                                name = name,\n-                                path = path.join(\"::\")\n-                            )?;\n-                        }\n-                        _ => write!(f, \"{}\", name)?,\n-                    }\n-                    Ok(())\n+                        url = url,\n+                        shortty = ItemType::AssocType,\n+                        name = name,\n+                        path = path.join(\"::\")\n+                    )?;\n                 }\n-                _ => write!(f, \"{}\", name),\n+                _ => write!(f, \"{}\", name)?,\n             }\n+            Ok(())\n         }\n     }\n }\n@@ -979,6 +967,15 @@ impl clean::Type {\n     }\n }\n \n+impl clean::Path {\n+    crate fn print<'b, 'a: 'b, 'tcx: 'a>(\n+        &'a self,\n+        cx: &'a Context<'tcx>,\n+    ) -> impl fmt::Display + 'b + Captures<'tcx> {\n+        display_fn(move |f| resolved_path(f, self.def_id(), self, false, false, cx))\n+    }\n+}\n+\n impl clean::Impl {\n     crate fn print<'a, 'tcx: 'a>(\n         &'a self,"}, {"sha": "9c05c80d55dfea35a5b8c820657ec6950d6a1394", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a8f2463c68a6532d74a13ec402ec5b513e4e2726/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f2463c68a6532d74a13ec402ec5b513e4e2726/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=a8f2463c68a6532d74a13ec402ec5b513e4e2726", "patch": "@@ -226,16 +226,13 @@ fn get_index_type(clean_type: &clean::Type) -> RenderType {\n fn get_index_type_name(clean_type: &clean::Type, accept_generic: bool) -> Option<Symbol> {\n     match *clean_type {\n         clean::ResolvedPath { ref path, .. } => {\n-            let segments = &path.segments;\n-            let path_segment = segments.iter().last().unwrap_or_else(|| {\n-                panic!(\n-                \"get_index_type_name(clean_type: {:?}, accept_generic: {:?}) had length zero path\",\n-                clean_type, accept_generic\n-            )\n-            });\n+            let path_segment = path.segments.last().unwrap();\n             Some(path_segment.name)\n         }\n-        clean::DynTrait(ref bounds, _) => get_index_type_name(&bounds[0].trait_, accept_generic),\n+        clean::DynTrait(ref bounds, _) => {\n+            let path = &bounds[0].trait_;\n+            Some(path.segments.last().unwrap().name)\n+        }\n         clean::Generic(s) if accept_generic => Some(s),\n         clean::Primitive(ref p) => Some(p.as_sym()),\n         clean::BorrowedRef { ref type_, .. } => get_index_type_name(type_, accept_generic),\n@@ -324,7 +321,8 @@ crate fn get_real_types<'tcx>(\n         }\n         if let Some(bound) = generics.params.iter().find(|g| g.is_type() && g.name == arg_s) {\n             for bound in bound.get_bounds().unwrap_or(&[]) {\n-                if let Some(ty) = bound.get_trait_type() {\n+                if let Some(path) = bound.get_trait_path() {\n+                    let ty = Type::ResolvedPath { did: path.def_id(), path };\n                     let adds = get_real_types(generics, &ty, tcx, recurse + 1, res);\n                     nb_added += adds;\n                     if adds == 0 && !ty.is_full_generic() {"}, {"sha": "4f189159747703dadf8d39f76f85d6675a4bfb51", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 53, "deletions": 67, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/a8f2463c68a6532d74a13ec402ec5b513e4e2726/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f2463c68a6532d74a13ec402ec5b513e4e2726/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=a8f2463c68a6532d74a13ec402ec5b513e4e2726", "patch": "@@ -716,18 +716,12 @@ fn short_item_info(\n \n // Render the list of items inside one of the sections \"Trait Implementations\",\n // \"Auto Trait Implementations,\" \"Blanket Trait Implementations\" (on struct/enum pages).\n-fn render_impls(\n-    cx: &Context<'_>,\n-    w: &mut Buffer,\n-    traits: &[&&Impl],\n-    containing_item: &clean::Item,\n-) {\n-    let cache = cx.cache();\n+fn render_impls(cx: &Context<'_>, w: &mut Buffer, impls: &[&&Impl], containing_item: &clean::Item) {\n     let tcx = cx.tcx();\n-    let mut impls = traits\n+    let mut rendered_impls = impls\n         .iter()\n         .map(|i| {\n-            let did = i.trait_did_full(cache).unwrap();\n+            let did = i.trait_did().unwrap();\n             let provided_trait_methods = i.inner_impl().provided_trait_methods(tcx);\n             let assoc_link = AssocItemLink::GotoSource(did.into(), &provided_trait_methods);\n             let mut buffer = if w.is_for_html() { Buffer::html() } else { Buffer::new() };\n@@ -751,8 +745,8 @@ fn render_impls(\n             buffer.into_inner()\n         })\n         .collect::<Vec<_>>();\n-    impls.sort();\n-    w.write_str(&impls.join(\"\"));\n+    rendered_impls.sort();\n+    w.write_str(&rendered_impls.join(\"\"));\n }\n \n fn naive_assoc_href(it: &clean::Item, link: AssocItemLink<'_>, cx: &Context<'_>) -> String {\n@@ -1097,13 +1091,11 @@ fn render_assoc_items(\n         return;\n     }\n     if !traits.is_empty() {\n-        let deref_impl = traits.iter().find(|t| {\n-            t.inner_impl().trait_.def_id_full(cache) == cx.tcx().lang_items().deref_trait()\n-        });\n+        let deref_impl =\n+            traits.iter().find(|t| t.trait_did() == cx.tcx().lang_items().deref_trait());\n         if let Some(impl_) = deref_impl {\n-            let has_deref_mut = traits.iter().any(|t| {\n-                t.inner_impl().trait_.def_id_full(cache) == cx.tcx().lang_items().deref_mut_trait()\n-            });\n+            let has_deref_mut =\n+                traits.iter().any(|t| t.trait_did() == cx.tcx().lang_items().deref_mut_trait());\n             render_deref_methods(w, cx, impl_, containing_item, has_deref_mut);\n         }\n         let (synthetic, concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n@@ -1221,45 +1213,39 @@ fn should_render_item(item: &clean::Item, deref_mut_: bool, tcx: TyCtxt<'_>) ->\n \n fn notable_traits_decl(decl: &clean::FnDecl, cx: &Context<'_>) -> String {\n     let mut out = Buffer::html();\n-    let mut trait_ = String::new();\n \n     if let Some(did) = decl.output.def_id_full(cx.cache()) {\n         if let Some(impls) = cx.cache().impls.get(&did) {\n             for i in impls {\n                 let impl_ = i.inner_impl();\n-                if impl_.trait_.def_id().map_or(false, |d| {\n-                    cx.cache().traits.get(&d).map(|t| t.is_notable).unwrap_or(false)\n-                }) {\n-                    if out.is_empty() {\n-                        write!(\n-                            &mut out,\n-                            \"<div class=\\\"notable\\\">Notable traits for {}</div>\\\n-                             <code class=\\\"content\\\">\",\n-                            impl_.for_.print(cx)\n-                        );\n-                        trait_.push_str(&impl_.for_.print(cx).to_string());\n-                    }\n+                if let Some(trait_) = &impl_.trait_ {\n+                    let trait_did = trait_.def_id();\n \n-                    //use the \"where\" class here to make it small\n-                    write!(\n-                        &mut out,\n-                        \"<span class=\\\"where fmt-newline\\\">{}</span>\",\n-                        impl_.print(false, cx)\n-                    );\n-                    let t_did = impl_.trait_.def_id_full(cx.cache()).unwrap();\n-                    for it in &impl_.items {\n-                        if let clean::TypedefItem(ref tydef, _) = *it.kind {\n-                            out.push_str(\"<span class=\\\"where fmt-newline\\\">    \");\n-                            assoc_type(\n+                    if cx.cache().traits.get(&trait_did).map_or(false, |t| t.is_notable) {\n+                        if out.is_empty() {\n+                            write!(\n                                 &mut out,\n-                                it,\n-                                &[],\n-                                Some(&tydef.type_),\n-                                AssocItemLink::GotoSource(t_did.into(), &FxHashSet::default()),\n-                                \"\",\n-                                cx,\n+                                \"<div class=\\\"notable\\\">Notable traits for {}</div>\\\n+                             <code class=\\\"content\\\">\",\n+                                impl_.for_.print(cx)\n                             );\n-                            out.push_str(\";</span>\");\n+                        }\n+\n+                        //use the \"where\" class here to make it small\n+                        write!(\n+                            &mut out,\n+                            \"<span class=\\\"where fmt-newline\\\">{}</span>\",\n+                            impl_.print(false, cx)\n+                        );\n+                        for it in &impl_.items {\n+                            if let clean::TypedefItem(ref tydef, _) = *it.kind {\n+                                out.push_str(\"<span class=\\\"where fmt-newline\\\">    \");\n+                                let empty_set = FxHashSet::default();\n+                                let src_link =\n+                                    AssocItemLink::GotoSource(trait_did.into(), &empty_set);\n+                                assoc_type(&mut out, it, &[], Some(&tydef.type_), src_link, \"\", cx);\n+                                out.push_str(\";</span>\");\n+                            }\n                         }\n                     }\n                 }\n@@ -1302,7 +1288,7 @@ fn render_impl(\n ) {\n     let cache = cx.cache();\n     let traits = &cache.traits;\n-    let trait_ = i.trait_did_full(cache).map(|did| &traits[&did]);\n+    let trait_ = i.trait_did().map(|did| &traits[&did]);\n     let mut close_tags = String::new();\n \n     // For trait implementations, the `interesting` output contains all methods that have doc\n@@ -1532,7 +1518,7 @@ fn render_impl(\n             if i.items.iter().any(|m| m.name == n) {\n                 continue;\n             }\n-            let did = i.trait_.as_ref().unwrap().def_id_full(cx.cache()).unwrap();\n+            let did = i.trait_.as_ref().unwrap().def_id();\n             let provided_methods = i.provided_trait_methods(cx.tcx());\n             let assoc_link = AssocItemLink::GotoSource(did.into(), &provided_methods);\n \n@@ -1917,9 +1903,9 @@ fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n         }\n \n         if v.iter().any(|i| i.inner_impl().trait_.is_some()) {\n-            if let Some(impl_) = v.iter().filter(|i| i.inner_impl().trait_.is_some()).find(|i| {\n-                i.inner_impl().trait_.def_id_full(cache) == cx.tcx().lang_items().deref_trait()\n-            }) {\n+            if let Some(impl_) =\n+                v.iter().find(|i| i.trait_did() == cx.tcx().lang_items().deref_trait())\n+            {\n                 sidebar_deref_methods(cx, out, impl_, v);\n             }\n \n@@ -2017,9 +2003,7 @@ fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &V\n                 }\n             }\n         }\n-        let deref_mut = v.iter().filter(|i| i.inner_impl().trait_.is_some()).any(|i| {\n-            i.inner_impl().trait_.def_id_full(c) == cx.tcx().lang_items().deref_mut_trait()\n-        });\n+        let deref_mut = v.iter().any(|i| i.trait_did() == cx.tcx().lang_items().deref_mut_trait());\n         let inner_impl = target\n             .def_id_full(c)\n             .or_else(|| {\n@@ -2086,10 +2070,10 @@ fn sidebar_struct(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, s: &clea\n \n fn get_id_for_impl_on_foreign_type(\n     for_: &clean::Type,\n-    trait_: &clean::Type,\n+    trait_: &clean::Path,\n     cx: &Context<'_>,\n ) -> String {\n-    small_url_encode(format!(\"impl-{:#}-for-{:#}\", trait_.print(cx), for_.print(cx),))\n+    small_url_encode(format!(\"impl-{:#}-for-{:#}\", trait_.print(cx), for_.print(cx)))\n }\n \n fn extract_for_impl_name(item: &clean::Item, cx: &Context<'_>) -> Option<(String, String)> {\n@@ -2400,6 +2384,15 @@ fn collect_paths_for_type(first_ty: clean::Type, cache: &Cache) -> Vec<String> {\n     let mut visited = FxHashSet::default();\n     let mut work = VecDeque::new();\n \n+    let mut process_path = |did: DefId| {\n+        let get_extern = || cache.external_paths.get(&did).map(|s| s.0.clone());\n+        let fqp = cache.exact_paths.get(&did).cloned().or_else(get_extern);\n+\n+        if let Some(path) = fqp {\n+            out.push(path.join(\"::\"));\n+        }\n+    };\n+\n     work.push_back(first_ty);\n \n     while let Some(ty) = work.pop_front() {\n@@ -2408,14 +2401,7 @@ fn collect_paths_for_type(first_ty: clean::Type, cache: &Cache) -> Vec<String> {\n         }\n \n         match ty {\n-            clean::Type::ResolvedPath { did, .. } => {\n-                let get_extern = || cache.external_paths.get(&did).map(|s| s.0.clone());\n-                let fqp = cache.exact_paths.get(&did).cloned().or_else(get_extern);\n-\n-                if let Some(path) = fqp {\n-                    out.push(path.join(\"::\"));\n-                }\n-            }\n+            clean::Type::ResolvedPath { did, .. } => process_path(did),\n             clean::Type::Tuple(tys) => {\n                 work.extend(tys.into_iter());\n             }\n@@ -2433,7 +2419,7 @@ fn collect_paths_for_type(first_ty: clean::Type, cache: &Cache) -> Vec<String> {\n             }\n             clean::Type::QPath { self_type, trait_, .. } => {\n                 work.push_back(*self_type);\n-                work.push_back(*trait_);\n+                process_path(trait_.def_id());\n             }\n             _ => {}\n         }"}, {"sha": "4098f17db818a576c7741282c7acb57c0029a93f", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a8f2463c68a6532d74a13ec402ec5b513e4e2726/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f2463c68a6532d74a13ec402ec5b513e4e2726/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=a8f2463c68a6532d74a13ec402ec5b513e4e2726", "patch": "@@ -364,8 +364,11 @@ impl FromWithTcx<clean::GenericBound> for GenericBound {\n         use clean::GenericBound::*;\n         match bound {\n             TraitBound(clean::PolyTrait { trait_, generic_params }, modifier) => {\n+                // FIXME: should `trait_` be a clean::Path equivalent in JSON?\n+                let trait_ =\n+                    clean::ResolvedPath { did: trait_.def_id(), path: trait_ }.into_tcx(tcx);\n                 GenericBound::TraitBound {\n-                    trait_: trait_.into_tcx(tcx),\n+                    trait_,\n                     generic_params: generic_params.into_iter().map(|x| x.into_tcx(tcx)).collect(),\n                     modifier: from_trait_bound_modifier(modifier),\n                 }\n@@ -395,15 +398,12 @@ impl FromWithTcx<clean::Type> for Type {\n                 param_names: Vec::new(),\n             },\n             DynTrait(mut bounds, lt) => {\n-                let (path, id) = match bounds.remove(0).trait_ {\n-                    ResolvedPath { path, did, .. } => (path, did),\n-                    _ => unreachable!(),\n-                };\n+                let first_trait = bounds.remove(0).trait_;\n \n                 Type::ResolvedPath {\n-                    name: path.whole_name(),\n-                    id: from_item_id(id.into()),\n-                    args: path\n+                    name: first_trait.whole_name(),\n+                    id: from_item_id(first_trait.def_id().into()),\n+                    args: first_trait\n                         .segments\n                         .last()\n                         .map(|args| Box::new(args.clone().args.into_tcx(tcx))),\n@@ -434,11 +434,15 @@ impl FromWithTcx<clean::Type> for Type {\n                 mutable: mutability == ast::Mutability::Mut,\n                 type_: Box::new((*type_).into_tcx(tcx)),\n             },\n-            QPath { name, self_type, trait_, .. } => Type::QualifiedPath {\n-                name: name.to_string(),\n-                self_type: Box::new((*self_type).into_tcx(tcx)),\n-                trait_: Box::new((*trait_).into_tcx(tcx)),\n-            },\n+            QPath { name, self_type, trait_, .. } => {\n+                // FIXME: should `trait_` be a clean::Path equivalent in JSON?\n+                let trait_ = ResolvedPath { did: trait_.def_id(), path: trait_ }.into_tcx(tcx);\n+                Type::QualifiedPath {\n+                    name: name.to_string(),\n+                    self_type: Box::new((*self_type).into_tcx(tcx)),\n+                    trait_: Box::new(trait_),\n+                }\n+            }\n         }\n     }\n }\n@@ -507,14 +511,19 @@ impl FromWithTcx<clean::Impl> for Impl {\n             blanket_impl,\n             span: _span,\n         } = impl_;\n+        // FIXME: should `trait_` be a clean::Path equivalent in JSON?\n+        let trait_ = trait_.map(|path| {\n+            let did = path.def_id();\n+            clean::ResolvedPath { path, did }.into_tcx(tcx)\n+        });\n         Impl {\n             is_unsafe: unsafety == rustc_hir::Unsafety::Unsafe,\n             generics: generics.into_tcx(tcx),\n             provided_trait_methods: provided_trait_methods\n                 .into_iter()\n                 .map(|x| x.to_string())\n                 .collect(),\n-            trait_: trait_.map(|x| x.into_tcx(tcx)),\n+            trait_,\n             for_: for_.into_tcx(tcx),\n             items: ids(items),\n             negative: negative_polarity,"}, {"sha": "319dd7b42b0ee69cb4d2d23d656f79188977aa82", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8f2463c68a6532d74a13ec402ec5b513e4e2726/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f2463c68a6532d74a13ec402ec5b513e4e2726/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=a8f2463c68a6532d74a13ec402ec5b513e4e2726", "patch": "@@ -57,7 +57,9 @@ crate fn collect_trait_impls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n     // scan through included items ahead of time to splice in Deref targets to the \"valid\" sets\n     for it in &new_items {\n         if let ImplItem(Impl { ref for_, ref trait_, ref items, .. }) = *it.kind {\n-            if cleaner.keep_impl(for_) && trait_.def_id() == cx.tcx.lang_items().deref_trait() {\n+            if cleaner.keep_impl(for_)\n+                && trait_.as_ref().map(|t| t.def_id()) == cx.tcx.lang_items().deref_trait()\n+            {\n                 let target = items\n                     .iter()\n                     .find_map(|item| match *item.kind {\n@@ -78,7 +80,9 @@ crate fn collect_trait_impls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n     new_items.retain(|it| {\n         if let ImplItem(Impl { ref for_, ref trait_, ref blanket_impl, .. }) = *it.kind {\n             cleaner.keep_impl(for_)\n-                || trait_.as_ref().map_or(false, |t| cleaner.keep_impl(t))\n+                || trait_\n+                    .as_ref()\n+                    .map_or(false, |t| cleaner.keep_impl_with_def_id(t.def_id().into()))\n                 || blanket_impl.is_some()\n         } else {\n             true"}, {"sha": "8b1fd662f85fdef57602ae5c3891b28af3547076", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8f2463c68a6532d74a13ec402ec5b513e4e2726/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f2463c68a6532d74a13ec402ec5b513e4e2726/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=a8f2463c68a6532d74a13ec402ec5b513e4e2726", "patch": "@@ -134,7 +134,7 @@ impl<'a> DocFolder for ImplStripper<'a> {\n                     return None;\n                 }\n             }\n-            if let Some(did) = imp.trait_.def_id() {\n+            if let Some(did) = imp.trait_.as_ref().map(|t| t.def_id()) {\n                 if did.is_local() && !self.retained.contains(&did.into()) {\n                     debug!(\"ImplStripper: impl item for stripped trait; removing\");\n                     return None;"}]}