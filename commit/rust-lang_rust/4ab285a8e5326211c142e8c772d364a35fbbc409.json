{"sha": "4ab285a8e5326211c142e8c772d364a35fbbc409", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhYjI4NWE4ZTUzMjYyMTFjMTQyZThjNzcyZDM2NGEzNWZiYmM0MDk=", "commit": {"author": {"name": "Domantas Jadenkus", "email": "djadenkus@gmail.com", "date": "2021-02-14T09:33:46Z"}, "committer": {"name": "Domantas Jadenkus", "email": "djadenkus@gmail.com", "date": "2021-02-27T10:05:59Z"}, "message": "make generate_enum_is_method work on any variants", "tree": {"sha": "2de464a3074738c12f551936d532620983c675e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2de464a3074738c12f551936d532620983c675e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ab285a8e5326211c142e8c772d364a35fbbc409", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ab285a8e5326211c142e8c772d364a35fbbc409", "html_url": "https://github.com/rust-lang/rust/commit/4ab285a8e5326211c142e8c772d364a35fbbc409", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ab285a8e5326211c142e8c772d364a35fbbc409/comments", "author": {"login": "jDomantas", "id": 8329015, "node_id": "MDQ6VXNlcjgzMjkwMTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8329015?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jDomantas", "html_url": "https://github.com/jDomantas", "followers_url": "https://api.github.com/users/jDomantas/followers", "following_url": "https://api.github.com/users/jDomantas/following{/other_user}", "gists_url": "https://api.github.com/users/jDomantas/gists{/gist_id}", "starred_url": "https://api.github.com/users/jDomantas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jDomantas/subscriptions", "organizations_url": "https://api.github.com/users/jDomantas/orgs", "repos_url": "https://api.github.com/users/jDomantas/repos", "events_url": "https://api.github.com/users/jDomantas/events{/privacy}", "received_events_url": "https://api.github.com/users/jDomantas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jDomantas", "id": 8329015, "node_id": "MDQ6VXNlcjgzMjkwMTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8329015?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jDomantas", "html_url": "https://github.com/jDomantas", "followers_url": "https://api.github.com/users/jDomantas/followers", "following_url": "https://api.github.com/users/jDomantas/following{/other_user}", "gists_url": "https://api.github.com/users/jDomantas/gists{/gist_id}", "starred_url": "https://api.github.com/users/jDomantas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jDomantas/subscriptions", "organizations_url": "https://api.github.com/users/jDomantas/orgs", "repos_url": "https://api.github.com/users/jDomantas/repos", "events_url": "https://api.github.com/users/jDomantas/events{/privacy}", "received_events_url": "https://api.github.com/users/jDomantas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f67586066d5299c11ee69823a6dfd3148eaa5ec7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f67586066d5299c11ee69823a6dfd3148eaa5ec7", "html_url": "https://github.com/rust-lang/rust/commit/f67586066d5299c11ee69823a6dfd3148eaa5ec7"}], "stats": {"total": 113, "additions": 95, "deletions": 18}, "files": [{"sha": "38aca0c88f1d2de786289641a707bf5595519c5b", "filename": "crates/ide_assists/src/handlers/generate_enum_match_method.rs", "status": "modified", "additions": 95, "deletions": 18, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/4ab285a8e5326211c142e8c772d364a35fbbc409/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_enum_match_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ab285a8e5326211c142e8c772d364a35fbbc409/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_enum_match_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_enum_match_method.rs?ref=4ab285a8e5326211c142e8c772d364a35fbbc409", "patch": "@@ -1,7 +1,6 @@\n use stdx::{format_to, to_lower_snake_case};\n use syntax::ast::VisibilityOwner;\n use syntax::ast::{self, AstNode, NameOwner};\n-use test_utils::mark;\n \n use crate::{\n     utils::{find_impl_block_end, find_struct_impl, generate_impl_text},\n@@ -37,20 +36,17 @@ use crate::{\n pub(crate) fn generate_enum_is_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let variant = ctx.find_node_at_offset::<ast::Variant>()?;\n     let variant_name = variant.name()?;\n-    let parent_enum = variant.parent_enum();\n-    if !matches!(variant.kind(), ast::StructKind::Unit) {\n-        mark::hit!(test_gen_enum_match_on_non_unit_variant_not_implemented);\n-        return None;\n-    }\n+    let parent_enum = ast::Adt::Enum(variant.parent_enum());\n+    let variant_kind = variant_kind(&variant);\n \n     let enum_lowercase_name = to_lower_snake_case(&parent_enum.name()?.to_string());\n-    let fn_name = to_lower_snake_case(&variant_name.to_string());\n+    let fn_name = format!(\"is_{}\", &to_lower_snake_case(variant_name.text()));\n \n     // Return early if we've found an existing new fn\n     let impl_def = find_struct_impl(\n         &ctx,\n-        &ast::Adt::Enum(parent_enum.clone()),\n-        format!(\"is_{}\", fn_name).as_str(),\n+        &parent_enum,\n+        &fn_name,\n     )?;\n \n     let target = variant.syntax().text_range();\n@@ -69,20 +65,21 @@ pub(crate) fn generate_enum_is_method(acc: &mut Assists, ctx: &AssistContext) ->\n             format_to!(\n                 buf,\n                 \"    /// Returns `true` if the {} is [`{}`].\n-    {}fn is_{}(&self) -> bool {{\n-        matches!(self, Self::{})\n+    {}fn {}(&self) -> bool {{\n+        matches!(self, Self::{}{})\n     }}\",\n                 enum_lowercase_name,\n                 variant_name,\n                 vis,\n                 fn_name,\n-                variant_name\n+                variant_name,\n+                variant_kind.pattern_suffix(),\n             );\n \n             let start_offset = impl_def\n                 .and_then(|impl_def| find_impl_block_end(impl_def, &mut buf))\n                 .unwrap_or_else(|| {\n-                    buf = generate_impl_text(&ast::Adt::Enum(parent_enum.clone()), &buf);\n+                    buf = generate_impl_text(&parent_enum, &buf);\n                     parent_enum.syntax().text_range().end()\n                 });\n \n@@ -91,10 +88,53 @@ pub(crate) fn generate_enum_is_method(acc: &mut Assists, ctx: &AssistContext) ->\n     )\n }\n \n+enum VariantKind {\n+    Unit,\n+    /// Tuple with a single field\n+    NewtypeTuple,\n+    /// Tuple with 0 or more than 2 fields\n+    Tuple,\n+    /// Record with a single field\n+    NewtypeRecord { field_name: Option<ast::Name> },\n+    /// Record with 0 or more than 2 fields\n+    Record,\n+}\n+\n+impl VariantKind {\n+    fn pattern_suffix(&self) -> &'static str {\n+        match self {\n+            VariantKind::Unit => \"\",\n+            VariantKind::NewtypeTuple |\n+            VariantKind::Tuple => \"(..)\",\n+            VariantKind::NewtypeRecord { .. } |\n+            VariantKind::Record => \" { .. }\",\n+        }\n+    }\n+}\n+\n+fn variant_kind(variant: &ast::Variant) -> VariantKind {\n+    match variant.kind() {\n+        ast::StructKind::Record(record) => {\n+            if record.fields().count() == 1 {\n+                let field_name = record.fields().nth(0).unwrap().name();\n+                VariantKind::NewtypeRecord { field_name }\n+            } else {\n+                VariantKind::Record\n+            }\n+        }\n+        ast::StructKind::Tuple(tuple) => {\n+            if tuple.fields().count() == 1 {\n+                VariantKind::NewtypeTuple\n+            } else {\n+                VariantKind::Tuple\n+            }\n+        }\n+        ast::StructKind::Unit => VariantKind::Unit,\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n-    use test_utils::mark;\n-\n     use crate::tests::{check_assist, check_assist_not_applicable};\n \n     use super::*;\n@@ -147,14 +187,51 @@ impl Variant {\n     }\n \n     #[test]\n-    fn test_add_from_impl_no_element() {\n-        mark::check!(test_gen_enum_match_on_non_unit_variant_not_implemented);\n-        check_not_applicable(\n+    fn test_generate_enum_match_from_tuple_variant() {\n+        check_assist(\n+            generate_enum_is_method,\n             r#\"\n enum Variant {\n     Undefined,\n     Minor(u32)$0,\n     Major,\n+}\"#,\n+            r#\"enum Variant {\n+    Undefined,\n+    Minor(u32),\n+    Major,\n+}\n+\n+impl Variant {\n+    /// Returns `true` if the variant is [`Minor`].\n+    fn is_minor(&self) -> bool {\n+        matches!(self, Self::Minor(..))\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_enum_match_from_record_variant() {\n+        check_assist(\n+            generate_enum_is_method,\n+            r#\"\n+enum Variant {\n+    Undefined,\n+    Minor { foo: i32 }$0,\n+    Major,\n+}\"#,\n+            r#\"enum Variant {\n+    Undefined,\n+    Minor { foo: i32 },\n+    Major,\n+}\n+\n+impl Variant {\n+    /// Returns `true` if the variant is [`Minor`].\n+    fn is_minor(&self) -> bool {\n+        matches!(self, Self::Minor { .. })\n+    }\n }\"#,\n         );\n     }"}]}