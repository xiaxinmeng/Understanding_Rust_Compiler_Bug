{"sha": "bb165eb5c21b057cb63a4421d6233e82deac4cba", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiMTY1ZWI1YzIxYjA1N2NiNjNhNDQyMWQ2MjMzZTgyZGVhYzRjYmE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-07-23T17:21:50Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-24T14:26:03Z"}, "message": "libsyntax: Remove `~self` and `mut ~self` from the language.\n\nThis eliminates the last vestige of the `~` syntax.\n\nInstead of `~self`, write `self: Box<TypeOfSelf>`; instead of `mut\n~self`, write `mut self: Box<TypeOfSelf>`, replacing `TypeOfSelf` with\nthe self-type parameter as specified in the implementation.\n\nCloses #13885.\n\n[breaking-change]", "tree": {"sha": "d322e182d6fea0796e00883954cd0a250c4b7fa4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d322e182d6fea0796e00883954cd0a250c4b7fa4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb165eb5c21b057cb63a4421d6233e82deac4cba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb165eb5c21b057cb63a4421d6233e82deac4cba", "html_url": "https://github.com/rust-lang/rust/commit/bb165eb5c21b057cb63a4421d6233e82deac4cba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb165eb5c21b057cb63a4421d6233e82deac4cba/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57cade574418e9507c67ba5177bc177cc7771721", "url": "https://api.github.com/repos/rust-lang/rust/commits/57cade574418e9507c67ba5177bc177cc7771721", "html_url": "https://github.com/rust-lang/rust/commit/57cade574418e9507c67ba5177bc177cc7771721"}], "stats": {"total": 187, "additions": 104, "deletions": 83}, "files": [{"sha": "b015cb0fbb8c679bab536198dab5e54d42fad9e9", "filename": "src/doc/rust.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=bb165eb5c21b057cb63a4421d6233e82deac4cba", "patch": "@@ -3864,13 +3864,13 @@ Function parameters are immutable unless declared with `mut`. The\n and `fn f(mut x: Box<int>, y: Box<int>)` declare one mutable variable `x` and\n one immutable variable `y`).\n \n-Methods that take either `self` or `~self` can optionally place them in a\n+Methods that take either `self` or `Box<Self>` can optionally place them in a\n mutable slot by prefixing them with `mut` (similar to regular arguments):\n \n ~~~\n trait Changer {\n     fn change(mut self) -> Self;\n-    fn modify(mut ~self) -> Box<Self>;\n+    fn modify(mut self: Box<Self>) -> Box<Self>;\n }\n ~~~\n "}, {"sha": "b6485f711ee7a4f75ff647aa627fad6afa6d4391", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=bb165eb5c21b057cb63a4421d6233e82deac4cba", "patch": "@@ -1971,7 +1971,7 @@ like any other function, except for the name `self`.\n \n The type of `self` is the type on which the method is implemented,\n or a pointer thereof. As an argument it is written either `self`,\n-`&self`, or `~self`.\n+`&self`, or `self: TYPE`.\n A caller must in turn have a compatible pointer type to call the method.\n \n ~~~\n@@ -1984,7 +1984,7 @@ A caller must in turn have a compatible pointer type to call the method.\n # }\n impl Shape {\n     fn draw_reference(&self) { /* ... */ }\n-    fn draw_owned(~self) { /* ... */ }\n+    fn draw_owned(self: Box<Shape>) { /* ... */ }\n     fn draw_value(self) { /* ... */ }\n }\n \n@@ -2009,7 +2009,7 @@ to a reference.\n # }\n # impl Shape {\n #    fn draw_reference(&self) { /* ... */ }\n-#    fn draw_owned(~self) { /* ... */ }\n+#    fn draw_owned(self: Box<Shape>) { /* ... */ }\n #    fn draw_value(self) { /* ... */ }\n # }\n # let s = Circle(Point { x: 1.0, y: 2.0 }, 3.0);"}, {"sha": "38bb6e355a77151857f370433b2518308d202f06", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=bb165eb5c21b057cb63a4421d6233e82deac4cba", "patch": "@@ -180,7 +180,7 @@ impl Scheduler {\n \n     // Take a main task to run, and a scheduler to run it in. Create a\n     // scheduler task and bootstrap into it.\n-    pub fn bootstrap(mut ~self) {\n+    pub fn bootstrap(mut self: Box<Scheduler>) {\n \n         // Build an Idle callback.\n         let cb = box SchedRunner as Box<Callback + Send>;\n@@ -224,7 +224,8 @@ impl Scheduler {\n \n     // This does not return a scheduler, as the scheduler is placed\n     // inside the task.\n-    pub fn run(mut ~self, stask: Box<GreenTask>) -> Box<GreenTask> {\n+    pub fn run(mut self: Box<Scheduler>, stask: Box<GreenTask>)\n+               -> Box<GreenTask> {\n \n         // This is unsafe because we need to place the scheduler, with\n         // the event_loop inside, inside our task. But we still need a\n@@ -271,7 +272,7 @@ impl Scheduler {\n     // If we try really hard to do some work, but no work is available to be\n     // done, then we fall back to epoll() to block this thread waiting for more\n     // work (instead of busy waiting).\n-    fn run_sched_once(mut ~self, stask: Box<GreenTask>) {\n+    fn run_sched_once(mut self: Box<Scheduler>, stask: Box<GreenTask>) {\n         // Make sure that we're not lying in that the `stask` argument is indeed\n         // the scheduler task for this scheduler.\n         assert!(self.sched_task.is_none());\n@@ -349,11 +350,10 @@ impl Scheduler {\n     // returns the still-available scheduler. At this point all\n     // message-handling will count as a turn of work, and as a result\n     // return None.\n-    fn interpret_message_queue(mut ~self, stask: Box<GreenTask>,\n+    fn interpret_message_queue(mut self: Box<Scheduler>,\n+                               stask: Box<GreenTask>,\n                                effort: EffortLevel)\n-            -> (Box<Scheduler>, Box<GreenTask>, bool)\n-    {\n-\n+                               -> (Box<Scheduler>, Box<GreenTask>, bool) {\n         let msg = if effort == DontTryTooHard {\n             self.message_queue.casual_pop()\n         } else {\n@@ -432,7 +432,7 @@ impl Scheduler {\n         }\n     }\n \n-    fn do_work(mut ~self, stask: Box<GreenTask>)\n+    fn do_work(mut self: Box<Scheduler>, stask: Box<GreenTask>)\n                -> (Box<Scheduler>, Box<GreenTask>, bool) {\n         rtdebug!(\"scheduler calling do work\");\n         match self.find_work() {\n@@ -517,7 +517,7 @@ impl Scheduler {\n     // * Task Routing Functions - Make sure tasks send up in the right\n     // place.\n \n-    fn process_task(mut ~self,\n+    fn process_task(mut self: Box<Scheduler>,\n                     cur: Box<GreenTask>,\n                     mut next: Box<GreenTask>,\n                     schedule_fn: SchedulingFn)\n@@ -610,7 +610,7 @@ impl Scheduler {\n     // cleanup function f, which takes the scheduler and the\n     // old task as inputs.\n \n-    pub fn change_task_context(mut ~self,\n+    pub fn change_task_context(mut self: Box<Scheduler>,\n                                mut current_task: Box<GreenTask>,\n                                mut next_task: Box<GreenTask>,\n                                f: |&mut Scheduler, Box<GreenTask>|)\n@@ -693,7 +693,7 @@ impl Scheduler {\n \n     // * Context Swapping Helpers - Here be ugliness!\n \n-    pub fn resume_task_immediately(~self,\n+    pub fn resume_task_immediately(self: Box<Scheduler>,\n                                    cur: Box<GreenTask>,\n                                    next: Box<GreenTask>)\n                                    -> (Box<Scheduler>, Box<GreenTask>) {\n@@ -733,7 +733,7 @@ impl Scheduler {\n     /// This situation is currently prevented, or in other words it is\n     /// guaranteed that this function will not return before the given closure\n     /// has returned.\n-    pub fn deschedule_running_task_and_then(mut ~self,\n+    pub fn deschedule_running_task_and_then(mut self: Box<Scheduler>,\n                                             cur: Box<GreenTask>,\n                                             f: |&mut Scheduler, BlockedTask|) {\n         // Trickier - we need to get the scheduler task out of self\n@@ -743,7 +743,7 @@ impl Scheduler {\n         self.switch_running_tasks_and_then(cur, stask, f)\n     }\n \n-    pub fn switch_running_tasks_and_then(~self,\n+    pub fn switch_running_tasks_and_then(self: Box<Scheduler>,\n                                          cur: Box<GreenTask>,\n                                          next: Box<GreenTask>,\n                                          f: |&mut Scheduler, BlockedTask|) {\n@@ -795,7 +795,9 @@ impl Scheduler {\n \n     /// Called by a running task to end execution, after which it will\n     /// be recycled by the scheduler for reuse in a new task.\n-    pub fn terminate_current_task(mut ~self, cur: Box<GreenTask>) -> ! {\n+    pub fn terminate_current_task(mut self: Box<Scheduler>,\n+                                  cur: Box<GreenTask>)\n+                                  -> ! {\n         // Similar to deschedule running task and then, but cannot go through\n         // the task-blocking path. The task is already dying.\n         let stask = self.sched_task.take_unwrap();\n@@ -807,7 +809,9 @@ impl Scheduler {\n         fail!(\"should never return!\");\n     }\n \n-    pub fn run_task(~self, cur: Box<GreenTask>, next: Box<GreenTask>) {\n+    pub fn run_task(self: Box<Scheduler>,\n+                    cur: Box<GreenTask>,\n+                    next: Box<GreenTask>) {\n         let (sched, task) =\n             self.process_task(cur, next, Scheduler::switch_task);\n         task.put_with_sched(sched);\n@@ -823,7 +827,7 @@ impl Scheduler {\n     /// to introduce some amount of randomness to the scheduler. Currently the\n     /// randomness is a result of performing a round of work stealing (which\n     /// may end up stealing from the current scheduler).\n-    pub fn yield_now(mut ~self, cur: Box<GreenTask>) {\n+    pub fn yield_now(mut self: Box<Scheduler>, cur: Box<GreenTask>) {\n         // Async handles trigger the scheduler by calling yield_now on the local\n         // task, which eventually gets us to here. See comments in SchedRunner\n         // for more info on this.\n@@ -842,7 +846,7 @@ impl Scheduler {\n         }\n     }\n \n-    pub fn maybe_yield(mut ~self, cur: Box<GreenTask>) {\n+    pub fn maybe_yield(mut self: Box<Scheduler>, cur: Box<GreenTask>) {\n         // It's possible for sched tasks to possibly call this function, and it\n         // just means that they're likely sending on channels (which\n         // occasionally call this function). Sched tasks follow different paths"}, {"sha": "6254e8c55f0075e41128e1cd70d10cc4f6f63bdf", "filename": "src/libgreen/simple.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibgreen%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibgreen%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsimple.rs?ref=bb165eb5c21b057cb63a4421d6233e82deac4cba", "patch": "@@ -27,7 +27,9 @@ struct SimpleTask {\n impl Runtime for SimpleTask {\n     // Implement the simple tasks of descheduling and rescheduling, but only in\n     // a simple number of cases.\n-    fn deschedule(mut ~self, times: uint, mut cur_task: Box<Task>,\n+    fn deschedule(mut self: Box<SimpleTask>,\n+                  times: uint,\n+                  mut cur_task: Box<Task>,\n                   f: |BlockedTask| -> Result<(), BlockedTask>) {\n         assert!(times == 1);\n \n@@ -54,7 +56,7 @@ impl Runtime for SimpleTask {\n         }\n         Local::put(cur_task);\n     }\n-    fn reawaken(mut ~self, mut to_wake: Box<Task>) {\n+    fn reawaken(mut self: Box<SimpleTask>, mut to_wake: Box<Task>) {\n         let me = &mut *self as *mut SimpleTask;\n         to_wake.put_runtime(self);\n         unsafe {\n@@ -69,9 +71,9 @@ impl Runtime for SimpleTask {\n     // purpose. A \"simple task\" is just that, a very simple task that can't\n     // really do a whole lot. The only purpose of the task is to get us off our\n     // feet and running.\n-    fn yield_now(~self, _cur_task: Box<Task>) { fail!() }\n-    fn maybe_yield(~self, _cur_task: Box<Task>) { fail!() }\n-    fn spawn_sibling(~self,\n+    fn yield_now(self: Box<SimpleTask>, _cur_task: Box<Task>) { fail!() }\n+    fn maybe_yield(self: Box<SimpleTask>, _cur_task: Box<Task>) { fail!() }\n+    fn spawn_sibling(self: Box<SimpleTask>,\n                      _cur_task: Box<Task>,\n                      _opts: TaskOpts,\n                      _f: proc():Send) {\n@@ -80,7 +82,7 @@ impl Runtime for SimpleTask {\n     fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>> { None }\n     fn stack_bounds(&self) -> (uint, uint) { fail!() }\n     fn can_block(&self) -> bool { true }\n-    fn wrap(~self) -> Box<Any> { fail!() }\n+    fn wrap(self: Box<SimpleTask>) -> Box<Any> { fail!() }\n }\n \n pub fn task() -> Box<Task> {"}, {"sha": "3d3b413384050f37e6cd6057c5b43e53118db332", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=bb165eb5c21b057cb63a4421d6233e82deac4cba", "patch": "@@ -265,7 +265,7 @@ impl GreenTask {\n \n     // Runtime glue functions and helpers\n \n-    pub fn put_with_sched(mut ~self, sched: Box<Scheduler>) {\n+    pub fn put_with_sched(mut self: Box<GreenTask>, sched: Box<Scheduler>) {\n         assert!(self.sched.is_none());\n         self.sched = Some(sched);\n         self.put();\n@@ -276,18 +276,18 @@ impl GreenTask {\n         self.task = Some(task);\n     }\n \n-    pub fn swap(mut ~self) -> Box<Task> {\n+    pub fn swap(mut self: Box<GreenTask>) -> Box<Task> {\n         let mut task = self.task.take_unwrap();\n         task.put_runtime(self);\n         return task;\n     }\n \n-    pub fn put(~self) {\n+    pub fn put(self: Box<GreenTask>) {\n         assert!(self.sched.is_some());\n         Local::put(self.swap());\n     }\n \n-    fn terminate(mut ~self) -> ! {\n+    fn terminate(mut self: Box<GreenTask>) -> ! {\n         let sched = self.sched.take_unwrap();\n         sched.terminate_current_task(self)\n     }\n@@ -311,7 +311,7 @@ impl GreenTask {\n     // *not* a cheap operation to clone a handle. Until the day comes that we\n     // need to optimize this, a lock should do just fine (it's completely\n     // uncontended except for when the task is rescheduled).\n-    fn reawaken_remotely(mut ~self) {\n+    fn reawaken_remotely(mut self: Box<GreenTask>) {\n         unsafe {\n             let mtx = &mut self.nasty_deschedule_lock as *mut NativeMutex;\n             let handle = self.handle.get_mut_ref() as *mut SchedHandle;\n@@ -322,19 +322,21 @@ impl GreenTask {\n }\n \n impl Runtime for GreenTask {\n-    fn yield_now(mut ~self, cur_task: Box<Task>) {\n+    fn yield_now(mut self: Box<GreenTask>, cur_task: Box<Task>) {\n         self.put_task(cur_task);\n         let sched = self.sched.take_unwrap();\n         sched.yield_now(self);\n     }\n \n-    fn maybe_yield(mut ~self, cur_task: Box<Task>) {\n+    fn maybe_yield(mut self: Box<GreenTask>, cur_task: Box<Task>) {\n         self.put_task(cur_task);\n         let sched = self.sched.take_unwrap();\n         sched.maybe_yield(self);\n     }\n \n-    fn deschedule(mut ~self, times: uint, cur_task: Box<Task>,\n+    fn deschedule(mut self: Box<GreenTask>,\n+                  times: uint,\n+                  cur_task: Box<Task>,\n                   f: |BlockedTask| -> Result<(), BlockedTask>) {\n         self.put_task(cur_task);\n         let mut sched = self.sched.take_unwrap();\n@@ -383,7 +385,7 @@ impl Runtime for GreenTask {\n         }\n     }\n \n-    fn reawaken(mut ~self, to_wake: Box<Task>) {\n+    fn reawaken(mut self: Box<GreenTask>, to_wake: Box<Task>) {\n         self.put_task(to_wake);\n         assert!(self.sched.is_none());\n \n@@ -434,7 +436,7 @@ impl Runtime for GreenTask {\n         }\n     }\n \n-    fn spawn_sibling(mut ~self,\n+    fn spawn_sibling(mut self: Box<GreenTask>,\n                      cur_task: Box<Task>,\n                      opts: TaskOpts,\n                      f: proc():Send) {\n@@ -471,7 +473,7 @@ impl Runtime for GreenTask {\n \n     fn can_block(&self) -> bool { false }\n \n-    fn wrap(~self) -> Box<Any> { self as Box<Any> }\n+    fn wrap(self: Box<GreenTask>) -> Box<Any> { self as Box<Any> }\n }\n \n #[cfg(test)]"}, {"sha": "c3eb5e91e90f07c5f6fd09a7f87e00c9a344abf6", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=bb165eb5c21b057cb63a4421d6233e82deac4cba", "patch": "@@ -484,7 +484,8 @@ impl TcpListener {\n }\n \n impl rtio::RtioTcpListener for TcpListener {\n-    fn listen(~self) -> IoResult<Box<rtio::RtioTcpAcceptor + Send>> {\n+    fn listen(self: Box<TcpListener>)\n+              -> IoResult<Box<rtio::RtioTcpAcceptor + Send>> {\n         self.native_listen(128).map(|a| {\n             box a as Box<rtio::RtioTcpAcceptor + Send>\n         })"}, {"sha": "075ca769d073e919a46f31415195cce75205e13d", "filename": "src/libnative/io/pipe_unix.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibnative%2Fio%2Fpipe_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibnative%2Fio%2Fpipe_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_unix.rs?ref=bb165eb5c21b057cb63a4421d6233e82deac4cba", "patch": "@@ -229,7 +229,8 @@ impl UnixListener {\n }\n \n impl rtio::RtioUnixListener for UnixListener {\n-    fn listen(~self) -> IoResult<Box<rtio::RtioUnixAcceptor + Send>> {\n+    fn listen(self: Box<UnixListener>)\n+              -> IoResult<Box<rtio::RtioUnixAcceptor + Send>> {\n         self.native_listen(128).map(|a| {\n             box a as Box<rtio::RtioUnixAcceptor + Send>\n         })"}, {"sha": "79ca23abed25c9968ef567a8a63cb2ade6699541", "filename": "src/libnative/io/pipe_win32.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibnative%2Fio%2Fpipe_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibnative%2Fio%2Fpipe_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_win32.rs?ref=bb165eb5c21b057cb63a4421d6233e82deac4cba", "patch": "@@ -588,7 +588,8 @@ impl Drop for UnixListener {\n }\n \n impl rtio::RtioUnixListener for UnixListener {\n-    fn listen(~self) -> IoResult<Box<rtio::RtioUnixAcceptor + Send>> {\n+    fn listen(self: Box<UnixListener>)\n+              -> IoResult<Box<rtio::RtioUnixAcceptor + Send>> {\n         self.native_listen().map(|a| {\n             box a as Box<rtio::RtioUnixAcceptor + Send>\n         })"}, {"sha": "35367ff2efab3675bbb0f376dfd893c203ecacce", "filename": "src/libnative/task.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=bb165eb5c21b057cb63a4421d6233e82deac4cba", "patch": "@@ -131,21 +131,21 @@ struct Ops {\n }\n \n impl rt::Runtime for Ops {\n-    fn yield_now(~self, mut cur_task: Box<Task>) {\n+    fn yield_now(self: Box<Ops>, mut cur_task: Box<Task>) {\n         // put the task back in TLS and then invoke the OS thread yield\n         cur_task.put_runtime(self);\n         Local::put(cur_task);\n         Thread::yield_now();\n     }\n \n-    fn maybe_yield(~self, mut cur_task: Box<Task>) {\n+    fn maybe_yield(self: Box<Ops>, mut cur_task: Box<Task>) {\n         // just put the task back in TLS, on OS threads we never need to\n         // opportunistically yield b/c the OS will do that for us (preemption)\n         cur_task.put_runtime(self);\n         Local::put(cur_task);\n     }\n \n-    fn wrap(~self) -> Box<Any> {\n+    fn wrap(self: Box<Ops>) -> Box<Any> {\n         self as Box<Any>\n     }\n \n@@ -192,7 +192,9 @@ impl rt::Runtime for Ops {\n     // `awoken` field which indicates whether we were actually woken up via some\n     // invocation of `reawaken`. This flag is only ever accessed inside the\n     // lock, so there's no need to make it atomic.\n-    fn deschedule(mut ~self, times: uint, mut cur_task: Box<Task>,\n+    fn deschedule(mut self: Box<Ops>,\n+                  times: uint,\n+                  mut cur_task: Box<Task>,\n                   f: |BlockedTask| -> Result<(), BlockedTask>) {\n         let me = &mut *self as *mut Ops;\n         cur_task.put_runtime(self);\n@@ -250,7 +252,7 @@ impl rt::Runtime for Ops {\n \n     // See the comments on `deschedule` for why the task is forgotten here, and\n     // why it's valid to do so.\n-    fn reawaken(mut ~self, mut to_wake: Box<Task>) {\n+    fn reawaken(mut self: Box<Ops>, mut to_wake: Box<Task>) {\n         unsafe {\n             let me = &mut *self as *mut Ops;\n             to_wake.put_runtime(self);\n@@ -261,7 +263,7 @@ impl rt::Runtime for Ops {\n         }\n     }\n \n-    fn spawn_sibling(~self,\n+    fn spawn_sibling(self: Box<Ops>,\n                      mut cur_task: Box<Task>,\n                      opts: TaskOpts,\n                      f: proc():Send) {"}, {"sha": "8f450fe3d76a7e29baef0f2f5412ea0a7d23462d", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=bb165eb5c21b057cb63a4421d6233e82deac4cba", "patch": "@@ -1051,7 +1051,6 @@ fn determine_explicit_self_category<AC:AstConv,\n                                          lifetime);\n             ty::ByReferenceExplicitSelfCategory(region, mutability)\n         }\n-        ast::SelfUniq(_) => ty::ByBoxExplicitSelfCategory,\n         ast::SelfExplicit(ast_type, _) => {\n             let explicit_type = ast_ty_to_ty(this, rscope, &*ast_type);\n "}, {"sha": "57cda6c48178a3d42ab98c2b0b079b16b5780323", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=bb165eb5c21b057cb63a4421d6233e82deac4cba", "patch": "@@ -779,7 +779,6 @@ impl Clean<SelfTy> for ast::ExplicitSelf_ {\n         match *self {\n             ast::SelfStatic => SelfStatic,\n             ast::SelfValue(_) => SelfValue,\n-            ast::SelfUniq(_) => SelfOwned,\n             ast::SelfRegion(lt, mt, _) => {\n                 SelfBorrowed(lt.clean(), mt.clean())\n             }"}, {"sha": "e7f9370339922d3ae5abf583e0f84eee999c7879", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=bb165eb5c21b057cb63a4421d6233e82deac4cba", "patch": "@@ -491,7 +491,7 @@ impl<'a> fmt::Show for Method<'a> {\n         match *selfty {\n             clean::SelfStatic => {},\n             clean::SelfValue => args.push_str(\"self\"),\n-            clean::SelfOwned => args.push_str(\"~self\"),\n+            clean::SelfOwned => args.push_str(\"self: Box<Self>\"),\n             clean::SelfBorrowed(Some(ref lt), mtbl) => {\n                 args.push_str(format!(\"&amp;{} {}self\", *lt,\n                                       MutableSpace(mtbl)).as_slice());"}, {"sha": "e2d7f91d1a6f9b4bc258886d430c0d2d967e9968", "filename": "src/librustrt/lib.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibrustrt%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibrustrt%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flib.rs?ref=bb165eb5c21b057cb63a4421d6233e82deac4cba", "patch": "@@ -74,15 +74,17 @@ pub mod unwind;\n pub trait Runtime {\n     // Necessary scheduling functions, used for channels and blocking I/O\n     // (sometimes).\n-    fn yield_now(~self, cur_task: Box<Task>);\n-    fn maybe_yield(~self, cur_task: Box<Task>);\n-    fn deschedule(~self, times: uint, cur_task: Box<Task>,\n+    fn yield_now(self: Box<Self>, cur_task: Box<Task>);\n+    fn maybe_yield(self: Box<Self>, cur_task: Box<Task>);\n+    fn deschedule(self: Box<Self>,\n+                  times: uint,\n+                  cur_task: Box<Task>,\n                   f: |BlockedTask| -> Result<(), BlockedTask>);\n-    fn reawaken(~self, to_wake: Box<Task>);\n+    fn reawaken(self: Box<Self>, to_wake: Box<Task>);\n \n     // Miscellaneous calls which are very different depending on what context\n     // you're in.\n-    fn spawn_sibling(~self,\n+    fn spawn_sibling(self: Box<Self>,\n                      cur_task: Box<Task>,\n                      opts: TaskOpts,\n                      f: proc():Send);\n@@ -92,7 +94,7 @@ pub trait Runtime {\n     fn can_block(&self) -> bool;\n \n     // FIXME: This is a serious code smell and this should not exist at all.\n-    fn wrap(~self) -> Box<Any>;\n+    fn wrap(self: Box<Self>) -> Box<Any>;\n }\n \n /// The default error code of the rust runtime if the main task fails instead"}, {"sha": "134453659dbf6740de949a95104e3d87c0a84d96", "filename": "src/librustrt/rtio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibrustrt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibrustrt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Frtio.rs?ref=bb165eb5c21b057cb63a4421d6233e82deac4cba", "patch": "@@ -238,7 +238,7 @@ pub trait IoFactory {\n }\n \n pub trait RtioTcpListener : RtioSocket {\n-    fn listen(~self) -> IoResult<Box<RtioTcpAcceptor + Send>>;\n+    fn listen(self: Box<Self>) -> IoResult<Box<RtioTcpAcceptor + Send>>;\n }\n \n pub trait RtioTcpAcceptor : RtioSocket {\n@@ -329,7 +329,7 @@ pub trait RtioPipe {\n }\n \n pub trait RtioUnixListener {\n-    fn listen(~self) -> IoResult<Box<RtioUnixAcceptor + Send>>;\n+    fn listen(self: Box<Self>) -> IoResult<Box<RtioUnixAcceptor + Send>>;\n }\n \n pub trait RtioUnixAcceptor {"}, {"sha": "d27a4f25b4e70ce60cd7a96091ea65431a19a606", "filename": "src/librustrt/task.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibrustrt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibrustrt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Ftask.rs?ref=bb165eb5c21b057cb63a4421d6233e82deac4cba", "patch": "@@ -203,7 +203,7 @@ impl Task {\n     /// }).destroy();\n     /// # }\n     /// ```\n-    pub fn run(~self, f: ||) -> Box<Task> {\n+    pub fn run(self: Box<Task>, f: ||) -> Box<Task> {\n         assert!(!self.is_destroyed(), \"cannot re-use a destroyed task\");\n \n         // First, make sure that no one else is in TLS. This does not allow\n@@ -239,7 +239,7 @@ impl Task {\n     ///\n     /// The returned task cannot be used for running any more code, but it may\n     /// be used to extract the runtime as necessary.\n-    pub fn destroy(~self) -> Box<Task> {\n+    pub fn destroy(self: Box<Task>) -> Box<Task> {\n         if self.is_destroyed() {\n             self\n         } else {\n@@ -252,7 +252,7 @@ impl Task {\n     /// This function consumes ownership of the task, deallocating it once it's\n     /// done being processed. It is assumed that TLD and the local heap have\n     /// already been destroyed and/or annihilated.\n-    fn cleanup(~self, result: Result) -> Box<Task> {\n+    fn cleanup(self: Box<Task>, result: Result) -> Box<Task> {\n         // The first thing to do when cleaning up is to deallocate our local\n         // resources, such as TLD and GC data.\n         //\n@@ -394,15 +394,18 @@ impl Task {\n \n     /// Spawns a sibling to this task. The newly spawned task is configured with\n     /// the `opts` structure and will run `f` as the body of its code.\n-    pub fn spawn_sibling(mut ~self, opts: TaskOpts, f: proc(): Send) {\n+    pub fn spawn_sibling(mut self: Box<Task>,\n+                         opts: TaskOpts,\n+                         f: proc(): Send) {\n         let ops = self.imp.take_unwrap();\n         ops.spawn_sibling(self, opts, f)\n     }\n \n     /// Deschedules the current task, invoking `f` `amt` times. It is not\n     /// recommended to use this function directly, but rather communication\n     /// primitives in `std::comm` should be used.\n-    pub fn deschedule(mut ~self, amt: uint,\n+    pub fn deschedule(mut self: Box<Task>,\n+                      amt: uint,\n                       f: |BlockedTask| -> ::core::result::Result<(), BlockedTask>) {\n         let ops = self.imp.take_unwrap();\n         ops.deschedule(amt, self, f)\n@@ -411,22 +414,22 @@ impl Task {\n     /// Wakes up a previously blocked task, optionally specifying whether the\n     /// current task can accept a change in scheduling. This function can only\n     /// be called on tasks that were previously blocked in `deschedule`.\n-    pub fn reawaken(mut ~self) {\n+    pub fn reawaken(mut self: Box<Task>) {\n         let ops = self.imp.take_unwrap();\n         ops.reawaken(self);\n     }\n \n     /// Yields control of this task to another task. This function will\n     /// eventually return, but possibly not immediately. This is used as an\n     /// opportunity to allow other tasks a chance to run.\n-    pub fn yield_now(mut ~self) {\n+    pub fn yield_now(mut self: Box<Task>) {\n         let ops = self.imp.take_unwrap();\n         ops.yield_now(self);\n     }\n \n     /// Similar to `yield_now`, except that this function may immediately return\n     /// without yielding (depending on what the runtime decides to do).\n-    pub fn maybe_yield(mut ~self) {\n+    pub fn maybe_yield(mut self: Box<Task>) {\n         let ops = self.imp.take_unwrap();\n         ops.maybe_yield(self);\n     }"}, {"sha": "24b8c29785804920ccd43c49cfd854bf220f0afb", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=bb165eb5c21b057cb63a4421d6233e82deac4cba", "patch": "@@ -154,7 +154,7 @@ pub trait UvHandle<T> {\n         mem::transmute(uvll::get_data_for_uv_handle(*h))\n     }\n \n-    fn install(~self) -> Box<Self> {\n+    fn install(self: Box<Self>) -> Box<Self> {\n         unsafe {\n             let myptr = mem::transmute::<&Box<Self>, &*mut u8>(&self);\n             uvll::set_data_for_uv_handle(self.uv_handle(), *myptr);"}, {"sha": "3cc10ae3823ac56a545d4e6fa4e014ebeccba299", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=bb165eb5c21b057cb63a4421d6233e82deac4cba", "patch": "@@ -389,7 +389,8 @@ impl rtio::RtioSocket for TcpListener {\n }\n \n impl rtio::RtioTcpListener for TcpListener {\n-    fn listen(~self) -> Result<Box<rtio::RtioTcpAcceptor + Send>, IoError> {\n+    fn listen(self: Box<TcpListener>)\n+              -> Result<Box<rtio::RtioTcpAcceptor + Send>, IoError> {\n         // create the acceptor object from ourselves\n         let mut acceptor = box TcpAcceptor {\n             listener: self,"}, {"sha": "f0a57546ed43ee1f94b469038561ce6b31468fa0", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=bb165eb5c21b057cb63a4421d6233e82deac4cba", "patch": "@@ -248,7 +248,8 @@ impl PipeListener {\n }\n \n impl rtio::RtioUnixListener for PipeListener {\n-    fn listen(~self) -> IoResult<Box<rtio::RtioUnixAcceptor + Send>> {\n+    fn listen(self: Box<PipeListener>)\n+              -> IoResult<Box<rtio::RtioUnixAcceptor + Send>> {\n         // create the acceptor object from ourselves\n         let mut acceptor = box PipeAcceptor {\n             listener: self,"}, {"sha": "f05d17569f68d82760630b147b018d246b39626f", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=bb165eb5c21b057cb63a4421d6233e82deac4cba", "patch": "@@ -955,8 +955,6 @@ pub enum ExplicitSelf_ {\n     SelfValue(Ident),\n     /// `&'lt self`, `&'lt mut self`\n     SelfRegion(Option<Lifetime>, Mutability, Ident),\n-    /// `~self`\n-    SelfUniq(Ident),\n     /// `self: TYPE`\n     SelfExplicit(P<Ty>, Ident),\n }"}, {"sha": "f48306bc6ee2fbfd6b5d96e14b2d9e94415d1f6e", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=bb165eb5c21b057cb63a4421d6233e82deac4cba", "patch": "@@ -340,7 +340,7 @@ pub trait Folder {\n \n     fn fold_explicit_self_(&mut self, es: &ExplicitSelf_) -> ExplicitSelf_ {\n         match *es {\n-            SelfStatic | SelfValue(_) | SelfUniq(_) => *es,\n+            SelfStatic | SelfValue(_) => *es,\n             SelfRegion(ref lifetime, m, id) => {\n                 SelfRegion(fold_opt_lifetime(lifetime, self), m, id)\n             }"}, {"sha": "afcf84753a612847e4de00b0e3483e7a58d523d6", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=bb165eb5c21b057cb63a4421d6233e82deac4cba", "patch": "@@ -31,6 +31,7 @@ pub enum ObsoleteSyntax {\n     ObsoleteOwnedExpr,\n     ObsoleteOwnedPattern,\n     ObsoleteOwnedVector,\n+    ObsoleteOwnedSelf,\n     ObsoleteManagedType,\n     ObsoleteManagedExpr,\n }\n@@ -70,6 +71,10 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n                 \"`~[T]` is no longer a type\",\n                 \"use the `Vec` type instead\"\n             ),\n+            ObsoleteOwnedSelf => (\n+                \"`~self` is no longer supported\",\n+                \"write `self: Box<Self>` instead\"\n+            ),\n             ObsoleteManagedType => (\n                 \"`@` notation for managed pointers\",\n                 \"use `Gc<T>` in `std::gc` instead\""}, {"sha": "ac3631636731369984ccf32fa7b5066046d685aa", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=bb165eb5c21b057cb63a4421d6233e82deac4cba", "patch": "@@ -45,7 +45,7 @@ use ast::{RetStyle, Return, BiShl, BiShr, Stmt, StmtDecl};\n use ast::{StmtExpr, StmtSemi, StmtMac, StructDef, StructField};\n use ast::{StructVariantKind, BiSub};\n use ast::StrStyle;\n-use ast::{SelfExplicit, SelfRegion, SelfStatic, SelfUniq, SelfValue};\n+use ast::{SelfExplicit, SelfRegion, SelfStatic, SelfValue};\n use ast::{TokenTree, TraitMethod, TraitRef, TTDelim, TTSeq, TTTok};\n use ast::{TTNonterminal, TupleVariantKind, Ty, Ty_, TyBot, TyBox};\n use ast::{TypeField, TyFixedLengthVec, TyClosure, TyProc, TyBareFn};\n@@ -3826,10 +3826,11 @@ impl<'a> Parser<'a> {\n                 // We need to make sure it isn't a type\n                 if self.look_ahead(1, |t| token::is_keyword(keywords::Self, t)) {\n                     self.bump();\n-                    SelfUniq(self.expect_self_ident())\n-                } else {\n-                    SelfStatic\n+                    drop(self.expect_self_ident());\n+                    let last_span = self.last_span;\n+                    self.obsolete(last_span, ObsoleteOwnedSelf)\n                 }\n+                SelfStatic\n             }\n             token::IDENT(..) if self.is_self_ident() => {\n                 let self_ident = self.expect_self_ident();\n@@ -3877,7 +3878,10 @@ impl<'a> Parser<'a> {\n                     self.look_ahead(2, |t| token::is_keyword(keywords::Self, t)) => {\n                 mutbl_self = self.parse_mutability();\n                 self.bump();\n-                SelfUniq(self.expect_self_ident())\n+                drop(self.expect_self_ident());\n+                let last_span = self.last_span;\n+                self.obsolete(last_span, ObsoleteOwnedSelf);\n+                SelfStatic\n             }\n             _ => SelfStatic\n         };\n@@ -3921,7 +3925,6 @@ impl<'a> Parser<'a> {\n             }\n             SelfValue(id) => parse_remaining_arguments!(id),\n             SelfRegion(_,_,id) => parse_remaining_arguments!(id),\n-            SelfUniq(id) => parse_remaining_arguments!(id),\n             SelfExplicit(_,id) => parse_remaining_arguments!(id),\n         };\n "}, {"sha": "ac8355651916e0a5c03b2b4d9da6c5cc6c994f83", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=bb165eb5c21b057cb63a4421d6233e82deac4cba", "patch": "@@ -1892,9 +1892,6 @@ impl<'a> State<'a> {\n             ast::SelfValue(_) => {\n                 try!(word(&mut self.s, \"self\"));\n             }\n-            ast::SelfUniq(_) => {\n-                try!(word(&mut self.s, \"~self\"));\n-            }\n             ast::SelfRegion(ref lt, m, _) => {\n                 try!(word(&mut self.s, \"&\"));\n                 try!(self.print_opt_lifetime(lt));"}, {"sha": "371fae53b41d06bc20390d5633a1111f2707a652", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb165eb5c21b057cb63a4421d6233e82deac4cba/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=bb165eb5c21b057cb63a4421d6233e82deac4cba", "patch": "@@ -216,7 +216,7 @@ pub fn walk_explicit_self<E: Clone, V: Visitor<E>>(visitor: &mut V,\n                                                    explicit_self: &ExplicitSelf,\n                                                    env: E) {\n     match explicit_self.node {\n-        SelfStatic | SelfValue(_) | SelfUniq(_) => {},\n+        SelfStatic | SelfValue(_) => {},\n         SelfRegion(ref lifetime, _, _) => {\n             visitor.visit_opt_lifetime_ref(explicit_self.span, lifetime, env)\n         }"}]}