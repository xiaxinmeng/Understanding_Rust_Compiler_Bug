{"sha": "4f49352e92ed229a1f51423e087734b86c6fe814", "node_id": "C_kwDOAAsO6NoAKDRmNDkzNTJlOTJlZDIyOWExZjUxNDIzZTA4NzczNGI4NmM2ZmU4MTQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-03-03T19:06:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-03T19:06:26Z"}, "message": "Rollup merge of #107981 - lcnr:canonicalization-uwu, r=compiler-errors\n\nnew solver: implement canonicalization and region constraints\n\nsee the corresponding rustc-dev-guide chapter: https://rustc-dev-guide.rust-lang.org/solve/canonicalization.html\n\nr? ``@compiler-errors``", "tree": {"sha": "8ad66ca712248678c9426b7b372b314f99a98723", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ad66ca712248678c9426b7b372b314f99a98723"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f49352e92ed229a1f51423e087734b86c6fe814", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkAkUyCRBK7hj4Ov3rIwAASyMIALJ5NXzATUVvh+8GuFAKVyp3\npM4lcsBQWAsbJcslo70XhOwsRORohJmMlFUpqVYg8WM6uU0SZMcYPvldhcDHnhDH\nbVnkMOPiMY9hmOh9k9M7OL/J6RoHlPxfOKNASdI4QTZhZJylQl/mYXgNQaH+0WTr\nJODnNNDZLjvO9hHG2rvV+B+TbsmmI/1Llo/r37gepz7U2bBYRMdDfr3luuHP5fUb\nGWh0Xl+i6mjumZQ+C5Houe0Im0NhhcSSIXh2su1+axUD/5fJTvWZa/2n2pFwjosS\nIojC62iezvmgnXNQW/jGIM6frtWJoGVW9Mb4dKpsQ6kmG5rUS01GSN22EAj7YY8=\n=wNmK\n-----END PGP SIGNATURE-----\n", "payload": "tree 8ad66ca712248678c9426b7b372b314f99a98723\nparent 7a809ce8997a1697b166b4bb2594993e87d69f31\nparent a15abea93198b3fe37b1e4147d862fa41d326ff4\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1677870386 +0100\ncommitter GitHub <noreply@github.com> 1677870386 +0100\n\nRollup merge of #107981 - lcnr:canonicalization-uwu, r=compiler-errors\n\nnew solver: implement canonicalization and region constraints\n\nsee the corresponding rustc-dev-guide chapter: https://rustc-dev-guide.rust-lang.org/solve/canonicalization.html\n\nr? ``@compiler-errors``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f49352e92ed229a1f51423e087734b86c6fe814", "html_url": "https://github.com/rust-lang/rust/commit/4f49352e92ed229a1f51423e087734b86c6fe814", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f49352e92ed229a1f51423e087734b86c6fe814/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a809ce8997a1697b166b4bb2594993e87d69f31", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a809ce8997a1697b166b4bb2594993e87d69f31", "html_url": "https://github.com/rust-lang/rust/commit/7a809ce8997a1697b166b4bb2594993e87d69f31"}, {"sha": "a15abea93198b3fe37b1e4147d862fa41d326ff4", "url": "https://api.github.com/repos/rust-lang/rust/commits/a15abea93198b3fe37b1e4147d862fa41d326ff4", "html_url": "https://github.com/rust-lang/rust/commit/a15abea93198b3fe37b1e4147d862fa41d326ff4"}], "stats": {"total": 893, "additions": 805, "deletions": 88}, "files": [{"sha": "7d9bae735e55d7e481389b89e025b31f2c2baf32", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4f49352e92ed229a1f51423e087734b86c6fe814/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f49352e92ed229a1f51423e087734b86c6fe814/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=4f49352e92ed229a1f51423e087734b86c6fe814", "patch": "@@ -369,6 +369,34 @@ impl<'tcx> ToTrace<'tcx> for Const<'tcx> {\n     }\n }\n \n+impl<'tcx> ToTrace<'tcx> for ty::GenericArg<'tcx> {\n+    fn to_trace(\n+        _: TyCtxt<'tcx>,\n+        cause: &ObligationCause<'tcx>,\n+        a_is_expected: bool,\n+        a: Self,\n+        b: Self,\n+    ) -> TypeTrace<'tcx> {\n+        use GenericArgKind::*;\n+        TypeTrace {\n+            cause: cause.clone(),\n+            values: match (a.unpack(), b.unpack()) {\n+                (Lifetime(a), Lifetime(b)) => Regions(ExpectedFound::new(a_is_expected, a, b)),\n+                (Type(a), Type(b)) => Terms(ExpectedFound::new(a_is_expected, a.into(), b.into())),\n+                (Const(a), Const(b)) => {\n+                    Terms(ExpectedFound::new(a_is_expected, a.into(), b.into()))\n+                }\n+\n+                (Lifetime(_), Type(_) | Const(_))\n+                | (Type(_), Lifetime(_) | Const(_))\n+                | (Const(_), Lifetime(_) | Type(_)) => {\n+                    bug!(\"relating different kinds: {a:?} {b:?}\")\n+                }\n+            },\n+        }\n+    }\n+}\n+\n impl<'tcx> ToTrace<'tcx> for ty::Term<'tcx> {\n     fn to_trace(\n         _: TyCtxt<'tcx>,"}, {"sha": "ce230afdab3ce2629474c4bf2ed8f37c1c6622fa", "filename": "compiler/rustc_infer/src/infer/canonical/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4f49352e92ed229a1f51423e087734b86c6fe814/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f49352e92ed229a1f51423e087734b86c6fe814/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs?ref=4f49352e92ed229a1f51423e087734b86c6fe814", "patch": "@@ -30,7 +30,7 @@ use rustc_middle::ty::{self, List, TyCtxt};\n use rustc_span::source_map::Span;\n \n pub use rustc_middle::infer::canonical::*;\n-use substitute::CanonicalExt;\n+pub use substitute::CanonicalExt;\n \n mod canonicalizer;\n pub mod query_response;\n@@ -100,7 +100,11 @@ impl<'tcx> InferCtxt<'tcx> {\n     /// variable for it. If this is an existentially quantified\n     /// variable, then you'll get a new inference variable; if it is a\n     /// universally quantified variable, you get a placeholder.\n-    fn instantiate_canonical_var(\n+    ///\n+    /// FIXME(-Ztrait-solver=next): This is public because it's used by the\n+    /// new trait solver which has a different canonicalization routine.\n+    /// We should somehow deduplicate all of this.\n+    pub fn instantiate_canonical_var(\n         &self,\n         span: Span,\n         cv_info: CanonicalVarInfo<'tcx>,"}, {"sha": "436d29c2449e4f925b2d748a2ec0d4ea3fca2e2f", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4f49352e92ed229a1f51423e087734b86c6fe814/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f49352e92ed229a1f51423e087734b86c6fe814/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=4f49352e92ed229a1f51423e087734b86c6fe814", "patch": "@@ -151,11 +151,21 @@ impl<'tcx> InferCtxt<'tcx> {\n         })\n     }\n \n-    /// FIXME: This method should only be used for canonical queries and therefore be private.\n-    ///\n-    /// As the new solver does canonicalization slightly differently, this is also used there\n-    /// for now. This should hopefully change fairly soon.\n-    pub fn take_opaque_types_for_query_response(&self) -> Vec<(Ty<'tcx>, Ty<'tcx>)> {\n+    /// Used by the new solver as that one takes the opaque types at the end of a probe\n+    /// to deal with multiple candidates without having to recompute them.\n+    pub fn clone_opaque_types_for_query_response(&self) -> Vec<(Ty<'tcx>, Ty<'tcx>)> {\n+        self.inner\n+            .borrow()\n+            .opaque_type_storage\n+            .opaque_types\n+            .iter()\n+            .map(|&(k, ref v)| {\n+                (self.tcx.mk_opaque(k.def_id.to_def_id(), k.substs), v.hidden_type.ty)\n+            })\n+            .collect()\n+    }\n+\n+    fn take_opaque_types_for_query_response(&self) -> Vec<(Ty<'tcx>, Ty<'tcx>)> {\n         std::mem::take(&mut self.inner.borrow_mut().opaque_type_storage.opaque_types)\n             .into_iter()\n             .map(|(k, v)| (self.tcx.mk_opaque(k.def_id.to_def_id(), k.substs), v.hidden_type.ty))"}, {"sha": "cac3b40725158d73164b1568e56c3b0cc6561fc5", "filename": "compiler/rustc_infer/src/infer/canonical/substitute.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f49352e92ed229a1f51423e087734b86c6fe814/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f49352e92ed229a1f51423e087734b86c6fe814/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=4f49352e92ed229a1f51423e087734b86c6fe814", "patch": "@@ -11,7 +11,9 @@ use rustc_middle::ty::fold::{FnMutDelegate, TypeFoldable};\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, TyCtxt};\n \n-pub(super) trait CanonicalExt<'tcx, V> {\n+/// FIXME(-Ztrait-solver=next): This or public because it is shared with the\n+/// new trait solver implementation. We should deduplicate canonicalization.\n+pub trait CanonicalExt<'tcx, V> {\n     /// Instantiate the wrapped value, replacing each canonical value\n     /// with the value given in `var_values`.\n     fn substitute(&self, tcx: TyCtxt<'tcx>, var_values: &CanonicalVarValues<'tcx>) -> V"}, {"sha": "7f8fc17744dc9f459111ce18e30eb054644445df", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/4f49352e92ed229a1f51423e087734b86c6fe814/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f49352e92ed229a1f51423e087734b86c6fe814/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=4f49352e92ed229a1f51423e087734b86c6fe814", "patch": "@@ -123,6 +123,11 @@ impl<'tcx> CanonicalVarInfo<'tcx> {\n         self.kind.universe()\n     }\n \n+    #[must_use]\n+    pub fn with_updated_universe(self, ui: ty::UniverseIndex) -> CanonicalVarInfo<'tcx> {\n+        CanonicalVarInfo { kind: self.kind.with_updated_universe(ui) }\n+    }\n+\n     pub fn is_existential(&self) -> bool {\n         match self.kind {\n             CanonicalVarKind::Ty(_) => true,\n@@ -133,6 +138,28 @@ impl<'tcx> CanonicalVarInfo<'tcx> {\n             CanonicalVarKind::PlaceholderConst(_, _) => false,\n         }\n     }\n+\n+    pub fn is_region(&self) -> bool {\n+        match self.kind {\n+            CanonicalVarKind::Region(_) | CanonicalVarKind::PlaceholderRegion(_) => true,\n+            CanonicalVarKind::Ty(_)\n+            | CanonicalVarKind::PlaceholderTy(_)\n+            | CanonicalVarKind::Const(_, _)\n+            | CanonicalVarKind::PlaceholderConst(_, _) => false,\n+        }\n+    }\n+\n+    pub fn expect_anon_placeholder(self) -> u32 {\n+        match self.kind {\n+            CanonicalVarKind::Ty(_)\n+            | CanonicalVarKind::Region(_)\n+            | CanonicalVarKind::Const(_, _) => bug!(\"expected placeholder: {self:?}\"),\n+\n+            CanonicalVarKind::PlaceholderRegion(placeholder) => placeholder.name.expect_anon(),\n+            CanonicalVarKind::PlaceholderTy(placeholder) => placeholder.name.expect_anon(),\n+            CanonicalVarKind::PlaceholderConst(placeholder, _) => placeholder.name.as_u32(),\n+        }\n+    }\n }\n \n /// Describes the \"kind\" of the canonical variable. This is a \"kind\"\n@@ -177,6 +204,38 @@ impl<'tcx> CanonicalVarKind<'tcx> {\n             CanonicalVarKind::PlaceholderConst(placeholder, _) => placeholder.universe,\n         }\n     }\n+\n+    /// Replaces the universe of this canonical variable with `ui`.\n+    ///\n+    /// In case this is a float or int variable, this causes an ICE if\n+    /// the updated universe is not the root.\n+    pub fn with_updated_universe(self, ui: ty::UniverseIndex) -> CanonicalVarKind<'tcx> {\n+        match self {\n+            CanonicalVarKind::Ty(kind) => match kind {\n+                CanonicalTyVarKind::General(_) => {\n+                    CanonicalVarKind::Ty(CanonicalTyVarKind::General(ui))\n+                }\n+                CanonicalTyVarKind::Int | CanonicalTyVarKind::Float => {\n+                    assert_eq!(ui, ty::UniverseIndex::ROOT);\n+                    CanonicalVarKind::Ty(kind)\n+                }\n+            },\n+            CanonicalVarKind::PlaceholderTy(placeholder) => {\n+                CanonicalVarKind::PlaceholderTy(ty::Placeholder { universe: ui, ..placeholder })\n+            }\n+            CanonicalVarKind::Region(_) => CanonicalVarKind::Region(ui),\n+            CanonicalVarKind::PlaceholderRegion(placeholder) => {\n+                CanonicalVarKind::PlaceholderRegion(ty::Placeholder { universe: ui, ..placeholder })\n+            }\n+            CanonicalVarKind::Const(_, ty) => CanonicalVarKind::Const(ui, ty),\n+            CanonicalVarKind::PlaceholderConst(placeholder, ty) => {\n+                CanonicalVarKind::PlaceholderConst(\n+                    ty::Placeholder { universe: ui, ..placeholder },\n+                    ty,\n+                )\n+            }\n+        }\n+    }\n }\n \n /// Rust actually has more than one category of type variables;\n@@ -213,7 +272,8 @@ pub struct QueryResponse<'tcx, R> {\n     pub value: R,\n }\n \n-#[derive(Clone, Debug, Default, HashStable, TypeFoldable, TypeVisitable, Lift)]\n+#[derive(Clone, Debug, Default, PartialEq, Eq, Hash)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct QueryRegionConstraints<'tcx> {\n     pub outlives: Vec<QueryOutlivesConstraint<'tcx>>,\n     pub member_constraints: Vec<MemberConstraint<'tcx>>,"}, {"sha": "2db59f37f4072d1b0a49cd24de531bdc8729d3e2", "filename": "compiler/rustc_middle/src/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4f49352e92ed229a1f51423e087734b86c6fe814/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f49352e92ed229a1f51423e087734b86c6fe814/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fmod.rs?ref=4f49352e92ed229a1f51423e087734b86c6fe814", "patch": "@@ -12,7 +12,8 @@ use rustc_span::Span;\n /// ```text\n /// R0 member of [O1..On]\n /// ```\n-#[derive(Debug, Clone, HashStable, TypeFoldable, TypeVisitable, Lift)]\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct MemberConstraint<'tcx> {\n     /// The `DefId` and substs of the opaque type causing this constraint.\n     /// Used for error reporting."}, {"sha": "bd43867a3da805db3fa5c0ea901f1c59af210cdb", "filename": "compiler/rustc_middle/src/traits/solve.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4f49352e92ed229a1f51423e087734b86c6fe814/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f49352e92ed229a1f51423e087734b86c6fe814/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs?ref=4f49352e92ed229a1f51423e087734b86c6fe814", "patch": "@@ -2,6 +2,7 @@ use std::ops::ControlFlow;\n \n use rustc_data_structures::intern::Interned;\n \n+use crate::infer::canonical::QueryRegionConstraints;\n use crate::ty::{\n     FallibleTypeFolder, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeVisitable, TypeVisitor,\n };\n@@ -18,20 +19,25 @@ impl<'tcx> std::ops::Deref for ExternalConstraints<'tcx> {\n }\n \n /// Additional constraints returned on success.\n-#[derive(Debug, PartialEq, Eq, Clone, Hash, Default)]\n+#[derive(Debug, PartialEq, Eq, Clone, Hash, Default, TypeFoldable, TypeVisitable)]\n pub struct ExternalConstraintsData<'tcx> {\n     // FIXME: implement this.\n-    pub regions: (),\n+    pub region_constraints: QueryRegionConstraints<'tcx>,\n     pub opaque_types: Vec<(Ty<'tcx>, Ty<'tcx>)>,\n }\n \n+// FIXME: Having to clone `region_constraints` for folding feels bad and\n+// probably isn't great wrt performance.\n+//\n+// Not sure how to fix this, maybe we should also intern `opaque_types` and\n+// `region_constraints` here or something.\n impl<'tcx> TypeFoldable<TyCtxt<'tcx>> for ExternalConstraints<'tcx> {\n     fn try_fold_with<F: FallibleTypeFolder<TyCtxt<'tcx>>>(\n         self,\n         folder: &mut F,\n     ) -> Result<Self, F::Error> {\n         Ok(FallibleTypeFolder::interner(folder).mk_external_constraints(ExternalConstraintsData {\n-            regions: (),\n+            region_constraints: self.region_constraints.clone().try_fold_with(folder)?,\n             opaque_types: self\n                 .opaque_types\n                 .iter()\n@@ -42,7 +48,7 @@ impl<'tcx> TypeFoldable<TyCtxt<'tcx>> for ExternalConstraints<'tcx> {\n \n     fn fold_with<F: TypeFolder<TyCtxt<'tcx>>>(self, folder: &mut F) -> Self {\n         TypeFolder::interner(folder).mk_external_constraints(ExternalConstraintsData {\n-            regions: (),\n+            region_constraints: self.region_constraints.clone().fold_with(folder),\n             opaque_types: self.opaque_types.iter().map(|opaque| opaque.fold_with(folder)).collect(),\n         })\n     }\n@@ -53,7 +59,7 @@ impl<'tcx> TypeVisitable<TyCtxt<'tcx>> for ExternalConstraints<'tcx> {\n         &self,\n         visitor: &mut V,\n     ) -> std::ops::ControlFlow<V::BreakTy> {\n-        self.regions.visit_with(visitor)?;\n+        self.region_constraints.visit_with(visitor)?;\n         self.opaque_types.visit_with(visitor)?;\n         ControlFlow::Continue(())\n     }"}, {"sha": "e6a73e8bb1c38f72090c6df3ffa009257c38fe16", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4f49352e92ed229a1f51423e087734b86c6fe814/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f49352e92ed229a1f51423e087734b86c6fe814/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=4f49352e92ed229a1f51423e087734b86c6fe814", "patch": "@@ -107,6 +107,15 @@ impl BoundRegionKind {\n             _ => None,\n         }\n     }\n+\n+    pub fn expect_anon(&self) -> u32 {\n+        match *self {\n+            BoundRegionKind::BrNamed(_, _) | BoundRegionKind::BrEnv => {\n+                bug!(\"expected anon region: {self:?}\")\n+            }\n+            BoundRegionKind::BrAnon(idx, _) => idx,\n+        }\n+    }\n }\n \n pub trait Article {"}, {"sha": "c048d4a2aad7649d7f787ff9615dd69da1651891", "filename": "compiler/rustc_trait_selection/src/solve/canonical/canonicalize.rs", "status": "added", "additions": 390, "deletions": 0, "changes": 390, "blob_url": "https://github.com/rust-lang/rust/blob/4f49352e92ed229a1f51423e087734b86c6fe814/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fcanonicalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f49352e92ed229a1f51423e087734b86c6fe814/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fcanonicalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fcanonicalize.rs?ref=4f49352e92ed229a1f51423e087734b86c6fe814", "patch": "@@ -0,0 +1,390 @@\n+use std::cmp::Ordering;\n+\n+use crate::infer::InferCtxt;\n+use rustc_middle::infer::canonical::Canonical;\n+use rustc_middle::infer::canonical::CanonicalTyVarKind;\n+use rustc_middle::infer::canonical::CanonicalVarInfo;\n+use rustc_middle::infer::canonical::CanonicalVarInfos;\n+use rustc_middle::infer::canonical::CanonicalVarKind;\n+use rustc_middle::ty::BoundRegionKind::BrAnon;\n+use rustc_middle::ty::BoundTyKind;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::TypeVisitableExt;\n+use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{TypeFoldable, TypeFolder, TypeSuperFoldable};\n+\n+/// Whether we're canonicalizing a query input or the query reponse.\n+///\n+/// When canonicalizing an input we're in the context of the caller\n+/// while canonicalizing the response happens in the context of the\n+/// query.\n+#[derive(Debug, Clone, Copy)]\n+pub enum CanonicalizeMode {\n+    Input,\n+    /// FIXME: We currently return region constraints refering to\n+    /// placeholders and inference variables from a binder instantiated\n+    /// inside of the query.\n+    ///\n+    /// In the long term we should eagerly deal with these constraints\n+    /// inside of the query and only propagate constraints which are\n+    /// actually nameable by the caller.\n+    Response {\n+        /// The highest universe nameable by the caller.\n+        ///\n+        /// All variables in a universe nameable by the caller get mapped\n+        /// to the root universe in the response and then mapped back to\n+        /// their correct universe when applying the query response in the\n+        /// context of the caller.\n+        ///\n+        /// This doesn't work for universes created inside of the query so\n+        /// we do remember their universe in the response.\n+        max_input_universe: ty::UniverseIndex,\n+    },\n+}\n+\n+pub struct Canonicalizer<'a, 'tcx> {\n+    infcx: &'a InferCtxt<'tcx>,\n+    canonicalize_mode: CanonicalizeMode,\n+\n+    variables: &'a mut Vec<ty::GenericArg<'tcx>>,\n+    primitive_var_infos: Vec<CanonicalVarInfo<'tcx>>,\n+    binder_index: ty::DebruijnIndex,\n+}\n+\n+impl<'a, 'tcx> Canonicalizer<'a, 'tcx> {\n+    #[instrument(level = \"debug\", skip(infcx), ret)]\n+    pub fn canonicalize<T: TypeFoldable<TyCtxt<'tcx>>>(\n+        infcx: &'a InferCtxt<'tcx>,\n+        canonicalize_mode: CanonicalizeMode,\n+        variables: &'a mut Vec<ty::GenericArg<'tcx>>,\n+        value: T,\n+    ) -> Canonical<'tcx, T> {\n+        let mut canonicalizer = Canonicalizer {\n+            infcx,\n+            canonicalize_mode,\n+\n+            variables,\n+            primitive_var_infos: Vec::new(),\n+            binder_index: ty::INNERMOST,\n+        };\n+\n+        let value = value.fold_with(&mut canonicalizer);\n+        assert!(!value.needs_infer());\n+        assert!(!value.has_placeholders());\n+\n+        let (max_universe, variables) = canonicalizer.finalize();\n+\n+        Canonical { max_universe, variables, value }\n+    }\n+\n+    fn finalize(self) -> (ty::UniverseIndex, CanonicalVarInfos<'tcx>) {\n+        let mut var_infos = self.primitive_var_infos;\n+        // See the rustc-dev-guide section about how we deal with universes\n+        // during canonicalization in the new solver.\n+        match self.canonicalize_mode {\n+            // We try to deduplicate as many query calls as possible and hide\n+            // all information which should not matter for the solver.\n+            //\n+            // For this we compress universes as much as possible.\n+            CanonicalizeMode::Input => {}\n+            // When canonicalizing a response we map a universes already entered\n+            // by the caller to the root universe and only return useful universe\n+            // information for placeholders and inference variables created inside\n+            // of the query.\n+            CanonicalizeMode::Response { max_input_universe } => {\n+                for var in var_infos.iter_mut() {\n+                    let uv = var.universe();\n+                    let new_uv = ty::UniverseIndex::from(\n+                        uv.index().saturating_sub(max_input_universe.index()),\n+                    );\n+                    *var = var.with_updated_universe(new_uv);\n+                }\n+                let max_universe = var_infos\n+                    .iter()\n+                    .map(|info| info.universe())\n+                    .max()\n+                    .unwrap_or(ty::UniverseIndex::ROOT);\n+\n+                let var_infos = self.infcx.tcx.mk_canonical_var_infos(&var_infos);\n+                return (max_universe, var_infos);\n+            }\n+        }\n+\n+        // Given a `var_infos` with existentials `En` and universals `Un` in\n+        // universes `n`, this algorithm compresses them in place so that:\n+        //\n+        // - the new universe indices are as small as possible\n+        // - we only create a new universe if we would otherwise put a placeholder in\n+        //   the same compressed universe as an existential which cannot name it\n+        //\n+        // Let's walk through an example:\n+        // - var_infos: [E0, U1, E5, U2, E2, E6, U6], curr_compressed_uv: 0, next_orig_uv: 0\n+        // - var_infos: [E0, U1, E5, U2, E2, E6, U6], curr_compressed_uv: 0, next_orig_uv: 1\n+        // - var_infos: [E0, U1, E5, U2, E2, E6, U6], curr_compressed_uv: 1, next_orig_uv: 2\n+        // - var_infos: [E0, U1, E5, U1, E1, E6, U6], curr_compressed_uv: 1, next_orig_uv: 5\n+        // - var_infos: [E0, U1, E1, U1, E1, E6, U6], curr_compressed_uv: 1, next_orig_uv: 6\n+        // - var_infos: [E0, U1, E1, U1, E1, E2, U2], curr_compressed_uv: 2, next_orig_uv: -\n+        //\n+        // This algorithm runs in `O(n\u00b2)` where `n` is the number of different universe\n+        // indices in the input. This should be fine as `n` is expected to be small.\n+        let mut curr_compressed_uv = ty::UniverseIndex::ROOT;\n+        let mut existential_in_new_uv = false;\n+        let mut next_orig_uv = Some(ty::UniverseIndex::ROOT);\n+        while let Some(orig_uv) = next_orig_uv.take() {\n+            let mut update_uv = |var: &mut CanonicalVarInfo<'tcx>, orig_uv, is_existential| {\n+                let uv = var.universe();\n+                match uv.cmp(&orig_uv) {\n+                    Ordering::Less => (), // Already updated\n+                    Ordering::Equal => {\n+                        if is_existential {\n+                            existential_in_new_uv = true;\n+                        } else if existential_in_new_uv {\n+                            //  `var` is a placeholder from a universe which is not nameable\n+                            // by an existential which we already put into the compressed\n+                            // universe `curr_compressed_uv`. We therefore have to create a\n+                            // new universe for `var`.\n+                            curr_compressed_uv = curr_compressed_uv.next_universe();\n+                            existential_in_new_uv = false;\n+                        }\n+\n+                        *var = var.with_updated_universe(curr_compressed_uv);\n+                    }\n+                    Ordering::Greater => {\n+                        // We can ignore this variable in this iteration. We only look at\n+                        // universes which actually occur in the input for performance.\n+                        //\n+                        // For this we set `next_orig_uv` to the next smallest, not yet compressed,\n+                        // universe of the input.\n+                        if next_orig_uv.map_or(true, |curr_next_uv| uv.cannot_name(curr_next_uv)) {\n+                            next_orig_uv = Some(uv);\n+                        }\n+                    }\n+                }\n+            };\n+\n+            // For each universe which occurs in the input, we first iterate over all\n+            // placeholders and then over all inference variables.\n+            //\n+            // Whenever we compress the universe of a placeholder, no existential with\n+            // an already compressed universe can name that placeholder.\n+            for is_existential in [false, true] {\n+                for var in var_infos.iter_mut() {\n+                    // We simply put all regions from the input into the highest\n+                    // compressed universe, so we only deal with them at the end.\n+                    if !var.is_region() {\n+                        if is_existential == var.is_existential() {\n+                            update_uv(var, orig_uv, is_existential)\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        for var in var_infos.iter_mut() {\n+            if var.is_region() {\n+                assert!(var.is_existential());\n+                *var = var.with_updated_universe(curr_compressed_uv);\n+            }\n+        }\n+\n+        let var_infos = self.infcx.tcx.mk_canonical_var_infos(&var_infos);\n+        (curr_compressed_uv, var_infos)\n+    }\n+}\n+\n+impl<'tcx> TypeFolder<TyCtxt<'tcx>> for Canonicalizer<'_, 'tcx> {\n+    fn interner(&self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn fold_binder<T>(&mut self, t: ty::Binder<'tcx, T>) -> ty::Binder<'tcx, T>\n+    where\n+        T: TypeFoldable<TyCtxt<'tcx>>,\n+    {\n+        self.binder_index.shift_in(1);\n+        let t = t.super_fold_with(self);\n+        self.binder_index.shift_out(1);\n+        t\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        let r = self.infcx.shallow_resolve(r);\n+        let kind = match *r {\n+            ty::ReLateBound(..) => return r,\n+\n+            ty::ReStatic => match self.canonicalize_mode {\n+                CanonicalizeMode::Input => CanonicalVarKind::Region(ty::UniverseIndex::ROOT),\n+                CanonicalizeMode::Response { .. } => return r,\n+            },\n+\n+            ty::ReErased | ty::ReFree(_) | ty::ReEarlyBound(_) => match self.canonicalize_mode {\n+                CanonicalizeMode::Input => CanonicalVarKind::Region(ty::UniverseIndex::ROOT),\n+                CanonicalizeMode::Response { .. } => bug!(\"unexpected region in response: {r:?}\"),\n+            },\n+\n+            ty::RePlaceholder(placeholder) => match self.canonicalize_mode {\n+                // We canonicalize placeholder regions as existentials in query inputs.\n+                CanonicalizeMode::Input => CanonicalVarKind::Region(ty::UniverseIndex::ROOT),\n+                CanonicalizeMode::Response { max_input_universe } => {\n+                    // If we have a placeholder region inside of a query, it must be from\n+                    // a new universe.\n+                    if max_input_universe.can_name(placeholder.universe) {\n+                        bug!(\"new placeholder in universe {max_input_universe:?}: {r:?}\");\n+                    }\n+                    CanonicalVarKind::PlaceholderRegion(placeholder)\n+                }\n+            },\n+\n+            ty::ReVar(_) => match self.canonicalize_mode {\n+                CanonicalizeMode::Input => CanonicalVarKind::Region(ty::UniverseIndex::ROOT),\n+                CanonicalizeMode::Response { .. } => {\n+                    CanonicalVarKind::Region(self.infcx.universe_of_region(r))\n+                }\n+            },\n+\n+            ty::ReError(_) => return r,\n+        };\n+\n+        let existing_bound_var = match self.canonicalize_mode {\n+            CanonicalizeMode::Input => None,\n+            CanonicalizeMode::Response { .. } => {\n+                self.variables.iter().position(|&v| v == r.into()).map(ty::BoundVar::from)\n+            }\n+        };\n+        let var = existing_bound_var.unwrap_or_else(|| {\n+            let var = ty::BoundVar::from(self.variables.len());\n+            self.variables.push(r.into());\n+            self.primitive_var_infos.push(CanonicalVarInfo { kind });\n+            var\n+        });\n+        let br = ty::BoundRegion { var, kind: BrAnon(var.as_u32(), None) };\n+        self.interner().mk_re_late_bound(self.binder_index, br)\n+    }\n+\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        let kind = match *t.kind() {\n+            ty::Infer(ty::TyVar(vid)) => match self.infcx.probe_ty_var(vid) {\n+                Ok(t) => return self.fold_ty(t),\n+                Err(ui) => CanonicalVarKind::Ty(CanonicalTyVarKind::General(ui)),\n+            },\n+            ty::Infer(ty::IntVar(_)) => {\n+                let nt = self.infcx.shallow_resolve(t);\n+                if nt != t {\n+                    return self.fold_ty(nt);\n+                } else {\n+                    CanonicalVarKind::Ty(CanonicalTyVarKind::Int)\n+                }\n+            }\n+            ty::Infer(ty::FloatVar(_)) => {\n+                let nt = self.infcx.shallow_resolve(t);\n+                if nt != t {\n+                    return self.fold_ty(nt);\n+                } else {\n+                    CanonicalVarKind::Ty(CanonicalTyVarKind::Int)\n+                }\n+            }\n+            ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {\n+                bug!(\"fresh var during canonicalization: {t:?}\")\n+            }\n+            ty::Placeholder(placeholder) => match self.canonicalize_mode {\n+                CanonicalizeMode::Input => CanonicalVarKind::PlaceholderTy(ty::Placeholder {\n+                    universe: placeholder.universe,\n+                    name: BoundTyKind::Anon(self.variables.len() as u32),\n+                }),\n+                CanonicalizeMode::Response { .. } => CanonicalVarKind::PlaceholderTy(placeholder),\n+            },\n+            ty::Param(_) => match self.canonicalize_mode {\n+                CanonicalizeMode::Input => CanonicalVarKind::PlaceholderTy(ty::Placeholder {\n+                    universe: ty::UniverseIndex::ROOT,\n+                    name: ty::BoundTyKind::Anon(self.variables.len() as u32),\n+                }),\n+                CanonicalizeMode::Response { .. } => bug!(\"param ty in response: {t:?}\"),\n+            },\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(_)\n+            | ty::Uint(_)\n+            | ty::Float(_)\n+            | ty::Adt(_, _)\n+            | ty::Foreign(_)\n+            | ty::Str\n+            | ty::Array(_, _)\n+            | ty::Slice(_)\n+            | ty::RawPtr(_)\n+            | ty::Ref(_, _, _)\n+            | ty::FnDef(_, _)\n+            | ty::FnPtr(_)\n+            | ty::Dynamic(_, _, _)\n+            | ty::Closure(_, _)\n+            | ty::Generator(_, _, _)\n+            | ty::GeneratorWitness(_)\n+            | ty::GeneratorWitnessMIR(..)\n+            | ty::Never\n+            | ty::Tuple(_)\n+            | ty::Alias(_, _)\n+            | ty::Bound(_, _)\n+            | ty::Error(_) => return t.super_fold_with(self),\n+        };\n+\n+        let var = ty::BoundVar::from(\n+            self.variables.iter().position(|&v| v == t.into()).unwrap_or_else(|| {\n+                let var = self.variables.len();\n+                self.variables.push(t.into());\n+                self.primitive_var_infos.push(CanonicalVarInfo { kind });\n+                var\n+            }),\n+        );\n+        let bt = ty::BoundTy { var, kind: BoundTyKind::Anon(var.index() as u32) };\n+        self.interner().mk_bound(self.binder_index, bt)\n+    }\n+\n+    fn fold_const(&mut self, c: ty::Const<'tcx>) -> ty::Const<'tcx> {\n+        let kind = match c.kind() {\n+            ty::ConstKind::Infer(ty::InferConst::Var(vid)) => match self.infcx.probe_const_var(vid)\n+            {\n+                Ok(c) => return self.fold_const(c),\n+                Err(universe) => CanonicalVarKind::Const(universe, c.ty()),\n+            },\n+            ty::ConstKind::Infer(ty::InferConst::Fresh(_)) => {\n+                bug!(\"fresh var during canonicalization: {c:?}\")\n+            }\n+            ty::ConstKind::Placeholder(placeholder) => match self.canonicalize_mode {\n+                CanonicalizeMode::Input => CanonicalVarKind::PlaceholderConst(\n+                    ty::Placeholder {\n+                        universe: placeholder.universe,\n+                        name: ty::BoundVar::from(self.variables.len()),\n+                    },\n+                    c.ty(),\n+                ),\n+                CanonicalizeMode::Response { .. } => {\n+                    CanonicalVarKind::PlaceholderConst(placeholder, c.ty())\n+                }\n+            },\n+            ty::ConstKind::Param(_) => match self.canonicalize_mode {\n+                CanonicalizeMode::Input => CanonicalVarKind::PlaceholderConst(\n+                    ty::Placeholder {\n+                        universe: ty::UniverseIndex::ROOT,\n+                        name: ty::BoundVar::from(self.variables.len()),\n+                    },\n+                    c.ty(),\n+                ),\n+                CanonicalizeMode::Response { .. } => bug!(\"param ty in response: {c:?}\"),\n+            },\n+            ty::ConstKind::Bound(_, _)\n+            | ty::ConstKind::Unevaluated(_)\n+            | ty::ConstKind::Value(_)\n+            | ty::ConstKind::Error(_)\n+            | ty::ConstKind::Expr(_) => return c.super_fold_with(self),\n+        };\n+\n+        let var = ty::BoundVar::from(\n+            self.variables.iter().position(|&v| v == c.into()).unwrap_or_else(|| {\n+                let var = self.variables.len();\n+                self.variables.push(c.into());\n+                self.primitive_var_infos.push(CanonicalVarInfo { kind });\n+                var\n+            }),\n+        );\n+        self.interner().mk_const(ty::ConstKind::Bound(self.binder_index, var), c.ty())\n+    }\n+}"}, {"sha": "8c3be8da16b57841f5a7523f4b3e8754fe11a595", "filename": "compiler/rustc_trait_selection/src/solve/canonical/mod.rs", "status": "added", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/4f49352e92ed229a1f51423e087734b86c6fe814/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f49352e92ed229a1f51423e087734b86c6fe814/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fmod.rs?ref=4f49352e92ed229a1f51423e087734b86c6fe814", "patch": "@@ -0,0 +1,240 @@\n+/// Canonicalization is used to separate some goal from its context,\n+/// throwing away unnecessary information in the process.\n+///\n+/// This is necessary to cache goals containing inference variables\n+/// and placeholders without restricting them to the current `InferCtxt`.\n+///\n+/// Canonicalization is fairly involved, for more details see the relevant\n+/// section of the [rustc-dev-guide][c].\n+///\n+/// [c]: https://rustc-dev-guide.rust-lang.org/solve/canonicalization.html\n+use self::canonicalize::{CanonicalizeMode, Canonicalizer};\n+use super::{CanonicalGoal, Certainty, EvalCtxt, Goal};\n+use super::{CanonicalResponse, ExternalConstraints, QueryResult, Response};\n+use rustc_infer::infer::canonical::query_response::make_query_region_constraints;\n+use rustc_infer::infer::canonical::CanonicalVarValues;\n+use rustc_infer::infer::canonical::{CanonicalExt, QueryRegionConstraints};\n+use rustc_infer::traits::query::NoSolution;\n+use rustc_infer::traits::solve::ExternalConstraintsData;\n+use rustc_infer::traits::ObligationCause;\n+use rustc_middle::ty::{self, GenericArgKind};\n+use rustc_span::DUMMY_SP;\n+use std::iter;\n+use std::ops::Deref;\n+\n+mod canonicalize;\n+\n+impl<'tcx> EvalCtxt<'_, 'tcx> {\n+    /// Canonicalizes the goal remembering the original values\n+    /// for each bound variable.\n+    pub(super) fn canonicalize_goal(\n+        &self,\n+        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n+    ) -> (Vec<ty::GenericArg<'tcx>>, CanonicalGoal<'tcx>) {\n+        let mut orig_values = Default::default();\n+        let canonical_goal = Canonicalizer::canonicalize(\n+            self.infcx,\n+            CanonicalizeMode::Input,\n+            &mut orig_values,\n+            goal,\n+        );\n+        (orig_values, canonical_goal)\n+    }\n+\n+    /// To return the constraints of a canonical query to the caller, we canonicalize:\n+    ///\n+    /// - `var_values`: a map from bound variables in the canonical goal to\n+    ///   the values inferred while solving the instantiated goal.\n+    /// - `external_constraints`: additional constraints which aren't expressable\n+    ///   using simple unification of inference variables.\n+    #[instrument(level = \"debug\", skip(self))]\n+    pub(super) fn make_canonical_response(&self, certainty: Certainty) -> QueryResult<'tcx> {\n+        let external_constraints = self.compute_external_query_constraints()?;\n+\n+        let response = Response { var_values: self.var_values, external_constraints, certainty };\n+        let canonical = Canonicalizer::canonicalize(\n+            self.infcx,\n+            CanonicalizeMode::Response { max_input_universe: self.max_input_universe },\n+            &mut Default::default(),\n+            response,\n+        );\n+        Ok(canonical)\n+    }\n+\n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    fn compute_external_query_constraints(&self) -> Result<ExternalConstraints<'tcx>, NoSolution> {\n+        // Cannot use `take_registered_region_obligations` as we may compute the response\n+        // inside of a `probe` whenever we have multiple choices inside of the solver.\n+        let region_obligations = self.infcx.inner.borrow().region_obligations().to_owned();\n+        let region_constraints = self.infcx.with_region_constraints(|region_constraints| {\n+            make_query_region_constraints(\n+                self.tcx(),\n+                region_obligations\n+                    .iter()\n+                    .map(|r_o| (r_o.sup_type, r_o.sub_region, r_o.origin.to_constraint_category())),\n+                region_constraints,\n+            )\n+        });\n+        let opaque_types = self.infcx.clone_opaque_types_for_query_response();\n+        Ok(self\n+            .tcx()\n+            .mk_external_constraints(ExternalConstraintsData { region_constraints, opaque_types }))\n+    }\n+\n+    /// After calling a canonical query, we apply the constraints returned\n+    /// by the query using this function.\n+    ///\n+    /// This happens in three steps:\n+    /// - we instantiate the bound variables of the query response\n+    /// - we unify the `var_values` of the response with the `original_values`\n+    /// - we apply the `external_constraints` returned by the query\n+    pub(super) fn instantiate_and_apply_query_response(\n+        &mut self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        original_values: Vec<ty::GenericArg<'tcx>>,\n+        response: CanonicalResponse<'tcx>,\n+    ) -> Result<Certainty, NoSolution> {\n+        let substitution = self.compute_query_response_substitution(&original_values, &response);\n+\n+        let Response { var_values, external_constraints, certainty } =\n+            response.substitute(self.tcx(), &substitution);\n+\n+        self.unify_query_var_values(param_env, &original_values, var_values)?;\n+\n+        // FIXME: implement external constraints.\n+        let ExternalConstraintsData { region_constraints, opaque_types: _ } =\n+            external_constraints.deref();\n+        self.register_region_constraints(region_constraints);\n+\n+        Ok(certainty)\n+    }\n+\n+    /// This returns the substitutions to instantiate the bound variables of\n+    /// the canonical reponse. This depends on the `original_values` for the\n+    /// bound variables.\n+    fn compute_query_response_substitution(\n+        &self,\n+        original_values: &[ty::GenericArg<'tcx>],\n+        response: &CanonicalResponse<'tcx>,\n+    ) -> CanonicalVarValues<'tcx> {\n+        // FIXME: Longterm canonical queries should deal with all placeholders\n+        // created inside of the query directly instead of returning them to the\n+        // caller.\n+        let prev_universe = self.infcx.universe();\n+        let universes_created_in_query = response.max_universe.index() + 1;\n+        for _ in 0..universes_created_in_query {\n+            self.infcx.create_next_universe();\n+        }\n+\n+        let var_values = response.value.var_values;\n+        assert_eq!(original_values.len(), var_values.len());\n+\n+        // If the query did not make progress with constraining inference variables,\n+        // we would normally create a new inference variables for bound existential variables\n+        // only then unify this new inference variable with the inference variable from\n+        // the input.\n+        //\n+        // We therefore instantiate the existential variable in the canonical response with the\n+        // inference variable of the input right away, which is more performant.\n+        let mut opt_values = vec![None; response.variables.len()];\n+        for (original_value, result_value) in iter::zip(original_values, var_values.var_values) {\n+            match result_value.unpack() {\n+                GenericArgKind::Type(t) => {\n+                    if let &ty::Bound(debruijn, b) = t.kind() {\n+                        assert_eq!(debruijn, ty::INNERMOST);\n+                        opt_values[b.var.index()] = Some(*original_value);\n+                    }\n+                }\n+                GenericArgKind::Lifetime(r) => {\n+                    if let ty::ReLateBound(debruijn, br) = *r {\n+                        assert_eq!(debruijn, ty::INNERMOST);\n+                        opt_values[br.var.index()] = Some(*original_value);\n+                    }\n+                }\n+                GenericArgKind::Const(c) => {\n+                    if let ty::ConstKind::Bound(debrujin, b) = c.kind() {\n+                        assert_eq!(debrujin, ty::INNERMOST);\n+                        opt_values[b.index()] = Some(*original_value);\n+                    }\n+                }\n+            }\n+        }\n+\n+        let var_values = self.tcx().mk_substs_from_iter(response.variables.iter().enumerate().map(\n+            |(index, info)| {\n+                if info.universe() != ty::UniverseIndex::ROOT {\n+                    // A variable from inside a binder of the query. While ideally these shouldn't\n+                    // exist at all (see the FIXME at the start of this method), we have to deal with\n+                    // them for now.\n+                    self.infcx.instantiate_canonical_var(DUMMY_SP, info, |idx| {\n+                        ty::UniverseIndex::from(prev_universe.index() + idx.index())\n+                    })\n+                } else if info.is_existential() {\n+                    // As an optimization we sometimes avoid creating a new inference variable here.\n+                    //\n+                    // All new inference variables we create start out in the current universe of the caller.\n+                    // This is conceptionally wrong as these inference variables would be able to name\n+                    // more placeholders then they should be able to. However the inference variables have\n+                    // to \"come from somewhere\", so by equating them with the original values of the caller\n+                    // later on, we pull them down into their correct universe again.\n+                    if let Some(v) = opt_values[index] {\n+                        v\n+                    } else {\n+                        self.infcx.instantiate_canonical_var(DUMMY_SP, info, |_| prev_universe)\n+                    }\n+                } else {\n+                    // For placeholders which were already part of the input, we simply map this\n+                    // universal bound variable back the placeholder of the input.\n+                    original_values[info.expect_anon_placeholder() as usize]\n+                }\n+            },\n+        ));\n+\n+        CanonicalVarValues { var_values }\n+    }\n+\n+    #[instrument(level = \"debug\", skip(self, param_env), ret)]\n+    fn unify_query_var_values(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        original_values: &[ty::GenericArg<'tcx>],\n+        var_values: CanonicalVarValues<'tcx>,\n+    ) -> Result<(), NoSolution> {\n+        assert_eq!(original_values.len(), var_values.len());\n+        for (&orig, response) in iter::zip(original_values, var_values.var_values) {\n+            // This can fail due to the occurs check, see\n+            // `tests/ui/typeck/lazy-norm/equating-projection-cyclically.rs` for an example\n+            // where that can happen.\n+            //\n+            // FIXME: To deal with #105787 I also expect us to emit nested obligations here at\n+            // some point. We can figure out how to deal with this once we actually have\n+            // an ICE.\n+            let nested_goals = self.eq(param_env, orig, response)?;\n+            assert!(nested_goals.is_empty(), \"{nested_goals:?}\");\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn register_region_constraints(&mut self, region_constraints: &QueryRegionConstraints<'tcx>) {\n+        for &(ty::OutlivesPredicate(lhs, rhs), _) in &region_constraints.outlives {\n+            match lhs.unpack() {\n+                GenericArgKind::Lifetime(lhs) => self.infcx.region_outlives_predicate(\n+                    &ObligationCause::dummy(),\n+                    ty::Binder::dummy(ty::OutlivesPredicate(lhs, rhs)),\n+                ),\n+                GenericArgKind::Type(lhs) => self.infcx.register_region_obligation_with_cause(\n+                    lhs,\n+                    rhs,\n+                    &ObligationCause::dummy(),\n+                ),\n+                GenericArgKind::Const(_) => bug!(\"const outlives: {lhs:?}: {rhs:?}\"),\n+            }\n+        }\n+\n+        for member_constraint in &region_constraints.member_constraints {\n+            // FIXME: Deal with member constraints :<\n+            let _ = member_constraint;\n+        }\n+    }\n+}"}, {"sha": "95612674eb9d417a0fa173e1c6516ce9e4679cfa", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4f49352e92ed229a1f51423e087734b86c6fe814/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f49352e92ed229a1f51423e087734b86c6fe814/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=4f49352e92ed229a1f51423e087734b86c6fe814", "patch": "@@ -19,8 +19,17 @@ use super::Goal;\n pub struct EvalCtxt<'a, 'tcx> {\n     // FIXME: should be private.\n     pub(super) infcx: &'a InferCtxt<'tcx>,\n-\n     pub(super) var_values: CanonicalVarValues<'tcx>,\n+    /// The highest universe index nameable by the caller.\n+    ///\n+    /// When we enter a new binder inside of the query we create new universes\n+    /// which the caller cannot name. We have to be careful with variables from\n+    /// these new universes when creating the query response.\n+    ///\n+    /// Both because these new universes can prevent us from reaching a fixpoint\n+    /// if we have a coinductive cycle and because that's the only way we can return\n+    /// new placeholders to the caller.\n+    pub(super) max_input_universe: ty::UniverseIndex,\n \n     pub(super) search_graph: &'a mut SearchGraph<'tcx>,\n "}, {"sha": "57b6a4527371835c0bee86d095e7a9f63a8d480a", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 27, "deletions": 70, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/4f49352e92ed229a1f51423e087734b86c6fe814/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f49352e92ed229a1f51423e087734b86c6fe814/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=4f49352e92ed229a1f51423e087734b86c6fe814", "patch": "@@ -19,11 +19,9 @@ use std::mem;\n \n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::canonical::{Canonical, CanonicalVarValues};\n-use rustc_infer::infer::canonical::{OriginalQueryValues, QueryRegionConstraints, QueryResponse};\n use rustc_infer::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::Obligation;\n-use rustc_middle::infer::canonical::Certainty as OldCertainty;\n use rustc_middle::traits::solve::{ExternalConstraints, ExternalConstraintsData};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{\n@@ -35,6 +33,7 @@ use crate::solve::search_graph::OverflowHandler;\n use crate::traits::ObligationCause;\n \n mod assembly;\n+mod canonical;\n mod eval_ctxt;\n mod fulfill;\n mod project_goals;\n@@ -89,11 +88,8 @@ trait CanonicalResponseExt {\n \n impl<'tcx> CanonicalResponseExt for Canonical<'tcx, Response<'tcx>> {\n     fn has_no_inference_or_external_constraints(&self) -> bool {\n-        // so that we get a compile error when regions are supported\n-        // so this code can be checked for being correct\n-        let _: () = self.value.external_constraints.regions;\n-\n-        self.value.var_values.is_identity()\n+        self.value.external_constraints.region_constraints.is_empty()\n+            && self.value.var_values.is_identity()\n             && self.value.external_constraints.opaque_types.is_empty()\n     }\n }\n@@ -169,6 +165,8 @@ impl<'tcx> InferCtxtEvalExt<'tcx> for InferCtxt<'tcx> {\n         let result = EvalCtxt {\n             search_graph: &mut search_graph,\n             infcx: self,\n+            // Only relevant when canonicalizing the response.\n+            max_input_universe: ty::UniverseIndex::ROOT,\n             var_values: CanonicalVarValues::dummy(),\n             in_projection_eq_hack: false,\n         }\n@@ -201,36 +199,33 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         search_graph.with_new_goal(tcx, canonical_goal, |search_graph| {\n             let (ref infcx, goal, var_values) =\n                 tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical_goal);\n-            let mut ecx =\n-                EvalCtxt { infcx, var_values, search_graph, in_projection_eq_hack: false };\n+            let mut ecx = EvalCtxt {\n+                infcx,\n+                var_values,\n+                max_input_universe: canonical_goal.max_universe,\n+                search_graph,\n+                in_projection_eq_hack: false,\n+            };\n             ecx.compute_goal(goal)\n         })\n     }\n \n-    fn make_canonical_response(&self, certainty: Certainty) -> QueryResult<'tcx> {\n-        let external_constraints = compute_external_query_constraints(self.infcx)?;\n-\n-        Ok(self.infcx.canonicalize_response(Response {\n-            var_values: self.var_values,\n-            external_constraints,\n-            certainty,\n-        }))\n-    }\n-\n     /// Recursively evaluates `goal`, returning whether any inference vars have\n     /// been constrained and the certainty of the result.\n     fn evaluate_goal(\n         &mut self,\n         goal: Goal<'tcx, ty::Predicate<'tcx>>,\n     ) -> Result<(bool, Certainty), NoSolution> {\n-        let mut orig_values = OriginalQueryValues::default();\n-        let canonical_goal = self.infcx.canonicalize_query(goal, &mut orig_values);\n+        let (orig_values, canonical_goal) = self.canonicalize_goal(goal);\n         let canonical_response =\n             EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n \n         let has_changed = !canonical_response.value.var_values.is_identity();\n-        let certainty =\n-            instantiate_canonical_query_response(self.infcx, &orig_values, canonical_response);\n+        let certainty = self.instantiate_and_apply_query_response(\n+            goal.param_env,\n+            orig_values,\n+            canonical_response,\n+        )?;\n \n         // Check that rerunning this query with its inference constraints applied\n         // doesn't result in new inference constraints and has the same result.\n@@ -244,8 +239,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             && !self.in_projection_eq_hack\n             && !self.search_graph.in_cycle()\n         {\n-            let mut orig_values = OriginalQueryValues::default();\n-            let canonical_goal = self.infcx.canonicalize_query(goal, &mut orig_values);\n+            let (_orig_values, canonical_goal) = self.canonicalize_goal(goal);\n             let canonical_response =\n                 EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n             if !canonical_response.value.var_values.is_identity() {\n@@ -316,15 +310,21 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n \n     fn compute_type_outlives_goal(\n         &mut self,\n-        _goal: Goal<'tcx, TypeOutlivesPredicate<'tcx>>,\n+        goal: Goal<'tcx, TypeOutlivesPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n+        let ty::OutlivesPredicate(ty, lt) = goal.predicate;\n+        self.infcx.register_region_obligation_with_cause(ty, lt, &ObligationCause::dummy());\n         self.make_canonical_response(Certainty::Yes)\n     }\n \n     fn compute_region_outlives_goal(\n         &mut self,\n-        _goal: Goal<'tcx, RegionOutlivesPredicate<'tcx>>,\n+        goal: Goal<'tcx, RegionOutlivesPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n+        self.infcx.region_outlives_predicate(\n+            &ObligationCause::dummy(),\n+            ty::Binder::dummy(goal.predicate),\n+        );\n         self.make_canonical_response(Certainty::Yes)\n     }\n \n@@ -561,49 +561,6 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n     }\n }\n \n-#[instrument(level = \"debug\", skip(infcx), ret)]\n-fn compute_external_query_constraints<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n-) -> Result<ExternalConstraints<'tcx>, NoSolution> {\n-    let region_obligations = infcx.take_registered_region_obligations();\n-    let opaque_types = infcx.take_opaque_types_for_query_response();\n-    Ok(infcx.tcx.mk_external_constraints(ExternalConstraintsData {\n-        // FIXME: Now that's definitely wrong :)\n-        //\n-        // Should also do the leak check here I think\n-        regions: drop(region_obligations),\n-        opaque_types,\n-    }))\n-}\n-\n-fn instantiate_canonical_query_response<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n-    original_values: &OriginalQueryValues<'tcx>,\n-    response: CanonicalResponse<'tcx>,\n-) -> Certainty {\n-    let Ok(InferOk { value, obligations }) = infcx\n-        .instantiate_query_response_and_region_obligations(\n-            &ObligationCause::dummy(),\n-            ty::ParamEnv::empty(),\n-            original_values,\n-            &response.unchecked_map(|resp| QueryResponse {\n-                var_values: resp.var_values,\n-                region_constraints: QueryRegionConstraints::default(),\n-                certainty: match resp.certainty {\n-                    Certainty::Yes => OldCertainty::Proven,\n-                    Certainty::Maybe(_) => OldCertainty::Ambiguous,\n-                },\n-                // FIXME: This to_owned makes me sad, but we should eventually impl\n-                // `instantiate_query_response_and_region_obligations` separately\n-                // instead of piggybacking off of the old implementation.\n-                opaque_types: resp.external_constraints.opaque_types.to_owned(),\n-                value: resp.certainty,\n-            }),\n-        ) else { bug!(); };\n-    assert!(obligations.is_empty());\n-    value\n-}\n-\n pub(super) fn response_no_constraints<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     goal: Canonical<'tcx, impl Sized>,"}, {"sha": "33c66d072e944dd5c8353d230df8855abaf7b796", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4f49352e92ed229a1f51423e087734b86c6fe814/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f49352e92ed229a1f51423e087734b86c6fe814/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=4f49352e92ed229a1f51423e087734b86c6fe814", "patch": "@@ -77,10 +77,11 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         let nested_goals = self\n             .eq(goal.param_env, goal.predicate.term, normalized_alias.into())\n             .expect(\"failed to unify with unconstrained term\");\n-        let rhs_certainty =\n+\n+        let unify_certainty =\n             self.evaluate_all(nested_goals).expect(\"failed to unify with unconstrained term\");\n \n-        self.make_canonical_response(normalization_certainty.unify_and(rhs_certainty))\n+        self.make_canonical_response(normalization_certainty.unify_and(unify_certainty))\n     }\n }\n "}]}