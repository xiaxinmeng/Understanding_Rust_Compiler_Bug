{"sha": "6b83862d09fe3cb04de50c335428b2ac5b2307ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiODM4NjJkMDlmZTNjYjA0ZGU1MGMzMzU0MjhiMmFjNWIyMzA3Y2U=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-01-16T06:28:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-16T06:28:00Z"}, "message": "Rollup merge of #67780 - cjgillot:passes-ty, r=Zoxc\n\nMove some queries from rustc::ty to librustc_ty.\n\ncc #65031", "tree": {"sha": "9b30bcd14b60d27e7ea93048b4d7e7a000615514", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b30bcd14b60d27e7ea93048b4d7e7a000615514"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b83862d09fe3cb04de50c335428b2ac5b2307ce", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeIAJwCRBK7hj4Ov3rIwAAdHIIAIODSv4d7AWsiYbFXlNwh13u\nZ+XwiyhdOXhOwPx4KhF7Xbc3M4gHOCYu8qjexpb9nOoXp2blp/sBChTiF2Vm1JmZ\nvoN2E7knt7jXG8RKjwf4i0EGo3CPeuTPh/n4BztoGAK7/r3BWG0gWOihLZBtoBIo\ngscXzhrT/YxrWpkLJ+D/92IOfuNG4Go+6V6mP4PZ5aGL/3jY6+vVypJjMeRiv+1+\nbGQPRiOQCK/uPxUk4pkTUiL2u+uy1/CI84ChW57qEhnxXIKdeN9ukKT0kL1EMk33\nViGSHycSOJdXHdBSxHNpQ6sxnoA3z3JshhG9me9y3ozUcRZDmZYKC4FakY8LQ60=\n=iaQ3\n-----END PGP SIGNATURE-----\n", "payload": "tree 9b30bcd14b60d27e7ea93048b4d7e7a000615514\nparent e02c475da5c7d942cac2e3cf9683ea4117d4fe46\nparent 894dc2d3d2b96e1f992324aa95125e0d161ab681\nauthor Dylan DPC <dylan.dpc@gmail.com> 1579156080 +0530\ncommitter GitHub <noreply@github.com> 1579156080 +0530\n\nRollup merge of #67780 - cjgillot:passes-ty, r=Zoxc\n\nMove some queries from rustc::ty to librustc_ty.\n\ncc #65031\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b83862d09fe3cb04de50c335428b2ac5b2307ce", "html_url": "https://github.com/rust-lang/rust/commit/6b83862d09fe3cb04de50c335428b2ac5b2307ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b83862d09fe3cb04de50c335428b2ac5b2307ce/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e02c475da5c7d942cac2e3cf9683ea4117d4fe46", "url": "https://api.github.com/repos/rust-lang/rust/commits/e02c475da5c7d942cac2e3cf9683ea4117d4fe46", "html_url": "https://github.com/rust-lang/rust/commit/e02c475da5c7d942cac2e3cf9683ea4117d4fe46"}, {"sha": "894dc2d3d2b96e1f992324aa95125e0d161ab681", "url": "https://api.github.com/repos/rust-lang/rust/commits/894dc2d3d2b96e1f992324aa95125e0d161ab681", "html_url": "https://github.com/rust-lang/rust/commit/894dc2d3d2b96e1f992324aa95125e0d161ab681"}], "stats": {"total": 780, "additions": 426, "deletions": 354}, "files": [{"sha": "f33d7ff12febff8ddad98478bc31215fb2e5f310", "filename": "Cargo.lock", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6b83862d09fe3cb04de50c335428b2ac5b2307ce/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/6b83862d09fe3cb04de50c335428b2ac5b2307ce/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=6b83862d09fe3cb04de50c335428b2ac5b2307ce", "patch": "@@ -3652,6 +3652,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"rustc_traits\",\n+ \"rustc_ty\",\n  \"rustc_typeck\",\n  \"serialize\",\n  \"smallvec 1.0.0\",\n@@ -3953,6 +3954,17 @@ dependencies = [\n  \"syntax\",\n ]\n \n+[[package]]\n+name = \"rustc_ty\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log\",\n+ \"rustc\",\n+ \"rustc_data_structures\",\n+ \"rustc_hir\",\n+ \"rustc_span\",\n+]\n+\n [[package]]\n name = \"rustc_typeck\"\n version = \"0.0.0\""}, {"sha": "e6acb6b74dc6340b449d074ef66d7875463c371e", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 354, "changes": 356, "blob_url": "https://github.com/rust-lang/rust/blob/6b83862d09fe3cb04de50c335428b2ac5b2307ce/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b83862d09fe3cb04de50c335428b2ac5b2307ce/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=6b83862d09fe3cb04de50c335428b2ac5b2307ce", "patch": "@@ -18,7 +18,6 @@ use crate::middle::resolve_lifetime::ObjectLifetimeDefault;\n use crate::mir::interpret::ErrorHandled;\n use crate::mir::GeneratorLayout;\n use crate::mir::ReadOnlyBodyAndCache;\n-use crate::session::CrateDisambiguator;\n use crate::session::DataTypeKind;\n use crate::traits::{self, Reveal};\n use crate::ty;\n@@ -31,7 +30,6 @@ use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::{self, par_iter, Lrc, ParallelIterator};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n@@ -2423,70 +2421,6 @@ impl<'tcx> AdtDef {\n     pub fn sized_constraint(&self, tcx: TyCtxt<'tcx>) -> &'tcx [Ty<'tcx>] {\n         tcx.adt_sized_constraint(self.did).0\n     }\n-\n-    fn sized_constraint_for_ty(&self, tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Vec<Ty<'tcx>> {\n-        let result = match ty.kind {\n-            Bool | Char | Int(..) | Uint(..) | Float(..) | RawPtr(..) | Ref(..) | FnDef(..)\n-            | FnPtr(_) | Array(..) | Closure(..) | Generator(..) | Never => vec![],\n-\n-            Str | Dynamic(..) | Slice(_) | Foreign(..) | Error | GeneratorWitness(..) => {\n-                // these are never sized - return the target type\n-                vec![ty]\n-            }\n-\n-            Tuple(ref tys) => match tys.last() {\n-                None => vec![],\n-                Some(ty) => self.sized_constraint_for_ty(tcx, ty.expect_ty()),\n-            },\n-\n-            Adt(adt, substs) => {\n-                // recursive case\n-                let adt_tys = adt.sized_constraint(tcx);\n-                debug!(\"sized_constraint_for_ty({:?}) intermediate = {:?}\", ty, adt_tys);\n-                adt_tys\n-                    .iter()\n-                    .map(|ty| ty.subst(tcx, substs))\n-                    .flat_map(|ty| self.sized_constraint_for_ty(tcx, ty))\n-                    .collect()\n-            }\n-\n-            Projection(..) | Opaque(..) => {\n-                // must calculate explicitly.\n-                // FIXME: consider special-casing always-Sized projections\n-                vec![ty]\n-            }\n-\n-            UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n-\n-            Param(..) => {\n-                // perf hack: if there is a `T: Sized` bound, then\n-                // we know that `T` is Sized and do not need to check\n-                // it on the impl.\n-\n-                let sized_trait = match tcx.lang_items().sized_trait() {\n-                    Some(x) => x,\n-                    _ => return vec![ty],\n-                };\n-                let sized_predicate = Binder::dummy(TraitRef {\n-                    def_id: sized_trait,\n-                    substs: tcx.mk_substs_trait(ty, &[]),\n-                })\n-                .to_predicate();\n-                let predicates = tcx.predicates_of(self.did).predicates;\n-                if predicates.iter().any(|(p, _)| *p == sized_predicate) {\n-                    vec![]\n-                } else {\n-                    vec![ty]\n-                }\n-            }\n-\n-            Placeholder(..) | Bound(..) | Infer(..) => {\n-                bug!(\"unexpected type `{:?}` in sized_constraint_for_ty\", ty)\n-            }\n-        };\n-        debug!(\"sized_constraint_for_ty({:?}) = {:?}\", ty, result);\n-        result\n-    }\n }\n \n impl<'tcx> FieldDef {\n@@ -2742,57 +2676,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         is_associated_item.then(|| self.associated_item(def_id))\n     }\n \n-    fn associated_item_from_trait_item_ref(\n-        self,\n-        parent_def_id: DefId,\n-        parent_vis: &hir::Visibility<'_>,\n-        trait_item_ref: &hir::TraitItemRef,\n-    ) -> AssocItem {\n-        let def_id = self.hir().local_def_id(trait_item_ref.id.hir_id);\n-        let (kind, has_self) = match trait_item_ref.kind {\n-            hir::AssocItemKind::Const => (ty::AssocKind::Const, false),\n-            hir::AssocItemKind::Method { has_self } => (ty::AssocKind::Method, has_self),\n-            hir::AssocItemKind::Type => (ty::AssocKind::Type, false),\n-            hir::AssocItemKind::OpaqueTy => bug!(\"only impls can have opaque types\"),\n-        };\n-\n-        AssocItem {\n-            ident: trait_item_ref.ident,\n-            kind,\n-            // Visibility of trait items is inherited from their traits.\n-            vis: Visibility::from_hir(parent_vis, trait_item_ref.id.hir_id, self),\n-            defaultness: trait_item_ref.defaultness,\n-            def_id,\n-            container: TraitContainer(parent_def_id),\n-            method_has_self_argument: has_self,\n-        }\n-    }\n-\n-    fn associated_item_from_impl_item_ref(\n-        self,\n-        parent_def_id: DefId,\n-        impl_item_ref: &hir::ImplItemRef<'_>,\n-    ) -> AssocItem {\n-        let def_id = self.hir().local_def_id(impl_item_ref.id.hir_id);\n-        let (kind, has_self) = match impl_item_ref.kind {\n-            hir::AssocItemKind::Const => (ty::AssocKind::Const, false),\n-            hir::AssocItemKind::Method { has_self } => (ty::AssocKind::Method, has_self),\n-            hir::AssocItemKind::Type => (ty::AssocKind::Type, false),\n-            hir::AssocItemKind::OpaqueTy => (ty::AssocKind::OpaqueTy, false),\n-        };\n-\n-        AssocItem {\n-            ident: impl_item_ref.ident,\n-            kind,\n-            // Visibility of trait impl items doesn't matter.\n-            vis: ty::Visibility::from_hir(&impl_item_ref.vis, impl_item_ref.id.hir_id, self),\n-            defaultness: impl_item_ref.defaultness,\n-            def_id,\n-            container: ImplContainer(parent_def_id),\n-            method_has_self_argument: has_self,\n-        }\n-    }\n-\n     pub fn field_index(self, hir_id: hir::HirId, tables: &TypeckTables<'_>) -> usize {\n         tables.field_indices().get(hir_id).cloned().expect(\"no index for a field\")\n     }\n@@ -3070,105 +2953,9 @@ impl Iterator for AssocItemsIterator<'_> {\n     }\n }\n \n-fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> AssocItem {\n-    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    let parent_id = tcx.hir().get_parent_item(id);\n-    let parent_def_id = tcx.hir().local_def_id(parent_id);\n-    let parent_item = tcx.hir().expect_item(parent_id);\n-    match parent_item.kind {\n-        hir::ItemKind::Impl(.., ref impl_item_refs) => {\n-            if let Some(impl_item_ref) = impl_item_refs.iter().find(|i| i.id.hir_id == id) {\n-                let assoc_item =\n-                    tcx.associated_item_from_impl_item_ref(parent_def_id, impl_item_ref);\n-                debug_assert_eq!(assoc_item.def_id, def_id);\n-                return assoc_item;\n-            }\n-        }\n-\n-        hir::ItemKind::Trait(.., ref trait_item_refs) => {\n-            if let Some(trait_item_ref) = trait_item_refs.iter().find(|i| i.id.hir_id == id) {\n-                let assoc_item = tcx.associated_item_from_trait_item_ref(\n-                    parent_def_id,\n-                    &parent_item.vis,\n-                    trait_item_ref,\n-                );\n-                debug_assert_eq!(assoc_item.def_id, def_id);\n-                return assoc_item;\n-            }\n-        }\n-\n-        _ => {}\n-    }\n-\n-    span_bug!(\n-        parent_item.span,\n-        \"unexpected parent of trait or impl item or item not found: {:?}\",\n-        parent_item.kind\n-    )\n-}\n-\n #[derive(Clone, HashStable)]\n pub struct AdtSizedConstraint<'tcx>(pub &'tcx [Ty<'tcx>]);\n \n-/// Calculates the `Sized` constraint.\n-///\n-/// In fact, there are only a few options for the types in the constraint:\n-///     - an obviously-unsized type\n-///     - a type parameter or projection whose Sizedness can't be known\n-///     - a tuple of type parameters or projections, if there are multiple\n-///       such.\n-///     - a Error, if a type contained itself. The representability\n-///       check should catch this case.\n-fn adt_sized_constraint(tcx: TyCtxt<'_>, def_id: DefId) -> AdtSizedConstraint<'_> {\n-    let def = tcx.adt_def(def_id);\n-\n-    let result = tcx.mk_type_list(\n-        def.variants\n-            .iter()\n-            .flat_map(|v| v.fields.last())\n-            .flat_map(|f| def.sized_constraint_for_ty(tcx, tcx.type_of(f.did))),\n-    );\n-\n-    debug!(\"adt_sized_constraint: {:?} => {:?}\", def, result);\n-\n-    AdtSizedConstraint(result)\n-}\n-\n-fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n-    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    let item = tcx.hir().expect_item(id);\n-    match item.kind {\n-        hir::ItemKind::Trait(.., ref trait_item_refs) => tcx.arena.alloc_from_iter(\n-            trait_item_refs\n-                .iter()\n-                .map(|trait_item_ref| trait_item_ref.id)\n-                .map(|id| tcx.hir().local_def_id(id.hir_id)),\n-        ),\n-        hir::ItemKind::Impl(.., ref impl_item_refs) => tcx.arena.alloc_from_iter(\n-            impl_item_refs\n-                .iter()\n-                .map(|impl_item_ref| impl_item_ref.id)\n-                .map(|id| tcx.hir().local_def_id(id.hir_id)),\n-        ),\n-        hir::ItemKind::TraitAlias(..) => &[],\n-        _ => span_bug!(item.span, \"associated_item_def_ids: not impl or trait\"),\n-    }\n-}\n-\n-fn def_span(tcx: TyCtxt<'_>, def_id: DefId) -> Span {\n-    tcx.hir().span_if_local(def_id).unwrap()\n-}\n-\n-/// If the given `DefId` describes an item belonging to a trait,\n-/// returns the `DefId` of the trait that the trait item belongs to;\n-/// otherwise, returns `None`.\n-fn trait_of_item(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n-    tcx.opt_associated_item(def_id).and_then(|associated_item| match associated_item.container {\n-        TraitContainer(def_id) => Some(def_id),\n-        ImplContainer(_) => None,\n-    })\n-}\n-\n /// Yields the parent function's `DefId` if `def_id` is an `impl Trait` definition.\n pub fn is_impl_trait_defn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n     if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n@@ -3181,151 +2968,12 @@ pub fn is_impl_trait_defn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n     None\n }\n \n-/// See `ParamEnv` struct definition for details.\n-fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ParamEnv<'_> {\n-    // The param_env of an impl Trait type is its defining function's param_env\n-    if let Some(parent) = is_impl_trait_defn(tcx, def_id) {\n-        return param_env(tcx, parent);\n-    }\n-    // Compute the bounds on Self and the type parameters.\n-\n-    let InstantiatedPredicates { predicates } = tcx.predicates_of(def_id).instantiate_identity(tcx);\n-\n-    // Finally, we have to normalize the bounds in the environment, in\n-    // case they contain any associated type projections. This process\n-    // can yield errors if the put in illegal associated types, like\n-    // `<i32 as Foo>::Bar` where `i32` does not implement `Foo`. We\n-    // report these errors right here; this doesn't actually feel\n-    // right to me, because constructing the environment feels like a\n-    // kind of a \"idempotent\" action, but I'm not sure where would be\n-    // a better place. In practice, we construct environments for\n-    // every fn once during type checking, and we'll abort if there\n-    // are any errors at that point, so after type checking you can be\n-    // sure that this will succeed without errors anyway.\n-\n-    let unnormalized_env = ty::ParamEnv::new(\n-        tcx.intern_predicates(&predicates),\n-        traits::Reveal::UserFacing,\n-        tcx.sess.opts.debugging_opts.chalk.then_some(def_id),\n-    );\n-\n-    let body_id = tcx.hir().as_local_hir_id(def_id).map_or(hir::DUMMY_HIR_ID, |id| {\n-        tcx.hir().maybe_body_owned_by(id).map_or(id, |body| body.hir_id)\n-    });\n-    let cause = traits::ObligationCause::misc(tcx.def_span(def_id), body_id);\n-    traits::normalize_param_env_or_error(tcx, def_id, unnormalized_env, cause)\n-}\n-\n-fn crate_disambiguator(tcx: TyCtxt<'_>, crate_num: CrateNum) -> CrateDisambiguator {\n-    assert_eq!(crate_num, LOCAL_CRATE);\n-    tcx.sess.local_crate_disambiguator()\n-}\n-\n-fn original_crate_name(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Symbol {\n-    assert_eq!(crate_num, LOCAL_CRATE);\n-    tcx.crate_name.clone()\n-}\n-\n-fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n-    assert_eq!(crate_num, LOCAL_CRATE);\n-    tcx.hir().crate_hash\n-}\n-\n-fn instance_def_size_estimate<'tcx>(tcx: TyCtxt<'tcx>, instance_def: InstanceDef<'tcx>) -> usize {\n-    match instance_def {\n-        InstanceDef::Item(..) | InstanceDef::DropGlue(..) => {\n-            let mir = tcx.instance_mir(instance_def);\n-            mir.basic_blocks().iter().map(|bb| bb.statements.len()).sum()\n-        }\n-        // Estimate the size of other compiler-generated shims to be 1.\n-        _ => 1,\n-    }\n-}\n-\n-/// If `def_id` is an issue 33140 hack impl, returns its self type; otherwise, returns `None`.\n-///\n-/// See [`ImplOverlapKind::Issue33140`] for more details.\n-fn issue33140_self_ty(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Ty<'_>> {\n-    debug!(\"issue33140_self_ty({:?})\", def_id);\n-\n-    let trait_ref = tcx\n-        .impl_trait_ref(def_id)\n-        .unwrap_or_else(|| bug!(\"issue33140_self_ty called on inherent impl {:?}\", def_id));\n-\n-    debug!(\"issue33140_self_ty({:?}), trait-ref={:?}\", def_id, trait_ref);\n-\n-    let is_marker_like = tcx.impl_polarity(def_id) == ty::ImplPolarity::Positive\n-        && tcx.associated_item_def_ids(trait_ref.def_id).is_empty();\n-\n-    // Check whether these impls would be ok for a marker trait.\n-    if !is_marker_like {\n-        debug!(\"issue33140_self_ty - not marker-like!\");\n-        return None;\n-    }\n-\n-    // impl must be `impl Trait for dyn Marker1 + Marker2 + ...`\n-    if trait_ref.substs.len() != 1 {\n-        debug!(\"issue33140_self_ty - impl has substs!\");\n-        return None;\n-    }\n-\n-    let predicates = tcx.predicates_of(def_id);\n-    if predicates.parent.is_some() || !predicates.predicates.is_empty() {\n-        debug!(\"issue33140_self_ty - impl has predicates {:?}!\", predicates);\n-        return None;\n-    }\n-\n-    let self_ty = trait_ref.self_ty();\n-    let self_ty_matches = match self_ty.kind {\n-        ty::Dynamic(ref data, ty::ReStatic) => data.principal().is_none(),\n-        _ => false,\n-    };\n-\n-    if self_ty_matches {\n-        debug!(\"issue33140_self_ty - MATCHES!\");\n-        Some(self_ty)\n-    } else {\n-        debug!(\"issue33140_self_ty - non-matching self type\");\n-        None\n-    }\n-}\n-\n-/// Check if a function is async.\n-fn asyncness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::IsAsync {\n-    let hir_id = tcx\n-        .hir()\n-        .as_local_hir_id(def_id)\n-        .unwrap_or_else(|| bug!(\"asyncness: expected local `DefId`, got `{:?}`\", def_id));\n-\n-    let node = tcx.hir().get(hir_id);\n-\n-    let fn_like = hir_map::blocks::FnLikeNode::from_node(node).unwrap_or_else(|| {\n-        bug!(\"asyncness: expected fn-like node but got `{:?}`\", def_id);\n-    });\n-\n-    fn_like.asyncness()\n-}\n-\n pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     context::provide(providers);\n     erase_regions::provide(providers);\n     layout::provide(providers);\n-    *providers = ty::query::Providers {\n-        asyncness,\n-        associated_item,\n-        associated_item_def_ids,\n-        adt_sized_constraint,\n-        def_span,\n-        param_env,\n-        trait_of_item,\n-        crate_disambiguator,\n-        original_crate_name,\n-        crate_hash,\n-        trait_impls_of: trait_def::trait_impls_of_provider,\n-        instance_def_size_estimate,\n-        issue33140_self_ty,\n-        ..*providers\n-    };\n+    *providers =\n+        ty::query::Providers { trait_impls_of: trait_def::trait_impls_of_provider, ..*providers };\n }\n \n /// A map for the local crate mapping each type to a vector of its"}, {"sha": "1fe5248dbf4ceac9b33712b6cbacc2af81081689", "filename": "src/librustc_interface/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b83862d09fe3cb04de50c335428b2ac5b2307ce/src%2Flibrustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6b83862d09fe3cb04de50c335428b2ac5b2307ce/src%2Flibrustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2FCargo.toml?ref=6b83862d09fe3cb04de50c335428b2ac5b2307ce", "patch": "@@ -40,6 +40,7 @@ rustc_errors = { path = \"../librustc_errors\" }\n rustc_plugin_impl = { path = \"../librustc_plugin_impl\" }\n rustc_privacy = { path = \"../librustc_privacy\" }\n rustc_resolve = { path = \"../librustc_resolve\" }\n+rustc_ty = { path = \"../librustc_ty\" }\n tempfile = \"3.0.5\"\n once_cell = \"1\"\n "}, {"sha": "c4444fbaa2fc761390e2b1b99be5d6cf84fa33ec", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b83862d09fe3cb04de50c335428b2ac5b2307ce/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b83862d09fe3cb04de50c335428b2ac5b2307ce/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=6b83862d09fe3cb04de50c335428b2ac5b2307ce", "patch": "@@ -680,6 +680,7 @@ pub fn default_provide(providers: &mut ty::query::Providers<'_>) {\n     rustc_passes::provide(providers);\n     rustc_resolve::provide(providers);\n     rustc_traits::provide(providers);\n+    rustc_ty::provide(providers);\n     rustc_metadata::provide(providers);\n     rustc_lint::provide(providers);\n     rustc_codegen_utils::provide(providers);"}, {"sha": "fb0d93fe5ebb6a8ee899bbd941e8b5a47c71a5b2", "filename": "src/librustc_ty/Cargo.toml", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6b83862d09fe3cb04de50c335428b2ac5b2307ce/src%2Flibrustc_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6b83862d09fe3cb04de50c335428b2ac5b2307ce/src%2Flibrustc_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2FCargo.toml?ref=6b83862d09fe3cb04de50c335428b2ac5b2307ce", "patch": "@@ -0,0 +1,16 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_ty\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+\n+[lib]\n+name = \"rustc_ty\"\n+path = \"lib.rs\"\n+\n+[dependencies]\n+log = \"0.4\"\n+rustc = { path = \"../librustc\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_hir = { path = \"../librustc_hir\" }\n+rustc_span = { path = \"../librustc_span\" }"}, {"sha": "2548d2cff976611b1b056f8f4806932ae8e078ba", "filename": "src/librustc_ty/lib.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6b83862d09fe3cb04de50c335428b2ac5b2307ce/src%2Flibrustc_ty%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b83862d09fe3cb04de50c335428b2ac5b2307ce/src%2Flibrustc_ty%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Flib.rs?ref=6b83862d09fe3cb04de50c335428b2ac5b2307ce", "patch": "@@ -0,0 +1,25 @@\n+//! Various checks\n+//!\n+//! # Note\n+//!\n+//! This API is completely unstable and subject to change.\n+\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![feature(bool_to_option)]\n+#![feature(in_band_lifetimes)]\n+#![feature(nll)]\n+#![feature(slice_patterns)]\n+#![recursion_limit = \"256\"]\n+\n+#[macro_use]\n+extern crate rustc;\n+#[macro_use]\n+extern crate log;\n+\n+use rustc::ty::query::Providers;\n+\n+mod ty;\n+\n+pub fn provide(providers: &mut Providers<'_>) {\n+    ty::provide(providers);\n+}"}, {"sha": "fc8beb67e4adade93ad0985adf7944647ef476f0", "filename": "src/librustc_ty/ty.rs", "status": "added", "additions": 369, "deletions": 0, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/6b83862d09fe3cb04de50c335428b2ac5b2307ce/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b83862d09fe3cb04de50c335428b2ac5b2307ce/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=6b83862d09fe3cb04de50c335428b2ac5b2307ce", "patch": "@@ -0,0 +1,369 @@\n+use rustc::hir::map as hir_map;\n+use rustc::session::CrateDisambiguator;\n+use rustc::traits::{self};\n+use rustc::ty::subst::Subst;\n+use rustc::ty::{self, ToPredicate, Ty, TyCtxt};\n+use rustc_data_structures::svh::Svh;\n+use rustc_hir as hir;\n+use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc_span::symbol::Symbol;\n+use rustc_span::Span;\n+\n+fn sized_constraint_for_ty(tcx: TyCtxt<'tcx>, adtdef: &ty::AdtDef, ty: Ty<'tcx>) -> Vec<Ty<'tcx>> {\n+    use ty::TyKind::*;\n+\n+    let result = match ty.kind {\n+        Bool | Char | Int(..) | Uint(..) | Float(..) | RawPtr(..) | Ref(..) | FnDef(..)\n+        | FnPtr(_) | Array(..) | Closure(..) | Generator(..) | Never => vec![],\n+\n+        Str | Dynamic(..) | Slice(_) | Foreign(..) | Error | GeneratorWitness(..) => {\n+            // these are never sized - return the target type\n+            vec![ty]\n+        }\n+\n+        Tuple(ref tys) => match tys.last() {\n+            None => vec![],\n+            Some(ty) => sized_constraint_for_ty(tcx, adtdef, ty.expect_ty()),\n+        },\n+\n+        Adt(adt, substs) => {\n+            // recursive case\n+            let adt_tys = adt.sized_constraint(tcx);\n+            debug!(\"sized_constraint_for_ty({:?}) intermediate = {:?}\", ty, adt_tys);\n+            adt_tys\n+                .iter()\n+                .map(|ty| ty.subst(tcx, substs))\n+                .flat_map(|ty| sized_constraint_for_ty(tcx, adtdef, ty))\n+                .collect()\n+        }\n+\n+        Projection(..) | Opaque(..) => {\n+            // must calculate explicitly.\n+            // FIXME: consider special-casing always-Sized projections\n+            vec![ty]\n+        }\n+\n+        UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n+\n+        Param(..) => {\n+            // perf hack: if there is a `T: Sized` bound, then\n+            // we know that `T` is Sized and do not need to check\n+            // it on the impl.\n+\n+            let sized_trait = match tcx.lang_items().sized_trait() {\n+                Some(x) => x,\n+                _ => return vec![ty],\n+            };\n+            let sized_predicate = ty::Binder::dummy(ty::TraitRef {\n+                def_id: sized_trait,\n+                substs: tcx.mk_substs_trait(ty, &[]),\n+            })\n+            .to_predicate();\n+            let predicates = tcx.predicates_of(adtdef.did).predicates;\n+            if predicates.iter().any(|(p, _)| *p == sized_predicate) { vec![] } else { vec![ty] }\n+        }\n+\n+        Placeholder(..) | Bound(..) | Infer(..) => {\n+            bug!(\"unexpected type `{:?}` in sized_constraint_for_ty\", ty)\n+        }\n+    };\n+    debug!(\"sized_constraint_for_ty({:?}) = {:?}\", ty, result);\n+    result\n+}\n+\n+fn associated_item_from_trait_item_ref(\n+    tcx: TyCtxt<'_>,\n+    parent_def_id: DefId,\n+    parent_vis: &hir::Visibility<'_>,\n+    trait_item_ref: &hir::TraitItemRef,\n+) -> ty::AssocItem {\n+    let def_id = tcx.hir().local_def_id(trait_item_ref.id.hir_id);\n+    let (kind, has_self) = match trait_item_ref.kind {\n+        hir::AssocItemKind::Const => (ty::AssocKind::Const, false),\n+        hir::AssocItemKind::Method { has_self } => (ty::AssocKind::Method, has_self),\n+        hir::AssocItemKind::Type => (ty::AssocKind::Type, false),\n+        hir::AssocItemKind::OpaqueTy => bug!(\"only impls can have opaque types\"),\n+    };\n+\n+    ty::AssocItem {\n+        ident: trait_item_ref.ident,\n+        kind,\n+        // Visibility of trait items is inherited from their traits.\n+        vis: ty::Visibility::from_hir(parent_vis, trait_item_ref.id.hir_id, tcx),\n+        defaultness: trait_item_ref.defaultness,\n+        def_id,\n+        container: ty::TraitContainer(parent_def_id),\n+        method_has_self_argument: has_self,\n+    }\n+}\n+\n+fn associated_item_from_impl_item_ref(\n+    tcx: TyCtxt<'_>,\n+    parent_def_id: DefId,\n+    impl_item_ref: &hir::ImplItemRef<'_>,\n+) -> ty::AssocItem {\n+    let def_id = tcx.hir().local_def_id(impl_item_ref.id.hir_id);\n+    let (kind, has_self) = match impl_item_ref.kind {\n+        hir::AssocItemKind::Const => (ty::AssocKind::Const, false),\n+        hir::AssocItemKind::Method { has_self } => (ty::AssocKind::Method, has_self),\n+        hir::AssocItemKind::Type => (ty::AssocKind::Type, false),\n+        hir::AssocItemKind::OpaqueTy => (ty::AssocKind::OpaqueTy, false),\n+    };\n+\n+    ty::AssocItem {\n+        ident: impl_item_ref.ident,\n+        kind,\n+        // Visibility of trait impl items doesn't matter.\n+        vis: ty::Visibility::from_hir(&impl_item_ref.vis, impl_item_ref.id.hir_id, tcx),\n+        defaultness: impl_item_ref.defaultness,\n+        def_id,\n+        container: ty::ImplContainer(parent_def_id),\n+        method_has_self_argument: has_self,\n+    }\n+}\n+\n+fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItem {\n+    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let parent_id = tcx.hir().get_parent_item(id);\n+    let parent_def_id = tcx.hir().local_def_id(parent_id);\n+    let parent_item = tcx.hir().expect_item(parent_id);\n+    match parent_item.kind {\n+        hir::ItemKind::Impl(.., ref impl_item_refs) => {\n+            if let Some(impl_item_ref) = impl_item_refs.iter().find(|i| i.id.hir_id == id) {\n+                let assoc_item =\n+                    associated_item_from_impl_item_ref(tcx, parent_def_id, impl_item_ref);\n+                debug_assert_eq!(assoc_item.def_id, def_id);\n+                return assoc_item;\n+            }\n+        }\n+\n+        hir::ItemKind::Trait(.., ref trait_item_refs) => {\n+            if let Some(trait_item_ref) = trait_item_refs.iter().find(|i| i.id.hir_id == id) {\n+                let assoc_item = associated_item_from_trait_item_ref(\n+                    tcx,\n+                    parent_def_id,\n+                    &parent_item.vis,\n+                    trait_item_ref,\n+                );\n+                debug_assert_eq!(assoc_item.def_id, def_id);\n+                return assoc_item;\n+            }\n+        }\n+\n+        _ => {}\n+    }\n+\n+    span_bug!(\n+        parent_item.span,\n+        \"unexpected parent of trait or impl item or item not found: {:?}\",\n+        parent_item.kind\n+    )\n+}\n+\n+/// Calculates the `Sized` constraint.\n+///\n+/// In fact, there are only a few options for the types in the constraint:\n+///     - an obviously-unsized type\n+///     - a type parameter or projection whose Sizedness can't be known\n+///     - a tuple of type parameters or projections, if there are multiple\n+///       such.\n+///     - a Error, if a type contained itself. The representability\n+///       check should catch this case.\n+fn adt_sized_constraint(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AdtSizedConstraint<'_> {\n+    let def = tcx.adt_def(def_id);\n+\n+    let result = tcx.mk_type_list(\n+        def.variants\n+            .iter()\n+            .flat_map(|v| v.fields.last())\n+            .flat_map(|f| sized_constraint_for_ty(tcx, def, tcx.type_of(f.did))),\n+    );\n+\n+    debug!(\"adt_sized_constraint: {:?} => {:?}\", def, result);\n+\n+    ty::AdtSizedConstraint(result)\n+}\n+\n+fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n+    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let item = tcx.hir().expect_item(id);\n+    match item.kind {\n+        hir::ItemKind::Trait(.., ref trait_item_refs) => tcx.arena.alloc_from_iter(\n+            trait_item_refs\n+                .iter()\n+                .map(|trait_item_ref| trait_item_ref.id)\n+                .map(|id| tcx.hir().local_def_id(id.hir_id)),\n+        ),\n+        hir::ItemKind::Impl(.., ref impl_item_refs) => tcx.arena.alloc_from_iter(\n+            impl_item_refs\n+                .iter()\n+                .map(|impl_item_ref| impl_item_ref.id)\n+                .map(|id| tcx.hir().local_def_id(id.hir_id)),\n+        ),\n+        hir::ItemKind::TraitAlias(..) => &[],\n+        _ => span_bug!(item.span, \"associated_item_def_ids: not impl or trait\"),\n+    }\n+}\n+\n+fn def_span(tcx: TyCtxt<'_>, def_id: DefId) -> Span {\n+    tcx.hir().span_if_local(def_id).unwrap()\n+}\n+\n+/// If the given `DefId` describes an item belonging to a trait,\n+/// returns the `DefId` of the trait that the trait item belongs to;\n+/// otherwise, returns `None`.\n+fn trait_of_item(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n+    tcx.opt_associated_item(def_id).and_then(|associated_item| match associated_item.container {\n+        ty::TraitContainer(def_id) => Some(def_id),\n+        ty::ImplContainer(_) => None,\n+    })\n+}\n+\n+/// See `ParamEnv` struct definition for details.\n+fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n+    // The param_env of an impl Trait type is its defining function's param_env\n+    if let Some(parent) = ty::is_impl_trait_defn(tcx, def_id) {\n+        return param_env(tcx, parent);\n+    }\n+    // Compute the bounds on Self and the type parameters.\n+\n+    let ty::InstantiatedPredicates { predicates } =\n+        tcx.predicates_of(def_id).instantiate_identity(tcx);\n+\n+    // Finally, we have to normalize the bounds in the environment, in\n+    // case they contain any associated type projections. This process\n+    // can yield errors if the put in illegal associated types, like\n+    // `<i32 as Foo>::Bar` where `i32` does not implement `Foo`. We\n+    // report these errors right here; this doesn't actually feel\n+    // right to me, because constructing the environment feels like a\n+    // kind of a \"idempotent\" action, but I'm not sure where would be\n+    // a better place. In practice, we construct environments for\n+    // every fn once during type checking, and we'll abort if there\n+    // are any errors at that point, so after type checking you can be\n+    // sure that this will succeed without errors anyway.\n+\n+    let unnormalized_env = ty::ParamEnv::new(\n+        tcx.intern_predicates(&predicates),\n+        traits::Reveal::UserFacing,\n+        tcx.sess.opts.debugging_opts.chalk.then_some(def_id),\n+    );\n+\n+    let body_id = tcx.hir().as_local_hir_id(def_id).map_or(hir::DUMMY_HIR_ID, |id| {\n+        tcx.hir().maybe_body_owned_by(id).map_or(id, |body| body.hir_id)\n+    });\n+    let cause = traits::ObligationCause::misc(tcx.def_span(def_id), body_id);\n+    traits::normalize_param_env_or_error(tcx, def_id, unnormalized_env, cause)\n+}\n+\n+fn crate_disambiguator(tcx: TyCtxt<'_>, crate_num: CrateNum) -> CrateDisambiguator {\n+    assert_eq!(crate_num, LOCAL_CRATE);\n+    tcx.sess.local_crate_disambiguator()\n+}\n+\n+fn original_crate_name(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Symbol {\n+    assert_eq!(crate_num, LOCAL_CRATE);\n+    tcx.crate_name.clone()\n+}\n+\n+fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n+    assert_eq!(crate_num, LOCAL_CRATE);\n+    tcx.hir().crate_hash\n+}\n+\n+fn instance_def_size_estimate<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    instance_def: ty::InstanceDef<'tcx>,\n+) -> usize {\n+    use ty::InstanceDef;\n+\n+    match instance_def {\n+        InstanceDef::Item(..) | InstanceDef::DropGlue(..) => {\n+            let mir = tcx.instance_mir(instance_def);\n+            mir.basic_blocks().iter().map(|bb| bb.statements.len()).sum()\n+        }\n+        // Estimate the size of other compiler-generated shims to be 1.\n+        _ => 1,\n+    }\n+}\n+\n+/// If `def_id` is an issue 33140 hack impl, returns its self type; otherwise, returns `None`.\n+///\n+/// See [`ImplOverlapKind::Issue33140`] for more details.\n+fn issue33140_self_ty(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Ty<'_>> {\n+    debug!(\"issue33140_self_ty({:?})\", def_id);\n+\n+    let trait_ref = tcx\n+        .impl_trait_ref(def_id)\n+        .unwrap_or_else(|| bug!(\"issue33140_self_ty called on inherent impl {:?}\", def_id));\n+\n+    debug!(\"issue33140_self_ty({:?}), trait-ref={:?}\", def_id, trait_ref);\n+\n+    let is_marker_like = tcx.impl_polarity(def_id) == ty::ImplPolarity::Positive\n+        && tcx.associated_item_def_ids(trait_ref.def_id).is_empty();\n+\n+    // Check whether these impls would be ok for a marker trait.\n+    if !is_marker_like {\n+        debug!(\"issue33140_self_ty - not marker-like!\");\n+        return None;\n+    }\n+\n+    // impl must be `impl Trait for dyn Marker1 + Marker2 + ...`\n+    if trait_ref.substs.len() != 1 {\n+        debug!(\"issue33140_self_ty - impl has substs!\");\n+        return None;\n+    }\n+\n+    let predicates = tcx.predicates_of(def_id);\n+    if predicates.parent.is_some() || !predicates.predicates.is_empty() {\n+        debug!(\"issue33140_self_ty - impl has predicates {:?}!\", predicates);\n+        return None;\n+    }\n+\n+    let self_ty = trait_ref.self_ty();\n+    let self_ty_matches = match self_ty.kind {\n+        ty::Dynamic(ref data, ty::ReStatic) => data.principal().is_none(),\n+        _ => false,\n+    };\n+\n+    if self_ty_matches {\n+        debug!(\"issue33140_self_ty - MATCHES!\");\n+        Some(self_ty)\n+    } else {\n+        debug!(\"issue33140_self_ty - non-matching self type\");\n+        None\n+    }\n+}\n+\n+/// Check if a function is async.\n+fn asyncness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::IsAsync {\n+    let hir_id = tcx\n+        .hir()\n+        .as_local_hir_id(def_id)\n+        .unwrap_or_else(|| bug!(\"asyncness: expected local `DefId`, got `{:?}`\", def_id));\n+\n+    let node = tcx.hir().get(hir_id);\n+\n+    let fn_like = hir_map::blocks::FnLikeNode::from_node(node).unwrap_or_else(|| {\n+        bug!(\"asyncness: expected fn-like node but got `{:?}`\", def_id);\n+    });\n+\n+    fn_like.asyncness()\n+}\n+\n+pub fn provide(providers: &mut ty::query::Providers<'_>) {\n+    *providers = ty::query::Providers {\n+        asyncness,\n+        associated_item,\n+        associated_item_def_ids,\n+        adt_sized_constraint,\n+        def_span,\n+        param_env,\n+        trait_of_item,\n+        crate_disambiguator,\n+        original_crate_name,\n+        crate_hash,\n+        instance_def_size_estimate,\n+        issue33140_self_ty,\n+        ..*providers\n+    };\n+}"}]}