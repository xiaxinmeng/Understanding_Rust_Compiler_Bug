{"sha": "99bc97940314176bc6ed38cea11723cc1fd9ee3b", "node_id": "C_kwDOAAsO6NoAKDk5YmM5Nzk0MDMxNDE3NmJjNmVkMzhjZWExMTcyM2NjMWZkOWVlM2I", "commit": {"author": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-06-23T13:51:44Z"}, "committer": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-06-24T08:08:25Z"}, "message": "macros: use typed identifiers in diag derive\n\nUsing typed identifiers instead of strings with the Fluent identifier\nenables the diagnostic derive to benefit from the compile-time\nvalidation that comes with typed identifiers - use of a non-existent\nFluent identifier will not compile.\n\nSigned-off-by: David Wood <david.wood@huawei.com>", "tree": {"sha": "26bc8329607a52e1ba23732424c0673844b29012", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26bc8329607a52e1ba23732424c0673844b29012"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99bc97940314176bc6ed38cea11723cc1fd9ee3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99bc97940314176bc6ed38cea11723cc1fd9ee3b", "html_url": "https://github.com/rust-lang/rust/commit/99bc97940314176bc6ed38cea11723cc1fd9ee3b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99bc97940314176bc6ed38cea11723cc1fd9ee3b/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc96600bf6a52f92aeeee60a92a161a82b61c0ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc96600bf6a52f92aeeee60a92a161a82b61c0ef", "html_url": "https://github.com/rust-lang/rust/commit/fc96600bf6a52f92aeeee60a92a161a82b61c0ef"}], "stats": {"total": 1128, "additions": 673, "deletions": 455}, "files": [{"sha": "aa355150b4f816f1913f7277a625f51f084ae255", "filename": "compiler/rustc_builtin_macros/src/cfg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99bc97940314176bc6ed38cea11723cc1fd9ee3b/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99bc97940314176bc6ed38cea11723cc1fd9ee3b/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs?ref=99bc97940314176bc6ed38cea11723cc1fd9ee3b", "patch": "@@ -36,15 +36,15 @@ pub fn expand_cfg(\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(slug = \"builtin-macros-requires-cfg-pattern\")]\n+#[error(builtin_macros::requires_cfg_pattern)]\n struct RequiresCfgPattern {\n     #[primary_span]\n     #[label]\n     span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(slug = \"builtin-macros-expected-one-cfg-pattern\")]\n+#[error(builtin_macros::expected_one_cfg_pattern)]\n struct OneCfgPattern {\n     #[primary_span]\n     span: Span,"}, {"sha": "4a42d52f71004c851b27f04b98b0dc5ce83db328", "filename": "compiler/rustc_error_messages/locales/en-US/builtin_macros.ftl", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99bc97940314176bc6ed38cea11723cc1fd9ee3b/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fbuiltin_macros.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/99bc97940314176bc6ed38cea11723cc1fd9ee3b/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fbuiltin_macros.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fbuiltin_macros.ftl?ref=99bc97940314176bc6ed38cea11723cc1fd9ee3b", "patch": "@@ -1,5 +1,5 @@\n-builtin-macros-requires-cfg-pattern =\n+builtin_macros-requires-cfg-pattern =\n     macro requires a cfg-pattern as an argument\n     .label = cfg-pattern required\n \n-builtin-macros-expected-one-cfg-pattern = expected 1 cfg-pattern\n+builtin_macros-expected-one-cfg-pattern = expected 1 cfg-pattern"}, {"sha": "d0c8652718969a91e88c485683c168e1f279747c", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic.rs", "status": "modified", "additions": 284, "deletions": 176, "changes": 460, "blob_url": "https://github.com/rust-lang/rust/blob/99bc97940314176bc6ed38cea11723cc1fd9ee3b/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99bc97940314176bc6ed38cea11723cc1fd9ee3b/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs?ref=99bc97940314176bc6ed38cea11723cc1fd9ee3b", "patch": "@@ -12,7 +12,9 @@ use proc_macro2::{Ident, TokenStream};\n use quote::{format_ident, quote};\n use std::collections::HashMap;\n use std::str::FromStr;\n-use syn::{spanned::Spanned, Attribute, Meta, MetaList, MetaNameValue, Type};\n+use syn::{\n+    parse_quote, spanned::Spanned, Attribute, Meta, MetaList, MetaNameValue, NestedMeta, Path, Type,\n+};\n use synstructure::{BindingInfo, Structure};\n \n /// The central struct for constructing the `into_diagnostic` method from an annotated struct.\n@@ -118,23 +120,23 @@ impl<'a> SessionDiagnosticDerive<'a> {\n                         return SessionDiagnosticDeriveError::ErrorHandled.to_compile_error();\n                     }\n                     (Some((kind, _)), None) => {\n-                        span_err(span, \"`slug` not specified\")\n-                            .help(&format!(\"use the `#[{}(slug = \\\"...\\\")]` attribute to set this diagnostic's slug\", kind.descr()))\n+                        span_err(span, \"diagnostic slug not specified\")\n+                            .help(&format!(\n+                                \"specify the slug as the first argument to the attribute, such as \\\n+                                 `#[{}(typeck::example_error)]`\",\n+                                kind.descr()\n+                            ))\n                             .emit();\n                         return SessionDiagnosticDeriveError::ErrorHandled.to_compile_error();\n                     }\n                     (Some((SessionDiagnosticKind::Error, _)), Some((slug, _))) => {\n                         quote! {\n-                            let mut #diag = #sess.struct_err(\n-                                rustc_errors::DiagnosticMessage::new(#slug),\n-                            );\n+                            let mut #diag = #sess.struct_err(rustc_errors::fluent::#slug);\n                         }\n                     }\n                     (Some((SessionDiagnosticKind::Warn, _)), Some((slug, _))) => {\n                         quote! {\n-                            let mut #diag = #sess.struct_warn(\n-                                rustc_errors::DiagnosticMessage::new(#slug),\n-                            );\n+                            let mut #diag = #sess.struct_warn(rustc_errors::fluent::#slug);\n                         }\n                     }\n                 };\n@@ -226,7 +228,7 @@ struct SessionDiagnosticDeriveBuilder {\n     kind: Option<(SessionDiagnosticKind, proc_macro::Span)>,\n     /// Slug is a mandatory part of the struct attribute as corresponds to the Fluent message that\n     /// has the actual diagnostic message.\n-    slug: Option<(String, proc_macro::Span)>,\n+    slug: Option<(Path, proc_macro::Span)>,\n     /// Error codes are a optional part of the struct attribute - this is only set to detect\n     /// multiple specifications.\n     code: Option<(String, proc_macro::Span)>,\n@@ -240,79 +242,104 @@ impl HasFieldMap for SessionDiagnosticDeriveBuilder {\n \n impl SessionDiagnosticDeriveBuilder {\n     /// Establishes state in the `SessionDiagnosticDeriveBuilder` resulting from the struct\n-    /// attributes like `#[error(..)#`, such as the diagnostic kind and slug. Generates\n+    /// attributes like `#[error(..)`, such as the diagnostic kind and slug. Generates\n     /// diagnostic builder calls for setting error code and creating note/help messages.\n     fn generate_structure_code(\n         &mut self,\n         attr: &Attribute,\n     ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n+        let diag = &self.diag;\n         let span = attr.span().unwrap();\n \n         let name = attr.path.segments.last().unwrap().ident.to_string();\n         let name = name.as_str();\n         let meta = attr.parse_meta()?;\n \n-        if matches!(name, \"help\" | \"note\") && matches!(meta, Meta::Path(_) | Meta::NameValue(_)) {\n-            let diag = &self.diag;\n-            let id = match meta {\n-                Meta::Path(..) => quote! { #name },\n-                Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n-                    quote! { #s }\n-                }\n-                _ => unreachable!(),\n-            };\n-            let fn_name = proc_macro2::Ident::new(name, attr.span());\n-\n-            return Ok(quote! {\n-                #diag.#fn_name(rustc_errors::SubdiagnosticMessage::attr(#id));\n-            });\n-        }\n+        let is_help_or_note = matches!(name, \"help\" | \"note\");\n \n         let nested = match meta {\n+            // Most attributes are lists, like `#[error(..)]`/`#[warning(..)]` for most cases or\n+            // `#[help(..)]`/`#[note(..)]` when the user is specifying a alternative slug.\n             Meta::List(MetaList { ref nested, .. }) => nested,\n+            // Subdiagnostics without spans can be applied to the type too, and these are just\n+            // paths: `#[help]` and `#[note]`\n+            Meta::Path(_) if is_help_or_note => {\n+                let fn_name = proc_macro2::Ident::new(name, attr.span());\n+                return Ok(quote! { #diag.#fn_name(rustc_errors::fluent::_subdiag::#fn_name); });\n+            }\n             _ => throw_invalid_attr!(attr, &meta),\n         };\n \n-        let kind = match name {\n-            \"error\" => SessionDiagnosticKind::Error,\n-            \"warning\" => SessionDiagnosticKind::Warn,\n+        // Check the kind before doing any further processing so that there aren't misleading\n+        // \"no kind specified\" errors if there are failures later.\n+        match name {\n+            \"error\" => self.kind.set_once((SessionDiagnosticKind::Error, span)),\n+            \"warning\" => self.kind.set_once((SessionDiagnosticKind::Warn, span)),\n+            \"help\" | \"note\" => (),\n             _ => throw_invalid_attr!(attr, &meta, |diag| {\n-                diag.help(\"only `error` and `warning` are valid attributes\")\n+                diag.help(\"only `error`, `warning`, `help` and `note` are valid attributes\")\n             }),\n-        };\n-        self.kind.set_once((kind, span));\n+        }\n+\n+        // First nested element should always be the path, e.g. `#[error(typeck::invalid)]` or\n+        // `#[help(typeck::another_help)]`.\n+        let mut nested_iter = nested.into_iter();\n+        if let Some(nested_attr) = nested_iter.next() {\n+            // Report an error if there are any other list items after the path.\n+            if is_help_or_note && nested_iter.next().is_some() {\n+                throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n+                    diag.help(\"`help` and `note` struct attributes can only have one argument\")\n+                });\n+            }\n \n+            match nested_attr {\n+                NestedMeta::Meta(Meta::Path(path)) if is_help_or_note => {\n+                    let fn_name = proc_macro2::Ident::new(name, attr.span());\n+                    return Ok(quote! { #diag.#fn_name(rustc_errors::fluent::#path); });\n+                }\n+                NestedMeta::Meta(Meta::Path(path)) => {\n+                    self.slug.set_once((path.clone(), span));\n+                }\n+                NestedMeta::Meta(meta @ Meta::NameValue(_))\n+                    if !is_help_or_note\n+                        && meta.path().segments.last().unwrap().ident.to_string() == \"code\" =>\n+                {\n+                    // don't error for valid follow-up attributes\n+                }\n+                nested_attr => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n+                    diag.help(\"first argument of the attribute should be the diagnostic slug\")\n+                }),\n+            };\n+        }\n+\n+        // Remaining attributes are optional, only `code = \"..\"` at the moment.\n         let mut tokens = Vec::new();\n-        for nested_attr in nested {\n+        for nested_attr in nested_iter {\n             let meta = match nested_attr {\n                 syn::NestedMeta::Meta(meta) => meta,\n                 _ => throw_invalid_nested_attr!(attr, &nested_attr),\n             };\n \n             let path = meta.path();\n             let nested_name = path.segments.last().unwrap().ident.to_string();\n-            match &meta {\n-                // Struct attributes are only allowed to be applied once, and the diagnostic\n-                // changes will be set in the initialisation code.\n-                Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n-                    let span = s.span().unwrap();\n-                    match nested_name.as_str() {\n-                        \"slug\" => {\n-                            self.slug.set_once((s.value(), span));\n-                        }\n-                        \"code\" => {\n-                            self.code.set_once((s.value(), span));\n-                            let (diag, code) = (&self.diag, &self.code.as_ref().map(|(v, _)| v));\n-                            tokens.push(quote! {\n-                                #diag.code(rustc_errors::DiagnosticId::Error(#code.to_string()));\n-                            });\n-                        }\n-                        _ => invalid_nested_attr(attr, &nested_attr)\n-                            .help(\"only `slug` and `code` are valid nested attributes\")\n-                            .emit(),\n+            // Struct attributes are only allowed to be applied once, and the diagnostic\n+            // changes will be set in the initialisation code.\n+            if let Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) = &meta {\n+                let span = s.span().unwrap();\n+                match nested_name.as_str() {\n+                    \"code\" => {\n+                        self.code.set_once((s.value(), span));\n+                        let code = &self.code.as_ref().map(|(v, _)| v);\n+                        tokens.push(quote! {\n+                            #diag.code(rustc_errors::DiagnosticId::Error(#code.to_string()));\n+                        });\n                     }\n+                    _ => invalid_nested_attr(attr, &nested_attr)\n+                        .help(\"only `code` is a valid nested attributes following the slug\")\n+                        .emit(),\n                 }\n-                _ => invalid_nested_attr(attr, &nested_attr).emit(),\n+            } else {\n+                invalid_nested_attr(attr, &nested_attr).emit()\n             }\n         }\n \n@@ -382,142 +409,215 @@ impl SessionDiagnosticDeriveBuilder {\n         info: FieldInfo<'_>,\n         binding: TokenStream,\n     ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n+        let meta = attr.parse_meta()?;\n+        match meta {\n+            Meta::Path(_) => self.generate_inner_field_code_path(attr, info, binding),\n+            Meta::List(MetaList { .. }) => self.generate_inner_field_code_list(attr, info, binding),\n+            _ => throw_invalid_attr!(attr, &meta),\n+        }\n+    }\n+\n+    fn generate_inner_field_code_path(\n+        &mut self,\n+        attr: &Attribute,\n+        info: FieldInfo<'_>,\n+        binding: TokenStream,\n+    ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n+        assert!(matches!(attr.parse_meta()?, Meta::Path(_)));\n         let diag = &self.diag;\n \n+        let meta = attr.parse_meta()?;\n+\n         let ident = &attr.path.segments.last().unwrap().ident;\n         let name = ident.to_string();\n         let name = name.as_str();\n+        match name {\n+            \"skip_arg\" => {\n+                // Don't need to do anything - by virtue of the attribute existing, the\n+                // `set_arg` call will not be generated.\n+                Ok(quote! {})\n+            }\n+            \"primary_span\" => {\n+                report_error_if_not_applied_to_span(attr, &info)?;\n+                Ok(quote! {\n+                    #diag.set_span(#binding);\n+                })\n+            }\n+            \"label\" => {\n+                report_error_if_not_applied_to_span(attr, &info)?;\n+                Ok(self.add_spanned_subdiagnostic(binding, ident, parse_quote! { _subdiag::label }))\n+            }\n+            \"note\" | \"help\" => {\n+                let path = match name {\n+                    \"note\" => parse_quote! { _subdiag::note },\n+                    \"help\" => parse_quote! { _subdiag::help },\n+                    _ => unreachable!(),\n+                };\n+                if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) {\n+                    Ok(self.add_spanned_subdiagnostic(binding, ident, path))\n+                } else if type_is_unit(&info.ty) {\n+                    Ok(self.add_subdiagnostic(ident, path))\n+                } else {\n+                    report_type_error(attr, \"`Span` or `()`\")?;\n+                }\n+            }\n+            \"subdiagnostic\" => Ok(quote! { #diag.subdiagnostic(#binding); }),\n+            _ => throw_invalid_attr!(attr, &meta, |diag| {\n+                diag.help(\n+                    \"only `skip_arg`, `primary_span`, `label`, `note`, `help` and `subdiagnostic` \\\n+                     are valid field attributes\",\n+                )\n+            }),\n+        }\n+    }\n \n+    fn generate_inner_field_code_list(\n+        &mut self,\n+        attr: &Attribute,\n+        info: FieldInfo<'_>,\n+        binding: TokenStream,\n+    ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n         let meta = attr.parse_meta()?;\n-        match meta {\n-            Meta::Path(_) => match name {\n-                \"skip_arg\" => {\n-                    // Don't need to do anything - by virtue of the attribute existing, the\n-                    // `set_arg` call will not be generated.\n-                    Ok(quote! {})\n-                }\n-                \"primary_span\" => {\n-                    report_error_if_not_applied_to_span(attr, &info)?;\n-                    Ok(quote! {\n-                        #diag.set_span(#binding);\n-                    })\n-                }\n-                \"label\" => {\n-                    report_error_if_not_applied_to_span(attr, &info)?;\n-                    Ok(self.add_spanned_subdiagnostic(binding, ident, name))\n-                }\n-                \"note\" | \"help\" => {\n-                    if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) {\n-                        Ok(self.add_spanned_subdiagnostic(binding, ident, name))\n-                    } else if type_is_unit(&info.ty) {\n-                        Ok(self.add_subdiagnostic(ident, name))\n-                    } else {\n-                        report_type_error(attr, \"`Span` or `()`\")?;\n-                    }\n-                }\n-                \"subdiagnostic\" => Ok(quote! { #diag.subdiagnostic(#binding); }),\n-                _ => throw_invalid_attr!(attr, &meta, |diag| {\n-                    diag\n-                        .help(\"only `skip_arg`, `primary_span`, `label`, `note`, `help` and `subdiagnostic` are valid field attributes\")\n-                }),\n-            },\n-            Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(ref s), .. }) => match name {\n-                \"label\" => {\n-                    report_error_if_not_applied_to_span(attr, &info)?;\n-                    Ok(self.add_spanned_subdiagnostic(binding, ident, &s.value()))\n-                }\n-                \"note\" | \"help\" => {\n-                    if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) {\n-                        Ok(self.add_spanned_subdiagnostic(binding, ident, &s.value()))\n-                    } else if type_is_unit(&info.ty) {\n-                        Ok(self.add_subdiagnostic(ident, &s.value()))\n-                    } else {\n-                        report_type_error(attr, \"`Span` or `()`\")?;\n-                    }\n-                }\n-                _ => throw_invalid_attr!(attr, &meta, |diag| {\n-                    diag.help(\"only `label`, `note` and `help` are valid field attributes\")\n-                }),\n-            },\n-            Meta::List(MetaList { ref path, ref nested, .. }) => {\n-                let name = path.segments.last().unwrap().ident.to_string();\n-                let name = name.as_ref();\n-\n-                match name {\n-                    \"suggestion\" | \"suggestion_short\" | \"suggestion_hidden\"\n-                    | \"suggestion_verbose\" => (),\n-                    _ => throw_invalid_attr!(attr, &meta, |diag| {\n-                        diag\n-                            .help(\"only `suggestion{,_short,_hidden,_verbose}` are valid field attributes\")\n-                    }),\n-                };\n+        let Meta::List(MetaList { ref path, ref nested, .. }) = meta  else { unreachable!() };\n \n-                let (span_field, mut applicability) = self.span_and_applicability_of_ty(info)?;\n+        let ident = &attr.path.segments.last().unwrap().ident;\n+        let name = path.segments.last().unwrap().ident.to_string();\n+        let name = name.as_ref();\n+        match name {\n+            \"suggestion\" | \"suggestion_short\" | \"suggestion_hidden\" | \"suggestion_verbose\" => {\n+                return self.generate_inner_field_code_suggestion(attr, info);\n+            }\n+            \"label\" | \"help\" | \"note\" => (),\n+            _ => throw_invalid_attr!(attr, &meta, |diag| {\n+                diag.help(\n+                    \"only `label`, `note`, `help` or `suggestion{,_short,_hidden,_verbose}` are \\\n+                     valid field attributes\",\n+                )\n+            }),\n+        }\n \n-                let mut msg = None;\n-                let mut code = None;\n+        // For `#[label(..)]`, `#[note(..)]` and `#[help(..)]`, the first nested element must be a\n+        // path, e.g. `#[label(typeck::label)]`.\n+        let mut nested_iter = nested.into_iter();\n+        let msg = match nested_iter.next() {\n+            Some(NestedMeta::Meta(Meta::Path(path))) => path.clone(),\n+            Some(nested_attr) => throw_invalid_nested_attr!(attr, &nested_attr),\n+            None => throw_invalid_attr!(attr, &meta),\n+        };\n \n-                for nested_attr in nested {\n-                    let meta = match nested_attr {\n-                        syn::NestedMeta::Meta(ref meta) => meta,\n-                        syn::NestedMeta::Lit(_) => throw_invalid_nested_attr!(attr, &nested_attr),\n-                    };\n+        // None of these attributes should have anything following the slug.\n+        if nested_iter.next().is_some() {\n+            throw_invalid_attr!(attr, &meta);\n+        }\n \n-                    let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n-                    let nested_name = nested_name.as_str();\n-                    match meta {\n-                        Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n-                            let span = meta.span().unwrap();\n-                            match nested_name {\n-                                \"message\" => {\n-                                    msg = Some(s.value());\n-                                }\n-                                \"code\" => {\n-                                    let formatted_str = self.build_format(&s.value(), s.span());\n-                                    code = Some(formatted_str);\n+        match name {\n+            \"label\" => {\n+                report_error_if_not_applied_to_span(attr, &info)?;\n+                Ok(self.add_spanned_subdiagnostic(binding, ident, msg))\n+            }\n+            \"note\" | \"help\" if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) => {\n+                Ok(self.add_spanned_subdiagnostic(binding, ident, msg))\n+            }\n+            \"note\" | \"help\" if type_is_unit(&info.ty) => Ok(self.add_subdiagnostic(ident, msg)),\n+            \"note\" | \"help\" => {\n+                report_type_error(attr, \"`Span` or `()`\")?;\n+            }\n+            _ => unreachable!(),\n+        }\n+    }\n+\n+    fn generate_inner_field_code_suggestion(\n+        &mut self,\n+        attr: &Attribute,\n+        info: FieldInfo<'_>,\n+    ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n+        let diag = &self.diag;\n+\n+        let mut meta = attr.parse_meta()?;\n+        let Meta::List(MetaList { ref path, ref mut nested, .. }) = meta  else { unreachable!() };\n+\n+        let (span_field, mut applicability) = self.span_and_applicability_of_ty(info)?;\n+\n+        let mut msg = None;\n+        let mut code = None;\n+\n+        let mut nested_iter = nested.into_iter().peekable();\n+        if let Some(nested_attr) = nested_iter.peek() {\n+            if let NestedMeta::Meta(Meta::Path(path)) = nested_attr {\n+                msg = Some(path.clone());\n+            }\n+        };\n+        // Move the iterator forward if a path was found (don't otherwise so that\n+        // code/applicability can be found or an error emitted).\n+        if msg.is_some() {\n+            let _ = nested_iter.next();\n+        }\n+\n+        for nested_attr in nested_iter {\n+            let meta = match nested_attr {\n+                syn::NestedMeta::Meta(ref meta) => meta,\n+                syn::NestedMeta::Lit(_) => throw_invalid_nested_attr!(attr, &nested_attr),\n+            };\n+\n+            let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n+            let nested_name = nested_name.as_str();\n+            match meta {\n+                Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n+                    let span = meta.span().unwrap();\n+                    match nested_name {\n+                        \"code\" => {\n+                            let formatted_str = self.build_format(&s.value(), s.span());\n+                            code = Some(formatted_str);\n+                        }\n+                        \"applicability\" => {\n+                            applicability = match applicability {\n+                                Some(v) => {\n+                                    span_err(\n+                                        span,\n+                                        \"applicability cannot be set in both the field and \\\n+                                         attribute\",\n+                                    )\n+                                    .emit();\n+                                    Some(v)\n                                 }\n-                                \"applicability\" => {\n-                                    applicability = match applicability {\n-                                        Some(v) => {\n-                                            span_err(\n-                                                span,\n-                                                \"applicability cannot be set in both the field and attribute\"\n-                                            ).emit();\n-                                            Some(v)\n-                                        }\n-                                        None => match Applicability::from_str(&s.value()) {\n-                                            Ok(v) => Some(quote! { #v }),\n-                                            Err(()) => {\n-                                                span_err(span, \"invalid applicability\").emit();\n-                                                None\n-                                            }\n-                                        },\n+                                None => match Applicability::from_str(&s.value()) {\n+                                    Ok(v) => Some(quote! { #v }),\n+                                    Err(()) => {\n+                                        span_err(span, \"invalid applicability\").emit();\n+                                        None\n                                     }\n-                                }\n-                                _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n-                                    diag.help(\n-                                        \"only `message`, `code` and `applicability` are valid field attributes\",\n-                                    )\n-                                }),\n+                                },\n                             }\n                         }\n-                        _ => throw_invalid_nested_attr!(attr, &nested_attr),\n+                        _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n+                            diag.help(\n+                                \"only `message`, `code` and `applicability` are valid field \\\n+                                 attributes\",\n+                            )\n+                        }),\n                     }\n                 }\n+                _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n+                    if matches!(meta, Meta::Path(_)) {\n+                        diag.help(\"a diagnostic slug must be the first argument to the attribute\")\n+                    } else {\n+                        diag\n+                    }\n+                }),\n+            }\n+        }\n \n-                let applicability = applicability\n-                    .unwrap_or_else(|| quote!(rustc_errors::Applicability::Unspecified));\n+        let applicability =\n+            applicability.unwrap_or_else(|| quote!(rustc_errors::Applicability::Unspecified));\n \n-                let method = format_ident!(\"span_{}\", name);\n+        let name = path.segments.last().unwrap().ident.to_string();\n+        let method = format_ident!(\"span_{}\", name);\n \n-                let msg = msg.as_deref().unwrap_or(\"suggestion\");\n-                let msg = quote! { rustc_errors::SubdiagnosticMessage::attr(#msg) };\n-                let code = code.unwrap_or_else(|| quote! { String::new() });\n+        let msg = msg.unwrap_or_else(|| parse_quote! { _subdiag::suggestion });\n+        let msg = quote! { rustc_errors::fluent::#msg };\n+        let code = code.unwrap_or_else(|| quote! { String::new() });\n \n-                Ok(quote! { #diag.#method(#span_field, #msg, #code, #applicability); })\n-            }\n-            _ => throw_invalid_attr!(attr, &meta),\n-        }\n+        Ok(quote! { #diag.#method(#span_field, #msg, #code, #applicability); })\n     }\n \n     /// Adds a spanned subdiagnostic by generating a `diag.span_$kind` call with the current slug\n@@ -526,24 +626,24 @@ impl SessionDiagnosticDeriveBuilder {\n         &self,\n         field_binding: TokenStream,\n         kind: &Ident,\n-        fluent_attr_identifier: &str,\n+        fluent_attr_identifier: Path,\n     ) -> TokenStream {\n         let diag = &self.diag;\n         let fn_name = format_ident!(\"span_{}\", kind);\n         quote! {\n             #diag.#fn_name(\n                 #field_binding,\n-                rustc_errors::SubdiagnosticMessage::attr(#fluent_attr_identifier)\n+                rustc_errors::fluent::#fluent_attr_identifier\n             );\n         }\n     }\n \n     /// Adds a subdiagnostic by generating a `diag.span_$kind` call with the current slug\n     /// and `fluent_attr_identifier`.\n-    fn add_subdiagnostic(&self, kind: &Ident, fluent_attr_identifier: &str) -> TokenStream {\n+    fn add_subdiagnostic(&self, kind: &Ident, fluent_attr_identifier: Path) -> TokenStream {\n         let diag = &self.diag;\n         quote! {\n-            #diag.#kind(rustc_errors::SubdiagnosticMessage::attr(#fluent_attr_identifier));\n+            #diag.#kind(rustc_errors::fluent::#fluent_attr_identifier);\n         }\n     }\n \n@@ -569,7 +669,8 @@ impl SessionDiagnosticDeriveBuilder {\n                         } else {\n                             throw_span_err!(\n                                 info.span.unwrap(),\n-                                \"type of field annotated with `#[suggestion(...)]` contains more than one `Span`\"\n+                                \"type of field annotated with `#[suggestion(...)]` contains more \\\n+                                 than one `Span`\"\n                             );\n                         }\n                     } else if type_matches_path(elem, &[\"rustc_errors\", \"Applicability\"]) {\n@@ -578,7 +679,8 @@ impl SessionDiagnosticDeriveBuilder {\n                         } else {\n                             throw_span_err!(\n                                 info.span.unwrap(),\n-                                \"type of field annotated with `#[suggestion(...)]` contains more than one Applicability\"\n+                                \"type of field annotated with `#[suggestion(...)]` contains more \\\n+                                 than one Applicability\"\n                             );\n                         }\n                     }\n@@ -595,12 +697,18 @@ impl SessionDiagnosticDeriveBuilder {\n                 }\n \n                 throw_span_err!(info.span.unwrap(), \"wrong types for suggestion\", |diag| {\n-                    diag.help(\"`#[suggestion(...)]` on a tuple field must be applied to fields of type `(Span, Applicability)`\")\n+                    diag.help(\n+                        \"`#[suggestion(...)]` on a tuple field must be applied to fields of type \\\n+                         `(Span, Applicability)`\",\n+                    )\n                 });\n             }\n             // If `ty` isn't a `Span` or `(Span, Applicability)` then emit an error.\n             _ => throw_span_err!(info.span.unwrap(), \"wrong field type for suggestion\", |diag| {\n-                diag.help(\"`#[suggestion(...)]` should be applied to fields of type `Span` or `(Span, Applicability)`\")\n+                diag.help(\n+                    \"`#[suggestion(...)]` should be applied to fields of type `Span` or \\\n+                     `(Span, Applicability)`\",\n+                )\n             }),\n         }\n     }"}, {"sha": "d088402abc6da21db0ac3bc62f6c078802d73d91", "filename": "compiler/rustc_macros/src/diagnostics/error.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/99bc97940314176bc6ed38cea11723cc1fd9ee3b/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99bc97940314176bc6ed38cea11723cc1fd9ee3b/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ferror.rs?ref=99bc97940314176bc6ed38cea11723cc1fd9ee3b", "patch": "@@ -39,6 +39,19 @@ pub(crate) fn _throw_err(\n     SessionDiagnosticDeriveError::ErrorHandled\n }\n \n+/// Helper function for printing `syn::Path` - doesn't handle arguments in paths and these are\n+/// unlikely to come up much in use of the macro.\n+fn path_to_string(path: &syn::Path) -> String {\n+    let mut out = String::new();\n+    for (i, segment) in path.segments.iter().enumerate() {\n+        if i > 0 || path.leading_colon.is_some() {\n+            out.push_str(\"::\");\n+        }\n+        out.push_str(&segment.ident.to_string());\n+    }\n+    out\n+}\n+\n /// Returns an error diagnostic on span `span` with msg `msg`.\n pub(crate) fn span_err(span: impl MultiSpan, msg: &str) -> Diagnostic {\n     Diagnostic::spanned(span, Level::Error, msg)\n@@ -61,15 +74,13 @@ pub(crate) use throw_span_err;\n /// Returns an error diagnostic for an invalid attribute.\n pub(crate) fn invalid_attr(attr: &Attribute, meta: &Meta) -> Diagnostic {\n     let span = attr.span().unwrap();\n-    let name = attr.path.segments.last().unwrap().ident.to_string();\n-    let name = name.as_str();\n-\n+    let path = path_to_string(&attr.path);\n     match meta {\n-        Meta::Path(_) => span_err(span, &format!(\"`#[{}]` is not a valid attribute\", name)),\n+        Meta::Path(_) => span_err(span, &format!(\"`#[{}]` is not a valid attribute\", path)),\n         Meta::NameValue(_) => {\n-            span_err(span, &format!(\"`#[{} = ...]` is not a valid attribute\", name))\n+            span_err(span, &format!(\"`#[{} = ...]` is not a valid attribute\", path))\n         }\n-        Meta::List(_) => span_err(span, &format!(\"`#[{}(...)]` is not a valid attribute\", name)),\n+        Meta::List(_) => span_err(span, &format!(\"`#[{}(...)]` is not a valid attribute\", path)),\n     }\n }\n \n@@ -101,18 +112,16 @@ pub(crate) fn invalid_nested_attr(attr: &Attribute, nested: &NestedMeta) -> Diag\n     };\n \n     let span = meta.span().unwrap();\n-    let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n-    let nested_name = nested_name.as_str();\n+    let path = path_to_string(meta.path());\n     match meta {\n-        Meta::NameValue(..) => span_err(\n-            span,\n-            &format!(\"`#[{}({} = ...)]` is not a valid attribute\", name, nested_name),\n-        ),\n+        Meta::NameValue(..) => {\n+            span_err(span, &format!(\"`#[{}({} = ...)]` is not a valid attribute\", name, path))\n+        }\n         Meta::Path(..) => {\n-            span_err(span, &format!(\"`#[{}({})]` is not a valid attribute\", name, nested_name))\n+            span_err(span, &format!(\"`#[{}({})]` is not a valid attribute\", name, path))\n         }\n         Meta::List(..) => {\n-            span_err(span, &format!(\"`#[{}({}(...))]` is not a valid attribute\", name, nested_name))\n+            span_err(span, &format!(\"`#[{}({}(...))]` is not a valid attribute\", name, path))\n         }\n     }\n }"}, {"sha": "2317186e65502d522809b84fd629b6db50610a3f", "filename": "compiler/rustc_macros/src/diagnostics/fluent.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/99bc97940314176bc6ed38cea11723cc1fd9ee3b/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99bc97940314176bc6ed38cea11723cc1fd9ee3b/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs?ref=99bc97940314176bc6ed38cea11723cc1fd9ee3b", "patch": "@@ -254,6 +254,17 @@ pub(crate) fn fluent_messages(input: proc_macro::TokenStream) -> proc_macro::Tok\n             ];\n \n             #generated\n+\n+            pub mod _subdiag {\n+                pub const note: crate::SubdiagnosticMessage =\n+                    crate::SubdiagnosticMessage::FluentAttr(std::borrow::Cow::Borrowed(\"note\"));\n+                pub const help: crate::SubdiagnosticMessage =\n+                    crate::SubdiagnosticMessage::FluentAttr(std::borrow::Cow::Borrowed(\"help\"));\n+                pub const label: crate::SubdiagnosticMessage =\n+                    crate::SubdiagnosticMessage::FluentAttr(std::borrow::Cow::Borrowed(\"label\"));\n+                pub const suggestion: crate::SubdiagnosticMessage =\n+                    crate::SubdiagnosticMessage::FluentAttr(std::borrow::Cow::Borrowed(\"suggestion\"));\n+            }\n         }\n     }\n     .into()"}, {"sha": "88182ed5a1224f93baffcaf5bb5c64d92166be0b", "filename": "compiler/rustc_macros/src/diagnostics/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99bc97940314176bc6ed38cea11723cc1fd9ee3b/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99bc97940314176bc6ed38cea11723cc1fd9ee3b/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=99bc97940314176bc6ed38cea11723cc1fd9ee3b", "patch": "@@ -22,14 +22,14 @@ use synstructure::Structure;\n /// # extern crate rust_middle;\n /// # use rustc_middle::ty::Ty;\n /// #[derive(SessionDiagnostic)]\n-/// #[error(code = \"E0505\", slug = \"borrowck-move-out-of-borrow\")]\n+/// #[error(borrowck::move_out_of_borrow, code = \"E0505\")]\n /// pub struct MoveOutOfBorrowError<'tcx> {\n ///     pub name: Ident,\n ///     pub ty: Ty<'tcx>,\n ///     #[primary_span]\n ///     #[label]\n ///     pub span: Span,\n-///     #[label = \"first-borrow-label\"]\n+///     #[label(borrowck::first_borrow_label)]\n ///     pub first_borrow_span: Span,\n ///     #[suggestion(code = \"{name}.clone()\")]\n ///     pub clone_sugg: Option<(Span, Applicability)>"}, {"sha": "30869f055f5fa5ac9a2a8ffa0f1b36ef3c36cff0", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/99bc97940314176bc6ed38cea11723cc1fd9ee3b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99bc97940314176bc6ed38cea11723cc1fd9ee3b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=99bc97940314176bc6ed38cea11723cc1fd9ee3b", "patch": "@@ -244,7 +244,7 @@ impl MultiSugg {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(slug = \"parser-maybe-report-ambiguous-plus\")]\n+#[error(parser::maybe_report_ambiguous_plus)]\n struct AmbiguousPlus {\n     pub sum_ty: String,\n     #[primary_span]\n@@ -253,7 +253,7 @@ struct AmbiguousPlus {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0178\", slug = \"parser-maybe-recover-from-bad-type-plus\")]\n+#[error(parser::maybe_recover_from_bad_type_plus, code = \"E0178\")]\n struct BadTypePlus {\n     pub ty: String,\n     #[primary_span]\n@@ -287,7 +287,7 @@ pub enum BadTypePlusSub {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(slug = \"parser-maybe-recover-from-bad-qpath-stage-2\")]\n+#[error(parser::maybe_recover_from_bad_qpath_stage_2)]\n struct BadQPathStage2 {\n     #[primary_span]\n     #[suggestion(applicability = \"maybe-incorrect\")]\n@@ -296,7 +296,7 @@ struct BadQPathStage2 {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(slug = \"parser-incorrect-semicolon\")]\n+#[error(parser::incorrect_semicolon)]\n struct IncorrectSemicolon<'a> {\n     #[primary_span]\n     #[suggestion_short(applicability = \"machine-applicable\")]\n@@ -307,26 +307,26 @@ struct IncorrectSemicolon<'a> {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(slug = \"parser-incorrect-use-of-await\")]\n+#[error(parser::incorrect_use_of_await)]\n struct IncorrectUseOfAwait {\n     #[primary_span]\n-    #[suggestion(message = \"parentheses-suggestion\", applicability = \"machine-applicable\")]\n+    #[suggestion(parser::parentheses_suggestion, applicability = \"machine-applicable\")]\n     span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(slug = \"parser-incorrect-use-of-await\")]\n+#[error(parser::incorrect_use_of_await)]\n struct IncorrectAwait {\n     #[primary_span]\n     span: Span,\n-    #[suggestion(message = \"postfix-suggestion\", code = \"{expr}.await{question_mark}\")]\n+    #[suggestion(parser::postfix_suggestion, code = \"{expr}.await{question_mark}\")]\n     sugg_span: (Span, Applicability),\n     expr: String,\n     question_mark: &'static str,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(slug = \"parser-in-in-typo\")]\n+#[error(parser::in_in_typo)]\n struct InInTypo {\n     #[primary_span]\n     span: Span,"}, {"sha": "758108e5d7170754db7fee6b97428f5a21408096", "filename": "compiler/rustc_typeck/src/errors.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/99bc97940314176bc6ed38cea11723cc1fd9ee3b/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99bc97940314176bc6ed38cea11723cc1fd9ee3b/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs?ref=99bc97940314176bc6ed38cea11723cc1fd9ee3b", "patch": "@@ -6,18 +6,18 @@ use rustc_session::{parse::ParseSess, SessionDiagnostic};\n use rustc_span::{symbol::Ident, Span, Symbol};\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0062\", slug = \"typeck-field-multiply-specified-in-initializer\")]\n+#[error(typeck::field_multiply_specified_in_initializer, code = \"E0062\")]\n pub struct FieldMultiplySpecifiedInInitializer {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label = \"previous-use-label\"]\n+    #[label(typeck::previous_use_label)]\n     pub prev_span: Span,\n     pub ident: Ident,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0092\", slug = \"typeck-unrecognized-atomic-operation\")]\n+#[error(typeck::unrecognized_atomic_operation, code = \"E0092\")]\n pub struct UnrecognizedAtomicOperation<'a> {\n     #[primary_span]\n     #[label]\n@@ -26,7 +26,7 @@ pub struct UnrecognizedAtomicOperation<'a> {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0094\", slug = \"typeck-wrong-number-of-generic-arguments-to-intrinsic\")]\n+#[error(typeck::wrong_number_of_generic_arguments_to_intrinsic, code = \"E0094\")]\n pub struct WrongNumberOfGenericArgumentsToIntrinsic<'a> {\n     #[primary_span]\n     #[label]\n@@ -37,7 +37,7 @@ pub struct WrongNumberOfGenericArgumentsToIntrinsic<'a> {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0093\", slug = \"typeck-unrecognized-intrinsic-function\")]\n+#[error(typeck::unrecognized_intrinsic_function, code = \"E0093\")]\n pub struct UnrecognizedIntrinsicFunction {\n     #[primary_span]\n     #[label]\n@@ -46,92 +46,92 @@ pub struct UnrecognizedIntrinsicFunction {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0195\", slug = \"typeck-lifetimes-or-bounds-mismatch-on-trait\")]\n+#[error(typeck::lifetimes_or_bounds_mismatch_on_trait, code = \"E0195\")]\n pub struct LifetimesOrBoundsMismatchOnTrait {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label = \"generics-label\"]\n+    #[label(typeck::generics_label)]\n     pub generics_span: Option<Span>,\n     pub item_kind: &'static str,\n     pub ident: Ident,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0120\", slug = \"typeck-drop-impl-on-wrong-item\")]\n+#[error(typeck::drop_impl_on_wrong_item, code = \"E0120\")]\n pub struct DropImplOnWrongItem {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0124\", slug = \"typeck-field-already-declared\")]\n+#[error(typeck::field_already_declared, code = \"E0124\")]\n pub struct FieldAlreadyDeclared {\n     pub field_name: Ident,\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label = \"previous-decl-label\"]\n+    #[label(typeck::previous_decl_label)]\n     pub prev_span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0184\", slug = \"typeck-copy-impl-on-type-with-dtor\")]\n+#[error(typeck::copy_impl_on_type_with_dtor, code = \"E0184\")]\n pub struct CopyImplOnTypeWithDtor {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0203\", slug = \"typeck-multiple-relaxed-default-bounds\")]\n+#[error(typeck::multiple_relaxed_default_bounds, code = \"E0203\")]\n pub struct MultipleRelaxedDefaultBounds {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0206\", slug = \"typeck-copy-impl-on-non-adt\")]\n+#[error(typeck::copy_impl_on_non_adt, code = \"E0206\")]\n pub struct CopyImplOnNonAdt {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0224\", slug = \"typeck-trait-object-declared-with-no-traits\")]\n+#[error(typeck::trait_object_declared_with_no_traits, code = \"E0224\")]\n pub struct TraitObjectDeclaredWithNoTraits {\n     #[primary_span]\n     pub span: Span,\n-    #[label = \"alias-span\"]\n+    #[label(typeck::alias_span)]\n     pub trait_alias_span: Option<Span>,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0227\", slug = \"typeck-ambiguous-lifetime-bound\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0227\")]\n pub struct AmbiguousLifetimeBound {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0229\", slug = \"typeck-assoc-type-binding-not-allowed\")]\n+#[error(typeck::assoc_type_binding_not_allowed, code = \"E0229\")]\n pub struct AssocTypeBindingNotAllowed {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0436\", slug = \"typeck-functional-record-update-on-non-struct\")]\n+#[error(typeck::functional_record_update_on_non_struct, code = \"E0436\")]\n pub struct FunctionalRecordUpdateOnNonStruct {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0516\", slug = \"typeck-typeof-reserved-keyword-used\")]\n+#[error(typeck::typeof_reserved_keyword_used, code = \"E0516\")]\n pub struct TypeofReservedKeywordUsed<'tcx> {\n     pub ty: Ty<'tcx>,\n     #[primary_span]\n@@ -142,52 +142,52 @@ pub struct TypeofReservedKeywordUsed<'tcx> {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0572\", slug = \"typeck-return-stmt-outside-of-fn-body\")]\n+#[error(typeck::return_stmt_outside_of_fn_body, code = \"E0572\")]\n pub struct ReturnStmtOutsideOfFnBody {\n     #[primary_span]\n     pub span: Span,\n-    #[label = \"encl-body-label\"]\n+    #[label(typeck::encl_body_label)]\n     pub encl_body_span: Option<Span>,\n-    #[label = \"encl-fn-label\"]\n+    #[label(typeck::encl_fn_label)]\n     pub encl_fn_span: Option<Span>,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0627\", slug = \"typeck-yield-expr-outside-of-generator\")]\n+#[error(typeck::yield_expr_outside_of_generator, code = \"E0627\")]\n pub struct YieldExprOutsideOfGenerator {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0639\", slug = \"typeck-struct-expr-non-exhaustive\")]\n+#[error(typeck::struct_expr_non_exhaustive, code = \"E0639\")]\n pub struct StructExprNonExhaustive {\n     #[primary_span]\n     pub span: Span,\n     pub what: &'static str,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0699\", slug = \"typeck-method-call-on-unknown-type\")]\n+#[error(typeck::method_call_on_unknown_type, code = \"E0699\")]\n pub struct MethodCallOnUnknownType {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0719\", slug = \"typeck-value-of-associated-struct-already-specified\")]\n+#[error(typeck::value_of_associated_struct_already_specified, code = \"E0719\")]\n pub struct ValueOfAssociatedStructAlreadySpecified {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label = \"previous-bound-label\"]\n+    #[label(typeck::previous_bound_label)]\n     pub prev_span: Span,\n     pub item_name: Ident,\n     pub def_path: String,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0745\", slug = \"typeck-address-of-temporary-taken\")]\n+#[error(typeck::address_of_temporary_taken, code = \"E0745\")]\n pub struct AddressOfTemporaryTaken {\n     #[primary_span]\n     #[label]\n@@ -233,7 +233,7 @@ pub enum ExpectedReturnTypeLabel<'tcx> {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(slug = \"typeck-unconstrained-opaque-type\")]\n+#[error(typeck::unconstrained_opaque_type)]\n #[note]\n pub struct UnconstrainedOpaqueType {\n     #[primary_span]\n@@ -301,7 +301,7 @@ impl<'a> SessionDiagnostic<'a> for MissingTypeParams {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0183\", slug = \"typeck-manual-implementation\")]\n+#[error(typeck::manual_implementation, code = \"E0183\")]\n #[help]\n pub struct ManualImplementation {\n     #[primary_span]\n@@ -311,7 +311,7 @@ pub struct ManualImplementation {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(slug = \"typeck-substs-on-overridden-impl\")]\n+#[error(typeck::substs_on_overridden_impl)]\n pub struct SubstsOnOverriddenImpl {\n     #[primary_span]\n     pub span: Span,"}, {"sha": "3e349ab02586f5c93d951525475739814a086ca2", "filename": "src/test/ui-fulldeps/internal-lints/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99bc97940314176bc6ed38cea11723cc1fd9ee3b/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99bc97940314176bc6ed38cea11723cc1fd9ee3b/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.rs?ref=99bc97940314176bc6ed38cea11723cc1fd9ee3b", "patch": "@@ -16,7 +16,7 @@ use rustc_session::{parse::ParseSess, SessionDiagnostic};\n use rustc_span::Span;\n \n #[derive(SessionDiagnostic)]\n-#[error(slug = \"parser-expect-path\")]\n+#[error(parser::expect_path)]\n struct DeriveSessionDiagnostic {\n     #[primary_span]\n     span: Span,"}, {"sha": "8cbee4c6d92438ebf085ebc918a35208cb1fd4bc", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.rs", "status": "modified", "additions": 136, "deletions": 103, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/99bc97940314176bc6ed38cea11723cc1fd9ee3b/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99bc97940314176bc6ed38cea11723cc1fd9ee3b/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs?ref=99bc97940314176bc6ed38cea11723cc1fd9ee3b", "patch": "@@ -26,29 +26,29 @@ use rustc_errors::Applicability;\n extern crate rustc_session;\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"hello-world\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct Hello {}\n \n #[derive(SessionDiagnostic)]\n-#[warning(code = \"E0123\", slug = \"hello-world\")]\n+#[warning(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct HelloWarn {}\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n //~^ ERROR `#[derive(SessionDiagnostic)]` can only be used on structs\n enum SessionDiagnosticOnEnum {\n     Foo,\n     Bar,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n #[error = \"E0123\"]\n //~^ ERROR `#[error = ...]` is not a valid attribute\n struct WrongStructAttrStyle {}\n \n #[derive(SessionDiagnostic)]\n-#[nonsense(code = \"E0123\", slug = \"foo\")]\n+#[nonsense(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n //~^ ERROR `#[nonsense(...)]` is not a valid attribute\n //~^^ ERROR diagnostic kind not specified\n //~^^^ ERROR cannot find attribute `nonsense` in this scope\n@@ -57,84 +57,93 @@ struct InvalidStructAttr {}\n #[derive(SessionDiagnostic)]\n #[error(\"E0123\")]\n //~^ ERROR `#[error(\"...\")]` is not a valid attribute\n-//~^^ ERROR `slug` not specified\n+//~^^ ERROR diagnostic slug not specified\n struct InvalidLitNestedAttr {}\n \n #[derive(SessionDiagnostic)]\n-#[error(nonsense, code = \"E0123\", slug = \"foo\")]\n-//~^ ERROR `#[error(nonsense)]` is not a valid attribute\n+#[error(nonsense, code = \"E0123\")]\n+//~^ ERROR cannot find value `nonsense` in module `rustc_errors::fluent`\n struct InvalidNestedStructAttr {}\n \n #[derive(SessionDiagnostic)]\n #[error(nonsense(\"foo\"), code = \"E0123\", slug = \"foo\")]\n //~^ ERROR `#[error(nonsense(...))]` is not a valid attribute\n+//~^^ ERROR diagnostic slug not specified\n struct InvalidNestedStructAttr1 {}\n \n #[derive(SessionDiagnostic)]\n #[error(nonsense = \"...\", code = \"E0123\", slug = \"foo\")]\n //~^ ERROR `#[error(nonsense = ...)]` is not a valid attribute\n+//~^^ ERROR diagnostic slug not specified\n struct InvalidNestedStructAttr2 {}\n \n #[derive(SessionDiagnostic)]\n #[error(nonsense = 4, code = \"E0123\", slug = \"foo\")]\n //~^ ERROR `#[error(nonsense = ...)]` is not a valid attribute\n+//~^^ ERROR diagnostic slug not specified\n struct InvalidNestedStructAttr3 {}\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\", slug = \"foo\")]\n+//~^ ERROR `#[error(slug = ...)]` is not a valid attribute\n+struct InvalidNestedStructAttr4 {}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct WrongPlaceField {\n     #[suggestion = \"bar\"]\n     //~^ ERROR `#[suggestion = ...]` is not a valid attribute\n     sp: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n-#[error(code = \"E0456\", slug = \"bar\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0456\")]\n //~^ ERROR specified multiple times\n //~^^ ERROR specified multiple times\n //~^^^ ERROR specified multiple times\n struct ErrorSpecifiedTwice {}\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n-#[warning(code = \"E0293\", slug = \"bar\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[warning(typeck::ambiguous_lifetime_bound, code = \"E0293\")]\n //~^ ERROR specified multiple times\n //~^^ ERROR specified multiple times\n //~^^^ ERROR specified multiple times\n struct WarnSpecifiedAfterError {}\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0456\", code = \"E0457\", slug = \"bar\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0456\", code = \"E0457\")]\n //~^ ERROR specified multiple times\n struct CodeSpecifiedTwice {}\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0456\", slug = \"foo\", slug = \"bar\")]\n-//~^ ERROR specified multiple times\n+#[error(typeck::ambiguous_lifetime_bound, typeck::ambiguous_lifetime_bound, code = \"E0456\")]\n+//~^ ERROR `#[error(typeck::ambiguous_lifetime_bound)]` is not a valid attribute\n struct SlugSpecifiedTwice {}\n \n #[derive(SessionDiagnostic)]\n struct KindNotProvided {} //~ ERROR diagnostic kind not specified\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0456\")] //~ ERROR `slug` not specified\n+#[error(code = \"E0456\")]\n+//~^ ERROR diagnostic slug not specified\n struct SlugNotProvided {}\n \n #[derive(SessionDiagnostic)]\n-#[error(slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound)]\n struct CodeNotProvided {}\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct MessageWrongType {\n     #[primary_span]\n     //~^ ERROR `#[primary_span]` attribute can only be applied to fields of type `Span`\n     foo: String,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct InvalidPathFieldAttr {\n     #[nonsense]\n     //~^ ERROR `#[nonsense]` is not a valid attribute\n@@ -143,183 +152,183 @@ struct InvalidPathFieldAttr {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ErrorWithField {\n     name: String,\n-    #[label = \"bar\"]\n+    #[label(typeck::label)]\n     span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ErrorWithMessageAppliedToField {\n-    #[label = \"bar\"]\n-    //~^ ERROR the `#[label = ...]` attribute can only be applied to fields of type `Span`\n+    #[label(typeck::label)]\n+    //~^ ERROR the `#[label(...)]` attribute can only be applied to fields of type `Span`\n     name: String,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ErrorWithNonexistentField {\n-    #[suggestion(message = \"bar\", code = \"{name}\")]\n+    #[suggestion(typeck::suggestion, code = \"{name}\")]\n     //~^ ERROR `name` doesn't refer to a field on this type\n     suggestion: (Span, Applicability),\n }\n \n #[derive(SessionDiagnostic)]\n //~^ ERROR invalid format string: expected `'}'`\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ErrorMissingClosingBrace {\n-    #[suggestion(message = \"bar\", code = \"{name\")]\n+    #[suggestion(typeck::suggestion, code = \"{name\")]\n     suggestion: (Span, Applicability),\n     name: String,\n     val: usize,\n }\n \n #[derive(SessionDiagnostic)]\n //~^ ERROR invalid format string: unmatched `}`\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ErrorMissingOpeningBrace {\n-    #[suggestion(message = \"bar\", code = \"name}\")]\n+    #[suggestion(typeck::suggestion, code = \"name}\")]\n     suggestion: (Span, Applicability),\n     name: String,\n     val: usize,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct LabelOnSpan {\n-    #[label = \"bar\"]\n+    #[label(typeck::label)]\n     sp: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct LabelOnNonSpan {\n-    #[label = \"bar\"]\n-    //~^ ERROR the `#[label = ...]` attribute can only be applied to fields of type `Span`\n+    #[label(typeck::label)]\n+    //~^ ERROR the `#[label(...)]` attribute can only be applied to fields of type `Span`\n     id: u32,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct Suggest {\n-    #[suggestion(message = \"bar\", code = \"This is the suggested code\")]\n-    #[suggestion_short(message = \"qux\", code = \"This is the suggested code\")]\n-    #[suggestion_hidden(message = \"foobar\", code = \"This is the suggested code\")]\n-    #[suggestion_verbose(message = \"fooqux\", code = \"This is the suggested code\")]\n+    #[suggestion(typeck::suggestion, code = \"This is the suggested code\")]\n+    #[suggestion_short(typeck::suggestion, code = \"This is the suggested code\")]\n+    #[suggestion_hidden(typeck::suggestion, code = \"This is the suggested code\")]\n+    #[suggestion_verbose(typeck::suggestion, code = \"This is the suggested code\")]\n     suggestion: (Span, Applicability),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct SuggestWithoutCode {\n-    #[suggestion(message = \"bar\")]\n+    #[suggestion(typeck::suggestion)]\n     suggestion: (Span, Applicability),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct SuggestWithBadKey {\n     #[suggestion(nonsense = \"bar\")]\n     //~^ ERROR `#[suggestion(nonsense = ...)]` is not a valid attribute\n     suggestion: (Span, Applicability),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct SuggestWithShorthandMsg {\n     #[suggestion(msg = \"bar\")]\n     //~^ ERROR `#[suggestion(msg = ...)]` is not a valid attribute\n     suggestion: (Span, Applicability),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct SuggestWithoutMsg {\n     #[suggestion(code = \"bar\")]\n     suggestion: (Span, Applicability),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct SuggestWithTypesSwapped {\n-    #[suggestion(message = \"bar\", code = \"This is suggested code\")]\n+    #[suggestion(typeck::suggestion, code = \"This is suggested code\")]\n     suggestion: (Applicability, Span),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct SuggestWithWrongTypeApplicabilityOnly {\n-    #[suggestion(message = \"bar\", code = \"This is suggested code\")]\n+    #[suggestion(typeck::suggestion, code = \"This is suggested code\")]\n     //~^ ERROR wrong field type for suggestion\n     suggestion: Applicability,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct SuggestWithSpanOnly {\n-    #[suggestion(message = \"bar\", code = \"This is suggested code\")]\n+    #[suggestion(typeck::suggestion, code = \"This is suggested code\")]\n     suggestion: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct SuggestWithDuplicateSpanAndApplicability {\n-    #[suggestion(message = \"bar\", code = \"This is suggested code\")]\n+    #[suggestion(typeck::suggestion, code = \"This is suggested code\")]\n     //~^ ERROR type of field annotated with `#[suggestion(...)]` contains more than one `Span`\n     suggestion: (Span, Span, Applicability),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct SuggestWithDuplicateApplicabilityAndSpan {\n-    #[suggestion(message = \"bar\", code = \"This is suggested code\")]\n+    #[suggestion(typeck::suggestion, code = \"This is suggested code\")]\n     //~^ ERROR type of field annotated with `#[suggestion(...)]` contains more than one\n     suggestion: (Applicability, Applicability, Span),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct WrongKindOfAnnotation {\n-    #[label(\"bar\")]\n-    //~^ ERROR `#[label(...)]` is not a valid attribute\n+    #[label = \"bar\"]\n+    //~^ ERROR `#[label = ...]` is not a valid attribute\n     z: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct OptionsInErrors {\n-    #[label = \"bar\"]\n+    #[label(typeck::label)]\n     label: Option<Span>,\n-    #[suggestion(message = \"bar\")]\n+    #[suggestion(typeck::suggestion)]\n     opt_sugg: Option<(Span, Applicability)>,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0456\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0456\")]\n struct MoveOutOfBorrowError<'tcx> {\n     name: Ident,\n     ty: Ty<'tcx>,\n     #[primary_span]\n-    #[label = \"bar\"]\n+    #[label(typeck::label)]\n     span: Span,\n-    #[label = \"qux\"]\n+    #[label(typeck::label)]\n     other_span: Span,\n-    #[suggestion(message = \"bar\", code = \"{name}.clone()\")]\n+    #[suggestion(typeck::suggestion, code = \"{name}.clone()\")]\n     opt_sugg: Option<(Span, Applicability)>,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ErrorWithLifetime<'a> {\n-    #[label = \"bar\"]\n+    #[label(typeck::label)]\n     span: Span,\n     name: &'a str,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ErrorWithDefaultLabelAttr<'a> {\n     #[label]\n     span: Span,\n@@ -328,15 +337,15 @@ struct ErrorWithDefaultLabelAttr<'a> {\n \n #[derive(SessionDiagnostic)]\n //~^ ERROR the trait bound `Hello: IntoDiagnosticArg` is not satisfied\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ArgFieldWithoutSkip {\n     #[primary_span]\n     span: Span,\n     other: Hello,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ArgFieldWithSkip {\n     #[primary_span]\n     span: Span,\n@@ -347,116 +356,116 @@ struct ArgFieldWithSkip {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ErrorWithSpannedNote {\n     #[note]\n     span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ErrorWithSpannedNoteCustom {\n-    #[note = \"bar\"]\n+    #[note(typeck::note)]\n     span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n #[note]\n struct ErrorWithNote {\n     val: String,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n-#[note = \"bar\"]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[note(typeck::note)]\n struct ErrorWithNoteCustom {\n     val: String,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ErrorWithSpannedHelp {\n     #[help]\n     span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ErrorWithSpannedHelpCustom {\n-    #[help = \"bar\"]\n+    #[help(typeck::help)]\n     span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n #[help]\n struct ErrorWithHelp {\n     val: String,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n-#[help = \"bar\"]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[help(typeck::help)]\n struct ErrorWithHelpCustom {\n     val: String,\n }\n \n #[derive(SessionDiagnostic)]\n #[help]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ErrorWithHelpWrongOrder {\n     val: String,\n }\n \n #[derive(SessionDiagnostic)]\n-#[help = \"bar\"]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[help(typeck::help)]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ErrorWithHelpCustomWrongOrder {\n     val: String,\n }\n \n #[derive(SessionDiagnostic)]\n #[note]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ErrorWithNoteWrongOrder {\n     val: String,\n }\n \n #[derive(SessionDiagnostic)]\n-#[note = \"bar\"]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[note(typeck::note)]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ErrorWithNoteCustomWrongOrder {\n     val: String,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ApplicabilityInBoth {\n-    #[suggestion(message = \"bar\", code = \"...\", applicability = \"maybe-incorrect\")]\n+    #[suggestion(typeck::suggestion, code = \"...\", applicability = \"maybe-incorrect\")]\n     //~^ ERROR applicability cannot be set in both the field and attribute\n     suggestion: (Span, Applicability),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct InvalidApplicability {\n-    #[suggestion(message = \"bar\", code = \"...\", applicability = \"batman\")]\n+    #[suggestion(typeck::suggestion, code = \"...\", applicability = \"batman\")]\n     //~^ ERROR invalid applicability\n     suggestion: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ValidApplicability {\n-    #[suggestion(message = \"bar\", code = \"...\", applicability = \"maybe-incorrect\")]\n+    #[suggestion(typeck::suggestion, code = \"...\", applicability = \"maybe-incorrect\")]\n     suggestion: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct NoApplicability {\n-    #[suggestion(message = \"bar\", code = \"...\")]\n+    #[suggestion(typeck::suggestion, code = \"...\")]\n     suggestion: Span,\n }\n \n@@ -465,38 +474,62 @@ struct NoApplicability {\n struct Note;\n \n #[derive(SessionDiagnostic)]\n-#[error(slug = \"subdiagnostic\")]\n+#[error(typeck::ambiguous_lifetime_bound)]\n struct Subdiagnostic {\n     #[subdiagnostic]\n     note: Note,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct VecField {\n     #[primary_span]\n     #[label]\n     spans: Vec<Span>,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct UnitField {\n     #[primary_span]\n     spans: Span,\n     #[help]\n     foo: (),\n-    #[help = \"a\"]\n+    #[help(typeck::help)]\n     bar: (),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct OptUnitField {\n     #[primary_span]\n     spans: Span,\n     #[help]\n     foo: Option<()>,\n-    #[help = \"a\"]\n+    #[help(typeck::help)]\n     bar: Option<()>,\n }\n+\n+#[derive(SessionDiagnostic)]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+struct LabelWithTrailingPath {\n+    #[label(typeck::label, foo)]\n+    //~^ ERROR `#[label(...)]` is not a valid attribute\n+    span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+struct LabelWithTrailingNameValue {\n+    #[label(typeck::label, foo = \"...\")]\n+    //~^ ERROR `#[label(...)]` is not a valid attribute\n+    span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+struct LabelWithTrailingList {\n+    #[label(typeck::label, foo(\"...\"))]\n+    //~^ ERROR `#[label(...)]` is not a valid attribute\n+    span: Span,\n+}"}, {"sha": "0d9690e1f5a998437943d7715c784956bd8fa2f0", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.stderr", "status": "modified", "additions": 172, "deletions": 115, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/99bc97940314176bc6ed38cea11723cc1fd9ee3b/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99bc97940314176bc6ed38cea11723cc1fd9ee3b/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr?ref=99bc97940314176bc6ed38cea11723cc1fd9ee3b", "patch": "@@ -1,7 +1,7 @@\n error: `#[derive(SessionDiagnostic)]` can only be used on structs\n   --> $DIR/diagnostic-derive.rs:37:1\n    |\n-LL | / #[error(code = \"E0123\", slug = \"foo\")]\n+LL | / #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n LL | |\n LL | | enum SessionDiagnosticOnEnum {\n LL | |     Foo,\n@@ -18,15 +18,15 @@ LL | #[error = \"E0123\"]\n error: `#[nonsense(...)]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:51:1\n    |\n-LL | #[nonsense(code = \"E0123\", slug = \"foo\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[nonsense(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: only `error` and `warning` are valid attributes\n+   = help: only `error`, `warning`, `help` and `note` are valid attributes\n \n error: diagnostic kind not specified\n   --> $DIR/diagnostic-derive.rs:51:1\n    |\n-LL | / #[nonsense(code = \"E0123\", slug = \"foo\")]\n+LL | / #[nonsense(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n LL | |\n LL | |\n LL | |\n@@ -40,8 +40,10 @@ error: `#[error(\"...\")]` is not a valid attribute\n    |\n LL | #[error(\"E0123\")]\n    |         ^^^^^^^\n+   |\n+   = help: first argument of the attribute should be the diagnostic slug\n \n-error: `slug` not specified\n+error: diagnostic slug not specified\n   --> $DIR/diagnostic-derive.rs:58:1\n    |\n LL | / #[error(\"E0123\")]\n@@ -50,183 +52,215 @@ LL | |\n LL | | struct InvalidLitNestedAttr {}\n    | |______________________________^\n    |\n-   = help: use the `#[error(slug = \"...\")]` attribute to set this diagnostic's slug\n-\n-error: `#[error(nonsense)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:64:9\n-   |\n-LL | #[error(nonsense, code = \"E0123\", slug = \"foo\")]\n-   |         ^^^^^^^^\n+   = help: specify the slug as the first argument to the attribute, such as `#[error(typeck::example_error)]`\n \n error: `#[error(nonsense(...))]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:69:9\n    |\n LL | #[error(nonsense(\"foo\"), code = \"E0123\", slug = \"foo\")]\n    |         ^^^^^^^^^^^^^^^\n+   |\n+   = help: first argument of the attribute should be the diagnostic slug\n+\n+error: diagnostic slug not specified\n+  --> $DIR/diagnostic-derive.rs:69:1\n+   |\n+LL | / #[error(nonsense(\"foo\"), code = \"E0123\", slug = \"foo\")]\n+LL | |\n+LL | |\n+LL | | struct InvalidNestedStructAttr1 {}\n+   | |__________________________________^\n+   |\n+   = help: specify the slug as the first argument to the attribute, such as `#[error(typeck::example_error)]`\n \n error: `#[error(nonsense = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:74:9\n+  --> $DIR/diagnostic-derive.rs:75:9\n    |\n LL | #[error(nonsense = \"...\", code = \"E0123\", slug = \"foo\")]\n    |         ^^^^^^^^^^^^^^^^\n    |\n-   = help: only `slug` and `code` are valid nested attributes\n+   = help: first argument of the attribute should be the diagnostic slug\n+\n+error: diagnostic slug not specified\n+  --> $DIR/diagnostic-derive.rs:75:1\n+   |\n+LL | / #[error(nonsense = \"...\", code = \"E0123\", slug = \"foo\")]\n+LL | |\n+LL | |\n+LL | | struct InvalidNestedStructAttr2 {}\n+   | |__________________________________^\n+   |\n+   = help: specify the slug as the first argument to the attribute, such as `#[error(typeck::example_error)]`\n \n error: `#[error(nonsense = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:79:9\n+  --> $DIR/diagnostic-derive.rs:81:9\n    |\n LL | #[error(nonsense = 4, code = \"E0123\", slug = \"foo\")]\n    |         ^^^^^^^^^^^^\n+   |\n+   = help: first argument of the attribute should be the diagnostic slug\n \n-error: `#[suggestion = ...]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:86:5\n+error: diagnostic slug not specified\n+  --> $DIR/diagnostic-derive.rs:81:1\n    |\n-LL |     #[suggestion = \"bar\"]\n-   |     ^^^^^^^^^^^^^^^^^^^^^\n+LL | / #[error(nonsense = 4, code = \"E0123\", slug = \"foo\")]\n+LL | |\n+LL | |\n+LL | | struct InvalidNestedStructAttr3 {}\n+   | |__________________________________^\n    |\n-   = help: only `label`, `note` and `help` are valid field attributes\n+   = help: specify the slug as the first argument to the attribute, such as `#[error(typeck::example_error)]`\n \n-error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:93:1\n+error: `#[error(slug = ...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:87:59\n    |\n-LL | #[error(code = \"E0456\", slug = \"bar\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\", slug = \"foo\")]\n+   |                                                           ^^^^^^^^^^^^\n    |\n-note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:92:1\n+   = help: only `code` is a valid nested attributes following the slug\n+\n+error: `#[suggestion = ...]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:94:5\n    |\n-LL | #[error(code = \"E0123\", slug = \"foo\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[suggestion = \"bar\"]\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:93:16\n+  --> $DIR/diagnostic-derive.rs:101:1\n    |\n-LL | #[error(code = \"E0456\", slug = \"bar\")]\n-   |                ^^^^^^^\n+LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0456\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:92:16\n+  --> $DIR/diagnostic-derive.rs:100:1\n    |\n-LL | #[error(code = \"E0123\", slug = \"foo\")]\n-   |                ^^^^^^^\n+LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:93:32\n+  --> $DIR/diagnostic-derive.rs:101:1\n    |\n-LL | #[error(code = \"E0456\", slug = \"bar\")]\n-   |                                ^^^^^\n+LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0456\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:92:32\n+  --> $DIR/diagnostic-derive.rs:100:1\n    |\n-LL | #[error(code = \"E0123\", slug = \"foo\")]\n-   |                                ^^^^^\n+LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:101:1\n+  --> $DIR/diagnostic-derive.rs:101:50\n    |\n-LL | #[warning(code = \"E0293\", slug = \"bar\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0456\")]\n+   |                                                  ^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:100:1\n+  --> $DIR/diagnostic-derive.rs:100:50\n    |\n-LL | #[error(code = \"E0123\", slug = \"foo\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+   |                                                  ^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:101:18\n+  --> $DIR/diagnostic-derive.rs:109:1\n    |\n-LL | #[warning(code = \"E0293\", slug = \"bar\")]\n-   |                  ^^^^^^^\n+LL | #[warning(typeck::ambiguous_lifetime_bound, code = \"E0293\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:100:16\n+  --> $DIR/diagnostic-derive.rs:108:1\n    |\n-LL | #[error(code = \"E0123\", slug = \"foo\")]\n-   |                ^^^^^^^\n+LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:101:34\n+  --> $DIR/diagnostic-derive.rs:109:1\n    |\n-LL | #[warning(code = \"E0293\", slug = \"bar\")]\n-   |                                  ^^^^^\n+LL | #[warning(typeck::ambiguous_lifetime_bound, code = \"E0293\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:100:32\n+  --> $DIR/diagnostic-derive.rs:108:1\n    |\n-LL | #[error(code = \"E0123\", slug = \"foo\")]\n-   |                                ^^^^^\n+LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:108:32\n+  --> $DIR/diagnostic-derive.rs:109:52\n    |\n-LL | #[error(code = \"E0456\", code = \"E0457\", slug = \"bar\")]\n-   |                                ^^^^^^^\n+LL | #[warning(typeck::ambiguous_lifetime_bound, code = \"E0293\")]\n+   |                                                    ^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:108:16\n+  --> $DIR/diagnostic-derive.rs:108:50\n    |\n-LL | #[error(code = \"E0456\", code = \"E0457\", slug = \"bar\")]\n-   |                ^^^^^^^\n+LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+   |                                                  ^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:113:46\n+  --> $DIR/diagnostic-derive.rs:116:66\n    |\n-LL | #[error(code = \"E0456\", slug = \"foo\", slug = \"bar\")]\n-   |                                              ^^^^^\n+LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0456\", code = \"E0457\")]\n+   |                                                                  ^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:113:32\n+  --> $DIR/diagnostic-derive.rs:116:50\n    |\n-LL | #[error(code = \"E0456\", slug = \"foo\", slug = \"bar\")]\n-   |                                ^^^^^\n+LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0456\", code = \"E0457\")]\n+   |                                                  ^^^^^^^\n+\n+error: `#[error(typeck::ambiguous_lifetime_bound)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:121:43\n+   |\n+LL | #[error(typeck::ambiguous_lifetime_bound, typeck::ambiguous_lifetime_bound, code = \"E0456\")]\n+   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: diagnostic kind not specified\n-  --> $DIR/diagnostic-derive.rs:118:1\n+  --> $DIR/diagnostic-derive.rs:126:1\n    |\n LL | struct KindNotProvided {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use the `#[error(...)]` attribute to create an error\n \n-error: `slug` not specified\n-  --> $DIR/diagnostic-derive.rs:121:1\n+error: diagnostic slug not specified\n+  --> $DIR/diagnostic-derive.rs:129:1\n    |\n LL | / #[error(code = \"E0456\")]\n+LL | |\n LL | | struct SlugNotProvided {}\n    | |_________________________^\n    |\n-   = help: use the `#[error(slug = \"...\")]` attribute to set this diagnostic's slug\n+   = help: specify the slug as the first argument to the attribute, such as `#[error(typeck::example_error)]`\n \n error: the `#[primary_span]` attribute can only be applied to fields of type `Span`\n-  --> $DIR/diagnostic-derive.rs:131:5\n+  --> $DIR/diagnostic-derive.rs:140:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n \n error: `#[nonsense]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:139:5\n+  --> $DIR/diagnostic-derive.rs:148:5\n    |\n LL |     #[nonsense]\n    |     ^^^^^^^^^^^\n    |\n    = help: only `skip_arg`, `primary_span`, `label`, `note`, `help` and `subdiagnostic` are valid field attributes\n \n-error: the `#[label = ...]` attribute can only be applied to fields of type `Span`\n-  --> $DIR/diagnostic-derive.rs:156:5\n+error: the `#[label(...)]` attribute can only be applied to fields of type `Span`\n+  --> $DIR/diagnostic-derive.rs:165:5\n    |\n-LL |     #[label = \"bar\"]\n-   |     ^^^^^^^^^^^^^^^^\n+LL |     #[label(typeck::label)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `name` doesn't refer to a field on this type\n-  --> $DIR/diagnostic-derive.rs:164:42\n+  --> $DIR/diagnostic-derive.rs:173:45\n    |\n-LL |     #[suggestion(message = \"bar\", code = \"{name}\")]\n-   |                                          ^^^^^^^^\n+LL |     #[suggestion(typeck::suggestion, code = \"{name}\")]\n+   |                                             ^^^^^^^^\n \n error: invalid format string: expected `'}'` but string was terminated\n-  --> $DIR/diagnostic-derive.rs:169:16\n+  --> $DIR/diagnostic-derive.rs:178:16\n    |\n LL | #[derive(SessionDiagnostic)]\n    |           -    ^ expected `'}'` in format string\n@@ -237,96 +271,118 @@ LL | #[derive(SessionDiagnostic)]\n    = note: this error originates in the derive macro `SessionDiagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: invalid format string: unmatched `}` found\n-  --> $DIR/diagnostic-derive.rs:179:15\n+  --> $DIR/diagnostic-derive.rs:188:15\n    |\n LL | #[derive(SessionDiagnostic)]\n    |               ^ unmatched `}` in format string\n    |\n    = note: if you intended to print `}`, you can escape it using `}}`\n    = note: this error originates in the derive macro `SessionDiagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: the `#[label = ...]` attribute can only be applied to fields of type `Span`\n-  --> $DIR/diagnostic-derive.rs:199:5\n+error: the `#[label(...)]` attribute can only be applied to fields of type `Span`\n+  --> $DIR/diagnostic-derive.rs:208:5\n    |\n-LL |     #[label = \"bar\"]\n-   |     ^^^^^^^^^^^^^^^^\n+LL |     #[label(typeck::label)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `#[suggestion(nonsense = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:224:18\n+  --> $DIR/diagnostic-derive.rs:233:18\n    |\n LL |     #[suggestion(nonsense = \"bar\")]\n    |                  ^^^^^^^^^^^^^^^^\n    |\n    = help: only `message`, `code` and `applicability` are valid field attributes\n \n error: `#[suggestion(msg = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:232:18\n+  --> $DIR/diagnostic-derive.rs:241:18\n    |\n LL |     #[suggestion(msg = \"bar\")]\n    |                  ^^^^^^^^^^^\n    |\n    = help: only `message`, `code` and `applicability` are valid field attributes\n \n error: wrong field type for suggestion\n-  --> $DIR/diagnostic-derive.rs:254:5\n+  --> $DIR/diagnostic-derive.rs:263:5\n    |\n-LL | /     #[suggestion(message = \"bar\", code = \"This is suggested code\")]\n+LL | /     #[suggestion(typeck::suggestion, code = \"This is suggested code\")]\n LL | |\n LL | |     suggestion: Applicability,\n    | |_____________________________^\n    |\n    = help: `#[suggestion(...)]` should be applied to fields of type `Span` or `(Span, Applicability)`\n \n error: type of field annotated with `#[suggestion(...)]` contains more than one `Span`\n-  --> $DIR/diagnostic-derive.rs:269:5\n+  --> $DIR/diagnostic-derive.rs:278:5\n    |\n-LL | /     #[suggestion(message = \"bar\", code = \"This is suggested code\")]\n+LL | /     #[suggestion(typeck::suggestion, code = \"This is suggested code\")]\n LL | |\n LL | |     suggestion: (Span, Span, Applicability),\n    | |___________________________________________^\n \n error: type of field annotated with `#[suggestion(...)]` contains more than one Applicability\n-  --> $DIR/diagnostic-derive.rs:277:5\n+  --> $DIR/diagnostic-derive.rs:286:5\n    |\n-LL | /     #[suggestion(message = \"bar\", code = \"This is suggested code\")]\n+LL | /     #[suggestion(typeck::suggestion, code = \"This is suggested code\")]\n LL | |\n LL | |     suggestion: (Applicability, Applicability, Span),\n    | |____________________________________________________^\n \n-error: `#[label(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:285:5\n-   |\n-LL |     #[label(\"bar\")]\n-   |     ^^^^^^^^^^^^^^^\n+error: `#[label = ...]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:294:5\n    |\n-   = help: only `suggestion{,_short,_hidden,_verbose}` are valid field attributes\n+LL |     #[label = \"bar\"]\n+   |     ^^^^^^^^^^^^^^^^\n \n error: applicability cannot be set in both the field and attribute\n-  --> $DIR/diagnostic-derive.rs:436:49\n+  --> $DIR/diagnostic-derive.rs:445:52\n    |\n-LL |     #[suggestion(message = \"bar\", code = \"...\", applicability = \"maybe-incorrect\")]\n-   |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[suggestion(typeck::suggestion, code = \"...\", applicability = \"maybe-incorrect\")]\n+   |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: invalid applicability\n-  --> $DIR/diagnostic-derive.rs:444:49\n+  --> $DIR/diagnostic-derive.rs:453:52\n+   |\n+LL |     #[suggestion(typeck::suggestion, code = \"...\", applicability = \"batman\")]\n+   |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `#[label(...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:516:5\n+   |\n+LL |     #[label(typeck::label, foo)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `#[label(...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:524:5\n+   |\n+LL |     #[label(typeck::label, foo = \"...\")]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `#[label(...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:532:5\n    |\n-LL |     #[suggestion(message = \"bar\", code = \"...\", applicability = \"batman\")]\n-   |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[label(typeck::label, foo(\"...\"))]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: cannot find attribute `nonsense` in this scope\n   --> $DIR/diagnostic-derive.rs:51:3\n    |\n-LL | #[nonsense(code = \"E0123\", slug = \"foo\")]\n+LL | #[nonsense(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    |   ^^^^^^^^\n \n error: cannot find attribute `nonsense` in this scope\n-  --> $DIR/diagnostic-derive.rs:139:7\n+  --> $DIR/diagnostic-derive.rs:148:7\n    |\n LL |     #[nonsense]\n    |       ^^^^^^^^\n \n+error[E0425]: cannot find value `nonsense` in module `rustc_errors::fluent`\n+  --> $DIR/diagnostic-derive.rs:64:9\n+   |\n+LL | #[error(nonsense, code = \"E0123\")]\n+   |         ^^^^^^^^ not found in `rustc_errors::fluent`\n+\n error[E0277]: the trait bound `Hello: IntoDiagnosticArg` is not satisfied\n-  --> $DIR/diagnostic-derive.rs:329:10\n+  --> $DIR/diagnostic-derive.rs:338:10\n    |\n LL | #[derive(SessionDiagnostic)]\n    |          ^^^^^^^^^^^^^^^^^ the trait `IntoDiagnosticArg` is not implemented for `Hello`\n@@ -345,6 +401,7 @@ LL |         arg: impl IntoDiagnosticArg,\n    |                   ^^^^^^^^^^^^^^^^^ required by this bound in `DiagnosticBuilder::<'a, G>::set_arg`\n    = note: this error originates in the derive macro `SessionDiagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 39 previous errors\n+error: aborting due to 46 previous errors\n \n-For more information about this error, try `rustc --explain E0277`.\n+Some errors have detailed explanations: E0277, E0425.\n+For more information about an error, try `rustc --explain E0277`."}]}