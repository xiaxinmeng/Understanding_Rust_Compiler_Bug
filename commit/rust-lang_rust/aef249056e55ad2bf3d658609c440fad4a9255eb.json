{"sha": "aef249056e55ad2bf3d658609c440fad4a9255eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlZjI0OTA1NmU1NWFkMmJmM2Q2NTg2MDljNDQwZmFkNGE5MjU1ZWI=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-04-23T07:59:49Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-04-24T02:46:26Z"}, "message": "Implement Signed and Unsigned traits and remove related predicate functions", "tree": {"sha": "c1e1251fd77c46270d4889ac27c91f1ce1126045", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1e1251fd77c46270d4889ac27c91f1ce1126045"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aef249056e55ad2bf3d658609c440fad4a9255eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aef249056e55ad2bf3d658609c440fad4a9255eb", "html_url": "https://github.com/rust-lang/rust/commit/aef249056e55ad2bf3d658609c440fad4a9255eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aef249056e55ad2bf3d658609c440fad4a9255eb/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "706096b31960143fb1eb957a882f170ae4a8b4e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/706096b31960143fb1eb957a882f170ae4a8b4e9", "html_url": "https://github.com/rust-lang/rust/commit/706096b31960143fb1eb957a882f170ae4a8b4e9"}], "stats": {"total": 506, "additions": 328, "deletions": 178}, "files": [{"sha": "123fbcca9d5364e816925e026db5cc5820bd9a7a", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aef249056e55ad2bf3d658609c440fad4a9255eb/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/aef249056e55ad2bf3d658609c440fad4a9255eb/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=aef249056e55ad2bf3d658609c440fad4a9255eb", "patch": "@@ -105,7 +105,7 @@ pub use iter::{BaseIter, ExtendedIter, EqIter, CopyableIter};\n pub use iter::{CopyableOrderedIter, CopyableNonstrictIter, Times};\n pub use iter::{ExtendedMutableIter};\n \n-pub use num::{Num, NumCast};\n+pub use num::{Num, Signed, Unsigned, NumCast};\n pub use ptr::Ptr;\n pub use to_str::ToStr;\n pub use clone::Clone;"}, {"sha": "5d663844e5b79d4afb75dee4f10f640b06179880", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 74, "deletions": 40, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/aef249056e55ad2bf3d658609c440fad4a9255eb/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef249056e55ad2bf3d658609c440fad4a9255eb/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=aef249056e55ad2bf3d658609c440fad4a9255eb", "patch": "@@ -11,6 +11,7 @@\n //! Operations and constants for `f32`\n \n use num::strconv;\n+use num::Signed;\n use num;\n use option::Option;\n use from_str;\n@@ -163,38 +164,6 @@ pub fn gt(x: f32, y: f32) -> bool { return x > y; }\n // FIXME (#1999): replace the predicates below with llvm intrinsics or\n // calls to the libmath macros in the rust runtime for performance.\n \n-/// Returns true if `x` is a positive number, including +0.0f320 and +Infinity\n-#[inline(always)]\n-pub fn is_positive(x: f32) -> bool {\n-    x > 0.0f32 || (1.0f32/x) == infinity\n-}\n-\n-/// Returns true if `x` is a negative number, including -0.0f320 and -Infinity\n-#[inline(always)]\n-pub fn is_negative(x: f32) -> bool {\n-    x < 0.0f32 || (1.0f32/x) == neg_infinity\n-}\n-\n-/**\n- * Returns true if `x` is a negative number, including -0.0f320 and -Infinity\n- *\n- * This is the same as `f32::is_negative`.\n- */\n-#[inline(always)]\n-pub fn is_nonpositive(x: f32) -> bool {\n-  return x < 0.0f32 || (1.0f32/x) == neg_infinity;\n-}\n-\n-/**\n- * Returns true if `x` is a positive number, including +0.0f320 and +Infinity\n- *\n- * This is the same as `f32::is_positive`.)\n- */\n-#[inline(always)]\n-pub fn is_nonnegative(x: f32) -> bool {\n-  return x > 0.0f32 || (1.0f32/x) == infinity;\n-}\n-\n /// Returns true if `x` is a zero number (positive or negative zero)\n #[inline(always)]\n pub fn is_zero(x: f32) -> bool {\n@@ -259,11 +228,6 @@ pub mod consts {\n     pub static ln_10: f32 = 2.30258509299404568401799145468436421_f32;\n }\n \n-#[inline(always)]\n-pub fn signbit(x: f32) -> int {\n-    if is_negative(x) { return 1; } else { return 0; }\n-}\n-\n #[inline(always)]\n pub fn logarithm(n: f32, b: f32) -> f32 {\n     return log2(n) / log2(b);\n@@ -351,15 +315,41 @@ impl Neg<f32> for f32 {\n     fn neg(&self) -> f32 { -*self }\n }\n \n+impl Signed for f32 {\n+    /// Computes the absolute value. Returns `NaN` if the number is `NaN`.\n+    #[inline(always)]\n+    fn abs(&self) -> f32 { abs(*self) }\n+\n+    /**\n+     * # Returns\n+     *\n+     * - `1.0` if the number is positive, `+0.0` or `infinity`\n+     * - `-1.0` if the number is negative, `-0.0` or `neg_infinity`\n+     * - `NaN` if the number is `NaN`\n+     */\n+    #[inline(always)]\n+    fn signum(&self) -> f32 {\n+        if is_NaN(*self) { NaN } else { copysign(1.0, *self) }\n+    }\n+\n+    /// Returns `true` if the number is positive, including `+0.0` and `infinity`\n+    #[inline(always)]\n+    fn is_positive(&self) -> bool { *self > 0.0 || (1.0 / *self) == infinity }\n+\n+    /// Returns `true` if the number is negative, including `-0.0` and `neg_infinity`\n+    #[inline(always)]\n+    fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == neg_infinity }\n+}\n+\n impl num::Round for f32 {\n     #[inline(always)]\n     fn round(&self, mode: num::RoundMode) -> f32 {\n         match mode {\n             num::RoundDown                           => floor(*self),\n             num::RoundUp                             => ceil(*self),\n-            num::RoundToZero   if is_negative(*self) => ceil(*self),\n+            num::RoundToZero   if self.is_negative() => ceil(*self),\n             num::RoundToZero                         => floor(*self),\n-            num::RoundFromZero if is_negative(*self) => floor(*self),\n+            num::RoundFromZero if self.is_negative() => floor(*self),\n             num::RoundFromZero                       => ceil(*self)\n         }\n     }\n@@ -370,7 +360,7 @@ impl num::Round for f32 {\n     fn ceil(&self) -> f32 { ceil(*self) }\n     #[inline(always)]\n     fn fract(&self) -> f32 {\n-        if is_negative(*self) {\n+        if self.is_negative() {\n             (*self) - ceil(*self)\n         } else {\n             (*self) - floor(*self)\n@@ -595,6 +585,50 @@ impl num::FromStrRadix for f32 {\n     }\n }\n \n+#[cfg(test)]\n+mod tests {\n+    use f32::*;\n+\n+    #[test]\n+    pub fn test_signed() {\n+        assert_eq!(infinity.abs(), infinity);\n+        assert_eq!(1f32.abs(), 1f32);\n+        assert_eq!(0f32.abs(), 0f32);\n+        assert_eq!((-0f32).abs(), 0f32);\n+        assert_eq!((-1f32).abs(), 1f32);\n+        assert_eq!(neg_infinity.abs(), infinity);\n+        assert_eq!((1f32/neg_infinity).abs(), 0f32);\n+        assert!(is_NaN(NaN.abs()));\n+\n+        assert_eq!(infinity.signum(), 1f32);\n+        assert_eq!(1f32.signum(), 1f32);\n+        assert_eq!(0f32.signum(), 1f32);\n+        assert_eq!((-0f32).signum(), -1f32);\n+        assert_eq!((-1f32).signum(), -1f32);\n+        assert_eq!(neg_infinity.signum(), -1f32);\n+        assert_eq!((1f32/neg_infinity).signum(), -1f32);\n+        assert!(is_NaN(NaN.signum()));\n+\n+        assert!(infinity.is_positive());\n+        assert!(1f32.is_positive());\n+        assert!(0f32.is_positive());\n+        assert!(!(-0f32).is_positive());\n+        assert!(!(-1f32).is_positive());\n+        assert!(!neg_infinity.is_positive());\n+        assert!(!(1f32/neg_infinity).is_positive());\n+        assert!(!NaN.is_positive());\n+\n+        assert!(!infinity.is_negative());\n+        assert!(!1f32.is_negative());\n+        assert!(!0f32.is_negative());\n+        assert!((-0f32).is_negative());\n+        assert!((-1f32).is_negative());\n+        assert!(neg_infinity.is_negative());\n+        assert!((1f32/neg_infinity).is_negative());\n+        assert!(!NaN.is_negative());\n+    }\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "48f23fe8ba946aa3b8a1a82f0e4db6c08227b000", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 74, "deletions": 38, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/aef249056e55ad2bf3d658609c440fad4a9255eb/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef249056e55ad2bf3d658609c440fad4a9255eb/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=aef249056e55ad2bf3d658609c440fad4a9255eb", "patch": "@@ -11,6 +11,7 @@\n //! Operations and constants for `f64`\n \n use num::strconv;\n+use num::Signed;\n use num;\n use option::Option;\n use to_str;\n@@ -183,36 +184,6 @@ pub fn ge(x: f64, y: f64) -> bool { return x >= y; }\n #[inline(always)]\n pub fn gt(x: f64, y: f64) -> bool { return x > y; }\n \n-/// Returns true if `x` is a positive number, including +0.0f640 and +Infinity\n-#[inline(always)]\n-pub fn is_positive(x: f64) -> bool\n-    { return x > 0.0f64 || (1.0f64/x) == infinity; }\n-\n-/// Returns true if `x` is a negative number, including -0.0f640 and -Infinity\n-#[inline(always)]\n-pub fn is_negative(x: f64) -> bool\n-    { return x < 0.0f64 || (1.0f64/x) == neg_infinity; }\n-\n-/**\n- * Returns true if `x` is a negative number, including -0.0f640 and -Infinity\n- *\n- * This is the same as `f64::is_negative`.\n- */\n-#[inline(always)]\n-pub fn is_nonpositive(x: f64) -> bool {\n-  return x < 0.0f64 || (1.0f64/x) == neg_infinity;\n-}\n-\n-/**\n- * Returns true if `x` is a positive number, including +0.0f640 and +Infinity\n- *\n- * This is the same as `f64::positive`.\n- */\n-#[inline(always)]\n-pub fn is_nonnegative(x: f64) -> bool {\n-  return x > 0.0f64 || (1.0f64/x) == infinity;\n-}\n-\n /// Returns true if `x` is a zero number (positive or negative zero)\n #[inline(always)]\n pub fn is_zero(x: f64) -> bool {\n@@ -278,11 +249,6 @@ pub mod consts {\n     pub static ln_10: f64 = 2.30258509299404568401799145468436421_f64;\n }\n \n-#[inline(always)]\n-pub fn signbit(x: f64) -> int {\n-    if is_negative(x) { return 1; } else { return 0; }\n-}\n-\n #[inline(always)]\n pub fn logarithm(n: f64, b: f64) -> f64 {\n     return log2(n) / log2(b);\n@@ -357,15 +323,41 @@ impl Neg<f64> for f64 {\n     fn neg(&self) -> f64 { -*self }\n }\n \n+impl Signed for f64 {\n+    /// Computes the absolute value. Returns `NaN` if the number is `NaN`.\n+    #[inline(always)]\n+    fn abs(&self) -> f64 { abs(*self) }\n+\n+    /**\n+     * # Returns\n+     *\n+     * - `1.0` if the number is positive, `+0.0` or `infinity`\n+     * - `-1.0` if the number is negative, `-0.0` or `neg_infinity`\n+     * - `NaN` if the number is `NaN`\n+     */\n+    #[inline(always)]\n+    fn signum(&self) -> f64 {\n+        if is_NaN(*self) { NaN } else { copysign(1.0, *self) }\n+    }\n+\n+    /// Returns `true` if the number is positive, including `+0.0` and `infinity`\n+    #[inline(always)]\n+    fn is_positive(&self) -> bool { *self > 0.0 || (1.0 / *self) == infinity }\n+\n+    /// Returns `true` if the number is negative, including `-0.0` and `neg_infinity`\n+    #[inline(always)]\n+    fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == neg_infinity }\n+}\n+\n impl num::Round for f64 {\n     #[inline(always)]\n     fn round(&self, mode: num::RoundMode) -> f64 {\n         match mode {\n             num::RoundDown                           => floor(*self),\n             num::RoundUp                             => ceil(*self),\n-            num::RoundToZero   if is_negative(*self) => ceil(*self),\n+            num::RoundToZero   if self.is_negative() => ceil(*self),\n             num::RoundToZero                         => floor(*self),\n-            num::RoundFromZero if is_negative(*self) => floor(*self),\n+            num::RoundFromZero if self.is_negative() => floor(*self),\n             num::RoundFromZero                       => ceil(*self)\n         }\n     }\n@@ -376,7 +368,7 @@ impl num::Round for f64 {\n     fn ceil(&self) -> f64 { ceil(*self) }\n     #[inline(always)]\n     fn fract(&self) -> f64 {\n-        if is_negative(*self) {\n+        if self.is_negative() {\n             (*self) - ceil(*self)\n         } else {\n             (*self) - floor(*self)\n@@ -601,6 +593,50 @@ impl num::FromStrRadix for f64 {\n     }\n }\n \n+#[cfg(test)]\n+mod tests {\n+    use f64::*;\n+\n+    #[test]\n+    pub fn test_signed() {\n+        assert_eq!(infinity.abs(), infinity);\n+        assert_eq!(1f64.abs(), 1f64);\n+        assert_eq!(0f64.abs(), 0f64);\n+        assert_eq!((-0f64).abs(), 0f64);\n+        assert_eq!((-1f64).abs(), 1f64);\n+        assert_eq!(neg_infinity.abs(), infinity);\n+        assert_eq!((1f64/neg_infinity).abs(), 0f64);\n+        assert!(is_NaN(NaN.abs()));\n+\n+        assert_eq!(infinity.signum(), 1f64);\n+        assert_eq!(1f64.signum(), 1f64);\n+        assert_eq!(0f64.signum(), 1f64);\n+        assert_eq!((-0f64).signum(), -1f64);\n+        assert_eq!((-1f64).signum(), -1f64);\n+        assert_eq!(neg_infinity.signum(), -1f64);\n+        assert_eq!((1f64/neg_infinity).signum(), -1f64);\n+        assert!(is_NaN(NaN.signum()));\n+\n+        assert!(infinity.is_positive());\n+        assert!(1f64.is_positive());\n+        assert!(0f64.is_positive());\n+        assert!(!(-0f64).is_positive());\n+        assert!(!(-1f64).is_positive());\n+        assert!(!neg_infinity.is_positive());\n+        assert!(!(1f64/neg_infinity).is_positive());\n+        assert!(!NaN.is_positive());\n+\n+        assert!(!infinity.is_negative());\n+        assert!(!1f64.is_negative());\n+        assert!(!0f64.is_negative());\n+        assert!((-0f64).is_negative());\n+        assert!((-1f64).is_negative());\n+        assert!(neg_infinity.is_negative());\n+        assert!((1f64/neg_infinity).is_negative());\n+        assert!(!NaN.is_negative());\n+    }\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "036d295943c7bc1d54493681c8bae94e70b12458", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 74, "deletions": 60, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/aef249056e55ad2bf3d658609c440fad4a9255eb/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef249056e55ad2bf3d658609c440fad4a9255eb/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=aef249056e55ad2bf3d658609c440fad4a9255eb", "patch": "@@ -22,6 +22,7 @@\n \n use f64;\n use num::strconv;\n+use num::Signed;\n use num;\n use option::Option;\n use to_str;\n@@ -42,7 +43,6 @@ pub use f64::{erf, erfc, exp, expm1, exp2, abs_sub};\n pub use f64::{mul_add, fmax, fmin, nextafter, frexp, hypot, ldexp};\n pub use f64::{lgamma, ln, log_radix, ln1p, log10, log2, ilog_radix};\n pub use f64::{modf, pow, powi, round, sinh, tanh, tgamma, trunc};\n-pub use f64::signbit;\n pub use f64::{j0, j1, jn, y0, y1, yn};\n \n pub static NaN: float = 0.0/0.0;\n@@ -348,14 +348,6 @@ pub fn pow_with_uint(base: uint, pow: uint) -> float {\n     return total;\n }\n \n-#[inline(always)]\n-pub fn is_positive(x: float) -> bool { f64::is_positive(x as f64) }\n-#[inline(always)]\n-pub fn is_negative(x: float) -> bool { f64::is_negative(x as f64) }\n-#[inline(always)]\n-pub fn is_nonpositive(x: float) -> bool { f64::is_nonpositive(x as f64) }\n-#[inline(always)]\n-pub fn is_nonnegative(x: float) -> bool { f64::is_nonnegative(x as f64) }\n #[inline(always)]\n pub fn is_zero(x: float) -> bool { f64::is_zero(x as f64) }\n #[inline(always)]\n@@ -428,11 +420,11 @@ impl num::Round for float {\n                 => f64::floor(*self as f64) as float,\n             num::RoundUp\n                 => f64::ceil(*self as f64) as float,\n-            num::RoundToZero   if is_negative(*self)\n+            num::RoundToZero   if self.is_negative()\n                 => f64::ceil(*self as f64) as float,\n             num::RoundToZero\n                 => f64::floor(*self as f64) as float,\n-            num::RoundFromZero if is_negative(*self)\n+            num::RoundFromZero if self.is_negative()\n                 => f64::floor(*self as f64) as float,\n             num::RoundFromZero\n                 => f64::ceil(*self as f64) as float\n@@ -445,7 +437,7 @@ impl num::Round for float {\n     fn ceil(&self) -> float { f64::ceil(*self as f64) as float}\n     #[inline(always)]\n     fn fract(&self) -> float {\n-        if is_negative(*self) {\n+        if self.is_negative() {\n             (*self) - (f64::ceil(*self as f64) as float)\n         } else {\n             (*self) - (f64::floor(*self as f64) as float)\n@@ -501,10 +493,76 @@ impl Neg<float> for float {\n     fn neg(&self) -> float { -*self }\n }\n \n+impl Signed for float {\n+    /// Computes the absolute value. Returns `NaN` if the number is `NaN`.\n+    #[inline(always)]\n+    fn abs(&self) -> float { abs(*self) }\n+\n+    /**\n+     * # Returns\n+     *\n+     * - `1.0` if the number is positive, `+0.0` or `infinity`\n+     * - `-1.0` if the number is negative, `-0.0` or `neg_infinity`\n+     * - `NaN` if the number is NaN\n+     */\n+    #[inline(always)]\n+    fn signum(&self) -> float {\n+        if is_NaN(*self) { NaN } else { f64::copysign(1.0, *self as f64) as float }\n+    }\n+\n+    /// Returns `true` if the number is positive, including `+0.0` and `infinity`\n+    #[inline(always)]\n+    fn is_positive(&self) -> bool { *self > 0.0 || (1.0 / *self) == infinity }\n+\n+    /// Returns `true` if the number is negative, including `-0.0` and `neg_infinity`\n+    #[inline(always)]\n+    fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == neg_infinity }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n     use prelude::*;\n+\n+    #[test]\n+    pub fn test_signed() {\n+        assert_eq!(infinity.abs(), infinity);\n+        assert_eq!(1f.abs(), 1f);\n+        assert_eq!(0f.abs(), 0f);\n+        assert_eq!((-0f).abs(), 0f);\n+        assert_eq!((-1f).abs(), 1f);\n+        assert_eq!(neg_infinity.abs(), infinity);\n+        assert_eq!((1f/neg_infinity).abs(), 0f);\n+        assert!(is_NaN(NaN.abs()));\n+\n+        assert_eq!(infinity.signum(), 1f);\n+        assert_eq!(1f.signum(), 1f);\n+        assert_eq!(0f.signum(), 1f);\n+        assert_eq!((-0f).signum(), -1f);\n+        assert_eq!((-1f).signum(), -1f);\n+        assert_eq!(neg_infinity.signum(), -1f);\n+        assert_eq!((1f/neg_infinity).signum(), -1f);\n+        assert!(is_NaN(NaN.signum()));\n+\n+        assert!(infinity.is_positive());\n+        assert!(1f.is_positive());\n+        assert!(0f.is_positive());\n+        assert!(!(-0f).is_positive());\n+        assert!(!(-1f).is_positive());\n+        assert!(!neg_infinity.is_positive());\n+        assert!(!(1f/neg_infinity).is_positive());\n+        assert!(!NaN.is_positive());\n+\n+        assert!(!infinity.is_negative());\n+        assert!(!1f.is_negative());\n+        assert!(!0f.is_negative());\n+        assert!((-0f).is_negative());\n+        assert!((-1f).is_negative());\n+        assert!(neg_infinity.is_negative());\n+        assert!((1f/neg_infinity).is_negative());\n+        assert!(!NaN.is_negative());\n+    }\n+\n     #[test]\n     pub fn test_to_str_exact_do_decimal() {\n         let s = to_str_exact(5.0, 4u);\n@@ -538,11 +596,11 @@ mod tests {\n         }\n         // note: -0 == 0, hence these slightly more complex tests\n         match from_str(~\"-0\") {\n-            Some(v) if is_zero(v) => assert!(is_negative(v)),\n+            Some(v) if is_zero(v) => assert!(v.is_negative()),\n             _ => fail!()\n         }\n         match from_str(~\"0\") {\n-            Some(v) if is_zero(v) => assert!(is_positive(v)),\n+            Some(v) if is_zero(v) => assert!(v.is_positive()),\n             _ => fail!()\n         }\n \n@@ -585,11 +643,11 @@ mod tests {\n         }\n         // note: -0 == 0, hence these slightly more complex tests\n         match from_str_hex(~\"-0\") {\n-            Some(v) if is_zero(v) => assert!(is_negative(v)),\n+            Some(v) if is_zero(v) => assert!(v.is_negative()),\n             _ => fail!()\n         }\n         match from_str_hex(~\"0\") {\n-            Some(v) if is_zero(v) => assert!(is_positive(v)),\n+            Some(v) if is_zero(v) => assert!(v.is_positive()),\n             _ => fail!()\n         }\n         assert_eq!(from_str_hex(~\"e\"), Some(14.));\n@@ -641,50 +699,6 @@ mod tests {\n         assert_eq!(from_str_radix(~\"1000.001\", 2u), Some(8.125));\n     }\n \n-    #[test]\n-    pub fn test_positive() {\n-        assert!(is_positive(infinity));\n-        assert!(is_positive(1.));\n-        assert!(is_positive(0.));\n-        assert!(!is_positive(-1.));\n-        assert!(!is_positive(neg_infinity));\n-        assert!(!is_positive(1./neg_infinity));\n-        assert!(!is_positive(NaN));\n-    }\n-\n-    #[test]\n-    pub fn test_negative() {\n-        assert!(!is_negative(infinity));\n-        assert!(!is_negative(1.));\n-        assert!(!is_negative(0.));\n-        assert!(is_negative(-1.));\n-        assert!(is_negative(neg_infinity));\n-        assert!(is_negative(1./neg_infinity));\n-        assert!(!is_negative(NaN));\n-    }\n-\n-    #[test]\n-    pub fn test_nonpositive() {\n-        assert!(!is_nonpositive(infinity));\n-        assert!(!is_nonpositive(1.));\n-        assert!(!is_nonpositive(0.));\n-        assert!(is_nonpositive(-1.));\n-        assert!(is_nonpositive(neg_infinity));\n-        assert!(is_nonpositive(1./neg_infinity));\n-        assert!(!is_nonpositive(NaN));\n-    }\n-\n-    #[test]\n-    pub fn test_nonnegative() {\n-        assert!(is_nonnegative(infinity));\n-        assert!(is_nonnegative(1.));\n-        assert!(is_nonnegative(0.));\n-        assert!(!is_nonnegative(-1.));\n-        assert!(!is_nonnegative(neg_infinity));\n-        assert!(!is_nonnegative(1./neg_infinity));\n-        assert!(!is_nonnegative(NaN));\n-    }\n-\n     #[test]\n     pub fn test_to_str_inf() {\n         assert_eq!(to_str_digits(infinity, 10u), ~\"inf\");"}, {"sha": "d65cbb4cf92757ad416cc6c1c2d5fb1a67b0b5a8", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 56, "deletions": 12, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/aef249056e55ad2bf3d658609c440fad4a9255eb/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef249056e55ad2bf3d658609c440fad4a9255eb/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=aef249056e55ad2bf3d658609c440fad4a9255eb", "patch": "@@ -14,6 +14,7 @@ use to_str::ToStr;\n use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n+use num::Signed;\n use num;\n use prelude::*;\n \n@@ -70,15 +71,6 @@ pub fn ge(x: T, y: T) -> bool { x >= y }\n #[inline(always)]\n pub fn gt(x: T, y: T) -> bool { x > y }\n \n-#[inline(always)]\n-pub fn is_positive(x: T) -> bool { x > 0 as T }\n-#[inline(always)]\n-pub fn is_negative(x: T) -> bool { x < 0 as T }\n-#[inline(always)]\n-pub fn is_nonpositive(x: T) -> bool { x <= 0 as T }\n-#[inline(always)]\n-pub fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n-\n /**\n  * Iterate over the range [`lo`..`hi`)\n  *\n@@ -139,9 +131,7 @@ pub fn compl(i: T) -> T {\n \n /// Computes the absolute value\n #[inline(always)]\n-pub fn abs(i: T) -> T {\n-    if is_negative(i) { -i } else { i }\n-}\n+pub fn abs(i: T) -> T { i.abs() }\n \n #[cfg(notest)]\n impl Ord for T {\n@@ -225,6 +215,38 @@ impl Neg<T> for T {\n     fn neg(&self) -> T { -*self }\n }\n \n+impl Signed for T {\n+    /// Computes the absolute value\n+    #[inline(always)]\n+    fn abs(&self) -> T {\n+        if self.is_negative() { -*self } else { *self }\n+    }\n+\n+    /**\n+     * # Returns\n+     *\n+     * - `0` if the number is zero\n+     * - `1` if the number is positive\n+     * - `-1` if the number is negative\n+     */\n+    #[inline(always)]\n+    fn signum(&self) -> T {\n+        match *self {\n+            n if n > 0 =>  1,\n+            0          =>  0,\n+            _          => -1,\n+        }\n+    }\n+\n+    /// Returns true if the number is positive\n+    #[inline(always)]\n+    fn is_positive(&self) -> bool { *self > 0 }\n+\n+    /// Returns true if the number is negative\n+    #[inline(always)]\n+    fn is_negative(&self) -> bool { *self < 0 }\n+}\n+\n #[cfg(notest)]\n impl BitOr<T,T> for T {\n     #[inline(always)]\n@@ -344,6 +366,28 @@ mod tests {\n     use super::inst::T;\n     use prelude::*;\n \n+    #[test]\n+    pub fn test_signed() {\n+        assert_eq!((1 as T).abs(), 1 as T);\n+        assert_eq!((0 as T).abs(), 0 as T);\n+        assert_eq!((-1 as T).abs(), 1 as T);\n+\n+        assert_eq!((1 as T).signum(), 1 as T);\n+        assert_eq!((0 as T).signum(), 0 as T);\n+        assert_eq!((-0 as T).signum(), 0 as T);\n+        assert_eq!((-1 as T).signum(), -1 as T);\n+\n+        assert!((1 as T).is_positive());\n+        assert!(!(0 as T).is_positive());\n+        assert!(!(-0 as T).is_positive());\n+        assert!(!(-1 as T).is_positive());\n+\n+        assert!(!(1 as T).is_negative());\n+        assert!(!(0 as T).is_negative());\n+        assert!(!(-0 as T).is_negative());\n+        assert!((-1 as T).is_negative());\n+    }\n+\n     #[test]\n     fn test_bitwise_ops() {\n         assert_eq!(0b1110 as T, (0b1100 as T).bitor(&(0b1010 as T)));"}, {"sha": "ea0b290aac2ce82dfbcbd8310808ed59dec48814", "filename": "src/libcore/num/num.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aef249056e55ad2bf3d658609c440fad4a9255eb/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef249056e55ad2bf3d658609c440fad4a9255eb/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=aef249056e55ad2bf3d658609c440fad4a9255eb", "patch": "@@ -60,6 +60,17 @@ pub trait One {\n     fn one() -> Self;\n }\n \n+pub trait Signed: Num\n+                + Neg<Self> {\n+    fn abs(&self) -> Self;\n+    fn signum(&self) -> Self;\n+    fn is_positive(&self) -> bool;\n+    fn is_negative(&self) -> bool;\n+}\n+\n+pub trait Unsigned: Num {}\n+\n+// This should be moved into the default implementation for Signed::abs\n pub fn abs<T:Ord + Zero + Neg<T>>(v: T) -> T {\n     if v < Zero::zero() { v.neg() } else { v }\n }"}, {"sha": "41205145f1778c26ad9cc95fc1b8afd42b8d255b", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aef249056e55ad2bf3d658609c440fad4a9255eb/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef249056e55ad2bf3d658609c440fad4a9255eb/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=aef249056e55ad2bf3d658609c440fad4a9255eb", "patch": "@@ -15,6 +15,7 @@ use to_str::ToStr;\n use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n+use num::Unsigned;\n use num;\n use option::Option;\n use prelude::*;\n@@ -51,15 +52,6 @@ pub fn ge(x: T, y: T) -> bool { x >= y }\n #[inline(always)]\n pub fn gt(x: T, y: T) -> bool { x > y }\n \n-#[inline(always)]\n-pub fn is_positive(x: T) -> bool { x > 0 as T }\n-#[inline(always)]\n-pub fn is_negative(x: T) -> bool { x < 0 as T }\n-#[inline(always)]\n-pub fn is_nonpositive(x: T) -> bool { x <= 0 as T }\n-#[inline(always)]\n-pub fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n-\n #[inline(always)]\n /**\n  * Iterate over the range [`start`,`start`+`step`..`stop`)\n@@ -190,6 +182,8 @@ impl Neg<T> for T {\n     fn neg(&self) -> T { -*self }\n }\n \n+impl Unsigned for T {}\n+\n #[cfg(notest)]\n impl BitOr<T,T> for T {\n     #[inline(always)]"}, {"sha": "157a0e3752d7710232dd883188ec2e28260700e2", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aef249056e55ad2bf3d658609c440fad4a9255eb/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef249056e55ad2bf3d658609c440fad4a9255eb/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=aef249056e55ad2bf3d658609c440fad4a9255eb", "patch": "@@ -39,7 +39,7 @@ pub use hash::Hash;\n pub use iter::{BaseIter, ReverseIter, MutableIter, ExtendedIter, EqIter};\n pub use iter::{CopyableIter, CopyableOrderedIter, CopyableNonstrictIter};\n pub use iter::{Times, ExtendedMutableIter};\n-pub use num::{Num, NumCast};\n+pub use num::{Num, Signed, Unsigned, NumCast};\n pub use path::GenericPath;\n pub use path::Path;\n pub use path::PosixPath;"}, {"sha": "5f0fd76640a3024c917ddc1ab2495649fedf969b", "filename": "src/libstd/num/bigint.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/aef249056e55ad2bf3d658609c440fad4a9255eb/src%2Flibstd%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef249056e55ad2bf3d658609c440fad4a9255eb/src%2Flibstd%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fbigint.rs?ref=aef249056e55ad2bf3d658609c440fad4a9255eb", "patch": "@@ -154,6 +154,8 @@ impl One for BigUint {\n     pub fn one() -> BigUint { BigUint::new(~[1]) }\n }\n \n+impl Unsigned for BigUint {}\n+\n impl Add<BigUint, BigUint> for BigUint {\n     fn add(&self, other: &BigUint) -> BigUint {\n         let new_len = uint::max(self.data.len(), other.data.len());\n@@ -469,11 +471,8 @@ pub impl BigUint {\n     }\n \n     fn is_zero(&self) -> bool { self.data.is_empty() }\n+\n     fn is_not_zero(&self) -> bool { !self.data.is_empty() }\n-    fn is_positive(&self) -> bool { self.is_not_zero() }\n-    fn is_negative(&self) -> bool { false }\n-    fn is_nonpositive(&self) -> bool { self.is_zero() }\n-    fn is_nonnegative(&self) -> bool { true }\n \n     fn to_uint(&self) -> uint {\n         match self.data.len() {\n@@ -693,6 +692,27 @@ impl One for BigInt {\n     }\n }\n \n+impl Signed for BigInt {\n+    fn abs(&self) -> BigInt {\n+        match self.sign {\n+            Plus | Zero => copy *self,\n+            Minus => BigInt::from_biguint(Plus, copy self.data)\n+        }\n+    }\n+\n+    fn signum(&self) -> BigInt {\n+        match self.sign {\n+            Plus  => BigInt::from_biguint(Plus, One::one()),\n+            Minus => BigInt::from_biguint(Minus, One::one()),\n+            Zero  => Zero::zero(),\n+        }\n+    }\n+\n+    fn is_positive(&self) -> bool { self.sign == Plus }\n+\n+    fn is_negative(&self) -> bool { self.sign == Minus }\n+}\n+\n impl Add<BigInt, BigInt> for BigInt {\n     fn add(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n@@ -888,11 +908,8 @@ pub impl BigInt {\n     }\n \n     fn is_zero(&self) -> bool { self.sign == Zero }\n+\n     fn is_not_zero(&self) -> bool { self.sign != Zero }\n-    fn is_positive(&self) -> bool { self.sign == Plus }\n-    fn is_negative(&self) -> bool { self.sign == Minus }\n-    fn is_nonpositive(&self) -> bool { self.sign != Plus }\n-    fn is_nonnegative(&self) -> bool { self.sign != Minus }\n \n     fn to_uint(&self) -> uint {\n         match self.sign {"}, {"sha": "93c44b8faa128e2741df013f8a395153f1ce4ae4", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/aef249056e55ad2bf3d658609c440fad4a9255eb/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef249056e55ad2bf3d658609c440fad4a9255eb/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=aef249056e55ad2bf3d658609c440fad4a9255eb", "patch": "@@ -18,28 +18,28 @@ pub fn main() {\n     }\n \n     // Usable at all:\n-    let mut any_negative = do vec::any(v) |e| { float::is_negative(*e) };\n+    let mut any_negative = do vec::any(v) |e| { e.is_negative() };\n     assert!(any_negative);\n \n     // Higher precedence than assignments:\n-    any_negative = do vec::any(v) |e| { float::is_negative(*e) };\n+    any_negative = do vec::any(v) |e| { e.is_negative() };\n     assert!(any_negative);\n \n     // Higher precedence than unary operations:\n-    let abs_v = do vec::map(v) |e| { float::abs(*e) };\n-    assert!(do vec::all(abs_v) |e| { float::is_nonnegative(*e) });\n-    assert!(!do vec::any(abs_v) |e| { float::is_negative(*e) });\n+    let abs_v = do vec::map(v) |e| { e.abs() };\n+    assert!(do vec::all(abs_v) |e| { e.is_positive() });\n+    assert!(!do vec::any(abs_v) |e| { e.is_negative() });\n \n     // Usable in funny statement-like forms:\n-    if !do vec::any(v) |e| { float::is_positive(*e) } {\n+    if !do vec::any(v) |e| { e.is_positive() } {\n         assert!(false);\n     }\n-    match do vec::all(v) |e| { float::is_negative(*e) } {\n+    match do vec::all(v) |e| { e.is_negative() } {\n         true => { fail!(~\"incorrect answer.\"); }\n         false => { }\n     }\n     match 3 {\n-      _ if do vec::any(v) |e| { float::is_negative(*e) } => {\n+      _ if do vec::any(v) |e| { e.is_negative() } => {\n       }\n       _ => {\n         fail!(~\"wrong answer.\");\n@@ -56,7 +56,7 @@ pub fn main() {\n \n     // In the tail of a block\n     let w =\n-        if true { do vec::any(abs_v) |e| { float::is_nonnegative(*e) } }\n+        if true { do vec::any(abs_v) |e| { e.is_positive() } }\n       else { false };\n     assert!(w);\n }"}]}