{"sha": "ec0a64def54e0b381ede187bfe199b7620b56c45", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjMGE2NGRlZjU0ZTBiMzgxZWRlMTg3YmZlMTk5Yjc2MjBiNTZjNDU=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-07-10T23:40:09Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-09-06T20:35:12Z"}, "message": "memoization for resolve", "tree": {"sha": "a3134a36f7c1c82ffb2d83d97c6e182a4f61cc9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3134a36f7c1c82ffb2d83d97c6e182a4f61cc9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec0a64def54e0b381ede187bfe199b7620b56c45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec0a64def54e0b381ede187bfe199b7620b56c45", "html_url": "https://github.com/rust-lang/rust/commit/ec0a64def54e0b381ede187bfe199b7620b56c45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec0a64def54e0b381ede187bfe199b7620b56c45/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0954e66442a169be40f1e65de68a85d7e3dacf3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0954e66442a169be40f1e65de68a85d7e3dacf3a", "html_url": "https://github.com/rust-lang/rust/commit/0954e66442a169be40f1e65de68a85d7e3dacf3a"}], "stats": {"total": 133, "additions": 93, "deletions": 40}, "files": [{"sha": "e0d58c14a9af0a39e7f130f3b4dcc8a12fb1c07a", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 91, "deletions": 38, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/ec0a64def54e0b381ede187bfe199b7620b56c45/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec0a64def54e0b381ede187bfe199b7620b56c45/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=ec0a64def54e0b381ede187bfe199b7620b56c45", "patch": "@@ -915,30 +915,63 @@ fn idx_push<T>(vec: &mut ~[T], val: T) -> uint {\n \n /// Resolve a syntax object to a name, per MTWT.\n pub fn mtwt_resolve(id : Ident) -> Name {\n-    resolve_internal(id, get_sctable())\n+    resolve_internal(id, get_sctable(), get_resolve_table())\n+}\n+\n+// FIXME #4536: must be pub for testing\n+pub type ResolveTable = HashMap<(Name,SyntaxContext),Name>;\n+\n+// okay, I admit, putting this in TLS is not so nice:\n+// fetch the SCTable from TLS, create one if it doesn't yet exist.\n+pub fn get_resolve_table() -> @mut ResolveTable {\n+    static resolve_table_key: local_data::Key<@@mut ResolveTable> = &local_data::Key;\n+    match local_data::get(resolve_table_key, |k| k.map(|&k| *k)) {\n+        None => {\n+            let new_table = @@mut HashMap::new();\n+            local_data::set(resolve_table_key,new_table);\n+            *new_table\n+        },\n+        Some(intr) => *intr\n+    }\n }\n \n // Resolve a syntax object to a name, per MTWT.\n+// adding memoization to possibly resolve 500+ seconds in resolve for librustc (!)\n // FIXME #4536 : currently pub to allow testing\n-pub fn resolve_internal(id : Ident, table : &mut SCTable) -> Name {\n-    match table.table[id.ctxt] {\n-        EmptyCtxt => id.name,\n-        // ignore marks here:\n-        Mark(_,subctxt) => resolve_internal(Ident{name:id.name, ctxt: subctxt},table),\n-        // do the rename if necessary:\n-        Rename(Ident{name,ctxt},toname,subctxt) => {\n-            // this could be cached or computed eagerly:\n-            let resolvedfrom = resolve_internal(Ident{name:name,ctxt:ctxt},table);\n-            let resolvedthis = resolve_internal(Ident{name:id.name,ctxt:subctxt},table);\n-            if ((resolvedthis == resolvedfrom)\n-                && (marksof(ctxt,resolvedthis,table)\n-                    == marksof(subctxt,resolvedthis,table))) {\n-                toname\n-            } else {\n-                resolvedthis\n-            }\n+pub fn resolve_internal(id : Ident,\n+                        table : &mut SCTable,\n+                        resolve_table : &mut ResolveTable) -> Name {\n+    let key = (id.name,id.ctxt);\n+    match resolve_table.contains_key(&key) {\n+        false => {\n+            let resolved = {\n+                match table.table[id.ctxt] {\n+                    EmptyCtxt => id.name,\n+                    // ignore marks here:\n+                    Mark(_,subctxt) => resolve_internal(Ident{name:id.name, ctxt: subctxt},table,resolve_table),\n+                    // do the rename if necessary:\n+                    Rename(Ident{name,ctxt},toname,subctxt) => {\n+                        let resolvedfrom = resolve_internal(Ident{name:name,ctxt:ctxt},table,resolve_table);\n+                        let resolvedthis = resolve_internal(Ident{name:id.name,ctxt:subctxt},table,resolve_table);\n+                        if ((resolvedthis == resolvedfrom)\n+                            && (marksof(ctxt,resolvedthis,table)\n+                                == marksof(subctxt,resolvedthis,table))) {\n+                            toname\n+                        } else {\n+                            resolvedthis\n+                        }\n+                    }\n+                    IllegalCtxt() => fail!(~\"expected resolvable context, got IllegalCtxt\")\n+                }\n+            };\n+            resolve_table.insert(key,resolved);\n+            resolved\n+        }\n+        true => {\n+            // it's guaranteed to be there, because we just checked that it was\n+            // there and we never remove anything from the table:\n+            *(resolve_table.find(&key).unwrap())\n         }\n-        IllegalCtxt() => fail!(~\"expected resolvable context, got IllegalCtxt\")\n     }\n }\n \n@@ -1017,20 +1050,21 @@ mod test {\n     use super::*;\n     use std::io;\n     use opt_vec;\n+    use std::hash::HashMap;\n \n-    fn ident_to_segment(id : &ident) -> PathSegment {\n+    fn ident_to_segment(id : &Ident) -> PathSegment {\n         PathSegment{identifier:id.clone(), lifetime: None, types: opt_vec::Empty}\n     }\n \n     #[test] fn idents_name_eq_test() {\n-        assert!(segments_name_eq([ident{name:3,ctxt:4},\n-                                   ident{name:78,ctxt:82}].map(ident_to_segment),\n-                                 [ident{name:3,ctxt:104},\n-                                   ident{name:78,ctxt:182}].map(ident_to_segment)));\n-        assert!(!segments_name_eq([ident{name:3,ctxt:4},\n-                                    ident{name:78,ctxt:82}].map(ident_to_segment),\n-                                  [ident{name:3,ctxt:104},\n-                                    ident{name:77,ctxt:182}].map(ident_to_segment)));\n+        assert!(segments_name_eq([Ident{name:3,ctxt:4},\n+                                   Ident{name:78,ctxt:82}].map(ident_to_segment),\n+                                 [Ident{name:3,ctxt:104},\n+                                   Ident{name:78,ctxt:182}].map(ident_to_segment)));\n+        assert!(!segments_name_eq([Ident{name:3,ctxt:4},\n+                                    Ident{name:78,ctxt:82}].map(ident_to_segment),\n+                                  [Ident{name:3,ctxt:104},\n+                                    Ident{name:77,ctxt:182}].map(ident_to_segment)));\n     }\n \n     #[test] fn xorpush_test () {\n@@ -1162,52 +1196,59 @@ mod test {\n     #[test] fn resolve_tests () {\n         let a = 40;\n         let mut t = new_sctable_internal();\n+        let mut rt = HashMap::new();\n         // - ctxt is MT\n-        assert_eq!(resolve_internal(id(a,EMPTY_CTXT),&mut t),a);\n+        assert_eq!(resolve_internal(id(a,EMPTY_CTXT),&mut t, &mut rt),a);\n         // - simple ignored marks\n         { let sc = unfold_marks(~[1,2,3],EMPTY_CTXT,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t),a);}\n+         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),a);}\n         // - orthogonal rename where names don't match\n         { let sc = unfold_test_sc(~[R(id(50,EMPTY_CTXT),51),M(12)],EMPTY_CTXT,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t),a);}\n+         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),a);}\n         // - rename where names do match, but marks don't\n         { let sc1 = new_mark_internal(1,EMPTY_CTXT,&mut t);\n          let sc = unfold_test_sc(~[R(id(a,sc1),50),\n                                    M(1),\n                                    M(2)],\n                                  EMPTY_CTXT,&mut t);\n-        assert_eq!(resolve_internal(id(a,sc),&mut t), a);}\n+        assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), a);}\n         // - rename where names and marks match\n         { let sc1 = unfold_test_sc(~[M(1),M(2)],EMPTY_CTXT,&mut t);\n          let sc = unfold_test_sc(~[R(id(a,sc1),50),M(1),M(2)],EMPTY_CTXT,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t), 50); }\n+         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), 50); }\n         // - rename where names and marks match by literal sharing\n         { let sc1 = unfold_test_sc(~[M(1),M(2)],EMPTY_CTXT,&mut t);\n          let sc = unfold_test_sc(~[R(id(a,sc1),50)],sc1,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t), 50); }\n+         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), 50); }\n         // - two renames of the same var.. can only happen if you use\n         // local-expand to prevent the inner binding from being renamed\n         // during the rename-pass caused by the first:\n         io::println(\"about to run bad test\");\n         { let sc = unfold_test_sc(~[R(id(a,EMPTY_CTXT),50),\n                                     R(id(a,EMPTY_CTXT),51)],\n                                   EMPTY_CTXT,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t), 51); }\n+         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), 51); }\n         // the simplest double-rename:\n         { let a_to_a50 = new_rename_internal(id(a,EMPTY_CTXT),50,EMPTY_CTXT,&mut t);\n          let a50_to_a51 = new_rename_internal(id(a,a_to_a50),51,a_to_a50,&mut t);\n-         assert_eq!(resolve_internal(id(a,a50_to_a51),&mut t),51);\n+         assert_eq!(resolve_internal(id(a,a50_to_a51),&mut t, &mut rt),51);\n          // mark on the outside doesn't stop rename:\n          let sc = new_mark_internal(9,a50_to_a51,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t),51);\n+         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),51);\n          // but mark on the inside does:\n          let a50_to_a51_b = unfold_test_sc(~[R(id(a,a_to_a50),51),\n                                               M(9)],\n                                            a_to_a50,\n                                            &mut t);\n-         assert_eq!(resolve_internal(id(a,a50_to_a51_b),&mut t),50);}\n+         assert_eq!(resolve_internal(id(a,a50_to_a51_b),&mut t, &mut rt),50);}\n+    }\n+\n+    #[test] fn mtwt_resolve_test(){\n+        let a = 40;\n+        assert_eq!(mtwt_resolve(id(a,EMPTY_CTXT)),a);\n     }\n \n+\n     #[test] fn hashing_tests () {\n         let mut t = new_sctable_internal();\n         assert_eq!(new_mark_internal(12,EMPTY_CTXT,&mut t),2);\n@@ -1217,4 +1258,16 @@ mod test {\n         // I'm assuming that the rename table will behave the same....\n     }\n \n+    #[test] fn resolve_table_hashing_tests() {\n+        let mut t = new_sctable_internal();\n+        let mut rt = HashMap::new();\n+        assert_eq!(rt.len(),0);\n+        resolve_internal(id(30,EMPTY_CTXT),&mut t, &mut rt);\n+        assert_eq!(rt.len(),1);\n+        resolve_internal(id(39,EMPTY_CTXT),&mut t, &mut rt);\n+        assert_eq!(rt.len(),2);\n+        resolve_internal(id(30,EMPTY_CTXT),&mut t, &mut rt);\n+        assert_eq!(rt.len(),2);\n+    }\n+\n }"}, {"sha": "aa26feec28c9c25866a45c3749c60cd855bc5e49", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec0a64def54e0b381ede187bfe199b7620b56c45/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec0a64def54e0b381ede187bfe199b7620b56c45/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=ec0a64def54e0b381ede187bfe199b7620b56c45", "patch": "@@ -737,8 +737,8 @@ mod test {\n     use ast;\n     use ast_util;\n \n-    fn mark_ident(id : ast::ident, m : ast::Mrk) -> ast::ident {\n-        ast::ident{name:id.name,ctxt:ast_util::new_mark(m,id.ctxt)}\n+    fn mark_ident(id : ast::Ident, m : ast::Mrk) -> ast::Ident {\n+        ast::Ident{name:id.name,ctxt:ast_util::new_mark(m,id.ctxt)}\n     }\n \n     #[test] fn mtwt_token_eq_test() {"}]}