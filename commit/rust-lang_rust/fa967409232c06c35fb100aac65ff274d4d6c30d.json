{"sha": "fa967409232c06c35fb100aac65ff274d4d6c30d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhOTY3NDA5MjMyYzA2YzM1ZmIxMDBhYWM2NWZmMjc0ZDRkNmMzMGQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-06T03:33:37Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-06T03:33:37Z"}, "message": "librustc: Remove some string allocations. rs=perf", "tree": {"sha": "18fcd1c8203fa072e3fc6dd4cbd350b3f029b3d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18fcd1c8203fa072e3fc6dd4cbd350b3f029b3d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa967409232c06c35fb100aac65ff274d4d6c30d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa967409232c06c35fb100aac65ff274d4d6c30d", "html_url": "https://github.com/rust-lang/rust/commit/fa967409232c06c35fb100aac65ff274d4d6c30d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa967409232c06c35fb100aac65ff274d4d6c30d/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1070cc0109661d9f47a6e2c39ad853041ddf30e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/1070cc0109661d9f47a6e2c39ad853041ddf30e2", "html_url": "https://github.com/rust-lang/rust/commit/1070cc0109661d9f47a6e2c39ad853041ddf30e2"}], "stats": {"total": 182, "additions": 97, "deletions": 85}, "files": [{"sha": "f7c2503df7c563c88f1131b525700f195054702e", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fa967409232c06c35fb100aac65ff274d4d6c30d/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa967409232c06c35fb100aac65ff274d4d6c30d/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=fa967409232c06c35fb100aac65ff274d4d6c30d", "patch": "@@ -105,12 +105,12 @@ impl lint : cmp::Eq {\n     pure fn ne(&self, other: &lint) -> bool { !(*self).eq(other) }\n }\n \n-fn level_to_str(lv: level) -> ~str {\n+fn level_to_str(lv: level) -> &static/str {\n     match lv {\n-      allow => ~\"allow\",\n-      warn => ~\"warn\",\n-      deny => ~\"deny\",\n-      forbid => ~\"forbid\"\n+      allow => \"allow\",\n+      warn => \"warn\",\n+      deny => \"deny\",\n+      forbid => \"forbid\"\n     }\n }\n \n@@ -126,7 +126,7 @@ impl level : cmp::Eq {\n }\n \n type lint_spec = @{lint: lint,\n-                   desc: ~str,\n+                   desc: &static/str,\n                    default: level};\n \n type lint_dict = HashMap<~str,lint_spec>;\n@@ -139,109 +139,109 @@ fn get_lint_dict() -> lint_dict {\n     let v = ~[\n         (~\"ctypes\",\n          @{lint: ctypes,\n-           desc: ~\"proper use of core::libc types in foreign modules\",\n+           desc: \"proper use of core::libc types in foreign modules\",\n            default: warn}),\n \n         (~\"unused_imports\",\n          @{lint: unused_imports,\n-           desc: ~\"imports that are never used\",\n+           desc: \"imports that are never used\",\n            default: allow}),\n \n         (~\"while_true\",\n          @{lint: while_true,\n-           desc: ~\"suggest using loop { } instead of while(true) { }\",\n+           desc: \"suggest using loop { } instead of while(true) { }\",\n            default: warn}),\n \n         (~\"path_statement\",\n          @{lint: path_statement,\n-           desc: ~\"path statements with no effect\",\n+           desc: \"path statements with no effect\",\n            default: warn}),\n \n         (~\"unrecognized_lint\",\n          @{lint: unrecognized_lint,\n-           desc: ~\"unrecognized lint attribute\",\n+           desc: \"unrecognized lint attribute\",\n            default: warn}),\n \n         (~\"non_implicitly_copyable_typarams\",\n          @{lint: non_implicitly_copyable_typarams,\n-           desc: ~\"passing non implicitly copyable types as copy type params\",\n+           desc: \"passing non implicitly copyable types as copy type params\",\n            default: warn}),\n \n         (~\"vecs_implicitly_copyable\",\n          @{lint: vecs_implicitly_copyable,\n-           desc: ~\"make vecs and strs not implicitly copyable \\\n+           desc: \"make vecs and strs not implicitly copyable \\\n                   (only checked at top level)\",\n            default: warn}),\n \n         (~\"implicit_copies\",\n          @{lint: implicit_copies,\n-           desc: ~\"implicit copies of non implicitly copyable data\",\n+           desc: \"implicit copies of non implicitly copyable data\",\n            default: warn}),\n \n         (~\"deprecated_mode\",\n          @{lint: deprecated_mode,\n-           desc: ~\"warn about deprecated uses of modes\",\n+           desc: \"warn about deprecated uses of modes\",\n            default: warn}),\n \n         (~\"deprecated_pattern\",\n          @{lint: deprecated_pattern,\n-           desc: ~\"warn about deprecated uses of pattern bindings\",\n+           desc: \"warn about deprecated uses of pattern bindings\",\n            default: allow}),\n \n         (~\"non_camel_case_types\",\n          @{lint: non_camel_case_types,\n-           desc: ~\"types, variants and traits should have camel case names\",\n+           desc: \"types, variants and traits should have camel case names\",\n            default: allow}),\n \n         (~\"managed_heap_memory\",\n          @{lint: managed_heap_memory,\n-           desc: ~\"use of managed (@ type) heap memory\",\n+           desc: \"use of managed (@ type) heap memory\",\n            default: allow}),\n \n         (~\"owned_heap_memory\",\n          @{lint: owned_heap_memory,\n-           desc: ~\"use of owned (~ type) heap memory\",\n+           desc: \"use of owned (~ type) heap memory\",\n            default: allow}),\n \n         (~\"heap_memory\",\n          @{lint: heap_memory,\n-           desc: ~\"use of any (~ type or @ type) heap memory\",\n+           desc: \"use of any (~ type or @ type) heap memory\",\n            default: allow}),\n \n         (~\"structural_records\",\n          @{lint: structural_records,\n-           desc: ~\"use of any structural records\",\n+           desc: \"use of any structural records\",\n            default: allow}),\n \n         (~\"legacy modes\",\n          @{lint: legacy_modes,\n-           desc: ~\"allow legacy modes\",\n+           desc: \"allow legacy modes\",\n            default: forbid}),\n \n         (~\"type_limits\",\n          @{lint: type_limits,\n-           desc: ~\"comparisons made useless by limits of the types involved\",\n+           desc: \"comparisons made useless by limits of the types involved\",\n            default: warn}),\n \n         (~\"default_methods\",\n          @{lint: default_methods,\n-           desc: ~\"allow default methods\",\n+           desc: \"allow default methods\",\n            default: deny}),\n \n         (~\"deprecated_self\",\n          @{lint: deprecated_self,\n-           desc: ~\"warn about deprecated uses of `self`\",\n+           desc: \"warn about deprecated uses of `self`\",\n            default: allow}),\n \n         /* FIXME(#3266)--make liveness warnings lintable\n         (~\"unused_variable\",\n          @{lint: unused_variable,\n-           desc: ~\"detect variables which are not used in any way\",\n+           desc: \"detect variables which are not used in any way\",\n            default: warn}),\n \n         (~\"dead_assignment\",\n          @{lint: dead_assignment,\n-           desc: ~\"detect assignments that will never be read\",\n+           desc: \"detect assignments that will never be read\",\n            default: warn}),\n         */\n     ];"}, {"sha": "623ba734c91e9bdceb3ef88e8657e67487ae83eb", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 33, "deletions": 23, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/fa967409232c06c35fb100aac65ff274d4d6c30d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa967409232c06c35fb100aac65ff274d4d6c30d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=fa967409232c06c35fb100aac65ff274d4d6c30d", "patch": "@@ -33,6 +33,7 @@ use core::dvec::DVec;\n use core::dvec;\n use core::ops;\n use core::option;\n+use core::ptr::to_unsafe_ptr;\n use core::result::Result;\n use core::result;\n use core::to_bytes;\n@@ -304,18 +305,22 @@ impl creader_cache_key : to_bytes::IterBytes {\n     }\n }\n \n-type intern_key = {sty: sty, o_def_id: Option<ast::def_id>};\n+type intern_key = {sty: *sty, o_def_id: Option<ast::def_id>};\n \n impl intern_key : cmp::Eq {\n     pure fn eq(&self, other: &intern_key) -> bool {\n-        (*self).sty == (*other).sty && (*self).o_def_id == (*other).o_def_id\n+        unsafe {\n+            *self.sty == *other.sty && self.o_def_id == other.o_def_id\n+        }\n     }\n     pure fn ne(&self, other: &intern_key) -> bool { !(*self).eq(other) }\n }\n \n impl intern_key : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_2(&self.sty, &self.o_def_id, lsb0, f);\n+        unsafe {\n+            to_bytes::iter_bytes_2(&*self.sty, &self.o_def_id, lsb0, f);\n+        }\n     }\n }\n \n@@ -1008,11 +1013,12 @@ fn mk_t(cx: ctxt, +st: sty) -> t { mk_t_with_id(cx, st, None) }\n // Interns a type/name combination, stores the resulting box in cx.interner,\n // and returns the box as cast to an unsafe ptr (see comments for t above).\n fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n-    let key = {sty: st, o_def_id: o_def_id};\n+    let key = {sty: to_unsafe_ptr(&st), o_def_id: o_def_id};\n     match cx.interner.find(key) {\n       Some(t) => unsafe { return cast::reinterpret_cast(&t); },\n       _ => ()\n     }\n+\n     let mut flags = 0u;\n     fn rflags(r: Region) -> uint {\n         (has_regions as uint) | {\n@@ -1028,42 +1034,46 @@ fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n         substs.self_r.iter(|r| f |= rflags(*r));\n         return f;\n     }\n-    match st {\n-      ty_estr(vstore_slice(r)) => {\n+    match &st {\n+      &ty_estr(vstore_slice(r)) => {\n         flags |= rflags(r);\n       }\n-      ty_evec(mt, vstore_slice(r)) => {\n+      &ty_evec(ref mt, vstore_slice(r)) => {\n         flags |= rflags(r);\n         flags |= get(mt.ty).flags;\n       }\n-      ty_nil | ty_bot | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n-      ty_estr(_) | ty_type | ty_opaque_closure_ptr(_) |\n-      ty_opaque_box | ty_err => (),\n-      ty_param(_) => flags |= has_params as uint,\n-      ty_infer(_) => flags |= needs_infer as uint,\n-      ty_self => flags |= has_self as uint,\n-      ty_enum(_, ref substs) | ty_struct(_, ref substs)\n-      | ty_trait(_, ref substs, _) => {\n+      &ty_nil | &ty_bot | &ty_bool | &ty_int(_) | &ty_float(_) | &ty_uint(_) |\n+      &ty_estr(_) | &ty_type | &ty_opaque_closure_ptr(_) |\n+      &ty_opaque_box | &ty_err => (),\n+      &ty_param(_) => flags |= has_params as uint,\n+      &ty_infer(_) => flags |= needs_infer as uint,\n+      &ty_self => flags |= has_self as uint,\n+      &ty_enum(_, ref substs) | &ty_struct(_, ref substs) |\n+      &ty_trait(_, ref substs, _) => {\n         flags |= sflags(substs);\n       }\n-      ty_box(m) | ty_uniq(m) | ty_evec(m, _) |\n-      ty_ptr(m) | ty_unboxed_vec(m) => {\n+      &ty_box(ref m) | &ty_uniq(ref m) | &ty_evec(ref m, _) |\n+      &ty_ptr(ref m) | &ty_unboxed_vec(ref m) => {\n         flags |= get(m.ty).flags;\n       }\n-      ty_rptr(r, m) => {\n+      &ty_rptr(r, ref m) => {\n         flags |= rflags(r);\n         flags |= get(m.ty).flags;\n       }\n-      ty_rec(flds) => for flds.each |f| { flags |= get(f.mt.ty).flags; },\n-      ty_tup(ts) => for ts.each |tt| { flags |= get(*tt).flags; },\n-      ty_fn(ref f) => {\n+      &ty_rec(ref flds) => for flds.each |f| { flags |= get(f.mt.ty).flags; },\n+      &ty_tup(ref ts) => for ts.each |tt| { flags |= get(*tt).flags; },\n+      &ty_fn(ref f) => {\n         flags |= rflags(f.meta.region);\n         for f.sig.inputs.each |a| { flags |= get(a.ty).flags; }\n         flags |= get(f.sig.output).flags;\n       }\n     }\n-    let t = @{sty: st, id: cx.next_id, flags: flags, o_def_id: o_def_id};\n-    cx.interner.insert(key, t);\n+\n+    let t = @{sty: move st, id: cx.next_id, flags: flags, o_def_id: o_def_id};\n+\n+    let key = {sty: to_unsafe_ptr(&t.sty), o_def_id: o_def_id};\n+    cx.interner.insert(move key, t);\n+\n     cx.next_id += 1u;\n     unsafe { cast::reinterpret_cast(&t) }\n }"}, {"sha": "6505b7f8384d601772745f43460d79e426ef6725", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa967409232c06c35fb100aac65ff274d4d6c30d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa967409232c06c35fb100aac65ff274d4d6c30d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=fa967409232c06c35fb100aac65ff274d4d6c30d", "patch": "@@ -54,6 +54,8 @@\n // terms of error reporting, although we do not do that properly right\n // now.\n \n+#[warn(vecs_implicitly_copyable)];\n+\n use middle::ty;\n use middle::ty::{FnTyBase, FnMeta, FnSig};\n use middle::typeck::infer::sub::Sub;"}, {"sha": "5515c534d110d28c4c96b4ab457f51ae52ae4409", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/fa967409232c06c35fb100aac65ff274d4d6c30d/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa967409232c06c35fb100aac65ff274d4d6c30d/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=fa967409232c06c35fb100aac65ff274d4d6c30d", "patch": "@@ -69,16 +69,16 @@ fn explain_region_and_span(cx: ctxt, region: ty::Region)\n       re_scope(node_id) => {\n         match cx.items.find(node_id) {\n           Some(ast_map::node_block(ref blk)) => {\n-            explain_span(cx, ~\"block\", (*blk).span)\n+            explain_span(cx, \"block\", (*blk).span)\n           }\n           Some(ast_map::node_expr(expr)) => {\n             match expr.node {\n-              ast::expr_call(*) => explain_span(cx, ~\"call\", expr.span),\n+              ast::expr_call(*) => explain_span(cx, \"call\", expr.span),\n               ast::expr_method_call(*) => {\n-                explain_span(cx, ~\"method call\", expr.span)\n+                explain_span(cx, \"method call\", expr.span)\n               },\n-              ast::expr_match(*) => explain_span(cx, ~\"match\", expr.span),\n-              _ => explain_span(cx, ~\"expression\", expr.span)\n+              ast::expr_match(*) => explain_span(cx, \"match\", expr.span),\n+              _ => explain_span(cx, \"expression\", expr.span)\n             }\n           }\n           Some(_) | None => {\n@@ -99,7 +99,7 @@ fn explain_region_and_span(cx: ctxt, region: ty::Region)\n \n         match cx.items.find(id) {\n           Some(ast_map::node_block(ref blk)) => {\n-            let (msg, opt_span) = explain_span(cx, ~\"block\", (*blk).span);\n+            let (msg, opt_span) = explain_span(cx, \"block\", (*blk).span);\n             (fmt!(\"%s %s\", prefix, msg), opt_span)\n           }\n           Some(_) | None => {\n@@ -118,7 +118,7 @@ fn explain_region_and_span(cx: ctxt, region: ty::Region)\n       }\n     };\n \n-    fn explain_span(cx: ctxt, heading: ~str, span: span)\n+    fn explain_span(cx: ctxt, heading: &str, span: span)\n         -> (~str, Option<span>)\n     {\n         let lo = cx.sess.codemap.lookup_char_pos_adj(span.lo);\n@@ -128,17 +128,17 @@ fn explain_region_and_span(cx: ctxt, region: ty::Region)\n }\n \n fn bound_region_to_str(cx: ctxt, br: bound_region) -> ~str {\n-    bound_region_to_str_adorned(cx, ~\"&\", br, ~\"\")\n+    bound_region_to_str_adorned(cx, \"&\", br, \"\")\n }\n \n-fn bound_region_to_str_adorned(cx: ctxt, prefix: ~str,\n-                               br: bound_region, sep: ~str) -> ~str {\n+fn bound_region_to_str_adorned(cx: ctxt, prefix: &str,\n+                               br: bound_region, sep: &str) -> ~str {\n     if cx.sess.verbose() { return fmt!(\"%s%?%s\", prefix, br, sep); }\n \n     match br {\n       br_named(id)         => fmt!(\"%s%s%s\", prefix, cx.sess.str_of(id), sep),\n       br_self              => fmt!(\"%sself%s\", prefix, sep),\n-      br_anon(_)           => prefix,\n+      br_anon(_)           => prefix.to_str(),\n       br_cap_avoid(_, br)  => bound_region_to_str_adorned(cx, prefix,\n                                                           *br, sep)\n     }\n@@ -188,11 +188,11 @@ fn re_scope_id_to_str(cx: ctxt, node_id: ast::node_id) -> ~str {\n // you should use `explain_region()` or, better yet,\n // `note_and_explain_region()`\n fn region_to_str(cx: ctxt, region: Region) -> ~str {\n-    region_to_str_adorned(cx, ~\"&\", region, ~\"\")\n+    region_to_str_adorned(cx, \"&\", region, \"\")\n }\n \n-fn region_to_str_adorned(cx: ctxt, prefix: ~str,\n-                         region: Region, sep: ~str) -> ~str {\n+fn region_to_str_adorned(cx: ctxt, prefix: &str,\n+                         region: Region, sep: &str) -> ~str {\n     if cx.sess.verbose() {\n         return fmt!(\"%s%?%s\", prefix, region, sep);\n     }\n@@ -202,24 +202,24 @@ fn region_to_str_adorned(cx: ctxt, prefix: ~str,\n     // to fit that into a short string.  Hence the recommendation to use\n     // `explain_region()` or `note_and_explain_region()`.\n     match region {\n-        re_scope(_) => prefix,\n+        re_scope(_) => prefix.to_str(),\n         re_bound(br) => bound_region_to_str_adorned(cx, prefix, br, sep),\n         re_free(_, br) => bound_region_to_str_adorned(cx, prefix, br, sep),\n         re_infer(ReSkolemized(_, br)) => {\n             bound_region_to_str_adorned(cx, prefix, br, sep)\n         }\n-        re_infer(ReVar(_)) => prefix,\n+        re_infer(ReVar(_)) => prefix.to_str(),\n         re_static => fmt!(\"%sstatic%s\", prefix, sep)\n     }\n }\n \n fn mt_to_str(cx: ctxt, m: mt) -> ~str {\n     let mstr = match m.mutbl {\n-      ast::m_mutbl => ~\"mut \",\n-      ast::m_imm => ~\"\",\n-      ast::m_const => ~\"const \"\n+      ast::m_mutbl => \"mut \",\n+      ast::m_imm => \"\",\n+      ast::m_const => \"const \"\n     };\n-    return mstr + ty_to_str(cx, m.ty);\n+    return fmt!(\"%s%s\", mstr, ty_to_str(cx, m.ty));\n }\n \n fn vstore_to_str(cx: ctxt, vs: ty::vstore) -> ~str {\n@@ -243,12 +243,12 @@ fn vstore_ty_to_str(cx: ctxt, ty: ~str, vs: ty::vstore) -> ~str {\n     }\n }\n \n-fn proto_ty_to_str(_cx: ctxt, proto: ast::Proto) -> ~str {\n+fn proto_ty_to_str(_cx: ctxt, proto: ast::Proto) -> &static/str {\n     match proto {\n-        ast::ProtoBare => ~\"\",\n-        ast::ProtoBox => ~\"@\",\n-        ast::ProtoBorrowed => ~\"&\",\n-        ast::ProtoUniq => ~\"~\",\n+        ast::ProtoBare => \"\",\n+        ast::ProtoBox => \"@\",\n+        ast::ProtoBorrowed => \"&\",\n+        ast::ProtoUniq => \"~\",\n     }\n }\n \n@@ -278,11 +278,11 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n                 m == ty::default_arg_mode_for_ty(cx, ty) {\n                 ~\"\"\n             } else {\n-                mode_to_str(ast::expl(m)) + \":\"\n+                mode_to_str(ast::expl(m)) + ~\":\"\n             }\n           }\n         };\n-        modestr + ty_to_str(cx, ty)\n+        fmt!(\"%s%s\", modestr, ty_to_str(cx, ty))\n     }\n     fn fn_to_str(cx: ctxt,\n                  proto: ast::Proto,\n@@ -442,7 +442,7 @@ fn parameterized(cx: ctxt,\n \n     if vec::len(tps) > 0u {\n         let strs = vec::map(tps, |t| ty_to_str(cx, *t));\n-        fmt!(\"%s%s<%s>\", base, r_str, str::connect(strs, ~\",\"))\n+        fmt!(\"%s%s<%s>\", base, r_str, str::connect(strs, \",\"))\n     } else {\n         fmt!(\"%s%s\", base, r_str)\n     }"}, {"sha": "73c14e2d00cf2a8934e22287169c9215140b52e7", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fa967409232c06c35fb100aac65ff274d4d6c30d/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa967409232c06c35fb100aac65ff274d4d6c30d/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=fa967409232c06c35fb100aac65ff274d4d6c30d", "patch": "@@ -178,15 +178,15 @@ fn get_name_value_str_pair(item: @ast::meta_item) -> Option<(~str, ~str)> {\n /* Searching */\n \n /// Search a list of attributes and return only those with a specific name\n-fn find_attrs_by_name(attrs: ~[ast::attribute], name: ~str) ->\n+fn find_attrs_by_name(attrs: ~[ast::attribute], name: &str) ->\n    ~[ast::attribute] {\n-    let filter = (\n-        fn@(a: &ast::attribute) -> Option<ast::attribute> {\n-            if get_attr_name(*a) == name {\n-                option::Some(*a)\n-            } else { option::None }\n+    let filter: &fn(a: &ast::attribute) -> Option<ast::attribute> = |a| {\n+        if name == get_attr_name(*a) {\n+            option::Some(*a)\n+        } else {\n+            option::None\n         }\n-    );\n+    };\n     return vec::filter_map(attrs, filter);\n }\n "}]}