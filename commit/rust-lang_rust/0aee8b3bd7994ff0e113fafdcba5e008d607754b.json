{"sha": "0aee8b3bd7994ff0e113fafdcba5e008d607754b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhZWU4YjNiZDc5OTRmZjBlMTEzZmFmZGNiYTVlMDA4ZDYwNzc1NGI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-18T22:36:14Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-18T22:36:14Z"}, "message": "rustc: Thread statement contexts through unification", "tree": {"sha": "09d0d77bd9db2291335fb60727b9606905033547", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09d0d77bd9db2291335fb60727b9606905033547"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0aee8b3bd7994ff0e113fafdcba5e008d607754b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0aee8b3bd7994ff0e113fafdcba5e008d607754b", "html_url": "https://github.com/rust-lang/rust/commit/0aee8b3bd7994ff0e113fafdcba5e008d607754b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0aee8b3bd7994ff0e113fafdcba5e008d607754b/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb7d4e15a82fca797a6f0faa812377ebde0baa13", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb7d4e15a82fca797a6f0faa812377ebde0baa13", "html_url": "https://github.com/rust-lang/rust/commit/bb7d4e15a82fca797a6f0faa812377ebde0baa13"}], "stats": {"total": 214, "additions": 107, "deletions": 107}, "files": [{"sha": "c8229e6c84999f0a5788e882b8c2c00d821ecf46", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 107, "deletions": 107, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/0aee8b3bd7994ff0e113fafdcba5e008d607754b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aee8b3bd7994ff0e113fafdcba5e008d607754b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=0aee8b3bd7994ff0e113fafdcba5e008d607754b", "patch": "@@ -854,35 +854,37 @@ mod collect {\n // Type unification\n \n mod unify {\n-    fn simple(&@fn_ctxt fcx, &ty::t expected,\n-              &ty::t actual) -> ty::unify::result {\n+    fn simple(&@stmt_ctxt scx, &ty::t expected, &ty::t actual)\n+            -> ty::unify::result {\n         // FIXME: horrid botch\n         let vec[mutable ty::t] param_substs =\n-            [mutable ty::mk_nil(fcx.ccx.tcx)];\n+            [mutable ty::mk_nil(scx.fcx.ccx.tcx)];\n         vec::pop(param_substs);\n-        ret with_params(fcx, expected, actual, param_substs);\n+        ret with_params(scx, expected, actual, param_substs);\n     }\n \n-    fn with_params(&@fn_ctxt fcx, &ty::t expected, &ty::t actual,\n+    fn with_params(&@stmt_ctxt scx,\n+                   &ty::t expected,\n+                   &ty::t actual,\n                    &vec[mutable ty::t] param_substs) -> ty::unify::result {\n         auto cache_key = tup(expected, actual, param_substs);\n-        alt (fcx.ccx.unify_cache.find(cache_key)) {\n+        alt (scx.fcx.ccx.unify_cache.find(cache_key)) {\n             case (some[ty::unify::result](?r)) {\n-                fcx.ccx.cache_hits += 1u;\n+                scx.fcx.ccx.cache_hits += 1u;\n                 ret r;\n             }\n             case (none[ty::unify::result]) {\n-                fcx.ccx.cache_misses += 1u;\n+                scx.fcx.ccx.cache_misses += 1u;\n             }\n         }\n \n-        obj unify_handler(@fn_ctxt fcx, vec[mutable ty::t] param_substs) {\n+        obj unify_handler(@stmt_ctxt scx, vec[mutable ty::t] param_substs) {\n             fn resolve_local(ast::def_id id) -> option::t[ty::t] {\n-                alt (fcx.locals.find(id)) {\n+                alt (scx.fcx.locals.find(id)) {\n                     case (none[ty::t]) { ret none[ty::t]; }\n                     case (some[ty::t](?existing_type)) {\n-                        if (ty::type_contains_vars(fcx.ccx.tcx,\n-                                                  existing_type)) {\n+                        if (ty::type_contains_vars(scx.fcx.ccx.tcx,\n+                                                   existing_type)) {\n                             // Not fully resolved yet. The writeback phase\n                             // will mop up.\n                             ret none[ty::t];\n@@ -893,10 +895,10 @@ mod unify {\n             }\n             fn record_local(ast::def_id id, ty::t new_type) {\n                 auto unified_type;\n-                alt (fcx.locals.find(id)) {\n+                alt (scx.fcx.locals.find(id)) {\n                     case (none[ty::t]) { unified_type = new_type; }\n                     case (some[ty::t](?old_type)) {\n-                        alt (with_params(fcx, old_type, new_type,\n+                        alt (with_params(scx, old_type, new_type,\n                                          param_substs)) {\n                             case (ures_ok(?ut)) { unified_type = ut; }\n                             case (_) { fail; /* FIXME */ }\n@@ -910,46 +912,47 @@ mod unify {\n                     param_substs_1 += [subst];\n                 }\n \n-                unified_type =\n-                    ty::substitute_type_params(fcx.ccx.tcx, param_substs_1,\n-                                              unified_type);\n-                fcx.locals.insert(id, unified_type);\n+                unified_type = ty::substitute_type_params(scx.fcx.ccx.tcx,\n+                                                          param_substs_1,\n+                                                          unified_type);\n+                scx.fcx.locals.insert(id, unified_type);\n             }\n             fn record_param(uint index, ty::t binding) -> ty::unify::result {\n                 // Unify with the appropriate type in the parameter\n                 // substitution list:\n                 auto old_subst = param_substs.(index);\n \n-                auto result = with_params(fcx, old_subst, binding,\n+                auto result = with_params(scx, old_subst, binding,\n                                           param_substs);\n                 alt (result) {\n                     case (ures_ok(?new_subst)) {\n                         param_substs.(index) = new_subst;\n-                        ret ures_ok(ty::mk_bound_param(fcx.ccx.tcx, index));\n+                        ret ures_ok(ty::mk_bound_param(scx.fcx.ccx.tcx,\n+                                                       index));\n                     }\n                     case (_) { ret result; }\n                 }\n             }\n         }\n \n \n-        auto handler = unify_handler(fcx, param_substs);\n+        auto handler = unify_handler(scx, param_substs);\n \n         auto var_bindings = ty::unify::mk_var_bindings();\n         auto result = ty::unify::unify(expected, actual, handler,\n-                                       var_bindings, fcx.ccx.tcx);\n+                                       var_bindings, scx.fcx.ccx.tcx);\n \n         alt (result) {\n             case (ures_ok(?rty)) {\n-                if (ty::type_contains_vars(fcx.ccx.tcx, rty)) {\n-                    result = ures_ok(ty::unify::fixup(fcx.ccx.tcx,\n+                if (ty::type_contains_vars(scx.fcx.ccx.tcx, rty)) {\n+                    result = ures_ok(ty::unify::fixup(scx.fcx.ccx.tcx,\n                                                       var_bindings, rty));\n                 }\n             }\n             case (_) { /* nothing */ }\n         }\n \n-        fcx.ccx.unify_cache.insert(cache_key, result);\n+        scx.fcx.ccx.unify_cache.insert(cache_key, result);\n         ret result;\n     }\n }\n@@ -1000,22 +1003,22 @@ fn count_boxes(&ty::ctxt tcx, &ty::t t) -> uint {\n type ty_param_substs_and_ty = tup(vec[ty::t], ty::t);\n \n mod Demand {\n-    fn simple(&@fn_ctxt fcx, &span sp, &ty::t expected, &ty::t actual)\n-        -> ty::t {\n+    fn simple(&@stmt_ctxt scx, &span sp, &ty::t expected, &ty::t actual)\n+            -> ty::t {\n         let vec[ty::t] tps = [];\n-        ret full(fcx, sp, expected, actual, tps, NO_AUTODEREF)._1;\n+        ret full(scx, sp, expected, actual, tps, NO_AUTODEREF)._1;\n     }\n \n-    fn autoderef(&@fn_ctxt fcx, &span sp, &ty::t expected, &ty::t actual,\n+    fn autoderef(&@stmt_ctxt scx, &span sp, &ty::t expected, &ty::t actual,\n                  autoderef_kind adk) -> ty::t {\n         let vec[ty::t] tps = [];\n-        ret full(fcx, sp, expected, actual, tps, adk)._1;\n+        ret full(scx, sp, expected, actual, tps, adk)._1;\n     }\n \n     // Requires that the two types unify, and prints an error message if they\n     // don't. Returns the unified type and the type parameter substitutions.\n \n-    fn full(&@fn_ctxt fcx, &span sp, &ty::t expected, &ty::t actual,\n+    fn full(&@stmt_ctxt scx, &span sp, &ty::t expected, &ty::t actual,\n             &vec[ty::t] ty_param_substs_0, autoderef_kind adk)\n             -> ty_param_substs_and_ty {\n \n@@ -1024,19 +1027,19 @@ mod Demand {\n         auto implicit_boxes = 0u;\n \n         if (adk == AUTODEREF_OK) {\n-            expected_1 = strip_boxes(fcx.ccx.tcx, expected_1);\n-            actual_1 = strip_boxes(fcx.ccx.tcx, actual_1);\n-            implicit_boxes = count_boxes(fcx.ccx.tcx, actual);\n+            expected_1 = strip_boxes(scx.fcx.ccx.tcx, expected_1);\n+            actual_1 = strip_boxes(scx.fcx.ccx.tcx, actual_1);\n+            implicit_boxes = count_boxes(scx.fcx.ccx.tcx, actual);\n         }\n \n         let vec[mutable ty::t] ty_param_substs =\n-            [mutable ty::mk_nil(fcx.ccx.tcx)];\n+            [mutable ty::mk_nil(scx.fcx.ccx.tcx)];\n         vec::pop(ty_param_substs);   // FIXME: horrid botch\n         for (ty::t ty_param_subst in ty_param_substs_0) {\n             ty_param_substs += [mutable ty_param_subst];\n         }\n \n-        alt (unify::with_params(fcx, expected_1, actual_1, ty_param_substs)) {\n+        alt (unify::with_params(scx, expected_1, actual_1, ty_param_substs)) {\n             case (ures_ok(?t)) {\n                 // TODO: Use \"freeze\", when we have it.\n                 let vec[ty::t] result_ty_param_substs = [];\n@@ -1045,13 +1048,13 @@ mod Demand {\n                 }\n \n                 ret tup(result_ty_param_substs,\n-                        add_boxes(fcx.ccx, implicit_boxes, t));\n+                        add_boxes(scx.fcx.ccx, implicit_boxes, t));\n             }\n \n             case (ures_err(?err, ?expected, ?actual)) {\n-                fcx.ccx.sess.span_err(sp, \"mismatched types: expected \"\n-                    + ty_to_str(fcx.ccx.tcx, expected) + \" but found \"\n-                    + ty_to_str(fcx.ccx.tcx, actual) + \" (\"\n+                scx.fcx.ccx.sess.span_err(sp, \"mismatched types: expected \"\n+                    + ty_to_str(scx.fcx.ccx.tcx, expected) + \" but found \"\n+                    + ty_to_str(scx.fcx.ccx.tcx, actual) + \" (\"\n                     + ty::type_err_to_str(err) + \")\");\n \n                 // TODO: In the future, try returning \"expected\", reporting\n@@ -1064,8 +1067,8 @@ mod Demand {\n \n \n // Returns true if the two types unify and false if they don't.\n-fn are_compatible(&@fn_ctxt fcx, &ty::t expected, &ty::t actual) -> bool {\n-    alt (unify::simple(fcx, expected, actual)) {\n+fn are_compatible(&@stmt_ctxt scx, &ty::t expected, &ty::t actual) -> bool {\n+    alt (unify::simple(scx, expected, actual)) {\n         case (ures_ok(_))        { ret true;  }\n         case (ures_err(_, _, _)) { ret false; }\n     }\n@@ -1121,32 +1124,32 @@ mod Pushdown {\n     //\n     // TODO: enforce this via a predicate.\n \n-    fn pushdown_pat(&@fn_ctxt fcx, &ty::t expected, &@ast::pat pat) {\n+    fn pushdown_pat(&@stmt_ctxt scx, &ty::t expected, &@ast::pat pat) {\n         alt (pat.node) {\n             case (ast::pat_wild(?ann)) {\n-                auto t = Demand::simple(fcx, pat.span, expected,\n-                                        ann_to_type(fcx.ccx.node_types, ann));\n-                write_type(fcx.ccx.node_types, ann.id,\n+                auto t = Demand::simple(scx, pat.span, expected,\n+                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                write_type(scx.fcx.ccx.node_types, ann.id,\n                            tup(none[vec[ty::t]], t));\n             }\n             case (ast::pat_lit(?lit, ?ann)) {\n-                auto t = Demand::simple(fcx, pat.span, expected,\n-                                        ann_to_type(fcx.ccx.node_types, ann));\n-                write_type(fcx.ccx.node_types, ann.id,\n+                auto t = Demand::simple(scx, pat.span, expected,\n+                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                write_type(scx.fcx.ccx.node_types, ann.id,\n                            tup(none[vec[ty::t]], t));\n             }\n             case (ast::pat_bind(?id, ?did, ?ann)) {\n-                auto t = Demand::simple(fcx, pat.span, expected,\n-                                        ann_to_type(fcx.ccx.node_types, ann));\n-                fcx.locals.insert(did, t);\n-                write_type(fcx.ccx.node_types, ann.id,\n+                auto t = Demand::simple(scx, pat.span, expected,\n+                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                scx.fcx.locals.insert(did, t);\n+                write_type(scx.fcx.ccx.node_types, ann.id,\n                            tup(none[vec[ty::t]], t));\n             }\n             case (ast::pat_tag(?id, ?subpats, ?ann)) {\n                 // Take the variant's type parameters out of the expected\n                 // type.\n                 auto tag_tps;\n-                alt (struct(fcx.ccx.tcx, expected)) {\n+                alt (struct(scx.fcx.ccx.tcx, expected)) {\n                     case (ty::ty_tag(_, ?tps)) { tag_tps = tps; }\n                     case (_) {\n                         log_err \"tag pattern type not actually a tag?!\";\n@@ -1159,48 +1162,46 @@ mod Pushdown {\n                 let vec[ty::t] tparams = [];\n                 auto j = 0u;\n                 auto actual_ty_params =\n-                  ty::ann_to_type_params(fcx.ccx.node_types, ann);\n+                  ty::ann_to_type_params(scx.fcx.ccx.node_types, ann);\n \n                 for (ty::t some_ty in tag_tps) {\n                     let ty::t t1 = some_ty;\n                     let ty::t t2 = actual_ty_params.(j);\n                     \n-                    let ty::t res = Demand::simple(fcx, \n-                                                   pat.span,\n-                                                   t1, t2);\n+                    let ty::t res = Demand::simple(scx, pat.span, t1, t2);\n                     \n                     vec::push(tparams, res);\n                     j += 1u;\n                 }\n \n                 auto arg_tys;\n-                alt (fcx.ccx.tcx.def_map.get(ann.id)) {\n+                alt (scx.fcx.ccx.tcx.def_map.get(ann.id)) {\n                     case (ast::def_variant(_, ?vdefid)) {\n-                        arg_tys = variant_arg_types(fcx.ccx, pat.span, vdefid,\n-                                                    tparams);\n+                        arg_tys = variant_arg_types(scx.fcx.ccx, pat.span,\n+                                                    vdefid, tparams);\n                     }\n                 }\n \n                 auto i = 0u;\n                 for (@ast::pat subpat in subpats) {\n-                    pushdown_pat(fcx, arg_tys.(i), subpat);\n+                    pushdown_pat(scx, arg_tys.(i), subpat);\n                     i += 1u;\n                 }\n \n-                auto tps = ty::ann_to_type_params(fcx.ccx.node_types, ann);\n-                auto tt  = ann_to_type(fcx.ccx.node_types, ann);\n+                auto tps =\n+                    ty::ann_to_type_params(scx.fcx.ccx.node_types, ann);\n+                auto tt = ann_to_type(scx.fcx.ccx.node_types, ann);\n                 \n-                let ty_param_substs_and_ty res_t = Demand::full(fcx, pat.span,\n+                let ty_param_substs_and_ty res_t = Demand::full(scx, pat.span,\n                       expected, tt, tps, NO_AUTODEREF);\n \n                 auto a_1 = mk_ann_type(ann.id, res_t._1,\n                                        some[vec[ty::t]](res_t._0));\n \n                 // TODO: push down type from \"expected\".\n-                write_type(fcx.ccx.node_types, ann.id,\n-                    ty::ann_to_ty_param_substs_opt_and_ty(fcx.ccx.node_types,\n-                                                          a_1));\n-                    \n+                write_type(scx.fcx.ccx.node_types, ann.id,\n+                    ty::ann_to_ty_param_substs_opt_and_ty\n+                        (scx.fcx.ccx.node_types, a_1));\n             }\n         }\n     }\n@@ -1221,7 +1222,7 @@ mod Pushdown {\n             case (ast::expr_vec(?es_0, ?mut, ?ann)) {\n                 // TODO: enforce mutability\n \n-                auto t = Demand::simple(scx.fcx, e.span, expected,\n+                auto t = Demand::simple(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann));\n                 alt (struct(scx.fcx.ccx.tcx, t)) {\n                     case (ty::ty_vec(?mt)) {\n@@ -1237,7 +1238,7 @@ mod Pushdown {\n                 write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_tup(?es_0, ?ann)) {\n-                auto t = Demand::simple(scx.fcx, e.span, expected,\n+                auto t = Demand::simple(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann));\n                 alt (struct(scx.fcx.ccx.tcx, t)) {\n                     case (ty::ty_tup(?mts)) {\n@@ -1256,7 +1257,7 @@ mod Pushdown {\n             }\n             case (ast::expr_rec(?fields_0, ?base_0, ?ann)) {\n \n-                auto t = Demand::simple(scx.fcx, e.span, expected,\n+                auto t = Demand::simple(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann));\n                 alt (struct(scx.fcx.ccx.tcx, t)) {\n                     case (ty::ty_rec(?field_mts)) {\n@@ -1297,7 +1298,7 @@ mod Pushdown {\n                 write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_bind(?sube, ?es, ?ann)) {\n-                auto t = Demand::simple(scx.fcx, e.span, expected,\n+                auto t = Demand::simple(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann));\n                 write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n@@ -1306,39 +1307,39 @@ mod Pushdown {\n                 // cases where e is an expression that could *possibly*\n                 // produce a box; things like expr_binary or expr_bind can't,\n                 // so there's no need.\n-                auto t = Demand::autoderef(scx.fcx, e.span, expected,\n+                auto t = Demand::autoderef(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n                 write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_self_method(?id, ?ann)) {\n-                auto t = Demand::simple(scx.fcx, e.span, expected,\n+                auto t = Demand::simple(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann));\n                 write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_binary(?bop, ?lhs, ?rhs, ?ann)) {\n-                auto t = Demand::simple(scx.fcx, e.span, expected,\n+                auto t = Demand::simple(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann));\n                 write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_unary(?uop, ?sube, ?ann)) {\n                 // See note in expr_unary for why we're calling\n                 // Demand::autoderef.\n-                auto t = Demand::autoderef(scx.fcx, e.span, expected,\n+                auto t = Demand::autoderef(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n                 write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_lit(?lit, ?ann)) {\n-                auto t = Demand::simple(scx.fcx, e.span, expected,\n+                auto t = Demand::simple(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann));\n                 write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_cast(?sube, ?ast_ty, ?ann)) {\n-                auto t = Demand::simple(scx.fcx, e.span, expected,\n+                auto t = Demand::simple(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann));\n                 write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_if(?cond, ?then_0, ?else_0, ?ann)) {\n-                auto t = Demand::autoderef(scx.fcx, e.span, expected,\n+                auto t = Demand::autoderef(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n                 pushdown_block(scx, expected, then_0);\n \n@@ -1351,51 +1352,51 @@ mod Pushdown {\n                 write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_for(?decl, ?seq, ?bloc, ?ann)) {\n-                auto t = Demand::simple(scx.fcx, e.span, expected,\n+                auto t = Demand::simple(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann));\n                 write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_for_each(?decl, ?seq, ?bloc, ?ann)) {\n-                auto t = Demand::simple(scx.fcx, e.span, expected,\n+                auto t = Demand::simple(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann));\n                 write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_while(?cond, ?bloc, ?ann)) {\n-                auto t = Demand::simple(scx.fcx, e.span, expected,\n+                auto t = Demand::simple(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann));\n                 write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_do_while(?bloc, ?cond, ?ann)) {\n-                auto t = Demand::simple(scx.fcx, e.span, expected,\n+                auto t = Demand::simple(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann));\n                 write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_block(?bloc, ?ann)) {\n-                auto t = Demand::autoderef(scx.fcx, e.span, expected,\n+                auto t = Demand::autoderef(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n                 write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_assign(?lhs_0, ?rhs_0, ?ann)) {\n-                auto t = Demand::autoderef(scx.fcx, e.span, expected,\n+                auto t = Demand::autoderef(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n                 pushdown_expr(scx, expected, lhs_0);\n                 pushdown_expr(scx, expected, rhs_0);\n                 write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_assign_op(?op, ?lhs_0, ?rhs_0, ?ann)) {\n-                auto t = Demand::autoderef(scx.fcx, e.span, expected,\n+                auto t = Demand::autoderef(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n                 pushdown_expr(scx, expected, lhs_0);\n                 pushdown_expr(scx, expected, rhs_0);\n                 write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_field(?lhs, ?rhs, ?ann)) {\n-                auto t = Demand::autoderef(scx.fcx, e.span, expected,\n+                auto t = Demand::autoderef(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n                 write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_index(?base, ?index, ?ann)) {\n-                auto t = Demand::autoderef(scx.fcx, e.span, expected,\n+                auto t = Demand::autoderef(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n                 write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n@@ -1404,7 +1405,7 @@ mod Pushdown {\n                     ty::ann_to_type_params(scx.fcx.ccx.node_types, ann);\n                 auto t_0 = ann_to_type(scx.fcx.ccx.node_types, ann);\n \n-                auto result_0 = Demand::full(scx.fcx, e.span, expected, t_0,\n+                auto result_0 = Demand::full(scx, e.span, expected, t_0,\n                                              tp_substs_0, adk);\n                 auto t = result_0._1;\n \n@@ -1425,7 +1426,7 @@ mod Pushdown {\n                            tup(ty_params_opt, t));\n             }\n             case (ast::expr_ext(?p, ?args, ?body, ?expanded, ?ann)) {\n-                auto t = Demand::autoderef(scx.fcx, e.span, expected,\n+                auto t = Demand::autoderef(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n                 write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n@@ -1441,13 +1442,13 @@ mod Pushdown {\n             case (ast::expr_assert(_,_)) { /* no-op */ }\n \n             case (ast::expr_port(?ann)) {\n-                auto t = Demand::simple(scx.fcx, e.span, expected,\n+                auto t = Demand::simple(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann));\n                 write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n \n             case (ast::expr_chan(?es, ?ann)) {\n-                auto t = Demand::simple(scx.fcx, e.span, expected,\n+                auto t = Demand::simple(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann));\n                 alt (struct(scx.fcx.ccx.tcx, t)) {\n                     case (ty::ty_chan(?subty)) {\n@@ -1469,7 +1470,7 @@ mod Pushdown {\n                     auto bty = block_ty(scx.fcx.ccx.tcx,\n                                         scx.fcx.ccx.node_types,\n                                         arm_0.block);\n-                    t = Demand::simple(scx.fcx, e.span, t, bty);\n+                    t = Demand::simple(scx, e.span, t, bty);\n                 }\n                 write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n@@ -1493,7 +1494,7 @@ mod Pushdown {\n                 // cases where e is an expression that could *possibly*\n                 // produce a box; things like expr_binary or expr_bind can't,\n                 // so there's no need.\n-                auto t = Demand::autoderef(scx.fcx, e.span, expected,\n+                auto t = Demand::autoderef(scx, e.span, expected,\n                     ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n                 write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n@@ -1516,7 +1517,7 @@ mod Pushdown {\n                                bloc.node.a.id);\n             }\n             case (none[@ast::expr]) {\n-                Demand::simple(scx.fcx, bloc.span, expected,\n+                Demand::simple(scx, bloc.span, expected,\n                                ty::mk_nil(scx.fcx.ccx.tcx));\n                 write_nil_type(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n                                bloc.node.a.id);\n@@ -1837,7 +1838,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n         // Unify the callee and arguments.\n         auto tpt_0 = ty::expr_ty_params_and_ty(scx.fcx.ccx.tcx,\n                                                scx.fcx.ccx.node_types, f);\n-        auto tpt_1 = Demand::full(scx.fcx, f.span, tpt_0._1, t_0, tpt_0._0,\n+        auto tpt_1 = Demand::full(scx, f.span, tpt_0._1, t_0, tpt_0._0,\n                                   NO_AUTODEREF);\n         replace_expr_type(scx.fcx.ccx.node_types, f, tpt_1);\n     }\n@@ -1978,7 +1979,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             alt (expr_opt) {\n                 case (none[@ast::expr]) {\n                     auto nil = ty::mk_nil(scx.fcx.ccx.tcx);\n-                    if (!are_compatible(scx.fcx, scx.fcx.ret_ty, nil)) {\n+                    if (!are_compatible(scx, scx.fcx.ret_ty, nil)) {\n                         // TODO: span_err\n                         scx.fcx.ccx.sess.err(\"ret; in function \" +\n                             \"returning non-nil\");\n@@ -2004,7 +2005,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             alt (expr_opt) {\n                 case (none[@ast::expr]) {\n                     auto nil = ty::mk_nil(scx.fcx.ccx.tcx);\n-                    if (!are_compatible(scx.fcx, scx.fcx.ret_ty, nil)) {\n+                    if (!are_compatible(scx, scx.fcx.ret_ty, nil)) {\n                         // TODO: span_err\n                         scx.fcx.ccx.sess.span_err(expr.span,\n                             \"put; in iterator yielding non-nil\");\n@@ -2041,7 +2042,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n \n         case (ast::expr_check(?e, ?a)) {\n             check_expr(scx, e);\n-            Demand::simple(scx.fcx, expr.span, ty::mk_bool(scx.fcx.ccx.tcx),\n+            Demand::simple(scx, expr.span, ty::mk_bool(scx.fcx.ccx.tcx),\n                 expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, e));\n             /* e must be a call expr where all arguments are either\n              literals or slots */\n@@ -2085,8 +2086,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n         case (ast::expr_assert(?e, ?a)) {\n             check_expr(scx, e);\n             auto ety = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, e);\n-            Demand::simple(scx.fcx, expr.span, ty::mk_bool(scx.fcx.ccx.tcx),\n-                           ety);\n+            Demand::simple(scx, expr.span, ty::mk_bool(scx.fcx.ccx.tcx), ety);\n \n             write_nil_type(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, a.id);\n         }\n@@ -2223,13 +2223,13 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             let vec[@ast::pat] pats = [];\n             for (ast::arm arm in arms) {\n                 check_pat(scx, arm.pat);\n-                pattern_ty = Demand::simple(scx.fcx, arm.pat.span, pattern_ty,\n+                pattern_ty = Demand::simple(scx, arm.pat.span, pattern_ty,\n                     pat_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, arm.pat));\n                 pats += [arm.pat];\n             }\n \n             for (@ast::pat pat in pats) {\n-                Pushdown::pushdown_pat(scx.fcx, pattern_ty, pat);\n+                Pushdown::pushdown_pat(scx, pattern_ty, pat);\n             }\n \n             // Now typecheck the blocks.\n@@ -2241,7 +2241,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n \n                 auto bty = block_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n                                     arm.block);\n-                result_ty = Demand::simple(scx.fcx, arm.block.span, result_ty,\n+                result_ty = Demand::simple(scx, arm.block.span, result_ty,\n                                            bty);\n             }\n \n@@ -2416,7 +2416,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                 check_expr(scx, e);\n                 auto expr_t = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n                                       e);\n-                Demand::simple(scx.fcx, expr.span, t, expr_t);\n+                Demand::simple(scx, expr.span, t, expr_t);\n             }\n \n             auto typ = ty::mk_vec(scx.fcx.ccx.tcx, rec(ty=t, mut=mut));\n@@ -2483,7 +2483,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                         auto found = false;\n                         for (ty::field bf in base_fields) {\n                             if (str::eq(f.ident, bf.ident)) {\n-                                Demand::simple(scx.fcx, expr.span, f.mt.ty,\n+                                Demand::simple(scx, expr.span, f.mt.ty,\n                                                bf.mt.ty);\n                                 found = true;\n                             }"}]}