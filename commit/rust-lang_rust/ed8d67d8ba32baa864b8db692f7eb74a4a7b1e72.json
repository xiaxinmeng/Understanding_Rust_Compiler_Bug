{"sha": "ed8d67d8ba32baa864b8db692f7eb74a4a7b1e72", "node_id": "C_kwDOAAsO6NoAKGVkOGQ2N2Q4YmEzMmJhYTg2NGI4ZGI2OTJmN2ViNzRhNGE3YjFlNzI", "commit": {"author": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2023-03-25T11:19:03Z"}, "committer": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2023-04-22T21:00:28Z"}, "message": "Impl `Copy` for almost all HIR types\n\nThis simplifies the invocation of the `arena_types` macro and probably\nmakes working with HIR nicer in general.", "tree": {"sha": "d497e4788129e487fac8d9403c225b7496a8df56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d497e4788129e487fac8d9403c225b7496a8df56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed8d67d8ba32baa864b8db692f7eb74a4a7b1e72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed8d67d8ba32baa864b8db692f7eb74a4a7b1e72", "html_url": "https://github.com/rust-lang/rust/commit/ed8d67d8ba32baa864b8db692f7eb74a4a7b1e72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed8d67d8ba32baa864b8db692f7eb74a4a7b1e72/comments", "author": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb758cfc6d773b15af5bf65330ea7c36d7c3673d", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb758cfc6d773b15af5bf65330ea7c36d7c3673d", "html_url": "https://github.com/rust-lang/rust/commit/bb758cfc6d773b15af5bf65330ea7c36d7c3673d"}], "stats": {"total": 172, "additions": 66, "deletions": 106}, "files": [{"sha": "efd8c440f5c6cbd40d22c514e88bafe4cce875e3", "filename": "compiler/rustc_hir/src/arena.rs", "status": "modified", "additions": 1, "deletions": 41, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ed8d67d8ba32baa864b8db692f7eb74a4a7b1e72/compiler%2Frustc_hir%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed8d67d8ba32baa864b8db692f7eb74a4a7b1e72/compiler%2Frustc_hir%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Farena.rs?ref=ed8d67d8ba32baa864b8db692f7eb74a4a7b1e72", "patch": "@@ -1,56 +1,16 @@\n /// This higher-order macro declares a list of types which can be allocated by `Arena`.\n-///\n-/// Specifying the `decode` modifier will add decode impls for `&T` and `&[T]`,\n-/// where `T` is the type listed. These impls will appear in the implement_ty_decoder! macro.\n+/// Note that all `Copy` types can be allocated by default and need not be specified here.\n #[macro_export]\n macro_rules! arena_types {\n     ($macro:path) => (\n         $macro!([\n             // HIR types\n             [] hir_krate: rustc_hir::Crate<'tcx>,\n-            [] arm: rustc_hir::Arm<'tcx>,\n-            [] asm_operand: (rustc_hir::InlineAsmOperand<'tcx>, rustc_span::Span),\n             [] asm_template: rustc_ast::InlineAsmTemplatePiece,\n             [] attribute: rustc_ast::Attribute,\n-            [] closure: rustc_hir::Closure<'tcx>,\n-            [] block: rustc_hir::Block<'tcx>,\n-            [] bare_fn_ty: rustc_hir::BareFnTy<'tcx>,\n-            [] body: rustc_hir::Body<'tcx>,\n-            [] generics: rustc_hir::Generics<'tcx>,\n-            [] generic_arg: rustc_hir::GenericArg<'tcx>,\n-            [] generic_args: rustc_hir::GenericArgs<'tcx>,\n-            [] generic_bound: rustc_hir::GenericBound<'tcx>,\n-            [] generic_param: rustc_hir::GenericParam<'tcx>,\n-            [] expr: rustc_hir::Expr<'tcx>,\n-            [] impl_: rustc_hir::Impl<'tcx>,\n-            [] let_expr: rustc_hir::Let<'tcx>,\n-            [] expr_field: rustc_hir::ExprField<'tcx>,\n-            [] pat_field: rustc_hir::PatField<'tcx>,\n-            [] fn_decl: rustc_hir::FnDecl<'tcx>,\n-            [] foreign_item: rustc_hir::ForeignItem<'tcx>,\n-            [] foreign_item_ref: rustc_hir::ForeignItemRef,\n-            [] impl_item: rustc_hir::ImplItem<'tcx>,\n-            [] impl_item_ref: rustc_hir::ImplItemRef,\n             [] item: rustc_hir::Item<'tcx>,\n-            [] inline_asm: rustc_hir::InlineAsm<'tcx>,\n-            [] local: rustc_hir::Local<'tcx>,\n-            [] mod_: rustc_hir::Mod<'tcx>,\n             [] owner_info: rustc_hir::OwnerInfo<'tcx>,\n-            [] param: rustc_hir::Param<'tcx>,\n-            [] pat: rustc_hir::Pat<'tcx>,\n-            [] path: rustc_hir::Path<'tcx>,\n             [] use_path: rustc_hir::UsePath<'tcx>,\n-            [] path_segment: rustc_hir::PathSegment<'tcx>,\n-            [] poly_trait_ref: rustc_hir::PolyTraitRef<'tcx>,\n-            [] qpath: rustc_hir::QPath<'tcx>,\n-            [] stmt: rustc_hir::Stmt<'tcx>,\n-            [] field_def: rustc_hir::FieldDef<'tcx>,\n-            [] trait_item: rustc_hir::TraitItem<'tcx>,\n-            [] trait_item_ref: rustc_hir::TraitItemRef,\n-            [] ty: rustc_hir::Ty<'tcx>,\n-            [] type_binding: rustc_hir::TypeBinding<'tcx>,\n-            [] variant: rustc_hir::Variant<'tcx>,\n-            [] where_predicate: rustc_hir::WherePredicate<'tcx>,\n             [] lit: rustc_hir::Lit,\n         ]);\n     )"}, {"sha": "0ecb1bf4c599357bc6b7eb6b35a1bbf878bcbf46", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/ed8d67d8ba32baa864b8db692f7eb74a4a7b1e72/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed8d67d8ba32baa864b8db692f7eb74a4a7b1e72/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=ed8d67d8ba32baa864b8db692f7eb74a4a7b1e72", "patch": "@@ -182,7 +182,7 @@ impl Lifetime {\n /// A `Path` is essentially Rust's notion of a name; for instance,\n /// `std::cmp::PartialEq`. It's represented as a sequence of identifiers,\n /// along with a bunch of supporting information.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Path<'hir, R = Res> {\n     pub span: Span,\n     /// The resolution for the path.\n@@ -202,7 +202,7 @@ impl Path<'_> {\n \n /// A segment of a path: an identifier, an optional lifetime, and a set of\n /// types.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct PathSegment<'hir> {\n     /// The identifier portion of this path segment.\n     pub ident: Ident,\n@@ -243,13 +243,13 @@ impl<'hir> PathSegment<'hir> {\n     }\n }\n \n-#[derive(Encodable, Debug, HashStable_Generic)]\n+#[derive(Encodable, Clone, Copy, Debug, HashStable_Generic)]\n pub struct ConstArg {\n     pub value: AnonConst,\n     pub span: Span,\n }\n \n-#[derive(Encodable, Debug, HashStable_Generic)]\n+#[derive(Encodable, Clone, Copy, Debug, HashStable_Generic)]\n pub struct InferArg {\n     pub hir_id: HirId,\n     pub span: Span,\n@@ -261,7 +261,7 @@ impl InferArg {\n     }\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum GenericArg<'hir> {\n     Lifetime(&'hir Lifetime),\n     Type(&'hir Ty<'hir>),\n@@ -318,7 +318,7 @@ impl GenericArg<'_> {\n     }\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct GenericArgs<'hir> {\n     /// The generic arguments for this path segment.\n     pub args: &'hir [GenericArg<'hir>],\n@@ -447,7 +447,7 @@ pub enum TraitBoundModifier {\n /// `typeck::collect::compute_bounds` matches these against\n /// the \"special\" built-in traits (see `middle::lang_items`) and\n /// detects `Copy`, `Send` and `Sync`.\n-#[derive(Clone, Debug, HashStable_Generic)]\n+#[derive(Clone, Copy, Debug, HashStable_Generic)]\n pub enum GenericBound<'hir> {\n     Trait(PolyTraitRef<'hir>, TraitBoundModifier),\n     // FIXME(davidtwco): Introduce `PolyTraitRef::LangItem`\n@@ -488,7 +488,7 @@ pub enum LifetimeParamKind {\n     Error,\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum GenericParamKind<'hir> {\n     /// A lifetime definition (e.g., `'a: 'b + 'c + 'd`).\n     Lifetime {\n@@ -505,7 +505,7 @@ pub enum GenericParamKind<'hir> {\n     },\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct GenericParam<'hir> {\n     pub hir_id: HirId,\n     pub def_id: LocalDefId,\n@@ -557,7 +557,7 @@ pub struct GenericParamCount {\n \n /// Represents lifetimes and type parameters attached to a declaration\n /// of a function, enum, trait, etc.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Generics<'hir> {\n     pub params: &'hir [GenericParam<'hir>],\n     pub predicates: &'hir [WherePredicate<'hir>],\n@@ -729,7 +729,7 @@ impl<'hir> Generics<'hir> {\n }\n \n /// A single predicate in a where-clause.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum WherePredicate<'hir> {\n     /// A type binding (e.g., `for<'c> Foo: Send + Clone + 'c`).\n     BoundPredicate(WhereBoundPredicate<'hir>),\n@@ -773,7 +773,7 @@ pub enum PredicateOrigin {\n }\n \n /// A type bound (e.g., `for<'c> Foo: Send + Clone + 'c`).\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct WhereBoundPredicate<'hir> {\n     pub hir_id: HirId,\n     pub span: Span,\n@@ -795,7 +795,7 @@ impl<'hir> WhereBoundPredicate<'hir> {\n }\n \n /// A lifetime predicate (e.g., `'a: 'b + 'c`).\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct WhereRegionPredicate<'hir> {\n     pub span: Span,\n     pub in_where_clause: bool,\n@@ -811,7 +811,7 @@ impl<'hir> WhereRegionPredicate<'hir> {\n }\n \n /// An equality predicate (e.g., `T = int`); currently unsupported.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct WhereEqPredicate<'hir> {\n     pub span: Span,\n     pub lhs_ty: &'hir Ty<'hir>,\n@@ -821,7 +821,7 @@ pub struct WhereEqPredicate<'hir> {\n /// HIR node coupled with its parent's id in the same HIR owner.\n ///\n /// The parent is trash when the node is a HIR owner.\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Copy, Debug)]\n pub struct ParentedNode<'tcx> {\n     pub parent: ItemLocalId,\n     pub node: Node<'tcx>,\n@@ -959,7 +959,7 @@ pub struct Crate<'hir> {\n     pub opt_hir_hash: Option<Fingerprint>,\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Closure<'hir> {\n     pub def_id: LocalDefId,\n     pub binder: ClosureBinder,\n@@ -978,7 +978,7 @@ pub struct Closure<'hir> {\n /// A block of statements `{ .. }`, which may have a label (in this case the\n /// `targeted_by_break` field will be `true`) and may be `unsafe` by means of\n /// the `rules` being anything but `DefaultBlock`.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Block<'hir> {\n     /// Statements in a block.\n     pub stmts: &'hir [Stmt<'hir>],\n@@ -1006,7 +1006,7 @@ impl<'hir> Block<'hir> {\n     }\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Pat<'hir> {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n@@ -1085,7 +1085,7 @@ impl<'hir> Pat<'hir> {\n /// Patterns like the fields of Foo `{ x, ref y, ref mut z }`\n /// are treated the same as` x: x, y: ref y, z: ref mut z`,\n /// except `is_shorthand` is true.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct PatField<'hir> {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n@@ -1141,7 +1141,7 @@ impl fmt::Debug for DotDotPos {\n     }\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum PatKind<'hir> {\n     /// Represents a wildcard pattern (i.e., `_`).\n     Wild,\n@@ -1351,15 +1351,15 @@ impl UnOp {\n }\n \n /// A statement.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Stmt<'hir> {\n     pub hir_id: HirId,\n     pub kind: StmtKind<'hir>,\n     pub span: Span,\n }\n \n /// The contents of a statement.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum StmtKind<'hir> {\n     /// A local (`let`) binding.\n     Local(&'hir Local<'hir>),\n@@ -1375,7 +1375,7 @@ pub enum StmtKind<'hir> {\n }\n \n /// Represents a `let` statement (i.e., `let <pat>:<ty> = <init>;`).\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Local<'hir> {\n     pub pat: &'hir Pat<'hir>,\n     /// Type annotation, if any (otherwise the type will be inferred).\n@@ -1393,7 +1393,7 @@ pub struct Local<'hir> {\n \n /// Represents a single arm of a `match` expression, e.g.\n /// `<pat> (if <guard>) => <body>`.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Arm<'hir> {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n@@ -1411,7 +1411,7 @@ pub struct Arm<'hir> {\n ///\n /// In an if-let, imagine it as `if (let <pat> = <expr>) { ... }`; in a let-else, it is part of the\n /// desugaring to if-let. Only let-else supports the type annotation at present.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Let<'hir> {\n     pub hir_id: HirId,\n     pub span: Span,\n@@ -1420,7 +1420,7 @@ pub struct Let<'hir> {\n     pub init: &'hir Expr<'hir>,\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum Guard<'hir> {\n     If(&'hir Expr<'hir>),\n     IfLet(&'hir Let<'hir>),\n@@ -1440,7 +1440,7 @@ impl<'hir> Guard<'hir> {\n     }\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct ExprField<'hir> {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n@@ -1488,7 +1488,7 @@ pub struct BodyId {\n ///\n /// All bodies have an **owner**, which can be accessed via the HIR\n /// map using `body_owner_def_id()`.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Body<'hir> {\n     pub params: &'hir [Param<'hir>],\n     pub value: &'hir Expr<'hir>,\n@@ -1679,7 +1679,7 @@ pub struct AnonConst {\n }\n \n /// An expression.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Expr<'hir> {\n     pub hir_id: HirId,\n     pub kind: ExprKind<'hir>,\n@@ -1922,7 +1922,7 @@ pub fn is_range_literal(expr: &Expr<'_>) -> bool {\n     }\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum ExprKind<'hir> {\n     /// Allow anonymous constants from an inline `const` block\n     ConstBlock(AnonConst),\n@@ -2051,7 +2051,7 @@ pub enum ExprKind<'hir> {\n /// To resolve the path to a `DefId`, call [`qpath_res`].\n ///\n /// [`qpath_res`]: ../../rustc_middle/ty/struct.TypeckResults.html#method.qpath_res\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum QPath<'hir> {\n     /// Path to a definition, optionally \"fully-qualified\" with a `Self`\n     /// type, if the path points to an associated item in a trait.\n@@ -2243,15 +2243,15 @@ impl From<GeneratorKind> for YieldSource {\n \n // N.B., if you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct MutTy<'hir> {\n     pub ty: &'hir Ty<'hir>,\n     pub mutbl: Mutability,\n }\n \n /// Represents a function's signature in a trait declaration,\n /// trait implementation, or a free function.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct FnSig<'hir> {\n     pub header: FnHeader,\n     pub decl: &'hir FnDecl<'hir>,\n@@ -2278,7 +2278,7 @@ impl TraitItemId {\n /// possibly including a default implementation. A trait item is\n /// either required (meaning it doesn't have an implementation, just a\n /// signature) or provided (meaning it has a default implementation).\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct TraitItem<'hir> {\n     pub ident: Ident,\n     pub owner_id: OwnerId,\n@@ -2327,7 +2327,7 @@ impl<'hir> TraitItem<'hir> {\n }\n \n /// Represents a trait method's body (or just argument names).\n-#[derive(Encodable, Debug, HashStable_Generic)]\n+#[derive(Encodable, Debug, Clone, Copy, HashStable_Generic)]\n pub enum TraitFn<'hir> {\n     /// No default body in the trait, just a signature.\n     Required(&'hir [Ident]),\n@@ -2337,7 +2337,7 @@ pub enum TraitFn<'hir> {\n }\n \n /// Represents a trait method or associated constant or type\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum TraitItemKind<'hir> {\n     /// An associated constant with an optional value (otherwise `impl`s must contain a value).\n     Const(&'hir Ty<'hir>, Option<BodyId>),\n@@ -2365,7 +2365,7 @@ impl ImplItemId {\n }\n \n /// Represents anything within an `impl` block.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct ImplItem<'hir> {\n     pub ident: Ident,\n     pub owner_id: OwnerId,\n@@ -2415,7 +2415,7 @@ impl<'hir> ImplItem<'hir> {\n }\n \n /// Represents various kinds of content within an `impl`.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum ImplItemKind<'hir> {\n     /// An associated constant of the given type, set to the constant result\n     /// of the expression.\n@@ -2444,7 +2444,7 @@ pub const FN_OUTPUT_NAME: Symbol = sym::Output;\n ///    Binding(...),\n /// }\n /// ```\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct TypeBinding<'hir> {\n     pub hir_id: HirId,\n     pub ident: Ident,\n@@ -2453,7 +2453,7 @@ pub struct TypeBinding<'hir> {\n     pub span: Span,\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum Term<'hir> {\n     Ty(&'hir Ty<'hir>),\n     Const(AnonConst),\n@@ -2472,7 +2472,7 @@ impl<'hir> From<AnonConst> for Term<'hir> {\n }\n \n // Represents the two kinds of type bindings.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum TypeBindingKind<'hir> {\n     /// E.g., `Foo<Bar: Send>`.\n     Constraint { bounds: &'hir [GenericBound<'hir>] },\n@@ -2495,7 +2495,7 @@ impl TypeBinding<'_> {\n     }\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Ty<'hir> {\n     pub hir_id: HirId,\n     pub kind: TyKind<'hir>,\n@@ -2640,7 +2640,7 @@ impl PrimTy {\n     }\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct BareFnTy<'hir> {\n     pub unsafety: Unsafety,\n     pub abi: Abi,\n@@ -2649,7 +2649,7 @@ pub struct BareFnTy<'hir> {\n     pub param_names: &'hir [Ident],\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct OpaqueTy<'hir> {\n     pub generics: &'hir Generics<'hir>,\n     pub bounds: GenericBounds<'hir>,\n@@ -2669,7 +2669,7 @@ pub enum OpaqueTyOrigin {\n }\n \n /// The various kinds of types recognized by the compiler.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum TyKind<'hir> {\n     /// A variable length slice (i.e., `[T]`).\n     Slice(&'hir Ty<'hir>),\n@@ -2709,7 +2709,7 @@ pub enum TyKind<'hir> {\n     Err(rustc_span::ErrorGuaranteed),\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum InlineAsmOperand<'hir> {\n     In {\n         reg: InlineAsmRegOrRegClass,\n@@ -2762,7 +2762,7 @@ impl<'hir> InlineAsmOperand<'hir> {\n     }\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct InlineAsm<'hir> {\n     pub template: &'hir [InlineAsmTemplatePiece],\n     pub template_strs: &'hir [(Symbol, Option<Symbol>, Span)],\n@@ -2772,7 +2772,7 @@ pub struct InlineAsm<'hir> {\n }\n \n /// Represents a parameter in a function header.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Param<'hir> {\n     pub hir_id: HirId,\n     pub pat: &'hir Pat<'hir>,\n@@ -2781,7 +2781,7 @@ pub struct Param<'hir> {\n }\n \n /// Represents the header (not the body) of a function declaration.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct FnDecl<'hir> {\n     /// The types of the function's parameters.\n     ///\n@@ -2854,7 +2854,7 @@ impl Defaultness {\n     }\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum FnRetTy<'hir> {\n     /// Return type is not specified.\n     ///\n@@ -2887,7 +2887,7 @@ pub enum ClosureBinder {\n     For { span: Span },\n }\n \n-#[derive(Encodable, Debug, HashStable_Generic)]\n+#[derive(Encodable, Debug, Clone, Copy, HashStable_Generic)]\n pub struct Mod<'hir> {\n     pub spans: ModSpans,\n     pub item_ids: &'hir [ItemId],\n@@ -2902,12 +2902,12 @@ pub struct ModSpans {\n     pub inject_use_span: Span,\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct EnumDef<'hir> {\n     pub variants: &'hir [Variant<'hir>],\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Variant<'hir> {\n     /// Name of the variant.\n     pub ident: Ident,\n@@ -2944,7 +2944,7 @@ pub enum UseKind {\n /// that the `ref_id` is for. Note that `ref_id`'s value is not the `HirId` of the\n /// trait being referred to but just a unique `HirId` that serves as a key\n /// within the resolution map.\n-#[derive(Clone, Debug, HashStable_Generic)]\n+#[derive(Clone, Debug, Copy, HashStable_Generic)]\n pub struct TraitRef<'hir> {\n     pub path: &'hir Path<'hir>,\n     // Don't hash the `ref_id`. It is tracked via the thing it is used to access.\n@@ -2963,7 +2963,7 @@ impl TraitRef<'_> {\n     }\n }\n \n-#[derive(Clone, Debug, HashStable_Generic)]\n+#[derive(Clone, Debug, Copy, HashStable_Generic)]\n pub struct PolyTraitRef<'hir> {\n     /// The `'a` in `for<'a> Foo<&'a T>`.\n     pub bound_generic_params: &'hir [GenericParam<'hir>],\n@@ -2974,7 +2974,7 @@ pub struct PolyTraitRef<'hir> {\n     pub span: Span,\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct FieldDef<'hir> {\n     pub span: Span,\n     pub vis_span: Span,\n@@ -2993,7 +2993,7 @@ impl FieldDef<'_> {\n }\n \n /// Fields and constructor IDs of enum variants and structs.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum VariantData<'hir> {\n     /// A struct variant.\n     ///\n@@ -3318,7 +3318,7 @@ pub enum ItemKind<'hir> {\n     Impl(&'hir Impl<'hir>),\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Impl<'hir> {\n     pub unsafety: Unsafety,\n     pub polarity: ImplPolarity,\n@@ -3381,7 +3381,7 @@ impl ItemKind<'_> {\n /// type or method, and whether it is public). This allows other\n /// passes to find the impl they want without loading the ID (which\n /// means fewer edges in the incremental compilation graph).\n-#[derive(Encodable, Debug, HashStable_Generic)]\n+#[derive(Encodable, Debug, Clone, Copy, HashStable_Generic)]\n pub struct TraitItemRef {\n     pub id: TraitItemId,\n     pub ident: Ident,\n@@ -3395,7 +3395,7 @@ pub struct TraitItemRef {\n /// type or method, and whether it is public). This allows other\n /// passes to find the impl they want without loading the ID (which\n /// means fewer edges in the incremental compilation graph).\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct ImplItemRef {\n     pub id: ImplItemId,\n     pub ident: Ident,\n@@ -3434,14 +3434,14 @@ impl ForeignItemId {\n /// type or method, and whether it is public). This allows other\n /// passes to find the impl they want without loading the ID (which\n /// means fewer edges in the incremental compilation graph).\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct ForeignItemRef {\n     pub id: ForeignItemId,\n     pub ident: Ident,\n     pub span: Span,\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct ForeignItem<'hir> {\n     pub ident: Ident,\n     pub kind: ForeignItemKind<'hir>,\n@@ -3463,7 +3463,7 @@ impl ForeignItem<'_> {\n }\n \n /// An item within an `extern` block.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum ForeignItemKind<'hir> {\n     /// A foreign function.\n     Fn(&'hir FnDecl<'hir>, &'hir [Ident], &'hir Generics<'hir>),\n@@ -3483,7 +3483,7 @@ pub struct Upvar {\n // The TraitCandidate's import_ids is empty if the trait is defined in the same module, and\n // has length > 0 if the trait is found through an chain of imports, starting with the\n // import/use statement in the scope where the trait is used.\n-#[derive(Encodable, Decodable, Debug, HashStable_Generic)]\n+#[derive(Encodable, Decodable, Debug, Clone, HashStable_Generic)]\n pub struct TraitCandidate {\n     pub def_id: DefId,\n     pub import_ids: SmallVec<[LocalDefId; 1]>,"}, {"sha": "10ef12ed314d32e48504c8833ade8d80d8442429", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed8d67d8ba32baa864b8db692f7eb74a4a7b1e72/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed8d67d8ba32baa864b8db692f7eb74a4a7b1e72/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=ed8d67d8ba32baa864b8db692f7eb74a4a7b1e72", "patch": "@@ -331,7 +331,7 @@ impl<'tcx> IrMaps<'tcx> {\n                     pats.extend(inner_pat.iter());\n                 }\n                 Struct(_, fields, _) => {\n-                    let (short, not_short): (Vec<_>, _) =\n+                    let (short, not_short): (Vec<hir::PatField<'_>>, _) =\n                         fields.iter().partition(|f| f.is_shorthand);\n                     shorthand_field_ids.extend(short.iter().map(|f| f.pat.hir_id));\n                     pats.extend(not_short.iter().map(|f| f.pat));"}]}