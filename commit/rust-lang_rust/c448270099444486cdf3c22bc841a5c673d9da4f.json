{"sha": "c448270099444486cdf3c22bc841a5c673d9da4f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0NDgyNzAwOTk0NDQ0ODZjZGYzYzIyYmM4NDFhNWM2NzNkOWRhNGY=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-01-13T21:06:41Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-01-27T09:05:05Z"}, "message": "Use empty Cache for methods requiring it when filling Cache itself", "tree": {"sha": "8a9b96ad3a5847ae122df23dea01a97f2f3bbd8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a9b96ad3a5847ae122df23dea01a97f2f3bbd8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c448270099444486cdf3c22bc841a5c673d9da4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c448270099444486cdf3c22bc841a5c673d9da4f", "html_url": "https://github.com/rust-lang/rust/commit/c448270099444486cdf3c22bc841a5c673d9da4f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c448270099444486cdf3c22bc841a5c673d9da4f/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fd5a679846a738d1117590a319fb12651711da4", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fd5a679846a738d1117590a319fb12651711da4", "html_url": "https://github.com/rust-lang/rust/commit/9fd5a679846a738d1117590a319fb12651711da4"}], "stats": {"total": 118, "additions": 70, "deletions": 48}, "files": [{"sha": "6e42acfe11f7df9468e096b1857f378b774ea0db", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 70, "deletions": 48, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/c448270099444486cdf3c22bc841a5c673d9da4f/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c448270099444486cdf3c22bc841a5c673d9da4f/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=c448270099444486cdf3c22bc841a5c673d9da4f", "patch": "@@ -193,7 +193,11 @@ impl Cache {\n         }\n \n         cache.stack.push(krate.name.to_string());\n-        krate = cache.fold_crate(krate);\n+\n+        krate = {\n+            let mut cache_wrapper = CacheWrapper { cache: &mut cache, tmp_cache: Cache::default() };\n+            cache_wrapper.fold_crate(krate)\n+        };\n \n         for (trait_did, dids, impl_) in cache.orphan_trait_impls.drain(..) {\n             if cache.traits.contains_key(&trait_did) {\n@@ -207,7 +211,15 @@ impl Cache {\n     }\n }\n \n-impl DocFolder for Cache {\n+/// This struct is needed because we need to use an empty `Cache` for all functions requiring\n+/// a `Cache`. If we use the already filled one (`cache` in here), it'll provide information\n+/// about implementations that aren't related to the type being checked.\n+struct CacheWrapper<'a> {\n+    cache: &'a mut Cache,\n+    tmp_cache: Cache,\n+}\n+\n+impl<'a> DocFolder for CacheWrapper<'a> {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n         if item.def_id.is_local() {\n             debug!(\"folding {} \\\"{:?}\\\", id {:?}\", item.type_(), item.name, item.def_id);\n@@ -217,17 +229,21 @@ impl DocFolder for Cache {\n         // we don't want it or its children in the search index.\n         let orig_stripped_mod = match *item.kind {\n             clean::StrippedItem(box clean::ModuleItem(..)) => {\n-                mem::replace(&mut self.stripped_mod, true)\n+                mem::replace(&mut self.cache.stripped_mod, true)\n             }\n-            _ => self.stripped_mod,\n+            _ => self.cache.stripped_mod,\n         };\n \n         // If the impl is from a masked crate or references something from a\n         // masked crate then remove it completely.\n         if let clean::ImplItem(ref i) = *item.kind {\n-            if self.masked_crates.contains(&item.def_id.krate)\n-                || i.trait_.def_id(self).map_or(false, |d| self.masked_crates.contains(&d.krate))\n-                || i.for_.def_id(self).map_or(false, |d| self.masked_crates.contains(&d.krate))\n+            if self.cache.masked_crates.contains(&item.def_id.krate)\n+                || i.trait_\n+                    .def_id(&self.tmp_cache)\n+                    .map_or(false, |d| self.cache.masked_crates.contains(&d.krate))\n+                || i.for_\n+                    .def_id(&self.tmp_cache)\n+                    .map_or(false, |d| self.cache.masked_crates.contains(&d.krate))\n             {\n                 return None;\n             }\n@@ -236,14 +252,15 @@ impl DocFolder for Cache {\n         // Propagate a trait method's documentation to all implementors of the\n         // trait.\n         if let clean::TraitItem(ref t) = *item.kind {\n-            self.traits.entry(item.def_id).or_insert_with(|| t.clone());\n+            self.cache.traits.entry(item.def_id).or_insert_with(|| t.clone());\n         }\n \n         // Collect all the implementors of traits.\n         if let clean::ImplItem(ref i) = *item.kind {\n-            if let Some(did) = i.trait_.def_id(self) {\n+            if let Some(did) = i.trait_.def_id(&self.tmp_cache) {\n                 if i.blanket_impl.is_none() {\n-                    self.implementors\n+                    self.cache\n+                        .implementors\n                         .entry(did)\n                         .or_default()\n                         .push(Impl { impl_item: item.clone() });\n@@ -256,7 +273,7 @@ impl DocFolder for Cache {\n             let (parent, is_inherent_impl_item) = match *item.kind {\n                 clean::StrippedItem(..) => ((None, None), false),\n                 clean::AssocConstItem(..) | clean::TypedefItem(_, true)\n-                    if self.parent_is_trait_impl =>\n+                    if self.cache.parent_is_trait_impl =>\n                 {\n                     // skip associated items in trait impls\n                     ((None, None), false)\n@@ -266,18 +283,18 @@ impl DocFolder for Cache {\n                 | clean::StructFieldItem(..)\n                 | clean::VariantItem(..) => (\n                     (\n-                        Some(*self.parent_stack.last().expect(\"parent_stack is empty\")),\n-                        Some(&self.stack[..self.stack.len() - 1]),\n+                        Some(*self.cache.parent_stack.last().expect(\"parent_stack is empty\")),\n+                        Some(&self.cache.stack[..self.cache.stack.len() - 1]),\n                     ),\n                     false,\n                 ),\n                 clean::MethodItem(..) | clean::AssocConstItem(..) => {\n-                    if self.parent_stack.is_empty() {\n+                    if self.cache.parent_stack.is_empty() {\n                         ((None, None), false)\n                     } else {\n-                        let last = self.parent_stack.last().expect(\"parent_stack is empty 2\");\n+                        let last = self.cache.parent_stack.last().expect(\"parent_stack is empty 2\");\n                         let did = *last;\n-                        let path = match self.paths.get(&did) {\n+                        let path = match self.cache.paths.get(&did) {\n                             // The current stack not necessarily has correlation\n                             // for where the type was defined. On the other\n                             // hand, `paths` always has the right\n@@ -289,24 +306,24 @@ impl DocFolder for Cache {\n                                 | ItemType::Union\n                                 | ItemType::Enum,\n                             )) => Some(&fqp[..fqp.len() - 1]),\n-                            Some(..) => Some(&*self.stack),\n+                            Some(..) => Some(&*self.cache.stack),\n                             None => None,\n                         };\n                         ((Some(*last), path), true)\n                     }\n                 }\n-                _ => ((None, Some(&*self.stack)), false),\n+                _ => ((None, Some(&*self.cache.stack)), false),\n             };\n \n             match parent {\n-                (parent, Some(path)) if is_inherent_impl_item || !self.stripped_mod => {\n+                (parent, Some(path)) if is_inherent_impl_item || !self.cache.stripped_mod => {\n                     debug_assert!(!item.is_stripped());\n \n                     // A crate has a module at its root, containing all items,\n                     // which should not be indexed. The crate-item itself is\n                     // inserted later on when serializing the search-index.\n                     if item.def_id.index != CRATE_DEF_INDEX {\n-                        self.search_index.push(IndexItem {\n+                        self.cache.search_index.push(IndexItem {\n                             ty: item.type_(),\n                             name: s.to_string(),\n                             path: path.join(\"::\"),\n@@ -315,21 +332,22 @@ impl DocFolder for Cache {\n                                 .map_or_else(String::new, |x| short_markdown_summary(&x.as_str())),\n                             parent,\n                             parent_idx: None,\n-                            search_type: get_index_search_type(&item, self),\n+                            search_type: get_index_search_type(&item, &self.tmp_cache),\n                         });\n \n                         for alias in item.attrs.get_doc_aliases() {\n-                            self.aliases\n+                            self.cache\n+                                .aliases\n                                 .entry(alias.to_lowercase())\n                                 .or_insert(Vec::new())\n-                                .push(self.search_index.len() - 1);\n+                                .push(self.cache.search_index.len() - 1);\n                         }\n                     }\n                 }\n                 (Some(parent), None) if is_inherent_impl_item => {\n                     // We have a parent, but we don't know where they're\n                     // defined yet. Wait for later to index this item.\n-                    self.orphan_impl_items.push((parent, item.clone()));\n+                    self.cache.orphan_impl_items.push((parent, item.clone()));\n                 }\n                 _ => {}\n             }\n@@ -338,7 +356,7 @@ impl DocFolder for Cache {\n         // Keep track of the fully qualified path for this item.\n         let pushed = match item.name {\n             Some(n) if !n.is_empty() => {\n-                self.stack.push(n.to_string());\n+                self.cache.stack.push(n.to_string());\n                 true\n             }\n             _ => false,\n@@ -360,54 +378,54 @@ impl DocFolder for Cache {\n             | clean::MacroItem(..)\n             | clean::ProcMacroItem(..)\n             | clean::VariantItem(..)\n-                if !self.stripped_mod =>\n+                if !self.cache.stripped_mod =>\n             {\n                 // Re-exported items mean that the same id can show up twice\n                 // in the rustdoc ast that we're looking at. We know,\n                 // however, that a re-exported item doesn't show up in the\n                 // `public_items` map, so we can skip inserting into the\n                 // paths map if there was already an entry present and we're\n                 // not a public item.\n-                if !self.paths.contains_key(&item.def_id)\n-                    || self.access_levels.is_public(item.def_id)\n+                if !self.cache.paths.contains_key(&item.def_id)\n+                    || self.cache.access_levels.is_public(item.def_id)\n                 {\n-                    self.paths.insert(item.def_id, (self.stack.clone(), item.type_()));\n+                    self.cache.paths.insert(item.def_id, (self.cache.stack.clone(), item.type_()));\n                 }\n             }\n             clean::PrimitiveItem(..) => {\n-                self.paths.insert(item.def_id, (self.stack.clone(), item.type_()));\n+                self.cache.paths.insert(item.def_id, (self.cache.stack.clone(), item.type_()));\n             }\n \n             _ => {}\n         }\n \n         // Maintain the parent stack\n-        let orig_parent_is_trait_impl = self.parent_is_trait_impl;\n+        let orig_parent_is_trait_impl = self.cache.parent_is_trait_impl;\n         let parent_pushed = match *item.kind {\n             clean::TraitItem(..)\n             | clean::EnumItem(..)\n             | clean::ForeignTypeItem\n             | clean::StructItem(..)\n             | clean::UnionItem(..)\n             | clean::VariantItem(..) => {\n-                self.parent_stack.push(item.def_id);\n-                self.parent_is_trait_impl = false;\n+                self.cache.parent_stack.push(item.def_id);\n+                self.cache.parent_is_trait_impl = false;\n                 true\n             }\n             clean::ImplItem(ref i) => {\n-                self.parent_is_trait_impl = i.trait_.is_some();\n+                self.cache.parent_is_trait_impl = i.trait_.is_some();\n                 match i.for_ {\n                     clean::ResolvedPath { did, .. } => {\n-                        self.parent_stack.push(did);\n+                        self.cache.parent_stack.push(did);\n                         true\n                     }\n                     ref t => {\n                         let prim_did = t\n                             .primitive_type()\n-                            .and_then(|t| self.primitive_locations.get(&t).cloned());\n+                            .and_then(|t| self.cache.primitive_locations.get(&t).cloned());\n                         match prim_did {\n                             Some(did) => {\n-                                self.parent_stack.push(did);\n+                                self.cache.parent_stack.push(did);\n                                 true\n                             }\n                             None => false,\n@@ -432,8 +450,9 @@ impl DocFolder for Cache {\n                     dids.insert(did);\n                 }\n                 ref t => {\n-                    let did =\n-                        t.primitive_type().and_then(|t| self.primitive_locations.get(&t).cloned());\n+                    let did = t\n+                        .primitive_type()\n+                        .and_then(|t| self.cache.primitive_locations.get(&t).cloned());\n \n                     if let Some(did) = did {\n                         dids.insert(did);\n@@ -443,33 +462,36 @@ impl DocFolder for Cache {\n \n             if let Some(generics) = i.trait_.as_ref().and_then(|t| t.generics()) {\n                 for bound in generics {\n-                    if let Some(did) = bound.def_id(self) {\n+                    if let Some(did) = bound.def_id(&self.tmp_cache) {\n                         dids.insert(did);\n                     }\n                 }\n             }\n             let impl_item = Impl { impl_item: item };\n-            if impl_item.trait_did(self).map_or(true, |d| self.traits.contains_key(&d)) {\n+            if impl_item\n+                .trait_did(&self.tmp_cache)\n+                .map_or(true, |d| self.cache.traits.contains_key(&d))\n+            {\n                 for did in dids {\n-                    self.impls.entry(did).or_insert(vec![]).push(impl_item.clone());\n+                    self.cache.impls.entry(did).or_insert(vec![]).push(impl_item.clone());\n                 }\n             } else {\n-                let trait_did = impl_item.trait_did(self).expect(\"no trait did\");\n-                self.orphan_trait_impls.push((trait_did, dids, impl_item));\n+                let trait_did = impl_item.trait_did(&self.tmp_cache).expect(\"no trait did\");\n+                self.cache.orphan_trait_impls.push((trait_did, dids, impl_item));\n             }\n             None\n         } else {\n             Some(item)\n         };\n \n         if pushed {\n-            self.stack.pop().expect(\"stack already empty\");\n+            self.cache.stack.pop().expect(\"stack already empty\");\n         }\n         if parent_pushed {\n-            self.parent_stack.pop().expect(\"parent stack already empty\");\n+            self.cache.parent_stack.pop().expect(\"parent stack already empty\");\n         }\n-        self.stripped_mod = orig_stripped_mod;\n-        self.parent_is_trait_impl = orig_parent_is_trait_impl;\n+        self.cache.stripped_mod = orig_stripped_mod;\n+        self.cache.parent_is_trait_impl = orig_parent_is_trait_impl;\n         ret\n     }\n }"}]}