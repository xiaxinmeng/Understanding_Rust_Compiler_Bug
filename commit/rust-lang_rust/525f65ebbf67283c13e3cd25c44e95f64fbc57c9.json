{"sha": "525f65ebbf67283c13e3cd25c44e95f64fbc57c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyNWY2NWViYmY2NzI4M2MxM2UzY2QyNWM0NGU5NWY2NGZiYzU3Yzk=", "commit": {"author": {"name": "Clark Gaebel", "email": "cg.wowus.cg@gmail.com", "date": "2014-12-16T04:01:58Z"}, "committer": {"name": "Clark Gaebel", "email": "cg.wowus.cg@gmail.com", "date": "2014-12-19T14:41:30Z"}, "message": "Add RingBuf::as_slices as per collections reform v2.\n\nSee: https://github.com/rust-lang/rfcs/pull/509\n\nNot sure if this is allowed to land before the RFC. Either way,\nit's here for review.\n\nr? @Gankro\ncc: @bfops", "tree": {"sha": "4f8932cebb2a84453937c0a6578c818f7f255ea7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f8932cebb2a84453937c0a6578c818f7f255ea7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/525f65ebbf67283c13e3cd25c44e95f64fbc57c9", "comment_count": 12, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/525f65ebbf67283c13e3cd25c44e95f64fbc57c9", "html_url": "https://github.com/rust-lang/rust/commit/525f65ebbf67283c13e3cd25c44e95f64fbc57c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/525f65ebbf67283c13e3cd25c44e95f64fbc57c9/comments", "author": null, "committer": null, "parents": [{"sha": "0efafac398ff7f28c5f0fe756c15b9008b3e0534", "url": "https://api.github.com/repos/rust-lang/rust/commits/0efafac398ff7f28c5f0fe756c15b9008b3e0534", "html_url": "https://github.com/rust-lang/rust/commit/0efafac398ff7f28c5f0fe756c15b9008b3e0534"}], "stats": {"total": 113, "additions": 111, "deletions": 2}, "files": [{"sha": "aa5679c43397d579ae7faa2cd523be27b2172475", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 111, "deletions": 2, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/525f65ebbf67283c13e3cd25c44e95f64fbc57c9/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/525f65ebbf67283c13e3cd25c44e95f64fbc57c9/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=525f65ebbf67283c13e3cd25c44e95f64fbc57c9", "patch": "@@ -78,7 +78,13 @@ impl<T> Default for RingBuf<T> {\n impl<T> RingBuf<T> {\n     /// Turn ptr into a slice\n     #[inline]\n-    unsafe fn buffer_as_slice(&self) -> &[T] {\n+    unsafe fn buffer_as_slice<'a>(&'a self) -> &'a [T] {\n+        mem::transmute(RawSlice { data: self.ptr as *const T, len: self.cap })\n+    }\n+\n+    /// Turn ptr into a mut slice\n+    #[inline]\n+    unsafe fn buffer_as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n         mem::transmute(RawSlice { data: self.ptr as *const T, len: self.cap })\n     }\n \n@@ -413,6 +419,48 @@ impl<T> RingBuf<T> {\n         }\n     }\n \n+    /// Returns a pair of slices which contain, in order, the contents of the\n+    /// `RingBuf`.\n+    #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn as_slices<'a>(&'a self) -> (&'a [T], &'a [T]) {\n+        unsafe {\n+            let contiguous = self.is_contiguous();\n+            let buf = self.buffer_as_slice();\n+            if contiguous {\n+                let (empty, buf) = buf.split_at(0);\n+                (buf[self.tail..self.head], empty)\n+            } else {\n+                let (mid, right) = buf.split_at(self.tail);\n+                let (left, _) = mid.split_at(self.head);\n+                (right, left)\n+            }\n+        }\n+    }\n+\n+    /// Returns a pair of slices which contain, in order, the contents of the\n+    /// `RingBuf`.\n+    #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn as_mut_slices<'a>(&'a mut self) -> (&'a mut [T], &'a mut [T]) {\n+        unsafe {\n+            let contiguous = self.is_contiguous();\n+            let head = self.head;\n+            let tail = self.tail;\n+            let buf = self.buffer_as_mut_slice();\n+\n+            if contiguous {\n+                let (empty, buf) = buf.split_at_mut(0);\n+                (buf[mut tail..head], empty)\n+            } else {\n+                let (mid, right) = buf.split_at_mut(tail);\n+                let (left, _) = mid.split_at_mut(head);\n+\n+                (right, left)\n+            }\n+        }\n+    }\n+\n     /// Returns the number of elements in the `RingBuf`.\n     ///\n     /// # Examples\n@@ -663,6 +711,11 @@ impl<T> RingBuf<T> {\n         }\n     }\n \n+    #[inline]\n+    fn is_contiguous(&self) -> bool {\n+        self.tail <= self.head\n+    }\n+\n     /// Inserts an element at position `i` within the ringbuf. Whichever\n     /// end is closer to the insertion point will be moved to make room,\n     /// and all the affected elements will be moved to new positions.\n@@ -715,7 +768,7 @@ impl<T> RingBuf<T> {\n         let distance_to_tail = i;\n         let distance_to_head = self.len() - i;\n \n-        let contiguous = self.tail <= self.head;\n+        let contiguous = self.is_contiguous();\n \n         match (contiguous, distance_to_tail <= distance_to_head, idx >= self.tail) {\n             (true, true, _) if i == 0 => {\n@@ -2132,4 +2185,60 @@ mod tests {\n         ring.pop_front();\n         assert_eq!(ring.front(), None);\n     }\n+\n+    #[test]\n+    fn test_as_slices() {\n+        let mut ring: RingBuf<int> = RingBuf::with_capacity(127);\n+        let cap = ring.capacity() as int;\n+        let first = cap/2;\n+        let last  = cap - first;\n+        for i in range(0, first) {\n+            ring.push_back(i);\n+\n+            let (left, right) = ring.as_slices();\n+            let expected: Vec<_> = range(0, i+1).collect();\n+            assert_eq!(left, expected);\n+            assert_eq!(right, []);\n+        }\n+\n+        for j in range(-last, 0) {\n+            ring.push_front(j);\n+            let (left, right) = ring.as_slices();\n+            let expected_left: Vec<_> = range(-last, j+1).rev().collect();\n+            let expected_right: Vec<_> = range(0, first).collect();\n+            assert_eq!(left, expected_left);\n+            assert_eq!(right, expected_right);\n+        }\n+\n+        assert_eq!(ring.len() as int, cap);\n+        assert_eq!(ring.capacity() as int, cap);\n+    }\n+\n+    #[test]\n+    fn test_as_mut_slices() {\n+        let mut ring: RingBuf<int> = RingBuf::with_capacity(127);\n+        let cap = ring.capacity() as int;\n+        let first = cap/2;\n+        let last  = cap - first;\n+        for i in range(0, first) {\n+            ring.push_back(i);\n+\n+            let (left, right) = ring.as_mut_slices();\n+            let expected: Vec<_> = range(0, i+1).collect();\n+            assert_eq!(left, expected);\n+            assert_eq!(right, []);\n+        }\n+\n+        for j in range(-last, 0) {\n+            ring.push_front(j);\n+            let (left, right) = ring.as_mut_slices();\n+            let expected_left: Vec<_> = range(-last, j+1).rev().collect();\n+            let expected_right: Vec<_> = range(0, first).collect();\n+            assert_eq!(left, expected_left);\n+            assert_eq!(right, expected_right);\n+        }\n+\n+        assert_eq!(ring.len() as int, cap);\n+        assert_eq!(ring.capacity() as int, cap);\n+    }\n }"}]}