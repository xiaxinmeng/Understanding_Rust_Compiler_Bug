{"sha": "c4995cfbd5b265c02d3038d72b8a022cde5f7040", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0OTk1Y2ZiZDViMjY1YzAyZDMwMzhkNzJiOGEwMjJjZGU1ZjcwNDA=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-12-28T12:24:13Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-12-28T13:06:10Z"}, "message": "Better query api and fuzzy search", "tree": {"sha": "d2fdb44eedf6c5e806804a1b874643b52586bb44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2fdb44eedf6c5e806804a1b874643b52586bb44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4995cfbd5b265c02d3038d72b8a022cde5f7040", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4995cfbd5b265c02d3038d72b8a022cde5f7040", "html_url": "https://github.com/rust-lang/rust/commit/c4995cfbd5b265c02d3038d72b8a022cde5f7040", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4995cfbd5b265c02d3038d72b8a022cde5f7040/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e48cd0c3c712cea0267476de974012b2b05b508", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e48cd0c3c712cea0267476de974012b2b05b508", "html_url": "https://github.com/rust-lang/rust/commit/0e48cd0c3c712cea0267476de974012b2b05b508"}], "stats": {"total": 88, "additions": 47, "deletions": 41}, "files": [{"sha": "d09849752064111b56b1fe95d8e63116b06ea756", "filename": "crates/completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4995cfbd5b265c02d3038d72b8a022cde5f7040/crates%2Fcompletion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4995cfbd5b265c02d3038d72b8a022cde5f7040/crates%2Fcompletion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=c4995cfbd5b265c02d3038d72b8a022cde5f7040", "patch": "@@ -135,7 +135,7 @@ fn fuzzy_completion(acc: &mut Completions, ctx: &CompletionContext) -> Option<()\n         ctx.krate?,\n         Some(100),\n         &potential_import_name,\n-        false,\n+        true,\n     )\n     .filter_map(|import_candidate| {\n         Some(match import_candidate {"}, {"sha": "ce25e1c6e9a73bc8b653af5d9a00a30edb9c74a3", "filename": "crates/hir_def/src/import_map.rs", "status": "modified", "additions": 40, "deletions": 33, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/c4995cfbd5b265c02d3038d72b8a022cde5f7040/crates%2Fhir_def%2Fsrc%2Fimport_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4995cfbd5b265c02d3038d72b8a022cde5f7040/crates%2Fhir_def%2Fsrc%2Fimport_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fimport_map.rs?ref=c4995cfbd5b265c02d3038d72b8a022cde5f7040", "patch": "@@ -156,7 +156,8 @@ impl ImportMap {\n             let start = last_batch_start;\n             last_batch_start = idx + 1;\n \n-            let key = fst_string(&importables[start].1.path);\n+            let key = fst_path(&importables[start].1.path);\n+\n             builder.insert(key, start as u64).unwrap();\n         }\n \n@@ -212,15 +213,15 @@ impl fmt::Debug for ImportMap {\n     }\n }\n \n-fn fst_string<T: ToString>(t: &T) -> String {\n-    let mut s = t.to_string();\n+fn fst_path(path: &ImportPath) -> String {\n+    let mut s = path.to_string();\n     s.make_ascii_lowercase();\n     s\n }\n \n fn cmp((_, lhs): &(&ItemInNs, &ImportInfo), (_, rhs): &(&ItemInNs, &ImportInfo)) -> Ordering {\n-    let lhs_str = fst_string(&lhs.path);\n-    let rhs_str = fst_string(&rhs.path);\n+    let lhs_str = fst_path(&lhs.path);\n+    let rhs_str = fst_path(&rhs.path);\n     lhs_str.cmp(&rhs_str)\n }\n \n@@ -237,14 +238,20 @@ pub enum ImportKind {\n     BuiltinType,\n }\n \n+/// todo kb\n+#[derive(Debug)]\n+pub enum SearchMode {\n+    Equals,\n+    Contains,\n+    Fuzzy,\n+}\n+\n #[derive(Debug)]\n pub struct Query {\n     query: String,\n     lowercased: String,\n-    // TODO kb use enums instead?\n     name_only: bool,\n-    name_end: bool,\n-    strict_include: bool,\n+    search_mode: SearchMode,\n     case_sensitive: bool,\n     limit: usize,\n     exclude_import_kinds: FxHashSet<ImportKind>,\n@@ -253,29 +260,23 @@ pub struct Query {\n impl Query {\n     pub fn new(query: &str) -> Self {\n         Self {\n-            lowercased: query.to_lowercase(),\n             query: query.to_string(),\n+            lowercased: query.to_lowercase(),\n             name_only: false,\n-            name_end: false,\n-            strict_include: false,\n+            search_mode: SearchMode::Contains,\n             case_sensitive: false,\n             limit: usize::max_value(),\n             exclude_import_kinds: FxHashSet::default(),\n         }\n     }\n \n-    pub fn name_end(self) -> Self {\n-        Self { name_end: true, ..self }\n-    }\n-\n-    /// todo kb\n     pub fn name_only(self) -> Self {\n         Self { name_only: true, ..self }\n     }\n \n     /// todo kb\n-    pub fn strict_include(self) -> Self {\n-        Self { strict_include: true, ..self }\n+    pub fn search_mode(self, search_mode: SearchMode) -> Self {\n+        Self { search_mode, ..self }\n     }\n \n     /// Limits the returned number of items to `limit`.\n@@ -309,18 +310,24 @@ fn contains_query(query: &Query, input_path: &ImportPath, enforce_lowercase: boo\n     let query_string =\n         if !enforce_lowercase && query.case_sensitive { &query.query } else { &query.lowercased };\n \n-    if query.strict_include {\n-        if query.name_end {\n-            &input == query_string\n-        } else {\n-            input.contains(query_string)\n+    match query.search_mode {\n+        SearchMode::Equals => &input == query_string,\n+        SearchMode::Contains => input.contains(query_string),\n+        SearchMode::Fuzzy => {\n+            let mut unchecked_query_chars = query_string.chars();\n+            let mut mismatching_query_char = unchecked_query_chars.next();\n+\n+            for input_char in input.chars() {\n+                match mismatching_query_char {\n+                    None => return true,\n+                    Some(matching_query_char) if matching_query_char == input_char => {\n+                        mismatching_query_char = unchecked_query_chars.next();\n+                    }\n+                    _ => (),\n+                }\n+            }\n+            mismatching_query_char.is_none()\n         }\n-    } else if query.name_end {\n-        input.ends_with(query_string)\n-    } else {\n-        let input_chars = input.chars().collect::<FxHashSet<_>>();\n-        // TODO kb actually check for the order and the quantity\n-        query_string.chars().all(|query_char| input_chars.contains(&query_char))\n     }\n }\n \n@@ -358,14 +365,14 @@ pub fn search_dependencies<'a>(\n                 continue;\n             }\n \n-            let common_importables_path_fst = fst_string(common_importables_path);\n+            let common_importables_path_fst = fst_path(common_importables_path);\n             // Add the items from this `ModPath` group. Those are all subsequent items in\n             // `importables` whose paths match `path`.\n             let iter = importables\n                 .iter()\n                 .copied()\n                 .take_while(|item| {\n-                    common_importables_path_fst == fst_string(&import_map.map[item].path)\n+                    common_importables_path_fst == fst_path(&import_map.map[item].path)\n                 })\n                 .filter(|&item| match item_import_kind(item) {\n                     Some(import_kind) => !query.exclude_import_kinds.contains(&import_kind),\n@@ -741,7 +748,7 @@ mod tests {\n         check_search(\n             ra_fixture,\n             \"main\",\n-            Query::new(\"fmt\"),\n+            Query::new(\"fmt\").search_mode(SearchMode::Fuzzy),\n             expect![[r#\"\n                 dep::fmt (t)\n                 dep::Fmt (t)\n@@ -756,7 +763,7 @@ mod tests {\n         check_search(\n             ra_fixture,\n             \"main\",\n-            Query::new(\"fmt\").name_only().strict_include(),\n+            Query::new(\"fmt\").name_only().search_mode(SearchMode::Equals),\n             expect![[r#\"\n                 dep::fmt (t)\n                 dep::Fmt (t)"}, {"sha": "986cb5b8363698d8c3b77ec87f1c84efbb546d4f", "filename": "crates/ide_db/src/imports_locator.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c4995cfbd5b265c02d3038d72b8a022cde5f7040/crates%2Fide_db%2Fsrc%2Fimports_locator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4995cfbd5b265c02d3038d72b8a022cde5f7040/crates%2Fide_db%2Fsrc%2Fimports_locator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fimports_locator.rs?ref=c4995cfbd5b265c02d3038d72b8a022cde5f7040", "patch": "@@ -30,8 +30,7 @@ pub fn find_exact_imports<'a>(\n         import_map::Query::new(name_to_import)\n             .limit(40)\n             .name_only()\n-            .name_end()\n-            .strict_include()\n+            .search_mode(import_map::SearchMode::Equals)\n             .case_sensitive(),\n     )\n }\n@@ -41,14 +40,14 @@ pub fn find_similar_imports<'a>(\n     krate: Crate,\n     limit: Option<usize>,\n     name_to_import: &str,\n-    // TODO kb change it to search across the whole path or not?\n-    ignore_modules: bool,\n+    name_only: bool,\n ) -> impl Iterator<Item = Either<ModuleDef, MacroDef>> {\n     let _p = profile::span(\"find_similar_imports\");\n \n-    let mut external_query = import_map::Query::new(name_to_import).name_only();\n-    if ignore_modules {\n-        external_query = external_query.exclude_import_kind(import_map::ImportKind::Module);\n+    let mut external_query =\n+        import_map::Query::new(name_to_import).search_mode(import_map::SearchMode::Fuzzy);\n+    if name_only {\n+        external_query = external_query.name_only();\n     }\n \n     let mut local_query = symbol_index::Query::new(name_to_import.to_string());"}]}