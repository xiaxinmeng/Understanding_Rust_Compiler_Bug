{"sha": "0881b3abe424034b0c69b99632b64b355057f203", "node_id": "C_kwDOAAsO6NoAKDA4ODFiM2FiZTQyNDAzNGIwYzY5Yjk5NjMyYjY0YjM1NTA1N2YyMDM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-27T07:58:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-27T07:58:00Z"}, "message": "Auto merge of #90846 - cuviper:weak, r=dtolnay\n\nRefactor weak symbols in std::sys::unix\n\nThis makes a few changes to the weak symbol macros in `sys::unix`:\n\n- `dlsym!` is added to keep the functionality for runtime `dlsym`\n  lookups, like for `__pthread_get_minstack@GLIBC_PRIVATE` that we don't\n  want to show up in ELF symbol tables.\n- `weak!` now uses `#[linkage = \"extern_weak\"]` symbols, so its runtime\n  behavior is just a simple null check. This is also used by `syscall!`.\n  - On non-ELF targets (macos/ios) where that linkage is not known to\n    behave, `weak!` is just an alias to `dlsym!` for the old behavior.\n- `raw_syscall!` is added to always call `libc::syscall` on linux and\n  android, for cases like `clone3` that have no known libc wrapper.\n\nThe new `weak!` linkage does mean that you'll get versioned symbols if\nyou build with a newer glibc, like `WEAK DEFAULT UND statx@GLIBC_2.28`.\nThis might seem problematic, but old non-weak symbols can tie the build\nto new versions too, like `dlsym@GLIBC_2.34` from their recent library\nunification. If you build with an old glibc like `dist-x86_64-linux`\ndoes, you'll still get unversioned `WEAK DEFAULT UND statx`, which may\nbe resolved based on the runtime glibc.\n\nI also found a few functions that don't need to be weak anymore:\n\n- Android can directly use `ftruncate64`, `pread64`, and `pwrite64`, as\n  these were added in API 12, and our baseline is API 14.\n- Linux can directly use `splice`, added way back in glibc 2.5 and\n  similarly old musl. Android only added it in API 21 though.", "tree": {"sha": "b1b742682a20508ad2e4dfc41a992b27a991383c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1b742682a20508ad2e4dfc41a992b27a991383c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0881b3abe424034b0c69b99632b64b355057f203", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0881b3abe424034b0c69b99632b64b355057f203", "html_url": "https://github.com/rust-lang/rust/commit/0881b3abe424034b0c69b99632b64b355057f203", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0881b3abe424034b0c69b99632b64b355057f203/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84826fec957aa17b0e068775c1c5574f707d43b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/84826fec957aa17b0e068775c1c5574f707d43b0", "html_url": "https://github.com/rust-lang/rust/commit/84826fec957aa17b0e068775c1c5574f707d43b0"}, {"sha": "5ff6ac4287e191ee684f1de1af642e7b656947b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ff6ac4287e191ee684f1de1af642e7b656947b6", "html_url": "https://github.com/rust-lang/rust/commit/5ff6ac4287e191ee684f1de1af642e7b656947b6"}], "stats": {"total": 325, "additions": 134, "deletions": 191}, "files": [{"sha": "73ff10ab8a221ccad212d9f231caa13fbc5b333d", "filename": "library/std/src/sys/unix/android.rs", "status": "modified", "additions": 2, "deletions": 88, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/0881b3abe424034b0c69b99632b64b355057f203/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fandroid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0881b3abe424034b0c69b99632b64b355057f203/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fandroid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fandroid.rs?ref=0881b3abe424034b0c69b99632b64b355057f203", "patch": "@@ -18,11 +18,9 @@\n \n #![cfg(target_os = \"android\")]\n \n-use libc::{c_int, c_void, sighandler_t, size_t, ssize_t};\n-use libc::{ftruncate, pread, pwrite};\n+use libc::{c_int, sighandler_t};\n \n-use super::{cvt, cvt_r, weak::weak};\n-use crate::io;\n+use super::weak::weak;\n \n // The `log2` and `log2f` functions apparently appeared in android-18, or at\n // least you can see they're not present in the android-17 header [1] and they\n@@ -81,87 +79,3 @@ pub unsafe fn signal(signum: c_int, handler: sighandler_t) -> sighandler_t {\n     let f = f.expect(\"neither `signal` nor `bsd_signal` symbols found\");\n     f(signum, handler)\n }\n-\n-// The `ftruncate64` symbol apparently appeared in android-12, so we do some\n-// dynamic detection to see if we can figure out whether `ftruncate64` exists.\n-//\n-// If it doesn't we just fall back to `ftruncate`, generating an error for\n-// too-large values.\n-#[cfg(target_pointer_width = \"32\")]\n-pub fn ftruncate64(fd: c_int, size: u64) -> io::Result<()> {\n-    weak!(fn ftruncate64(c_int, i64) -> c_int);\n-\n-    unsafe {\n-        match ftruncate64.get() {\n-            Some(f) => cvt_r(|| f(fd, size as i64)).map(drop),\n-            None => {\n-                if size > i32::MAX as u64 {\n-                    Err(io::Error::new_const(io::ErrorKind::InvalidInput, &\"cannot truncate >2GB\"))\n-                } else {\n-                    cvt_r(|| ftruncate(fd, size as i32)).map(drop)\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(target_pointer_width = \"64\")]\n-pub fn ftruncate64(fd: c_int, size: u64) -> io::Result<()> {\n-    unsafe { cvt_r(|| ftruncate(fd, size as i64)).map(drop) }\n-}\n-\n-#[cfg(target_pointer_width = \"32\")]\n-pub unsafe fn cvt_pread64(\n-    fd: c_int,\n-    buf: *mut c_void,\n-    count: size_t,\n-    offset: i64,\n-) -> io::Result<ssize_t> {\n-    use crate::convert::TryInto;\n-    weak!(fn pread64(c_int, *mut c_void, size_t, i64) -> ssize_t);\n-    pread64.get().map(|f| cvt(f(fd, buf, count, offset))).unwrap_or_else(|| {\n-        if let Ok(o) = offset.try_into() {\n-            cvt(pread(fd, buf, count, o))\n-        } else {\n-            Err(io::Error::new_const(io::ErrorKind::InvalidInput, &\"cannot pread >2GB\"))\n-        }\n-    })\n-}\n-\n-#[cfg(target_pointer_width = \"32\")]\n-pub unsafe fn cvt_pwrite64(\n-    fd: c_int,\n-    buf: *const c_void,\n-    count: size_t,\n-    offset: i64,\n-) -> io::Result<ssize_t> {\n-    use crate::convert::TryInto;\n-    weak!(fn pwrite64(c_int, *const c_void, size_t, i64) -> ssize_t);\n-    pwrite64.get().map(|f| cvt(f(fd, buf, count, offset))).unwrap_or_else(|| {\n-        if let Ok(o) = offset.try_into() {\n-            cvt(pwrite(fd, buf, count, o))\n-        } else {\n-            Err(io::Error::new_const(io::ErrorKind::InvalidInput, &\"cannot pwrite >2GB\"))\n-        }\n-    })\n-}\n-\n-#[cfg(target_pointer_width = \"64\")]\n-pub unsafe fn cvt_pread64(\n-    fd: c_int,\n-    buf: *mut c_void,\n-    count: size_t,\n-    offset: i64,\n-) -> io::Result<ssize_t> {\n-    cvt(pread(fd, buf, count, offset))\n-}\n-\n-#[cfg(target_pointer_width = \"64\")]\n-pub unsafe fn cvt_pwrite64(\n-    fd: c_int,\n-    buf: *const c_void,\n-    count: size_t,\n-    offset: i64,\n-) -> io::Result<ssize_t> {\n-    cvt(pwrite(fd, buf, count, offset))\n-}"}, {"sha": "ea688571a9891ff907fc96b2351ae217d936a660", "filename": "library/std/src/sys/unix/fd.rs", "status": "modified", "additions": 12, "deletions": 36, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0881b3abe424034b0c69b99632b64b355057f203/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0881b3abe424034b0c69b99632b64b355057f203/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs?ref=0881b3abe424034b0c69b99632b64b355057f203", "patch": "@@ -99,30 +99,18 @@ impl FileDesc {\n     }\n \n     pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n-        #[cfg(target_os = \"android\")]\n-        use super::android::cvt_pread64;\n-\n-        #[cfg(not(target_os = \"android\"))]\n-        unsafe fn cvt_pread64(\n-            fd: c_int,\n-            buf: *mut c_void,\n-            count: usize,\n-            offset: i64,\n-        ) -> io::Result<isize> {\n-            #[cfg(not(target_os = \"linux\"))]\n-            use libc::pread as pread64;\n-            #[cfg(target_os = \"linux\")]\n-            use libc::pread64;\n-            cvt(pread64(fd, buf, count, offset))\n-        }\n+        #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n+        use libc::pread as pread64;\n+        #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+        use libc::pread64;\n \n         unsafe {\n-            cvt_pread64(\n+            cvt(pread64(\n                 self.as_raw_fd(),\n                 buf.as_mut_ptr() as *mut c_void,\n                 cmp::min(buf.len(), READ_LIMIT),\n                 offset as i64,\n-            )\n+            ))\n             .map(|n| n as usize)\n         }\n     }\n@@ -161,30 +149,18 @@ impl FileDesc {\n     }\n \n     pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n-        #[cfg(target_os = \"android\")]\n-        use super::android::cvt_pwrite64;\n-\n-        #[cfg(not(target_os = \"android\"))]\n-        unsafe fn cvt_pwrite64(\n-            fd: c_int,\n-            buf: *const c_void,\n-            count: usize,\n-            offset: i64,\n-        ) -> io::Result<isize> {\n-            #[cfg(not(target_os = \"linux\"))]\n-            use libc::pwrite as pwrite64;\n-            #[cfg(target_os = \"linux\")]\n-            use libc::pwrite64;\n-            cvt(pwrite64(fd, buf, count, offset))\n-        }\n+        #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n+        use libc::pwrite as pwrite64;\n+        #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+        use libc::pwrite64;\n \n         unsafe {\n-            cvt_pwrite64(\n+            cvt(pwrite64(\n                 self.as_raw_fd(),\n                 buf.as_ptr() as *const c_void,\n                 cmp::min(buf.len(), READ_LIMIT),\n                 offset as i64,\n-            )\n+            ))\n             .map(|n| n as usize)\n         }\n     }"}, {"sha": "d77e5cae3ad7366964f9e51738580cf8e8879c89", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0881b3abe424034b0c69b99632b64b355057f203/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0881b3abe424034b0c69b99632b64b355057f203/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=0881b3abe424034b0c69b99632b64b355057f203", "patch": "@@ -46,8 +46,8 @@ use libc::fstatat64;\n use libc::readdir_r as readdir64_r;\n #[cfg(target_os = \"android\")]\n use libc::{\n-    dirent as dirent64, fstat as fstat64, fstatat as fstatat64, lseek64, lstat as lstat64,\n-    open as open64, stat as stat64,\n+    dirent as dirent64, fstat as fstat64, fstatat as fstatat64, ftruncate64, lseek64,\n+    lstat as lstat64, off64_t, open as open64, stat as stat64,\n };\n #[cfg(not(any(\n     target_os = \"linux\",\n@@ -835,16 +835,10 @@ impl File {\n     }\n \n     pub fn truncate(&self, size: u64) -> io::Result<()> {\n-        #[cfg(target_os = \"android\")]\n-        return crate::sys::android::ftruncate64(self.as_raw_fd(), size);\n-\n-        #[cfg(not(target_os = \"android\"))]\n-        {\n-            use crate::convert::TryInto;\n-            let size: off64_t =\n-                size.try_into().map_err(|e| io::Error::new(io::ErrorKind::InvalidInput, e))?;\n-            cvt_r(|| unsafe { ftruncate64(self.as_raw_fd(), size) }).map(drop)\n-        }\n+        use crate::convert::TryInto;\n+        let size: off64_t =\n+            size.try_into().map_err(|e| io::Error::new(io::ErrorKind::InvalidInput, e))?;\n+        cvt_r(|| unsafe { ftruncate64(self.as_raw_fd(), size) }).map(drop)\n     }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n@@ -1154,7 +1148,7 @@ pub fn link(original: &Path, link: &Path) -> io::Result<()> {\n         } else if #[cfg(target_os = \"macos\")] {\n             // On MacOS, older versions (<=10.9) lack support for linkat while newer\n             // versions have it. We want to use linkat if it is available, so we use weak!\n-            // to check. `linkat` is preferable to `link` ecause it gives us a flag to\n+            // to check. `linkat` is preferable to `link` because it gives us a flag to\n             // specify how symlinks should be handled. We pass 0 as the flags argument,\n             // meaning it shouldn't follow symlinks.\n             weak!(fn linkat(c_int, *const c_char, c_int, *const c_char, c_int) -> c_int);"}, {"sha": "241cf89d3145c6cfcd20dac0b125b31d14cd64b9", "filename": "library/std/src/sys/unix/kernel_copy.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0881b3abe424034b0c69b99632b64b355057f203/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0881b3abe424034b0c69b99632b64b355057f203/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs?ref=0881b3abe424034b0c69b99632b64b355057f203", "patch": "@@ -614,6 +614,9 @@ fn sendfile_splice(mode: SpliceMode, reader: RawFd, writer: RawFd, len: u64) ->\n     static HAS_SENDFILE: AtomicBool = AtomicBool::new(true);\n     static HAS_SPLICE: AtomicBool = AtomicBool::new(true);\n \n+    // Android builds use feature level 14, but the libc wrapper for splice is\n+    // gated on feature level 21+, so we have to invoke the syscall directly.\n+    #[cfg(target_os = \"android\")]\n     syscall! {\n         fn splice(\n             srcfd: libc::c_int,\n@@ -625,6 +628,9 @@ fn sendfile_splice(mode: SpliceMode, reader: RawFd, writer: RawFd, len: u64) ->\n         ) -> libc::ssize_t\n     }\n \n+    #[cfg(target_os = \"linux\")]\n+    use libc::splice;\n+\n     match mode {\n         SpliceMode::Sendfile if !HAS_SENDFILE.load(Ordering::Relaxed) => {\n             return CopyResult::Fallback(0);"}, {"sha": "a82a0172126d4fa51066b4b5313712cb61ffe812", "filename": "library/std/src/sys/unix/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0881b3abe424034b0c69b99632b64b355057f203/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0881b3abe424034b0c69b99632b64b355057f203/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs?ref=0881b3abe424034b0c69b99632b64b355057f203", "patch": "@@ -501,7 +501,7 @@ impl FromRawFd for Socket {\n // res_init unconditionally, we call it only when we detect we're linking\n // against glibc version < 2.26. (That is, when we both know its needed and\n // believe it's thread-safe).\n-#[cfg(all(target_env = \"gnu\", not(target_os = \"vxworks\")))]\n+#[cfg(all(target_os = \"linux\", target_env = \"gnu\"))]\n fn on_resolver_failure() {\n     use crate::sys;\n \n@@ -513,5 +513,5 @@ fn on_resolver_failure() {\n     }\n }\n \n-#[cfg(any(not(target_env = \"gnu\"), target_os = \"vxworks\"))]\n+#[cfg(not(all(target_os = \"linux\", target_env = \"gnu\")))]\n fn on_resolver_failure() {}"}, {"sha": "7686b61b67a892de9ae9bfa7d25ada0448c0efde", "filename": "library/std/src/sys/unix/os.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0881b3abe424034b0c69b99632b64b355057f203/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0881b3abe424034b0c69b99632b64b355057f203/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs?ref=0881b3abe424034b0c69b99632b64b355057f203", "patch": "@@ -2,7 +2,7 @@\n \n #![allow(unused_imports)] // lots of cfg code here\n \n-#[cfg(all(test, target_env = \"gnu\"))]\n+#[cfg(test)]\n mod tests;\n \n use crate::os::unix::prelude::*;\n@@ -636,30 +636,22 @@ pub fn getppid() -> u32 {\n     unsafe { libc::getppid() as u32 }\n }\n \n-#[cfg(all(target_env = \"gnu\", not(target_os = \"vxworks\")))]\n+#[cfg(all(target_os = \"linux\", target_env = \"gnu\"))]\n pub fn glibc_version() -> Option<(usize, usize)> {\n-    if let Some(Ok(version_str)) = glibc_version_cstr().map(CStr::to_str) {\n-        parse_glibc_version(version_str)\n-    } else {\n-        None\n-    }\n-}\n-\n-#[cfg(all(target_env = \"gnu\", not(target_os = \"vxworks\")))]\n-fn glibc_version_cstr() -> Option<&'static CStr> {\n-    weak! {\n-        fn gnu_get_libc_version() -> *const libc::c_char\n+    extern \"C\" {\n+        fn gnu_get_libc_version() -> *const libc::c_char;\n     }\n-    if let Some(f) = gnu_get_libc_version.get() {\n-        unsafe { Some(CStr::from_ptr(f())) }\n+    let version_cstr = unsafe { CStr::from_ptr(gnu_get_libc_version()) };\n+    if let Ok(version_str) = version_cstr.to_str() {\n+        parse_glibc_version(version_str)\n     } else {\n         None\n     }\n }\n \n // Returns Some((major, minor)) if the string is a valid \"x.y\" version,\n // ignoring any extra dot-separated parts. Otherwise return None.\n-#[cfg(all(target_env = \"gnu\", not(target_os = \"vxworks\")))]\n+#[cfg(all(target_os = \"linux\", target_env = \"gnu\"))]\n fn parse_glibc_version(version: &str) -> Option<(usize, usize)> {\n     let mut parsed_ints = version.split('.').map(str::parse::<usize>).fuse();\n     match (parsed_ints.next(), parsed_ints.next()) {"}, {"sha": "efc29955b05fea7eac7ebe2c41a4ef6c796bc120", "filename": "library/std/src/sys/unix/os/tests.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0881b3abe424034b0c69b99632b64b355057f203/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0881b3abe424034b0c69b99632b64b355057f203/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos%2Ftests.rs?ref=0881b3abe424034b0c69b99632b64b355057f203", "patch": "@@ -1,14 +1,12 @@\n-use super::*;\n-\n #[test]\n-#[cfg(not(target_os = \"vxworks\"))]\n+#[cfg(all(target_os = \"linux\", target_env = \"gnu\"))]\n fn test_glibc_version() {\n     // This mostly just tests that the weak linkage doesn't panic wildly...\n-    glibc_version();\n+    super::glibc_version();\n }\n \n #[test]\n-#[cfg(not(target_os = \"vxworks\"))]\n+#[cfg(all(target_os = \"linux\", target_env = \"gnu\"))]\n fn test_parse_glibc_version() {\n     let cases = [\n         (\"0.0\", Some((0, 0))),\n@@ -20,6 +18,6 @@ fn test_parse_glibc_version() {\n         (\"foo.1\", None),\n     ];\n     for &(version_str, parsed) in cases.iter() {\n-        assert_eq!(parsed, parse_glibc_version(version_str));\n+        assert_eq!(parsed, super::parse_glibc_version(version_str));\n     }\n }"}, {"sha": "bce35b380e677075da4f2f2a43024787b5d6b378", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0881b3abe424034b0c69b99632b64b355057f203/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0881b3abe424034b0c69b99632b64b355057f203/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=0881b3abe424034b0c69b99632b64b355057f203", "patch": "@@ -13,7 +13,7 @@ use crate::sys::process::process_common::*;\n use crate::os::linux::process::PidFd;\n \n #[cfg(target_os = \"linux\")]\n-use crate::sys::weak::syscall;\n+use crate::sys::weak::raw_syscall;\n \n #[cfg(any(\n     target_os = \"macos\",\n@@ -162,7 +162,7 @@ impl Command {\n             cgroup: u64,\n         }\n \n-        syscall! {\n+        raw_syscall! {\n             fn clone3(cl_args: *mut clone_args, len: libc::size_t) -> libc::c_long\n         }\n "}, {"sha": "9e02966b57c0d1066486eca3c1fadd507055a364", "filename": "library/std/src/sys/unix/thread.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0881b3abe424034b0c69b99632b64b355057f203/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0881b3abe424034b0c69b99632b64b355057f203/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs?ref=0881b3abe424034b0c69b99632b64b355057f203", "patch": "@@ -7,7 +7,9 @@ use crate::ptr;\n use crate::sys::{os, stack_overflow};\n use crate::time::Duration;\n \n-#[cfg(any(target_os = \"linux\", target_os = \"solaris\", target_os = \"illumos\"))]\n+#[cfg(all(target_os = \"linux\", target_env = \"gnu\"))]\n+use crate::sys::weak::dlsym;\n+#[cfg(any(target_os = \"solaris\", target_os = \"illumos\"))]\n use crate::sys::weak::weak;\n #[cfg(not(any(target_os = \"l4re\", target_os = \"vxworks\", target_os = \"espidf\")))]\n pub const DEFAULT_MIN_STACK_SIZE: usize = 2 * 1024 * 1024;\n@@ -627,20 +629,21 @@ pub mod guard {\n // We need that information to avoid blowing up when a small stack\n // is created in an application with big thread-local storage requirements.\n // See #6233 for rationale and details.\n-#[cfg(target_os = \"linux\")]\n-#[allow(deprecated)]\n+#[cfg(all(target_os = \"linux\", target_env = \"gnu\"))]\n fn min_stack_size(attr: *const libc::pthread_attr_t) -> usize {\n-    weak!(fn __pthread_get_minstack(*const libc::pthread_attr_t) -> libc::size_t);\n+    // We use dlsym to avoid an ELF version dependency on GLIBC_PRIVATE. (#23628)\n+    // We shouldn't really be using such an internal symbol, but there's currently\n+    // no other way to account for the TLS size.\n+    dlsym!(fn __pthread_get_minstack(*const libc::pthread_attr_t) -> libc::size_t);\n \n     match __pthread_get_minstack.get() {\n         None => libc::PTHREAD_STACK_MIN,\n         Some(f) => unsafe { f(attr) },\n     }\n }\n \n-// No point in looking up __pthread_get_minstack() on non-glibc\n-// platforms.\n-#[cfg(all(not(target_os = \"linux\"), not(target_os = \"netbsd\")))]\n+// No point in looking up __pthread_get_minstack() on non-glibc platforms.\n+#[cfg(all(not(all(target_os = \"linux\", target_env = \"gnu\")), not(target_os = \"netbsd\")))]\n fn min_stack_size(_: *const libc::pthread_attr_t) -> usize {\n     libc::PTHREAD_STACK_MIN\n }"}, {"sha": "32072affe8af45f20c8862e23f73fe7fa059b5a2", "filename": "library/std/src/sys/unix/weak.rs", "status": "modified", "additions": 81, "deletions": 21, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/0881b3abe424034b0c69b99632b64b355057f203/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0881b3abe424034b0c69b99632b64b355057f203/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs?ref=0881b3abe424034b0c69b99632b64b355057f203", "patch": "@@ -6,47 +6,92 @@\n //! detection.\n //!\n //! One option to use here is weak linkage, but that is unfortunately only\n-//! really workable on Linux. Hence, use dlsym to get the symbol value at\n+//! really workable with ELF. Otherwise, use dlsym to get the symbol value at\n //! runtime. This is also done for compatibility with older versions of glibc,\n //! and to avoid creating dependencies on GLIBC_PRIVATE symbols. It assumes that\n //! we've been dynamically linked to the library the symbol comes from, but that\n //! is currently always the case for things like libpthread/libc.\n //!\n //! A long time ago this used weak linkage for the __pthread_get_minstack\n //! symbol, but that caused Debian to detect an unnecessarily strict versioned\n-//! dependency on libc6 (#23628).\n+//! dependency on libc6 (#23628) because it is GLIBC_PRIVATE. We now use `dlsym`\n+//! for a runtime lookup of that symbol to avoid the ELF versioned dependency.\n \n // There are a variety of `#[cfg]`s controlling which targets are involved in\n // each instance of `weak!` and `syscall!`. Rather than trying to unify all of\n // that, we'll just allow that some unix targets don't use this module at all.\n #![allow(dead_code, unused_macros)]\n \n use crate::ffi::CStr;\n-use crate::marker;\n+use crate::marker::PhantomData;\n use crate::mem;\n use crate::sync::atomic::{self, AtomicUsize, Ordering};\n \n+// We can use true weak linkage on ELF targets.\n+#[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n pub(crate) macro weak {\n     (fn $name:ident($($t:ty),*) -> $ret:ty) => (\n-        #[allow(non_upper_case_globals)]\n-        static $name: crate::sys::weak::Weak<unsafe extern \"C\" fn($($t),*) -> $ret> =\n-            crate::sys::weak::Weak::new(concat!(stringify!($name), '\\0'));\n+        let ref $name: ExternWeak<unsafe extern \"C\" fn($($t),*) -> $ret> = {\n+            extern \"C\" {\n+                #[linkage = \"extern_weak\"]\n+                static $name: *const libc::c_void;\n+            }\n+            #[allow(unused_unsafe)]\n+            ExternWeak::new(unsafe { $name })\n+        };\n     )\n }\n \n-pub struct Weak<F> {\n+// On non-ELF targets, use the dlsym approximation of weak linkage.\n+#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+pub(crate) use self::dlsym as weak;\n+\n+pub(crate) struct ExternWeak<F> {\n+    weak_ptr: *const libc::c_void,\n+    _marker: PhantomData<F>,\n+}\n+\n+impl<F> ExternWeak<F> {\n+    #[inline]\n+    pub(crate) fn new(weak_ptr: *const libc::c_void) -> Self {\n+        ExternWeak { weak_ptr, _marker: PhantomData }\n+    }\n+}\n+\n+impl<F> ExternWeak<F> {\n+    #[inline]\n+    pub(crate) fn get(&self) -> Option<F> {\n+        unsafe {\n+            if self.weak_ptr.is_null() {\n+                None\n+            } else {\n+                Some(mem::transmute_copy::<*const libc::c_void, F>(&self.weak_ptr))\n+            }\n+        }\n+    }\n+}\n+\n+pub(crate) macro dlsym {\n+    (fn $name:ident($($t:ty),*) -> $ret:ty) => (\n+        static DLSYM: DlsymWeak<unsafe extern \"C\" fn($($t),*) -> $ret> =\n+            DlsymWeak::new(concat!(stringify!($name), '\\0'));\n+        let $name = &DLSYM;\n+    )\n+}\n+\n+pub(crate) struct DlsymWeak<F> {\n     name: &'static str,\n     addr: AtomicUsize,\n-    _marker: marker::PhantomData<F>,\n+    _marker: PhantomData<F>,\n }\n \n-impl<F> Weak<F> {\n-    pub const fn new(name: &'static str) -> Weak<F> {\n-        Weak { name, addr: AtomicUsize::new(1), _marker: marker::PhantomData }\n+impl<F> DlsymWeak<F> {\n+    pub(crate) const fn new(name: &'static str) -> Self {\n+        DlsymWeak { name, addr: AtomicUsize::new(1), _marker: PhantomData }\n     }\n \n-    pub fn get(&self) -> Option<F> {\n-        assert_eq!(mem::size_of::<F>(), mem::size_of::<usize>());\n+    #[inline]\n+    pub(crate) fn get(&self) -> Option<F> {\n         unsafe {\n             // Relaxed is fine here because we fence before reading through the\n             // pointer (see the comment below).\n@@ -82,6 +127,8 @@ impl<F> Weak<F> {\n     // Cold because it should only happen during first-time initalization.\n     #[cold]\n     unsafe fn initialize(&self) -> Option<F> {\n+        assert_eq!(mem::size_of::<F>(), mem::size_of::<usize>());\n+\n         let val = fetch(self.name);\n         // This synchronizes with the acquire fence in `get`.\n         self.addr.store(val, Ordering::Release);\n@@ -105,14 +152,12 @@ unsafe fn fetch(name: &str) -> usize {\n pub(crate) macro syscall {\n     (fn $name:ident($($arg_name:ident: $t:ty),*) -> $ret:ty) => (\n         unsafe fn $name($($arg_name: $t),*) -> $ret {\n-            use super::os;\n-\n             weak! { fn $name($($t),*) -> $ret }\n \n             if let Some(fun) = $name.get() {\n                 fun($($arg_name),*)\n             } else {\n-                os::set_errno(libc::ENOSYS);\n+                super::os::set_errno(libc::ENOSYS);\n                 -1\n             }\n         }\n@@ -123,18 +168,17 @@ pub(crate) macro syscall {\n pub(crate) macro syscall {\n     (fn $name:ident($($arg_name:ident: $t:ty),*) -> $ret:ty) => (\n         unsafe fn $name($($arg_name:$t),*) -> $ret {\n-            use weak;\n-            // This looks like a hack, but concat_idents only accepts idents\n-            // (not paths).\n-            use libc::*;\n-\n             weak! { fn $name($($t),*) -> $ret }\n \n             // Use a weak symbol from libc when possible, allowing `LD_PRELOAD`\n             // interposition, but if it's not found just use a raw syscall.\n             if let Some(fun) = $name.get() {\n                 fun($($arg_name),*)\n             } else {\n+                // This looks like a hack, but concat_idents only accepts idents\n+                // (not paths).\n+                use libc::*;\n+\n                 syscall(\n                     concat_idents!(SYS_, $name),\n                     $($arg_name),*\n@@ -143,3 +187,19 @@ pub(crate) macro syscall {\n         }\n     )\n }\n+\n+#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+pub(crate) macro raw_syscall {\n+    (fn $name:ident($($arg_name:ident: $t:ty),*) -> $ret:ty) => (\n+        unsafe fn $name($($arg_name:$t),*) -> $ret {\n+            // This looks like a hack, but concat_idents only accepts idents\n+            // (not paths).\n+            use libc::*;\n+\n+            syscall(\n+                concat_idents!(SYS_, $name),\n+                $($arg_name),*\n+            ) as $ret\n+        }\n+    )\n+}"}]}