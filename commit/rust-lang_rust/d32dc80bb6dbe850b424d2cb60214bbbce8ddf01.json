{"sha": "d32dc80bb6dbe850b424d2cb60214bbbce8ddf01", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzMmRjODBiYjZkYmU4NTBiNDI0ZDJjYjYwMjE0YmJiY2U4ZGRmMDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-05T04:37:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-05T04:37:12Z"}, "message": "Auto merge of #88559 - bjorn3:archive_logic_dedup, r=cjgillot\n\nMove add_rlib and add_native_library to cg_ssa\n\nThis deduplicates logic between codegen backends.\n\ncc `@antoyo` and `@khyperia` for cg_gcc and rust-gpu.", "tree": {"sha": "acb03aac7ea5d5458db871229e798080d5783961", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/acb03aac7ea5d5458db871229e798080d5783961"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d32dc80bb6dbe850b424d2cb60214bbbce8ddf01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d32dc80bb6dbe850b424d2cb60214bbbce8ddf01", "html_url": "https://github.com/rust-lang/rust/commit/d32dc80bb6dbe850b424d2cb60214bbbce8ddf01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d32dc80bb6dbe850b424d2cb60214bbbce8ddf01/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0961e688fda35a664b5869dcfe1295b00538c7ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/0961e688fda35a664b5869dcfe1295b00538c7ae", "html_url": "https://github.com/rust-lang/rust/commit/0961e688fda35a664b5869dcfe1295b00538c7ae"}, {"sha": "977f279553ab2a7ab754bdbef5e33a19b29f1803", "url": "https://api.github.com/repos/rust-lang/rust/commits/977f279553ab2a7ab754bdbef5e33a19b29f1803", "html_url": "https://github.com/rust-lang/rust/commit/977f279553ab2a7ab754bdbef5e33a19b29f1803"}], "stats": {"total": 247, "additions": 84, "deletions": 163}, "files": [{"sha": "0fa228fc944a160c226f21c2ebec660c1192ba7c", "filename": "compiler/rustc_codegen_cranelift/src/archive.rs", "status": "modified", "additions": 19, "deletions": 64, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/d32dc80bb6dbe850b424d2cb60214bbbce8ddf01/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32dc80bb6dbe850b424d2cb60214bbbce8ddf01/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs?ref=d32dc80bb6dbe850b424d2cb60214bbbce8ddf01", "patch": "@@ -4,8 +4,7 @@ use std::collections::BTreeMap;\n use std::fs::File;\n use std::path::{Path, PathBuf};\n \n-use rustc_codegen_ssa::back::archive::{find_library, ArchiveBuilder};\n-use rustc_codegen_ssa::METADATA_FILENAME;\n+use rustc_codegen_ssa::back::archive::ArchiveBuilder;\n use rustc_session::Session;\n \n use object::{Object, ObjectSymbol, SymbolKind};\n@@ -19,7 +18,6 @@ enum ArchiveEntry {\n pub(crate) struct ArArchiveBuilder<'a> {\n     sess: &'a Session,\n     dst: PathBuf,\n-    lib_search_paths: Vec<PathBuf>,\n     use_gnu_style_archive: bool,\n     no_builtin_ranlib: bool,\n \n@@ -31,8 +29,6 @@ pub(crate) struct ArArchiveBuilder<'a> {\n \n impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n     fn new(sess: &'a Session, output: &Path, input: Option<&Path>) -> Self {\n-        use rustc_codegen_ssa::back::link::archive_search_paths;\n-\n         let (src_archives, entries) = if let Some(input) = input {\n             let mut archive = ar::Archive::new(File::open(input).unwrap());\n             let mut entries = Vec::new();\n@@ -55,7 +51,6 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         ArArchiveBuilder {\n             sess,\n             dst: output.to_path_buf(),\n-            lib_search_paths: archive_search_paths(sess),\n             use_gnu_style_archive: sess.target.archive_format == \"gnu\",\n             // FIXME fix builtin ranlib on macOS\n             no_builtin_ranlib: sess.target.is_like_osx,\n@@ -85,42 +80,27 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         ));\n     }\n \n-    fn add_native_library(&mut self, name: rustc_span::symbol::Symbol, verbatim: bool) {\n-        let location = find_library(name, verbatim, &self.lib_search_paths, self.sess);\n-        self.add_archive(location.clone(), |_| false).unwrap_or_else(|e| {\n-            panic!(\"failed to add native library {}: {}\", location.to_string_lossy(), e);\n-        });\n-    }\n-\n-    fn add_rlib(\n-        &mut self,\n-        rlib: &Path,\n-        name: &str,\n-        lto: bool,\n-        skip_objects: bool,\n-    ) -> std::io::Result<()> {\n-        let obj_start = name.to_owned();\n-\n-        self.add_archive(rlib.to_owned(), move |fname: &str| {\n-            // Ignore metadata files, no matter the name.\n-            if fname == METADATA_FILENAME {\n-                return true;\n-            }\n-\n-            // Don't include Rust objects if LTO is enabled\n-            if lto && fname.starts_with(&obj_start) && fname.ends_with(\".o\") {\n-                return true;\n-            }\n+    fn add_archive<F>(&mut self, archive_path: &Path, mut skip: F) -> std::io::Result<()>\n+    where\n+        F: FnMut(&str) -> bool + 'static,\n+    {\n+        let mut archive = ar::Archive::new(std::fs::File::open(&archive_path)?);\n+        let archive_index = self.src_archives.len();\n \n-            // Otherwise if this is *not* a rust object and we're skipping\n-            // objects then skip this file\n-            if skip_objects && (!fname.starts_with(&obj_start) || !fname.ends_with(\".o\")) {\n-                return true;\n+        let mut i = 0;\n+        while let Some(entry) = archive.next_entry() {\n+            let entry = entry?;\n+            let file_name = String::from_utf8(entry.header().identifier().to_vec())\n+                .map_err(|err| std::io::Error::new(std::io::ErrorKind::InvalidData, err))?;\n+            if !skip(&file_name) {\n+                self.entries\n+                    .push((file_name, ArchiveEntry::FromArchive { archive_index, entry_index: i }));\n             }\n+            i += 1;\n+        }\n \n-            // ok, don't skip this\n-            false\n-        })\n+        self.src_archives.push((archive_path.to_owned(), archive));\n+        Ok(())\n     }\n \n     fn update_symbols(&mut self) {}\n@@ -264,28 +244,3 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         bug!(\"injecting dll imports is not supported\");\n     }\n }\n-\n-impl<'a> ArArchiveBuilder<'a> {\n-    fn add_archive<F>(&mut self, archive_path: PathBuf, mut skip: F) -> std::io::Result<()>\n-    where\n-        F: FnMut(&str) -> bool + 'static,\n-    {\n-        let mut archive = ar::Archive::new(std::fs::File::open(&archive_path)?);\n-        let archive_index = self.src_archives.len();\n-\n-        let mut i = 0;\n-        while let Some(entry) = archive.next_entry() {\n-            let entry = entry?;\n-            let file_name = String::from_utf8(entry.header().identifier().to_vec())\n-                .map_err(|err| std::io::Error::new(std::io::ErrorKind::InvalidData, err))?;\n-            if !skip(&file_name) {\n-                self.entries\n-                    .push((file_name, ArchiveEntry::FromArchive { archive_index, entry_index: i }));\n-            }\n-            i += 1;\n-        }\n-\n-        self.src_archives.push((archive_path, archive));\n-        Ok(())\n-    }\n-}"}, {"sha": "4e86946219fb151676c38889abe6a7b560ec0ad3", "filename": "compiler/rustc_codegen_llvm/src/back/archive.rs", "status": "modified", "additions": 18, "deletions": 80, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/d32dc80bb6dbe850b424d2cb60214bbbce8ddf01/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32dc80bb6dbe850b424d2cb60214bbbce8ddf01/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs?ref=d32dc80bb6dbe850b424d2cb60214bbbce8ddf01", "patch": "@@ -9,18 +9,15 @@ use std::str;\n \n use crate::llvm::archive_ro::{ArchiveRO, Child};\n use crate::llvm::{self, ArchiveKind, LLVMMachineType, LLVMRustCOFFShortExport};\n-use rustc_codegen_ssa::back::archive::{find_library, ArchiveBuilder};\n-use rustc_codegen_ssa::{looks_like_rust_object_file, METADATA_FILENAME};\n+use rustc_codegen_ssa::back::archive::ArchiveBuilder;\n use rustc_data_structures::temp_dir::MaybeTempDir;\n use rustc_middle::middle::cstore::{DllCallingConvention, DllImport};\n use rustc_session::Session;\n-use rustc_span::symbol::Symbol;\n \n struct ArchiveConfig<'a> {\n     pub sess: &'a Session,\n     pub dst: PathBuf,\n     pub src: Option<PathBuf>,\n-    pub lib_search_paths: Vec<PathBuf>,\n }\n \n /// Helper for adding many files to an archive.\n@@ -54,13 +51,7 @@ fn is_relevant_child(c: &Child<'_>) -> bool {\n }\n \n fn archive_config<'a>(sess: &'a Session, output: &Path, input: Option<&Path>) -> ArchiveConfig<'a> {\n-    use rustc_codegen_ssa::back::link::archive_search_paths;\n-    ArchiveConfig {\n-        sess,\n-        dst: output.to_path_buf(),\n-        src: input.map(|p| p.to_path_buf()),\n-        lib_search_paths: archive_search_paths(sess),\n-    }\n+    ArchiveConfig { sess, dst: output.to_path_buf(), src: input.map(|p| p.to_path_buf()) }\n }\n \n /// Map machine type strings to values of LLVM's MachineTypes enum.\n@@ -111,57 +102,23 @@ impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n             .collect()\n     }\n \n-    /// Adds all of the contents of a native library to this archive. This will\n-    /// search in the relevant locations for a library named `name`.\n-    fn add_native_library(&mut self, name: Symbol, verbatim: bool) {\n-        let location =\n-            find_library(name, verbatim, &self.config.lib_search_paths, self.config.sess);\n-        self.add_archive(&location, |_| false).unwrap_or_else(|e| {\n-            self.config.sess.fatal(&format!(\n-                \"failed to add native library {}: {}\",\n-                location.to_string_lossy(),\n-                e\n-            ));\n+    fn add_archive<F>(&mut self, archive: &Path, skip: F) -> io::Result<()>\n+    where\n+        F: FnMut(&str) -> bool + 'static,\n+    {\n+        let archive_ro = match ArchiveRO::open(archive) {\n+            Ok(ar) => ar,\n+            Err(e) => return Err(io::Error::new(io::ErrorKind::Other, e)),\n+        };\n+        if self.additions.iter().any(|ar| ar.path() == archive) {\n+            return Ok(());\n+        }\n+        self.additions.push(Addition::Archive {\n+            path: archive.to_path_buf(),\n+            archive: archive_ro,\n+            skip: Box::new(skip),\n         });\n-    }\n-\n-    /// Adds all of the contents of the rlib at the specified path to this\n-    /// archive.\n-    ///\n-    /// This ignores adding the bytecode from the rlib, and if LTO is enabled\n-    /// then the object file also isn't added.\n-    fn add_rlib(\n-        &mut self,\n-        rlib: &Path,\n-        name: &str,\n-        lto: bool,\n-        skip_objects: bool,\n-    ) -> io::Result<()> {\n-        // Ignoring obj file starting with the crate name\n-        // as simple comparison is not enough - there\n-        // might be also an extra name suffix\n-        let obj_start = name.to_owned();\n-\n-        self.add_archive(rlib, move |fname: &str| {\n-            // Ignore metadata files, no matter the name.\n-            if fname == METADATA_FILENAME {\n-                return true;\n-            }\n-\n-            // Don't include Rust objects if LTO is enabled\n-            if lto && looks_like_rust_object_file(fname) {\n-                return true;\n-            }\n-\n-            // Otherwise if this is *not* a rust object and we're skipping\n-            // objects then skip this file\n-            if skip_objects && (!fname.starts_with(&obj_start) || !fname.ends_with(\".o\")) {\n-                return true;\n-            }\n-\n-            // ok, don't skip this\n-            false\n-        })\n+        Ok(())\n     }\n \n     /// Adds an arbitrary file to this archive\n@@ -270,25 +227,6 @@ impl<'a> LlvmArchiveBuilder<'a> {\n         self.src_archive.as_ref().unwrap().as_ref()\n     }\n \n-    fn add_archive<F>(&mut self, archive: &Path, skip: F) -> io::Result<()>\n-    where\n-        F: FnMut(&str) -> bool + 'static,\n-    {\n-        let archive_ro = match ArchiveRO::open(archive) {\n-            Ok(ar) => ar,\n-            Err(e) => return Err(io::Error::new(io::ErrorKind::Other, e)),\n-        };\n-        if self.additions.iter().any(|ar| ar.path() == archive) {\n-            return Ok(());\n-        }\n-        self.additions.push(Addition::Archive {\n-            path: archive.to_path_buf(),\n-            archive: archive_ro,\n-            skip: Box::new(skip),\n-        });\n-        Ok(())\n-    }\n-\n     fn llvm_archive_kind(&self) -> Result<ArchiveKind, &str> {\n         let kind = &*self.config.sess.target.archive_format;\n         kind.parse().map_err(|_| kind)"}, {"sha": "5188abdbe628632e8be71bd203ee52bf2141513c", "filename": "compiler/rustc_codegen_ssa/src/back/archive.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d32dc80bb6dbe850b424d2cb60214bbbce8ddf01/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32dc80bb6dbe850b424d2cb60214bbbce8ddf01/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs?ref=d32dc80bb6dbe850b424d2cb60214bbbce8ddf01", "patch": "@@ -6,7 +6,7 @@ use rustc_span::symbol::Symbol;\n use std::io;\n use std::path::{Path, PathBuf};\n \n-pub fn find_library(\n+pub(super) fn find_library(\n     name: Symbol,\n     verbatim: bool,\n     search_paths: &[PathBuf],\n@@ -48,14 +48,9 @@ pub trait ArchiveBuilder<'a> {\n     fn remove_file(&mut self, name: &str);\n     fn src_files(&mut self) -> Vec<String>;\n \n-    fn add_rlib(\n-        &mut self,\n-        path: &Path,\n-        name: &str,\n-        lto: bool,\n-        skip_objects: bool,\n-    ) -> io::Result<()>;\n-    fn add_native_library(&mut self, name: Symbol, verbatim: bool);\n+    fn add_archive<F>(&mut self, archive: &Path, skip: F) -> io::Result<()>\n+    where\n+        F: FnMut(&str) -> bool + 'static;\n     fn update_symbols(&mut self);\n \n     fn build(self);"}, {"sha": "903b630bbd627c8c49fb31869e9491ddf5f11798", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 43, "deletions": 10, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/d32dc80bb6dbe850b424d2cb60214bbbce8ddf01/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32dc80bb6dbe850b424d2cb60214bbbce8ddf01/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=d32dc80bb6dbe850b424d2cb60214bbbce8ddf01", "patch": "@@ -19,7 +19,7 @@ use rustc_target::spec::crt_objects::{CrtObjects, CrtObjectsFallback};\n use rustc_target::spec::{LinkOutputKind, LinkerFlavor, LldFlavor, SplitDebuginfo};\n use rustc_target::spec::{PanicStrategy, RelocModel, RelroLevel, SanitizerSet, Target};\n \n-use super::archive::ArchiveBuilder;\n+use super::archive::{find_library, ArchiveBuilder};\n use super::command::Command;\n use super::linker::{self, Linker};\n use super::rpath::{self, RPathConfig};\n@@ -230,6 +230,9 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n     tmpdir: &MaybeTempDir,\n ) -> Result<B, ErrorReported> {\n     info!(\"preparing rlib to {:?}\", out_filename);\n+\n+    let lib_search_paths = archive_search_paths(sess);\n+\n     let mut ab = <B as ArchiveBuilder>::new(sess, out_filename, None);\n \n     for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n@@ -262,7 +265,15 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n             | NativeLibKind::Unspecified => continue,\n         }\n         if let Some(name) = lib.name {\n-            ab.add_native_library(name, lib.verbatim.unwrap_or(false));\n+            let location =\n+                find_library(name, lib.verbatim.unwrap_or(false), &lib_search_paths, sess);\n+            ab.add_archive(&location, |_| false).unwrap_or_else(|e| {\n+                sess.fatal(&format!(\n+                    \"failed to add native library {}: {}\",\n+                    location.to_string_lossy(),\n+                    e\n+                ));\n+            });\n         }\n     }\n \n@@ -541,13 +552,35 @@ fn link_staticlib<'a, B: ArchiveBuilder<'a>>(\n             matches!(lib.kind, NativeLibKind::Static { bundle: None | Some(true), .. })\n                 && !relevant_lib(sess, lib)\n         });\n-        ab.add_rlib(\n-            path,\n-            &name.as_str(),\n-            are_upstream_rust_objects_already_included(sess)\n-                && !ignored_for_lto(sess, &codegen_results.crate_info, cnum),\n-            skip_object_files,\n-        )\n+\n+        let lto = are_upstream_rust_objects_already_included(sess)\n+            && !ignored_for_lto(sess, &codegen_results.crate_info, cnum);\n+\n+        // Ignoring obj file starting with the crate name\n+        // as simple comparison is not enough - there\n+        // might be also an extra name suffix\n+        let obj_start = name.as_str().to_owned();\n+\n+        ab.add_archive(path, move |fname: &str| {\n+            // Ignore metadata files, no matter the name.\n+            if fname == METADATA_FILENAME {\n+                return true;\n+            }\n+\n+            // Don't include Rust objects if LTO is enabled\n+            if lto && looks_like_rust_object_file(fname) {\n+                return true;\n+            }\n+\n+            // Otherwise if this is *not* a rust object and we're skipping\n+            // objects then skip this file\n+            if skip_object_files && (!fname.starts_with(&obj_start) || !fname.ends_with(\".o\")) {\n+                return true;\n+            }\n+\n+            // ok, don't skip this\n+            false\n+        })\n         .unwrap();\n \n         all_native_libs.extend(codegen_results.crate_info.native_libraries[&cnum].iter().cloned());\n@@ -1218,7 +1251,7 @@ fn preserve_objects_for_their_debuginfo(sess: &Session) -> bool {\n     sess.split_debuginfo() == SplitDebuginfo::Unpacked\n }\n \n-pub fn archive_search_paths(sess: &Session) -> Vec<PathBuf> {\n+fn archive_search_paths(sess: &Session) -> Vec<PathBuf> {\n     sess.target_filesearch(PathKind::Native).search_path_dirs()\n }\n "}]}