{"sha": "fb61b8f2625ff77766462b2c0b347bd2b06c5b48", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiNjFiOGYyNjI1ZmY3Nzc2NjQ2MmIyYzBiMzQ3YmQyYjA2YzViNDg=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-06T11:52:13Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-06T16:11:30Z"}, "message": "Add a reachability checker, only export metadata for reachable items\n\nCloses #1934", "tree": {"sha": "9058616eaf55b420b963a7930aece60f9868f789", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9058616eaf55b420b963a7930aece60f9868f789"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb61b8f2625ff77766462b2c0b347bd2b06c5b48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb61b8f2625ff77766462b2c0b347bd2b06c5b48", "html_url": "https://github.com/rust-lang/rust/commit/fb61b8f2625ff77766462b2c0b347bd2b06c5b48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb61b8f2625ff77766462b2c0b347bd2b06c5b48/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e4bd585cd59caeb3a2fb107f1f5ba272149b3ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e4bd585cd59caeb3a2fb107f1f5ba272149b3ee", "html_url": "https://github.com/rust-lang/rust/commit/4e4bd585cd59caeb3a2fb107f1f5ba272149b3ee"}], "stats": {"total": 153, "additions": 146, "deletions": 7}, "files": [{"sha": "ab6a8dea04caaff306bd020463a3301a52088243", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fb61b8f2625ff77766462b2c0b347bd2b06c5b48/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb61b8f2625ff77766462b2c0b347bd2b06c5b48/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=fb61b8f2625ff77766462b2c0b347bd2b06c5b48", "patch": "@@ -27,7 +27,9 @@ export encode_def_id;\n \n type abbrev_map = map::hashmap<ty::t, tyencode::ty_abbrev>;\n \n-type encode_ctxt = {ccx: crate_ctxt, type_abbrevs: abbrev_map};\n+type encode_ctxt = {ccx: crate_ctxt,\n+                    type_abbrevs: abbrev_map,\n+                    reachable: reachable::map};\n \n // Path table encoding\n fn encode_name(ebml_w: ebml::writer, name: str) {\n@@ -73,11 +75,11 @@ fn encode_native_module_item_paths(ebml_w: ebml::writer, nmod: native_mod,\n     }\n }\n \n-fn encode_module_item_paths(ebml_w: ebml::writer, module: _mod, path: [str],\n-                            &index: [entry<str>]) {\n+fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n+                            module: _mod, path: [str], &index: [entry<str>]) {\n     // FIXME factor out add_to_index/start/encode_name/encode_def_id/end ops\n     for it: @item in module.items {\n-        if !ast_util::is_exported(it.ident, module) { cont; }\n+        if !ecx.reachable.contains_key(it.id) { cont; }\n         alt it.node {\n           item_const(_, _) {\n             add_to_index(ebml_w, path, index, it.ident);\n@@ -92,7 +94,8 @@ fn encode_module_item_paths(ebml_w: ebml::writer, module: _mod, path: [str],\n             ebml_w.start_tag(tag_paths_data_mod);\n             encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(it.id));\n-            encode_module_item_paths(ebml_w, _mod, path + [it.ident], index);\n+            encode_module_item_paths(ebml_w, ecx, _mod, path + [it.ident],\n+                                     index);\n             ebml_w.end_tag();\n           }\n           item_native_mod(nmod) {\n@@ -151,7 +154,7 @@ fn encode_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt, crate: @crate)\n     let index: [entry<str>] = [];\n     let path: [str] = [];\n     ebml_w.start_tag(tag_paths);\n-    encode_module_item_paths(ebml_w, crate.node.module, path, index);\n+    encode_module_item_paths(ebml_w, ecx, crate.node.module, path, index);\n     encode_reexport_paths(ebml_w, ecx, index);\n     ebml_w.end_tag();\n     ret index;\n@@ -334,6 +337,12 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n     }\n \n     let tcx = ecx.ccx.tcx;\n+    let must_write = alt item.node {\n+      item_enum(_, _) | item_res(_, _, _, _, _) { true }\n+      _ { false }\n+    };\n+    if !must_write && !ecx.reachable.contains_key(item.id) { ret; }\n+\n     alt item.node {\n       item_const(_, _) {\n         ebml_w.start_tag(tag_items_data_item);\n@@ -488,6 +497,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n \n fn encode_info_for_native_item(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                                nitem: @native_item, path: ast_map::path) {\n+    if !ecx.reachable.contains_key(nitem.id) { ret; }\n     ebml_w.start_tag(tag_items_data_item);\n     alt nitem.node {\n       native_item_fn(fn_decl, tps) {\n@@ -723,8 +733,11 @@ fn encode_hash(ebml_w: ebml::writer, hash: str) {\n \n fn encode_metadata(cx: crate_ctxt, crate: @crate) -> [u8] {\n \n+    let reachable = reachable::find_reachable(cx, crate.node.module);\n     let abbrevs = ty::new_ty_hash();\n-    let ecx = @{ccx: cx, type_abbrevs: abbrevs};\n+    let ecx = @{ccx: cx,\n+                type_abbrevs: abbrevs,\n+                reachable: reachable};\n \n     let buf = io::mk_mem_buffer();\n     let buf_w = io::mem_buffer_writer(buf);"}, {"sha": "e85d4098fde6904a155dce2de8a30f6c58057fc4", "filename": "src/rustc/metadata/reachable.rs", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/fb61b8f2625ff77766462b2c0b347bd2b06c5b48/src%2Frustc%2Fmetadata%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb61b8f2625ff77766462b2c0b347bd2b06c5b48/src%2Frustc%2Fmetadata%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Freachable.rs?ref=fb61b8f2625ff77766462b2c0b347bd2b06c5b48", "patch": "@@ -0,0 +1,125 @@\n+// Finds items that are externally reachable, to determine which items\n+// need to have their metadata (and possibly their AST) serialized.\n+// All items that can be referred to through an exported name are\n+// reachable, and when a reachable thing is inline or generic, it\n+// makes all other generics or inline functions that it references\n+// reachable as well.\n+\n+import middle::{resolve, ast_map, typeck};\n+import syntax::ast::*;\n+import syntax::visit;\n+import syntax::ast_util::def_id_of_def;\n+import front::attr;\n+\n+export map, find_reachable;\n+\n+type map = std::map::map<node_id, ()>;\n+\n+type ctx = {ccx: middle::trans::common::crate_ctxt,\n+            rmap: map};\n+\n+fn find_reachable(ccx: middle::trans::common::crate_ctxt, crate_mod: _mod)\n+    -> map {\n+    let rmap = std::map::new_int_hash();\n+    traverse_public_mod({ccx: ccx, rmap: rmap}, crate_mod);\n+    rmap\n+}\n+\n+fn traverse_exports(cx: ctx, vis: [@view_item]) -> bool {\n+    let found_export = false;\n+    for vi in vis {\n+        alt vi.node {\n+          view_item_export(vps) {\n+            found_export = true;\n+            for vp in vps {\n+                alt vp.node {\n+                  view_path_simple(_, _, id) | view_path_glob(_, id) |\n+                  view_path_list(_, _, id) {\n+                    traverse_export(cx, id);\n+                  }\n+                }\n+            }\n+          }\n+          _ {}\n+        }\n+    }\n+    found_export\n+}\n+\n+fn traverse_export(cx: ctx, exp_id: node_id) {\n+    option::may(cx.ccx.exp_map.find(exp_id)) {|defs|\n+        for def in defs { traverse_def_id(cx, def.id); }\n+    }\n+}\n+\n+fn traverse_def_id(cx: ctx, did: def_id) {\n+    if did.crate != local_crate { ret; }\n+    alt cx.ccx.tcx.items.get(did.node) {\n+      ast_map::node_item(item, _) { traverse_public_item(cx, item); }\n+      ast_map::node_method(_, impl_id, _) { traverse_def_id(cx, impl_id); }\n+      ast_map::node_native_item(item, _) { cx.rmap.insert(item.id, ()); }\n+      ast_map::node_variant(v, _, _) { cx.rmap.insert(v.node.id, ()); }\n+      _ {}\n+    }\n+}\n+\n+fn traverse_public_mod(cx: ctx, m: _mod) {\n+    if !traverse_exports(cx, m.view_items) {\n+        // No exports, so every local item is exported\n+        for item in m.items { traverse_public_item(cx, item); }\n+    }\n+}\n+\n+fn traverse_public_item(cx: ctx, item: @item) {\n+    if cx.rmap.contains_key(item.id) { ret; }\n+    cx.rmap.insert(item.id, ());\n+    alt item.node {\n+      item_mod(m) { traverse_public_mod(cx, m); }\n+      item_native_mod(nm) {\n+          if !traverse_exports(cx, nm.view_items) {\n+              for item in nm.items { cx.rmap.insert(item.id, ()); }\n+          }\n+      }\n+      item_res(_, tps, blk, _, _) | item_fn(_, tps, blk) {\n+        if tps.len() > 0u ||\n+           attr::find_inline_attr(item.attrs) != attr::ia_none {\n+            traverse_inline_body(cx, blk);\n+        }\n+      }\n+      item_impl(tps, _, _, ms) {\n+        for m in ms {\n+            if tps.len() > 0u || m.tps.len() > 0u ||\n+               attr::find_inline_attr(m.attrs) != attr::ia_none {\n+                traverse_inline_body(cx, m.body);\n+            }\n+        }\n+      }\n+      item_class(_tps, _items, _) {} // FIXME handle these when stable\n+      item_const(_, _) | item_ty(_, _) | item_enum(_, _) | item_iface(_, _) {}\n+    }\n+}\n+\n+fn traverse_inline_body(cx: ctx, body: blk) {\n+    fn traverse_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n+        alt e.node {\n+          expr_path(_) {\n+            traverse_def_id(cx, def_id_of_def(cx.ccx.tcx.def_map.get(e.id)));\n+          }\n+          expr_field(_, _, _) {\n+            alt cx.ccx.maps.method_map.find(e.id) {\n+              some(typeck::method_static(did)) { traverse_def_id(cx, did); }\n+              _ {}\n+            }\n+          }\n+          _ {}\n+        }\n+        visit::visit_expr(e, cx, v);\n+    }\n+    // Ignore nested items\n+    fn traverse_item(_i: @item, _cx: ctx, _v: visit::vt<ctx>) {}\n+    visit::visit_block(body, cx, visit::mk_vt(@{\n+        visit_expr: traverse_expr,\n+        visit_item: traverse_item\n+        with *visit::default_visitor()\n+    }));\n+}"}, {"sha": "837e167567954dfbe288556294c04a9878956753", "filename": "src/rustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb61b8f2625ff77766462b2c0b347bd2b06c5b48/src%2Frustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/fb61b8f2625ff77766462b2c0b347bd2b06c5b48/src%2Frustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rc?ref=fb61b8f2625ff77766462b2c0b347bd2b06c5b48", "patch": "@@ -128,6 +128,7 @@ mod metadata {\n     mod creader;\n     mod cstore;\n     mod csearch;\n+    mod reachable;\n }\n \n mod driver {"}]}