{"sha": "c7473c8260cbe6892eeed82f275bf09a73895e0e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3NDczYzgyNjBjYmU2ODkyZWVlZDgyZjI3NWJmMDlhNzM4OTVlMGU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-22T19:27:28Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-22T19:27:52Z"}, "message": "rustc: Switch @ty.t to ty.t so that we can change it to a uint", "tree": {"sha": "7575249a63b6467a6dde53f89e7a19720136bfee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7575249a63b6467a6dde53f89e7a19720136bfee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7473c8260cbe6892eeed82f275bf09a73895e0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7473c8260cbe6892eeed82f275bf09a73895e0e", "html_url": "https://github.com/rust-lang/rust/commit/c7473c8260cbe6892eeed82f275bf09a73895e0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7473c8260cbe6892eeed82f275bf09a73895e0e/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fac8cc3b066da8351dc24b209c1a070a53b16a61", "url": "https://api.github.com/repos/rust-lang/rust/commits/fac8cc3b066da8351dc24b209c1a070a53b16a61", "html_url": "https://github.com/rust-lang/rust/commit/fac8cc3b066da8351dc24b209c1a070a53b16a61"}], "stats": {"total": 847, "additions": 424, "deletions": 423}, "files": [{"sha": "2fd13194e50375fe9093de822711ed5726c91d26", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7473c8260cbe6892eeed82f275bf09a73895e0e/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7473c8260cbe6892eeed82f275bf09a73895e0e/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=c7473c8260cbe6892eeed82f275bf09a73895e0e", "patch": "@@ -22,8 +22,8 @@ type ty_param = ident;\n // Annotations added during successive passes.\n tag ann {\n     ann_none;\n-    ann_type(@middle.ty.t,\n-             option.t[vec[@middle.ty.t]], /* ty param substs */\n+    ann_type(middle.ty.t,\n+             option.t[vec[middle.ty.t]], /* ty param substs */\n              option.t[@ts_ann]); /* pre- and postcondition for typestate */\n }\n "}, {"sha": "857ed2d3ae281e2ce502268ba71395f9ab9e0f8a", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c7473c8260cbe6892eeed82f275bf09a73895e0e/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7473c8260cbe6892eeed82f275bf09a73895e0e/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=c7473c8260cbe6892eeed82f275bf09a73895e0e", "patch": "@@ -63,7 +63,7 @@ fn next(@pstate st) -> u8 {\n     ret ch as u8;\n }\n \n-fn parse_ty_str(str rep, str_def sd, @ty.type_store tystore) -> @ty.t {\n+fn parse_ty_str(str rep, str_def sd, @ty.type_store tystore) -> ty.t {\n     auto len = _str.byte_len(rep);\n     auto st = @rec(rep=rep, mutable pos=0u, len=len, tystore=tystore);\n     auto result = parse_ty(st, sd);\n@@ -75,7 +75,7 @@ fn parse_ty_str(str rep, str_def sd, @ty.type_store tystore) -> @ty.t {\n     ret result;\n }\n \n-fn parse_ty(@pstate st, str_def sd) -> @ty.t {\n+fn parse_ty(@pstate st, str_def sd) -> ty.t {\n     alt (next(st) as char) {\n         case ('n') { ret ty.mk_nil(st.tystore); }\n         case ('b') { ret ty.mk_bool(st.tystore); }\n@@ -101,7 +101,7 @@ fn parse_ty(@pstate st, str_def sd) -> @ty.t {\n         case ('t') {\n             check(next(st) as char == '[');\n             auto def = parse_def(st, sd);\n-            let vec[@ty.t] params = vec();\n+            let vec[ty.t] params = vec();\n             while (peek(st) as char != ']') {\n                 params += vec(parse_ty(st, sd));\n             }\n@@ -213,7 +213,7 @@ fn parse_int(@pstate st) -> int {\n     ret n;\n }\n \n-fn parse_ty_fn(@pstate st, str_def sd) -> tup(vec[ty.arg], @ty.t) {\n+fn parse_ty_fn(@pstate st, str_def sd) -> tup(vec[ty.arg], ty.t) {\n     check(next(st) as char == '[');\n     let vec[ty.arg] inputs = vec();\n     while (peek(st) as char != ']') {\n@@ -331,7 +331,7 @@ fn variant_tag_id(&ebml.doc d) -> ast.def_id {\n     ret parse_def_id(ebml.doc_data(tagdoc));\n }\n \n-fn item_type(&ebml.doc item, int this_cnum, @ty.type_store tystore) -> @ty.t {\n+fn item_type(&ebml.doc item, int this_cnum, @ty.type_store tystore) -> ty.t {\n     fn parse_external_def_id(int this_cnum, str s) -> ast.def_id {\n         // FIXME: This is completely wrong when linking against a crate\n         // that, in turn, links against another crate. We need a mapping\n@@ -545,7 +545,7 @@ fn get_tag_variants(session.session sess,\n     for (ast.def_id did in variant_ids) {\n         auto item = find_item(did._1, items);\n         auto ctor_ty = item_type(item, external_crate_id, tystore);\n-        let vec[@ty.t] arg_tys = vec();\n+        let vec[ty.t] arg_tys = vec();\n         alt (ty.struct(ctor_ty)) {\n             case (ty.ty_fn(_, ?args, _)) {\n                 for (ty.arg a in args) {"}, {"sha": "5cefa83c5f9fb5433a70a22dda9a9070360ca37f", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7473c8260cbe6892eeed82f275bf09a73895e0e/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7473c8260cbe6892eeed82f275bf09a73895e0e/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=c7473c8260cbe6892eeed82f275bf09a73895e0e", "patch": "@@ -52,7 +52,7 @@ const uint tag_index_table = 0x15u;\n // Callback to translate defs to strs or back.\n type def_str = fn(ast.def_id) -> str;\n \n-fn ty_str(@ty.t t, def_str ds) -> str {\n+fn ty_str(ty.t t, def_str ds) -> str {\n     ret sty_str(ty.struct(t), ds);\n }\n \n@@ -91,7 +91,7 @@ fn sty_str(ty.sty st, def_str ds) -> str {\n         case (ty.ty_str) {ret \"s\";}\n         case (ty.ty_tag(?def,?tys)) { // TODO restore def_id\n             auto acc = \"t[\" + ds(def) + \"|\";\n-            for (@ty.t t in tys) {acc += ty_str(t, ds);}\n+            for (ty.t t in tys) {acc += ty_str(t, ds);}\n             ret acc + \"]\";\n         }\n         case (ty.ty_box(?mt)) {ret \"@\" + mt_str(mt, ds);}\n@@ -151,7 +151,7 @@ fn proto_str(ast.proto proto) -> str {\n     }\n }\n \n-fn ty_fn_str(vec[ty.arg] args, @ty.t out, def_str ds) -> str {\n+fn ty_fn_str(vec[ty.arg] args, ty.t out, def_str ds) -> str {\n     auto acc = \"[\";\n     for (ty.arg arg in args) {\n         if (arg.mode == ast.alias) {acc += \"&\";}\n@@ -327,7 +327,7 @@ fn encode_variant_id(&ebml.writer ebml_w, ast.def_id vid) {\n     ebml.end_tag(ebml_w);\n }\n \n-fn encode_type(&ebml.writer ebml_w, @ty.t typ) {\n+fn encode_type(&ebml.writer ebml_w, ty.t typ) {\n     ebml.start_tag(ebml_w, tag_items_data_item_type);\n     auto f = def_to_str;\n     ebml_w.writer.write(_str.bytes(ty_str(typ, f)));"}, {"sha": "f995ee6e63e6a049cda75f458d33f64b317cde90", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 152, "deletions": 152, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/c7473c8260cbe6892eeed82f275bf09a73895e0e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7473c8260cbe6892eeed82f275bf09a73895e0e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=c7473c8260cbe6892eeed82f275bf09a73895e0e", "patch": "@@ -101,15 +101,15 @@ state type crate_ctxt = rec(session.session sess,\n                             ty.type_cache type_cache,\n                             hashmap[ast.def_id, str] item_symbols,\n                             // TODO: hashmap[tup(tag_id,subtys), @tag_info]\n-                            hashmap[@ty.t, uint] tag_sizes,\n+                            hashmap[ty.t, uint] tag_sizes,\n                             hashmap[ast.def_id, ValueRef] discrims,\n                             hashmap[ast.def_id, str] discrim_symbols,\n                             hashmap[ast.def_id, ValueRef] fn_pairs,\n                             hashmap[ast.def_id, ValueRef] consts,\n                             hashmap[ast.def_id,()] obj_methods,\n-                            hashmap[@ty.t, @tydesc_info] tydescs,\n+                            hashmap[ty.t, @tydesc_info] tydescs,\n                             hashmap[str, ValueRef] module_data,\n-                            hashmap[@ty.t, TypeRef] lltypes,\n+                            hashmap[ty.t, TypeRef] lltypes,\n                             @glue_fns glues,\n                             namegen names,\n                             std.sha1.sha1 sha,\n@@ -122,7 +122,7 @@ type local_ctxt = rec(vec[str] path,\n                       @crate_ctxt ccx);\n                 \n \n-type self_vt = rec(ValueRef v, @ty.t t);\n+type self_vt = rec(ValueRef v, ty.t t);\n \n state type fn_ctxt = rec(ValueRef llfn,\n                          ValueRef lltaskptr,\n@@ -181,7 +181,7 @@ fn path_name(vec[str] path) -> str {\n }\n \n \n-fn mangle_name_by_type(@crate_ctxt ccx, vec[str] path, @ty.t t) -> str {\n+fn mangle_name_by_type(@crate_ctxt ccx, vec[str] path, ty.t t) -> str {\n     ccx.sha.reset();\n     auto f = metadata.def_to_str;\n     ccx.sha.input_str(metadata.ty_str(t, f));\n@@ -554,7 +554,7 @@ fn T_opaque_obj_ptr(type_names tn) -> TypeRef {\n // return value was always meaningless in that case anyhow). Beware!\n //\n // TODO: Enforce via a predicate.\n-fn type_of(@crate_ctxt cx, @ty.t t) -> TypeRef {\n+fn type_of(@crate_ctxt cx, ty.t t) -> TypeRef {\n     if (ty.type_has_dynamic_size(t)) {\n         log_err \"type_of() called on a type with dynamic size: \" +\n             ty.ty_to_str(t);\n@@ -597,7 +597,7 @@ fn type_of_fn_full(@crate_ctxt cx,\n                    ast.proto proto,\n                    option.t[TypeRef] obj_self,\n                    vec[ty.arg] inputs,\n-                   @ty.t output,\n+                   ty.t output,\n                    uint ty_param_count) -> TypeRef {\n     let vec[TypeRef] atys = vec();\n \n@@ -651,15 +651,15 @@ fn type_of_fn_full(@crate_ctxt cx,\n fn type_of_fn(@crate_ctxt cx,\n               ast.proto proto,\n               vec[ty.arg] inputs,\n-              @ty.t output,\n+              ty.t output,\n               uint ty_param_count) -> TypeRef {\n     ret type_of_fn_full(cx, proto, none[TypeRef], inputs, output,\n                         ty_param_count);\n }\n \n fn type_of_native_fn(@crate_ctxt cx, ast.native_abi abi,\n                      vec[ty.arg] inputs,\n-                     @ty.t output,\n+                     ty.t output,\n                      uint ty_param_count) -> TypeRef {\n     let vec[TypeRef] atys = vec();\n     if (abi == ast.native_abi_rust) {\n@@ -675,7 +675,7 @@ fn type_of_native_fn(@crate_ctxt cx, ast.native_abi abi,\n     ret T_fn(atys, type_of_inner(cx, output));\n }\n \n-fn type_of_inner(@crate_ctxt cx, @ty.t t) -> TypeRef {\n+fn type_of_inner(@crate_ctxt cx, ty.t t) -> TypeRef {\n     // Check the cache.\n     if (cx.lltypes.contains_key(t)) {\n         ret cx.lltypes.get(t);\n@@ -1119,14 +1119,14 @@ fn llalign_of(TypeRef t) -> ValueRef {\n     ret llvm.LLVMConstIntCast(lib.llvm.llvm.LLVMAlignOf(t), T_int(), False);\n }\n \n-fn size_of(@block_ctxt cx, @ty.t t) -> result {\n+fn size_of(@block_ctxt cx, ty.t t) -> result {\n     if (!ty.type_has_dynamic_size(t)) {\n         ret res(cx, llsize_of(type_of(cx.fcx.lcx.ccx, t)));\n     }\n     ret dynamic_size_of(cx, t);\n }\n \n-fn align_of(@block_ctxt cx, @ty.t t) -> result {\n+fn align_of(@block_ctxt cx, ty.t t) -> result {\n     if (!ty.type_has_dynamic_size(t)) {\n         ret res(cx, llalign_of(type_of(cx.fcx.lcx.ccx, t)));\n     }\n@@ -1146,8 +1146,8 @@ fn array_alloca(@block_ctxt cx, TypeRef t, ValueRef n) -> ValueRef {\n // to have (a) the same size as the type that was passed in; (b) to be non-\n // recursive. This is done by replacing all boxes in a type with boxed unit\n // types.\n-fn simplify_type(@crate_ctxt ccx, @ty.t typ) -> @ty.t {\n-    fn simplifier(@crate_ctxt ccx, @ty.t typ) -> @ty.t {\n+fn simplify_type(@crate_ctxt ccx, ty.t typ) -> ty.t {\n+    fn simplifier(@crate_ctxt ccx, ty.t typ) -> ty.t {\n         alt (ty.struct(typ)) {\n             case (ty.ty_box(_)) {\n                 ret ty.mk_imm_box(ccx.tystore, ty.mk_nil(ccx.tystore));\n@@ -1160,7 +1160,7 @@ fn simplify_type(@crate_ctxt ccx, @ty.t typ) -> @ty.t {\n }\n \n // Computes the size of the data part of a non-dynamically-sized tag.\n-fn static_size_of_tag(@crate_ctxt cx, @ty.t t) -> uint {\n+fn static_size_of_tag(@crate_ctxt cx, ty.t t) -> uint {\n     if (ty.type_has_dynamic_size(t)) {\n         log_err \"dynamically sized type passed to static_size_of_tag()\";\n         fail;\n@@ -1171,7 +1171,7 @@ fn static_size_of_tag(@crate_ctxt cx, @ty.t t) -> uint {\n     }\n \n     auto tid;\n-    let vec[@ty.t] subtys;\n+    let vec[ty.t] subtys;\n     alt (ty.struct(t)) {\n         case (ty.ty_tag(?tid_, ?subtys_)) {\n             tid = tid_;\n@@ -1206,8 +1206,8 @@ fn static_size_of_tag(@crate_ctxt cx, @ty.t t) -> uint {\n     ret max_size;\n }\n \n-fn dynamic_size_of(@block_ctxt cx, @ty.t t) -> result {\n-    fn align_elements(@block_ctxt cx, vec[@ty.t] elts) -> result {\n+fn dynamic_size_of(@block_ctxt cx, ty.t t) -> result {\n+    fn align_elements(@block_ctxt cx, vec[ty.t] elts) -> result {\n         //\n         // C padding rules:\n         //\n@@ -1219,7 +1219,7 @@ fn dynamic_size_of(@block_ctxt cx, @ty.t t) -> result {\n         auto off = C_int(0);\n         auto max_align = C_int(1);\n         auto bcx = cx;\n-        for (@ty.t e in elts) {\n+        for (ty.t e in elts) {\n             auto elt_align = align_of(bcx, e);\n             bcx = elt_align.bcx;\n             auto elt_size = size_of(bcx, e);\n@@ -1238,14 +1238,14 @@ fn dynamic_size_of(@block_ctxt cx, @ty.t t) -> result {\n             ret res(szptr.bcx, szptr.bcx.build.Load(szptr.val));\n         }\n         case (ty.ty_tup(?elts)) {\n-            let vec[@ty.t] tys = vec();\n+            let vec[ty.t] tys = vec();\n             for (ty.mt mt in elts) {\n                 tys += vec(mt.ty);\n             }\n             ret align_elements(cx, tys);\n         }\n         case (ty.ty_rec(?flds)) {\n-            let vec[@ty.t] tys = vec();\n+            let vec[ty.t] tys = vec();\n             for (ty.field f in flds) {\n                 tys += vec(f.mt.ty);\n             }\n@@ -1261,9 +1261,9 @@ fn dynamic_size_of(@block_ctxt cx, @ty.t t) -> result {\n             auto variants = tag_variants(bcx.fcx.lcx.ccx, tid);\n             for (variant_info variant in variants) {\n                 // Perform type substitution on the raw argument types.\n-                let vec[@ty.t] raw_tys = variant.args;\n-                let vec[@ty.t] tys = vec();\n-                for (@ty.t raw_ty in raw_tys) {\n+                let vec[ty.t] raw_tys = variant.args;\n+                let vec[ty.t] tys = vec();\n+                for (ty.t raw_ty in raw_tys) {\n                     auto t = ty.bind_params_in_type(cx.fcx.lcx.ccx.tystore,\n                                                     raw_ty);\n                     t = ty.substitute_type_params(cx.fcx.lcx.ccx.tystore, tps,\n@@ -1286,7 +1286,7 @@ fn dynamic_size_of(@block_ctxt cx, @ty.t t) -> result {\n     }\n }\n \n-fn dynamic_align_of(@block_ctxt cx, @ty.t t) -> result {\n+fn dynamic_align_of(@block_ctxt cx, ty.t t) -> result {\n     alt (ty.struct(t)) {\n         case (ty.ty_param(?p)) {\n             auto aptr = field_of_tydesc(cx, t, abi.tydesc_field_align);\n@@ -1324,7 +1324,7 @@ fn dynamic_align_of(@block_ctxt cx, @ty.t t) -> result {\n // middle of the thing it's GEP'ing into. Much like size_of and align_of,\n // above.\n \n-fn GEP_tup_like(@block_ctxt cx, @ty.t t,\n+fn GEP_tup_like(@block_ctxt cx, ty.t t,\n                 ValueRef base, vec[int] ixs) -> result {\n \n     check (ty.type_is_tup_like(t));\n@@ -1356,8 +1356,8 @@ fn GEP_tup_like(@block_ctxt cx, @ty.t t,\n     // elements of the type and splitting the Xth off. Return the prefix as\n     // well as the innermost Xth type.\n \n-    fn split_type(@ty.t t, vec[int] ixs, uint n)\n-        -> rec(vec[@ty.t] prefix, @ty.t target) {\n+    fn split_type(ty.t t, vec[int] ixs, uint n)\n+        -> rec(vec[ty.t] prefix, ty.t target) {\n \n         let uint len = _vec.len[int](ixs);\n \n@@ -1378,10 +1378,10 @@ fn GEP_tup_like(@block_ctxt cx, @ty.t t,\n         check (n < len);\n \n         let int ix = ixs.(n);\n-        let vec[@ty.t] prefix = vec();\n+        let vec[ty.t] prefix = vec();\n         let int i = 0;\n         while (i < ix) {\n-            _vec.push[@ty.t](prefix, ty.get_element_type(t, i as uint));\n+            _vec.push[ty.t](prefix, ty.get_element_type(t, i as uint));\n             i += 1 ;\n         }\n \n@@ -1429,7 +1429,7 @@ fn GEP_tag(@block_ctxt cx,\n            ValueRef llblobptr,\n            &ast.def_id tag_id,\n            &ast.def_id variant_id,\n-           vec[@ty.t] ty_substs,\n+           vec[ty.t] ty_substs,\n            int ix)\n         -> result {\n     auto variant = tag_variant_with_id(cx.fcx.lcx.ccx, tag_id, variant_id);\n@@ -1439,8 +1439,8 @@ fn GEP_tag(@block_ctxt cx,\n     auto arg_tys = variant.args;\n     auto elem_ty = ty.mk_nil(cx.fcx.lcx.ccx.tystore); // typestate infelicity\n     auto i = 0;\n-    let vec[@ty.t] true_arg_tys = vec();\n-    for (@ty.t aty in arg_tys) {\n+    let vec[ty.t] true_arg_tys = vec();\n+    for (ty.t aty in arg_tys) {\n         auto arg_ty = ty.bind_params_in_type(cx.fcx.lcx.ccx.tystore, aty);\n         arg_ty = ty.substitute_type_params(cx.fcx.lcx.ccx.tystore, ty_substs,\n                                            arg_ty);\n@@ -1489,7 +1489,7 @@ fn trans_raw_malloc(@block_ctxt cx, TypeRef llptr_ty, ValueRef llsize)\n     ret rslt;\n }\n \n-fn trans_malloc_boxed(@block_ctxt cx, @ty.t t) -> result {\n+fn trans_malloc_boxed(@block_ctxt cx, ty.t t) -> result {\n     // Synthesize a fake box type structurally so we have something\n     // to measure the size of.\n     auto boxed_body = ty.mk_imm_tup(cx.fcx.lcx.ccx.tystore,\n@@ -1507,7 +1507,7 @@ fn trans_malloc_boxed(@block_ctxt cx, @ty.t t) -> result {\n // Given a type and a field index into its corresponding type descriptor,\n // returns an LLVM ValueRef of that field from the tydesc, generating the\n // tydesc if necessary.\n-fn field_of_tydesc(@block_ctxt cx, @ty.t t, int field) -> result {\n+fn field_of_tydesc(@block_ctxt cx, ty.t t, int field) -> result {\n     auto tydesc = get_tydesc(cx, t);\n     ret res(tydesc.bcx,\n             tydesc.bcx.build.GEP(tydesc.val, vec(C_int(0), C_int(field))));\n@@ -1517,15 +1517,15 @@ fn field_of_tydesc(@block_ctxt cx, @ty.t t, int field) -> result {\n // each of the ty params it uses (from the current frame) and a vector of the\n // indices of the ty params present in the type. This is used solely for\n // constructing derived tydescs.\n-fn linearize_ty_params(@block_ctxt cx, @ty.t t) ->\n+fn linearize_ty_params(@block_ctxt cx, ty.t t) ->\n         tup(vec[uint], vec[ValueRef]) {\n     let vec[ValueRef] param_vals = vec();\n     let vec[uint] param_defs = vec();\n     type rr = rec(@block_ctxt cx,\n                   mutable vec[ValueRef] vals,\n                   mutable vec[uint] defs);\n \n-    fn linearizer(@rr r, @ty.t t) {\n+    fn linearizer(@rr r, ty.t t) {\n         alt(ty.struct(t)) {\n             case (ty.ty_param(?pid)) {\n                 let bool seen = false;\n@@ -1554,7 +1554,7 @@ fn linearize_ty_params(@block_ctxt cx, @ty.t t) ->\n     ret tup(x.defs, x.vals);\n }\n \n-fn get_tydesc(&@block_ctxt cx, @ty.t t) -> result {\n+fn get_tydesc(&@block_ctxt cx, ty.t t) -> result {\n     // Is the supplied type a type param? If so, return the passed-in tydesc.\n     alt (ty.type_param(t)) {\n         case (some[uint](?id)) { ret res(cx, cx.fcx.lltydescs.(id)); }\n@@ -1619,7 +1619,7 @@ fn get_tydesc(&@block_ctxt cx, @ty.t t) -> result {\n // Generates the declaration for (but doesn't fill in) a type descriptor. This\n // needs to be separate from make_tydesc() below, because sometimes type glue\n // functions needs to refer to their own type descriptors.\n-fn declare_tydesc(@local_ctxt cx, @ty.t t) {\n+fn declare_tydesc(@local_ctxt cx, ty.t t) {\n     auto take_glue = declare_generic_glue(cx, t, T_glue_fn(cx.ccx.tn),\n                                           \"take\");\n     auto drop_glue = declare_generic_glue(cx, t, T_glue_fn(cx.ccx.tn),\n@@ -1674,12 +1674,12 @@ fn declare_tydesc(@local_ctxt cx, @ty.t t) {\n }\n \n tag make_generic_glue_helper_fn {\n-    mgghf_single(fn(@block_ctxt cx, ValueRef v, @ty.t t));\n+    mgghf_single(fn(@block_ctxt cx, ValueRef v, ty.t t));\n     mgghf_cmp;\n }\n \n // declare_tydesc() above must have been called first.\n-fn define_tydesc(@local_ctxt cx, @ty.t t, vec[uint] ty_params) {\n+fn define_tydesc(@local_ctxt cx, ty.t t, vec[uint] ty_params) {\n     auto info = cx.ccx.tydescs.get(t);\n     auto gvar = info.tydesc;\n \n@@ -1691,7 +1691,7 @@ fn define_tydesc(@local_ctxt cx, @ty.t t, vec[uint] ty_params) {\n }\n \n fn declare_generic_glue(@local_ctxt cx,\n-                        @ty.t t,\n+                        ty.t t,\n                         TypeRef llfnty,\n                         str name) -> ValueRef {\n     auto gcx = @rec(path=vec(\"glue\", name) with *cx);\n@@ -1702,7 +1702,7 @@ fn declare_generic_glue(@local_ctxt cx,\n }\n \n fn make_generic_glue(@local_ctxt cx,\n-                     @ty.t t,\n+                     ty.t t,\n                      ValueRef llfn,\n                      make_generic_glue_helper_fn helper,\n                      vec[uint] ty_params) -> ValueRef {\n@@ -1760,7 +1760,7 @@ fn make_generic_glue(@local_ctxt cx,\n     ret llfn;\n }\n \n-fn make_take_glue(@block_ctxt cx, ValueRef v, @ty.t t) {\n+fn make_take_glue(@block_ctxt cx, ValueRef v, ty.t t) {\n     // NB: v is an *alias* of type t here, not a direct value.\n     auto bcx;\n     if (ty.type_is_boxed(t)) {\n@@ -1794,7 +1794,7 @@ fn incr_refcnt_of_boxed(@block_ctxt cx, ValueRef box_ptr) -> result {\n     ret res(next_cx, C_nil());\n }\n \n-fn make_drop_glue(@block_ctxt cx, ValueRef v0, @ty.t t) {\n+fn make_drop_glue(@block_ctxt cx, ValueRef v0, ty.t t) {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     auto rslt;\n     alt (ty.struct(t)) {\n@@ -1808,7 +1808,7 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v0, @ty.t t) {\n \n         case (ty.ty_vec(_)) {\n             fn hit_zero(@block_ctxt cx, ValueRef v,\n-                        @ty.t t) -> result {\n+                        ty.t t) -> result {\n                 auto res = iter_sequence(cx, v, t,\n                                          bind drop_ty(_,_,_));\n                 // FIXME: switch gc/non-gc on layer of the type.\n@@ -1823,7 +1823,7 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v0, @ty.t t) {\n \n         case (ty.ty_box(?body_mt)) {\n             fn hit_zero(@block_ctxt cx, ValueRef v,\n-                        @ty.t body_ty) -> result {\n+                        ty.t body_ty) -> result {\n                 auto body = cx.build.GEP(v,\n                                          vec(C_int(0),\n                                              C_int(abi.box_rc_field_body)));\n@@ -2001,7 +2001,7 @@ fn decr_refcnt_and_if_zero(@block_ctxt cx,\n fn make_cmp_glue(@block_ctxt cx,\n                  ValueRef lhs0,\n                  ValueRef rhs0,\n-                 @ty.t t,\n+                 ty.t t,\n                  ValueRef llop) {\n     auto lhs = load_if_immediate(cx, lhs0, t);\n     auto rhs = load_if_immediate(cx, rhs0, t);\n@@ -2079,7 +2079,7 @@ fn make_cmp_glue(@block_ctxt cx,\n                  @block_ctxt cx,\n                  ValueRef av0,\n                  ValueRef bv0,\n-                 @ty.t t) -> result {\n+                 ty.t t) -> result {\n \n             auto cnt_cx = new_sub_block_ctxt(cx, \"continue_comparison\");\n             auto stop_cx = new_sub_block_ctxt(cx, \"stop_comparison\");\n@@ -2145,7 +2145,7 @@ fn make_cmp_glue(@block_ctxt cx,\n }\n \n // A helper function to create scalar comparison glue.\n-fn make_scalar_cmp_glue(@block_ctxt cx, ValueRef lhs, ValueRef rhs, @ty.t t,\n+fn make_scalar_cmp_glue(@block_ctxt cx, ValueRef lhs, ValueRef rhs, ty.t t,\n                         ValueRef llop) {\n     if (ty.type_is_fp(t)) {\n         make_fp_cmp_glue(cx, lhs, rhs, t, llop);\n@@ -2168,7 +2168,7 @@ fn make_scalar_cmp_glue(@block_ctxt cx, ValueRef lhs, ValueRef rhs, @ty.t t,\n }\n \n // A helper function to create floating point comparison glue.\n-fn make_fp_cmp_glue(@block_ctxt cx, ValueRef lhs, ValueRef rhs, @ty.t fptype,\n+fn make_fp_cmp_glue(@block_ctxt cx, ValueRef lhs, ValueRef rhs, ty.t fptype,\n                     ValueRef llop) {\n     auto last_cx = new_sub_block_ctxt(cx, \"last\");\n \n@@ -2242,7 +2242,7 @@ fn compare_integral_values(@block_ctxt cx, ValueRef lhs, ValueRef rhs,\n \n // A helper function to create integral comparison glue.\n fn make_integral_cmp_glue(@block_ctxt cx, ValueRef lhs, ValueRef rhs,\n-                          @ty.t intype, ValueRef llop) {\n+                          ty.t intype, ValueRef llop) {\n     auto r = compare_integral_values(cx, lhs, rhs, ty.type_is_signed(intype),\n                                      llop);\n     r.bcx.build.Store(r.val, r.bcx.fcx.llretptr);\n@@ -2252,7 +2252,7 @@ fn make_integral_cmp_glue(@block_ctxt cx, ValueRef lhs, ValueRef rhs,\n \n // Tag information\n \n-type variant_info = rec(vec[@ty.t] args, @ty.t ctor_ty, ast.def_id id);\n+type variant_info = rec(vec[ty.t] args, ty.t ctor_ty, ast.def_id id);\n \n // Returns information about the variants in a tag.\n fn tag_variants(@crate_ctxt cx, ast.def_id id) -> vec[variant_info] {\n@@ -2266,7 +2266,7 @@ fn tag_variants(@crate_ctxt cx, ast.def_id id) -> vec[variant_info] {\n             let vec[variant_info] result = vec();\n             for (ast.variant variant in variants) {\n                 auto ctor_ty = node_ann_type(cx, variant.node.ann);\n-                let vec[@ty.t] arg_tys = vec();\n+                let vec[ty.t] arg_tys = vec();\n                 if (_vec.len[ast.variant_arg](variant.node.args) > 0u) {\n                     for (ty.arg a in ty.ty_fn_args(ctor_ty)) {\n                         arg_tys += vec(a.ty);\n@@ -2303,22 +2303,22 @@ fn tag_variant_with_id(@crate_ctxt cx,\n \n type val_pair_fn = fn(@block_ctxt cx, ValueRef dst, ValueRef src) -> result;\n \n-type val_and_ty_fn = fn(@block_ctxt cx, ValueRef v, @ty.t t) -> result;\n+type val_and_ty_fn = fn(@block_ctxt cx, ValueRef v, ty.t t) -> result;\n \n type val_pair_and_ty_fn =\n-    fn(@block_ctxt cx, ValueRef av, ValueRef bv, @ty.t t) -> result;\n+    fn(@block_ctxt cx, ValueRef av, ValueRef bv, ty.t t) -> result;\n \n // Iterates through the elements of a structural type.\n fn iter_structural_ty(@block_ctxt cx,\n                       ValueRef v,\n-                      @ty.t t,\n+                      ty.t t,\n                       val_and_ty_fn f)\n     -> result {\n     fn adaptor_fn(val_and_ty_fn f,\n                   @block_ctxt cx,\n                   ValueRef av,\n                   ValueRef bv,\n-                  @ty.t t) -> result {\n+                  ty.t t) -> result {\n         ret f(cx, av, t);\n     }\n     be iter_structural_ty_full(cx, v, v, t,\n@@ -2329,7 +2329,7 @@ fn iter_structural_ty(@block_ctxt cx,\n fn iter_structural_ty_full(@block_ctxt cx,\n                            ValueRef av,\n                            ValueRef bv,\n-                           @ty.t t,\n+                           ty.t t,\n                            val_pair_and_ty_fn f)\n     -> result {\n     let result r = res(cx, C_nil());\n@@ -2424,7 +2424,7 @@ fn iter_structural_ty_full(@block_ctxt cx,\n                                                      _uint.to_str(i, 10u));\n                 llvm.LLVMAddCase(llswitch, C_int(i as int), variant_cx.llbb);\n \n-                if (_vec.len[@ty.t](variant.args) > 0u) {\n+                if (_vec.len[ty.t](variant.args) > 0u) {\n                     // N-ary variant.\n                     auto fn_ty = variant.ctor_ty;\n                     alt (ty.struct(fn_ty)) {\n@@ -2559,10 +2559,10 @@ fn iter_sequence_raw(@block_ctxt cx,\n fn iter_sequence_inner(@block_ctxt cx,\n                        ValueRef src,     // elt*\n                        ValueRef src_lim, // elt*\n-                       @ty.t elt_ty,\n+                       ty.t elt_ty,\n                        val_and_ty_fn f) -> result {\n     fn adaptor_fn(val_and_ty_fn f,\n-                  @ty.t elt_ty,\n+                  ty.t elt_ty,\n                   @block_ctxt cx,\n                   ValueRef dst,\n                   ValueRef src) -> result {\n@@ -2587,12 +2587,12 @@ fn iter_sequence_inner(@block_ctxt cx,\n // Iterates through the elements of a vec or str.\n fn iter_sequence(@block_ctxt cx,\n                  ValueRef v,\n-                 @ty.t t,\n+                 ty.t t,\n                  val_and_ty_fn f) -> result {\n \n     fn iter_sequence_body(@block_ctxt cx,\n                           ValueRef v,\n-                          @ty.t elt_ty,\n+                          ty.t elt_ty,\n                           val_and_ty_fn f,\n                           bool trailing_null) -> result {\n \n@@ -2654,14 +2654,14 @@ fn call_tydesc_glue_full(@block_ctxt cx, ValueRef v,\n                                 llrawptr));\n }\n \n-fn call_tydesc_glue(@block_ctxt cx, ValueRef v, @ty.t t, int field) {\n+fn call_tydesc_glue(@block_ctxt cx, ValueRef v, ty.t t, int field) {\n     auto td = get_tydesc(cx, t);\n     call_tydesc_glue_full(td.bcx,\n                           spill_if_immediate(td.bcx, v, t),\n                           td.val, field);\n }\n \n-fn call_cmp_glue(@block_ctxt cx, ValueRef lhs, ValueRef rhs, @ty.t t,\n+fn call_cmp_glue(@block_ctxt cx, ValueRef lhs, ValueRef rhs, ty.t t,\n                  ValueRef llop) -> result {\n     // We can't use call_tydesc_glue_full() and friends here because compare\n     // glue has a special signature.\n@@ -2697,7 +2697,7 @@ fn call_cmp_glue(@block_ctxt cx, ValueRef lhs, ValueRef rhs, @ty.t t,\n     ret res(r.bcx, r.bcx.build.Load(llcmpresultptr));\n }\n \n-fn take_ty(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n+fn take_ty(@block_ctxt cx, ValueRef v, ty.t t) -> result {\n     if (!ty.type_is_scalar(t)) {\n         call_tydesc_glue(cx, v, t, abi.tydesc_field_take_glue);\n     }\n@@ -2706,7 +2706,7 @@ fn take_ty(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n \n fn drop_slot(@block_ctxt cx,\n              ValueRef slot,\n-             @ty.t t) -> result {\n+             ty.t t) -> result {\n     auto llptr = load_if_immediate(cx, slot, t);\n     auto re = drop_ty(cx, llptr, t);\n \n@@ -2718,7 +2718,7 @@ fn drop_slot(@block_ctxt cx,\n \n fn drop_ty(@block_ctxt cx,\n            ValueRef v,\n-           @ty.t t) -> result {\n+           ty.t t) -> result {\n \n     if (!ty.type_is_scalar(t)) {\n         call_tydesc_glue(cx, v, t, abi.tydesc_field_drop_glue);\n@@ -2749,7 +2749,7 @@ fn call_bzero(@block_ctxt cx,\n fn memcpy_ty(@block_ctxt cx,\n              ValueRef dst,\n              ValueRef src,\n-             @ty.t t) -> result {\n+             ty.t t) -> result {\n     if (ty.type_has_dynamic_size(t)) {\n         auto llszptr = field_of_tydesc(cx, t, abi.tydesc_field_size);\n         auto llsz = llszptr.bcx.build.Load(llszptr.val);\n@@ -2769,7 +2769,7 @@ fn copy_ty(@block_ctxt cx,\n            copy_action action,\n            ValueRef dst,\n            ValueRef src,\n-           @ty.t t) -> result {\n+           ty.t t) -> result {\n     if (ty.type_is_scalar(t) || ty.type_is_native(t)) {\n         ret res(cx, cx.build.Store(src, dst));\n \n@@ -2849,7 +2849,7 @@ fn trans_lit(@crate_ctxt cx, &ast.lit lit, &ast.ann ann) -> ValueRef {\n     }\n }\n \n-fn target_type(@crate_ctxt cx, @ty.t t) -> @ty.t {\n+fn target_type(@crate_ctxt cx, ty.t t) -> ty.t {\n     alt (ty.struct(t)) {\n         case (ty.ty_int) {\n             auto struct_ty = ty.mk_mach(cx.tystore,\n@@ -2868,23 +2868,23 @@ fn target_type(@crate_ctxt cx, @ty.t t) -> @ty.t {\n \n \n // Converts an annotation to a type\n-fn node_ann_type(@crate_ctxt cx, &ast.ann a) -> @ty.t {\n+fn node_ann_type(@crate_ctxt cx, &ast.ann a) -> ty.t {\n     ret target_type(cx, ty.ann_to_monotype(cx.tystore, a));\n }\n \n-fn node_ann_ty_params(&ast.ann a) -> vec[@ty.t] {\n+fn node_ann_ty_params(&ast.ann a) -> vec[ty.t] {\n     alt (a) {\n         case (ast.ann_none) {\n             log_err \"missing type annotation\";\n             fail;\n         }\n         case (ast.ann_type(_, ?tps_opt, _)) {\n             alt (tps_opt) {\n-                case (none[vec[@ty.t]]) {\n+                case (none[vec[ty.t]]) {\n                     log_err \"type annotation has no ty params\";\n                     fail;\n                 }\n-                case (some[vec[@ty.t]](?tps)) { ret tps; }\n+                case (some[vec[ty.t]](?tps)) { ret tps; }\n             }\n         }\n     }\n@@ -2958,7 +2958,7 @@ fn trans_unary(@block_ctxt cx, ast.unop op,\n     fail;\n }\n \n-fn trans_compare(@block_ctxt cx0, ast.binop op, @ty.t t0,\n+fn trans_compare(@block_ctxt cx0, ast.binop op, ty.t t0,\n                  ValueRef lhs0, ValueRef rhs0) -> result {\n     // Autoderef both sides.\n     auto cx = cx0;\n@@ -2999,7 +2999,7 @@ fn trans_compare(@block_ctxt cx0, ast.binop op, @ty.t t0,\n     }\n }\n \n-fn trans_vec_append(@block_ctxt cx, @ty.t t,\n+fn trans_vec_append(@block_ctxt cx, ty.t t,\n                     ValueRef lhs, ValueRef rhs) -> result {\n \n     auto elt_ty = ty.sequence_element_type(cx.fcx.lcx.ccx.tystore, t);\n@@ -3028,7 +3028,7 @@ fn trans_vec_append(@block_ctxt cx, @ty.t t,\n                                         dst, src, skip_null)));\n }\n \n-fn trans_vec_add(@block_ctxt cx, @ty.t t,\n+fn trans_vec_add(@block_ctxt cx, ty.t t,\n                  ValueRef lhs, ValueRef rhs) -> result {\n     auto r = alloc_ty(cx, t);\n     auto tmp = r.val;\n@@ -3041,7 +3041,7 @@ fn trans_vec_add(@block_ctxt cx, @ty.t t,\n }\n \n \n-fn trans_eager_binop(@block_ctxt cx, ast.binop op, @ty.t intype,\n+fn trans_eager_binop(@block_ctxt cx, ast.binop op, ty.t intype,\n                      ValueRef lhs, ValueRef rhs) -> result {\n \n     auto is_float = false;\n@@ -3118,9 +3118,9 @@ fn trans_eager_binop(@block_ctxt cx, ast.binop op, @ty.t intype,\n     fail;\n }\n \n-fn autoderef(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n+fn autoderef(@block_ctxt cx, ValueRef v, ty.t t) -> result {\n     let ValueRef v1 = v;\n-    let @ty.t t1 = t;\n+    let ty.t t1 = t;\n \n     while (true) {\n         alt (ty.struct(t1)) {\n@@ -3150,8 +3150,8 @@ fn autoderef(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n     }\n }\n \n-fn autoderefed_ty(@ty.t t) -> @ty.t {\n-    let @ty.t t1 = t;\n+fn autoderefed_ty(ty.t t) -> ty.t {\n+    let ty.t t1 = t;\n \n     while (true) {\n         alt (ty.struct(t1)) {\n@@ -3329,7 +3329,7 @@ fn trans_for(@block_ctxt cx,\n              &ast.block body) -> result {\n     fn inner(@block_ctxt cx,\n              @ast.local local, ValueRef curr,\n-             @ty.t t, ast.block body,\n+             ty.t t, ast.block body,\n              @block_ctxt outer_next_cx) -> result {\n \n         auto next_cx = new_sub_block_ctxt(cx, \"next\");\n@@ -3841,29 +3841,29 @@ fn trans_alt(@block_ctxt cx, @ast.expr expr,\n     ret join_results(cx, expr_llty, arm_results);\n }\n \n-type generic_info = rec(@ty.t item_type,\n+type generic_info = rec(ty.t item_type,\n                         vec[ValueRef] tydescs);\n \n type lval_result = rec(result res,\n                        bool is_mem,\n                        option.t[generic_info] generic,\n                        option.t[ValueRef] llobj,\n-                       option.t[@ty.t] method_ty);\n+                       option.t[ty.t] method_ty);\n \n fn lval_mem(@block_ctxt cx, ValueRef val) -> lval_result {\n     ret rec(res=res(cx, val),\n             is_mem=true,\n             generic=none[generic_info],\n             llobj=none[ValueRef],\n-            method_ty=none[@ty.t]);\n+            method_ty=none[ty.t]);\n }\n \n fn lval_val(@block_ctxt cx, ValueRef val) -> lval_result {\n     ret rec(res=res(cx, val),\n             is_mem=false,\n             generic=none[generic_info],\n             llobj=none[ValueRef],\n-            method_ty=none[@ty.t]);\n+            method_ty=none[ty.t]);\n }\n \n fn trans_external_path(@block_ctxt cx, ast.def_id did,\n@@ -3891,22 +3891,22 @@ fn lval_generic_fn(@block_ctxt cx,\n     }\n \n     auto monoty;\n-    let vec[@ty.t] tys;\n+    let vec[ty.t] tys;\n     alt (ann) {\n         case (ast.ann_none) {\n             cx.fcx.lcx.ccx.sess.bug(\"no type annotation for path!\");\n             fail;\n         }\n         case (ast.ann_type(?monoty_, ?tps, _)) {\n             monoty = monoty_;\n-            tys = option.get[vec[@ty.t]](tps);\n+            tys = option.get[vec[ty.t]](tps);\n         }\n     }\n \n-    if (_vec.len[@ty.t](tys) != 0u) {\n+    if (_vec.len[ty.t](tys) != 0u) {\n         auto bcx = cx;\n         let vec[ValueRef] tydescs = vec();\n-        for (@ty.t t in tys) {\n+        for (ty.t t in tys) {\n             auto td = get_tydesc(bcx, t);\n             bcx = td.bcx;\n             _vec.push[ValueRef](tydescs, td.val);\n@@ -4046,7 +4046,7 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n     fail;\n }\n \n-fn trans_field(@block_ctxt cx, &ast.span sp, ValueRef v, @ty.t t0,\n+fn trans_field(@block_ctxt cx, &ast.span sp, ValueRef v, ty.t t0,\n                &ast.ident field, &ast.ann ann) -> lval_result {\n \n     auto r = autoderef(cx, v, t0);\n@@ -4075,10 +4075,10 @@ fn trans_field(@block_ctxt cx, &ast.span sp, ValueRef v, @ty.t t0,\n                                                 C_int(ix as int)));\n \n             auto lvo = lval_mem(r.bcx, v);\n-            let @ty.t fn_ty = ty.method_ty_to_fn_ty(cx.fcx.lcx.ccx.tystore,\n+            let ty.t fn_ty = ty.method_ty_to_fn_ty(cx.fcx.lcx.ccx.tystore,\n                                                     methods.(ix));\n             ret rec(llobj = some[ValueRef](r.val),\n-                    method_ty = some[@ty.t](fn_ty)\n+                    method_ty = some[ty.t](fn_ty)\n                     with lvo);\n         }\n         case (_) {cx.fcx.lcx.ccx.sess.unimpl(\"field variant in trans_field\");}\n@@ -4230,11 +4230,11 @@ fn trans_cast(@block_ctxt cx, @ast.expr e, &ast.ann ann) -> result {\n }\n \n fn trans_bind_thunk(@local_ctxt cx,\n-                    @ty.t incoming_fty,\n-                    @ty.t outgoing_fty,\n+                    ty.t incoming_fty,\n+                    ty.t outgoing_fty,\n                     vec[option.t[@ast.expr]] args,\n-                    @ty.t closure_ty,\n-                    vec[@ty.t] bound_tys,\n+                    ty.t closure_ty,\n+                    vec[ty.t] bound_tys,\n                     uint ty_param_count) -> ValueRef {\n     // Construct a thunk-call with signature incoming_fty, and that copies\n     // args forward into a call to outgoing_fty.\n@@ -4387,7 +4387,7 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n         }\n \n         // Figure out which tydescs we need to pass, if any.\n-        let @ty.t outgoing_fty;\n+        let ty.t outgoing_fty;\n         let vec[ValueRef] lltydescs;\n         alt (f_res.generic) {\n             case (none[generic_info]) {\n@@ -4410,39 +4410,39 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n             auto pair_v = alloca(bcx, pair_t);\n \n             // Translate the bound expressions.\n-            let vec[@ty.t] bound_tys = vec();\n+            let vec[ty.t] bound_tys = vec();\n             let vec[ValueRef] bound_vals = vec();\n             auto i = 0u;\n             for (@ast.expr e in bound) {\n                 auto arg = trans_expr(bcx, e);\n                 bcx = arg.bcx;\n \n                 _vec.push[ValueRef](bound_vals, arg.val);\n-                _vec.push[@ty.t](bound_tys,\n+                _vec.push[ty.t](bound_tys,\n                                  ty.expr_ty(cx.fcx.lcx.ccx.tystore, e));\n \n                 i += 1u;\n             }\n \n             // Synthesize a closure type.\n-            let @ty.t bindings_ty = ty.mk_imm_tup(cx.fcx.lcx.ccx.tystore,\n+            let ty.t bindings_ty = ty.mk_imm_tup(cx.fcx.lcx.ccx.tystore,\n                                                   bound_tys);\n \n             // NB: keep this in sync with T_closure_ptr; we're making\n             // a ty.t structure that has the same \"shape\" as the LLVM type\n             // it constructs.\n-            let @ty.t tydesc_ty = ty.mk_type(cx.fcx.lcx.ccx.tystore);\n+            let ty.t tydesc_ty = ty.mk_type(cx.fcx.lcx.ccx.tystore);\n \n-            let vec[@ty.t] captured_tys =\n-                _vec.init_elt[@ty.t](tydesc_ty, ty_param_count);\n+            let vec[ty.t] captured_tys =\n+                _vec.init_elt[ty.t](tydesc_ty, ty_param_count);\n \n-            let vec[@ty.t] closure_tys =\n+            let vec[ty.t] closure_tys =\n                 vec(tydesc_ty,\n                     outgoing_fty,\n                     bindings_ty,\n                     ty.mk_imm_tup(cx.fcx.lcx.ccx.tystore, captured_tys));\n \n-            let @ty.t closure_ty = ty.mk_imm_tup(cx.fcx.lcx.ccx.tystore,\n+            let ty.t closure_ty = ty.mk_imm_tup(cx.fcx.lcx.ccx.tystore,\n                                                  closure_tys);\n \n             auto r = trans_malloc_boxed(bcx, closure_ty);\n@@ -4528,7 +4528,7 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n                                            vec(C_int(0),\n                                                C_int(abi.fn_field_code)));\n \n-            let @ty.t pair_ty = node_ann_type(cx.fcx.lcx.ccx, ann);\n+            let ty.t pair_ty = node_ann_type(cx.fcx.lcx.ccx, ann);\n \n             let ValueRef llthunk =\n                 trans_bind_thunk(cx.fcx.lcx, pair_ty, outgoing_fty,\n@@ -4568,7 +4568,7 @@ fn trans_args(@block_ctxt cx,\n               option.t[generic_info] gen,\n               option.t[ValueRef] lliterbody,\n               &vec[@ast.expr] es,\n-              @ty.t fn_ty)\n+              ty.t fn_ty)\n     -> tup(@block_ctxt, vec[ValueRef], ValueRef) {\n \n     let vec[ty.arg] args = ty.ty_fn_args(fn_ty);\n@@ -4744,9 +4744,9 @@ fn trans_call(@block_ctxt cx, @ast.expr f,\n         }\n     }\n \n-    let @ty.t fn_ty;\n+    let ty.t fn_ty;\n     alt (f_res.method_ty) {\n-        case (some[@ty.t](?meth)) {\n+        case (some[ty.t](?meth)) {\n             // self-call\n             fn_ty = meth;\n         }\n@@ -4849,7 +4849,7 @@ fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n \n     auto pseudo_tup_ty =\n         ty.mk_imm_tup(cx.fcx.lcx.ccx.tystore,\n-                      _vec.init_elt[@ty.t](unit_ty,\n+                      _vec.init_elt[ty.t](unit_ty,\n                                            _vec.len[@ast.expr](args)));\n     let int i = 0;\n \n@@ -5117,7 +5117,7 @@ fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n // pointer (or need one), perform load/store operations based on the\n // immediate-ness of the type.\n \n-fn type_is_immediate(@ty.t t) -> bool {\n+fn type_is_immediate(ty.t t) -> bool {\n     ret ty.type_is_scalar(t) || ty.type_is_boxed(t) || ty.type_is_native(t);\n }\n \n@@ -5128,14 +5128,14 @@ fn do_spill(@block_ctxt cx, ValueRef v) -> ValueRef {\n     ret llptr;\n }\n \n-fn spill_if_immediate(@block_ctxt cx, ValueRef v, @ty.t t) -> ValueRef {\n+fn spill_if_immediate(@block_ctxt cx, ValueRef v, ty.t t) -> ValueRef {\n     if (type_is_immediate(t)) {\n         ret do_spill(cx, v);\n     }\n     ret v;\n }\n \n-fn load_if_immediate(@block_ctxt cx, ValueRef v, @ty.t t) -> ValueRef {\n+fn load_if_immediate(@block_ctxt cx, ValueRef v, ty.t t) -> ValueRef {\n     if (type_is_immediate(t)) {\n         ret cx.build.Load(v);\n     }\n@@ -5477,7 +5477,7 @@ fn trans_recv(@block_ctxt cx, @ast.expr lhs, @ast.expr rhs,\n  }\n \n fn recv_val(@block_ctxt cx, ValueRef lhs, @ast.expr rhs,\n-            @ty.t unit_ty, copy_action action) -> result {\n+            ty.t unit_ty, copy_action action) -> result {\n \n     auto bcx = cx;\n     auto prt = trans_expr(bcx, rhs);\n@@ -5527,7 +5527,7 @@ fn init_local(@block_ctxt cx, @ast.local local) -> result {\n     ret res(bcx, llptr);\n }\n \n-fn zero_alloca(@block_ctxt cx, ValueRef llptr, @ty.t t) -> result {\n+fn zero_alloca(@block_ctxt cx, ValueRef llptr, ty.t t) -> result {\n     auto bcx = cx;\n     if (ty.type_has_dynamic_size(t)) {\n         auto llsz = size_of(bcx, t);\n@@ -5660,7 +5660,7 @@ fn llallocas_block_ctxt(@fn_ctxt fcx) -> @block_ctxt {\n              fcx=fcx);\n }\n \n-fn alloc_ty(@block_ctxt cx, @ty.t t) -> result {\n+fn alloc_ty(@block_ctxt cx, ty.t t) -> result {\n     auto val = C_int(0);\n     if (ty.type_has_dynamic_size(t)) {\n \n@@ -5744,7 +5744,7 @@ fn trans_block(@block_ctxt cx, &ast.block b) -> result {\n \n                     fn drop_hoisted_ty(@block_ctxt cx,\n                                        ValueRef alloca_val,\n-                                       @ty.t t) -> result {\n+                                       ty.t t) -> result {\n                         auto reg_val = load_if_immediate(cx,\n                                                             alloca_val, t);\n                         ret drop_ty(cx, reg_val, t);\n@@ -5822,18 +5822,18 @@ fn new_fn_ctxt(@local_ctxt cx,\n \n fn create_llargs_for_fn_args(&@fn_ctxt cx,\n                              ast.proto proto,\n-                             option.t[tup(TypeRef, @ty.t)] ty_self,\n-                             @ty.t ret_ty,\n+                             option.t[tup(TypeRef, ty.t)] ty_self,\n+                             ty.t ret_ty,\n                              &vec[ast.arg] args,\n                              &vec[ast.ty_param] ty_params) {\n \n     auto arg_n = 3u;\n \n     alt (ty_self) {\n-        case (some[tup(TypeRef, @ty.t)](?tt)) {\n+        case (some[tup(TypeRef, ty.t)](?tt)) {\n             cx.llself = some[self_vt](rec(v = cx.llenv, t = tt._1));\n         }\n-        case (none[tup(TypeRef, @ty.t)]) {\n+        case (none[tup(TypeRef, ty.t)]) {\n             auto i = 0u;\n             for (ast.ty_param tp in ty_params) {\n                 auto llarg = llvm.LLVMGetParam(cx.llfn, arg_n);\n@@ -5865,14 +5865,14 @@ fn create_llargs_for_fn_args(&@fn_ctxt cx,\n // were passed and whatnot. Apparently mem2reg will mop up.\n \n fn copy_any_self_to_alloca(@fn_ctxt fcx,\n-                           option.t[tup(TypeRef, @ty.t)] ty_self) {\n+                           option.t[tup(TypeRef, ty.t)] ty_self) {\n \n     auto bcx = llallocas_block_ctxt(fcx);\n \n     alt (fcx.llself) {\n         case (some[self_vt](?s_vt)) {\n             alt (ty_self) {\n-                case (some[tup(TypeRef, @ty.t)](?tt)) {\n+                case (some[tup(TypeRef, ty.t)](?tt)) {\n                     auto a = alloca(bcx, tt._0);\n                     bcx.build.Store(s_vt.v, a);\n                     fcx.llself = some[self_vt](rec(v = a, t = s_vt.t));\n@@ -5923,7 +5923,7 @@ fn arg_tys_of_fn(ast.ann ann) -> vec[ty.arg] {\n     fail;\n }\n \n-fn ret_ty_of_fn_ty(@ty.t t) -> @ty.t {\n+fn ret_ty_of_fn_ty(ty.t t) -> ty.t {\n     alt (ty.struct(t)) {\n         case (ty.ty_fn(_, _, ?ret_ty)) {\n             ret ret_ty;\n@@ -5933,14 +5933,14 @@ fn ret_ty_of_fn_ty(@ty.t t) -> @ty.t {\n }\n \n \n-fn ret_ty_of_fn(ast.ann ann) -> @ty.t {\n+fn ret_ty_of_fn(ast.ann ann) -> ty.t {\n     ret ret_ty_of_fn_ty(ty.ann_to_type(ann));\n }\n \n fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, self_vt llself) {\n     auto bcx = llallocas_block_ctxt(fcx);\n \n-    let vec[@ty.t] field_tys = vec();\n+    let vec[ty.t] field_tys = vec();\n \n     for (ast.obj_field f in bcx.fcx.lcx.obj_fields) {\n         field_tys += vec(node_ann_type(bcx.fcx.lcx.ccx, f.ann));\n@@ -6007,7 +6007,7 @@ fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, self_vt llself) {\n }\n \n fn trans_fn(@local_ctxt cx, &ast._fn f, ast.def_id fid,\n-            option.t[tup(TypeRef, @ty.t)] ty_self,\n+            option.t[tup(TypeRef, ty.t)] ty_self,\n             &vec[ast.ty_param] ty_params, &ast.ann ann) {\n \n     auto llfndecl = cx.ccx.item_ids.get(fid);\n@@ -6045,7 +6045,7 @@ fn trans_fn(@local_ctxt cx, &ast._fn f, ast.def_id fid,\n \n fn trans_vtbl(@local_ctxt cx, \n               TypeRef llself_ty,\n-              @ty.t self_ty,\n+              ty.t self_ty,\n               &ast._obj ob,\n               &vec[ast.ty_param] ty_params) -> ValueRef {\n     let vec[ValueRef] methods = vec();\n@@ -6077,7 +6077,7 @@ fn trans_vtbl(@local_ctxt cx,\n         cx.ccx.item_symbols.insert(m.node.id, s);\n \n         trans_fn(mcx, m.node.meth, m.node.id, \n-                 some[tup(TypeRef, @ty.t)](tup(llself_ty, self_ty)),\n+                 some[tup(TypeRef, ty.t)](tup(llself_ty, self_ty)),\n                  ty_params, m.node.ann);\n         methods += vec(llfn);\n     }\n@@ -6094,7 +6094,7 @@ fn trans_vtbl(@local_ctxt cx,\n \n fn trans_dtor(@local_ctxt cx,\n               TypeRef llself_ty,\n-              @ty.t self_ty,\n+              ty.t self_ty,\n               &vec[ast.ty_param] ty_params,\n               &@ast.method dtor) -> ValueRef {\n \n@@ -6115,7 +6115,7 @@ fn trans_dtor(@local_ctxt cx,\n     cx.ccx.item_symbols.insert(dtor.node.id, s);\n \n     trans_fn(dcx, dtor.node.meth, dtor.node.id,\n-             some[tup(TypeRef, @ty.t)](tup(llself_ty, self_ty)),\n+             some[tup(TypeRef, ty.t)](tup(llself_ty, self_ty)),\n              ty_params, dtor.node.ann);\n \n     ret llfn;\n@@ -6137,7 +6137,7 @@ fn trans_obj(@local_ctxt cx, &ast._obj ob, ast.def_id oid,\n \n     auto fcx = new_fn_ctxt(cx, llctor_decl);\n     create_llargs_for_fn_args(fcx, ast.proto_fn,\n-                              none[tup(TypeRef, @ty.t)], \n+                              none[tup(TypeRef, ty.t)], \n                               ret_ty_of_fn(ann),\n                               fn_args, ty_params);\n \n@@ -6167,25 +6167,25 @@ fn trans_obj(@local_ctxt cx, &ast._obj ob, ast.def_id oid,\n         bcx.build.Store(C_null(llbox_ty), pair_box);\n     } else {\n         // Malloc a box for the body and copy args in.\n-        let vec[@ty.t] obj_fields = vec();\n+        let vec[ty.t] obj_fields = vec();\n         for (ty.arg a in arg_tys) {\n-            _vec.push[@ty.t](obj_fields, a.ty);\n+            _vec.push[ty.t](obj_fields, a.ty);\n         }\n \n         // Synthesize an obj body type.\n         auto tydesc_ty = ty.mk_type(cx.ccx.tystore);\n-        let vec[@ty.t] tps = vec();\n+        let vec[ty.t] tps = vec();\n         for (ast.ty_param tp in ty_params) {\n-            _vec.push[@ty.t](tps, tydesc_ty);\n+            _vec.push[ty.t](tps, tydesc_ty);\n         }\n \n-        let @ty.t typarams_ty = ty.mk_imm_tup(cx.ccx.tystore, tps);\n-        let @ty.t fields_ty = ty.mk_imm_tup(cx.ccx.tystore, obj_fields);\n-        let @ty.t body_ty = ty.mk_imm_tup(cx.ccx.tystore,\n+        let ty.t typarams_ty = ty.mk_imm_tup(cx.ccx.tystore, tps);\n+        let ty.t fields_ty = ty.mk_imm_tup(cx.ccx.tystore, obj_fields);\n+        let ty.t body_ty = ty.mk_imm_tup(cx.ccx.tystore,\n                                           vec(tydesc_ty,\n                                               typarams_ty,\n                                               fields_ty));\n-        let @ty.t boxed_body_ty = ty.mk_imm_box(cx.ccx.tystore, body_ty);\n+        let ty.t boxed_body_ty = ty.mk_imm_box(cx.ccx.tystore, body_ty);\n \n         // Malloc a box for the body.\n         auto box = trans_malloc_boxed(bcx, body_ty);\n@@ -6280,11 +6280,11 @@ fn trans_tag_variant(@local_ctxt cx, ast.def_id tag_id,\n     auto fcx = new_fn_ctxt(cx, llfndecl);\n \n     create_llargs_for_fn_args(fcx, ast.proto_fn,\n-                              none[tup(TypeRef, @ty.t)], \n+                              none[tup(TypeRef, ty.t)], \n                               ret_ty_of_fn(variant.node.ann),\n                               fn_args, ty_params);\n \n-    let vec[@ty.t] ty_param_substs = vec();\n+    let vec[ty.t] ty_param_substs = vec();\n     i = 0u;\n     for (ast.ty_param tp in ty_params) {\n         ty_param_substs += vec(ty.mk_param(cx.ccx.tystore, i));\n@@ -6371,7 +6371,7 @@ fn trans_item(@local_ctxt cx, &ast.item item) {\n     alt (item.node) {\n         case (ast.item_fn(?name, ?f, ?tps, ?fid, ?ann)) {\n             auto sub_cx = extend_path(cx, name);\n-            trans_fn(sub_cx, f, fid, none[tup(TypeRef, @ty.t)], tps, ann);\n+            trans_fn(sub_cx, f, fid, none[tup(TypeRef, ty.t)], tps, ann);\n         }\n         case (ast.item_obj(?name, ?ob, ?tps, ?oid, ?ann)) {\n             auto sub_cx = @rec(obj_typarams=tps,\n@@ -6480,7 +6480,7 @@ fn native_fn_ty_param_count(@crate_ctxt cx, &ast.def_id id) -> uint {\n     ret count;\n }\n \n-fn native_fn_wrapper_type(@crate_ctxt cx, uint ty_param_count, @ty.t x)\n+fn native_fn_wrapper_type(@crate_ctxt cx, uint ty_param_count, ty.t x)\n         -> TypeRef {\n     alt (ty.struct(x)) {\n         case (ty.ty_native_fn(?abi, ?args, ?out)) {\n@@ -6551,7 +6551,7 @@ fn decl_native_fn_and_pair(@crate_ctxt ccx,\n     fn push_arg(@block_ctxt cx,\n                 &mutable vec[ValueRef] args,\n                 ValueRef v,\n-                @ty.t t) {\n+                ty.t t) {\n         if (ty.type_is_integral(t)) {\n             auto lldsttype = T_int();\n             auto llsrctype = type_of(cx.fcx.lcx.ccx, t);\n@@ -7502,9 +7502,9 @@ fn trans_crate(session.session sess, @ast.crate crate, @ty.type_store tystore,\n     auto glues = make_glues(llmod, tn);\n     auto hasher = ty.hash_ty;\n     auto eqer = ty.eq_ty;\n-    auto tag_sizes = map.mk_hashmap[@ty.t,uint](hasher, eqer);\n-    auto tydescs = map.mk_hashmap[@ty.t,@tydesc_info](hasher, eqer);\n-    auto lltypes = map.mk_hashmap[@ty.t,TypeRef](hasher, eqer);\n+    auto tag_sizes = map.mk_hashmap[ty.t,uint](hasher, eqer);\n+    auto tydescs = map.mk_hashmap[ty.t,@tydesc_info](hasher, eqer);\n+    auto lltypes = map.mk_hashmap[ty.t,TypeRef](hasher, eqer);\n \n     auto ccx = @rec(sess = sess,\n                     llmod = llmod,"}, {"sha": "eca80aff30a1e7cd60a29a314bc1977e03815a93", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 173, "deletions": 172, "changes": 345, "blob_url": "https://github.com/rust-lang/rust/blob/c7473c8260cbe6892eeed82f275bf09a73895e0e/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7473c8260cbe6892eeed82f275bf09a73895e0e/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=c7473c8260cbe6892eeed82f275bf09a73895e0e", "patch": "@@ -21,18 +21,18 @@ import util.typestate_ann.ts_ann;\n \n // Data types\n \n-type arg = rec(ast.mode mode, @t ty);\n+type arg = rec(ast.mode mode, t ty);\n type field = rec(ast.ident ident, mt mt);\n type method = rec(ast.proto proto,\n                   ast.ident ident,\n                   vec[arg] inputs,\n-                  @t output);\n+                  t output);\n \n-type mt = rec(@t ty, ast.mutability mut);\n+type mt = rec(t ty, ast.mutability mut);\n \n // Convert from method type to function type.  Pretty easy; we just drop\n // 'ident'.\n-fn method_ty_to_fn_ty(@type_store tystore, method m) -> @ty.t {\n+fn method_ty_to_fn_ty(@type_store tystore, method m) -> t {\n     ret mk_fn(tystore, m.proto, m.inputs, m.output);\n }\n \n@@ -42,7 +42,8 @@ fn method_ty_to_fn_ty(@type_store tystore, method m) -> @ty.t {\n //\n // TODO: It'd be really nice to be able to hide this definition from the\n // outside world, to enforce the above invariants.\n-type t = rec(sty struct, option.t[str] cname, uint hash);\n+type raw_t = rec(sty struct, option.t[str] cname, uint hash);\n+type t = @raw_t;\n \n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in front/ast.rs as well.\n@@ -55,32 +56,32 @@ tag sty {\n     ty_machine(util.common.ty_mach);\n     ty_char;\n     ty_str;\n-    ty_tag(ast.def_id, vec[@t]);\n+    ty_tag(ast.def_id, vec[t]);\n     ty_box(mt);\n     ty_vec(mt);\n-    ty_port(@t);\n-    ty_chan(@t);\n+    ty_port(t);\n+    ty_chan(t);\n     ty_task;\n     ty_tup(vec[mt]);\n     ty_rec(vec[field]);\n-    ty_fn(ast.proto, vec[arg], @t);\n-    ty_native_fn(ast.native_abi, vec[arg], @t);\n+    ty_fn(ast.proto, vec[arg], t);\n+    ty_native_fn(ast.native_abi, vec[arg], t);\n     ty_obj(vec[method]);\n     ty_var(int);                                    // ephemeral type var\n     ty_local(ast.def_id);                           // type of a local var\n     ty_param(uint);                                 // fn/tag type param\n     ty_bound_param(uint);                           // bound param, only paths\n     ty_type;\n     ty_native;\n-    // TODO: ty_fn_arg(@t), for a possibly-aliased function argument\n+    // TODO: ty_fn_arg(t), for a possibly-aliased function argument\n }\n \n // Data structures used in type unification\n \n type unify_handler = obj {\n-    fn resolve_local(ast.def_id id) -> option.t[@t];\n-    fn record_local(ast.def_id id, @t ty);  // TODO: -> Unify.result\n-    fn record_param(uint index, @t binding) -> Unify.result;\n+    fn resolve_local(ast.def_id id) -> option.t[t];\n+    fn record_local(ast.def_id id, t ty);  // TODO: -> Unify.result\n+    fn record_param(uint index, t binding) -> Unify.result;\n };\n \n tag type_err {\n@@ -98,123 +99,123 @@ tag type_err {\n }\n \n \n-type ty_param_count_and_ty = tup(uint, @t);\n+type ty_param_count_and_ty = tup(uint, t);\n type type_cache = hashmap[ast.def_id,ty_param_count_and_ty];\n \n \n-type type_store = hashmap[@t,@t];\n+type type_store = hashmap[t,t];\n \n fn mk_type_store() -> @type_store {\n     auto hasher = hash_ty;\n     auto eqer = eq_ty_full;\n-    ret @map.mk_hashmap[@t,@t](hasher, eqer);\n+    ret @map.mk_hashmap[t,t](hasher, eqer);\n }\n \n // Type constructors\n \n // These are private constructors to this module. External users should always\n // use the mk_foo() functions below.\n-fn gen_ty(@type_store tystore, &sty st) -> @t {\n+fn gen_ty(@type_store tystore, &sty st) -> t {\n     ret gen_ty_full(tystore, st, none[str]);\n }\n \n-fn gen_ty_full(@type_store tystore, &sty st, option.t[str] cname) -> @t {\n+fn gen_ty_full(@type_store tystore, &sty st, option.t[str] cname) -> t {\n     auto h = hash_type_structure(st);\n     auto new_type = @rec(struct=st, cname=cname, hash=h);\n \n     // Is it interned?\n     alt (tystore.find(new_type)) {\n-        case (some[@t](?typ)) {\n+        case (some[t](?typ)) {\n             ret typ;\n         }\n-        case (none[@t]) {\n+        case (none[t]) {\n             // Nope. Insert it and return.\n             tystore.insert(new_type, new_type);\n             ret new_type;\n         }\n     }\n }\n \n-fn mk_nil(@type_store ts) -> @t          { ret gen_ty(ts, ty_nil); }\n-fn mk_bool(@type_store ts) -> @t         { ret gen_ty(ts, ty_bool); }\n-fn mk_int(@type_store ts) -> @t          { ret gen_ty(ts, ty_int); }\n-fn mk_float(@type_store ts) -> @t        { ret gen_ty(ts, ty_float); }\n-fn mk_uint(@type_store ts) -> @t         { ret gen_ty(ts, ty_uint); }\n+fn mk_nil(@type_store ts) -> t          { ret gen_ty(ts, ty_nil); }\n+fn mk_bool(@type_store ts) -> t         { ret gen_ty(ts, ty_bool); }\n+fn mk_int(@type_store ts) -> t          { ret gen_ty(ts, ty_int); }\n+fn mk_float(@type_store ts) -> t        { ret gen_ty(ts, ty_float); }\n+fn mk_uint(@type_store ts) -> t         { ret gen_ty(ts, ty_uint); }\n \n-fn mk_mach(@type_store ts, util.common.ty_mach tm) -> @t {\n+fn mk_mach(@type_store ts, util.common.ty_mach tm) -> t {\n     ret gen_ty(ts, ty_machine(tm));\n }\n \n-fn mk_char(@type_store ts) -> @t         { ret gen_ty(ts, ty_char); }\n-fn mk_str(@type_store ts) -> @t          { ret gen_ty(ts, ty_str); }\n+fn mk_char(@type_store ts) -> t         { ret gen_ty(ts, ty_char); }\n+fn mk_str(@type_store ts) -> t          { ret gen_ty(ts, ty_str); }\n \n-fn mk_tag(@type_store ts, ast.def_id did, vec[@t] tys) -> @t {\n+fn mk_tag(@type_store ts, ast.def_id did, vec[t] tys) -> t {\n     ret gen_ty(ts, ty_tag(did, tys));\n }\n \n-fn mk_box(@type_store ts, mt tm) -> @t {\n+fn mk_box(@type_store ts, mt tm) -> t {\n     ret gen_ty(ts, ty_box(tm));\n }\n \n-fn mk_imm_box(@type_store ts, @t ty) -> @t {\n+fn mk_imm_box(@type_store ts, t ty) -> t {\n     ret mk_box(ts, rec(ty=ty, mut=ast.imm));\n }\n \n-fn mk_vec(@type_store ts, mt tm) -> @t   { ret gen_ty(ts, ty_vec(tm)); }\n-fn mk_port(@type_store ts, @t ty) -> @t  { ret gen_ty(ts, ty_port(ty)); }\n-fn mk_chan(@type_store ts, @t ty) -> @t  { ret gen_ty(ts, ty_chan(ty)); }\n-fn mk_task(@type_store ts) -> @t         { ret gen_ty(ts, ty_task); }\n+fn mk_vec(@type_store ts, mt tm) -> t   { ret gen_ty(ts, ty_vec(tm)); }\n+fn mk_port(@type_store ts, t ty) -> t   { ret gen_ty(ts, ty_port(ty)); }\n+fn mk_chan(@type_store ts, t ty) -> t   { ret gen_ty(ts, ty_chan(ty)); }\n+fn mk_task(@type_store ts) -> t         { ret gen_ty(ts, ty_task); }\n \n-fn mk_tup(@type_store ts, vec[mt] tms) -> @t {\n+fn mk_tup(@type_store ts, vec[mt] tms) -> t {\n     ret gen_ty(ts, ty_tup(tms));\n }\n \n-fn mk_imm_tup(@type_store ts, vec[@t] tys) -> @t {\n+fn mk_imm_tup(@type_store ts, vec[t] tys) -> t {\n     // TODO: map\n     let vec[ty.mt] mts = vec();\n-    for (@ty.t typ in tys) {\n+    for (t typ in tys) {\n         mts += vec(rec(ty=typ, mut=ast.imm));\n     }\n     ret mk_tup(ts, mts);\n }\n \n-fn mk_rec(@type_store ts, vec[field] fs) -> @t {\n+fn mk_rec(@type_store ts, vec[field] fs) -> t {\n     ret gen_ty(ts, ty_rec(fs));\n }\n \n-fn mk_fn(@type_store ts, ast.proto proto, vec[arg] args, @t ty) -> @t {\n+fn mk_fn(@type_store ts, ast.proto proto, vec[arg] args, t ty) -> t {\n     ret gen_ty(ts, ty_fn(proto, args, ty));\n }\n \n-fn mk_native_fn(@type_store ts, ast.native_abi abi, vec[arg] args, @t ty)\n-        -> @t {\n+fn mk_native_fn(@type_store ts, ast.native_abi abi, vec[arg] args, t ty)\n+        -> t {\n     ret gen_ty(ts, ty_native_fn(abi, args, ty));\n }\n \n-fn mk_obj(@type_store ts, vec[method] meths) -> @t {\n+fn mk_obj(@type_store ts, vec[method] meths) -> t {\n     ret gen_ty(ts, ty_obj(meths));\n }\n \n-fn mk_var(@type_store ts, int v) -> @t   { ret gen_ty(ts, ty_var(v)); }\n+fn mk_var(@type_store ts, int v) -> t    { ret gen_ty(ts, ty_var(v)); }\n \n-fn mk_local(@type_store ts, ast.def_id did) -> @t {\n+fn mk_local(@type_store ts, ast.def_id did) -> t {\n     ret gen_ty(ts, ty_local(did));\n }\n \n-fn mk_param(@type_store ts, uint n) -> @t {\n+fn mk_param(@type_store ts, uint n) -> t {\n     ret gen_ty(ts, ty_param(n));\n }\n \n-fn mk_bound_param(@type_store ts, uint n) -> @t {\n+fn mk_bound_param(@type_store ts, uint n) -> t {\n     ret gen_ty(ts, ty_bound_param(n));\n }\n \n-fn mk_type(@type_store ts) -> @t         { ret gen_ty(ts, ty_type); }\n-fn mk_native(@type_store ts) -> @t       { ret gen_ty(ts, ty_native); }\n+fn mk_type(@type_store ts) -> t          { ret gen_ty(ts, ty_type); }\n+fn mk_native(@type_store ts) -> t        { ret gen_ty(ts, ty_native); }\n \n \n // Returns the one-level-deep type structure of the given type.\n-fn struct(@t typ) -> sty { ret typ.struct; }\n+fn struct(t typ) -> sty { ret typ.struct; }\n \n \n // Stringification\n@@ -230,9 +231,9 @@ fn path_to_str(&ast.path pth) -> str {\n     ret result;\n }\n \n-fn ty_to_str(&@t typ) -> str {\n+fn ty_to_str(&t typ) -> str {\n \n-    fn fn_input_to_str(&rec(ast.mode mode, @t ty) input) -> str {\n+    fn fn_input_to_str(&rec(ast.mode mode, t ty) input) -> str {\n         auto s;\n         if (mode_is_alias(input.mode)) {\n             s = \"&\";\n@@ -245,7 +246,7 @@ fn ty_to_str(&@t typ) -> str {\n \n     fn fn_to_str(ast.proto proto,\n                  option.t[ast.ident] ident,\n-                 vec[arg] inputs, @t output) -> str {\n+                 vec[arg] inputs, t output) -> str {\n             auto f = fn_input_to_str;\n \n             auto s;\n@@ -329,9 +330,9 @@ fn ty_to_str(&@t typ) -> str {\n             // The user should never see this if the cname is set properly!\n             s += \"<tag#\" + util.common.istr(id._0) + \":\" +\n                 util.common.istr(id._1) + \">\";\n-            if (_vec.len[@t](tps) > 0u) {\n+            if (_vec.len[t](tps) > 0u) {\n                 auto f = ty_to_str;\n-                auto strs = _vec.map[@t,str](f, tps);\n+                auto strs = _vec.map[t,str](f, tps);\n                 s += \"[\" + _str.connect(strs, \",\") + \"]\";\n             }\n         }\n@@ -380,9 +381,9 @@ fn ty_to_str(&@t typ) -> str {\n \n // Type folds\n \n-type ty_walk = fn(@t);\n+type ty_walk = fn(t);\n \n-fn walk_ty(ty_walk walker, @t ty) {\n+fn walk_ty(ty_walk walker, t ty) {\n     alt (struct(ty)) {\n         case (ty_nil)           { /* no-op */ }\n         case (ty_bool)          { /* no-op */ }\n@@ -399,7 +400,7 @@ fn walk_ty(ty_walk walker, @t ty) {\n         case (ty_port(?subty))  { walk_ty(walker, subty); }\n         case (ty_chan(?subty))  { walk_ty(walker, subty); }\n         case (ty_tag(?tid, ?subtys)) {\n-            for (@t subty in subtys) {\n+            for (t subty in subtys) {\n                 walk_ty(walker, subty);\n             }\n         }\n@@ -443,9 +444,9 @@ fn walk_ty(ty_walk walker, @t ty) {\n     walker(ty);\n }\n \n-type ty_fold = fn(@t) -> @t;\n+type ty_fold = fn(t) -> t;\n \n-fn fold_ty(@type_store tystore, ty_fold fld, @t ty_0) -> @t {\n+fn fold_ty(@type_store tystore, ty_fold fld, t ty_0) -> t {\n     auto ty = ty_0;\n     alt (struct(ty)) {\n         case (ty_nil)           { /* no-op */ }\n@@ -478,8 +479,8 @@ fn fold_ty(@type_store tystore, ty_fold fld, @t ty_0) -> @t {\n                 mk_chan(tystore, fold_ty(tystore, fld, subty)), ty);\n         }\n         case (ty_tag(?tid, ?subtys)) {\n-            let vec[@t] new_subtys = vec();\n-            for (@t subty in subtys) {\n+            let vec[t] new_subtys = vec();\n+            for (t subty in subtys) {\n                 new_subtys += vec(fold_ty(tystore, fld, subty));\n             }\n             ty = copy_cname(tystore, mk_tag(tystore, tid, new_subtys), ty);\n@@ -547,13 +548,13 @@ fn fold_ty(@type_store tystore, ty_fold fld, @t ty_0) -> @t {\n \n // Type utilities\n \n-fn rename(@type_store tystore, @t typ, str new_cname) -> @t {\n+fn rename(@type_store tystore, t typ, str new_cname) -> t {\n     ret gen_ty_full(tystore, struct(typ), some[str](new_cname));\n }\n \n // Returns a type with the structural part taken from `struct_ty` and the\n // canonical name from `cname_ty`.\n-fn copy_cname(@type_store tystore, @t struct_ty, @t cname_ty) -> @t {\n+fn copy_cname(@type_store tystore, t struct_ty, t cname_ty) -> t {\n     ret gen_ty_full(tystore, struct(struct_ty), cname_ty.cname);\n }\n \n@@ -566,23 +567,23 @@ fn mode_is_alias(ast.mode m) -> bool {\n     fail;\n }\n \n-fn type_is_nil(@t ty) -> bool {\n+fn type_is_nil(t ty) -> bool {\n     alt (struct(ty)) {\n         case (ty_nil) { ret true; }\n         case (_) { ret false; }\n     }\n     fail;\n }\n \n-fn type_is_bool(@t ty) -> bool {\n+fn type_is_bool(t ty) -> bool {\n     alt (struct(ty)) {\n         case (ty_bool) { ret true; }\n         case (_) { ret false; }\n     }\n }\n \n \n-fn type_is_structural(@t ty) -> bool {\n+fn type_is_structural(t ty) -> bool {\n     alt (struct(ty)) {\n         case (ty_tup(_))    { ret true; }\n         case (ty_rec(_))    { ret true; }\n@@ -594,7 +595,7 @@ fn type_is_structural(@t ty) -> bool {\n     fail;\n }\n \n-fn type_is_sequence(@t ty) -> bool {\n+fn type_is_sequence(t ty) -> bool {\n     alt (struct(ty)) {\n         case (ty_str)    { ret true; }\n         case (ty_vec(_))    { ret true; }\n@@ -603,7 +604,7 @@ fn type_is_sequence(@t ty) -> bool {\n     fail;\n }\n \n-fn sequence_element_type(@type_store tystore, @t ty) -> @t {\n+fn sequence_element_type(@type_store tystore, t ty) -> t {\n     alt (struct(ty)) {\n         case (ty_str)      { ret mk_mach(tystore, common.ty_u8); }\n         case (ty_vec(?mt)) { ret mt.ty; }\n@@ -612,7 +613,7 @@ fn sequence_element_type(@type_store tystore, @t ty) -> @t {\n }\n \n \n-fn type_is_tup_like(@t ty) -> bool {\n+fn type_is_tup_like(t ty) -> bool {\n     alt (struct(ty)) {\n         case (ty_box(_))    { ret true; }\n         case (ty_tup(_))    { ret true; }\n@@ -623,7 +624,7 @@ fn type_is_tup_like(@t ty) -> bool {\n     fail;\n }\n \n-fn get_element_type(@t ty, uint i) -> @t {\n+fn get_element_type(t ty, uint i) -> t {\n     check (type_is_tup_like(ty));\n     alt (struct(ty)) {\n         case (ty_tup(?mts)) {\n@@ -636,15 +637,15 @@ fn get_element_type(@t ty, uint i) -> @t {\n     fail;\n }\n \n-fn type_is_box(@t ty) -> bool {\n+fn type_is_box(t ty) -> bool {\n     alt (struct(ty)) {\n         case (ty_box(_)) { ret true; }\n         case (_) { ret false; }\n     }\n     fail;\n }\n \n-fn type_is_boxed(@t ty) -> bool {\n+fn type_is_boxed(t ty) -> bool {\n     alt (struct(ty)) {\n         case (ty_str) { ret true; }\n         case (ty_vec(_)) { ret true; }\n@@ -656,7 +657,7 @@ fn type_is_boxed(@t ty) -> bool {\n     fail;\n }\n \n-fn type_is_scalar(@t ty) -> bool {\n+fn type_is_scalar(t ty) -> bool {\n     alt (struct(ty)) {\n         case (ty_nil) { ret true; }\n         case (ty_bool) { ret true; }\n@@ -674,15 +675,15 @@ fn type_is_scalar(@t ty) -> bool {\n \n // FIXME: should we just return true for native types in\n // type_is_scalar?\n-fn type_is_native(@t ty) -> bool {\n+fn type_is_native(t ty) -> bool {\n     alt (struct(ty)) {\n         case (ty_native) { ret true; }\n         case (_) { ret false; }\n     }\n     fail;\n }\n \n-fn type_has_dynamic_size(@t ty) -> bool {\n+fn type_has_dynamic_size(t ty) -> bool {\n     alt (struct(ty)) {\n         case (ty_tup(?mts)) {\n             auto i = 0u;\n@@ -700,7 +701,7 @@ fn type_has_dynamic_size(@t ty) -> bool {\n         }\n         case (ty_tag(_, ?subtys)) {\n             auto i = 0u;\n-            while (i < _vec.len[@t](subtys)) {\n+            while (i < _vec.len[t](subtys)) {\n                 if (type_has_dynamic_size(subtys.(i))) { ret true; }\n                 i += 1u;\n             }\n@@ -711,7 +712,7 @@ fn type_has_dynamic_size(@t ty) -> bool {\n     ret false;\n }\n \n-fn type_is_integral(@t ty) -> bool {\n+fn type_is_integral(t ty) -> bool {\n     alt (struct(ty)) {\n         case (ty_int) { ret true; }\n         case (ty_uint) { ret true; }\n@@ -735,7 +736,7 @@ fn type_is_integral(@t ty) -> bool {\n     fail;\n }\n \n-fn type_is_fp(@t ty) -> bool {\n+fn type_is_fp(t ty) -> bool {\n     alt (struct(ty)) {\n         case (ty_machine(?tm)) {\n             alt (tm) {\n@@ -752,7 +753,7 @@ fn type_is_fp(@t ty) -> bool {\n     fail;\n }\n \n-fn type_is_signed(@t ty) -> bool {\n+fn type_is_signed(t ty) -> bool {\n     alt (struct(ty)) {\n         case (ty_int) { ret true; }\n         case (ty_machine(?tm)) {\n@@ -769,7 +770,7 @@ fn type_is_signed(@t ty) -> bool {\n     fail;\n }\n \n-fn type_param(@t ty) -> option.t[uint] {\n+fn type_param(t ty) -> option.t[uint] {\n     alt (struct(ty)) {\n         case (ty_param(?id)) { ret some[uint](id); }\n         case (_)             { /* fall through */  }\n@@ -797,13 +798,13 @@ fn hash_type_structure(&sty st) -> uint {\n         ret h;\n     }\n \n-    fn hash_subty(uint id, @t subty) -> uint {\n+    fn hash_subty(uint id, t subty) -> uint {\n         auto h = id;\n         h += h << 5u + hash_ty(subty);\n         ret h;\n     }\n \n-    fn hash_fn(uint id, vec[arg] args, @t rty) -> uint {\n+    fn hash_fn(uint id, vec[arg] args, t rty) -> uint {\n         auto h = id;\n         for (arg a in args) {\n             h += h << 5u + hash_ty(a.ty);\n@@ -838,7 +839,7 @@ fn hash_type_structure(&sty st) -> uint {\n         case (ty_str) { ret 16u; }\n         case (ty_tag(?did, ?tys)) {\n             auto h = hash_def(17u, did);\n-            for (@ty.t typ in tys) {\n+            for (t typ in tys) {\n                 h += h << 5u + hash_ty(typ);\n             }\n             ret h;\n@@ -880,13 +881,13 @@ fn hash_type_structure(&sty st) -> uint {\n     }\n }\n \n-fn hash_ty(&@t typ) -> uint { ret typ.hash; }\n+fn hash_ty(&t typ) -> uint { ret typ.hash; }\n \n \n // Type equality. This function is private to this module (and slow); external\n // users should use `eq_ty()` instead.\n fn equal_type_structures(&sty a, &sty b) -> bool {\n-    fn equal_ty(@t a, @t b) -> bool { ret Box.ptr_eq[t](a, b); }\n+    fn equal_ty(t a, t b) -> bool { ret Box.ptr_eq[raw_t](a, b); }\n \n     fn equal_proto(ast.proto a, ast.proto b) -> bool {\n         alt (a) {\n@@ -972,8 +973,8 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n         ret equal_mut(a.mut, b.mut) && equal_ty(a.ty, b.ty);\n     }\n \n-    fn equal_fn(vec[arg] args_a, @t rty_a,\n-                vec[arg] args_b, @t rty_b) -> bool {\n+    fn equal_fn(vec[arg] args_a, t rty_a,\n+                vec[arg] args_b, t rty_b) -> bool {\n         if (!equal_ty(rty_a, rty_b)) { ret false; }\n \n         auto len = _vec.len[arg](args_a);\n@@ -1050,8 +1051,8 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n                 case (ty_tag(?id_b, ?tys_b)) {\n                     if (!equal_def(id_a, id_b)) { ret false; }\n \n-                    auto len = _vec.len[@ty.t](tys_a);\n-                    if (len != _vec.len[@ty.t](tys_b)) { ret false; }\n+                    auto len = _vec.len[t](tys_a);\n+                    if (len != _vec.len[t](tys_b)) { ret false; }\n                     auto i = 0u;\n                     while (i < len) {\n                         if (!equal_ty(tys_a.(i), tys_b.(i))) { ret false; }\n@@ -1206,7 +1207,7 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n \n // An expensive type equality function. This function is private to this\n // module.\n-fn eq_ty_full(&@t a, &@t b) -> bool {\n+fn eq_ty_full(&t a, &t b) -> bool {\n     // Check hashes (fast path).\n     if (a.hash != b.hash) {\n         ret false;\n@@ -1236,10 +1237,10 @@ fn eq_ty_full(&@t a, &@t b) -> bool {\n \n // This is the equality function the public should use. It works as long as\n // the types are interned.\n-fn eq_ty(&@t a, &@t b) -> bool { ret Box.ptr_eq[t](a, b); }\n+fn eq_ty(&t a, &t b) -> bool { ret Box.ptr_eq[raw_t](a, b); }\n \n \n-fn ann_to_type(&ast.ann ann) -> @t {\n+fn ann_to_type(&ast.ann ann) -> t {\n     alt (ann) {\n         case (ast.ann_none) {\n             log_err \"ann_to_type() called on node with no type\";\n@@ -1251,27 +1252,27 @@ fn ann_to_type(&ast.ann ann) -> @t {\n     }\n }\n \n-fn ann_to_type_params(&ast.ann ann) -> vec[@t] {\n+fn ann_to_type_params(&ast.ann ann) -> vec[t] {\n     alt (ann) {\n         case (ast.ann_none) {\n             log_err \"ann_to_type_params() called on node with no type params\";\n             fail;\n         }\n         case (ast.ann_type(_, ?tps, _)) {\n             alt (tps) {\n-                case (none[vec[@ty.t]]) {\n-                    let vec[@t] result = vec();\n+                case (none[vec[t]]) {\n+                    let vec[t] result = vec();\n                     ret result;\n                 }\n-                case (some[vec[@ty.t]](?tps)) { ret tps; }\n+                case (some[vec[t]](?tps)) { ret tps; }\n             }\n         }\n     }\n }\n \n // Returns the type of an annotation, with type parameter substitutions\n // performed if applicable.\n-fn ann_to_monotype(@type_store tystore, ast.ann a) -> @ty.t {\n+fn ann_to_monotype(@type_store tystore, ast.ann a) -> t {\n     // TODO: Refactor to use recursive pattern matching when we're more\n     // confident that it works.\n     alt (a) {\n@@ -1281,8 +1282,8 @@ fn ann_to_monotype(@type_store tystore, ast.ann a) -> @ty.t {\n         }\n         case (ast.ann_type(?typ, ?tps_opt, _)) {\n             alt (tps_opt) {\n-                case (none[vec[@ty.t]]) { ret typ; }\n-                case (some[vec[@ty.t]](?tps)) {\n+                case (none[vec[t]]) { ret typ; }\n+                case (some[vec[t]](?tps)) {\n                     ret substitute_type_params(tystore, tps, typ);\n                 }\n             }\n@@ -1291,13 +1292,13 @@ fn ann_to_monotype(@type_store tystore, ast.ann a) -> @ty.t {\n }\n \n // Turns a type into an ann_type, using defaults for other fields.\n-fn triv_ann(@ty.t typ) -> ast.ann {\n-    ret ast.ann_type(typ, none[vec[@ty.t]], none[@ts_ann]);\n+fn triv_ann(t typ) -> ast.ann {\n+    ret ast.ann_type(typ, none[vec[t]], none[@ts_ann]);\n }\n \n // Returns the number of distinct type parameters in the given type.\n-fn count_ty_params(@t ty) -> uint {\n-    fn counter(@mutable vec[uint] param_indices, @t ty) {\n+fn count_ty_params(t ty) -> uint {\n+    fn counter(@mutable vec[uint] param_indices, t ty) {\n         alt (struct(ty)) {\n             case (ty_param(?param_idx)) {\n                 auto seen = false;\n@@ -1321,8 +1322,8 @@ fn count_ty_params(@t ty) -> uint {\n     ret _vec.len[uint](*param_indices);\n }\n \n-fn type_contains_vars(@t typ) -> bool {\n-    fn checker(@mutable bool flag, @t typ) {\n+fn type_contains_vars(t typ) -> bool {\n+    fn checker(@mutable bool flag, t typ) {\n         alt (struct(typ)) {\n             case (ty_var(_)) { *flag = true; }\n             case (_) { /* fall through */ }\n@@ -1337,37 +1338,37 @@ fn type_contains_vars(@t typ) -> bool {\n \n // Type accessors for substructures of types\n \n-fn ty_fn_args(@t fty) -> vec[arg] {\n+fn ty_fn_args(t fty) -> vec[arg] {\n     alt (struct(fty)) {\n         case (ty.ty_fn(_, ?a, _)) { ret a; }\n         case (ty.ty_native_fn(_, ?a, _)) { ret a; }\n     }\n     fail;\n }\n \n-fn ty_fn_proto(@t fty) -> ast.proto {\n+fn ty_fn_proto(t fty) -> ast.proto {\n     alt (struct(fty)) {\n         case (ty.ty_fn(?p, _, _)) { ret p; }\n     }\n     fail;\n }\n \n-fn ty_fn_abi(@t fty) -> ast.native_abi {\n+fn ty_fn_abi(t fty) -> ast.native_abi {\n     alt (struct(fty)) {\n         case (ty.ty_native_fn(?a, _, _)) { ret a; }\n     }\n     fail;\n }\n \n-fn ty_fn_ret(@t fty) -> @t {\n+fn ty_fn_ret(t fty) -> t {\n     alt (struct(fty)) {\n         case (ty.ty_fn(_, _, ?r)) { ret r; }\n         case (ty.ty_native_fn(_, _, ?r)) { ret r; }\n     }\n     fail;\n }\n \n-fn is_fn_ty(@t fty) -> bool {\n+fn is_fn_ty(t fty) -> bool {\n     alt (struct(fty)) {\n         case (ty.ty_fn(_, _, _)) { ret true; }\n         case (ty.ty_native_fn(_, _, _)) { ret true; }\n@@ -1425,7 +1426,7 @@ fn item_ty(@ast.item it) -> ty_param_count_and_ty {\n     ret tup(ty_param_count, result_ty);\n }\n \n-fn stmt_ty(@type_store tystore, @ast.stmt s) -> @t {\n+fn stmt_ty(@type_store tystore, @ast.stmt s) -> t {\n     alt (s.node) {\n         case (ast.stmt_expr(?e,_)) {\n             ret expr_ty(tystore, e);\n@@ -1436,7 +1437,7 @@ fn stmt_ty(@type_store tystore, @ast.stmt s) -> @t {\n     }\n }\n \n-fn block_ty(@type_store tystore, &ast.block b) -> @t {\n+fn block_ty(@type_store tystore, &ast.block b) -> t {\n     alt (b.node.expr) {\n         case (some[@ast.expr](?e)) { ret expr_ty(tystore, e); }\n         case (none[@ast.expr])     { ret mk_nil(tystore); }\n@@ -1445,7 +1446,7 @@ fn block_ty(@type_store tystore, &ast.block b) -> @t {\n \n // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n // doesn't provide type parameter substitutions.\n-fn pat_ty(@type_store ts, @ast.pat pat) -> @t {\n+fn pat_ty(@type_store ts, @ast.pat pat) -> t {\n     alt (pat.node) {\n         case (ast.pat_wild(?ann))           { ret ann_to_monotype(ts, ann); }\n         case (ast.pat_lit(_, ?ann))         { ret ann_to_monotype(ts, ann); }\n@@ -1507,18 +1508,18 @@ fn expr_ann(@ast.expr expr) -> option.t[ast.ann] {\n // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&int) -> int\"\n // instead of \"fn(&T) -> T with T = int\". If this isn't what you want, see\n // expr_ty_params_and_ty() below.\n-fn expr_ty(@type_store tystore, @ast.expr expr) -> @t {\n+fn expr_ty(@type_store tystore, @ast.expr expr) -> t {\n     alt (expr_ann(expr)) {\n         case (none[ast.ann])     { ret mk_nil(tystore); }\n         case (some[ast.ann](?a)) { ret ann_to_monotype(tystore, a); }\n     }\n }\n \n fn expr_ty_params_and_ty(@type_store tystore, @ast.expr expr)\n-        -> tup(vec[@t], @t) {\n+        -> tup(vec[t], t) {\n     alt (expr_ann(expr)) {\n         case (none[ast.ann]) {\n-            let vec[@t] tps = vec();\n+            let vec[t] tps = vec();\n             ret tup(tps, mk_nil(tystore));\n         }\n         case (some[ast.ann](?a)) {\n@@ -1535,20 +1536,20 @@ fn expr_has_ty_params(@ast.expr expr) -> bool {\n             alt (a) {\n                 case (ast.ann_none) { fail; }\n                 case (ast.ann_type(_, ?tps_opt, _)) {\n-                    ret !option.is_none[vec[@t]](tps_opt);\n+                    ret !option.is_none[vec[t]](tps_opt);\n                 }\n             }\n         }\n     }\n }\n \n // FIXME: At the moment this works only for call, bind, and path expressions.\n-fn replace_expr_type(@ast.expr expr, tup(vec[@t], @t) new_tyt) -> @ast.expr {\n+fn replace_expr_type(@ast.expr expr, tup(vec[t], t) new_tyt) -> @ast.expr {\n     auto new_tps;\n     if (expr_has_ty_params(expr)) {\n-        new_tps = some[vec[@t]](new_tyt._0);\n+        new_tps = some[vec[t]](new_tyt._0);\n     } else {\n-        new_tps = none[vec[@t]];\n+        new_tps = none[vec[t]];\n     }\n \n     auto ann = ast.ann_type(new_tyt._1, new_tps, none[@ts_ann]);\n@@ -1662,13 +1663,13 @@ fn is_lval(@ast.expr expr) -> bool {\n \n mod Unify {\n     tag result {\n-        ures_ok(@ty.t);\n-        ures_err(type_err, @ty.t, @ty.t);\n+        ures_ok(t);\n+        ures_err(type_err, t, t);\n     }\n \n     type ctxt = rec(UFind.ufind sets,\n                     hashmap[int,uint] var_ids,\n-                    mutable vec[mutable vec[@t]] types,\n+                    mutable vec[mutable vec[t]] types,\n                     unify_handler handler,\n                     @type_store tystore);\n \n@@ -1680,7 +1681,7 @@ mod Unify {\n     // something we'll probably need to develop over time.\n \n     // Simple structural type comparison.\n-    fn struct_cmp(@ty.t expected, @ty.t actual) -> result {\n+    fn struct_cmp(t expected, t actual) -> result {\n         if (struct(expected) == struct(actual)) {\n             ret ures_ok(expected);\n         }\n@@ -1705,14 +1706,14 @@ mod Unify {\n \n     tag fn_common_res {\n         fn_common_res_err(result);\n-        fn_common_res_ok(vec[arg], @t);\n+        fn_common_res_ok(vec[arg], t);\n     }\n \n     fn unify_fn_common(@ctxt cx,\n-                       @ty.t expected,\n-                       @ty.t actual,\n-                       vec[arg] expected_inputs, @t expected_output,\n-                       vec[arg] actual_inputs, @t actual_output)\n+                       t expected,\n+                       t actual,\n+                       vec[arg] expected_inputs, t expected_output,\n+                       vec[arg] actual_inputs, t actual_output)\n         -> fn_common_res {\n         auto expected_len = _vec.len[arg](expected_inputs);\n         auto actual_len = _vec.len[arg](actual_inputs);\n@@ -1768,10 +1769,10 @@ mod Unify {\n     fn unify_fn(@ctxt cx,\n                 ast.proto e_proto,\n                 ast.proto a_proto,\n-                @ty.t expected,\n-                @ty.t actual,\n-                vec[arg] expected_inputs, @t expected_output,\n-                vec[arg] actual_inputs, @t actual_output)\n+                t expected,\n+                t actual,\n+                vec[arg] expected_inputs, t expected_output,\n+                vec[arg] actual_inputs, t actual_output)\n         -> result {\n \n         if (e_proto != a_proto) {\n@@ -1794,10 +1795,10 @@ mod Unify {\n     fn unify_native_fn(@ctxt cx,\n                        ast.native_abi e_abi,\n                        ast.native_abi a_abi,\n-                       @ty.t expected,\n-                       @ty.t actual,\n-                       vec[arg] expected_inputs, @t expected_output,\n-                       vec[arg] actual_inputs, @t actual_output)\n+                       t expected,\n+                       t actual,\n+                       vec[arg] expected_inputs, t expected_output,\n+                       vec[arg] actual_inputs, t actual_output)\n         -> result {\n         if (e_abi != a_abi) {\n             ret ures_err(terr_mismatch, expected, actual);\n@@ -1819,8 +1820,8 @@ mod Unify {\n     }\n \n     fn unify_obj(@ctxt cx,\n-                 @ty.t expected,\n-                 @ty.t actual,\n+                 t expected,\n+                 t actual,\n                  vec[method] expected_meths,\n                  vec[method] actual_meths) -> result {\n       let vec[method] result_meths = vec();\n@@ -1876,7 +1877,7 @@ mod Unify {\n         ret set_num;\n     }\n \n-    fn unify_step(@ctxt cx, @ty.t expected, @ty.t actual) -> result {\n+    fn unify_step(@ctxt cx, t expected, t actual) -> result {\n         // TODO: rewrite this using tuple pattern matching when available, to\n         // avoid all this rightward drift and spikiness.\n \n@@ -1899,7 +1900,7 @@ mod Unify {\n \n                     case (_) {\n                         // Just bind the type variable to the expected type.\n-                        auto vlen = _vec.len[mutable vec[@t]](cx.types);\n+                        auto vlen = _vec.len[mutable vec[t]](cx.types);\n                         if (actual_n < vlen) {\n                             cx.types.(actual_n) += vec(expected);\n                         } else {\n@@ -1913,8 +1914,8 @@ mod Unify {\n             case (ty.ty_local(?actual_id)) {\n                 auto result_ty;\n                 alt (cx.handler.resolve_local(actual_id)) {\n-                    case (none[@ty.t]) { result_ty = expected; }\n-                    case (some[@ty.t](?actual_ty)) {\n+                    case (none[t]) { result_ty = expected; }\n+                    case (some[t](?actual_ty)) {\n                         auto result = unify_step(cx, expected, actual_ty);\n                         alt (result) {\n                             case (ures_ok(?rty)) { result_ty = rty; }\n@@ -1964,9 +1965,9 @@ mod Unify {\n \n                         // TODO: factor this cruft out, see the TODO in the\n                         // ty.ty_tup case\n-                        let vec[@ty.t] result_tps = vec();\n+                        let vec[t] result_tps = vec();\n                         auto i = 0u;\n-                        auto expected_len = _vec.len[@ty.t](expected_tps);\n+                        auto expected_len = _vec.len[t](expected_tps);\n                         while (i < expected_len) {\n                             auto expected_tp = expected_tps.(i);\n                             auto actual_tp = actual_tps.(i);\n@@ -1977,7 +1978,7 @@ mod Unify {\n \n                             alt (result) {\n                                 case (ures_ok(?rty)) {\n-                                    _vec.push[@ty.t](result_tps, rty);\n+                                    _vec.push[t](result_tps, rty);\n                                 }\n                                 case (_) {\n                                     ret result;\n@@ -2268,7 +2269,7 @@ mod Unify {\n             case (ty.ty_var(?expected_id)) {\n                 // Add a binding.\n                 auto expected_n = get_or_create_set(cx, expected_id);\n-                auto vlen = _vec.len[mutable vec[@t]](cx.types);\n+                auto vlen = _vec.len[mutable vec[t]](cx.types);\n                 if (expected_n < vlen) {\n                     cx.types.(expected_n) += vec(actual);\n                 } else {\n@@ -2281,8 +2282,8 @@ mod Unify {\n             case (ty.ty_local(?expected_id)) {\n                 auto result_ty;\n                 alt (cx.handler.resolve_local(expected_id)) {\n-                    case (none[@ty.t]) { result_ty = actual; }\n-                    case (some[@ty.t](?expected_ty)) {\n+                    case (none[t]) { result_ty = actual; }\n+                    case (some[t](?expected_ty)) {\n                         auto result = unify_step(cx, expected_ty, actual);\n                         alt (result) {\n                             case (ures_ok(?rty)) { result_ty = rty; }\n@@ -2305,8 +2306,8 @@ mod Unify {\n     }\n \n     // Performs type binding substitution.\n-    fn substitute(@ctxt cx, vec[@t] set_types, @t typ) -> @t {\n-        fn substituter(@ctxt cx, vec[@t] types, @t typ) -> @t {\n+    fn substitute(@ctxt cx, vec[t] set_types, t typ) -> t {\n+        fn substituter(@ctxt cx, vec[t] types, t typ) -> t {\n             alt (struct(typ)) {\n                 case (ty_var(?id)) {\n                     alt (cx.var_ids.find(id)) {\n@@ -2325,26 +2326,26 @@ mod Unify {\n         ret fold_ty(cx.tystore, f, typ);\n     }\n \n-    fn unify_sets(@ctxt cx) -> vec[@t] {\n-        let vec[@t] throwaway = vec();\n-        let vec[mutable vec[@t]] set_types = vec(mutable throwaway);\n-        _vec.pop[mutable vec[@t]](set_types);   // FIXME: botch\n+    fn unify_sets(@ctxt cx) -> vec[t] {\n+        let vec[t] throwaway = vec();\n+        let vec[mutable vec[t]] set_types = vec(mutable throwaway);\n+        _vec.pop[mutable vec[t]](set_types);   // FIXME: botch\n \n         for (UFind.node node in cx.sets.nodes) {\n-            let vec[@t] v = vec();\n+            let vec[t] v = vec();\n             set_types += vec(mutable v);\n         }\n \n         auto i = 0u;\n-        while (i < _vec.len[mutable vec[@t]](set_types)) {\n+        while (i < _vec.len[mutable vec[t]](set_types)) {\n             auto root = UFind.find(cx.sets, i);\n             set_types.(root) += cx.types.(i);\n             i += 1u;\n         }\n \n-        let vec[@t] result = vec();\n-        for (vec[@t] types in set_types) {\n-            if (_vec.len[@t](types) > 1u) {\n+        let vec[t] result = vec();\n+        for (vec[t] types in set_types) {\n+            if (_vec.len[t](types) > 1u) {\n                 log_err \"unification of > 1 types in a type set is \" +\n                     \"unimplemented\";\n                 fail;\n@@ -2355,13 +2356,13 @@ mod Unify {\n         ret result;\n     }\n \n-    fn unify(@ty.t expected,\n-             @ty.t actual,\n+    fn unify(t expected,\n+             t actual,\n              &unify_handler handler,\n              @type_store tystore) -> result {\n-        let vec[@t] throwaway = vec();\n-        let vec[mutable vec[@t]] types = vec(mutable throwaway);\n-        _vec.pop[mutable vec[@t]](types);   // FIXME: botch\n+        let vec[t] throwaway = vec();\n+        let vec[mutable vec[t]] types = vec(mutable throwaway);\n+        _vec.pop[mutable vec[t]](types);   // FIXME: botch\n \n         auto cx = @rec(sets=UFind.make(),\n                        var_ids=common.new_int_hash[uint](),\n@@ -2437,9 +2438,9 @@ fn type_err_to_str(&ty.type_err err) -> str {\n // Performs bound type parameter replacement using the supplied mapping from\n // parameter IDs to types.\n fn substitute_type_params(@type_store tystore,\n-                          vec[@t] bindings,\n-                          @t typ) -> @t {\n-    fn replacer(vec[@t] bindings, @t typ) -> @t {\n+                          vec[t] bindings,\n+                          t typ) -> t {\n+    fn replacer(vec[t] bindings, t typ) -> t {\n         alt (struct(typ)) {\n             case (ty_bound_param(?param_index)) {\n                 ret bindings.(param_index);\n@@ -2453,8 +2454,8 @@ fn substitute_type_params(@type_store tystore,\n }\n \n // Converts type parameters in a type to bound type parameters.\n-fn bind_params_in_type(@type_store tystore, @t typ) -> @t {\n-    fn binder(@type_store tystore, @t typ) -> @t {\n+fn bind_params_in_type(@type_store tystore, t typ) -> t {\n+    fn binder(@type_store tystore, t typ) -> t {\n         alt (struct(typ)) {\n             case (ty_bound_param(?index)) {\n                 log_err \"bind_params_in_type() called on type that already \" +"}, {"sha": "b6729989845bc8fab423b771194e4f28dc0197fb", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 86, "deletions": 86, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/c7473c8260cbe6892eeed82f275bf09a73895e0e/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7473c8260cbe6892eeed82f275bf09a73895e0e/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=c7473c8260cbe6892eeed82f275bf09a73895e0e", "patch": "@@ -43,7 +43,7 @@ import pretty.pprust;\n \n import util.typestate_ann.ts_ann;\n \n-type ty_table = hashmap[ast.def_id, @ty.t];\n+type ty_table = hashmap[ast.def_id, ty.t];\n \n tag any_item {\n     any_item_rust(@ast.item);\n@@ -52,7 +52,7 @@ tag any_item {\n \n type ty_item_table = hashmap[ast.def_id,any_item];\n \n-type unify_cache_entry = tup(@ty.t,@ty.t,vec[mutable @ty.t]);\n+type unify_cache_entry = tup(ty.t,ty.t,vec[mutable ty.t]);\n type unify_cache = hashmap[unify_cache_entry,ty.Unify.result];\n \n type crate_ctxt = rec(session.session sess,\n@@ -66,7 +66,7 @@ type crate_ctxt = rec(session.session sess,\n                       mutable uint cache_misses,\n                       @ty.type_store tystore);\n \n-type fn_ctxt = rec(@ty.t ret_ty,\n+type fn_ctxt = rec(ty.t ret_ty,\n                    @ty_table locals,\n                    @crate_ctxt ccx);\n \n@@ -76,18 +76,18 @@ type ty_getter = fn(ast.def_id) -> ty.ty_param_count_and_ty;\n // Substitutes the user's explicit types for the parameters in a path\n // expression.\n fn substitute_ty_params(&@crate_ctxt ccx,\n-                        @ty.t typ,\n+                        ty.t typ,\n                         uint ty_param_count,\n-                        vec[@ty.t] supplied,\n-                        &span sp) -> @ty.t {\n-    fn substituter(@crate_ctxt ccx, vec[@ty.t] supplied, @ty.t typ) -> @ty.t {\n+                        vec[ty.t] supplied,\n+                        &span sp) -> ty.t {\n+    fn substituter(@crate_ctxt ccx, vec[ty.t] supplied, ty.t typ) -> ty.t {\n         alt (struct(typ)) {\n             case (ty.ty_bound_param(?pid)) { ret supplied.(pid); }\n             case (_) { ret typ; }\n         }\n     }\n \n-    auto supplied_len = _vec.len[@ty.t](supplied);\n+    auto supplied_len = _vec.len[ty.t](supplied);\n     if (ty_param_count != supplied_len) {\n         ccx.sess.span_err(sp, \"expected \" +\n                           _uint.to_str(ty_param_count, 10u) +\n@@ -112,8 +112,8 @@ fn ty_param_count_and_ty_for_def(@fn_ctxt fcx, &ast.def defn)\n         case (ast.def_local(?id)) {\n             auto t;\n             alt (fcx.locals.find(id)) {\n-                case (some[@ty.t](?t1)) { t = t1; }\n-                case (none[@ty.t]) { t = ty.mk_local(fcx.ccx.tystore, id); }\n+                case (some[ty.t](?t1)) { t = t1; }\n+                case (none[ty.t]) { t = ty.mk_local(fcx.ccx.tystore, id); }\n             }\n             ret tup(0u, t);\n         }\n@@ -175,13 +175,13 @@ fn instantiate_path(@fn_ctxt fcx, &ast.path pth, &ty_param_count_and_ty tpt,\n     auto ty_substs_opt;\n     auto ty_substs_len = _vec.len[@ast.ty](pth.node.types);\n     if (ty_substs_len > 0u) {\n-        let vec[@ty.t] ty_substs = vec();\n+        let vec[ty.t] ty_substs = vec();\n         auto i = 0u;\n         while (i < ty_substs_len) {\n             ty_substs += vec(ast_ty_to_ty_crate(fcx.ccx, pth.node.types.(i)));\n             i += 1u;\n         }\n-        ty_substs_opt = some[vec[@ty.t]](ty_substs);\n+        ty_substs_opt = some[vec[ty.t]](ty_substs);\n \n         if (ty_param_count == 0u) {\n             fcx.ccx.sess.span_err(sp, \"this item does not take type \" +\n@@ -190,13 +190,13 @@ fn instantiate_path(@fn_ctxt fcx, &ast.path pth, &ty_param_count_and_ty tpt,\n         }\n     } else {\n         // We will acquire the type parameters through unification.\n-        let vec[@ty.t] ty_substs = vec();\n+        let vec[ty.t] ty_substs = vec();\n         auto i = 0u;\n         while (i < ty_param_count) {\n             ty_substs += vec(next_ty_var(fcx.ccx));\n             i += 1u;\n         }\n-        ty_substs_opt = some[vec[@ty.t]](ty_substs);\n+        ty_substs_opt = some[vec[ty.t]](ty_substs);\n     }\n \n     ret ast.ann_type(t, ty_substs_opt, none[@ts_ann]);\n@@ -207,11 +207,11 @@ fn instantiate_path(@fn_ctxt fcx, &ast.path pth, &ty_param_count_and_ty tpt,\n // corresponding to a definition ID.\n fn ast_ty_to_ty(@ty.type_store tystore,\n                 ty_getter getter,\n-                &@ast.ty ast_ty) -> @ty.t {\n+                &@ast.ty ast_ty) -> ty.t {\n     fn ast_arg_to_arg(@ty.type_store tystore,\n                       ty_getter getter,\n                       &rec(ast.mode mode, @ast.ty ty) arg)\n-            -> rec(ast.mode mode, @ty.t ty) {\n+            -> rec(ast.mode mode, ty.t ty) {\n         ret rec(mode=arg.mode, ty=ast_ty_to_ty(tystore, getter, arg.ty));\n     }\n \n@@ -224,7 +224,7 @@ fn ast_ty_to_ty(@ty.type_store tystore,\n     fn instantiate(@ty.type_store tystore,\n                    ty_getter getter,\n                    ast.def_id id,\n-                   vec[@ast.ty] args) -> @ty.t {\n+                   vec[@ast.ty] args) -> ty.t {\n         // TODO: maybe record cname chains so we can do\n         // \"foo = int\" like OCaml?\n         auto params_opt_and_ty = getter(id);\n@@ -238,7 +238,7 @@ fn ast_ty_to_ty(@ty.type_store tystore,\n         // TODO: Make sure the number of supplied bindings matches the number\n         // of type parameters in the typedef. Emit a friendly error otherwise.\n         auto bound_ty = bind_params_in_type(tystore, params_opt_and_ty._1);\n-        let vec[@ty.t] param_bindings = vec();\n+        let vec[ty.t] param_bindings = vec();\n         for (@ast.ty ast_ty in args) {\n             param_bindings += vec(ast_ty_to_ty(tystore, getter, ast_ty));\n         }\n@@ -340,7 +340,7 @@ fn ast_ty_to_ty(@ty.type_store tystore,\n \n // A convenience function to use a crate_ctxt to resolve names for\n // ast_ty_to_ty.\n-fn ast_ty_to_ty_crate(@crate_ctxt ccx, &@ast.ty ast_ty) -> @ty.t {\n+fn ast_ty_to_ty_crate(@crate_ctxt ccx, &@ast.ty ast_ty) -> ty.t {\n     fn getter(@crate_ctxt ccx, ast.def_id id) -> ty.ty_param_count_and_ty {\n         ret ty.lookup_item_type(ccx.sess, ccx.tystore, ccx.type_cache, id);\n     }\n@@ -368,7 +368,7 @@ mod Collect {\n     type env = rec(@ctxt cx, ast.native_abi abi);\n \n     fn ty_of_fn_decl(@ctxt cx,\n-                     fn(&@ast.ty ast_ty) -> @ty.t convert,\n+                     fn(&@ast.ty ast_ty) -> ty.t convert,\n                      fn(&ast.arg a) -> arg ty_of_arg,\n                      &ast.fn_decl decl,\n                      ast.proto proto,\n@@ -384,7 +384,7 @@ mod Collect {\n     }\n \n     fn ty_of_native_fn_decl(@ctxt cx,\n-                            fn(&@ast.ty ast_ty) -> @ty.t convert,\n+                            fn(&@ast.ty ast_ty) -> ty.t convert,\n                             fn(&ast.arg a) -> arg ty_of_arg,\n                             &ast.fn_decl decl,\n                             ast.native_abi abi,\n@@ -510,7 +510,7 @@ mod Collect {\n \n             case (ast.item_tag(_, _, ?tps, ?def_id, _)) {\n                 // Create a new generic polytype.\n-                let vec[@ty.t] subtys = vec();\n+                let vec[ty.t] subtys = vec();\n \n                 auto i = 0u;\n                 for (ast.ty_param tp in tps) {\n@@ -563,7 +563,7 @@ mod Collect {\n         let vec[ast.variant] result = vec();\n \n         // Create a set of parameter types shared among all the variants.\n-        let vec[@ty.t] ty_param_tys = vec();\n+        let vec[ty.t] ty_param_tys = vec();\n         auto i = 0u;\n         for (ast.ty_param tp in ty_params) {\n             ty_param_tys += vec(ty.mk_param(cx.tystore, i));\n@@ -686,7 +686,7 @@ mod Collect {\n         ret @fold.respan[ast.native_item_](sp, item);\n     }\n \n-    fn get_ctor_obj_methods(@ty.t t) -> vec[method] {\n+    fn get_ctor_obj_methods(ty.t t) -> vec[method] {\n         alt (struct(t)) {\n             case (ty.ty_fn(_,_,?tobj)) {\n                 alt (struct(tobj)) {\n@@ -735,7 +735,7 @@ mod Collect {\n         }\n         auto g = bind getter(e.cx, _);\n         for (ast.obj_field fld in ob.fields) {\n-            let @ty.t fty = ast_ty_to_ty(e.cx.tystore, g, fld.ty);\n+            let ty.t fty = ast_ty_to_ty(e.cx.tystore, g, fld.ty);\n             let ast.obj_field f = rec(ann=triv_ann(fty)\n                 with fld\n             );\n@@ -746,7 +746,7 @@ mod Collect {\n         alt (ob.dtor) {\n             case (some[@ast.method](?d)) {\n                 let vec[arg] inputs = vec();\n-                let @ty.t output = ty.mk_nil(e.cx.tystore);\n+                let ty.t output = ty.mk_nil(e.cx.tystore);\n                 auto dtor_tfn = ty.mk_fn(e.cx.tystore, ast.proto_fn, inputs,\n                                          output);\n                 auto d_ = rec(ann=triv_ann(dtor_tfn) with d.node);\n@@ -780,7 +780,7 @@ mod Collect {\n                                                 ty_params);\n         auto typ = e.cx.type_cache.get(id)._1;\n         auto item = ast.item_tag(i, variants_t, ty_params, id,\n-                                 ast.ann_type(typ, none[vec[@ty.t]],\n+                                 ast.ann_type(typ, none[vec[ty.t]],\n                                               none[@ts_ann]));\n         ret @fold.respan[ast.item_](sp, item);\n     }\n@@ -830,16 +830,16 @@ mod Collect {\n // Type unification\n \n mod Unify {\n-    fn simple(@fn_ctxt fcx, @ty.t expected, @ty.t actual) -> ty.Unify.result {\n+    fn simple(@fn_ctxt fcx, ty.t expected, ty.t actual) -> ty.Unify.result {\n         // FIXME: horrid botch\n-        let vec[mutable @ty.t] param_substs =\n+        let vec[mutable ty.t] param_substs =\n             vec(mutable ty.mk_nil(fcx.ccx.tystore));\n-        _vec.pop[mutable @ty.t](param_substs);\n+        _vec.pop[mutable ty.t](param_substs);\n         ret with_params(fcx, expected, actual, param_substs);\n     }\n \n-    fn with_params(@fn_ctxt fcx, @ty.t expected, @ty.t actual,\n-                   vec[mutable @ty.t] param_substs) -> ty.Unify.result {\n+    fn with_params(@fn_ctxt fcx, ty.t expected, ty.t actual,\n+                   vec[mutable ty.t] param_substs) -> ty.Unify.result {\n         auto cache_key = tup(expected, actual, param_substs);\n         if (fcx.ccx.unify_cache.contains_key(cache_key)) {\n             fcx.ccx.cache_hits += 1u;\n@@ -848,25 +848,25 @@ mod Unify {\n \n         fcx.ccx.cache_misses += 1u;\n \n-        obj unify_handler(@fn_ctxt fcx, vec[mutable @ty.t] param_substs) {\n-            fn resolve_local(ast.def_id id) -> option.t[@ty.t] {\n+        obj unify_handler(@fn_ctxt fcx, vec[mutable ty.t] param_substs) {\n+            fn resolve_local(ast.def_id id) -> option.t[ty.t] {\n                 alt (fcx.locals.find(id)) {\n-                    case (none[@ty.t]) { ret none[@ty.t]; }\n-                    case (some[@ty.t](?existing_type)) {\n+                    case (none[ty.t]) { ret none[ty.t]; }\n+                    case (some[ty.t](?existing_type)) {\n                         if (ty.type_contains_vars(existing_type)) {\n                             // Not fully resolved yet. The writeback phase\n                             // will mop up.\n-                            ret none[@ty.t];\n+                            ret none[ty.t];\n                         }\n-                        ret some[@ty.t](existing_type);\n+                        ret some[ty.t](existing_type);\n                     }\n                 }\n             }\n-            fn record_local(ast.def_id id, @ty.t new_type) {\n+            fn record_local(ast.def_id id, ty.t new_type) {\n                 auto unified_type;\n                 alt (fcx.locals.find(id)) {\n-                    case (none[@ty.t]) { unified_type = new_type; }\n-                    case (some[@ty.t](?old_type)) {\n+                    case (none[ty.t]) { unified_type = new_type; }\n+                    case (some[ty.t](?old_type)) {\n                         alt (with_params(fcx, old_type, new_type,\n                                          param_substs)) {\n                             case (ures_ok(?ut)) { unified_type = ut; }\n@@ -876,8 +876,8 @@ mod Unify {\n                 }\n \n                 // TODO: \"freeze\"\n-                let vec[@ty.t] param_substs_1 = vec();\n-                for (@ty.t subst in param_substs) {\n+                let vec[ty.t] param_substs_1 = vec();\n+                for (ty.t subst in param_substs) {\n                     param_substs_1 += vec(subst);\n                 }\n \n@@ -886,7 +886,7 @@ mod Unify {\n                                               unified_type);\n                 fcx.locals.insert(id, unified_type);\n             }\n-            fn record_param(uint index, @ty.t binding) -> ty.Unify.result {\n+            fn record_param(uint index, ty.t binding) -> ty.Unify.result {\n                 // Unify with the appropriate type in the parameter\n                 // substitution list.\n                 auto old_subst = param_substs.(index);\n@@ -921,7 +921,7 @@ tag autoderef_kind {\n     NO_AUTODEREF;\n }\n \n-fn strip_boxes(@ty.t t) -> @ty.t {\n+fn strip_boxes(ty.t t) -> ty.t {\n     auto t1 = t;\n     while (true) {\n         alt (struct(t1)) {\n@@ -932,7 +932,7 @@ fn strip_boxes(@ty.t t) -> @ty.t {\n     fail;\n }\n \n-fn add_boxes(@crate_ctxt ccx, uint n, @ty.t t) -> @ty.t {\n+fn add_boxes(@crate_ctxt ccx, uint n, ty.t t) -> ty.t {\n     auto t1 = t;\n     while (n != 0u) {\n         t1 = ty.mk_imm_box(ccx.tystore, t1);\n@@ -942,7 +942,7 @@ fn add_boxes(@crate_ctxt ccx, uint n, @ty.t t) -> @ty.t {\n }\n \n \n-fn count_boxes(@ty.t t) -> uint {\n+fn count_boxes(ty.t t) -> uint {\n     auto n = 0u;\n     auto t1 = t;\n     while (true) {\n@@ -958,25 +958,25 @@ fn count_boxes(@ty.t t) -> uint {\n // Demands - procedures that require that two types unify and emit an error\n // message if they don't.\n \n-type ty_param_substs_and_ty = tup(vec[@ty.t], @ty.t);\n+type ty_param_substs_and_ty = tup(vec[ty.t], ty.t);\n \n mod Demand {\n-    fn simple(@fn_ctxt fcx, &span sp, @ty.t expected, @ty.t actual) -> @ty.t {\n-        let vec[@ty.t] tps = vec();\n+    fn simple(@fn_ctxt fcx, &span sp, ty.t expected, ty.t actual) -> ty.t {\n+        let vec[ty.t] tps = vec();\n         ret full(fcx, sp, expected, actual, tps, NO_AUTODEREF)._1;\n     }\n \n-    fn autoderef(@fn_ctxt fcx, &span sp, @ty.t expected, @ty.t actual,\n-                 autoderef_kind adk) -> @ty.t {\n-        let vec[@ty.t] tps = vec();\n+    fn autoderef(@fn_ctxt fcx, &span sp, ty.t expected, ty.t actual,\n+                 autoderef_kind adk) -> ty.t {\n+        let vec[ty.t] tps = vec();\n         ret full(fcx, sp, expected, actual, tps, adk)._1;\n     }\n \n     // Requires that the two types unify, and prints an error message if they\n     // don't. Returns the unified type and the type parameter substitutions.\n \n-    fn full(@fn_ctxt fcx, &span sp, @ty.t expected, @ty.t actual,\n-            vec[@ty.t] ty_param_substs_0, autoderef_kind adk)\n+    fn full(@fn_ctxt fcx, &span sp, ty.t expected, ty.t actual,\n+            vec[ty.t] ty_param_substs_0, autoderef_kind adk)\n             -> ty_param_substs_and_ty {\n \n         auto expected_1 = expected;\n@@ -989,18 +989,18 @@ mod Demand {\n             implicit_boxes = count_boxes(actual);\n         }\n \n-        let vec[mutable @ty.t] ty_param_substs =\n+        let vec[mutable ty.t] ty_param_substs =\n             vec(mutable ty.mk_nil(fcx.ccx.tystore));\n-        _vec.pop[mutable @ty.t](ty_param_substs);   // FIXME: horrid botch\n-        for (@ty.t ty_param_subst in ty_param_substs_0) {\n+        _vec.pop[mutable ty.t](ty_param_substs);   // FIXME: horrid botch\n+        for (ty.t ty_param_subst in ty_param_substs_0) {\n             ty_param_substs += vec(mutable ty_param_subst);\n         }\n \n         alt (Unify.with_params(fcx, expected_1, actual_1, ty_param_substs)) {\n             case (ures_ok(?t)) {\n                 // TODO: Use \"freeze\", when we have it.\n-                let vec[@ty.t] result_ty_param_substs = vec();\n-                for (mutable @ty.t ty_param_subst in ty_param_substs) {\n+                let vec[ty.t] result_ty_param_substs = vec();\n+                for (mutable ty.t ty_param_subst in ty_param_substs) {\n                     result_ty_param_substs += vec(ty_param_subst);\n                 }\n \n@@ -1024,7 +1024,7 @@ mod Demand {\n \n \n // Returns true if the two types unify and false if they don't.\n-fn are_compatible(&@fn_ctxt fcx, @ty.t expected, @ty.t actual) -> bool {\n+fn are_compatible(&@fn_ctxt fcx, ty.t expected, ty.t actual) -> bool {\n     alt (Unify.simple(fcx, expected, actual)) {\n         case (ures_ok(_))        { ret true;  }\n         case (ures_err(_, _, _)) { ret false; }\n@@ -1033,10 +1033,10 @@ fn are_compatible(&@fn_ctxt fcx, @ty.t expected, @ty.t actual) -> bool {\n \n // Returns the types of the arguments to a tag variant.\n fn variant_arg_types(@crate_ctxt ccx, &span sp, ast.def_id vid,\n-                     vec[@ty.t] tag_ty_params) -> vec[@ty.t] {\n-    auto ty_param_count = _vec.len[@ty.t](tag_ty_params);\n+                     vec[ty.t] tag_ty_params) -> vec[ty.t] {\n+    auto ty_param_count = _vec.len[ty.t](tag_ty_params);\n \n-    let vec[@ty.t] result = vec();\n+    let vec[ty.t] result = vec();\n \n     auto tpt = ty.lookup_item_type(ccx.sess, ccx.tystore, ccx.type_cache,\n                                    vid);\n@@ -1081,28 +1081,28 @@ mod Pushdown {\n     //\n     // TODO: enforce this via a predicate.\n \n-    fn pushdown_pat(&@fn_ctxt fcx, @ty.t expected, @ast.pat pat) -> @ast.pat {\n+    fn pushdown_pat(&@fn_ctxt fcx, ty.t expected, @ast.pat pat) -> @ast.pat {\n         auto p_1;\n \n         alt (pat.node) {\n             case (ast.pat_wild(?ann)) {\n                 auto t = Demand.simple(fcx, pat.span, expected,\n                                        ann_to_type(ann));\n-                p_1 = ast.pat_wild(ast.ann_type(t, none[vec[@ty.t]],\n+                p_1 = ast.pat_wild(ast.ann_type(t, none[vec[ty.t]],\n                                                 none[@ts_ann]));\n             }\n             case (ast.pat_lit(?lit, ?ann)) {\n                 auto t = Demand.simple(fcx, pat.span, expected,\n                                        ann_to_type(ann));\n-                p_1 = ast.pat_lit(lit, ast.ann_type(t, none[vec[@ty.t]],\n+                p_1 = ast.pat_lit(lit, ast.ann_type(t, none[vec[ty.t]],\n                                                     none[@ts_ann]));\n             }\n             case (ast.pat_bind(?id, ?did, ?ann)) {\n                 auto t = Demand.simple(fcx, pat.span, expected,\n                                        ann_to_type(ann));\n                 fcx.locals.insert(did, t);\n                 p_1 = ast.pat_bind(id, did, ast.ann_type(t,\n-                                                         none[vec[@ty.t]],\n+                                                         none[vec[ty.t]],\n                                                          none[@ts_ann]));\n             }\n             case (ast.pat_tag(?id, ?subpats, ?vdef_opt, ?ann)) {\n@@ -1143,12 +1143,12 @@ mod Pushdown {\n     // TODO: enforce this via a predicate.\n     // TODO: This function is incomplete.\n \n-    fn pushdown_expr(&@fn_ctxt fcx, @ty.t expected, @ast.expr e)\n+    fn pushdown_expr(&@fn_ctxt fcx, ty.t expected, @ast.expr e)\n             -> @ast.expr {\n         be pushdown_expr_full(fcx, expected, e, NO_AUTODEREF);\n     }\n \n-    fn pushdown_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n+    fn pushdown_expr_full(&@fn_ctxt fcx, ty.t expected, @ast.expr e,\n                           autoderef_kind adk) -> @ast.expr {\n         auto e_1;\n \n@@ -1374,11 +1374,11 @@ mod Pushdown {\n                     }\n                     case (ast.ann_type(_, ?tps_opt, _)) {\n                         alt (tps_opt) {\n-                            case (none[vec[@ty.t]]) {\n-                                ty_params_opt = none[vec[@ty.t]];\n+                            case (none[vec[ty.t]]) {\n+                                ty_params_opt = none[vec[ty.t]];\n                             }\n-                            case (some[vec[@ty.t]](?tps)) {\n-                                ty_params_opt = some[vec[@ty.t]](tps);\n+                            case (some[vec[ty.t]](?tps)) {\n+                                ty_params_opt = some[vec[ty.t]](tps);\n                             }\n                         }\n                     }\n@@ -1472,7 +1472,7 @@ mod Pushdown {\n     }\n \n     // Push-down over typed blocks.\n-    fn pushdown_block(&@fn_ctxt fcx, @ty.t expected, &ast.block bloc)\n+    fn pushdown_block(&@fn_ctxt fcx, ty.t expected, &ast.block bloc)\n             -> ast.block {\n         alt (bloc.node.expr) {\n             case (some[@ast.expr](?e_0)) {\n@@ -1514,7 +1514,7 @@ fn writeback_local(&option.t[@fn_ctxt] env, &span sp, @ast.local local)\n \n fn resolve_local_types_in_annotation(&option.t[@fn_ctxt] env, ast.ann ann)\n         -> ast.ann {\n-    fn resolver(@fn_ctxt fcx, @ty.t typ) -> @ty.t {\n+    fn resolver(@fn_ctxt fcx, ty.t typ) -> ty.t {\n         alt (struct(typ)) {\n             case (ty.ty_local(?lid)) { ret fcx.locals.get(lid); }\n             case (_)                 { ret typ; }\n@@ -1563,7 +1563,7 @@ fn resolve_local_types_in_block(&@fn_ctxt fcx, &ast.block block)\n \n // AST fragment checking\n \n-fn check_lit(@crate_ctxt ccx, @ast.lit lit) -> @ty.t {\n+fn check_lit(@crate_ctxt ccx, @ast.lit lit) -> ty.t {\n     alt (lit.node) {\n         case (ast.lit_str(_))           { ret ty.mk_str(ccx.tystore); }\n         case (ast.lit_char(_))          { ret ty.mk_char(ccx.tystore); }\n@@ -2218,7 +2218,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         case (ast.expr_self_method(?id, _)) {\n             auto t = ty.mk_nil(fcx.ccx.tystore);\n-            let @ty.t this_obj_ty;\n+            let ty.t this_obj_ty;\n \n             // Grab the type of the current object\n             auto this_obj_id = fcx.ccx.this_obj;\n@@ -2233,7 +2233,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             // Grab this method's type out of the current object type\n \n-            // this_obj_ty is an @ty.t\n+            // this_obj_ty is an ty.t\n             alt (struct(this_obj_ty)) {\n                 case (ty.ty_obj(?methods)) {\n                     for (ty.method method in methods) {\n@@ -2302,7 +2302,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         case (ast.expr_vec(?args, ?mut, _)) {\n             let vec[@ast.expr] args_1 = vec();\n \n-            let @ty.t t;\n+            let ty.t t;\n             if (_vec.len[@ast.expr](args) == 0u) {\n                 t = next_ty_var(fcx.ccx);\n             } else {\n@@ -2544,7 +2544,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n     }\n }\n \n-fn next_ty_var(@crate_ctxt ccx) -> @ty.t {\n+fn next_ty_var(@crate_ctxt ccx) -> ty.t {\n     auto t = ty.mk_var(ccx.tystore, ccx.next_var_id);\n     ccx.next_var_id += 1;\n     ret t;\n@@ -2667,7 +2667,7 @@ fn check_const(&@crate_ctxt ccx, &span sp, ast.ident ident, @ast.ty t,\n     // for checking the initializer expression.\n     auto rty = ann_to_type(ann);\n     let @fn_ctxt fcx = @rec(ret_ty = rty,\n-                            locals = @common.new_def_hash[@ty.t](),\n+                            locals = @common.new_def_hash[ty.t](),\n                             ccx = ccx);\n     auto e_ = check_expr(fcx, e);\n     // FIXME: necessary? Correct sequence?\n@@ -2678,7 +2678,7 @@ fn check_const(&@crate_ctxt ccx, &span sp, ast.ident ident, @ast.ty t,\n \n fn check_fn(&@crate_ctxt ccx, &ast.fn_decl decl, ast.proto proto,\n             &ast.block body) -> ast._fn {\n-    auto local_ty_table = @common.new_def_hash[@ty.t]();\n+    auto local_ty_table = @common.new_def_hash[ty.t]();\n \n     // FIXME: duplicate work: the item annotation already has the arg types\n     // and return type translated to typeck.ty values. We don't need do to it\n@@ -2752,7 +2752,7 @@ fn hash_unify_cache_entry(&unify_cache_entry uce) -> uint {\n     h += h << 5u + ty.hash_ty(uce._1);\n \n     auto i = 0u;\n-    auto tys_len = _vec.len[mutable @ty.t](uce._2);\n+    auto tys_len = _vec.len[mutable ty.t](uce._2);\n     while (i < tys_len) {\n         h += h << 5u + ty.hash_ty(uce._2.(i));\n         i += 1u;\n@@ -2765,8 +2765,8 @@ fn eq_unify_cache_entry(&unify_cache_entry a, &unify_cache_entry b) -> bool {\n     if (!ty.eq_ty(a._0, b._0) || !ty.eq_ty(a._1, b._1)) { ret false; }\n \n     auto i = 0u;\n-    auto tys_len = _vec.len[mutable @ty.t](a._2);\n-    if (_vec.len[mutable @ty.t](b._2) != tys_len) { ret false; }\n+    auto tys_len = _vec.len[mutable ty.t](a._2);\n+    if (_vec.len[mutable ty.t](b._2) != tys_len) { ret false; }\n \n     while (i < tys_len) {\n         if (!ty.eq_ty(a._2.(i), b._2.(i))) { ret false; }"}, {"sha": "0d0ca05da4bad86e6bd74e65c4ac5faeb417d985", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7473c8260cbe6892eeed82f275bf09a73895e0e/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7473c8260cbe6892eeed82f275bf09a73895e0e/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=c7473c8260cbe6892eeed82f275bf09a73895e0e", "patch": "@@ -112,7 +112,7 @@ fn field_exprs(vec[ast.field] fields) -> vec [@ast.expr] {\n \n fn plain_ann(@middle.ty.type_store tystore) -> ast.ann {\n   ret ast.ann_type(middle.ty.mk_nil(tystore),\n-                   none[vec[@middle.ty.t]], none[@ts_ann]);\n+                   none[vec[middle.ty.t]], none[@ts_ann]);\n }\n \n fn log_expr(&ast.expr e) -> () {"}]}