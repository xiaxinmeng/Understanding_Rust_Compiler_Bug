{"sha": "a90df393f9acb9633e0581711a3bc43f97bfe946", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5MGRmMzkzZjlhY2I5NjMzZTA1ODE3MTFhM2JjNDNmOTdiZmU5NDY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-17T18:45:49Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-17T18:45:49Z"}, "message": "Alias-ify the parser and lexer\n\nThis only shaves a measly 19k off the rustc binary... but hey, every\nlittle thing helps.", "tree": {"sha": "603b9f05452d144a631753dbecf91dcac5d8a807", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/603b9f05452d144a631753dbecf91dcac5d8a807"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a90df393f9acb9633e0581711a3bc43f97bfe946", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a90df393f9acb9633e0581711a3bc43f97bfe946", "html_url": "https://github.com/rust-lang/rust/commit/a90df393f9acb9633e0581711a3bc43f97bfe946", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a90df393f9acb9633e0581711a3bc43f97bfe946/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09d8ef8d51c4db16c477f2ae603cd50e457967b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/09d8ef8d51c4db16c477f2ae603cd50e457967b1", "html_url": "https://github.com/rust-lang/rust/commit/09d8ef8d51c4db16c477f2ae603cd50e457967b1"}], "stats": {"total": 244, "additions": 121, "deletions": 123}, "files": [{"sha": "b459c8e4792b3f3b73113c7d412aaf8beb6dd4e0", "filename": "src/comp/front/lexer.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a90df393f9acb9633e0581711a3bc43f97bfe946/src%2Fcomp%2Ffront%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a90df393f9acb9633e0581711a3bc43f97bfe946/src%2Fcomp%2Ffront%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Flexer.rs?ref=a90df393f9acb9633e0581711a3bc43f97bfe946", "patch": "@@ -155,14 +155,14 @@ fn is_whitespace(char c) -> bool {\n     ret c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n }\n \n-fn consume_any_whitespace(reader rdr) {\n+fn consume_any_whitespace(&reader rdr) {\n     while (is_whitespace(rdr.curr())) {\n         rdr.bump();\n     }\n     be consume_any_line_comment(rdr);\n }\n \n-fn consume_any_line_comment(reader rdr) {\n+fn consume_any_line_comment(&reader rdr) {\n     if (rdr.curr() == '/') {\n         alt (rdr.next()) {\n             case ('/') {\n@@ -185,7 +185,7 @@ fn consume_any_line_comment(reader rdr) {\n }\n \n \n-fn consume_block_comment(reader rdr) {\n+fn consume_block_comment(&reader rdr) {\n     let int level = 1;\n     while (level > 0) {\n         if (rdr.is_eof()) {\n@@ -223,7 +223,7 @@ fn digits_to_string(str s) -> int {\n     ret accum_int;\n }\n \n-fn scan_exponent(reader rdr) -> option::t[str] {\n+fn scan_exponent(&reader rdr) -> option::t[str] {\n     auto c = rdr.curr();\n     auto res = \"\";\n \n@@ -249,7 +249,7 @@ fn scan_exponent(reader rdr) -> option::t[str] {\n     }\n }\n \n-fn scan_dec_digits(reader rdr) -> str {\n+fn scan_dec_digits(&reader rdr) -> str {\n \n     auto c = rdr.curr();\n     let str res = \"\";\n@@ -265,7 +265,7 @@ fn scan_dec_digits(reader rdr) -> str {\n     ret res;\n }\n \n-fn scan_number(char c, reader rdr) -> token::token {\n+fn scan_number(char c, &reader rdr) -> token::token {\n     auto accum_int = 0;\n     let str dec_str = \"\";\n     let bool is_dec_integer = false;\n@@ -410,7 +410,7 @@ fn scan_number(char c, reader rdr) -> token::token {\n     }\n }\n \n-fn scan_numeric_escape(reader rdr) -> char {\n+fn scan_numeric_escape(&reader rdr) -> char {\n \n     auto n_hex_digits = 0;\n \n@@ -446,7 +446,7 @@ fn scan_numeric_escape(reader rdr) -> char {\n }\n \n \n-fn next_token(reader rdr) -> token::token {\n+fn next_token(&reader rdr) -> token::token {\n     auto accum_str = \"\";\n \n     consume_any_whitespace(rdr);\n@@ -476,7 +476,7 @@ fn next_token(reader rdr) -> token::token {\n         ret scan_number(c, rdr);\n     }\n \n-    fn binop(reader rdr, token::binop op) -> token::token {\n+    fn binop(&reader rdr, token::binop op) -> token::token {\n         rdr.bump();\n         if (rdr.curr() == '=') {\n             rdr.bump();\n@@ -739,7 +739,7 @@ tag cmnt_ {\n \n type cmnt = rec(cmnt_ val, uint pos, bool space_after);\n \n-fn consume_whitespace(reader rdr) -> uint {\n+fn consume_whitespace(&reader rdr) -> uint {\n     auto lines = 0u;\n     while (is_whitespace(rdr.curr())) {\n         if (rdr.curr() == '\\n') {lines += 1u;}\n@@ -748,7 +748,7 @@ fn consume_whitespace(reader rdr) -> uint {\n     ret lines;\n }\n \n-fn read_line_comment(reader rdr) -> cmnt {\n+fn read_line_comment(&reader rdr) -> cmnt {\n     auto p = rdr.get_chpos();\n     rdr.bump(); rdr.bump();\n     while (rdr.curr() == ' ') {rdr.bump();}\n@@ -762,7 +762,7 @@ fn read_line_comment(reader rdr) -> cmnt {\n             space_after=consume_whitespace(rdr) > 1u);\n }\n \n-fn read_block_comment(reader rdr) -> cmnt {\n+fn read_block_comment(&reader rdr) -> cmnt {\n     auto p = rdr.get_chpos();\n     rdr.bump(); rdr.bump();\n     while (rdr.curr() == ' ') {rdr.bump();}"}, {"sha": "1579598925035dc178ac2ad7ad2866e67841436d", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 109, "deletions": 111, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/a90df393f9acb9633e0581711a3bc43f97bfe946/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a90df393f9acb9633e0581711a3bc43f97bfe946/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=a90df393f9acb9633e0581711a3bc43f97bfe946", "patch": "@@ -215,13 +215,13 @@ fn bad_expr_word_table() -> std::map::hashmap[str, ()] {\n     ret words;\n }\n \n-fn unexpected(parser p, token::token t) {\n+fn unexpected(&parser p, token::token t) {\n     let str s = \"unexpected token: \";\n     s += token::to_str(p.get_reader(), t);\n     p.err(s);\n }\n \n-fn expect(parser p, token::token t) {\n+fn expect(&parser p, token::token t) {\n     if (p.peek() == t) {\n         p.bump();\n     } else {\n@@ -237,7 +237,7 @@ fn spanned[T](uint lo, uint hi, &T node) -> ast::spanned[T] {\n     ret rec(node=node, span=rec(lo=lo, hi=hi));\n }\n \n-fn parse_ident(parser p) -> ast::ident {\n+fn parse_ident(&parser p) -> ast::ident {\n     alt (p.peek()) {\n         case (token::IDENT(?i, _)) { p.bump(); ret p.get_str(i); }\n         case (_) {\n@@ -246,7 +246,7 @@ fn parse_ident(parser p) -> ast::ident {\n         }\n     }\n }\n-fn parse_value_ident(parser p) -> ast::ident {\n+fn parse_value_ident(&parser p) -> ast::ident {\n     check_bad_word(p);\n     ret parse_ident(p);\n }\n@@ -257,7 +257,7 @@ fn parse_value_ident(parser p) -> ast::ident {\n  * lexical sytnax-extension or something similar. For now we just imitate\n  * rustboot.\n  */\n-fn parse_str_lit_or_env_ident(parser p) -> ast::ident {\n+fn parse_str_lit_or_env_ident(&parser p) -> ast::ident {\n     alt (p.peek()) {\n         case (token::LIT_STR(?s)) { p.bump(); ret p.get_str(s); }\n         case (token::IDENT(?i, _)) {\n@@ -312,9 +312,9 @@ fn check_bad_word(&parser p) {\n     }\n }\n \n-fn parse_ty_fn(ast::proto proto, parser p, uint lo)\n+fn parse_ty_fn(ast::proto proto, &parser p, uint lo)\n     -> ast::ty_ {\n-    fn parse_fn_input_ty(parser p) -> rec(ast::mode mode, @ast::ty ty) {\n+    fn parse_fn_input_ty(&parser p) -> rec(ast::mode mode, @ast::ty ty) {\n         auto mode;\n         if (p.peek() == token::BINOP(token::AND)) {\n             p.bump();\n@@ -358,15 +358,15 @@ fn parse_ty_fn(ast::proto proto, parser p, uint lo)\n     ret ast::ty_fn(proto, inputs.node, output);\n }\n \n-fn parse_proto(parser p) -> ast::proto {\n+fn parse_proto(&parser p) -> ast::proto {\n     if      (eat_word(p, \"iter\")) { ret ast::proto_iter; }\n     else if (eat_word(p, \"fn\"))   { ret ast::proto_fn; }\n     else if (eat_word(p, \"pred\")) { ret ast::proto_fn; }\n     else                          { unexpected(p, p.peek()); }\n }\n \n-fn parse_ty_obj(parser p, &mutable uint hi) -> ast::ty_ {\n-    fn parse_method_sig(parser p) -> ast::ty_method {\n+fn parse_ty_obj(&parser p, &mutable uint hi) -> ast::ty_ {\n+    fn parse_method_sig(&parser p) -> ast::ty_method {\n         auto flo = p.get_lo_pos();\n \n         let ast::proto proto = parse_proto(p);\n@@ -382,28 +382,27 @@ fn parse_ty_obj(parser p, &mutable uint hi) -> ast::ty_ {\n         fail;\n     }\n     auto f = parse_method_sig;\n-    auto meths =\n-        parse_seq[ast::ty_method](token::LBRACE,\n-                                 token::RBRACE,\n-                                 none[token::token],\n-                                 f, p);\n+    auto meths = parse_seq(token::LBRACE,\n+                           token::RBRACE,\n+                           none[token::token],\n+                           f, p);\n     hi = meths.span.hi;\n     ret ast::ty_obj(meths.node);\n }\n \n-fn parse_mt(parser p) -> ast::mt {\n+fn parse_mt(&parser p) -> ast::mt {\n     auto mut = parse_mutability(p);\n     auto t = parse_ty(p);\n     ret rec(ty=t, mut=mut);\n }\n \n-fn parse_ty_field(parser p) -> ast::ty_field {\n+fn parse_ty_field(&parser p) -> ast::ty_field {\n     auto mt = parse_mt(p);\n     auto id = parse_ident(p);\n     ret rec(ident=id, mt=mt);\n }\n \n-fn parse_constr_arg(parser p) -> @ast::constr_arg {\n+fn parse_constr_arg(&parser p) -> @ast::constr_arg {\n     auto sp = p.get_span();\n     auto carg = ast::carg_base;\n     if (p.peek() == token::BINOP(token::STAR)) {\n@@ -414,7 +413,7 @@ fn parse_constr_arg(parser p) -> @ast::constr_arg {\n     ret @rec(node=carg, span=sp);\n }\n \n-fn parse_ty_constr(parser p) -> @ast::constr {\n+fn parse_ty_constr(&parser p) -> @ast::constr {\n     auto lo = p.get_lo_pos();\n     auto path = parse_path(p);\n     auto pf = parse_constr_arg;\n@@ -424,7 +423,7 @@ fn parse_ty_constr(parser p) -> @ast::constr {\n     ret @spanned(lo, args.span.hi, rec(path=path, args=args.node));\n }\n \n-fn parse_constrs(parser p) -> common::spanned[vec[@ast::constr]] {\n+fn parse_constrs(&parser p) -> common::spanned[vec[@ast::constr]] {\n     auto lo = p.get_lo_pos();\n     auto hi = p.get_hi_pos();\n     let vec[@ast::constr] constrs = [];\n@@ -444,7 +443,7 @@ fn parse_constrs(parser p) -> common::spanned[vec[@ast::constr]] {\n    ret spanned(lo, hi, constrs);\n }\n \n-fn parse_ty_constrs(@ast::ty t, parser p) -> @ast::ty {\n+fn parse_ty_constrs(@ast::ty t, &parser p) -> @ast::ty {\n    if (p.peek() == token::COLON) {\n        auto constrs = parse_constrs(p);\n        ret @spanned(t.span.lo, constrs.span.hi,\n@@ -453,14 +452,14 @@ fn parse_ty_constrs(@ast::ty t, parser p) -> @ast::ty {\n    ret t;\n }\n \n-fn parse_ty_or_bang(parser p) -> ty_or_bang {\n+fn parse_ty_or_bang(&parser p) -> ty_or_bang {\n     alt (p.peek()) {\n         case (token::NOT) { p.bump(); ret a_bang; }\n         case (_)         { ret a_ty(parse_ty(p)); }\n     }\n }\n \n-fn parse_ty(parser p) -> @ast::ty {\n+fn parse_ty(&parser p) -> @ast::ty {\n     auto lo = p.get_lo_pos();\n     auto hi = lo;\n     let ast::ty_ t;\n@@ -572,7 +571,7 @@ fn parse_ty(parser p) -> @ast::ty {\n     ret parse_ty_constrs(@spanned(lo, hi, t), p);\n }\n \n-fn parse_arg(parser p) -> ast::arg {\n+fn parse_arg(&parser p) -> ast::arg {\n     let ast::mode m = ast::val;\n     if (p.peek() == token::BINOP(token::AND)) {\n         m = ast::alias;\n@@ -587,10 +586,10 @@ fn parse_arg(parser p) -> ast::arg {\n }\n \n fn parse_seq_to_end[T](token::token ket,\n-                              option::t[token::token] sep,\n-                              (fn(parser) -> T) f,\n-                              uint hi,\n-                              parser p) -> vec[T] {\n+                       option::t[token::token] sep,\n+                       (fn(&parser) -> T) f,\n+                       uint hi,\n+                       &parser p) -> vec[T] {\n     let bool first = true;\n     let vec[T] v = [];\n     while (p.peek() != ket) {\n@@ -615,18 +614,18 @@ fn parse_seq_to_end[T](token::token ket,\n }\n \n fn parse_seq[T](token::token bra,\n-                       token::token ket,\n-                       option::t[token::token] sep,\n-                       (fn(parser) -> T) f,\n-                       parser p) -> util::common::spanned[vec[T]] {\n+                token::token ket,\n+                option::t[token::token] sep,\n+                (fn(&parser) -> T) f,\n+                &parser p) -> util::common::spanned[vec[T]] {\n     auto lo = p.get_lo_pos();\n     auto hi = p.get_hi_pos();\n     expect(p, bra);\n     auto result = parse_seq_to_end[T](ket, sep, f, hi, p);\n     ret spanned(lo, hi, result);\n }\n \n-fn parse_lit(parser p) -> ast::lit {\n+fn parse_lit(&parser p) -> ast::lit {\n     auto sp = p.get_span();\n     let ast::lit_ lit = ast::lit_nil;\n     if (eat_word(p, \"true\")) {\n@@ -679,7 +678,7 @@ fn is_ident(token::token t) -> bool {\n     ret false;\n }\n \n-fn parse_ty_args(parser p, uint hi) ->\n+fn parse_ty_args(&parser p, uint hi) ->\n     util::common::spanned[vec[@ast::ty]] {\n \n     if (p.peek() == token::LBRACKET) {\n@@ -694,7 +693,7 @@ fn parse_ty_args(parser p, uint hi) ->\n     ret spanned(hi, hi, v);\n }\n \n-fn parse_path(parser p) -> ast::path {\n+fn parse_path(&parser p) -> ast::path {\n \n     auto lo = p.get_lo_pos();\n     auto hi = lo;\n@@ -718,7 +717,7 @@ fn parse_path(parser p) -> ast::path {\n     ret spanned(lo, tys.span.hi, rec(idents=ids, types=tys.node));\n }\n \n-fn parse_mutability(parser p) -> ast::mutability {\n+fn parse_mutability(&parser p) -> ast::mutability {\n     if (eat_word(p, \"mutable\")) {\n         if (p.peek() == token::QUES) {\n             p.bump();\n@@ -729,15 +728,15 @@ fn parse_mutability(parser p) -> ast::mutability {\n     ret ast::imm;\n }\n \n-fn parse_field(parser p) -> ast::field {\n+fn parse_field(&parser p) -> ast::field {\n     auto m = parse_mutability(p);\n     auto i = parse_ident(p);\n     expect(p, token::EQ);\n     auto e = parse_expr(p);\n     ret rec(mut=m, ident=i, expr=e);\n }\n \n-fn parse_bottom_expr(parser p) -> @ast::expr {\n+fn parse_bottom_expr(&parser p) -> @ast::expr {\n \n     auto lo = p.get_lo_pos();\n     auto hi = p.get_hi_pos();\n@@ -764,7 +763,7 @@ fn parse_bottom_expr(parser p) -> @ast::expr {\n         expect(p, token::RPAREN);\n         ret @spanned(lo, hi, e.node);\n     } else if (eat_word(p, \"tup\")) {\n-        fn parse_elt(parser p) -> ast::elt {\n+        fn parse_elt(&parser p) -> ast::elt {\n             auto m = parse_mutability(p);\n             auto e = parse_expr(p);\n             ret rec(mut=m, expr=e);\n@@ -867,7 +866,7 @@ fn parse_bottom_expr(parser p) -> @ast::expr {\n         ex = ast::expr_rec(fields, base, p.get_ann());\n     } else if (eat_word(p, \"bind\")) {\n         auto e = parse_expr_res(p, RESTRICT_NO_CALL_EXPRS);\n-        fn parse_expr_opt(parser p) -> option::t[@ast::expr] {\n+        fn parse_expr_opt(&parser p) -> option::t[@ast::expr] {\n             alt (p.peek()) {\n                 case (token::UNDERSCORE) {\n                     p.bump();\n@@ -1000,7 +999,7 @@ fn parse_bottom_expr(parser p) -> @ast::expr {\n  * loading rust crates to process extensions.\n  */\n \n-fn expand_syntax_ext(parser p, ast::span sp,\n+fn expand_syntax_ext(&parser p, ast::span sp,\n                      &ast::path path, vec[@ast::expr] args,\n                      option::t[str] body) -> ast::expr_ {\n \n@@ -1026,14 +1025,14 @@ fn expand_syntax_ext(parser p, ast::span sp,\n     }\n }\n \n-fn parse_self_method(parser p) -> @ast::expr {\n+fn parse_self_method(&parser p) -> @ast::expr {\n     auto sp = p.get_span();\n     let ast::ident f_name = parse_ident(p);\n     auto hi = p.get_span();\n     ret @rec(node=ast::expr_self_method(f_name, p.get_ann()), span=sp);\n }\n \n-fn parse_dot_or_call_expr(parser p) -> @ast::expr {\n+fn parse_dot_or_call_expr(&parser p) -> @ast::expr {\n     auto lo = p.get_lo_pos();\n     auto e = parse_bottom_expr(p);\n     auto hi = e.span.hi;\n@@ -1090,7 +1089,7 @@ fn parse_dot_or_call_expr(parser p) -> @ast::expr {\n     ret e;\n }\n \n-fn parse_prefix_expr(parser p) -> @ast::expr {\n+fn parse_prefix_expr(&parser p) -> @ast::expr {\n \n     if (eat_word(p, \"mutable\")) {\n         p.get_session().span_warn(p.get_span(),\n@@ -1184,13 +1183,13 @@ fn prec_table() -> vec[op_spec] {\n             rec(tok=token::OROR, op=ast::or, prec=1)];\n }\n \n-fn parse_binops(parser p) -> @ast::expr {\n+fn parse_binops(&parser p) -> @ast::expr {\n     ret parse_more_binops(p, parse_prefix_expr(p), 0);\n }\n \n const int as_prec = 5;\n \n-fn parse_more_binops(parser p, @ast::expr lhs, int min_prec)\n+fn parse_more_binops(&parser p, @ast::expr lhs, int min_prec)\n     -> @ast::expr {\n     auto peeked = p.peek();\n     for (op_spec cur in p.get_prec_table()) {\n@@ -1213,7 +1212,7 @@ fn parse_more_binops(parser p, @ast::expr lhs, int min_prec)\n     ret lhs;\n }\n \n-fn parse_assign_expr(parser p) -> @ast::expr {\n+fn parse_assign_expr(&parser p) -> @ast::expr {\n     auto lo = p.get_lo_pos();\n     auto lhs = parse_binops(p);\n     alt (p.peek()) {\n@@ -1260,7 +1259,7 @@ fn parse_assign_expr(parser p) -> @ast::expr {\n     ret lhs;\n }\n \n-fn parse_if_expr(parser p) -> @ast::expr {\n+fn parse_if_expr(&parser p) -> @ast::expr {\n     auto lo = p.get_last_lo_pos();\n \n     expect(p, token::LPAREN);\n@@ -1278,7 +1277,7 @@ fn parse_if_expr(parser p) -> @ast::expr {\n     ret @spanned(lo, hi, ast::expr_if(cond, thn, els, p.get_ann()));\n }\n \n-fn parse_else_expr(parser p) -> @ast::expr {\n+fn parse_else_expr(&parser p) -> @ast::expr {\n     if (eat_word(p, \"if\")) {\n         ret parse_if_expr(p);\n     } else {\n@@ -1288,7 +1287,7 @@ fn parse_else_expr(parser p) -> @ast::expr {\n     }\n }\n \n-fn parse_head_local(parser p) -> @ast::decl {\n+fn parse_head_local(&parser p) -> @ast::decl {\n     auto lo = p.get_lo_pos();\n     let @ast::local local;\n     if (is_word(p, \"auto\")) {\n@@ -1301,7 +1300,7 @@ fn parse_head_local(parser p) -> @ast::decl {\n \n \n \n-fn parse_for_expr(parser p) -> @ast::expr {\n+fn parse_for_expr(&parser p) -> @ast::expr {\n     auto lo = p.get_last_lo_pos();\n \n     auto is_each = eat_word(p, \"each\");\n@@ -1325,7 +1324,7 @@ fn parse_for_expr(parser p) -> @ast::expr {\n }\n \n \n-fn parse_while_expr(parser p) -> @ast::expr {\n+fn parse_while_expr(&parser p) -> @ast::expr {\n     auto lo = p.get_last_lo_pos();\n     expect(p, token::LPAREN);\n     auto cond = parse_expr(p);\n@@ -1335,7 +1334,7 @@ fn parse_while_expr(parser p) -> @ast::expr {\n     ret @spanned(lo, hi, ast::expr_while(cond, body, p.get_ann()));\n }\n \n-fn parse_do_while_expr(parser p) -> @ast::expr {\n+fn parse_do_while_expr(&parser p) -> @ast::expr {\n     auto lo = p.get_last_lo_pos();\n     auto body = parse_block(p);\n     expect_word(p, \"while\");\n@@ -1346,7 +1345,7 @@ fn parse_do_while_expr(parser p) -> @ast::expr {\n     ret @spanned(lo, hi, ast::expr_do_while(body, cond, p.get_ann()));\n }\n \n-fn parse_alt_expr(parser p) -> @ast::expr {\n+fn parse_alt_expr(&parser p) -> @ast::expr {\n     auto lo = p.get_last_lo_pos();\n     expect(p, token::LPAREN);\n     auto discriminant = parse_expr(p);\n@@ -1375,7 +1374,7 @@ fn parse_alt_expr(parser p) -> @ast::expr {\n     ret @spanned(lo, hi, expr);\n }\n \n-fn parse_spawn_expr(parser p) -> @ast::expr {\n+fn parse_spawn_expr(&parser p) -> @ast::expr {\n     auto lo = p.get_last_lo_pos();\n     // FIXME: Parse domain and name\n     // FIXME: why no full expr?\n@@ -1394,19 +1393,19 @@ fn parse_spawn_expr(parser p) -> @ast::expr {\n     ret @spanned(lo, hi, spawn_expr);\n }\n \n-fn parse_expr(parser p) -> @ast::expr {\n+fn parse_expr(&parser p) -> @ast::expr {\n     ret parse_expr_res(p, UNRESTRICTED);\n }\n \n-fn parse_expr_res(parser p, restriction r) -> @ast::expr {\n+fn parse_expr_res(&parser p, restriction r) -> @ast::expr {\n     auto old = p.get_restriction();\n     p.restrict(r);\n     auto e = parse_expr_inner(p);\n     p.restrict(old);\n     ret e;\n }\n \n-fn parse_expr_inner(parser p) -> @ast::expr {\n+fn parse_expr_inner(&parser p) -> @ast::expr {\n     if (p.peek() == token::LBRACE) {\n         auto blk = parse_block(p);\n         ret @spanned(blk.span.lo, blk.span.hi,\n@@ -1428,7 +1427,7 @@ fn parse_expr_inner(parser p) -> @ast::expr {\n     }\n }\n \n-fn parse_initializer(parser p) -> option::t[ast::initializer] {\n+fn parse_initializer(&parser p) -> option::t[ast::initializer] {\n     alt (p.peek()) {\n         case (token::EQ) {\n             p.bump();\n@@ -1446,7 +1445,7 @@ fn parse_initializer(parser p) -> option::t[ast::initializer] {\n     }\n }\n \n-fn parse_pat(parser p) -> @ast::pat {\n+fn parse_pat(&parser p) -> @ast::pat {\n     auto lo = p.get_lo_pos();\n     auto hi = p.get_hi_pos();\n     auto pat;\n@@ -1503,7 +1502,7 @@ fn parse_pat(parser p) -> @ast::pat {\n }\n \n fn parse_local_full(&option::t[@ast::ty] tyopt,\n-                           parser p) -> @ast::local {\n+                    &parser p) -> @ast::local {\n     auto ident = parse_value_ident(p);\n     auto init = parse_initializer(p);\n     ret @rec(ty = tyopt,\n@@ -1514,42 +1513,42 @@ fn parse_local_full(&option::t[@ast::ty] tyopt,\n              ann = p.get_ann());\n }\n \n-fn parse_typed_local(parser p) -> @ast::local {\n+fn parse_typed_local(&parser p) -> @ast::local {\n     auto ty = parse_ty(p);\n     ret parse_local_full(some(ty), p);\n }\n \n-fn parse_auto_local(parser p) -> @ast::local {\n+fn parse_auto_local(&parser p) -> @ast::local {\n     ret parse_local_full(none[@ast::ty], p);\n }\n \n-fn parse_let(parser p) -> @ast::decl {\n+fn parse_let(&parser p) -> @ast::decl {\n     auto lo = p.get_last_lo_pos();\n     auto local = parse_typed_local(p);\n     ret @spanned(lo, p.get_hi_pos(), ast::decl_local(local));\n }\n \n-fn parse_auto(parser p) -> @ast::decl {\n+fn parse_auto(&parser p) -> @ast::decl {\n     auto lo = p.get_last_lo_pos();\n     auto local = parse_auto_local(p);\n     ret @spanned(lo, p.get_hi_pos(), ast::decl_local(local));\n }\n \n-fn parse_stmt(parser p) -> @ast::stmt {\n+fn parse_stmt(&parser p) -> @ast::stmt {\n     if (p.get_file_type() == SOURCE_FILE) {\n         ret parse_source_stmt(p);\n     } else {\n         ret parse_crate_stmt(p);\n     }\n }\n \n-fn parse_crate_stmt(parser p) -> @ast::stmt {\n+fn parse_crate_stmt(&parser p) -> @ast::stmt {\n     auto cdir = parse_crate_directive(p);\n     ret @spanned(cdir.span.lo, cdir.span.hi,\n                  ast::stmt_crate_directive(@cdir));\n }\n \n-fn parse_source_stmt(parser p) -> @ast::stmt {\n+fn parse_source_stmt(&parser p) -> @ast::stmt {\n     auto lo = p.get_lo_pos();\n     if (eat_word(p, \"let\")) {\n         auto decl = parse_let(p);\n@@ -1638,7 +1637,7 @@ fn stmt_ends_with_semi(@ast::stmt stmt) -> bool {\n     }\n }\n \n-fn parse_block(parser p) -> ast::block {\n+fn parse_block(&parser p) -> ast::block {\n     auto lo = p.get_lo_pos();\n \n     let vec[@ast::stmt] stmts = [];\n@@ -1699,11 +1698,11 @@ fn parse_block(parser p) -> ast::block {\n     ret spanned[ast::block_](lo, hi, bloc);\n }\n \n-fn parse_ty_param(parser p) -> ast::ty_param {\n+fn parse_ty_param(&parser p) -> ast::ty_param {\n     ret parse_ident(p);\n }\n \n-fn parse_ty_params(parser p) -> vec[ast::ty_param] {\n+fn parse_ty_params(&parser p) -> vec[ast::ty_param] {\n     let vec[ast::ty_param] ty_params = [];\n     if (p.peek() == token::LBRACKET) {\n         auto f = parse_ty_param;   // FIXME: pass as lval directly\n@@ -1713,7 +1712,7 @@ fn parse_ty_params(parser p) -> vec[ast::ty_param] {\n     ret ty_params;\n }\n \n-fn parse_fn_decl(parser p, ast::purity purity) -> ast::fn_decl {\n+fn parse_fn_decl(&parser p, ast::purity purity) -> ast::fn_decl {\n     auto pf = parse_arg;\n     let util::common::spanned[vec[ast::arg]] inputs =\n         // FIXME: passing parse_arg as an lval doesn't work at the\n@@ -1751,22 +1750,22 @@ fn parse_fn_decl(parser p, ast::purity purity) -> ast::fn_decl {\n     }\n }\n \n-fn parse_fn(parser p, ast::proto proto, ast::purity purity) -> ast::_fn {\n+fn parse_fn(&parser p, ast::proto proto, ast::purity purity) -> ast::_fn {\n     auto decl = parse_fn_decl(p, purity);\n     auto body = parse_block(p);\n     ret rec(decl = decl,\n             proto = proto,\n             body = body);\n }\n \n-fn parse_fn_header(parser p)\n+fn parse_fn_header(&parser p)\n     -> tup(ast::ident, vec[ast::ty_param]) {\n     auto id = parse_value_ident(p);\n     auto ty_params = parse_ty_params(p);\n     ret tup(id, ty_params);\n }\n \n-fn parse_item_fn_or_iter(parser p, ast::purity purity, ast::proto proto)\n+fn parse_item_fn_or_iter(&parser p, ast::purity purity, ast::proto proto)\n     -> @ast::item {\n     auto lo = p.get_last_lo_pos();\n     auto t = parse_fn_header(p);\n@@ -1777,14 +1776,14 @@ fn parse_item_fn_or_iter(parser p, ast::purity purity, ast::proto proto)\n }\n \n \n-fn parse_obj_field(parser p) -> ast::obj_field {\n+fn parse_obj_field(&parser p) -> ast::obj_field {\n     auto mut = parse_mutability(p); // TODO: store this, use it in typeck\n     auto ty = parse_ty(p);\n     auto ident = parse_value_ident(p);\n     ret rec(ty=ty, ident=ident, id=p.next_def_id(), ann=p.get_ann());\n }\n \n-fn parse_method(parser p) -> @ast::method {\n+fn parse_method(&parser p) -> @ast::method {\n     auto lo = p.get_lo_pos();\n     auto proto = parse_proto(p);\n     auto ident = parse_value_ident(p);\n@@ -1794,7 +1793,7 @@ fn parse_method(parser p) -> @ast::method {\n     ret @spanned(lo, f.body.span.hi, meth);\n }\n \n-fn parse_dtor(parser p) -> @ast::method {\n+fn parse_dtor(&parser p) -> @ast::method {\n     auto lo = p.get_last_lo_pos();\n     let ast::block b = parse_block(p);\n     let vec[ast::arg] inputs = [];\n@@ -1813,7 +1812,7 @@ fn parse_dtor(parser p) -> @ast::method {\n     ret @spanned(lo, f.body.span.hi, m);\n }\n \n-fn parse_item_obj(parser p, ast::layer lyr) -> @ast::item {\n+fn parse_item_obj(&parser p, ast::layer lyr) -> @ast::item {\n     auto lo = p.get_last_lo_pos();\n     auto ident = parse_value_ident(p);\n     auto ty_params = parse_ty_params(p);\n@@ -1850,7 +1849,7 @@ fn parse_item_obj(parser p, ast::layer lyr) -> @ast::item {\n     ret @spanned(lo, hi, item);\n }\n \n-fn parse_mod_items(parser p, token::token term) -> ast::_mod {\n+fn parse_mod_items(&parser p, token::token term) -> ast::_mod {\n     auto view_items = parse_view(p);\n     let vec[@ast::item] items = [];\n     while (p.peek() != term) {\n@@ -1859,7 +1858,7 @@ fn parse_mod_items(parser p, token::token term) -> ast::_mod {\n     ret rec(view_items=view_items, items=items);\n }\n \n-fn parse_item_const(parser p) -> @ast::item {\n+fn parse_item_const(&parser p) -> @ast::item {\n     auto lo = p.get_last_lo_pos();\n     auto ty = parse_ty(p);\n     auto id = parse_value_ident(p);\n@@ -1871,7 +1870,7 @@ fn parse_item_const(parser p) -> @ast::item {\n     ret @spanned(lo, hi, item);\n }\n \n-fn parse_item_mod(parser p) -> @ast::item {\n+fn parse_item_mod(&parser p) -> @ast::item {\n     auto lo = p.get_last_lo_pos();\n     auto id = parse_ident(p);\n     expect(p, token::LBRACE);\n@@ -1882,15 +1881,15 @@ fn parse_item_mod(parser p) -> @ast::item {\n     ret @spanned(lo, hi, item);\n }\n \n-fn parse_item_native_type(parser p) -> @ast::native_item {\n+fn parse_item_native_type(&parser p) -> @ast::native_item {\n     auto t = parse_type_decl(p);\n     auto hi = p.get_hi_pos();\n     expect(p, token::SEMI);\n     auto item = ast::native_item_ty(t._1, p.next_def_id());\n     ret @spanned(t._0, hi, item);\n }\n \n-fn parse_item_native_fn(parser p) -> @ast::native_item {\n+fn parse_item_native_fn(&parser p) -> @ast::native_item {\n     auto lo = p.get_last_lo_pos();\n     auto t = parse_fn_header(p);\n     auto decl = parse_fn_decl(p, ast::impure_fn);\n@@ -1907,7 +1906,7 @@ fn parse_item_native_fn(parser p) -> @ast::native_item {\n     ret @spanned(lo, hi, item);\n }\n \n-fn parse_native_item(parser p) -> @ast::native_item {\n+fn parse_native_item(&parser p) -> @ast::native_item {\n     let ast::layer lyr = parse_layer(p);\n     if (eat_word(p, \"type\")) {\n         ret parse_item_native_type(p);\n@@ -1919,9 +1918,8 @@ fn parse_native_item(parser p) -> @ast::native_item {\n     }\n }\n \n-fn parse_native_mod_items(parser p,\n-                                 str native_name,\n-                                 ast::native_abi abi) -> ast::native_mod {\n+fn parse_native_mod_items(&parser p, &str native_name,\n+                          ast::native_abi abi) -> ast::native_mod {\n     let vec[@ast::native_item] items = [];\n \n     auto view_items = parse_native_view(p);\n@@ -1948,7 +1946,7 @@ fn default_native_name(session::session sess, str id) -> str {\n     }\n }\n \n-fn parse_item_native_mod(parser p) -> @ast::item {\n+fn parse_item_native_mod(&parser p) -> @ast::item {\n     auto lo = p.get_last_lo_pos();\n     auto abi = ast::native_abi_cdecl;\n     if (!is_word(p, \"mod\")) {\n@@ -1982,13 +1980,13 @@ fn parse_item_native_mod(parser p) -> @ast::item {\n     ret @spanned(lo, hi, item);\n }\n \n-fn parse_type_decl(parser p) -> tup(uint, ast::ident) {\n+fn parse_type_decl(&parser p) -> tup(uint, ast::ident) {\n     auto lo = p.get_last_lo_pos();\n     auto id = parse_ident(p);\n     ret tup(lo, id);\n }\n \n-fn parse_item_type(parser p) -> @ast::item {\n+fn parse_item_type(&parser p) -> @ast::item {\n     auto t = parse_type_decl(p);\n     auto tps = parse_ty_params(p);\n \n@@ -2000,7 +1998,7 @@ fn parse_item_type(parser p) -> @ast::item {\n     ret @spanned(t._0, hi, item);\n }\n \n-fn parse_item_tag(parser p) -> @ast::item {\n+fn parse_item_tag(&parser p) -> @ast::item {\n     auto lo = p.get_last_lo_pos();\n     auto id = parse_ident(p);\n     auto ty_params = parse_ty_params(p);\n@@ -2054,7 +2052,7 @@ fn parse_item_tag(parser p) -> @ast::item {\n }\n \n \n-fn parse_layer(parser p) -> ast::layer {\n+fn parse_layer(&parser p) -> ast::layer {\n     if (eat_word(p, \"state\")) {\n         ret ast::layer_state;\n     } else if (eat_word(p, \"gc\")) {\n@@ -2066,7 +2064,7 @@ fn parse_layer(parser p) -> ast::layer {\n }\n \n \n-fn parse_auth(parser p) -> ast::_auth {\n+fn parse_auth(&parser p) -> ast::_auth {\n     if (eat_word(p, \"unsafe\")) {\n         ret ast::auth_unsafe;\n     } else {\n@@ -2075,7 +2073,7 @@ fn parse_auth(parser p) -> ast::_auth {\n     fail;\n }\n \n-fn peeking_at_item(parser p) -> bool {\n+fn peeking_at_item(&parser p) -> bool {\n     alt (p.peek()) {\n         case (token::IDENT(?sid, false)) {\n             auto st = p.get_str(sid);\n@@ -2094,7 +2092,7 @@ fn peeking_at_item(parser p) -> bool {\n     }\n }\n \n-fn parse_item(parser p) -> @ast::item {\n+fn parse_item(&parser p) -> @ast::item {\n     let ast::layer lyr = parse_layer(p);\n \n     if (eat_word(p, \"const\")) {\n@@ -2128,7 +2126,7 @@ fn parse_item(parser p) -> @ast::item {\n     fail;\n }\n \n-fn parse_meta_item(parser p) -> @ast::meta_item {\n+fn parse_meta_item(&parser p) -> @ast::meta_item {\n     auto lo = p.get_lo_pos();\n     auto ident = parse_ident(p);\n     expect(p, token::EQ);\n@@ -2146,13 +2144,13 @@ fn parse_meta_item(parser p) -> @ast::meta_item {\n     fail;\n }\n \n-fn parse_meta(parser p) -> vec[@ast::meta_item] {\n+fn parse_meta(&parser p) -> vec[@ast::meta_item] {\n     auto pf = parse_meta_item;\n     ret parse_seq[@ast::meta_item](token::LPAREN, token::RPAREN,\n                                    some(token::COMMA), pf, p).node;\n }\n \n-fn parse_optional_meta(parser p) -> vec[@ast::meta_item] {\n+fn parse_optional_meta(&parser p) -> vec[@ast::meta_item] {\n     alt (p.peek()) {\n         case (token::LPAREN) {\n             ret parse_meta(p);\n@@ -2164,7 +2162,7 @@ fn parse_optional_meta(parser p) -> vec[@ast::meta_item] {\n     }\n }\n \n-fn parse_use(parser p) -> @ast::view_item {\n+fn parse_use(&parser p) -> @ast::view_item {\n     auto lo = p.get_last_lo_pos();\n     auto ident = parse_ident(p);\n     auto metadata = parse_optional_meta(p);\n@@ -2175,7 +2173,7 @@ fn parse_use(parser p) -> @ast::view_item {\n     ret @spanned(lo, hi, use_decl);\n }\n \n-fn parse_rest_import_name(parser p, ast::ident first,\n+fn parse_rest_import_name(&parser p, ast::ident first,\n                                  option::t[ast::ident] def_ident)\n         -> @ast::view_item {\n     auto lo = p.get_lo_pos();\n@@ -2202,7 +2200,7 @@ fn parse_rest_import_name(parser p, ast::ident first,\n     ret @spanned(lo, hi, import_decl);\n }\n \n-fn parse_full_import_name(parser p, ast::ident def_ident)\n+fn parse_full_import_name(&parser p, ast::ident def_ident)\n        -> @ast::view_item {\n     alt (p.peek()) {\n         case (token::IDENT(?i, _)) {\n@@ -2216,7 +2214,7 @@ fn parse_full_import_name(parser p, ast::ident def_ident)\n     fail;\n }\n \n-fn parse_import(parser p) -> @ast::view_item {\n+fn parse_import(&parser p) -> @ast::view_item {\n     alt (p.peek()) {\n         case (token::IDENT(?i, _)) {\n             p.bump();\n@@ -2238,15 +2236,15 @@ fn parse_import(parser p) -> @ast::view_item {\n     fail;\n }\n \n-fn parse_export(parser p) -> @ast::view_item {\n+fn parse_export(&parser p) -> @ast::view_item {\n     auto lo = p.get_last_lo_pos();\n     auto id = parse_ident(p);\n     auto hi = p.get_hi_pos();\n     expect(p, token::SEMI);\n     ret @spanned(lo, hi, ast::view_item_export(id));\n }\n \n-fn parse_view_item(parser p) -> @ast::view_item {\n+fn parse_view_item(&parser p) -> @ast::view_item {\n     if (eat_word(p, \"use\")) {\n         ret parse_use(p);\n     } else if (eat_word(p, \"import\")) {\n@@ -2270,15 +2268,15 @@ fn is_view_item(&parser p) -> bool {\n     ret false;\n }\n \n-fn parse_view(parser p) -> vec[@ast::view_item] {\n+fn parse_view(&parser p) -> vec[@ast::view_item] {\n     let vec[@ast::view_item] items = [];\n     while (is_view_item(p)) {\n         items += [parse_view_item(p)];\n     }\n     ret items;\n }\n \n-fn parse_native_view(parser p) -> vec[@ast::view_item] {\n+fn parse_native_view(&parser p) -> vec[@ast::view_item] {\n     let vec[@ast::view_item] items = [];\n     while (is_view_item(p)) {\n         items += [parse_view_item(p)];\n@@ -2287,7 +2285,7 @@ fn parse_native_view(parser p) -> vec[@ast::view_item] {\n }\n \n \n-fn parse_crate_from_source_file(parser p) -> @ast::crate {\n+fn parse_crate_from_source_file(&parser p) -> @ast::crate {\n     auto lo = p.get_lo_pos();\n     auto m = parse_mod_items(p, token::EOF);\n     let vec[@ast::crate_directive] cdirs = [];\n@@ -2301,7 +2299,7 @@ fn parse_crate_from_source_file(parser p) -> @ast::crate {\n //\n // Each directive imperatively extends its environment with 0 or more items.\n \n-fn parse_crate_directive(parser p) -> ast::crate_directive\n+fn parse_crate_directive(&parser p) -> ast::crate_directive\n {\n     auto lo = p.get_lo_pos();\n     if (eat_word(p, \"auth\")) {\n@@ -2382,7 +2380,7 @@ fn parse_crate_directive(parser p) -> ast::crate_directive\n }\n \n \n-fn parse_crate_directives(parser p, token::token term)\n+fn parse_crate_directives(&parser p, token::token term)\n     -> vec[@ast::crate_directive] {\n \n     let vec[@ast::crate_directive] cdirs = [];\n@@ -2395,7 +2393,7 @@ fn parse_crate_directives(parser p, token::token term)\n     ret cdirs;\n }\n \n-fn parse_crate_from_crate_file(parser p) -> @ast::crate {\n+fn parse_crate_from_crate_file(&parser p) -> @ast::crate {\n     auto lo = p.get_lo_pos();\n     auto prefix = std::fs::dirname(p.get_filemap().name);\n     auto cdirs = parse_crate_directives(p, token::EOF);"}]}