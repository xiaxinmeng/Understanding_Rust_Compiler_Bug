{"sha": "ebdd4e2c723c6902851a050ec8bdc7b966dc2c64", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViZGQ0ZTJjNzIzYzY5MDI4NTFhMDUwZWM4YmRjN2I5NjZkYzJjNjQ=", "commit": {"author": {"name": "Hirochika Matsumoto", "email": "matsujika@gmail.com", "date": "2020-09-22T17:53:55Z"}, "committer": {"name": "Hirochika Matsumoto", "email": "matsujika@gmail.com", "date": "2020-11-17T16:28:37Z"}, "message": "Refactor code according to reivews", "tree": {"sha": "4d34dcf8957146467f0a5814304c4569daa325bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d34dcf8957146467f0a5814304c4569daa325bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ebdd4e2c723c6902851a050ec8bdc7b966dc2c64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ebdd4e2c723c6902851a050ec8bdc7b966dc2c64", "html_url": "https://github.com/rust-lang/rust/commit/ebdd4e2c723c6902851a050ec8bdc7b966dc2c64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ebdd4e2c723c6902851a050ec8bdc7b966dc2c64/comments", "author": {"login": "hkmatsumoto", "id": 57856193, "node_id": "MDQ6VXNlcjU3ODU2MTkz", "avatar_url": "https://avatars.githubusercontent.com/u/57856193?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hkmatsumoto", "html_url": "https://github.com/hkmatsumoto", "followers_url": "https://api.github.com/users/hkmatsumoto/followers", "following_url": "https://api.github.com/users/hkmatsumoto/following{/other_user}", "gists_url": "https://api.github.com/users/hkmatsumoto/gists{/gist_id}", "starred_url": "https://api.github.com/users/hkmatsumoto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hkmatsumoto/subscriptions", "organizations_url": "https://api.github.com/users/hkmatsumoto/orgs", "repos_url": "https://api.github.com/users/hkmatsumoto/repos", "events_url": "https://api.github.com/users/hkmatsumoto/events{/privacy}", "received_events_url": "https://api.github.com/users/hkmatsumoto/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hkmatsumoto", "id": 57856193, "node_id": "MDQ6VXNlcjU3ODU2MTkz", "avatar_url": "https://avatars.githubusercontent.com/u/57856193?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hkmatsumoto", "html_url": "https://github.com/hkmatsumoto", "followers_url": "https://api.github.com/users/hkmatsumoto/followers", "following_url": "https://api.github.com/users/hkmatsumoto/following{/other_user}", "gists_url": "https://api.github.com/users/hkmatsumoto/gists{/gist_id}", "starred_url": "https://api.github.com/users/hkmatsumoto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hkmatsumoto/subscriptions", "organizations_url": "https://api.github.com/users/hkmatsumoto/orgs", "repos_url": "https://api.github.com/users/hkmatsumoto/repos", "events_url": "https://api.github.com/users/hkmatsumoto/events{/privacy}", "received_events_url": "https://api.github.com/users/hkmatsumoto/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e9d227c043c1b990912508662e2e5158383ea54", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e9d227c043c1b990912508662e2e5158383ea54", "html_url": "https://github.com/rust-lang/rust/commit/0e9d227c043c1b990912508662e2e5158383ea54"}], "stats": {"total": 224, "additions": 141, "deletions": 83}, "files": [{"sha": "53ade7baec7bee0695f107b42b35866525d06c0e", "filename": "clippy_lints/src/unnecessary_wrap.rs", "status": "modified", "additions": 141, "deletions": 83, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/ebdd4e2c723c6902851a050ec8bdc7b966dc2c64/clippy_lints%2Fsrc%2Funnecessary_wrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebdd4e2c723c6902851a050ec8bdc7b966dc2c64/clippy_lints%2Fsrc%2Funnecessary_wrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_wrap.rs?ref=ebdd4e2c723c6902851a050ec8bdc7b966dc2c64", "patch": "@@ -4,7 +4,7 @@ use crate::utils::{\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{FnKind, NestedVisitorMap, Visitor};\n+use rustc_hir::intravisit::{FnKind, Visitor};\n use rustc_hir::*;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::{hir::map::Map, ty::subst::GenericArgKind};\n@@ -71,57 +71,31 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWrap {\n             }\n         }\n \n-        if let ExprKind::Block(ref block, ..) = body.value.kind {\n-            let path = if is_type_diagnostic_item(cx, return_ty(cx, hir_id), sym!(option_type)) {\n-                &paths::OPTION_SOME\n-            } else if is_type_diagnostic_item(cx, return_ty(cx, hir_id), sym!(result_type)) {\n-                &paths::RESULT_OK\n-            } else {\n-                return;\n-            };\n-\n-            let mut visitor = UnnecessaryWrapVisitor { result: Vec::new() };\n-            visitor.visit_block(block);\n-            let result = visitor.result;\n-\n-            if result.iter().any(|expr| {\n-                if_chain! {\n-                    if let ExprKind::Call(ref func, ref args) = expr.kind;\n-                    if let ExprKind::Path(ref qpath) = func.kind;\n-                    if match_qpath(qpath, path);\n-                    if args.len() == 1;\n-                    then {\n-                        false\n-                    } else {\n-                        true\n-                    }\n+        let path = if is_type_diagnostic_item(cx, return_ty(cx, hir_id), sym!(option_type)) {\n+            &paths::OPTION_SOME\n+        } else if is_type_diagnostic_item(cx, return_ty(cx, hir_id), sym!(result_type)) {\n+            &paths::RESULT_OK\n+        } else {\n+            return;\n+        };\n+\n+        let mut suggs = Vec::new();\n+        let can_sugg = find_all_ret_expressions(cx, &body.value, |ret_expr| {\n+            if_chain! {\n+                if let ExprKind::Call(ref func, ref args) = ret_expr.kind;\n+                if let ExprKind::Path(ref qpath) = func.kind;\n+                if match_qpath(qpath, path);\n+                if args.len() == 1;\n+                then {\n+                    suggs.push((ret_expr.span, snippet(cx, args[0].span.source_callsite(), \"..\").to_string()));\n+                    true\n+                } else {\n+                    false\n                 }\n-            }) {\n-                return;\n             }\n+        });\n \n-            let suggs = result\n-                .iter()\n-                .filter_map(|expr| {\n-                    let snippet = if let ExprKind::Call(_, ref args) = expr.kind {\n-                        Some(snippet(cx, args[0].span, \"..\").to_string())\n-                    } else {\n-                        None\n-                    };\n-                    snippet.map(|snip| (expr.span, snip))\n-                })\n-                .chain({\n-                    let inner_ty = return_ty(cx, hir_id)\n-                        .walk()\n-                        .skip(1) // skip `std::option::Option` or `std::result::Result`\n-                        .take(1) // first outermost inner type is needed\n-                        .filter_map(|inner| match inner.unpack() {\n-                            GenericArgKind::Type(inner_ty) => Some(inner_ty.to_string()),\n-                            _ => None,\n-                        });\n-                    inner_ty.map(|inner_ty| (fn_decl.output.span(), inner_ty))\n-                });\n-\n+        if can_sugg {\n             span_lint_and_then(\n                 cx,\n                 UNNECESSARY_WRAP,\n@@ -132,59 +106,143 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWrap {\n                         diag,\n                         \"factor this out to\",\n                         Applicability::MachineApplicable,\n-                        suggs,\n+                        suggs.into_iter().chain({\n+                            let inner_ty = return_ty(cx, hir_id)\n+                                .walk()\n+                                .skip(1) // skip `std::option::Option` or `std::result::Result`\n+                                .take(1) // take the first outermost inner type\n+                                .filter_map(|inner| match inner.unpack() {\n+                                    GenericArgKind::Type(inner_ty) => Some(inner_ty.to_string()),\n+                                    _ => None,\n+                                });\n+                            inner_ty.map(|inner_ty| (fn_decl.output.span(), inner_ty))\n+                        }),\n                     );\n                 },\n             );\n         }\n     }\n }\n \n-struct UnnecessaryWrapVisitor<'tcx> {\n-    result: Vec<&'tcx Expr<'tcx>>,\n-}\n+// code below is copied from `bind_instead_of_map`\n+\n+fn find_all_ret_expressions<'hir, F>(_cx: &LateContext<'_>, expr: &'hir Expr<'hir>, callback: F) -> bool\n+where\n+    F: FnMut(&'hir Expr<'hir>) -> bool,\n+{\n+    struct RetFinder<F> {\n+        in_stmt: bool,\n+        failed: bool,\n+        cb: F,\n+    }\n+\n+    struct WithStmtGuarg<'a, F> {\n+        val: &'a mut RetFinder<F>,\n+        prev_in_stmt: bool,\n+    }\n \n-impl<'tcx> Visitor<'tcx> for UnnecessaryWrapVisitor<'tcx> {\n-    type Map = Map<'tcx>;\n+    impl<F> RetFinder<F> {\n+        fn inside_stmt(&mut self, in_stmt: bool) -> WithStmtGuarg<'_, F> {\n+            let prev_in_stmt = std::mem::replace(&mut self.in_stmt, in_stmt);\n+            WithStmtGuarg {\n+                val: self,\n+                prev_in_stmt,\n+            }\n+        }\n+    }\n \n-    fn visit_block(&mut self, block: &'tcx Block<'tcx>) {\n-        for stmt in block.stmts {\n-            self.visit_stmt(stmt);\n+    impl<F> std::ops::Deref for WithStmtGuarg<'_, F> {\n+        type Target = RetFinder<F>;\n+\n+        fn deref(&self) -> &Self::Target {\n+            self.val\n         }\n-        if let Some(expr) = block.expr {\n-            self.visit_expr(expr)\n+    }\n+\n+    impl<F> std::ops::DerefMut for WithStmtGuarg<'_, F> {\n+        fn deref_mut(&mut self) -> &mut Self::Target {\n+            self.val\n         }\n     }\n \n-    fn visit_stmt(&mut self, stmt: &'tcx Stmt<'tcx>) {\n-        match stmt.kind {\n-            StmtKind::Semi(ref expr) => {\n-                if let ExprKind::Ret(Some(value)) = expr.kind {\n-                    self.result.push(value);\n-                }\n-            },\n-            StmtKind::Expr(ref expr) => self.visit_expr(expr),\n-            _ => (),\n+    impl<F> Drop for WithStmtGuarg<'_, F> {\n+        fn drop(&mut self) {\n+            self.val.in_stmt = self.prev_in_stmt;\n         }\n     }\n \n-    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-        match expr.kind {\n-            ExprKind::Ret(Some(value)) => self.result.push(value),\n-            ExprKind::Call(..) | ExprKind::Path(..) => self.result.push(expr),\n-            ExprKind::Block(ref block, _) | ExprKind::Loop(ref block, ..) => {\n-                self.visit_block(block);\n-            },\n-            ExprKind::Match(_, arms, _) => {\n-                for arm in arms {\n-                    self.visit_expr(arm.body);\n+    impl<'hir, F: FnMut(&'hir Expr<'hir>) -> bool> intravisit::Visitor<'hir> for RetFinder<F> {\n+        type Map = Map<'hir>;\n+\n+        fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+            intravisit::NestedVisitorMap::None\n+        }\n+\n+        fn visit_stmt(&mut self, stmt: &'hir Stmt<'_>) {\n+            intravisit::walk_stmt(&mut *self.inside_stmt(true), stmt)\n+        }\n+\n+        fn visit_expr(&mut self, expr: &'hir Expr<'_>) {\n+            if self.failed {\n+                return;\n+            }\n+            if self.in_stmt {\n+                match expr.kind {\n+                    ExprKind::Ret(Some(expr)) => self.inside_stmt(false).visit_expr(expr),\n+                    _ => intravisit::walk_expr(self, expr),\n+                }\n+            } else {\n+                match expr.kind {\n+                    ExprKind::Match(cond, arms, _) => {\n+                        self.inside_stmt(true).visit_expr(cond);\n+                        for arm in arms {\n+                            self.visit_expr(arm.body);\n+                        }\n+                    },\n+                    ExprKind::Block(..) => intravisit::walk_expr(self, expr),\n+                    ExprKind::Ret(Some(expr)) => self.visit_expr(expr),\n+                    _ => self.failed |= !(self.cb)(expr),\n                 }\n-            },\n-            _ => intravisit::walk_expr(self, expr),\n+            }\n         }\n     }\n \n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n+    !contains_try(expr) && {\n+        let mut ret_finder = RetFinder {\n+            in_stmt: false,\n+            failed: false,\n+            cb: callback,\n+        };\n+        ret_finder.visit_expr(expr);\n+        !ret_finder.failed\n+    }\n+}\n+\n+/// returns `true` if expr contains match expr desugared from try\n+fn contains_try(expr: &Expr<'_>) -> bool {\n+    struct TryFinder {\n+        found: bool,\n+    }\n+\n+    impl<'hir> intravisit::Visitor<'hir> for TryFinder {\n+        type Map = Map<'hir>;\n+\n+        fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+            intravisit::NestedVisitorMap::None\n+        }\n+\n+        fn visit_expr(&mut self, expr: &'hir Expr<'hir>) {\n+            if self.found {\n+                return;\n+            }\n+            match expr.kind {\n+                ExprKind::Match(_, _, MatchSource::TryDesugar) => self.found = true,\n+                _ => intravisit::walk_expr(self, expr),\n+            }\n+        }\n     }\n+\n+    let mut visitor = TryFinder { found: false };\n+    visitor.visit_expr(expr);\n+    visitor.found\n }"}]}