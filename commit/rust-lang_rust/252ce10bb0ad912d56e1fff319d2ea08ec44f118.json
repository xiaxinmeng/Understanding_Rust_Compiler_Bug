{"sha": "252ce10bb0ad912d56e1fff319d2ea08ec44f118", "node_id": "C_kwDOAAsO6NoAKDI1MmNlMTBiYjBhZDkxMmQ1NmUxZmZmMzE5ZDJlYTA4ZWM0NGYxMTg", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-10-12T05:41:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-12T05:41:26Z"}, "message": "Rollup merge of #102913 - SparrowLii:import-candidate, r=compiler-errors\n\nunify `IsPattern` and `IsImport` enum in `show_candidates`\n\nFollow-up of #102876\nA binding cannot appear in both pattern and import at the same time, so it makes sense to unify them\nr? `@compiler-errors`", "tree": {"sha": "16f8461dc66f04178e2acc75ad2f0426d87473e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16f8461dc66f04178e2acc75ad2f0426d87473e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/252ce10bb0ad912d56e1fff319d2ea08ec44f118", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjRlOGCRBK7hj4Ov3rIwAAbU4IAETWWU3vYRhClVXshqzfwcry\nQ36qDO/Va+H7+wNB/LwO8z6i8sBHYEwPlcm5fbKVWVGIk/NYLpnuF7TOQ+EGYfKr\n6qrLTsKFuc3duyxETpQs+6PLGQRicJoZkLnjw18UgFgd15vkKPCUbbJIlgqkEY4t\nCMlyqQjZQTFXmsPg6nghzelXjn2hz50ELcKfuMLBPI8vvJiFUFOcG1wTzSAh8tKH\ntBdlp0PVDhobKbR9ruXeVkE6XpBAGVhsU6tSCkJb50mLMoNl90IQ468hPVFssJ1j\nsszWRHjJVGQnK29SBooco0s+0W9M9aQoeAIP6SM79ZTKOUC1pqJLHrX1GdzxdPQ=\n=etE5\n-----END PGP SIGNATURE-----\n", "payload": "tree 16f8461dc66f04178e2acc75ad2f0426d87473e0\nparent c8a8e7d116f4d2058f8b02904de56ca6dac663d8\nparent a7f58af9fe53bbdbc7a4ca9de049f9647c29d16f\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1665553286 +0530\ncommitter GitHub <noreply@github.com> 1665553286 +0530\n\nRollup merge of #102913 - SparrowLii:import-candidate, r=compiler-errors\n\nunify `IsPattern` and `IsImport` enum in `show_candidates`\n\nFollow-up of #102876\nA binding cannot appear in both pattern and import at the same time, so it makes sense to unify them\nr? `@compiler-errors`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/252ce10bb0ad912d56e1fff319d2ea08ec44f118", "html_url": "https://github.com/rust-lang/rust/commit/252ce10bb0ad912d56e1fff319d2ea08ec44f118", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/252ce10bb0ad912d56e1fff319d2ea08ec44f118/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8a8e7d116f4d2058f8b02904de56ca6dac663d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8a8e7d116f4d2058f8b02904de56ca6dac663d8", "html_url": "https://github.com/rust-lang/rust/commit/c8a8e7d116f4d2058f8b02904de56ca6dac663d8"}, {"sha": "a7f58af9fe53bbdbc7a4ca9de049f9647c29d16f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7f58af9fe53bbdbc7a4ca9de049f9647c29d16f", "html_url": "https://github.com/rust-lang/rust/commit/a7f58af9fe53bbdbc7a4ca9de049f9647c29d16f"}], "stats": {"total": 68, "additions": 33, "deletions": 35}, "files": [{"sha": "c4644d4f076e2ee3eded9b9a7d8febda3b703835", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 33, "deletions": 35, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/252ce10bb0ad912d56e1fff319d2ea08ec44f118/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252ce10bb0ad912d56e1fff319d2ea08ec44f118/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=252ce10bb0ad912d56e1fff319d2ea08ec44f118", "patch": "@@ -139,8 +139,7 @@ impl<'a> Resolver<'a> {\n                     &candidates,\n                     if instead { Instead::Yes } else { Instead::No },\n                     found_use,\n-                    IsPattern::No,\n-                    IsImport::No,\n+                    DiagnosticMode::Normal,\n                     path,\n                 );\n                 err.emit();\n@@ -699,8 +698,7 @@ impl<'a> Resolver<'a> {\n                         &import_suggestions,\n                         Instead::No,\n                         FoundUse::Yes,\n-                        IsPattern::Yes,\n-                        IsImport::No,\n+                        DiagnosticMode::Pattern,\n                         vec![],\n                     );\n                 }\n@@ -1496,8 +1494,7 @@ impl<'a> Resolver<'a> {\n             &import_suggestions,\n             Instead::No,\n             FoundUse::Yes,\n-            IsPattern::No,\n-            IsImport::No,\n+            DiagnosticMode::Normal,\n             vec![],\n         );\n \n@@ -2458,18 +2455,13 @@ enum FoundUse {\n     No,\n }\n \n-/// Whether a binding is part of a pattern or an expression. Used for diagnostics.\n-enum IsPattern {\n+/// Whether a binding is part of a pattern or a use statement. Used for diagnostics.\n+enum DiagnosticMode {\n+    Normal,\n     /// The binding is part of a pattern\n-    Yes,\n-    /// The binding is part of an expression\n-    No,\n-}\n-\n-/// Whether a binding is part of a use statement. Used for diagnostics.\n-enum IsImport {\n-    Yes,\n-    No,\n+    Pattern,\n+    /// The binding is part of a use statement\n+    Import,\n }\n \n pub(crate) fn import_candidates(\n@@ -2488,8 +2480,7 @@ pub(crate) fn import_candidates(\n         candidates,\n         Instead::Yes,\n         FoundUse::Yes,\n-        IsPattern::No,\n-        IsImport::Yes,\n+        DiagnosticMode::Import,\n         vec![],\n     );\n }\n@@ -2506,8 +2497,7 @@ fn show_candidates(\n     candidates: &[ImportSuggestion],\n     instead: Instead,\n     found_use: FoundUse,\n-    is_pattern: IsPattern,\n-    is_import: IsImport,\n+    mode: DiagnosticMode,\n     path: Vec<Segment>,\n ) {\n     if candidates.is_empty() {\n@@ -2542,7 +2532,7 @@ fn show_candidates(\n         };\n \n         let instead = if let Instead::Yes = instead { \" instead\" } else { \"\" };\n-        let mut msg = if let IsPattern::Yes = is_pattern {\n+        let mut msg = if let DiagnosticMode::Pattern = mode {\n             format!(\n                 \"if you meant to match on {}{}{}, use the full path in the pattern\",\n                 kind, instead, name\n@@ -2555,19 +2545,24 @@ fn show_candidates(\n             err.note(note);\n         }\n \n-        if let (IsPattern::Yes, Some(span)) = (is_pattern, use_placement_span) {\n-            err.span_suggestions(\n-                span,\n-                &msg,\n-                accessible_path_strings.into_iter().map(|a| a.0),\n-                Applicability::MaybeIncorrect,\n-            );\n-        } else if let Some(span) = use_placement_span {\n+        if let Some(span) = use_placement_span {\n+            let add_use = match mode {\n+                DiagnosticMode::Pattern => {\n+                    err.span_suggestions(\n+                        span,\n+                        &msg,\n+                        accessible_path_strings.into_iter().map(|a| a.0),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                    return;\n+                }\n+                DiagnosticMode::Import => \"\",\n+                DiagnosticMode::Normal => \"use \",\n+            };\n             for candidate in &mut accessible_path_strings {\n                 // produce an additional newline to separate the new use statement\n                 // from the directly following item.\n                 let additional_newline = if let FoundUse::Yes = found_use { \"\" } else { \"\\n\" };\n-                let add_use = if let IsImport::Yes = is_import { \"\" } else { \"use \" };\n                 candidate.0 = format!(\"{}{};\\n{}\", add_use, &candidate.0, additional_newline);\n             }\n \n@@ -2598,19 +2593,22 @@ fn show_candidates(\n \n             err.note(&msg);\n         }\n-    } else if matches!(is_import, IsImport::No) {\n+    } else if !matches!(mode, DiagnosticMode::Import) {\n         assert!(!inaccessible_path_strings.is_empty());\n \n-        let prefix =\n-            if let IsPattern::Yes = is_pattern { \"you might have meant to match on \" } else { \"\" };\n+        let prefix = if let DiagnosticMode::Pattern = mode {\n+            \"you might have meant to match on \"\n+        } else {\n+            \"\"\n+        };\n         if inaccessible_path_strings.len() == 1 {\n             let (name, descr, def_id, note) = &inaccessible_path_strings[0];\n             let msg = format!(\n                 \"{}{} `{}`{} exists but is inaccessible\",\n                 prefix,\n                 descr,\n                 name,\n-                if let IsPattern::Yes = is_pattern { \", which\" } else { \"\" }\n+                if let DiagnosticMode::Pattern = mode { \", which\" } else { \"\" }\n             );\n \n             if let Some(local_def_id) = def_id.and_then(|did| did.as_local()) {"}]}