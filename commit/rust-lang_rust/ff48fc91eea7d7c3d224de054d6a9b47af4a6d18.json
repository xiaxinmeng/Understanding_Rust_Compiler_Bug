{"sha": "ff48fc91eea7d7c3d224de054d6a9b47af4a6d18", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmNDhmYzkxZWVhN2Q3YzNkMjI0ZGUwNTRkNmE5YjQ3YWY0YTZkMTg=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-05-23T22:00:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-23T22:00:42Z"}, "message": "Rollup merge of #71618 - ecstatic-morse:issue-71394, r=nikomatsakis\n\nPreserve substitutions when making trait obligations for suggestions\n\nResolves #71394.\n\nI *think* `map_bound_ref` is correct here. In any case, I think a lot of the diagnostic code is using `skip_binder` more aggressively than it should be, so I doubt that this is worse than the status quo. The assertion that `new_self_ty` has no escaping bound vars should be enough.\n\nr? @estebank\n\ncc @nikomatsakis Is the call to `skip_binder` on line 551 (and elsewhere in this file) appropriate? https://github.com/rust-lang/rust/blob/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src/librustc_trait_selection/traits/error_reporting/suggestions.rs#L537-L565", "tree": {"sha": "8cb3d075de16ffb6fc66812299b74476ff1ea38a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8cb3d075de16ffb6fc66812299b74476ff1ea38a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff48fc91eea7d7c3d224de054d6a9b47af4a6d18", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeyZ0KCRBK7hj4Ov3rIwAAdHIIAIVikmoWQCPHYYn0ziaKP+Af\nzmBN496nX9rs66fSvlN5q8pj1EHrpgQkm00mBkUFxvEXVIiO5a1p7SDKIJoqSYMM\nj/7qFPjNQOrucAUfNcVZdlC2l8v5DBkVMd10Ww3HrTe3S9ndUJucVsgYeHsuNS5T\ngSpWceKqJ/UOopojqxDsEy7U3X1/C72GJ/zOhNeTr8Z0rsdVdvDRaEDULFvakzb2\ngZvoi50hlvEI26VYFMBTeuf8r8G1n7HjNlrOymUlMmwrL2ja/GHubkaRQTXiMLZR\nRT+7/DY4G1nbAKXnQ26oRcItwv9SwpT6hUiSrD6EdDrHsTlhJgNlMURZjNvIHvY=\n=S84e\n-----END PGP SIGNATURE-----\n", "payload": "tree 8cb3d075de16ffb6fc66812299b74476ff1ea38a\nparent 8970e8bcf6153d1ead2283f1a0ed7b192230eca6\nparent 1fad3b7a0535c4a4da046170d4080e0cd214ee42\nauthor Dylan DPC <dylan.dpc@gmail.com> 1590271242 +0200\ncommitter GitHub <noreply@github.com> 1590271242 +0200\n\nRollup merge of #71618 - ecstatic-morse:issue-71394, r=nikomatsakis\n\nPreserve substitutions when making trait obligations for suggestions\n\nResolves #71394.\n\nI *think* `map_bound_ref` is correct here. In any case, I think a lot of the diagnostic code is using `skip_binder` more aggressively than it should be, so I doubt that this is worse than the status quo. The assertion that `new_self_ty` has no escaping bound vars should be enough.\n\nr? @estebank\n\ncc @nikomatsakis Is the call to `skip_binder` on line 551 (and elsewhere in this file) appropriate? https://github.com/rust-lang/rust/blob/46ec74e60f238f694b46c976d6217e7cf8d4cf1a/src/librustc_trait_selection/traits/error_reporting/suggestions.rs#L537-L565\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff48fc91eea7d7c3d224de054d6a9b47af4a6d18", "html_url": "https://github.com/rust-lang/rust/commit/ff48fc91eea7d7c3d224de054d6a9b47af4a6d18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff48fc91eea7d7c3d224de054d6a9b47af4a6d18/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8970e8bcf6153d1ead2283f1a0ed7b192230eca6", "url": "https://api.github.com/repos/rust-lang/rust/commits/8970e8bcf6153d1ead2283f1a0ed7b192230eca6", "html_url": "https://github.com/rust-lang/rust/commit/8970e8bcf6153d1ead2283f1a0ed7b192230eca6"}, {"sha": "1fad3b7a0535c4a4da046170d4080e0cd214ee42", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fad3b7a0535c4a4da046170d4080e0cd214ee42", "html_url": "https://github.com/rust-lang/rust/commit/1fad3b7a0535c4a4da046170d4080e0cd214ee42"}], "stats": {"total": 112, "additions": 69, "deletions": 43}, "files": [{"sha": "b1c6815c7414f06bcfe49d8370fe3f74c2ba52d5", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ff48fc91eea7d7c3d224de054d6a9b47af4a6d18/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff48fc91eea7d7c3d224de054d6a9b47af4a6d18/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=ff48fc91eea7d7c3d224de054d6a9b47af4a6d18", "patch": "@@ -1000,12 +1000,15 @@ trait InferCtxtPrivExt<'tcx> {\n         trait_ref: &ty::PolyTraitRef<'tcx>,\n     );\n \n-    fn mk_obligation_for_def_id(\n+    /// Creates a `PredicateObligation` with `new_self_ty` replacing the existing type in the\n+    /// `trait_ref`.\n+    ///\n+    /// For this to work, `new_self_ty` must have no escaping bound variables.\n+    fn mk_trait_obligation_with_new_self_ty(\n         &self,\n-        def_id: DefId,\n-        output_ty: Ty<'tcx>,\n-        cause: ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n+        trait_ref: &ty::PolyTraitRef<'tcx>,\n+        new_self_ty: Ty<'tcx>,\n     ) -> PredicateObligation<'tcx>;\n \n     fn maybe_report_ambiguity(\n@@ -1380,16 +1383,24 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn mk_obligation_for_def_id(\n+    fn mk_trait_obligation_with_new_self_ty(\n         &self,\n-        def_id: DefId,\n-        output_ty: Ty<'tcx>,\n-        cause: ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n+        trait_ref: &ty::PolyTraitRef<'tcx>,\n+        new_self_ty: Ty<'tcx>,\n     ) -> PredicateObligation<'tcx> {\n-        let new_trait_ref =\n-            ty::TraitRef { def_id, substs: self.tcx.mk_substs_trait(output_ty, &[]) };\n-        Obligation::new(cause, param_env, new_trait_ref.without_const().to_predicate(self.tcx))\n+        assert!(!new_self_ty.has_escaping_bound_vars());\n+\n+        let trait_ref = trait_ref.map_bound_ref(|tr| ty::TraitRef {\n+            substs: self.tcx.mk_substs_trait(new_self_ty, &tr.substs[1..]),\n+            ..*tr\n+        });\n+\n+        Obligation::new(\n+            ObligationCause::dummy(),\n+            param_env,\n+            trait_ref.without_const().to_predicate(self.tcx),\n+        )\n     }\n \n     fn maybe_report_ambiguity("}, {"sha": "5c85855535e38529dcaab7f7dc7d2417a28f4c96", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/ff48fc91eea7d7c3d224de054d6a9b47af4a6d18/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff48fc91eea7d7c3d224de054d6a9b47af4a6d18/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=ff48fc91eea7d7c3d224de054d6a9b47af4a6d18", "patch": "@@ -532,14 +532,17 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         };\n         let msg = format!(\"use parentheses to call the {}\", callable);\n \n-        let obligation = self.mk_obligation_for_def_id(\n-            trait_ref.def_id(),\n-            output_ty.skip_binder(),\n-            obligation.cause.clone(),\n-            obligation.param_env,\n-        );\n+        // `mk_trait_obligation_with_new_self_ty` only works for types with no escaping bound\n+        // variables, so bail out if we have any.\n+        let output_ty = match output_ty.no_bound_vars() {\n+            Some(ty) => ty,\n+            None => return,\n+        };\n+\n+        let new_obligation =\n+            self.mk_trait_obligation_with_new_self_ty(obligation.param_env, trait_ref, output_ty);\n \n-        match self.evaluate_obligation(&obligation) {\n+        match self.evaluate_obligation(&new_obligation) {\n             Ok(\n                 EvaluationResult::EvaluatedToOk\n                 | EvaluationResult::EvaluatedToOkModuloRegions\n@@ -694,7 +697,6 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n         trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n     ) {\n-        let trait_ref = trait_ref.skip_binder();\n         let span = obligation.cause.span;\n \n         if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n@@ -705,17 +707,16 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 return;\n             }\n \n-            let mut trait_type = trait_ref.self_ty();\n+            let mut suggested_ty = trait_ref.self_ty();\n \n             for refs_remaining in 0..refs_number {\n-                if let ty::Ref(_, t_type, _) = trait_type.kind {\n-                    trait_type = t_type;\n+                if let ty::Ref(_, inner_ty, _) = suggested_ty.kind {\n+                    suggested_ty = inner_ty;\n \n-                    let new_obligation = self.mk_obligation_for_def_id(\n-                        trait_ref.def_id,\n-                        trait_type,\n-                        ObligationCause::dummy(),\n+                    let new_obligation = self.mk_trait_obligation_with_new_self_ty(\n                         obligation.param_env,\n+                        trait_ref,\n+                        suggested_ty,\n                     );\n \n                     if self.predicate_may_hold(&new_obligation) {\n@@ -782,20 +783,20 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     return;\n                 }\n \n-                let trait_type = match mutability {\n+                let suggested_ty = match mutability {\n                     hir::Mutability::Mut => self.tcx.mk_imm_ref(region, t_type),\n                     hir::Mutability::Not => self.tcx.mk_mut_ref(region, t_type),\n                 };\n \n-                let new_obligation = self.mk_obligation_for_def_id(\n-                    trait_ref.skip_binder().def_id,\n-                    trait_type,\n-                    ObligationCause::dummy(),\n+                let new_obligation = self.mk_trait_obligation_with_new_self_ty(\n                     obligation.param_env,\n+                    &trait_ref,\n+                    suggested_ty,\n                 );\n-\n-                if self.evaluate_obligation_no_overflow(&new_obligation).must_apply_modulo_regions()\n-                {\n+                let suggested_ty_would_satisfy_obligation = self\n+                    .evaluate_obligation_no_overflow(&new_obligation)\n+                    .must_apply_modulo_regions();\n+                if suggested_ty_would_satisfy_obligation {\n                     let sp = self\n                         .tcx\n                         .sess\n@@ -812,7 +813,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         err.note(&format!(\n                             \"`{}` is implemented for `{:?}`, but not for `{:?}`\",\n                             trait_ref.print_only_trait_path(),\n-                            trait_type,\n+                            suggested_ty,\n                             trait_ref.skip_binder().self_ty(),\n                         ));\n                     }\n@@ -1891,7 +1892,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         span: Span,\n     ) {\n         debug!(\n-            \"suggest_await_befor_try: obligation={:?}, span={:?}, trait_ref={:?}, trait_ref_self_ty={:?}\",\n+            \"suggest_await_before_try: obligation={:?}, span={:?}, trait_ref={:?}, trait_ref_self_ty={:?}\",\n             obligation,\n             span,\n             trait_ref,\n@@ -1946,16 +1947,15 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 );\n \n                 debug!(\n-                    \"suggest_await_befor_try: normalized_projection_type {:?}\",\n+                    \"suggest_await_before_try: normalized_projection_type {:?}\",\n                     self.resolve_vars_if_possible(&normalized_ty)\n                 );\n-                let try_obligation = self.mk_obligation_for_def_id(\n-                    trait_ref.def_id(),\n-                    normalized_ty,\n-                    obligation.cause.clone(),\n+                let try_obligation = self.mk_trait_obligation_with_new_self_ty(\n                     obligation.param_env,\n+                    trait_ref,\n+                    normalized_ty,\n                 );\n-                debug!(\"suggest_await_befor_try: try_trait_obligation {:?}\", try_obligation);\n+                debug!(\"suggest_await_before_try: try_trait_obligation {:?}\", try_obligation);\n                 if self.predicate_may_hold(&try_obligation) && impls_future {\n                     if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n                         if snippet.ends_with('?') {"}, {"sha": "f7affdbf1b4084729b9d4fb8b8be27e54ef7f775", "filename": "src/test/ui/suggestions/into-str.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff48fc91eea7d7c3d224de054d6a9b47af4a6d18/src%2Ftest%2Fui%2Fsuggestions%2Finto-str.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff48fc91eea7d7c3d224de054d6a9b47af4a6d18/src%2Ftest%2Fui%2Fsuggestions%2Finto-str.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finto-str.stderr?ref=ff48fc91eea7d7c3d224de054d6a9b47af4a6d18", "patch": "@@ -8,7 +8,6 @@ LL |     foo(String::new());\n    |     ^^^ the trait `std::convert::From<std::string::String>` is not implemented for `&str`\n    |\n    = note: to coerce a `std::string::String` into a `&str`, use `&*` as a prefix\n-   = note: `std::convert::From<std::string::String>` is implemented for `&mut str`, but not for `&str`\n    = note: required because of the requirements on the impl of `std::convert::Into<&str>` for `std::string::String`\n \n error: aborting due to previous error"}, {"sha": "9ffcc3f7bc1c1f85649780f2233382ee1c85361a", "filename": "src/test/ui/suggestions/issue-71394-no-from-impl.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ff48fc91eea7d7c3d224de054d6a9b47af4a6d18/src%2Ftest%2Fui%2Fsuggestions%2Fissue-71394-no-from-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff48fc91eea7d7c3d224de054d6a9b47af4a6d18/src%2Ftest%2Fui%2Fsuggestions%2Fissue-71394-no-from-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-71394-no-from-impl.rs?ref=ff48fc91eea7d7c3d224de054d6a9b47af4a6d18", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    let data: &[u8] = &[0; 10];\n+    let _: &[i8] = data.into();\n+    //~^ ERROR the trait bound `&[i8]: std::convert::From<&[u8]>` is not satisfied\n+}"}, {"sha": "84c73c2f67e707816b39064b7a4b357716a88985", "filename": "src/test/ui/suggestions/issue-71394-no-from-impl.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ff48fc91eea7d7c3d224de054d6a9b47af4a6d18/src%2Ftest%2Fui%2Fsuggestions%2Fissue-71394-no-from-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff48fc91eea7d7c3d224de054d6a9b47af4a6d18/src%2Ftest%2Fui%2Fsuggestions%2Fissue-71394-no-from-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-71394-no-from-impl.stderr?ref=ff48fc91eea7d7c3d224de054d6a9b47af4a6d18", "patch": "@@ -0,0 +1,11 @@\n+error[E0277]: the trait bound `&[i8]: std::convert::From<&[u8]>` is not satisfied\n+  --> $DIR/issue-71394-no-from-impl.rs:3:25\n+   |\n+LL |     let _: &[i8] = data.into();\n+   |                         ^^^^ the trait `std::convert::From<&[u8]>` is not implemented for `&[i8]`\n+   |\n+   = note: required because of the requirements on the impl of `std::convert::Into<&[i8]>` for `&[u8]`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}]}