{"sha": "88a37a20867a3b9840d2f56f806f77ec0990d50c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4YTM3YTIwODY3YTNiOTg0MGQyZjU2ZjgwNmY3N2VjMDk5MGQ1MGM=", "commit": {"author": {"name": "Joe Richey", "email": "joerichey@google.com", "date": "2020-05-15T08:28:33Z"}, "committer": {"name": "Joe Richey", "email": "joerichey@google.com", "date": "2020-05-25T20:09:02Z"}, "message": "test/ui/consts: Add tests for const ptr offsets\n\nSigned-off-by: Joe Richey <joerichey@google.com>", "tree": {"sha": "6f3d1914d8c38053ec56078a589bedb0be5d2bd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f3d1914d8c38053ec56078a589bedb0be5d2bd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88a37a20867a3b9840d2f56f806f77ec0990d50c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88a37a20867a3b9840d2f56f806f77ec0990d50c", "html_url": "https://github.com/rust-lang/rust/commit/88a37a20867a3b9840d2f56f806f77ec0990d50c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88a37a20867a3b9840d2f56f806f77ec0990d50c/comments", "author": {"login": "josephlr", "id": 5506060, "node_id": "MDQ6VXNlcjU1MDYwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/5506060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josephlr", "html_url": "https://github.com/josephlr", "followers_url": "https://api.github.com/users/josephlr/followers", "following_url": "https://api.github.com/users/josephlr/following{/other_user}", "gists_url": "https://api.github.com/users/josephlr/gists{/gist_id}", "starred_url": "https://api.github.com/users/josephlr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josephlr/subscriptions", "organizations_url": "https://api.github.com/users/josephlr/orgs", "repos_url": "https://api.github.com/users/josephlr/repos", "events_url": "https://api.github.com/users/josephlr/events{/privacy}", "received_events_url": "https://api.github.com/users/josephlr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "josephlr", "id": 5506060, "node_id": "MDQ6VXNlcjU1MDYwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/5506060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josephlr", "html_url": "https://github.com/josephlr", "followers_url": "https://api.github.com/users/josephlr/followers", "following_url": "https://api.github.com/users/josephlr/following{/other_user}", "gists_url": "https://api.github.com/users/josephlr/gists{/gist_id}", "starred_url": "https://api.github.com/users/josephlr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josephlr/subscriptions", "organizations_url": "https://api.github.com/users/josephlr/orgs", "repos_url": "https://api.github.com/users/josephlr/repos", "events_url": "https://api.github.com/users/josephlr/events{/privacy}", "received_events_url": "https://api.github.com/users/josephlr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b3dfd8ea987ce1d4b5ccbcb4c032f60a71c8cfb", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b3dfd8ea987ce1d4b5ccbcb4c032f60a71c8cfb", "html_url": "https://github.com/rust-lang/rust/commit/9b3dfd8ea987ce1d4b5ccbcb4c032f60a71c8cfb"}], "stats": {"total": 291, "additions": 291, "deletions": 0}, "files": [{"sha": "f64242d568e318a8b43cfb945030877e74788ae6", "filename": "src/test/ui/consts/offset.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/88a37a20867a3b9840d2f56f806f77ec0990d50c/src%2Ftest%2Fui%2Fconsts%2Foffset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88a37a20867a3b9840d2f56f806f77ec0990d50c/src%2Ftest%2Fui%2Fconsts%2Foffset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset.rs?ref=88a37a20867a3b9840d2f56f806f77ec0990d50c", "patch": "@@ -0,0 +1,115 @@\n+// run-pass\n+#![feature(const_ptr_offset)]\n+#![feature(const_ptr_offset_from)]\n+#![feature(ptr_offset_from)]\n+use std::ptr;\n+\n+#[repr(C)]\n+struct Struct {\n+    a: u32,\n+    b: u32,\n+    c: u32,\n+}\n+static S: Struct = Struct { a: 0, b: 0, c: 0 };\n+\n+// For these tests we use offset_from to check that two pointers are equal.\n+// Rust doesn't currently support comparing pointers in const fn.\n+\n+static OFFSET_NO_CHANGE: bool = unsafe {\n+    let p1 = &S.b as *const u32;\n+    let p2 = p1.offset(2).offset(-2);\n+    p1.offset_from(p2) == 0\n+};\n+static OFFSET_MIDDLE: bool = unsafe {\n+    let p1 = (&S.a as *const u32).offset(1);\n+    let p2 = (&S.c as *const u32).offset(-1);\n+    p1.offset_from(p2) == 0\n+};\n+// Pointing to the end of the allocation is OK\n+static OFFSET_END: bool = unsafe {\n+    let p1 = (&S.a as *const u32).offset(3);\n+    let p2 = (&S.c as *const u32).offset(1);\n+    p1.offset_from(p2) == 0\n+};\n+// Casting though a differently sized type is OK\n+static OFFSET_U8_PTR: bool = unsafe {\n+    let p1 = (&S.a as *const u32 as *const u8).offset(5);\n+    let p2 = (&S.c as *const u32 as *const u8).offset(-3);\n+    p1.offset_from(p2) == 0\n+};\n+// Any offset with a ZST does nothing\n+const OFFSET_ZST: bool = unsafe {\n+    let pz = &() as *const ();\n+    // offset_from can't work with ZSTs, so cast to u8 ptr\n+    let p1 = pz.offset(5) as *const u8;\n+    let p2 = pz.offset(isize::MIN) as *const u8;\n+    p1.offset_from(p2) == 0\n+};\n+const OFFSET_ZERO: bool = unsafe {\n+    let p = [0u8; 0].as_ptr();\n+    p.offset(0).offset_from(p) == 0\n+};\n+const OFFSET_ONE: bool = unsafe {\n+    let p = &42u32 as *const u32;\n+    p.offset(1).offset_from(p) == 1\n+};\n+const OFFSET_DANGLING: bool = unsafe {\n+    let p = ptr::NonNull::<u8>::dangling().as_ptr();\n+    p.offset(0).offset_from(p) == 0\n+};\n+const OFFSET_UNALIGNED: bool = unsafe {\n+    let arr = [0u8; 32];\n+    let p1 = arr.as_ptr();\n+    let p2 = (p1.offset(2) as *const u32).offset(1);\n+    (p2 as *const u8).offset_from(p1) == 6\n+};\n+\n+const WRAP_OFFSET_NO_CHANGE: bool = unsafe {\n+    let p1 = &42u32 as *const u32;\n+    let p2 = p1.wrapping_offset(1000).wrapping_offset(-1000);\n+    let p3 = p1.wrapping_offset(-1000).wrapping_offset(1000);\n+    (p1.offset_from(p2) == 0) & (p1.offset_from(p3) == 0)\n+};\n+const WRAP_ADDRESS_SPACE: bool = unsafe {\n+    let p1 = &42u8 as *const u8;\n+    let p2 = p1.wrapping_offset(isize::MIN).wrapping_offset(isize::MIN);\n+    p1.offset_from(p2) == 0\n+};\n+// Wrap on the count*size_of::<T>() calculation.\n+const WRAP_SIZE_OF: bool = unsafe {\n+    // Make sure that if p1 moves backwards, we are still in range\n+    let arr = [0u32; 2];\n+    let p = &arr[1] as *const u32;\n+    // With wrapping arithmetic, isize::MAX * 4 == -4\n+    let wrapped = p.wrapping_offset(isize::MAX);\n+    let backward = p.wrapping_offset(-1);\n+    wrapped.offset_from(backward) == 0\n+};\n+const WRAP_INTEGER_POINTER: bool = unsafe {\n+    let p1 = (0x42 as *const u32).wrapping_offset(4);\n+    let p2 = 0x52 as *const u32;\n+    p1.offset_from(p2) == 0\n+};\n+const WRAP_NULL: bool = unsafe {\n+    let p1 = ptr::null::<u32>().wrapping_offset(1);\n+    let p2 = 0x4 as *const u32;\n+    p1.offset_from(p2) == 0\n+};\n+\n+fn main() {\n+    assert!(OFFSET_NO_CHANGE);\n+    assert!(OFFSET_MIDDLE);\n+    assert!(OFFSET_END);\n+    assert!(OFFSET_U8_PTR);\n+    assert!(OFFSET_ZST);\n+    assert!(OFFSET_ZERO);\n+    assert!(OFFSET_ONE);\n+    assert!(OFFSET_DANGLING);\n+    assert!(OFFSET_UNALIGNED);\n+\n+    assert!(WRAP_OFFSET_NO_CHANGE);\n+    assert!(WRAP_ADDRESS_SPACE);\n+    assert!(WRAP_SIZE_OF);\n+    assert!(WRAP_INTEGER_POINTER);\n+    assert!(WRAP_NULL);\n+}"}, {"sha": "ac1207896948050eec62db4bc44d94fcd42d5b26", "filename": "src/test/ui/consts/offset_ub.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/88a37a20867a3b9840d2f56f806f77ec0990d50c/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88a37a20867a3b9840d2f56f806f77ec0990d50c/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.rs?ref=88a37a20867a3b9840d2f56f806f77ec0990d50c", "patch": "@@ -0,0 +1,22 @@\n+// ignore-tidy-linelength\n+#![feature(const_ptr_offset)]\n+use std::ptr;\n+\n+// normalize-stderr-test \"alloc\\d+\" -> \"allocN\"\n+\n+pub const BEFORE_START: *const u8 = unsafe { (&0u8 as *const u8).offset(-1) }; //~NOTE\n+pub const AFTER_END: *const u8 = unsafe { (&0u8 as *const u8).offset(2) }; //~NOTE\n+pub const AFTER_ARRAY: *const u8 = unsafe { [0u8; 100].as_ptr().offset(101) }; //~NOTE\n+\n+pub const OVERFLOW: *const u16 = unsafe { [0u16; 1].as_ptr().offset(isize::MAX) }; //~NOTE\n+pub const UNDERFLOW: *const u16 = unsafe { [0u16; 1].as_ptr().offset(isize::MIN) }; //~NOTE\n+pub const OVERFLOW_ADDRESS_SPACE: *const u8 = unsafe { (usize::MAX as *const u8).offset(2) }; //~NOTE\n+pub const UNDERFLOW_ADDRESS_SPACE: *const u8 = unsafe { (1 as *const u8).offset(-2) }; //~NOTE\n+\n+pub const ZERO_SIZED_ALLOC: *const u8 = unsafe { [0u8; 0].as_ptr().offset(1) }; //~NOTE\n+pub const DANGLING: *const u8 = unsafe { ptr::NonNull::<u8>::dangling().as_ptr().offset(4) }; //~NOTE\n+\n+// Right now, a zero offset from null is UB\n+pub const NULL_OFFSET_ZERO: *const u8 = unsafe { ptr::null::<u8>().offset(0) }; //~NOTE\n+\n+fn main() {}"}, {"sha": "b2b77586a504dfda85b4aa56d8bbcde012b57913", "filename": "src/test/ui/consts/offset_ub.stderr", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/88a37a20867a3b9840d2f56f806f77ec0990d50c/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/88a37a20867a3b9840d2f56f806f77ec0990d50c/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.stderr?ref=88a37a20867a3b9840d2f56f806f77ec0990d50c", "patch": "@@ -0,0 +1,154 @@\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         intrinsics::offset(self, count)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         overflowing in-bounds pointer arithmetic\n+   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |         inside `BEFORE_START` at $DIR/offset_ub.rs:7:46\n+   | \n+  ::: $DIR/offset_ub.rs:7:1\n+   |\n+LL | pub const BEFORE_START: *const u8 = unsafe { (&0u8 as *const u8).offset(-1) };\n+   | ------------------------------------------------------------------------------\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         intrinsics::offset(self, count)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         inbounds test failed: pointer must be in-bounds at offset 2, but is outside bounds of allocN which has size 1\n+   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |         inside `AFTER_END` at $DIR/offset_ub.rs:8:43\n+   | \n+  ::: $DIR/offset_ub.rs:8:1\n+   |\n+LL | pub const AFTER_END: *const u8 = unsafe { (&0u8 as *const u8).offset(2) };\n+   | --------------------------------------------------------------------------\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         intrinsics::offset(self, count)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         inbounds test failed: pointer must be in-bounds at offset 101, but is outside bounds of allocN which has size 100\n+   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |         inside `AFTER_ARRAY` at $DIR/offset_ub.rs:9:45\n+   | \n+  ::: $DIR/offset_ub.rs:9:1\n+   |\n+LL | pub const AFTER_ARRAY: *const u8 = unsafe { [0u8; 100].as_ptr().offset(101) };\n+   | ------------------------------------------------------------------------------\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         intrinsics::offset(self, count)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         inbounds pointer arithmetic: overflow computing offset\n+   |         inside `std::ptr::const_ptr::<impl *const u16>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |         inside `OVERFLOW` at $DIR/offset_ub.rs:11:43\n+   | \n+  ::: $DIR/offset_ub.rs:11:1\n+   |\n+LL | pub const OVERFLOW: *const u16 = unsafe { [0u16; 1].as_ptr().offset(isize::MAX) };\n+   | ----------------------------------------------------------------------------------\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         intrinsics::offset(self, count)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         inbounds pointer arithmetic: overflow computing offset\n+   |         inside `std::ptr::const_ptr::<impl *const u16>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |         inside `UNDERFLOW` at $DIR/offset_ub.rs:12:44\n+   | \n+  ::: $DIR/offset_ub.rs:12:1\n+   |\n+LL | pub const UNDERFLOW: *const u16 = unsafe { [0u16; 1].as_ptr().offset(isize::MIN) };\n+   | -----------------------------------------------------------------------------------\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         intrinsics::offset(self, count)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         overflowing in-bounds pointer arithmetic\n+   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |         inside `OVERFLOW_ADDRESS_SPACE` at $DIR/offset_ub.rs:13:56\n+   | \n+  ::: $DIR/offset_ub.rs:13:1\n+   |\n+LL | pub const OVERFLOW_ADDRESS_SPACE: *const u8 = unsafe { (usize::MAX as *const u8).offset(2) };\n+   | ---------------------------------------------------------------------------------------------\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         intrinsics::offset(self, count)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         overflowing in-bounds pointer arithmetic\n+   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |         inside `UNDERFLOW_ADDRESS_SPACE` at $DIR/offset_ub.rs:14:57\n+   | \n+  ::: $DIR/offset_ub.rs:14:1\n+   |\n+LL | pub const UNDERFLOW_ADDRESS_SPACE: *const u8 = unsafe { (1 as *const u8).offset(-2) };\n+   | --------------------------------------------------------------------------------------\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         intrinsics::offset(self, count)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         inbounds test failed: pointer must be in-bounds at offset 1, but is outside bounds of allocN which has size 0\n+   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |         inside `ZERO_SIZED_ALLOC` at $DIR/offset_ub.rs:16:50\n+   | \n+  ::: $DIR/offset_ub.rs:16:1\n+   |\n+LL | pub const ZERO_SIZED_ALLOC: *const u8 = unsafe { [0u8; 0].as_ptr().offset(1) };\n+   | -------------------------------------------------------------------------------\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/mut_ptr.rs:LL:COL\n+   |\n+LL |         intrinsics::offset(self, count) as *mut T\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         unable to turn bytes into a pointer\n+   |         inside `std::ptr::mut_ptr::<impl *mut u8>::offset` at $SRC_DIR/libcore/ptr/mut_ptr.rs:LL:COL\n+   |         inside `DANGLING` at $DIR/offset_ub.rs:17:42\n+   | \n+  ::: $DIR/offset_ub.rs:17:1\n+   |\n+LL | pub const DANGLING: *const u8 = unsafe { ptr::NonNull::<u8>::dangling().as_ptr().offset(4) };\n+   | ---------------------------------------------------------------------------------------------\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         intrinsics::offset(self, count)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         inbounds test failed: 0x0 is not a valid pointer\n+   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |         inside `NULL_OFFSET_ZERO` at $DIR/offset_ub.rs:20:50\n+   | \n+  ::: $DIR/offset_ub.rs:20:1\n+   |\n+LL | pub const NULL_OFFSET_ZERO: *const u8 = unsafe { ptr::null::<u8>().offset(0) };\n+   | -------------------------------------------------------------------------------\n+\n+error: aborting due to 10 previous errors\n+"}]}