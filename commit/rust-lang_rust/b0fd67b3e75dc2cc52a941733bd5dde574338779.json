{"sha": "b0fd67b3e75dc2cc52a941733bd5dde574338779", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwZmQ2N2IzZTc1ZGMyY2M1MmE5NDE3MzNiZDVkZGU1NzQzMzg3Nzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-26T05:44:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-26T05:44:26Z"}, "message": "Auto merge of #23691 - richo:dedup-typeorigin-mergable, r=eddyb\n\nI've started on refactoring the error handling code to avoid the need to reparse generated errors in `span_*`, but would rather land this incrementally as one monolithic PR (and have un-fond memories of merge conflicts from various other monoliths)\r\n\r\nr? @eddyb", "tree": {"sha": "89e65daf8a24fb0c292673e9fbac49c2e5883fa2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89e65daf8a24fb0c292673e9fbac49c2e5883fa2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0fd67b3e75dc2cc52a941733bd5dde574338779", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0fd67b3e75dc2cc52a941733bd5dde574338779", "html_url": "https://github.com/rust-lang/rust/commit/b0fd67b3e75dc2cc52a941733bd5dde574338779", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0fd67b3e75dc2cc52a941733bd5dde574338779/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4ba1caa99e63b14f6b4d0789344c7ad11100744", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4ba1caa99e63b14f6b4d0789344c7ad11100744", "html_url": "https://github.com/rust-lang/rust/commit/d4ba1caa99e63b14f6b4d0789344c7ad11100744"}, {"sha": "c193fe4f3c5a1e325ff5491b62094b7bf7036de7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c193fe4f3c5a1e325ff5491b62094b7bf7036de7", "html_url": "https://github.com/rust-lang/rust/commit/c193fe4f3c5a1e325ff5491b62094b7bf7036de7"}], "stats": {"total": 69, "additions": 40, "deletions": 29}, "files": [{"sha": "80e8ed47d305299a24db2908d4e9fc3fb1e7ec92", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 15, "deletions": 29, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b0fd67b3e75dc2cc52a941733bd5dde574338779/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0fd67b3e75dc2cc52a941733bd5dde574338779/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=b0fd67b3e75dc2cc52a941733bd5dde574338779", "patch": "@@ -357,23 +357,9 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n         };\n \n-        let message_root_str = match trace.origin {\n-            infer::Misc(_) => \"mismatched types\",\n-            infer::MethodCompatCheck(_) => \"method not compatible with trait\",\n-            infer::ExprAssignable(_) => \"mismatched types\",\n-            infer::RelateTraitRefs(_) => \"mismatched traits\",\n-            infer::RelateSelfType(_) => \"mismatched types\",\n-            infer::RelateOutputImplTypes(_) => \"mismatched types\",\n-            infer::MatchExpressionArm(_, _) => \"match arms have incompatible types\",\n-            infer::IfExpression(_) => \"if and else have incompatible types\",\n-            infer::IfExpressionWithNoElse(_) => \"if may be missing an else clause\",\n-            infer::RangeExpression(_) => \"start and end of range have incompatible types\",\n-            infer::EquatePredicate(_) => \"equality predicate not satisfied\",\n-        };\n-\n         span_err!(self.tcx.sess, trace.origin.span(), E0308,\n             \"{}: {} ({})\",\n-                 message_root_str,\n+                 trace.origin,\n                  expected_found_str,\n                  ty::type_err_to_str(self.tcx, terr));\n \n@@ -1495,38 +1481,38 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n             infer::Subtype(ref trace) => {\n                 let desc = match trace.origin {\n                     infer::Misc(_) => {\n-                        format!(\"types are compatible\")\n+                        \"types are compatible\"\n                     }\n                     infer::MethodCompatCheck(_) => {\n-                        format!(\"method type is compatible with trait\")\n+                        \"method type is compatible with trait\"\n                     }\n                     infer::ExprAssignable(_) => {\n-                        format!(\"expression is assignable\")\n+                        \"expression is assignable\"\n                     }\n                     infer::RelateTraitRefs(_) => {\n-                        format!(\"traits are compatible\")\n+                        \"traits are compatible\"\n                     }\n                     infer::RelateSelfType(_) => {\n-                        format!(\"self type matches impl self type\")\n+                        \"self type matches impl self type\"\n                     }\n                     infer::RelateOutputImplTypes(_) => {\n-                        format!(\"trait type parameters matches those \\\n-                                 specified on the impl\")\n+                        \"trait type parameters matches those \\\n+                                 specified on the impl\"\n                     }\n                     infer::MatchExpressionArm(_, _) => {\n-                        format!(\"match arms have compatible types\")\n+                        \"match arms have compatible types\"\n                     }\n                     infer::IfExpression(_) => {\n-                        format!(\"if and else have compatible types\")\n+                        \"if and else have compatible types\"\n                     }\n                     infer::IfExpressionWithNoElse(_) => {\n-                        format!(\"if may be missing an else clause\")\n+                        \"if may be missing an else clause\"\n                     }\n                     infer::RangeExpression(_) => {\n-                        format!(\"start and end of range have compatible types\")\n+                        \"start and end of range have compatible types\"\n                     }\n                     infer::EquatePredicate(_) => {\n-                        format!(\"equality where clause is satisfied\")\n+                        \"equality where clause is satisfied\"\n                     }\n                 };\n \n@@ -1666,8 +1652,8 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n             infer::RelateRegionParamBound(span) => {\n                 self.tcx.sess.span_note(\n                     span,\n-                    &format!(\"...so that the declared lifetime parameter bounds \\\n-                                are satisfied\"));\n+                    \"...so that the declared lifetime parameter bounds \\\n+                                are satisfied\");\n             }\n             infer::SafeDestructor(span) => {\n                 self.tcx.sess.span_note("}, {"sha": "8bd3ca826a6b202561d9a041ef26d70313c3ec01", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b0fd67b3e75dc2cc52a941733bd5dde574338779/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0fd67b3e75dc2cc52a941733bd5dde574338779/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=b0fd67b3e75dc2cc52a941733bd5dde574338779", "patch": "@@ -29,6 +29,7 @@ use middle::ty::replace_late_bound_regions;\n use middle::ty::{self, Ty};\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n use std::cell::{RefCell};\n+use std::fmt;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap;\n@@ -128,6 +129,30 @@ pub enum TypeOrigin {\n     EquatePredicate(Span),\n }\n \n+impl TypeOrigin {\n+    fn as_str(&self) -> &'static str {\n+        match self {\n+            &TypeOrigin::Misc(_) |\n+            &TypeOrigin::RelateSelfType(_) |\n+            &TypeOrigin::RelateOutputImplTypes(_) |\n+            &TypeOrigin::ExprAssignable(_) => \"mismatched types\",\n+            &TypeOrigin::RelateTraitRefs(_) => \"mismatched traits\",\n+            &TypeOrigin::MethodCompatCheck(_) => \"method not compatible with trait\",\n+            &TypeOrigin::MatchExpressionArm(_, _) => \"match arms have incompatible types\",\n+            &TypeOrigin::IfExpression(_) => \"if and else have incompatible types\",\n+            &TypeOrigin::IfExpressionWithNoElse(_) => \"if may be missing an else clause\",\n+            &TypeOrigin::RangeExpression(_) => \"start and end of range have incompatible types\",\n+            &TypeOrigin::EquatePredicate(_) => \"equality predicate not satisfied\",\n+        }\n+    }\n+}\n+\n+impl fmt::Display for TypeOrigin {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(),fmt::Error> {\n+        fmt::Display::fmt(self.as_str(), f)\n+    }\n+}\n+\n /// See `error_reporting.rs` for more details\n #[derive(Clone, Debug)]\n pub enum ValuePairs<'tcx> {"}]}