{"sha": "203d5dd0d0092b505db9efcff377fea154cbfe11", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwM2Q1ZGQwZDAwOTJiNTA1ZGI5ZWZjZmYzNzdmZWExNTRjYmZlMTE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-06-26T16:35:22Z"}, "committer": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-06-26T16:35:22Z"}, "message": "Merge #1443\n\n1443: cache chalk queries r=flodiebold a=matklad\n\nThis gives a significant speedup, because chalk will call these\r\nfunctions several times even withing a single revision. The only\r\nsignificant one here is `impl_data`, but I figured it might be good to\r\ncache others just for consistency.\r\n\r\nThe results I get are:\r\n\r\nBefore:\r\n\r\nfrom scratch:   16.081457952s\r\nno change:      15.846493ms\r\ntrivial change: 352.95592ms\r\ncomment change: 361.998408ms\r\nconst change:   457.629212ms\r\n\r\nAfter:\r\n\r\nfrom scratch:   14.910610278s\r\nno change:      14.934647ms\r\ntrivial change: 85.633023ms\r\ncomment change: 96.433023ms\r\nconst change:   171.543296ms\r\n\r\nSeems like a nice win!\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "80400bb1dc37c38bc2ce920ba616600a0d8b868d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80400bb1dc37c38bc2ce920ba616600a0d8b868d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/203d5dd0d0092b505db9efcff377fea154cbfe11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/203d5dd0d0092b505db9efcff377fea154cbfe11", "html_url": "https://github.com/rust-lang/rust/commit/203d5dd0d0092b505db9efcff377fea154cbfe11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/203d5dd0d0092b505db9efcff377fea154cbfe11/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "0cff7f84c64eb9e6524b0ecb27304b854d783ec1", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cff7f84c64eb9e6524b0ecb27304b854d783ec1", "html_url": "https://github.com/rust-lang/rust/commit/0cff7f84c64eb9e6524b0ecb27304b854d783ec1"}, {"sha": "a198d78bd1dafbfe78c597ff0deab17ac4d9092e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a198d78bd1dafbfe78c597ff0deab17ac4d9092e", "html_url": "https://github.com/rust-lang/rust/commit/a198d78bd1dafbfe78c597ff0deab17ac4d9092e"}], "stats": {"total": 434, "additions": 240, "deletions": 194}, "files": [{"sha": "a9840905c36547561a1c3c62fcadba50de28b504", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/203d5dd0d0092b505db9efcff377fea154cbfe11/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/203d5dd0d0092b505db9efcff377fea154cbfe11/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=203d5dd0d0092b505db9efcff377fea154cbfe11", "patch": "@@ -181,6 +181,26 @@ pub trait HirDatabase: DefDatabase + AstDatabase {\n     #[salsa::volatile]\n     fn solver(&self, krate: Crate) -> Arc<Mutex<crate::ty::traits::Solver>>;\n \n+    #[salsa::invoke(crate::ty::traits::chalk::associated_ty_data_query)]\n+    fn associated_ty_data(&self, id: chalk_ir::TypeId) -> Arc<chalk_rust_ir::AssociatedTyDatum>;\n+\n+    #[salsa::invoke(crate::ty::traits::chalk::trait_datum_query)]\n+    fn trait_datum(\n+        &self,\n+        krate: Crate,\n+        trait_id: chalk_ir::TraitId,\n+    ) -> Arc<chalk_rust_ir::TraitDatum>;\n+\n+    #[salsa::invoke(crate::ty::traits::chalk::struct_datum_query)]\n+    fn struct_datum(\n+        &self,\n+        krate: Crate,\n+        struct_id: chalk_ir::StructId,\n+    ) -> Arc<chalk_rust_ir::StructDatum>;\n+\n+    #[salsa::invoke(crate::ty::traits::chalk::impl_datum_query)]\n+    fn impl_datum(&self, krate: Crate, impl_id: chalk_ir::ImplId) -> Arc<chalk_rust_ir::ImplDatum>;\n+\n     #[salsa::invoke(crate::ty::traits::implements_query)]\n     fn implements(\n         &self,"}, {"sha": "69c03a36cdd6ff97517e7ab2f9a63503df51b724", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/203d5dd0d0092b505db9efcff377fea154cbfe11/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/203d5dd0d0092b505db9efcff377fea154cbfe11/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=203d5dd0d0092b505db9efcff377fea154cbfe11", "patch": "@@ -12,7 +12,7 @@ use super::{TraitRef, Ty, Canonical, ProjectionTy};\n \n use self::chalk::{ToChalk, from_chalk};\n \n-mod chalk;\n+pub(crate) mod chalk;\n \n pub(crate) type Solver = chalk_solve::Solver;\n "}, {"sha": "4ceb8b70bcbeba8bad22b4ac0f4ff78a38651e4a", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 219, "deletions": 193, "changes": 412, "blob_url": "https://github.com/rust-lang/rust/blob/203d5dd0d0092b505db9efcff377fea154cbfe11/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/203d5dd0d0092b505db9efcff377fea154cbfe11/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=203d5dd0d0092b505db9efcff377fea154cbfe11", "patch": "@@ -10,7 +10,7 @@ use test_utils::tested_by;\n use ra_db::salsa::{InternId, InternKey};\n \n use crate::{\n-    Trait, HasGenericParams, ImplBlock,\n+    Trait, HasGenericParams, ImplBlock, Crate,\n     db::HirDatabase,\n     ty::{TraitRef, Ty, ApplicationTy, TypeCtor, Substs, GenericPredicate, CallableDef, ProjectionTy},\n     ty::display::HirDisplay,\n@@ -256,204 +256,16 @@ where\n     DB: HirDatabase,\n {\n     fn associated_ty_data(&self, id: TypeId) -> Arc<AssociatedTyDatum> {\n-        debug!(\"associated_ty_data {:?}\", id);\n-        let type_alias: TypeAlias = from_chalk(self.db, id);\n-        let trait_ = match type_alias.container(self.db) {\n-            Some(crate::Container::Trait(t)) => t,\n-            _ => panic!(\"associated type not in trait\"),\n-        };\n-        let generic_params = type_alias.generic_params(self.db);\n-        let parameter_kinds = generic_params\n-            .params_including_parent()\n-            .into_iter()\n-            .map(|p| chalk_ir::ParameterKind::Ty(lalrpop_intern::intern(&p.name.to_string())))\n-            .collect();\n-        let datum = AssociatedTyDatum {\n-            trait_id: trait_.to_chalk(self.db),\n-            id,\n-            name: lalrpop_intern::intern(&type_alias.name(self.db).to_string()),\n-            parameter_kinds,\n-            // FIXME add bounds and where clauses\n-            bounds: vec![],\n-            where_clauses: vec![],\n-        };\n-        Arc::new(datum)\n+        self.db.associated_ty_data(id)\n     }\n     fn trait_datum(&self, trait_id: chalk_ir::TraitId) -> Arc<TraitDatum> {\n-        debug!(\"trait_datum {:?}\", trait_id);\n-        if trait_id == UNKNOWN_TRAIT {\n-            let trait_datum_bound = chalk_rust_ir::TraitDatumBound {\n-                trait_ref: chalk_ir::TraitRef {\n-                    trait_id: UNKNOWN_TRAIT,\n-                    parameters: vec![chalk_ir::Ty::BoundVar(0).cast()],\n-                },\n-                associated_ty_ids: Vec::new(),\n-                where_clauses: Vec::new(),\n-                flags: chalk_rust_ir::TraitFlags {\n-                    auto: false,\n-                    marker: false,\n-                    upstream: true,\n-                    fundamental: false,\n-                },\n-            };\n-            return Arc::new(TraitDatum { binders: make_binders(trait_datum_bound, 1) });\n-        }\n-        let trait_: Trait = from_chalk(self.db, trait_id);\n-        debug!(\"trait {:?} = {:?}\", trait_id, trait_.name(self.db));\n-        let generic_params = trait_.generic_params(self.db);\n-        let bound_vars = Substs::bound_vars(&generic_params);\n-        let trait_ref = trait_.trait_ref(self.db).subst(&bound_vars).to_chalk(self.db);\n-        let flags = chalk_rust_ir::TraitFlags {\n-            auto: trait_.is_auto(self.db),\n-            upstream: trait_.module(self.db).krate(self.db) != Some(self.krate),\n-            // FIXME set these flags correctly\n-            marker: false,\n-            fundamental: false,\n-        };\n-        let where_clauses = convert_where_clauses(self.db, trait_.into(), &bound_vars);\n-        let associated_ty_ids = trait_\n-            .items(self.db)\n-            .into_iter()\n-            .filter_map(|trait_item| match trait_item {\n-                crate::traits::TraitItem::TypeAlias(type_alias) => Some(type_alias),\n-                _ => None,\n-            })\n-            .map(|type_alias| type_alias.to_chalk(self.db))\n-            .collect();\n-        let trait_datum_bound =\n-            chalk_rust_ir::TraitDatumBound { trait_ref, where_clauses, flags, associated_ty_ids };\n-        let trait_datum = TraitDatum { binders: make_binders(trait_datum_bound, bound_vars.len()) };\n-        Arc::new(trait_datum)\n+        self.db.trait_datum(self.krate, trait_id)\n     }\n     fn struct_datum(&self, struct_id: chalk_ir::StructId) -> Arc<StructDatum> {\n-        debug!(\"struct_datum {:?}\", struct_id);\n-        let type_ctor = from_chalk(self.db, struct_id);\n-        debug!(\"struct {:?} = {:?}\", struct_id, type_ctor);\n-        // FIXME might be nicer if we can create a fake GenericParams for the TypeCtor\n-        // FIXME extract this to a method on Ty\n-        let (num_params, where_clauses, upstream) = match type_ctor {\n-            TypeCtor::Bool\n-            | TypeCtor::Char\n-            | TypeCtor::Int(_)\n-            | TypeCtor::Float(_)\n-            | TypeCtor::Never\n-            | TypeCtor::Str => (0, vec![], true),\n-            TypeCtor::Slice | TypeCtor::Array | TypeCtor::RawPtr(_) | TypeCtor::Ref(_) => {\n-                (1, vec![], true)\n-            }\n-            TypeCtor::FnPtr { num_args } => (num_args as usize + 1, vec![], true),\n-            TypeCtor::Tuple { cardinality } => (cardinality as usize, vec![], true),\n-            TypeCtor::FnDef(callable) => {\n-                tested_by!(trait_resolution_on_fn_type);\n-                let krate = match callable {\n-                    CallableDef::Function(f) => f.module(self.db).krate(self.db),\n-                    CallableDef::Struct(s) => s.module(self.db).krate(self.db),\n-                    CallableDef::EnumVariant(v) => {\n-                        v.parent_enum(self.db).module(self.db).krate(self.db)\n-                    }\n-                };\n-                let generic_def: GenericDef = match callable {\n-                    CallableDef::Function(f) => f.into(),\n-                    CallableDef::Struct(s) => s.into(),\n-                    CallableDef::EnumVariant(v) => v.parent_enum(self.db).into(),\n-                };\n-                let generic_params = generic_def.generic_params(self.db);\n-                let bound_vars = Substs::bound_vars(&generic_params);\n-                let where_clauses = convert_where_clauses(self.db, generic_def, &bound_vars);\n-                (\n-                    generic_params.count_params_including_parent(),\n-                    where_clauses,\n-                    krate != Some(self.krate),\n-                )\n-            }\n-            TypeCtor::Adt(adt) => {\n-                let generic_params = adt.generic_params(self.db);\n-                let bound_vars = Substs::bound_vars(&generic_params);\n-                let where_clauses = convert_where_clauses(self.db, adt.into(), &bound_vars);\n-                (\n-                    generic_params.count_params_including_parent(),\n-                    where_clauses,\n-                    adt.krate(self.db) != Some(self.krate),\n-                )\n-            }\n-        };\n-        let flags = chalk_rust_ir::StructFlags {\n-            upstream,\n-            // FIXME set fundamental flag correctly\n-            fundamental: false,\n-        };\n-        let self_ty = chalk_ir::ApplicationTy {\n-            name: TypeName::TypeKindId(type_ctor.to_chalk(self.db).into()),\n-            parameters: (0..num_params).map(|i| chalk_ir::Ty::BoundVar(i).cast()).collect(),\n-        };\n-        let struct_datum_bound = chalk_rust_ir::StructDatumBound {\n-            self_ty,\n-            fields: Vec::new(), // FIXME add fields (only relevant for auto traits)\n-            where_clauses,\n-            flags,\n-        };\n-        let struct_datum = StructDatum { binders: make_binders(struct_datum_bound, num_params) };\n-        Arc::new(struct_datum)\n+        self.db.struct_datum(self.krate, struct_id)\n     }\n     fn impl_datum(&self, impl_id: ImplId) -> Arc<ImplDatum> {\n-        debug!(\"impl_datum {:?}\", impl_id);\n-        let impl_block: ImplBlock = from_chalk(self.db, impl_id);\n-        let generic_params = impl_block.generic_params(self.db);\n-        let bound_vars = Substs::bound_vars(&generic_params);\n-        let trait_ref = impl_block\n-            .target_trait_ref(self.db)\n-            .expect(\"FIXME handle unresolved impl block trait ref\")\n-            .subst(&bound_vars);\n-        let impl_type = if impl_block.module().krate(self.db) == Some(self.krate) {\n-            chalk_rust_ir::ImplType::Local\n-        } else {\n-            chalk_rust_ir::ImplType::External\n-        };\n-        let where_clauses = convert_where_clauses(self.db, impl_block.into(), &bound_vars);\n-        let negative = impl_block.is_negative(self.db);\n-        debug!(\n-            \"impl {:?}: {}{} where {:?}\",\n-            impl_id,\n-            if negative { \"!\" } else { \"\" },\n-            trait_ref.display(self.db),\n-            where_clauses\n-        );\n-        let trait_ = trait_ref.trait_;\n-        let trait_ref = trait_ref.to_chalk(self.db);\n-        let associated_ty_values = impl_block\n-            .items(self.db)\n-            .into_iter()\n-            .filter_map(|item| match item {\n-                ImplItem::TypeAlias(t) => Some(t),\n-                _ => None,\n-            })\n-            .filter_map(|t| {\n-                let assoc_ty = trait_.associated_type_by_name(self.db, t.name(self.db))?;\n-                let ty = self.db.type_for_def(t.into(), crate::Namespace::Types).subst(&bound_vars);\n-                Some(chalk_rust_ir::AssociatedTyValue {\n-                    impl_id,\n-                    associated_ty_id: assoc_ty.to_chalk(self.db),\n-                    value: chalk_ir::Binders {\n-                        value: chalk_rust_ir::AssociatedTyValueBound { ty: ty.to_chalk(self.db) },\n-                        binders: vec![], // we don't support GATs yet\n-                    },\n-                })\n-            })\n-            .collect();\n-\n-        let impl_datum_bound = chalk_rust_ir::ImplDatumBound {\n-            trait_ref: if negative {\n-                chalk_rust_ir::PolarizedTraitRef::Negative(trait_ref)\n-            } else {\n-                chalk_rust_ir::PolarizedTraitRef::Positive(trait_ref)\n-            },\n-            where_clauses,\n-            associated_ty_values,\n-            impl_type,\n-        };\n-        debug!(\"impl_datum: {:?}\", impl_datum_bound);\n-        let impl_datum = ImplDatum { binders: make_binders(impl_datum_bound, bound_vars.len()) };\n-        Arc::new(impl_datum)\n+        self.db.impl_datum(self.krate, impl_id)\n     }\n     fn impls_for_trait(&self, trait_id: chalk_ir::TraitId) -> Vec<ImplId> {\n         debug!(\"impls_for_trait {:?}\", trait_id);\n@@ -503,6 +315,220 @@ where\n     }\n }\n \n+pub(crate) fn associated_ty_data_query(\n+    db: &impl HirDatabase,\n+    id: TypeId,\n+) -> Arc<AssociatedTyDatum> {\n+    debug!(\"associated_ty_data {:?}\", id);\n+    let type_alias: TypeAlias = from_chalk(db, id);\n+    let trait_ = match type_alias.container(db) {\n+        Some(crate::Container::Trait(t)) => t,\n+        _ => panic!(\"associated type not in trait\"),\n+    };\n+    let generic_params = type_alias.generic_params(db);\n+    let parameter_kinds = generic_params\n+        .params_including_parent()\n+        .into_iter()\n+        .map(|p| chalk_ir::ParameterKind::Ty(lalrpop_intern::intern(&p.name.to_string())))\n+        .collect();\n+    let datum = AssociatedTyDatum {\n+        trait_id: trait_.to_chalk(db),\n+        id,\n+        name: lalrpop_intern::intern(&type_alias.name(db).to_string()),\n+        parameter_kinds,\n+        // FIXME add bounds and where clauses\n+        bounds: vec![],\n+        where_clauses: vec![],\n+    };\n+    Arc::new(datum)\n+}\n+\n+pub(crate) fn trait_datum_query(\n+    db: &impl HirDatabase,\n+    krate: Crate,\n+    trait_id: chalk_ir::TraitId,\n+) -> Arc<TraitDatum> {\n+    debug!(\"trait_datum {:?}\", trait_id);\n+    if trait_id == UNKNOWN_TRAIT {\n+        let trait_datum_bound = chalk_rust_ir::TraitDatumBound {\n+            trait_ref: chalk_ir::TraitRef {\n+                trait_id: UNKNOWN_TRAIT,\n+                parameters: vec![chalk_ir::Ty::BoundVar(0).cast()],\n+            },\n+            associated_ty_ids: Vec::new(),\n+            where_clauses: Vec::new(),\n+            flags: chalk_rust_ir::TraitFlags {\n+                auto: false,\n+                marker: false,\n+                upstream: true,\n+                fundamental: false,\n+            },\n+        };\n+        return Arc::new(TraitDatum { binders: make_binders(trait_datum_bound, 1) });\n+    }\n+    let trait_: Trait = from_chalk(db, trait_id);\n+    debug!(\"trait {:?} = {:?}\", trait_id, trait_.name(db));\n+    let generic_params = trait_.generic_params(db);\n+    let bound_vars = Substs::bound_vars(&generic_params);\n+    let trait_ref = trait_.trait_ref(db).subst(&bound_vars).to_chalk(db);\n+    let flags = chalk_rust_ir::TraitFlags {\n+        auto: trait_.is_auto(db),\n+        upstream: trait_.module(db).krate(db) != Some(krate),\n+        // FIXME set these flags correctly\n+        marker: false,\n+        fundamental: false,\n+    };\n+    let where_clauses = convert_where_clauses(db, trait_.into(), &bound_vars);\n+    let associated_ty_ids = trait_\n+        .items(db)\n+        .into_iter()\n+        .filter_map(|trait_item| match trait_item {\n+            crate::traits::TraitItem::TypeAlias(type_alias) => Some(type_alias),\n+            _ => None,\n+        })\n+        .map(|type_alias| type_alias.to_chalk(db))\n+        .collect();\n+    let trait_datum_bound =\n+        chalk_rust_ir::TraitDatumBound { trait_ref, where_clauses, flags, associated_ty_ids };\n+    let trait_datum = TraitDatum { binders: make_binders(trait_datum_bound, bound_vars.len()) };\n+    Arc::new(trait_datum)\n+}\n+\n+pub(crate) fn struct_datum_query(\n+    db: &impl HirDatabase,\n+    krate: Crate,\n+    struct_id: chalk_ir::StructId,\n+) -> Arc<StructDatum> {\n+    debug!(\"struct_datum {:?}\", struct_id);\n+    let type_ctor = from_chalk(db, struct_id);\n+    debug!(\"struct {:?} = {:?}\", struct_id, type_ctor);\n+    // FIXME might be nicer if we can create a fake GenericParams for the TypeCtor\n+    // FIXME extract this to a method on Ty\n+    let (num_params, where_clauses, upstream) = match type_ctor {\n+        TypeCtor::Bool\n+        | TypeCtor::Char\n+        | TypeCtor::Int(_)\n+        | TypeCtor::Float(_)\n+        | TypeCtor::Never\n+        | TypeCtor::Str => (0, vec![], true),\n+        TypeCtor::Slice | TypeCtor::Array | TypeCtor::RawPtr(_) | TypeCtor::Ref(_) => {\n+            (1, vec![], true)\n+        }\n+        TypeCtor::FnPtr { num_args } => (num_args as usize + 1, vec![], true),\n+        TypeCtor::Tuple { cardinality } => (cardinality as usize, vec![], true),\n+        TypeCtor::FnDef(callable) => {\n+            tested_by!(trait_resolution_on_fn_type);\n+            let upstream = match callable {\n+                CallableDef::Function(f) => f.module(db).krate(db),\n+                CallableDef::Struct(s) => s.module(db).krate(db),\n+                CallableDef::EnumVariant(v) => v.parent_enum(db).module(db).krate(db),\n+            } != Some(krate);\n+            let generic_def: GenericDef = match callable {\n+                CallableDef::Function(f) => f.into(),\n+                CallableDef::Struct(s) => s.into(),\n+                CallableDef::EnumVariant(v) => v.parent_enum(db).into(),\n+            };\n+            let generic_params = generic_def.generic_params(db);\n+            let bound_vars = Substs::bound_vars(&generic_params);\n+            let where_clauses = convert_where_clauses(db, generic_def, &bound_vars);\n+            (generic_params.count_params_including_parent(), where_clauses, upstream)\n+        }\n+        TypeCtor::Adt(adt) => {\n+            let generic_params = adt.generic_params(db);\n+            let bound_vars = Substs::bound_vars(&generic_params);\n+            let where_clauses = convert_where_clauses(db, adt.into(), &bound_vars);\n+            (\n+                generic_params.count_params_including_parent(),\n+                where_clauses,\n+                adt.krate(db) != Some(krate),\n+            )\n+        }\n+    };\n+    let flags = chalk_rust_ir::StructFlags {\n+        upstream,\n+        // FIXME set fundamental flag correctly\n+        fundamental: false,\n+    };\n+    let self_ty = chalk_ir::ApplicationTy {\n+        name: TypeName::TypeKindId(type_ctor.to_chalk(db).into()),\n+        parameters: (0..num_params).map(|i| chalk_ir::Ty::BoundVar(i).cast()).collect(),\n+    };\n+    let struct_datum_bound = chalk_rust_ir::StructDatumBound {\n+        self_ty,\n+        fields: Vec::new(), // FIXME add fields (only relevant for auto traits)\n+        where_clauses,\n+        flags,\n+    };\n+    let struct_datum = StructDatum { binders: make_binders(struct_datum_bound, num_params) };\n+    Arc::new(struct_datum)\n+}\n+\n+pub(crate) fn impl_datum_query(\n+    db: &impl HirDatabase,\n+    krate: Crate,\n+    impl_id: ImplId,\n+) -> Arc<ImplDatum> {\n+    let _p = ra_prof::profile(\"impl_datum\");\n+    debug!(\"impl_datum {:?}\", impl_id);\n+    let impl_block: ImplBlock = from_chalk(db, impl_id);\n+    let generic_params = impl_block.generic_params(db);\n+    let bound_vars = Substs::bound_vars(&generic_params);\n+    let trait_ref = impl_block\n+        .target_trait_ref(db)\n+        .expect(\"FIXME handle unresolved impl block trait ref\")\n+        .subst(&bound_vars);\n+    let impl_type = if impl_block.module().krate(db) == Some(krate) {\n+        chalk_rust_ir::ImplType::Local\n+    } else {\n+        chalk_rust_ir::ImplType::External\n+    };\n+    let where_clauses = convert_where_clauses(db, impl_block.into(), &bound_vars);\n+    let negative = impl_block.is_negative(db);\n+    debug!(\n+        \"impl {:?}: {}{} where {:?}\",\n+        impl_id,\n+        if negative { \"!\" } else { \"\" },\n+        trait_ref.display(db),\n+        where_clauses\n+    );\n+    let trait_ = trait_ref.trait_;\n+    let trait_ref = trait_ref.to_chalk(db);\n+    let associated_ty_values = impl_block\n+        .items(db)\n+        .into_iter()\n+        .filter_map(|item| match item {\n+            ImplItem::TypeAlias(t) => Some(t),\n+            _ => None,\n+        })\n+        .filter_map(|t| {\n+            let assoc_ty = trait_.associated_type_by_name(db, t.name(db))?;\n+            let ty = db.type_for_def(t.into(), crate::Namespace::Types).subst(&bound_vars);\n+            Some(chalk_rust_ir::AssociatedTyValue {\n+                impl_id,\n+                associated_ty_id: assoc_ty.to_chalk(db),\n+                value: chalk_ir::Binders {\n+                    value: chalk_rust_ir::AssociatedTyValueBound { ty: ty.to_chalk(db) },\n+                    binders: vec![], // we don't support GATs yet\n+                },\n+            })\n+        })\n+        .collect();\n+\n+    let impl_datum_bound = chalk_rust_ir::ImplDatumBound {\n+        trait_ref: if negative {\n+            chalk_rust_ir::PolarizedTraitRef::Negative(trait_ref)\n+        } else {\n+            chalk_rust_ir::PolarizedTraitRef::Positive(trait_ref)\n+        },\n+        where_clauses,\n+        associated_ty_values,\n+        impl_type,\n+    };\n+    debug!(\"impl_datum: {:?}\", impl_datum_bound);\n+    let impl_datum = ImplDatum { binders: make_binders(impl_datum_bound, bound_vars.len()) };\n+    Arc::new(impl_datum)\n+}\n+\n fn id_from_chalk<T: InternKey>(chalk_id: chalk_ir::RawId) -> T {\n     T::from_intern_id(InternId::from(chalk_id.index))\n }"}]}