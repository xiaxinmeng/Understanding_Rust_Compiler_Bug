{"sha": "6c9f298a8bee9b1716b2e6fcdb8305c3f4874fc6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjOWYyOThhOGJlZTliMTcxNmIyZTZmY2RiODMwNWMzZjQ4NzRmYzY=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-09-30T19:19:22Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-10-03T18:55:18Z"}, "message": "review comments", "tree": {"sha": "c0eb4a39dad0af3208244a361f425bc7784bcfbd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0eb4a39dad0af3208244a361f425bc7784bcfbd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c9f298a8bee9b1716b2e6fcdb8305c3f4874fc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c9f298a8bee9b1716b2e6fcdb8305c3f4874fc6", "html_url": "https://github.com/rust-lang/rust/commit/6c9f298a8bee9b1716b2e6fcdb8305c3f4874fc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c9f298a8bee9b1716b2e6fcdb8305c3f4874fc6/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed60cf2475cabd3d9ad1afdc03bd6952d99b744c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed60cf2475cabd3d9ad1afdc03bd6952d99b744c", "html_url": "https://github.com/rust-lang/rust/commit/ed60cf2475cabd3d9ad1afdc03bd6952d99b744c"}], "stats": {"total": 87, "additions": 49, "deletions": 38}, "files": [{"sha": "584c7c2ded55bf8a43da365a7f0daf4203e64c67", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 49, "deletions": 38, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/6c9f298a8bee9b1716b2e6fcdb8305c3f4874fc6/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c9f298a8bee9b1716b2e6fcdb8305c3f4874fc6/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=6c9f298a8bee9b1716b2e6fcdb8305c3f4874fc6", "patch": "@@ -560,6 +560,7 @@ impl<'a> Parser<'a> {\n         );\n         match lhs.kind {\n             ExprKind::Binary(op, _, _) if op.node.is_comparison() => {\n+\n                 // Respan to include both operators.\n                 let op_span = op.span.to(self.prev_span);\n                 let mut err = self.struct_span_err(\n@@ -573,70 +574,63 @@ impl<'a> Parser<'a> {\n                     let msg = \"use `::<...>` instead of `<...>` if you meant to specify type \\\n                                arguments\";\n                     if *outer_op == AssocOp::Less {\n-                    // if self.look_ahead(1, |t| t.kind == token::Lt || t.kind == token::ModSep) {\n                         let snapshot = self.clone();\n                         self.bump();\n-                        // So far we have parsed `foo<bar<`\n-                        let mut acc = 1;\n-                        while acc > 0 {\n-                            match &self.token.kind {\n-                                token::Lt => {\n-                                    acc += 1;\n-                                }\n-                                token::Gt => {\n-                                    acc -= 1;\n-                                }\n-                                token::BinOp(token::Shr) => {\n-                                    acc -= 2;\n-                                }\n-                                token::Eof => {\n-                                    break;\n-                                }\n-                                _ => {}\n-                            }\n-                            self.bump();\n-                        }\n+                        // So far we have parsed `foo<bar<`, consume the rest of the type params\n+                        let modifiers = vec![\n+                            (token::Lt, 1),\n+                            (token::Gt, -1),\n+                            (token::BinOp(token::Shr), -2),\n+                        ];\n+                        let early_return = vec![token::Eof];\n+                        self.consume_tts(1, &modifiers[..], &early_return[..]);\n+\n                         if self.token.kind != token::OpenDelim(token::Paren) {\n+                            // We don't have `foo< bar >(`, so we rewind the parser and bail out.\n                             mem::replace(self, snapshot.clone());\n                         }\n                     }\n                     if self.token.kind == token::OpenDelim(token::Paren) {\n+                        // We have high certainty that this was a bad turbofish at this point.\n+                        // `foo< bar >(`\n                         err.span_suggestion(\n                             op_span.shrink_to_lo(),\n                             msg,\n                             \"::\".to_string(),\n                             Applicability::MaybeIncorrect,\n                         );\n+\n                         let snapshot = self.clone();\n-                        self.bump();\n-                        let mut acc = 1;\n-                        while acc > 0 {\n-                            match &self.token.kind {\n-                                token::OpenDelim(token::Paren) => {\n-                                    acc += 1;\n-                                }\n-                                token::CloseDelim(token::Paren) => {\n-                                    acc -= 1;\n-                                }\n-                                token::Eof => {\n-                                    break;\n-                                }\n-                                _ => {}\n-                            }\n-                            self.bump();\n-                        }\n+\n+                        // Consume the fn call arguments.\n+                        let modifiers = vec![\n+                            (token::OpenDelim(token::Paren), 1),\n+                            (token::CloseDelim(token::Paren), -1),\n+                        ];\n+                        let early_return = vec![token::Eof];\n+                        self.bump(); // `(`\n+                        self.consume_tts(1, &modifiers[..], &early_return[..]);\n+\n                         if self.token.kind == token::Eof {\n+                            // Not entirely sure now, but we bubble the error up with the\n+                            // suggestion.\n                             mem::replace(self, snapshot);\n                             return Err(err);\n                         } else {\n+                            // 99% certain that the suggestion is correct, continue parsing.\n                             err.emit();\n+                            // FIXME: actually check that the two expressions in the binop are\n+                            // paths and resynthesize new fn call expression instead of using\n+                            // `ExprKind::Err` placeholder.\n                             return Ok(Some(self.mk_expr(\n                                 lhs.span.to(self.prev_span),\n                                 ExprKind::Err,\n                                 ThinVec::new(),\n                             )));\n                         }\n                     } else {\n+                        // All we know is that this is `foo < bar >` and *nothing* else. Try to\n+                        // be helpful, but don't attempt to recover.\n                         err.help(msg);\n                         err.help(\"or use `(...)` if you meant to specify fn arguments\");\n                         // These cases cause too many knock-down errors, bail out (#61329).\n@@ -1424,6 +1418,23 @@ impl<'a> Parser<'a> {\n         err\n     }\n \n+    fn consume_tts(\n+        &mut self,\n+        mut acc: i64,\n+        modifier: &[(token::TokenKind, i64)], // Not using FxHasMap and FxHashSet due to\n+        early_return: &[token::TokenKind],    // `token::TokenKind: !Eq + !Hash`.\n+    ) {\n+        while acc > 0 {\n+            if let Some((_, val)) = modifier.iter().filter(|(t, _)| *t == self.token.kind).next() {\n+                acc += *val;\n+            }\n+            if early_return.contains(&self.token.kind) {\n+                break;\n+            }\n+            self.bump();\n+        }\n+    }\n+\n     /// Replace duplicated recovered parameters with `_` pattern to avoid unecessary errors.\n     ///\n     /// This is necessary because at this point we don't know whether we parsed a function with"}]}