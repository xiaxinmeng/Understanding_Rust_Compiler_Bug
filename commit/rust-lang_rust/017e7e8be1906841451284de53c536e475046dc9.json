{"sha": "017e7e8be1906841451284de53c536e475046dc9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxN2U3ZThiZTE5MDY4NDE0NTEyODRkZTUzYzUzNmU0NzUwNDZkYzk=", "commit": {"author": {"name": "Olivier Saut", "email": "osaut@airpost.net", "date": "2013-05-10T19:12:11Z"}, "committer": {"name": "Olivier Saut", "email": "osaut@airpost.net", "date": "2013-05-10T19:12:11Z"}, "message": "Replace io::println by println as it is now included in prelude.rs", "tree": {"sha": "54e32105a589a6edaa0c284a1750056f351c4b8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54e32105a589a6edaa0c284a1750056f351c4b8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/017e7e8be1906841451284de53c536e475046dc9", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/017e7e8be1906841451284de53c536e475046dc9", "html_url": "https://github.com/rust-lang/rust/commit/017e7e8be1906841451284de53c536e475046dc9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/017e7e8be1906841451284de53c536e475046dc9/comments", "author": null, "committer": null, "parents": [{"sha": "fdf601eaf3f6fcc727819f8c0ae2b44b30770a8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/fdf601eaf3f6fcc727819f8c0ae2b44b30770a8a", "html_url": "https://github.com/rust-lang/rust/commit/fdf601eaf3f6fcc727819f8c0ae2b44b30770a8a"}], "stats": {"total": 58, "additions": 27, "deletions": 31}, "files": [{"sha": "3582acbe0f6b8b617d34f1d0431b66ee8db4f83f", "filename": "doc/tutorial.md", "status": "modified", "additions": 27, "deletions": 31, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/017e7e8be1906841451284de53c536e475046dc9/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/017e7e8be1906841451284de53c536e475046dc9/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=017e7e8be1906841451284de53c536e475046dc9", "patch": "@@ -129,7 +129,7 @@ we have a file `hello.rs` containing this program:\n \n ~~~~\n fn main() {\n-    io::println(\"hello?\");\n+    println(\"hello?\");\n }\n ~~~~\n \n@@ -139,12 +139,12 @@ Windows) which, upon running, will likely do exactly what you expect.\n \n The Rust compiler tries to provide useful information when it encounters an\n error. If you introduce an error into the program (for example, by changing\n-`io::println` to some nonexistent function), and then compile it, you'll see\n+`println` to some nonexistent function), and then compile it, you'll see\n an error message like this:\n \n ~~~~ {.notrust}\n-hello.rs:2:4: 2:16 error: unresolved name: io::print_with_unicorns\n-hello.rs:2     io::print_with_unicorns(\"hello?\");\n+hello.rs:2:4: 2:16 error: unresolved name: print_with_unicorns\n+hello.rs:2     print_with_unicorns(\"hello?\");\n                ^~~~~~~~~~~~~~~~~~~~~~~\n ~~~~\n \n@@ -227,7 +227,7 @@ let hi = \"hi\";\n let mut count = 0;\n \n while count < 10 {\n-    io::println(fmt!(\"count: %?\", count));\n+    println(fmt!(\"count: %?\", count));\n     count += 1;\n }\n ~~~~\n@@ -400,10 +400,10 @@ don't match the types of the arguments.\n ~~~~\n # let mystery_object = ();\n \n-io::println(fmt!(\"%s is %d\", \"the answer\", 43));\n+println(fmt!(\"%s is %d\", \"the answer\", 43));\n \n // %? will conveniently print any type\n-io::println(fmt!(\"what is this thing: %?\", mystery_object));\n+println(fmt!(\"what is this thing: %?\", mystery_object));\n ~~~~\n \n [pf]: http://en.cppreference.com/w/cpp/io/c/fprintf\n@@ -422,11 +422,11 @@ compulsory, an `if` can have an optional `else` clause, and multiple\n \n ~~~~\n if false {\n-    io::println(\"that's odd\");\n+    println(\"that's odd\");\n } else if true {\n-    io::println(\"right\");\n+    println(\"right\");\n } else {\n-    io::println(\"neither true nor false\");\n+    println(\"neither true nor false\");\n }\n ~~~~\n \n@@ -454,10 +454,10 @@ executes its corresponding arm.\n ~~~~\n # let my_number = 1;\n match my_number {\n-  0     => io::println(\"zero\"),\n-  1 | 2 => io::println(\"one or two\"),\n-  3..10 => io::println(\"three to ten\"),\n-  _     => io::println(\"something else\")\n+  0     => println(\"zero\"),\n+  1 | 2 => println(\"one or two\"),\n+  3..10 => println(\"three to ten\"),\n+  _     => println(\"something else\")\n }\n ~~~~\n \n@@ -483,8 +483,8 @@ commas are optional.\n ~~~\n # let my_number = 1;\n match my_number {\n-  0 => { io::println(\"zero\") }\n-  _ => { io::println(\"something else\") }\n+  0 => { println(\"zero\") }\n+  _ => { println(\"something else\") }\n }\n ~~~\n \n@@ -560,7 +560,7 @@ let mut x = 5;\n loop {\n     x += x - 3;\n     if x % 5 == 0 { break; }\n-    io::println(int::to_str(x));\n+    println(int::to_str(x));\n }\n ~~~~\n \n@@ -614,8 +614,8 @@ origin.y += 1.0; // ERROR: assigning to immutable field\n # struct Point { x: float, y: float }\n # let mypoint = Point { x: 0.0, y: 0.0 };\n match mypoint {\n-    Point { x: 0.0, y: yy } => { io::println(yy.to_str());                     }\n-    Point { x: xx,  y: yy } => { io::println(xx.to_str() + \" \" + yy.to_str()); }\n+    Point { x: 0.0, y: yy } => { println(yy.to_str());                     }\n+    Point { x: xx,  y: yy } => { println(xx.to_str() + \" \" + yy.to_str()); }\n }\n ~~~~\n \n@@ -630,7 +630,7 @@ reuses the field name as the binding name.\n # struct Point { x: float, y: float }\n # let mypoint = Point { x: 0.0, y: 0.0 };\n match mypoint {\n-    Point { x, _ } => { io::println(x.to_str()) }\n+    Point { x, _ } => { println(x.to_str()) }\n }\n ~~~\n \n@@ -1231,7 +1231,7 @@ something silly like\n ~~~\n # struct Point { x: float, y: float }\n let point = &@~Point { x: 10f, y: 20f };\n-io::println(fmt!(\"%f\", point.x));\n+println(fmt!(\"%f\", point.x));\n ~~~\n \n The indexing operator (`[]`) also auto-dereferences.\n@@ -1373,7 +1373,6 @@ and [`core::str`]. Here are some examples.\n [`core::str`]: core/str.html\n \n ~~~\n-# use core::io::println;\n # enum Crayon {\n #     Almond, AntiqueBrass, Apricot,\n #     Aquamarine, Asparagus, AtomicTangerine,\n@@ -1428,7 +1427,6 @@ Rust also supports _closures_, functions that can access variables in\n the enclosing scope.\n \n ~~~~\n-# use println = core::io::println;\n fn call_closure_with_ten(b: &fn(int)) { b(10); }\n \n let captured_var = 20;\n@@ -1490,7 +1488,7 @@ fn mk_appender(suffix: ~str) -> @fn(~str) -> ~str {\n \n fn main() {\n     let shout = mk_appender(~\"!\");\n-    io::println(shout(~\"hey ho, let's go\"));\n+    println(shout(~\"hey ho, let's go\"));\n }\n ~~~~\n \n@@ -1632,7 +1630,6 @@ And using this function to iterate over a vector:\n \n ~~~~\n # use each = core::vec::each;\n-# use println = core::io::println;\n each([2, 4, 8, 5, 16], |n| {\n     if *n % 2 != 0 {\n         println(\"found odd number!\");\n@@ -1649,7 +1646,6 @@ to the next iteration, write `loop`.\n \n ~~~~\n # use each = core::vec::each;\n-# use println = core::io::println;\n for each([2, 4, 8, 5, 16]) |n| {\n     if *n % 2 != 0 {\n         println(\"found odd number!\");\n@@ -1982,7 +1978,7 @@ struct TimeBomb {\n impl Drop for TimeBomb {\n     fn finalize(&self) {\n         for old_iter::repeat(self.explosivity) {\n-            io::println(\"blam!\");\n+            println(\"blam!\");\n         }\n     }\n }\n@@ -2014,11 +2010,11 @@ and `~str`.\n ~~~~\n # trait Printable { fn print(&self); }\n impl Printable for int {\n-    fn print(&self) { io::println(fmt!(\"%d\", *self)) }\n+    fn print(&self) { println(fmt!(\"%d\", *self)) }\n }\n \n impl Printable for ~str {\n-    fn print(&self) { io::println(*self) }\n+    fn print(&self) { println(*self) }\n }\n \n # 1.print();\n@@ -2307,7 +2303,7 @@ mod farm {\n }\n \n fn main() {\n-    io::println(farm::chicken());\n+    println(farm::chicken());\n }\n ~~~~\n \n@@ -2507,7 +2503,7 @@ pub fn explore() -> &str { \"world\" }\n ~~~~ {.xfail-test}\n // main.rs\n extern mod world;\n-fn main() { io::println(~\"hello \" + world::explore()); }\n+fn main() { println(~\"hello \" + world::explore()); }\n ~~~~\n \n Now compile and run like this (adjust to your platform if necessary):"}]}