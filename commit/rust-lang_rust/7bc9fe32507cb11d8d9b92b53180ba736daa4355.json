{"sha": "7bc9fe32507cb11d8d9b92b53180ba736daa4355", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiYzlmZTMyNTA3Y2IxMWQ4ZDliOTJiNTMxODBiYTczNmRhYTQzNTU=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-03-19T23:15:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-03-19T23:15:19Z"}, "message": "Rollup merge of #49092 - mark-i-m:deptrack_readme, r=nikomatsakis\n\nReplace many of the last references to readmes\n\nIn particular, this removes the dep track readme, so it should not be merged before https://github.com/rust-lang-nursery/rustc-guide/pull/92\n\nFix #47935\n\ncc #48478\n\nr? @nikomatsakis", "tree": {"sha": "f903a599bac6758fd5ec28d26447d31a678169b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f903a599bac6758fd5ec28d26447d31a678169b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bc9fe32507cb11d8d9b92b53180ba736daa4355", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJasESHCRBK7hj4Ov3rIwAAdHIIACbMcY8+Y6eFpkpeyZz4XD5v\nG3bhKSh5FvAkMEYoyUV+OJDMJkLZF0DQfmPzGpgE6XJZp+sX9ifeYaRZd06FKuOF\njp7khURD1pvJJUK1DhTlsEizxCX6Q1tgSjtEnaKwujv+VH4ZsA4RiEG64ElX87NV\n/NtBuo36zm6BVQbpvtgWXMYra0apInPJm+1yaGK4FTYJM/l+Wmsjq/yif+8dBeAT\n8Re92un7AXBkFf27c3gG5UFGvboTh4HYwodmuvR9CucFHnzUZ+hLdJvkkKFg+1I7\nbHUPQ+rTOQiJUpnpJ3HqKMB3p3l16gjNE/U6tf/xcZo5gLZNodju81A7SAHJmnI=\n=00Py\n-----END PGP SIGNATURE-----\n", "payload": "tree f903a599bac6758fd5ec28d26447d31a678169b0\nparent 28eced1cb503e036350c55526e2dfd58a13f5fc6\nparent 50f2884dcdc0c9ba8f24b0c2014f60cb85b0e717\nauthor kennytm <kennytm@gmail.com> 1521501319 +0800\ncommitter GitHub <noreply@github.com> 1521501319 +0800\n\nRollup merge of #49092 - mark-i-m:deptrack_readme, r=nikomatsakis\n\nReplace many of the last references to readmes\n\nIn particular, this removes the dep track readme, so it should not be merged before https://github.com/rust-lang-nursery/rustc-guide/pull/92\n\nFix #47935\n\ncc #48478\n\nr? @nikomatsakis\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bc9fe32507cb11d8d9b92b53180ba736daa4355", "html_url": "https://github.com/rust-lang/rust/commit/7bc9fe32507cb11d8d9b92b53180ba736daa4355", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bc9fe32507cb11d8d9b92b53180ba736daa4355/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28eced1cb503e036350c55526e2dfd58a13f5fc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/28eced1cb503e036350c55526e2dfd58a13f5fc6", "html_url": "https://github.com/rust-lang/rust/commit/28eced1cb503e036350c55526e2dfd58a13f5fc6"}, {"sha": "50f2884dcdc0c9ba8f24b0c2014f60cb85b0e717", "url": "https://api.github.com/repos/rust-lang/rust/commits/50f2884dcdc0c9ba8f24b0c2014f60cb85b0e717", "html_url": "https://github.com/rust-lang/rust/commit/50f2884dcdc0c9ba8f24b0c2014f60cb85b0e717"}], "stats": {"total": 383, "additions": 56, "deletions": 327}, "files": [{"sha": "f1f383d7ad1262f5c5ae2cf30852d812286314fe", "filename": "src/librustc/dep_graph/README.md", "status": "modified", "additions": 3, "deletions": 294, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/7bc9fe32507cb11d8d9b92b53180ba736daa4355/src%2Flibrustc%2Fdep_graph%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/7bc9fe32507cb11d8d9b92b53180ba736daa4355/src%2Flibrustc%2Fdep_graph%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2FREADME.md?ref=7bc9fe32507cb11d8d9b92b53180ba736daa4355", "patch": "@@ -1,295 +1,4 @@\n-# Dependency graph for incremental compilation\n+To learn more about how dependency tracking works in rustc, see the [rustc\n+guide].\n \n-This module contains the infrastructure for managing the incremental\n-compilation dependency graph. This README aims to explain how it ought\n-to be used. In this document, we'll first explain the overall\n-strategy, and then share some tips for handling specific scenarios.\n-\n-The high-level idea is that we want to instrument the compiler to\n-track which parts of the AST and other IR are read/written by what.\n-This way, when we come back later, we can look at this graph and\n-determine what work needs to be redone.\n-\n-### The dependency graph\n-\n-The nodes of the graph are defined by the enum `DepNode`. They represent\n-one of three things:\n-\n-1. HIR nodes (like `Hir(DefId)`) represent the HIR input itself.\n-2. Data nodes (like `TypeOfItem(DefId)`) represent some computed\n-   information about a particular item.\n-3. Procedure nodes (like `CoherenceCheckTrait(DefId)`) represent some\n-   procedure that is executing. Usually this procedure is\n-   performing some kind of check for errors. You can think of them as\n-   computed values where the value being computed is `()` (and the\n-   value may fail to be computed, if an error results).\n-\n-An edge `N1 -> N2` is added between two nodes if either:\n-\n-- the value of `N1` is used to compute `N2`;\n-- `N1` is read by the procedure `N2`;\n-- the procedure `N1` writes the value `N2`.\n-\n-The latter two conditions are equivalent to the first one if you think\n-of procedures as values.\n-\n-### Basic tracking\n-\n-There is a very general strategy to ensure that you have a correct, if\n-sometimes overconservative, dependency graph. The two main things you have\n-to do are (a) identify shared state and (b) identify the current tasks.\n-\n-### Identifying shared state\n-\n-Identify \"shared state\" that will be written by one pass and read by\n-another. In particular, we need to identify shared state that will be\n-read \"across items\" -- that is, anything where changes in one item\n-could invalidate work done for other items. So, for example:\n-\n-1. The signature for a function is \"shared state\".\n-2. The computed type of some expression in the body of a function is\n-   not shared state, because if it changes it does not itself\n-   invalidate other functions (though it may be that it causes new\n-   monomorphizations to occur, but that's handled independently).\n-\n-Put another way: if the HIR for an item changes, we are going to\n-recompile that item for sure. But we need the dep tracking map to tell\n-us what *else* we have to recompile. Shared state is anything that is\n-used to communicate results from one item to another.\n-\n-### Identifying the current task, tracking reads/writes, etc\n-\n-FIXME(#42293). This text needs to be rewritten for the new red-green\n-system, which doesn't fully exist yet.\n-\n-#### Dependency tracking map\n-\n-`DepTrackingMap` is a particularly convenient way to correctly store\n-shared state. A `DepTrackingMap` is a special hashmap that will add\n-edges automatically when `get` and `insert` are called. The idea is\n-that, when you get/insert a value for the key `K`, we will add an edge\n-from/to the node `DepNode::Variant(K)` (for some variant specific to\n-the map).\n-\n-Each `DepTrackingMap` is parameterized by a special type `M` that\n-implements `DepTrackingMapConfig`; this trait defines the key and value\n-types of the map, and also defines a fn for converting from the key to\n-a `DepNode` label. You don't usually have to muck about with this by\n-hand, there is a macro for creating it. You can see the complete set\n-of `DepTrackingMap` definitions in `librustc/middle/ty/maps.rs`.\n-\n-As an example, let's look at the `adt_defs` map. The `adt_defs` map\n-maps from the def-id of a struct/enum to its `AdtDef`. It is defined\n-using this macro:\n-\n-```rust\n-dep_map_ty! { AdtDefs: ItemSignature(DefId) -> ty::AdtDefMaster<'tcx> }\n-//            ~~~~~~~  ~~~~~~~~~~~~~ ~~~~~     ~~~~~~~~~~~~~~~~~~~~~~\n-//               |           |      Key type       Value type\n-//               |    DepNode variant\n-//      Name of map id type\n-```\n-\n-this indicates that a map id type `AdtDefs` will be created. The key\n-of the map will be a `DefId` and value will be\n-`ty::AdtDefMaster<'tcx>`. The `DepNode` will be created by\n-`DepNode::ItemSignature(K)` for a given key.\n-\n-Once that is done, you can just use the `DepTrackingMap` like any\n-other map:\n-\n-```rust\n-let mut map: DepTrackingMap<M> = DepTrackingMap::new(dep_graph);\n-map.insert(key, value); // registers dep_graph.write\n-map.get(key; // registers dep_graph.read\n-```\n-\n-#### Memoization\n-\n-One particularly interesting case is memoization. If you have some\n-shared state that you compute in a memoized fashion, the correct thing\n-to do is to define a `RefCell<DepTrackingMap>` for it and use the\n-`memoize` helper:\n-\n-```rust\n-map.memoize(key, || /* compute value */)\n-```\n-\n-This will create a graph that looks like\n-\n-    ... -> MapVariant(key) -> CurrentTask\n-\n-where `MapVariant` is the `DepNode` variant that the map is associated with,\n-and `...` are whatever edges the `/* compute value */` closure creates.\n-\n-In particular, using the memoize helper is much better than writing\n-the obvious code yourself:\n-\n-```rust\n-if let Some(result) = map.get(key) {\n-    return result;\n-}\n-let value = /* compute value */;\n-map.insert(key, value);\n-```\n-\n-If you write that code manually, the dependency graph you get will\n-include artificial edges that are not necessary. For example, imagine that\n-two tasks, A and B, both invoke the manual memoization code, but A happens\n-to go first. The resulting graph will be:\n-\n-    ... -> A -> MapVariant(key) -> B\n-    ~~~~~~~~~~~~~~~~~~~~~~~~~~~       // caused by A writing to MapVariant(key)\n-                ~~~~~~~~~~~~~~~~~~~~  // caused by B reading from MapVariant(key)\n-\n-This graph is not *wrong*, but it encodes a path from A to B that\n-should not exist.  In contrast, using the memoized helper, you get:\n-\n-    ... -> MapVariant(key) -> A\n-                 |\n-                 +----------> B\n-\n-which is much cleaner.\n-\n-**Be aware though that the closure is executed with `MapVariant(key)`\n-pushed onto the stack as the current task!** That means that you must\n-add explicit `read` calls for any shared state that it accesses\n-implicitly from its environment. See the section on \"explicit calls to\n-read and write when starting a new subtask\" above for more details.\n-\n-### How to decide where to introduce a new task\n-\n-Certainly, you need at least one task on the stack: any attempt to\n-`read` or `write` shared state will panic if there is no current\n-task. But where does it make sense to introduce subtasks? The basic\n-rule is that a subtask makes sense for any discrete unit of work you\n-may want to skip in the future. Adding a subtask separates out the\n-reads/writes from *that particular subtask* versus the larger\n-context. An example: you might have a 'meta' task for all of borrow\n-checking, and then subtasks for borrow checking individual fns.  (Seen\n-in this light, memoized computations are just a special case where we\n-may want to avoid redoing the work even within the context of one\n-compilation.)\n-\n-The other case where you might want a subtask is to help with refining\n-the reads/writes for some later bit of work that needs to be memoized.\n-For example, we create a subtask for type-checking the body of each\n-fn.  However, in the initial version of incr. comp. at least, we do\n-not expect to actually *SKIP* type-checking -- we only expect to skip\n-trans. However, it's still useful to create subtasks for type-checking\n-individual items, because, otherwise, if a fn sig changes, we won't\n-know which callers are affected -- in fact, because the graph would be\n-so coarse, we'd just have to retrans everything, since we can't\n-distinguish which fns used which fn sigs.\n-\n-### Testing the dependency graph\n-\n-There are various ways to write tests against the dependency graph.\n-The simplest mechanism are the\n-`#[rustc_if_this_changed]` and `#[rustc_then_this_would_need]`\n-annotations. These are used in compile-fail tests to test whether the\n-expected set of paths exist in the dependency graph. As an example,\n-see `src/test/compile-fail/dep-graph-caller-callee.rs`.\n-\n-The idea is that you can annotate a test like:\n-\n-```rust\n-#[rustc_if_this_changed]\n-fn foo() { }\n-\n-#[rustc_then_this_would_need(TypeckTables)] //~ ERROR OK\n-fn bar() { foo(); }\n-\n-#[rustc_then_this_would_need(TypeckTables)] //~ ERROR no path\n-fn baz() { }\n-```\n-\n-This will check whether there is a path in the dependency graph from\n-`Hir(foo)` to `TypeckTables(bar)`. An error is reported for each\n-`#[rustc_then_this_would_need]` annotation that indicates whether a\n-path exists. `//~ ERROR` annotations can then be used to test if a\n-path is found (as demonstrated above).\n-\n-### Debugging the dependency graph\n-\n-#### Dumping the graph\n-\n-The compiler is also capable of dumping the dependency graph for your\n-debugging pleasure. To do so, pass the `-Z dump-dep-graph` flag. The\n-graph will be dumped to `dep_graph.{txt,dot}` in the current\n-directory.  You can override the filename with the `RUST_DEP_GRAPH`\n-environment variable.\n-\n-Frequently, though, the full dep graph is quite overwhelming and not\n-particularly helpful. Therefore, the compiler also allows you to filter\n-the graph. You can filter in three ways:\n-\n-1. All edges originating in a particular set of nodes (usually a single node).\n-2. All edges reaching a particular set of nodes.\n-3. All edges that lie between given start and end nodes.\n-\n-To filter, use the `RUST_DEP_GRAPH_FILTER` environment variable, which should\n-look like one of the following:\n-\n-```\n-source_filter     // nodes originating from source_filter\n--> target_filter  // nodes that can reach target_filter\n-source_filter -> target_filter // nodes in between source_filter and target_filter\n-```\n-\n-`source_filter` and `target_filter` are a `&`-separated list of strings.\n-A node is considered to match a filter if all of those strings appear in its\n-label. So, for example:\n-\n-```\n-RUST_DEP_GRAPH_FILTER='-> TypeckTables'\n-```\n-\n-would select the predecessors of all `TypeckTables` nodes. Usually though you\n-want the `TypeckTables` node for some particular fn, so you might write:\n-\n-```\n-RUST_DEP_GRAPH_FILTER='-> TypeckTables & bar'\n-```\n-\n-This will select only the `TypeckTables` nodes for fns with `bar` in their name.\n-\n-Perhaps you are finding that when you change `foo` you need to re-type-check `bar`,\n-but you don't think you should have to. In that case, you might do:\n-\n-```\n-RUST_DEP_GRAPH_FILTER='Hir&foo -> TypeckTables & bar'\n-```\n-\n-This will dump out all the nodes that lead from `Hir(foo)` to\n-`TypeckTables(bar)`, from which you can (hopefully) see the source\n-of the erroneous edge.\n-\n-#### Tracking down incorrect edges\n-\n-Sometimes, after you dump the dependency graph, you will find some\n-path that should not exist, but you will not be quite sure how it came\n-to be. **When the compiler is built with debug assertions,** it can\n-help you track that down. Simply set the `RUST_FORBID_DEP_GRAPH_EDGE`\n-environment variable to a filter. Every edge created in the dep-graph\n-will be tested against that filter -- if it matches, a `bug!` is\n-reported, so you can easily see the backtrace (`RUST_BACKTRACE=1`).\n-\n-The syntax for these filters is the same as described in the previous\n-section. However, note that this filter is applied to every **edge**\n-and doesn't handle longer paths in the graph, unlike the previous\n-section.\n-\n-Example:\n-\n-You find that there is a path from the `Hir` of `foo` to the type\n-check of `bar` and you don't think there should be. You dump the\n-dep-graph as described in the previous section and open `dep-graph.txt`\n-to see something like:\n-\n-    Hir(foo) -> Collect(bar)\n-    Collect(bar) -> TypeckTables(bar)\n-\n-That first edge looks suspicious to you. So you set\n-`RUST_FORBID_DEP_GRAPH_EDGE` to `Hir&foo -> Collect&bar`, re-run, and\n-then observe the backtrace. Voila, bug fixed!\n+[rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/query.html"}, {"sha": "d44f2ec95492f9592456577a4158042ff2a74c90", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7bc9fe32507cb11d8d9b92b53180ba736daa4355/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc9fe32507cb11d8d9b92b53180ba736daa4355/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=7bc9fe32507cb11d8d9b92b53180ba736daa4355", "patch": "@@ -580,7 +580,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// the pop occurs as part of the rollback, so an explicit call is not\n     /// needed (but is also permitted).\n     ///\n-    /// See `README.md` for more details.\n+    /// For more information about how skolemization for HRTBs works, see\n+    /// the [rustc guide].\n+    ///\n+    /// [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/trait-hrtb.html\n     pub fn skolemize_late_bound_regions<T>(&self,\n                                            binder: &ty::Binder<T>,\n                                            snapshot: &CombinedSnapshot<'a, 'tcx>)"}, {"sha": "0086aed3e7c975b94b41d8b2646139b55be56dca", "filename": "src/librustc/infer/lexical_region_resolve/README.md", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bc9fe32507cb11d8d9b92b53180ba736daa4355/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/7bc9fe32507cb11d8d9b92b53180ba736daa4355/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2FREADME.md?ref=7bc9fe32507cb11d8d9b92b53180ba736daa4355", "patch": "@@ -1,14 +1,16 @@\n # Region inference\n \n+> WARNING: This README is obsolete and will be removed soon! For\n+> more info on how the current borrowck works, see the [rustc guide].\n+\n+[rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/mir-borrowck.html\n+\n ## Terminology\n \n Note that we use the terms region and lifetime interchangeably.\n \n ## Introduction\n \n-See the [general inference README](../README.md) for an overview of\n-how lexical-region-solving fits into the bigger picture.\n-\n Region inference uses a somewhat more involved algorithm than type\n inference. It is not the most efficient thing ever written though it\n seems to work well enough in practice (famous last words).  The reason"}, {"sha": "07b87e2012dde775df98f09d6c502d3ec8a8aed0", "filename": "src/librustc/infer/region_constraints/README.md", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7bc9fe32507cb11d8d9b92b53180ba736daa4355/src%2Flibrustc%2Finfer%2Fregion_constraints%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/7bc9fe32507cb11d8d9b92b53180ba736daa4355/src%2Flibrustc%2Finfer%2Fregion_constraints%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2FREADME.md?ref=7bc9fe32507cb11d8d9b92b53180ba736daa4355", "patch": "@@ -1,18 +1,25 @@\n # Region constraint collection\n \n+> WARNING: This README is obsolete and will be removed soon! For\n+> more info on how the current borrowck works, see the [rustc guide].\n+\n+[rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/mir-borrowck.html\n+\n ## Terminology\n \n Note that we use the terms region and lifetime interchangeably.\n \n ## Introduction\n \n-As described in the [inference README](../README.md), and unlike\n+As described in the rustc guide [chapter on type inference][ti], and unlike\n normal type inference, which is similar in spirit to H-M and thus\n works progressively, the region type inference works by accumulating\n constraints over the course of a function.  Finally, at the end of\n processing a function, we process and solve the constraints all at\n once.\n \n+[ti]: https://rust-lang-nursery.github.io/rustc-guide/type-inference.html\n+\n The constraints are always of one of three possible forms:\n \n - `ConstrainVarSubVar(Ri, Rj)` states that region variable Ri must be"}, {"sha": "e864485539b2d65f3555966fabcd2d704b64e52b", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bc9fe32507cb11d8d9b92b53180ba736daa4355/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc9fe32507cb11d8d9b92b53180ba736daa4355/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=7bc9fe32507cb11d8d9b92b53180ba736daa4355", "patch": "@@ -468,8 +468,10 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n     /// the APIs in `higher_ranked/mod.rs`, such as\n     /// `skolemize_late_bound_regions` and `plug_leaks`, which will\n     /// guide you on this path (ensure that the `SkolemizationMap` is\n-    /// consumed and you are good).  There are also somewhat extensive\n-    /// comments in `higher_ranked/README.md`.\n+    /// consumed and you are good). For more info on how skolemization\n+    /// for HRTBs works, see the [rustc guide].\n+    ///\n+    /// [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/trait-hrtb.html\n     ///\n     /// The `snapshot` argument to this function is not really used;\n     /// it's just there to make it explicit which snapshot bounds the"}, {"sha": "966353b53a95aefa875399f02271ebdf8aee23a5", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bc9fe32507cb11d8d9b92b53180ba736daa4355/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc9fe32507cb11d8d9b92b53180ba736daa4355/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=7bc9fe32507cb11d8d9b92b53180ba736daa4355", "patch": "@@ -402,12 +402,10 @@ fn visit_local<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, local: &'tcx hir::Local) {\n \n fn visit_arm<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, arm: &'tcx hir::Arm) {\n     for pat in &arm.pats {\n-        // for struct patterns, take note of which fields used shorthand (`x`\n-        // rather than `x: x`)\n+        // for struct patterns, take note of which fields used shorthand (`x` rather than `x: x`)\n         //\n-        // FIXME: according to the rust-lang-nursery/rustc-guide book and\n-        // librustc/README.md, `NodeId`s are to be phased out in favor of\n-        // `HirId`s; however, we need to match the signature of `each_binding`,\n+        // FIXME: according to the rust-lang-nursery/rustc-guide book, `NodeId`s are to be phased\n+        // out in favor of `HirId`s; however, we need to match the signature of `each_binding`,\n         // which uses `NodeIds`.\n         let mut shorthand_field_ids = NodeSet();\n         if let hir::PatKind::Struct(_, ref fields, _) = pat.node {"}, {"sha": "c7396b34c4689548bd413d4ec8e71b24268105a2", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bc9fe32507cb11d8d9b92b53180ba736daa4355/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc9fe32507cb11d8d9b92b53180ba736daa4355/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=7bc9fe32507cb11d8d9b92b53180ba736daa4355", "patch": "@@ -11,8 +11,10 @@\n //! This file builds up the `ScopeTree`, which describes\n //! the parent links in the region hierarchy.\n //!\n-//! Most of the documentation on regions can be found in\n-//! `middle/infer/region_constraints/README.md`\n+//! For more information about how MIR-based region-checking works,\n+//! see the [rustc guide].\n+//!\n+//! [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/mir-borrowck.html\n \n use ich::{StableHashingContext, NodeIdHashingMode};\n use util::nodemap::{FxHashMap, FxHashSet};"}, {"sha": "64a1729982a3168aae8757340c5fbfcc3da40ce5", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bc9fe32507cb11d8d9b92b53180ba736daa4355/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc9fe32507cb11d8d9b92b53180ba736daa4355/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=7bc9fe32507cb11d8d9b92b53180ba736daa4355", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! MIR datatypes and passes. See the module-level [README] for details.\n+//! MIR datatypes and passes. See the [rustc guide] for more info.\n //!\n-//! [README]: https://github.com/rust-lang/rust/blob/master/src/librustc/mir/README.md\n+//! [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/mir.html\n \n use graphviz::IntoCow;\n use middle::const_val::ConstVal;"}, {"sha": "bb5c7b5fd2a5e0eddf38a9a041837c7415450109", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7bc9fe32507cb11d8d9b92b53180ba736daa4355/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc9fe32507cb11d8d9b92b53180ba736daa4355/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=7bc9fe32507cb11d8d9b92b53180ba736daa4355", "patch": "@@ -991,10 +991,11 @@ pub type Region<'tcx> = &'tcx RegionKind;\n /// the inference variable is supposed to satisfy the relation\n /// *for every value of the skolemized region*. To ensure that doesn't\n /// happen, you can use `leak_check`. This is more clearly explained\n-/// by infer/higher_ranked/README.md.\n+/// by the [rustc guide].\n ///\n /// [1]: http://smallcultfollowing.com/babysteps/blog/2013/10/29/intermingled-parameter-lists/\n /// [2]: http://smallcultfollowing.com/babysteps/blog/2013/11/04/intermingled-parameter-lists/\n+/// [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/trait-hrtb.html\n #[derive(Clone, PartialEq, Eq, Hash, Copy, RustcEncodable, RustcDecodable, PartialOrd, Ord)]\n pub enum RegionKind {\n     // Region bound in a type or fn declaration which will be"}, {"sha": "3c01692c12b3c846957c15f44d2746158808e1f8", "filename": "src/librustc_back/README.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bc9fe32507cb11d8d9b92b53180ba736daa4355/src%2Flibrustc_back%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/7bc9fe32507cb11d8d9b92b53180ba736daa4355/src%2Flibrustc_back%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2FREADME.md?ref=7bc9fe32507cb11d8d9b92b53180ba736daa4355", "patch": "@@ -1,6 +1,6 @@\n-NB: This crate is part of the Rust compiler. For an overview of the\n-compiler as a whole, see\n-[the README.md file found in `librustc`](../librustc/README.md).\n-\n `librustc_back` contains some very low-level details that are\n specific to different LLVM targets and so forth.\n+\n+For more information about how trans works, see the [rustc guide].\n+\n+[rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/trans.html"}, {"sha": "29f03c06ab75999c5048b74340ee2a87b8cf60b0", "filename": "src/librustc_borrowck/borrowck/README.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7bc9fe32507cb11d8d9b92b53180ba736daa4355/src%2Flibrustc_borrowck%2Fborrowck%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/7bc9fe32507cb11d8d9b92b53180ba736daa4355/src%2Flibrustc_borrowck%2Fborrowck%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2FREADME.md?ref=7bc9fe32507cb11d8d9b92b53180ba736daa4355", "patch": "@@ -1,5 +1,10 @@\n % The Borrow Checker\n \n+> WARNING: This README is more or less obsolete, and will be removed\n+> soon! The new system is described in the [rustc guide].\n+\n+[rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/mir-borrowck.html\n+\n This pass has the job of enforcing memory safety. This is a subtle\n topic. This docs aim to explain both the practice and the theory\n behind the borrow checker. They start with a high-level overview of"}, {"sha": "fef249a9e4eb8e02936c99691908a8f20772965a", "filename": "src/librustc_driver/README.md", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bc9fe32507cb11d8d9b92b53180ba736daa4355/src%2Flibrustc_driver%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/7bc9fe32507cb11d8d9b92b53180ba736daa4355/src%2Flibrustc_driver%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FREADME.md?ref=7bc9fe32507cb11d8d9b92b53180ba736daa4355", "patch": "@@ -1,12 +1,10 @@\n-NB: This crate is part of the Rust compiler. For an overview of the\n-compiler as a whole, see\n-[the README.md file found in `librustc`](../librustc/README.md).\n-\n The `driver` crate is effectively the \"main\" function for the rust\n compiler.  It orchestrates the compilation process and \"knits together\"\n the code from the other crates within rustc. This crate itself does\n not contain any of the \"main logic\" of the compiler (though it does\n have some code related to pretty printing or other minor compiler\n options).\n \n+For more information about how the driver works, see the [rustc guide].\n \n+[rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/rustc-driver.html"}, {"sha": "d1868ba2abb1722760356eb4812c20173ebe063b", "filename": "src/librustc_trans/README.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bc9fe32507cb11d8d9b92b53180ba736daa4355/src%2Flibrustc_trans%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/7bc9fe32507cb11d8d9b92b53180ba736daa4355/src%2Flibrustc_trans%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FREADME.md?ref=7bc9fe32507cb11d8d9b92b53180ba736daa4355", "patch": "@@ -1,7 +1,7 @@\n-NB: This crate is part of the Rust compiler. For an overview of the\n-compiler as a whole, see\n-[the README.md file found in `librustc`](../librustc/README.md).\n-\n The `trans` crate contains the code to convert from MIR into LLVM IR,\n and then from LLVM IR into machine code. In general it contains code\n that runs towards the end of the compilation process.\n+\n+For more information about how trans works, see the [rustc guide].\n+\n+[rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/trans.html"}, {"sha": "7214203830e7457b1bea2c1317779bc7cbd8d4a2", "filename": "src/libsyntax/README.md", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7bc9fe32507cb11d8d9b92b53180ba736daa4355/src%2Flibsyntax%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/7bc9fe32507cb11d8d9b92b53180ba736daa4355/src%2Flibsyntax%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2FREADME.md?ref=7bc9fe32507cb11d8d9b92b53180ba736daa4355", "patch": "@@ -1,7 +1,9 @@\n-NB: This crate is part of the Rust compiler. For an overview of the\n-compiler as a whole, see\n-[the README.md file found in `librustc`](../librustc/README.md).\n-\n The `syntax` crate contains those things concerned purely with syntax\n \u2013 that is, the AST (\"abstract syntax tree\"), parser, pretty-printer,\n lexer, macro expander, and utilities for traversing ASTs.\n+\n+For more information about how these things work in rustc, see the\n+rustc guide:\n+\n+- [Parsing](https://rust-lang-nursery.github.io/rustc-guide/the-parser.html)\n+- [Macro Expansion](https://rust-lang-nursery.github.io/rustc-guide/macro-expansion.html)"}]}