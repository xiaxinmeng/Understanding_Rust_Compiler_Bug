{"sha": "7732ad85df5a8fe0d6176aa08e6b86e6636561d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3MzJhZDg1ZGY1YThmZTBkNjE3NmFhMDhlNmI4NmU2NjM2NTYxZDE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-09-03T13:29:56Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-09-03T15:28:07Z"}, "message": "Move lints to HIR", "tree": {"sha": "9756c49ba5b14abaab3425a0252af039ce9ff5de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9756c49ba5b14abaab3425a0252af039ce9ff5de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7732ad85df5a8fe0d6176aa08e6b86e6636561d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7732ad85df5a8fe0d6176aa08e6b86e6636561d1", "html_url": "https://github.com/rust-lang/rust/commit/7732ad85df5a8fe0d6176aa08e6b86e6636561d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7732ad85df5a8fe0d6176aa08e6b86e6636561d1/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1661947014fc2ecbbb7a30b1604499500dcf767e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1661947014fc2ecbbb7a30b1604499500dcf767e", "html_url": "https://github.com/rust-lang/rust/commit/1661947014fc2ecbbb7a30b1604499500dcf767e"}], "stats": {"total": 665, "additions": 328, "deletions": 337}, "files": [{"sha": "67be93cc2bdc6425ea6b62e704702a17b09db8d8", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 44, "deletions": 47, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/7732ad85df5a8fe0d6176aa08e6b86e6636561d1/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732ad85df5a8fe0d6176aa08e6b86e6636561d1/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=7732ad85df5a8fe0d6176aa08e6b86e6636561d1", "patch": "@@ -37,12 +37,14 @@ use std::cell::RefCell;\n use std::cmp;\n use std::mem;\n use syntax::ast_util::IdVisitingOperation;\n-use syntax::attr::AttrMetaMethods;\n-use syntax::attr;\n+use rustc_front::attr::{self, AttrMetaMethods};\n+use rustc_front::util;\n use syntax::codemap::Span;\n-use syntax::visit::{Visitor, FnKind};\n use syntax::parse::token::InternedString;\n-use syntax::{ast, ast_util, visit};\n+use syntax::ast;\n+use rustc_front::hir;\n+use rustc_front::visit::{self, Visitor, FnKind};\n+use syntax::visit::Visitor as SyntaxVisitor;\n use syntax::diagnostic;\n \n /// Information about the registered lints.\n@@ -252,7 +254,7 @@ pub struct Context<'a, 'tcx: 'a> {\n     pub tcx: &'a ty::ctxt<'tcx>,\n \n     /// The crate being checked.\n-    pub krate: &'a ast::Crate,\n+    pub krate: &'a hir::Crate,\n \n     /// Items exported from the crate being checked.\n     pub exported_items: &'a ExportedItems,\n@@ -284,7 +286,7 @@ macro_rules! run_lints { ($cx:expr, $f:ident, $($args:expr),*) => ({\n /// Parse the lint attributes into a vector, with `Err`s for malformed lint\n /// attributes. Writing this as an iterator is an enormous mess.\n // See also the hir version just below.\n-pub fn gather_attrs(attrs: &[ast::Attribute])\n+pub fn gather_attrs(attrs: &[hir::Attribute])\n                     -> Vec<Result<(InternedString, Level, Span), Span>> {\n     let mut out = vec!();\n     for attr in attrs {\n@@ -297,7 +299,7 @@ pub fn gather_attrs(attrs: &[ast::Attribute])\n \n         let meta = &attr.node.value;\n         let metas = match meta.node {\n-            ast::MetaList(_, ref metas) => metas,\n+            hir::MetaList(_, ref metas) => metas,\n             _ => {\n                 out.push(Err(meta.span));\n                 continue;\n@@ -306,7 +308,7 @@ pub fn gather_attrs(attrs: &[ast::Attribute])\n \n         for meta in metas {\n             out.push(match meta.node {\n-                ast::MetaWord(ref lint_name) => Ok((lint_name.clone(), level, meta.span)),\n+                hir::MetaWord(ref lint_name) => Ok((lint_name.clone(), level, meta.span)),\n                 _ => Err(meta.span),\n             });\n         }\n@@ -398,7 +400,7 @@ pub fn raw_emit_lint(sess: &Session, lint: &'static Lint,\n \n impl<'a, 'tcx> Context<'a, 'tcx> {\n     fn new(tcx: &'a ty::ctxt<'tcx>,\n-           krate: &'a ast::Crate,\n+           krate: &'a hir::Crate,\n            exported_items: &'a ExportedItems) -> Context<'a, 'tcx> {\n         // We want to own the lint store, so move it out of the session.\n         let lint_store = mem::replace(&mut *tcx.sess.lint_store.borrow_mut(),\n@@ -452,7 +454,7 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n     /// current lint context, call the provided function, then reset the\n     /// lints in effect to their previous state.\n     fn with_lint_attrs<F>(&mut self,\n-                          attrs: &[ast::Attribute],\n+                          attrs: &[hir::Attribute],\n                           f: F) where\n         F: FnOnce(&mut Context),\n     {\n@@ -519,9 +521,9 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n     }\n \n     fn visit_ids<F>(&mut self, f: F) where\n-        F: FnOnce(&mut ast_util::IdVisitor<Context>)\n+        F: FnOnce(&mut util::IdVisitor<Context>)\n     {\n-        let mut v = ast_util::IdVisitor {\n+        let mut v = util::IdVisitor {\n             operation: self,\n             pass_through_items: false,\n             visited_outermost: false,\n@@ -531,68 +533,68 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n-    fn visit_item(&mut self, it: &ast::Item) {\n+    fn visit_item(&mut self, it: &hir::Item) {\n         self.with_lint_attrs(&it.attrs, |cx| {\n             run_lints!(cx, check_item, it);\n             cx.visit_ids(|v| v.visit_item(it));\n             visit::walk_item(cx, it);\n         })\n     }\n \n-    fn visit_foreign_item(&mut self, it: &ast::ForeignItem) {\n+    fn visit_foreign_item(&mut self, it: &hir::ForeignItem) {\n         self.with_lint_attrs(&it.attrs, |cx| {\n             run_lints!(cx, check_foreign_item, it);\n             visit::walk_foreign_item(cx, it);\n         })\n     }\n \n-    fn visit_pat(&mut self, p: &ast::Pat) {\n+    fn visit_pat(&mut self, p: &hir::Pat) {\n         run_lints!(self, check_pat, p);\n         visit::walk_pat(self, p);\n     }\n \n-    fn visit_expr(&mut self, e: &ast::Expr) {\n+    fn visit_expr(&mut self, e: &hir::Expr) {\n         run_lints!(self, check_expr, e);\n         visit::walk_expr(self, e);\n     }\n \n-    fn visit_stmt(&mut self, s: &ast::Stmt) {\n+    fn visit_stmt(&mut self, s: &hir::Stmt) {\n         run_lints!(self, check_stmt, s);\n         visit::walk_stmt(self, s);\n     }\n \n-    fn visit_fn(&mut self, fk: FnKind<'v>, decl: &'v ast::FnDecl,\n-                body: &'v ast::Block, span: Span, id: ast::NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'v>, decl: &'v hir::FnDecl,\n+                body: &'v hir::Block, span: Span, id: ast::NodeId) {\n         run_lints!(self, check_fn, fk, decl, body, span, id);\n         visit::walk_fn(self, fk, decl, body, span);\n     }\n \n     fn visit_struct_def(&mut self,\n-                        s: &ast::StructDef,\n+                        s: &hir::StructDef,\n                         ident: ast::Ident,\n-                        g: &ast::Generics,\n+                        g: &hir::Generics,\n                         id: ast::NodeId) {\n         run_lints!(self, check_struct_def, s, ident, g, id);\n         visit::walk_struct_def(self, s);\n         run_lints!(self, check_struct_def_post, s, ident, g, id);\n     }\n \n-    fn visit_struct_field(&mut self, s: &ast::StructField) {\n+    fn visit_struct_field(&mut self, s: &hir::StructField) {\n         self.with_lint_attrs(&s.node.attrs, |cx| {\n             run_lints!(cx, check_struct_field, s);\n             visit::walk_struct_field(cx, s);\n         })\n     }\n \n-    fn visit_variant(&mut self, v: &ast::Variant, g: &ast::Generics) {\n+    fn visit_variant(&mut self, v: &hir::Variant, g: &hir::Generics) {\n         self.with_lint_attrs(&v.node.attrs, |cx| {\n             run_lints!(cx, check_variant, v, g);\n             visit::walk_variant(cx, v, g);\n             run_lints!(cx, check_variant_post, v, g);\n         })\n     }\n \n-    fn visit_ty(&mut self, t: &ast::Ty) {\n+    fn visit_ty(&mut self, t: &hir::Ty) {\n         run_lints!(self, check_ty, t);\n         visit::walk_ty(self, t);\n     }\n@@ -601,84 +603,79 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n         run_lints!(self, check_ident, sp, id);\n     }\n \n-    fn visit_mod(&mut self, m: &ast::Mod, s: Span, n: ast::NodeId) {\n+    fn visit_mod(&mut self, m: &hir::Mod, s: Span, n: ast::NodeId) {\n         run_lints!(self, check_mod, m, s, n);\n         visit::walk_mod(self, m);\n     }\n \n-    fn visit_local(&mut self, l: &ast::Local) {\n+    fn visit_local(&mut self, l: &hir::Local) {\n         run_lints!(self, check_local, l);\n         visit::walk_local(self, l);\n     }\n \n-    fn visit_block(&mut self, b: &ast::Block) {\n+    fn visit_block(&mut self, b: &hir::Block) {\n         run_lints!(self, check_block, b);\n         visit::walk_block(self, b);\n     }\n \n-    fn visit_arm(&mut self, a: &ast::Arm) {\n+    fn visit_arm(&mut self, a: &hir::Arm) {\n         run_lints!(self, check_arm, a);\n         visit::walk_arm(self, a);\n     }\n \n-    fn visit_decl(&mut self, d: &ast::Decl) {\n+    fn visit_decl(&mut self, d: &hir::Decl) {\n         run_lints!(self, check_decl, d);\n         visit::walk_decl(self, d);\n     }\n \n-    fn visit_expr_post(&mut self, e: &ast::Expr) {\n+    fn visit_expr_post(&mut self, e: &hir::Expr) {\n         run_lints!(self, check_expr_post, e);\n     }\n \n-    fn visit_generics(&mut self, g: &ast::Generics) {\n+    fn visit_generics(&mut self, g: &hir::Generics) {\n         run_lints!(self, check_generics, g);\n         visit::walk_generics(self, g);\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n+    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n         self.with_lint_attrs(&trait_item.attrs, |cx| {\n             run_lints!(cx, check_trait_item, trait_item);\n             cx.visit_ids(|v| v.visit_trait_item(trait_item));\n             visit::walk_trait_item(cx, trait_item);\n         });\n     }\n \n-    fn visit_impl_item(&mut self, impl_item: &ast::ImplItem) {\n+    fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {\n         self.with_lint_attrs(&impl_item.attrs, |cx| {\n             run_lints!(cx, check_impl_item, impl_item);\n             cx.visit_ids(|v| v.visit_impl_item(impl_item));\n             visit::walk_impl_item(cx, impl_item);\n         });\n     }\n \n-    fn visit_opt_lifetime_ref(&mut self, sp: Span, lt: &Option<ast::Lifetime>) {\n+    fn visit_opt_lifetime_ref(&mut self, sp: Span, lt: &Option<hir::Lifetime>) {\n         run_lints!(self, check_opt_lifetime_ref, sp, lt);\n     }\n \n-    fn visit_lifetime_ref(&mut self, lt: &ast::Lifetime) {\n+    fn visit_lifetime_ref(&mut self, lt: &hir::Lifetime) {\n         run_lints!(self, check_lifetime_ref, lt);\n     }\n \n-    fn visit_lifetime_def(&mut self, lt: &ast::LifetimeDef) {\n+    fn visit_lifetime_def(&mut self, lt: &hir::LifetimeDef) {\n         run_lints!(self, check_lifetime_def, lt);\n     }\n \n-    fn visit_explicit_self(&mut self, es: &ast::ExplicitSelf) {\n+    fn visit_explicit_self(&mut self, es: &hir::ExplicitSelf) {\n         run_lints!(self, check_explicit_self, es);\n         visit::walk_explicit_self(self, es);\n     }\n \n-    fn visit_mac(&mut self, mac: &ast::Mac) {\n-        run_lints!(self, check_mac, mac);\n-        visit::walk_mac(self, mac);\n-    }\n-\n-    fn visit_path(&mut self, p: &ast::Path, id: ast::NodeId) {\n+    fn visit_path(&mut self, p: &hir::Path, id: ast::NodeId) {\n         run_lints!(self, check_path, p, id);\n         visit::walk_path(self, p);\n     }\n \n-    fn visit_attribute(&mut self, attr: &ast::Attribute) {\n+    fn visit_attribute(&mut self, attr: &hir::Attribute) {\n         run_lints!(self, check_attribute, attr);\n     }\n }\n@@ -709,9 +706,9 @@ impl LintPass for GatherNodeLevels {\n         lint_array!()\n     }\n \n-    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n         match it.node {\n-            ast::ItemEnum(..) => {\n+            hir::ItemEnum(..) => {\n                 let lint_id = LintId::of(builtin::VARIANT_SIZE_DIFFERENCES);\n                 let lvlsrc = cx.lints.get_level_source(lint_id);\n                 match lvlsrc {\n@@ -731,7 +728,7 @@ impl LintPass for GatherNodeLevels {\n ///\n /// Consumes the `lint_store` field of the `Session`.\n pub fn check_crate(tcx: &ty::ctxt,\n-                   krate: &ast::Crate,\n+                   krate: &hir::Crate,\n                    exported_items: &ExportedItems) {\n \n     let mut cx = Context::new(tcx, krate, exported_items);"}, {"sha": "2b3a6c6e287f9e0912b84a0304b284e19c76434a", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/7732ad85df5a8fe0d6176aa08e6b86e6636561d1/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732ad85df5a8fe0d6176aa08e6b86e6636561d1/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=7732ad85df5a8fe0d6176aa08e6b86e6636561d1", "patch": "@@ -34,8 +34,9 @@ pub use self::LintSource::*;\n use std::hash;\n use std::ascii::AsciiExt;\n use syntax::codemap::Span;\n-use syntax::visit::FnKind;\n+use rustc_front::visit::FnKind;\n use syntax::ast;\n+use rustc_front::hir;\n \n pub use lint::context::{Context, LintStore, raw_emit_lint, check_crate, gather_attrs,\n                         gather_attrs_from_hir, GatherNodeLevels};\n@@ -125,46 +126,46 @@ pub trait LintPass {\n     /// `Lint`, make it a private `static` item in its own module.\n     fn get_lints(&self) -> LintArray;\n \n-    fn check_crate(&mut self, _: &Context, _: &ast::Crate) { }\n+    fn check_crate(&mut self, _: &Context, _: &hir::Crate) { }\n     fn check_ident(&mut self, _: &Context, _: Span, _: ast::Ident) { }\n-    fn check_mod(&mut self, _: &Context, _: &ast::Mod, _: Span, _: ast::NodeId) { }\n-    fn check_foreign_item(&mut self, _: &Context, _: &ast::ForeignItem) { }\n-    fn check_item(&mut self, _: &Context, _: &ast::Item) { }\n-    fn check_local(&mut self, _: &Context, _: &ast::Local) { }\n-    fn check_block(&mut self, _: &Context, _: &ast::Block) { }\n-    fn check_stmt(&mut self, _: &Context, _: &ast::Stmt) { }\n-    fn check_arm(&mut self, _: &Context, _: &ast::Arm) { }\n-    fn check_pat(&mut self, _: &Context, _: &ast::Pat) { }\n-    fn check_decl(&mut self, _: &Context, _: &ast::Decl) { }\n-    fn check_expr(&mut self, _: &Context, _: &ast::Expr) { }\n-    fn check_expr_post(&mut self, _: &Context, _: &ast::Expr) { }\n-    fn check_ty(&mut self, _: &Context, _: &ast::Ty) { }\n-    fn check_generics(&mut self, _: &Context, _: &ast::Generics) { }\n+    fn check_mod(&mut self, _: &Context, _: &hir::Mod, _: Span, _: ast::NodeId) { }\n+    fn check_foreign_item(&mut self, _: &Context, _: &hir::ForeignItem) { }\n+    fn check_item(&mut self, _: &Context, _: &hir::Item) { }\n+    fn check_local(&mut self, _: &Context, _: &hir::Local) { }\n+    fn check_block(&mut self, _: &Context, _: &hir::Block) { }\n+    fn check_stmt(&mut self, _: &Context, _: &hir::Stmt) { }\n+    fn check_arm(&mut self, _: &Context, _: &hir::Arm) { }\n+    fn check_pat(&mut self, _: &Context, _: &hir::Pat) { }\n+    fn check_decl(&mut self, _: &Context, _: &hir::Decl) { }\n+    fn check_expr(&mut self, _: &Context, _: &hir::Expr) { }\n+    fn check_expr_post(&mut self, _: &Context, _: &hir::Expr) { }\n+    fn check_ty(&mut self, _: &Context, _: &hir::Ty) { }\n+    fn check_generics(&mut self, _: &Context, _: &hir::Generics) { }\n     fn check_fn(&mut self, _: &Context,\n-        _: FnKind, _: &ast::FnDecl, _: &ast::Block, _: Span, _: ast::NodeId) { }\n-    fn check_trait_item(&mut self, _: &Context, _: &ast::TraitItem) { }\n-    fn check_impl_item(&mut self, _: &Context, _: &ast::ImplItem) { }\n+        _: FnKind, _: &hir::FnDecl, _: &hir::Block, _: Span, _: ast::NodeId) { }\n+    fn check_trait_item(&mut self, _: &Context, _: &hir::TraitItem) { }\n+    fn check_impl_item(&mut self, _: &Context, _: &hir::ImplItem) { }\n     fn check_struct_def(&mut self, _: &Context,\n-        _: &ast::StructDef, _: ast::Ident, _: &ast::Generics, _: ast::NodeId) { }\n+        _: &hir::StructDef, _: ast::Ident, _: &hir::Generics, _: ast::NodeId) { }\n     fn check_struct_def_post(&mut self, _: &Context,\n-        _: &ast::StructDef, _: ast::Ident, _: &ast::Generics, _: ast::NodeId) { }\n-    fn check_struct_field(&mut self, _: &Context, _: &ast::StructField) { }\n-    fn check_variant(&mut self, _: &Context, _: &ast::Variant, _: &ast::Generics) { }\n-    fn check_variant_post(&mut self, _: &Context, _: &ast::Variant, _: &ast::Generics) { }\n-    fn check_opt_lifetime_ref(&mut self, _: &Context, _: Span, _: &Option<ast::Lifetime>) { }\n-    fn check_lifetime_ref(&mut self, _: &Context, _: &ast::Lifetime) { }\n-    fn check_lifetime_def(&mut self, _: &Context, _: &ast::LifetimeDef) { }\n-    fn check_explicit_self(&mut self, _: &Context, _: &ast::ExplicitSelf) { }\n+        _: &hir::StructDef, _: ast::Ident, _: &hir::Generics, _: ast::NodeId) { }\n+    fn check_struct_field(&mut self, _: &Context, _: &hir::StructField) { }\n+    fn check_variant(&mut self, _: &Context, _: &hir::Variant, _: &hir::Generics) { }\n+    fn check_variant_post(&mut self, _: &Context, _: &hir::Variant, _: &hir::Generics) { }\n+    fn check_opt_lifetime_ref(&mut self, _: &Context, _: Span, _: &Option<hir::Lifetime>) { }\n+    fn check_lifetime_ref(&mut self, _: &Context, _: &hir::Lifetime) { }\n+    fn check_lifetime_def(&mut self, _: &Context, _: &hir::LifetimeDef) { }\n+    fn check_explicit_self(&mut self, _: &Context, _: &hir::ExplicitSelf) { }\n     fn check_mac(&mut self, _: &Context, _: &ast::Mac) { }\n-    fn check_path(&mut self, _: &Context, _: &ast::Path, _: ast::NodeId) { }\n-    fn check_attribute(&mut self, _: &Context, _: &ast::Attribute) { }\n+    fn check_path(&mut self, _: &Context, _: &hir::Path, _: ast::NodeId) { }\n+    fn check_attribute(&mut self, _: &Context, _: &hir::Attribute) { }\n \n     /// Called when entering a syntax node that can have lint attributes such\n     /// as `#[allow(...)]`. Called with *all* the attributes of that node.\n-    fn enter_lint_attrs(&mut self, _: &Context, _: &[ast::Attribute]) { }\n+    fn enter_lint_attrs(&mut self, _: &Context, _: &[hir::Attribute]) { }\n \n     /// Counterpart to `enter_lint_attrs`.\n-    fn exit_lint_attrs(&mut self, _: &Context, _: &[ast::Attribute]) { }\n+    fn exit_lint_attrs(&mut self, _: &Context, _: &[hir::Attribute]) { }\n }\n \n /// A lint pass boxed up as a trait object."}, {"sha": "dad20e0a24fb2b96259662b359c086abf78cb39a", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7732ad85df5a8fe0d6176aa08e6b86e6636561d1/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732ad85df5a8fe0d6176aa08e6b86e6636561d1/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=7732ad85df5a8fe0d6176aa08e6b86e6636561d1", "patch": "@@ -761,7 +761,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: Session,\n                 &tcx.sess, lib_features_used));\n \n         time(time_passes, \"lint checking\", ||\n-            lint::check_crate(tcx, ast_crate, &exported_items));\n+            lint::check_crate(tcx, &lower_crate(ast_crate), &exported_items));\n \n         // The above three passes generate errors w/o aborting\n         tcx.sess.abort_if_errors();"}, {"sha": "c8ffe0766061114d63e7aaa745e9100d93e7713b", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 242, "deletions": 248, "changes": 490, "blob_url": "https://github.com/rust-lang/rust/blob/7732ad85df5a8fe0d6176aa08e6b86e6636561d1/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732ad85df5a8fe0d6176aa08e6b86e6636561d1/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=7732ad85df5a8fe0d6176aa08e6b86e6636561d1", "patch": "@@ -45,21 +45,19 @@ use std::{cmp, slice};\n use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n \n use syntax::{abi, ast};\n-use syntax::ast_util::is_shift_binop;\n-use syntax::attr::{self, AttrMetaMethods};\n+use syntax::attr as syntax_attr;\n use syntax::codemap::{self, Span};\n use syntax::feature_gate::{KNOWN_ATTRIBUTES, AttributeType};\n-use syntax::ast::{TyIs, TyUs, TyI8, TyU8, TyI16, TyU16, TyI32, TyU32, TyI64, TyU64};\n+use rustc_front::hir::{TyIs, TyUs, TyI8, TyU8, TyI16, TyU16, TyI32, TyU32, TyI64, TyU64};\n use syntax::ptr::P;\n-use syntax::visit::{self, FnKind, Visitor};\n \n-use rustc_front::lowering::{lower_expr, lower_block, lower_item, lower_path, lower_pat,\n-                            lower_trait_ref};\n use rustc_front::hir;\n-use rustc_front::attr as front_attr;\n-use rustc_front::attr::AttrMetaMethods as FrontAttrMetaMethods;\n-use rustc_front::visit::Visitor as HirVisitor;\n-use rustc_front::visit as hir_visit;\n+\n+use rustc_front::attr::{self, AttrMetaMethods};\n+use rustc_front::visit::{self, FnKind, Visitor};\n+use rustc_front::lowering::unlower_attribute;\n+\n+use rustc_front::util::is_shift_binop;\n \n // hardwired lints from librustc\n pub use lint::builtin::*;\n@@ -78,10 +76,10 @@ impl LintPass for WhileTrue {\n         lint_array!(WHILE_TRUE)\n     }\n \n-    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        if let ast::ExprWhile(ref cond, _, _) = e.node {\n-            if let ast::ExprLit(ref lit) = cond.node {\n-                if let ast::LitBool(true) = lit.node {\n+    fn check_expr(&mut self, cx: &Context, e: &hir::Expr) {\n+        if let hir::ExprWhile(ref cond, _, _) = e.node {\n+            if let hir::ExprLit(ref lit) = cond.node {\n+                if let hir::LitBool(true) = lit.node {\n                     cx.span_lint(WHILE_TRUE, e.span,\n                                  \"denote infinite loops with loop { ... }\");\n                 }\n@@ -127,16 +125,16 @@ impl LintPass for TypeLimits {\n         lint_array!(UNUSED_COMPARISONS, OVERFLOWING_LITERALS, EXCEEDING_BITSHIFTS)\n     }\n \n-    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+    fn check_expr(&mut self, cx: &Context, e: &hir::Expr) {\n         match e.node {\n-            ast::ExprUnary(ast::UnNeg, ref expr) => {\n+            hir::ExprUnary(hir::UnNeg, ref expr) => {\n                 match expr.node  {\n-                    ast::ExprLit(ref lit) => {\n+                    hir::ExprLit(ref lit) => {\n                         match lit.node {\n-                            ast::LitInt(_, ast::UnsignedIntLit(_)) => {\n+                            hir::LitInt(_, hir::UnsignedIntLit(_)) => {\n                                 check_unsigned_negation_feature(cx, e.span);\n                             },\n-                            ast::LitInt(_, ast::UnsuffixedIntLit(_)) => {\n+                            hir::LitInt(_, hir::UnsuffixedIntLit(_)) => {\n                                 if let ty::TyUint(_) = cx.tcx.node_id_to_type(e.id).sty {\n                                     check_unsigned_negation_feature(cx, e.span);\n                                 }\n@@ -159,10 +157,10 @@ impl LintPass for TypeLimits {\n                     self.negated_expr_id = expr.id;\n                 }\n             },\n-            ast::ExprParen(ref expr) if self.negated_expr_id == e.id => {\n+            hir::ExprParen(ref expr) if self.negated_expr_id == e.id => {\n                 self.negated_expr_id = expr.id;\n             },\n-            ast::ExprBinary(binop, ref l, ref r) => {\n+            hir::ExprBinary(binop, ref l, ref r) => {\n                 if is_comparison(binop) && !check_limits(cx.tcx, binop, &**l, &**r) {\n                     cx.span_lint(UNUSED_COMPARISONS, e.span,\n                                  \"comparison is useless due to type limits\");\n@@ -176,11 +174,10 @@ impl LintPass for TypeLimits {\n                     };\n \n                     if let Some(bits) = opt_ty_bits {\n-                        let exceeding = if let ast::ExprLit(ref lit) = r.node {\n-                            if let ast::LitInt(shift, _) = lit.node { shift >= bits }\n+                        let exceeding = if let hir::ExprLit(ref lit) = r.node {\n+                            if let hir::LitInt(shift, _) = lit.node { shift >= bits }\n                             else { false }\n                         } else {\n-                            let r = lower_expr(r);\n                             match eval_const_expr_partial(cx.tcx, &r, ExprTypeChecked) {\n                                 Ok(ConstVal::Int(shift)) => { shift as u64 >= bits },\n                                 Ok(ConstVal::Uint(shift)) => { shift >= bits },\n@@ -194,12 +191,12 @@ impl LintPass for TypeLimits {\n                     };\n                 }\n             },\n-            ast::ExprLit(ref lit) => {\n+            hir::ExprLit(ref lit) => {\n                 match cx.tcx.node_id_to_type(e.id).sty {\n                     ty::TyInt(t) => {\n                         match lit.node {\n-                            ast::LitInt(v, ast::SignedIntLit(_, ast::Plus)) |\n-                            ast::LitInt(v, ast::UnsuffixedIntLit(ast::Plus)) => {\n+                            hir::LitInt(v, hir::SignedIntLit(_, hir::Plus)) |\n+                            hir::LitInt(v, hir::UnsuffixedIntLit(hir::Plus)) => {\n                                 let int_type = if let hir::TyIs = t {\n                                     cx.sess().target.int_type\n                                 } else {\n@@ -228,8 +225,8 @@ impl LintPass for TypeLimits {\n                         };\n                         let (min, max) = uint_ty_range(uint_type);\n                         let lit_val: u64 = match lit.node {\n-                            ast::LitByte(_v) => return,  // _v is u8, within range by definition\n-                            ast::LitInt(v, _) => v,\n+                            hir::LitByte(_v) => return,  // _v is u8, within range by definition\n+                            hir::LitInt(v, _) => v,\n                             _ => panic!()\n                         };\n                         if lit_val < min || lit_val > max {\n@@ -240,8 +237,8 @@ impl LintPass for TypeLimits {\n                     ty::TyFloat(t) => {\n                         let (min, max) = float_ty_range(t);\n                         let lit_val: f64 = match lit.node {\n-                            ast::LitFloat(ref v, _) |\n-                            ast::LitFloatUnsuffixed(ref v) => {\n+                            hir::LitFloat(ref v, _) |\n+                            hir::LitFloatUnsuffixed(ref v) => {\n                                 match v.parse() {\n                                     Ok(f) => f,\n                                     Err(_) => return\n@@ -260,24 +257,24 @@ impl LintPass for TypeLimits {\n             _ => ()\n         };\n \n-        fn is_valid<T:cmp::PartialOrd>(binop: ast::BinOp, v: T,\n+        fn is_valid<T:cmp::PartialOrd>(binop: hir::BinOp, v: T,\n                                 min: T, max: T) -> bool {\n             match binop.node {\n-                ast::BiLt => v >  min && v <= max,\n-                ast::BiLe => v >= min && v <  max,\n-                ast::BiGt => v >= min && v <  max,\n-                ast::BiGe => v >  min && v <= max,\n-                ast::BiEq | ast::BiNe => v >= min && v <= max,\n+                hir::BiLt => v >  min && v <= max,\n+                hir::BiLe => v >= min && v <  max,\n+                hir::BiGt => v >= min && v <  max,\n+                hir::BiGe => v >  min && v <= max,\n+                hir::BiEq | hir::BiNe => v >= min && v <= max,\n                 _ => panic!()\n             }\n         }\n \n-        fn rev_binop(binop: ast::BinOp) -> ast::BinOp {\n+        fn rev_binop(binop: hir::BinOp) -> hir::BinOp {\n             codemap::respan(binop.span, match binop.node {\n-                ast::BiLt => ast::BiGt,\n-                ast::BiLe => ast::BiGe,\n-                ast::BiGt => ast::BiLt,\n-                ast::BiGe => ast::BiLe,\n+                hir::BiLt => hir::BiGt,\n+                hir::BiLe => hir::BiGe,\n+                hir::BiGt => hir::BiLt,\n+                hir::BiGe => hir::BiLe,\n                 _ => return binop\n             })\n         }\n@@ -331,11 +328,11 @@ impl LintPass for TypeLimits {\n             }\n         }\n \n-        fn check_limits(tcx: &ty::ctxt, binop: ast::BinOp,\n-                        l: &ast::Expr, r: &ast::Expr) -> bool {\n+        fn check_limits(tcx: &ty::ctxt, binop: hir::BinOp,\n+                        l: &hir::Expr, r: &hir::Expr) -> bool {\n             let (lit, expr, swap) = match (&l.node, &r.node) {\n-                (&ast::ExprLit(_), _) => (l, r, true),\n-                (_, &ast::ExprLit(_)) => (r, l, false),\n+                (&hir::ExprLit(_), _) => (l, r, true),\n+                (_, &hir::ExprLit(_)) => (r, l, false),\n                 _ => return true\n             };\n             // Normalize the binop so that the literal is always on the RHS in\n@@ -349,11 +346,11 @@ impl LintPass for TypeLimits {\n                 ty::TyInt(int_ty) => {\n                     let (min, max) = int_ty_range(int_ty);\n                     let lit_val: i64 = match lit.node {\n-                        ast::ExprLit(ref li) => match li.node {\n-                            ast::LitInt(v, ast::SignedIntLit(_, ast::Plus)) |\n-                            ast::LitInt(v, ast::UnsuffixedIntLit(ast::Plus)) => v as i64,\n-                            ast::LitInt(v, ast::SignedIntLit(_, ast::Minus)) |\n-                            ast::LitInt(v, ast::UnsuffixedIntLit(ast::Minus)) => -(v as i64),\n+                        hir::ExprLit(ref li) => match li.node {\n+                            hir::LitInt(v, hir::SignedIntLit(_, hir::Plus)) |\n+                            hir::LitInt(v, hir::UnsuffixedIntLit(hir::Plus)) => v as i64,\n+                            hir::LitInt(v, hir::SignedIntLit(_, hir::Minus)) |\n+                            hir::LitInt(v, hir::UnsuffixedIntLit(hir::Minus)) => -(v as i64),\n                             _ => return true\n                         },\n                         _ => panic!()\n@@ -363,8 +360,8 @@ impl LintPass for TypeLimits {\n                 ty::TyUint(uint_ty) => {\n                     let (min, max): (u64, u64) = uint_ty_range(uint_ty);\n                     let lit_val: u64 = match lit.node {\n-                        ast::ExprLit(ref li) => match li.node {\n-                            ast::LitInt(v, _) => v,\n+                        hir::ExprLit(ref li) => match li.node {\n+                            hir::LitInt(v, _) => v,\n                             _ => return true\n                         },\n                         _ => panic!()\n@@ -375,10 +372,10 @@ impl LintPass for TypeLimits {\n             }\n         }\n \n-        fn is_comparison(binop: ast::BinOp) -> bool {\n+        fn is_comparison(binop: hir::BinOp) -> bool {\n             match binop.node {\n-                ast::BiEq | ast::BiLt | ast::BiLe |\n-                ast::BiNe | ast::BiGe | ast::BiGt => true,\n+                hir::BiEq | hir::BiLt | hir::BiLe |\n+                hir::BiNe | hir::BiGe | hir::BiGt => true,\n                 _ => false\n             }\n         }\n@@ -475,7 +472,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n         match ty.sty {\n             ty::TyStruct(def, substs) => {\n-                if !cx.lookup_repr_hints(def.did).contains(&front_attr::ReprExtern) {\n+                if !cx.lookup_repr_hints(def.did).contains(&attr::ReprExtern) {\n                     return FfiUnsafe(\n                         \"found struct without foreign-function-safe \\\n                          representation annotation in foreign module, \\\n@@ -681,17 +678,17 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for ImproperCTypesVisitor<'a, 'tcx> {\n-    fn visit_ty(&mut self, ty: &ast::Ty) {\n+    fn visit_ty(&mut self, ty: &hir::Ty) {\n         match ty.node {\n-            ast::TyPath(..) |\n-            ast::TyBareFn(..) => self.check_def(ty.span, ty.id),\n-            ast::TyVec(..) => {\n+            hir::TyPath(..) |\n+            hir::TyBareFn(..) => self.check_def(ty.span, ty.id),\n+            hir::TyVec(..) => {\n                 self.cx.span_lint(IMPROPER_CTYPES, ty.span,\n                     \"found Rust slice type in foreign module, consider \\\n                      using a raw pointer instead\");\n             }\n-            ast::TyFixedLengthVec(ref ty, _) => self.visit_ty(ty),\n-            ast::TyTup(..) => {\n+            hir::TyFixedLengthVec(ref ty, _) => self.visit_ty(ty),\n+            hir::TyTup(..) => {\n                 self.cx.span_lint(IMPROPER_CTYPES, ty.span,\n                     \"found Rust tuple type in foreign module; \\\n                      consider using a struct instead`\")\n@@ -709,17 +706,17 @@ impl LintPass for ImproperCTypes {\n         lint_array!(IMPROPER_CTYPES)\n     }\n \n-    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n-        fn check_ty(cx: &Context, ty: &ast::Ty) {\n+    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n+        fn check_ty(cx: &Context, ty: &hir::Ty) {\n             let mut vis = ImproperCTypesVisitor { cx: cx };\n             vis.visit_ty(ty);\n         }\n \n-        fn check_foreign_fn(cx: &Context, decl: &ast::FnDecl) {\n+        fn check_foreign_fn(cx: &Context, decl: &hir::FnDecl) {\n             for input in &decl.inputs {\n                 check_ty(cx, &*input.ty);\n             }\n-            if let ast::Return(ref ret_ty) = decl.output {\n+            if let hir::Return(ref ret_ty) = decl.output {\n                 let tty = ast_ty_to_normalized(cx.tcx, ret_ty.id);\n                 if !tty.is_nil() {\n                     check_ty(cx, &ret_ty);\n@@ -728,13 +725,13 @@ impl LintPass for ImproperCTypes {\n         }\n \n         match it.node {\n-            ast::ItemForeignMod(ref nmod)\n+            hir::ItemForeignMod(ref nmod)\n                 if nmod.abi != abi::RustIntrinsic &&\n                    nmod.abi != abi::PlatformIntrinsic => {\n                 for ni in &nmod.items {\n                     match ni.node {\n-                        ast::ForeignItemFn(ref decl, _) => check_foreign_fn(cx, &**decl),\n-                        ast::ForeignItemStatic(ref t, _) => check_ty(cx, &**t)\n+                        hir::ForeignItemFn(ref decl, _) => check_foreign_fn(cx, &**decl),\n+                        hir::ForeignItemStatic(ref t, _) => check_ty(cx, &**t)\n                     }\n                 }\n             }\n@@ -769,20 +766,20 @@ impl LintPass for BoxPointers {\n         lint_array!(BOX_POINTERS)\n     }\n \n-    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n         match it.node {\n-            ast::ItemFn(..) |\n-            ast::ItemTy(..) |\n-            ast::ItemEnum(..) |\n-            ast::ItemStruct(..) =>\n+            hir::ItemFn(..) |\n+            hir::ItemTy(..) |\n+            hir::ItemEnum(..) |\n+            hir::ItemStruct(..) =>\n                 self.check_heap_type(cx, it.span,\n                                      cx.tcx.node_id_to_type(it.id)),\n             _ => ()\n         }\n \n         // If it's a struct, we also have to check the fields' types\n         match it.node {\n-            ast::ItemStruct(ref struct_def, _) => {\n+            hir::ItemStruct(ref struct_def, _) => {\n                 for struct_field in &struct_def.fields {\n                     self.check_heap_type(cx, struct_field.span,\n                                          cx.tcx.node_id_to_type(struct_field.node.id));\n@@ -792,7 +789,7 @@ impl LintPass for BoxPointers {\n         }\n     }\n \n-    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+    fn check_expr(&mut self, cx: &Context, e: &hir::Expr) {\n         let ty = cx.tcx.node_id_to_type(e.id);\n         self.check_heap_type(cx, e.span, ty);\n     }\n@@ -808,13 +805,13 @@ struct RawPtrDeriveVisitor<'a, 'tcx: 'a> {\n     cx: &'a Context<'a, 'tcx>\n }\n \n-impl<'a, 'tcx, 'v> HirVisitor<'v> for RawPtrDeriveVisitor<'a, 'tcx> {\n+impl<'a, 'tcx, 'v> Visitor<'v> for RawPtrDeriveVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &hir::Ty) {\n         const MSG: &'static str = \"use of `#[derive]` with a raw pointer\";\n         if let hir::TyPtr(..) = ty.node {\n             self.cx.span_lint(RAW_POINTER_DERIVE, ty.span, MSG);\n         }\n-        hir_visit::walk_ty(self, ty);\n+        visit::walk_ty(self, ty);\n     }\n     // explicit override to a no-op to reduce code bloat\n     fn visit_expr(&mut self, _: &hir::Expr) {}\n@@ -838,11 +835,10 @@ impl LintPass for RawPointerDerive {\n         lint_array!(RAW_POINTER_DERIVE)\n     }\n \n-    fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n+    fn check_item(&mut self, cx: &Context, item: &hir::Item) {\n         if !attr::contains_name(&item.attrs, \"automatically_derived\") {\n             return;\n         }\n-        let item = lower_item(item);\n         let did = match item.node {\n             hir::ItemImpl(_, _, _, ref t_ref_opt, _, _) => {\n                 // Deriving the Copy trait does not cause a warning\n@@ -874,7 +870,7 @@ impl LintPass for RawPointerDerive {\n         match item.node {\n             hir::ItemStruct(..) | hir::ItemEnum(..) => {\n                 let mut visitor = RawPtrDeriveVisitor { cx: cx };\n-                hir_visit::walk_item(&mut visitor, &item);\n+                visit::walk_item(&mut visitor, &item);\n             }\n             _ => {}\n         }\n@@ -895,7 +891,7 @@ impl LintPass for UnusedAttributes {\n         lint_array!(UNUSED_ATTRIBUTES)\n     }\n \n-    fn check_attribute(&mut self, cx: &Context, attr: &ast::Attribute) {\n+    fn check_attribute(&mut self, cx: &Context, attr: &hir::Attribute) {\n         // Note that check_name() marks the attribute as used if it matches.\n         for &(ref name, ty, _) in KNOWN_ATTRIBUTES {\n             match ty {\n@@ -913,7 +909,7 @@ impl LintPass for UnusedAttributes {\n             }\n         }\n \n-        if !attr::is_used(attr) {\n+        if !syntax_attr::is_used(&unlower_attribute(attr)) {\n             cx.span_lint(UNUSED_ATTRIBUTES, attr.span, \"unused attribute\");\n             // Is it a builtin attribute that must be used at the crate level?\n             let known_crate = KNOWN_ATTRIBUTES.iter().find(|&&(name, ty, _)| {\n@@ -930,9 +926,9 @@ impl LintPass for UnusedAttributes {\n                                                     }).is_some();\n             if  known_crate || plugin_crate {\n                 let msg = match attr.node.style {\n-                    ast::AttrOuter => \"crate-level attribute should be an inner \\\n+                    hir::AttrOuter => \"crate-level attribute should be an inner \\\n                                        attribute: add an exclamation mark: #![foo]\",\n-                    ast::AttrInner => \"crate-level attribute should be in the \\\n+                    hir::AttrInner => \"crate-level attribute should be in the \\\n                                        root module\",\n                 };\n                 cx.span_lint(UNUSED_ATTRIBUTES, attr.span, msg);\n@@ -955,11 +951,11 @@ impl LintPass for PathStatements {\n         lint_array!(PATH_STATEMENTS)\n     }\n \n-    fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n+    fn check_stmt(&mut self, cx: &Context, s: &hir::Stmt) {\n         match s.node {\n-            ast::StmtSemi(ref expr, _) => {\n+            hir::StmtSemi(ref expr, _) => {\n                 match expr.node {\n-                    ast::ExprPath(..) => cx.span_lint(PATH_STATEMENTS, s.span,\n+                    hir::ExprPath(..) => cx.span_lint(PATH_STATEMENTS, s.span,\n                                                       \"path statement with no effect\"),\n                     _ => ()\n                 }\n@@ -989,17 +985,16 @@ impl LintPass for UnusedResults {\n         lint_array!(UNUSED_MUST_USE, UNUSED_RESULTS)\n     }\n \n-    fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n+    fn check_stmt(&mut self, cx: &Context, s: &hir::Stmt) {\n         let expr = match s.node {\n-            ast::StmtSemi(ref expr, _) => &**expr,\n+            hir::StmtSemi(ref expr, _) => &**expr,\n             _ => return\n         };\n \n-        if let ast::ExprRet(..) = expr.node {\n+        if let hir::ExprRet(..) = expr.node {\n             return;\n         }\n \n-        let expr = lower_expr(expr);\n         let t = cx.tcx.expr_ty(&expr);\n         let warned = match t.sty {\n             ty::TyTuple(ref tys) if tys.is_empty() => return,\n@@ -1096,7 +1091,7 @@ impl LintPass for NonCamelCaseTypes {\n         lint_array!(NON_CAMEL_CASE_TYPES)\n     }\n \n-    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n         let extern_repr_count = it.attrs.iter().filter(|attr| {\n             attr::find_repr_attrs(cx.tcx.sess.diagnostic(), attr).iter()\n                 .any(|r| r == &attr::ReprExtern)\n@@ -1108,13 +1103,13 @@ impl LintPass for NonCamelCaseTypes {\n         }\n \n         match it.node {\n-            ast::ItemTy(..) | ast::ItemStruct(..) => {\n+            hir::ItemTy(..) | hir::ItemStruct(..) => {\n                 self.check_case(cx, \"type\", it.ident, it.span)\n             }\n-            ast::ItemTrait(..) => {\n+            hir::ItemTrait(..) => {\n                 self.check_case(cx, \"trait\", it.ident, it.span)\n             }\n-            ast::ItemEnum(ref enum_definition, _) => {\n+            hir::ItemEnum(ref enum_definition, _) => {\n                 if has_extern_repr {\n                     return;\n                 }\n@@ -1127,7 +1122,7 @@ impl LintPass for NonCamelCaseTypes {\n         }\n     }\n \n-    fn check_generics(&mut self, cx: &Context, it: &ast::Generics) {\n+    fn check_generics(&mut self, cx: &Context, it: &hir::Generics) {\n         for gen in it.ty_params.iter() {\n             self.check_case(cx, \"type parameter\", gen.ident, gen.span);\n         }\n@@ -1242,7 +1237,7 @@ impl LintPass for NonSnakeCase {\n         lint_array!(NON_SNAKE_CASE)\n     }\n \n-    fn check_crate(&mut self, cx: &Context, cr: &ast::Crate) {\n+    fn check_crate(&mut self, cx: &Context, cr: &hir::Crate) {\n         let attr_crate_name = cr.attrs.iter().find(|at| at.check_name(\"crate_name\"))\n                                       .and_then(|at| at.value_str().map(|s| (at, s)));\n         if let Some(ref name) = cx.tcx.sess.opts.crate_name {\n@@ -1253,8 +1248,8 @@ impl LintPass for NonSnakeCase {\n     }\n \n     fn check_fn(&mut self, cx: &Context,\n-                fk: FnKind, _: &ast::FnDecl,\n-                _: &ast::Block, span: Span, id: ast::NodeId) {\n+                fk: FnKind, _: &hir::FnDecl,\n+                _: &hir::Block, span: Span, id: ast::NodeId) {\n         match fk {\n             FnKind::Method(ident, _, _) => match method_context(cx, id, span) {\n                 MethodContext::PlainImpl => {\n@@ -1272,37 +1267,37 @@ impl LintPass for NonSnakeCase {\n         }\n     }\n \n-    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n-        if let ast::ItemMod(_) = it.node {\n+    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n+        if let hir::ItemMod(_) = it.node {\n             self.check_snake_case(cx, \"module\", &it.ident.name.as_str(), Some(it.span));\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &Context, trait_item: &ast::TraitItem) {\n-        if let ast::MethodTraitItem(_, None) = trait_item.node {\n+    fn check_trait_item(&mut self, cx: &Context, trait_item: &hir::TraitItem) {\n+        if let hir::MethodTraitItem(_, None) = trait_item.node {\n             self.check_snake_case(cx, \"trait method\", &trait_item.ident.name.as_str(),\n                                   Some(trait_item.span));\n         }\n     }\n \n-    fn check_lifetime_def(&mut self, cx: &Context, t: &ast::LifetimeDef) {\n+    fn check_lifetime_def(&mut self, cx: &Context, t: &hir::LifetimeDef) {\n         self.check_snake_case(cx, \"lifetime\", &t.lifetime.name.as_str(),\n                               Some(t.lifetime.span));\n     }\n \n-    fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n-        if let &ast::PatIdent(_, ref path1, _) = &p.node {\n+    fn check_pat(&mut self, cx: &Context, p: &hir::Pat) {\n+        if let &hir::PatIdent(_, ref path1, _) = &p.node {\n             let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n             if let Some(def::DefLocal(_)) = def {\n                 self.check_snake_case(cx, \"variable\", &path1.node.name.as_str(), Some(p.span));\n             }\n         }\n     }\n \n-    fn check_struct_def(&mut self, cx: &Context, s: &ast::StructDef,\n-                        _: ast::Ident, _: &ast::Generics, _: ast::NodeId) {\n+    fn check_struct_def(&mut self, cx: &Context, s: &hir::StructDef,\n+                        _: ast::Ident, _: &hir::Generics, _: ast::NodeId) {\n         for sf in &s.fields {\n-            if let ast::StructField_ { kind: ast::NamedField(ident, _), .. } = sf.node {\n+            if let hir::StructField_ { kind: hir::NamedField(ident, _), .. } = sf.node {\n                 self.check_snake_case(cx, \"structure field\", &ident.name.as_str(),\n                                       Some(sf.span));\n             }\n@@ -1343,43 +1338,43 @@ impl LintPass for NonUpperCaseGlobals {\n         lint_array!(NON_UPPER_CASE_GLOBALS)\n     }\n \n-    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n         match it.node {\n             // only check static constants\n-            ast::ItemStatic(_, ast::MutImmutable, _) => {\n+            hir::ItemStatic(_, hir::MutImmutable, _) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"static constant\", it.ident, it.span);\n             }\n-            ast::ItemConst(..) => {\n+            hir::ItemConst(..) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"constant\", it.ident, it.span);\n             }\n             _ => {}\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &Context, ti: &ast::TraitItem) {\n+    fn check_trait_item(&mut self, cx: &Context, ti: &hir::TraitItem) {\n         match ti.node {\n-            ast::ConstTraitItem(..) => {\n+            hir::ConstTraitItem(..) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\",\n                                                       ti.ident, ti.span);\n             }\n             _ => {}\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &Context, ii: &ast::ImplItem) {\n+    fn check_impl_item(&mut self, cx: &Context, ii: &hir::ImplItem) {\n         match ii.node {\n-            ast::ConstImplItem(..) => {\n+            hir::ConstImplItem(..) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\",\n                                                       ii.ident, ii.span);\n             }\n             _ => {}\n         }\n     }\n \n-    fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n+    fn check_pat(&mut self, cx: &Context, p: &hir::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n         match (&p.node, cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def())) {\n-            (&ast::PatIdent(_, ref path1, _), Some(def::DefConst(..))) => {\n+            (&hir::PatIdent(_, ref path1, _), Some(def::DefConst(..))) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"constant in pattern\",\n                                                       path1.node, p.span);\n             }\n@@ -1398,9 +1393,9 @@ declare_lint! {\n pub struct UnusedParens;\n \n impl UnusedParens {\n-    fn check_unused_parens_core(&self, cx: &Context, value: &ast::Expr, msg: &str,\n+    fn check_unused_parens_core(&self, cx: &Context, value: &hir::Expr, msg: &str,\n                                 struct_lit_needs_parens: bool) {\n-        if let ast::ExprParen(ref inner) = value.node {\n+        if let hir::ExprParen(ref inner) = value.node {\n             let necessary = struct_lit_needs_parens && contains_exterior_struct_lit(&**inner);\n             if !necessary {\n                 cx.span_lint(UNUSED_PARENS, value.span,\n@@ -1413,27 +1408,27 @@ impl UnusedParens {\n         /// delimiters, e.g. `X { y: 1 }`, `X { y: 1 }.method()`, `foo\n         /// == X { y: 1 }` and `X { y: 1 } == foo` all do, but `(X {\n         /// y: 1 }) == foo` does not.\n-        fn contains_exterior_struct_lit(value: &ast::Expr) -> bool {\n+        fn contains_exterior_struct_lit(value: &hir::Expr) -> bool {\n             match value.node {\n-                ast::ExprStruct(..) => true,\n+                hir::ExprStruct(..) => true,\n \n-                ast::ExprAssign(ref lhs, ref rhs) |\n-                ast::ExprAssignOp(_, ref lhs, ref rhs) |\n-                ast::ExprBinary(_, ref lhs, ref rhs) => {\n+                hir::ExprAssign(ref lhs, ref rhs) |\n+                hir::ExprAssignOp(_, ref lhs, ref rhs) |\n+                hir::ExprBinary(_, ref lhs, ref rhs) => {\n                     // X { y: 1 } + X { y: 2 }\n                     contains_exterior_struct_lit(&**lhs) ||\n                         contains_exterior_struct_lit(&**rhs)\n                 }\n-                ast::ExprUnary(_, ref x) |\n-                ast::ExprCast(ref x, _) |\n-                ast::ExprField(ref x, _) |\n-                ast::ExprTupField(ref x, _) |\n-                ast::ExprIndex(ref x, _) => {\n+                hir::ExprUnary(_, ref x) |\n+                hir::ExprCast(ref x, _) |\n+                hir::ExprField(ref x, _) |\n+                hir::ExprTupField(ref x, _) |\n+                hir::ExprIndex(ref x, _) => {\n                     // &X { y: 1 }, X { y: 1 }.y\n                     contains_exterior_struct_lit(&**x)\n                 }\n \n-                ast::ExprMethodCall(_, _, ref exprs) => {\n+                hir::ExprMethodCall(_, _, ref exprs) => {\n                     // X { y: 1 }.bar(...)\n                     contains_exterior_struct_lit(&*exprs[0])\n                 }\n@@ -1449,28 +1444,28 @@ impl LintPass for UnusedParens {\n         lint_array!(UNUSED_PARENS)\n     }\n \n-    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+    fn check_expr(&mut self, cx: &Context, e: &hir::Expr) {\n         let (value, msg, struct_lit_needs_parens) = match e.node {\n-            ast::ExprIf(ref cond, _, _) => (cond, \"`if` condition\", true),\n-            ast::ExprWhile(ref cond, _, _) => (cond, \"`while` condition\", true),\n-            ast::ExprMatch(ref head, _, source) => match source {\n-                ast::MatchSource::Normal => (head, \"`match` head expression\", true),\n-                ast::MatchSource::IfLetDesugar { .. } => (head, \"`if let` head expression\", true),\n-                ast::MatchSource::WhileLetDesugar => (head, \"`while let` head expression\", true),\n-                ast::MatchSource::ForLoopDesugar => (head, \"`for` head expression\", true),\n+            hir::ExprIf(ref cond, _, _) => (cond, \"`if` condition\", true),\n+            hir::ExprWhile(ref cond, _, _) => (cond, \"`while` condition\", true),\n+            hir::ExprMatch(ref head, _, source) => match source {\n+                hir::MatchSource::Normal => (head, \"`match` head expression\", true),\n+                hir::MatchSource::IfLetDesugar { .. } => (head, \"`if let` head expression\", true),\n+                hir::MatchSource::WhileLetDesugar => (head, \"`while let` head expression\", true),\n+                hir::MatchSource::ForLoopDesugar => (head, \"`for` head expression\", true),\n             },\n-            ast::ExprRet(Some(ref value)) => (value, \"`return` value\", false),\n-            ast::ExprAssign(_, ref value) => (value, \"assigned value\", false),\n-            ast::ExprAssignOp(_, _, ref value) => (value, \"assigned value\", false),\n+            hir::ExprRet(Some(ref value)) => (value, \"`return` value\", false),\n+            hir::ExprAssign(_, ref value) => (value, \"assigned value\", false),\n+            hir::ExprAssignOp(_, _, ref value) => (value, \"assigned value\", false),\n             _ => return\n         };\n         self.check_unused_parens_core(cx, &**value, msg, struct_lit_needs_parens);\n     }\n \n-    fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n+    fn check_stmt(&mut self, cx: &Context, s: &hir::Stmt) {\n         let (value, msg) = match s.node {\n-            ast::StmtDecl(ref decl, _) => match decl.node {\n-                ast::DeclLocal(ref local) => match local.init {\n+            hir::StmtDecl(ref decl, _) => match decl.node {\n+                hir::DeclLocal(ref local) => match local.init {\n                     Some(ref value) => (value, \"assigned value\"),\n                     None => return\n                 },\n@@ -1496,11 +1491,11 @@ impl LintPass for UnusedImportBraces {\n         lint_array!(UNUSED_IMPORT_BRACES)\n     }\n \n-    fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n-        if let ast::ItemUse(ref view_path) = item.node {\n-            if let ast::ViewPathList(_, ref items) = view_path.node {\n+    fn check_item(&mut self, cx: &Context, item: &hir::Item) {\n+        if let hir::ItemUse(ref view_path) = item.node {\n+            if let hir::ViewPathList(_, ref items) = view_path.node {\n                 if items.len() == 1 {\n-                    if let ast::PathListIdent {ref name, ..} = items[0].node {\n+                    if let hir::PathListIdent {ref name, ..} = items[0].node {\n                         let m = format!(\"braces around {} is unnecessary\",\n                                         name);\n                         cx.span_lint(UNUSED_IMPORT_BRACES, item.span,\n@@ -1526,9 +1521,9 @@ impl LintPass for NonShorthandFieldPatterns {\n         lint_array!(NON_SHORTHAND_FIELD_PATTERNS)\n     }\n \n-    fn check_pat(&mut self, cx: &Context, pat: &ast::Pat) {\n+    fn check_pat(&mut self, cx: &Context, pat: &hir::Pat) {\n         let def_map = cx.tcx.def_map.borrow();\n-        if let ast::PatStruct(_, ref v, _) = pat.node {\n+        if let hir::PatStruct(_, ref v, _) = pat.node {\n             let field_pats = v.iter().filter(|fieldpat| {\n                 if fieldpat.node.is_shorthand {\n                     return false;\n@@ -1537,7 +1532,7 @@ impl LintPass for NonShorthandFieldPatterns {\n                 def == Some(def::DefLocal(fieldpat.node.pat.id))\n             });\n             for fieldpat in field_pats {\n-                if let ast::PatIdent(_, ident, None) = fieldpat.node.pat.node {\n+                if let hir::PatIdent(_, ident, None) = fieldpat.node.pat.node {\n                     if ident.node.name == fieldpat.node.ident.name {\n                         // FIXME: should this comparison really be done on the name?\n                         // doing it on the ident will fail during compilation of libcore\n@@ -1565,10 +1560,10 @@ impl LintPass for UnusedUnsafe {\n         lint_array!(UNUSED_UNSAFE)\n     }\n \n-    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        if let ast::ExprBlock(ref blk) = e.node {\n+    fn check_expr(&mut self, cx: &Context, e: &hir::Expr) {\n+        if let hir::ExprBlock(ref blk) = e.node {\n             // Don't warn about generated blocks, that'll just pollute the output.\n-            if blk.rules == ast::UnsafeBlock(ast::UserProvided) &&\n+            if blk.rules == hir::UnsafeBlock(hir::UserProvided) &&\n                 !cx.tcx.used_unsafe.borrow().contains(&blk.id) {\n                     cx.span_lint(UNUSED_UNSAFE, blk.span, \"unnecessary `unsafe` block\");\n             }\n@@ -1590,35 +1585,35 @@ impl LintPass for UnsafeCode {\n         lint_array!(UNSAFE_CODE)\n     }\n \n-    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        if let ast::ExprBlock(ref blk) = e.node {\n+    fn check_expr(&mut self, cx: &Context, e: &hir::Expr) {\n+        if let hir::ExprBlock(ref blk) = e.node {\n             // Don't warn about generated blocks, that'll just pollute the output.\n-            if blk.rules == ast::UnsafeBlock(ast::UserProvided) {\n+            if blk.rules == hir::UnsafeBlock(hir::UserProvided) {\n                 cx.span_lint(UNSAFE_CODE, blk.span, \"usage of an `unsafe` block\");\n             }\n         }\n     }\n \n-    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n         match it.node {\n-            ast::ItemTrait(ast::Unsafety::Unsafe, _, _, _) =>\n+            hir::ItemTrait(hir::Unsafety::Unsafe, _, _, _) =>\n                 cx.span_lint(UNSAFE_CODE, it.span, \"declaration of an `unsafe` trait\"),\n \n-            ast::ItemImpl(ast::Unsafety::Unsafe, _, _, _, _, _) =>\n+            hir::ItemImpl(hir::Unsafety::Unsafe, _, _, _, _, _) =>\n                 cx.span_lint(UNSAFE_CODE, it.span, \"implementation of an `unsafe` trait\"),\n \n             _ => return,\n         }\n     }\n \n-    fn check_fn(&mut self, cx: &Context, fk: FnKind, _: &ast::FnDecl,\n-                _: &ast::Block, span: Span, _: ast::NodeId) {\n+    fn check_fn(&mut self, cx: &Context, fk: FnKind, _: &hir::FnDecl,\n+                _: &hir::Block, span: Span, _: ast::NodeId) {\n         match fk {\n-            FnKind::ItemFn(_, _, ast::Unsafety::Unsafe, _, _, _) =>\n+            FnKind::ItemFn(_, _, hir::Unsafety::Unsafe, _, _, _) =>\n                 cx.span_lint(UNSAFE_CODE, span, \"declaration of an `unsafe` function\"),\n \n             FnKind::Method(_, sig, _) => {\n-                if sig.unsafety == ast::Unsafety::Unsafe {\n+                if sig.unsafety == hir::Unsafety::Unsafe {\n                     cx.span_lint(UNSAFE_CODE, span, \"implementation of an `unsafe` method\")\n                 }\n             },\n@@ -1627,9 +1622,9 @@ impl LintPass for UnsafeCode {\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &Context, trait_item: &ast::TraitItem) {\n-        if let ast::MethodTraitItem(ref sig, None) = trait_item.node {\n-            if sig.unsafety == ast::Unsafety::Unsafe {\n+    fn check_trait_item(&mut self, cx: &Context, trait_item: &hir::TraitItem) {\n+        if let hir::MethodTraitItem(ref sig, None) = trait_item.node {\n+            if sig.unsafety == hir::Unsafety::Unsafe {\n                 cx.span_lint(UNSAFE_CODE, trait_item.span,\n                              \"declaration of an `unsafe` method\")\n             }\n@@ -1647,13 +1642,13 @@ declare_lint! {\n pub struct UnusedMut;\n \n impl UnusedMut {\n-    fn check_unused_mut_pat(&self, cx: &Context, pats: &[P<ast::Pat>]) {\n+    fn check_unused_mut_pat(&self, cx: &Context, pats: &[P<hir::Pat>]) {\n         // collect all mutable pattern and group their NodeIDs by their Identifier to\n         // avoid false warnings in match arms with multiple patterns\n \n         let mut mutables = FnvHashMap();\n         for p in pats {\n-            pat_util::pat_bindings(&cx.tcx.def_map, &lower_pat(p), |mode, id, _, path1| {\n+            pat_util::pat_bindings(&cx.tcx.def_map, p, |mode, id, _, path1| {\n                 let ident = path1.node;\n                 if let hir::BindByValue(hir::MutMutable) = mode {\n                     if !ident.name.as_str().starts_with(\"_\") {\n@@ -1681,25 +1676,25 @@ impl LintPass for UnusedMut {\n         lint_array!(UNUSED_MUT)\n     }\n \n-    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        if let ast::ExprMatch(_, ref arms, _) = e.node {\n+    fn check_expr(&mut self, cx: &Context, e: &hir::Expr) {\n+        if let hir::ExprMatch(_, ref arms, _) = e.node {\n             for a in arms {\n                 self.check_unused_mut_pat(cx, &a.pats)\n             }\n         }\n     }\n \n-    fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n-        if let ast::StmtDecl(ref d, _) = s.node {\n-            if let ast::DeclLocal(ref l) = d.node {\n+    fn check_stmt(&mut self, cx: &Context, s: &hir::Stmt) {\n+        if let hir::StmtDecl(ref d, _) = s.node {\n+            if let hir::DeclLocal(ref l) = d.node {\n                 self.check_unused_mut_pat(cx, slice::ref_slice(&l.pat));\n             }\n         }\n     }\n \n     fn check_fn(&mut self, cx: &Context,\n-                _: FnKind, decl: &ast::FnDecl,\n-                _: &ast::Block, _: Span, _: ast::NodeId) {\n+                _: FnKind, decl: &hir::FnDecl,\n+                _: &hir::Block, _: Span, _: ast::NodeId) {\n         for a in &decl.inputs {\n             self.check_unused_mut_pat(cx, slice::ref_slice(&a.pat));\n         }\n@@ -1720,9 +1715,9 @@ impl LintPass for UnusedAllocation {\n         lint_array!(UNUSED_ALLOCATION)\n     }\n \n-    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+    fn check_expr(&mut self, cx: &Context, e: &hir::Expr) {\n         match e.node {\n-            ast::ExprUnary(ast::UnUniq, _) => (),\n+            hir::ExprUnary(hir::UnUniq, _) => (),\n             _ => return\n         }\n \n@@ -1782,7 +1777,7 @@ impl MissingDoc {\n     fn check_missing_docs_attrs(&self,\n                                cx: &Context,\n                                id: Option<ast::NodeId>,\n-                               attrs: &[ast::Attribute],\n+                               attrs: &[hir::Attribute],\n                                sp: Span,\n                                desc: &'static str) {\n         // If we're building a test harness, then warning about\n@@ -1807,7 +1802,7 @@ impl MissingDoc {\n \n         let has_doc = attrs.iter().any(|a| {\n             match a.node.value.node {\n-                ast::MetaNameValue(ref name, _) if *name == \"doc\" => true,\n+                hir::MetaNameValue(ref name, _) if *name == \"doc\" => true,\n                 _ => false\n             }\n         });\n@@ -1823,7 +1818,7 @@ impl LintPass for MissingDoc {\n         lint_array!(MISSING_DOCS)\n     }\n \n-    fn enter_lint_attrs(&mut self, _: &Context, attrs: &[ast::Attribute]) {\n+    fn enter_lint_attrs(&mut self, _: &Context, attrs: &[hir::Attribute]) {\n         let doc_hidden = self.doc_hidden() || attrs.iter().any(|attr| {\n             attr.check_name(\"doc\") && match attr.meta_item_list() {\n                 None => false,\n@@ -1833,34 +1828,34 @@ impl LintPass for MissingDoc {\n         self.doc_hidden_stack.push(doc_hidden);\n     }\n \n-    fn exit_lint_attrs(&mut self, _: &Context, _: &[ast::Attribute]) {\n+    fn exit_lint_attrs(&mut self, _: &Context, _: &[hir::Attribute]) {\n         self.doc_hidden_stack.pop().expect(\"empty doc_hidden_stack\");\n     }\n \n-    fn check_struct_def(&mut self, _: &Context, _: &ast::StructDef,\n-                        _: ast::Ident, _: &ast::Generics, id: ast::NodeId) {\n+    fn check_struct_def(&mut self, _: &Context, _: &hir::StructDef,\n+                        _: ast::Ident, _: &hir::Generics, id: ast::NodeId) {\n         self.struct_def_stack.push(id);\n     }\n \n-    fn check_struct_def_post(&mut self, _: &Context, _: &ast::StructDef,\n-                             _: ast::Ident, _: &ast::Generics, id: ast::NodeId) {\n+    fn check_struct_def_post(&mut self, _: &Context, _: &hir::StructDef,\n+                             _: ast::Ident, _: &hir::Generics, id: ast::NodeId) {\n         let popped = self.struct_def_stack.pop().expect(\"empty struct_def_stack\");\n         assert!(popped == id);\n     }\n \n-    fn check_crate(&mut self, cx: &Context, krate: &ast::Crate) {\n+    fn check_crate(&mut self, cx: &Context, krate: &hir::Crate) {\n         self.check_missing_docs_attrs(cx, None, &krate.attrs, krate.span, \"crate\");\n     }\n \n-    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n         let desc = match it.node {\n-            ast::ItemFn(..) => \"a function\",\n-            ast::ItemMod(..) => \"a module\",\n-            ast::ItemEnum(..) => \"an enum\",\n-            ast::ItemStruct(..) => \"a struct\",\n-            ast::ItemTrait(_, _, _, ref items) => {\n+            hir::ItemFn(..) => \"a function\",\n+            hir::ItemMod(..) => \"a module\",\n+            hir::ItemEnum(..) => \"an enum\",\n+            hir::ItemStruct(..) => \"a struct\",\n+            hir::ItemTrait(_, _, _, ref items) => {\n                 // Issue #11592, traits are always considered exported, even when private.\n-                if it.vis == ast::Visibility::Inherited {\n+                if it.vis == hir::Visibility::Inherited {\n                     self.private_traits.insert(it.id);\n                     for itm in items {\n                         self.private_traits.insert(itm.id);\n@@ -1869,11 +1864,11 @@ impl LintPass for MissingDoc {\n                 }\n                 \"a trait\"\n             },\n-            ast::ItemTy(..) => \"a type alias\",\n-            ast::ItemImpl(_, _, _, Some(ref trait_ref), _, ref impl_items) => {\n+            hir::ItemTy(..) => \"a type alias\",\n+            hir::ItemImpl(_, _, _, Some(ref trait_ref), _, ref impl_items) => {\n                 // If the trait is private, add the impl items to private_traits so they don't get\n                 // reported for missing docs.\n-                let real_trait = cx.tcx.trait_ref_to_def_id(&lower_trait_ref(trait_ref));\n+                let real_trait = cx.tcx.trait_ref_to_def_id(trait_ref);\n                 match cx.tcx.map.find(real_trait.node) {\n                     Some(hir_map::NodeItem(item)) => if item.vis == hir::Visibility::Inherited {\n                         for itm in impl_items {\n@@ -1884,48 +1879,47 @@ impl LintPass for MissingDoc {\n                 }\n                 return\n             },\n-            ast::ItemConst(..) => \"a constant\",\n-            ast::ItemStatic(..) => \"a static\",\n+            hir::ItemConst(..) => \"a constant\",\n+            hir::ItemStatic(..) => \"a static\",\n             _ => return\n         };\n \n         self.check_missing_docs_attrs(cx, Some(it.id), &it.attrs, it.span, desc);\n     }\n \n-    fn check_trait_item(&mut self, cx: &Context, trait_item: &ast::TraitItem) {\n+    fn check_trait_item(&mut self, cx: &Context, trait_item: &hir::TraitItem) {\n         if self.private_traits.contains(&trait_item.id) { return }\n \n         let desc = match trait_item.node {\n-            ast::ConstTraitItem(..) => \"an associated constant\",\n-            ast::MethodTraitItem(..) => \"a trait method\",\n-            ast::TypeTraitItem(..) => \"an associated type\",\n+            hir::ConstTraitItem(..) => \"an associated constant\",\n+            hir::MethodTraitItem(..) => \"a trait method\",\n+            hir::TypeTraitItem(..) => \"an associated type\",\n         };\n \n         self.check_missing_docs_attrs(cx, Some(trait_item.id),\n                                       &trait_item.attrs,\n                                       trait_item.span, desc);\n     }\n \n-    fn check_impl_item(&mut self, cx: &Context, impl_item: &ast::ImplItem) {\n+    fn check_impl_item(&mut self, cx: &Context, impl_item: &hir::ImplItem) {\n         // If the method is an impl for a trait, don't doc.\n         if method_context(cx, impl_item.id, impl_item.span) == MethodContext::TraitImpl {\n             return;\n         }\n \n         let desc = match impl_item.node {\n-            ast::ConstImplItem(..) => \"an associated constant\",\n-            ast::MethodImplItem(..) => \"a method\",\n-            ast::TypeImplItem(_) => \"an associated type\",\n-            ast::MacImplItem(_) => \"an impl item macro\",\n+            hir::ConstImplItem(..) => \"an associated constant\",\n+            hir::MethodImplItem(..) => \"a method\",\n+            hir::TypeImplItem(_) => \"an associated type\",\n         };\n         self.check_missing_docs_attrs(cx, Some(impl_item.id),\n                                       &impl_item.attrs,\n                                       impl_item.span, desc);\n     }\n \n-    fn check_struct_field(&mut self, cx: &Context, sf: &ast::StructField) {\n-        if let ast::NamedField(_, vis) = sf.node.kind {\n-            if vis == ast::Public || self.in_variant {\n+    fn check_struct_field(&mut self, cx: &Context, sf: &hir::StructField) {\n+        if let hir::NamedField(_, vis) = sf.node.kind {\n+            if vis == hir::Public || self.in_variant {\n                 let cur_struct_def = *self.struct_def_stack.last()\n                     .expect(\"empty struct_def_stack\");\n                 self.check_missing_docs_attrs(cx, Some(cur_struct_def),\n@@ -1935,13 +1929,13 @@ impl LintPass for MissingDoc {\n         }\n     }\n \n-    fn check_variant(&mut self, cx: &Context, v: &ast::Variant, _: &ast::Generics) {\n+    fn check_variant(&mut self, cx: &Context, v: &hir::Variant, _: &hir::Generics) {\n         self.check_missing_docs_attrs(cx, Some(v.node.id), &v.node.attrs, v.span, \"a variant\");\n         assert!(!self.in_variant);\n         self.in_variant = true;\n     }\n \n-    fn check_variant_post(&mut self, _: &Context, _: &ast::Variant, _: &ast::Generics) {\n+    fn check_variant_post(&mut self, _: &Context, _: &hir::Variant, _: &hir::Generics) {\n         assert!(self.in_variant);\n         self.in_variant = false;\n     }\n@@ -1961,20 +1955,20 @@ impl LintPass for MissingCopyImplementations {\n         lint_array!(MISSING_COPY_IMPLEMENTATIONS)\n     }\n \n-    fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n+    fn check_item(&mut self, cx: &Context, item: &hir::Item) {\n         if !cx.exported_items.contains(&item.id) {\n             return;\n         }\n         let (def, ty) = match item.node {\n-            ast::ItemStruct(_, ref ast_generics) => {\n+            hir::ItemStruct(_, ref ast_generics) => {\n                 if ast_generics.is_parameterized() {\n                     return;\n                 }\n                 let def = cx.tcx.lookup_adt_def(DefId::local(item.id));\n                 (def, cx.tcx.mk_struct(def,\n                                        cx.tcx.mk_substs(Substs::empty())))\n             }\n-            ast::ItemEnum(_, ref ast_generics) => {\n+            hir::ItemEnum(_, ref ast_generics) => {\n                 if ast_generics.is_parameterized() {\n                     return;\n                 }\n@@ -2023,13 +2017,13 @@ impl LintPass for MissingDebugImplementations {\n         lint_array!(MISSING_DEBUG_IMPLEMENTATIONS)\n     }\n \n-    fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n+    fn check_item(&mut self, cx: &Context, item: &hir::Item) {\n         if !cx.exported_items.contains(&item.id) {\n             return;\n         }\n \n         match item.node {\n-            ast::ItemStruct(..) | ast::ItemEnum(..) => {},\n+            hir::ItemStruct(..) | hir::ItemEnum(..) => {},\n             _ => return,\n         }\n \n@@ -2098,11 +2092,11 @@ impl Stability {\n     }\n }\n \n-fn hir_to_ast_stability(stab: &front_attr::Stability) -> attr::Stability {\n+fn hir_to_ast_stability(stab: &attr::Stability) -> attr::Stability {\n     attr::Stability {\n         level: match stab.level {\n-            front_attr::Unstable => attr::Unstable,\n-            front_attr::Stable => attr::Stable,\n+            attr::Unstable => attr::Unstable,\n+            attr::Stable => attr::Stable,\n         },\n         feature: stab.feature.clone(),\n         since: stab.since.clone(),\n@@ -2117,29 +2111,29 @@ impl LintPass for Stability {\n         lint_array!(DEPRECATED)\n     }\n \n-    fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n-        stability::check_item(cx.tcx, &lower_item(item), false,\n+    fn check_item(&mut self, cx: &Context, item: &hir::Item) {\n+        stability::check_item(cx.tcx, item, false,\n                               &mut |id, sp, stab|\n                                 self.lint(cx, id, sp,\n                                           &stab.map(|s| hir_to_ast_stability(s)).as_ref()));\n     }\n \n-    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        stability::check_expr(cx.tcx, &lower_expr(e),\n+    fn check_expr(&mut self, cx: &Context, e: &hir::Expr) {\n+        stability::check_expr(cx.tcx, e,\n                               &mut |id, sp, stab|\n                                 self.lint(cx, id, sp,\n                                           &stab.map(|s| hir_to_ast_stability(s)).as_ref()));\n     }\n \n-    fn check_path(&mut self, cx: &Context, path: &ast::Path, id: ast::NodeId) {\n-        stability::check_path(cx.tcx, &lower_path(path), id,\n+    fn check_path(&mut self, cx: &Context, path: &hir::Path, id: ast::NodeId) {\n+        stability::check_path(cx.tcx, path, id,\n                               &mut |id, sp, stab|\n                                 self.lint(cx, id, sp,\n                                           &stab.map(|s| hir_to_ast_stability(s)).as_ref()));\n     }\n \n-    fn check_pat(&mut self, cx: &Context, pat: &ast::Pat) {\n-        stability::check_pat(cx.tcx, &lower_pat(pat),\n+    fn check_pat(&mut self, cx: &Context, pat: &hir::Pat) {\n+        stability::check_pat(cx.tcx, pat,\n                              &mut |id, sp, stab|\n                                 self.lint(cx, id, sp,\n                                           &stab.map(|s| hir_to_ast_stability(s)).as_ref()));\n@@ -2161,8 +2155,8 @@ impl LintPass for UnconditionalRecursion {\n         lint_array![UNCONDITIONAL_RECURSION]\n     }\n \n-    fn check_fn(&mut self, cx: &Context, fn_kind: FnKind, _: &ast::FnDecl,\n-                blk: &ast::Block, sp: Span, id: ast::NodeId) {\n+    fn check_fn(&mut self, cx: &Context, fn_kind: FnKind, _: &hir::FnDecl,\n+                blk: &hir::Block, sp: Span, id: ast::NodeId) {\n         type F = for<'tcx> fn(&ty::ctxt<'tcx>,\n                               ast::NodeId, ast::NodeId, ast::Ident, ast::NodeId) -> bool;\n \n@@ -2201,7 +2195,7 @@ impl LintPass for UnconditionalRecursion {\n         // to have behaviour like the above, rather than\n         // e.g. accidentally recurring after an assert.\n \n-        let cfg = cfg::CFG::new(cx.tcx, &lower_block(blk));\n+        let cfg = cfg::CFG::new(cx.tcx, blk);\n \n         let mut work_queue = vec![cfg.entry];\n         let mut reached_exit_without_self_call = false;\n@@ -2408,14 +2402,14 @@ impl LintPass for PluginAsLibrary {\n         lint_array![PLUGIN_AS_LIBRARY]\n     }\n \n-    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n         if cx.sess().plugin_registrar_fn.get().is_some() {\n             // We're compiling a plugin; it's fine to link other plugins.\n             return;\n         }\n \n         match it.node {\n-            ast::ItemExternCrate(..) => (),\n+            hir::ItemExternCrate(..) => (),\n             _ => return,\n         };\n \n@@ -2464,25 +2458,25 @@ impl LintPass for InvalidNoMangleItems {\n                     NO_MANGLE_CONST_ITEMS)\n     }\n \n-    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n         match it.node {\n-            ast::ItemFn(..) => {\n+            hir::ItemFn(..) => {\n                 if attr::contains_name(&it.attrs, \"no_mangle\") &&\n                        !cx.exported_items.contains(&it.id) {\n                     let msg = format!(\"function {} is marked #[no_mangle], but not exported\",\n                                       it.ident);\n                     cx.span_lint(PRIVATE_NO_MANGLE_FNS, it.span, &msg);\n                 }\n             },\n-            ast::ItemStatic(..) => {\n+            hir::ItemStatic(..) => {\n                 if attr::contains_name(&it.attrs, \"no_mangle\") &&\n                        !cx.exported_items.contains(&it.id) {\n                     let msg = format!(\"static {} is marked #[no_mangle], but not exported\",\n                                       it.ident);\n                     cx.span_lint(PRIVATE_NO_MANGLE_STATICS, it.span, &msg);\n                 }\n             },\n-            ast::ItemConst(..) => {\n+            hir::ItemConst(..) => {\n                 if attr::contains_name(&it.attrs, \"no_mangle\") {\n                     // Const items do not refer to a particular location in memory, and therefore\n                     // don't have anything to attach a symbol to\n@@ -2510,7 +2504,7 @@ impl LintPass for MutableTransmutes {\n         lint_array!(MUTABLE_TRANSMUTES)\n     }\n \n-    fn check_expr(&mut self, cx: &Context, expr: &ast::Expr) {\n+    fn check_expr(&mut self, cx: &Context, expr: &hir::Expr) {\n         use syntax::abi::RustIntrinsic;\n \n         let msg = \"mutating transmuted &mut T from &T may cause undefined behavior,\\\n@@ -2525,13 +2519,13 @@ impl LintPass for MutableTransmutes {\n             _ => ()\n         }\n \n-        fn get_transmute_from_to<'a, 'tcx>(cx: &Context<'a, 'tcx>, expr: &ast::Expr)\n+        fn get_transmute_from_to<'a, 'tcx>(cx: &Context<'a, 'tcx>, expr: &hir::Expr)\n             -> Option<(&'tcx ty::TypeVariants<'tcx>, &'tcx ty::TypeVariants<'tcx>)> {\n             match expr.node {\n-                ast::ExprPath(..) => (),\n+                hir::ExprPath(..) => (),\n                 _ => return None\n             }\n-            if let def::DefFn(did, _) = cx.tcx.resolve_expr(&lower_expr(expr)) {\n+            if let def::DefFn(did, _) = cx.tcx.resolve_expr(expr) {\n                 if !def_id_is_transmute(cx, did) {\n                     return None;\n                 }\n@@ -2576,7 +2570,7 @@ impl LintPass for UnstableFeatures {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNSTABLE_FEATURES)\n     }\n-    fn check_attribute(&mut self, ctx: &Context, attr: &ast::Attribute) {\n+    fn check_attribute(&mut self, ctx: &Context, attr: &hir::Attribute) {\n         if attr::contains_name(&[attr.node.value.clone()], \"feature\") {\n             if let Some(items) = attr.node.value.meta_item_list() {\n                 for item in items {\n@@ -2602,7 +2596,7 @@ impl LintPass for DropWithReprExtern {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(DROP_WITH_REPR_EXTERN)\n     }\n-    fn check_crate(&mut self, ctx: &Context, _: &ast::Crate) {\n+    fn check_crate(&mut self, ctx: &Context, _: &hir::Crate) {\n         for dtor_did in ctx.tcx.destructors.borrow().iter() {\n             let (drop_impl_did, dtor_self_type) =\n                 if dtor_did.is_local() {\n@@ -2618,7 +2612,7 @@ impl LintPass for DropWithReprExtern {\n                 ty::TyStruct(self_type_def, _) => {\n                     let self_type_did = self_type_def.did;\n                     let hints = ctx.tcx.lookup_repr_hints(self_type_did);\n-                    if hints.iter().any(|attr| *attr == front_attr::ReprExtern) &&\n+                    if hints.iter().any(|attr| *attr == attr::ReprExtern) &&\n                         self_type_def.dtor_kind().has_drop_flag() {\n                         let drop_impl_span = ctx.tcx.map.def_id_span(drop_impl_did,\n                                                                      codemap::DUMMY_SP);"}, {"sha": "708fcafcb53112d00a02d67f09538f15fd876c64", "filename": "src/test/auxiliary/lint_for_crate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7732ad85df5a8fe0d6176aa08e6b86e6636561d1/src%2Ftest%2Fauxiliary%2Flint_for_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732ad85df5a8fe0d6176aa08e6b86e6636561d1/src%2Ftest%2Fauxiliary%2Flint_for_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_for_crate.rs?ref=7732ad85df5a8fe0d6176aa08e6b86e6636561d1", "patch": "@@ -13,12 +13,12 @@\n #![feature(plugin_registrar, rustc_private)]\n #![feature(box_syntax)]\n \n-extern crate syntax;\n #[macro_use] extern crate rustc;\n+extern crate rustc_front;\n \n-use syntax::{ast, attr};\n use rustc::lint::{Context, LintPass, LintPassObject, LintArray};\n use rustc::plugin::Registry;\n+use rustc_front::{hir, attr};\n \n declare_lint!(CRATE_NOT_OKAY, Warn, \"crate not marked with #![crate_okay]\");\n \n@@ -29,7 +29,7 @@ impl LintPass for Pass {\n         lint_array!(CRATE_NOT_OKAY)\n     }\n \n-    fn check_crate(&mut self, cx: &Context, krate: &ast::Crate) {\n+    fn check_crate(&mut self, cx: &Context, krate: &hir::Crate) {\n         if !attr::contains_name(&krate.attrs, \"crate_okay\") {\n             cx.span_lint(CRATE_NOT_OKAY, krate.span,\n                          \"crate is not marked with #![crate_okay]\");"}, {"sha": "adc194fa454862a40eab10a6b56279e22b335ca4", "filename": "src/test/auxiliary/lint_group_plugin_test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7732ad85df5a8fe0d6176aa08e6b86e6636561d1/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732ad85df5a8fe0d6176aa08e6b86e6636561d1/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs?ref=7732ad85df5a8fe0d6176aa08e6b86e6636561d1", "patch": "@@ -13,13 +13,13 @@\n #![feature(plugin_registrar)]\n #![feature(box_syntax, rustc_private)]\n \n-extern crate syntax;\n+extern crate rustc_front;\n \n // Load rustc as a plugin to get macros\n #[macro_use]\n extern crate rustc;\n \n-use syntax::ast;\n+use rustc_front::hir;\n use rustc::lint::{Context, LintPass, LintPassObject, LintArray};\n use rustc::plugin::Registry;\n \n@@ -34,7 +34,7 @@ impl LintPass for Pass {\n         lint_array!(TEST_LINT, PLEASE_LINT)\n     }\n \n-    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n         match &*it.ident.name.as_str() {\n             \"lintme\" => cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\"),\n             \"pleaselintme\" => cx.span_lint(PLEASE_LINT, it.span, \"item is named 'pleaselintme'\"),"}, {"sha": "e6f91db230009af05c3411ad9842129f47b62e50", "filename": "src/test/auxiliary/lint_plugin_test.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7732ad85df5a8fe0d6176aa08e6b86e6636561d1/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732ad85df5a8fe0d6176aa08e6b86e6636561d1/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs?ref=7732ad85df5a8fe0d6176aa08e6b86e6636561d1", "patch": "@@ -13,16 +13,15 @@\n #![feature(plugin_registrar)]\n #![feature(box_syntax, rustc_private)]\n \n-extern crate syntax;\n+extern crate rustc_front;\n \n // Load rustc as a plugin to get macros\n #[macro_use]\n extern crate rustc;\n \n-use syntax::ast;\n use rustc::lint::{Context, LintPass, LintPassObject, LintArray};\n use rustc::plugin::Registry;\n-\n+use rustc_front::hir;\n declare_lint!(TEST_LINT, Warn, \"Warn about items named 'lintme'\");\n \n struct Pass;\n@@ -32,7 +31,7 @@ impl LintPass for Pass {\n         lint_array!(TEST_LINT)\n     }\n \n-    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+    fn check_item(&mut self, cx: &Context, it: &hir::Item) {\n         if it.ident.name == \"lintme\" {\n             cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\");\n         }"}]}