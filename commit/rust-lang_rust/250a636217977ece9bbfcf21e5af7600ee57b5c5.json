{"sha": "250a636217977ece9bbfcf21e5af7600ee57b5c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1MGE2MzYyMTc5NzdlY2U5YmJmY2YyMWU1YWY3NjAwZWU1N2I1YzU=", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2019-12-27T18:50:56Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2019-12-28T17:13:44Z"}, "message": "Avoid copying some undef memory in MIR\n\nDuring MIR interpretation it may happen that a place containing\nuninitialized bytes is copied. This would read the current\nrepresentation of these bytes and write it to the destination even\nthough they must, by definition, not matter to the execution.\n\nThis elides that representation change when no bytes are defined in such\na copy, saving some cpu cycles. In such a case, the memory of the target\nallocation is not touched at all which also means that sometimes no\nphysical page backing the memory allocation of the representation needs\nto be provided by the OS at all, reducing memory pressure on the system.", "tree": {"sha": "de2020b9c4619cac47dca2d9c6277118caa68064", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de2020b9c4619cac47dca2d9c6277118caa68064"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/250a636217977ece9bbfcf21e5af7600ee57b5c5", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEmNHc6jmXzkUyxd4xiMlBzaHUZDIFAl4HjUkACgkQiMlBzaHU\nZDKkjhAAhmS8UwKu+gN6DTRcCGqHleqp00wxTBfeWB0lE3KJVbETSZBsVtHaFi9K\nlssgsBd2p/MelSZHDdKGdd2CTRGExOyLxSiq8gye8LhpaUcU/r0OhpGO29EYDFc7\nrqS+7jrXN4Ul+1NWeHE+foA0KyVl42BE4OHiXehjR33n8k7xDd54ZQBj6GTwnpKI\n2FCO2hgVQzGxFHvjtkMK3kz0wcgcEcIyWgrVr0gbwpvheWS7PqFfP4V6BE0XX0rf\nZT5qOuFRxywgFrvcwFEaQKthIWrn5BMk5JhKH0RCTLG+R4mFT1Yks+DnyAsk1VWT\neuw67orDSSGRSRrRQFBcgR/y0JHtoSMVtjIGDhBTdZN1GYOSm2IyKBd0LF1f8aTb\nAeML3G7RujcXi4h20AMPjcCFYG5hl7nI80ayt6SollRDYLvsyucQRRES0ZZg4nEh\nOSkmZpYhHZjmlRpSPvfFVjDwIOSCcezrcOsMUWF55EwE/NCH4ntZcv1KHZXDsNWY\nD9lJFen7/3MtqMs5bYv7+Qlu8iRO6e8bQCDn4Is/AxZtQAcTHUjI2l2jaxXCNxrO\nVwM4sUngDYuMcqm402NKMLSrWqXCxVeT9C5wzlf/bT0oZ1WJ5T64H67qMGCTouMW\nlwYv/JAME4AztTNIWBMatgv9VEqdFBPQCS0rVrr2sDGe0rr7g/U=\n=uCN5\n-----END PGP SIGNATURE-----", "payload": "tree de2020b9c4619cac47dca2d9c6277118caa68064\nparent bd93b7718efc4267e1106abb42b19c84ab0d5a86\nauthor Santiago Pastorino <spastorino@gmail.com> 1577472656 -0300\ncommitter Santiago Pastorino <spastorino@gmail.com> 1577553224 -0300\n\nAvoid copying some undef memory in MIR\n\nDuring MIR interpretation it may happen that a place containing\nuninitialized bytes is copied. This would read the current\nrepresentation of these bytes and write it to the destination even\nthough they must, by definition, not matter to the execution.\n\nThis elides that representation change when no bytes are defined in such\na copy, saving some cpu cycles. In such a case, the memory of the target\nallocation is not touched at all which also means that sometimes no\nphysical page backing the memory allocation of the representation needs\nto be provided by the OS at all, reducing memory pressure on the system.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/250a636217977ece9bbfcf21e5af7600ee57b5c5", "html_url": "https://github.com/rust-lang/rust/commit/250a636217977ece9bbfcf21e5af7600ee57b5c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/250a636217977ece9bbfcf21e5af7600ee57b5c5/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd93b7718efc4267e1106abb42b19c84ab0d5a86", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd93b7718efc4267e1106abb42b19c84ab0d5a86", "html_url": "https://github.com/rust-lang/rust/commit/bd93b7718efc4267e1106abb42b19c84ab0d5a86"}], "stats": {"total": 60, "additions": 36, "deletions": 24}, "files": [{"sha": "a06b23367e6daeca9c5862c56fbcba2b4a3a0f40", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/250a636217977ece9bbfcf21e5af7600ee57b5c5/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250a636217977ece9bbfcf21e5af7600ee57b5c5/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=250a636217977ece9bbfcf21e5af7600ee57b5c5", "patch": "@@ -594,6 +594,14 @@ pub struct AllocationDefinedness {\n     ranges: smallvec::SmallVec<[u64; 1]>,\n }\n \n+impl AllocationDefinedness {\n+    pub fn all_bytes_undef(&self) -> bool {\n+        // The `ranges` are run-length encoded and of alternating definedness.\n+        // So if `ranges.len() > 1` then the second block is a range of defined.\n+        self.initial == false && self.ranges.len() == 1\n+    }\n+}\n+\n /// Transferring the definedness mask to other allocations.\n impl<Tag, Extra> Allocation<Tag, Extra> {\n     /// Creates a run-length encoding of the undef mask."}, {"sha": "cb676821fd438ee407774a6e1eea3d34ed0d42cf", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/250a636217977ece9bbfcf21e5af7600ee57b5c5/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250a636217977ece9bbfcf21e5af7600ee57b5c5/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=250a636217977ece9bbfcf21e5af7600ee57b5c5", "patch": "@@ -841,6 +841,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n         let tcx = self.tcx.tcx;\n \n+        // The bits have to be saved locally before writing to dest in case src and dest overlap.\n+        assert_eq!(size.bytes() as usize as u64, size.bytes());\n+\n         // This checks relocation edges on the src.\n         let src_bytes =\n             self.get_raw(src.alloc_id)?.get_bytes_with_undef_and_ptr(&tcx, src, size)?.as_ptr();\n@@ -855,6 +858,22 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n         let dest_bytes = dest_bytes.as_mut_ptr();\n \n+        // Prepare a copy of the undef mask.\n+        let compressed = self.get_raw(src.alloc_id)?.compress_undef_range(src, size);\n+\n+        if compressed.all_bytes_undef() {\n+            // Fast path: If all bytes are `undef` then there is nothing to copy. The target range\n+            // is marked as undef but we otherwise omit changing the byte representation which may\n+            // be arbitrary for undef bytes.\n+            // This also avoids writing to the target bytes so that the backing allocation is never\n+            // touched if the bytes stay undef for the whole interpreter execution. On contemporary\n+            // operating system this can avoid physically allocating the page.\n+            let dest_alloc = self.get_raw_mut(dest.alloc_id)?;\n+            dest_alloc.mark_definedness(dest, size * length, false);\n+            dest_alloc.mark_relocation_range(relocations);\n+            return Ok(());\n+        }\n+\n         // SAFE: The above indexing would have panicked if there weren't at least `size` bytes\n         // behind `src` and `dest`. Also, we use the overlapping-safe `ptr::copy` if `src` and\n         // `dest` could possibly overlap.\n@@ -889,38 +908,23 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             }\n         }\n \n-        // copy definedness to the destination\n-        self.copy_undef_mask(src, dest, size, length)?;\n+        // now fill in all the data\n+        self.get_raw_mut(dest.alloc_id)?.mark_compressed_undef_range(\n+            &compressed,\n+            dest,\n+            size,\n+            length,\n+        );\n+\n         // copy the relocations to the destination\n         self.get_raw_mut(dest.alloc_id)?.mark_relocation_range(relocations);\n \n         Ok(())\n     }\n }\n \n-/// Undefined bytes\n+/// Machine pointer introspection.\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n-    // FIXME: Add a fast version for the common, nonoverlapping case\n-    fn copy_undef_mask(\n-        &mut self,\n-        src: Pointer<M::PointerTag>,\n-        dest: Pointer<M::PointerTag>,\n-        size: Size,\n-        repeat: u64,\n-    ) -> InterpResult<'tcx> {\n-        // The bits have to be saved locally before writing to dest in case src and dest overlap.\n-        assert_eq!(size.bytes() as usize as u64, size.bytes());\n-\n-        let src_alloc = self.get_raw(src.alloc_id)?;\n-        let compressed = src_alloc.compress_undef_range(src, size);\n-\n-        // now fill in all the data\n-        let dest_allocation = self.get_raw_mut(dest.alloc_id)?;\n-        dest_allocation.mark_compressed_undef_range(&compressed, dest, size, repeat);\n-\n-        Ok(())\n-    }\n-\n     pub fn force_ptr(\n         &self,\n         scalar: Scalar<M::PointerTag>,"}]}