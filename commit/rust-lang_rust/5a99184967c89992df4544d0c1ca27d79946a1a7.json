{"sha": "5a99184967c89992df4544d0c1ca27d79946a1a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhOTkxODQ5NjdjODk5OTJkZjQ1NDRkMGMxY2EyN2Q3OTk0NmExYTc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-08-27T18:29:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-27T18:29:00Z"}, "message": "Merge #1680\n\n1680: Correctly infer match with early return r=flodiebold a=SomeoneToIgnore\n\nFixes #1505\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "1ffe483a008c2d43441d7f04ef0b006823faf5f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ffe483a008c2d43441d7f04ef0b006823faf5f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a99184967c89992df4544d0c1ca27d79946a1a7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdZXZsCRBK7hj4Ov3rIwAAdHIIAHtkyBmXuI5Isv89obSNmYDm\nHC7ZGa6hqNHJGvW0/VZ62XomjJ4r4FPqR/JdXWJwr8j3IVTqN98EVMNJwAJV/GK0\ny/d1xSz3ygTywRtcr3NMYyxsSwMeDxhcYP0J9OF3jFd2OIAtGTy8eYc7miTAf8TE\nxxS57qMFOe0GDXqOd421MD3LlKFFvFs/gIOIwG9oamP3jhLDhbgr7F9H6ycqip3K\nexVUdoX4e8F8Jnzq8NJ0newZg362qivBW5AVWaqLoii1SzEB7p0Xr8uvojXA0UID\nUeTAIoi9Jb0hZItlpjSoi1bfkMOkqa19XvuLnCL6mwkfYqfz+vQl2V8VuVZLlVo=\n=NdN8\n-----END PGP SIGNATURE-----\n", "payload": "tree 1ffe483a008c2d43441d7f04ef0b006823faf5f0\nparent 04c2961d0c5493962e948dc8101445cc76f1d460\nparent 4adfdea1ad5aca393fa5bb9ff40fdc05827fcd56\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1566930540 +0000\ncommitter GitHub <noreply@github.com> 1566930540 +0000\n\nMerge #1680\n\n1680: Correctly infer match with early return r=flodiebold a=SomeoneToIgnore\n\nFixes #1505\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a99184967c89992df4544d0c1ca27d79946a1a7", "html_url": "https://github.com/rust-lang/rust/commit/5a99184967c89992df4544d0c1ca27d79946a1a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a99184967c89992df4544d0c1ca27d79946a1a7/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04c2961d0c5493962e948dc8101445cc76f1d460", "url": "https://api.github.com/repos/rust-lang/rust/commits/04c2961d0c5493962e948dc8101445cc76f1d460", "html_url": "https://github.com/rust-lang/rust/commit/04c2961d0c5493962e948dc8101445cc76f1d460"}, {"sha": "4adfdea1ad5aca393fa5bb9ff40fdc05827fcd56", "url": "https://api.github.com/repos/rust-lang/rust/commits/4adfdea1ad5aca393fa5bb9ff40fdc05827fcd56", "html_url": "https://github.com/rust-lang/rust/commit/4adfdea1ad5aca393fa5bb9ff40fdc05827fcd56"}], "stats": {"total": 257, "additions": 221, "deletions": 36}, "files": [{"sha": "c8ae198696e2b5d1481046e69956d3547a2c449f", "filename": "crates/ra_hir/src/expr/validation.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a99184967c89992df4544d0c1ca27d79946a1a7/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a99184967c89992df4544d0c1ca27d79946a1a7/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs?ref=5a99184967c89992df4544d0c1ca27d79946a1a7", "patch": "@@ -41,7 +41,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n \n         let body_expr = &body[body.body_expr()];\n         if let Expr::Block { statements: _, tail: Some(t) } = body_expr {\n-            self.validate_results_in_tail_expr(*t, db);\n+            self.validate_results_in_tail_expr(body.body_expr(), *t, db);\n         }\n     }\n \n@@ -97,8 +97,14 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         }\n     }\n \n-    fn validate_results_in_tail_expr(&mut self, id: ExprId, db: &impl HirDatabase) {\n-        let mismatch = match self.infer.type_mismatch_for_expr(id) {\n+    fn validate_results_in_tail_expr(\n+        &mut self,\n+        body_id: ExprId,\n+        id: ExprId,\n+        db: &impl HirDatabase,\n+    ) {\n+        // the mismatch will be on the whole block currently\n+        let mismatch = match self.infer.type_mismatch_for_expr(body_id) {\n             Some(m) => m,\n             None => return,\n         };"}, {"sha": "8129904261ac41234423eea3f7b57e9ca891af92", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 82, "deletions": 23, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/5a99184967c89992df4544d0c1ca27d79946a1a7/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a99184967c89992df4544d0c1ca27d79946a1a7/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=5a99184967c89992df4544d0c1ca27d79946a1a7", "patch": "@@ -280,8 +280,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         let ty1 = self.resolve_ty_shallow(ty1);\n         let ty2 = self.resolve_ty_shallow(ty2);\n         match (&*ty1, &*ty2) {\n-            (Ty::Unknown, ..) => true,\n-            (.., Ty::Unknown) => true,\n+            (Ty::Unknown, _) | (_, Ty::Unknown) => true,\n             (Ty::Apply(a_ty1), Ty::Apply(a_ty2)) if a_ty1.ctor == a_ty2.ctor => {\n                 self.unify_substs(&a_ty1.parameters, &a_ty2.parameters, depth + 1)\n             }\n@@ -976,24 +975,48 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         ret_ty\n     }\n \n+    /// This is similar to unify, but it makes the first type coerce to the\n+    /// second one.\n+    fn coerce(&mut self, from_ty: &Ty, to_ty: &Ty) -> bool {\n+        if is_never(from_ty) {\n+            // ! coerces to any type\n+            true\n+        } else {\n+            self.unify(from_ty, to_ty)\n+        }\n+    }\n+\n     fn infer_expr(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n+        let ty = self.infer_expr_inner(tgt_expr, expected);\n+        let could_unify = self.unify(&ty, &expected.ty);\n+        if !could_unify {\n+            self.result.type_mismatches.insert(\n+                tgt_expr,\n+                TypeMismatch { expected: expected.ty.clone(), actual: ty.clone() },\n+            );\n+        }\n+        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n+        ty\n+    }\n+\n+    fn infer_expr_inner(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n         let ty = match &body[tgt_expr] {\n             Expr::Missing => Ty::Unknown,\n             Expr::If { condition, then_branch, else_branch } => {\n                 // if let is desugared to match, so this is always simple if\n                 self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeCtor::Bool)));\n-                let then_ty = self.infer_expr(*then_branch, expected);\n-                match else_branch {\n-                    Some(else_branch) => {\n-                        self.infer_expr(*else_branch, expected);\n-                    }\n-                    None => {\n-                        // no else branch -> unit\n-                        self.unify(&then_ty, &Ty::unit()); // actually coerce\n-                    }\n+\n+                let then_ty = self.infer_expr_inner(*then_branch, &expected);\n+                self.coerce(&then_ty, &expected.ty);\n+\n+                let else_ty = match else_branch {\n+                    Some(else_branch) => self.infer_expr_inner(*else_branch, &expected),\n+                    None => Ty::unit(),\n                 };\n-                then_ty\n+                self.coerce(&else_ty, &expected.ty);\n+\n+                expected.ty.clone()\n             }\n             Expr::Block { statements, tail } => self.infer_block(statements, *tail, expected),\n             Expr::TryBlock { body } => {\n@@ -1073,12 +1096,14 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Expr::MethodCall { receiver, args, method_name, generic_args } => self\n                 .infer_method_call(tgt_expr, *receiver, &args, &method_name, generic_args.as_ref()),\n             Expr::Match { expr, arms } => {\n+                let input_ty = self.infer_expr(*expr, &Expectation::none());\n                 let expected = if expected.ty == Ty::Unknown {\n                     Expectation::has_type(self.new_type_var())\n                 } else {\n                     expected.clone()\n                 };\n-                let input_ty = self.infer_expr(*expr, &Expectation::none());\n+\n+                let mut arm_tys = Vec::with_capacity(arms.len());\n \n                 for arm in arms {\n                     for &pat in &arm.pats {\n@@ -1090,10 +1115,16 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             &Expectation::has_type(Ty::simple(TypeCtor::Bool)),\n                         );\n                     }\n-                    self.infer_expr(arm.expr, &expected);\n+                    arm_tys.push(self.infer_expr_inner(arm.expr, &expected));\n+                }\n+\n+                let lub_ty = calculate_least_upper_bound(expected.ty.clone(), &arm_tys);\n+\n+                for arm_ty in &arm_tys {\n+                    self.coerce(arm_ty, &lub_ty);\n                 }\n \n-                expected.ty\n+                lub_ty\n             }\n             Expr::Path(p) => {\n                 // FIXME this could be more efficient...\n@@ -1356,15 +1387,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         };\n         // use a new type variable if we got Ty::Unknown here\n         let ty = self.insert_type_vars_shallow(ty);\n-        let could_unify = self.unify(&ty, &expected.ty);\n         let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n         self.write_expr_ty(tgt_expr, ty.clone());\n-        if !could_unify {\n-            self.result.type_mismatches.insert(\n-                tgt_expr,\n-                TypeMismatch { expected: expected.ty.clone(), actual: ty.clone() },\n-            );\n-        }\n         ty\n     }\n \n@@ -1394,7 +1418,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 }\n             }\n         }\n-        let ty = if let Some(expr) = tail { self.infer_expr(expr, expected) } else { Ty::unit() };\n+        let ty =\n+            if let Some(expr) = tail { self.infer_expr_inner(expr, expected) } else { Ty::unit() };\n         ty\n     }\n \n@@ -1616,3 +1641,37 @@ mod diagnostics {\n         }\n     }\n }\n+\n+fn is_never(ty: &Ty) -> bool {\n+    if let Ty::Apply(ApplicationTy { ctor: TypeCtor::Never, .. }) = ty {\n+        true\n+    } else {\n+        false\n+    }\n+}\n+\n+fn calculate_least_upper_bound(expected_ty: Ty, actual_tys: &[Ty]) -> Ty {\n+    let mut all_never = true;\n+    let mut last_never_ty = None;\n+    let mut least_upper_bound = expected_ty;\n+\n+    for actual_ty in actual_tys {\n+        if is_never(actual_ty) {\n+            last_never_ty = Some(actual_ty.clone());\n+        } else {\n+            all_never = false;\n+            least_upper_bound = match (actual_ty, &least_upper_bound) {\n+                (_, Ty::Unknown)\n+                | (Ty::Infer(_), Ty::Infer(InferTy::TypeVar(_)))\n+                | (Ty::Apply(_), _) => actual_ty.clone(),\n+                _ => least_upper_bound,\n+            }\n+        }\n+    }\n+\n+    if all_never && last_never_ty.is_some() {\n+        last_never_ty.unwrap()\n+    } else {\n+        least_upper_bound\n+    }\n+}"}, {"sha": "e3eb0c3fafc6e2184b05764964f07976cad8203f", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 130, "deletions": 10, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/5a99184967c89992df4544d0c1ca27d79946a1a7/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a99184967c89992df4544d0c1ca27d79946a1a7/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=5a99184967c89992df4544d0c1ca27d79946a1a7", "patch": "@@ -718,16 +718,18 @@ fn main(foo: Foo) {\n }\n \"#),\n         @r###\"\n-[35; 38) 'foo': Foo\n-[45; 109) '{     ...   } }': ()\n-[51; 107) 'if tru...     }': ()\n-[54; 58) 'true': bool\n-[59; 67) '{      }': ()\n-[73; 107) 'if fal...     }': i32\n-[76; 81) 'false': bool\n-[82; 107) '{     ...     }': i32\n-[92; 95) 'foo': Foo\n-[92; 101) 'foo.field': i32\"###\n+   \u22ee\n+   \u22ee[35; 38) 'foo': Foo\n+   \u22ee[45; 109) '{     ...   } }': ()\n+   \u22ee[51; 107) 'if tru...     }': ()\n+   \u22ee[54; 58) 'true': bool\n+   \u22ee[59; 67) '{      }': ()\n+   \u22ee[73; 107) 'if fal...     }': ()\n+   \u22ee[76; 81) 'false': bool\n+   \u22ee[82; 107) '{     ...     }': i32\n+   \u22ee[92; 95) 'foo': Foo\n+   \u22ee[92; 101) 'foo.field': i32\n+    \"###\n     )\n }\n \n@@ -3594,3 +3596,121 @@ fn no_such_field_diagnostics() {\n \"###\n     );\n }\n+\n+mod branching_with_never_tests {\n+    use super::type_at;\n+\n+    #[test]\n+    fn if_never() {\n+        let t = type_at(\n+            r#\"\n+//- /main.rs\n+fn test() {\n+    let i = if true {\n+        loop {}\n+    } else {\n+        3.0\n+    };\n+    i<|>\n+    ()\n+}\n+\"#,\n+        );\n+        assert_eq!(t, \"f64\");\n+    }\n+\n+    #[test]\n+    fn if_else_never() {\n+        let t = type_at(\n+            r#\"\n+//- /main.rs\n+fn test(input: bool) {\n+    let i = if input {\n+        2.0\n+    } else {\n+        return\n+    };\n+    i<|>\n+    ()\n+}\n+\"#,\n+        );\n+        assert_eq!(t, \"f64\");\n+    }\n+\n+    #[test]\n+    fn match_first_arm_never() {\n+        let t = type_at(\n+            r#\"\n+//- /main.rs\n+fn test(a: i32) {\n+    let i = match a {\n+        1 => return,\n+        2 => 2.0,\n+        3 => loop {},\n+        _ => 3.0,\n+    };\n+    i<|>\n+    ()\n+}\n+\"#,\n+        );\n+        assert_eq!(t, \"f64\");\n+    }\n+\n+    #[test]\n+    fn match_second_arm_never() {\n+        let t = type_at(\n+            r#\"\n+//- /main.rs\n+fn test(a: i32) {\n+    let i = match a {\n+        1 => 3.0,\n+        2 => loop {},\n+        3 => 3.0,\n+        _ => return,\n+    };\n+    i<|>\n+    ()\n+}\n+\"#,\n+        );\n+        assert_eq!(t, \"f64\");\n+    }\n+\n+    #[test]\n+    fn match_all_arms_never() {\n+        let t = type_at(\n+            r#\"\n+//- /main.rs\n+fn test(a: i32) {\n+    let i = match a {\n+        2 => return,\n+        _ => loop {},\n+    };\n+    i<|>\n+    ()\n+}\n+\"#,\n+        );\n+        assert_eq!(t, \"!\");\n+    }\n+\n+    #[test]\n+    fn match_no_never_arms() {\n+        let t = type_at(\n+            r#\"\n+//- /main.rs\n+fn test(a: i32) {\n+    let i = match a {\n+        2 => 2.0,\n+        _ => 3.0,\n+    };\n+    i<|>\n+    ()\n+}\n+\"#,\n+        );\n+        assert_eq!(t, \"f64\");\n+    }\n+}"}]}