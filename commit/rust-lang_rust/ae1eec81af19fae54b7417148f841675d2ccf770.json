{"sha": "ae1eec81af19fae54b7417148f841675d2ccf770", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlMWVlYzgxYWYxOWZhZTU0Yjc0MTcxNDhmODQxNjc1ZDJjY2Y3NzA=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-08-16T21:41:45Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-08-19T20:11:14Z"}, "message": "Rewrite match expressions (continued).", "tree": {"sha": "8eb6f31b0ccf0048f779da8cbf7b412ace84b64a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8eb6f31b0ccf0048f779da8cbf7b412ace84b64a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae1eec81af19fae54b7417148f841675d2ccf770", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae1eec81af19fae54b7417148f841675d2ccf770", "html_url": "https://github.com/rust-lang/rust/commit/ae1eec81af19fae54b7417148f841675d2ccf770", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae1eec81af19fae54b7417148f841675d2ccf770/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a43e2b5ae837604511557133f5e7554184465677", "url": "https://api.github.com/repos/rust-lang/rust/commits/a43e2b5ae837604511557133f5e7554184465677", "html_url": "https://github.com/rust-lang/rust/commit/a43e2b5ae837604511557133f5e7554184465677"}], "stats": {"total": 120, "additions": 103, "deletions": 17}, "files": [{"sha": "face73d72f0f1eb4b5c7d0dc21595f83483ac6c6", "filename": "src/expr.rs", "status": "modified", "additions": 91, "deletions": 14, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/ae1eec81af19fae54b7417148f841675d2ccf770/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae1eec81af19fae54b7417148f841675d2ccf770/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=ae1eec81af19fae54b7417148f841675d2ccf770", "patch": "@@ -113,7 +113,7 @@ impl Rewrite for ast::Expr {\n impl Rewrite for ast::Block {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n         let user_str = context.codemap.span_to_snippet(self.span).unwrap();\n-        if user_str == \"{}\" && width > 1 {\n+        if user_str == \"{}\" && width >= 2 {\n             return Some(user_str);\n         }\n \n@@ -316,7 +316,9 @@ fn rewrite_match(context: &RewriteContext,\n                  width: usize,\n                  offset: usize)\n                  -> Option<String> {\n-    // TODO comments etc. (I am somewhat surprised we don't need handling for these).\n+    if arms.len() == 0 {\n+        return None;\n+    }\n \n     // `match `cond` {`\n     let cond_str = try_opt!(cond.rewrite(context, width - 8, offset + 6));\n@@ -326,28 +328,101 @@ fn rewrite_match(context: &RewriteContext,\n     let nested_context = context.nested_context();\n     let arm_indent_str = make_indent(nested_context.block_indent);\n \n-    for arm in arms {\n+    let open_brace_pos = span_after(mk_sp(cond.span.hi, arm_start_pos(&arms[0])),\n+                                    \"{\",\n+                                    context.codemap);\n+\n+    for (i, arm) in arms.iter().enumerate() {\n+        // Make sure we get the stuff between arms.\n+        let missed_str = if i == 0 {\n+            context.codemap.span_to_snippet(mk_sp(open_brace_pos + BytePos(1),\n+                                                  arm_start_pos(arm))).unwrap()\n+        } else {\n+            context.codemap.span_to_snippet(mk_sp(arm_end_pos(&arms[i-1]),\n+                                                  arm_start_pos(arm))).unwrap()\n+        };\n+        let missed_str = match missed_str.find_uncommented(\",\") {\n+            Some(n) => &missed_str[n+1..],\n+            None => &missed_str[..],\n+        };\n+        // first = first non-whitespace byte index.\n+        let first = missed_str.find(|c: char| !c.is_whitespace()).unwrap_or(missed_str.len());\n+        if missed_str[..first].chars().filter(|c| c == &'\\n').count() >= 2 {\n+            // There were multiple line breaks which got trimmed to nothing\n+            // that means there should be some vertical white space. Lets\n+            // replace that with just one blank line.\n+            result.push('\\n');\n+        }\n+        let missed_str = missed_str.trim();\n+        if missed_str.len() > 0 {\n+            result.push('\\n');\n+            result.push_str(&arm_indent_str);\n+            result.push_str(missed_str);\n+        }\n         result.push('\\n');\n         result.push_str(&arm_indent_str);\n-        result.push_str(&&try_opt!(arm.rewrite(&nested_context,\n-                                               context.config.max_width -\n-                                                   nested_context.block_indent,\n-                                               nested_context.block_indent)));\n+\n+        let arm_str = arm.rewrite(&nested_context,\n+                                  context.config.max_width -\n+                                      nested_context.block_indent,\n+                                  nested_context.block_indent);\n+        if let Some(ref arm_str) = arm_str {\n+            result.push_str(arm_str);\n+        } else {\n+            // We couldn't format the arm, just reproduce the source.\n+            let snippet = context.codemap.span_to_snippet(mk_sp(arm_start_pos(arm),\n+                                                                arm_end_pos(arm))).unwrap();\n+            result.push_str(&snippet);\n+        }\n     }\n \n+    // We'll miss any comments etc. between the last arm and the end of the\n+    // match expression, but meh.\n+\n     result.push('\\n');\n     result.push_str(&make_indent(block_indent));\n     result.push('}');\n     Some(result)\n }\n \n+fn arm_start_pos(arm: &ast::Arm) -> BytePos {\n+    let &ast::Arm { ref attrs, ref pats, .. } = arm;\n+    if attrs.len() > 0 {\n+        return attrs[0].span.lo\n+    }\n+\n+    pats[0].span.lo\n+}\n+\n+fn arm_end_pos(arm: &ast::Arm) -> BytePos {\n+    arm.body.span.hi\n+}\n+\n // Match arms.\n impl Rewrite for ast::Arm {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n         let &ast::Arm { ref attrs, ref pats, ref guard, ref body } = self;\n         let indent_str = make_indent(offset);\n \n-        // TODO attrs\n+        // FIXME this is all a bit grotty, would be nice to abstract out the\n+        // treatment of attributes.\n+        let attr_str = if attrs.len() > 0 {\n+            // We only use this visitor for the attributes, should we use it for\n+            // more?\n+            let mut attr_visitor = FmtVisitor::from_codemap(context.codemap, context.config);\n+            attr_visitor.block_indent = context.block_indent;\n+            attr_visitor.last_pos = attrs[0].span.lo;\n+            if attr_visitor.visit_attrs(attrs) {\n+                // Attributes included a skip instruction.\n+                let snippet = context.codemap.span_to_snippet(mk_sp(attrs[0].span.lo,\n+                                                                    body.span.hi)).unwrap();\n+                return Some(snippet);\n+            }\n+            attr_visitor.format_missing(pats[0].span.lo);\n+            attr_visitor.buffer.to_string()\n+        } else {\n+            String::new()\n+        };\n \n         // Patterns\n         let pat_strs = pats.iter().map(|p| p.rewrite(context,\n@@ -393,9 +468,6 @@ impl Rewrite for ast::Arm {\n             pats_str.push_str(&p);\n         }\n \n-        // TODO probably want to compute the guard width first, then the rest\n-        // TODO also, only subtract the guard width from the last pattern.\n-        // If guard.\n         let guard_str = try_opt!(rewrite_guard(context, guard, width, offset, pats_width));\n \n         let pats_str = format!(\"{}{}\", pats_str, guard_str);\n@@ -419,21 +491,26 @@ impl Rewrite for ast::Arm {\n                                                      budget,\n                                                      offset + context.config.tab_spaces) {\n                 if first_line_width(body_str) <= budget {\n-                    return Some(format!(\"{} => {}{}\", pats_str, body_str, comma));\n+                    return Some(format!(\"{}{} => {}{}\",\n+                                        attr_str.trim_left(),\n+                                        pats_str,\n+                                        body_str,\n+                                        comma));\n                 }\n             }\n         }\n \n         // We have to push the body to the next line.\n-        if comma.len() > 0 {\n+        if comma.len() == 0 {\n             // We're trying to fit a block in, but it still failed, give up.\n             return None;\n         }\n \n         let body_str = try_opt!(body.rewrite(context,\n                                              width - context.config.tab_spaces,\n                                              offset + context.config.tab_spaces));\n-        Some(format!(\"{} =>\\n{}{}\",\n+        Some(format!(\"{}{} =>\\n{}{},\",\n+                     attr_str.trim_left(),\n                      pats_str,\n                      make_indent(offset + context.config.tab_spaces),\n                      body_str))"}, {"sha": "00e18c3a65b47e397a507231128951698522be30", "filename": "src/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae1eec81af19fae54b7417148f841675d2ccf770/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae1eec81af19fae54b7417148f841675d2ccf770/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=ae1eec81af19fae54b7417148f841675d2ccf770", "patch": "@@ -95,7 +95,7 @@ pub fn first_line_width(s: &str) -> usize {\n #[inline]\n pub fn last_line_width(s: &str) -> usize {\n     match s.rfind('\\n') {\n-        Some(n) => s.len() - n,\n+        Some(n) => s.len() - n - 1,\n         None => s.len(),\n     }\n }"}, {"sha": "04bc7c87127b46355ff8c6d59001310940acc9db", "filename": "tests/target/match.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ae1eec81af19fae54b7417148f841675d2ccf770/tests%2Ftarget%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae1eec81af19fae54b7417148f841675d2ccf770/tests%2Ftarget%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmatch.rs?ref=ae1eec81af19fae54b7417148f841675d2ccf770", "patch": "@@ -28,15 +28,24 @@ fn foo() {\n         Patternnnnnnnnnnnnnnnnnnn if looooooooooooooooooong_guard => meh,\n \n         Patternnnnnnnnnnnnnnnnnnnnnnnnn |\n-        Patternnnnnnnnnnnnnnnnnnnnnnnnn\n-            if looooooooooooooooooooooooooooooooooooooooong_guard => meh,\n+        Patternnnnnnnnnnnnnnnnnnnnnnnnn if looooooooooooooooooooooooooooooooooooooooong_guard =>\n+            meh,\n+\n+        // Test that earlier patterns can take the guard space\n+        (aaaa, bbbbb, ccccccc, aaaaa, bbbbbbbb, cccccc, aaaa, bbbbbbbb, cccccc, dddddd) |\n+        Patternnnnnnnnnnnnnnnnnnnnnnnnn if loooooooooooooooooooooooooooooooooooooooooong_guard => {}\n+\n         _ => {}\n     }\n \n     let whatever = match something {\n         /// DOC COMMENT!\n         Some(_) => 42,\n+        // COmment on an attribute.\n         #[an_attribute]\n+        // Comment after an attribute.\n         None => 0,\n+        #[rustfmt_skip]\n+        Blurb     =>     {                  }\n     };\n }"}]}