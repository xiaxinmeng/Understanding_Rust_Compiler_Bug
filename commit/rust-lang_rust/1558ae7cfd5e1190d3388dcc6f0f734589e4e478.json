{"sha": "1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1NThhZTdjZmQ1ZTExOTBkMzM4OGRjYzZmMGY3MzQ1ODllNGU0Nzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-20T15:47:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-20T15:47:39Z"}, "message": "Auto merge of #51880 - varkor:generics-hir-generalisation-followup, r=eddyb\n\nThe Great Generics Generalisation: HIR Followup\n\nAddresses the final comments in #48149.\n\nr? @eddyb, but there are a few things I have yet to clean up. Making the PR now to more easily see when things break.\n\ncc @yodaldevoid", "tree": {"sha": "e5052cf7aa779cc0cd67d31c8723a0fd88ce5ff1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5052cf7aa779cc0cd67d31c8723a0fd88ce5ff1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "html_url": "https://github.com/rust-lang/rust/commit/1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf1e461173e3936e4014cc951dfbdd7d9ec9190b", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf1e461173e3936e4014cc951dfbdd7d9ec9190b", "html_url": "https://github.com/rust-lang/rust/commit/bf1e461173e3936e4014cc951dfbdd7d9ec9190b"}, {"sha": "ee9bd0fd99ef5049f53b5d8233369187637cb71c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee9bd0fd99ef5049f53b5d8233369187637cb71c", "html_url": "https://github.com/rust-lang/rust/commit/ee9bd0fd99ef5049f53b5d8233369187637cb71c"}], "stats": {"total": 1774, "additions": 973, "deletions": 801}, "files": [{"sha": "43cc33f422f53357ab1447216116b247167688c6", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -401,6 +401,13 @@ impl GenericArg {\n             GenericArg::Type(t) => t.span,\n         }\n     }\n+\n+    pub fn id(&self) -> NodeId {\n+        match self {\n+            GenericArg::Lifetime(l) => l.id,\n+            GenericArg::Type(t) => t.id,\n+        }\n+    }\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n@@ -445,6 +452,22 @@ impl GenericArgs {\n         }\n         bug!(\"GenericArgs::inputs: not a `Fn(T) -> U`\");\n     }\n+\n+    pub fn own_counts(&self) -> GenericParamCount {\n+        // We could cache this as a property of `GenericParamCount`, but\n+        // the aim is to refactor this away entirely eventually and the\n+        // presence of this method will be a constant reminder.\n+        let mut own_counts: GenericParamCount = Default::default();\n+\n+        for arg in &self.args {\n+            match arg {\n+                GenericArg::Lifetime(_) => own_counts.lifetimes += 1,\n+                GenericArg::Type(_) => own_counts.types += 1,\n+            };\n+        }\n+\n+        own_counts\n+    }\n }\n \n /// A modifier on a bound, currently this is only used for `?Sized`, where the\n@@ -503,6 +526,7 @@ pub struct GenericParam {\n     pub kind: GenericParamKind,\n }\n \n+#[derive(Default)]\n pub struct GenericParamCount {\n     pub lifetimes: usize,\n     pub types: usize,\n@@ -533,10 +557,7 @@ impl Generics {\n         // We could cache this as a property of `GenericParamCount`, but\n         // the aim is to refactor this away entirely eventually and the\n         // presence of this method will be a constant reminder.\n-        let mut own_counts = GenericParamCount {\n-            lifetimes: 0,\n-            types: 0,\n-        };\n+        let mut own_counts: GenericParamCount = Default::default();\n \n         for param in &self.params {\n             match param.kind {"}, {"sha": "3d8bb6b825b38ec40e599a6086ae1d053c75e0a7", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -20,7 +20,7 @@ use hir::map as hir_map;\n use hir::def::Def;\n use hir::def_id::{DefId, CrateNum};\n use rustc_data_structures::sync::Lrc;\n-use ty::{self, TyCtxt, GenericParamDefKind};\n+use ty::{self, TyCtxt};\n use ty::query::Providers;\n use middle::privacy;\n use session::config;\n@@ -34,18 +34,6 @@ use hir::intravisit::{Visitor, NestedVisitorMap};\n use hir::itemlikevisit::ItemLikeVisitor;\n use hir::intravisit;\n \n-// Returns true if the given set of generics implies that the item it's\n-// associated with must be inlined.\n-fn generics_require_inlining(generics: &ty::Generics) -> bool {\n-    for param in &generics.params {\n-        match param.kind {\n-            GenericParamDefKind::Lifetime { .. } => {}\n-            GenericParamDefKind::Type { .. } => return true,\n-        }\n-    }\n-    false\n-}\n-\n // Returns true if the given item must be inlined because it may be\n // monomorphized or it was marked with `#[inline]`. This will only return\n // true for functions.\n@@ -60,7 +48,7 @@ fn item_might_be_inlined(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         hir::ItemKind::Impl(..) |\n         hir::ItemKind::Fn(..) => {\n             let generics = tcx.generics_of(tcx.hir.local_def_id(item.id));\n-            generics_require_inlining(generics)\n+            generics.requires_monomorphization(tcx)\n         }\n         _ => false,\n     }\n@@ -71,7 +59,7 @@ fn method_might_be_inlined<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      impl_src: DefId) -> bool {\n     let codegen_fn_attrs = tcx.codegen_fn_attrs(impl_item.hir_id.owner_def_id());\n     let generics = tcx.generics_of(tcx.hir.local_def_id(impl_item.id));\n-    if codegen_fn_attrs.requests_inline() || generics_require_inlining(generics) {\n+    if codegen_fn_attrs.requests_inline() || generics.requires_monomorphization(tcx) {\n         return true\n     }\n     if let Some(impl_node_id) = tcx.hir.as_local_node_id(impl_src) {\n@@ -189,8 +177,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::ImplItemKind::Method(..) => {\n                         let attrs = self.tcx.codegen_fn_attrs(def_id);\n                         let generics = self.tcx.generics_of(def_id);\n-                        if generics_require_inlining(&generics) ||\n-                                attrs.requests_inline() {\n+                        if generics.requires_monomorphization(self.tcx) || attrs.requests_inline() {\n                             true\n                         } else {\n                             let impl_did = self.tcx\n@@ -203,7 +190,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                             match self.tcx.hir.expect_item(impl_node_id).node {\n                                 hir::ItemKind::Impl(..) => {\n                                     let generics = self.tcx.generics_of(impl_did);\n-                                    generics_require_inlining(&generics)\n+                                    generics.requires_monomorphization(self.tcx)\n                                 }\n                                 _ => false\n                             }"}, {"sha": "f6d21ca5861fbf6c45720f8e92abe368877ce2d5", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -881,6 +881,7 @@ impl GenericParamDef {\n     }\n }\n \n+#[derive(Default)]\n pub struct GenericParamCount {\n     pub lifetimes: usize,\n     pub types: usize,\n@@ -913,15 +914,12 @@ impl<'a, 'gcx, 'tcx> Generics {\n         // We could cache this as a property of `GenericParamCount`, but\n         // the aim is to refactor this away entirely eventually and the\n         // presence of this method will be a constant reminder.\n-        let mut own_counts = GenericParamCount {\n-            lifetimes: 0,\n-            types: 0,\n-        };\n+        let mut own_counts: GenericParamCount = Default::default();\n \n         for param in &self.params {\n             match param.kind {\n                 GenericParamDefKind::Lifetime => own_counts.lifetimes += 1,\n-                GenericParamDefKind::Type {..} => own_counts.types += 1,\n+                GenericParamDefKind::Type { .. } => own_counts.types += 1,\n             };\n         }\n \n@@ -931,7 +929,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n     pub fn requires_monomorphization(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n         for param in &self.params {\n             match param.kind {\n-                GenericParamDefKind::Type {..} => return true,\n+                GenericParamDefKind::Type { .. } => return true,\n                 GenericParamDefKind::Lifetime => {}\n             }\n         }"}, {"sha": "a6ff979f472af46bd7b4ee1c677e7237510237a0", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -231,7 +231,6 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                     mk_kind: &mut F)\n     where F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>\n     {\n-\n         if let Some(def_id) = defs.parent {\n             let parent_defs = tcx.generics_of(def_id);\n             Substs::fill_item(substs, tcx, parent_defs, mk_kind);"}, {"sha": "9513086667b28abf082a8a7c2f531baaff057fa0", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -262,10 +262,7 @@ impl PrintContext {\n         let verbose = self.is_verbose;\n         let mut num_supplied_defaults = 0;\n         let mut has_self = false;\n-        let mut own_counts = GenericParamCount {\n-            lifetimes: 0,\n-            types: 0,\n-        };\n+        let mut own_counts: GenericParamCount = Default::default();\n         let mut is_value_path = false;\n         let fn_trait_kind = ty::tls::with(|tcx| {\n             // Unfortunately, some kinds of items (e.g., closures) don't have"}, {"sha": "32a68738fb28dda37051e5e7813d3b0a931b6c6b", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -819,14 +819,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         if let hir::ItemKind::Enum(ref enum_definition, _) = it.node {\n             let item_def_id = cx.tcx.hir.local_def_id(it.id);\n-            let generics = cx.tcx.generics_of(item_def_id);\n-            for param in &generics.params {\n-                match param.kind {\n-                    ty::GenericParamDefKind::Lifetime { .. } => {},\n-                    ty::GenericParamDefKind::Type { .. } => return,\n-                }\n-            }\n-            // Sizes only make sense for non-generic types.\n             let t = cx.tcx.type_of(item_def_id);\n             let ty = cx.tcx.erase_regions(&t);\n             match cx.layout_of(ty) {"}, {"sha": "1b13c240a87e309556be7c2c1538f07c4f08db38", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -1262,12 +1262,9 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 hir::ItemKind::Const(..) => self.encode_optimized_mir(def_id),\n                 hir::ItemKind::Fn(_, header, ..) => {\n                     let generics = tcx.generics_of(def_id);\n-                    let has_types = generics.params.iter().any(|param| match param.kind {\n-                        ty::GenericParamDefKind::Type { .. } => true,\n-                        _ => false,\n-                    });\n                     let needs_inline =\n-                        (has_types || tcx.codegen_fn_attrs(def_id).requests_inline()) &&\n+                        (generics.requires_monomorphization(tcx) ||\n+                         tcx.codegen_fn_attrs(def_id).requests_inline()) &&\n                             !self.metadata_output_only();\n                     let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n                     if needs_inline\n@@ -1683,15 +1680,17 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_info_for_generics(&mut self, generics: &hir::Generics) {\n-        generics.params.iter().for_each(|param| match param.kind {\n-            hir::GenericParamKind::Lifetime { .. } => {}\n-            hir::GenericParamKind::Type { ref default, .. } => {\n-                let def_id = self.tcx.hir.local_def_id(param.id);\n-                let has_default = Untracked(default.is_some());\n-                let encode_info = IsolatedEncoder::encode_info_for_ty_param;\n-                self.record(def_id, encode_info, (def_id, has_default));\n+        for param in &generics.params {\n+            match param.kind {\n+                hir::GenericParamKind::Lifetime { .. } => {}\n+                hir::GenericParamKind::Type { ref default, .. } => {\n+                    let def_id = self.tcx.hir.local_def_id(param.id);\n+                    let has_default = Untracked(default.is_some());\n+                    let encode_info = IsolatedEncoder::encode_info_for_ty_param;\n+                    self.record(def_id, encode_info, (def_id, has_default));\n+                }\n             }\n-        });\n+        }\n     }\n \n     fn encode_info_for_ty(&mut self, ty: &hir::Ty) {"}, {"sha": "11d1d85c97d394a2d7bd44cd7aa933d1f02de0ba", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -539,10 +539,9 @@ impl<'a> Visitor<'a> for NestedImplTraitVisitor<'a> {\n     fn visit_generic_args(&mut self, _: Span, generic_args: &'a GenericArgs) {\n         match *generic_args {\n             GenericArgs::AngleBracketed(ref data) => {\n-                data.args.iter().for_each(|arg| match arg {\n-                    GenericArg::Type(ty) => self.visit_ty(ty),\n-                    _ => {}\n-                });\n+                for arg in &data.args {\n+                    self.visit_generic_arg(arg)\n+                }\n                 for type_binding in &data.bindings {\n                     // Type bindings such as `Item=impl Debug` in `Iterator<Item=Debug>`\n                     // are allowed to contain nested `impl Trait`."}, {"sha": "d9c3fc221dce1c6b9deae099665e2ab3f76fded2", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -23,7 +23,7 @@ extern crate rustc_typeck;\n extern crate syntax_pos;\n extern crate rustc_data_structures;\n \n-use rustc::hir::{self, GenericParamKind, PatKind};\n+use rustc::hir::{self, PatKind};\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, CrateNum, DefId};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n@@ -1270,14 +1270,11 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n-        generics.params.iter().for_each(|param| match param.kind {\n-            GenericParamKind::Lifetime { .. } => {}\n-            GenericParamKind::Type { .. } => {\n-                for bound in &param.bounds {\n-                    self.check_generic_bound(bound);\n-                }\n+        for param in &generics.params {\n+            for bound in &param.bounds {\n+                self.check_generic_bound(bound);\n             }\n-        });\n+        }\n         for predicate in &generics.where_clause.predicates {\n             match predicate {\n                 &hir::WherePredicate::BoundPredicate(ref bound_pred) => {"}, {"sha": "71a7fde202942ac63992b04f679e7484ee6e9adf", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 27, "deletions": 24, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -822,11 +822,12 @@ impl<'a, 'tcx, 'cl> Visitor<'tcx> for Resolver<'a, 'cl> {\n             .filter_map(|param| match param.kind {\n                 GenericParamKind::Lifetime { .. } => None,\n                 GenericParamKind::Type { ref default, .. } => {\n-                    if found_default || default.is_some() {\n-                        found_default = true;\n-                        return Some((Ident::with_empty_ctxt(param.ident.name), Def::Err));\n+                    found_default |= default.is_some();\n+                    if found_default {\n+                        Some((Ident::with_empty_ctxt(param.ident.name), Def::Err))\n+                    } else {\n+                        None\n                     }\n-                    None\n                 }\n             }));\n \n@@ -2339,28 +2340,30 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             HasTypeParameters(generics, rib_kind) => {\n                 let mut function_type_rib = Rib::new(rib_kind);\n                 let mut seen_bindings = FxHashMap();\n-                generics.params.iter().for_each(|param| match param.kind {\n-                    GenericParamKind::Lifetime { .. } => {}\n-                    GenericParamKind::Type { .. } => {\n-                        let ident = param.ident.modern();\n-                        debug!(\"with_type_parameter_rib: {}\", param.id);\n-\n-                        if seen_bindings.contains_key(&ident) {\n-                            let span = seen_bindings.get(&ident).unwrap();\n-                            let err = ResolutionError::NameAlreadyUsedInTypeParameterList(\n-                                ident.name,\n-                                span,\n-                            );\n-                            resolve_error(self, param.ident.span, err);\n-                        }\n-                        seen_bindings.entry(ident).or_insert(param.ident.span);\n+                for param in &generics.params {\n+                    match param.kind {\n+                        GenericParamKind::Lifetime { .. } => {}\n+                        GenericParamKind::Type { .. } => {\n+                            let ident = param.ident.modern();\n+                            debug!(\"with_type_parameter_rib: {}\", param.id);\n+\n+                            if seen_bindings.contains_key(&ident) {\n+                                let span = seen_bindings.get(&ident).unwrap();\n+                                let err = ResolutionError::NameAlreadyUsedInTypeParameterList(\n+                                    ident.name,\n+                                    span,\n+                                );\n+                                resolve_error(self, param.ident.span, err);\n+                            }\n+                            seen_bindings.entry(ident).or_insert(param.ident.span);\n \n-                    // Plain insert (no renaming).\n-                    let def = Def::TyParam(self.definitions.local_def_id(param.id));\n-                        function_type_rib.bindings.insert(ident, def);\n-                        self.record_def(param.id, PathResolution::new(def));\n+                        // Plain insert (no renaming).\n+                        let def = Def::TyParam(self.definitions.local_def_id(param.id));\n+                            function_type_rib.bindings.insert(ident, def);\n+                            self.record_def(param.id, PathResolution::new(def));\n+                        }\n                     }\n-                });\n+                }\n                 self.ribs[TypeNS].push(function_type_rib);\n             }\n "}, {"sha": "dc9310cdcdaa40990e0cf71db31a6b41896ef0a1", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -824,10 +824,12 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             if let Some(ref generic_args) = seg.args {\n                 match **generic_args {\n                     ast::GenericArgs::AngleBracketed(ref data) => {\n-                        data.args.iter().for_each(|arg| match arg {\n-                            ast::GenericArg::Type(ty) => self.visit_ty(ty),\n-                            _ => {}\n-                        });\n+                        for arg in &data.args {\n+                            match arg {\n+                                ast::GenericArg::Type(ty) => self.visit_ty(ty),\n+                                _ => {}\n+                            }\n+                        }\n                     }\n                     ast::GenericArgs::Parenthesized(ref data) => {\n                         for t in &data.inputs {\n@@ -911,10 +913,12 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         // Explicit types in the turbo-fish.\n         if let Some(ref generic_args) = seg.args {\n             if let ast::GenericArgs::AngleBracketed(ref data) = **generic_args {\n-                data.args.iter().for_each(|arg| match arg {\n-                    ast::GenericArg::Type(ty) => self.visit_ty(ty),\n-                    _ => {}\n-                });\n+                for arg in &data.args {\n+                    match arg {\n+                        ast::GenericArg::Type(ty) => self.visit_ty(ty),\n+                        _ => {}\n+                    }\n+                }\n             }\n         }\n \n@@ -1522,19 +1526,21 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n     }\n \n     fn visit_generics(&mut self, generics: &'l ast::Generics) {\n-        generics.params.iter().for_each(|param| match param.kind {\n-            ast::GenericParamKind::Lifetime { .. } => {}\n-            ast::GenericParamKind::Type { ref default, .. } => {\n-                for bound in &param.bounds {\n-                    if let ast::GenericBound::Trait(ref trait_ref, _) = *bound {\n-                        self.process_path(trait_ref.trait_ref.ref_id, &trait_ref.trait_ref.path)\n+        for param in &generics.params {\n+            match param.kind {\n+                ast::GenericParamKind::Lifetime { .. } => {}\n+                ast::GenericParamKind::Type { ref default, .. } => {\n+                    for bound in &param.bounds {\n+                        if let ast::GenericBound::Trait(ref trait_ref, _) = *bound {\n+                            self.process_path(trait_ref.trait_ref.ref_id, &trait_ref.trait_ref.path)\n+                        }\n+                    }\n+                    if let Some(ref ty) = default {\n+                        self.visit_ty(&ty);\n                     }\n-                }\n-                if let Some(ref ty) = default {\n-                    self.visit_ty(&ty);\n                 }\n             }\n-        });\n+        }\n     }\n \n     fn visit_ty(&mut self, t: &'l ast::Ty) {"}, {"sha": "ccdb751bc4eeda4eb743283bd6104768313f215b", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 467, "deletions": 196, "changes": 663, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -13,27 +13,31 @@\n //! is parameterized by an instance of `AstConv`.\n \n use rustc_data_structures::accumulate_vec::AccumulateVec;\n-use hir::{self, GenericArg};\n+use rustc_data_structures::array_vec::ArrayVec;\n+use hir::{self, GenericArg, GenericArgs};\n use hir::def::Def;\n use hir::def_id::DefId;\n+use hir::HirVec;\n use middle::resolve_lifetime as rl;\n use namespace::Namespace;\n-use rustc::ty::subst::{Subst, Substs};\n+use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, ToPredicate, TypeFoldable};\n-use rustc::ty::GenericParamDefKind;\n+use rustc::ty::{GenericParamDef, GenericParamDefKind};\n use rustc::ty::wf::object_region_bounds;\n use rustc_target::spec::abi;\n use std::slice;\n use require_c_abi_if_variadic;\n use util::common::ErrorReported;\n use util::nodemap::{FxHashSet, FxHashMap};\n-use errors::FatalError;\n+use errors::{FatalError, DiagnosticId};\n+use lint;\n \n use std::iter;\n use syntax::ast;\n+use syntax::ptr::P;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n-use syntax_pos::Span;\n+use syntax_pos::{Span, MultiSpan};\n \n pub trait AstConv<'gcx, 'tcx> {\n     fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx>;\n@@ -88,9 +92,17 @@ struct ConvertedBinding<'tcx> {\n     span: Span,\n }\n \n-struct ParamRange {\n-    required: usize,\n-    accepted: usize\n+#[derive(PartialEq)]\n+enum GenericArgPosition {\n+    Type,\n+    Value, // e.g. functions\n+    MethodCall,\n+}\n+\n+// FIXME(#53525): these error codes should all be unified.\n+struct GenericArgMismatchErrorCode {\n+    lifetimes: (&'static str, &'static str),\n+    types: (&'static str, &'static str),\n }\n \n /// Dummy type used for the `Self` of a `TraitRef` created for converting\n@@ -176,21 +188,370 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         -> &'tcx Substs<'tcx>\n     {\n \n-        let (substs, assoc_bindings) =\n-            item_segment.with_generic_args(|generic_args| {\n-                self.create_substs_for_ast_path(\n-                    span,\n-                    def_id,\n-                    generic_args,\n-                    item_segment.infer_types,\n-                    None)\n-            });\n+        let (substs, assoc_bindings) = item_segment.with_generic_args(|generic_args| {\n+            self.create_substs_for_ast_path(\n+                span,\n+                def_id,\n+                generic_args,\n+                item_segment.infer_types,\n+                None,\n+            )\n+        });\n \n-        assoc_bindings.first().map(|b| self.prohibit_projection(b.span));\n+        assoc_bindings.first().map(|b| Self::prohibit_assoc_ty_binding(self.tcx(), b.span));\n \n         substs\n     }\n \n+    /// Report error if there is an explicit type parameter when using `impl Trait`.\n+    fn check_impl_trait(\n+        tcx: TyCtxt,\n+        span: Span,\n+        seg: &hir::PathSegment,\n+        generics: &ty::Generics,\n+    ) -> bool {\n+        let explicit = !seg.infer_types;\n+        let impl_trait = generics.params.iter().any(|param| match param.kind {\n+            ty::GenericParamDefKind::Type {\n+                synthetic: Some(hir::SyntheticTyParamKind::ImplTrait), ..\n+            } => true,\n+            _ => false,\n+        });\n+\n+        if explicit && impl_trait {\n+            let mut err = struct_span_err! {\n+                tcx.sess,\n+                span,\n+                E0632,\n+                \"cannot provide explicit type parameters when `impl Trait` is \\\n+                used in argument position.\"\n+            };\n+\n+            err.emit();\n+        }\n+\n+        impl_trait\n+    }\n+\n+    /// Check that the correct number of generic arguments have been provided.\n+    /// Used specifically for function calls.\n+    pub fn check_generic_arg_count_for_call(\n+        tcx: TyCtxt,\n+        span: Span,\n+        def: &ty::Generics,\n+        seg: &hir::PathSegment,\n+        is_method_call: bool,\n+    ) -> bool {\n+        let empty_args = P(hir::GenericArgs {\n+            args: HirVec::new(), bindings: HirVec::new(), parenthesized: false,\n+        });\n+        let suppress_mismatch = Self::check_impl_trait(tcx, span, seg, &def);\n+        Self::check_generic_arg_count(\n+            tcx,\n+            span,\n+            def,\n+            if let Some(ref args) = seg.args {\n+                args\n+            } else {\n+                &empty_args\n+            },\n+            if is_method_call {\n+                GenericArgPosition::MethodCall\n+            } else {\n+                GenericArgPosition::Value\n+            },\n+            def.parent.is_none() && def.has_self, // `has_self`\n+            seg.infer_types || suppress_mismatch, // `infer_types`\n+            GenericArgMismatchErrorCode {\n+                lifetimes: (\"E0090\", \"E0088\"),\n+                types: (\"E0089\", \"E0087\"),\n+            },\n+        )\n+    }\n+\n+    /// Check that the correct number of generic arguments have been provided.\n+    /// This is used both for datatypes and function calls.\n+    fn check_generic_arg_count(\n+        tcx: TyCtxt,\n+        span: Span,\n+        def: &ty::Generics,\n+        args: &hir::GenericArgs,\n+        position: GenericArgPosition,\n+        has_self: bool,\n+        infer_types: bool,\n+        error_codes: GenericArgMismatchErrorCode,\n+    ) -> bool {\n+        // At this stage we are guaranteed that the generic arguments are in the correct order, e.g.\n+        // that lifetimes will proceed types. So it suffices to check the number of each generic\n+        // arguments in order to validate them with respect to the generic parameters.\n+        let param_counts = def.own_counts();\n+        let arg_counts = args.own_counts();\n+        let infer_lifetimes = position != GenericArgPosition::Type && arg_counts.lifetimes == 0;\n+\n+        let mut defaults: ty::GenericParamCount = Default::default();\n+        for param in &def.params {\n+            match param.kind {\n+                GenericParamDefKind::Lifetime => {}\n+                GenericParamDefKind::Type { has_default, .. } => {\n+                    defaults.types += has_default as usize\n+                }\n+            };\n+        }\n+\n+        if position != GenericArgPosition::Type && !args.bindings.is_empty() {\n+            AstConv::prohibit_assoc_ty_binding(tcx, args.bindings[0].span);\n+        }\n+\n+        // Prohibit explicit lifetime arguments if late-bound lifetime parameters are present.\n+        if !infer_lifetimes {\n+            if let Some(span_late) = def.has_late_bound_regions {\n+                let msg = \"cannot specify lifetime arguments explicitly \\\n+                           if late bound lifetime parameters are present\";\n+                let note = \"the late bound lifetime parameter is introduced here\";\n+                let span = args.args[0].span();\n+                if position == GenericArgPosition::Value\n+                    && arg_counts.lifetimes != param_counts.lifetimes {\n+                    let mut err = tcx.sess.struct_span_err(span, msg);\n+                    err.span_note(span_late, note);\n+                    err.emit();\n+                    return true;\n+                } else {\n+                    let mut multispan = MultiSpan::from_span(span);\n+                    multispan.push_span_label(span_late, note.to_string());\n+                    tcx.lint_node(lint::builtin::LATE_BOUND_LIFETIME_ARGUMENTS,\n+                                  args.args[0].id(), multispan, msg);\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        let check_kind_count = |error_code: (&str, &str),\n+                                kind,\n+                                required,\n+                                permitted,\n+                                provided,\n+                                offset| {\n+            // We enforce the following: `required` <= `provided` <= `permitted`.\n+            // For kinds without defaults (i.e. lifetimes), `required == permitted`.\n+            // For other kinds (i.e. types), `permitted` may be greater than `required`.\n+            if required <= provided && provided <= permitted {\n+                return false;\n+            }\n+\n+            // Unfortunately lifetime and type parameter mismatches are typically styled\n+            // differently in diagnostics, which means we have a few cases to consider here.\n+            let (bound, quantifier) = if required != permitted {\n+                if provided < required {\n+                    (required, \"at least \")\n+                } else { // provided > permitted\n+                    (permitted, \"at most \")\n+                }\n+            } else {\n+                (required, \"\")\n+            };\n+\n+            let mut span = span;\n+            let label = if required == permitted && provided > permitted {\n+                let diff = provided - permitted;\n+                if diff == 1 {\n+                    // In the case when the user has provided too many arguments,\n+                    // we want to point to the first unexpected argument.\n+                    let first_superfluous_arg: &GenericArg = &args.args[offset + permitted];\n+                    span = first_superfluous_arg.span();\n+                }\n+                format!(\n+                    \"{}unexpected {} argument{}\",\n+                    if diff != 1 { format!(\"{} \", diff) } else { String::new() },\n+                    kind,\n+                    if diff != 1 { \"s\" } else { \"\" },\n+                )\n+            } else {\n+                format!(\n+                    \"expected {}{} {} argument{}\",\n+                    quantifier,\n+                    bound,\n+                    kind,\n+                    if required != 1 { \"s\" } else { \"\" },\n+                )\n+            };\n+\n+            tcx.sess.struct_span_err_with_code(\n+                span,\n+                &format!(\n+                    \"wrong number of {} arguments: expected {}{}, found {}\",\n+                    kind,\n+                    quantifier,\n+                    bound,\n+                    provided,\n+                ),\n+                DiagnosticId::Error({\n+                    if provided <= permitted {\n+                        error_code.0\n+                    } else {\n+                        error_code.1\n+                    }\n+                }.into())\n+            ).span_label(span, label).emit();\n+\n+            provided > required // `suppress_error`\n+        };\n+\n+        if !infer_lifetimes || arg_counts.lifetimes > param_counts.lifetimes {\n+            check_kind_count(\n+                error_codes.lifetimes,\n+                \"lifetime\",\n+                param_counts.lifetimes,\n+                param_counts.lifetimes,\n+                arg_counts.lifetimes,\n+                0,\n+            );\n+        }\n+        if !infer_types\n+            || arg_counts.types > param_counts.types - defaults.types - has_self as usize {\n+            check_kind_count(\n+                error_codes.types,\n+                \"type\",\n+                param_counts.types - defaults.types - has_self as usize,\n+                param_counts.types - has_self as usize,\n+                arg_counts.types,\n+                arg_counts.lifetimes,\n+            )\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// Creates the relevant generic argument substitutions\n+    /// corresponding to a set of generic parameters.\n+    pub fn create_substs_for_generic_args<'a, 'b, A, P, I>(\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        def_id: DefId,\n+        parent_substs: &[Kind<'tcx>],\n+        has_self: bool,\n+        self_ty: Option<Ty<'tcx>>,\n+        args_for_def_id: A,\n+        provided_kind: P,\n+        inferred_kind: I,\n+    ) -> &'tcx Substs<'tcx> where\n+        A: Fn(DefId) -> (Option<&'b GenericArgs>, bool),\n+        P: Fn(&GenericParamDef, &GenericArg) -> Kind<'tcx>,\n+        I: Fn(Option<&[Kind<'tcx>]>, &GenericParamDef, bool) -> Kind<'tcx>\n+    {\n+        // Collect the segments of the path: we need to substitute arguments\n+        // for parameters throughout the entire path (wherever there are\n+        // generic parameters).\n+        let mut parent_defs = tcx.generics_of(def_id);\n+        let count = parent_defs.count();\n+        let mut stack = vec![(def_id, parent_defs)];\n+        while let Some(def_id) = parent_defs.parent {\n+            parent_defs = tcx.generics_of(def_id);\n+            stack.push((def_id, parent_defs));\n+        }\n+\n+        // We manually build up the substitution, rather than using convenience\n+        // methods in subst.rs so that we can iterate over the arguments and\n+        // parameters in lock-step linearly, rather than trying to match each pair.\n+        let mut substs: AccumulateVec<[Kind<'tcx>; 8]> = if count <= 8 {\n+            AccumulateVec::Array(ArrayVec::new())\n+        } else {\n+            AccumulateVec::Heap(Vec::with_capacity(count))\n+        };\n+\n+        fn push_kind<'tcx>(substs: &mut AccumulateVec<[Kind<'tcx>; 8]>, kind: Kind<'tcx>) {\n+            match substs {\n+                AccumulateVec::Array(ref mut arr) => arr.push(kind),\n+                AccumulateVec::Heap(ref mut vec) => vec.push(kind),\n+            }\n+        }\n+\n+        // Iterate over each segment of the path.\n+        while let Some((def_id, defs)) = stack.pop() {\n+            let mut params = defs.params.iter().peekable();\n+\n+            // If we have already computed substitutions for parents, we can use those directly.\n+            while let Some(&param) = params.peek() {\n+                if let Some(&kind) = parent_substs.get(param.index as usize) {\n+                    push_kind(&mut substs, kind);\n+                    params.next();\n+                } else {\n+                    break;\n+                }\n+            }\n+\n+            // (Unless it's been handled in `parent_substs`) `Self` is handled first.\n+            if has_self {\n+                if let Some(&param) = params.peek() {\n+                    if param.index == 0 {\n+                        if let GenericParamDefKind::Type { .. } = param.kind {\n+                            push_kind(&mut substs, self_ty.map(|ty| ty.into())\n+                                .unwrap_or_else(|| inferred_kind(None, param, true)));\n+                            params.next();\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Check whether this segment takes generic arguments and the user has provided any.\n+            let (generic_args, infer_types) = args_for_def_id(def_id);\n+\n+            let mut args = generic_args.iter().flat_map(|generic_args| generic_args.args.iter())\n+                .peekable();\n+\n+            loop {\n+                // We're going to iterate through the generic arguments that the user\n+                // provided, matching them with the generic parameters we expect.\n+                // Mismatches can occur as a result of elided lifetimes, or for malformed\n+                // input. We try to handle both sensibly.\n+                match (args.peek(), params.peek()) {\n+                    (Some(&arg), Some(&param)) => {\n+                        match (arg, &param.kind) {\n+                            (GenericArg::Lifetime(_), GenericParamDefKind::Lifetime)\n+                            | (GenericArg::Type(_), GenericParamDefKind::Type { .. }) => {\n+                                push_kind(&mut substs, provided_kind(param, arg));\n+                                args.next();\n+                                params.next();\n+                            }\n+                            (GenericArg::Lifetime(_), GenericParamDefKind::Type { .. }) => {\n+                                // We expected a type argument, but got a lifetime\n+                                // argument. This is an error, but we need to handle it\n+                                // gracefully so we can report sensible errors. In this\n+                                // case, we're simply going to infer this argument.\n+                                args.next();\n+                            }\n+                            (GenericArg::Type(_), GenericParamDefKind::Lifetime) => {\n+                                // We expected a lifetime argument, but got a type\n+                                // argument. That means we're inferring the lifetimes.\n+                                push_kind(&mut substs, inferred_kind(None, param, infer_types));\n+                                params.next();\n+                            }\n+                        }\n+                    }\n+                    (Some(_), None) => {\n+                        // We should never be able to reach this point with well-formed input.\n+                        // Getting to this point means the user supplied more arguments than\n+                        // there are parameters.\n+                        args.next();\n+                    }\n+                    (None, Some(&param)) => {\n+                        // If there are fewer arguments than parameters, it means\n+                        // we're inferring the remaining arguments.\n+                        match param.kind {\n+                            GenericParamDefKind::Lifetime | GenericParamDefKind::Type { .. } => {\n+                                let kind = inferred_kind(Some(&substs), param, infer_types);\n+                                push_kind(&mut substs, kind);\n+                            }\n+                        }\n+                        args.next();\n+                        params.next();\n+                    }\n+                    (None, None) => break,\n+                }\n+            }\n+        }\n+\n+        tcx.intern_substs(&substs)\n+    }\n+\n     /// Given the type/region arguments provided to some path (along with\n     /// an implicit Self, if this is a trait reference) returns the complete\n     /// set of substitutions. This may involve applying defaulted type parameters.\n@@ -204,60 +565,33 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         self_ty: Option<Ty<'tcx>>)\n         -> (&'tcx Substs<'tcx>, Vec<ConvertedBinding<'tcx>>)\n     {\n-        let tcx = self.tcx();\n-\n-        debug!(\"create_substs_for_ast_path(def_id={:?}, self_ty={:?}, \\\n-               generic_args={:?})\",\n-               def_id, self_ty, generic_args);\n-\n         // If the type is parameterized by this region, then replace this\n         // region with the current anon region binding (in other words,\n         // whatever & would get replaced with).\n+        debug!(\"create_substs_for_ast_path(def_id={:?}, self_ty={:?}, \\\n+               generic_args={:?})\",\n+               def_id, self_ty, generic_args);\n \n-        // FIXME(varkor): Separating out the parameters is messy.\n-        let lifetimes: Vec<_> = generic_args.args.iter().filter_map(|arg| match arg {\n-            GenericArg::Lifetime(lt) => Some(lt),\n-            _ => None,\n-        }).collect();\n-        let types: Vec<_> = generic_args.args.iter().filter_map(|arg| match arg {\n-            GenericArg::Type(ty) => Some(ty),\n-            _ => None,\n-        }).collect();\n-        let lt_provided = lifetimes.len();\n-        let ty_provided = types.len();\n-\n-        let decl_generics = tcx.generics_of(def_id);\n-        let mut lt_accepted = 0;\n-        let mut ty_params = ParamRange { required: 0, accepted: 0 };\n-        for param in &decl_generics.params {\n-            match param.kind {\n-                GenericParamDefKind::Lifetime => {\n-                    lt_accepted += 1;\n-                }\n-                GenericParamDefKind::Type { has_default, .. } => {\n-                    ty_params.accepted += 1;\n-                    if !has_default {\n-                        ty_params.required += 1;\n-                    }\n-                }\n-            };\n-        }\n-        if self_ty.is_some() {\n-            ty_params.required -= 1;\n-            ty_params.accepted -= 1;\n-        }\n-\n-        if lt_accepted != lt_provided {\n-            report_lifetime_number_error(tcx, span, lt_provided, lt_accepted);\n-        }\n+        let tcx = self.tcx();\n+        let generic_params = tcx.generics_of(def_id);\n \n         // If a self-type was declared, one should be provided.\n-        assert_eq!(decl_generics.has_self, self_ty.is_some());\n+        assert_eq!(generic_params.has_self, self_ty.is_some());\n \n-        // Check the number of type parameters supplied by the user.\n-        if !infer_types || ty_provided > ty_params.required {\n-            check_type_argument_count(tcx, span, ty_provided, ty_params);\n-        }\n+        let has_self = generic_params.has_self;\n+        Self::check_generic_arg_count(\n+            self.tcx(),\n+            span,\n+            &generic_params,\n+            &generic_args,\n+            GenericArgPosition::Type,\n+            has_self,\n+            infer_types,\n+            GenericArgMismatchErrorCode {\n+                lifetimes: (\"E0107\", \"E0107\"),\n+                types: (\"E0243\", \"E0244\"),\n+            },\n+        );\n \n         let is_object = self_ty.map_or(false, |ty| ty.sty == TRAIT_OBJECT_DUMMY_SELF);\n         let default_needs_object_self = |param: &ty::GenericParamDef| {\n@@ -274,71 +608,74 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             false\n         };\n \n-        let own_self = self_ty.is_some() as usize;\n-        let substs = Substs::for_item(tcx, def_id, |param, substs| {\n-            match param.kind {\n-                GenericParamDefKind::Lifetime => {\n-                    let i = param.index as usize - own_self;\n-                    if let Some(lt) = lifetimes.get(i) {\n-                        self.ast_region_to_region(lt, Some(param)).into()\n-                    } else {\n-                        tcx.types.re_static.into()\n+        let substs = Self::create_substs_for_generic_args(\n+            self.tcx(),\n+            def_id,\n+            &[][..],\n+            self_ty.is_some(),\n+            self_ty,\n+            // Provide the generic args, and whether types should be inferred.\n+            |_| (Some(generic_args), infer_types),\n+            // Provide substitutions for parameters for which (valid) arguments have been provided.\n+            |param, arg| {\n+                match (&param.kind, arg) {\n+                    (GenericParamDefKind::Lifetime, GenericArg::Lifetime(lt)) => {\n+                        self.ast_region_to_region(&lt, Some(param)).into()\n                     }\n-                }\n-                GenericParamDefKind::Type { has_default, .. } => {\n-                    let i = param.index as usize;\n-\n-                    // Handle Self first, so we can adjust the index to match the AST.\n-                    if let (0, Some(ty)) = (i, self_ty) {\n-                        return ty.into();\n+                    (GenericParamDefKind::Type { .. }, GenericArg::Type(ty)) => {\n+                        self.ast_ty_to_ty(&ty).into()\n                     }\n-\n-                    let i = i - (lt_accepted + own_self);\n-                    if i < ty_provided {\n-                        // A provided type parameter.\n-                        self.ast_ty_to_ty(&types[i]).into()\n-                    } else if infer_types {\n-                        // No type parameters were provided, we can infer all.\n-                        if !default_needs_object_self(param) {\n-                            self.ty_infer_for_def(param, span).into()\n+                    _ => unreachable!(),\n+                }\n+            },\n+            // Provide substitutions for parameters for which arguments are inferred.\n+            |substs, param, infer_types| {\n+                match param.kind {\n+                    GenericParamDefKind::Lifetime => tcx.types.re_static.into(),\n+                    GenericParamDefKind::Type { has_default, .. } => {\n+                        if !infer_types && has_default {\n+                            // No type parameter provided, but a default exists.\n+\n+                            // If we are converting an object type, then the\n+                            // `Self` parameter is unknown. However, some of the\n+                            // other type parameters may reference `Self` in their\n+                            // defaults. This will lead to an ICE if we are not\n+                            // careful!\n+                            if default_needs_object_self(param) {\n+                                struct_span_err!(tcx.sess, span, E0393,\n+                                                    \"the type parameter `{}` must be explicitly \\\n+                                                    specified\",\n+                                                    param.name)\n+                                    .span_label(span,\n+                                                format!(\"missing reference to `{}`\", param.name))\n+                                    .note(&format!(\"because of the default `Self` reference, \\\n+                                                    type parameters must be specified on object \\\n+                                                    types\"))\n+                                    .emit();\n+                                tcx.types.err.into()\n+                            } else {\n+                                // This is a default type parameter.\n+                                self.normalize_ty(\n+                                    span,\n+                                    tcx.at(span).type_of(param.def_id)\n+                                        .subst_spanned(tcx, substs.unwrap(), Some(span))\n+                                ).into()\n+                            }\n+                        } else if infer_types {\n+                            // No type parameters were provided, we can infer all.\n+                            if !default_needs_object_self(param) {\n+                                self.ty_infer_for_def(param, span).into()\n+                            } else {\n+                                self.ty_infer(span).into()\n+                            }\n                         } else {\n-                            self.ty_infer(span).into()\n-                        }\n-                    } else if has_default {\n-                        // No type parameter provided, but a default exists.\n-\n-                        // If we are converting an object type, then the\n-                        // `Self` parameter is unknown. However, some of the\n-                        // other type parameters may reference `Self` in their\n-                        // defaults. This will lead to an ICE if we are not\n-                        // careful!\n-                        if default_needs_object_self(param) {\n-                            struct_span_err!(tcx.sess, span, E0393,\n-                                             \"the type parameter `{}` must be explicitly \\\n-                                             specified\",\n-                                             param.name)\n-                                .span_label(span,\n-                                            format!(\"missing reference to `{}`\", param.name))\n-                                .note(&format!(\"because of the default `Self` reference, \\\n-                                                type parameters must be specified on object \\\n-                                                types\"))\n-                                .emit();\n+                            // We've already errored above about the mismatch.\n                             tcx.types.err.into()\n-                        } else {\n-                            // This is a default type parameter.\n-                            self.normalize_ty(\n-                                span,\n-                                tcx.at(span).type_of(param.def_id)\n-                                    .subst_spanned(tcx, substs, Some(span))\n-                            ).into()\n                         }\n-                    } else {\n-                        // We've already errored above about the mismatch.\n-                        tcx.types.err.into()\n                     }\n                 }\n-            }\n-        });\n+            },\n+        );\n \n         let assoc_bindings = generic_args.bindings.iter().map(|binding| {\n             ConvertedBinding {\n@@ -348,8 +685,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             }\n         }).collect();\n \n-        debug!(\"create_substs_for_ast_path(decl_generics={:?}, self_ty={:?}) -> {:?}\",\n-               decl_generics, self_ty, substs);\n+        debug!(\"create_substs_for_ast_path(generic_params={:?}, self_ty={:?}) -> {:?}\",\n+               generic_params, self_ty, substs);\n \n         (substs, assoc_bindings)\n     }\n@@ -444,7 +781,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                                                  trait_def_id,\n                                                  self_ty,\n                                                  trait_segment);\n-        assoc_bindings.first().map(|b| self.prohibit_projection(b.span));\n+        assoc_bindings.first().map(|b| AstConv::prohibit_assoc_ty_binding(self.tcx(), b.span));\n         ty::TraitRef::new(trait_def_id, substs)\n     }\n \n@@ -978,7 +1315,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         self.normalize_ty(span, tcx.mk_projection(item_def_id, trait_ref.substs))\n     }\n \n-    pub fn prohibit_generics(&self, segments: &[hir::PathSegment]) {\n+    pub fn prohibit_generics<'a, T: IntoIterator<Item = &'a hir::PathSegment>>(&self, segments: T) {\n         for segment in segments {\n             segment.with_generic_args(|generic_args| {\n                 let (mut err_for_lt, mut err_for_ty) = (false, false);\n@@ -1009,15 +1346,15 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                     }\n                 }\n                 for binding in &generic_args.bindings {\n-                    self.prohibit_projection(binding.span);\n+                    Self::prohibit_assoc_ty_binding(self.tcx(), binding.span);\n                     break;\n                 }\n             })\n         }\n     }\n \n-    pub fn prohibit_projection(&self, span: Span) {\n-        let mut err = struct_span_err!(self.tcx().sess, span, E0229,\n+    pub fn prohibit_assoc_ty_binding(tcx: TyCtxt, span: Span) {\n+        let mut err = struct_span_err!(tcx.sess, span, E0229,\n                                        \"associated type bindings are not allowed here\");\n         err.span_label(span, \"associated type not allowed here\").emit();\n     }\n@@ -1393,72 +1730,6 @@ fn split_auto_traits<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     (auto_traits, trait_bounds)\n }\n \n-fn check_type_argument_count(tcx: TyCtxt,\n-                             span: Span,\n-                             supplied: usize,\n-                             ty_params: ParamRange)\n-{\n-    let (required, accepted) = (ty_params.required, ty_params.accepted);\n-    if supplied < required {\n-        let expected = if required < accepted {\n-            \"expected at least\"\n-        } else {\n-            \"expected\"\n-        };\n-        let arguments_plural = if required == 1 { \"\" } else { \"s\" };\n-\n-        struct_span_err!(tcx.sess, span, E0243,\n-                \"wrong number of type arguments: {} {}, found {}\",\n-                expected, required, supplied)\n-            .span_label(span,\n-                format!(\"{} {} type argument{}\",\n-                    expected,\n-                    required,\n-                    arguments_plural))\n-            .emit();\n-    } else if supplied > accepted {\n-        let expected = if required < accepted {\n-            format!(\"expected at most {}\", accepted)\n-        } else {\n-            format!(\"expected {}\", accepted)\n-        };\n-        let arguments_plural = if accepted == 1 { \"\" } else { \"s\" };\n-\n-        struct_span_err!(tcx.sess, span, E0244,\n-                \"wrong number of type arguments: {}, found {}\",\n-                expected, supplied)\n-            .span_label(\n-                span,\n-                format!(\"{} type argument{}\",\n-                    if accepted == 0 { \"expected no\" } else { &expected },\n-                    arguments_plural)\n-            )\n-            .emit();\n-    }\n-}\n-\n-fn report_lifetime_number_error(tcx: TyCtxt, span: Span, number: usize, expected: usize) {\n-    let label = if number < expected {\n-        if expected == 1 {\n-            format!(\"expected {} lifetime parameter\", expected)\n-        } else {\n-            format!(\"expected {} lifetime parameters\", expected)\n-        }\n-    } else {\n-        let additional = number - expected;\n-        if additional == 1 {\n-            \"unexpected lifetime parameter\".to_string()\n-        } else {\n-            format!(\"{} unexpected lifetime parameters\", additional)\n-        }\n-    };\n-    struct_span_err!(tcx.sess, span, E0107,\n-                     \"wrong number of lifetime parameters: expected {}, found {}\",\n-                     expected, number)\n-        .span_label(span, label)\n-        .emit();\n-}\n-\n // A helper struct for conveniently grouping a set of bounds which we pass to\n // and return from functions in multiple places.\n #[derive(PartialEq, Eq, Clone, Debug)]"}, {"sha": "fbb49c95edf0311ec8ed1fcb2106ed5f914c29f8", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -22,8 +22,8 @@ use rustc::ty::adjustment::{Adjustment, Adjust, OverloadedDeref};\n use rustc::ty::adjustment::{AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::fold::TypeFoldable;\n use rustc::infer::{self, InferOk};\n-use syntax_pos::Span;\n use rustc::hir;\n+use syntax_pos::Span;\n \n use std::ops::Deref;\n \n@@ -308,55 +308,55 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     fn instantiate_method_substs(\n         &mut self,\n         pick: &probe::Pick<'tcx>,\n-        segment: &hir::PathSegment,\n+        seg: &hir::PathSegment,\n         parent_substs: &Substs<'tcx>,\n     ) -> &'tcx Substs<'tcx> {\n         // Determine the values for the generic parameters of the method.\n         // If they were not explicitly supplied, just construct fresh\n         // variables.\n-        let method_generics = self.tcx.generics_of(pick.item.def_id);\n-        let mut fn_segment = Some((segment, method_generics));\n-        let supress_mismatch = self.fcx.check_impl_trait(self.span, fn_segment);\n-        self.fcx.check_generic_arg_count(self.span, &mut fn_segment, true, supress_mismatch);\n+        let generics = self.tcx.generics_of(pick.item.def_id);\n+        AstConv::check_generic_arg_count_for_call(\n+            self.tcx,\n+            self.span,\n+            &generics,\n+            &seg,\n+            true, // `is_method_call`\n+        );\n \n         // Create subst for early-bound lifetime parameters, combining\n         // parameters from the type and those from the method.\n-        assert_eq!(method_generics.parent_count, parent_substs.len());\n-        let provided = &segment.args;\n-        let own_counts = method_generics.own_counts();\n-        Substs::for_item(self.tcx, pick.item.def_id, |param, _| {\n-            let mut i = param.index as usize;\n-            if i < parent_substs.len() {\n-                parent_substs[i]\n-            } else {\n-                let (is_lt, is_ty) = match param.kind {\n-                    GenericParamDefKind::Lifetime => (true, false),\n-                    GenericParamDefKind::Type { .. } => (false, true),\n-                };\n-                provided.as_ref().and_then(|data| {\n-                    for arg in &data.args {\n-                        match arg {\n-                            GenericArg::Lifetime(lt) if is_lt => {\n-                                if i == parent_substs.len() {\n-                                    return Some(AstConv::ast_region_to_region(\n-                                        self.fcx, lt, Some(param)).into());\n-                                }\n-                                i -= 1;\n-                            }\n-                            GenericArg::Lifetime(_) => {}\n-                            GenericArg::Type(ty) if is_ty => {\n-                                if i == parent_substs.len() + own_counts.lifetimes {\n-                                    return Some(self.to_ty(ty).into());\n-                                }\n-                                i -= 1;\n-                            }\n-                            GenericArg::Type(_) => {}\n-                        }\n+        assert_eq!(generics.parent_count, parent_substs.len());\n+\n+        AstConv::create_substs_for_generic_args(\n+            self.tcx,\n+            pick.item.def_id,\n+            parent_substs,\n+            false,\n+            None,\n+            // Provide the generic args, and whether types should be inferred.\n+            |_| {\n+                // The last argument of the returned tuple here is unimportant.\n+                if let Some(ref data) = seg.args {\n+                    (Some(data), false)\n+                } else {\n+                    (None, false)\n+                }\n+            },\n+            // Provide substitutions for parameters for which (valid) arguments have been provided.\n+            |param, arg| {\n+                match (&param.kind, arg) {\n+                    (GenericParamDefKind::Lifetime, GenericArg::Lifetime(lt)) => {\n+                        AstConv::ast_region_to_region(self.fcx, lt, Some(param)).into()\n                     }\n-                    None\n-                }).unwrap_or_else(|| self.var_for_def(self.span, param))\n-            }\n-        })\n+                    (GenericParamDefKind::Type { .. }, GenericArg::Type(ty)) => {\n+                        self.to_ty(ty).into()\n+                    }\n+                    _ => unreachable!(),\n+                }\n+            },\n+            // Provide substitutions for parameters for which arguments are inferred.\n+            |_, param, _| self.var_for_def(self.span, param),\n+        )\n     }\n \n     fn unify_receivers(&mut self, self_ty: Ty<'tcx>, method_self_ty: Ty<'tcx>) {"}, {"sha": "c89f7e0586b0822c44d554ab5052378d51be61d6", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 153, "deletions": 299, "changes": 452, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -109,7 +109,7 @@ use session::{CompileIncomplete, config, Session};\n use TypeAndSubsts;\n use lint;\n use util::common::{ErrorReported, indenter};\n-use util::nodemap::{DefIdMap, DefIdSet, FxHashMap, NodeMap};\n+use util::nodemap::{DefIdMap, DefIdSet, FxHashMap, FxHashSet, NodeMap};\n \n use std::cell::{Cell, RefCell, Ref, RefMut};\n use rustc_data_structures::sync::Lrc;\n@@ -505,6 +505,9 @@ impl<'gcx, 'tcx> EnclosingBreakables<'gcx, 'tcx> {\n     }\n }\n \n+#[derive(Debug)]\n+struct PathSeg(DefId, usize);\n+\n pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     body_id: ast::NodeId,\n \n@@ -4277,8 +4280,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     {\n         match *qpath {\n             hir::QPath::Resolved(ref maybe_qself, ref path) => {\n-                let opt_self_ty = maybe_qself.as_ref().map(|qself| self.to_ty(qself));\n-                let ty = AstConv::def_to_ty(self, opt_self_ty, path, true);\n+                let self_ty = maybe_qself.as_ref().map(|qself| self.to_ty(qself));\n+                let ty = AstConv::def_to_ty(self, self_ty, path, true);\n                 (path.def, ty)\n             }\n             hir::QPath::TypeRelative(ref qself, ref segment) => {\n@@ -4770,20 +4773,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         err.span_suggestion(span_semi, \"consider removing this semicolon\", \"\".to_string());\n     }\n \n-    // Instantiates the given path, which must refer to an item with the given\n-    // number of type parameters and type.\n-    pub fn instantiate_value_path(&self,\n-                                  segments: &[hir::PathSegment],\n-                                  opt_self_ty: Option<Ty<'tcx>>,\n-                                  def: Def,\n-                                  span: Span,\n-                                  node_id: ast::NodeId)\n-                                  -> Ty<'tcx> {\n-        debug!(\"instantiate_value_path(path={:?}, def={:?}, node_id={})\",\n-               segments,\n-               def,\n-               node_id);\n-\n+    fn def_ids_for_path_segments(&self,\n+                                 segments: &[hir::PathSegment],\n+                                 def: Def)\n+                                 -> Vec<PathSeg> {\n         // We need to extract the type parameters supplied by the user in\n         // the path `path`. Due to the current setup, this is a bit of a\n         // tricky-process; the problem is that resolve only tells us the\n@@ -4829,33 +4822,69 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // The first step then is to categorize the segments appropriately.\n \n         assert!(!segments.is_empty());\n+        let last = segments.len() - 1;\n+\n+        let mut path_segs = vec![];\n \n-        let mut ufcs_associated = None;\n-        let mut type_segment = None;\n-        let mut fn_segment = None;\n         match def {\n             // Case 1. Reference to a struct/variant constructor.\n             Def::StructCtor(def_id, ..) |\n             Def::VariantCtor(def_id, ..) => {\n                 // Everything but the final segment should have no\n                 // parameters at all.\n-                let mut generics = self.tcx.generics_of(def_id);\n-                if let Some(def_id) = generics.parent {\n-                    // Variant and struct constructors use the\n-                    // generics of their parent type definition.\n-                    generics = self.tcx.generics_of(def_id);\n-                }\n-                type_segment = Some((segments.last().unwrap(), generics));\n+                let generics = self.tcx.generics_of(def_id);\n+                // Variant and struct constructors use the\n+                // generics of their parent type definition.\n+                let generics_def_id = generics.parent.unwrap_or(def_id);\n+                path_segs.push(PathSeg(generics_def_id, last));\n             }\n \n             // Case 2. Reference to a top-level value.\n             Def::Fn(def_id) |\n             Def::Const(def_id) |\n             Def::Static(def_id, _) => {\n-                fn_segment = Some((segments.last().unwrap(), self.tcx.generics_of(def_id)));\n+                path_segs.push(PathSeg(def_id, last));\n             }\n \n             // Case 3. Reference to a method or associated const.\n+            Def::Method(def_id) |\n+            Def::AssociatedConst(def_id) => {\n+                if segments.len() >= 2 {\n+                    let generics = self.tcx.generics_of(def_id);\n+                    path_segs.push(PathSeg(generics.parent.unwrap(), last - 1));\n+                }\n+                path_segs.push(PathSeg(def_id, last));\n+            }\n+\n+            // Case 4. Local variable, no generics.\n+            Def::Local(..) | Def::Upvar(..) => {}\n+\n+            _ => bug!(\"unexpected definition: {:?}\", def),\n+        }\n+\n+        debug!(\"path_segs = {:?}\", path_segs);\n+\n+        path_segs\n+    }\n+\n+    // Instantiates the given path, which must refer to an item with the given\n+    // number of type parameters and type.\n+    pub fn instantiate_value_path(&self,\n+                                  segments: &[hir::PathSegment],\n+                                  self_ty: Option<Ty<'tcx>>,\n+                                  def: Def,\n+                                  span: Span,\n+                                  node_id: ast::NodeId)\n+                                  -> Ty<'tcx> {\n+        debug!(\"instantiate_value_path(path={:?}, def={:?}, node_id={})\",\n+               segments,\n+               def,\n+               node_id);\n+\n+        let path_segs = self.def_ids_for_path_segments(segments, def);\n+\n+        let mut ufcs_associated = None;\n+        match def {\n             Def::Method(def_id) |\n             Def::AssociatedConst(def_id) => {\n                 let container = self.tcx.associated_item(def_id).container;\n@@ -4865,34 +4894,31 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                     ty::ImplContainer(_) => {}\n                 }\n-\n-                let generics = self.tcx.generics_of(def_id);\n-                if segments.len() >= 2 {\n-                    let parent_generics = self.tcx.generics_of(generics.parent.unwrap());\n-                    type_segment = Some((&segments[segments.len() - 2], parent_generics));\n-                } else {\n+                if segments.len() == 1 {\n                     // `<T>::assoc` will end up here, and so can `T::assoc`.\n-                    let self_ty = opt_self_ty.expect(\"UFCS sugared assoc missing Self\");\n+                    let self_ty = self_ty.expect(\"UFCS sugared assoc missing Self\");\n                     ufcs_associated = Some((container, self_ty));\n                 }\n-                fn_segment = Some((segments.last().unwrap(), generics));\n             }\n-\n-            // Case 4. Local variable, no generics.\n-            Def::Local(..) | Def::Upvar(..) => {}\n-\n-            _ => bug!(\"unexpected definition: {:?}\", def),\n+            _ => {}\n         }\n \n-        debug!(\"type_segment={:?} fn_segment={:?}\", type_segment, fn_segment);\n-\n         // Now that we have categorized what space the parameters for each\n         // segment belong to, let's sort out the parameters that the user\n         // provided (if any) into their appropriate spaces. We'll also report\n         // errors if type parameters are provided in an inappropriate place.\n-        let poly_segments = type_segment.is_some() as usize +\n-                            fn_segment.is_some() as usize;\n-        AstConv::prohibit_generics(self, &segments[..segments.len() - poly_segments]);\n+\n+        let mut generic_segs = FxHashSet::default();\n+        for PathSeg(_, index) in &path_segs {\n+            generic_segs.insert(index);\n+        }\n+        AstConv::prohibit_generics(self, segments.iter().enumerate().filter_map(|(index, seg)| {\n+            if !generic_segs.contains(&index) {\n+                Some(seg)\n+            } else {\n+                None\n+            }\n+        }));\n \n         match def {\n             Def::Local(nid) | Def::Upvar(nid, ..) => {\n@@ -4910,120 +4936,109 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // variables. If the user provided some types, we may still need\n         // to add defaults. If the user provided *too many* types, that's\n         // a problem.\n-        let supress_mismatch = self.check_impl_trait(span, fn_segment);\n-        self.check_generic_arg_count(span, &mut type_segment, false, supress_mismatch);\n-        self.check_generic_arg_count(span, &mut fn_segment, false, supress_mismatch);\n \n-        let (fn_start, has_self) = match (type_segment, fn_segment) {\n-            (_, Some((_, generics))) => {\n-                (generics.parent_count, generics.has_self)\n-            }\n-            (Some((_, generics)), None) => {\n-                (generics.params.len(), generics.has_self)\n-            }\n-            (None, None) => (0, false)\n-        };\n-        // FIXME(varkor): Separating out the parameters is messy.\n-        let mut lifetimes_type_seg = vec![];\n-        let mut types_type_seg = vec![];\n-        let mut infer_types_type_seg = true;\n-        if let Some((seg, _)) = type_segment {\n-            if let Some(ref data) = seg.args {\n-                for arg in &data.args {\n-                    match arg {\n-                        GenericArg::Lifetime(lt) => lifetimes_type_seg.push(lt),\n-                        GenericArg::Type(ty) => types_type_seg.push(ty),\n-                    }\n-                }\n+        let mut infer_args_for_err = FxHashSet::default();\n+        for &PathSeg(def_id, index) in &path_segs {\n+            let seg = &segments[index];\n+            let generics = self.tcx.generics_of(def_id);\n+            // Argument-position `impl Trait` is treated as a normal generic\n+            // parameter internally, but we don't allow users to specify the\n+            // parameter's value explicitly, so we have to do some error-\n+            // checking here.\n+            let suppress_errors = AstConv::check_generic_arg_count_for_call(\n+                self.tcx,\n+                span,\n+                &generics,\n+                &seg,\n+                false, // `is_method_call`\n+            );\n+            if suppress_errors {\n+                infer_args_for_err.insert(index);\n+                self.set_tainted_by_errors(); // See issue #53251.\n             }\n-            infer_types_type_seg = seg.infer_types;\n         }\n \n-        let mut lifetimes_fn_seg = vec![];\n-        let mut types_fn_seg = vec![];\n-        let mut infer_types_fn_seg = true;\n-        if let Some((seg, _)) = fn_segment {\n-            if let Some(ref data) = seg.args {\n-                for arg in &data.args {\n-                    match arg {\n-                        GenericArg::Lifetime(lt) => lifetimes_fn_seg.push(lt),\n-                        GenericArg::Type(ty) => types_fn_seg.push(ty),\n-                    }\n-                }\n-            }\n-            infer_types_fn_seg = seg.infer_types;\n-        }\n+        let has_self = path_segs.last().map(|PathSeg(def_id, _)| {\n+            self.tcx.generics_of(*def_id).has_self\n+        }).unwrap_or(false);\n \n-        let substs = Substs::for_item(self.tcx, def.def_id(), |param, substs| {\n-            let mut i = param.index as usize;\n+        let def_id = def.def_id();\n \n-            let (segment, lifetimes, types, infer_types) = if i < fn_start {\n-                if let GenericParamDefKind::Type { .. } = param.kind {\n-                    // Handle Self first, so we can adjust the index to match the AST.\n-                    if has_self && i == 0 {\n-                        return opt_self_ty.map(|ty| ty.into()).unwrap_or_else(|| {\n-                            self.var_for_def(span, param)\n-                        });\n+        let substs = AstConv::create_substs_for_generic_args(\n+            self.tcx,\n+            def_id,\n+            &[][..],\n+            has_self,\n+            self_ty,\n+            // Provide the generic args, and whether types should be inferred.\n+            |def_id| {\n+                if let Some(&PathSeg(_, index)) = path_segs.iter().find(|&PathSeg(did, _)| {\n+                    *did == def_id\n+                }) {\n+                    // If we've encountered an `impl Trait`-related error, we're just\n+                    // going to infer the arguments for better error messages.\n+                    if !infer_args_for_err.contains(&index) {\n+                        // Check whether the user has provided generic arguments.\n+                        if let Some(ref data) = segments[index].args {\n+                            return (Some(data), segments[index].infer_types);\n+                        }\n                     }\n+                    return (None, segments[index].infer_types);\n                 }\n-                i -= has_self as usize;\n-                (type_segment, &lifetimes_type_seg, &types_type_seg, infer_types_type_seg)\n-            } else {\n-                i -= fn_start;\n-                (fn_segment, &lifetimes_fn_seg, &types_fn_seg, infer_types_fn_seg)\n-            };\n \n-            match param.kind {\n-                GenericParamDefKind::Lifetime => {\n-                    if let Some(lifetime) = lifetimes.get(i) {\n-                        AstConv::ast_region_to_region(self, lifetime, Some(param)).into()\n-                    } else {\n-                        self.re_infer(span, Some(param)).unwrap().into()\n+                (None, true)\n+            },\n+            // Provide substitutions for parameters for which (valid) arguments have been provided.\n+            |param, arg| {\n+                match (&param.kind, arg) {\n+                    (GenericParamDefKind::Lifetime, GenericArg::Lifetime(lt)) => {\n+                        AstConv::ast_region_to_region(self, lt, Some(param)).into()\n                     }\n+                    (GenericParamDefKind::Type { .. }, GenericArg::Type(ty)) => {\n+                        self.to_ty(ty).into()\n+                    }\n+                    _ => unreachable!(),\n                 }\n-                GenericParamDefKind::Type { .. } => {\n-                    // Skip over the lifetimes in the same segment.\n-                    if let Some((_, generics)) = segment {\n-                        i -= generics.own_counts().lifetimes;\n+            },\n+            // Provide substitutions for parameters for which arguments are inferred.\n+            |substs, param, infer_types| {\n+                match param.kind {\n+                    GenericParamDefKind::Lifetime => {\n+                        self.re_infer(span, Some(param)).unwrap().into()\n                     }\n-\n-                    let has_default = match param.kind {\n-                        GenericParamDefKind::Type { has_default, .. } => has_default,\n-                        _ => unreachable!()\n-                    };\n-\n-                    if let Some(ast_ty) = types.get(i) {\n-                        // A provided type parameter.\n-                        self.to_ty(ast_ty).into()\n-                    } else if !infer_types && has_default {\n-                        // No type parameter provided, but a default exists.\n-                        let default = self.tcx.type_of(param.def_id);\n-                        self.normalize_ty(\n-                            span,\n-                            default.subst_spanned(self.tcx, substs, Some(span))\n-                        ).into()\n-                    } else {\n-                        // No type parameters were provided, we can infer all.\n-                        // This can also be reached in some error cases:\n-                        // We prefer to use inference variables instead of\n-                        // TyError to let type inference recover somewhat.\n-                        self.var_for_def(span, param)\n+                    GenericParamDefKind::Type { has_default, .. } => {\n+                        if !infer_types && has_default {\n+                            // If we have a default, then we it doesn't matter that we're not\n+                            // inferring the type arguments: we provide the default where any\n+                            // is missing.\n+                            let default = self.tcx.type_of(param.def_id);\n+                            self.normalize_ty(\n+                                span,\n+                                default.subst_spanned(self.tcx, substs.unwrap(), Some(span))\n+                            ).into()\n+                        } else {\n+                            // If no type arguments were provided, we have to infer them.\n+                            // This case also occurs as a result of some malformed input, e.g.\n+                            // a lifetime argument being given instead of a type paramter.\n+                            // Using inference instead of `TyError` gives better error messages.\n+                            self.var_for_def(span, param)\n+                        }\n                     }\n                 }\n-            }\n-        });\n+            },\n+        );\n \n         // The things we are substituting into the type should not contain\n         // escaping late-bound regions, and nor should the base type scheme.\n-        let ty = self.tcx.type_of(def.def_id());\n+        let ty = self.tcx.type_of(def_id);\n         assert!(!substs.has_escaping_regions());\n         assert!(!ty.has_escaping_regions());\n \n         // Add all the obligations that are required, substituting and\n         // normalized appropriately.\n-        let bounds = self.instantiate_bounds(span, def.def_id(), &substs);\n+        let bounds = self.instantiate_bounds(span, def_id, &substs);\n         self.add_obligations_for_parameters(\n-            traits::ObligationCause::new(span, self.body_id, traits::ItemObligation(def.def_id())),\n+            traits::ObligationCause::new(span, self.body_id, traits::ItemObligation(def_id)),\n             &bounds);\n \n         // Substitute the values for the type parameters into the type of\n@@ -5049,7 +5064,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        self.check_rustc_args_require_const(def.def_id(), node_id, span);\n+        self.check_rustc_args_require_const(def_id, node_id, span);\n \n         debug!(\"instantiate_value_path: type of {:?} is {:?}\",\n                node_id,\n@@ -5088,167 +5103,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                       directly, not through a function pointer\");\n     }\n \n-    /// Report errors if the provided parameters are too few or too many.\n-    fn check_generic_arg_count(&self,\n-                               span: Span,\n-                               segment: &mut Option<(&hir::PathSegment, &ty::Generics)>,\n-                               is_method_call: bool,\n-                               supress_mismatch_error: bool) {\n-        let (lifetimes, types, infer_types, bindings) = segment.map_or(\n-            (vec![], vec![], true, &[][..]),\n-            |(s, _)| {\n-                s.args.as_ref().map_or(\n-                    (vec![], vec![], s.infer_types, &[][..]),\n-                    |data| {\n-                        let (mut lifetimes, mut types) = (vec![], vec![]);\n-                        data.args.iter().for_each(|arg| match arg {\n-                            GenericArg::Lifetime(lt) => lifetimes.push(lt),\n-                            GenericArg::Type(ty) => types.push(ty),\n-                        });\n-                        (lifetimes, types, s.infer_types, &data.bindings[..])\n-                    }\n-                )\n-            });\n-\n-        // Check provided parameters.\n-        let ((ty_required, ty_accepted), lt_accepted) =\n-            segment.map_or(((0, 0), 0), |(_, generics)| {\n-                struct ParamRange {\n-                    required: usize,\n-                    accepted: usize\n-                };\n-\n-                let mut lt_accepted = 0;\n-                let mut ty_params = ParamRange { required: 0, accepted: 0 };\n-                for param in &generics.params {\n-                    match param.kind {\n-                        GenericParamDefKind::Lifetime => lt_accepted += 1,\n-                        GenericParamDefKind::Type { has_default, .. } => {\n-                            ty_params.accepted += 1;\n-                            if !has_default {\n-                                ty_params.required += 1;\n-                            }\n-                        }\n-                    };\n-                }\n-                if generics.parent.is_none() && generics.has_self {\n-                    ty_params.required -= 1;\n-                    ty_params.accepted -= 1;\n-                }\n-\n-                ((ty_params.required, ty_params.accepted), lt_accepted)\n-            });\n-\n-        let count_type_params = |n| {\n-            format!(\"{} type parameter{}\", n, if n == 1 { \"\" } else { \"s\" })\n-        };\n-        let expected_text = count_type_params(ty_accepted);\n-        let actual_text = count_type_params(types.len());\n-        if let Some((mut err, span)) = if types.len() > ty_accepted {\n-            // To prevent derived errors to accumulate due to extra\n-            // type parameters, we force instantiate_value_path to\n-            // use inference variables instead of the provided types.\n-            *segment = None;\n-            let span = types[ty_accepted].span;\n-            Some((struct_span_err!(self.tcx.sess, span, E0087,\n-                                  \"too many type parameters provided: \\\n-                                  expected at most {}, found {}\",\n-                                  expected_text, actual_text), span))\n-        } else if types.len() < ty_required && !infer_types && !supress_mismatch_error {\n-            Some((struct_span_err!(self.tcx.sess, span, E0089,\n-                                  \"too few type parameters provided: \\\n-                                  expected {}, found {}\",\n-                                  expected_text, actual_text), span))\n-        } else {\n-            None\n-        } {\n-            self.set_tainted_by_errors(); // #53251\n-            err.span_label(span, format!(\"expected {}\", expected_text)).emit();\n-        }\n-\n-        if !bindings.is_empty() {\n-            AstConv::prohibit_projection(self, bindings[0].span);\n-        }\n-\n-        let infer_lifetimes = lifetimes.len() == 0;\n-        // Prohibit explicit lifetime arguments if late bound lifetime parameters are present.\n-        let has_late_bound_lifetime_defs =\n-            segment.map_or(None, |(_, generics)| generics.has_late_bound_regions);\n-        if let (Some(span_late), false) = (has_late_bound_lifetime_defs, lifetimes.is_empty()) {\n-            // Report this as a lint only if no error was reported previously.\n-            let primary_msg = \"cannot specify lifetime arguments explicitly \\\n-                               if late bound lifetime parameters are present\";\n-            let note_msg = \"the late bound lifetime parameter is introduced here\";\n-            if !is_method_call && (lifetimes.len() > lt_accepted ||\n-                                   lifetimes.len() < lt_accepted && !infer_lifetimes) {\n-                let mut err = self.tcx.sess.struct_span_err(lifetimes[0].span, primary_msg);\n-                err.span_note(span_late, note_msg);\n-                err.emit();\n-                *segment = None;\n-            } else {\n-                let mut multispan = MultiSpan::from_span(lifetimes[0].span);\n-                multispan.push_span_label(span_late, note_msg.to_string());\n-                self.tcx.lint_node(lint::builtin::LATE_BOUND_LIFETIME_ARGUMENTS,\n-                                   lifetimes[0].id, multispan, primary_msg);\n-            }\n-            return;\n-        }\n-\n-        let count_lifetime_params = |n| {\n-            format!(\"{} lifetime parameter{}\", n, if n == 1 { \"\" } else { \"s\" })\n-        };\n-        let expected_text = count_lifetime_params(lt_accepted);\n-        let actual_text = count_lifetime_params(lifetimes.len());\n-        if let Some((mut err, span)) = if lifetimes.len() > lt_accepted {\n-            let span = lifetimes[lt_accepted].span;\n-            Some((struct_span_err!(self.tcx.sess, span, E0088,\n-                                  \"too many lifetime parameters provided: \\\n-                                  expected at most {}, found {}\",\n-                                  expected_text, actual_text), span))\n-        } else if lifetimes.len() < lt_accepted && !infer_lifetimes {\n-            Some((struct_span_err!(self.tcx.sess, span, E0090,\n-                                  \"too few lifetime parameters provided: \\\n-                                  expected {}, found {}\",\n-                                  expected_text, actual_text), span))\n-        } else {\n-            None\n-        } {\n-            err.span_label(span, format!(\"expected {}\", expected_text)).emit();\n-        }\n-    }\n-\n-    /// Report error if there is an explicit type parameter when using `impl Trait`.\n-    fn check_impl_trait(&self,\n-                        span: Span,\n-                        segment: Option<(&hir::PathSegment, &ty::Generics)>)\n-                        -> bool {\n-        let segment = segment.map(|(path_segment, generics)| {\n-            let explicit = !path_segment.infer_types;\n-            let impl_trait = generics.params.iter().any(|param| match param.kind {\n-                ty::GenericParamDefKind::Type {\n-                    synthetic: Some(hir::SyntheticTyParamKind::ImplTrait), ..\n-                } => true,\n-                _ => false,\n-            });\n-\n-            if explicit && impl_trait {\n-                let mut err = struct_span_err! {\n-                    self.tcx.sess,\n-                    span,\n-                    E0632,\n-                    \"cannot provide explicit type parameters when `impl Trait` is \\\n-                    used in argument position.\"\n-                };\n-\n-                err.emit();\n-            }\n-\n-            impl_trait\n-        });\n-\n-        segment.unwrap_or(false)\n-    }\n-\n     // Resolves `typ` by a single level if `typ` is a type variable.\n     // If no resolution is possible, then an error is reported.\n     // Numeric inference variables may be left unresolved."}, {"sha": "c01102272aeb4e7bc269ac970b14f7666cb9d1d4", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -1041,32 +1041,34 @@ enum NightsWatch {}\n \"##,\n \n E0087: r##\"\n-Too many type parameters were supplied for a function. For example:\n+Too many type arguments were supplied for a function. For example:\n \n ```compile_fail,E0087\n fn foo<T>() {}\n \n fn main() {\n-    foo::<f64, bool>(); // error, expected 1 parameter, found 2 parameters\n+    foo::<f64, bool>(); // error: wrong number of type arguments:\n+                        //        expected 1, found 2\n }\n ```\n \n-The number of supplied parameters must exactly match the number of defined type\n+The number of supplied arguments must exactly match the number of defined type\n parameters.\n \"##,\n \n E0088: r##\"\n-You gave too many lifetime parameters. Erroneous code example:\n+You gave too many lifetime arguments. Erroneous code example:\n \n ```compile_fail,E0088\n fn f() {}\n \n fn main() {\n-    f::<'static>() // error: too many lifetime parameters provided\n+    f::<'static>() // error: wrong number of lifetime arguments:\n+                   //        expected 0, found 1\n }\n ```\n \n-Please check you give the right number of lifetime parameters. Example:\n+Please check you give the right number of lifetime arguments. Example:\n \n ```\n fn f() {}\n@@ -1101,42 +1103,44 @@ fn main() {\n \"##,\n \n E0089: r##\"\n-Not enough type parameters were supplied for a function. For example:\n+Too few type arguments were supplied for a function. For example:\n \n ```compile_fail,E0089\n fn foo<T, U>() {}\n \n fn main() {\n-    foo::<f64>(); // error, expected 2 parameters, found 1 parameter\n+    foo::<f64>(); // error: wrong number of type arguments: expected 2, found 1\n }\n ```\n \n-Note that if a function takes multiple type parameters but you want the compiler\n+Note that if a function takes multiple type arguments but you want the compiler\n to infer some of them, you can use type placeholders:\n \n ```compile_fail,E0089\n fn foo<T, U>(x: T) {}\n \n fn main() {\n     let x: bool = true;\n-    foo::<f64>(x);    // error, expected 2 parameters, found 1 parameter\n+    foo::<f64>(x);    // error: wrong number of type arguments:\n+                      //        expected 2, found 1\n     foo::<_, f64>(x); // same as `foo::<bool, f64>(x)`\n }\n ```\n \"##,\n \n E0090: r##\"\n-You gave too few lifetime parameters. Example:\n+You gave too few lifetime arguments. Example:\n \n ```compile_fail,E0090\n fn foo<'a: 'b, 'b: 'a>() {}\n \n fn main() {\n-    foo::<'static>(); // error, expected 2 lifetime parameters\n+    foo::<'static>(); // error: wrong number of lifetime arguments:\n+                      //        expected 2, found 1\n }\n ```\n \n-Please check you give the right number of lifetime parameters. Example:\n+Please check you give the right number of lifetime arguments. Example:\n \n ```\n fn foo<'a: 'b, 'b: 'a>() {}"}, {"sha": "6cb37c0e6de142a16c32d067990b714534fb013b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -2432,10 +2432,7 @@ impl Clean<Type> for hir::Ty {\n                     let mut ty_substs = FxHashMap();\n                     let mut lt_substs = FxHashMap();\n                     provided_params.with_generic_args(|generic_args| {\n-                        let mut indices = ty::GenericParamCount {\n-                            lifetimes: 0,\n-                            types: 0\n-                        };\n+                        let mut indices: GenericParamCount = Default::default();\n                         for param in generics.params.iter() {\n                             match param.kind {\n                                 hir::GenericParamKind::Lifetime { .. } => {"}, {"sha": "1ee70d9bddea0faf7efa8e729ceab9c09232d3fa", "filename": "src/test/ui/bad/bad-mid-path-type-params.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fbad%2Fbad-mid-path-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fbad%2Fbad-mid-path-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbad%2Fbad-mid-path-type-params.rs?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -38,16 +38,16 @@ impl Trait<isize> for S2 {\n \n fn foo<'a>() {\n     let _ = S::new::<isize,f64>(1, 1.0);\n-    //~^ ERROR too many type parameters provided\n+    //~^ ERROR wrong number of type arguments\n \n     let _ = S::<'a,isize>::new::<f64>(1, 1.0);\n-    //~^ ERROR wrong number of lifetime parameters\n+    //~^ ERROR wrong number of lifetime arguments\n \n     let _: S2 = Trait::new::<isize,f64>(1, 1.0);\n-    //~^ ERROR too many type parameters provided\n+    //~^ ERROR wrong number of type arguments\n \n     let _: S2 = Trait::<'a,isize>::new::<f64>(1, 1.0);\n-    //~^ ERROR too many lifetime parameters provided\n+    //~^ ERROR wrong number of lifetime arguments\n }\n \n fn main() {}"}, {"sha": "7901f1f0fba201f2f6747c4ad2acece48c215874", "filename": "src/test/ui/bad/bad-mid-path-type-params.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fbad%2Fbad-mid-path-type-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fbad%2Fbad-mid-path-type-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbad%2Fbad-mid-path-type-params.stderr?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -1,26 +1,26 @@\n-error[E0087]: too many type parameters provided: expected at most 1 type parameter, found 2 type parameters\n+error[E0087]: wrong number of type arguments: expected 1, found 2\n   --> $DIR/bad-mid-path-type-params.rs:40:28\n    |\n LL |     let _ = S::new::<isize,f64>(1, 1.0);\n-   |                            ^^^ expected 1 type parameter\n+   |                            ^^^ unexpected type argument\n \n-error[E0107]: wrong number of lifetime parameters: expected 0, found 1\n-  --> $DIR/bad-mid-path-type-params.rs:43:13\n+error[E0107]: wrong number of lifetime arguments: expected 0, found 1\n+  --> $DIR/bad-mid-path-type-params.rs:43:17\n    |\n LL |     let _ = S::<'a,isize>::new::<f64>(1, 1.0);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^ unexpected lifetime parameter\n+   |                 ^^ unexpected lifetime argument\n \n-error[E0087]: too many type parameters provided: expected at most 1 type parameter, found 2 type parameters\n+error[E0087]: wrong number of type arguments: expected 1, found 2\n   --> $DIR/bad-mid-path-type-params.rs:46:36\n    |\n LL |     let _: S2 = Trait::new::<isize,f64>(1, 1.0);\n-   |                                    ^^^ expected 1 type parameter\n+   |                                    ^^^ unexpected type argument\n \n-error[E0088]: too many lifetime parameters provided: expected at most 0 lifetime parameters, found 1 lifetime parameter\n+error[E0088]: wrong number of lifetime arguments: expected 0, found 1\n   --> $DIR/bad-mid-path-type-params.rs:49:25\n    |\n LL |     let _: S2 = Trait::<'a,isize>::new::<f64>(1, 1.0);\n-   |                         ^^ expected 0 lifetime parameters\n+   |                         ^^ unexpected lifetime argument\n \n error: aborting due to 4 previous errors\n "}, {"sha": "1fe50cfebbac364c2e75add17a3f9e36685007ae", "filename": "src/test/ui/constructor-lifetime-args.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fconstructor-lifetime-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fconstructor-lifetime-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconstructor-lifetime-args.rs?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -25,12 +25,12 @@ enum E<'a, 'b> {\n fn main() {\n     S(&0, &0); // OK\n     S::<'static>(&0, &0);\n-    //~^ ERROR expected 2 lifetime parameters, found 1 lifetime parameter\n+    //~^ ERROR wrong number of lifetime arguments: expected 2, found 1\n     S::<'static, 'static, 'static>(&0, &0);\n-    //~^ ERROR expected at most 2 lifetime parameters, found 3 lifetime parameters\n+    //~^ ERROR wrong number of lifetime arguments: expected 2, found 3\n     E::V(&0); // OK\n     E::V::<'static>(&0);\n-    //~^ ERROR expected 2 lifetime parameters, found 1 lifetime parameter\n+    //~^ ERROR wrong number of lifetime arguments: expected 2, found 1\n     E::V::<'static, 'static, 'static>(&0);\n-    //~^ ERROR expected at most 2 lifetime parameters, found 3 lifetime parameters\n+    //~^ ERROR wrong number of lifetime arguments: expected 2, found 3\n }"}, {"sha": "cf3ad9ae8ecd7ae33bdc7bad2ba982c77c7897c7", "filename": "src/test/ui/constructor-lifetime-args.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fconstructor-lifetime-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fconstructor-lifetime-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconstructor-lifetime-args.stderr?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -1,26 +1,26 @@\n-error[E0090]: too few lifetime parameters provided: expected 2 lifetime parameters, found 1 lifetime parameter\n+error[E0090]: wrong number of lifetime arguments: expected 2, found 1\n   --> $DIR/constructor-lifetime-args.rs:27:5\n    |\n LL |     S::<'static>(&0, &0);\n-   |     ^^^^^^^^^^^^ expected 2 lifetime parameters\n+   |     ^^^^^^^^^^^^ expected 2 lifetime arguments\n \n-error[E0088]: too many lifetime parameters provided: expected at most 2 lifetime parameters, found 3 lifetime parameters\n+error[E0088]: wrong number of lifetime arguments: expected 2, found 3\n   --> $DIR/constructor-lifetime-args.rs:29:27\n    |\n LL |     S::<'static, 'static, 'static>(&0, &0);\n-   |                           ^^^^^^^ expected 2 lifetime parameters\n+   |                           ^^^^^^^ unexpected lifetime argument\n \n-error[E0090]: too few lifetime parameters provided: expected 2 lifetime parameters, found 1 lifetime parameter\n+error[E0090]: wrong number of lifetime arguments: expected 2, found 1\n   --> $DIR/constructor-lifetime-args.rs:32:5\n    |\n LL |     E::V::<'static>(&0);\n-   |     ^^^^^^^^^^^^^^^ expected 2 lifetime parameters\n+   |     ^^^^^^^^^^^^^^^ expected 2 lifetime arguments\n \n-error[E0088]: too many lifetime parameters provided: expected at most 2 lifetime parameters, found 3 lifetime parameters\n+error[E0088]: wrong number of lifetime arguments: expected 2, found 3\n   --> $DIR/constructor-lifetime-args.rs:34:30\n    |\n LL |     E::V::<'static, 'static, 'static>(&0);\n-   |                              ^^^^^^^ expected 2 lifetime parameters\n+   |                              ^^^^^^^ unexpected lifetime argument\n \n error: aborting due to 4 previous errors\n "}, {"sha": "bea76f34220ef7dfa324c5785f21f312b0eb8256", "filename": "src/test/ui/error-codes/E0087.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ferror-codes%2FE0087.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ferror-codes%2FE0087.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0087.rs?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -12,7 +12,7 @@ fn foo() {}\n fn bar<T>() {}\n \n fn main() {\n-    foo::<f64>(); //~ ERROR expected at most 0 type parameters, found 1 type parameter [E0087]\n+    foo::<f64>(); //~ ERROR wrong number of type arguments: expected 0, found 1 [E0087]\n \n-    bar::<f64, u64>(); //~ ERROR expected at most 1 type parameter, found 2 type parameters [E0087]\n+    bar::<f64, u64>(); //~ ERROR wrong number of type arguments: expected 1, found 2 [E0087]\n }"}, {"sha": "a07f1bbf39a3eedd025aa3680758b4fb4d087610", "filename": "src/test/ui/error-codes/E0087.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ferror-codes%2FE0087.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ferror-codes%2FE0087.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0087.stderr?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -1,14 +1,14 @@\n-error[E0087]: too many type parameters provided: expected at most 0 type parameters, found 1 type parameter\n+error[E0087]: wrong number of type arguments: expected 0, found 1\n   --> $DIR/E0087.rs:15:11\n    |\n-LL |     foo::<f64>(); //~ ERROR expected at most 0 type parameters, found 1 type parameter [E0087]\n-   |           ^^^ expected 0 type parameters\n+LL |     foo::<f64>(); //~ ERROR wrong number of type arguments: expected 0, found 1 [E0087]\n+   |           ^^^ unexpected type argument\n \n-error[E0087]: too many type parameters provided: expected at most 1 type parameter, found 2 type parameters\n+error[E0087]: wrong number of type arguments: expected 1, found 2\n   --> $DIR/E0087.rs:17:16\n    |\n-LL |     bar::<f64, u64>(); //~ ERROR expected at most 1 type parameter, found 2 type parameters [E0087]\n-   |                ^^^ expected 1 type parameter\n+LL |     bar::<f64, u64>(); //~ ERROR wrong number of type arguments: expected 1, found 2 [E0087]\n+   |                ^^^ unexpected type argument\n \n error: aborting due to 2 previous errors\n "}, {"sha": "6b956023e05a489174b8678f06b852c26f3e5660", "filename": "src/test/ui/error-codes/E0088.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ferror-codes%2FE0088.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ferror-codes%2FE0088.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0088.stderr?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -1,14 +1,14 @@\n-error[E0088]: too many lifetime parameters provided: expected at most 0 lifetime parameters, found 1 lifetime parameter\n+error[E0088]: wrong number of lifetime arguments: expected 0, found 1\n   --> $DIR/E0088.rs:15:9\n    |\n LL |     f::<'static>(); //~ ERROR E0088\n-   |         ^^^^^^^ expected 0 lifetime parameters\n+   |         ^^^^^^^ unexpected lifetime argument\n \n-error[E0088]: too many lifetime parameters provided: expected at most 1 lifetime parameter, found 2 lifetime parameters\n+error[E0088]: wrong number of lifetime arguments: expected 1, found 2\n   --> $DIR/E0088.rs:16:18\n    |\n LL |     g::<'static, 'static>(); //~ ERROR E0088\n-   |                  ^^^^^^^ expected 1 lifetime parameter\n+   |                  ^^^^^^^ unexpected lifetime argument\n \n error: aborting due to 2 previous errors\n "}, {"sha": "4e6196a7b89dbce7ea1a518f618418c87e0bb021", "filename": "src/test/ui/error-codes/E0089.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ferror-codes%2FE0089.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ferror-codes%2FE0089.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0089.rs?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -11,5 +11,5 @@\n fn foo<T, U>() {}\n \n fn main() {\n-    foo::<f64>(); //~ ERROR expected 2 type parameters, found 1 type parameter [E0089]\n+    foo::<f64>(); //~ ERROR wrong number of type arguments: expected 2, found 1 [E0089]\n }"}, {"sha": "f79c478b733f6d780873263ecba85eceaffb126b", "filename": "src/test/ui/error-codes/E0089.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ferror-codes%2FE0089.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ferror-codes%2FE0089.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0089.stderr?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -1,8 +1,8 @@\n-error[E0089]: too few type parameters provided: expected 2 type parameters, found 1 type parameter\n+error[E0089]: wrong number of type arguments: expected 2, found 1\n   --> $DIR/E0089.rs:14:5\n    |\n-LL |     foo::<f64>(); //~ ERROR expected 2 type parameters, found 1 type parameter [E0089]\n-   |     ^^^^^^^^^^ expected 2 type parameters\n+LL |     foo::<f64>(); //~ ERROR wrong number of type arguments: expected 2, found 1 [E0089]\n+   |     ^^^^^^^^^^ expected 2 type arguments\n \n error: aborting due to previous error\n "}, {"sha": "26be4c12f075e4088610de44784e6e9da6454d46", "filename": "src/test/ui/error-codes/E0090.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ferror-codes%2FE0090.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ferror-codes%2FE0090.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0090.rs?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -11,5 +11,5 @@\n fn foo<'a: 'b, 'b: 'a>() {}\n \n fn main() {\n-    foo::<'static>(); //~ ERROR expected 2 lifetime parameters, found 1 lifetime parameter [E0090]\n+    foo::<'static>(); //~ ERROR wrong number of lifetime arguments: expected 2, found 1 [E0090]\n }"}, {"sha": "9029b6c2708bd3d6fe6c9443ce25721cb29923d4", "filename": "src/test/ui/error-codes/E0090.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ferror-codes%2FE0090.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ferror-codes%2FE0090.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0090.stderr?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -1,8 +1,8 @@\n-error[E0090]: too few lifetime parameters provided: expected 2 lifetime parameters, found 1 lifetime parameter\n+error[E0090]: wrong number of lifetime arguments: expected 2, found 1\n   --> $DIR/E0090.rs:14:5\n    |\n-LL |     foo::<'static>(); //~ ERROR expected 2 lifetime parameters, found 1 lifetime parameter [E0090]\n-   |     ^^^^^^^^^^^^^^ expected 2 lifetime parameters\n+LL |     foo::<'static>(); //~ ERROR wrong number of lifetime arguments: expected 2, found 1 [E0090]\n+   |     ^^^^^^^^^^^^^^ expected 2 lifetime arguments\n \n error: aborting due to previous error\n "}, {"sha": "815c7fefd2a96e79b71594cfae493f8c21bdbe49", "filename": "src/test/ui/error-codes/E0107.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ferror-codes%2FE0107.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ferror-codes%2FE0107.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0107.rs?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -20,14 +20,13 @@ enum Bar {\n struct Baz<'a, 'b, 'c> {\n     buzz: Buzz<'a>,\n     //~^ ERROR E0107\n-    //~| expected 2 lifetime parameters\n+    //~| expected 2 lifetime arguments\n     bar: Bar<'a>,\n     //~^ ERROR E0107\n-    //~| unexpected lifetime parameter\n+    //~| unexpected lifetime argument\n     foo2: Foo<'a, 'b, 'c>,\n     //~^ ERROR E0107\n-    //~| 2 unexpected lifetime parameters\n+    //~| 2 unexpected lifetime arguments\n }\n \n-fn main() {\n-}\n+fn main() {}"}, {"sha": "497fa91bd4f399f58f407dc0516bf16521ce125c", "filename": "src/test/ui/error-codes/E0107.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ferror-codes%2FE0107.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ferror-codes%2FE0107.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0107.stderr?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -1,20 +1,20 @@\n-error[E0107]: wrong number of lifetime parameters: expected 2, found 1\n+error[E0107]: wrong number of lifetime arguments: expected 2, found 1\n   --> $DIR/E0107.rs:21:11\n    |\n LL |     buzz: Buzz<'a>,\n-   |           ^^^^^^^^ expected 2 lifetime parameters\n+   |           ^^^^^^^^ expected 2 lifetime arguments\n \n-error[E0107]: wrong number of lifetime parameters: expected 0, found 1\n-  --> $DIR/E0107.rs:24:10\n+error[E0107]: wrong number of lifetime arguments: expected 0, found 1\n+  --> $DIR/E0107.rs:24:14\n    |\n LL |     bar: Bar<'a>,\n-   |          ^^^^^^^ unexpected lifetime parameter\n+   |              ^^ unexpected lifetime argument\n \n-error[E0107]: wrong number of lifetime parameters: expected 1, found 3\n+error[E0107]: wrong number of lifetime arguments: expected 1, found 3\n   --> $DIR/E0107.rs:27:11\n    |\n LL |     foo2: Foo<'a, 'b, 'c>,\n-   |           ^^^^^^^^^^^^^^^ 2 unexpected lifetime parameters\n+   |           ^^^^^^^^^^^^^^^ 2 unexpected lifetime arguments\n \n error: aborting due to 3 previous errors\n "}, {"sha": "87f063c604fe4065252c05feeda5281171ce22f1", "filename": "src/test/ui/error-codes/E0244.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ferror-codes%2FE0244.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ferror-codes%2FE0244.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0244.stderr?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -2,7 +2,7 @@ error[E0244]: wrong number of type arguments: expected 0, found 2\n   --> $DIR/E0244.rs:12:23\n    |\n LL | struct Bar<S, T> { x: Foo<S, T> }\n-   |                       ^^^^^^^^^ expected no type arguments\n+   |                       ^^^^^^^^^ 2 unexpected type arguments\n \n error: aborting due to previous error\n "}, {"sha": "b8883ff9c8333fccad0aa9f2231dc67bc198077e", "filename": "src/test/ui/generic/generic-arg-mismatch-recover.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fgeneric%2Fgeneric-arg-mismatch-recover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fgeneric%2Fgeneric-arg-mismatch-recover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric%2Fgeneric-arg-mismatch-recover.rs?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo<'a, T: 'a>(&'a T);\n+\n+struct Bar<'a>(&'a ());\n+\n+fn main() {\n+    Foo::<'static, 'static, ()>(&0); //~ ERROR wrong number of lifetime arguments\n+    //~^ ERROR mismatched types\n+\n+    Bar::<'static, 'static, ()>(&()); //~ ERROR wrong number of lifetime arguments\n+    //~^ ERROR wrong number of type arguments\n+}"}, {"sha": "81869ad0d08a53f93bf9930a4cd56dd0b6bfca1f", "filename": "src/test/ui/generic/generic-arg-mismatch-recover.stderr", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fgeneric%2Fgeneric-arg-mismatch-recover.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fgeneric%2Fgeneric-arg-mismatch-recover.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric%2Fgeneric-arg-mismatch-recover.stderr?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -0,0 +1,31 @@\n+error[E0088]: wrong number of lifetime arguments: expected 1, found 2\n+  --> $DIR/generic-arg-mismatch-recover.rs:16:20\n+   |\n+LL |     Foo::<'static, 'static, ()>(&0); //~ ERROR wrong number of lifetime arguments\n+   |                    ^^^^^^^ unexpected lifetime argument\n+\n+error[E0308]: mismatched types\n+  --> $DIR/generic-arg-mismatch-recover.rs:16:33\n+   |\n+LL |     Foo::<'static, 'static, ()>(&0); //~ ERROR wrong number of lifetime arguments\n+   |                                 ^^ expected (), found integral variable\n+   |\n+   = note: expected type `&'static ()`\n+              found type `&{integer}`\n+\n+error[E0088]: wrong number of lifetime arguments: expected 1, found 2\n+  --> $DIR/generic-arg-mismatch-recover.rs:19:20\n+   |\n+LL |     Bar::<'static, 'static, ()>(&()); //~ ERROR wrong number of lifetime arguments\n+   |                    ^^^^^^^ unexpected lifetime argument\n+\n+error[E0087]: wrong number of type arguments: expected 0, found 1\n+  --> $DIR/generic-arg-mismatch-recover.rs:19:29\n+   |\n+LL |     Bar::<'static, 'static, ()>(&()); //~ ERROR wrong number of lifetime arguments\n+   |                             ^^ unexpected type argument\n+\n+error: aborting due to 4 previous errors\n+\n+Some errors occurred: E0087, E0088, E0308.\n+For more information about an error, try `rustc --explain E0087`."}, {"sha": "b614da88ba164953eda612e7cba816500ccf8763", "filename": "src/test/ui/generic/generic-impl-more-params-with-defaults.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fgeneric%2Fgeneric-impl-more-params-with-defaults.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fgeneric%2Fgeneric-impl-more-params-with-defaults.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric%2Fgeneric-impl-more-params-with-defaults.stderr?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -2,7 +2,7 @@ error[E0244]: wrong number of type arguments: expected at most 2, found 3\n   --> $DIR/generic-impl-more-params-with-defaults.rs:23:5\n    |\n LL |     Vec::<isize, Heap, bool>::new();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected at most 2 type arguments\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected at most 2 type argument\n \n error: aborting due to previous error\n "}, {"sha": "f226921816d09f72ef1d263a5780feaae7a507f0", "filename": "src/test/ui/generic/generic-type-more-params-with-defaults.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fgeneric%2Fgeneric-type-more-params-with-defaults.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fgeneric%2Fgeneric-type-more-params-with-defaults.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric%2Fgeneric-type-more-params-with-defaults.stderr?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -2,7 +2,7 @@ error[E0244]: wrong number of type arguments: expected at most 2, found 3\n   --> $DIR/generic-type-more-params-with-defaults.rs:19:12\n    |\n LL |     let _: Vec<isize, Heap, bool>;\n-   |            ^^^^^^^^^^^^^^^^^^^^^^ expected at most 2 type arguments\n+   |            ^^^^^^^^^^^^^^^^^^^^^^ expected at most 2 type argument\n \n error: aborting due to previous error\n "}, {"sha": "8c75ea45a617089037f40b0bd304936809a88001", "filename": "src/test/ui/issue-53251.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fissue-53251.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fissue-53251.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-53251.rs?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -19,10 +19,12 @@ macro_rules! impl_add {\n         $(\n             fn $n() {\n                 S::f::<i64>();\n-                //~^ ERROR too many type parameters provided\n+                //~^ ERROR wrong number of type arguments\n             }\n         )*\n     }\n }\n \n impl_add!(a b);\n+\n+fn main() {}"}, {"sha": "f12afa4a79208a077b041f0a5b8a39091da0040e", "filename": "src/test/ui/issue-53251.stderr", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fissue-53251.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fissue-53251.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-53251.stderr?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -1,17 +1,12 @@\n-error[E0601]: `main` function not found in crate `issue_53251`\n-   |\n-   = note: consider adding a `main` function to `$DIR/issue-53251.rs`\n-\n-error[E0087]: too many type parameters provided: expected at most 0 type parameters, found 1 type parameter\n+error[E0087]: wrong number of type arguments: expected 0, found 1\n   --> $DIR/issue-53251.rs:21:24\n    |\n LL |                 S::f::<i64>();\n-   |                        ^^^ expected 0 type parameters\n+   |                        ^^^ unexpected type argument\n ...\n LL | impl_add!(a b);\n    | --------------- in this macro invocation\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors occurred: E0087, E0601.\n-For more information about an error, try `rustc --explain E0087`.\n+For more information about this error, try `rustc --explain E0087`."}, {"sha": "f550dc6f310ffcb028aed19ea02436572045e5d7", "filename": "src/test/ui/issues/issue-18423.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fissues%2Fissue-18423.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fissues%2Fissue-18423.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-18423.rs?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that `Box` cannot be used with a lifetime parameter.\n+// Test that `Box` cannot be used with a lifetime argument.\n \n struct Foo<'a> {\n-    x: Box<'a, isize> //~ ERROR wrong number of lifetime parameters\n+    x: Box<'a, isize> //~ ERROR wrong number of lifetime arguments\n }\n \n pub fn main() {"}, {"sha": "49afd5130924103bf3fbf0be91a1fe1e6f117fe7", "filename": "src/test/ui/issues/issue-18423.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fissues%2Fissue-18423.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fissues%2Fissue-18423.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-18423.stderr?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -1,8 +1,8 @@\n-error[E0107]: wrong number of lifetime parameters: expected 0, found 1\n-  --> $DIR/issue-18423.rs:14:8\n+error[E0107]: wrong number of lifetime arguments: expected 0, found 1\n+  --> $DIR/issue-18423.rs:14:12\n    |\n-LL |     x: Box<'a, isize> //~ ERROR wrong number of lifetime parameters\n-   |        ^^^^^^^^^^^^^^ unexpected lifetime parameter\n+LL |     x: Box<'a, isize> //~ ERROR wrong number of lifetime arguments\n+   |            ^^ unexpected lifetime argument\n \n error: aborting due to previous error\n "}, {"sha": "2c4b9f84105eac84b240879f1ac9bc97b74540bc", "filename": "src/test/ui/issues/issue-3214.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fissues%2Fissue-3214.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fissues%2Fissue-3214.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3214.stderr?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -10,10 +10,10 @@ LL |         x: T, //~ ERROR can't use type parameters from outer function\n    |            ^ use of type variable from outer function\n \n error[E0244]: wrong number of type arguments: expected 0, found 1\n-  --> $DIR/issue-3214.rs:16:22\n+  --> $DIR/issue-3214.rs:16:26\n    |\n LL |     impl<T> Drop for foo<T> {\n-   |                      ^^^^^^ expected no type arguments\n+   |                          ^ unexpected type argument\n \n error: aborting due to 2 previous errors\n "}, {"sha": "980ada9020c4875a83bc9626f90469caf838b018", "filename": "src/test/ui/methods/method-call-lifetime-args-fail.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-lifetime-args-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-lifetime-args-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-lifetime-args-fail.rs?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -24,9 +24,9 @@ impl S {\n fn method_call() {\n     S.early(); // OK\n     S.early::<'static>();\n-    //~^ ERROR expected 2 lifetime parameters, found 1 lifetime parameter\n+    //~^ ERROR wrong number of lifetime arguments: expected 2, found 1\n     S.early::<'static, 'static, 'static>();\n-    //~^ ERROR expected at most 2 lifetime parameters, found 3 lifetime parameters\n+    //~^ ERROR wrong number of lifetime arguments: expected 2, found 3\n     let _: &u8 = S.life_and_type::<'static>();\n     S.life_and_type::<u8>();\n     S.life_and_type::<'static, u8>();\n@@ -71,9 +71,9 @@ fn ufcs() {\n \n     S::early(S); // OK\n     S::early::<'static>(S);\n-    //~^ ERROR expected 2 lifetime parameters, found 1 lifetime parameter\n+    //~^ ERROR wrong number of lifetime arguments: expected 2, found 1\n     S::early::<'static, 'static, 'static>(S);\n-    //~^ ERROR expected at most 2 lifetime parameters, found 3 lifetime parameters\n+    //~^ ERROR wrong number of lifetime arguments: expected 2, found 3\n     let _: &u8 = S::life_and_type::<'static>(S);\n     S::life_and_type::<u8>(S);\n     S::life_and_type::<'static, u8>(S);"}, {"sha": "d86a9f48e003e347bc1102ab98347e4e5ae9d9c3", "filename": "src/test/ui/methods/method-call-lifetime-args-fail.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-lifetime-args-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-lifetime-args-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-lifetime-args-fail.stderr?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -1,14 +1,14 @@\n-error[E0090]: too few lifetime parameters provided: expected 2 lifetime parameters, found 1 lifetime parameter\n+error[E0090]: wrong number of lifetime arguments: expected 2, found 1\n   --> $DIR/method-call-lifetime-args-fail.rs:26:7\n    |\n LL |     S.early::<'static>();\n-   |       ^^^^^ expected 2 lifetime parameters\n+   |       ^^^^^ expected 2 lifetime arguments\n \n-error[E0088]: too many lifetime parameters provided: expected at most 2 lifetime parameters, found 3 lifetime parameters\n+error[E0088]: wrong number of lifetime arguments: expected 2, found 3\n   --> $DIR/method-call-lifetime-args-fail.rs:28:33\n    |\n LL |     S.early::<'static, 'static, 'static>();\n-   |                                 ^^^^^^^ expected 2 lifetime parameters\n+   |                                 ^^^^^^^ unexpected lifetime argument\n \n error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present\n   --> $DIR/method-call-lifetime-args-fail.rs:37:15\n@@ -178,17 +178,17 @@ note: the late bound lifetime parameter is introduced here\n LL |     fn late_unused_early<'a, 'b>(self) -> &'b u8 { loop {} }\n    |                          ^^\n \n-error[E0090]: too few lifetime parameters provided: expected 2 lifetime parameters, found 1 lifetime parameter\n+error[E0090]: wrong number of lifetime arguments: expected 2, found 1\n   --> $DIR/method-call-lifetime-args-fail.rs:73:5\n    |\n LL |     S::early::<'static>(S);\n-   |     ^^^^^^^^^^^^^^^^^^^ expected 2 lifetime parameters\n+   |     ^^^^^^^^^^^^^^^^^^^ expected 2 lifetime arguments\n \n-error[E0088]: too many lifetime parameters provided: expected at most 2 lifetime parameters, found 3 lifetime parameters\n+error[E0088]: wrong number of lifetime arguments: expected 2, found 3\n   --> $DIR/method-call-lifetime-args-fail.rs:75:34\n    |\n LL |     S::early::<'static, 'static, 'static>(S);\n-   |                                  ^^^^^^^ expected 2 lifetime parameters\n+   |                                  ^^^^^^^ unexpected lifetime argument\n \n error: aborting due to 18 previous errors\n "}, {"sha": "068f08eebe76cc8a1dc116135e7b9350886b1651", "filename": "src/test/ui/seq-args.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fseq-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fseq-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fseq-args.stderr?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -1,14 +1,14 @@\n error[E0244]: wrong number of type arguments: expected 0, found 1\n-  --> $DIR/seq-args.rs:14:9\n+  --> $DIR/seq-args.rs:14:13\n    |\n LL | impl<T> seq<T> for Vec<T> { //~ ERROR wrong number of type arguments\n-   |         ^^^^^^ expected no type arguments\n+   |             ^ unexpected type argument\n \n error[E0244]: wrong number of type arguments: expected 0, found 1\n-  --> $DIR/seq-args.rs:17:6\n+  --> $DIR/seq-args.rs:17:10\n    |\n LL | impl seq<bool> for u32 { //~ ERROR wrong number of type arguments\n-   |      ^^^^^^^^^ expected no type arguments\n+   |          ^^^^ unexpected type argument\n \n error: aborting due to 2 previous errors\n "}, {"sha": "dfa219e0872ce89fbfe4181ea76b7e726547b629", "filename": "src/test/ui/structs/structure-constructor-type-mismatch.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fstructs%2Fstructure-constructor-type-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fstructs%2Fstructure-constructor-type-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstructure-constructor-type-mismatch.stderr?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -71,10 +71,10 @@ LL |         x: 7,\n               found type `{integer}`\n \n error[E0244]: wrong number of type arguments: expected 0, found 1\n-  --> $DIR/structure-constructor-type-mismatch.rs:58:15\n+  --> $DIR/structure-constructor-type-mismatch.rs:58:24\n    |\n LL |     let pt3 = PointF::<i32> { //~ ERROR wrong number of type arguments\n-   |               ^^^^^^^^^^^^^ expected no type arguments\n+   |                        ^^^ unexpected type argument\n \n error[E0308]: mismatched types\n   --> $DIR/structure-constructor-type-mismatch.rs:59:12\n@@ -101,10 +101,10 @@ LL |         y: 10, //~ ERROR mismatched types\n               found type `{integer}`\n \n error[E0244]: wrong number of type arguments: expected 0, found 1\n-  --> $DIR/structure-constructor-type-mismatch.rs:64:9\n+  --> $DIR/structure-constructor-type-mismatch.rs:64:18\n    |\n LL |         PointF::<u32> { .. } => {} //~ ERROR wrong number of type arguments\n-   |         ^^^^^^^^^^^^^ expected no type arguments\n+   |                  ^^^ unexpected type argument\n \n error[E0308]: mismatched types\n   --> $DIR/structure-constructor-type-mismatch.rs:64:9"}, {"sha": "954e20e334566603c8a4a649b0753f783b51387c", "filename": "src/test/ui/traits/trait-object-vs-lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-vs-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-vs-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-vs-lifetime.rs?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -21,7 +21,7 @@ fn main() {\n     let _: S<'static, 'static +>;\n     //~^ at least one non-builtin trait is required for an object type\n     let _: S<'static, 'static>;\n-    //~^ ERROR wrong number of lifetime parameters: expected 1, found 2\n+    //~^ ERROR wrong number of lifetime arguments: expected 1, found 2\n     //~| ERROR wrong number of type arguments: expected 1, found 0\n     let _: S<'static +, 'static>;\n     //~^ ERROR lifetime parameters must be declared prior to type parameters"}, {"sha": "c0b65a7aa5c380207dc2f50cb868023343c16ff2", "filename": "src/test/ui/traits/trait-object-vs-lifetime.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-vs-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-vs-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-vs-lifetime.stderr?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -10,11 +10,11 @@ error[E0224]: at least one non-builtin trait is required for an object type\n LL |     let _: S<'static, 'static +>;\n    |                       ^^^^^^^^^\n \n-error[E0107]: wrong number of lifetime parameters: expected 1, found 2\n-  --> $DIR/trait-object-vs-lifetime.rs:23:12\n+error[E0107]: wrong number of lifetime arguments: expected 1, found 2\n+  --> $DIR/trait-object-vs-lifetime.rs:23:23\n    |\n LL |     let _: S<'static, 'static>;\n-   |            ^^^^^^^^^^^^^^^^^^^ unexpected lifetime parameter\n+   |                       ^^^^^^^ unexpected lifetime argument\n \n error[E0243]: wrong number of type arguments: expected 1, found 0\n   --> $DIR/trait-object-vs-lifetime.rs:23:12"}, {"sha": "dac76fb57fd7c3a3b4592b596222fd5009d261d9", "filename": "src/test/ui/traits/trait-test-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ftraits%2Ftrait-test-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ftraits%2Ftrait-test-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-test-2.rs?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -15,8 +15,8 @@ impl bar for i32 { fn dup(&self) -> i32 { *self } fn blah<X>(&self) {} }\n impl bar for u32 { fn dup(&self) -> u32 { *self } fn blah<X>(&self) {} }\n \n fn main() {\n-    10.dup::<i32>(); //~ ERROR expected at most 0 type parameters, found 1 type parameter\n-    10.blah::<i32, i32>(); //~ ERROR expected at most 1 type parameter, found 2 type parameters\n+    10.dup::<i32>(); //~ ERROR wrong number of type arguments: expected 0, found 1\n+    10.blah::<i32, i32>(); //~ ERROR wrong number of type arguments: expected 1, found 2\n     (box 10 as Box<bar>).dup();\n     //~^ ERROR E0038\n     //~| ERROR E0038"}, {"sha": "fb9cd7019224d9be6a3997beaf1c155d28562125", "filename": "src/test/ui/traits/trait-test-2.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ftraits%2Ftrait-test-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ftraits%2Ftrait-test-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-test-2.stderr?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -1,14 +1,14 @@\n-error[E0087]: too many type parameters provided: expected at most 0 type parameters, found 1 type parameter\n+error[E0087]: wrong number of type arguments: expected 0, found 1\n   --> $DIR/trait-test-2.rs:18:14\n    |\n-LL |     10.dup::<i32>(); //~ ERROR expected at most 0 type parameters, found 1 type parameter\n-   |              ^^^ expected 0 type parameters\n+LL |     10.dup::<i32>(); //~ ERROR wrong number of type arguments: expected 0, found 1\n+   |              ^^^ unexpected type argument\n \n-error[E0087]: too many type parameters provided: expected at most 1 type parameter, found 2 type parameters\n+error[E0087]: wrong number of type arguments: expected 1, found 2\n   --> $DIR/trait-test-2.rs:19:20\n    |\n-LL |     10.blah::<i32, i32>(); //~ ERROR expected at most 1 type parameter, found 2 type parameters\n-   |                    ^^^ expected 1 type parameter\n+LL |     10.blah::<i32, i32>(); //~ ERROR wrong number of type arguments: expected 1, found 2\n+   |                    ^^^ unexpected type argument\n \n error[E0277]: the trait bound `dyn bar: bar` is not satisfied\n   --> $DIR/trait-test-2.rs:20:26"}, {"sha": "9285b8ca6bcf04fb1eb25cb218127fa66ff5354d", "filename": "src/test/ui/typeck/typeck-builtin-bound-type-parameters.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-builtin-bound-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-builtin-bound-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-builtin-bound-type-parameters.rs?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -18,12 +18,12 @@ struct MyStruct1<T: Copy<T>>;\n //~^ ERROR wrong number of type arguments: expected 0, found 1 [E0244]\n \n struct MyStruct2<'a, T: Copy<'a>>;\n-//~^ ERROR: wrong number of lifetime parameters: expected 0, found 1\n+//~^ ERROR: wrong number of lifetime arguments: expected 0, found 1\n \n \n fn foo2<'a, T:Copy<'a, U>, U>(x: T) {}\n //~^ ERROR wrong number of type arguments: expected 0, found 1 [E0244]\n-//~| ERROR: wrong number of lifetime parameters: expected 0, found 1\n+//~| ERROR: wrong number of lifetime arguments: expected 0, found 1\n \n fn main() {\n }"}, {"sha": "b6444181dd8bd80755fd9004327d9ec1c87073d3", "filename": "src/test/ui/typeck/typeck-builtin-bound-type-parameters.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-builtin-bound-type-parameters.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-builtin-bound-type-parameters.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-builtin-bound-type-parameters.stderr?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -1,38 +1,38 @@\n error[E0244]: wrong number of type arguments: expected 0, found 1\n-  --> $DIR/typeck-builtin-bound-type-parameters.rs:11:11\n+  --> $DIR/typeck-builtin-bound-type-parameters.rs:11:16\n    |\n LL | fn foo1<T:Copy<U>, U>(x: T) {}\n-   |           ^^^^^^^ expected no type arguments\n+   |                ^ unexpected type argument\n \n error[E0244]: wrong number of type arguments: expected 0, found 1\n-  --> $DIR/typeck-builtin-bound-type-parameters.rs:14:14\n+  --> $DIR/typeck-builtin-bound-type-parameters.rs:14:19\n    |\n LL | trait Trait: Copy<Send> {}\n-   |              ^^^^^^^^^^ expected no type arguments\n+   |                   ^^^^ unexpected type argument\n \n error[E0244]: wrong number of type arguments: expected 0, found 1\n-  --> $DIR/typeck-builtin-bound-type-parameters.rs:17:21\n+  --> $DIR/typeck-builtin-bound-type-parameters.rs:17:26\n    |\n LL | struct MyStruct1<T: Copy<T>>;\n-   |                     ^^^^^^^ expected no type arguments\n+   |                          ^ unexpected type argument\n \n-error[E0107]: wrong number of lifetime parameters: expected 0, found 1\n-  --> $DIR/typeck-builtin-bound-type-parameters.rs:20:25\n+error[E0107]: wrong number of lifetime arguments: expected 0, found 1\n+  --> $DIR/typeck-builtin-bound-type-parameters.rs:20:30\n    |\n LL | struct MyStruct2<'a, T: Copy<'a>>;\n-   |                         ^^^^^^^^ unexpected lifetime parameter\n+   |                              ^^ unexpected lifetime argument\n \n-error[E0107]: wrong number of lifetime parameters: expected 0, found 1\n-  --> $DIR/typeck-builtin-bound-type-parameters.rs:24:15\n+error[E0107]: wrong number of lifetime arguments: expected 0, found 1\n+  --> $DIR/typeck-builtin-bound-type-parameters.rs:24:20\n    |\n LL | fn foo2<'a, T:Copy<'a, U>, U>(x: T) {}\n-   |               ^^^^^^^^^^^ unexpected lifetime parameter\n+   |                    ^^ unexpected lifetime argument\n \n error[E0244]: wrong number of type arguments: expected 0, found 1\n-  --> $DIR/typeck-builtin-bound-type-parameters.rs:24:15\n+  --> $DIR/typeck-builtin-bound-type-parameters.rs:24:24\n    |\n LL | fn foo2<'a, T:Copy<'a, U>, U>(x: T) {}\n-   |               ^^^^^^^^^^^ expected no type arguments\n+   |                        ^ unexpected type argument\n \n error: aborting due to 6 previous errors\n "}, {"sha": "a49839b731070174d96e386d3887df99bb6a94fb", "filename": "src/test/ui/typeck/typeck_type_placeholder_lifetime_1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_lifetime_1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_lifetime_1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_lifetime_1.stderr?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -1,8 +1,8 @@\n error[E0244]: wrong number of type arguments: expected 1, found 2\n-  --> $DIR/typeck_type_placeholder_lifetime_1.rs:19:12\n+  --> $DIR/typeck_type_placeholder_lifetime_1.rs:19:19\n    |\n LL |     let c: Foo<_, _> = Foo { r: &5 };\n-   |            ^^^^^^^^^ expected 1 type argument\n+   |                   ^ unexpected type argument\n \n error: aborting due to previous error\n "}, {"sha": "cafb6f507a0e9052d7e2b00bb773b931dd6223d6", "filename": "src/test/ui/typeck/typeck_type_placeholder_lifetime_2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_lifetime_2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_lifetime_2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_lifetime_2.stderr?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -1,8 +1,8 @@\n error[E0244]: wrong number of type arguments: expected 1, found 2\n-  --> $DIR/typeck_type_placeholder_lifetime_2.rs:19:12\n+  --> $DIR/typeck_type_placeholder_lifetime_2.rs:19:19\n    |\n LL |     let c: Foo<_, usize> = Foo { r: &5 };\n-   |            ^^^^^^^^^^^^^ expected 1 type argument\n+   |                   ^^^^^ unexpected type argument\n \n error: aborting due to previous error\n "}, {"sha": "294a0fa0340cce58b505bb878570817f966f98e4", "filename": "src/test/ui/ufcs/ufcs-qpath-missing-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fufcs%2Fufcs-qpath-missing-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fufcs%2Fufcs-qpath-missing-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fufcs%2Fufcs-qpath-missing-params.rs?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -22,5 +22,5 @@ impl<'a> IntoCow<'a, str> for String {\n \n fn main() {\n     <String as IntoCow>::into_cow(\"foo\".to_string());\n-    //~^ ERROR too few type parameters provided: expected 1 type parameter\n+    //~^ ERROR wrong number of type arguments: expected 1, found 0\n }"}, {"sha": "2653b7bf4ac7b839fda5c5dacdbd51874c3a8a90", "filename": "src/test/ui/ufcs/ufcs-qpath-missing-params.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fufcs%2Fufcs-qpath-missing-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Fufcs%2Fufcs-qpath-missing-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fufcs%2Fufcs-qpath-missing-params.stderr?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -1,8 +1,8 @@\n-error[E0089]: too few type parameters provided: expected 1 type parameter, found 0 type parameters\n+error[E0089]: wrong number of type arguments: expected 1, found 0\n   --> $DIR/ufcs-qpath-missing-params.rs:24:5\n    |\n LL |     <String as IntoCow>::into_cow(\"foo\".to_string());\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 1 type parameter\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 1 type argument\n \n error: aborting due to previous error\n "}, {"sha": "331ad620c27c02a310410a437f53e53b460f9a1e", "filename": "src/test/ui/unboxed-closures/unboxed-closure-sugar-region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-region.rs?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -38,7 +38,7 @@ fn test<'a,'b>() {\n }\n \n fn test2(x: &Foo<(isize,),Output=()>, y: &Foo(isize)) {\n-//~^ ERROR wrong number of lifetime parameters: expected 1, found 0\n+//~^ ERROR wrong number of lifetime arguments: expected 1, found 0\n     // Here, the omitted lifetimes are expanded to distinct things.\n     same_type(x, y)\n }"}, {"sha": "2245c5e66481ee5b21e0f4fa96795d70be3acb4d", "filename": "src/test/ui/unboxed-closures/unboxed-closure-sugar-region.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-region.stderr?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -1,8 +1,8 @@\n-error[E0107]: wrong number of lifetime parameters: expected 1, found 0\n+error[E0107]: wrong number of lifetime arguments: expected 1, found 0\n   --> $DIR/unboxed-closure-sugar-region.rs:40:43\n    |\n LL | fn test2(x: &Foo<(isize,),Output=()>, y: &Foo(isize)) {\n-   |                                           ^^^^^^^^^^ expected 1 lifetime parameter\n+   |                                           ^^^^^^^^^^ expected 1 lifetime argument\n \n error: aborting due to previous error\n "}, {"sha": "89587c47cf67d1a1c71bd53dc2f2ac22d451f153", "filename": "src/test/ui/unboxed-closures/unboxed-closure-sugar-wrong-number-number-type-parameters.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-wrong-number-number-type-parameters.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-wrong-number-number-type-parameters.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-wrong-number-number-type-parameters.stderr?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -1,8 +1,8 @@\n error[E0244]: wrong number of type arguments: expected 0, found 1\n-  --> $DIR/unboxed-closure-sugar-wrong-number-number-type-parameters.rs:15:11\n+  --> $DIR/unboxed-closure-sugar-wrong-number-number-type-parameters.rs:15:15\n    |\n LL | fn foo(_: Zero())\n-   |           ^^^^^^ expected no type arguments\n+   |               ^^ unexpected type argument\n \n error[E0220]: associated type `Output` not found for `Zero`\n   --> $DIR/unboxed-closure-sugar-wrong-number-number-type-parameters.rs:15:15"}, {"sha": "5d8c86f5a580974241d8ece24fa5960e861d97f8", "filename": "src/test/ui/unboxed-closures/unboxed-closure-sugar-wrong-trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-wrong-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1558ae7cfd5e1190d3388dcc6f0f734589e4e478/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-wrong-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-wrong-trait.stderr?ref=1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "patch": "@@ -1,8 +1,8 @@\n error[E0244]: wrong number of type arguments: expected 0, found 1\n-  --> $DIR/unboxed-closure-sugar-wrong-trait.rs:15:8\n+  --> $DIR/unboxed-closure-sugar-wrong-trait.rs:15:13\n    |\n LL | fn f<F:Trait(isize) -> isize>(x: F) {}\n-   |        ^^^^^^^^^^^^^^^^^^^^^ expected no type arguments\n+   |             ^^^^^^^^^^^^^^^^ unexpected type argument\n \n error[E0220]: associated type `Output` not found for `Trait`\n   --> $DIR/unboxed-closure-sugar-wrong-trait.rs:15:24"}]}