{"sha": "020373f2c807627274a53251a7841f0e9617e98e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyMDM3M2YyYzgwNzYyNzI3NGE1MzI1MWE3ODQxZjBlOTYxN2U5OGU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-06-20T10:35:06Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-06-22T13:54:42Z"}, "message": "Refactor the unification code and rejuvenate the unit test\ninfrastructure that has been accidentally left out of the build\nfor a rather long time (it was still using `@DVec`!)", "tree": {"sha": "7088040ad89b47105860ed7dbad6fb4321362b66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7088040ad89b47105860ed7dbad6fb4321362b66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/020373f2c807627274a53251a7841f0e9617e98e", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/020373f2c807627274a53251a7841f0e9617e98e", "html_url": "https://github.com/rust-lang/rust/commit/020373f2c807627274a53251a7841f0e9617e98e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/020373f2c807627274a53251a7841f0e9617e98e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c39962d325c09849e9cbb1828f85028f29fcea3", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c39962d325c09849e9cbb1828f85028f29fcea3", "html_url": "https://github.com/rust-lang/rust/commit/4c39962d325c09849e9cbb1828f85028f29fcea3"}], "stats": {"total": 2350, "additions": 1353, "deletions": 997}, "files": [{"sha": "766cb06907e8bb91b4101b7be1a57c963fd56d03", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 14, "deletions": 28, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/020373f2c807627274a53251a7841f0e9617e98e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/020373f2c807627274a53251a7841f0e9617e98e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=020373f2c807627274a53251a7841f0e9617e98e", "patch": "@@ -850,17 +850,23 @@ impl CLike for BuiltinBound {\n }\n \n #[deriving(Clone, PartialEq, Eq, Hash)]\n-pub struct TyVid(pub uint);\n+pub struct TyVid {\n+    pub index: uint\n+}\n \n #[deriving(Clone, PartialEq, Eq, Hash)]\n-pub struct IntVid(pub uint);\n+pub struct IntVid {\n+    pub index: uint\n+}\n \n #[deriving(Clone, PartialEq, Eq, Hash)]\n-pub struct FloatVid(pub uint);\n+pub struct FloatVid {\n+    pub index: uint\n+}\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct RegionVid {\n-    pub id: uint\n+    pub index: uint\n }\n \n #[deriving(Clone, PartialEq, Eq, Hash)]\n@@ -893,47 +899,27 @@ impl cmp::PartialEq for InferRegion {\n     }\n }\n \n-pub trait Vid {\n-    fn to_uint(&self) -> uint;\n-}\n-\n-impl Vid for TyVid {\n-    fn to_uint(&self) -> uint { let TyVid(v) = *self; v }\n-}\n-\n impl fmt::Show for TyVid {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n-        write!(f, \"<generic #{}>\", self.to_uint())\n+        write!(f, \"<generic #{}>\", self.index)\n     }\n }\n \n-impl Vid for IntVid {\n-    fn to_uint(&self) -> uint { let IntVid(v) = *self; v }\n-}\n-\n impl fmt::Show for IntVid {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"<generic integer #{}>\", self.to_uint())\n+        write!(f, \"<generic integer #{}>\", self.index)\n     }\n }\n \n-impl Vid for FloatVid {\n-    fn to_uint(&self) -> uint { let FloatVid(v) = *self; v }\n-}\n-\n impl fmt::Show for FloatVid {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"<generic float #{}>\", self.to_uint())\n+        write!(f, \"<generic float #{}>\", self.index)\n     }\n }\n \n-impl Vid for RegionVid {\n-    fn to_uint(&self) -> uint { self.id }\n-}\n-\n impl fmt::Show for RegionVid {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.id.fmt(f)\n+        write!(f, \"'<generic lifetime #{}>\", self.index)\n     }\n }\n "}, {"sha": "71bc2f0374c5a149721fba6aedf93a3b7a26a157", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/020373f2c807627274a53251a7841f0e9617e98e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/020373f2c807627274a53251a7841f0e9617e98e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=020373f2c807627274a53251a7841f0e9617e98e", "patch": "@@ -519,7 +519,8 @@ impl<'a> CoherenceChecker<'a> {\n     fn can_unify_universally_quantified<'a>(&self,\n                                             a: &'a UniversalQuantificationResult,\n                                             b: &'a UniversalQuantificationResult)\n-                                            -> bool {\n+                                            -> bool\n+    {\n         infer::can_mk_subty(&self.inference_context,\n                             a.monotype,\n                             b.monotype).is_ok()"}, {"sha": "9317563da934f1ab6c01bebc475a19dc86fa67ba", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/020373f2c807627274a53251a7841f0e9617e98e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/020373f2c807627274a53251a7841f0e9617e98e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=020373f2c807627274a53251a7841f0e9617e98e", "patch": "@@ -71,9 +71,9 @@ use middle::ty;\n use middle::typeck::infer::{CoerceResult, resolve_type, Coercion};\n use middle::typeck::infer::combine::{CombineFields, Combine};\n use middle::typeck::infer::sub::Sub;\n-use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::resolve::try_resolve_tvar_shallow;\n use util::common::indenter;\n+use util::ppaux::Repr;\n \n use syntax::abi;\n use syntax::ast::MutImmutable;\n@@ -91,8 +91,8 @@ impl<'f> Coerce<'f> {\n \n     pub fn tys(&self, a: ty::t, b: ty::t) -> CoerceResult {\n         debug!(\"Coerce.tys({} => {})\",\n-               a.inf_str(self.get_ref().infcx),\n-               b.inf_str(self.get_ref().infcx));\n+               a.repr(self.get_ref().infcx.tcx),\n+               b.repr(self.get_ref().infcx.tcx));\n         let _indent = indenter();\n \n         // Examine the supertype and consider auto-borrowing.\n@@ -233,8 +233,8 @@ impl<'f> Coerce<'f> {\n                                    mt_b: ty::mt)\n                                    -> CoerceResult {\n         debug!(\"coerce_borrowed_pointer(a={}, sty_a={:?}, b={}, mt_b={:?})\",\n-               a.inf_str(self.get_ref().infcx), sty_a,\n-               b.inf_str(self.get_ref().infcx), mt_b);\n+               a.repr(self.get_ref().infcx.tcx), sty_a,\n+               b.repr(self.get_ref().infcx.tcx), mt_b);\n \n         // If we have a parameter of type `&M T_a` and the value\n         // provided is `expr`, we will be adding an implicit borrow,\n@@ -270,8 +270,8 @@ impl<'f> Coerce<'f> {\n                                   b: ty::t)\n                                   -> CoerceResult {\n         debug!(\"coerce_borrowed_string(a={}, sty_a={:?}, b={})\",\n-               a.inf_str(self.get_ref().infcx), sty_a,\n-               b.inf_str(self.get_ref().infcx));\n+               a.repr(self.get_ref().infcx.tcx), sty_a,\n+               b.repr(self.get_ref().infcx.tcx));\n \n         match *sty_a {\n             ty::ty_uniq(t) => match ty::get(t).sty {\n@@ -300,8 +300,8 @@ impl<'f> Coerce<'f> {\n                                   mutbl_b: ast::Mutability)\n                                   -> CoerceResult {\n         debug!(\"coerce_borrowed_vector(a={}, sty_a={:?}, b={})\",\n-               a.inf_str(self.get_ref().infcx), sty_a,\n-               b.inf_str(self.get_ref().infcx));\n+               a.repr(self.get_ref().infcx.tcx), sty_a,\n+               b.repr(self.get_ref().infcx.tcx));\n \n         let sub = Sub(self.get_ref().clone());\n         let coercion = Coercion(self.get_ref().trace.clone());\n@@ -336,8 +336,8 @@ impl<'f> Coerce<'f> {\n                               b_mutbl: ast::Mutability) -> CoerceResult\n     {\n         debug!(\"coerce_borrowed_object(a={}, sty_a={:?}, b={})\",\n-               a.inf_str(self.get_ref().infcx), sty_a,\n-               b.inf_str(self.get_ref().infcx));\n+               a.repr(self.get_ref().infcx.tcx), sty_a,\n+               b.repr(self.get_ref().infcx.tcx));\n \n         let tcx = self.get_ref().infcx.tcx;\n         let coercion = Coercion(self.get_ref().trace.clone());\n@@ -376,8 +376,8 @@ impl<'f> Coerce<'f> {\n                               b: ty::t)\n                               -> CoerceResult {\n         debug!(\"coerce_borrowed_fn(a={}, sty_a={:?}, b={})\",\n-               a.inf_str(self.get_ref().infcx), sty_a,\n-               b.inf_str(self.get_ref().infcx));\n+               a.repr(self.get_ref().infcx.tcx), sty_a,\n+               b.repr(self.get_ref().infcx.tcx));\n \n         match *sty_a {\n             ty::ty_bare_fn(ref f) => {\n@@ -400,7 +400,7 @@ impl<'f> Coerce<'f> {\n         self.unpack_actual_value(b, |sty_b| {\n \n             debug!(\"coerce_from_bare_fn(a={}, b={})\",\n-                   a.inf_str(self.get_ref().infcx), b.inf_str(self.get_ref().infcx));\n+                   a.repr(self.get_ref().infcx.tcx), b.repr(self.get_ref().infcx.tcx));\n \n             if fn_ty_a.abi != abi::Rust || fn_ty_a.fn_style != ast::NormalFn {\n                 return self.subtype(a, b);\n@@ -429,8 +429,8 @@ impl<'f> Coerce<'f> {\n                              mt_b: ty::mt)\n                              -> CoerceResult {\n         debug!(\"coerce_unsafe_ptr(a={}, sty_a={:?}, b={})\",\n-               a.inf_str(self.get_ref().infcx), sty_a,\n-               b.inf_str(self.get_ref().infcx));\n+               a.repr(self.get_ref().infcx.tcx), sty_a,\n+               b.repr(self.get_ref().infcx.tcx));\n \n         let mt_a = match *sty_a {\n             ty::ty_rptr(_, mt) => mt,\n@@ -462,8 +462,8 @@ impl<'f> Coerce<'f> {\n                          bounds: ty::BuiltinBounds) -> CoerceResult {\n \n         debug!(\"coerce_object(a={}, sty_a={:?}, b={})\",\n-               a.inf_str(self.get_ref().infcx), sty_a,\n-               b.inf_str(self.get_ref().infcx));\n+               a.repr(self.get_ref().infcx.tcx), sty_a,\n+               b.repr(self.get_ref().infcx.tcx));\n \n         Ok(Some(ty::AutoObject(trait_store, bounds,\n                                trait_def_id, trait_substs.clone())))"}, {"sha": "844a37d366ee53b1bd436740e19fee6c96f78468", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/020373f2c807627274a53251a7841f0e9617e98e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/020373f2c807627274a53251a7841f0e9617e98e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=020373f2c807627274a53251a7841f0e9617e98e", "patch": "@@ -57,8 +57,7 @@ use middle::typeck::infer::{ToUres};\n use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::sub::Sub;\n-use middle::typeck::infer::to_str::InferStr;\n-use middle::typeck::infer::unify::InferCtxtMethods;\n+use middle::typeck::infer::unify::InferCtxtMethodsForSimplyUnifiableTypes;\n use middle::typeck::infer::{InferCtxt, cres, ures};\n use middle::typeck::infer::{TypeTrace};\n use util::common::indent;\n@@ -263,7 +262,7 @@ pub trait Combine {\n                     a: ty::TraitStore,\n                     b: ty::TraitStore)\n                     -> cres<ty::TraitStore> {\n-        debug!(\"{}.trait_stores(a={:?}, b={:?})\", self.tag(), a, b);\n+        debug!(\"{}.trait_stores(a={}, b={})\", self.tag(), a, b);\n \n         match (a, b) {\n             (ty::RegionTraitStore(a_r, a_m),\n@@ -409,8 +408,8 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n         tcx.sess.bug(\n             format!(\"{}: bot and var types should have been handled ({},{})\",\n                     this.tag(),\n-                    a.inf_str(this.infcx()),\n-                    b.inf_str(this.infcx())).as_slice());\n+                    a.repr(this.infcx().tcx),\n+                    b.repr(this.infcx().tcx)).as_slice());\n       }\n \n         // Relate integral variables to other types"}, {"sha": "d2c27330a94ade27e266e64a360615ac46b8d28a", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/020373f2c807627274a53251a7841f0e9617e98e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/020373f2c807627274a53251a7841f0e9617e98e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=020373f2c807627274a53251a7841f0e9617e98e", "patch": "@@ -17,16 +17,17 @@ use middle::typeck::infer::combine::*;\n use middle::typeck::infer::lattice::*;\n use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::sub::Sub;\n-use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::{cres, InferCtxt};\n use middle::typeck::infer::{TypeTrace, Subtype};\n use middle::typeck::infer::fold_regions_in_sig;\n+use middle::typeck::infer::region_inference::RegionMark;\n use syntax::ast::{Many, Once, MutImmutable, MutMutable};\n use syntax::ast::{NormalFn, UnsafeFn, NodeId};\n use syntax::ast::{Onceness, FnStyle};\n use std::collections::HashMap;\n use util::common::{indenter};\n use util::ppaux::mt_to_str;\n+use util::ppaux::Repr;\n \n pub struct Glb<'f>(pub CombineFields<'f>);  // \"greatest lower bound\" (common subtype)\n \n@@ -104,8 +105,8 @@ impl<'f> Combine for Glb<'f> {\n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n         debug!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n-               a.inf_str(self.get_ref().infcx),\n-               b.inf_str(self.get_ref().infcx));\n+               a.repr(self.get_ref().infcx.tcx),\n+               b.repr(self.get_ref().infcx.tcx));\n \n         Ok(self.get_ref().infcx.region_vars.glb_regions(Subtype(self.trace()), a, b))\n     }\n@@ -124,14 +125,12 @@ impl<'f> Combine for Glb<'f> {\n         // please see the large comment in `region_inference.rs`.\n \n         debug!(\"{}.fn_sigs({:?}, {:?})\",\n-               self.tag(), a.inf_str(self.get_ref().infcx), b.inf_str(self.get_ref().infcx));\n+               self.tag(), a.repr(self.get_ref().infcx.tcx), b.repr(self.get_ref().infcx.tcx));\n         let _indenter = indenter();\n \n-        // Take a snapshot.  We'll never roll this back, but in later\n-        // phases we do want to be able to examine \"all bindings that\n-        // were created as part of this type comparison\", and making a\n-        // snapshot is a convenient way to do that.\n-        let snapshot = self.get_ref().infcx.region_vars.start_snapshot();\n+        // Make a mark so we can examine \"all bindings that were\n+        // created as part of this type comparison\".\n+        let mark = self.get_ref().infcx.region_vars.mark();\n \n         // Instantiate each bound region with a fresh region variable.\n         let (a_with_fresh, a_map) =\n@@ -145,30 +144,30 @@ impl<'f> Combine for Glb<'f> {\n \n         // Collect constraints.\n         let sig0 = if_ok!(super_fn_sigs(self, &a_with_fresh, &b_with_fresh));\n-        debug!(\"sig0 = {}\", sig0.inf_str(self.get_ref().infcx));\n+        debug!(\"sig0 = {}\", sig0.repr(self.get_ref().infcx.tcx));\n \n         // Generalize the regions appearing in fn_ty0 if possible\n         let new_vars =\n-            self.get_ref().infcx.region_vars.vars_created_since_snapshot(snapshot);\n+            self.get_ref().infcx.region_vars.vars_created_since_mark(mark);\n         let sig1 =\n             fold_regions_in_sig(\n                 self.get_ref().infcx.tcx,\n                 &sig0,\n                 |r| {\n                 generalize_region(self,\n-                                  snapshot,\n+                                  mark,\n                                   new_vars.as_slice(),\n                                   sig0.binder_id,\n                                   &a_map,\n                                   a_vars.as_slice(),\n                                   b_vars.as_slice(),\n                                   r)\n             });\n-        debug!(\"sig1 = {}\", sig1.inf_str(self.get_ref().infcx));\n+        debug!(\"sig1 = {}\", sig1.repr(self.get_ref().infcx.tcx));\n         return Ok(sig1);\n \n         fn generalize_region(this: &Glb,\n-                             snapshot: uint,\n+                             mark: RegionMark,\n                              new_vars: &[RegionVid],\n                              new_binder_id: NodeId,\n                              a_map: &HashMap<ty::BoundRegion, ty::Region>,\n@@ -180,7 +179,7 @@ impl<'f> Combine for Glb<'f> {\n                 return r0;\n             }\n \n-            let tainted = this.get_ref().infcx.region_vars.tainted(snapshot, r0);\n+            let tainted = this.get_ref().infcx.region_vars.tainted(mark, r0);\n \n             let mut a_r = None;\n             let mut b_r = None;"}, {"sha": "1b3d96e474e4b5f051aae01b892f3eb4c9a959fd", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 186, "deletions": 170, "changes": 356, "blob_url": "https://github.com/rust-lang/rust/blob/020373f2c807627274a53251a7841f0e9617e98e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/020373f2c807627274a53251a7841f0e9617e98e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=020373f2c807627274a53251a7841f0e9617e98e", "patch": "@@ -32,22 +32,20 @@\n  * a lattice.\n  */\n \n-\n-use middle::ty::{RegionVid, TyVar, Vid};\n+use middle::ty::{RegionVid, TyVar};\n use middle::ty;\n-use middle::typeck::infer::{then, ToUres};\n+use middle::typeck::infer::{ToUres};\n use middle::typeck::infer::*;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::lub::Lub;\n-use middle::typeck::infer::unify::*;\n+use middle::typeck::infer::unify::{Root, UnifyKey};\n use middle::typeck::infer::sub::Sub;\n-use middle::typeck::infer::to_str::InferStr;\n-use util::common::indenter;\n+use util::ppaux::Repr;\n \n use std::collections::HashMap;\n \n-trait LatticeValue {\n+trait LatticeValue : Clone + Repr + PartialEq {\n     fn sub(cf: CombineFields, a: &Self, b: &Self) -> ures;\n     fn lub(cf: CombineFields, a: &Self, b: &Self) -> cres<Self>;\n     fn glb(cf: CombineFields, a: &Self, b: &Self) -> cres<Self>;\n@@ -70,72 +68,73 @@ impl LatticeValue for ty::t {\n     }\n }\n \n-pub trait CombineFieldsLatticeMethods {\n-    fn var_sub_var<T:Clone + InferStr + LatticeValue,\n-                   V:Clone + PartialEq + ToStr + Vid + UnifyVid<Bounds<T>>>(&self,\n-                                                                     a_id: V,\n-                                                                     b_id: V)\n-                                                                     -> ures;\n+pub trait CombineFieldsLatticeMethods<T:LatticeValue, K:UnifyKey<Bounds<T>>> {\n+    /// make variable a subtype of variable\n+    fn var_sub_var(&self,\n+                   a_id: K,\n+                   b_id: K)\n+                   -> ures;\n+\n     /// make variable a subtype of T\n-    fn var_sub_t<T:Clone + InferStr + LatticeValue,\n-                 V:Clone + PartialEq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n-                 &self,\n-                 a_id: V,\n+    fn var_sub_t(&self,\n+                 a_id: K,\n                  b: T)\n                  -> ures;\n-    fn t_sub_var<T:Clone + InferStr + LatticeValue,\n-                 V:Clone + PartialEq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n-                 &self,\n+\n+    /// make T a subtype of variable\n+    fn t_sub_var(&self,\n                  a: T,\n-                 b_id: V)\n+                 b_id: K)\n                  -> ures;\n-    fn merge_bnd<T:Clone + InferStr + LatticeValue>(\n-                 &self,\n-                 a: &Bound<T>,\n-                 b: &Bound<T>,\n-                 lattice_op: LatticeOp<T>)\n-                 -> cres<Bound<T>>;\n-    fn set_var_to_merged_bounds<T:Clone + InferStr + LatticeValue,\n-                                V:Clone+PartialEq+ToStr+Vid+UnifyVid<Bounds<T>>>(\n-                                &self,\n-                                v_id: V,\n+\n+    fn set_var_to_merged_bounds(&self,\n+                                v_id: K,\n                                 a: &Bounds<T>,\n                                 b: &Bounds<T>,\n                                 rank: uint)\n                                 -> ures;\n-    fn bnds<T:Clone + InferStr + LatticeValue>(\n-            &self,\n-            a: &Bound<T>,\n-            b: &Bound<T>)\n-            -> ures;\n }\n \n-impl<'f> CombineFieldsLatticeMethods for CombineFields<'f> {\n-    fn var_sub_var<T:Clone + InferStr + LatticeValue,\n-                   V:Clone + PartialEq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n-                   &self,\n-                   a_id: V,\n-                   b_id: V)\n-                   -> ures {\n+pub trait CombineFieldsLatticeMethods2<T:LatticeValue> {\n+    fn merge_bnd(&self,\n+                 a: &Bound<T>,\n+                 b: &Bound<T>,\n+                 lattice_op: LatticeOp<T>)\n+                 -> cres<Bound<T>>;\n+\n+    fn bnds(&self, a: &Bound<T>, b: &Bound<T>) -> ures;\n+}\n+\n+impl<'f,T:LatticeValue, K:UnifyKey<Bounds<T>>>\n+    CombineFieldsLatticeMethods<T,K> for CombineFields<'f>\n+{\n+    fn var_sub_var(&self,\n+                   a_id: K,\n+                   b_id: K)\n+                   -> ures\n+    {\n         /*!\n-         *\n          * Make one variable a subtype of another variable.  This is a\n          * subtle and tricky process, as described in detail at the\n-         * top of infer.rs*/\n+         * top of infer.rs.\n+         */\n+\n+        let tcx = self.infcx.tcx;\n+        let table = UnifyKey::unification_table(self.infcx);\n \n         // Need to make sub_id a subtype of sup_id.\n-        let node_a = self.infcx.get(a_id);\n-        let node_b = self.infcx.get(b_id);\n-        let a_id = node_a.root.clone();\n-        let b_id = node_b.root.clone();\n-        let a_bounds = node_a.possible_types.clone();\n-        let b_bounds = node_b.possible_types.clone();\n+        let node_a = table.borrow_mut().get(tcx, a_id);\n+        let node_b = table.borrow_mut().get(tcx, b_id);\n+        let a_id = node_a.key.clone();\n+        let b_id = node_b.key.clone();\n+        let a_bounds = node_a.value.clone();\n+        let b_bounds = node_b.value.clone();\n \n         debug!(\"vars({}={} <: {}={})\",\n-               a_id.to_str(), a_bounds.inf_str(self.infcx),\n-               b_id.to_str(), b_bounds.inf_str(self.infcx));\n+               a_id, a_bounds.repr(tcx),\n+               b_id, b_bounds.repr(tcx));\n \n-        if a_id == b_id { return uok(); }\n+        if a_id == b_id { return Ok(()); }\n \n         // If both A's UB and B's LB have already been bound to types,\n         // see if we can make those types subtypes.\n@@ -157,104 +156,81 @@ impl<'f> CombineFieldsLatticeMethods for CombineFields<'f> {\n         // A remains a subtype of B.  Actually, there are other options,\n         // but that's the route we choose to take.\n \n-        let (new_root, new_rank) = self.infcx.unify(&node_a, &node_b);\n+        let (new_root, new_rank) =\n+            table.borrow_mut().unify(tcx, &node_a, &node_b);\n         self.set_var_to_merged_bounds(new_root,\n                                       &a_bounds, &b_bounds,\n                                       new_rank)\n     }\n \n     /// make variable a subtype of T\n-    fn var_sub_t<T:Clone + InferStr + LatticeValue,\n-                 V:Clone + PartialEq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n-                 &self,\n-                 a_id: V,\n+    fn var_sub_t(&self,\n+                 a_id: K,\n                  b: T)\n-                 -> ures {\n+                 -> ures\n+    {\n         /*!\n-         *\n-         * Make a variable (`a_id`) a subtype of the concrete type `b` */\n-\n-        let node_a = self.infcx.get(a_id);\n-        let a_id = node_a.root.clone();\n-        let a_bounds = &node_a.possible_types;\n+         * Make a variable (`a_id`) a subtype of the concrete type `b`.\n+         */\n+\n+        let tcx = self.infcx.tcx;\n+        let table = UnifyKey::unification_table(self.infcx);\n+        let node_a = table.borrow_mut().get(tcx, a_id);\n+        let a_id = node_a.key.clone();\n+        let a_bounds = &node_a.value;\n         let b_bounds = &Bounds { lb: None, ub: Some(b.clone()) };\n \n         debug!(\"var_sub_t({}={} <: {})\",\n-               a_id.to_str(),\n-               a_bounds.inf_str(self.infcx),\n-               b.inf_str(self.infcx));\n+               a_id,\n+               a_bounds.repr(self.infcx.tcx),\n+               b.repr(self.infcx.tcx));\n \n         self.set_var_to_merged_bounds(\n             a_id, a_bounds, b_bounds, node_a.rank)\n     }\n \n-    fn t_sub_var<T:Clone + InferStr + LatticeValue,\n-                 V:Clone + PartialEq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n-                 &self,\n+    fn t_sub_var(&self,\n                  a: T,\n-                 b_id: V)\n-                 -> ures {\n+                 b_id: K)\n+                 -> ures\n+    {\n         /*!\n-         *\n-         * Make a concrete type (`a`) a subtype of the variable `b_id` */\n+         * Make a concrete type (`a`) a subtype of the variable `b_id`\n+         */\n \n+        let tcx = self.infcx.tcx;\n+        let table = UnifyKey::unification_table(self.infcx);\n         let a_bounds = &Bounds { lb: Some(a.clone()), ub: None };\n-        let node_b = self.infcx.get(b_id);\n-        let b_id = node_b.root.clone();\n-        let b_bounds = &node_b.possible_types;\n+        let node_b = table.borrow_mut().get(tcx, b_id);\n+        let b_id = node_b.key.clone();\n+        let b_bounds = &node_b.value;\n \n         debug!(\"t_sub_var({} <: {}={})\",\n-               a.inf_str(self.infcx),\n-               b_id.to_str(),\n-               b_bounds.inf_str(self.infcx));\n+               a.repr(self.infcx.tcx),\n+               b_id,\n+               b_bounds.repr(self.infcx.tcx));\n \n         self.set_var_to_merged_bounds(\n             b_id, a_bounds, b_bounds, node_b.rank)\n     }\n \n-    fn merge_bnd<T:Clone + InferStr + LatticeValue>(\n-                 &self,\n-                 a: &Bound<T>,\n-                 b: &Bound<T>,\n-                 lattice_op: LatticeOp<T>)\n-                 -> cres<Bound<T>> {\n-        /*!\n-         *\n-         * Combines two bounds into a more general bound. */\n-\n-        debug!(\"merge_bnd({},{})\",\n-               a.inf_str(self.infcx),\n-               b.inf_str(self.infcx));\n-        let _r = indenter();\n-\n-        match (a, b) {\n-            (&None,          &None) => Ok(None),\n-            (&Some(_),       &None) => Ok((*a).clone()),\n-            (&None,          &Some(_)) => Ok((*b).clone()),\n-            (&Some(ref v_a), &Some(ref v_b)) => {\n-                lattice_op(self.clone(), v_a, v_b).and_then(|v| Ok(Some(v)))\n-            }\n-        }\n-    }\n-\n-    fn set_var_to_merged_bounds<T:Clone + InferStr + LatticeValue,\n-                                V:Clone+PartialEq+ToStr+Vid+UnifyVid<Bounds<T>>>(\n-                                &self,\n-                                v_id: V,\n+    fn set_var_to_merged_bounds(&self,\n+                                v_id: K,\n                                 a: &Bounds<T>,\n                                 b: &Bounds<T>,\n                                 rank: uint)\n-                                -> ures {\n+                                -> ures\n+    {\n         /*!\n-         *\n          * Updates the bounds for the variable `v_id` to be the intersection\n          * of `a` and `b`.  That is, the new bounds for `v_id` will be\n          * a bounds c such that:\n          *    c.ub <: a.ub\n          *    c.ub <: b.ub\n          *    a.lb <: c.lb\n          *    b.lb <: c.lb\n-         * If this cannot be achieved, the result is failure. */\n+         * If this cannot be achieved, the result is failure.\n+         */\n \n         // Think of the two diamonds, we want to find the\n         // intersection.  There are basically four possibilities (you\n@@ -271,11 +247,13 @@ impl<'f> CombineFieldsLatticeMethods for CombineFields<'f> {\n         //       A     \\ / A\n         //              B\n \n+        let tcx = self.infcx.tcx;\n+        let table = UnifyKey::unification_table(self.infcx);\n+\n         debug!(\"merge({},{},{})\",\n-               v_id.to_str(),\n-               a.inf_str(self.infcx),\n-               b.inf_str(self.infcx));\n-        let _indent = indenter();\n+               v_id,\n+               a.repr(self.infcx.tcx),\n+               b.repr(self.infcx.tcx));\n \n         // First, relate the lower/upper bounds of A and B.\n         // Note that these relations *must* hold for us\n@@ -289,29 +267,57 @@ impl<'f> CombineFieldsLatticeMethods for CombineFields<'f> {\n         let lb = if_ok!(self.merge_bnd(&a.lb, &b.lb, LatticeValue::lub));\n         let bounds = Bounds { lb: lb, ub: ub };\n         debug!(\"merge({}): bounds={}\",\n-               v_id.to_str(),\n-               bounds.inf_str(self.infcx));\n+               v_id,\n+               bounds.repr(self.infcx.tcx));\n \n         // the new bounds must themselves\n         // be relatable:\n         let () = if_ok!(self.bnds(&bounds.lb, &bounds.ub));\n-        self.infcx.set(v_id, Root(bounds, rank));\n-        uok()\n+        table.borrow_mut().set(tcx, v_id, Root(bounds, rank));\n+        Ok(())\n     }\n+}\n \n-    fn bnds<T:Clone + InferStr + LatticeValue>(&self,\n-                                               a: &Bound<T>,\n-                                               b: &Bound<T>)\n-                                               -> ures {\n-        debug!(\"bnds({} <: {})\", a.inf_str(self.infcx),\n-               b.inf_str(self.infcx));\n-        let _r = indenter();\n+impl<'f,T:LatticeValue>\n+    CombineFieldsLatticeMethods2<T> for CombineFields<'f>\n+{\n+    fn merge_bnd(&self,\n+                 a: &Bound<T>,\n+                 b: &Bound<T>,\n+                 lattice_op: LatticeOp<T>)\n+                 -> cres<Bound<T>>\n+    {\n+        /*!\n+         * Combines two bounds into a more general bound.\n+         */\n+\n+        debug!(\"merge_bnd({},{})\",\n+               a.repr(self.infcx.tcx),\n+               b.repr(self.infcx.tcx));\n+        match (a, b) {\n+            (&None,          &None) => Ok(None),\n+            (&Some(_),       &None) => Ok((*a).clone()),\n+            (&None,          &Some(_)) => Ok((*b).clone()),\n+            (&Some(ref v_a), &Some(ref v_b)) => {\n+                lattice_op(self.clone(), v_a, v_b).and_then(|v| Ok(Some(v)))\n+            }\n+        }\n+    }\n+\n+    fn bnds(&self,\n+            a: &Bound<T>,\n+            b: &Bound<T>)\n+            -> ures\n+    {\n+        debug!(\"bnds({} <: {})\",\n+               a.repr(self.infcx.tcx),\n+               b.repr(self.infcx.tcx));\n \n         match (a, b) {\n             (&None, &None) |\n             (&Some(_), &None) |\n             (&None, &Some(_)) => {\n-                uok()\n+                Ok(())\n             }\n             (&Some(ref t_a), &Some(ref t_b)) => {\n                 LatticeValue::sub(self.clone(), t_a, t_b)\n@@ -368,9 +374,10 @@ pub fn super_lattice_tys<L:LatticeDir+TyLatticeDir+Combine>(this: &L,\n                                                             a: ty::t,\n                                                             b: ty::t)\n                                                             -> cres<ty::t> {\n-    debug!(\"{}.lattice_tys({}, {})\", this.tag(),\n-           a.inf_str(this.infcx()),\n-           b.inf_str(this.infcx()));\n+    debug!(\"{}.lattice_tys({}, {})\",\n+           this.tag(),\n+           a.repr(this.infcx().tcx),\n+           b.repr(this.infcx().tcx));\n \n     if a == b {\n         return Ok(a);\n@@ -410,8 +417,8 @@ pub fn super_lattice_tys<L:LatticeDir+TyLatticeDir+Combine>(this: &L,\n pub type LatticeDirOp<'a, T> = |a: &T, b: &T|: 'a -> cres<T>;\n \n #[deriving(Clone)]\n-pub enum LatticeVarResult<V,T> {\n-    VarResult(V),\n+pub enum LatticeVarResult<K,T> {\n+    VarResult(K),\n     ValueResult(T)\n }\n \n@@ -429,26 +436,31 @@ pub enum LatticeVarResult<V,T> {\n  * - If the variables do not both have an upper bound, we will unify\n  *   the variables and return the unified variable, in which case the\n  *   result is a variable.  This is indicated with a `VarResult`\n- *   return. */\n-pub fn lattice_vars<L:LatticeDir + Combine,\n-                    T:Clone + InferStr + LatticeValue,\n-                    V:Clone + PartialEq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n+ *   return.\n+ */\n+pub fn lattice_vars<L:LatticeDir+Combine,\n+                    T:LatticeValue,\n+                    K:UnifyKey<Bounds<T>>>(\n     this: &L,                           // defines whether we want LUB or GLB\n-    a_vid: V,                          // first variable\n-    b_vid: V,                          // second variable\n+    a_vid: K,                           // first variable\n+    b_vid: K,                           // second variable\n     lattice_dir_op: LatticeDirOp<T>)    // LUB or GLB operation on types\n-    -> cres<LatticeVarResult<V,T>> {\n-    let nde_a = this.infcx().get(a_vid);\n-    let nde_b = this.infcx().get(b_vid);\n-    let a_vid = nde_a.root.clone();\n-    let b_vid = nde_b.root.clone();\n-    let a_bounds = &nde_a.possible_types;\n-    let b_bounds = &nde_b.possible_types;\n+    -> cres<LatticeVarResult<K,T>>\n+{\n+    let tcx = this.infcx().tcx;\n+    let table = UnifyKey::unification_table(this.infcx());\n+\n+    let node_a = table.borrow_mut().get(tcx, a_vid);\n+    let node_b = table.borrow_mut().get(tcx, b_vid);\n+    let a_vid = node_a.key.clone();\n+    let b_vid = node_b.key.clone();\n+    let a_bounds = &node_a.value;\n+    let b_bounds = &node_b.value;\n \n     debug!(\"{}.lattice_vars({}={} <: {}={})\",\n            this.tag(),\n-           a_vid.to_str(), a_bounds.inf_str(this.infcx()),\n-           b_vid.to_str(), b_bounds.inf_str(this.infcx()));\n+           a_vid, a_bounds.repr(tcx),\n+           b_vid, b_bounds.repr(tcx));\n \n     // Same variable: the easy case.\n     if a_vid == b_vid {\n@@ -471,48 +483,52 @@ pub fn lattice_vars<L:LatticeDir + Combine,\n     // Otherwise, we need to merge A and B into one variable.  We can\n     // then use either variable as an upper bound:\n     let cf = this.combine_fields();\n-    cf.var_sub_var(a_vid.clone(), b_vid.clone()).then(|| {\n-        Ok(VarResult(a_vid.clone()))\n-    })\n+    let () = try!(cf.var_sub_var(a_vid.clone(), b_vid.clone()));\n+    Ok(VarResult(a_vid.clone()))\n }\n \n-pub fn lattice_var_and_t<L:LatticeDir + Combine,\n-                         T:Clone + InferStr + LatticeValue,\n-                         V:Clone + PartialEq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n+pub fn lattice_var_and_t<L:LatticeDir+Combine,\n+                         T:LatticeValue,\n+                         K:UnifyKey<Bounds<T>>>(\n     this: &L,\n-    a_id: V,\n+    a_id: K,\n     b: &T,\n     lattice_dir_op: LatticeDirOp<T>)\n-    -> cres<T> {\n-    let nde_a = this.infcx().get(a_id);\n-    let a_id = nde_a.root.clone();\n-    let a_bounds = &nde_a.possible_types;\n+    -> cres<T>\n+{\n+    let tcx = this.infcx().tcx;\n+    let table = UnifyKey::unification_table(this.infcx());\n+\n+    let node_a = table.borrow_mut().get(tcx, a_id);\n+    let a_id = node_a.key.clone();\n+    let a_bounds = &node_a.value;\n \n     // The comments in this function are written for LUB, but they\n     // apply equally well to GLB if you inverse upper/lower/sub/super/etc.\n \n     debug!(\"{}.lattice_var_and_t({}={} <: {})\",\n            this.tag(),\n-           a_id.to_str(),\n-           a_bounds.inf_str(this.infcx()),\n-           b.inf_str(this.infcx()));\n+           a_id,\n+           a_bounds.repr(this.infcx().tcx),\n+           b.repr(this.infcx().tcx));\n \n     match this.bnd(a_bounds) {\n         Some(ref a_bnd) => {\n             // If a has an upper bound, return the LUB(a.ub, b)\n-            debug!(\"bnd=Some({})\", a_bnd.inf_str(this.infcx()));\n+            debug!(\"bnd=Some({})\", a_bnd.repr(this.infcx().tcx));\n             lattice_dir_op(a_bnd, b)\n         }\n         None => {\n             // If a does not have an upper bound, make b the upper bound of a\n             // and then return b.\n             debug!(\"bnd=None\");\n             let a_bounds = this.with_bnd(a_bounds, (*b).clone());\n-            this.combine_fields().bnds(&a_bounds.lb, &a_bounds.ub).then(|| {\n-                this.infcx().set(a_id.clone(),\n-                                 Root(a_bounds.clone(), nde_a.rank));\n-                Ok((*b).clone())\n-            })\n+            let () = try!(this.combine_fields().bnds(&a_bounds.lb,\n+                                                     &a_bounds.ub));\n+            table.borrow_mut().set(tcx,\n+                                   a_id.clone(),\n+                                   Root(a_bounds.clone(), node_a.rank));\n+            Ok((*b).clone())\n         }\n     }\n }"}, {"sha": "7ccffdfeb062fc1ffa4ba2d735784ba41798c354", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/020373f2c807627274a53251a7841f0e9617e98e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/020373f2c807627274a53251a7841f0e9617e98e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=020373f2c807627274a53251a7841f0e9617e98e", "patch": "@@ -16,16 +16,17 @@ use middle::typeck::infer::combine::*;\n use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::lattice::*;\n use middle::typeck::infer::sub::Sub;\n-use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::{cres, InferCtxt};\n use middle::typeck::infer::fold_regions_in_sig;\n use middle::typeck::infer::{TypeTrace, Subtype};\n+use middle::typeck::infer::region_inference::RegionMark;\n use std::collections::HashMap;\n use syntax::ast::{Many, Once, NodeId};\n use syntax::ast::{NormalFn, UnsafeFn};\n use syntax::ast::{Onceness, FnStyle};\n use syntax::ast::{MutMutable, MutImmutable};\n use util::ppaux::mt_to_str;\n+use util::ppaux::Repr;\n \n pub struct Lub<'f>(pub CombineFields<'f>);  // least-upper-bound: common supertype\n \n@@ -101,10 +102,10 @@ impl<'f> Combine for Lub<'f> {\n     }\n \n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n-        debug!(\"{}.regions({:?}, {:?})\",\n+        debug!(\"{}.regions({}, {})\",\n                self.tag(),\n-               a.inf_str(self.get_ref().infcx),\n-               b.inf_str(self.get_ref().infcx));\n+               a.repr(self.get_ref().infcx.tcx),\n+               b.repr(self.get_ref().infcx.tcx));\n \n         Ok(self.get_ref().infcx.region_vars.lub_regions(Subtype(self.trace()), a, b))\n     }\n@@ -113,11 +114,9 @@ impl<'f> Combine for Lub<'f> {\n         // Note: this is a subtle algorithm.  For a full explanation,\n         // please see the large comment in `region_inference.rs`.\n \n-        // Take a snapshot.  We'll never roll this back, but in later\n-        // phases we do want to be able to examine \"all bindings that\n-        // were created as part of this type comparison\", and making a\n-        // snapshot is a convenient way to do that.\n-        let snapshot = self.get_ref().infcx.region_vars.start_snapshot();\n+        // Make a mark so we can examine \"all bindings that were\n+        // created as part of this type comparison\".\n+        let mark = self.get_ref().infcx.region_vars.mark();\n \n         // Instantiate each bound region with a fresh region variable.\n         let (a_with_fresh, a_map) =\n@@ -129,21 +128,21 @@ impl<'f> Combine for Lub<'f> {\n \n         // Collect constraints.\n         let sig0 = if_ok!(super_fn_sigs(self, &a_with_fresh, &b_with_fresh));\n-        debug!(\"sig0 = {}\", sig0.inf_str(self.get_ref().infcx));\n+        debug!(\"sig0 = {}\", sig0.repr(self.get_ref().infcx.tcx));\n \n         // Generalize the regions appearing in sig0 if possible\n         let new_vars =\n-            self.get_ref().infcx.region_vars.vars_created_since_snapshot(snapshot);\n+            self.get_ref().infcx.region_vars.vars_created_since_mark(mark);\n         let sig1 =\n             fold_regions_in_sig(\n                 self.get_ref().infcx.tcx,\n                 &sig0,\n-                |r| generalize_region(self, snapshot, new_vars.as_slice(),\n+                |r| generalize_region(self, mark, new_vars.as_slice(),\n                                       sig0.binder_id, &a_map, r));\n         return Ok(sig1);\n \n         fn generalize_region(this: &Lub,\n-                             snapshot: uint,\n+                             mark: RegionMark,\n                              new_vars: &[RegionVid],\n                              new_scope: NodeId,\n                              a_map: &HashMap<ty::BoundRegion, ty::Region>,\n@@ -156,7 +155,7 @@ impl<'f> Combine for Lub<'f> {\n                 return r0;\n             }\n \n-            let tainted = this.get_ref().infcx.region_vars.tainted(snapshot, r0);\n+            let tainted = this.get_ref().infcx.region_vars.tainted(mark, r0);\n \n             // Variables created during LUB computation which are\n             // *related* to regions that pre-date the LUB computation"}, {"sha": "bb458d27d17ac5688230b6046192b6ad91ded9a2", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 136, "deletions": 145, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/020373f2c807627274a53251a7841f0e9617e98e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/020373f2c807627274a53251a7841f0e9617e98e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=020373f2c807627274a53251a7841f0e9617e98e", "patch": "@@ -23,21 +23,21 @@ pub use middle::typeck::infer::resolve::{resolve_rvar};\n \n use middle::subst;\n use middle::subst::Substs;\n-use middle::ty::{TyVid, IntVid, FloatVid, RegionVid, Vid};\n+use middle::ty::{TyVid, IntVid, FloatVid, RegionVid};\n use middle::ty;\n use middle::ty_fold;\n use middle::ty_fold::TypeFolder;\n use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n use middle::typeck::infer::coercion::Coerce;\n use middle::typeck::infer::combine::{Combine, CombineFields, eq_tys};\n-use middle::typeck::infer::region_inference::{RegionVarBindings};\n+use middle::typeck::infer::region_inference::{RegionVarBindings,\n+                                              RegionSnapshot};\n use middle::typeck::infer::resolve::{resolver};\n use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::lub::Lub;\n-use middle::typeck::infer::to_str::InferStr;\n-use middle::typeck::infer::unify::{ValsAndBindings, Root};\n+use middle::typeck::infer::unify::{UnificationTable, Snapshot};\n use middle::typeck::infer::error_reporting::ErrorReporting;\n-use std::cell::{Cell, RefCell};\n+use std::cell::{RefCell};\n use std::collections::HashMap;\n use std::rc::Rc;\n use syntax::ast;\n@@ -55,17 +55,17 @@ pub mod lub;\n pub mod region_inference;\n pub mod resolve;\n pub mod sub;\n-pub mod to_str;\n pub mod unify;\n pub mod coercion;\n pub mod error_reporting;\n+pub mod test;\n \n pub type Bound<T> = Option<T>;\n \n-#[deriving(Clone)]\n+#[deriving(PartialEq,Clone)]\n pub struct Bounds<T> {\n-    lb: Bound<T>,\n-    ub: Bound<T>\n+    pub lb: Bound<T>,\n+    pub ub: Bound<T>\n }\n \n pub type cres<T> = Result<T,ty::type_err>; // \"combine result\"\n@@ -76,24 +76,23 @@ pub type CoerceResult = cres<Option<ty::AutoAdjustment>>;\n pub struct InferCtxt<'a> {\n     pub tcx: &'a ty::ctxt,\n \n-    // We instantiate ValsAndBindings with bounds<ty::t> because the\n+    // We instantiate UnificationTable with bounds<ty::t> because the\n     // types that might instantiate a general type variable have an\n     // order, represented by its upper and lower bounds.\n-    pub ty_var_bindings: RefCell<ValsAndBindings<ty::TyVid, Bounds<ty::t>>>,\n-    pub ty_var_counter: Cell<uint>,\n+    type_unification_table:\n+        RefCell<UnificationTable<ty::TyVid, Bounds<ty::t>>>,\n \n     // Map from integral variable to the kind of integer it represents\n-    pub int_var_bindings: RefCell<ValsAndBindings<ty::IntVid,\n-                                              Option<IntVarValue>>>,\n-    pub int_var_counter: Cell<uint>,\n+    int_unification_table:\n+        RefCell<UnificationTable<ty::IntVid, Option<IntVarValue>>>,\n \n     // Map from floating variable to the kind of float it represents\n-    pub float_var_bindings: RefCell<ValsAndBindings<ty::FloatVid,\n-                                                Option<ast::FloatTy>>>,\n-    pub float_var_counter: Cell<uint>,\n+    float_unification_table:\n+        RefCell<UnificationTable<ty::FloatVid, Option<ast::FloatTy>>>,\n \n     // For region variables.\n-    pub region_vars: RegionVarBindings<'a>,\n+    region_vars:\n+        RegionVarBindings<'a>,\n }\n \n /// Why did we require that the two types be related?\n@@ -261,16 +260,9 @@ pub fn fixup_err_to_str(f: fixup_err) -> String {\n pub fn new_infer_ctxt<'a>(tcx: &'a ty::ctxt) -> InferCtxt<'a> {\n     InferCtxt {\n         tcx: tcx,\n-\n-        ty_var_bindings: RefCell::new(ValsAndBindings::new()),\n-        ty_var_counter: Cell::new(0),\n-\n-        int_var_bindings: RefCell::new(ValsAndBindings::new()),\n-        int_var_counter: Cell::new(0),\n-\n-        float_var_bindings: RefCell::new(ValsAndBindings::new()),\n-        float_var_counter: Cell::new(0),\n-\n+        type_unification_table: RefCell::new(UnificationTable::new()),\n+        int_unification_table: RefCell::new(UnificationTable::new()),\n+        float_unification_table: RefCell::new(UnificationTable::new()),\n         region_vars: RegionVarBindings::new(tcx),\n     }\n }\n@@ -280,20 +272,23 @@ pub fn common_supertype(cx: &InferCtxt,\n                         a_is_expected: bool,\n                         a: ty::t,\n                         b: ty::t)\n-                        -> ty::t {\n+                        -> ty::t\n+{\n     /*!\n      * Computes the least upper-bound of `a` and `b`. If this is\n      * not possible, reports an error and returns ty::err.\n      */\n \n-    debug!(\"common_supertype({}, {})\", a.inf_str(cx), b.inf_str(cx));\n+    debug!(\"common_supertype({}, {})\",\n+           a.repr(cx.tcx), b.repr(cx.tcx));\n \n     let trace = TypeTrace {\n         origin: origin,\n         values: Types(expected_found(a_is_expected, a, b))\n     };\n \n-    let result = cx.commit(|| cx.lub(a_is_expected, trace.clone()).tys(a, b));\n+    let result =\n+        cx.commit_if_ok(|| cx.lub(a_is_expected, trace.clone()).tys(a, b));\n     match result {\n         Ok(t) => t,\n         Err(ref err) => {\n@@ -309,9 +304,9 @@ pub fn mk_subty(cx: &InferCtxt,\n                 a: ty::t,\n                 b: ty::t)\n              -> ures {\n-    debug!(\"mk_subty({} <: {})\", a.inf_str(cx), b.inf_str(cx));\n+    debug!(\"mk_subty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n     indent(|| {\n-        cx.commit(|| {\n+        cx.commit_if_ok(|| {\n             let trace = TypeTrace {\n                 origin: origin,\n                 values: Types(expected_found(a_is_expected, a, b))\n@@ -322,15 +317,13 @@ pub fn mk_subty(cx: &InferCtxt,\n }\n \n pub fn can_mk_subty(cx: &InferCtxt, a: ty::t, b: ty::t) -> ures {\n-    debug!(\"can_mk_subty({} <: {})\", a.inf_str(cx), b.inf_str(cx));\n-    indent(|| {\n-        cx.probe(|| {\n-            let trace = TypeTrace {\n-                origin: Misc(codemap::DUMMY_SP),\n-                values: Types(expected_found(true, a, b))\n-            };\n-            cx.sub(true, trace).tys(a, b)\n-        })\n+    debug!(\"can_mk_subty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n+    cx.probe(|| {\n+        let trace = TypeTrace {\n+            origin: Misc(codemap::DUMMY_SP),\n+            values: Types(expected_found(true, a, b))\n+        };\n+        cx.sub(true, trace).tys(a, b)\n     }).to_ures()\n }\n \n@@ -339,29 +332,28 @@ pub fn mk_subr(cx: &InferCtxt,\n                origin: SubregionOrigin,\n                a: ty::Region,\n                b: ty::Region) {\n-    debug!(\"mk_subr({} <: {})\", a.inf_str(cx), b.inf_str(cx));\n-    cx.region_vars.start_snapshot();\n+    debug!(\"mk_subr({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n+    let snapshot = cx.region_vars.start_snapshot();\n     cx.region_vars.make_subregion(origin, a, b);\n-    cx.region_vars.commit();\n+    cx.region_vars.commit(snapshot);\n }\n \n pub fn mk_eqty(cx: &InferCtxt,\n                a_is_expected: bool,\n                origin: TypeOrigin,\n                a: ty::t,\n                b: ty::t)\n-            -> ures {\n-    debug!(\"mk_eqty({} <: {})\", a.inf_str(cx), b.inf_str(cx));\n-    indent(|| {\n-        cx.commit(|| {\n-            let trace = TypeTrace {\n-                origin: origin,\n-                values: Types(expected_found(a_is_expected, a, b))\n-            };\n-            let suber = cx.sub(a_is_expected, trace);\n-            eq_tys(&suber, a, b)\n-        })\n-    }).to_ures()\n+            -> ures\n+{\n+    debug!(\"mk_eqty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n+    cx.commit_if_ok(|| {\n+        let trace = TypeTrace {\n+            origin: origin,\n+            values: Types(expected_found(a_is_expected, a, b))\n+        };\n+        let suber = cx.sub(a_is_expected, trace);\n+        eq_tys(&suber, a, b)\n+    })\n }\n \n pub fn mk_sub_trait_refs(cx: &InferCtxt,\n@@ -372,9 +364,9 @@ pub fn mk_sub_trait_refs(cx: &InferCtxt,\n     -> ures\n {\n     debug!(\"mk_sub_trait_refs({} <: {})\",\n-           a.inf_str(cx), b.inf_str(cx));\n+           a.repr(cx.tcx), b.repr(cx.tcx));\n     indent(|| {\n-        cx.commit(|| {\n+        cx.commit_if_ok(|| {\n             let trace = TypeTrace {\n                 origin: origin,\n                 values: TraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n@@ -401,9 +393,9 @@ pub fn mk_coercety(cx: &InferCtxt,\n                    a: ty::t,\n                    b: ty::t)\n                 -> CoerceResult {\n-    debug!(\"mk_coercety({} -> {})\", a.inf_str(cx), b.inf_str(cx));\n+    debug!(\"mk_coercety({} -> {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n     indent(|| {\n-        cx.commit(|| {\n+        cx.commit_if_ok(|| {\n             let trace = TypeTrace {\n                 origin: origin,\n                 values: Types(expected_found(a_is_expected, a, b))\n@@ -417,13 +409,15 @@ pub fn mk_coercety(cx: &InferCtxt,\n pub fn resolve_type(cx: &InferCtxt,\n                     a: ty::t,\n                     modes: uint)\n-                 -> fres<ty::t> {\n+                 -> fres<ty::t>\n+{\n     let mut resolver = resolver(cx, modes);\n-    resolver.resolve_type_chk(a)\n+    cx.commit_unconditionally(|| resolver.resolve_type_chk(a))\n }\n \n pub fn resolve_region(cx: &InferCtxt, r: ty::Region, modes: uint)\n-                   -> fres<ty::Region> {\n+                   -> fres<ty::Region>\n+{\n     let mut resolver = resolver(cx, modes);\n     resolver.resolve_region_chk(r)\n }\n@@ -473,19 +467,11 @@ pub fn uok() -> ures {\n     Ok(())\n }\n \n-fn rollback_to<V:Clone + Vid,T:Clone>(vb: &mut ValsAndBindings<V, T>,\n-                                      len: uint) {\n-    while vb.bindings.len() != len {\n-        let (vid, old_v) = vb.bindings.pop().unwrap();\n-        vb.vals.insert(vid.to_uint(), old_v);\n-    }\n-}\n-\n-pub struct Snapshot {\n-    ty_var_bindings_len: uint,\n-    int_var_bindings_len: uint,\n-    float_var_bindings_len: uint,\n-    region_vars_snapshot: uint,\n+pub struct CombinedSnapshot {\n+    type_snapshot: Snapshot<ty::TyVid>,\n+    int_snapshot: Snapshot<ty::IntVid>,\n+    float_snapshot: Snapshot<ty::FloatVid>,\n+    region_vars_snapshot: RegionSnapshot,\n }\n \n impl<'a> InferCtxt<'a> {\n@@ -508,52 +494,81 @@ impl<'a> InferCtxt<'a> {\n         self.region_vars.in_snapshot()\n     }\n \n-    pub fn start_snapshot(&self) -> Snapshot {\n-        Snapshot {\n-            ty_var_bindings_len: self.ty_var_bindings.borrow().bindings.len(),\n-            int_var_bindings_len: self.int_var_bindings.borrow().bindings.len(),\n-            float_var_bindings_len: self.float_var_bindings.borrow().bindings.len(),\n+    fn start_snapshot(&self) -> CombinedSnapshot {\n+        CombinedSnapshot {\n+            type_snapshot: self.type_unification_table.borrow_mut().snapshot(),\n+            int_snapshot: self.int_unification_table.borrow_mut().snapshot(),\n+            float_snapshot: self.float_unification_table.borrow_mut().snapshot(),\n             region_vars_snapshot: self.region_vars.start_snapshot(),\n         }\n     }\n \n-    pub fn rollback_to(&self, snapshot: &Snapshot) {\n+    fn rollback_to(&self, snapshot: CombinedSnapshot) {\n         debug!(\"rollback!\");\n-        rollback_to(&mut *self.ty_var_bindings.borrow_mut(),\n-                    snapshot.ty_var_bindings_len);\n-        rollback_to(&mut *self.int_var_bindings.borrow_mut(),\n-                    snapshot.int_var_bindings_len);\n-        rollback_to(&mut *self.float_var_bindings.borrow_mut(),\n-                    snapshot.float_var_bindings_len);\n-\n-        self.region_vars.rollback_to(snapshot.region_vars_snapshot);\n+        let CombinedSnapshot { type_snapshot,\n+                               int_snapshot,\n+                               float_snapshot,\n+                               region_vars_snapshot } = snapshot;\n+\n+        self.type_unification_table\n+            .borrow_mut()\n+            .rollback_to(self.tcx, type_snapshot);\n+        self.int_unification_table\n+            .borrow_mut()\n+            .rollback_to(self.tcx, int_snapshot);\n+        self.float_unification_table\n+            .borrow_mut()\n+            .rollback_to(self.tcx, float_snapshot);\n+        self.region_vars\n+            .rollback_to(region_vars_snapshot);\n+    }\n+\n+    fn commit_from(&self, snapshot: CombinedSnapshot) {\n+        debug!(\"commit_from!\");\n+        let CombinedSnapshot { type_snapshot,\n+                               int_snapshot,\n+                               float_snapshot,\n+                               region_vars_snapshot } = snapshot;\n+\n+        self.type_unification_table\n+            .borrow_mut()\n+            .commit(type_snapshot);\n+        self.int_unification_table\n+            .borrow_mut()\n+            .commit(int_snapshot);\n+        self.float_unification_table\n+            .borrow_mut()\n+            .commit(float_snapshot);\n+        self.region_vars\n+            .commit(region_vars_snapshot);\n+    }\n+\n+    /// Execute `f` and commit the bindings\n+    pub fn commit_unconditionally<R>(&self, f: || -> R) -> R {\n+        debug!(\"commit()\");\n+        let snapshot = self.start_snapshot();\n+        let r = f();\n+        self.commit_from(snapshot);\n+        r\n     }\n \n     /// Execute `f` and commit the bindings if successful\n-    pub fn commit<T,E>(&self, f: || -> Result<T,E>) -> Result<T,E> {\n-        assert!(!self.in_snapshot());\n-\n-        debug!(\"commit()\");\n-        indent(|| {\n-            let r = self.try(|| f());\n-\n-            self.ty_var_bindings.borrow_mut().bindings.truncate(0);\n-            self.int_var_bindings.borrow_mut().bindings.truncate(0);\n-            self.region_vars.commit();\n-            r\n-        })\n+    pub fn commit_if_ok<T,E>(&self, f: || -> Result<T,E>) -> Result<T,E> {\n+        self.commit_unconditionally(|| self.try(|| f()))\n     }\n \n     /// Execute `f`, unroll bindings on failure\n     pub fn try<T,E>(&self, f: || -> Result<T,E>) -> Result<T,E> {\n         debug!(\"try()\");\n         let snapshot = self.start_snapshot();\n         let r = f();\n+        debug!(\"try() -- r.is_ok() = {}\", r.is_ok());\n         match r {\n-            Ok(_) => { debug!(\"success\"); }\n-            Err(ref e) => {\n-                debug!(\"error: {:?}\", *e);\n-                self.rollback_to(&snapshot)\n+            Ok(_) => {\n+                self.commit_from(snapshot);\n+            }\n+            Err(_) => {\n+                self.rollback_to(snapshot);\n             }\n         }\n         r\n@@ -562,36 +577,18 @@ impl<'a> InferCtxt<'a> {\n     /// Execute `f` then unroll any bindings it creates\n     pub fn probe<T,E>(&self, f: || -> Result<T,E>) -> Result<T,E> {\n         debug!(\"probe()\");\n-        indent(|| {\n-            let snapshot = self.start_snapshot();\n-            let r = f();\n-            self.rollback_to(&snapshot);\n-            r\n-        })\n+        let snapshot = self.start_snapshot();\n+        let r = f();\n+        self.rollback_to(snapshot);\n+        r\n     }\n }\n \n-fn next_simple_var<V:Clone,T:Clone>(counter: &mut uint,\n-                                    bindings: &mut ValsAndBindings<V,\n-                                                                   Option<T>>)\n-                                    -> uint {\n-    let id = *counter;\n-    *counter += 1;\n-    bindings.vals.insert(id, Root(None, 0));\n-    return id;\n-}\n-\n impl<'a> InferCtxt<'a> {\n     pub fn next_ty_var_id(&self) -> TyVid {\n-        let id = self.ty_var_counter.get();\n-        self.ty_var_counter.set(id + 1);\n-        {\n-            let mut ty_var_bindings = self.ty_var_bindings.borrow_mut();\n-            let vals = &mut ty_var_bindings.vals;\n-            vals.insert(id, Root(Bounds { lb: None, ub: None }, 0u));\n-        }\n-        debug!(\"created type variable {}\", TyVid(id));\n-        return TyVid(id);\n+        self.type_unification_table\n+            .borrow_mut()\n+            .new_key(Bounds { lb: None, ub: None })\n     }\n \n     pub fn next_ty_var(&self) -> ty::t {\n@@ -603,21 +600,15 @@ impl<'a> InferCtxt<'a> {\n     }\n \n     pub fn next_int_var_id(&self) -> IntVid {\n-        let mut int_var_counter = self.int_var_counter.get();\n-        let mut int_var_bindings = self.int_var_bindings.borrow_mut();\n-        let result = IntVid(next_simple_var(&mut int_var_counter,\n-                                            &mut *int_var_bindings));\n-        self.int_var_counter.set(int_var_counter);\n-        result\n+        self.int_unification_table\n+            .borrow_mut()\n+            .new_key(None)\n     }\n \n     pub fn next_float_var_id(&self) -> FloatVid {\n-        let mut float_var_counter = self.float_var_counter.get();\n-        let mut float_var_bindings = self.float_var_bindings.borrow_mut();\n-        let result = FloatVid(next_simple_var(&mut float_var_counter,\n-                                              &mut *float_var_bindings));\n-        self.float_var_counter.set(float_var_counter);\n-        result\n+        self.float_unification_table\n+            .borrow_mut()\n+            .new_key(None)\n     }\n \n     pub fn next_region_var(&self, origin: RegionVariableOrigin) -> ty::Region {"}, {"sha": "c81d4b17d9ba226b3939506507adf2b76c7287c8", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 115, "deletions": 85, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/020373f2c807627274a53251a7841f0e9617e98e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/020373f2c807627274a53251a7841f0e9617e98e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=020373f2c807627274a53251a7841f0e9617e98e", "patch": "@@ -12,7 +12,7 @@\n \n \n use middle::ty;\n-use middle::ty::{BoundRegion, FreeRegion, Region, RegionVid, Vid};\n+use middle::ty::{BoundRegion, FreeRegion, Region, RegionVid};\n use middle::ty::{ReEmpty, ReStatic, ReInfer, ReFree, ReEarlyBound,\n                  ReLateBound};\n use middle::ty::{ReScope, ReVar, ReSkolemized, BrFresh};\n@@ -45,13 +45,17 @@ pub struct TwoRegions {\n     b: Region,\n }\n \n+#[deriving(PartialEq)]\n pub enum UndoLogEntry {\n-    Snapshot,\n+    OpenSnapshot,\n+    CommitedSnapshot,\n+    Mark,\n     AddVar(RegionVid),\n     AddConstraint(Constraint),\n     AddCombination(CombineMapType, TwoRegions)\n }\n \n+#[deriving(PartialEq)]\n pub enum CombineMapType {\n     Lub, Glb\n }\n@@ -131,16 +135,27 @@ pub struct RegionVarBindings<'a> {\n     // The undo log records actions that might later be undone.\n     //\n     // Note: when the undo_log is empty, we are not actively\n-    // snapshotting.  When the `start_snapshot()` method is called, we\n-    // push a Snapshot entry onto the list to indicate that we are now\n-    // actively snapshotting.  The reason for this is that otherwise\n-    // we end up adding entries for things like the lower bound on\n-    // a variable and so forth, which can never be rolled back.\n-    undo_log: RefCell<Vec<UndoLogEntry> >,\n+    // snapshotting. When the `start_snapshot()` method is called, we\n+    // push an OpenSnapshot entry onto the list to indicate that we\n+    // are now actively snapshotting. The reason for this is that\n+    // otherwise we end up adding entries for things like the lower\n+    // bound on a variable and so forth, which can never be rolled\n+    // back.\n+    undo_log: RefCell<Vec<UndoLogEntry>>,\n \n     // This contains the results of inference.  It begins as an empty\n     // option and only acquires a value after inference is complete.\n-    values: RefCell<Option<Vec<VarValue> >>,\n+    values: RefCell<Option<Vec<VarValue>>>,\n+}\n+\n+#[deriving(Show)]\n+pub struct RegionSnapshot {\n+    length: uint\n+}\n+\n+#[deriving(Show)]\n+pub struct RegionMark {\n+    length: uint\n }\n \n impl<'a> RegionVarBindings<'a> {\n@@ -162,48 +177,62 @@ impl<'a> RegionVarBindings<'a> {\n         self.undo_log.borrow().len() > 0\n     }\n \n-    pub fn start_snapshot(&self) -> uint {\n-        debug!(\"RegionVarBindings: start_snapshot()\");\n-        if self.in_snapshot() {\n-            self.undo_log.borrow().len()\n-        } else {\n-            self.undo_log.borrow_mut().push(Snapshot);\n-            0\n-        }\n+    pub fn start_snapshot(&self) -> RegionSnapshot {\n+        let length = self.undo_log.borrow().len();\n+        debug!(\"RegionVarBindings: start_snapshot({})\", length);\n+        self.undo_log.borrow_mut().push(OpenSnapshot);\n+        RegionSnapshot { length: length }\n+    }\n+\n+    pub fn mark(&self) -> RegionMark {\n+        let length = self.undo_log.borrow().len();\n+        debug!(\"RegionVarBindings: mark({})\", length);\n+        self.undo_log.borrow_mut().push(Mark);\n+        RegionMark { length: length }\n     }\n \n-    pub fn commit(&self) {\n+    pub fn commit(&self, snapshot: RegionSnapshot) {\n         debug!(\"RegionVarBindings: commit()\");\n+        assert!(self.undo_log.borrow().len() > snapshot.length);\n+        assert!(*self.undo_log.borrow().get(snapshot.length) == OpenSnapshot);\n+\n         let mut undo_log = self.undo_log.borrow_mut();\n-        while undo_log.len() > 0 {\n-            undo_log.pop().unwrap();\n+        if snapshot.length == 0 {\n+            undo_log.truncate(0);\n+        } else {\n+            *undo_log.get_mut(snapshot.length) = CommitedSnapshot;\n         }\n     }\n \n-    pub fn rollback_to(&self, snapshot: uint) {\n+    pub fn rollback_to(&self, snapshot: RegionSnapshot) {\n         debug!(\"RegionVarBindings: rollback_to({})\", snapshot);\n         let mut undo_log = self.undo_log.borrow_mut();\n-        while undo_log.len() > snapshot {\n-            let undo_item = undo_log.pop().unwrap();\n-            debug!(\"undo_item={:?}\", undo_item);\n-            match undo_item {\n-              Snapshot => {}\n-              AddVar(vid) => {\n-                let mut var_origins = self.var_origins.borrow_mut();\n-                assert_eq!(var_origins.len(), vid.to_uint() + 1);\n-                var_origins.pop().unwrap();\n-              }\n-              AddConstraint(ref constraint) => {\n-                self.constraints.borrow_mut().remove(constraint);\n-              }\n-              AddCombination(Glb, ref regions) => {\n-                self.glbs.borrow_mut().remove(regions);\n-              }\n-              AddCombination(Lub, ref regions) => {\n-                self.lubs.borrow_mut().remove(regions);\n-              }\n+        assert!(undo_log.len() > snapshot.length);\n+        assert!(*undo_log.get(snapshot.length) == OpenSnapshot);\n+        while undo_log.len() > snapshot.length + 1 {\n+            match undo_log.pop().unwrap() {\n+                OpenSnapshot => {\n+                    fail!(\"Failure to observe stack discipline\");\n+                }\n+                Mark | CommitedSnapshot => { }\n+                AddVar(vid) => {\n+                    let mut var_origins = self.var_origins.borrow_mut();\n+                    assert_eq!(var_origins.len(), vid.index + 1);\n+                    var_origins.pop().unwrap();\n+                }\n+                AddConstraint(ref constraint) => {\n+                    self.constraints.borrow_mut().remove(constraint);\n+                }\n+                AddCombination(Glb, ref regions) => {\n+                    self.glbs.borrow_mut().remove(regions);\n+                }\n+                AddCombination(Lub, ref regions) => {\n+                    self.lubs.borrow_mut().remove(regions);\n+                }\n             }\n         }\n+        let c = undo_log.pop().unwrap();\n+        assert!(c == OpenSnapshot);\n     }\n \n     pub fn num_vars(&self) -> uint {\n@@ -213,7 +242,7 @@ impl<'a> RegionVarBindings<'a> {\n     pub fn new_region_var(&self, origin: RegionVariableOrigin) -> RegionVid {\n         let id = self.num_vars();\n         self.var_origins.borrow_mut().push(origin.clone());\n-        let vid = RegionVid { id: id };\n+        let vid = RegionVid { index: id };\n         if self.in_snapshot() {\n             self.undo_log.borrow_mut().push(AddVar(vid));\n         }\n@@ -368,15 +397,15 @@ impl<'a> RegionVarBindings<'a> {\n         let v = match *self.values.borrow() {\n             None => {\n                 self.tcx.sess.span_bug(\n-                    self.var_origins.borrow().get(rid.to_uint()).span(),\n+                    self.var_origins.borrow().get(rid.index).span(),\n                     \"attempt to resolve region variable before values have \\\n                      been computed!\")\n             }\n-            Some(ref values) => *values.get(rid.to_uint())\n+            Some(ref values) => *values.get(rid.index)\n         };\n \n         debug!(\"RegionVarBindings: resolve_var({:?}={})={:?}\",\n-               rid, rid.to_uint(), v);\n+               rid, rid.index, v);\n         match v {\n             Value(r) => r,\n \n@@ -427,30 +456,31 @@ impl<'a> RegionVarBindings<'a> {\n         ReInfer(ReVar(c))\n     }\n \n-    pub fn vars_created_since_snapshot(&self, snapshot: uint)\n-                                       -> Vec<RegionVid> {\n-        self.undo_log.borrow().slice_from(snapshot).iter()\n+    pub fn vars_created_since_mark(&self, mark: RegionMark)\n+                                   -> Vec<RegionVid>\n+    {\n+        self.undo_log.borrow()\n+            .slice_from(mark.length)\n+            .iter()\n             .filter_map(|&elt| match elt {\n                 AddVar(vid) => Some(vid),\n                 _ => None\n             })\n             .collect()\n     }\n \n-    pub fn tainted(&self, snapshot: uint, r0: Region) -> Vec<Region> {\n+    pub fn tainted(&self, mark: RegionMark, r0: Region) -> Vec<Region> {\n         /*!\n          * Computes all regions that have been related to `r0` in any\n-         * way since the snapshot `snapshot` was taken---`r0` itself\n-         * will be the first entry. This is used when checking whether\n+         * way since the mark `mark` was made---`r0` itself will be\n+         * the first entry. This is used when checking whether\n          * skolemized regions are being improperly related to other\n          * regions.\n          */\n \n-        debug!(\"tainted(snapshot={}, r0={:?})\", snapshot, r0);\n+        debug!(\"tainted(mark={}, r0={})\", mark, r0.repr(self.tcx));\n         let _indenter = indenter();\n \n-        let undo_len = self.undo_log.borrow().len();\n-\n         // `result_set` acts as a worklist: we explore all outgoing\n         // edges and add any new regions we find to result_set.  This\n         // is not a terribly efficient implementation.\n@@ -459,16 +489,14 @@ impl<'a> RegionVarBindings<'a> {\n         while result_index < result_set.len() {\n             // nb: can't use uint::range() here because result_set grows\n             let r = *result_set.get(result_index);\n-\n             debug!(\"result_index={}, r={:?}\", result_index, r);\n \n-            let mut undo_index = snapshot;\n-            while undo_index < undo_len {\n-                // nb: can't use uint::range() here as we move result_set\n-                let regs = match self.undo_log.borrow().get(undo_index) {\n+            for undo_entry in\n+                self.undo_log.borrow().slice_from(mark.length).iter()\n+            {\n+                let regs = match undo_entry {\n                     &AddConstraint(ConstrainVarSubVar(ref a, ref b)) => {\n-                        Some((ReInfer(ReVar(*a)),\n-                              ReInfer(ReVar(*b))))\n+                        Some((ReInfer(ReVar(*a)), ReInfer(ReVar(*b))))\n                     }\n                     &AddConstraint(ConstrainRegSubVar(ref a, ref b)) => {\n                         Some((*a, ReInfer(ReVar(*b))))\n@@ -479,7 +507,11 @@ impl<'a> RegionVarBindings<'a> {\n                     &AddConstraint(ConstrainRegSubReg(a, b)) => {\n                         Some((a, b))\n                     }\n-                    _ => {\n+                    &AddCombination(..) |\n+                    &Mark |\n+                    &AddVar(..) |\n+                    &OpenSnapshot |\n+                    &CommitedSnapshot => {\n                         None\n                     }\n                 };\n@@ -493,8 +525,6 @@ impl<'a> RegionVarBindings<'a> {\n                             consider_adding_edge(result_set, r, r2, r1);\n                     }\n                 }\n-\n-                undo_index += 1;\n             }\n \n             result_index += 1;\n@@ -559,7 +589,7 @@ impl<'a> RegionVarBindings<'a> {\n \n           (ReInfer(ReVar(v_id)), _) | (_, ReInfer(ReVar(v_id))) => {\n             self.tcx.sess.span_bug(\n-                self.var_origins.borrow().get(v_id.to_uint()).span(),\n+                self.var_origins.borrow().get(v_id.index).span(),\n                 format!(\"lub_concrete_regions invoked with \\\n                          non-concrete regions: {:?}, {:?}\",\n                         a,\n@@ -665,7 +695,7 @@ impl<'a> RegionVarBindings<'a> {\n             (ReInfer(ReVar(v_id)), _) |\n             (_, ReInfer(ReVar(v_id))) => {\n                 self.tcx.sess.span_bug(\n-                    self.var_origins.borrow().get(v_id.to_uint()).span(),\n+                    self.var_origins.borrow().get(v_id.index).span(),\n                     format!(\"glb_concrete_regions invoked with \\\n                              non-concrete regions: {:?}, {:?}\",\n                             a,\n@@ -804,14 +834,14 @@ impl<'a> RegionVarBindings<'a> {\n         self.iterate_until_fixed_point(\"Expansion\", |constraint| {\n             match *constraint {\n               ConstrainRegSubVar(a_region, b_vid) => {\n-                let b_data = &mut var_data[b_vid.to_uint()];\n+                let b_data = &mut var_data[b_vid.index];\n                 self.expand_node(a_region, b_vid, b_data)\n               }\n               ConstrainVarSubVar(a_vid, b_vid) => {\n-                match var_data[a_vid.to_uint()].value {\n+                match var_data[a_vid.index].value {\n                   NoValue | ErrorValue => false,\n                   Value(a_region) => {\n-                    let b_node = &mut var_data[b_vid.to_uint()];\n+                    let b_node = &mut var_data[b_vid.index];\n                     self.expand_node(a_region, b_vid, b_node)\n                   }\n                 }\n@@ -873,16 +903,16 @@ impl<'a> RegionVarBindings<'a> {\n                 false\n               }\n               ConstrainVarSubVar(a_vid, b_vid) => {\n-                match var_data[b_vid.to_uint()].value {\n+                match var_data[b_vid.index].value {\n                   NoValue | ErrorValue => false,\n                   Value(b_region) => {\n-                    let a_data = &mut var_data[a_vid.to_uint()];\n+                    let a_data = &mut var_data[a_vid.index];\n                     self.contract_node(a_vid, a_data, b_region)\n                   }\n                 }\n               }\n               ConstrainVarSubReg(a_vid, b_region) => {\n-                let a_data = &mut var_data[a_vid.to_uint()];\n+                let a_data = &mut var_data[a_vid.index];\n                 self.contract_node(a_vid, a_data, b_region)\n               }\n               ConstrainRegSubReg(..) => {\n@@ -1054,7 +1084,7 @@ impl<'a> RegionVarBindings<'a> {\n                     }\n                     let graph = opt_graph.get_ref();\n \n-                    let node_vid = RegionVid { id: idx };\n+                    let node_vid = RegionVid { index: idx };\n                     match var_data[idx].classification {\n                         Expanding => {\n                             self.collect_error_for_expanding_node(\n@@ -1091,17 +1121,17 @@ impl<'a> RegionVarBindings<'a> {\n         for (constraint, _) in constraints.iter() {\n             match *constraint {\n                 ConstrainVarSubVar(a_id, b_id) => {\n-                    graph.add_edge(NodeIndex(a_id.to_uint()),\n-                                   NodeIndex(b_id.to_uint()),\n+                    graph.add_edge(NodeIndex(a_id.index),\n+                                   NodeIndex(b_id.index),\n                                    *constraint);\n                 }\n                 ConstrainRegSubVar(_, b_id) => {\n                     graph.add_edge(dummy_idx,\n-                                   NodeIndex(b_id.to_uint()),\n+                                   NodeIndex(b_id.index),\n                                    *constraint);\n                 }\n                 ConstrainVarSubReg(a_id, _) => {\n-                    graph.add_edge(NodeIndex(a_id.to_uint()),\n+                    graph.add_edge(NodeIndex(a_id.index),\n                                    dummy_idx,\n                                    *constraint);\n                 }\n@@ -1157,7 +1187,7 @@ impl<'a> RegionVarBindings<'a> {\n                 if !self.is_subregion_of(lower_bound.region,\n                                          upper_bound.region) {\n                     errors.push(SubSupConflict(\n-                        self.var_origins.borrow().get(node_idx.to_uint()).clone(),\n+                        self.var_origins.borrow().get(node_idx.index).clone(),\n                         lower_bound.origin.clone(),\n                         lower_bound.region,\n                         upper_bound.origin.clone(),\n@@ -1168,7 +1198,7 @@ impl<'a> RegionVarBindings<'a> {\n         }\n \n         self.tcx.sess.span_bug(\n-            self.var_origins.borrow().get(node_idx.to_uint()).span(),\n+            self.var_origins.borrow().get(node_idx.index).span(),\n             format!(\"collect_error_for_expanding_node() could not find error \\\n                   for var {:?}, lower_bounds={}, upper_bounds={}\",\n                  node_idx,\n@@ -1207,7 +1237,7 @@ impl<'a> RegionVarBindings<'a> {\n                   Ok(_) => {}\n                   Err(_) => {\n                     errors.push(SupSupConflict(\n-                        self.var_origins.borrow().get(node_idx.to_uint()).clone(),\n+                        self.var_origins.borrow().get(node_idx.index).clone(),\n                         upper_bound_1.origin.clone(),\n                         upper_bound_1.region,\n                         upper_bound_2.origin.clone(),\n@@ -1219,7 +1249,7 @@ impl<'a> RegionVarBindings<'a> {\n         }\n \n         self.tcx.sess.span_bug(\n-            self.var_origins.borrow().get(node_idx.to_uint()).span(),\n+            self.var_origins.borrow().get(node_idx.index).span(),\n             format!(\"collect_error_for_contracting_node() could not find error \\\n                   for var {:?}, upper_bounds={}\",\n                  node_idx,\n@@ -1256,12 +1286,12 @@ impl<'a> RegionVarBindings<'a> {\n \n         while !state.stack.is_empty() {\n             let node_idx = state.stack.pop().unwrap();\n-            let classification = var_data[node_idx.to_uint()].classification;\n+            let classification = var_data[node_idx.index].classification;\n \n             // check whether we've visited this node on some previous walk\n-            if dup_vec[node_idx.to_uint()] == uint::MAX {\n-                dup_vec[node_idx.to_uint()] = orig_node_idx.to_uint();\n-            } else if dup_vec[node_idx.to_uint()] != orig_node_idx.to_uint() {\n+            if dup_vec[node_idx.index] == uint::MAX {\n+                dup_vec[node_idx.index] = orig_node_idx.index;\n+            } else if dup_vec[node_idx.index] != orig_node_idx.index {\n                 state.dup_found = true;\n             }\n \n@@ -1289,7 +1319,7 @@ impl<'a> RegionVarBindings<'a> {\n                          dir: Direction) {\n             debug!(\"process_edges(source_vid={:?}, dir={:?})\", source_vid, dir);\n \n-            let source_node_index = NodeIndex(source_vid.to_uint());\n+            let source_node_index = NodeIndex(source_vid.index);\n             graph.each_adjacent_edge(source_node_index, dir, |_, edge| {\n                 match edge.data {\n                     ConstrainVarSubVar(from_vid, to_vid) => {"}, {"sha": "ae7578957f890f14646dc8a721d48b58f49d5b19", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/020373f2c807627274a53251a7841f0e9617e98e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/020373f2c807627274a53251a7841f0e9617e98e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=020373f2c807627274a53251a7841f0e9617e98e", "patch": "@@ -53,10 +53,9 @@ use middle::ty;\n use middle::ty_fold;\n use middle::typeck::infer::{Bounds, cyclic_ty, fixup_err, fres, InferCtxt};\n use middle::typeck::infer::unresolved_ty;\n-use middle::typeck::infer::to_str::InferStr;\n-use middle::typeck::infer::unify::{Root, UnifyInferCtxtMethods};\n-use util::common::{indent, indenter};\n-use util::ppaux::ty_to_str;\n+use middle::typeck::infer::unify::Root;\n+use util::common::{indent};\n+use util::ppaux::{ty_to_str, Repr};\n \n use syntax::ast;\n \n@@ -150,8 +149,7 @@ impl<'a> ResolveState<'a> {\n     }\n \n     pub fn resolve_type(&mut self, typ: ty::t) -> ty::t {\n-        debug!(\"resolve_type({})\", typ.inf_str(self.infcx));\n-        let _i = indenter();\n+        debug!(\"resolve_type({})\", typ.repr(self.infcx.tcx));\n \n         if !ty::type_needs_infer(typ) {\n             return typ;\n@@ -188,7 +186,7 @@ impl<'a> ResolveState<'a> {\n     }\n \n     pub fn resolve_region(&mut self, orig: ty::Region) -> ty::Region {\n-        debug!(\"Resolve_region({})\", orig.inf_str(self.infcx));\n+        debug!(\"Resolve_region({})\", orig.repr(self.infcx.tcx));\n         match orig {\n           ty::ReInfer(ty::ReVar(rid)) => self.resolve_region_var(rid),\n           _ => orig\n@@ -216,14 +214,15 @@ impl<'a> ResolveState<'a> {\n             // tend to carry more restrictions or higher\n             // perf. penalties, so it pays to know more.\n \n-            let nde = self.infcx.get(vid);\n-            let bounds = nde.possible_types;\n-\n-            let t1 = match bounds {\n-              Bounds { ub:_, lb:Some(t) } if !type_is_bot(t)\n-                => self.resolve_type(t),\n-              Bounds { ub:Some(t), lb:_ } => self.resolve_type(t),\n-              Bounds { ub:_, lb:Some(t) } => self.resolve_type(t),\n+            let node =\n+                self.infcx.type_unification_table.borrow_mut().get(tcx, vid);\n+            let t1 = match node.value {\n+              Bounds { ub:_, lb:Some(t) } if !type_is_bot(t) => {\n+                  self.resolve_type(t)\n+              }\n+              Bounds { ub:Some(t), lb:_ } | Bounds { ub:_, lb:Some(t) } => {\n+                  self.resolve_type(t)\n+              }\n               Bounds { ub:None, lb:None } => {\n                 if self.should(force_tvar) {\n                     self.err = Some(unresolved_ty(vid));\n@@ -241,15 +240,18 @@ impl<'a> ResolveState<'a> {\n             return ty::mk_int_var(self.infcx.tcx, vid);\n         }\n \n-        let node = self.infcx.get(vid);\n-        match node.possible_types {\n+        let tcx = self.infcx.tcx;\n+        let table = &self.infcx.int_unification_table;\n+        let node = table.borrow_mut().get(tcx, vid);\n+        match node.value {\n           Some(IntType(t)) => ty::mk_mach_int(t),\n           Some(UintType(t)) => ty::mk_mach_uint(t),\n           None => {\n             if self.should(force_ivar) {\n                 // As a last resort, default to int.\n                 let ty = ty::mk_int();\n-                self.infcx.set(vid, Root(Some(IntType(ast::TyI)), node.rank));\n+                table.borrow_mut().set(\n+                    tcx, node.key, Root(Some(IntType(ast::TyI)), node.rank));\n                 ty\n             } else {\n                 ty::mk_int_var(self.infcx.tcx, vid)\n@@ -263,14 +265,17 @@ impl<'a> ResolveState<'a> {\n             return ty::mk_float_var(self.infcx.tcx, vid);\n         }\n \n-        let node = self.infcx.get(vid);\n-        match node.possible_types {\n+        let tcx = self.infcx.tcx;\n+        let table = &self.infcx.float_unification_table;\n+        let node = table.borrow_mut().get(tcx, vid);\n+        match node.value {\n           Some(t) => ty::mk_mach_float(t),\n           None => {\n             if self.should(force_fvar) {\n                 // As a last resort, default to f64.\n                 let ty = ty::mk_f64();\n-                self.infcx.set(vid, Root(Some(ast::TyF64), node.rank));\n+                table.borrow_mut().set(\n+                    tcx, node.key, Root(Some(ast::TyF64), node.rank));\n                 ty\n             } else {\n                 ty::mk_float_var(self.infcx.tcx, vid)"}, {"sha": "856237c4bcaa4c3634468e23839267db6a4d74f3", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/020373f2c807627274a53251a7841f0e9617e98e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/020373f2c807627274a53251a7841f0e9617e98e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=020373f2c807627274a53251a7841f0e9617e98e", "patch": "@@ -20,10 +20,9 @@ use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::lattice::CombineFieldsLatticeMethods;\n use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::then;\n-use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::{TypeTrace, Subtype};\n use util::common::{indenter};\n-use util::ppaux::bound_region_to_str;\n+use util::ppaux::{bound_region_to_str, Repr};\n \n use syntax::ast::{Onceness, FnStyle, MutImmutable, MutMutable};\n \n@@ -63,14 +62,16 @@ impl<'f> Combine for Sub<'f> {\n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),\n-               a.inf_str(self.get_ref().infcx),\n-               b.inf_str(self.get_ref().infcx));\n+               a.repr(self.get_ref().infcx.tcx),\n+               b.repr(self.get_ref().infcx.tcx));\n         self.get_ref().infcx.region_vars.make_subregion(Subtype(self.trace()), a, b);\n         Ok(a)\n     }\n \n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n-        debug!(\"mts({} <: {})\", a.inf_str(self.get_ref().infcx), b.inf_str(self.get_ref().infcx));\n+        debug!(\"mts({} <: {})\",\n+               a.repr(self.get_ref().infcx.tcx),\n+               b.repr(self.get_ref().infcx.tcx));\n \n         if a.mutbl != b.mutbl {\n             return Err(ty::terr_mutability);\n@@ -116,7 +117,7 @@ impl<'f> Combine for Sub<'f> {\n \n     fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n         debug!(\"{}.tys({}, {})\", self.tag(),\n-               a.inf_str(self.get_ref().infcx), b.inf_str(self.get_ref().infcx));\n+               a.repr(self.get_ref().infcx.tcx), b.repr(self.get_ref().infcx.tcx));\n         if a == b { return Ok(a); }\n         let _indenter = indenter();\n         match (&ty::get(a).sty, &ty::get(b).sty) {\n@@ -149,7 +150,7 @@ impl<'f> Combine for Sub<'f> {\n \n     fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n         debug!(\"fn_sigs(a={}, b={})\",\n-               a.inf_str(self.get_ref().infcx), b.inf_str(self.get_ref().infcx));\n+               a.repr(self.get_ref().infcx.tcx), b.repr(self.get_ref().infcx.tcx));\n         let _indenter = indenter();\n \n         // Rather than checking the subtype relationship between `a` and `b`\n@@ -159,11 +160,9 @@ impl<'f> Combine for Sub<'f> {\n         // Note: this is a subtle algorithm.  For a full explanation,\n         // please see the large comment in `region_inference.rs`.\n \n-        // Take a snapshot.  We'll never roll this back, but in later\n-        // phases we do want to be able to examine \"all bindings that\n-        // were created as part of this type comparison\", and making a\n-        // snapshot is a convenient way to do that.\n-        let snapshot = self.get_ref().infcx.region_vars.start_snapshot();\n+        // Make a mark so we can examine \"all bindings that were\n+        // created as part of this type comparison\".\n+        let mark = self.get_ref().infcx.region_vars.mark();\n \n         // First, we instantiate each bound region in the subtype with a fresh\n         // region variable.\n@@ -183,18 +182,18 @@ impl<'f> Combine for Sub<'f> {\n             })\n         };\n \n-        debug!(\"a_sig={}\", a_sig.inf_str(self.get_ref().infcx));\n-        debug!(\"b_sig={}\", b_sig.inf_str(self.get_ref().infcx));\n+        debug!(\"a_sig={}\", a_sig.repr(self.get_ref().infcx.tcx));\n+        debug!(\"b_sig={}\", b_sig.repr(self.get_ref().infcx.tcx));\n \n         // Compare types now that bound regions have been replaced.\n         let sig = if_ok!(super_fn_sigs(self, &a_sig, &b_sig));\n \n         // Presuming type comparison succeeds, we need to check\n         // that the skolemized regions do not \"leak\".\n         let new_vars =\n-            self.get_ref().infcx.region_vars.vars_created_since_snapshot(snapshot);\n+            self.get_ref().infcx.region_vars.vars_created_since_mark(mark);\n         for (&skol_br, &skol) in skol_map.iter() {\n-            let tainted = self.get_ref().infcx.region_vars.tainted(snapshot, skol);\n+            let tainted = self.get_ref().infcx.region_vars.tainted(mark, skol);\n             for tainted_region in tainted.iter() {\n                 // Each skolemized should only be relatable to itself\n                 // or new variables:\n@@ -209,9 +208,11 @@ impl<'f> Combine for Sub<'f> {\n \n                 // A is not as polymorphic as B:\n                 if self.a_is_expected() {\n+                    debug!(\"Not as polymorphic!\");\n                     return Err(ty::terr_regions_insufficiently_polymorphic(\n                             skol_br, *tainted_region));\n                 } else {\n+                    debug!(\"Overly polymorphic!\");\n                     return Err(ty::terr_regions_overly_polymorphic(\n                             skol_br, *tainted_region));\n                 }"}, {"sha": "f08cbb06c9e3166c21b83d5d4c1bbc52140f408e", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 294, "deletions": 191, "changes": 485, "blob_url": "https://github.com/rust-lang/rust/blob/020373f2c807627274a53251a7841f0e9617e98e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/020373f2c807627274a53251a7841f0e9617e98e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=020373f2c807627274a53251a7841f0e9617e98e", "patch": "@@ -8,77 +8,144 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/**\n+/*!\n \n # Standalone Tests for the Inference Module\n \n-Note: This module is only compiled when doing unit testing.\n-\n */\n \n+// This is only used by tests, hence allow dead code.\n+#![allow(dead_code)]\n+\n+use driver::config;\n use driver::diagnostic;\n-use driver::driver::{optgroups, build_session_options, build_session};\n-use driver::driver::{str_input, build_configuration};\n-use middle::lang_items::{LanguageItems, language_items};\n-use middle::ty::{FnTyBase, FnMeta, FnSig};\n-use util::ppaux::ty_to_str;\n-\n-use extra::oldmap::HashMap;\n-use getopts::{optopt, optmulti, optflag, optflagopt, getopts};\n-use getopts::opt_present;\n-use syntax::codemap::DUMMY_SP;\n-use syntax::parse::parse_crate_from_source_str;\n-use syntax::{ast, attr, parse};\n-\n-struct Env {\n-    krate: @ast::Crate,\n-    tcx: ty::ctxt,\n-    infcx: infer::infer_ctxt,\n-    err_messages: @DVec<String>\n+use driver::diagnostic::Emitter;\n+use driver::driver;\n+use driver::session;\n+use middle::freevars;\n+use middle::lang_items;\n+use middle::region;\n+use middle::resolve;\n+use middle::resolve_lifetime;\n+use middle::stability;\n+use middle::ty;\n+use middle::typeck::infer::combine::Combine;\n+use middle::typeck::infer;\n+use middle::typeck::infer::lub::Lub;\n+use middle::typeck::infer::glb::Glb;\n+use syntax::codemap;\n+use syntax::codemap::{Span, CodeMap, DUMMY_SP};\n+use syntax::diagnostic::{Level, RenderSpan, Bug, Fatal, Error, Warning, Note};\n+use syntax::ast;\n+use syntax::crateid::CrateId;\n+use util::ppaux::{ty_to_str, UserString};\n+\n+struct Env<'a> {\n+    krate: ast::Crate,\n+    tcx: &'a ty::ctxt,\n+    infcx: &'a infer::InferCtxt<'a>,\n+}\n+\n+struct RH<'a> {\n+    id: ast::NodeId,\n+    sub: &'a [RH<'a>]\n }\n \n-struct RH {\n-    id: ast::node_id,\n-    sub: &[RH]\n+static EMPTY_SOURCE_STR: &'static str = \"#![no_std]\";\n+\n+struct ExpectErrorEmitter {\n+    messages: Vec<String>\n }\n \n-static EMPTY_SOURCE_STR: &str = \"/* Hello, world! */\";\n-\n-fn setup_env(test_name: &str, source_string: &str) -> Env {\n-    let messages = @DVec();\n-    let matches = getopts(vec!(\"-Z\".to_string(), \"verbose\".to_string()), optgroups()).get();\n-    let diag = diagnostic::collect(messages);\n-    let sessopts = build_session_options(\"rustc\".to_string(), &matches, diag);\n-    let sess = build_session(sessopts, None, diag);\n-    let cfg = build_configuration(sess, \"whatever\".to_string(), str_input(\"\".to_string()));\n-    let dm = HashMap();\n-    let amap = HashMap();\n-    let freevars = HashMap();\n-    let region_paramd_items = HashMap();\n-    let region_map = HashMap();\n-    let lang_items = LanguageItems::new();\n-\n-    let parse_sess = parse::new_parse_sess(None);\n-    let krate = parse_crate_from_source_str(\n-        test_name.to_str(), @source_string.to_str(),\n-        cfg, parse_sess);\n-\n-    let tcx = ty::mk_ctxt(sess, dm, amap, freevars, region_map,\n-                          region_paramd_items, lang_items);\n-\n-    let infcx = infer::new_infer_ctxt(tcx);\n-\n-    return Env {krate: krate,\n-                tcx: tcx,\n-                infcx: infcx,\n-                err_messages: messages};\n+fn remove_message(e: &mut ExpectErrorEmitter, msg: &str, lvl: Level) {\n+    match lvl {\n+        Bug | Fatal | Error => { }\n+        Warning | Note => { return; }\n+    }\n+\n+    debug!(\"Error: {}\", msg);\n+    match e.messages.iter().position(|m| msg.contains(m.as_slice())) {\n+        Some(i) => {\n+            e.messages.remove(i);\n+        }\n+        None => {\n+            fail!(\"Unexpected error: {} Expected: {}\",\n+                  msg, e.messages);\n+        }\n+    }\n }\n \n-impl Env {\n+impl Emitter for ExpectErrorEmitter {\n+    fn emit(&mut self,\n+            _cmsp: Option<(&codemap::CodeMap, Span)>,\n+            msg: &str,\n+            lvl: Level)\n+    {\n+        remove_message(self, msg, lvl);\n+    }\n+\n+    fn custom_emit(&mut self,\n+                   _cm: &codemap::CodeMap,\n+                   _sp: RenderSpan,\n+                   msg: &str,\n+                   lvl: Level)\n+    {\n+        remove_message(self, msg, lvl);\n+    }\n+}\n+\n+fn errors(msgs: &[&str]) -> (Box<Emitter+Send>, uint) {\n+    let v = Vec::from_fn(msgs.len(), |i| msgs[i].to_owned());\n+    (box ExpectErrorEmitter { messages: v } as Box<Emitter+Send>, msgs.len())\n+}\n+\n+fn test_env(_test_name: &str,\n+            source_string: &str,\n+            (emitter, expected_err_count): (Box<Emitter+Send>, uint),\n+            body: |Env|) {\n+    let options =\n+        config::basic_options();\n+    let codemap =\n+        CodeMap::new();\n+    let diagnostic_handler =\n+        diagnostic::mk_handler(emitter);\n+    let span_diagnostic_handler =\n+        diagnostic::mk_span_handler(diagnostic_handler, codemap);\n+\n+    let sess = session::build_session_(options, None, span_diagnostic_handler);\n+    let krate_config = Vec::new();\n+    let input = driver::StrInput(source_string.to_owned());\n+    let krate = driver::phase_1_parse_input(&sess, krate_config, &input);\n+    let krate_id = CrateId { path: \"test\".to_owned(),\n+                             name: \"test\".to_owned(),\n+                             version: None };\n+    let (krate, ast_map) =\n+        driver::phase_2_configure_and_expand(&sess, krate, &krate_id);\n+\n+    // run just enough stuff to build a tcx:\n+    let lang_items = lang_items::collect_language_items(&krate, &sess);\n+    let resolve::CrateMap { def_map: def_map, .. } =\n+        resolve::resolve_crate(&sess, &lang_items, &krate);\n+    let freevars_map = freevars::annotate_freevars(&def_map, &krate);\n+    let named_region_map = resolve_lifetime::krate(&sess, &krate);\n+    let region_map = region::resolve_crate(&sess, &krate);\n+    let stability_index = stability::Index::build(&krate);\n+    let tcx = ty::mk_ctxt(sess, def_map, named_region_map, ast_map,\n+                          freevars_map, region_map, lang_items, stability_index);\n+    let infcx = infer::new_infer_ctxt(&tcx);\n+    let env = Env {krate: krate,\n+                   tcx: &tcx,\n+                   infcx: &infcx};\n+    body(env);\n+    infcx.resolve_regions_and_report_errors();\n+    assert_eq!(tcx.sess.err_count(), expected_err_count);\n+}\n+\n+impl<'a> Env<'a> {\n     pub fn create_region_hierarchy(&self, rh: &RH) {\n         for child_rh in rh.sub.iter() {\n             self.create_region_hierarchy(child_rh);\n-            self.tcx.region_map.insert(child_rh.id, rh.id);\n+            self.tcx.region_maps.record_encl_scope(child_rh.id, rh.id);\n         }\n     }\n \n@@ -93,37 +160,39 @@ impl Env {\n                             sub: &[]}]});\n     }\n \n-    pub fn lookup_item(&self, names: &[String]) -> ast::node_id {\n-        return match search_mod(self, &self.krate.node.module, 0, names) {\n+    pub fn lookup_item(&self, names: &[String]) -> ast::NodeId {\n+        return match search_mod(self, &self.krate.module, 0, names) {\n             Some(id) => id,\n             None => {\n-                fail!(\"no item found: `%s`\", names.connect(\"::\"));\n+                fail!(\"no item found: `{}`\", names.connect(\"::\"));\n             }\n         };\n \n-        fn search_mod(self: &Env,\n+        fn search_mod(this: &Env,\n                       m: &ast::Mod,\n                       idx: uint,\n-                      names: &[String]) -> Option<ast::node_id> {\n+                      names: &[String])\n+                      -> Option<ast::NodeId> {\n             assert!(idx < names.len());\n             for item in m.items.iter() {\n-                if self.tcx.sess.str_of(item.ident) == names[idx] {\n-                    return search(self, *item, idx+1, names);\n+                if item.ident.user_string(this.tcx) == names[idx] {\n+                    return search(this, *item, idx+1, names);\n                 }\n             }\n             return None;\n         }\n \n-        fn search(self: &Env,\n-                  it: @ast::Item,\n+        fn search(this: &Env,\n+                  it: &ast::Item,\n                   idx: uint,\n-                  names: &[String]) -> Option<ast::node_id> {\n+                  names: &[String])\n+                  -> Option<ast::NodeId> {\n             if idx == names.len() {\n                 return Some(it.id);\n             }\n \n             return match it.node {\n-                ast::ItemConst(..) | ast::ItemFn(..) |\n+                ast::ItemStatic(..) | ast::ItemFn(..) |\n                 ast::ItemForeignMod(..) | ast::ItemTy(..) => {\n                     None\n                 }\n@@ -135,12 +204,20 @@ impl Env {\n                 }\n \n                 ast::ItemMod(ref m) => {\n-                    search_mod(self, m, idx, names)\n+                    search_mod(this, m, idx, names)\n                 }\n             };\n         }\n     }\n \n+    pub fn make_subtype(&self, a: ty::t, b: ty::t) -> bool {\n+        match infer::mk_subty(self.infcx, true, infer::Misc(DUMMY_SP), a, b) {\n+            Ok(_) => true,\n+            Err(ref e) => fail!(\"Encountered error: {}\",\n+                                ty::type_err_to_str(self.tcx, e))\n+        }\n+    }\n+\n     pub fn is_subtype(&self, a: ty::t, b: ty::t) -> bool {\n         match infer::can_mk_subty(self.infcx, a, b) {\n             Ok(_) => true,\n@@ -150,25 +227,20 @@ impl Env {\n \n     pub fn assert_subtype(&self, a: ty::t, b: ty::t) {\n         if !self.is_subtype(a, b) {\n-            fail!(\"%s is not a subtype of %s, but it should be\",\n+            fail!(\"{} is not a subtype of {}, but it should be\",\n                   self.ty_to_str(a),\n                   self.ty_to_str(b));\n         }\n     }\n \n     pub fn assert_not_subtype(&self, a: ty::t, b: ty::t) {\n         if self.is_subtype(a, b) {\n-            fail!(\"%s is a subtype of %s, but it shouldn't be\",\n+            fail!(\"{} is a subtype of {}, but it shouldn't be\",\n                   self.ty_to_str(a),\n                   self.ty_to_str(b));\n         }\n     }\n \n-    pub fn assert_strict_subtype(&self, a: ty::t, b: ty::t) {\n-        self.assert_subtype(a, b);\n-        self.assert_not_subtype(b, a);\n-    }\n-\n     pub fn assert_eq(&self, a: ty::t, b: ty::t) {\n         self.assert_subtype(a, b);\n         self.assert_subtype(b, a);\n@@ -178,36 +250,29 @@ impl Env {\n         ty_to_str(self.tcx, a)\n     }\n \n-    pub fn t_fn(&self, input_tys: &[ty::t], output_ty: ty::t) -> ty::t {\n-        let inputs = input_tys.map(|t| {mode: ast::expl(ast::by_copy),\n-                                        ty: *t});\n-        ty::mk_fn(self.tcx, FnTyBase {\n-            meta: FnMeta {fn_style: ast::NormalFn,\n-                          proto: ast::ProtoBare,\n-                          onceness: ast::Many,\n-                          region: ty::ReStatic,\n-                          bounds: @Vec::new()},\n-            sig: FnSig {\n-                inputs: inputs,\n-                output: output_ty,\n-                variadic: false\n-            }\n-        })\n+    pub fn t_fn(&self,\n+                binder_id: ast::NodeId,\n+                input_tys: &[ty::t],\n+                output_ty: ty::t)\n+                -> ty::t\n+    {\n+        ty::mk_ctor_fn(self.tcx, binder_id, input_tys, output_ty)\n     }\n \n     pub fn t_int(&self) -> ty::t {\n-        ty::mk_int(self.tcx)\n+        ty::mk_int()\n     }\n \n-    pub fn t_rptr_bound(&self, id: uint) -> ty::t {\n-        ty::mk_imm_rptr(self.tcx, ty::re_bound(ty::BrAnon(id)), self.t_int())\n+    pub fn t_rptr_late_bound(&self, binder_id: ast::NodeId, id: uint) -> ty::t {\n+        ty::mk_imm_rptr(self.tcx, ty::ReLateBound(binder_id, ty::BrAnon(id)),\n+                        self.t_int())\n     }\n \n-    pub fn t_rptr_scope(&self, id: ast::node_id) -> ty::t {\n+    pub fn t_rptr_scope(&self, id: ast::NodeId) -> ty::t {\n         ty::mk_imm_rptr(self.tcx, ty::ReScope(id), self.t_int())\n     }\n \n-    pub fn t_rptr_free(&self, nid: ast::node_id, id: uint) -> ty::t {\n+    pub fn t_rptr_free(&self, nid: ast::NodeId, id: uint) -> ty::t {\n         ty::mk_imm_rptr(self.tcx,\n                         ty::ReFree(ty::FreeRegion {scope_id: nid,\n                                                     bound_region: ty::BrAnon(id)}),\n@@ -218,60 +283,67 @@ impl Env {\n         ty::mk_imm_rptr(self.tcx, ty::ReStatic, self.t_int())\n     }\n \n-    pub fn lub() -> Lub { Lub(self.infcx.combine_fields(true, DUMMY_SP)) }\n+    pub fn dummy_type_trace(&self) -> infer::TypeTrace {\n+        infer::TypeTrace {\n+            origin: infer::Misc(DUMMY_SP),\n+            values: infer::Types(ty::expected_found {\n+                expected: ty::mk_err(),\n+                found: ty::mk_err(),\n+            })\n+        }\n+    }\n+\n+    pub fn lub(&self) -> Lub<'a> {\n+        let trace = self.dummy_type_trace();\n+        Lub(self.infcx.combine_fields(true, trace))\n+    }\n \n-    pub fn glb() -> Glb { Glb(self.infcx.combine_fields(true, DUMMY_SP)) }\n+    pub fn glb(&self) -> Glb<'a> {\n+        let trace = self.dummy_type_trace();\n+        Glb(self.infcx.combine_fields(true, trace))\n+    }\n \n-    pub fn resolve_regions(exp_count: uint) {\n-        debug!(\"resolve_regions(%u)\", exp_count);\n+    pub fn resolve_regions(&self) {\n+        self.infcx.resolve_regions_and_report_errors();\n+    }\n \n-        self.infcx.resolve_regions();\n-        if self.err_messages.len() != exp_count {\n-            for msg in self.err_messages.iter() {\n-                debug!(\"Error encountered: %s\", *msg);\n-            }\n-            format!(\"resolving regions encountered %u errors but expected %u!\",\n-                 self.err_messages.len(),\n-                 exp_count);\n+    pub fn make_lub_ty(&self, t1: ty::t, t2: ty::t) -> ty::t {\n+        match self.lub().tys(t1, t2) {\n+            Ok(t) => t,\n+            Err(ref e) => fail!(\"unexpected error computing LUB: {:?}\",\n+                                ty::type_err_to_str(self.tcx, e))\n         }\n     }\n \n     /// Checks that `LUB(t1,t2) == t_lub`\n     pub fn check_lub(&self, t1: ty::t, t2: ty::t, t_lub: ty::t) {\n         match self.lub().tys(t1, t2) {\n-            Err(e) => {\n-                fail!(\"unexpected error computing LUB: %?\", e)\n-            }\n             Ok(t) => {\n                 self.assert_eq(t, t_lub);\n-\n-                // sanity check for good measure:\n-                self.assert_subtype(t1, t);\n-                self.assert_subtype(t2, t);\n-\n-                self.resolve_regions(0);\n+            }\n+            Err(ref e) => {\n+                fail!(\"unexpected error in LUB: {}\",\n+                      ty::type_err_to_str(self.tcx, e))\n             }\n         }\n     }\n \n     /// Checks that `GLB(t1,t2) == t_glb`\n     pub fn check_glb(&self, t1: ty::t, t2: ty::t, t_glb: ty::t) {\n-        debug!(\"check_glb(t1=%s, t2=%s, t_glb=%s)\",\n+        debug!(\"check_glb(t1={}, t2={}, t_glb={})\",\n                self.ty_to_str(t1),\n                self.ty_to_str(t2),\n                self.ty_to_str(t_glb));\n         match self.glb().tys(t1, t2) {\n             Err(e) => {\n-                fail!(\"unexpected error computing LUB: %?\", e)\n+                fail!(\"unexpected error computing LUB: {:?}\", e)\n             }\n             Ok(t) => {\n                 self.assert_eq(t, t_glb);\n \n                 // sanity check for good measure:\n                 self.assert_subtype(t, t1);\n                 self.assert_subtype(t, t2);\n-\n-                self.resolve_regions(0);\n             }\n         }\n     }\n@@ -281,7 +353,7 @@ impl Env {\n         match self.lub().tys(t1, t2) {\n             Err(_) => {}\n             Ok(t) => {\n-                fail!(\"unexpected success computing LUB: %?\", self.ty_to_str(t))\n+                fail!(\"unexpected success computing LUB: {}\", self.ty_to_str(t))\n             }\n         }\n     }\n@@ -291,120 +363,151 @@ impl Env {\n         match self.glb().tys(t1, t2) {\n             Err(_) => {}\n             Ok(t) => {\n-                fail!(\"unexpected success computing GLB: %?\", self.ty_to_str(t))\n+                fail!(\"unexpected success computing GLB: {}\", self.ty_to_str(t))\n             }\n         }\n     }\n }\n \n #[test]\n-fn contravariant_region_ptr() {\n-    let env = setup_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR);\n-    env.create_simple_region_hierarchy();\n-    let t_rptr1 = env.t_rptr_scope(1);\n-    let t_rptr10 = env.t_rptr_scope(10);\n-    env.assert_eq(t_rptr1, t_rptr1);\n-    env.assert_eq(t_rptr10, t_rptr10);\n-    env.assert_strict_subtype(t_rptr1, t_rptr10);\n+fn contravariant_region_ptr_ok() {\n+    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors([]), |env| {\n+        env.create_simple_region_hierarchy();\n+        let t_rptr1 = env.t_rptr_scope(1);\n+        let t_rptr10 = env.t_rptr_scope(10);\n+        env.assert_eq(t_rptr1, t_rptr1);\n+        env.assert_eq(t_rptr10, t_rptr10);\n+        env.make_subtype(t_rptr1, t_rptr10);\n+    })\n+}\n+\n+#[test]\n+fn contravariant_region_ptr_err() {\n+    test_env(\"contravariant_region_ptr\",\n+             EMPTY_SOURCE_STR,\n+             errors([\"lifetime mismatch\"]),\n+             |env| {\n+                 env.create_simple_region_hierarchy();\n+                 let t_rptr1 = env.t_rptr_scope(1);\n+                 let t_rptr10 = env.t_rptr_scope(10);\n+                 env.assert_eq(t_rptr1, t_rptr1);\n+                 env.assert_eq(t_rptr10, t_rptr10);\n+\n+                 // will cause an error when regions are resolved\n+                 env.make_subtype(t_rptr10, t_rptr1);\n+             })\n }\n \n #[test]\n fn lub_bound_bound() {\n-    let env = setup_env(\"lub_bound_bound\", EMPTY_SOURCE_STR);\n-    let t_rptr_bound1 = env.t_rptr_bound(1);\n-    let t_rptr_bound2 = env.t_rptr_bound(2);\n-    env.check_lub(env.t_fn([t_rptr_bound1], env.t_int()),\n-                  env.t_fn([t_rptr_bound2], env.t_int()),\n-                  env.t_fn([t_rptr_bound1], env.t_int()));\n+    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors([]), |env| {\n+        let t_rptr_bound1 = env.t_rptr_late_bound(22, 1);\n+        let t_rptr_bound2 = env.t_rptr_late_bound(22, 2);\n+        env.check_lub(env.t_fn(22, [t_rptr_bound1], env.t_int()),\n+                      env.t_fn(22, [t_rptr_bound2], env.t_int()),\n+                      env.t_fn(22, [t_rptr_bound1], env.t_int()));\n+    })\n }\n \n #[test]\n fn lub_bound_free() {\n-    let env = setup_env(\"lub_bound_free\", EMPTY_SOURCE_STR);\n-    let t_rptr_bound1 = env.t_rptr_bound(1);\n-    let t_rptr_free1 = env.t_rptr_free(0, 1);\n-    env.check_lub(env.t_fn([t_rptr_bound1], env.t_int()),\n-                  env.t_fn([t_rptr_free1], env.t_int()),\n-                  env.t_fn([t_rptr_free1], env.t_int()));\n+    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors([]), |env| {\n+        let t_rptr_bound1 = env.t_rptr_late_bound(22, 1);\n+        let t_rptr_free1 = env.t_rptr_free(0, 1);\n+        env.check_lub(env.t_fn(22, [t_rptr_bound1], env.t_int()),\n+                      env.t_fn(22, [t_rptr_free1], env.t_int()),\n+                      env.t_fn(22, [t_rptr_free1], env.t_int()));\n+    })\n }\n \n #[test]\n fn lub_bound_static() {\n-    let env = setup_env(\"lub_bound_static\", EMPTY_SOURCE_STR);\n-    let t_rptr_bound1 = env.t_rptr_bound(1);\n-    let t_rptr_static = env.t_rptr_static();\n-    env.check_lub(env.t_fn([t_rptr_bound1], env.t_int()),\n-                  env.t_fn([t_rptr_static], env.t_int()),\n-                  env.t_fn([t_rptr_static], env.t_int()));\n+    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors([]), |env| {\n+        let t_rptr_bound1 = env.t_rptr_late_bound(22, 1);\n+        let t_rptr_static = env.t_rptr_static();\n+        env.check_lub(env.t_fn(22, [t_rptr_bound1], env.t_int()),\n+                      env.t_fn(22, [t_rptr_static], env.t_int()),\n+                      env.t_fn(22, [t_rptr_static], env.t_int()));\n+    })\n }\n \n #[test]\n fn lub_bound_bound_inverse_order() {\n-    let env = setup_env(\"lub_bound_bound_inverse_order\", EMPTY_SOURCE_STR);\n-    let t_rptr_bound1 = env.t_rptr_bound(1);\n-    let t_rptr_bound2 = env.t_rptr_bound(2);\n-    env.check_lub(env.t_fn([t_rptr_bound1, t_rptr_bound2], t_rptr_bound1),\n-                  env.t_fn([t_rptr_bound2, t_rptr_bound1], t_rptr_bound1),\n-                  env.t_fn([t_rptr_bound1, t_rptr_bound1], t_rptr_bound1));\n+    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors([]), |env| {\n+        let t_rptr_bound1 = env.t_rptr_late_bound(22, 1);\n+        let t_rptr_bound2 = env.t_rptr_late_bound(22, 2);\n+        env.check_lub(env.t_fn(22, [t_rptr_bound1, t_rptr_bound2], t_rptr_bound1),\n+                      env.t_fn(22, [t_rptr_bound2, t_rptr_bound1], t_rptr_bound1),\n+                      env.t_fn(22, [t_rptr_bound1, t_rptr_bound1], t_rptr_bound1));\n+    })\n }\n \n #[test]\n fn lub_free_free() {\n-    let env = setup_env(\"lub_free_free\", EMPTY_SOURCE_STR);\n-    let t_rptr_free1 = env.t_rptr_free(0, 1);\n-    let t_rptr_free2 = env.t_rptr_free(0, 2);\n-    let t_rptr_static = env.t_rptr_static();\n-    env.check_lub(env.t_fn([t_rptr_free1], env.t_int()),\n-                  env.t_fn([t_rptr_free2], env.t_int()),\n-                  env.t_fn([t_rptr_static], env.t_int()));\n+    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors([]), |env| {\n+        let t_rptr_free1 = env.t_rptr_free(0, 1);\n+        let t_rptr_free2 = env.t_rptr_free(0, 2);\n+        let t_rptr_static = env.t_rptr_static();\n+        env.check_lub(env.t_fn(22, [t_rptr_free1], env.t_int()),\n+                      env.t_fn(22, [t_rptr_free2], env.t_int()),\n+                      env.t_fn(22, [t_rptr_static], env.t_int()));\n+    })\n }\n \n #[test]\n fn lub_returning_scope() {\n-    let env = setup_env(\"lub_returning_scope\", EMPTY_SOURCE_STR);\n-    let t_rptr_scope10 = env.t_rptr_scope(10);\n-    let t_rptr_scope11 = env.t_rptr_scope(11);\n-    env.check_no_lub(env.t_fn([], t_rptr_scope10),\n-                     env.t_fn([], t_rptr_scope11));\n+    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR,\n+             errors([\"cannot infer an appropriate lifetime\"]), |env| {\n+                 let t_rptr_scope10 = env.t_rptr_scope(10);\n+                 let t_rptr_scope11 = env.t_rptr_scope(11);\n+\n+                 // this should generate an error when regions are resolved\n+                 env.make_lub_ty(env.t_fn(22, [], t_rptr_scope10),\n+                                 env.t_fn(22, [], t_rptr_scope11));\n+             })\n }\n \n #[test]\n fn glb_free_free_with_common_scope() {\n-    let env = setup_env(\"glb_free_free\", EMPTY_SOURCE_STR);\n-    let t_rptr_free1 = env.t_rptr_free(0, 1);\n-    let t_rptr_free2 = env.t_rptr_free(0, 2);\n-    let t_rptr_scope = env.t_rptr_scope(0);\n-    env.check_glb(env.t_fn([t_rptr_free1], env.t_int()),\n-                  env.t_fn([t_rptr_free2], env.t_int()),\n-                  env.t_fn([t_rptr_scope], env.t_int()));\n+    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors([]), |env| {\n+        let t_rptr_free1 = env.t_rptr_free(0, 1);\n+        let t_rptr_free2 = env.t_rptr_free(0, 2);\n+        let t_rptr_scope = env.t_rptr_scope(0);\n+        env.check_glb(env.t_fn(22, [t_rptr_free1], env.t_int()),\n+                      env.t_fn(22, [t_rptr_free2], env.t_int()),\n+                      env.t_fn(22, [t_rptr_scope], env.t_int()));\n+    })\n }\n \n #[test]\n fn glb_bound_bound() {\n-    let env = setup_env(\"glb_bound_bound\", EMPTY_SOURCE_STR);\n-    let t_rptr_bound1 = env.t_rptr_bound(1);\n-    let t_rptr_bound2 = env.t_rptr_bound(2);\n-    env.check_glb(env.t_fn([t_rptr_bound1], env.t_int()),\n-                  env.t_fn([t_rptr_bound2], env.t_int()),\n-                  env.t_fn([t_rptr_bound1], env.t_int()));\n+    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors([]), |env| {\n+        let t_rptr_bound1 = env.t_rptr_late_bound(22, 1);\n+        let t_rptr_bound2 = env.t_rptr_late_bound(22, 2);\n+        env.check_glb(env.t_fn(22, [t_rptr_bound1], env.t_int()),\n+                      env.t_fn(22, [t_rptr_bound2], env.t_int()),\n+                      env.t_fn(22, [t_rptr_bound1], env.t_int()));\n+    })\n }\n \n #[test]\n fn glb_bound_free() {\n-    let env = setup_env(\"glb_bound_free\", EMPTY_SOURCE_STR);\n-    let t_rptr_bound1 = env.t_rptr_bound(1);\n-    let t_rptr_free1 = env.t_rptr_free(0, 1);\n-    env.check_glb(env.t_fn([t_rptr_bound1], env.t_int()),\n-                  env.t_fn([t_rptr_free1], env.t_int()),\n-                  env.t_fn([t_rptr_bound1], env.t_int()));\n+    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors([]), |env| {\n+        let t_rptr_bound1 = env.t_rptr_late_bound(22, 1);\n+        let t_rptr_free1 = env.t_rptr_free(0, 1);\n+        env.check_glb(env.t_fn(22, [t_rptr_bound1], env.t_int()),\n+                      env.t_fn(22, [t_rptr_free1], env.t_int()),\n+                      env.t_fn(22, [t_rptr_bound1], env.t_int()));\n+    })\n }\n \n #[test]\n fn glb_bound_static() {\n-    let env = setup_env(\"glb_bound_static\", EMPTY_SOURCE_STR);\n-    let t_rptr_bound1 = env.t_rptr_bound(1);\n-    let t_rptr_static = env.t_rptr_static();\n-    env.check_glb(env.t_fn([t_rptr_bound1], env.t_int()),\n-                  env.t_fn([t_rptr_static], env.t_int()),\n-                  env.t_fn([t_rptr_bound1], env.t_int()));\n+    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors([]), |env| {\n+        let t_rptr_bound1 = env.t_rptr_late_bound(22, 1);\n+        let t_rptr_static = env.t_rptr_static();\n+        env.check_glb(env.t_fn(22, [t_rptr_bound1], env.t_int()),\n+                      env.t_fn(22, [t_rptr_static], env.t_int()),\n+                      env.t_fn(22, [t_rptr_bound1], env.t_int()));\n+    })\n }"}, {"sha": "097c5dcfedaa34a5cc81af93ff2e5acd41b69a1c", "filename": "src/librustc/middle/typeck/infer/to_str.rs", "status": "removed", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=4c39962d325c09849e9cbb1828f85028f29fcea3", "patch": "@@ -1,96 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-use middle::ty::{FnSig, Vid};\n-use middle::ty::IntVarValue;\n-use middle::ty;\n-use middle::typeck::infer::{Bound, Bounds};\n-use middle::typeck::infer::InferCtxt;\n-use middle::typeck::infer::unify::{Redirect, Root, VarValue};\n-use util::ppaux::{mt_to_str, ty_to_str, trait_ref_to_str};\n-\n-use syntax::ast;\n-\n-pub trait InferStr {\n-    fn inf_str(&self, cx: &InferCtxt) -> String;\n-}\n-\n-impl InferStr for ty::t {\n-    fn inf_str(&self, cx: &InferCtxt) -> String {\n-        ty_to_str(cx.tcx, *self)\n-    }\n-}\n-\n-impl InferStr for FnSig {\n-    fn inf_str(&self, cx: &InferCtxt) -> String {\n-        format!(\"({}) -> {}\",\n-                self.inputs.iter()\n-                    .map(|a| a.inf_str(cx))\n-                    .collect::<Vec<String>>().connect(\", \"),\n-                self.output.inf_str(cx))\n-    }\n-}\n-\n-impl InferStr for ty::mt {\n-    fn inf_str(&self, cx: &InferCtxt) -> String {\n-        mt_to_str(cx.tcx, self)\n-    }\n-}\n-\n-impl InferStr for ty::Region {\n-    fn inf_str(&self, _cx: &InferCtxt) -> String {\n-        format!(\"{:?}\", *self)\n-    }\n-}\n-\n-impl<V:InferStr> InferStr for Bound<V> {\n-    fn inf_str(&self, cx: &InferCtxt) -> String {\n-        match *self {\n-            Some(ref v) => v.inf_str(cx),\n-            None => \"none\".to_string()\n-        }\n-    }\n-}\n-\n-impl<T:InferStr> InferStr for Bounds<T> {\n-    fn inf_str(&self, cx: &InferCtxt) -> String {\n-        format!(\"{{{} <: {}}}\", self.lb.inf_str(cx), self.ub.inf_str(cx))\n-    }\n-}\n-\n-impl<V:Vid + ToStr,T:InferStr> InferStr for VarValue<V, T> {\n-    fn inf_str(&self, cx: &InferCtxt) -> String {\n-        match *self {\n-          Redirect(ref vid) => format!(\"Redirect({})\", vid.to_str()),\n-          Root(ref pt, rk) => {\n-              format!(\"Root({}, {})\", pt.inf_str(cx), rk)\n-          }\n-        }\n-    }\n-}\n-\n-impl InferStr for IntVarValue {\n-    fn inf_str(&self, _cx: &InferCtxt) -> String {\n-        self.to_str()\n-    }\n-}\n-\n-impl InferStr for ast::FloatTy {\n-    fn inf_str(&self, _cx: &InferCtxt) -> String {\n-        self.to_str()\n-    }\n-}\n-\n-impl InferStr for ty::TraitRef {\n-    fn inf_str(&self, cx: &InferCtxt) -> String {\n-        trait_ref_to_str(cx.tcx, self)\n-    }\n-}"}, {"sha": "f106ce18a4adb579bbed9edf275acd10b430d746", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 423, "deletions": 184, "changes": 607, "blob_url": "https://github.com/rust-lang/rust/blob/020373f2c807627274a53251a7841f0e9617e98e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/020373f2c807627274a53251a7841f0e9617e98e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=020373f2c807627274a53251a7841f0e9617e98e", "patch": "@@ -8,179 +8,372 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::kinds::marker;\n \n-use std::collections::SmallIntMap;\n-\n-use middle::ty::{Vid, expected_found, IntVarValue};\n+use middle::ty::{expected_found, IntVarValue};\n use middle::ty;\n use middle::typeck::infer::{Bounds, uok, ures};\n use middle::typeck::infer::InferCtxt;\n-use middle::typeck::infer::to_str::InferStr;\n use std::cell::RefCell;\n+use std::fmt::Show;\n+use std::mem;\n use syntax::ast;\n+use util::ppaux::Repr;\n+\n+/**\n+ * This trait is implemented by any type that can serve as a type\n+ * variable. We call such variables *unification keys*. For example,\n+ * this trait is implemented by `TyVid`, which represents normal\n+ * type variables, and `IntVid`, which represents integral variables.\n+ *\n+ * Each key type has an associated value type `V`. For example,\n+ * for `TyVid`, this is `Bounds<ty::t>`, representing a pair of\n+ * upper- and lower-bound types.\n+ *\n+ * Implementations of this trait are at the end of this file.\n+ */\n+pub trait UnifyKey<V> : Clone + Show + PartialEq + Repr {\n+    fn index(&self) -> uint;\n+\n+    fn from_index(u: uint) -> Self;\n+\n+    /**\n+     * Given an inference context, returns the unification table\n+     * appropriate to this key type.\n+     */\n+    fn unification_table<'v>(infcx: &'v InferCtxt)\n+                             -> &'v RefCell<UnificationTable<Self,V>>;\n+\n+    fn tag(k: Option<Self>) -> &'static str;\n+}\n \n-#[deriving(Clone)]\n-pub enum VarValue<V, T> {\n-    Redirect(V),\n-    Root(T, uint),\n+/**\n+ * Trait for valid types that a type variable can be set to.  Note\n+ * that this is typically not the end type that the value will\n+ * take on, but rather some wrapper: for example, for normal type\n+ * variables, the associated type is not `ty::t` but rather\n+ * `Bounds<ty::t>`.\n+ *\n+ * Implementations of this trait are at the end of this file.\n+ */\n+pub trait UnifyValue : Clone + Repr + PartialEq {\n }\n \n-pub struct ValsAndBindings<V, T> {\n-    pub vals: SmallIntMap<VarValue<V, T>>,\n-    pub bindings: Vec<(V, VarValue<V, T>)> ,\n+/**\n+ * Value of a unification key. We implement Tarjan's union-find\n+ * algorithm: when two keys are unified, one of them is converted\n+ * into a \"redirect\" pointing at the other. These redirects form a\n+ * DAG: the roots of the DAG (nodes that are not redirected) are each\n+ * associated with a value of type `V` and a rank. The rank is used\n+ * to keep the DAG relatively balanced, which helps keep the running\n+ * time of the algorithm under control. For more information, see\n+ * <http://en.wikipedia.org/wiki/Disjoint-set_data_structure>.\n+ */\n+#[deriving(PartialEq,Clone)]\n+pub enum VarValue<K,V> {\n+    Redirect(K),\n+    Root(V, uint),\n }\n \n-impl<V:Clone, T:Clone> ValsAndBindings<V, T> {\n-    pub fn new() -> ValsAndBindings<V, T> {\n-        ValsAndBindings {\n-            vals: SmallIntMap::new(),\n-            bindings: Vec::new()\n-        }\n-    }\n+/**\n+ * Table of unification keys and their values.\n+ */\n+pub struct UnificationTable<K,V> {\n+    /**\n+     * Indicates the current value of each key.\n+     */\n+    values: Vec<VarValue<K,V>>,\n+\n+    /**\n+     * When a snapshot is active, logs each change made to the table\n+     * so that they can be unrolled.\n+     */\n+    undo_log: Vec<UndoLog<K,V>>,\n }\n \n-pub struct Node<V, T> {\n-    pub root: V,\n-    pub possible_types: T,\n-    pub rank: uint,\n+/**\n+ * At any time, users may snapshot a unification table.  The changes\n+ * made during the snapshot may either be *commited* or *rolled back*.\n+ */\n+pub struct Snapshot<K> {\n+    // Ensure that this snapshot is keyed to the table type.\n+    marker1: marker::CovariantType<K>,\n+\n+    // Snapshots are tokens that should be created/consumed linearly.\n+    marker2: marker::NoCopy,\n+\n+    // Length of the undo log at the time the snapshot was taken.\n+    length: uint,\n }\n \n-pub trait UnifyVid<T> {\n-    fn appropriate_vals_and_bindings<'v>(infcx: &'v InferCtxt)\n-                                     -> &'v RefCell<ValsAndBindings<Self, T>>;\n+#[deriving(PartialEq)]\n+enum UndoLog<K,V> {\n+    /// Indicates where a snapshot started.\n+    OpenSnapshot,\n+\n+    /// Indicates a snapshot that has been committed.\n+    CommittedSnapshot,\n+\n+    /// New variable with given index was created.\n+    NewVar(uint),\n+\n+    /// Variable with given index was changed *from* the given value.\n+    SetVar(uint, VarValue<K,V>),\n }\n \n-pub trait UnifyInferCtxtMethods {\n-    fn get<T:Clone,\n-           V:Clone + PartialEq + Vid + UnifyVid<T>>(\n-           &self,\n-           vid: V)\n-           -> Node<V, T>;\n-    fn set<T:Clone + InferStr,\n-           V:Clone + Vid + ToStr + UnifyVid<T>>(\n-           &self,\n-           vid: V,\n-           new_v: VarValue<V, T>);\n-    fn unify<T:Clone + InferStr,\n-             V:Clone + Vid + ToStr + UnifyVid<T>>(\n-             &self,\n-             node_a: &Node<V, T>,\n-             node_b: &Node<V, T>)\n-             -> (V, uint);\n+/**\n+ * Internal type used to represent the result of a `get()` operation.\n+ * Conveys the current root and value of the key.\n+ */\n+pub struct Node<K,V> {\n+    pub key: K,\n+    pub value: V,\n+    pub rank: uint,\n }\n \n-impl<'a> UnifyInferCtxtMethods for InferCtxt<'a> {\n-    fn get<T:Clone,\n-           V:Clone + PartialEq + Vid + UnifyVid<T>>(\n-           &self,\n-           vid: V)\n-           -> Node<V, T> {\n+// We can't use V:LatticeValue, much as I would like to,\n+// because frequently the pattern is that V=Bounds<U> for some\n+// other type parameter U, and we have no way to say\n+// Bounds<U>:\n+\n+impl<V:PartialEq+Clone+Repr,K:UnifyKey<V>> UnificationTable<K,V> {\n+    pub fn new() -> UnificationTable<K,V> {\n+        UnificationTable {\n+            values: Vec::new(),\n+            undo_log: Vec::new()\n+        }\n+    }\n+\n+    pub fn in_snapshot(&self) -> bool {\n+        /*! True if a snapshot has been started. */\n+\n+        self.undo_log.len() > 0\n+    }\n+\n+    /**\n+     * Starts a new snapshot. Each snapshot must be either\n+     * rolled back or commited in a \"LIFO\" (stack) order.\n+     */\n+    pub fn snapshot(&mut self) -> Snapshot<K> {\n+        let length = self.undo_log.len();\n+        debug!(\"{}: snapshot at length {}\",\n+               UnifyKey::tag(None::<K>),\n+               length);\n+        self.undo_log.push(OpenSnapshot);\n+        Snapshot { length: length,\n+                   marker1: marker::CovariantType,\n+                   marker2: marker::NoCopy }\n+    }\n+\n+    fn assert_open_snapshot(&self, snapshot: &Snapshot<K>) {\n+        // Or else there was a failure to follow a stack discipline:\n+        assert!(self.undo_log.len() > snapshot.length);\n+\n+        // Invariant established by start_snapshot():\n+        assert!(*self.undo_log.get(snapshot.length) == OpenSnapshot);\n+    }\n+\n+    /**\n+     * Reverses all changes since the last snapshot. Also\n+     * removes any keys that have been created since then.\n+     */\n+    pub fn rollback_to(&mut self, tcx: &ty::ctxt, snapshot: Snapshot<K>) {\n+        debug!(\"{}: rollback_to({})\",\n+               UnifyKey::tag(None::<K>),\n+               snapshot.length);\n+\n+        self.assert_open_snapshot(&snapshot);\n+\n+        while self.undo_log.len() > snapshot.length + 1 {\n+            match self.undo_log.pop().unwrap() {\n+                OpenSnapshot => {\n+                    // This indicates a failure to obey the stack discipline.\n+                    tcx.sess.bug(\"Cannot rollback an uncommited snapshot\");\n+                }\n+\n+                CommittedSnapshot => {\n+                    // This occurs when there are nested snapshots and\n+                    // the inner is commited but outer is rolled back.\n+                }\n+\n+                NewVar(i) => {\n+                    assert!(self.values.len() == i);\n+                    self.values.pop();\n+                }\n+\n+                SetVar(i, v) => {\n+                    *self.values.get_mut(i) = v;\n+                }\n+            }\n+        }\n+\n+        let v = self.undo_log.pop().unwrap();\n+        assert!(v == OpenSnapshot);\n+        assert!(self.undo_log.len() == snapshot.length);\n+    }\n+\n+    /**\n+     * Commits all changes since the last snapshot. Of course, they\n+     * can still be undone if there is a snapshot further out.\n+     */\n+    pub fn commit(&mut self, snapshot: Snapshot<K>) {\n+        debug!(\"{}: commit({})\",\n+               UnifyKey::tag(None::<K>),\n+               snapshot.length);\n+\n+        self.assert_open_snapshot(&snapshot);\n+\n+        if snapshot.length == 0 {\n+            // The root snapshot.\n+            self.undo_log.truncate(0);\n+        } else {\n+            *self.undo_log.get_mut(snapshot.length) = CommittedSnapshot;\n+        }\n+    }\n+\n+    pub fn new_key(&mut self, value: V) -> K {\n+        let index = self.values.len();\n+\n+        if self.in_snapshot() {\n+            self.undo_log.push(NewVar(index));\n+        }\n+\n+        self.values.push(Root(value, 0));\n+        let k = UnifyKey::from_index(index);\n+        debug!(\"{}: created new key: {}\",\n+               UnifyKey::tag(None::<K>),\n+               k);\n+        k\n+    }\n+\n+    fn swap_value(&mut self,\n+                  index: uint,\n+                  new_value: VarValue<K,V>)\n+                  -> VarValue<K,V>\n+    {\n+        /*!\n+         * Primitive operation to swap a value in the var array.\n+         * Caller should update the undo log if we are in a snapshot.\n+         */\n+\n+        let loc = self.values.get_mut(index);\n+        mem::replace(loc, new_value)\n+    }\n+\n+    pub fn get(&mut self, tcx: &ty::ctxt, vid: K) -> Node<K,V> {\n         /*!\n-         *\n          * Find the root node for `vid`. This uses the standard\n          * union-find algorithm with path compression:\n          * http://en.wikipedia.org/wiki/Disjoint-set_data_structure\n          */\n \n-        let tcx = self.tcx;\n-        let vb = UnifyVid::appropriate_vals_and_bindings(self);\n-        return helper(tcx, &mut *vb.borrow_mut(), vid);\n-\n-        fn helper<T:Clone, V:Clone+PartialEq+Vid>(\n-            tcx: &ty::ctxt,\n-            vb: &mut ValsAndBindings<V,T>,\n-            vid: V) -> Node<V, T>\n-        {\n-            let vid_u = vid.to_uint();\n-            let var_val = match vb.vals.find(&vid_u) {\n-                Some(&ref var_val) => (*var_val).clone(),\n-                None => {\n-                    tcx.sess.bug(format!(\n-                        \"failed lookup of vid `{}`\", vid_u).as_slice());\n-                }\n-            };\n-            match var_val {\n-                Redirect(vid) => {\n-                    let node: Node<V,T> = helper(tcx, vb, vid.clone());\n-                    if node.root != vid {\n-                        // Path compression\n-                        vb.vals.insert(vid.to_uint(),\n-                                       Redirect(node.root.clone()));\n+        let index = vid.index();\n+        let value = (*self.values.get(index)).clone();\n+        match value {\n+            Redirect(redirect) => {\n+                let node: Node<K,V> = self.get(tcx, redirect.clone());\n+                if node.key != redirect {\n+                    // Path compression\n+                    let old_value =\n+                        self.swap_value(index, Redirect(node.key.clone()));\n+\n+                    // If we are in a snapshot, record this compression,\n+                    // because it's possible that the unification which\n+                    // caused it will be rolled back later.\n+                    if self.in_snapshot() {\n+                        self.undo_log.push(SetVar(index, old_value));\n                     }\n-                    node\n-                }\n-                Root(pt, rk) => {\n-                    Node {root: vid, possible_types: pt, rank: rk}\n                 }\n+                node\n             }\n+            Root(value, rank) => {\n+                Node { key: vid, value: value, rank: rank }\n+            }\n+        }\n+    }\n+\n+    fn is_root(&self, key: &K) -> bool {\n+        match *self.values.get(key.index()) {\n+            Redirect(..) => false,\n+            Root(..) => true,\n         }\n     }\n \n-    fn set<T:Clone + InferStr,\n-           V:Clone + Vid + ToStr + UnifyVid<T>>(\n-           &self,\n-           vid: V,\n-           new_v: VarValue<V, T>) {\n+    pub fn set(&mut self,\n+               tcx: &ty::ctxt,\n+               key: K,\n+               new_value: VarValue<K,V>)\n+    {\n         /*!\n-         *\n-         * Sets the value for `vid` to `new_v`.  `vid` MUST be a root node!\n+         * Sets the value for `vid` to `new_value`. `vid` MUST be a\n+         * root node! Also, we must be in the middle of a snapshot.\n          */\n \n+        assert!(self.is_root(&key));\n+        assert!(self.in_snapshot());\n+\n         debug!(\"Updating variable {} to {}\",\n-               vid.to_str(), new_v.inf_str(self));\n+               key.repr(tcx),\n+               new_value.repr(tcx));\n \n-        let vb = UnifyVid::appropriate_vals_and_bindings(self);\n-        let mut vb = vb.borrow_mut();\n-        let old_v = (*vb.vals.get(&vid.to_uint())).clone();\n-        vb.bindings.push((vid.clone(), old_v));\n-        vb.vals.insert(vid.to_uint(), new_v);\n+        let index = key.index();\n+        let old_value = self.swap_value(index, new_value);\n+        self.undo_log.push(SetVar(index, old_value));\n     }\n \n-    fn unify<T:Clone + InferStr,\n-             V:Clone + Vid + ToStr + UnifyVid<T>>(\n-             &self,\n-             node_a: &Node<V, T>,\n-             node_b: &Node<V, T>)\n-             -> (V, uint) {\n-        // Rank optimization: if you don't know what it is, check\n-        // out <http://en.wikipedia.org/wiki/Disjoint-set_data_structure>\n+    pub fn unify(&mut self,\n+                 tcx: &ty::ctxt,\n+                 node_a: &Node<K,V>,\n+                 node_b: &Node<K,V>)\n+                 -> (K, uint)\n+    {\n+        /*!\n+         * Either redirects node_a to node_b or vice versa, depending\n+         * on the relative rank. Returns the new root and rank.  You\n+         * should then update the value of the new root to something\n+         * suitable.\n+         */\n \n-        debug!(\"unify(node_a(id={:?}, rank={:?}), \\\n-                node_b(id={:?}, rank={:?}))\",\n-               node_a.root, node_a.rank,\n-               node_b.root, node_b.rank);\n+        debug!(\"unify(node_a(id={}, rank={}), node_b(id={}, rank={}))\",\n+               node_a.key.repr(tcx),\n+               node_a.rank,\n+               node_b.key.repr(tcx),\n+               node_b.rank);\n \n         if node_a.rank > node_b.rank {\n             // a has greater rank, so a should become b's parent,\n             // i.e., b should redirect to a.\n-            self.set(node_b.root.clone(), Redirect(node_a.root.clone()));\n-            (node_a.root.clone(), node_a.rank)\n+            self.set(tcx, node_b.key.clone(), Redirect(node_a.key.clone()));\n+            (node_a.key.clone(), node_a.rank)\n         } else if node_a.rank < node_b.rank {\n             // b has greater rank, so a should redirect to b.\n-            self.set(node_a.root.clone(), Redirect(node_b.root.clone()));\n-            (node_b.root.clone(), node_b.rank)\n+            self.set(tcx, node_a.key.clone(), Redirect(node_b.key.clone()));\n+            (node_b.key.clone(), node_b.rank)\n         } else {\n             // If equal, redirect one to the other and increment the\n             // other's rank.\n             assert_eq!(node_a.rank, node_b.rank);\n-            self.set(node_b.root.clone(), Redirect(node_a.root.clone()));\n-            (node_a.root.clone(), node_a.rank + 1)\n+            self.set(tcx, node_b.key.clone(), Redirect(node_a.key.clone()));\n+            (node_a.key.clone(), node_a.rank + 1)\n         }\n     }\n-\n }\n \n-// ______________________________________________________________________\n-// Code to handle simple variables like ints, floats---anything that\n+///////////////////////////////////////////////////////////////////////////\n+// Code to handle simple keys like ints, floats---anything that\n // doesn't have a subtyping relationship we need to worry about.\n \n-pub trait SimplyUnifiable {\n+/**\n+ * Indicates a type that does not have any kind of subtyping\n+ * relationship.\n+ */\n+pub trait SimplyUnifiable : Clone + PartialEq + Repr {\n     fn to_type_err(expected_found<Self>) -> ty::type_err;\n }\n \n-pub fn mk_err<T:SimplyUnifiable>(a_is_expected: bool,\n-                                 a_t: T,\n-                                 b_t: T) -> ures {\n+pub fn err<V:SimplyUnifiable>(a_is_expected: bool,\n+                              a_t: V,\n+                              b_t: V) -> ures {\n     if a_is_expected {\n         Err(SimplyUnifiable::to_type_err(\n             ty::expected_found {expected: a_t, found: b_t}))\n@@ -190,111 +383,141 @@ pub fn mk_err<T:SimplyUnifiable>(a_is_expected: bool,\n     }\n }\n \n-pub trait InferCtxtMethods {\n-    fn simple_vars<T:Clone + PartialEq + InferStr + SimplyUnifiable,\n-                   V:Clone + PartialEq + Vid + ToStr + UnifyVid<Option<T>>>(\n-                   &self,\n+pub trait InferCtxtMethodsForSimplyUnifiableTypes<V:SimplyUnifiable,\n+                                                  K:UnifyKey<Option<V>>> {\n+    fn simple_vars(&self,\n                    a_is_expected: bool,\n-                   a_id: V,\n-                   b_id: V)\n+                   a_id: K,\n+                   b_id: K)\n                    -> ures;\n-    fn simple_var_t<T:Clone + PartialEq + InferStr + SimplyUnifiable,\n-                    V:Clone + PartialEq + Vid + ToStr + UnifyVid<Option<T>>>(\n-                    &self,\n+    fn simple_var_t(&self,\n                     a_is_expected: bool,\n-                    a_id: V,\n-                    b: T)\n+                    a_id: K,\n+                    b: V)\n                     -> ures;\n }\n \n-impl<'a> InferCtxtMethods for InferCtxt<'a> {\n-    fn simple_vars<T:Clone + PartialEq + InferStr + SimplyUnifiable,\n-                   V:Clone + PartialEq + Vid + ToStr + UnifyVid<Option<T>>>(\n-                   &self,\n+impl<'tcx,V:SimplyUnifiable,K:UnifyKey<Option<V>>>\n+    InferCtxtMethodsForSimplyUnifiableTypes<V,K> for InferCtxt<'tcx>\n+{\n+    fn simple_vars(&self,\n                    a_is_expected: bool,\n-                   a_id: V,\n-                   b_id: V)\n-                   -> ures {\n+                   a_id: K,\n+                   b_id: K)\n+                   -> ures\n+    {\n         /*!\n-         *\n-         * Unifies two simple variables.  Because simple variables do\n-         * not have any subtyping relationships, if both variables\n+         * Unifies two simple keys.  Because simple keys do\n+         * not have any subtyping relationships, if both keys\n          * have already been associated with a value, then those two\n-         * values must be the same. */\n+         * values must be the same.\n+         */\n \n-        let node_a = self.get(a_id);\n-        let node_b = self.get(b_id);\n-        let a_id = node_a.root.clone();\n-        let b_id = node_b.root.clone();\n+        let tcx = self.tcx;\n+        let table = UnifyKey::unification_table(self);\n+        let node_a = table.borrow_mut().get(tcx, a_id);\n+        let node_b = table.borrow_mut().get(tcx, b_id);\n+        let a_id = node_a.key.clone();\n+        let b_id = node_b.key.clone();\n \n         if a_id == b_id { return uok(); }\n \n-        let combined = match (&node_a.possible_types, &node_b.possible_types)\n-        {\n-            (&None, &None) => None,\n-            (&Some(ref v), &None) | (&None, &Some(ref v)) => {\n-                Some((*v).clone())\n-            }\n-            (&Some(ref v1), &Some(ref v2)) => {\n-                if *v1 != *v2 {\n-                    return mk_err(a_is_expected, (*v1).clone(), (*v2).clone())\n+        let combined = {\n+            match (&node_a.value, &node_b.value) {\n+                (&None, &None) => {\n+                    None\n+                }\n+                (&Some(ref v), &None) | (&None, &Some(ref v)) => {\n+                    Some((*v).clone())\n+                }\n+                (&Some(ref v1), &Some(ref v2)) => {\n+                    if *v1 != *v2 {\n+                        return err(a_is_expected, (*v1).clone(), (*v2).clone())\n+                    }\n+                    Some((*v1).clone())\n                 }\n-                Some((*v1).clone())\n             }\n         };\n \n-        let (new_root, new_rank) = self.unify(&node_a, &node_b);\n-        self.set(new_root, Root(combined, new_rank));\n-        return uok();\n+        let (new_root, new_rank) = table.borrow_mut().unify(tcx,\n+                                                            &node_a,\n+                                                            &node_b);\n+        table.borrow_mut().set(tcx, new_root, Root(combined, new_rank));\n+        return Ok(())\n     }\n \n-    fn simple_var_t<T:Clone + PartialEq + InferStr + SimplyUnifiable,\n-                    V:Clone + PartialEq + Vid + ToStr + UnifyVid<Option<T>>>(\n-                    &self,\n+    fn simple_var_t(&self,\n                     a_is_expected: bool,\n-                    a_id: V,\n-                    b: T)\n-                    -> ures {\n+                    a_id: K,\n+                    b: V)\n+                    -> ures\n+    {\n         /*!\n-         *\n-         * Sets the value of the variable `a_id` to `b`.  Because\n-         * simple variables do not have any subtyping relationships,\n+         * Sets the value of the key `a_id` to `b`.  Because\n+         * simple keys do not have any subtyping relationships,\n          * if `a_id` already has a value, it must be the same as\n-         * `b`. */\n+         * `b`.\n+         */\n \n-        let node_a = self.get(a_id);\n-        let a_id = node_a.root.clone();\n+        let tcx = self.tcx;\n+        let table = UnifyKey::unification_table(self);\n+        let node_a = table.borrow_mut().get(tcx, a_id);\n+        let a_id = node_a.key.clone();\n \n-        match node_a.possible_types {\n+        match node_a.value {\n             None => {\n-                self.set(a_id, Root(Some(b), node_a.rank));\n-                return uok();\n+                table.borrow_mut().set(tcx, a_id, Root(Some(b), node_a.rank));\n+                return Ok(());\n             }\n \n             Some(ref a_t) => {\n                 if *a_t == b {\n-                    return uok();\n+                    return Ok(());\n                 } else {\n-                    return mk_err(a_is_expected, (*a_t).clone(), b);\n+                    return err(a_is_expected, (*a_t).clone(), b);\n                 }\n             }\n         }\n     }\n }\n \n-// ______________________________________________________________________\n+///////////////////////////////////////////////////////////////////////////\n+\n+// General type keys\n+\n+impl UnifyKey<Bounds<ty::t>> for ty::TyVid {\n+    fn index(&self) -> uint { self.index }\n+\n+    fn from_index(i: uint) -> ty::TyVid { ty::TyVid { index: i } }\n \n-impl UnifyVid<Bounds<ty::t>> for ty::TyVid {\n-    fn appropriate_vals_and_bindings<'v>(infcx: &'v InferCtxt)\n-        -> &'v RefCell<ValsAndBindings<ty::TyVid, Bounds<ty::t>>> {\n-        return &infcx.ty_var_bindings;\n+    fn unification_table<'v>(infcx: &'v InferCtxt)\n+        -> &'v RefCell<UnificationTable<ty::TyVid, Bounds<ty::t>>>\n+    {\n+        return &infcx.type_unification_table;\n+    }\n+\n+    fn tag(_: Option<ty::TyVid>) -> &'static str {\n+        \"TyVid\"\n     }\n }\n \n-impl UnifyVid<Option<IntVarValue>> for ty::IntVid {\n-    fn appropriate_vals_and_bindings<'v>(infcx: &'v InferCtxt)\n-        -> &'v RefCell<ValsAndBindings<ty::IntVid, Option<IntVarValue>>> {\n-        return &infcx.int_var_bindings;\n+impl UnifyValue for Bounds<ty::t> { }\n+\n+// Integral type keys\n+\n+impl UnifyKey<Option<IntVarValue>> for ty::IntVid {\n+    fn index(&self) -> uint { self.index }\n+\n+    fn from_index(i: uint) -> ty::IntVid { ty::IntVid { index: i } }\n+\n+    fn unification_table<'v>(infcx: &'v InferCtxt)\n+        -> &'v RefCell<UnificationTable<ty::IntVid, Option<IntVarValue>>>\n+    {\n+        return &infcx.int_unification_table;\n+    }\n+\n+    fn tag(_: Option<ty::IntVid>) -> &'static str {\n+        \"IntVid\"\n     }\n }\n \n@@ -304,13 +527,29 @@ impl SimplyUnifiable for IntVarValue {\n     }\n }\n \n-impl UnifyVid<Option<ast::FloatTy>> for ty::FloatVid {\n-    fn appropriate_vals_and_bindings<'v>(infcx: &'v InferCtxt)\n-        -> &'v RefCell<ValsAndBindings<ty::FloatVid, Option<ast::FloatTy>>> {\n-        return &infcx.float_var_bindings;\n+impl UnifyValue for Option<IntVarValue> { }\n+\n+// Floating point type keys\n+\n+impl UnifyKey<Option<ast::FloatTy>> for ty::FloatVid {\n+    fn index(&self) -> uint { self.index }\n+\n+    fn from_index(i: uint) -> ty::FloatVid { ty::FloatVid { index: i } }\n+\n+    fn unification_table<'v>(infcx: &'v InferCtxt)\n+        -> &'v RefCell<UnificationTable<ty::FloatVid, Option<ast::FloatTy>>>\n+    {\n+        return &infcx.float_unification_table;\n+    }\n+\n+    fn tag(_: Option<ty::FloatVid>) -> &'static str {\n+        \"FloatVid\"\n     }\n }\n \n+impl UnifyValue for Option<ast::FloatTy> {\n+}\n+\n impl SimplyUnifiable for ast::FloatTy {\n     fn to_type_err(err: expected_found<ast::FloatTy>) -> ty::type_err {\n         return ty::terr_float_mismatch(err);"}, {"sha": "d08dd4f6cbc7b54f4e12fe9f534496374d87aa87", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 91, "deletions": 8, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/020373f2c807627274a53251a7841f0e9617e98e/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/020373f2c807627274a53251a7841f0e9617e98e/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=020373f2c807627274a53251a7841f0e9617e98e", "patch": "@@ -24,6 +24,10 @@ use middle::ty::{ty_nil, ty_param, ty_ptr, ty_rptr, ty_tup};\n use middle::ty::{ty_uniq, ty_trait, ty_int, ty_uint, ty_infer};\n use middle::ty;\n use middle::typeck;\n+use middle::typeck::infer;\n+use middle::typeck::infer::unify;\n+use VV = middle::typeck::infer::unify::VarValue;\n+use middle::typeck::infer::region_inference;\n \n use std::rc::Rc;\n use std::gc::Gc;\n@@ -574,6 +578,12 @@ impl Repr for ty::t {\n     }\n }\n \n+impl Repr for ty::mt {\n+    fn repr(&self, tcx: &ctxt) -> String {\n+        mt_to_str(tcx, self)\n+    }\n+}\n+\n impl Repr for subst::Substs {\n     fn repr(&self, tcx: &ctxt) -> String {\n         format!(\"Substs[types={}, regions={}]\",\n@@ -707,7 +717,7 @@ impl Repr for ty::Region {\n             }\n \n             ty::ReInfer(ReVar(ref vid)) => {\n-                format!(\"ReInfer({})\", vid.id)\n+                format!(\"ReInfer({})\", vid.index)\n             }\n \n             ty::ReInfer(ReSkolemized(id, ref bound_region)) => {\n@@ -878,13 +888,6 @@ impl Repr for typeck::MethodObject {\n     }\n }\n \n-\n-impl Repr for ty::RegionVid {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", *self)\n-    }\n-}\n-\n impl Repr for ty::TraitStore {\n     fn repr(&self, tcx: &ctxt) -> String {\n         trait_store_to_str(tcx, *self)\n@@ -998,3 +1001,83 @@ impl Repr for ty::UpvarBorrow {\n                 self.region.repr(tcx))\n     }\n }\n+\n+impl Repr for ty::IntVid {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n+        format!(\"{}\", self)\n+    }\n+}\n+\n+impl Repr for ty::FloatVid {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n+        format!(\"{}\", self)\n+    }\n+}\n+\n+impl Repr for ty::RegionVid {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n+        format!(\"{}\", self)\n+    }\n+}\n+\n+impl Repr for ty::TyVid {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n+        format!(\"{}\", self)\n+    }\n+}\n+\n+impl Repr for ty::IntVarValue {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n+        format!(\"{:?}\", *self)\n+    }\n+}\n+\n+impl Repr for ast::IntTy {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n+        format!(\"{:?}\", *self)\n+    }\n+}\n+\n+impl Repr for ast::UintTy {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n+        format!(\"{:?}\", *self)\n+    }\n+}\n+\n+impl Repr for ast::FloatTy {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n+        format!(\"{:?}\", *self)\n+    }\n+}\n+\n+impl<T:Repr> Repr for infer::Bounds<T> {\n+    fn repr(&self, tcx: &ctxt) -> String {\n+        format!(\"({} <= {})\",\n+                self.lb.repr(tcx),\n+                self.ub.repr(tcx))\n+    }\n+}\n+\n+impl<K:Repr,V:Repr> Repr for VV<K,V> {\n+    fn repr(&self, tcx: &ctxt) -> String {\n+        match *self {\n+            unify::Redirect(ref k) =>\n+                format!(\"Redirect({})\", k.repr(tcx)),\n+            unify::Root(ref v, r) =>\n+                format!(\"Root({}, {})\", v.repr(tcx), r)\n+        }\n+    }\n+}\n+\n+impl Repr for region_inference::VarValue {\n+    fn repr(&self, tcx: &ctxt) -> String {\n+        match *self {\n+            infer::region_inference::NoValue =>\n+                format!(\"NoValue\"),\n+            infer::region_inference::Value(r) =>\n+                format!(\"Value({})\", r.repr(tcx)),\n+            infer::region_inference::ErrorValue =>\n+                format!(\"ErrorValue\"),\n+        }\n+    }\n+}"}]}