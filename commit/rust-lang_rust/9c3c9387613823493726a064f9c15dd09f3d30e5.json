{"sha": "9c3c9387613823493726a064f9c15dd09f3d30e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljM2M5Mzg3NjEzODIzNDkzNzI2YTA2NGY5YzE1ZGQwOWYzZDMwZTU=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-03-30T09:16:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-03-30T09:16:20Z"}, "message": "Merge pull request #1613 from Manishearth/dont_ref_operator_args\n\nDont ref operator args", "tree": {"sha": "fdae33e099588712ffe0f2b9a5d00b7b4527b5d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdae33e099588712ffe0f2b9a5d00b7b4527b5d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c3c9387613823493726a064f9c15dd09f3d30e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c3c9387613823493726a064f9c15dd09f3d30e5", "html_url": "https://github.com/rust-lang/rust/commit/9c3c9387613823493726a064f9c15dd09f3d30e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c3c9387613823493726a064f9c15dd09f3d30e5/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "813daf236f2cbc5ea8ebbb80d676d58f0f012e6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/813daf236f2cbc5ea8ebbb80d676d58f0f012e6a", "html_url": "https://github.com/rust-lang/rust/commit/813daf236f2cbc5ea8ebbb80d676d58f0f012e6a"}, {"sha": "0ae1a77a2e336118ceb63121e45014ac0ca3c853", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ae1a77a2e336118ceb63121e45014ac0ca3c853", "html_url": "https://github.com/rust-lang/rust/commit/0ae1a77a2e336118ceb63121e45014ac0ca3c853"}], "stats": {"total": 204, "additions": 136, "deletions": 68}, "files": [{"sha": "7093e18454f55ad5d9075426f5378c61332cb963", "filename": "clippy_lints/src/approx_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fapprox_const.rs?ref=9c3c9387613823493726a064f9c15dd09f3d30e5", "patch": "@@ -77,10 +77,10 @@ fn check_lit(cx: &LateContext, lit: &Lit, e: &Expr) {\n }\n \n fn check_known_consts(cx: &LateContext, e: &Expr, s: &symbol::Symbol, module: &str) {\n-    let s = &*s.as_str();\n+    let s = s.as_str();\n     if s.parse::<f64>().is_ok() {\n         for &(constant, name, min_digits) in KNOWN_CONSTS {\n-            if is_approx_const(constant, s, min_digits) {\n+            if is_approx_const(constant, &s, min_digits) {\n                 span_lint(cx,\n                           APPROX_CONSTANT,\n                           e.span,"}, {"sha": "646bcdad5ffb05240d68079b2b8447063f383c3d", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=9c3c9387613823493726a064f9c15dd09f3d30e5", "patch": "@@ -237,7 +237,7 @@ fn check_attrs(cx: &LateContext, span: Span, name: &Name, attrs: &[Attribute]) {\n \n fn check_semver(cx: &LateContext, span: Span, lit: &Lit) {\n     if let LitKind::Str(ref is, _) = lit.node {\n-        if Version::parse(&*is.as_str()).is_ok() {\n+        if Version::parse(&is.as_str()).is_ok() {\n             return;\n         }\n     }"}, {"sha": "3713aa0a2051cdbb6df95307521e32a39c295819", "filename": "clippy_lints/src/blacklisted_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblacklisted_name.rs?ref=9c3c9387613823493726a064f9c15dd09f3d30e5", "patch": "@@ -40,7 +40,7 @@ impl LintPass for BlackListedName {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlackListedName {\n     fn check_pat(&mut self, cx: &LateContext<'a, 'tcx>, pat: &'tcx Pat) {\n         if let PatKind::Binding(_, _, ref ident, _) = pat.node {\n-            if self.blacklist.iter().any(|s| s == &*ident.node.as_str()) {\n+            if self.blacklist.iter().any(|s| ident.node == *s) {\n                 span_lint(cx,\n                           BLACKLISTED_NAME,\n                           pat.span,"}, {"sha": "b869948c324a2861db269370d456c9b9f26a7413", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=9c3c9387613823493726a064f9c15dd09f3d30e5", "patch": "@@ -90,7 +90,7 @@ pub fn check_attrs<'a>(cx: &EarlyContext, valid_idents: &[String], attrs: &'a [a\n     for attr in attrs {\n         if attr.is_sugared_doc {\n             if let Some(ref doc) = attr.value_str() {\n-                let doc = (*doc.as_str()).to_owned();\n+                let doc = doc.to_string();\n                 docs.extend_from_slice(&strip_doc_comment_decoration((doc, attr.span)));\n             }\n         }"}, {"sha": "860003587bc3f1138375e953e935fa9777fdf20e", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=9c3c9387613823493726a064f9c15dd09f3d30e5", "patch": "@@ -85,7 +85,7 @@ fn check_cond<'a, 'tcx, 'b>(\n     if_let_chain! {[\n         let ExprMethodCall(ref name, _, ref params) = check.node,\n         params.len() >= 2,\n-        &*name.node.as_str() == \"contains_key\",\n+        name.node == \"contains_key\",\n         let ExprAddrOf(_, ref key) = params[1].node\n     ], {\n         let map = &params[0];\n@@ -119,7 +119,7 @@ impl<'a, 'tcx, 'b> Visitor<'tcx> for InsertVisitor<'a, 'tcx, 'b> {\n         if_let_chain! {[\n             let ExprMethodCall(ref name, _, ref params) = expr.node,\n             params.len() == 3,\n-            &*name.node.as_str() == \"insert\",\n+            name.node == \"insert\",\n             get_item_name(self.cx, self.map) == get_item_name(self.cx, &params[0]),\n             SpanlessEq::new(self.cx).eq_expr(self.key, &params[1])\n         ], {"}, {"sha": "d0c75125df07f61567a0fea2ccecc02039d2cb95", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=9c3c9387613823493726a064f9c15dd09f3d30e5", "patch": "@@ -232,7 +232,7 @@ impl EarlyLintPass for EnumVariantNames {\n             if let Some(&(ref mod_name, ref mod_camel)) = self.modules.last() {\n                 // constants don't have surrounding modules\n                 if !mod_camel.is_empty() {\n-                    if mod_name == &item_name {\n+                    if *mod_name == item_name {\n                         if let ItemKind::Mod(..) = item.node {\n                             span_lint(cx,\n                                       MODULE_INCEPTION,"}, {"sha": "dccfed87269222f8edb0624b6ef976729d44cff7", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 76, "deletions": 7, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=9c3c9387613823493726a064f9c15dd09f3d30e5", "patch": "@@ -1,6 +1,7 @@\n use rustc::hir::*;\n use rustc::lint::*;\n-use utils::{SpanlessEq, span_lint};\n+use utils::{SpanlessEq, span_lint, span_lint_and_then, multispan_sugg, snippet};\n+use utils::sugg::Sugg;\n \n /// **What it does:** Checks for equal operands to comparison, logical and\n /// bitwise, difference and division binary operators (`==`, `>`, etc., `&&`,\n@@ -23,23 +24,91 @@ declare_lint! {\n     \"equal operands on both sides of a comparison or bitwise combination (e.g. `x == x`)\"\n }\n \n+/// **What it does:** Checks for arguments to `==` which have their address taken to satisfy a bound\n+/// and suggests to dereference the other argument instead\n+///\n+/// **Why is this bad?** It is more idiomatic to dereference the other argument.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:**\n+/// ```rust\n+/// &x == y\n+/// ```\n+declare_lint! {\n+    pub OP_REF,\n+    Warn,\n+    \"taking a reference to satisfy the type constraints on `==`\"\n+}\n+\n #[derive(Copy,Clone)]\n pub struct EqOp;\n \n impl LintPass for EqOp {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(EQ_OP)\n+        lint_array!(EQ_OP, OP_REF)\n     }\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprBinary(ref op, ref left, ref right) = e.node {\n-            if is_valid_operator(op) && SpanlessEq::new(cx).ignore_fn().eq_expr(left, right) {\n-                span_lint(cx,\n-                          EQ_OP,\n-                          e.span,\n-                          &format!(\"equal expressions as operands to `{}`\", op.node.as_str()));\n+            if is_valid_operator(op) {\n+                if SpanlessEq::new(cx).ignore_fn().eq_expr(left, right) {\n+                    span_lint(cx,\n+                            EQ_OP,\n+                            e.span,\n+                            &format!(\"equal expressions as operands to `{}`\", op.node.as_str()));\n+                } else {\n+                    match (&left.node, &right.node) {\n+                        (&ExprAddrOf(_, ref l), &ExprAddrOf(_, ref r)) => {\n+                            span_lint_and_then(cx,\n+                                OP_REF,\n+                                e.span,\n+                                \"taken reference of both operands, which is done automatically by the operator anyway\",\n+                                |db| {\n+                                    let lsnip = snippet(cx, l.span, \"...\").to_string();\n+                                    let rsnip = snippet(cx, r.span, \"...\").to_string();\n+                                    multispan_sugg(db,\n+                                                \"use the values directly\".to_string(),\n+                                                vec![(left.span, lsnip),\n+                                                     (right.span, rsnip)]);\n+                                }\n+                            )\n+                        }\n+                        (&ExprAddrOf(_, ref l), _) => {\n+                            span_lint_and_then(cx,\n+                                OP_REF,\n+                                e.span,\n+                                \"taken reference of left operand\",\n+                                |db| {\n+                                    let lsnip = snippet(cx, l.span, \"...\").to_string();\n+                                    let rsnip = Sugg::hir(cx, right, \"...\").deref().to_string();\n+                                    multispan_sugg(db,\n+                                                \"dereference the right operand instead\".to_string(),\n+                                                vec![(left.span, lsnip),\n+                                                     (right.span, rsnip)]);\n+                                }\n+                            )\n+                        }\n+                        (_, &ExprAddrOf(_, ref r)) => {\n+                            span_lint_and_then(cx,\n+                                OP_REF,\n+                                e.span,\n+                                \"taken reference of right operand\",\n+                                |db| {\n+                                    let lsnip = Sugg::hir(cx, left, \"...\").deref().to_string();\n+                                    let rsnip = snippet(cx, r.span, \"...\").to_string();\n+                                    multispan_sugg(db,\n+                                                \"dereference the left operand instead\".to_string(),\n+                                                vec![(left.span, lsnip),\n+                                                     (right.span, rsnip)]);\n+                                }\n+                            )\n+                        }\n+                        _ => {}\n+                    }\n+                }\n             }\n         }\n     }"}, {"sha": "32e02e30b7912a28e83dea47a5a085acd7d7906f", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=9c3c9387613823493726a064f9c15dd09f3d30e5", "patch": "@@ -79,7 +79,7 @@ pub fn get_argument_fmtstr_parts<'a, 'b>(cx: &LateContext<'a, 'b>, expr: &'a Exp\n         let StmtDecl(ref decl, _) = block.stmts[0].node,\n         let DeclItem(ref decl) = decl.node,\n         let Some(NodeItem(decl)) = cx.tcx.hir.find(decl.id),\n-        &*decl.name.as_str() == \"__STATIC_FMTSTR\",\n+        decl.name == \"__STATIC_FMTSTR\",\n         let ItemStatic(_, _, ref expr) = decl.node,\n         let ExprAddrOf(_, ref expr) = cx.tcx.hir.body(*expr).value.node, // &[\"\u2026\", \"\u2026\", \u2026]\n         let ExprArray(ref exprs) = expr.node,"}, {"sha": "3c7b139cbd7a0ce225651e3dce5c4f8fc7724340", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=9c3c9387613823493726a064f9c15dd09f3d30e5", "patch": "@@ -89,7 +89,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LenZero {\n \n fn check_trait_items(cx: &LateContext, item: &Item, trait_items: &[TraitItemRef]) {\n     fn is_named_self(cx: &LateContext, item: &TraitItemRef, name: &str) -> bool {\n-        &*item.name.as_str() == name &&\n+        item.name == name &&\n         if let AssociatedItemKind::Method { has_self } = item.kind {\n             has_self &&\n             {\n@@ -116,7 +116,7 @@ fn check_trait_items(cx: &LateContext, item: &Item, trait_items: &[TraitItemRef]\n \n fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[ImplItemRef]) {\n     fn is_named_self(cx: &LateContext, item: &ImplItemRef, name: &str) -> bool {\n-        &*item.name.as_str() == name &&\n+        item.name == name &&\n         if let AssociatedItemKind::Method { has_self } = item.kind {\n             has_self &&\n             {\n@@ -155,22 +155,22 @@ fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[ImplItemRef]) {\n fn check_cmp(cx: &LateContext, span: Span, left: &Expr, right: &Expr, op: &str) {\n     // check if we are in an is_empty() method\n     if let Some(name) = get_item_name(cx, left) {\n-        if &*name.as_str() == \"is_empty\" {\n+        if name == \"is_empty\" {\n             return;\n         }\n     }\n     match (&left.node, &right.node) {\n         (&ExprLit(ref lit), &ExprMethodCall(ref method, _, ref args)) |\n         (&ExprMethodCall(ref method, _, ref args), &ExprLit(ref lit)) => {\n-            check_len_zero(cx, span, &method.node, args, lit, op)\n+            check_len_zero(cx, span, method.node, args, lit, op)\n         },\n         _ => (),\n     }\n }\n \n-fn check_len_zero(cx: &LateContext, span: Span, name: &Name, args: &[Expr], lit: &Lit, op: &str) {\n+fn check_len_zero(cx: &LateContext, span: Span, name: Name, args: &[Expr], lit: &Lit, op: &str) {\n     if let Spanned { node: LitKind::Int(0, _), .. } = *lit {\n-        if &*name.as_str() == \"len\" && args.len() == 1 && has_is_empty(cx, &args[0]) {\n+        if name == \"len\" && args.len() == 1 && has_is_empty(cx, &args[0]) {\n             span_lint_and_then(cx, LEN_ZERO, span, \"length comparison to zero\", |db| {\n                 db.span_suggestion(span,\n                                    \"consider using `is_empty`\",\n@@ -185,7 +185,7 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n     /// Get an `AssociatedItem` and return true if it matches `is_empty(self)`.\n     fn is_is_empty(cx: &LateContext, item: &ty::AssociatedItem) -> bool {\n         if let ty::AssociatedKind::Method = item.kind {\n-            if &*item.name.as_str() == \"is_empty\" {\n+            if item.name == \"is_empty\" {\n                 let sig = cx.tcx.item_type(item.def_id).fn_sig();\n                 let ty = sig.skip_binder();\n                 ty.inputs().len() == 1"}, {"sha": "1de7e9e47f766f8205fd9c637257b2f07d0f57a2", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=9c3c9387613823493726a064f9c15dd09f3d30e5", "patch": "@@ -199,7 +199,7 @@ fn allowed_lts_from(named_lts: &[LifetimeDef]) -> HashSet<RefLt> {\n \n fn lts_from_bounds<'a, T: Iterator<Item = &'a Lifetime>>(mut vec: Vec<RefLt>, bounds_lts: T) -> Vec<RefLt> {\n     for lt in bounds_lts {\n-        if &*lt.name.as_str() != \"'static\" {\n+        if lt.name != \"'static\" {\n             vec.push(RefLt::Named(lt.name));\n         }\n     }\n@@ -228,7 +228,7 @@ impl<'v, 't> RefVisitor<'v, 't> {\n \n     fn record(&mut self, lifetime: &Option<Lifetime>) {\n         if let Some(ref lt) = *lifetime {\n-            if &*lt.name.as_str() == \"'static\" {\n+            if lt.name == \"'static\" {\n                 self.lts.push(RefLt::Static);\n             } else if lt.is_elided() {\n                 self.lts.push(RefLt::Unnamed);"}, {"sha": "ff57afb732499f0c67aeec27f2c046db5ce19cef", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=9c3c9387613823493726a064f9c15dd09f3d30e5", "patch": "@@ -389,8 +389,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     &ExprMethodCall(method_name, _, ref method_args)) = (pat, &match_expr.node) {\n                 let iter_expr = &method_args[0];\n                 let lhs_constructor = last_path_segment(qpath);\n-                if &*method_name.node.as_str() == \"next\" && match_trait_method(cx, match_expr, &paths::ITERATOR) &&\n-                   &*lhs_constructor.name.as_str() == \"Some\" && !is_refutable(cx, &pat_args[0]) &&\n+                if method_name.node == \"next\" && match_trait_method(cx, match_expr, &paths::ITERATOR) &&\n+                   lhs_constructor.name == \"Some\" && !is_refutable(cx, &pat_args[0]) &&\n                    !is_iterator_used_after_while_let(cx, iter_expr) {\n                     let iterator = snippet(cx, method_args[0].span, \"_\");\n                     let loop_var = snippet(cx, pat_args[0].span, \"_\");\n@@ -409,7 +409,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n         if let StmtSemi(ref expr, _) = stmt.node {\n             if let ExprMethodCall(ref method, _, ref args) = expr.node {\n-                if args.len() == 1 && &*method.node.as_str() == \"collect\" &&\n+                if args.len() == 1 && method.node == \"collect\" &&\n                    match_trait_method(cx, expr, &paths::ITERATOR) {\n                     span_lint(cx,\n                               UNUSED_COLLECT,\n@@ -579,10 +579,10 @@ fn is_len_call(expr: &Expr, var: &Name) -> bool {\n     if_let_chain! {[\n         let ExprMethodCall(method, _, ref len_args) = expr.node,\n         len_args.len() == 1,\n-        &*method.node.as_str() == \"len\",\n+        method.node == \"len\",\n         let ExprPath(QPath::Resolved(_, ref path)) = len_args[0].node,\n         path.segments.len() == 1,\n-        &path.segments[0].name == var\n+        path.segments[0].name == *var\n     ], {\n         return true;\n     }}\n@@ -664,11 +664,11 @@ fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n     if let ExprMethodCall(ref method, _, ref args) = arg.node {\n         // just the receiver, no arguments\n         if args.len() == 1 {\n-            let method_name = &*method.node.as_str();\n+            let method_name = method.node.as_str();\n             // check for looping over x.iter() or x.iter_mut(), could use &x or &mut x\n             if method_name == \"iter\" || method_name == \"iter_mut\" {\n                 if is_ref_iterable_type(cx, &args[0]) {\n-                    lint_iter_method(cx, args, arg, method_name);\n+                    lint_iter_method(cx, args, arg, &method_name);\n                 }\n             } else if method_name == \"into_iter\" && match_trait_method(cx, arg, &paths::INTO_ITERATOR) {\n                 let method_call = ty::MethodCall::expr(arg.id);\n@@ -680,7 +680,7 @@ fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n                 let fn_arg_tys = fn_ty.fn_args();\n                 assert_eq!(fn_arg_tys.skip_binder().len(), 1);\n                 if fn_arg_tys.skip_binder()[0].is_region_ptr() {\n-                    lint_iter_method(cx, args, arg, method_name);\n+                    lint_iter_method(cx, args, arg, &method_name);\n                 } else {\n                     let object = snippet(cx, args[0].span, \"_\");\n                     span_lint_and_sugg(cx,"}, {"sha": "f6138a4870eb7abc6a10c4b40d5781ae210288ae", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=9c3c9387613823493726a064f9c15dd09f3d30e5", "patch": "@@ -28,7 +28,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // call to .map()\n         if let ExprMethodCall(name, _, ref args) = expr.node {\n-            if &*name.node.as_str() == \"map\" && args.len() == 2 {\n+            if name.node == \"map\" && args.len() == 2 {\n                 match args[1].node {\n                     ExprClosure(_, ref decl, closure_eid, _) => {\n                         let body = cx.tcx.hir.body(closure_eid);\n@@ -53,7 +53,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                             }\n                             // explicit clone() calls ( .map(|x| x.clone()) )\n                             else if let ExprMethodCall(clone_call, _, ref clone_args) = closure_expr.node {\n-                                if &*clone_call.node.as_str() == \"clone\" &&\n+                                if clone_call.node == \"clone\" &&\n                                     clone_args.len() == 1 &&\n                                     match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT) &&\n                                     expr_eq_name(&clone_args[0], arg_ident)"}, {"sha": "46dd54648815c5c32f86df756a0bdd57c51c23b2", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=9c3c9387613823493726a064f9c15dd09f3d30e5", "patch": "@@ -257,7 +257,7 @@ fn check_single_match_opt_like(\n     };\n \n     for &(ty_path, pat_path) in candidates {\n-        if &path == pat_path && match_type(cx, ty, ty_path) {\n+        if path == *pat_path && match_type(cx, ty, ty_path) {\n             report_single_match_single_pattern(cx, ex, arms, expr, els);\n         }\n     }"}, {"sha": "b6f7e2fca1c15b6e5d726f7e3d2e9e34da00e238", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=9c3c9387613823493726a064f9c15dd09f3d30e5", "patch": "@@ -607,14 +607,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 lint_or_fun_call(cx, expr, &name.node.as_str(), args);\n \n                 let self_ty = cx.tables.expr_ty_adjusted(&args[0]);\n-                if args.len() == 1 && &*name.node.as_str() == \"clone\" {\n+                if args.len() == 1 && name.node == \"clone\" {\n                     lint_clone_on_copy(cx, expr, &args[0], self_ty);\n                 }\n \n                 match self_ty.sty {\n                     ty::TyRef(_, ty) if ty.ty.sty == ty::TyStr => {\n                         for &(method, pos) in &PATTERN_METHODS {\n-                            if &*name.node.as_str() == method && args.len() > pos {\n+                            if name.node == method && args.len() > pos {\n                                 lint_single_char_pattern(cx, expr, &args[pos]);\n                             }\n                         }\n@@ -646,7 +646,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         ], {\n             // check missing trait implementations\n             for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n-                if &*name.as_str() == method_name &&\n+                if name == method_name &&\n                    sig.decl.inputs.len() == n_args &&\n                    out_type.matches(&sig.decl.output) &&\n                    self_kind.matches(&first_arg_ty, &first_arg, &self_ty, false) {\n@@ -683,7 +683,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             }\n \n             let ret_ty = return_ty(cx, implitem.id);\n-            if &*name.as_str() == \"new\" &&\n+            if name == \"new\" &&\n                !ret_ty.walk().any(|t| same_tys(cx, t, ty, implitem.id)) {\n                 span_lint(cx,\n                           NEW_RET_NO_SELF,\n@@ -712,7 +712,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n \n         if name == \"unwrap_or\" {\n             if let hir::ExprPath(ref qpath) = fun.node {\n-                let path: &str = &*last_path_segment(qpath).name.as_str();\n+                let path = &*last_path_segment(qpath).name.as_str();\n \n                 if [\"default\", \"new\"].contains(&path) {\n                     let arg_ty = cx.tables.expr_ty(arg);\n@@ -991,7 +991,7 @@ fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: ty::Ty) -> Option<sug\n     }\n \n     if let hir::ExprMethodCall(name, _, ref args) = expr.node {\n-        if &*name.node.as_str() == \"iter\" && may_slice(cx, cx.tables.expr_ty(&args[0])) {\n+        if name.node == \"iter\" && may_slice(cx, cx.tables.expr_ty(&args[0])) {\n             sugg::Sugg::hir_opt(cx, &args[0]).map(|sugg| sugg.addr())\n         } else {\n             None\n@@ -1209,7 +1209,7 @@ fn lint_chars_next(cx: &LateContext, expr: &hir::Expr, chain: &hir::Expr, other:\n         arg_char.len() == 1,\n         let hir::ExprPath(ref qpath) = fun.node,\n         let Some(segment) = single_segment_path(qpath),\n-        &*segment.name.as_str() == \"Some\"\n+        segment.name == \"Some\"\n     ], {\n         let self_ty = walk_ptrs_ty(cx.tables.expr_ty_adjusted(&args[0][0]));\n "}, {"sha": "a029a9c4ddaabe026ba9ca61167fa0927939a9c1", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=9c3c9387613823493726a064f9c15dd09f3d30e5", "patch": "@@ -305,7 +305,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                         return;\n                     }\n                     if let Some(name) = get_item_name(cx, expr) {\n-                        let name = &*name.as_str();\n+                        let name = name.as_str();\n                         if name == \"eq\" || name == \"ne\" || name == \"is_nan\" || name.starts_with(\"eq_\") ||\n                            name.ends_with(\"_eq\") {\n                             return;\n@@ -335,7 +335,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 let binding = last_path_segment(qpath).name.as_str();\n                 if binding.starts_with('_') &&\n                     !binding.starts_with(\"__\") &&\n-                    &*binding != \"_result\" && // FIXME: #944\n+                    binding != \"_result\" && // FIXME: #944\n                     is_used(cx, expr) &&\n                     // don't lint if the declaration is in a macro\n                     non_macro_local(cx, &cx.tables.qpath_def(qpath, expr.id)) {\n@@ -378,7 +378,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n fn check_nan(cx: &LateContext, path: &Path, expr: &Expr) {\n     if !in_constant(cx, expr.id) {\n-        path.segments.last().map(|seg| if &*seg.name.as_str() == \"NAN\" {\n+        path.segments.last().map(|seg| if seg.name == \"NAN\" {\n             span_lint(cx,\n                       CMP_NAN,\n                       expr.span,\n@@ -425,7 +425,7 @@ fn is_float(cx: &LateContext, expr: &Expr) -> bool {\n fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr, left: bool, op: Span) {\n     let (arg_ty, snip) = match expr.node {\n         ExprMethodCall(Spanned { node: ref name, .. }, _, ref args) if args.len() == 1 => {\n-            let name = &*name.as_str();\n+            let name = name.as_str();\n             if name == \"to_string\" || name == \"to_owned\" && is_str_arg(cx, args) {\n                 (cx.tables.expr_ty(&args[0]), snippet(cx, args[0].span, \"..\"))\n             } else {"}, {"sha": "ed495e7e56733d6bdb965a2e8920553a87d06895", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=9c3c9387613823493726a064f9c15dd09f3d30e5", "patch": "@@ -65,7 +65,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                     if_let_chain!{[\n                         a.meta_item_list().is_some(),\n                         let Some(name) = a.name(),\n-                        &*name.as_str() == \"proc_macro_derive\",\n+                        name == \"proc_macro_derive\",\n                     ], {\n                         return;\n                     }}\n@@ -102,7 +102,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n         let fn_sig = cx.tcx.item_type(fn_def_id).fn_sig();\n         let fn_sig = cx.tcx.liberate_late_bound_regions(param_env.free_id_outlive, &fn_sig);\n \n-        for ((input, ty), arg) in decl.inputs.iter().zip(fn_sig.inputs()).zip(&body.arguments) {\n+        for ((input, &ty), arg) in decl.inputs.iter().zip(fn_sig.inputs()).zip(&body.arguments) {\n \n             // Determines whether `ty` implements `Borrow<U>` (U != ty) specifically.\n             // This is needed due to the `Borrow<T> for T` blanket impl.\n@@ -112,8 +112,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                 } else {\n                     None\n                 })\n-                .filter(|tpred| tpred.def_id() == borrow_trait && &tpred.self_ty() == ty)\n-                .any(|tpred| &tpred.input_types().nth(1).expect(\"Borrow trait must have an parameter\") != ty);\n+                .filter(|tpred| tpred.def_id() == borrow_trait && tpred.self_ty() == ty)\n+                .any(|tpred| tpred.input_types().nth(1).expect(\"Borrow trait must have an parameter\") != ty);\n \n             if_let_chain! {[\n                 !is_self(arg),\n@@ -141,7 +141,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                         match_type(cx, ty, &paths::VEC),\n                         let TyPath(QPath::Resolved(_, ref path)) = input.node,\n                         let Some(elem_ty) = path.segments.iter()\n-                            .find(|seg| &*seg.name.as_str() == \"Vec\")\n+                            .find(|seg| seg.name == \"Vec\")\n                             .map(|ps| ps.parameters.types()[0]),\n                     ], {\n                         let slice_ty = format!(\"&[{}]\", snippet(cx, elem_ty.span, \"_\"));"}, {"sha": "2040bd7167dfcdd3238562a62a2870d535e3c2f4", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=9c3c9387613823493726a064f9c15dd09f3d30e5", "patch": "@@ -108,7 +108,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n                 // can't be implemented by default\n                 return;\n             }\n-            if decl.inputs.is_empty() && &*name.as_str() == \"new\" && cx.access_levels.is_reachable(id) {\n+            if decl.inputs.is_empty() && name == \"new\" && cx.access_levels.is_reachable(id) {\n                 let self_ty = cx.tcx\n                     .item_type(cx.tcx.hir.local_def_id(cx.tcx.hir.get_parent(id)));\n                 if_let_chain!{["}, {"sha": "b59c32005a345e874e28b38a72461e20bf4c1b3c", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=9c3c9387613823493726a064f9c15dd09f3d30e5", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSensical {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprMethodCall(ref name, _, ref arguments) = e.node {\n             let (obj_ty, _) = walk_ptrs_ty_depth(cx.tables.expr_ty(&arguments[0]));\n-            if &*name.node.as_str() == \"open\" && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n+            if name.node == \"open\" && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n                 let mut options = Vec::new();\n                 get_open_options(cx, &arguments[0], &mut options);\n                 check_open_options(cx, &options, e.span);"}, {"sha": "41ea6fbc4618ef607de25e4dedaec0494acf5ec4", "filename": "clippy_lints/src/overflow_check_conditional.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs?ref=9c3c9387613823493726a064f9c15dd09f3d30e5", "patch": "@@ -38,7 +38,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OverflowCheckConditional {\n             let Expr_::ExprPath(QPath::Resolved(_, ref path1)) = ident1.node,\n             let Expr_::ExprPath(QPath::Resolved(_, ref path2)) = ident2.node,\n             let Expr_::ExprPath(QPath::Resolved(_, ref path3)) = second.node,\n-            &path1.segments[0] == &path3.segments[0] || &path2.segments[0] == &path3.segments[0],\n+            path1.segments[0] == path3.segments[0] || path2.segments[0] == path3.segments[0],\n             cx.tables.expr_ty(ident1).is_integral(),\n             cx.tables.expr_ty(ident2).is_integral()\n         ], {\n@@ -62,7 +62,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OverflowCheckConditional {\n             let Expr_::ExprPath(QPath::Resolved(_, ref path1)) = ident1.node,\n             let Expr_::ExprPath(QPath::Resolved(_, ref path2)) = ident2.node,\n             let Expr_::ExprPath(QPath::Resolved(_, ref path3)) = first.node,\n-            &path1.segments[0] == &path3.segments[0] || &path2.segments[0] == &path3.segments[0],\n+            path1.segments[0] == path3.segments[0] || path2.segments[0] == path3.segments[0],\n             cx.tables.expr_ty(ident1).is_integral(),\n             cx.tables.expr_ty(ident2).is_integral()\n         ], {"}, {"sha": "6989eb79f8e77485d489d47e4ffe05dc0819c2f5", "filename": "clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=9c3c9387613823493726a064f9c15dd09f3d30e5", "patch": "@@ -43,7 +43,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             trait_ref.path.def.def_id() == cx.tcx.lang_items.eq_trait().unwrap(),\n         ], {\n             for impl_item in impl_items {\n-                if &*impl_item.name.as_str() == \"ne\" {\n+                if impl_item.name == \"ne\" {\n                     span_lint(cx,\n                               PARTIALEQ_NE_IMPL,\n                               impl_item.span,"}, {"sha": "aa190402f298eb8463a1c392597ab2aa284fca3c", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=9c3c9387613823493726a064f9c15dd09f3d30e5", "patch": "@@ -49,7 +49,7 @@ impl LintPass for StepByZero {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StepByZero {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprMethodCall(Spanned { node: ref name, .. }, _, ref args) = expr.node {\n-            let name = &*name.as_str();\n+            let name = name.as_str();\n \n             // Range with step_by(0).\n             if name == \"step_by\" && args.len() == 2 && has_step_by(cx, &args[0]) && is_integer_literal(&args[1], 0) {\n@@ -63,14 +63,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StepByZero {\n                 let zip_arg = &args[1];\n                 if_let_chain! {[\n                     // .iter() call\n-                    let ExprMethodCall( Spanned { node: ref iter_name, .. }, _, ref iter_args ) = *iter,\n-                    &*iter_name.as_str() == \"iter\",\n+                    let ExprMethodCall( Spanned { node: iter_name, .. }, _, ref iter_args ) = *iter,\n+                    iter_name == \"iter\",\n                     // range expression in .zip() call: 0..x.len()\n                     let Some(higher::Range { start: Some(ref start), end: Some(ref end), .. }) = higher::range(zip_arg),\n                     is_integer_literal(start, 0),\n                     // .len() call\n-                    let ExprMethodCall(Spanned { node: ref len_name, .. }, _, ref len_args) = end.node,\n-                    &*len_name.as_str() == \"len\" && len_args.len() == 1,\n+                    let ExprMethodCall(Spanned { node: len_name, .. }, _, ref len_args) = end.node,\n+                    len_name == \"len\" && len_args.len() == 1,\n                     // .iter() and .len() called on same Path\n                     let ExprPath(QPath::Resolved(_, ref iter_path)) = iter_args[0].node,\n                     let ExprPath(QPath::Resolved(_, ref len_path)) = len_args[0].node,"}, {"sha": "2808dfd35465a010c69b38a0627e415881200160", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=9c3c9387613823493726a064f9c15dd09f3d30e5", "patch": "@@ -203,7 +203,7 @@ fn check_regex(cx: &LateContext, expr: &Expr, utf8: bool) {\n \n     if let ExprLit(ref lit) = expr.node {\n         if let LitKind::Str(ref r, _) = lit.node {\n-            let r = &*r.as_str();\n+            let r = &r.as_str();\n             match builder.parse(r) {\n                 Ok(r) => {\n                     if let Some(repl) = is_trivial_regex(&r) {"}, {"sha": "0e4bf017f3f60190d335b17a05d1fdd0d08fbe81", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=9c3c9387613823493726a064f9c15dd09f3d30e5", "patch": "@@ -143,7 +143,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringLitAsBytes {\n         use utils::{snippet, in_macro};\n \n         if let ExprMethodCall(ref name, _, ref args) = e.node {\n-            if &*name.node.as_str() == \"as_bytes\" {\n+            if name.node == \"as_bytes\" {\n                 if let ExprLit(ref lit) = args[0].node {\n                     if let LitKind::Str(ref lit_content, _) = lit.node {\n                         if lit_content.as_str().chars().all(|c| c.is_ascii()) && !in_macro(cx, args[0].span) {"}, {"sha": "c8ceb6be0cc061a412098d323666c57fb030c3db", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=9c3c9387613823493726a064f9c15dd09f3d30e5", "patch": "@@ -56,8 +56,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n             },\n \n             hir::ExprMethodCall(ref symbol, _, ref args) => {\n-                let symbol = &*symbol.node.as_str();\n-                match symbol {\n+                match &*symbol.node.as_str() {\n                     \"expect\" | \"unwrap\" | \"unwrap_or\" | \"unwrap_or_else\" => {\n                         check_method_call(cx, &args[0], expr);\n                     },"}, {"sha": "1eed85c9fe0429bf2f6236d9ecebd3ae34a87acc", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3c9387613823493726a064f9c15dd09f3d30e5/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=9c3c9387613823493726a064f9c15dd09f3d30e5", "patch": "@@ -179,7 +179,7 @@ pub fn match_def_path(tcx: ty::TyCtxt, def_id: DefId, path: &[&str]) -> bool {\n \n     tcx.push_item_path(&mut apb, def_id);\n \n-    apb.names.len() == path.len() && apb.names.iter().zip(path.iter()).all(|(a, &b)| &**a == b)\n+    apb.names.len() == path.len() && apb.names.into_iter().zip(path.iter()).all(|(a, &b)| *a == *b)\n }\n \n /// Check if type is struct, enum or union type with given def path.\n@@ -680,7 +680,7 @@ fn parse_attrs<F: FnMut(u64)>(sess: &Session, attrs: &[ast::Attribute], name: &'\n         }\n         if let Some(ref value) = attr.value_str() {\n             if attr.name().map_or(false, |n| n == name) {\n-                if let Ok(value) = FromStr::from_str(&*value.as_str()) {\n+                if let Ok(value) = FromStr::from_str(&value.as_str()) {\n                     attr::mark_used(attr);\n                     f(value)\n                 } else {"}]}