{"sha": "739f3eece9c341f4f1e70b8a0417853ed2a09cbc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczOWYzZWVjZTljMzQxZjRmMWU3MGI4YTA0MTc4NTNlZDJhMDljYmM=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-07-02T08:33:51Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-07-19T05:55:24Z"}, "message": "debuginfo: Added support for c-style enums.", "tree": {"sha": "5269178c6faac201b5ac764a6a07b2531a1f48e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5269178c6faac201b5ac764a6a07b2531a1f48e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/739f3eece9c341f4f1e70b8a0417853ed2a09cbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/739f3eece9c341f4f1e70b8a0417853ed2a09cbc", "html_url": "https://github.com/rust-lang/rust/commit/739f3eece9c341f4f1e70b8a0417853ed2a09cbc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/739f3eece9c341f4f1e70b8a0417853ed2a09cbc/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99ebb816cf9db45953c123bec95c2c3e19ed2302", "url": "https://api.github.com/repos/rust-lang/rust/commits/99ebb816cf9db45953c123bec95c2c3e19ed2302", "html_url": "https://github.com/rust-lang/rust/commit/99ebb816cf9db45953c123bec95c2c3e19ed2302"}], "stats": {"total": 398, "additions": 361, "deletions": 37}, "files": [{"sha": "bfa8d84d5b0b821ff568ed0aca27082cabc35dc2", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/739f3eece9c341f4f1e70b8a0417853ed2a09cbc/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/739f3eece9c341f4f1e70b8a0417853ed2a09cbc/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=739f3eece9c341f4f1e70b8a0417853ed2a09cbc", "patch": "@@ -2097,8 +2097,25 @@ pub mod llvm {\n             Val: ValueRef,\n             VarInfo: DIVariable,\n             InsertBefore: ValueRef) -> ValueRef;\n-    }\n-}\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderCreateEnumerator(\n+            Builder: DIBuilderRef,\n+            Name: *c_char,\n+            Val: c_ulonglong) -> ValueRef;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderCreateEnumerationType(\n+            Builder: DIBuilderRef,\n+            Scope: ValueRef,\n+            Name: *c_char,\n+            File: ValueRef,\n+            LineNumber: c_uint,\n+            SizeInBits: c_ulonglong,\n+            AlignInBits: c_ulonglong,\n+            Elements: ValueRef,\n+            ClassType: ValueRef) -> ValueRef;\n+}}\n \n pub fn SetInstructionCallConv(Instr: ValueRef, CC: CallConv) {\n     unsafe {"}, {"sha": "d3878e242f3d29ac695624ba2c3ec6f5534812f0", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 92, "deletions": 31, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/739f3eece9c341f4f1e70b8a0417853ed2a09cbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/739f3eece9c341f4f1e70b8a0417853ed2a09cbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=739f3eece9c341f4f1e70b8a0417853ed2a09cbc", "patch": "@@ -143,11 +143,11 @@ pub fn create_local_var(bcx: block, local: @ast::local) -> DIVariable {\n \n     let loc = span_start(cx, local.span);\n     let ty = node_id_type(bcx, local.node.id);\n-    let tymd = get_or_create_ty(cx, ty, local.node.ty.span);\n+    let tymd = get_or_create_type(cx, ty, local.node.ty.span);\n     let filemd = get_or_create_file(cx, loc.file.name);\n     let context = match bcx.parent {\n         None => create_function(bcx.fcx),\n-        Some(_) => create_block(bcx)\n+        Some(_) => get_or_create_block(bcx)\n     };\n \n     let var_md = do as_c_str(name) |name| { unsafe {\n@@ -167,7 +167,7 @@ pub fn create_local_var(bcx: block, local: @ast::local) -> DIVariable {\n         }\n     };\n \n-    set_debug_location(cx, create_block(bcx), loc.line, loc.col.to_uint());\n+    set_debug_location(cx, get_or_create_block(bcx), loc.line, loc.col.to_uint());\n     unsafe {\n         let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(DIB(cx), llptr, var_md, bcx.llbb);\n         llvm::LLVMSetInstDebugLocation(trans::build::B(bcx), instr);\n@@ -197,7 +197,7 @@ pub fn create_arg(bcx: block, arg: &ast::arg, span: span) -> Option<DIVariable>\n     }\n \n     let ty = node_id_type(bcx, arg.id);\n-    let tymd = get_or_create_ty(cx, ty, arg.ty.span);\n+    let tymd = get_or_create_type(cx, ty, arg.ty.span);\n     let filemd = get_or_create_file(cx, loc.file.name);\n     let context = create_function(fcx);\n \n@@ -222,7 +222,7 @@ pub fn create_arg(bcx: block, arg: &ast::arg, span: span) -> Option<DIVariable>\n             }};\n \n             let llptr = fcx.llargs.get_copy(&arg.id);\n-            set_debug_location(cx, create_block(bcx), loc.line, loc.col.to_uint());\n+            set_debug_location(cx, get_or_create_block(bcx), loc.line, loc.col.to_uint());\n             unsafe {\n                 let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n                         DIB(cx), llptr, mdnode, bcx.llbb);\n@@ -245,7 +245,7 @@ pub fn update_source_pos(bcx: block, span: span) {\n     }\n     debug!(\"update_source_pos: %s\", bcx.sess().codemap.span_to_str(span));\n     let loc = span_start(bcx.ccx(), span);\n-    set_debug_location(bcx.ccx(), create_block(bcx), loc.line, loc.col.to_uint())\n+    set_debug_location(bcx.ccx(), get_or_create_block(bcx), loc.line, loc.col.to_uint())\n }\n \n /// Creates debug information for the given function.\n@@ -297,7 +297,7 @@ pub fn create_function(fcx: fn_ctxt) -> DISubprogram {\n     let ret_ty_md = if cx.sess.opts.extra_debuginfo {\n         match ret_ty.node {\n           ast::ty_nil => ptr::null(),\n-          _ => get_or_create_ty(cx, ty::node_id_to_type(cx.tcx, id), ret_ty.span)\n+          _ => get_or_create_type(cx, ty::node_id_to_type(cx.tcx, id), ret_ty.span)\n         }\n     } else {\n         ptr::null()\n@@ -397,7 +397,7 @@ fn get_or_create_file(cx: &mut CrateContext, full_path: &str) -> DIFile {\n \n \n \n-fn create_block(bcx: block) -> DILexicalBlock {\n+fn get_or_create_block(bcx: block) -> DILexicalBlock {\n     let mut bcx = bcx;\n     let cx = bcx.ccx();\n \n@@ -415,11 +415,11 @@ fn create_block(bcx: block) -> DILexicalBlock {\n         None => ()\n     }\n \n-    debug!(\"create_block: %s\", bcx.sess().codemap.span_to_str(span));\n+    debug!(\"get_or_create_block: %s\", bcx.sess().codemap.span_to_str(span));\n \n     let parent = match bcx.parent {\n         None => create_function(bcx.fcx),\n-        Some(b) => create_block(b)\n+        Some(b) => get_or_create_block(b)\n     };\n     let cx = bcx.ccx();\n     let loc = span_start(cx, span);\n@@ -508,7 +508,7 @@ fn create_struct(cx: &mut CrateContext,\n \n     let field_llvm_types = fields.map(|field| type_of::type_of(cx, field.mt.ty));\n     let field_names = fields.map(|field| cx.sess.str_of(field.ident).to_owned());\n-    let field_types_metadata = fields.map(|field| get_or_create_ty(cx, field.mt.ty, span));\n+    let field_types_metadata = fields.map(|field| get_or_create_type(cx, field.mt.ty, span));\n \n     return create_composite_type(\n         cx,\n@@ -533,7 +533,7 @@ fn create_tuple(cx: &mut CrateContext,\n     component_names.grow_fn(component_types.len(), |_| ~\"\");\n \n     let component_llvm_types = component_types.map(|it| type_of::type_of(cx, *it));\n-    let component_types_metadata = component_types.map(|it| get_or_create_ty(cx, *it, span));\n+    let component_types_metadata = component_types.map(|it| get_or_create_type(cx, *it, span));\n \n     return create_composite_type(\n         cx,\n@@ -545,6 +545,66 @@ fn create_tuple(cx: &mut CrateContext,\n         span);\n }\n \n+fn create_enum_md(cx: &mut CrateContext,\n+                  enum_type: ty::t,\n+                  enum_def_id: ast::def_id,\n+                  span: span) -> DIType {\n+\n+    let enum_name = ty_to_str(cx.tcx, enum_type);\n+    let discriminator_llvm_type = Type::enum_discrim(cx);\n+    let discriminator_size = machine::llsize_of_alloc(cx, discriminator_llvm_type);\n+    let discriminator_align = machine::llalign_of_min(cx, discriminator_llvm_type);\n+\n+    assert!(Type::enum_discrim(cx) == cx.int_type);\n+    let discriminator_type_md = get_or_create_type(cx, ty::mk_int(), span);\n+\n+    if ty::type_is_empty(cx.tcx, enum_type) {\n+        // XXX: This should not \"rename\" the type to nil\n+        return get_or_create_type(cx, ty::mk_nil(), span);\n+    }\n+\n+    if ty::type_is_c_like_enum(cx.tcx, enum_type) {\n+\n+        let variants : &[ty::VariantInfo] = *ty::enum_variants(cx.tcx, enum_def_id);\n+\n+        let enumerators : ~[(~str, int)] = variants\n+            .iter()\n+            .transform(|v| (cx.sess.str_of(v.name).to_owned(), v.disr_val))\n+            .collect();\n+\n+        let enumerators_md : ~[DIDescriptor] =\n+            do enumerators.iter().transform |&(name,value)| {\n+                do name.as_c_str |name| { unsafe {\n+                    llvm::LLVMDIBuilderCreateEnumerator(\n+                        DIB(cx),\n+                        name,\n+                        value as c_ulonglong)\n+                }}\n+            }.collect();\n+\n+        let loc = span_start(cx, span);\n+        let file_metadata = get_or_create_file(cx, loc.file.name);\n+\n+        return do enum_name.as_c_str |enum_name| { unsafe {\n+            llvm::LLVMDIBuilderCreateEnumerationType(\n+                DIB(cx),\n+                file_metadata,\n+                enum_name,\n+                file_metadata,\n+                loc.line as c_uint,\n+                bytes_to_bits(discriminator_size),\n+                bytes_to_bits(discriminator_align),\n+                create_DIArray(DIB(cx), enumerators_md),\n+                discriminator_type_md)\n+        }};\n+    }\n+\n+    cx.sess.bug(\"\");\n+}\n+\n+\n+\n+\n /// Creates debug information for a composite type, that is, anything that results in a LLVM struct.\n ///\n /// Examples of Rust types to use this are: structs, tuples, boxes, vecs, and enums.\n@@ -636,10 +696,10 @@ fn create_boxed_type(cx: &mut CrateContext,\n     let nil_pointer_type = ty::mk_nil_ptr(cx.tcx);\n \n     let member_types_metadata = [\n-        get_or_create_ty(cx, int_type, span),\n-        get_or_create_ty(cx, nil_pointer_type, span),\n-        get_or_create_ty(cx, nil_pointer_type, span),\n-        get_or_create_ty(cx, nil_pointer_type, span),\n+        get_or_create_type(cx, int_type, span),\n+        get_or_create_type(cx, nil_pointer_type, span),\n+        get_or_create_type(cx, nil_pointer_type, span),\n+        get_or_create_type(cx, nil_pointer_type, span),\n         content_type_metadata\n     ];\n \n@@ -671,7 +731,7 @@ fn create_fixed_vec(cx: &mut CrateContext, _vec_t: ty::t, elem_t: ty::t,\n                     len: uint, span: span) -> DIType {\n     debug!(\"create_fixed_vec: %?\", ty::get(_vec_t));\n \n-    let elem_ty_md = get_or_create_ty(cx, elem_t, span);\n+    let elem_ty_md = get_or_create_type(cx, elem_t, span);\n     let (size, align) = size_and_align_of(cx, elem_t);\n \n     let subrange = unsafe { llvm::LLVMDIBuilderGetOrCreateSubrange(\n@@ -695,15 +755,15 @@ fn create_boxed_vec(cx: &mut CrateContext,\n                     span: span)\n                  -> DICompositeType {\n \n-    let element_type_metadata = get_or_create_ty(cx, element_type, span);\n+    let element_type_metadata = get_or_create_type(cx, element_type, span);\n     let element_llvm_type = type_of::type_of(cx, element_type);\n     let vec_llvm_type = Type::vec(cx.sess.targ_cfg.arch, &element_llvm_type);\n     let vec_type_name = &\"vec\";\n \n     let member_llvm_types = vec_llvm_type.field_types();\n     let member_names = &[~\"fill\", ~\"alloc\", ~\"elements\"];\n \n-    let int_type_md = get_or_create_ty(cx, ty::mk_int(), span);\n+    let int_type_md = get_or_create_type(cx, ty::mk_int(), span);\n     let array_type_md = unsafe { llvm::LLVMDIBuilderCreateArrayType(\n         DIB(cx),\n         bytes_to_bits(machine::llsize_of_alloc(cx, element_llvm_type)),\n@@ -746,8 +806,8 @@ fn create_vec_slice(cx: &mut CrateContext,\n     let data_ptr_type = ty::mk_ptr(cx.tcx, ty::mt { ty: element_type, mutbl: ast::m_const });\n \n     let member_type_metadata = &[\n-        get_or_create_ty(cx, data_ptr_type, span),\n-        get_or_create_ty(cx, ty::mk_uint(), span)\n+        get_or_create_type(cx, data_ptr_type, span),\n+        get_or_create_type(cx, ty::mk_uint(), span)\n         ];\n \n     return create_composite_type(\n@@ -776,9 +836,9 @@ fn create_fn_ty(cx: &mut CrateContext, _fn_ty: ty::t, inputs: ~[ty::t], output:\n     let loc = span_start(cx, span);\n     let file_md = get_or_create_file(cx, loc.file.name);\n     let (vp, _, _) = voidptr(cx);\n-    let output_md = get_or_create_ty(cx, output, span);\n+    let output_md = get_or_create_type(cx, output, span);\n     let output_ptr_md = create_pointer_type(cx, output, span, output_md);\n-    let inputs_vals = do inputs.map |arg| { get_or_create_ty(cx, *arg, span) };\n+    let inputs_vals = do inputs.map |arg| { get_or_create_type(cx, *arg, span) };\n     let members = ~[output_ptr_md, vp] + inputs_vals;\n \n     return unsafe {\n@@ -804,14 +864,14 @@ fn create_unimpl_ty(cx: &mut CrateContext, t: ty::t) -> DIType {\n     return md;\n }\n \n-fn get_or_create_ty(cx: &mut CrateContext, t: ty::t, span: span) -> DIType {\n+fn get_or_create_type(cx: &mut CrateContext, t: ty::t, span: span) -> DIType {\n     let ty_id = ty::type_id(t);\n     match dbg_cx(cx).created_types.find(&ty_id) {\n         Some(ty_md) => return *ty_md,\n         None => ()\n     }\n \n-    debug!(\"get_or_create_ty: %?\", ty::get(t));\n+    debug!(\"get_or_create_type: %?\", ty::get(t));\n \n     let sty = copy ty::get(t).sty;\n     let ty_md = match sty {\n@@ -839,14 +899,15 @@ fn get_or_create_ty(cx: &mut CrateContext, t: ty::t, span: span) -> DIType {\n                 }\n             }\n         },\n-        ty::ty_enum(_did, ref _substs) => {\n-            cx.sess.span_note(span, \"debuginfo for enum NYI\");\n-            create_unimpl_ty(cx, t)\n+        ty::ty_enum(def_id, ref _substs) => {\n+            //cx.sess.span_note(span, \"debuginfo for enum NYI\");\n+            //create_unimpl_ty(cx, t)\n+            create_enum_md(cx, t, def_id, span)\n         },\n         ty::ty_box(ref mt) |\n         ty::ty_uniq(ref mt) => {\n             let content_llvm_type = type_of::type_of(cx, mt.ty);\n-            let content_type_metadata = get_or_create_ty(cx, mt.ty, span);\n+            let content_type_metadata = get_or_create_type(cx, mt.ty, span);\n \n             let box_metadata = create_boxed_type(cx,\n                                                  content_llvm_type,\n@@ -872,7 +933,7 @@ fn get_or_create_ty(cx: &mut CrateContext, t: ty::t, span: span) -> DIType {\n         },\n         ty::ty_ptr(ref mt) |\n         ty::ty_rptr(_, ref mt) => {\n-            let pointee = get_or_create_ty(cx, mt.ty, span);\n+            let pointee = get_or_create_type(cx, mt.ty, span);\n             create_pointer_type(cx, t, span, pointee)\n         },\n         ty::ty_bare_fn(ref barefnty) => {\n@@ -895,7 +956,7 @@ fn get_or_create_ty(cx: &mut CrateContext, t: ty::t, span: span) -> DIType {\n         ty::ty_tup(ref elements) => {\n             create_tuple(cx, t, *elements, span)\n         },\n-        _ => cx.sess.bug(\"debuginfo: unexpected type in get_or_create_ty\")\n+        _ => cx.sess.bug(\"debuginfo: unexpected type in get_or_create_type\")\n     };\n \n     dbg_cx(cx).created_types.insert(ty_id, ty_md);"}, {"sha": "27ba508293e947e48ff482119bfda14b19529e36", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/739f3eece9c341f4f1e70b8a0417853ed2a09cbc/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/739f3eece9c341f4f1e70b8a0417853ed2a09cbc/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=739f3eece9c341f4f1e70b8a0417853ed2a09cbc", "patch": "@@ -785,3 +785,33 @@ extern \"C\" LLVMValueRef LLVMDIBuilderInsertDeclareBefore(\n         unwrapDI<DIVariable>(VarInfo), \n         unwrap<Instruction>(InsertBefore)));\n }\n+\n+extern \"C\" LLVMValueRef LLVMDIBuilderCreateEnumerator(\n+    DIBuilderRef Builder,\n+    const char* Name,\n+    uint64_t Val)\n+{\n+    return wrap(Builder->createEnumerator(Name, Val));\n+}\n+\n+extern \"C\" LLVMValueRef LLVMDIBuilderCreateEnumerationType(\n+    DIBuilderRef Builder,\n+    LLVMValueRef Scope,\n+    const char* Name,\n+    LLVMValueRef File,\n+    unsigned LineNumber,\n+    uint64_t SizeInBits,\n+    uint64_t AlignInBits,\n+    LLVMValueRef Elements,\n+    LLVMValueRef ClassType)\n+{\n+    return wrap(Builder->createEnumerationType(\n+        unwrapDI<DIDescriptor>(Scope),\n+        Name,\n+        unwrapDI<DIFile>(File),\n+        LineNumber,\n+        SizeInBits,\n+        AlignInBits,\n+        unwrapDI<DIArray>(Elements),\n+        unwrapDI<DIType>(ClassType)));\n+}\n\\ No newline at end of file"}, {"sha": "8e46816d41c35e50c62e948f6eaa0ed628cb0b35", "filename": "src/test/debug-info/borrowed-basic.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/739f3eece9c341f4f1e70b8a0417853ed2a09cbc/src%2Ftest%2Fdebug-info%2Fborrowed-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/739f3eece9c341f4f1e70b8a0417853ed2a09cbc/src%2Ftest%2Fdebug-info%2Fborrowed-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fborrowed-basic.rs?ref=739f3eece9c341f4f1e70b8a0417853ed2a09cbc", "patch": "@@ -10,10 +10,7 @@\n \n // xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n \n-// Caveats - gdb prints any 8-bit value (meaning rust i8 and u8 values)\n-// as its numerical value along with its associated ASCII char, there\n-// doesn't seem to be any way around this. Also, gdb doesn't know\n-// about UTF-32 character encoding and will print a rust char as only\n+// Gdb doesn't know about UTF-32 character encoding and will print a rust char as only\n // its numerical value.\n \n // compile-flags:-Z extra-debug-info"}, {"sha": "2ca4c5a4397f7ff1619f571bb08913fc1da63759", "filename": "src/test/debug-info/borrowed-c-style-enum.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/739f3eece9c341f4f1e70b8a0417853ed2a09cbc/src%2Ftest%2Fdebug-info%2Fborrowed-c-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/739f3eece9c341f4f1e70b8a0417853ed2a09cbc/src%2Ftest%2Fdebug-info%2Fborrowed-c-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fborrowed-c-style-enum.rs?ref=739f3eece9c341f4f1e70b8a0417853ed2a09cbc", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print *the_a_ref\n+// check:$1 = TheA\n+\n+// debugger:print *the_b_ref\n+// check:$2 = TheB\n+\n+// debugger:print *the_c_ref\n+// check:$3 = TheC\n+\n+enum ABC { TheA, TheB, TheC }\n+\n+fn main() {\n+    let the_a = TheA;\n+    let the_a_ref : &ABC = &the_a;\n+\n+    let the_b = TheB;\n+    let the_b_ref : &ABC = &the_b;\n+\n+    let the_c = TheC;\n+    let the_c_ref : &ABC = &the_c;\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "601d8ed441c1359d50e4345019408cdaa286039d", "filename": "src/test/debug-info/c-style-enum-in-composite.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/739f3eece9c341f4f1e70b8a0417853ed2a09cbc/src%2Ftest%2Fdebug-info%2Fc-style-enum-in-composite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/739f3eece9c341f4f1e70b8a0417853ed2a09cbc/src%2Ftest%2Fdebug-info%2Fc-style-enum-in-composite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fc-style-enum-in-composite.rs?ref=739f3eece9c341f4f1e70b8a0417853ed2a09cbc", "patch": "@@ -0,0 +1,117 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print tuple_interior_padding\n+// check:$1 = {0, OneHundred}\n+\n+// debugger:print tuple_padding_at_end\n+// check:$2 = {{1, OneThousand}, 2}\n+\n+// debugger:print tuple_different_enums\n+// check:$3 = {OneThousand, MountainView, OneMillion, Vienna}\n+\n+// debugger:print padded_struct\n+// check:$4 = {a = 3, b = OneMillion, c = 4, d = Toronto, e = 5}\n+\n+// debugger:print packed_struct\n+// check:$5 = {a = 6, b = OneHundred, c = 7, d = Vienna, e = 8}\n+\n+// debugger:print non_padded_struct\n+// check:$6 = {a = OneMillion, b = MountainView, c = OneThousand, d = Toronto}\n+\n+// debugger:print struct_with_drop\n+// check:$7 = {{a = OneHundred, b = Vienna}, 9}\n+\n+enum AnEnum {\n+    OneHundred = 100,\n+    OneThousand = 1000,\n+    OneMillion = 1000000\n+}\n+\n+enum AnotherEnum {\n+    MountainView,\n+    Toronto,\n+    Vienna\n+}\n+\n+struct PaddedStruct {\n+    a: i16,\n+    b: AnEnum,\n+    c: i16,\n+    d: AnotherEnum,\n+    e: i16\n+}\n+\n+#[packed]\n+struct PackedStruct {\n+    a: i16,\n+    b: AnEnum,\n+    c: i16,\n+    d: AnotherEnum,\n+    e: i16\n+}\n+\n+struct NonPaddedStruct {\n+    a: AnEnum,\n+    b: AnotherEnum,\n+    c: AnEnum,\n+    d: AnotherEnum\n+}\n+\n+struct StructWithDrop {\n+    a: AnEnum,\n+    b: AnotherEnum\n+}\n+\n+impl Drop for StructWithDrop {\n+    fn drop(&self) {()}\n+}\n+\n+fn main() {\n+\n+    let tuple_interior_padding = (0_i16, OneHundred);\n+    // It will depend on the machine architecture if any padding is actually involved here\n+    let tuple_padding_at_end = ((1_u64, OneThousand), 2_u64);\n+    let tuple_different_enums = (OneThousand, MountainView, OneMillion, Vienna);\n+\n+    let padded_struct = PaddedStruct {\n+        a: 3,\n+        b: OneMillion,\n+        c: 4,\n+        d: Toronto,\n+        e: 5\n+    };\n+\n+    let packed_struct = PackedStruct {\n+        a: 6,\n+        b: OneHundred,\n+        c: 7,\n+        d: Vienna,\n+        e: 8\n+    };\n+\n+    let non_padded_struct = NonPaddedStruct {\n+        a: OneMillion,\n+        b: MountainView,\n+        c: OneThousand,\n+        d: Toronto\n+    };\n+\n+    let struct_with_drop = (StructWithDrop { a: OneHundred, b: Vienna }, 9_i64);\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "408e98102663a5af93e0b08ad713b6cf036052b2", "filename": "src/test/debug-info/c-style-enum.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/739f3eece9c341f4f1e70b8a0417853ed2a09cbc/src%2Ftest%2Fdebug-info%2Fc-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/739f3eece9c341f4f1e70b8a0417853ed2a09cbc/src%2Ftest%2Fdebug-info%2Fc-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fc-style-enum.rs?ref=739f3eece9c341f4f1e70b8a0417853ed2a09cbc", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print auto_one\n+// check:$1 = One\n+\n+// debugger:print auto_two\n+// check:$2 = Two\n+\n+// debugger:print auto_three\n+// check:$3 = Three\n+\n+// debugger:print manual_one_hundred\n+// check:$4 = OneHundred\n+\n+// debugger:print manual_one_thousand\n+// check:$5 = OneThousand\n+\n+// debugger:print manual_one_million\n+// check:$6 = OneMillion\n+\n+\n+enum AutoDiscriminator {\n+    One,\n+    Two,\n+    Three\n+}\n+\n+enum ManualDiscriminator {\n+    OneHundred = 100,\n+    OneThousand = 1000,\n+    OneMillion = 1000000\n+}\n+\n+fn main() {\n+\n+    let auto_one = One;\n+    let auto_two = Two;\n+    let auto_three = Three;\n+\n+    let manual_one_hundred = OneHundred;\n+    let manual_one_thousand = OneThousand;\n+    let manual_one_million = OneMillion;\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}]}