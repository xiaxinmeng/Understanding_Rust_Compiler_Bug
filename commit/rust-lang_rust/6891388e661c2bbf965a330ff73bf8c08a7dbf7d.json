{"sha": "6891388e661c2bbf965a330ff73bf8c08a7dbf7d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4OTEzODhlNjYxYzJiYmY5NjVhMzMwZmY3M2JmOGMwOGE3ZGJmN2Q=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-12-24T22:38:22Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-12-24T22:38:22Z"}, "message": "x.py fmt after previous deignore", "tree": {"sha": "ff2f518c1dfdb558a162c73b3ee3f2a0b44d5adc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff2f518c1dfdb558a162c73b3ee3f2a0b44d5adc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6891388e661c2bbf965a330ff73bf8c08a7dbf7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6891388e661c2bbf965a330ff73bf8c08a7dbf7d", "html_url": "https://github.com/rust-lang/rust/commit/6891388e661c2bbf965a330ff73bf8c08a7dbf7d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48291a9dda821a81957b44034572c0ec62728f35", "url": "https://api.github.com/repos/rust-lang/rust/commits/48291a9dda821a81957b44034572c0ec62728f35", "html_url": "https://github.com/rust-lang/rust/commit/48291a9dda821a81957b44034572c0ec62728f35"}], "stats": {"total": 19432, "additions": 9637, "deletions": 9795}, "files": [{"sha": "6eb837ed0fed8d20f1395a6c7777cc9e7eb77210", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 456, "deletions": 267, "changes": 723, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d", "patch": "@@ -1,11 +1,11 @@\n use crate::cmp;\n use crate::fmt;\n+use crate::intrinsics;\n use crate::ops::{Add, AddAssign, Try};\n use crate::usize;\n-use crate::intrinsics;\n \n-use super::{Iterator, DoubleEndedIterator, ExactSizeIterator, FusedIterator, TrustedLen};\n-use super::{LoopState, from_fn};\n+use super::{from_fn, LoopState};\n+use super::{DoubleEndedIterator, ExactSizeIterator, FusedIterator, Iterator, TrustedLen};\n \n mod chain;\n mod flatten;\n@@ -14,8 +14,8 @@ mod zip;\n pub use self::chain::Chain;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::flatten::{FlatMap, Flatten};\n-pub use self::zip::Zip;\n pub(crate) use self::zip::TrustedRandomAccess;\n+pub use self::zip::Zip;\n \n /// A double-ended iterator with the direction inverted.\n ///\n@@ -28,7 +28,7 @@ pub(crate) use self::zip::TrustedRandomAccess;\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rev<T> {\n-    iter: T\n+    iter: T,\n }\n impl<T> Rev<T> {\n     pub(super) fn new(iter: T) -> Rev<T> {\n@@ -37,67 +37,94 @@ impl<T> Rev<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n+impl<I> Iterator for Rev<I>\n+where\n+    I: DoubleEndedIterator,\n+{\n     type Item = <I as Iterator>::Item;\n \n     #[inline]\n-    fn next(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next_back() }\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n+        self.iter.next_back()\n+    }\n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n \n     #[inline]\n-    fn nth(&mut self, n: usize) -> Option<<I as Iterator>::Item> { self.iter.nth_back(n) }\n+    fn nth(&mut self, n: usize) -> Option<<I as Iterator>::Item> {\n+        self.iter.nth_back(n)\n+    }\n \n-    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R where\n-        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n     {\n         self.iter.try_rfold(init, f)\n     }\n \n     fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.iter.rfold(init, f)\n     }\n \n     #[inline]\n     fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n-        where P: FnMut(&Self::Item) -> bool\n+    where\n+        P: FnMut(&Self::Item) -> bool,\n     {\n         self.iter.rfind(predicate)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n+impl<I> DoubleEndedIterator for Rev<I>\n+where\n+    I: DoubleEndedIterator,\n+{\n     #[inline]\n-    fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next() }\n+    fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n+        self.iter.next()\n+    }\n \n     #[inline]\n-    fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item> { self.iter.nth(n) }\n+    fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item> {\n+        self.iter.nth(n)\n+    }\n \n-    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R where\n-        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n     {\n         self.iter.try_fold(init, f)\n     }\n \n     fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.iter.fold(init, f)\n     }\n \n     fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n-        where P: FnMut(&Self::Item) -> bool\n+    where\n+        P: FnMut(&Self::Item) -> bool,\n     {\n         self.iter.find(predicate)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> ExactSizeIterator for Rev<I>\n-    where I: ExactSizeIterator + DoubleEndedIterator\n+where\n+    I: ExactSizeIterator + DoubleEndedIterator,\n {\n     fn len(&self) -> usize {\n         self.iter.len()\n@@ -109,12 +136,10 @@ impl<I> ExactSizeIterator for Rev<I>\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> FusedIterator for Rev<I>\n-    where I: FusedIterator + DoubleEndedIterator {}\n+impl<I> FusedIterator for Rev<I> where I: FusedIterator + DoubleEndedIterator {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<I> TrustedLen for Rev<I>\n-    where I: TrustedLen + DoubleEndedIterator {}\n+unsafe impl<I> TrustedLen for Rev<I> where I: TrustedLen + DoubleEndedIterator {}\n \n /// An iterator that copies the elements of an underlying iterator.\n ///\n@@ -136,21 +161,19 @@ impl<I> Copied<I> {\n     }\n }\n \n-fn copy_fold<T: Copy, Acc>(\n-    mut f: impl FnMut(Acc, T) -> Acc,\n-) -> impl FnMut(Acc, &T) -> Acc {\n+fn copy_fold<T: Copy, Acc>(mut f: impl FnMut(Acc, T) -> Acc) -> impl FnMut(Acc, &T) -> Acc {\n     move |acc, &elt| f(acc, elt)\n }\n \n-fn copy_try_fold<T: Copy, Acc, R>(\n-    mut f: impl FnMut(Acc, T) -> R,\n-) -> impl FnMut(Acc, &T) -> R {\n+fn copy_try_fold<T: Copy, Acc, R>(mut f: impl FnMut(Acc, T) -> R) -> impl FnMut(Acc, &T) -> R {\n     move |acc, &elt| f(acc, elt)\n }\n \n #[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n impl<'a, I, T: 'a> Iterator for Copied<I>\n-    where I: Iterator<Item=&'a T>, T: Copy\n+where\n+    I: Iterator<Item = &'a T>,\n+    T: Copy,\n {\n     type Item = T;\n \n@@ -162,43 +185,55 @@ impl<'a, I, T: 'a> Iterator for Copied<I>\n         self.it.size_hint()\n     }\n \n-    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R where\n-        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n     {\n         self.it.try_fold(init, copy_try_fold(f))\n     }\n \n     fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.it.fold(init, copy_fold(f))\n     }\n }\n \n #[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n impl<'a, I, T: 'a> DoubleEndedIterator for Copied<I>\n-    where I: DoubleEndedIterator<Item=&'a T>, T: Copy\n+where\n+    I: DoubleEndedIterator<Item = &'a T>,\n+    T: Copy,\n {\n     fn next_back(&mut self) -> Option<T> {\n         self.it.next_back().copied()\n     }\n \n-    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R where\n-        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n     {\n         self.it.try_rfold(init, copy_try_fold(f))\n     }\n \n     fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.it.rfold(init, copy_fold(f))\n     }\n }\n \n #[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n impl<'a, I, T: 'a> ExactSizeIterator for Copied<I>\n-    where I: ExactSizeIterator<Item=&'a T>, T: Copy\n+where\n+    I: ExactSizeIterator<Item = &'a T>,\n+    T: Copy,\n {\n     fn len(&self) -> usize {\n         self.it.len()\n@@ -211,12 +246,17 @@ impl<'a, I, T: 'a> ExactSizeIterator for Copied<I>\n \n #[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n impl<'a, I, T: 'a> FusedIterator for Copied<I>\n-    where I: FusedIterator<Item=&'a T>, T: Copy\n-{}\n+where\n+    I: FusedIterator<Item = &'a T>,\n+    T: Copy,\n+{\n+}\n \n #[doc(hidden)]\n unsafe impl<'a, I, T: 'a> TrustedRandomAccess for Copied<I>\n-    where I: TrustedRandomAccess<Item=&'a T>, T: Copy\n+where\n+    I: TrustedRandomAccess<Item = &'a T>,\n+    T: Copy,\n {\n     unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n         *self.it.get_unchecked(i)\n@@ -230,9 +270,11 @@ unsafe impl<'a, I, T: 'a> TrustedRandomAccess for Copied<I>\n \n #[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n unsafe impl<'a, I, T: 'a> TrustedLen for Copied<I>\n-    where I: TrustedLen<Item=&'a T>,\n-          T: Copy\n-{}\n+where\n+    I: TrustedLen<Item = &'a T>,\n+    T: Copy,\n+{\n+}\n \n /// An iterator that clones the elements of an underlying iterator.\n ///\n@@ -253,15 +295,15 @@ impl<I> Cloned<I> {\n     }\n }\n \n-fn clone_try_fold<T: Clone, Acc, R>(\n-    mut f: impl FnMut(Acc, T) -> R,\n-) -> impl FnMut(Acc, &T) -> R {\n+fn clone_try_fold<T: Clone, Acc, R>(mut f: impl FnMut(Acc, T) -> R) -> impl FnMut(Acc, &T) -> R {\n     move |acc, elt| f(acc, elt.clone())\n }\n \n #[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n impl<'a, I, T: 'a> Iterator for Cloned<I>\n-    where I: Iterator<Item=&'a T>, T: Clone\n+where\n+    I: Iterator<Item = &'a T>,\n+    T: Clone,\n {\n     type Item = T;\n \n@@ -273,43 +315,55 @@ impl<'a, I, T: 'a> Iterator for Cloned<I>\n         self.it.size_hint()\n     }\n \n-    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R where\n-        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n     {\n         self.it.try_fold(init, clone_try_fold(f))\n     }\n \n     fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.it.map(T::clone).fold(init, f)\n     }\n }\n \n #[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n impl<'a, I, T: 'a> DoubleEndedIterator for Cloned<I>\n-    where I: DoubleEndedIterator<Item=&'a T>, T: Clone\n+where\n+    I: DoubleEndedIterator<Item = &'a T>,\n+    T: Clone,\n {\n     fn next_back(&mut self) -> Option<T> {\n         self.it.next_back().cloned()\n     }\n \n-    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R where\n-        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n     {\n         self.it.try_rfold(init, clone_try_fold(f))\n     }\n \n     fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.it.map(T::clone).rfold(init, f)\n     }\n }\n \n #[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n impl<'a, I, T: 'a> ExactSizeIterator for Cloned<I>\n-    where I: ExactSizeIterator<Item=&'a T>, T: Clone\n+where\n+    I: ExactSizeIterator<Item = &'a T>,\n+    T: Clone,\n {\n     fn len(&self) -> usize {\n         self.it.len()\n@@ -322,24 +376,33 @@ impl<'a, I, T: 'a> ExactSizeIterator for Cloned<I>\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, I, T: 'a> FusedIterator for Cloned<I>\n-    where I: FusedIterator<Item=&'a T>, T: Clone\n-{}\n+where\n+    I: FusedIterator<Item = &'a T>,\n+    T: Clone,\n+{\n+}\n \n #[doc(hidden)]\n unsafe impl<'a, I, T: 'a> TrustedRandomAccess for Cloned<I>\n-    where I: TrustedRandomAccess<Item=&'a T>, T: Clone\n+where\n+    I: TrustedRandomAccess<Item = &'a T>,\n+    T: Clone,\n {\n     default unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n         self.it.get_unchecked(i).clone()\n     }\n \n     #[inline]\n-    default fn may_have_side_effect() -> bool { true }\n+    default fn may_have_side_effect() -> bool {\n+        true\n+    }\n }\n \n #[doc(hidden)]\n unsafe impl<'a, I, T: 'a> TrustedRandomAccess for Cloned<I>\n-    where I: TrustedRandomAccess<Item=&'a T>, T: Copy\n+where\n+    I: TrustedRandomAccess<Item = &'a T>,\n+    T: Copy,\n {\n     unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n         *self.it.get_unchecked(i)\n@@ -353,9 +416,11 @@ unsafe impl<'a, I, T: 'a> TrustedRandomAccess for Cloned<I>\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<'a, I, T: 'a> TrustedLen for Cloned<I>\n-    where I: TrustedLen<Item=&'a T>,\n-          T: Clone\n-{}\n+where\n+    I: TrustedLen<Item = &'a T>,\n+    T: Clone,\n+{\n+}\n \n /// An iterator that repeats endlessly.\n ///\n@@ -378,14 +443,20 @@ impl<I: Clone> Cycle<I> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n+impl<I> Iterator for Cycle<I>\n+where\n+    I: Clone + Iterator,\n+{\n     type Item = <I as Iterator>::Item;\n \n     #[inline]\n     fn next(&mut self) -> Option<<I as Iterator>::Item> {\n         match self.iter.next() {\n-            None => { self.iter = self.orig.clone(); self.iter.next() }\n-            y => y\n+            None => {\n+                self.iter = self.orig.clone();\n+                self.iter.next()\n+            }\n+            y => y,\n         }\n     }\n \n@@ -395,7 +466,7 @@ impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n         match self.orig.size_hint() {\n             sz @ (0, Some(0)) => sz,\n             (0, _) => (0, None),\n-            _ => (usize::MAX, None)\n+            _ => (usize::MAX, None),\n         }\n     }\n \n@@ -456,7 +527,10 @@ impl<I> StepBy<I> {\n }\n \n #[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n-impl<I> Iterator for StepBy<I> where I: Iterator {\n+impl<I> Iterator for StepBy<I>\n+where\n+    I: Iterator,\n+{\n     type Item = I::Item;\n \n     #[inline]\n@@ -558,7 +632,10 @@ impl<I> Iterator for StepBy<I> where I: Iterator {\n     }\n }\n \n-impl<I> StepBy<I> where I: ExactSizeIterator {\n+impl<I> StepBy<I>\n+where\n+    I: ExactSizeIterator,\n+{\n     // The zero-based index starting from the end of the iterator of the\n     // last element. Used in the `DoubleEndedIterator` implementation.\n     fn next_back_index(&self) -> usize {\n@@ -572,7 +649,10 @@ impl<I> StepBy<I> where I: ExactSizeIterator {\n }\n \n #[stable(feature = \"double_ended_step_by_iterator\", since = \"1.38.0\")]\n-impl<I> DoubleEndedIterator for StepBy<I> where I: DoubleEndedIterator + ExactSizeIterator {\n+impl<I> DoubleEndedIterator for StepBy<I>\n+where\n+    I: DoubleEndedIterator + ExactSizeIterator,\n+{\n     #[inline]\n     fn next_back(&mut self) -> Option<Self::Item> {\n         self.iter.nth_back(self.next_back_index())\n@@ -584,9 +664,7 @@ impl<I> DoubleEndedIterator for StepBy<I> where I: DoubleEndedIterator + ExactSi\n         // is out of bounds because the length of `self.iter` does not exceed\n         // `usize::MAX` (because `I: ExactSizeIterator`) and `nth_back` is\n         // zero-indexed\n-        let n = n\n-            .saturating_mul(self.step + 1)\n-            .saturating_add(self.next_back_index());\n+        let n = n.saturating_mul(self.step + 1).saturating_add(self.next_back_index());\n         self.iter.nth_back(n)\n     }\n \n@@ -683,9 +761,7 @@ impl<I, F> Map<I, F> {\n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n impl<I: fmt::Debug, F> fmt::Debug for Map<I, F> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Map\")\n-            .field(\"iter\", &self.iter)\n-            .finish()\n+        f.debug_struct(\"Map\").field(\"iter\", &self.iter).finish()\n     }\n }\n \n@@ -704,7 +780,10 @@ fn map_try_fold<'a, T, B, Acc, R>(\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I: Iterator, F> Iterator for Map<I, F> where F: FnMut(I::Item) -> B {\n+impl<B, I: Iterator, F> Iterator for Map<I, F>\n+where\n+    F: FnMut(I::Item) -> B,\n+{\n     type Item = B;\n \n     #[inline]\n@@ -717,44 +796,54 @@ impl<B, I: Iterator, F> Iterator for Map<I, F> where F: FnMut(I::Item) -> B {\n         self.iter.size_hint()\n     }\n \n-    fn try_fold<Acc, G, R>(&mut self, init: Acc, g: G) -> R where\n-        Self: Sized, G: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_fold<Acc, G, R>(&mut self, init: Acc, g: G) -> R\n+    where\n+        Self: Sized,\n+        G: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         self.iter.try_fold(init, map_try_fold(&mut self.f, g))\n     }\n \n     fn fold<Acc, G>(self, init: Acc, g: G) -> Acc\n-        where G: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        G: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.iter.fold(init, map_fold(self.f, g))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for Map<I, F> where\n+impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for Map<I, F>\n+where\n     F: FnMut(I::Item) -> B,\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<B> {\n         self.iter.next_back().map(&mut self.f)\n     }\n \n-    fn try_rfold<Acc, G, R>(&mut self, init: Acc, g: G) -> R where\n-        Self: Sized, G: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_rfold<Acc, G, R>(&mut self, init: Acc, g: G) -> R\n+    where\n+        Self: Sized,\n+        G: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         self.iter.try_rfold(init, map_try_fold(&mut self.f, g))\n     }\n \n     fn rfold<Acc, G>(self, init: Acc, g: G) -> Acc\n-        where G: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        G: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.iter.rfold(init, map_fold(self.f, g))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<B, I: ExactSizeIterator, F> ExactSizeIterator for Map<I, F>\n-    where F: FnMut(I::Item) -> B\n+where\n+    F: FnMut(I::Item) -> B,\n {\n     fn len(&self) -> usize {\n         self.iter.len()\n@@ -766,24 +855,29 @@ impl<B, I: ExactSizeIterator, F> ExactSizeIterator for Map<I, F>\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<B, I: FusedIterator, F> FusedIterator for Map<I, F>\n-    where F: FnMut(I::Item) -> B {}\n+impl<B, I: FusedIterator, F> FusedIterator for Map<I, F> where F: FnMut(I::Item) -> B {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<B, I, F> TrustedLen for Map<I, F>\n-    where I: TrustedLen,\n-          F: FnMut(I::Item) -> B {}\n+where\n+    I: TrustedLen,\n+    F: FnMut(I::Item) -> B,\n+{\n+}\n \n #[doc(hidden)]\n unsafe impl<B, I, F> TrustedRandomAccess for Map<I, F>\n-    where I: TrustedRandomAccess,\n-          F: FnMut(I::Item) -> B,\n+where\n+    I: TrustedRandomAccess,\n+    F: FnMut(I::Item) -> B,\n {\n     unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n         (self.f)(self.iter.get_unchecked(i))\n     }\n     #[inline]\n-    fn may_have_side_effect() -> bool { true }\n+    fn may_have_side_effect() -> bool {\n+        true\n+    }\n }\n \n /// An iterator that filters the elements of `iter` with `predicate`.\n@@ -809,9 +903,7 @@ impl<I, P> Filter<I, P> {\n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n impl<I: fmt::Debug, P> fmt::Debug for Filter<I, P> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Filter\")\n-            .field(\"iter\", &self.iter)\n-            .finish()\n+        f.debug_struct(\"Filter\").field(\"iter\", &self.iter).finish()\n     }\n }\n \n@@ -830,7 +922,10 @@ fn filter_try_fold<'a, T, Acc, R: Try<Ok = Acc>>(\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator, P> Iterator for Filter<I, P> where P: FnMut(&I::Item) -> bool {\n+impl<I: Iterator, P> Iterator for Filter<I, P>\n+where\n+    P: FnMut(&I::Item) -> bool,\n+{\n     type Item = I::Item;\n \n     #[inline]\n@@ -866,47 +961,55 @@ impl<I: Iterator, P> Iterator for Filter<I, P> where P: FnMut(&I::Item) -> bool\n     }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         self.iter.try_fold(init, filter_try_fold(&mut self.predicate, fold))\n     }\n \n     #[inline]\n     fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.iter.fold(init, filter_fold(self.predicate, fold))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: DoubleEndedIterator, P> DoubleEndedIterator for Filter<I, P>\n-    where P: FnMut(&I::Item) -> bool,\n+where\n+    P: FnMut(&I::Item) -> bool,\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<I::Item> {\n         self.iter.rfind(&mut self.predicate)\n     }\n \n     #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         self.iter.try_rfold(init, filter_try_fold(&mut self.predicate, fold))\n     }\n \n     #[inline]\n     fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.iter.rfold(init, filter_fold(self.predicate, fold))\n     }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I: FusedIterator, P> FusedIterator for Filter<I, P>\n-    where P: FnMut(&I::Item) -> bool {}\n+impl<I: FusedIterator, P> FusedIterator for Filter<I, P> where P: FnMut(&I::Item) -> bool {}\n \n /// An iterator that uses `f` to both filter and map elements from `iter`.\n ///\n@@ -931,9 +1034,7 @@ impl<I, F> FilterMap<I, F> {\n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n impl<I: fmt::Debug, F> fmt::Debug for FilterMap<I, F> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"FilterMap\")\n-            .field(\"iter\", &self.iter)\n-            .finish()\n+        f.debug_struct(\"FilterMap\").field(\"iter\", &self.iter).finish()\n     }\n }\n \n@@ -959,7 +1060,8 @@ fn filter_map_try_fold<'a, T, B, Acc, R: Try<Ok = Acc>>(\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n-    where F: FnMut(I::Item) -> Option<B>,\n+where\n+    F: FnMut(I::Item) -> Option<B>,\n {\n     type Item = B;\n \n@@ -975,29 +1077,34 @@ impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n     }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         self.iter.try_fold(init, filter_map_try_fold(&mut self.f, fold))\n     }\n \n     #[inline]\n     fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.iter.fold(init, filter_map_fold(self.f, fold))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for FilterMap<I, F>\n-    where F: FnMut(I::Item) -> Option<B>,\n+where\n+    F: FnMut(I::Item) -> Option<B>,\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<B> {\n         #[inline]\n         fn find<T, B>(\n-            f: &mut impl FnMut(T) -> Option<B>\n+            f: &mut impl FnMut(T) -> Option<B>,\n         ) -> impl FnMut((), T) -> LoopState<(), B> + '_ {\n             move |(), x| match f(x) {\n                 Some(x) => LoopState::Break(x),\n@@ -1009,23 +1116,26 @@ impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for FilterMap<I, F>\n     }\n \n     #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         self.iter.try_rfold(init, filter_map_try_fold(&mut self.f, fold))\n     }\n \n     #[inline]\n     fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.iter.rfold(init, filter_map_fold(self.f, fold))\n     }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<B, I: FusedIterator, F> FusedIterator for FilterMap<I, F>\n-    where F: FnMut(I::Item) -> Option<B> {}\n+impl<B, I: FusedIterator, F> FusedIterator for FilterMap<I, F> where F: FnMut(I::Item) -> Option<B> {}\n \n /// An iterator that yields the current count and the element during iteration.\n ///\n@@ -1048,7 +1158,10 @@ impl<I> Enumerate<I> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Enumerate<I> where I: Iterator {\n+impl<I> Iterator for Enumerate<I>\n+where\n+    I: Iterator,\n+{\n     type Item = (usize, <I as Iterator>::Item);\n \n     /// # Overflow Behavior\n@@ -1089,8 +1202,11 @@ impl<I> Iterator for Enumerate<I> where I: Iterator {\n     }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         #[inline]\n         fn enumerate<'a, T, Acc, R>(\n@@ -1110,7 +1226,8 @@ impl<I> Iterator for Enumerate<I> where I: Iterator {\n \n     #[inline]\n     fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         #[inline]\n         fn enumerate<T, Acc>(\n@@ -1130,8 +1247,9 @@ impl<I> Iterator for Enumerate<I> where I: Iterator {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> DoubleEndedIterator for Enumerate<I> where\n-    I: ExactSizeIterator + DoubleEndedIterator\n+impl<I> DoubleEndedIterator for Enumerate<I>\n+where\n+    I: ExactSizeIterator + DoubleEndedIterator,\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n@@ -1152,8 +1270,11 @@ impl<I> DoubleEndedIterator for Enumerate<I> where\n     }\n \n     #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         // Can safely add and subtract the count, as `ExactSizeIterator` promises\n         // that the number of elements fits into a `usize`.\n@@ -1173,7 +1294,8 @@ impl<I> DoubleEndedIterator for Enumerate<I> where\n \n     #[inline]\n     fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         // Can safely add and subtract the count, as `ExactSizeIterator` promises\n         // that the number of elements fits into a `usize`.\n@@ -1193,7 +1315,10 @@ impl<I> DoubleEndedIterator for Enumerate<I> where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> ExactSizeIterator for Enumerate<I> where I: ExactSizeIterator {\n+impl<I> ExactSizeIterator for Enumerate<I>\n+where\n+    I: ExactSizeIterator,\n+{\n     fn len(&self) -> usize {\n         self.iter.len()\n     }\n@@ -1205,7 +1330,8 @@ impl<I> ExactSizeIterator for Enumerate<I> where I: ExactSizeIterator {\n \n #[doc(hidden)]\n unsafe impl<I> TrustedRandomAccess for Enumerate<I>\n-    where I: TrustedRandomAccess\n+where\n+    I: TrustedRandomAccess,\n {\n     unsafe fn get_unchecked(&mut self, i: usize) -> (usize, I::Item) {\n         (self.count + i, self.iter.get_unchecked(i))\n@@ -1220,10 +1346,7 @@ unsafe impl<I> TrustedRandomAccess for Enumerate<I>\n impl<I> FusedIterator for Enumerate<I> where I: FusedIterator {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<I> TrustedLen for Enumerate<I>\n-    where I: TrustedLen,\n-{}\n-\n+unsafe impl<I> TrustedLen for Enumerate<I> where I: TrustedLen {}\n \n /// An iterator with a `peek()` that returns an optional reference to the next\n /// element.\n@@ -1310,8 +1433,11 @@ impl<I: Iterator> Iterator for Peekable<I> {\n     }\n \n     #[inline]\n-    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n-        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n     {\n         let acc = match self.peeked.take() {\n             Some(None) => return Try::from_ok(init),\n@@ -1323,7 +1449,8 @@ impl<I: Iterator> Iterator for Peekable<I> {\n \n     #[inline]\n     fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         let acc = match self.peeked {\n             Some(None) => return init,\n@@ -1335,15 +1462,21 @@ impl<I: Iterator> Iterator for Peekable<I> {\n }\n \n #[stable(feature = \"double_ended_peek_iterator\", since = \"1.38.0\")]\n-impl<I> DoubleEndedIterator for Peekable<I> where I: DoubleEndedIterator {\n+impl<I> DoubleEndedIterator for Peekable<I>\n+where\n+    I: DoubleEndedIterator,\n+{\n     #[inline]\n     fn next_back(&mut self) -> Option<Self::Item> {\n         self.iter.next_back().or_else(|| self.peeked.take().and_then(|x| x))\n     }\n \n     #[inline]\n-    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n-        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n     {\n         match self.peeked.take() {\n             Some(None) => Try::from_ok(init),\n@@ -1360,7 +1493,8 @@ impl<I> DoubleEndedIterator for Peekable<I> where I: DoubleEndedIterator {\n \n     #[inline]\n     fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         match self.peeked {\n             Some(None) => init,\n@@ -1449,16 +1583,14 @@ impl<I, P> SkipWhile<I, P> {\n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n impl<I: fmt::Debug, P> fmt::Debug for SkipWhile<I, P> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"SkipWhile\")\n-            .field(\"iter\", &self.iter)\n-            .field(\"flag\", &self.flag)\n-            .finish()\n+        f.debug_struct(\"SkipWhile\").field(\"iter\", &self.iter).field(\"flag\", &self.flag).finish()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: Iterator, P> Iterator for SkipWhile<I, P>\n-    where P: FnMut(&I::Item) -> bool\n+where\n+    P: FnMut(&I::Item) -> bool,\n {\n     type Item = I::Item;\n \n@@ -1490,8 +1622,11 @@ impl<I: Iterator, P> Iterator for SkipWhile<I, P>\n     }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_fold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         if !self.flag {\n             match self.next() {\n@@ -1504,7 +1639,8 @@ impl<I: Iterator, P> Iterator for SkipWhile<I, P>\n \n     #[inline]\n     fn fold<Acc, Fold>(mut self, mut init: Acc, mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         if !self.flag {\n             match self.next() {\n@@ -1518,7 +1654,11 @@ impl<I: Iterator, P> Iterator for SkipWhile<I, P>\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I, P> FusedIterator for SkipWhile<I, P>\n-    where I: FusedIterator, P: FnMut(&I::Item) -> bool {}\n+where\n+    I: FusedIterator,\n+    P: FnMut(&I::Item) -> bool,\n+{\n+}\n \n /// An iterator that only accepts elements while `predicate` returns `true`.\n ///\n@@ -1544,16 +1684,14 @@ impl<I, P> TakeWhile<I, P> {\n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n impl<I: fmt::Debug, P> fmt::Debug for TakeWhile<I, P> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"TakeWhile\")\n-            .field(\"iter\", &self.iter)\n-            .field(\"flag\", &self.flag)\n-            .finish()\n+        f.debug_struct(\"TakeWhile\").field(\"iter\", &self.iter).field(\"flag\", &self.flag).finish()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: Iterator, P> Iterator for TakeWhile<I, P>\n-    where P: FnMut(&I::Item) -> bool\n+where\n+    P: FnMut(&I::Item) -> bool,\n {\n     type Item = I::Item;\n \n@@ -1583,8 +1721,11 @@ impl<I: Iterator, P> Iterator for TakeWhile<I, P>\n     }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         fn check<'a, T, Acc, R: Try<Ok = Acc>>(\n             flag: &'a mut bool,\n@@ -1613,7 +1754,11 @@ impl<I: Iterator, P> Iterator for TakeWhile<I, P>\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I, P> FusedIterator for TakeWhile<I, P>\n-    where I: FusedIterator, P: FnMut(&I::Item) -> bool {}\n+where\n+    I: FusedIterator,\n+    P: FnMut(&I::Item) -> bool,\n+{\n+}\n \n /// An iterator that skips over `n` elements of `iter`.\n ///\n@@ -1627,7 +1772,7 @@ impl<I, P> FusedIterator for TakeWhile<I, P>\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Skip<I> {\n     iter: I,\n-    n: usize\n+    n: usize,\n }\n impl<I> Skip<I> {\n     pub(super) fn new(iter: I, n: usize) -> Skip<I> {\n@@ -1636,7 +1781,10 @@ impl<I> Skip<I> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Skip<I> where I: Iterator {\n+impl<I> Iterator for Skip<I>\n+where\n+    I: Iterator,\n+{\n     type Item = <I as Iterator>::Item;\n \n     #[inline]\n@@ -1659,7 +1807,7 @@ impl<I> Iterator for Skip<I> where I: Iterator {\n             let to_skip = self.n;\n             self.n = 0;\n             // nth(n) skips n+1\n-            if self.iter.nth(to_skip-1).is_none() {\n+            if self.iter.nth(to_skip - 1).is_none() {\n                 return None;\n             }\n             self.iter.nth(n)\n@@ -1700,8 +1848,11 @@ impl<I> Iterator for Skip<I> where I: Iterator {\n     }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         let n = self.n;\n         self.n = 0;\n@@ -1716,7 +1867,8 @@ impl<I> Iterator for Skip<I> where I: Iterator {\n \n     #[inline]\n     fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         if self.n > 0 {\n             // nth(n) skips n+1\n@@ -1732,13 +1884,12 @@ impl<I> Iterator for Skip<I> where I: Iterator {\n impl<I> ExactSizeIterator for Skip<I> where I: ExactSizeIterator {}\n \n #[stable(feature = \"double_ended_skip_iterator\", since = \"1.9.0\")]\n-impl<I> DoubleEndedIterator for Skip<I> where I: DoubleEndedIterator + ExactSizeIterator {\n+impl<I> DoubleEndedIterator for Skip<I>\n+where\n+    I: DoubleEndedIterator + ExactSizeIterator,\n+{\n     fn next_back(&mut self) -> Option<Self::Item> {\n-        if self.len() > 0 {\n-            self.iter.next_back()\n-        } else {\n-            None\n-        }\n+        if self.len() > 0 { self.iter.next_back() } else { None }\n     }\n \n     #[inline]\n@@ -1749,14 +1900,17 @@ impl<I> DoubleEndedIterator for Skip<I> where I: DoubleEndedIterator + ExactSize\n         } else {\n             if len > 0 {\n                 // consume the original iterator\n-                self.iter.nth_back(len-1);\n+                self.iter.nth_back(len - 1);\n             }\n             None\n         }\n     }\n \n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         fn check<T, Acc, R: Try<Ok = Acc>>(\n             mut n: usize,\n@@ -1765,8 +1919,7 @@ impl<I> DoubleEndedIterator for Skip<I> where I: DoubleEndedIterator + ExactSize\n             move |acc, x| {\n                 n -= 1;\n                 let r = fold(acc, x);\n-                if n == 0 { LoopState::Break(r) }\n-                else { LoopState::from_try(r) }\n+                if n == 0 { LoopState::Break(r) } else { LoopState::from_try(r) }\n             }\n         }\n \n@@ -1794,7 +1947,7 @@ impl<I> FusedIterator for Skip<I> where I: FusedIterator {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Take<I> {\n     pub(super) iter: I,\n-    pub(super) n: usize\n+    pub(super) n: usize,\n }\n impl<I> Take<I> {\n     pub(super) fn new(iter: I, n: usize) -> Take<I> {\n@@ -1803,7 +1956,10 @@ impl<I> Take<I> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Take<I> where I: Iterator{\n+impl<I> Iterator for Take<I>\n+where\n+    I: Iterator,\n+{\n     type Item = <I as Iterator>::Item;\n \n     #[inline]\n@@ -1842,15 +1998,18 @@ impl<I> Iterator for Take<I> where I: Iterator{\n \n         let upper = match upper {\n             Some(x) if x < self.n => Some(x),\n-            _ => Some(self.n)\n+            _ => Some(self.n),\n         };\n \n         (lower, upper)\n     }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         fn check<'a, T, Acc, R: Try<Ok = Acc>>(\n             n: &'a mut usize,\n@@ -1859,8 +2018,7 @@ impl<I> Iterator for Take<I> where I: Iterator{\n             move |acc, x| {\n                 *n -= 1;\n                 let r = fold(acc, x);\n-                if *n == 0 { LoopState::Break(r) }\n-                else { LoopState::from_try(r) }\n+                if *n == 0 { LoopState::Break(r) } else { LoopState::from_try(r) }\n             }\n         }\n \n@@ -1874,7 +2032,10 @@ impl<I> Iterator for Take<I> where I: Iterator{\n }\n \n #[stable(feature = \"double_ended_take_iterator\", since = \"1.38.0\")]\n-impl<I> DoubleEndedIterator for Take<I> where I: DoubleEndedIterator + ExactSizeIterator {\n+impl<I> DoubleEndedIterator for Take<I>\n+where\n+    I: DoubleEndedIterator + ExactSizeIterator,\n+{\n     #[inline]\n     fn next_back(&mut self) -> Option<Self::Item> {\n         if self.n == 0 {\n@@ -1902,8 +2063,11 @@ impl<I> DoubleEndedIterator for Take<I> where I: DoubleEndedIterator + ExactSize\n     }\n \n     #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok = Acc>\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         if self.n == 0 {\n             Try::from_ok(init)\n@@ -1951,15 +2115,13 @@ impl<I, St, F> Scan<I, St, F> {\n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n impl<I: fmt::Debug, St: fmt::Debug, F> fmt::Debug for Scan<I, St, F> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Scan\")\n-            .field(\"iter\", &self.iter)\n-            .field(\"state\", &self.state)\n-            .finish()\n+        f.debug_struct(\"Scan\").field(\"iter\", &self.iter).field(\"state\", &self.state).finish()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I, St, F> Iterator for Scan<I, St, F> where\n+impl<B, I, St, F> Iterator for Scan<I, St, F>\n+where\n     I: Iterator,\n     F: FnMut(&mut St, I::Item) -> Option<B>,\n {\n@@ -1978,19 +2140,20 @@ impl<B, I, St, F> Iterator for Scan<I, St, F> where\n     }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         fn scan<'a, T, St, B, Acc, R: Try<Ok = Acc>>(\n             state: &'a mut St,\n             f: &'a mut impl FnMut(&mut St, T) -> Option<B>,\n             mut fold: impl FnMut(Acc, B) -> R + 'a,\n         ) -> impl FnMut(Acc, T) -> LoopState<Acc, R> + 'a {\n-            move |acc, x| {\n-                match f(state, x) {\n-                    None => LoopState::Break(Try::from_ok(acc)),\n-                    Some(x) => LoopState::from_try(fold(acc, x)),\n-                }\n+            move |acc, x| match f(state, x) {\n+                None => LoopState::Break(Try::from_ok(acc)),\n+                Some(x) => LoopState::from_try(fold(acc, x)),\n             }\n         }\n \n@@ -2013,7 +2176,7 @@ impl<B, I, St, F> Iterator for Scan<I, St, F> where\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Fuse<I> {\n     iter: I,\n-    done: bool\n+    done: bool,\n }\n impl<I> Fuse<I> {\n     pub(super) fn new(iter: I) -> Fuse<I> {\n@@ -2025,7 +2188,10 @@ impl<I> Fuse<I> {\n impl<I> FusedIterator for Fuse<I> where I: Iterator {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Fuse<I> where I: Iterator {\n+impl<I> Iterator for Fuse<I>\n+where\n+    I: Iterator,\n+{\n     type Item = <I as Iterator>::Item;\n \n     #[inline]\n@@ -2052,34 +2218,25 @@ impl<I> Iterator for Fuse<I> where I: Iterator {\n \n     #[inline]\n     default fn last(self) -> Option<I::Item> {\n-        if self.done {\n-            None\n-        } else {\n-            self.iter.last()\n-        }\n+        if self.done { None } else { self.iter.last() }\n     }\n \n     #[inline]\n     default fn count(self) -> usize {\n-        if self.done {\n-            0\n-        } else {\n-            self.iter.count()\n-        }\n+        if self.done { 0 } else { self.iter.count() }\n     }\n \n     #[inline]\n     default fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.done {\n-            (0, Some(0))\n-        } else {\n-            self.iter.size_hint()\n-        }\n+        if self.done { (0, Some(0)) } else { self.iter.size_hint() }\n     }\n \n     #[inline]\n-    default fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    default fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         if self.done {\n             Try::from_ok(init)\n@@ -2092,18 +2249,18 @@ impl<I> Iterator for Fuse<I> where I: Iterator {\n \n     #[inline]\n     default fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        if self.done {\n-            init\n-        } else {\n-            self.iter.fold(init, fold)\n-        }\n+        if self.done { init } else { self.iter.fold(init, fold) }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n+impl<I> DoubleEndedIterator for Fuse<I>\n+where\n+    I: DoubleEndedIterator,\n+{\n     #[inline]\n     default fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n         if self.done {\n@@ -2127,8 +2284,11 @@ impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n     }\n \n     #[inline]\n-    default fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    default fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         if self.done {\n             Try::from_ok(init)\n@@ -2141,18 +2301,16 @@ impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n \n     #[inline]\n     default fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        if self.done {\n-            init\n-        } else {\n-            self.iter.rfold(init, fold)\n-        }\n+        if self.done { init } else { self.iter.rfold(init, fold) }\n     }\n }\n \n unsafe impl<I> TrustedRandomAccess for Fuse<I>\n-    where I: TrustedRandomAccess,\n+where\n+    I: TrustedRandomAccess,\n {\n     unsafe fn get_unchecked(&mut self, i: usize) -> I::Item {\n         self.iter.get_unchecked(i)\n@@ -2164,7 +2322,10 @@ unsafe impl<I> TrustedRandomAccess for Fuse<I>\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> Iterator for Fuse<I> where I: FusedIterator {\n+impl<I> Iterator for Fuse<I>\n+where\n+    I: FusedIterator,\n+{\n     #[inline]\n     fn next(&mut self) -> Option<<I as Iterator>::Item> {\n         self.iter.next()\n@@ -2191,23 +2352,28 @@ impl<I> Iterator for Fuse<I> where I: FusedIterator {\n     }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         self.iter.try_fold(init, fold)\n     }\n \n     #[inline]\n     fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.iter.fold(init, fold)\n     }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I> DoubleEndedIterator for Fuse<I>\n-    where I: DoubleEndedIterator + FusedIterator\n+where\n+    I: DoubleEndedIterator + FusedIterator,\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n@@ -2220,23 +2386,29 @@ impl<I> DoubleEndedIterator for Fuse<I>\n     }\n \n     #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         self.iter.try_rfold(init, fold)\n     }\n \n     #[inline]\n     fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.iter.rfold(init, fold)\n     }\n }\n \n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> ExactSizeIterator for Fuse<I> where I: ExactSizeIterator {\n+impl<I> ExactSizeIterator for Fuse<I>\n+where\n+    I: ExactSizeIterator,\n+{\n     fn len(&self) -> usize {\n         self.iter.len()\n     }\n@@ -2270,13 +2442,14 @@ impl<I, F> Inspect<I, F> {\n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n impl<I: fmt::Debug, F> fmt::Debug for Inspect<I, F> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Inspect\")\n-            .field(\"iter\", &self.iter)\n-            .finish()\n+        f.debug_struct(\"Inspect\").field(\"iter\", &self.iter).finish()\n     }\n }\n \n-impl<I: Iterator, F> Inspect<I, F> where F: FnMut(&I::Item) {\n+impl<I: Iterator, F> Inspect<I, F>\n+where\n+    F: FnMut(&I::Item),\n+{\n     #[inline]\n     fn do_inspect(&mut self, elt: Option<I::Item>) -> Option<I::Item> {\n         if let Some(ref a) = elt {\n@@ -2291,18 +2464,27 @@ fn inspect_fold<T, Acc>(\n     mut f: impl FnMut(&T),\n     mut fold: impl FnMut(Acc, T) -> Acc,\n ) -> impl FnMut(Acc, T) -> Acc {\n-    move |acc, item| { f(&item); fold(acc, item) }\n+    move |acc, item| {\n+        f(&item);\n+        fold(acc, item)\n+    }\n }\n \n fn inspect_try_fold<'a, T, Acc, R>(\n     f: &'a mut impl FnMut(&T),\n     mut fold: impl FnMut(Acc, T) -> R + 'a,\n ) -> impl FnMut(Acc, T) -> R + 'a {\n-    move |acc, item| { f(&item); fold(acc, item) }\n+    move |acc, item| {\n+        f(&item);\n+        fold(acc, item)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator, F> Iterator for Inspect<I, F> where F: FnMut(&I::Item) {\n+impl<I: Iterator, F> Iterator for Inspect<I, F>\n+where\n+    F: FnMut(&I::Item),\n+{\n     type Item = I::Item;\n \n     #[inline]\n@@ -2317,23 +2499,28 @@ impl<I: Iterator, F> Iterator for Inspect<I, F> where F: FnMut(&I::Item) {\n     }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         self.iter.try_fold(init, inspect_try_fold(&mut self.f, fold))\n     }\n \n     #[inline]\n     fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.iter.fold(init, inspect_fold(self.f, fold))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: DoubleEndedIterator, F> DoubleEndedIterator for Inspect<I, F>\n-    where F: FnMut(&I::Item),\n+where\n+    F: FnMut(&I::Item),\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<I::Item> {\n@@ -2342,23 +2529,28 @@ impl<I: DoubleEndedIterator, F> DoubleEndedIterator for Inspect<I, F>\n     }\n \n     #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         self.iter.try_rfold(init, inspect_try_fold(&mut self.f, fold))\n     }\n \n     #[inline]\n     fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.iter.rfold(init, inspect_fold(self.f, fold))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: ExactSizeIterator, F> ExactSizeIterator for Inspect<I, F>\n-    where F: FnMut(&I::Item)\n+where\n+    F: FnMut(&I::Item),\n {\n     fn len(&self) -> usize {\n         self.iter.len()\n@@ -2370,8 +2562,7 @@ impl<I: ExactSizeIterator, F> ExactSizeIterator for Inspect<I, F>\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I: FusedIterator, F> FusedIterator for Inspect<I, F>\n-    where F: FnMut(&I::Item) {}\n+impl<I: FusedIterator, F> FusedIterator for Inspect<I, F> where F: FnMut(&I::Item) {}\n \n /// An iterator adapter that produces output as long as the underlying\n /// iterator produces `Result::Ok` values.\n@@ -2392,16 +2583,14 @@ where\n     for<'a> F: FnMut(ResultShunt<'a, I, E>) -> U,\n {\n     let mut error = Ok(());\n-    let shunt = ResultShunt {\n-        iter,\n-        error: &mut error,\n-    };\n+    let shunt = ResultShunt { iter, error: &mut error };\n     let value = f(shunt);\n     error.map(|()| value)\n }\n \n impl<I, T, E> Iterator for ResultShunt<'_, I, E>\n-    where I: Iterator<Item = Result<T, E>>\n+where\n+    I: Iterator<Item = Result<T, E>>,\n {\n     type Item = T;\n "}, {"sha": "25be26491e327a12d6c7a66a2294235ecb797166", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 257, "deletions": 145, "changes": 402, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d", "patch": "@@ -1,13 +1,15 @@\n+// ignore-tidy-filelength\n+\n use crate::cmp::{self, Ordering};\n use crate::ops::{Add, Try};\n \n use super::super::LoopState;\n-use super::super::{Chain, Cycle, Copied, Cloned, Enumerate, Filter, FilterMap, Fuse};\n-use super::super::{Flatten, FlatMap};\n-use super::super::{Inspect, Map, Peekable, Scan, Skip, SkipWhile, StepBy, Take, TakeWhile, Rev};\n-use super::super::{Zip, Sum, Product, FromIterator};\n+use super::super::{Chain, Cloned, Copied, Cycle, Enumerate, Filter, FilterMap, Fuse};\n+use super::super::{FlatMap, Flatten};\n+use super::super::{FromIterator, Product, Sum, Zip};\n+use super::super::{Inspect, Map, Peekable, Rev, Scan, Skip, SkipWhile, StepBy, Take, TakeWhile};\n \n-fn _assert_is_object_safe(_: &dyn Iterator<Item=()>) {}\n+fn _assert_is_object_safe(_: &dyn Iterator<Item = ()>) {}\n \n /// An interface for dealing with iterators.\n ///\n@@ -20,71 +22,71 @@ fn _assert_is_object_safe(_: &dyn Iterator<Item=()>) {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented(\n     on(\n-        _Self=\"[std::ops::Range<Idx>; 1]\",\n-        label=\"if you meant to iterate between two values, remove the square brackets\",\n-        note=\"`[start..end]` is an array of one `Range`; you might have meant to have a `Range` \\\n-              without the brackets: `start..end`\"\n+        _Self = \"[std::ops::Range<Idx>; 1]\",\n+        label = \"if you meant to iterate between two values, remove the square brackets\",\n+        note = \"`[start..end]` is an array of one `Range`; you might have meant to have a `Range` \\\n+                without the brackets: `start..end`\"\n     ),\n     on(\n-        _Self=\"[std::ops::RangeFrom<Idx>; 1]\",\n-        label=\"if you meant to iterate from a value onwards, remove the square brackets\",\n-        note=\"`[start..]` is an array of one `RangeFrom`; you might have meant to have a \\\n+        _Self = \"[std::ops::RangeFrom<Idx>; 1]\",\n+        label = \"if you meant to iterate from a value onwards, remove the square brackets\",\n+        note = \"`[start..]` is an array of one `RangeFrom`; you might have meant to have a \\\n               `RangeFrom` without the brackets: `start..`, keeping in mind that iterating over an \\\n               unbounded iterator will run forever unless you `break` or `return` from within the \\\n               loop\"\n     ),\n     on(\n-        _Self=\"[std::ops::RangeTo<Idx>; 1]\",\n-        label=\"if you meant to iterate until a value, remove the square brackets and add a \\\n-               starting value\",\n-        note=\"`[..end]` is an array of one `RangeTo`; you might have meant to have a bounded \\\n-              `Range` without the brackets: `0..end`\"\n+        _Self = \"[std::ops::RangeTo<Idx>; 1]\",\n+        label = \"if you meant to iterate until a value, remove the square brackets and add a \\\n+                 starting value\",\n+        note = \"`[..end]` is an array of one `RangeTo`; you might have meant to have a bounded \\\n+                `Range` without the brackets: `0..end`\"\n     ),\n     on(\n-        _Self=\"[std::ops::RangeInclusive<Idx>; 1]\",\n-        label=\"if you meant to iterate between two values, remove the square brackets\",\n-        note=\"`[start..=end]` is an array of one `RangeInclusive`; you might have meant to have a \\\n+        _Self = \"[std::ops::RangeInclusive<Idx>; 1]\",\n+        label = \"if you meant to iterate between two values, remove the square brackets\",\n+        note = \"`[start..=end]` is an array of one `RangeInclusive`; you might have meant to have a \\\n               `RangeInclusive` without the brackets: `start..=end`\"\n     ),\n     on(\n-        _Self=\"[std::ops::RangeToInclusive<Idx>; 1]\",\n-        label=\"if you meant to iterate until a value (including it), remove the square brackets \\\n-               and add a starting value\",\n-        note=\"`[..=end]` is an array of one `RangeToInclusive`; you might have meant to have a \\\n-              bounded `RangeInclusive` without the brackets: `0..=end`\"\n+        _Self = \"[std::ops::RangeToInclusive<Idx>; 1]\",\n+        label = \"if you meant to iterate until a value (including it), remove the square brackets \\\n+                 and add a starting value\",\n+        note = \"`[..=end]` is an array of one `RangeToInclusive`; you might have meant to have a \\\n+                bounded `RangeInclusive` without the brackets: `0..=end`\"\n     ),\n     on(\n-        _Self=\"std::ops::RangeTo<Idx>\",\n-        label=\"if you meant to iterate until a value, add a starting value\",\n-        note=\"`..end` is a `RangeTo`, which cannot be iterated on; you might have meant to have a \\\n+        _Self = \"std::ops::RangeTo<Idx>\",\n+        label = \"if you meant to iterate until a value, add a starting value\",\n+        note = \"`..end` is a `RangeTo`, which cannot be iterated on; you might have meant to have a \\\n               bounded `Range`: `0..end`\"\n     ),\n     on(\n-        _Self=\"std::ops::RangeToInclusive<Idx>\",\n-        label=\"if you meant to iterate until a value (including it), add a starting value\",\n-        note=\"`..=end` is a `RangeToInclusive`, which cannot be iterated on; you might have meant \\\n+        _Self = \"std::ops::RangeToInclusive<Idx>\",\n+        label = \"if you meant to iterate until a value (including it), add a starting value\",\n+        note = \"`..=end` is a `RangeToInclusive`, which cannot be iterated on; you might have meant \\\n               to have a bounded `RangeInclusive`: `0..=end`\"\n     ),\n     on(\n-        _Self=\"&str\",\n-        label=\"`{Self}` is not an iterator; try calling `.chars()` or `.bytes()`\"\n+        _Self = \"&str\",\n+        label = \"`{Self}` is not an iterator; try calling `.chars()` or `.bytes()`\"\n     ),\n     on(\n-        _Self=\"std::string::String\",\n-        label=\"`{Self}` is not an iterator; try calling `.chars()` or `.bytes()`\"\n+        _Self = \"std::string::String\",\n+        label = \"`{Self}` is not an iterator; try calling `.chars()` or `.bytes()`\"\n     ),\n     on(\n-        _Self=\"[]\",\n-        label=\"borrow the array with `&` or call `.iter()` on it to iterate over it\",\n-        note=\"arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\"\n+        _Self = \"[]\",\n+        label = \"borrow the array with `&` or call `.iter()` on it to iterate over it\",\n+        note = \"arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\"\n     ),\n     on(\n-        _Self=\"{integral}\",\n-        note=\"if you want to iterate between `start` until a value `end`, use the exclusive range \\\n+        _Self = \"{integral}\",\n+        note = \"if you want to iterate between `start` until a value `end`, use the exclusive range \\\n               syntax `start..end` or the inclusive range syntax `start..=end`\"\n     ),\n-    label=\"`{Self}` is not an iterator\",\n-    message=\"`{Self}` is not an iterator\"\n+    label = \"`{Self}` is not an iterator\",\n+    message = \"`{Self}` is not an iterator\"\n )]\n #[doc(spotlight)]\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n@@ -197,7 +199,9 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn size_hint(&self) -> (usize, Option<usize>) { (0, None) }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (0, None)\n+    }\n \n     /// Consumes the iterator, counting the number of iterations and returning it.\n     ///\n@@ -236,7 +240,10 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn count(self) -> usize where Self: Sized {\n+    fn count(self) -> usize\n+    where\n+        Self: Sized,\n+    {\n         #[inline]\n         fn add1<T>(count: usize, _: T) -> usize {\n             // Might overflow.\n@@ -267,7 +274,10 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn last(self) -> Option<Self::Item> where Self: Sized {\n+    fn last(self) -> Option<Self::Item>\n+    where\n+        Self: Sized,\n+    {\n         #[inline]\n         fn some<T>(_: Option<T>, x: T) -> Option<T> {\n             Some(x)\n@@ -321,7 +331,9 @@ pub trait Iterator {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn nth(&mut self, mut n: usize) -> Option<Self::Item> {\n         for x in self {\n-            if n == 0 { return Some(x) }\n+            if n == 0 {\n+                return Some(x);\n+            }\n             n -= 1;\n         }\n         None\n@@ -373,7 +385,10 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n-    fn step_by(self, step: usize) -> StepBy<Self> where Self: Sized {\n+    fn step_by(self, step: usize) -> StepBy<Self>\n+    where\n+        Self: Sized,\n+    {\n         StepBy::new(self, step)\n     }\n \n@@ -443,8 +458,10 @@ pub trait Iterator {\n     /// [`OsStr`]: ../../std/ffi/struct.OsStr.html\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn chain<U>(self, other: U) -> Chain<Self, U::IntoIter> where\n-        Self: Sized, U: IntoIterator<Item=Self::Item>,\n+    fn chain<U>(self, other: U) -> Chain<Self, U::IntoIter>\n+    where\n+        Self: Sized,\n+        U: IntoIterator<Item = Self::Item>,\n     {\n         Chain::new(self, other.into_iter())\n     }\n@@ -521,8 +538,10 @@ pub trait Iterator {\n     /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn zip<U>(self, other: U) -> Zip<Self, U::IntoIter> where\n-        Self: Sized, U: IntoIterator\n+    fn zip<U>(self, other: U) -> Zip<Self, U::IntoIter>\n+    where\n+        Self: Sized,\n+        U: IntoIterator,\n     {\n         Zip::new(self, other.into_iter())\n     }\n@@ -578,8 +597,10 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn map<B, F>(self, f: F) -> Map<Self, F> where\n-        Self: Sized, F: FnMut(Self::Item) -> B,\n+    fn map<B, F>(self, f: F) -> Map<Self, F>\n+    where\n+        Self: Sized,\n+        F: FnMut(Self::Item) -> B,\n     {\n         Map::new(self, f)\n     }\n@@ -621,8 +642,10 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iterator_for_each\", since = \"1.21.0\")]\n-    fn for_each<F>(self, f: F) where\n-        Self: Sized, F: FnMut(Self::Item),\n+    fn for_each<F>(self, f: F)\n+    where\n+        Self: Sized,\n+        F: FnMut(Self::Item),\n     {\n         #[inline]\n         fn call<T>(mut f: impl FnMut(T)) -> impl FnMut((), T) {\n@@ -694,8 +717,10 @@ pub trait Iterator {\n     /// of these layers.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn filter<P>(self, predicate: P) -> Filter<Self, P> where\n-        Self: Sized, P: FnMut(&Self::Item) -> bool,\n+    fn filter<P>(self, predicate: P) -> Filter<Self, P>\n+    where\n+        Self: Sized,\n+        P: FnMut(&Self::Item) -> bool,\n     {\n         Filter::new(self, predicate)\n     }\n@@ -751,8 +776,10 @@ pub trait Iterator {\n     /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn filter_map<B, F>(self, f: F) -> FilterMap<Self, F> where\n-        Self: Sized, F: FnMut(Self::Item) -> Option<B>,\n+    fn filter_map<B, F>(self, f: F) -> FilterMap<Self, F>\n+    where\n+        Self: Sized,\n+        F: FnMut(Self::Item) -> Option<B>,\n     {\n         FilterMap::new(self, f)\n     }\n@@ -797,7 +824,10 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn enumerate(self) -> Enumerate<Self> where Self: Sized {\n+    fn enumerate(self) -> Enumerate<Self>\n+    where\n+        Self: Sized,\n+    {\n         Enumerate::new(self)\n     }\n \n@@ -843,7 +873,10 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn peekable(self) -> Peekable<Self> where Self: Sized {\n+    fn peekable(self) -> Peekable<Self>\n+    where\n+        Self: Sized,\n+    {\n         Peekable::new(self)\n     }\n \n@@ -904,8 +937,10 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn skip_while<P>(self, predicate: P) -> SkipWhile<Self, P> where\n-        Self: Sized, P: FnMut(&Self::Item) -> bool,\n+    fn skip_while<P>(self, predicate: P) -> SkipWhile<Self, P>\n+    where\n+        Self: Sized,\n+        P: FnMut(&Self::Item) -> bool,\n     {\n         SkipWhile::new(self, predicate)\n     }\n@@ -983,8 +1018,10 @@ pub trait Iterator {\n     /// the iteration should stop, but wasn't placed back into the iterator.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn take_while<P>(self, predicate: P) -> TakeWhile<Self, P> where\n-        Self: Sized, P: FnMut(&Self::Item) -> bool,\n+    fn take_while<P>(self, predicate: P) -> TakeWhile<Self, P>\n+    where\n+        Self: Sized,\n+        P: FnMut(&Self::Item) -> bool,\n     {\n         TakeWhile::new(self, predicate)\n     }\n@@ -1008,7 +1045,10 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn skip(self, n: usize) -> Skip<Self> where Self: Sized {\n+    fn skip(self, n: usize) -> Skip<Self>\n+    where\n+        Self: Sized,\n+    {\n         Skip::new(self, n)\n     }\n \n@@ -1040,7 +1080,10 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn take(self, n: usize) -> Take<Self> where Self: Sized, {\n+    fn take(self, n: usize) -> Take<Self>\n+    where\n+        Self: Sized,\n+    {\n         Take::new(self, n)\n     }\n \n@@ -1084,7 +1127,9 @@ pub trait Iterator {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn scan<St, B, F>(self, initial_state: St, f: F) -> Scan<Self, St, F>\n-        where Self: Sized, F: FnMut(&mut St, Self::Item) -> Option<B>,\n+    where\n+        Self: Sized,\n+        F: FnMut(&mut St, Self::Item) -> Option<B>,\n     {\n         Scan::new(self, initial_state, f)\n     }\n@@ -1122,7 +1167,10 @@ pub trait Iterator {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn flat_map<U, F>(self, f: F) -> FlatMap<Self, U, F>\n-        where Self: Sized, U: IntoIterator, F: FnMut(Self::Item) -> U,\n+    where\n+        Self: Sized,\n+        U: IntoIterator,\n+        F: FnMut(Self::Item) -> U,\n     {\n         FlatMap::new(self, f)\n     }\n@@ -1191,7 +1239,10 @@ pub trait Iterator {\n     #[inline]\n     #[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n     fn flatten(self) -> Flatten<Self>\n-    where Self: Sized, Self::Item: IntoIterator {\n+    where\n+        Self: Sized,\n+        Self::Item: IntoIterator,\n+    {\n         Flatten::new(self)\n     }\n \n@@ -1251,7 +1302,10 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn fuse(self) -> Fuse<Self> where Self: Sized {\n+    fn fuse(self) -> Fuse<Self>\n+    where\n+        Self: Sized,\n+    {\n         Fuse::new(self)\n     }\n \n@@ -1332,8 +1386,10 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn inspect<F>(self, f: F) -> Inspect<Self, F> where\n-        Self: Sized, F: FnMut(&Self::Item),\n+    fn inspect<F>(self, f: F) -> Inspect<Self, F>\n+    where\n+        Self: Sized,\n+        F: FnMut(&Self::Item),\n     {\n         Inspect::new(self, f)\n     }\n@@ -1375,7 +1431,12 @@ pub trait Iterator {\n     /// assert_eq!(iter.next(), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn by_ref(&mut self) -> &mut Self where Self: Sized { self }\n+    fn by_ref(&mut self) -> &mut Self\n+    where\n+        Self: Sized,\n+    {\n+        self\n+    }\n \n     /// Transforms an iterator into a collection.\n     ///\n@@ -1490,7 +1551,10 @@ pub trait Iterator {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[must_use = \"if you really need to exhaust the iterator, consider `.for_each(drop)` instead\"]\n-    fn collect<B: FromIterator<Self::Item>>(self) -> B where Self: Sized {\n+    fn collect<B: FromIterator<Self::Item>>(self) -> B\n+    where\n+        Self: Sized,\n+    {\n         FromIterator::from_iter(self)\n     }\n \n@@ -1520,10 +1584,11 @@ pub trait Iterator {\n     /// assert_eq!(odd, vec![1, 3]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn partition<B, F>(self, f: F) -> (B, B) where\n+    fn partition<B, F>(self, f: F) -> (B, B)\n+    where\n         Self: Sized,\n         B: Default + Extend<Self::Item>,\n-        F: FnMut(&Self::Item) -> bool\n+        F: FnMut(&Self::Item) -> bool,\n     {\n         #[inline]\n         fn extend<'a, T, B: Extend<T>>(\n@@ -1597,9 +1662,7 @@ pub trait Iterator {\n         }\n \n         #[inline]\n-        fn is_true<T>(\n-            predicate: &mut impl FnMut(&T) -> bool\n-        ) -> impl FnMut(&&mut T) -> bool + '_ {\n+        fn is_true<T>(predicate: &mut impl FnMut(&T) -> bool) -> impl FnMut(&&mut T) -> bool + '_ {\n             move |x| predicate(&**x)\n         }\n \n@@ -1702,8 +1765,11 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iterator_try_fold\", since = \"1.27.0\")]\n-    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n-        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n     {\n         let mut accum = init;\n         while let Some(x) = self.next() {\n@@ -1741,8 +1807,11 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iterator_try_fold\", since = \"1.27.0\")]\n-    fn try_for_each<F, R>(&mut self, f: F) -> R where\n-        Self: Sized, F: FnMut(Self::Item) -> R, R: Try<Ok=()>\n+    fn try_for_each<F, R>(&mut self, f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(Self::Item) -> R,\n+        R: Try<Ok = ()>,\n     {\n         #[inline]\n         fn call<T, R>(mut f: impl FnMut(T) -> R) -> impl FnMut((), T) -> R {\n@@ -1821,8 +1890,10 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn fold<B, F>(mut self, init: B, f: F) -> B where\n-        Self: Sized, F: FnMut(B, Self::Item) -> B,\n+    fn fold<B, F>(mut self, init: B, f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B,\n     {\n         #[inline]\n         fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n@@ -1871,14 +1942,15 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn all<F>(&mut self, f: F) -> bool where\n-        Self: Sized, F: FnMut(Self::Item) -> bool\n+    fn all<F>(&mut self, f: F) -> bool\n+    where\n+        Self: Sized,\n+        F: FnMut(Self::Item) -> bool,\n     {\n         #[inline]\n         fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut((), T) -> LoopState<(), ()> {\n             move |(), x| {\n-                if f(x) { LoopState::Continue(()) }\n-                else { LoopState::Break(()) }\n+                if f(x) { LoopState::Continue(()) } else { LoopState::Break(()) }\n             }\n         }\n         self.try_fold((), check(f)) == LoopState::Continue(())\n@@ -1923,15 +1995,15 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn any<F>(&mut self, f: F) -> bool where\n+    fn any<F>(&mut self, f: F) -> bool\n+    where\n         Self: Sized,\n-        F: FnMut(Self::Item) -> bool\n+        F: FnMut(Self::Item) -> bool,\n     {\n         #[inline]\n         fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut((), T) -> LoopState<(), ()> {\n             move |(), x| {\n-                if f(x) { LoopState::Break(()) }\n-                else { LoopState::Continue(()) }\n+                if f(x) { LoopState::Break(()) } else { LoopState::Continue(()) }\n             }\n         }\n \n@@ -1982,17 +2054,17 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn find<P>(&mut self, predicate: P) -> Option<Self::Item> where\n+    fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n+    where\n         Self: Sized,\n         P: FnMut(&Self::Item) -> bool,\n     {\n         #[inline]\n         fn check<T>(\n-            mut predicate: impl FnMut(&T) -> bool\n+            mut predicate: impl FnMut(&T) -> bool,\n         ) -> impl FnMut((), T) -> LoopState<(), T> {\n             move |(), x| {\n-                if predicate(&x) { LoopState::Break(x) }\n-                else { LoopState::Continue(()) }\n+                if predicate(&x) { LoopState::Break(x) } else { LoopState::Continue(()) }\n             }\n         }\n \n@@ -2016,7 +2088,8 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iterator_find_map\", since = \"1.30.0\")]\n-    fn find_map<B, F>(&mut self, f: F) -> Option<B> where\n+    fn find_map<B, F>(&mut self, f: F) -> Option<B>\n+    where\n         Self: Sized,\n         F: FnMut(Self::Item) -> Option<B>,\n     {\n@@ -2087,7 +2160,8 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn position<P>(&mut self, predicate: P) -> Option<usize> where\n+    fn position<P>(&mut self, predicate: P) -> Option<usize>\n+    where\n         Self: Sized,\n         P: FnMut(Self::Item) -> bool,\n     {\n@@ -2097,8 +2171,7 @@ pub trait Iterator {\n         ) -> impl FnMut(usize, T) -> LoopState<usize, usize> {\n             // The addition might panic on overflow\n             move |i, x| {\n-                if predicate(x) { LoopState::Break(i) }\n-                else { LoopState::Continue(Add::add(i, 1)) }\n+                if predicate(x) { LoopState::Break(i) } else { LoopState::Continue(Add::add(i, 1)) }\n             }\n         }\n \n@@ -2145,9 +2218,10 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn rposition<P>(&mut self, predicate: P) -> Option<usize> where\n+    fn rposition<P>(&mut self, predicate: P) -> Option<usize>\n+    where\n         P: FnMut(Self::Item) -> bool,\n-        Self: Sized + ExactSizeIterator + DoubleEndedIterator\n+        Self: Sized + ExactSizeIterator + DoubleEndedIterator,\n     {\n         // No need for an overflow check here, because `ExactSizeIterator`\n         // implies that the number of elements fits into a `usize`.\n@@ -2157,8 +2231,7 @@ pub trait Iterator {\n         ) -> impl FnMut(usize, T) -> LoopState<usize, usize> {\n             move |i, x| {\n                 let i = i - 1;\n-                if predicate(x) { LoopState::Break(i) }\n-                else { LoopState::Continue(i) }\n+                if predicate(x) { LoopState::Break(i) } else { LoopState::Continue(i) }\n             }\n         }\n \n@@ -2186,7 +2259,10 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn max(self) -> Option<Self::Item> where Self: Sized, Self::Item: Ord\n+    fn max(self) -> Option<Self::Item>\n+    where\n+        Self: Sized,\n+        Self::Item: Ord,\n     {\n         self.max_by(Ord::cmp)\n     }\n@@ -2211,7 +2287,10 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn min(self) -> Option<Self::Item> where Self: Sized, Self::Item: Ord\n+    fn min(self) -> Option<Self::Item>\n+    where\n+        Self: Sized,\n+        Self::Item: Ord,\n     {\n         self.min_by(Ord::cmp)\n     }\n@@ -2233,7 +2312,9 @@ pub trait Iterator {\n     #[inline]\n     #[stable(feature = \"iter_cmp_by_key\", since = \"1.6.0\")]\n     fn max_by_key<B: Ord, F>(self, f: F) -> Option<Self::Item>\n-        where Self: Sized, F: FnMut(&Self::Item) -> B,\n+    where\n+        Self: Sized,\n+        F: FnMut(&Self::Item) -> B,\n     {\n         #[inline]\n         fn key<T, B>(mut f: impl FnMut(&T) -> B) -> impl FnMut(T) -> (B, T) {\n@@ -2266,7 +2347,9 @@ pub trait Iterator {\n     #[inline]\n     #[stable(feature = \"iter_max_by\", since = \"1.15.0\")]\n     fn max_by<F>(self, compare: F) -> Option<Self::Item>\n-        where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n+    where\n+        Self: Sized,\n+        F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n     {\n         #[inline]\n         fn fold<T>(mut compare: impl FnMut(&T, &T) -> Ordering) -> impl FnMut(T, T) -> T {\n@@ -2293,7 +2376,9 @@ pub trait Iterator {\n     #[inline]\n     #[stable(feature = \"iter_cmp_by_key\", since = \"1.6.0\")]\n     fn min_by_key<B: Ord, F>(self, f: F) -> Option<Self::Item>\n-        where Self: Sized, F: FnMut(&Self::Item) -> B,\n+    where\n+        Self: Sized,\n+        F: FnMut(&Self::Item) -> B,\n     {\n         #[inline]\n         fn key<T, B>(mut f: impl FnMut(&T) -> B) -> impl FnMut(T) -> (B, T) {\n@@ -2326,7 +2411,9 @@ pub trait Iterator {\n     #[inline]\n     #[stable(feature = \"iter_min_by\", since = \"1.15.0\")]\n     fn min_by<F>(self, compare: F) -> Option<Self::Item>\n-        where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n+    where\n+        Self: Sized,\n+        F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n     {\n         #[inline]\n         fn fold<T>(mut compare: impl FnMut(&T, &T) -> Ordering) -> impl FnMut(T, T) -> T {\n@@ -2336,7 +2423,6 @@ pub trait Iterator {\n         fold1(self, fold(compare))\n     }\n \n-\n     /// Reverses an iterator's direction.\n     ///\n     /// Usually, iterators iterate from left to right. After using `rev()`,\n@@ -2362,7 +2448,10 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn rev(self) -> Rev<Self> where Self: Sized + DoubleEndedIterator {\n+    fn rev(self) -> Rev<Self>\n+    where\n+        Self: Sized + DoubleEndedIterator,\n+    {\n         Rev::new(self)\n     }\n \n@@ -2389,10 +2478,11 @@ pub trait Iterator {\n     /// assert_eq!(right, [2, 4]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn unzip<A, B, FromA, FromB>(self) -> (FromA, FromB) where\n+    fn unzip<A, B, FromA, FromB>(self) -> (FromA, FromB)\n+    where\n         FromA: Default + Extend<A>,\n         FromB: Default + Extend<B>,\n-        Self: Sized + Iterator<Item=(A, B)>,\n+        Self: Sized + Iterator<Item = (A, B)>,\n     {\n         fn extend<'a, A, B>(\n             ts: &'a mut impl Extend<A>,\n@@ -2434,7 +2524,9 @@ pub trait Iterator {\n     /// ```\n     #[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n     fn copied<'a, T: 'a>(self) -> Copied<Self>\n-        where Self: Sized + Iterator<Item=&'a T>, T: Copy\n+    where\n+        Self: Sized + Iterator<Item = &'a T>,\n+        T: Copy,\n     {\n         Copied::new(self)\n     }\n@@ -2463,7 +2555,9 @@ pub trait Iterator {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn cloned<'a, T: 'a>(self) -> Cloned<Self>\n-        where Self: Sized + Iterator<Item=&'a T>, T: Clone\n+    where\n+        Self: Sized + Iterator<Item = &'a T>,\n+        T: Clone,\n     {\n         Cloned::new(self)\n     }\n@@ -2495,7 +2589,10 @@ pub trait Iterator {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    fn cycle(self) -> Cycle<Self> where Self: Sized + Clone {\n+    fn cycle(self) -> Cycle<Self>\n+    where\n+        Self: Sized + Clone,\n+    {\n         Cycle::new(self)\n     }\n \n@@ -2523,8 +2620,9 @@ pub trait Iterator {\n     /// ```\n     #[stable(feature = \"iter_arith\", since = \"1.11.0\")]\n     fn sum<S>(self) -> S\n-        where Self: Sized,\n-              S: Sum<Self::Item>,\n+    where\n+        Self: Sized,\n+        S: Sum<Self::Item>,\n     {\n         Sum::sum(self)\n     }\n@@ -2551,8 +2649,9 @@ pub trait Iterator {\n     /// ```\n     #[stable(feature = \"iter_arith\", since = \"1.11.0\")]\n     fn product<P>(self) -> P\n-        where Self: Sized,\n-              P: Product<Self::Item>,\n+    where\n+        Self: Sized,\n+        P: Product<Self::Item>,\n     {\n         Product::product(self)\n     }\n@@ -2609,11 +2708,13 @@ pub trait Iterator {\n \n         loop {\n             let x = match self.next() {\n-                None => if other.next().is_none() {\n-                    return Ordering::Equal\n-                } else {\n-                    return Ordering::Less\n-                },\n+                None => {\n+                    if other.next().is_none() {\n+                        return Ordering::Equal;\n+                    } else {\n+                        return Ordering::Less;\n+                    }\n+                }\n                 Some(val) => val,\n             };\n \n@@ -2692,11 +2793,13 @@ pub trait Iterator {\n \n         loop {\n             let x = match self.next() {\n-                None => if other.next().is_none() {\n-                    return Some(Ordering::Equal)\n-                } else {\n-                    return Some(Ordering::Less)\n-                },\n+                None => {\n+                    if other.next().is_none() {\n+                        return Some(Ordering::Equal);\n+                    } else {\n+                        return Some(Ordering::Less);\n+                    }\n+                }\n                 Some(val) => val,\n             };\n \n@@ -2782,7 +2885,8 @@ pub trait Iterator {\n     /// assert_eq!([1].iter().ne([1, 2].iter()), true);\n     /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n-    fn ne<I>(self, other: I) -> bool where\n+    fn ne<I>(self, other: I) -> bool\n+    where\n         I: IntoIterator,\n         Self::Item: PartialEq<I::Item>,\n         Self: Sized,\n@@ -2801,7 +2905,8 @@ pub trait Iterator {\n     /// assert_eq!([1, 2].iter().lt([1].iter()), false);\n     /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n-    fn lt<I>(self, other: I) -> bool where\n+    fn lt<I>(self, other: I) -> bool\n+    where\n         I: IntoIterator,\n         Self::Item: PartialOrd<I::Item>,\n         Self: Sized,\n@@ -2820,7 +2925,8 @@ pub trait Iterator {\n     /// assert_eq!([1, 2].iter().le([1].iter()), false);\n     /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n-    fn le<I>(self, other: I) -> bool where\n+    fn le<I>(self, other: I) -> bool\n+    where\n         I: IntoIterator,\n         Self::Item: PartialOrd<I::Item>,\n         Self: Sized,\n@@ -2842,7 +2948,8 @@ pub trait Iterator {\n     /// assert_eq!([1, 2].iter().gt([1].iter()), true);\n     /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n-    fn gt<I>(self, other: I) -> bool where\n+    fn gt<I>(self, other: I) -> bool\n+    where\n         I: IntoIterator,\n         Self::Item: PartialOrd<I::Item>,\n         Self: Sized,\n@@ -2861,7 +2968,8 @@ pub trait Iterator {\n     /// assert_eq!([1, 2].iter().ge([1].iter()), true);\n     /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n-    fn ge<I>(self, other: I) -> bool where\n+    fn ge<I>(self, other: I) -> bool\n+    where\n         I: IntoIterator,\n         Self::Item: PartialOrd<I::Item>,\n         Self: Sized,\n@@ -2925,7 +3033,7 @@ pub trait Iterator {\n     fn is_sorted_by<F>(mut self, mut compare: F) -> bool\n     where\n         Self: Sized,\n-        F: FnMut(&Self::Item, &Self::Item) -> Option<Ordering>\n+        F: FnMut(&Self::Item, &Self::Item) -> Option<Ordering>,\n     {\n         let mut last = match self.next() {\n             Some(e) => e,\n@@ -2965,7 +3073,7 @@ pub trait Iterator {\n     where\n         Self: Sized,\n         F: FnMut(Self::Item) -> K,\n-        K: PartialOrd\n+        K: PartialOrd,\n     {\n         self.map(f).is_sorted()\n     }\n@@ -2974,9 +3082,9 @@ pub trait Iterator {\n /// Fold an iterator without having to provide an initial value.\n #[inline]\n fn fold1<I, F>(mut it: I, f: F) -> Option<I::Item>\n-    where\n-        I: Iterator,\n-        F: FnMut(I::Item, I::Item) -> I::Item,\n+where\n+    I: Iterator,\n+    F: FnMut(I::Item, I::Item) -> I::Item,\n {\n     // start with the first element as our selection. This avoids\n     // having to use `Option`s inside the loop, translating to a\n@@ -2988,8 +3096,12 @@ fn fold1<I, F>(mut it: I, f: F) -> Option<I::Item>\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: Iterator + ?Sized> Iterator for &mut I {\n     type Item = I::Item;\n-    fn next(&mut self) -> Option<I::Item> { (**self).next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { (**self).size_hint() }\n+    fn next(&mut self) -> Option<I::Item> {\n+        (**self).next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (**self).size_hint()\n+    }\n     fn nth(&mut self, n: usize) -> Option<Self::Item> {\n         (**self).nth(n)\n     }"}, {"sha": "d4bec996d89a1e279a1ea1cf89d8f5cb53b9b833", "filename": "src/libcore/tests/pattern.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibcore%2Ftests%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibcore%2Ftests%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fpattern.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d", "patch": "@@ -42,8 +42,6 @@ impl From<Option<(usize, usize)>> for Step {\n     }\n }\n \n-// ignore-tidy-linelength\n-\n // FIXME(Manishearth) these tests focus on single-character searching  (CharSearcher)\n // and on next()/next_match(), not next_reject(). This is because\n // the memchr changes make next_match() for single chars complex, but next_reject()"}, {"sha": "f6db451d57ead86c101730c3eb197fa5f39cc4f1", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 401, "deletions": 582, "changes": 983, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d", "patch": "@@ -37,39 +37,39 @@ mod item;\n \n use crate::arena::Arena;\n use crate::dep_graph::DepGraph;\n-use crate::hir::{self, ParamName};\n-use crate::hir::HirVec;\n-use crate::hir::map::{DefKey, DefPathData, Definitions};\n+use crate::hir::def::{DefKind, Namespace, PartialRes, PerNS, Res};\n use crate::hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n-use crate::hir::def::{Namespace, Res, DefKind, PartialRes, PerNS};\n-use crate::hir::{GenericArg, ConstArg};\n+use crate::hir::map::{DefKey, DefPathData, Definitions};\n use crate::hir::ptr::P;\n+use crate::hir::HirVec;\n+use crate::hir::{self, ParamName};\n+use crate::hir::{ConstArg, GenericArg};\n use crate::lint;\n use crate::lint::builtin::{self, ELIDED_LIFETIMES_IN_PATHS};\n use crate::middle::cstore::CrateStore;\n-use crate::session::Session;\n use crate::session::config::nightly_options;\n+use crate::session::Session;\n use crate::util::common::FN_OUTPUT_NAME;\n use crate::util::nodemap::{DefIdMap, NodeMap};\n use errors::Applicability;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_index::vec::IndexVec;\n use rustc_data_structures::sync::Lrc;\n+use rustc_index::vec::IndexVec;\n \n+use smallvec::SmallVec;\n use std::collections::BTreeMap;\n use std::mem;\n-use smallvec::SmallVec;\n-use syntax::attr;\n use syntax::ast;\n-use syntax::ptr::P as AstP;\n use syntax::ast::*;\n+use syntax::attr;\n use syntax::errors;\n use syntax::print::pprust;\n-use syntax::token::{self, Nonterminal, Token};\n-use syntax::tokenstream::{TokenStream, TokenTree};\n+use syntax::ptr::P as AstP;\n use syntax::sess::ParseSess;\n-use syntax::source_map::{respan, ExpnData, ExpnKind, DesugaringKind, Spanned};\n+use syntax::source_map::{respan, DesugaringKind, ExpnData, ExpnKind, Spanned};\n use syntax::symbol::{kw, sym, Symbol};\n+use syntax::token::{self, Nonterminal, Token};\n+use syntax::tokenstream::{TokenStream, TokenTree};\n use syntax::visit::{self, Visitor};\n use syntax_pos::hygiene::ExpnId;\n use syntax_pos::Span;\n@@ -291,7 +291,8 @@ pub fn lower_crate<'a, 'hir>(\n         in_scope_lifetimes: Vec::new(),\n         allow_try_trait: Some([sym::try_trait][..].into()),\n         allow_gen_future: Some([sym::gen_future][..].into()),\n-    }.lower_crate(krate)\n+    }\n+    .lower_crate(krate)\n }\n \n #[derive(Copy, Clone, PartialEq)]\n@@ -359,26 +360,22 @@ enum AnonymousLifetimeMode {\n     PassThrough,\n }\n \n-struct ImplTraitTypeIdVisitor<'a> { ids: &'a mut SmallVec<[NodeId; 1]> }\n+struct ImplTraitTypeIdVisitor<'a> {\n+    ids: &'a mut SmallVec<[NodeId; 1]>,\n+}\n \n impl<'a, 'b> Visitor<'a> for ImplTraitTypeIdVisitor<'b> {\n     fn visit_ty(&mut self, ty: &'a Ty) {\n         match ty.kind {\n-            | TyKind::Typeof(_)\n-            | TyKind::BareFn(_)\n-            => return,\n+            TyKind::Typeof(_) | TyKind::BareFn(_) => return,\n \n             TyKind::ImplTrait(id, _) => self.ids.push(id),\n-            _ => {},\n+            _ => {}\n         }\n         visit::walk_ty(self, ty);\n     }\n \n-    fn visit_path_segment(\n-        &mut self,\n-        path_span: Span,\n-        path_segment: &'v PathSegment,\n-    ) {\n+    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'v PathSegment) {\n         if let Some(ref p) = path_segment.args {\n             if let GenericArgs::Parenthesized(_) = **p {\n                 return;\n@@ -401,11 +398,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n \n         impl MiscCollector<'_, '_, '_> {\n-            fn allocate_use_tree_hir_id_counters(\n-                &mut self,\n-                tree: &UseTree,\n-                owner: DefIndex,\n-            ) {\n+            fn allocate_use_tree_hir_id_counters(&mut self, tree: &UseTree, owner: DefIndex) {\n                 match tree.kind {\n                     UseTreeKind::Simple(_, id1, id2) => {\n                         for &id in &[id1, id2] {\n@@ -488,13 +481,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 match item.kind {\n                     AssocItemKind::Fn(_, None) => {\n                         // Ignore patterns in trait methods without bodies\n-                        self.with_hir_id_owner(None, |this| {\n-                            visit::walk_trait_item(this, item)\n-                        });\n+                        self.with_hir_id_owner(None, |this| visit::walk_trait_item(this, item));\n                     }\n                     _ => self.with_hir_id_owner(Some(item.id), |this| {\n                         visit::walk_trait_item(this, item);\n-                    })\n+                    }),\n                 }\n             }\n \n@@ -507,20 +498,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n             fn visit_foreign_item(&mut self, i: &'tcx ForeignItem) {\n                 // Ignore patterns in foreign items\n-                self.with_hir_id_owner(None, |this| {\n-                    visit::walk_foreign_item(this, i)\n-                });\n+                self.with_hir_id_owner(None, |this| visit::walk_foreign_item(this, i));\n             }\n \n             fn visit_ty(&mut self, t: &'tcx Ty) {\n                 match t.kind {\n                     // Mirrors the case in visit::walk_ty\n                     TyKind::BareFn(ref f) => {\n-                        walk_list!(\n-                            self,\n-                            visit_generic_param,\n-                            &f.generic_params\n-                        );\n+                        walk_list!(self, visit_generic_param, &f.generic_params);\n                         // Mirrors visit::walk_fn_decl\n                         for parameter in &f.decl.inputs {\n                             // We don't lower the ids of argument patterns\n@@ -546,9 +531,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let attrs = self.arena.alloc_from_iter(self.lower_attrs(&c.attrs).into_iter());\n         let body_ids = body_ids(&self.bodies);\n \n-        self.resolver\n-            .definitions()\n-            .init_node_id_to_hir_id_mapping(self.node_id_to_hir_id);\n+        self.resolver.definitions().init_node_id_to_hir_id_mapping(self.node_id_to_hir_id);\n \n         hir::Crate {\n             module,\n@@ -614,7 +597,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     where\n         F: FnOnce(&mut Self) -> T,\n     {\n-        let counter = self.item_local_id_counters\n+        let counter = self\n+            .item_local_id_counters\n             .insert(owner, HIR_ID_COUNTER_LOCKED)\n             .unwrap_or_else(|| panic!(\"no `item_local_id_counters` entry for {:?}\", owner));\n         let def_index = self.resolver.definitions().opt_def_index(owner).unwrap();\n@@ -625,9 +609,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         debug_assert!(def_index == new_def_index);\n         debug_assert!(new_counter >= counter);\n \n-        let prev = self.item_local_id_counters\n-            .insert(owner, new_counter)\n-            .unwrap();\n+        let prev = self.item_local_id_counters.insert(owner, new_counter).unwrap();\n         debug_assert!(prev == HIR_ID_COUNTER_LOCKED);\n         ret\n     }\n@@ -644,10 +626,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 this.current_hir_id_owner.last_mut().unwrap();\n             let local_id = *local_id_counter;\n             *local_id_counter += 1;\n-            hir::HirId {\n-                owner: def_index,\n-                local_id: hir::ItemLocalId::from_u32(local_id),\n-            }\n+            hir::HirId { owner: def_index, local_id: hir::ItemLocalId::from_u32(local_id) }\n         })\n     }\n \n@@ -665,17 +644,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             debug_assert!(local_id != HIR_ID_COUNTER_LOCKED);\n \n             *local_id_counter += 1;\n-            let def_index = this\n-                .resolver\n-                .definitions()\n-                .opt_def_index(owner)\n-                .expect(\"you forgot to call `create_def_with_parent` or are lowering node-IDs \\\n-                         that do not belong to the current owner\");\n-\n-            hir::HirId {\n-                owner: def_index,\n-                local_id: hir::ItemLocalId::from_u32(local_id),\n-            }\n+            let def_index = this.resolver.definitions().opt_def_index(owner).expect(\n+                \"you forgot to call `create_def_with_parent` or are lowering node-IDs \\\n+                         that do not belong to the current owner\",\n+            );\n+\n+            hir::HirId { owner: def_index, local_id: hir::ItemLocalId::from_u32(local_id) }\n         })\n     }\n \n@@ -736,8 +710,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.anonymous_lifetime_mode = anonymous_lifetime_mode;\n         let result = op(self);\n         self.anonymous_lifetime_mode = old_anonymous_lifetime_mode;\n-        debug!(\"with_anonymous_lifetime_mode: restoring anonymous_lifetime_mode={:?}\",\n-               old_anonymous_lifetime_mode);\n+        debug!(\n+            \"with_anonymous_lifetime_mode: restoring anonymous_lifetime_mode={:?}\",\n+            old_anonymous_lifetime_mode\n+        );\n         result\n     }\n \n@@ -774,9 +750,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         let params = lifetimes_to_define\n             .into_iter()\n-            .map(|(span, hir_name)| self.lifetime_to_generic_param(\n-                span, hir_name, parent_id.index,\n-            ))\n+            .map(|(span, hir_name)| self.lifetime_to_generic_param(span, hir_name, parent_id.index))\n             .chain(in_band_ty_params.into_iter())\n             .collect();\n \n@@ -796,18 +770,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // that collisions are ok here and this shouldn't\n         // really show up for end-user.\n         let (str_name, kind) = match hir_name {\n-            ParamName::Plain(ident) => (\n-                ident.name,\n-                hir::LifetimeParamKind::InBand,\n-            ),\n-            ParamName::Fresh(_) => (\n-                kw::UnderscoreLifetime,\n-                hir::LifetimeParamKind::Elided,\n-            ),\n-            ParamName::Error => (\n-                kw::UnderscoreLifetime,\n-                hir::LifetimeParamKind::Error,\n-            ),\n+            ParamName::Plain(ident) => (ident.name, hir::LifetimeParamKind::InBand),\n+            ParamName::Fresh(_) => (kw::UnderscoreLifetime, hir::LifetimeParamKind::Elided),\n+            ParamName::Error => (kw::UnderscoreLifetime, hir::LifetimeParamKind::Error),\n         };\n \n         // Add a definition for the in-band lifetime def.\n@@ -826,7 +791,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             bounds: hir_vec![],\n             span,\n             pure_wrt_drop: false,\n-            kind: hir::GenericParamKind::Lifetime { kind }\n+            kind: hir::GenericParamKind::Lifetime { kind },\n         }\n     }\n \n@@ -849,8 +814,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         let hir_name = ParamName::Plain(ident);\n \n-        if self.lifetimes_to_define.iter()\n-                                   .any(|(_, lt_name)| lt_name.modern() == hir_name.modern()) {\n+        if self.lifetimes_to_define.iter().any(|(_, lt_name)| lt_name.modern() == hir_name.modern())\n+        {\n             return;\n         }\n \n@@ -904,9 +869,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     where\n         F: FnOnce(&mut LoweringContext<'_, '_>, &mut Vec<hir::GenericParam>) -> T,\n     {\n-        let (in_band_defs, (mut lowered_generics, res)) = self.with_in_scope_lifetime_defs(\n-            &generics.params,\n-            |this| {\n+        let (in_band_defs, (mut lowered_generics, res)) =\n+            self.with_in_scope_lifetime_defs(&generics.params, |this| {\n                 this.collect_in_band_defs(parent_id, anonymous_lifetime_mode, |this| {\n                     let mut params = Vec::new();\n                     // Note: it is necessary to lower generics *before* calling `f`.\n@@ -916,32 +880,24 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // `lifetimes_to_define`. If we swapped the order of these two,\n                     // in-band-lifetimes introduced by generics or where-clauses\n                     // wouldn't have been added yet.\n-                    let generics = this.lower_generics(\n-                        generics,\n-                        ImplTraitContext::Universal(&mut params),\n-                    );\n+                    let generics =\n+                        this.lower_generics(generics, ImplTraitContext::Universal(&mut params));\n                     let res = f(this, &mut params);\n                     (params, (generics, res))\n                 })\n-            },\n-        );\n+            });\n \n-        let mut lowered_params: Vec<_> = lowered_generics\n-            .params\n-            .into_iter()\n-            .chain(in_band_defs)\n-            .collect();\n+        let mut lowered_params: Vec<_> =\n+            lowered_generics.params.into_iter().chain(in_band_defs).collect();\n \n         // FIXME(const_generics): the compiler doesn't always cope with\n         // unsorted generic parameters at the moment, so we make sure\n         // that they're ordered correctly here for now. (When we chain\n         // the `in_band_defs`, we might make the order unsorted.)\n-        lowered_params.sort_by_key(|param| {\n-            match param.kind {\n-                hir::GenericParamKind::Lifetime { .. } => ParamKindOrd::Lifetime,\n-                hir::GenericParamKind::Type { .. } => ParamKindOrd::Type,\n-                hir::GenericParamKind::Const { .. } => ParamKindOrd::Const,\n-            }\n+        lowered_params.sort_by_key(|param| match param.kind {\n+            hir::GenericParamKind::Lifetime { .. } => ParamKindOrd::Lifetime,\n+            hir::GenericParamKind::Type { .. } => ParamKindOrd::Type,\n+            hir::GenericParamKind::Const { .. } => ParamKindOrd::Const,\n         });\n \n         lowered_generics.params = lowered_params.into();\n@@ -990,9 +946,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn lower_attrs_arena(&mut self, attrs: &[Attribute]) -> &'hir [Attribute] {\n-        self.arena.alloc_from_iter(\n-            attrs.iter().map(|a| self.lower_attr(a))\n-        )\n+        self.arena.alloc_from_iter(attrs.iter().map(|a| self.lower_attr(a)))\n     }\n \n     fn lower_attrs(&mut self, attrs: &[Attribute]) -> hir::HirVec<Attribute> {\n@@ -1004,48 +958,38 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // lower attributes (we use the AST version) there is nowhere to keep\n         // the `HirId`s. We don't actually need HIR version of attributes anyway.\n         let kind = match attr.kind {\n-            AttrKind::Normal(ref item) => {\n-                AttrKind::Normal(AttrItem {\n-                    path: item.path.clone(),\n-                    args: self.lower_mac_args(&item.args),\n-                })\n-            }\n-            AttrKind::DocComment(comment) => AttrKind::DocComment(comment)\n+            AttrKind::Normal(ref item) => AttrKind::Normal(AttrItem {\n+                path: item.path.clone(),\n+                args: self.lower_mac_args(&item.args),\n+            }),\n+            AttrKind::DocComment(comment) => AttrKind::DocComment(comment),\n         };\n \n-        Attribute {\n-            kind,\n-            id: attr.id,\n-            style: attr.style,\n-            span: attr.span,\n-        }\n+        Attribute { kind, id: attr.id, style: attr.style, span: attr.span }\n     }\n \n     fn lower_mac_args(&mut self, args: &MacArgs) -> MacArgs {\n         match *args {\n             MacArgs::Empty => MacArgs::Empty,\n-            MacArgs::Delimited(dspan, delim, ref tokens) =>\n-                MacArgs::Delimited(dspan, delim, self.lower_token_stream(tokens.clone())),\n-            MacArgs::Eq(eq_span, ref tokens) =>\n-                MacArgs::Eq(eq_span, self.lower_token_stream(tokens.clone())),\n+            MacArgs::Delimited(dspan, delim, ref tokens) => {\n+                MacArgs::Delimited(dspan, delim, self.lower_token_stream(tokens.clone()))\n+            }\n+            MacArgs::Eq(eq_span, ref tokens) => {\n+                MacArgs::Eq(eq_span, self.lower_token_stream(tokens.clone()))\n+            }\n         }\n     }\n \n     fn lower_token_stream(&mut self, tokens: TokenStream) -> TokenStream {\n-        tokens\n-            .into_trees()\n-            .flat_map(|tree| self.lower_token_tree(tree).into_trees())\n-            .collect()\n+        tokens.into_trees().flat_map(|tree| self.lower_token_tree(tree).into_trees()).collect()\n     }\n \n     fn lower_token_tree(&mut self, tree: TokenTree) -> TokenStream {\n         match tree {\n             TokenTree::Token(token) => self.lower_token(token),\n-            TokenTree::Delimited(span, delim, tts) => TokenTree::Delimited(\n-                span,\n-                delim,\n-                self.lower_token_stream(tts),\n-            ).into(),\n+            TokenTree::Delimited(span, delim, tts) => {\n+                TokenTree::Delimited(span, delim, self.lower_token_stream(tts)).into()\n+            }\n         }\n     }\n \n@@ -1077,9 +1021,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         debug!(\"lower_assoc_ty_constraint(constraint={:?}, itctx={:?})\", constraint, itctx);\n \n         let kind = match constraint.kind {\n-            AssocTyConstraintKind::Equality { ref ty } => hir::TypeBindingKind::Equality {\n-                ty: self.lower_ty(ty, itctx)\n-            },\n+            AssocTyConstraintKind::Equality { ref ty } => {\n+                hir::TypeBindingKind::Equality { ty: self.lower_ty(ty, itctx) }\n+            }\n             AssocTyConstraintKind::Bound { ref bounds } => {\n                 // Piggy-back on the `impl Trait` context to figure out the correct behavior.\n                 let (desugar_to_impl_trait, itctx) = match itctx {\n@@ -1107,8 +1051,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // then to an opaque type).\n                     //\n                     // FIXME: this is only needed until `impl Trait` is allowed in type aliases.\n-                    ImplTraitContext::Disallowed(_) if self.is_in_dyn_type =>\n-                        (true, ImplTraitContext::OpaqueTy(None)),\n+                    ImplTraitContext::Disallowed(_) if self.is_in_dyn_type => {\n+                        (true, ImplTraitContext::OpaqueTy(None))\n+                    }\n \n                     // We are in the parameter position, but not within a dyn type:\n                     //\n@@ -1145,18 +1090,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             itctx,\n                         );\n \n-                        hir::TypeBindingKind::Equality {\n-                            ty\n-                        }\n+                        hir::TypeBindingKind::Equality { ty }\n                     })\n                 } else {\n                     // Desugar `AssocTy: Bounds` into a type binding where the\n                     // later desugars into a trait predicate.\n                     let bounds = self.lower_param_bounds(bounds, itctx);\n \n-                    hir::TypeBindingKind::Constraint {\n-                        bounds\n-                    }\n+                    hir::TypeBindingKind::Constraint { bounds }\n                 }\n             }\n         };\n@@ -1172,7 +1113,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_generic_arg(\n         &mut self,\n         arg: &ast::GenericArg,\n-        itctx: ImplTraitContext<'_>\n+        itctx: ImplTraitContext<'_>,\n     ) -> hir::GenericArg {\n         match arg {\n             ast::GenericArg::Lifetime(lt) => GenericArg::Lifetime(self.lower_lifetime(&lt)),\n@@ -1192,8 +1133,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                             // Construct a AnonConst where the expr is the \"ty\"'s path.\n \n-                            let parent_def_index =\n-                                self.current_hir_id_owner.last().unwrap().0;\n+                            let parent_def_index = self.current_hir_id_owner.last().unwrap().0;\n                             let node_id = self.resolver.next_node_id();\n \n                             // Add a definition for the in-band const def.\n@@ -1212,27 +1152,20 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                 attrs: AttrVec::new(),\n                             };\n \n-                            let ct = self.with_new_scopes(|this| {\n-                                hir::AnonConst {\n-                                    hir_id: this.lower_node_id(node_id),\n-                                    body: this.lower_const_body(path_expr.span, Some(&path_expr)),\n-                                }\n-                            });\n-                            return GenericArg::Const(ConstArg {\n-                                value: ct,\n-                                span: ty.span,\n+                            let ct = self.with_new_scopes(|this| hir::AnonConst {\n+                                hir_id: this.lower_node_id(node_id),\n+                                body: this.lower_const_body(path_expr.span, Some(&path_expr)),\n                             });\n+                            return GenericArg::Const(ConstArg { value: ct, span: ty.span });\n                         }\n                     }\n                 }\n                 GenericArg::Type(self.lower_ty_direct(&ty, itctx))\n             }\n-            ast::GenericArg::Const(ct) => {\n-                GenericArg::Const(ConstArg {\n-                    value: self.lower_anon_const(&ct),\n-                    span: ct.value.span,\n-                })\n-            }\n+            ast::GenericArg::Const(ct) => GenericArg::Const(ConstArg {\n+                value: self.lower_anon_const(&ct),\n+                span: ct.value.span,\n+            }),\n         }\n     }\n \n@@ -1246,7 +1179,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         qself: &Option<QSelf>,\n         path: &Path,\n         param_mode: ParamMode,\n-        itctx: ImplTraitContext<'_>\n+        itctx: ImplTraitContext<'_>,\n     ) -> hir::Ty {\n         let id = self.lower_node_id(t.id);\n         let qpath = self.lower_qpath(t.id, qself, path, param_mode, itctx);\n@@ -1279,33 +1212,25 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 };\n                 hir::TyKind::Rptr(lifetime, self.lower_mt(mt, itctx))\n             }\n-            TyKind::BareFn(ref f) => self.with_in_scope_lifetime_defs(\n-                &f.generic_params,\n-                |this| {\n-                    this.with_anonymous_lifetime_mode(\n-                        AnonymousLifetimeMode::PassThrough,\n-                        |this| {\n-                            hir::TyKind::BareFn(P(hir::BareFnTy {\n-                                generic_params: this.lower_generic_params(\n-                                    &f.generic_params,\n-                                    &NodeMap::default(),\n-                                    ImplTraitContext::disallowed(),\n-                                ),\n-                                unsafety: f.unsafety,\n-                                abi: this.lower_extern(f.ext),\n-                                decl: this.lower_fn_decl(&f.decl, None, false, None),\n-                                param_names: this.lower_fn_params_to_names(&f.decl),\n-                            }))\n-                        },\n-                    )\n-                },\n-            ),\n+            TyKind::BareFn(ref f) => self.with_in_scope_lifetime_defs(&f.generic_params, |this| {\n+                this.with_anonymous_lifetime_mode(AnonymousLifetimeMode::PassThrough, |this| {\n+                    hir::TyKind::BareFn(P(hir::BareFnTy {\n+                        generic_params: this.lower_generic_params(\n+                            &f.generic_params,\n+                            &NodeMap::default(),\n+                            ImplTraitContext::disallowed(),\n+                        ),\n+                        unsafety: f.unsafety,\n+                        abi: this.lower_extern(f.ext),\n+                        decl: this.lower_fn_decl(&f.decl, None, false, None),\n+                        param_names: this.lower_fn_params_to_names(&f.decl),\n+                    }))\n+                })\n+            }),\n             TyKind::Never => hir::TyKind::Never,\n-            TyKind::Tup(ref tys) => {\n-                hir::TyKind::Tup(tys.iter().map(|ty| {\n-                    self.lower_ty_direct(ty, itctx.reborrow())\n-                }).collect())\n-            }\n+            TyKind::Tup(ref tys) => hir::TyKind::Tup(\n+                tys.iter().map(|ty| self.lower_ty_direct(ty, itctx.reborrow())).collect(),\n+            ),\n             TyKind::Paren(ref ty) => {\n                 return self.lower_ty_direct(ty, itctx);\n             }\n@@ -1319,19 +1244,17 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     None,\n                     P(hir::Path {\n                         res,\n-                        segments: hir_vec![hir::PathSegment::from_ident(\n-                            Ident::with_dummy_span(kw::SelfUpper)\n-                        )],\n+                        segments: hir_vec![hir::PathSegment::from_ident(Ident::with_dummy_span(\n+                            kw::SelfUpper\n+                        ))],\n                         span: t.span,\n                     }),\n                 ))\n-            },\n+            }\n             TyKind::Array(ref ty, ref length) => {\n                 hir::TyKind::Array(self.lower_ty(ty, itctx), self.lower_anon_const(length))\n             }\n-            TyKind::Typeof(ref expr) => {\n-                hir::TyKind::Typeof(self.lower_anon_const(expr))\n-            }\n+            TyKind::Typeof(ref expr) => hir::TyKind::Typeof(self.lower_anon_const(expr)),\n             TyKind::TraitObject(ref bounds, kind) => {\n                 let mut lifetime_bound = None;\n                 let (bounds, lifetime_bound) = self.with_dyn_type_scope(true, |this| {\n@@ -1363,18 +1286,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 let span = t.span;\n                 match itctx {\n                     ImplTraitContext::OpaqueTy(fn_def_id) => {\n-                        self.lower_opaque_impl_trait(\n-                            span, fn_def_id, def_node_id,\n-                            |this| this.lower_param_bounds(bounds, itctx),\n-                        )\n+                        self.lower_opaque_impl_trait(span, fn_def_id, def_node_id, |this| {\n+                            this.lower_param_bounds(bounds, itctx)\n+                        })\n                     }\n                     ImplTraitContext::Universal(in_band_ty_params) => {\n                         // Add a definition for the in-band `Param`.\n-                        let def_index = self\n-                            .resolver\n-                            .definitions()\n-                            .opt_def_index(def_node_id)\n-                            .unwrap();\n+                        let def_index =\n+                            self.resolver.definitions().opt_def_index(def_node_id).unwrap();\n \n                         let hir_bounds = self.lower_param_bounds(\n                             bounds,\n@@ -1392,7 +1311,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             kind: hir::GenericParamKind::Type {\n                                 default: None,\n                                 synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n-                            }\n+                            },\n                         });\n \n                         hir::TyKind::Path(hir::QPath::Resolved(\n@@ -1405,8 +1324,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         ))\n                     }\n                     ImplTraitContext::Disallowed(pos) => {\n-                        let allowed_in = if self.sess.features_untracked()\n-                                                .impl_trait_in_bindings {\n+                        let allowed_in = if self.sess.features_untracked().impl_trait_in_bindings {\n                             \"bindings or function and inherent method return types\"\n                         } else {\n                             \"function and inherent method return types\"\n@@ -1418,11 +1336,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             \"`impl Trait` not allowed outside of {}\",\n                             allowed_in,\n                         );\n-                        if pos == ImplTraitPosition::Binding &&\n-                            nightly_options::is_nightly_build() {\n-                            help!(err,\n-                                  \"add `#![feature(impl_trait_in_bindings)]` to the crate \\\n-                                   attributes to enable\");\n+                        if pos == ImplTraitPosition::Binding && nightly_options::is_nightly_build()\n+                        {\n+                            help!(\n+                                err,\n+                                \"add `#![feature(impl_trait_in_bindings)]` to the crate \\\n+                                   attributes to enable\"\n+                            );\n                         }\n                         err.emit();\n                         hir::TyKind::Err\n@@ -1439,11 +1359,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n         };\n \n-        hir::Ty {\n-            kind,\n-            span: t.span,\n-            hir_id: self.lower_node_id(t.id),\n-        }\n+        hir::Ty { kind, span: t.span, hir_id: self.lower_node_id(t.id) }\n     }\n \n     fn lower_opaque_impl_trait(\n@@ -1455,27 +1371,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     ) -> hir::TyKind {\n         debug!(\n             \"lower_opaque_impl_trait(fn_def_id={:?}, opaque_ty_node_id={:?}, span={:?})\",\n-            fn_def_id,\n-            opaque_ty_node_id,\n-            span,\n+            fn_def_id, opaque_ty_node_id, span,\n         );\n \n         // Make sure we know that some funky desugaring has been going on here.\n         // This is a first: there is code in other places like for loop\n         // desugaring that explicitly states that we don't want to track that.\n         // Not tracking it makes lints in rustc and clippy very fragile, as\n         // frequently opened issues show.\n-        let opaque_ty_span = self.mark_span_with_reason(\n-            DesugaringKind::OpaqueTy,\n-            span,\n-            None,\n-        );\n+        let opaque_ty_span = self.mark_span_with_reason(DesugaringKind::OpaqueTy, span, None);\n \n-        let opaque_ty_def_index = self\n-            .resolver\n-            .definitions()\n-            .opt_def_index(opaque_ty_node_id)\n-            .unwrap();\n+        let opaque_ty_def_index =\n+            self.resolver.definitions().opt_def_index(opaque_ty_node_id).unwrap();\n \n         self.allocate_hir_id_counter(opaque_ty_node_id);\n \n@@ -1487,22 +1394,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             &hir_bounds,\n         );\n \n-        debug!(\n-            \"lower_opaque_impl_trait: lifetimes={:#?}\", lifetimes,\n-        );\n+        debug!(\"lower_opaque_impl_trait: lifetimes={:#?}\", lifetimes,);\n \n-        debug!(\n-            \"lower_opaque_impl_trait: lifetime_defs={:#?}\", lifetime_defs,\n-        );\n+        debug!(\"lower_opaque_impl_trait: lifetime_defs={:#?}\", lifetime_defs,);\n \n         self.with_hir_id_owner(opaque_ty_node_id, |lctx| {\n             let opaque_ty_item = hir::OpaqueTy {\n                 generics: hir::Generics {\n                     params: lifetime_defs,\n-                    where_clause: hir::WhereClause {\n-                        predicates: hir_vec![],\n-                        span,\n-                    },\n+                    where_clause: hir::WhereClause { predicates: hir_vec![], span },\n                     span,\n                 },\n                 bounds: hir_bounds,\n@@ -1511,12 +1411,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             };\n \n             trace!(\"lower_opaque_impl_trait: {:#?}\", opaque_ty_def_index);\n-            let opaque_ty_id = lctx.generate_opaque_type(\n-                opaque_ty_node_id,\n-                opaque_ty_item,\n-                span,\n-                opaque_ty_span,\n-            );\n+            let opaque_ty_id =\n+                lctx.generate_opaque_type(opaque_ty_node_id, opaque_ty_item, span, opaque_ty_span);\n \n             // `impl Trait` now just becomes `Foo<'a, 'b, ..>`.\n             hir::TyKind::Def(hir::ItemId { id: opaque_ty_id }, lifetimes)\n@@ -1579,9 +1475,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             output_lifetime_params: Vec<hir::GenericParam>,\n         }\n \n-        impl<'r, 'a, 'v, 'hir> hir::intravisit::Visitor<'v>\n-        for ImplTraitLifetimeCollector<'r, 'a, 'hir>\n-        {\n+        impl<'r, 'a, 'v, 'hir> hir::intravisit::Visitor<'v> for ImplTraitLifetimeCollector<'r, 'a, 'hir> {\n             fn nested_visit_map<'this>(\n                 &'this mut self,\n             ) -> hir::intravisit::NestedVisitorMap<'this, 'v> {\n@@ -1663,7 +1557,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 };\n \n                 if !self.currently_bound_lifetimes.contains(&name)\n-                    && !self.already_defined_lifetimes.contains(&name) {\n+                    && !self.already_defined_lifetimes.contains(&name)\n+                {\n                     self.already_defined_lifetimes.insert(name);\n \n                     self.output_lifetimes.push(hir::GenericArg::Lifetime(hir::Lifetime {\n@@ -1680,17 +1575,17 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         def_node_id,\n                         DefPathData::LifetimeNs(name.ident().name),\n                         ExpnId::root(),\n-                        lifetime.span);\n+                        lifetime.span,\n+                    );\n \n                     let (name, kind) = match name {\n                         hir::LifetimeName::Underscore => (\n                             hir::ParamName::Plain(Ident::with_dummy_span(kw::UnderscoreLifetime)),\n                             hir::LifetimeParamKind::Elided,\n                         ),\n-                        hir::LifetimeName::Param(param_name) => (\n-                            param_name,\n-                            hir::LifetimeParamKind::Explicit,\n-                        ),\n+                        hir::LifetimeName::Param(param_name) => {\n+                            (param_name, hir::LifetimeParamKind::Explicit)\n+                        }\n                         _ => bug!(\"expected `LifetimeName::Param` or `ParamName::Plain`\"),\n                     };\n \n@@ -1701,7 +1596,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         pure_wrt_drop: false,\n                         attrs: hir_vec![],\n                         bounds: hir_vec![],\n-                        kind: hir::GenericParamKind::Lifetime { kind }\n+                        kind: hir::GenericParamKind::Lifetime { kind },\n                     });\n                 }\n             }\n@@ -1739,9 +1634,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let qself_position = qself.as_ref().map(|q| q.position);\n         let qself = qself.as_ref().map(|q| self.lower_ty(&q.ty, itctx.reborrow()));\n \n-        let partial_res = self.resolver\n-            .get_partial_res(id)\n-            .unwrap_or_else(|| PartialRes::new(Res::Err));\n+        let partial_res =\n+            self.resolver.get_partial_res(id).unwrap_or_else(|| PartialRes::new(Res::Err));\n \n         let proj_start = p.segments.len() - partial_res.unresolved_segments();\n         let path = P(hir::Path {\n@@ -1777,7 +1671,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         | Res::Def(DefKind::Union, def_id)\n                         | Res::Def(DefKind::Enum, def_id)\n                         | Res::Def(DefKind::TyAlias, def_id)\n-                        | Res::Def(DefKind::Trait, def_id) if i + 1 == proj_start =>\n+                        | Res::Def(DefKind::Trait, def_id)\n+                            if i + 1 == proj_start =>\n                         {\n                             Some(def_id)\n                         }\n@@ -1789,9 +1684,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             ParenthesizedGenericArgs::Ok\n                         }\n                         // `a::b::Trait(Args)::TraitItem`\n-                        Res::Def(DefKind::Method, _) |\n-                        Res::Def(DefKind::AssocConst, _) |\n-                        Res::Def(DefKind::AssocTy, _) if i + 2 == proj_start => {\n+                        Res::Def(DefKind::Method, _)\n+                        | Res::Def(DefKind::AssocConst, _)\n+                        | Res::Def(DefKind::AssocTy, _)\n+                            if i + 2 == proj_start =>\n+                        {\n                             ParenthesizedGenericArgs::Ok\n                         }\n                         // Avoid duplicated errors.\n@@ -1805,7 +1702,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             return n;\n                         }\n                         assert!(!def_id.is_local());\n-                        let item_generics = self.resolver.cstore()\n+                        let item_generics = self\n+                            .resolver\n+                            .cstore()\n                             .item_generics_cloned_untracked(def_id, self.sess);\n                         let n = item_generics.own_counts().lifetimes;\n                         self.type_def_lifetime_params.insert(def_id, n);\n@@ -1894,7 +1793,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     ) -> hir::Path {\n         hir::Path {\n             res,\n-            segments: p.segments\n+            segments: p\n+                .segments\n                 .iter()\n                 .map(|segment| {\n                     self.lower_path_segment(\n@@ -1944,7 +1844,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             if data.inputs.len() > 0 {\n                                 if let Some(split) = snippet.find('(') {\n                                     let trait_name = &snippet[0..split];\n-                                    let args = &snippet[split + 1 .. snippet.len() - 1];\n+                                    let args = &snippet[split + 1..snippet.len() - 1];\n                                     err.span_suggestion(\n                                         data.span,\n                                         \"use angle brackets instead\",\n@@ -1959,8 +1859,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             self.lower_angle_bracketed_parameter_data(\n                                 &data.as_angle_bracketed_args(),\n                                 param_mode,\n-                                itctx\n-                            ).0,\n+                                itctx,\n+                            )\n+                            .0,\n                             false,\n                         )\n                     }\n@@ -1974,14 +1875,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             GenericArg::Lifetime(_) => true,\n             _ => false,\n         });\n-        let first_generic_span = generic_args.args.iter().map(|a| a.span())\n-            .chain(generic_args.bindings.iter().map(|b| b.span)).next();\n+        let first_generic_span = generic_args\n+            .args\n+            .iter()\n+            .map(|a| a.span())\n+            .chain(generic_args.bindings.iter().map(|b| b.span))\n+            .next();\n         if !generic_args.parenthesized && !has_lifetimes {\n-            generic_args.args =\n-                self.elided_path_lifetimes(path_span, expected_lifetimes)\n-                    .into_iter()\n-                    .map(|lt| GenericArg::Lifetime(lt))\n-                    .chain(generic_args.args.into_iter())\n+            generic_args.args = self\n+                .elided_path_lifetimes(path_span, expected_lifetimes)\n+                .into_iter()\n+                .map(|lt| GenericArg::Lifetime(lt))\n+                .chain(generic_args.args.into_iter())\n                 .collect();\n             if expected_lifetimes > 0 && param_mode == ParamMode::Explicit {\n                 let anon_lt_suggestion = vec![\"'_\"; expected_lifetimes].join(\", \");\n@@ -2023,8 +1928,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         );\n                         err.emit();\n                     }\n-                    AnonymousLifetimeMode::PassThrough |\n-                    AnonymousLifetimeMode::ReportError => {\n+                    AnonymousLifetimeMode::PassThrough | AnonymousLifetimeMode::ReportError => {\n                         self.resolver.lint_buffer().buffer_lint_with_diagnostic(\n                             ELIDED_LIFETIMES_IN_PATHS,\n                             CRATE_NODE_ID,\n@@ -2036,7 +1940,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                 incl_angl_brckt,\n                                 insertion_sp,\n                                 suggestion,\n-                            )\n+                            ),\n                         );\n                     }\n                 }\n@@ -2078,12 +1982,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         (\n             hir::GenericArgs {\n                 args: args.iter().map(|a| self.lower_generic_arg(a, itctx.reborrow())).collect(),\n-                bindings: constraints.iter()\n+                bindings: constraints\n+                    .iter()\n                     .map(|b| self.lower_assoc_ty_constraint(b, itctx.reborrow()))\n                     .collect(),\n                 parenthesized: false,\n             },\n-            !has_non_lt_args && param_mode == ParamMode::Optional\n+            !has_non_lt_args && param_mode == ParamMode::Optional,\n         )\n     }\n \n@@ -2096,31 +2001,25 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // a hidden lifetime parameter. This is needed for backwards\n         // compatibility, even in contexts like an impl header where\n         // we generally don't permit such things (see #51008).\n-        self.with_anonymous_lifetime_mode(\n-            AnonymousLifetimeMode::PassThrough,\n-            |this| {\n-                let &ParenthesizedArgs { ref inputs, ref output, span } = data;\n-                let inputs = inputs\n-                    .iter()\n-                    .map(|ty| this.lower_ty_direct(ty, ImplTraitContext::disallowed()))\n-                    .collect();\n-                let output_ty = match output {\n-                    FunctionRetTy::Ty(ty) => this.lower_ty(&ty, ImplTraitContext::disallowed()),\n-                    FunctionRetTy::Default(_) => P(this.ty_tup(span, hir::HirVec::new())),\n-                };\n-                let args = hir_vec![GenericArg::Type(this.ty_tup(span, inputs))];\n-                let binding = hir::TypeBinding {\n-                    hir_id: this.next_id(),\n-                    ident: Ident::with_dummy_span(FN_OUTPUT_NAME),\n-                    span: output_ty.span,\n-                    kind: hir::TypeBindingKind::Equality { ty: output_ty },\n-                };\n-                (\n-                    hir::GenericArgs { args, bindings: hir_vec![binding], parenthesized: true },\n-                    false,\n-                )\n-            }\n-        )\n+        self.with_anonymous_lifetime_mode(AnonymousLifetimeMode::PassThrough, |this| {\n+            let &ParenthesizedArgs { ref inputs, ref output, span } = data;\n+            let inputs = inputs\n+                .iter()\n+                .map(|ty| this.lower_ty_direct(ty, ImplTraitContext::disallowed()))\n+                .collect();\n+            let output_ty = match output {\n+                FunctionRetTy::Ty(ty) => this.lower_ty(&ty, ImplTraitContext::disallowed()),\n+                FunctionRetTy::Default(_) => P(this.ty_tup(span, hir::HirVec::new())),\n+            };\n+            let args = hir_vec![GenericArg::Type(this.ty_tup(span, inputs))];\n+            let binding = hir::TypeBinding {\n+                hir_id: this.next_id(),\n+                ident: Ident::with_dummy_span(FN_OUTPUT_NAME),\n+                span: output_ty.span,\n+                kind: hir::TypeBindingKind::Equality { ty: output_ty },\n+            };\n+            (hir::GenericArgs { args, bindings: hir_vec![binding], parenthesized: true }, false)\n+        })\n     }\n \n     fn lower_local(&mut self, l: &Local) -> (hir::Local, SmallVec<[NodeId; 1]>) {\n@@ -2132,23 +2031,27 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n         }\n         let parent_def_id = DefId::local(self.current_hir_id_owner.last().unwrap().0);\n-        (hir::Local {\n-            hir_id: self.lower_node_id(l.id),\n-            ty: l.ty\n-                .as_ref()\n-                .map(|t| self.lower_ty(t,\n-                    if self.sess.features_untracked().impl_trait_in_bindings {\n-                        ImplTraitContext::OpaqueTy(Some(parent_def_id))\n-                    } else {\n-                        ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n-                    }\n-                )),\n-            pat: self.lower_pat(&l.pat),\n-            init: l.init.as_ref().map(|e| P(self.lower_expr(e))),\n-            span: l.span,\n-            attrs: l.attrs.clone(),\n-            source: hir::LocalSource::Normal,\n-        }, ids)\n+        (\n+            hir::Local {\n+                hir_id: self.lower_node_id(l.id),\n+                ty: l.ty.as_ref().map(|t| {\n+                    self.lower_ty(\n+                        t,\n+                        if self.sess.features_untracked().impl_trait_in_bindings {\n+                            ImplTraitContext::OpaqueTy(Some(parent_def_id))\n+                        } else {\n+                            ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n+                        },\n+                    )\n+                }),\n+                pat: self.lower_pat(&l.pat),\n+                init: l.init.as_ref().map(|e| P(self.lower_expr(e))),\n+                span: l.span,\n+                attrs: l.attrs.clone(),\n+                source: hir::LocalSource::Normal,\n+            },\n+            ids,\n+        )\n     }\n \n     fn lower_fn_params_to_names(&mut self, decl: &FnDecl) -> hir::HirVec<Ident> {\n@@ -2187,15 +2090,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         impl_trait_return_allow: bool,\n         make_ret_async: Option<NodeId>,\n     ) -> P<hir::FnDecl> {\n-        debug!(\"lower_fn_decl(\\\n+        debug!(\n+            \"lower_fn_decl(\\\n             fn_decl: {:?}, \\\n             in_band_ty_params: {:?}, \\\n             impl_trait_return_allow: {}, \\\n             make_ret_async: {:?})\",\n-            decl,\n-            in_band_ty_params,\n-            impl_trait_return_allow,\n-            make_ret_async,\n+            decl, in_band_ty_params, impl_trait_return_allow, make_ret_async,\n         );\n         let lt_mode = if make_ret_async.is_some() {\n             // In `async fn`, argument-position elided lifetimes\n@@ -2242,9 +2143,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     Some((def_id, _)) if impl_trait_return_allow => {\n                         hir::Return(self.lower_ty(ty, ImplTraitContext::OpaqueTy(Some(def_id))))\n                     }\n-                    _ => {\n-                        hir::Return(self.lower_ty(ty, ImplTraitContext::disallowed()))\n-                    }\n+                    _ => hir::Return(self.lower_ty(ty, ImplTraitContext::disallowed())),\n                 },\n                 FunctionRetTy::Default(span) => hir::DefaultReturn(span),\n             }\n@@ -2254,31 +2153,30 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             inputs,\n             output,\n             c_variadic,\n-            implicit_self: decl.inputs.get(0).map_or(\n-                hir::ImplicitSelfKind::None,\n-                |arg| {\n-                    let is_mutable_pat = match arg.pat.kind {\n-                        PatKind::Ident(BindingMode::ByValue(mt), _, _) |\n-                        PatKind::Ident(BindingMode::ByRef(mt), _, _) =>\n-                            mt == Mutability::Mut,\n-                        _ => false,\n-                    };\n+            implicit_self: decl.inputs.get(0).map_or(hir::ImplicitSelfKind::None, |arg| {\n+                let is_mutable_pat = match arg.pat.kind {\n+                    PatKind::Ident(BindingMode::ByValue(mt), _, _)\n+                    | PatKind::Ident(BindingMode::ByRef(mt), _, _) => mt == Mutability::Mut,\n+                    _ => false,\n+                };\n \n-                    match arg.ty.kind {\n-                        TyKind::ImplicitSelf if is_mutable_pat => hir::ImplicitSelfKind::Mut,\n-                        TyKind::ImplicitSelf => hir::ImplicitSelfKind::Imm,\n-                        // Given we are only considering `ImplicitSelf` types, we needn't consider\n-                        // the case where we have a mutable pattern to a reference as that would\n-                        // no longer be an `ImplicitSelf`.\n-                        TyKind::Rptr(_, ref mt) if mt.ty.kind.is_implicit_self() &&\n-                            mt.mutbl == ast::Mutability::Mut =>\n-                                hir::ImplicitSelfKind::MutRef,\n-                        TyKind::Rptr(_, ref mt) if mt.ty.kind.is_implicit_self() =>\n-                            hir::ImplicitSelfKind::ImmRef,\n-                        _ => hir::ImplicitSelfKind::None,\n+                match arg.ty.kind {\n+                    TyKind::ImplicitSelf if is_mutable_pat => hir::ImplicitSelfKind::Mut,\n+                    TyKind::ImplicitSelf => hir::ImplicitSelfKind::Imm,\n+                    // Given we are only considering `ImplicitSelf` types, we needn't consider\n+                    // the case where we have a mutable pattern to a reference as that would\n+                    // no longer be an `ImplicitSelf`.\n+                    TyKind::Rptr(_, ref mt)\n+                        if mt.ty.kind.is_implicit_self() && mt.mutbl == ast::Mutability::Mut =>\n+                    {\n+                        hir::ImplicitSelfKind::MutRef\n                     }\n-                },\n-            ),\n+                    TyKind::Rptr(_, ref mt) if mt.ty.kind.is_implicit_self() => {\n+                        hir::ImplicitSelfKind::ImmRef\n+                    }\n+                    _ => hir::ImplicitSelfKind::None,\n+                }\n+            }),\n         })\n     }\n \n@@ -2308,17 +2206,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         let span = output.span();\n \n-        let opaque_ty_span = self.mark_span_with_reason(\n-            DesugaringKind::Async,\n-            span,\n-            None,\n-        );\n+        let opaque_ty_span = self.mark_span_with_reason(DesugaringKind::Async, span, None);\n \n-        let opaque_ty_def_index = self\n-            .resolver\n-            .definitions()\n-            .opt_def_index(opaque_ty_node_id)\n-            .unwrap();\n+        let opaque_ty_def_index =\n+            self.resolver.definitions().opt_def_index(opaque_ty_node_id).unwrap();\n \n         self.allocate_hir_id_counter(opaque_ty_node_id);\n \n@@ -2379,14 +2270,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             //\n             // Then, we will create `fn foo(..) -> Foo<'_, '_>`, and\n             // hence the elision takes place at the fn site.\n-            let future_bound = this.with_anonymous_lifetime_mode(\n-                AnonymousLifetimeMode::CreateParameter,\n-                |this| this.lower_async_fn_output_type_to_future_bound(\n-                    output,\n-                    fn_def_id,\n-                    span,\n-                ),\n-            );\n+            let future_bound = this\n+                .with_anonymous_lifetime_mode(AnonymousLifetimeMode::CreateParameter, |this| {\n+                    this.lower_async_fn_output_type_to_future_bound(output, fn_def_id, span)\n+                });\n \n             debug!(\"lower_async_fn_ret_ty: future_bound={:#?}\", future_bound);\n \n@@ -2396,32 +2283,30 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             //\n             // Note: this must be done after lowering the output type,\n             // as the output type may introduce new in-band lifetimes.\n-            let lifetime_params: Vec<(Span, ParamName)> =\n-                this.in_scope_lifetimes\n-                    .iter().cloned()\n-                    .map(|name| (name.ident().span, name))\n-                    .chain(this.lifetimes_to_define.iter().cloned())\n-                    .collect();\n+            let lifetime_params: Vec<(Span, ParamName)> = this\n+                .in_scope_lifetimes\n+                .iter()\n+                .cloned()\n+                .map(|name| (name.ident().span, name))\n+                .chain(this.lifetimes_to_define.iter().cloned())\n+                .collect();\n \n             debug!(\"lower_async_fn_ret_ty: in_scope_lifetimes={:#?}\", this.in_scope_lifetimes);\n             debug!(\"lower_async_fn_ret_ty: lifetimes_to_define={:#?}\", this.lifetimes_to_define);\n             debug!(\"lower_async_fn_ret_ty: lifetime_params={:#?}\", lifetime_params);\n \n-            let generic_params =\n-                lifetime_params\n-                    .iter().cloned()\n-                    .map(|(span, hir_name)| {\n-                        this.lifetime_to_generic_param(span, hir_name, opaque_ty_def_index)\n-                    })\n-                    .collect();\n+            let generic_params = lifetime_params\n+                .iter()\n+                .cloned()\n+                .map(|(span, hir_name)| {\n+                    this.lifetime_to_generic_param(span, hir_name, opaque_ty_def_index)\n+                })\n+                .collect();\n \n             let opaque_ty_item = hir::OpaqueTy {\n                 generics: hir::Generics {\n                     params: generic_params,\n-                    where_clause: hir::WhereClause {\n-                        predicates: hir_vec![],\n-                        span,\n-                    },\n+                    where_clause: hir::WhereClause { predicates: hir_vec![], span },\n                     span,\n                 },\n                 bounds: hir_vec![future_bound],\n@@ -2430,12 +2315,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             };\n \n             trace!(\"exist ty from async fn def index: {:#?}\", opaque_ty_def_index);\n-            let opaque_ty_id = this.generate_opaque_type(\n-                opaque_ty_node_id,\n-                opaque_ty_item,\n-                span,\n-                opaque_ty_span,\n-            );\n+            let opaque_ty_id =\n+                this.generate_opaque_type(opaque_ty_node_id, opaque_ty_item, span, opaque_ty_span);\n \n             (opaque_ty_id, lifetime_params)\n         });\n@@ -2456,8 +2337,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         //\n         // For the \"output\" lifetime parameters, we just want to\n         // generate `'_`.\n-        let mut generic_args: Vec<_> =\n-            lifetime_params[..input_lifetimes_count]\n+        let mut generic_args: Vec<_> = lifetime_params[..input_lifetimes_count]\n             .iter()\n             .map(|&(span, hir_name)| {\n                 // Input lifetime like `'a` or `'1`:\n@@ -2468,18 +2348,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 })\n             })\n             .collect();\n-        generic_args.extend(\n-            lifetime_params[input_lifetimes_count..]\n-            .iter()\n-            .map(|&(span, _)| {\n-                // Output lifetime like `'_`.\n-                GenericArg::Lifetime(hir::Lifetime {\n-                    hir_id: self.next_id(),\n-                    span,\n-                    name: hir::LifetimeName::Implicit,\n-                })\n+        generic_args.extend(lifetime_params[input_lifetimes_count..].iter().map(|&(span, _)| {\n+            // Output lifetime like `'_`.\n+            GenericArg::Lifetime(hir::Lifetime {\n+                hir_id: self.next_id(),\n+                span,\n+                name: hir::LifetimeName::Implicit,\n             })\n-        );\n+        }));\n \n         // Create the `Foo<...>` reference itself. Note that the `type\n         // Foo = impl Trait` is, internally, created as a child of the\n@@ -2508,9 +2384,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             args: hir_vec![],\n             bindings: hir_vec![hir::TypeBinding {\n                 ident: Ident::with_dummy_span(FN_OUTPUT_NAME),\n-                kind: hir::TypeBindingKind::Equality {\n-                    ty: output_ty,\n-                },\n+                kind: hir::TypeBindingKind::Equality { ty: output_ty },\n                 hir_id: self.next_id(),\n                 span,\n             }],\n@@ -2523,10 +2397,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         hir::GenericBound::Trait(\n             hir::PolyTraitRef {\n-                trait_ref: hir::TraitRef {\n-                    path: future_path,\n-                    hir_ref_id: self.next_id(),\n-                },\n+                trait_ref: hir::TraitRef { path: future_path, hir_ref_id: self.next_id() },\n                 bound_generic_params: hir_vec![],\n                 span,\n             },\n@@ -2540,12 +2411,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         itctx: ImplTraitContext<'_>,\n     ) -> hir::GenericBound {\n         match *tpb {\n-            GenericBound::Trait(ref ty, modifier) => {\n-                hir::GenericBound::Trait(\n-                    self.lower_poly_trait_ref(ty, itctx),\n-                    self.lower_trait_bound_modifier(modifier),\n-                )\n-            }\n+            GenericBound::Trait(ref ty, modifier) => hir::GenericBound::Trait(\n+                self.lower_poly_trait_ref(ty, itctx),\n+                self.lower_trait_bound_modifier(modifier),\n+            ),\n             GenericBound::Outlives(ref lifetime) => {\n                 hir::GenericBound::Outlives(self.lower_lifetime(lifetime))\n             }\n@@ -2555,21 +2424,21 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_lifetime(&mut self, l: &Lifetime) -> hir::Lifetime {\n         let span = l.ident.span;\n         match l.ident {\n-            ident if ident.name == kw::StaticLifetime =>\n-                self.new_named_lifetime(l.id, span, hir::LifetimeName::Static),\n-            ident if ident.name == kw::UnderscoreLifetime =>\n-                match self.anonymous_lifetime_mode {\n-                    AnonymousLifetimeMode::CreateParameter => {\n-                        let fresh_name = self.collect_fresh_in_band_lifetime(span);\n-                        self.new_named_lifetime(l.id, span, hir::LifetimeName::Param(fresh_name))\n-                    }\n+            ident if ident.name == kw::StaticLifetime => {\n+                self.new_named_lifetime(l.id, span, hir::LifetimeName::Static)\n+            }\n+            ident if ident.name == kw::UnderscoreLifetime => match self.anonymous_lifetime_mode {\n+                AnonymousLifetimeMode::CreateParameter => {\n+                    let fresh_name = self.collect_fresh_in_band_lifetime(span);\n+                    self.new_named_lifetime(l.id, span, hir::LifetimeName::Param(fresh_name))\n+                }\n \n-                    AnonymousLifetimeMode::PassThrough => {\n-                        self.new_named_lifetime(l.id, span, hir::LifetimeName::Underscore)\n-                    }\n+                AnonymousLifetimeMode::PassThrough => {\n+                    self.new_named_lifetime(l.id, span, hir::LifetimeName::Underscore)\n+                }\n \n-                    AnonymousLifetimeMode::ReportError => self.new_error_lifetime(Some(l.id), span),\n-                },\n+                AnonymousLifetimeMode::ReportError => self.new_error_lifetime(Some(l.id), span),\n+            },\n             ident => {\n                 self.maybe_collect_in_band_lifetime(ident);\n                 let param_name = ParamName::Plain(ident);\n@@ -2584,11 +2453,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         span: Span,\n         name: hir::LifetimeName,\n     ) -> hir::Lifetime {\n-        hir::Lifetime {\n-            hir_id: self.lower_node_id(id),\n-            span,\n-            name,\n-        }\n+        hir::Lifetime { hir_id: self.lower_node_id(id), span, name }\n     }\n \n     fn lower_generic_params(\n@@ -2597,35 +2462,37 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         add_bounds: &NodeMap<Vec<GenericBound>>,\n         mut itctx: ImplTraitContext<'_>,\n     ) -> hir::HirVec<hir::GenericParam> {\n-        params.iter().map(|param| {\n-            self.lower_generic_param(param, add_bounds, itctx.reborrow())\n-        }).collect()\n-    }\n-\n-    fn lower_generic_param(&mut self,\n-                           param: &GenericParam,\n-                           add_bounds: &NodeMap<Vec<GenericBound>>,\n-                           mut itctx: ImplTraitContext<'_>)\n-                           -> hir::GenericParam {\n-        let mut bounds = self.with_anonymous_lifetime_mode(\n-            AnonymousLifetimeMode::ReportError,\n-            |this| this.lower_param_bounds(&param.bounds, itctx.reborrow()),\n-        );\n+        params\n+            .iter()\n+            .map(|param| self.lower_generic_param(param, add_bounds, itctx.reborrow()))\n+            .collect()\n+    }\n+\n+    fn lower_generic_param(\n+        &mut self,\n+        param: &GenericParam,\n+        add_bounds: &NodeMap<Vec<GenericBound>>,\n+        mut itctx: ImplTraitContext<'_>,\n+    ) -> hir::GenericParam {\n+        let mut bounds = self\n+            .with_anonymous_lifetime_mode(AnonymousLifetimeMode::ReportError, |this| {\n+                this.lower_param_bounds(&param.bounds, itctx.reborrow())\n+            });\n \n         let (name, kind) = match param.kind {\n             GenericParamKind::Lifetime => {\n                 let was_collecting_in_band = self.is_collecting_in_band_lifetimes;\n                 self.is_collecting_in_band_lifetimes = false;\n \n-                let lt = self.with_anonymous_lifetime_mode(\n-                    AnonymousLifetimeMode::ReportError,\n-                    |this| this.lower_lifetime(&Lifetime { id: param.id, ident: param.ident }),\n-                );\n+                let lt = self\n+                    .with_anonymous_lifetime_mode(AnonymousLifetimeMode::ReportError, |this| {\n+                        this.lower_lifetime(&Lifetime { id: param.id, ident: param.ident })\n+                    });\n                 let param_name = match lt.name {\n                     hir::LifetimeName::Param(param_name) => param_name,\n                     hir::LifetimeName::Implicit\n-                        | hir::LifetimeName::Underscore\n-                        | hir::LifetimeName::Static => hir::ParamName::Plain(lt.name.ident()),\n+                    | hir::LifetimeName::Underscore\n+                    | hir::LifetimeName::Static => hir::ParamName::Plain(lt.name.ident()),\n                     hir::LifetimeName::ImplicitObjectLifetimeDefault => {\n                         span_bug!(\n                             param.ident.span,\n@@ -2635,9 +2502,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     hir::LifetimeName::Error => ParamName::Error,\n                 };\n \n-                let kind = hir::GenericParamKind::Lifetime {\n-                    kind: hir::LifetimeParamKind::Explicit\n-                };\n+                let kind =\n+                    hir::GenericParamKind::Lifetime { kind: hir::LifetimeParamKind::Explicit };\n \n                 self.is_collecting_in_band_lifetimes = was_collecting_in_band;\n \n@@ -2647,28 +2513,29 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 let add_bounds = add_bounds.get(&param.id).map_or(&[][..], |x| &x);\n                 if !add_bounds.is_empty() {\n                     let params = self.lower_param_bounds(add_bounds, itctx.reborrow()).into_iter();\n-                    bounds = bounds.into_iter()\n-                                   .chain(params)\n-                                   .collect();\n+                    bounds = bounds.into_iter().chain(params).collect();\n                 }\n \n                 let kind = hir::GenericParamKind::Type {\n-                    default: default.as_ref().map(|x| {\n-                        self.lower_ty(x, ImplTraitContext::OpaqueTy(None))\n-                    }),\n-                    synthetic: param.attrs.iter()\n-                                          .filter(|attr| attr.check_name(sym::rustc_synthetic))\n-                                          .map(|_| hir::SyntheticTyParamKind::ImplTrait)\n-                                          .next(),\n+                    default: default\n+                        .as_ref()\n+                        .map(|x| self.lower_ty(x, ImplTraitContext::OpaqueTy(None))),\n+                    synthetic: param\n+                        .attrs\n+                        .iter()\n+                        .filter(|attr| attr.check_name(sym::rustc_synthetic))\n+                        .map(|_| hir::SyntheticTyParamKind::ImplTrait)\n+                        .next(),\n                 };\n \n                 (hir::ParamName::Plain(param.ident), kind)\n             }\n-            GenericParamKind::Const { ref ty } => {\n-                (hir::ParamName::Plain(param.ident), hir::GenericParamKind::Const {\n+            GenericParamKind::Const { ref ty } => (\n+                hir::ParamName::Plain(param.ident),\n+                hir::GenericParamKind::Const {\n                     ty: self.lower_ty(&ty, ImplTraitContext::disallowed()),\n-                })\n-            }\n+                },\n+            ),\n         };\n \n         hir::GenericParam {\n@@ -2687,10 +2554,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             hir::QPath::Resolved(None, path) => path,\n             qpath => bug!(\"lower_trait_ref: unexpected QPath `{:?}`\", qpath),\n         };\n-        hir::TraitRef {\n-            path,\n-            hir_ref_id: self.lower_node_id(p.ref_id),\n-        }\n+        hir::TraitRef { path, hir_ref_id: self.lower_node_id(p.ref_id) }\n     }\n \n     fn lower_poly_trait_ref(\n@@ -2703,27 +2567,22 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             &NodeMap::default(),\n             itctx.reborrow(),\n         );\n-        let trait_ref = self.with_in_scope_lifetime_defs(\n-            &p.bound_generic_params,\n-            |this| this.lower_trait_ref(&p.trait_ref, itctx),\n-        );\n+        let trait_ref = self.with_in_scope_lifetime_defs(&p.bound_generic_params, |this| {\n+            this.lower_trait_ref(&p.trait_ref, itctx)\n+        });\n \n-        hir::PolyTraitRef {\n-            bound_generic_params,\n-            trait_ref,\n-            span: p.span,\n-        }\n+        hir::PolyTraitRef { bound_generic_params, trait_ref, span: p.span }\n     }\n \n     fn lower_mt(&mut self, mt: &MutTy, itctx: ImplTraitContext<'_>) -> hir::MutTy {\n-        hir::MutTy {\n-            ty: self.lower_ty(&mt.ty, itctx),\n-            mutbl: mt.mutbl,\n-        }\n+        hir::MutTy { ty: self.lower_ty(&mt.ty, itctx), mutbl: mt.mutbl }\n     }\n \n-    fn lower_param_bounds(&mut self, bounds: &[GenericBound], mut itctx: ImplTraitContext<'_>)\n-                          -> hir::GenericBounds {\n+    fn lower_param_bounds(\n+        &mut self,\n+        bounds: &[GenericBound],\n+        mut itctx: ImplTraitContext<'_>,\n+    ) -> hir::GenericBounds {\n         bounds.iter().map(|bound| self.lower_param_bound(bound, itctx.reborrow())).collect()\n     }\n \n@@ -2819,9 +2678,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 hir::PatKind::Tuple(pats, ddpos)\n             }\n             PatKind::Box(ref inner) => hir::PatKind::Box(self.lower_pat(inner)),\n-            PatKind::Ref(ref inner, mutbl) => {\n-                hir::PatKind::Ref(self.lower_pat(inner), mutbl)\n-            }\n+            PatKind::Ref(ref inner, mutbl) => hir::PatKind::Ref(self.lower_pat(inner), mutbl),\n             PatKind::Range(ref e1, ref e2, Spanned { node: ref end, .. }) => hir::PatKind::Range(\n                 P(self.lower_expr(e1)),\n                 P(self.lower_expr(e2)),\n@@ -2895,7 +2752,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     prev_rest_span = Some(pat.span);\n                     slice = Some(self.pat_wild_with_node_id_of(pat));\n                     break;\n-                },\n+                }\n                 // Found a sub-slice pattern `$binding_mode $ident @ ..`.\n                 // Record, lower it to `$binding_mode $ident @ _`, and stop here.\n                 PatKind::Ident(ref bm, ident, Some(ref sub)) if sub.is_rest() => {\n@@ -2904,7 +2761,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     let node = self.lower_pat_ident(pat, bm, ident, lower_sub);\n                     slice = Some(self.pat_with_node_id_of(pat, node));\n                     break;\n-                },\n+                }\n                 // It was not a subslice pattern so lower it normally.\n                 _ => before.push(self.lower_pat(pat)),\n             }\n@@ -2919,7 +2776,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // The `HirValidator` is merciless; add a `_` pattern to avoid ICEs.\n                     after.push(self.pat_wild_with_node_id_of(pat));\n                     Some(sub.span)\n-                },\n+                }\n                 _ => None,\n             };\n             if let Some(rest_span) = rest_span {\n@@ -2973,11 +2830,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n     /// Construct a `Pat` with the `HirId` of `p.id` lowered.\n     fn pat_with_node_id_of(&mut self, p: &Pat, kind: hir::PatKind) -> P<hir::Pat> {\n-        P(hir::Pat {\n-            hir_id: self.lower_node_id(p.id),\n-            kind,\n-            span: p.span,\n-        })\n+        P(hir::Pat { hir_id: self.lower_node_id(p.id), kind, span: p.span })\n     }\n \n     /// Emit a friendly error for extra `..` patterns in a tuple/tuple struct/slice pattern.\n@@ -3010,11 +2863,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn lower_anon_const(&mut self, c: &AnonConst) -> hir::AnonConst {\n-        self.with_new_scopes(|this| {\n-            hir::AnonConst {\n-                hir_id: this.lower_node_id(c.id),\n-                body: this.lower_const_body(c.value.span, Some(&c.value)),\n-            }\n+        self.with_new_scopes(|this| hir::AnonConst {\n+            hir_id: this.lower_node_id(c.id),\n+            body: this.lower_const_body(c.value.span, Some(&c.value)),\n         })\n     }\n \n@@ -3037,34 +2888,28 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     }\n                 });\n                 return ids;\n-            },\n+            }\n             StmtKind::Item(ref it) => {\n                 // Can only use the ID once.\n                 let mut id = Some(s.id);\n-                return self.lower_item_id(it)\n+                return self\n+                    .lower_item_id(it)\n                     .into_iter()\n                     .map(|item_id| {\n-                        let hir_id = id.take()\n-                          .map(|id| self.lower_node_id(id))\n-                          .unwrap_or_else(|| self.next_id());\n-\n-                        hir::Stmt {\n-                            hir_id,\n-                            kind: hir::StmtKind::Item(item_id),\n-                            span: s.span,\n-                        }\n+                        let hir_id = id\n+                            .take()\n+                            .map(|id| self.lower_node_id(id))\n+                            .unwrap_or_else(|| self.next_id());\n+\n+                        hir::Stmt { hir_id, kind: hir::StmtKind::Item(item_id), span: s.span }\n                     })\n                     .collect();\n             }\n             StmtKind::Expr(ref e) => hir::StmtKind::Expr(P(self.lower_expr(e))),\n             StmtKind::Semi(ref e) => hir::StmtKind::Semi(P(self.lower_expr(e))),\n             StmtKind::Mac(..) => panic!(\"shouldn't exist here\"),\n         };\n-        smallvec![hir::Stmt {\n-            hir_id: self.lower_node_id(s.id),\n-            kind,\n-            span: s.span,\n-        }]\n+        smallvec![hir::Stmt { hir_id: self.lower_node_id(s.id), kind, span: s.span }]\n     }\n \n     fn lower_block_check_mode(&mut self, b: &BlockCheckMode) -> hir::BlockCheckMode {\n@@ -3115,15 +2960,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         pat: P<hir::Pat>,\n         source: hir::LocalSource,\n     ) -> hir::Stmt {\n-        let local = hir::Local {\n-            attrs,\n-            hir_id: self.next_id(),\n-            init,\n-            pat,\n-            source,\n-            span,\n-            ty: None,\n-        };\n+        let local = hir::Local { attrs, hir_id: self.next_id(), init, pat, source, span, ty: None };\n         self.stmt(span, hir::StmtKind::Local(P(local)))\n     }\n \n@@ -3203,7 +3040,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 kind: hir::PatKind::Binding(bm, hir_id, ident.with_span_pos(span), None),\n                 span,\n             }),\n-            hir_id\n+            hir_id,\n         )\n     }\n \n@@ -3212,11 +3049,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn pat(&mut self, span: Span, kind: hir::PatKind) -> P<hir::Pat> {\n-        P(hir::Pat {\n-            hir_id: self.next_id(),\n-            kind,\n-            span,\n-        })\n+        P(hir::Pat { hir_id: self.next_id(), kind, span })\n     }\n \n     /// Given a suffix `[\"b\", \"c\", \"d\"]`, returns path `::std::b::c::d` when\n@@ -3232,16 +3065,20 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let ns = if is_value { Namespace::ValueNS } else { Namespace::TypeNS };\n         let (path, res) = self.resolver.resolve_str_path(span, self.crate_root, components, ns);\n \n-        let mut segments: Vec<_> = path.segments.iter().map(|segment| {\n-            let res = self.expect_full_res(segment.id);\n-            hir::PathSegment {\n-                ident: segment.ident,\n-                hir_id: Some(self.lower_node_id(segment.id)),\n-                res: Some(self.lower_res(res)),\n-                infer_args: true,\n-                args: None,\n-            }\n-        }).collect();\n+        let mut segments: Vec<_> = path\n+            .segments\n+            .iter()\n+            .map(|segment| {\n+                let res = self.expect_full_res(segment.id);\n+                hir::PathSegment {\n+                    ident: segment.ident,\n+                    hir_id: Some(self.lower_node_id(segment.id)),\n+                    res: Some(self.lower_res(res)),\n+                    infer_args: true,\n+                    args: None,\n+                }\n+            })\n+            .collect();\n         segments.last_mut().unwrap().args = params;\n \n         hir::Path {\n@@ -3259,10 +3096,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     Res::Def(DefKind::Trait, _) | Res::Def(DefKind::TraitAlias, _) => {\n                         let principal = hir::PolyTraitRef {\n                             bound_generic_params: hir::HirVec::new(),\n-                            trait_ref: hir::TraitRef {\n-                                path,\n-                                hir_ref_id: hir_id,\n-                            },\n+                            trait_ref: hir::TraitRef { path, hir_ref_id: hir_id },\n                             span,\n                         };\n \n@@ -3277,11 +3111,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             _ => hir::TyKind::Path(qpath),\n         };\n \n-        hir::Ty {\n-            hir_id,\n-            kind,\n-            span,\n-        }\n+        hir::Ty { hir_id, kind, span }\n     }\n \n     /// Invoked to create the lifetime argument for a type `&T`\n@@ -3320,13 +3150,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             ),\n         };\n \n-        let mut err = struct_span_err!(\n-            self.sess,\n-            span,\n-            E0637,\n-            \"{}\",\n-            msg,\n-        );\n+        let mut err = struct_span_err!(self.sess, span, E0637, \"{}\", msg,);\n         err.span_label(span, label);\n         err.emit();\n \n@@ -3338,19 +3162,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// sorts of cases are deprecated. This may therefore report a warning or an\n     /// error, depending on the mode.\n     fn elided_path_lifetimes(&mut self, span: Span, count: usize) -> P<[hir::Lifetime]> {\n-        (0..count)\n-            .map(|_| self.elided_path_lifetime(span))\n-            .collect()\n+        (0..count).map(|_| self.elided_path_lifetime(span)).collect()\n     }\n \n     fn elided_path_lifetime(&mut self, span: Span) -> hir::Lifetime {\n         match self.anonymous_lifetime_mode {\n             AnonymousLifetimeMode::CreateParameter => {\n                 // We should have emitted E0726 when processing this path above\n-                self.sess.delay_span_bug(\n-                    span,\n-                    \"expected 'implicit elided lifetime not allowed' error\",\n-                );\n+                self.sess\n+                    .delay_span_bug(span, \"expected 'implicit elided lifetime not allowed' error\");\n                 let id = self.resolver.next_node_id();\n                 self.new_named_lifetime(id, span, hir::LifetimeName::Error)\n             }\n@@ -3360,8 +3180,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             // `PathSegment`, for which there is no associated `'_` or `&T` with no explicit\n             // lifetime. Instead, we simply create an implicit lifetime, which will be checked\n             // later, at which point a suitable error will be emitted.\n-          | AnonymousLifetimeMode::PassThrough\n-          | AnonymousLifetimeMode::ReportError => self.new_implicit_lifetime(span),\n+            AnonymousLifetimeMode::PassThrough | AnonymousLifetimeMode::ReportError => {\n+                self.new_implicit_lifetime(span)\n+            }\n         }\n     }\n \n@@ -3404,17 +3225,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn new_implicit_lifetime(&mut self, span: Span) -> hir::Lifetime {\n-        hir::Lifetime {\n-            hir_id: self.next_id(),\n-            span,\n-            name: hir::LifetimeName::Implicit,\n-        }\n+        hir::Lifetime { hir_id: self.next_id(), span, name: hir::LifetimeName::Implicit }\n     }\n \n     fn maybe_lint_bare_trait(&mut self, span: Span, id: NodeId, is_global: bool) {\n         // FIXME(davidtwco): This is a hack to detect macros which produce spans of the\n         // call site which do not have a macro backtrace. See #61963.\n-        let is_macro_callsite = self.sess.source_map()\n+        let is_macro_callsite = self\n+            .sess\n+            .source_map()\n             .span_to_snippet(span)\n             .map(|snippet| snippet.starts_with(\"#[\"))\n             .unwrap_or(true);"}, {"sha": "8914ff8add8d70870e020642ce051c808bba0601", "filename": "src/librustc/infer/error_reporting/nice_region_error/outlives_closure.rs", "status": "modified", "additions": 61, "deletions": 55, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d", "patch": "@@ -1,13 +1,13 @@\n //! Error Reporting for Anonymous Region Lifetime Errors\n //! where both the regions are anonymous.\n \n+use crate::hir::Node;\n+use crate::hir::{Expr, ExprKind::Closure};\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n+use crate::infer::lexical_region_resolve::RegionResolutionError::SubSupConflict;\n use crate::infer::SubregionOrigin;\n use crate::ty::RegionKind;\n-use crate::hir::{Expr, ExprKind::Closure};\n-use crate::hir::Node;\n use crate::util::common::ErrorReported;\n-use crate::infer::lexical_region_resolve::RegionResolutionError::SubSupConflict;\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// Print the error message for lifetime errors when binding escapes a closure.\n@@ -36,69 +36,75 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     ///              ...because it cannot outlive this closure\n     /// ```\n     pub(super) fn try_report_outlives_closure(&self) -> Option<ErrorReported> {\n-        if let Some(SubSupConflict(_,\n-                                   origin,\n-                                   ref sub_origin,\n-                                   _,\n-                                   ref sup_origin,\n-                                   sup_region)) = self.error {\n-\n+        if let Some(SubSupConflict(_, origin, ref sub_origin, _, ref sup_origin, sup_region)) =\n+            self.error\n+        {\n             // #45983: when trying to assign the contents of an argument to a binding outside of a\n             // closure, provide a specific message pointing this out.\n-            if let (&SubregionOrigin::BindingTypeIsNotValidAtDecl(ref external_span),\n-                    &RegionKind::ReFree(ref free_region)) = (&sub_origin, sup_region) {\n+            if let (\n+                &SubregionOrigin::BindingTypeIsNotValidAtDecl(ref external_span),\n+                &RegionKind::ReFree(ref free_region),\n+            ) = (&sub_origin, sup_region)\n+            {\n                 let hir = &self.tcx().hir();\n                 if let Some(hir_id) = hir.as_local_hir_id(free_region.scope) {\n-                    if let Node::Expr(Expr {\n-                        kind: Closure(_, _, _, closure_span, None),\n-                        ..\n-                    }) = hir.get(hir_id) {\n+                    if let Node::Expr(Expr { kind: Closure(_, _, _, closure_span, None), .. }) =\n+                        hir.get(hir_id)\n+                    {\n                         let sup_sp = sup_origin.span();\n                         let origin_sp = origin.span();\n                         let mut err = self.tcx().sess.struct_span_err(\n                             sup_sp,\n-                            \"borrowed data cannot be stored outside of its closure\");\n+                            \"borrowed data cannot be stored outside of its closure\",\n+                        );\n                         err.span_label(sup_sp, \"cannot be stored outside of its closure\");\n                         if origin_sp == sup_sp || origin_sp.contains(sup_sp) {\n-// // sup_sp == origin.span():\n-//\n-// let mut x = None;\n-//     ----- borrowed data cannot be stored into here...\n-// with_int(|y| x = Some(y));\n-//          ---          ^ cannot be stored outside of its closure\n-//          |\n-//          ...because it cannot outlive this closure\n-//\n-// // origin.contains(&sup_sp):\n-//\n-// let mut f: Option<&u32> = None;\n-//     ----- borrowed data cannot be stored into here...\n-// closure_expecting_bound(|x: &'x u32| {\n-//                         ------------ ... because it cannot outlive this closure\n-//     f = Some(x);\n-//              ^ cannot be stored outside of its closure\n-                            err.span_label(*external_span,\n-                                           \"borrowed data cannot be stored into here...\");\n-                            err.span_label(*closure_span,\n-                                           \"...because it cannot outlive this closure\");\n+                            // // sup_sp == origin.span():\n+                            //\n+                            // let mut x = None;\n+                            //     ----- borrowed data cannot be stored into here...\n+                            // with_int(|y| x = Some(y));\n+                            //          ---          ^ cannot be stored outside of its closure\n+                            //          |\n+                            //          ...because it cannot outlive this closure\n+                            //\n+                            // // origin.contains(&sup_sp):\n+                            //\n+                            // let mut f: Option<&u32> = None;\n+                            //     ----- borrowed data cannot be stored into here...\n+                            // closure_expecting_bound(|x: &'x u32| {\n+                            //                         ------------ ... because it cannot outlive this closure\n+                            //     f = Some(x);\n+                            //              ^ cannot be stored outside of its closure\n+                            err.span_label(\n+                                *external_span,\n+                                \"borrowed data cannot be stored into here...\",\n+                            );\n+                            err.span_label(\n+                                *closure_span,\n+                                \"...because it cannot outlive this closure\",\n+                            );\n                         } else {\n-// FIXME: the wording for this case could be much improved\n-//\n-// let mut lines_to_use: Vec<&CrateId> = Vec::new();\n-//                           - cannot infer an appropriate lifetime...\n-// let push_id = |installed_id: &CrateId| {\n-//     -------   ------------------------ borrowed data cannot outlive this closure\n-//     |\n-//     ...so that variable is valid at time of its declaration\n-//     lines_to_use.push(installed_id);\n-//                       ^^^^^^^^^^^^ cannot be stored outside of its closure\n-                            err.span_label(origin_sp,\n-                                           \"cannot infer an appropriate lifetime...\");\n-                            err.span_label(*external_span,\n-                                           \"...so that variable is valid at time of its \\\n-                                            declaration\");\n-                            err.span_label(*closure_span,\n-                                           \"borrowed data cannot outlive this closure\");\n+                            // FIXME: the wording for this case could be much improved\n+                            //\n+                            // let mut lines_to_use: Vec<&CrateId> = Vec::new();\n+                            //                           - cannot infer an appropriate lifetime...\n+                            // let push_id = |installed_id: &CrateId| {\n+                            //     -------   ------------------------ borrowed data cannot outlive this closure\n+                            //     |\n+                            //     ...so that variable is valid at time of its declaration\n+                            //     lines_to_use.push(installed_id);\n+                            //                       ^^^^^^^^^^^^ cannot be stored outside of its closure\n+                            err.span_label(origin_sp, \"cannot infer an appropriate lifetime...\");\n+                            err.span_label(\n+                                *external_span,\n+                                \"...so that variable is valid at time of its \\\n+                                            declaration\",\n+                            );\n+                            err.span_label(\n+                                *closure_span,\n+                                \"borrowed data cannot outlive this closure\",\n+                            );\n                         }\n                         err.emit();\n                         return Some(ErrorReported);"}, {"sha": "6900ed4f47565f6b5edc2a22a605a7fb4bca9f56", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 71, "deletions": 57, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d", "patch": "@@ -23,26 +23,27 @@ pub use self::LintSource::*;\n \n use rustc_data_structures::sync;\n \n+use crate::hir;\n use crate::hir::def_id::{CrateNum, LOCAL_CRATE};\n use crate::hir::intravisit;\n-use crate::hir;\n use crate::lint::builtin::BuiltinLintDiagnostics;\n-use crate::session::{Session, DiagnosticMessageId};\n-use crate::ty::TyCtxt;\n+use crate::session::{DiagnosticMessageId, Session};\n use crate::ty::query::Providers;\n+use crate::ty::TyCtxt;\n use crate::util::nodemap::NodeMap;\n use errors::{DiagnosticBuilder, DiagnosticId};\n use syntax::ast;\n-use syntax::source_map::{MultiSpan, ExpnKind, DesugaringKind};\n+use syntax::source_map::{DesugaringKind, ExpnKind, MultiSpan};\n use syntax::symbol::Symbol;\n use syntax_pos::hygiene::MacroKind;\n use syntax_pos::Span;\n \n-pub use crate::lint::context::{LateContext, EarlyContext, LintContext, LintStore,\n-                        check_crate, check_ast_crate, late_lint_mod, CheckLintNameResult,\n-                        BufferedEarlyLint,};\n+pub use crate::lint::context::{\n+    check_ast_crate, check_crate, late_lint_mod, BufferedEarlyLint, CheckLintNameResult,\n+    EarlyContext, LateContext, LintContext, LintStore,\n+};\n \n-pub use rustc_session::lint::{Lint, LintId, Level, FutureIncompatibleInfo};\n+pub use rustc_session::lint::{FutureIncompatibleInfo, Level, Lint, LintId};\n \n /// Declares a static `LintArray` and return it as an expression.\n #[macro_export]\n@@ -351,8 +352,8 @@ macro_rules! declare_combined_early_lint_pass {\n \n /// A lint pass boxed up as a trait object.\n pub type EarlyLintPassObject = Box<dyn EarlyLintPass + sync::Send + sync::Sync + 'static>;\n-pub type LateLintPassObject = Box<dyn for<'a, 'tcx> LateLintPass<'a, 'tcx> + sync::Send\n-                                                                           + sync::Sync + 'static>;\n+pub type LateLintPassObject =\n+    Box<dyn for<'a, 'tcx> LateLintPass<'a, 'tcx> + sync::Send + sync::Sync + 'static>;\n \n /// How a lint level was set.\n #[derive(Clone, Copy, PartialEq, Eq, HashStable)]\n@@ -371,30 +372,32 @@ pub enum LintSource {\n pub type LevelSource = (Level, LintSource);\n \n pub mod builtin;\n-pub mod internal;\n mod context;\n+pub mod internal;\n mod levels;\n \n-pub use self::levels::{LintLevelSets, LintLevelMap};\n+pub use self::levels::{LintLevelMap, LintLevelSets};\n \n #[derive(Default)]\n pub struct LintBuffer {\n     map: NodeMap<Vec<BufferedEarlyLint>>,\n }\n \n impl LintBuffer {\n-    pub fn add_lint(&mut self,\n-                    lint: &'static Lint,\n-                    id: ast::NodeId,\n-                    sp: MultiSpan,\n-                    msg: &str,\n-                    diagnostic: BuiltinLintDiagnostics) {\n+    pub fn add_lint(\n+        &mut self,\n+        lint: &'static Lint,\n+        id: ast::NodeId,\n+        sp: MultiSpan,\n+        msg: &str,\n+        diagnostic: BuiltinLintDiagnostics,\n+    ) {\n         let early_lint = BufferedEarlyLint {\n             lint_id: LintId::of(lint),\n             ast_id: id,\n             span: sp,\n             msg: msg.to_string(),\n-            diagnostic\n+            diagnostic,\n         };\n         let arr = self.map.entry(id).or_default();\n         if !arr.contains(&early_lint) {\n@@ -428,22 +431,20 @@ impl LintBuffer {\n     }\n }\n \n-pub fn struct_lint_level<'a>(sess: &'a Session,\n-                             lint: &'static Lint,\n-                             level: Level,\n-                             src: LintSource,\n-                             span: Option<MultiSpan>,\n-                             msg: &str)\n-    -> DiagnosticBuilder<'a>\n-{\n+pub fn struct_lint_level<'a>(\n+    sess: &'a Session,\n+    lint: &'static Lint,\n+    level: Level,\n+    src: LintSource,\n+    span: Option<MultiSpan>,\n+    msg: &str,\n+) -> DiagnosticBuilder<'a> {\n     let mut err = match (level, span) {\n         (Level::Allow, _) => return sess.diagnostic().struct_dummy(),\n         (Level::Warn, Some(span)) => sess.struct_span_warn(span, msg),\n         (Level::Warn, None) => sess.struct_warn(msg),\n-        (Level::Deny, Some(span)) |\n-        (Level::Forbid, Some(span)) => sess.struct_span_err(span, msg),\n-        (Level::Deny, None) |\n-        (Level::Forbid, None) => sess.struct_err(msg),\n+        (Level::Deny, Some(span)) | (Level::Forbid, Some(span)) => sess.struct_span_err(span, msg),\n+        (Level::Deny, None) | (Level::Forbid, None) => sess.struct_err(msg),\n     };\n \n     // Check for future incompatibility lints and issue a stronger warning.\n@@ -475,7 +476,8 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n             sess.diag_note_once(\n                 &mut err,\n                 DiagnosticMessageId::from(lint),\n-                &format!(\"`#[{}({})]` on by default\", level.as_str(), name));\n+                &format!(\"`#[{}({})]` on by default\", level.as_str(), name),\n+            );\n         }\n         LintSource::CommandLine(lint_flag_val) => {\n             let flag = match level {\n@@ -489,38 +491,51 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n                 sess.diag_note_once(\n                     &mut err,\n                     DiagnosticMessageId::from(lint),\n-                    &format!(\"requested on the command line with `{} {}`\",\n-                             flag, hyphen_case_lint_name));\n+                    &format!(\n+                        \"requested on the command line with `{} {}`\",\n+                        flag, hyphen_case_lint_name\n+                    ),\n+                );\n             } else {\n                 let hyphen_case_flag_val = lint_flag_val.as_str().replace(\"_\", \"-\");\n                 sess.diag_note_once(\n                     &mut err,\n                     DiagnosticMessageId::from(lint),\n-                    &format!(\"`{} {}` implied by `{} {}`\",\n-                             flag, hyphen_case_lint_name, flag,\n-                             hyphen_case_flag_val));\n+                    &format!(\n+                        \"`{} {}` implied by `{} {}`\",\n+                        flag, hyphen_case_lint_name, flag, hyphen_case_flag_val\n+                    ),\n+                );\n             }\n         }\n         LintSource::Node(lint_attr_name, src, reason) => {\n             if let Some(rationale) = reason {\n                 err.note(&rationale.as_str());\n             }\n-            sess.diag_span_note_once(&mut err, DiagnosticMessageId::from(lint),\n-                                     src, \"lint level defined here\");\n+            sess.diag_span_note_once(\n+                &mut err,\n+                DiagnosticMessageId::from(lint),\n+                src,\n+                \"lint level defined here\",\n+            );\n             if lint_attr_name.as_str() != name {\n                 let level_str = level.as_str();\n-                sess.diag_note_once(&mut err, DiagnosticMessageId::from(lint),\n-                                    &format!(\"`#[{}({})]` implied by `#[{}({})]`\",\n-                                             level_str, name, level_str, lint_attr_name));\n+                sess.diag_note_once(\n+                    &mut err,\n+                    DiagnosticMessageId::from(lint),\n+                    &format!(\n+                        \"`#[{}({})]` implied by `#[{}({})]`\",\n+                        level_str, name, level_str, lint_attr_name\n+                    ),\n+                );\n             }\n         }\n     }\n \n     err.code(DiagnosticId::Lint(name));\n \n     if let Some(future_incompatible) = future_incompatible {\n-        const STANDARD_MESSAGE: &str =\n-            \"this was previously accepted by the compiler but is being phased out; \\\n+        const STANDARD_MESSAGE: &str = \"this was previously accepted by the compiler but is being phased out; \\\n              it will become a hard error\";\n \n         let explanation = if lint_id == LintId::of(builtin::UNSTABLE_NAME_COLLISIONS) {\n@@ -536,13 +551,12 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n         } else {\n             format!(\"{} in a future release!\", STANDARD_MESSAGE)\n         };\n-        let citation = format!(\"for more information, see {}\",\n-                               future_incompatible.reference);\n+        let citation = format!(\"for more information, see {}\", future_incompatible.reference);\n         err.warn(&explanation);\n         err.note(&citation);\n     }\n \n-    return err\n+    return err;\n }\n \n pub fn maybe_lint_level_root(tcx: TyCtxt<'_>, id: hir::HirId) -> bool {\n@@ -563,7 +577,7 @@ fn lint_levels(tcx: TyCtxt<'_>, cnum: CrateNum) -> &LintLevelMap {\n     let push = builder.levels.push(&krate.attrs, &store);\n     builder.levels.register_id(hir::CRATE_HIR_ID);\n     for macro_def in krate.exported_macros {\n-       builder.levels.register_id(macro_def.hir_id);\n+        builder.levels.register_id(macro_def.hir_id);\n     }\n     intravisit::walk_crate(&mut builder, krate);\n     builder.levels.pop(push);\n@@ -578,11 +592,9 @@ struct LintLevelMapBuilder<'a, 'tcx> {\n }\n \n impl LintLevelMapBuilder<'_, '_> {\n-    fn with_lint_attrs<F>(&mut self,\n-                          id: hir::HirId,\n-                          attrs: &[ast::Attribute],\n-                          f: F)\n-        where F: FnOnce(&mut Self)\n+    fn with_lint_attrs<F>(&mut self, id: hir::HirId, attrs: &[ast::Attribute], f: F)\n+    where\n+        F: FnOnce(&mut Self),\n     {\n         let push = self.levels.push(attrs, self.store);\n         if push.changed {\n@@ -628,10 +640,12 @@ impl intravisit::Visitor<'tcx> for LintLevelMapBuilder<'_, 'tcx> {\n         })\n     }\n \n-    fn visit_variant(&mut self,\n-                     v: &'tcx hir::Variant<'tcx>,\n-                     g: &'tcx hir::Generics,\n-                     item_id: hir::HirId) {\n+    fn visit_variant(\n+        &mut self,\n+        v: &'tcx hir::Variant<'tcx>,\n+        g: &'tcx hir::Generics,\n+        item_id: hir::HirId,\n+    ) {\n         self.with_lint_attrs(v.id, &v.attrs, |builder| {\n             intravisit::walk_variant(builder, v, g, item_id);\n         })"}, {"sha": "67630a75768d0ff13a5ccb8d69fd8f5a169c6a1a", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 233, "deletions": 384, "changes": 617, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d", "patch": "@@ -5,9 +5,7 @@\n //! used between functions, and they operate in a purely top-down\n //! way. Therefore, we break lifetime name resolution into a separate pass.\n \n-// ignore-tidy-filelength\n-\n-use crate::hir::def::{Res, DefKind};\n+use crate::hir::def::{DefKind, Res};\n use crate::hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use crate::hir::map::Map;\n use crate::hir::ptr::P;\n@@ -17,7 +15,7 @@ use crate::ty::{self, DefIdTree, GenericParamDefKind, TyCtxt};\n use crate::rustc::lint;\n use crate::session::Session;\n use crate::util::nodemap::{DefIdMap, FxHashMap, FxHashSet, HirIdMap, HirIdSet};\n-use errors::{Applicability, DiagnosticBuilder, pluralize};\n+use errors::{pluralize, Applicability, DiagnosticBuilder};\n use rustc_macros::HashStable;\n use std::borrow::Cow;\n use std::cell::Cell;\n@@ -69,16 +67,8 @@ pub enum LifetimeUseSet<'tcx> {\n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum Region {\n     Static,\n-    EarlyBound(\n-        /* index */ u32,\n-        /* lifetime decl */ DefId,\n-        LifetimeDefOrigin,\n-    ),\n-    LateBound(\n-        ty::DebruijnIndex,\n-        /* lifetime decl */ DefId,\n-        LifetimeDefOrigin,\n-    ),\n+    EarlyBound(/* index */ u32, /* lifetime decl */ DefId, LifetimeDefOrigin),\n+    LateBound(ty::DebruijnIndex, /* lifetime decl */ DefId, LifetimeDefOrigin),\n     LateBoundAnon(ty::DebruijnIndex, /* anon index */ u32),\n     Free(DefId, /* lifetime decl */ DefId),\n }\n@@ -101,10 +91,7 @@ impl Region {\n             \"Region::late: param={:?} depth={:?} def_id={:?} origin={:?}\",\n             param, depth, def_id, origin,\n         );\n-        (\n-            param.name.modern(),\n-            Region::LateBound(depth, def_id, origin),\n-        )\n+        (param.name.modern(), Region::LateBound(depth, def_id, origin))\n     }\n \n     fn late_anon(index: &Cell<u32>) -> Region {\n@@ -153,9 +140,7 @@ impl Region {\n         L: Iterator<Item = &'a hir::Lifetime>,\n     {\n         if let Region::EarlyBound(index, _, _) = self {\n-            params\n-                .nth(index as usize)\n-                .and_then(|lifetime| map.defs.get(&lifetime.hir_id).cloned())\n+            params.nth(index as usize).and_then(|lifetime| map.defs.get(&lifetime.hir_id).cloned())\n         } else {\n             Some(self)\n         }\n@@ -344,16 +329,12 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n \n         is_late_bound_map: |tcx, id| {\n             let id = LocalDefId::from_def_id(DefId::local(id)); // (*)\n-            tcx.resolve_lifetimes(LOCAL_CRATE)\n-                .late_bound\n-                .get(&id)\n+            tcx.resolve_lifetimes(LOCAL_CRATE).late_bound.get(&id)\n         },\n \n         object_lifetime_defaults_map: |tcx, id| {\n             let id = LocalDefId::from_def_id(DefId::local(id)); // (*)\n-            tcx.resolve_lifetimes(LOCAL_CRATE)\n-                .object_lifetime_defaults\n-                .get(&id)\n+            tcx.resolve_lifetimes(LOCAL_CRATE).object_lifetime_defaults.get(&id)\n         },\n \n         ..*providers\n@@ -378,15 +359,11 @@ fn resolve_lifetimes(tcx: TyCtxt<'_>, for_krate: CrateNum) -> &ResolveLifetimes\n         map.insert(hir_id.local_id, v);\n     }\n     for hir_id in named_region_map.late_bound {\n-        let map = rl.late_bound\n-            .entry(hir_id.owner_local_def_id())\n-            .or_default();\n+        let map = rl.late_bound.entry(hir_id.owner_local_def_id()).or_default();\n         map.insert(hir_id.local_id);\n     }\n     for (hir_id, v) in named_region_map.object_lifetime_defaults {\n-        let map = rl.object_lifetime_defaults\n-            .entry(hir_id.owner_local_def_id())\n-            .or_default();\n+        let map = rl.object_lifetime_defaults.entry(hir_id.owner_local_def_id()).or_default();\n         map.insert(hir_id.local_id, v);\n     }\n \n@@ -423,8 +400,7 @@ fn krate(tcx: TyCtxt<'_>) -> NamedRegionMap {\n /// This function returns whether there is such an implicit parameter defined on the given item.\n fn sub_items_have_self_param(node: &hir::ItemKind<'_>) -> bool {\n     match *node {\n-        hir::ItemKind::Trait(..) |\n-        hir::ItemKind::TraitAlias(..) => true,\n+        hir::ItemKind::Trait(..) | hir::ItemKind::TraitAlias(..) => true,\n         _ => false,\n     }\n }\n@@ -442,15 +418,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         let saved = take(&mut self.labels_in_fn);\n         let body = self.tcx.hir().body(body);\n         extract_labels(self, body);\n-        self.with(\n-            Scope::Body {\n-                id: body.id(),\n-                s: self.scope,\n-            },\n-            |_, this| {\n-                this.visit_body(body);\n-            },\n-        );\n+        self.with(Scope::Body { id: body.id(), s: self.scope }, |_, this| {\n+            this.visit_body(body);\n+        });\n         replace(&mut self.labels_in_fn, saved);\n     }\n \n@@ -472,25 +442,17 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             }\n             hir::ItemKind::Static(..) | hir::ItemKind::Const(..) => {\n                 // No lifetime parameters, but implied 'static.\n-                let scope = Scope::Elision {\n-                    elide: Elide::Exact(Region::Static),\n-                    s: ROOT_SCOPE,\n-                };\n+                let scope = Scope::Elision { elide: Elide::Exact(Region::Static), s: ROOT_SCOPE };\n                 self.with(scope, |_, this| intravisit::walk_item(this, item));\n             }\n-            hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                impl_trait_fn: Some(_),\n-                ..\n-            }) => {\n+            hir::ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn: Some(_), .. }) => {\n                 // Currently opaque type declarations are just generated from `impl Trait`\n                 // items. Doing anything on this node is irrelevant, as we currently don't need\n                 // it.\n             }\n             hir::ItemKind::TyAlias(_, ref generics)\n             | hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                impl_trait_fn: None,\n-                ref generics,\n-                ..\n+                impl_trait_fn: None, ref generics, ..\n             })\n             | hir::ItemKind::Enum(_, ref generics)\n             | hir::ItemKind::Struct(_, ref generics)\n@@ -511,16 +473,19 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     0\n                 };\n                 let mut non_lifetime_count = 0;\n-                let lifetimes = generics.params.iter().filter_map(|param| match param.kind {\n-                    GenericParamKind::Lifetime { .. } => {\n-                        Some(Region::early(&self.tcx.hir(), &mut index, param))\n-                    }\n-                    GenericParamKind::Type { .. } |\n-                    GenericParamKind::Const { .. } => {\n-                        non_lifetime_count += 1;\n-                        None\n-                    }\n-                }).collect();\n+                let lifetimes = generics\n+                    .params\n+                    .iter()\n+                    .filter_map(|param| match param.kind {\n+                        GenericParamKind::Lifetime { .. } => {\n+                            Some(Region::early(&self.tcx.hir(), &mut index, param))\n+                        }\n+                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n+                            non_lifetime_count += 1;\n+                            None\n+                        }\n+                    })\n+                    .collect();\n                 let scope = Scope::Binder {\n                     lifetimes,\n                     next_early_index: index + non_lifetime_count,\n@@ -561,7 +526,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let was_in_fn_syntax = self.is_in_fn_syntax;\n                 self.is_in_fn_syntax = true;\n                 let scope = Scope::Binder {\n-                    lifetimes: c.generic_params\n+                    lifetimes: c\n+                        .generic_params\n                         .iter()\n                         .filter_map(|param| match param.kind {\n                             GenericParamKind::Lifetime { .. } => {\n@@ -592,10 +558,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     LifetimeName::Implicit => {\n                         // For types like `dyn Foo`, we should\n                         // generate a special form of elided.\n-                        span_bug!(\n-                            ty.span,\n-                            \"object-lifetime-default expected, not implict\",\n-                        );\n+                        span_bug!(ty.span, \"object-lifetime-default expected, not implict\",);\n                     }\n                     LifetimeName::ImplicitObjectLifetimeDefault => {\n                         // If the user does not write *anything*, we\n@@ -636,19 +599,14 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let (generics, bounds) = match self.tcx.hir().expect_item(item_id.id).kind {\n                     // Named opaque `impl Trait` types are reached via `TyKind::Path`.\n                     // This arm is for `impl Trait` in the types of statics, constants and locals.\n-                    hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                        impl_trait_fn: None,\n-                        ..\n-                    }) => {\n+                    hir::ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn: None, .. }) => {\n                         intravisit::walk_ty(self, ty);\n                         return;\n                     }\n                     // RPIT (return position impl trait)\n-                    hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                        ref generics,\n-                        ref bounds,\n-                        ..\n-                    }) => (generics, bounds),\n+                    hir::ItemKind::OpaqueTy(hir::OpaqueTy { ref generics, ref bounds, .. }) => {\n+                        (generics, bounds)\n+                    }\n                     ref i => bug!(\"`impl Trait` pointed to non-opaque type?? {:#?}\", i),\n                 };\n \n@@ -704,7 +662,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n                             let (name, reg) = Region::early(&self.tcx.hir(), &mut index, &param);\n-                            let def_id = if let Region::EarlyBound(_ ,def_id , _) = reg {\n+                            let def_id = if let Region::EarlyBound(_, def_id, _) = reg {\n                                 def_id\n                             } else {\n                                 bug!();\n@@ -723,19 +681,16 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                 lifetimes.insert(name, reg);\n                             }\n                         }\n-                        GenericParamKind::Type { .. } |\n-                        GenericParamKind::Const { .. } => {\n+                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n                             non_lifetime_count += 1;\n                         }\n                     }\n                 }\n                 let next_early_index = index + non_lifetime_count;\n \n                 if let Some(elision_region) = elision {\n-                    let scope = Scope::Elision {\n-                        elide: Elide::Exact(elision_region),\n-                        s: self.scope,\n-                    };\n+                    let scope =\n+                        Scope::Elision { elide: Elide::Exact(elision_region), s: self.scope };\n                     self.with(scope, |_old_scope, this| {\n                         let scope = Scope::Binder {\n                             lifetimes,\n@@ -788,16 +743,19 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let mut index = self.next_early_index();\n                 debug!(\"visit_ty: index = {}\", index);\n                 let mut non_lifetime_count = 0;\n-                let lifetimes = generics.params.iter().filter_map(|param| match param.kind {\n-                    GenericParamKind::Lifetime { .. } => {\n-                        Some(Region::early(&self.tcx.hir(), &mut index, param))\n-                    }\n-                    GenericParamKind::Type { .. } |\n-                    GenericParamKind::Const { .. } => {\n-                        non_lifetime_count += 1;\n-                        None\n-                    }\n-                }).collect();\n+                let lifetimes = generics\n+                    .params\n+                    .iter()\n+                    .filter_map(|param| match param.kind {\n+                        GenericParamKind::Lifetime { .. } => {\n+                            Some(Region::early(&self.tcx.hir(), &mut index, param))\n+                        }\n+                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n+                            non_lifetime_count += 1;\n+                            None\n+                        }\n+                    })\n+                    .collect();\n                 let scope = Scope::Binder {\n                     lifetimes,\n                     next_early_index: index + non_lifetime_count,\n@@ -840,16 +798,19 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let mut index = self.next_early_index();\n                 let mut non_lifetime_count = 0;\n                 debug!(\"visit_ty: index = {}\", index);\n-                let lifetimes = generics.params.iter().filter_map(|param| match param.kind {\n-                    GenericParamKind::Lifetime { .. } => {\n-                        Some(Region::early(&self.tcx.hir(), &mut index, param))\n-                    }\n-                    GenericParamKind::Const { .. } |\n-                    GenericParamKind::Type { .. } => {\n-                        non_lifetime_count += 1;\n-                        None\n-                    }\n-                }).collect();\n+                let lifetimes = generics\n+                    .params\n+                    .iter()\n+                    .filter_map(|param| match param.kind {\n+                        GenericParamKind::Lifetime { .. } => {\n+                            Some(Region::early(&self.tcx.hir(), &mut index, param))\n+                        }\n+                        GenericParamKind::Const { .. } | GenericParamKind::Type { .. } => {\n+                            non_lifetime_count += 1;\n+                            None\n+                        }\n+                    })\n+                    .collect();\n                 let scope = Scope::Binder {\n                     lifetimes,\n                     next_early_index: index + non_lifetime_count,\n@@ -867,19 +828,23 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let mut index = self.next_early_index();\n                 let mut next_early_index = index;\n                 debug!(\"visit_ty: index = {}\", index);\n-                let lifetimes = generics.params.iter().filter_map(|param| match param.kind {\n-                    GenericParamKind::Lifetime { .. } => {\n-                        Some(Region::early(&self.tcx.hir(), &mut index, param))\n-                    }\n-                    GenericParamKind::Type { .. } => {\n-                        next_early_index += 1;\n-                        None\n-                    }\n-                    GenericParamKind::Const { .. } => {\n-                        next_early_index += 1;\n-                        None\n-                    }\n-                }).collect();\n+                let lifetimes = generics\n+                    .params\n+                    .iter()\n+                    .filter_map(|param| match param.kind {\n+                        GenericParamKind::Lifetime { .. } => {\n+                            Some(Region::early(&self.tcx.hir(), &mut index, param))\n+                        }\n+                        GenericParamKind::Type { .. } => {\n+                            next_early_index += 1;\n+                            None\n+                        }\n+                        GenericParamKind::Const { .. } => {\n+                            next_early_index += 1;\n+                            None\n+                        }\n+                    })\n+                    .collect();\n \n                 let scope = Scope::Binder {\n                     lifetimes,\n@@ -1016,12 +981,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     ) {\n         debug!(\"visit_poly_trait_ref(trait_ref={:?})\", trait_ref);\n \n-        if !self.trait_ref_hack || trait_ref.bound_generic_params.iter().any(|param| {\n-            match param.kind {\n+        if !self.trait_ref_hack\n+            || trait_ref.bound_generic_params.iter().any(|param| match param.kind {\n                 GenericParamKind::Lifetime { .. } => true,\n                 _ => false,\n-            }\n-        }) {\n+            })\n+        {\n             if self.trait_ref_hack {\n                 span_err!(\n                     self.tcx.sess,\n@@ -1073,28 +1038,16 @@ struct Shadower {\n }\n \n fn original_label(span: Span) -> Original {\n-    Original {\n-        kind: ShadowKind::Label,\n-        span: span,\n-    }\n+    Original { kind: ShadowKind::Label, span: span }\n }\n fn shadower_label(span: Span) -> Shadower {\n-    Shadower {\n-        kind: ShadowKind::Label,\n-        span: span,\n-    }\n+    Shadower { kind: ShadowKind::Label, span: span }\n }\n fn original_lifetime(span: Span) -> Original {\n-    Original {\n-        kind: ShadowKind::Lifetime,\n-        span: span,\n-    }\n+    Original { kind: ShadowKind::Lifetime, span: span }\n }\n fn shadower_lifetime(param: &hir::GenericParam) -> Shadower {\n-    Shadower {\n-        kind: ShadowKind::Lifetime,\n-        span: param.span,\n-    }\n+    Shadower { kind: ShadowKind::Lifetime, span: param.span }\n }\n \n impl ShadowKind {\n@@ -1114,22 +1067,19 @@ fn check_mixed_explicit_and_in_band_defs(tcx: TyCtxt<'_>, params: &P<[hir::Gener\n             _ => None,\n         })\n         .collect();\n-    let explicit = lifetime_params\n-        .iter()\n-        .find(|(kind, _)| *kind == LifetimeParamKind::Explicit);\n-    let in_band = lifetime_params\n-        .iter()\n-        .find(|(kind, _)| *kind == LifetimeParamKind::InBand);\n+    let explicit = lifetime_params.iter().find(|(kind, _)| *kind == LifetimeParamKind::Explicit);\n+    let in_band = lifetime_params.iter().find(|(kind, _)| *kind == LifetimeParamKind::InBand);\n \n     if let (Some((_, explicit_span)), Some((_, in_band_span))) = (explicit, in_band) {\n         struct_span_err!(\n             tcx.sess,\n             *in_band_span,\n             E0688,\n             \"cannot mix in-band and explicit lifetime definitions\"\n-        ).span_label(*in_band_span, \"in-band lifetime definition here\")\n-            .span_label(*explicit_span, \"explicit lifetime definition here\")\n-            .emit();\n+        )\n+        .span_label(*in_band_span, \"in-band lifetime definition here\")\n+        .span_label(*explicit_span, \"explicit lifetime definition here\")\n+        .emit();\n     }\n }\n \n@@ -1174,11 +1124,8 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body<'_>) {\n         labels_in_fn: &'a mut Vec<ast::Ident>,\n     }\n \n-    let mut gather = GatherLabels {\n-        tcx: ctxt.tcx,\n-        scope: ctxt.scope,\n-        labels_in_fn: &mut ctxt.labels_in_fn,\n-    };\n+    let mut gather =\n+        GatherLabels { tcx: ctxt.tcx, scope: ctxt.scope, labels_in_fn: &mut ctxt.labels_in_fn };\n     gather.visit_body(body);\n \n     impl<'v, 'a, 'tcx> Visitor<'v> for GatherLabels<'a, 'tcx> {\n@@ -1209,11 +1156,7 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body<'_>) {\n     }\n \n     fn expression_label(ex: &hir::Expr) -> Option<ast::Ident> {\n-        if let hir::ExprKind::Loop(_, Some(label), _) = ex.kind {\n-            Some(label.ident)\n-        } else {\n-            None\n-        }\n+        if let hir::ExprKind::Loop(_, Some(label), _) = ex.kind { Some(label.ident) } else { None }\n     }\n \n     fn check_if_label_shadows_lifetime(\n@@ -1233,9 +1176,7 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body<'_>) {\n                     return;\n                 }\n \n-                Scope::Binder {\n-                    ref lifetimes, s, ..\n-                } => {\n+                Scope::Binder { ref lifetimes, s, .. } => {\n                     // FIXME (#24278): non-hygienic comparison\n                     if let Some(def) = lifetimes.get(&hir::ParamName::Plain(label.modern())) {\n                         let hir_id = tcx.hir().as_local_hir_id(def.id().unwrap()).unwrap();\n@@ -1263,9 +1204,7 @@ fn compute_object_lifetime_defaults(tcx: TyCtxt<'_>) -> HirIdMap<Vec<ObjectLifet\n             | hir::ItemKind::Union(_, ref generics)\n             | hir::ItemKind::Enum(_, ref generics)\n             | hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                ref generics,\n-                impl_trait_fn: None,\n-                ..\n+                ref generics, impl_trait_fn: None, ..\n             })\n             | hir::ItemKind::TyAlias(_, ref generics)\n             | hir::ItemKind::Trait(_, _, ref generics, ..) => {\n@@ -1406,12 +1345,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     where\n         F: for<'b> FnOnce(ScopeRef<'_>, &mut LifetimeContext<'b, 'tcx>),\n     {\n-        let LifetimeContext {\n-            tcx,\n-            map,\n-            lifetime_uses,\n-            ..\n-        } = self;\n+        let LifetimeContext { tcx, map, lifetime_uses, .. } = self;\n         let labels_in_fn = take(&mut self.labels_in_fn);\n         let xcrate_object_lifetime_defaults = take(&mut self.xcrate_object_lifetime_defaults);\n         let mut this = LifetimeContext {\n@@ -1468,7 +1402,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     // helper method to issue suggestions from `fn rah<'a>(&'a T)` to `fn rah(&T)`\n     // or from `fn rah<'a>(T<'a>)` to `fn rah(T<'_>)`\n     fn suggest_eliding_single_use_lifetime(\n-        &self, err: &mut DiagnosticBuilder<'_>, def_id: DefId, lifetime: &hir::Lifetime\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        def_id: DefId,\n+        lifetime: &hir::Lifetime,\n     ) {\n         let name = lifetime.name.ident();\n         let mut remove_decl = None;\n@@ -1488,16 +1425,17 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             // include the trailing whitespace between the lifetime and type names\n                             let lt_through_ty_span = lifetime.span.to(input.span.shrink_to_hi());\n                             remove_use = Some(\n-                                self.tcx.sess.source_map()\n-                                    .span_until_non_whitespace(lt_through_ty_span)\n+                                self.tcx\n+                                    .sess\n+                                    .source_map()\n+                                    .span_until_non_whitespace(lt_through_ty_span),\n                             );\n                             break;\n                         }\n                     }\n                     hir::TyKind::Path(ref qpath) => {\n                         if let QPath::Resolved(_, path) = qpath {\n-\n-                            let last_segment = &path.segments[path.segments.len()-1];\n+                            let last_segment = &path.segments[path.segments.len() - 1];\n                             let generics = last_segment.generic_args();\n                             for arg in generics.args.iter() {\n                                 if let GenericArg::Lifetime(lt) = arg {\n@@ -1509,21 +1447,21 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             }\n                             break;\n                         }\n-                    },\n+                    }\n                     _ => {}\n                 }\n             }\n         };\n         if let Node::Lifetime(hir_lifetime) = self.tcx.hir().get(lifetime.hir_id) {\n-            if let Some(parent) = self.tcx.hir().find(\n-                self.tcx.hir().get_parent_item(hir_lifetime.hir_id))\n+            if let Some(parent) =\n+                self.tcx.hir().find(self.tcx.hir().get_parent_item(hir_lifetime.hir_id))\n             {\n                 match parent {\n                     Node::Item(item) => {\n                         if let hir::ItemKind::Fn(sig, _, _) = &item.kind {\n                             find_arg_use_span(&sig.decl.inputs);\n                         }\n-                    },\n+                    }\n                     Node::ImplItem(impl_item) => {\n                         if let hir::ImplItemKind::Method(sig, _) = &impl_item.kind {\n                             find_arg_use_span(&sig.decl.inputs);\n@@ -1590,10 +1528,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         def_ids.sort_by_cached_key(|&def_id| self.tcx.def_path_hash(def_id));\n \n         for def_id in def_ids {\n-            debug!(\n-                \"check_uses_for_lifetimes_defined_by_scope: def_id = {:?}\",\n-                def_id\n-            );\n+            debug!(\"check_uses_for_lifetimes_defined_by_scope: def_id = {:?}\", def_id);\n \n             let lifetimeuseset = self.lifetime_uses.remove(&def_id);\n \n@@ -1623,14 +1558,20 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         }\n \n                         if let Some(parent_def_id) = self.tcx.parent(def_id) {\n-                            if let Some(parent_hir_id) = self.tcx.hir()\n-                                .as_local_hir_id(parent_def_id) {\n-                                    // lifetimes in `derive` expansions don't count (Issue #53738)\n-                                    if self.tcx.hir().attrs(parent_hir_id).iter()\n-                                        .any(|attr| attr.check_name(sym::automatically_derived)) {\n-                                            continue;\n-                                        }\n+                            if let Some(parent_hir_id) =\n+                                self.tcx.hir().as_local_hir_id(parent_def_id)\n+                            {\n+                                // lifetimes in `derive` expansions don't count (Issue #53738)\n+                                if self\n+                                    .tcx\n+                                    .hir()\n+                                    .attrs(parent_hir_id)\n+                                    .iter()\n+                                    .any(|attr| attr.check_name(sym::automatically_derived))\n+                                {\n+                                    continue;\n                                 }\n+                            }\n                         }\n \n                         let mut err = self.tcx.struct_span_lint_hir(\n@@ -1740,20 +1681,23 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }\n \n         let mut non_lifetime_count = 0;\n-        let lifetimes = generics.params.iter().filter_map(|param| match param.kind {\n-            GenericParamKind::Lifetime { .. } => {\n-                if self.map.late_bound.contains(&param.hir_id) {\n-                    Some(Region::late(&self.tcx.hir(), param))\n-                } else {\n-                    Some(Region::early(&self.tcx.hir(), &mut index, param))\n+        let lifetimes = generics\n+            .params\n+            .iter()\n+            .filter_map(|param| match param.kind {\n+                GenericParamKind::Lifetime { .. } => {\n+                    if self.map.late_bound.contains(&param.hir_id) {\n+                        Some(Region::late(&self.tcx.hir(), param))\n+                    } else {\n+                        Some(Region::early(&self.tcx.hir(), &mut index, param))\n+                    }\n                 }\n-            }\n-            GenericParamKind::Type { .. } |\n-            GenericParamKind::Const { .. } => {\n-                non_lifetime_count += 1;\n-                None\n-            }\n-        }).collect();\n+                GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n+                    non_lifetime_count += 1;\n+                    None\n+                }\n+            })\n+            .collect();\n         let next_early_index = index + non_lifetime_count;\n \n         let scope = Scope::Binder {\n@@ -1775,13 +1719,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             match *scope {\n                 Scope::Root => return 0,\n \n-                Scope::Binder {\n-                    next_early_index,\n-                    opaque_type_parent,\n-                    ..\n-                } if (!only_opaque_type_parent || opaque_type_parent) =>\n+                Scope::Binder { next_early_index, opaque_type_parent, .. }\n+                    if (!only_opaque_type_parent || opaque_type_parent) =>\n                 {\n-                    return next_early_index\n+                    return next_early_index;\n                 }\n \n                 Scope::Binder { s, .. }\n@@ -1832,9 +1773,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     break None;\n                 }\n \n-                Scope::Binder {\n-                    ref lifetimes, s, ..\n-                } => {\n+                Scope::Binder { ref lifetimes, s, .. } => {\n                     match lifetime_ref.name {\n                         LifetimeName::Param(param_name) => {\n                             if let Some(&def) = lifetimes.get(&param_name.modern()) {\n@@ -1860,17 +1799,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             } else if let Some(body_id) = outermost_body {\n                 let fn_id = self.tcx.hir().body_owner(body_id);\n                 match self.tcx.hir().get(fn_id) {\n-                    Node::Item(&hir::Item {\n-                        kind: hir::ItemKind::Fn(..),\n-                        ..\n-                    })\n+                    Node::Item(&hir::Item { kind: hir::ItemKind::Fn(..), .. })\n                     | Node::TraitItem(&hir::TraitItem {\n                         kind: hir::TraitItemKind::Method(..),\n                         ..\n                     })\n                     | Node::ImplItem(&hir::ImplItem {\n-                        kind: hir::ImplItemKind::Method(..),\n-                        ..\n+                        kind: hir::ImplItemKind::Method(..), ..\n                     }) => {\n                         let scope = self.tcx.hir().local_def_id(fn_id);\n                         def = Region::Free(scope, def.id().unwrap());\n@@ -1890,8 +1825,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             E0687,\n                             \"lifetimes used in `fn` or `Fn` syntax must be \\\n                              explicitly declared using `<...>` binders\"\n-                        ).span_label(lifetime_ref.span, \"in-band lifetime definition\")\n-                            .emit();\n+                        )\n+                        .span_label(lifetime_ref.span, \"in-band lifetime definition\")\n+                        .emit();\n                     }\n \n                     Region::Static\n@@ -1912,17 +1848,16 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 E0261,\n                 \"use of undeclared lifetime name `{}`\",\n                 lifetime_ref\n-            ).span_label(lifetime_ref.span, \"undeclared lifetime\")\n-                .emit();\n+            )\n+            .span_label(lifetime_ref.span, \"undeclared lifetime\")\n+            .emit();\n         }\n     }\n \n     fn visit_segment_args(&mut self, res: Res, depth: usize, generic_args: &'tcx hir::GenericArgs) {\n         debug!(\n             \"visit_segment_args(res={:?}, depth={:?}, generic_args={:?})\",\n-            res,\n-            depth,\n-            generic_args,\n+            res, depth, generic_args,\n         );\n \n         if generic_args.parenthesized {\n@@ -1957,21 +1892,17 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // which requires object lifetime defaults.\n         let parent_def_id = |this: &mut Self, def_id: DefId| {\n             let def_key = this.tcx.def_key(def_id);\n-            DefId {\n-                krate: def_id.krate,\n-                index: def_key.parent.expect(\"missing parent\"),\n-            }\n+            DefId { krate: def_id.krate, index: def_key.parent.expect(\"missing parent\") }\n         };\n         let type_def_id = match res {\n-            Res::Def(DefKind::AssocTy, def_id)\n-                if depth == 1 => Some(parent_def_id(self, def_id)),\n-            Res::Def(DefKind::Variant, def_id)\n-                if depth == 0 => Some(parent_def_id(self, def_id)),\n+            Res::Def(DefKind::AssocTy, def_id) if depth == 1 => Some(parent_def_id(self, def_id)),\n+            Res::Def(DefKind::Variant, def_id) if depth == 0 => Some(parent_def_id(self, def_id)),\n             Res::Def(DefKind::Struct, def_id)\n             | Res::Def(DefKind::Union, def_id)\n             | Res::Def(DefKind::Enum, def_id)\n             | Res::Def(DefKind::TyAlias, def_id)\n-            | Res::Def(DefKind::Trait, def_id) if depth == 0 =>\n+            | Res::Def(DefKind::Trait, def_id)\n+                if depth == 0 =>\n             {\n                 Some(def_id)\n             }\n@@ -2018,31 +1949,30 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 &map.object_lifetime_defaults[&id]\n             } else {\n                 let tcx = self.tcx;\n-                self.xcrate_object_lifetime_defaults\n-                    .entry(def_id)\n-                    .or_insert_with(|| {\n-                        tcx.generics_of(def_id)\n-                            .params\n-                            .iter()\n-                            .filter_map(|param| match param.kind {\n-                                GenericParamDefKind::Type {\n-                                    object_lifetime_default,\n-                                    ..\n-                                } => Some(object_lifetime_default),\n-                                GenericParamDefKind::Lifetime | GenericParamDefKind::Const => None,\n-                            })\n-                            .collect()\n-                    })\n+                self.xcrate_object_lifetime_defaults.entry(def_id).or_insert_with(|| {\n+                    tcx.generics_of(def_id)\n+                        .params\n+                        .iter()\n+                        .filter_map(|param| match param.kind {\n+                            GenericParamDefKind::Type { object_lifetime_default, .. } => {\n+                                Some(object_lifetime_default)\n+                            }\n+                            GenericParamDefKind::Lifetime | GenericParamDefKind::Const => None,\n+                        })\n+                        .collect()\n+                })\n             };\n             debug!(\"visit_segment_args: unsubst={:?}\", unsubst);\n             unsubst\n                 .iter()\n                 .map(|set| match *set {\n-                    Set1::Empty => if in_body {\n-                        None\n-                    } else {\n-                        Some(Region::Static)\n-                    },\n+                    Set1::Empty => {\n+                        if in_body {\n+                            None\n+                        } else {\n+                            Some(Region::Static)\n+                        }\n+                    }\n                     Set1::One(r) => {\n                         let lifetimes = generic_args.args.iter().filter_map(|arg| match arg {\n                             GenericArg::Lifetime(lt) => Some(lt),\n@@ -2063,10 +1993,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 GenericArg::Lifetime(_) => {}\n                 GenericArg::Type(ty) => {\n                     if let Some(&lt) = object_lifetime_defaults.get(i) {\n-                        let scope = Scope::ObjectLifetimeDefault {\n-                            lifetime: lt,\n-                            s: self.scope,\n-                        };\n+                        let scope = Scope::ObjectLifetimeDefault { lifetime: lt, s: self.scope };\n                         self.with(scope, |_, this| this.visit_ty(ty));\n                     } else {\n                         self.visit_ty(ty);\n@@ -2103,22 +2030,15 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         //\n         // This is intended to leave room for us to implement the\n         // correct behavior in the future.\n-        let has_lifetime_parameter = generic_args\n-            .args\n-            .iter()\n-            .any(|arg| match arg {\n-                GenericArg::Lifetime(_) => true,\n-                _ => false,\n-            });\n+        let has_lifetime_parameter = generic_args.args.iter().any(|arg| match arg {\n+            GenericArg::Lifetime(_) => true,\n+            _ => false,\n+        });\n \n         // Resolve lifetimes found in the type `XX` from `Item = XX` bindings.\n         for b in &generic_args.bindings {\n             let scope = Scope::ObjectLifetimeDefault {\n-                lifetime: if has_lifetime_parameter {\n-                    None\n-                } else {\n-                    Some(Region::Static)\n-                },\n+                lifetime: if has_lifetime_parameter { None } else { Some(Region::Static) },\n                 s: self.scope,\n             };\n             self.with(scope, |_, this| this.visit_assoc_type_binding(b));\n@@ -2128,10 +2048,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     fn visit_fn_like_elision(&mut self, inputs: &'tcx [hir::Ty], output: Option<&'tcx hir::Ty>) {\n         debug!(\"visit_fn_like_elision: enter\");\n         let mut arg_elide = Elide::FreshLateAnon(Cell::new(0));\n-        let arg_scope = Scope::Elision {\n-            elide: arg_elide.clone(),\n-            s: self.scope,\n-        };\n+        let arg_scope = Scope::Elision { elide: arg_elide.clone(), s: self.scope };\n         self.with(arg_scope, |_, this| {\n             for input in inputs {\n                 this.visit_ty(input);\n@@ -2158,45 +2075,30 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let parent = self.tcx.hir().get_parent_node(output.hir_id);\n         let body = match self.tcx.hir().get(parent) {\n             // `fn` definitions and methods.\n-            Node::Item(&hir::Item {\n-                kind: hir::ItemKind::Fn(.., body),\n-                ..\n-            }) => Some(body),\n+            Node::Item(&hir::Item { kind: hir::ItemKind::Fn(.., body), .. }) => Some(body),\n \n             Node::TraitItem(&hir::TraitItem {\n-                kind: hir::TraitItemKind::Method(_, ref m),\n-                ..\n+                kind: hir::TraitItemKind::Method(_, ref m), ..\n             }) => {\n-                if let hir::ItemKind::Trait(.., ref trait_items) = self.tcx\n-                    .hir()\n-                    .expect_item(self.tcx.hir().get_parent_item(parent))\n-                    .kind\n+                if let hir::ItemKind::Trait(.., ref trait_items) =\n+                    self.tcx.hir().expect_item(self.tcx.hir().get_parent_item(parent)).kind\n                 {\n-                    assoc_item_kind = trait_items\n-                        .iter()\n-                        .find(|ti| ti.id.hir_id == parent)\n-                        .map(|ti| ti.kind);\n+                    assoc_item_kind =\n+                        trait_items.iter().find(|ti| ti.id.hir_id == parent).map(|ti| ti.kind);\n                 }\n                 match *m {\n                     hir::TraitMethod::Required(_) => None,\n                     hir::TraitMethod::Provided(body) => Some(body),\n                 }\n             }\n \n-            Node::ImplItem(&hir::ImplItem {\n-                kind: hir::ImplItemKind::Method(_, body),\n-                ..\n-            }) => {\n-                if let hir::ItemKind::Impl(.., ref self_ty, ref impl_items) = self.tcx\n-                    .hir()\n-                    .expect_item(self.tcx.hir().get_parent_item(parent))\n-                    .kind\n+            Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Method(_, body), .. }) => {\n+                if let hir::ItemKind::Impl(.., ref self_ty, ref impl_items) =\n+                    self.tcx.hir().expect_item(self.tcx.hir().get_parent_item(parent)).kind\n                 {\n                     impl_self = Some(self_ty);\n-                    assoc_item_kind = impl_items\n-                        .iter()\n-                        .find(|ii| ii.id.hir_id == parent)\n-                        .map(|ii| ii.kind);\n+                    assoc_item_kind =\n+                        impl_items.iter().find(|ii| ii.id.hir_id == parent).map(|ii| ii.kind);\n                 }\n                 Some(body)\n             }\n@@ -2247,9 +2149,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             Res::Def(DefKind::Struct, _)\n                             | Res::Def(DefKind::Union, _)\n                             | Res::Def(DefKind::Enum, _)\n-                            | Res::PrimTy(_) => {\n-                                return res == path.res\n-                            }\n+                            | Res::PrimTy(_) => return res == path.res,\n                             _ => {}\n                         }\n                     }\n@@ -2285,10 +2185,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             };\n             visitor.visit_ty(&inputs[0]);\n             if let Set1::One(lifetime) = visitor.lifetime {\n-                let scope = Scope::Elision {\n-                    elide: Elide::Exact(lifetime),\n-                    s: self.scope,\n-                };\n+                let scope = Scope::Elision { elide: Elide::Exact(lifetime), s: self.scope };\n                 self.with(scope, |_, this| this.visit_ty(output));\n                 return;\n             }\n@@ -2338,10 +2235,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         debug!(\"visit_fn_like_elision: elide={:?}\", elide);\n \n-        let scope = Scope::Elision {\n-            elide,\n-            s: self.scope,\n-        };\n+        let scope = Scope::Elision { elide, s: self.scope };\n         self.with(scope, |_, this| this.visit_ty(output));\n         debug!(\"visit_fn_like_elision: exit\");\n \n@@ -2411,8 +2305,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             self.have_bound_regions = true;\n                         }\n                         _ => {\n-                            self.lifetimes\n-                                .insert(lifetime.shifted_out_to_binder(self.outer_index));\n+                            self.lifetimes.insert(lifetime.shifted_out_to_binder(self.outer_index));\n                         }\n                     }\n                 }\n@@ -2533,25 +2426,17 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let mut m = String::new();\n         let len = params.len();\n \n-        let elided_params: Vec<_> = params\n-            .iter()\n-            .cloned()\n-            .filter(|info| info.lifetime_count > 0)\n-            .collect();\n+        let elided_params: Vec<_> =\n+            params.iter().cloned().filter(|info| info.lifetime_count > 0).collect();\n \n         let elided_len = elided_params.len();\n \n         for (i, info) in elided_params.into_iter().enumerate() {\n-            let ElisionFailureInfo {\n-                parent,\n-                index,\n-                lifetime_count: n,\n-                have_bound_regions,\n-            } = info;\n-\n-            let help_name = if let Some(ident) = parent.and_then(|body| {\n-                self.tcx.hir().body(body).params[index].pat.simple_ident()\n-            }) {\n+            let ElisionFailureInfo { parent, index, lifetime_count: n, have_bound_regions } = info;\n+\n+            let help_name = if let Some(ident) =\n+                parent.and_then(|body| self.tcx.hir().body(body).params[index].pat.simple_ident())\n+            {\n                 format!(\"`{}`\", ident)\n             } else {\n                 format!(\"argument {}\", index + 1)\n@@ -2629,9 +2514,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n                 Scope::Body { .. } | Scope::ObjectLifetimeDefault { lifetime: None, .. } => return,\n \n-                Scope::ObjectLifetimeDefault {\n-                    lifetime: Some(l), ..\n-                } => break l,\n+                Scope::ObjectLifetimeDefault { lifetime: Some(l), .. } => break l,\n             }\n         };\n         self.insert_lifetime(lifetime_ref, lifetime.shifted(late_depth));\n@@ -2652,9 +2535,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         for (i, (lifetime_i, lifetime_i_name)) in lifetimes.iter().enumerate() {\n             if let hir::ParamName::Plain(_) = lifetime_i_name {\n                 let name = lifetime_i_name.ident().name;\n-                if name == kw::UnderscoreLifetime\n-                    || name == kw::StaticLifetime\n-                {\n+                if name == kw::UnderscoreLifetime || name == kw::StaticLifetime {\n                     let mut err = struct_span_err!(\n                         self.tcx.sess,\n                         lifetime_i.span,\n@@ -2679,9 +2560,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         E0263,\n                         \"lifetime name `{}` declared twice in the same scope\",\n                         lifetime_j.name.ident()\n-                    ).span_label(lifetime_j.span, \"declared twice\")\n-                        .span_label(lifetime_i.span, \"previous declaration here\")\n-                        .emit();\n+                    )\n+                    .span_label(lifetime_j.span, \"declared twice\")\n+                    .span_label(lifetime_i.span, \"previous declaration here\")\n+                    .emit();\n                 }\n             }\n \n@@ -2762,9 +2644,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     return;\n                 }\n \n-                Scope::Binder {\n-                    ref lifetimes, s, ..\n-                } => {\n+                Scope::Binder { ref lifetimes, s, .. } => {\n                     if let Some(&def) = lifetimes.get(&param.name.modern()) {\n                         let hir_id = self.tcx.hir().as_local_hir_id(def.id().unwrap()).unwrap();\n \n@@ -2792,10 +2672,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 Scope::Root => break false,\n \n                 // Inside of items, it depends on the kind of item.\n-                Scope::Binder {\n-                    track_lifetime_uses,\n-                    ..\n-                } => break track_lifetime_uses,\n+                Scope::Binder { track_lifetime_uses, .. } => break track_lifetime_uses,\n \n                 // Inside a body, `'_` will use an inference variable,\n                 // should be fine.\n@@ -2804,23 +2681,14 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 // A lifetime only used in a fn argument could as well\n                 // be replaced with `'_`, as that would generate a\n                 // fresh name, too.\n-                Scope::Elision {\n-                    elide: Elide::FreshLateAnon(_),\n-                    ..\n-                } => break true,\n+                Scope::Elision { elide: Elide::FreshLateAnon(_), .. } => break true,\n \n                 // In the return type or other such place, `'_` is not\n                 // going to make a fresh name, so we cannot\n                 // necessarily replace a single-use lifetime with\n                 // `'_`.\n-                Scope::Elision {\n-                    elide: Elide::Exact(_),\n-                    ..\n-                } => break false,\n-                Scope::Elision {\n-                    elide: Elide::Error(_),\n-                    ..\n-                } => break false,\n+                Scope::Elision { elide: Elide::Exact(_), .. } => break false,\n+                Scope::Elision { elide: Elide::Error(_), .. } => break false,\n \n                 Scope::ObjectLifetimeDefault { s, .. } => scope = s,\n             }\n@@ -2854,14 +2722,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             | Region::EarlyBound(_, def_id, _) => {\n                 // A lifetime declared by the user.\n                 let track_lifetime_uses = self.track_lifetime_uses();\n-                debug!(\n-                    \"insert_lifetime: track_lifetime_uses={}\",\n-                    track_lifetime_uses\n-                );\n+                debug!(\"insert_lifetime: track_lifetime_uses={}\", track_lifetime_uses);\n                 if track_lifetime_uses && !self.lifetime_uses.contains_key(&def_id) {\n                     debug!(\"insert_lifetime: first use of {:?}\", def_id);\n-                    self.lifetime_uses\n-                        .insert(def_id, LifetimeUseSet::One(lifetime_ref));\n+                    self.lifetime_uses.insert(def_id, LifetimeUseSet::One(lifetime_ref));\n                 } else {\n                     debug!(\"insert_lifetime: many uses of {:?}\", def_id);\n                     self.lifetime_uses.insert(def_id, LifetimeUseSet::Many);\n@@ -2894,10 +2758,7 @@ fn insert_late_bound_lifetimes(\n     decl: &hir::FnDecl,\n     generics: &hir::Generics,\n ) {\n-    debug!(\n-        \"insert_late_bound_lifetimes(decl={:?}, generics={:?})\",\n-        decl, generics\n-    );\n+    debug!(\"insert_late_bound_lifetimes(decl={:?}, generics={:?})\", decl, generics);\n \n     let mut constrained_by_input = ConstrainedCollector::default();\n     for arg_ty in &decl.inputs {\n@@ -2907,10 +2768,7 @@ fn insert_late_bound_lifetimes(\n     let mut appears_in_output = AllCollector::default();\n     intravisit::walk_fn_ret_ty(&mut appears_in_output, &decl.output);\n \n-    debug!(\n-        \"insert_late_bound_lifetimes: constrained_by_input={:?}\",\n-        constrained_by_input.regions\n-    );\n+    debug!(\"insert_late_bound_lifetimes: constrained_by_input={:?}\", constrained_by_input.regions);\n \n     // Walk the lifetimes that appear in where clauses.\n     //\n@@ -2944,8 +2802,7 @@ fn insert_late_bound_lifetimes(\n             hir::GenericParamKind::Lifetime { .. } => { /* fall through */ }\n \n             // Neither types nor consts are late-bound.\n-            hir::GenericParamKind::Type { .. }\n-            | hir::GenericParamKind::Const { .. } => continue,\n+            hir::GenericParamKind::Type { .. } | hir::GenericParamKind::Const { .. } => continue,\n         }\n \n         let lt_name = hir::LifetimeName::Param(param.name.modern());\n@@ -3035,13 +2892,7 @@ pub fn report_missing_lifetime_specifiers(\n     span: Span,\n     count: usize,\n ) -> DiagnosticBuilder<'_> {\n-    struct_span_err!(\n-        sess,\n-        span,\n-        E0106,\n-        \"missing lifetime specifier{}\",\n-        pluralize!(count)\n-    )\n+    struct_span_err!(sess, span, E0106, \"missing lifetime specifier{}\", pluralize!(count))\n }\n \n fn add_missing_lifetime_specifiers_label(\n@@ -3053,11 +2904,9 @@ fn add_missing_lifetime_specifiers_label(\n ) {\n     if count > 1 {\n         err.span_label(span, format!(\"expected {} lifetime parameters\", count));\n-    } else if let (1, Some(name), Some(\"&\")) = (\n-        lifetime_names.len(),\n-        lifetime_names.iter().next(),\n-        snippet,\n-    ) {\n+    } else if let (1, Some(name), Some(\"&\")) =\n+        (lifetime_names.len(), lifetime_names.iter().next(), snippet)\n+    {\n         err.span_suggestion(\n             span,\n             \"consider using the named lifetime\","}, {"sha": "e6ecf1b676e85f8aba2febb9460e5bca16e2925f", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 232, "deletions": 221, "changes": 453, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d", "patch": "@@ -5,81 +5,80 @@\n #[allow(dead_code)]\n pub mod auto_trait;\n mod chalk_fulfill;\n+pub mod codegen;\n mod coherence;\n-pub mod error_reporting;\n mod engine;\n+pub mod error_reporting;\n mod fulfill;\n-mod project;\n mod object_safety;\n mod on_unimplemented;\n+mod project;\n+pub mod query;\n mod select;\n mod specialize;\n mod structural_impls;\n-pub mod codegen;\n mod util;\n-pub mod query;\n \n-use chalk_engine;\n use crate::hir;\n use crate::hir::def_id::DefId;\n-use crate::infer::{InferCtxt, SuppressRegionErrors};\n use crate::infer::outlives::env::OutlivesEnvironment;\n+use crate::infer::{InferCtxt, SuppressRegionErrors};\n use crate::middle::region;\n use crate::mir::interpret::ErrorHandled;\n+use crate::ty::error::{ExpectedFound, TypeError};\n+use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use crate::ty::subst::{InternalSubsts, SubstsRef};\n+use crate::ty::{self, AdtKind, GenericParamDefKind, List, ToPredicate, Ty, TyCtxt};\n+use crate::util::common::ErrorReported;\n+use chalk_engine;\n use rustc_macros::HashStable;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n-use crate::ty::subst::{InternalSubsts, SubstsRef};\n-use crate::ty::{self, AdtKind, List, Ty, TyCtxt, GenericParamDefKind, ToPredicate};\n-use crate::ty::error::{ExpectedFound, TypeError};\n-use crate::ty::fold::{TypeFolder, TypeFoldable, TypeVisitor};\n-use crate::util::common::ErrorReported;\n \n use std::fmt::Debug;\n use std::rc::Rc;\n \n-pub use self::SelectionError::*;\n pub use self::FulfillmentErrorCode::*;\n-pub use self::Vtable::*;\n pub use self::ObligationCauseCode::*;\n+pub use self::SelectionError::*;\n+pub use self::Vtable::*;\n \n pub use self::coherence::{add_placeholder_note, orphan_check, overlapping_impls};\n pub use self::coherence::{OrphanCheckErr, OverlapResult};\n+pub use self::engine::{TraitEngine, TraitEngineExt};\n pub use self::fulfill::{FulfillmentContext, PendingPredicateObligation};\n-pub use self::project::MismatchedProjectionTypes;\n-pub use self::project::{normalize, normalize_projection_type, poly_project_and_unify_type};\n-pub use self::project::{ProjectionCache, ProjectionCacheSnapshot, Reveal, Normalized};\n-pub use self::object_safety::ObjectSafetyViolation;\n pub use self::object_safety::MethodViolationCode;\n+pub use self::object_safety::ObjectSafetyViolation;\n pub use self::on_unimplemented::{OnUnimplementedDirective, OnUnimplementedNote};\n-pub use self::select::{EvaluationCache, SelectionContext, SelectionCache};\n+pub use self::project::MismatchedProjectionTypes;\n+pub use self::project::{normalize, normalize_projection_type, poly_project_and_unify_type};\n+pub use self::project::{Normalized, ProjectionCache, ProjectionCacheSnapshot, Reveal};\n+pub use self::select::{EvaluationCache, SelectionCache, SelectionContext};\n pub use self::select::{EvaluationResult, IntercrateAmbiguityCause, OverflowError};\n-pub use self::specialize::{OverlapError, specialization_graph, translate_substs};\n pub use self::specialize::find_associated_item;\n pub use self::specialize::specialization_graph::FutureCompatOverlapError;\n pub use self::specialize::specialization_graph::FutureCompatOverlapErrorKind;\n-pub use self::engine::{TraitEngine, TraitEngineExt};\n+pub use self::specialize::{specialization_graph, translate_substs, OverlapError};\n pub use self::util::{elaborate_predicates, elaborate_trait_ref, elaborate_trait_refs};\n+pub use self::util::{expand_trait_aliases, TraitAliasExpander};\n pub use self::util::{\n-    supertraits, supertrait_def_ids, transitive_bounds, Supertraits, SupertraitDefIds,\n+    supertrait_def_ids, supertraits, transitive_bounds, SupertraitDefIds, Supertraits,\n };\n-pub use self::util::{expand_trait_aliases, TraitAliasExpander};\n \n pub use self::chalk_fulfill::{\n-    CanonicalGoal as ChalkCanonicalGoal,\n-    FulfillmentContext as ChalkFulfillmentContext\n+    CanonicalGoal as ChalkCanonicalGoal, FulfillmentContext as ChalkFulfillmentContext,\n };\n \n-pub use self::ObligationCauseCode::*;\n pub use self::FulfillmentErrorCode::*;\n+pub use self::ObligationCauseCode::*;\n pub use self::SelectionError::*;\n pub use self::Vtable::*;\n \n /// Whether to enable bug compatibility with issue #43355.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum IntercrateMode {\n     Issue43355,\n-    Fixed\n+    Fixed,\n }\n \n /// The mode that trait queries run in.\n@@ -140,19 +139,19 @@ pub struct ObligationCause<'tcx> {\n     /// information.\n     pub body_id: hir::HirId,\n \n-    pub code: ObligationCauseCode<'tcx>\n+    pub code: ObligationCauseCode<'tcx>,\n }\n \n impl<'tcx> ObligationCause<'tcx> {\n     pub fn span(&self, tcx: TyCtxt<'tcx>) -> Span {\n         match self.code {\n-            ObligationCauseCode::CompareImplMethodObligation { .. } |\n-            ObligationCauseCode::MainFunctionType |\n-            ObligationCauseCode::StartFunctionType => {\n-                tcx.sess.source_map().def_span(self.span)\n-            }\n-            ObligationCauseCode::MatchExpressionArm(\n-                box MatchExpressionArmCause { arm_span, .. }) => arm_span,\n+            ObligationCauseCode::CompareImplMethodObligation { .. }\n+            | ObligationCauseCode::MainFunctionType\n+            | ObligationCauseCode::StartFunctionType => tcx.sess.source_map().def_span(self.span),\n+            ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n+                arm_span,\n+                ..\n+            }) => arm_span,\n             _ => self.span,\n         }\n     }\n@@ -189,7 +188,10 @@ pub enum ObligationCauseCode<'tcx> {\n     ObjectCastObligation(/* Object type */ Ty<'tcx>),\n \n     /// Obligation incurred due to a coercion.\n-    Coercion { source: Ty<'tcx>, target: Ty<'tcx> },\n+    Coercion {\n+        source: Ty<'tcx>,\n+        target: Ty<'tcx>,\n+    },\n \n     /// Various cases where expressions must be `Sized` / `Copy` / etc.\n     /// `L = X` implies that `L` is `Sized`.\n@@ -211,7 +213,10 @@ pub enum ObligationCauseCode<'tcx> {\n     RepeatVec(bool),\n \n     /// Types of fields (other than the last, except for packed structs) in a struct must be sized.\n-    FieldSized { adt_kind: AdtKind, last: bool },\n+    FieldSized {\n+        adt_kind: AdtKind,\n+        last: bool,\n+    },\n \n     /// Constant expressions must be sized.\n     ConstSized,\n@@ -245,7 +250,10 @@ pub enum ObligationCauseCode<'tcx> {\n     MatchExpressionArm(Box<MatchExpressionArmCause<'tcx>>),\n \n     /// Computing common supertype in the pattern guard for the arms of a match expression\n-    MatchExpressionArmPattern { span: Span, ty: Ty<'tcx> },\n+    MatchExpressionArmPattern {\n+        span: Span,\n+        ty: Ty<'tcx>,\n+    },\n \n     /// Constants in patterns must have `Structural` type.\n     ConstPatternStructural,\n@@ -322,7 +330,7 @@ pub struct DerivedObligationCause<'tcx> {\n     parent_trait_ref: ty::PolyTraitRef<'tcx>,\n \n     /// The parent trait had this cause.\n-    parent_code: Rc<ObligationCauseCode<'tcx>>\n+    parent_code: Rc<ObligationCauseCode<'tcx>>,\n }\n \n pub type Obligations<'tcx, O> = Vec<Obligation<'tcx, O>>;\n@@ -415,7 +423,7 @@ impl<'tcx> GoalKind<'tcx> {\n             Some(p) => p.into_goal(),\n             None => GoalKind::Quantified(\n                 QuantifierKind::Universal,\n-                domain_goal.map_bound(|p| tcx.mk_goal(p.into_goal()))\n+                domain_goal.map_bound(|p| tcx.mk_goal(p.into_goal())),\n             ),\n         }\n     }\n@@ -474,10 +482,7 @@ pub struct Environment<'tcx> {\n \n impl Environment<'tcx> {\n     pub fn with<G>(self, goal: G) -> InEnvironment<'tcx, G> {\n-        InEnvironment {\n-            environment: self,\n-            goal,\n-        }\n+        InEnvironment { environment: self, goal }\n     }\n }\n \n@@ -490,12 +495,14 @@ pub struct InEnvironment<'tcx, G> {\n \n pub type Selection<'tcx> = Vtable<'tcx, PredicateObligation<'tcx>>;\n \n-#[derive(Clone,Debug,TypeFoldable)]\n+#[derive(Clone, Debug, TypeFoldable)]\n pub enum SelectionError<'tcx> {\n     Unimplemented,\n-    OutputTypeParameterMismatch(ty::PolyTraitRef<'tcx>,\n-                                ty::PolyTraitRef<'tcx>,\n-                                ty::error::TypeError<'tcx>),\n+    OutputTypeParameterMismatch(\n+        ty::PolyTraitRef<'tcx>,\n+        ty::PolyTraitRef<'tcx>,\n+        ty::error::TypeError<'tcx>,\n+    ),\n     TraitNotObjectSafe(DefId),\n     ConstEvalFailure(ErrorHandled),\n     Overflow,\n@@ -514,8 +521,7 @@ pub struct FulfillmentError<'tcx> {\n pub enum FulfillmentErrorCode<'tcx> {\n     CodeSelectionError(SelectionError<'tcx>),\n     CodeProjectionError(MismatchedProjectionTypes<'tcx>),\n-    CodeSubtypeError(ExpectedFound<Ty<'tcx>>,\n-                     TypeError<'tcx>), // always comes from a SubtypePredicate\n+    CodeSubtypeError(ExpectedFound<Ty<'tcx>>, TypeError<'tcx>), // always comes from a SubtypePredicate\n     CodeAmbiguity,\n }\n \n@@ -617,7 +623,7 @@ pub enum Vtable<'tcx, N> {\n pub struct VtableImplData<'tcx, N> {\n     pub impl_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n-    pub nested: Vec<N>\n+    pub nested: Vec<N>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n@@ -626,7 +632,7 @@ pub struct VtableGeneratorData<'tcx, N> {\n     pub substs: SubstsRef<'tcx>,\n     /// Nested obligations. This can be non-empty if the generator\n     /// signature contains associated types.\n-    pub nested: Vec<N>\n+    pub nested: Vec<N>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n@@ -635,18 +641,18 @@ pub struct VtableClosureData<'tcx, N> {\n     pub substs: SubstsRef<'tcx>,\n     /// Nested obligations. This can be non-empty if the closure\n     /// signature contains associated types.\n-    pub nested: Vec<N>\n+    pub nested: Vec<N>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n pub struct VtableAutoImplData<N> {\n     pub trait_def_id: DefId,\n-    pub nested: Vec<N>\n+    pub nested: Vec<N>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n pub struct VtableBuiltinData<N> {\n-    pub nested: Vec<N>\n+    pub nested: Vec<N>,\n }\n \n /// A vtable for some object-safe trait `Foo` automatically derived\n@@ -667,7 +673,7 @@ pub struct VtableObjectData<'tcx, N> {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n pub struct VtableFnPointerData<'tcx, N> {\n     pub fn_ty: Ty<'tcx>,\n-    pub nested: Vec<N>\n+    pub nested: Vec<N>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n@@ -698,14 +704,13 @@ pub fn type_known_to_meet_bound_modulo_regions<'a, 'tcx>(\n     def_id: DefId,\n     span: Span,\n ) -> bool {\n-    debug!(\"type_known_to_meet_bound_modulo_regions(ty={:?}, bound={:?})\",\n-           ty,\n-           infcx.tcx.def_path_str(def_id));\n+    debug!(\n+        \"type_known_to_meet_bound_modulo_regions(ty={:?}, bound={:?})\",\n+        ty,\n+        infcx.tcx.def_path_str(def_id)\n+    );\n \n-    let trait_ref = ty::TraitRef {\n-        def_id,\n-        substs: infcx.tcx.mk_substs_trait(ty, &[]),\n-    };\n+    let trait_ref = ty::TraitRef { def_id, substs: infcx.tcx.mk_substs_trait(ty, &[]) };\n     let obligation = Obligation {\n         param_env,\n         cause: ObligationCause::misc(span, hir::DUMMY_HIR_ID),\n@@ -714,8 +719,12 @@ pub fn type_known_to_meet_bound_modulo_regions<'a, 'tcx>(\n     };\n \n     let result = infcx.predicate_must_hold_modulo_regions(&obligation);\n-    debug!(\"type_known_to_meet_ty={:?} bound={} => {:?}\",\n-           ty, infcx.tcx.def_path_str(def_id), result);\n+    debug!(\n+        \"type_known_to_meet_ty={:?} bound={} => {:?}\",\n+        ty,\n+        infcx.tcx.def_path_str(def_id),\n+        result\n+    );\n \n     if result && (ty.has_infer_types() || ty.has_closure_types()) {\n         // Because of inference \"guessing\", selection can sometimes claim\n@@ -740,16 +749,20 @@ pub fn type_known_to_meet_bound_modulo_regions<'a, 'tcx>(\n         // assume it is move; linear is always ok.\n         match fulfill_cx.select_all_or_error(infcx) {\n             Ok(()) => {\n-                debug!(\"type_known_to_meet_bound_modulo_regions: ty={:?} bound={} success\",\n-                       ty,\n-                       infcx.tcx.def_path_str(def_id));\n+                debug!(\n+                    \"type_known_to_meet_bound_modulo_regions: ty={:?} bound={} success\",\n+                    ty,\n+                    infcx.tcx.def_path_str(def_id)\n+                );\n                 true\n             }\n             Err(e) => {\n-                debug!(\"type_known_to_meet_bound_modulo_regions: ty={:?} bound={} errors={:?}\",\n-                       ty,\n-                       infcx.tcx.def_path_str(def_id),\n-                       e);\n+                debug!(\n+                    \"type_known_to_meet_bound_modulo_regions: ty={:?} bound={} errors={:?}\",\n+                    ty,\n+                    infcx.tcx.def_path_str(def_id),\n+                    e\n+                );\n                 false\n             }\n         }\n@@ -767,9 +780,7 @@ fn do_normalize_predicates<'tcx>(\n ) -> Result<Vec<ty::Predicate<'tcx>>, ErrorReported> {\n     debug!(\n         \"do_normalize_predicates(predicates={:?}, region_context={:?}, cause={:?})\",\n-        predicates,\n-        region_context,\n-        cause,\n+        predicates, region_context, cause,\n     );\n     let span = cause.span;\n     tcx.infer_ctxt().enter(|infcx| {\n@@ -787,19 +798,14 @@ fn do_normalize_predicates<'tcx>(\n         // them here too, and we will remove this function when\n         // we move over to lazy normalization *anyway*.\n         let fulfill_cx = FulfillmentContext::new_ignoring_regions();\n-        let predicates = match fully_normalize(\n-            &infcx,\n-            fulfill_cx,\n-            cause,\n-            elaborated_env,\n-            &predicates,\n-        ) {\n-            Ok(predicates) => predicates,\n-            Err(errors) => {\n-                infcx.report_fulfillment_errors(&errors, None, false);\n-                return Err(ErrorReported)\n-            }\n-        };\n+        let predicates =\n+            match fully_normalize(&infcx, fulfill_cx, cause, elaborated_env, &predicates) {\n+                Ok(predicates) => predicates,\n+                Err(errors) => {\n+                    infcx.report_fulfillment_errors(&errors, None, false);\n+                    return Err(ErrorReported);\n+                }\n+            };\n \n         debug!(\"do_normalize_predictes: normalized predicates = {:?}\", predicates);\n \n@@ -827,7 +833,7 @@ fn do_normalize_predicates<'tcx>(\n                 // unconstrained variable, and it seems better not to ICE,\n                 // all things considered.\n                 tcx.sess.span_err(span, &fixup_err.to_string());\n-                return Err(ErrorReported)\n+                return Err(ErrorReported);\n             }\n         };\n         if predicates.has_local_value() {\n@@ -862,20 +868,20 @@ pub fn normalize_param_env_or_error<'tcx>(\n     // and errors will get reported then; so after typeck we\n     // can be sure that no errors should occur.\n \n-    debug!(\"normalize_param_env_or_error(region_context={:?}, unnormalized_env={:?}, cause={:?})\",\n-           region_context, unnormalized_env, cause);\n+    debug!(\n+        \"normalize_param_env_or_error(region_context={:?}, unnormalized_env={:?}, cause={:?})\",\n+        region_context, unnormalized_env, cause\n+    );\n \n     let mut predicates: Vec<_> =\n-        util::elaborate_predicates(tcx, unnormalized_env.caller_bounds.to_vec())\n-            .collect();\n+        util::elaborate_predicates(tcx, unnormalized_env.caller_bounds.to_vec()).collect();\n \n-    debug!(\"normalize_param_env_or_error: elaborated-predicates={:?}\",\n-           predicates);\n+    debug!(\"normalize_param_env_or_error: elaborated-predicates={:?}\", predicates);\n \n     let elaborated_env = ty::ParamEnv::new(\n         tcx.intern_predicates(&predicates),\n         unnormalized_env.reveal,\n-        unnormalized_env.def_id\n+        unnormalized_env.def_id,\n     );\n \n     // HACK: we are trying to normalize the param-env inside *itself*. The problem is that\n@@ -896,25 +902,31 @@ pub fn normalize_param_env_or_error<'tcx>(\n     //\n     // This works fairly well because trait matching  does not actually care about param-env\n     // TypeOutlives predicates - these are normally used by regionck.\n-    let outlives_predicates: Vec<_> = predicates.drain_filter(|predicate| {\n-        match predicate {\n+    let outlives_predicates: Vec<_> = predicates\n+        .drain_filter(|predicate| match predicate {\n             ty::Predicate::TypeOutlives(..) => true,\n-            _ => false\n-        }\n-    }).collect();\n+            _ => false,\n+        })\n+        .collect();\n \n-    debug!(\"normalize_param_env_or_error: predicates=(non-outlives={:?}, outlives={:?})\",\n-           predicates, outlives_predicates);\n-    let non_outlives_predicates =\n-        match do_normalize_predicates(tcx, region_context, cause.clone(),\n-                                      elaborated_env, predicates) {\n-            Ok(predicates) => predicates,\n-            // An unnormalized env is better than nothing.\n-            Err(ErrorReported) => {\n-                debug!(\"normalize_param_env_or_error: errored resolving non-outlives predicates\");\n-                return elaborated_env\n-            }\n-        };\n+    debug!(\n+        \"normalize_param_env_or_error: predicates=(non-outlives={:?}, outlives={:?})\",\n+        predicates, outlives_predicates\n+    );\n+    let non_outlives_predicates = match do_normalize_predicates(\n+        tcx,\n+        region_context,\n+        cause.clone(),\n+        elaborated_env,\n+        predicates,\n+    ) {\n+        Ok(predicates) => predicates,\n+        // An unnormalized env is better than nothing.\n+        Err(ErrorReported) => {\n+            debug!(\"normalize_param_env_or_error: errored resolving non-outlives predicates\");\n+            return elaborated_env;\n+        }\n+    };\n \n     debug!(\"normalize_param_env_or_error: non-outlives predicates={:?}\", non_outlives_predicates);\n \n@@ -923,21 +935,22 @@ pub fn normalize_param_env_or_error<'tcx>(\n     // predicates here anyway. Keeping them here anyway because it seems safer.\n     let outlives_env: Vec<_> =\n         non_outlives_predicates.iter().chain(&outlives_predicates).cloned().collect();\n-    let outlives_env = ty::ParamEnv::new(\n-        tcx.intern_predicates(&outlives_env),\n-        unnormalized_env.reveal,\n-        None\n-    );\n-    let outlives_predicates =\n-        match do_normalize_predicates(tcx, region_context, cause,\n-                                      outlives_env, outlives_predicates) {\n-            Ok(predicates) => predicates,\n-            // An unnormalized env is better than nothing.\n-            Err(ErrorReported) => {\n-                debug!(\"normalize_param_env_or_error: errored resolving outlives predicates\");\n-                return elaborated_env\n-            }\n-        };\n+    let outlives_env =\n+        ty::ParamEnv::new(tcx.intern_predicates(&outlives_env), unnormalized_env.reveal, None);\n+    let outlives_predicates = match do_normalize_predicates(\n+        tcx,\n+        region_context,\n+        cause,\n+        outlives_env,\n+        outlives_predicates,\n+    ) {\n+        Ok(predicates) => predicates,\n+        // An unnormalized env is better than nothing.\n+        Err(ErrorReported) => {\n+            debug!(\"normalize_param_env_or_error: errored resolving outlives predicates\");\n+            return elaborated_env;\n+        }\n+    };\n     debug!(\"normalize_param_env_or_error: outlives predicates={:?}\", outlives_predicates);\n \n     let mut predicates = non_outlives_predicates;\n@@ -946,7 +959,7 @@ pub fn normalize_param_env_or_error<'tcx>(\n     ty::ParamEnv::new(\n         tcx.intern_predicates(&predicates),\n         unnormalized_env.reveal,\n-        unnormalized_env.def_id\n+        unnormalized_env.def_id,\n     )\n }\n \n@@ -964,9 +977,10 @@ where\n     let selcx = &mut SelectionContext::new(infcx);\n     let Normalized { value: normalized_value, obligations } =\n         project::normalize(selcx, param_env, cause, value);\n-    debug!(\"fully_normalize: normalized_value={:?} obligations={:?}\",\n-           normalized_value,\n-           obligations);\n+    debug!(\n+        \"fully_normalize: normalized_value={:?} obligations={:?}\",\n+        normalized_value, obligations\n+    );\n     for obligation in obligations {\n         fulfill_cx.register_predicate_obligation(selcx.infcx(), obligation);\n     }\n@@ -987,8 +1001,7 @@ fn normalize_and_test_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     predicates: Vec<ty::Predicate<'tcx>>,\n ) -> bool {\n-    debug!(\"normalize_and_test_predicates(predicates={:?})\",\n-           predicates);\n+    debug!(\"normalize_and_test_predicates(predicates={:?})\", predicates);\n \n     let result = tcx.infer_ctxt().enter(|infcx| {\n         let param_env = ty::ParamEnv::reveal_all();\n@@ -1007,23 +1020,20 @@ fn normalize_and_test_predicates<'tcx>(\n \n         fulfill_cx.select_all_or_error(&infcx).is_ok()\n     });\n-    debug!(\"normalize_and_test_predicates(predicates={:?}) = {:?}\",\n-           predicates, result);\n+    debug!(\"normalize_and_test_predicates(predicates={:?}) = {:?}\", predicates, result);\n     result\n }\n \n fn substitute_normalize_and_test_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     key: (DefId, SubstsRef<'tcx>),\n ) -> bool {\n-    debug!(\"substitute_normalize_and_test_predicates(key={:?})\",\n-           key);\n+    debug!(\"substitute_normalize_and_test_predicates(key={:?})\", key);\n \n     let predicates = tcx.predicates_of(key.0).instantiate(tcx, key.1).predicates;\n     let result = normalize_and_test_predicates(tcx, predicates);\n \n-    debug!(\"substitute_normalize_and_test_predicates(key={:?}) = {:?}\",\n-           key, result);\n+    debug!(\"substitute_normalize_and_test_predicates(key={:?}) = {:?}\", key, result);\n     result\n }\n \n@@ -1036,100 +1046,98 @@ fn vtable_methods<'tcx>(\n ) -> &'tcx [Option<(DefId, SubstsRef<'tcx>)>] {\n     debug!(\"vtable_methods({:?})\", trait_ref);\n \n-    tcx.arena.alloc_from_iter(\n-        supertraits(tcx, trait_ref).flat_map(move |trait_ref| {\n-            let trait_methods = tcx.associated_items(trait_ref.def_id())\n-                .filter(|item| item.kind == ty::AssocKind::Method);\n-\n-            // Now list each method's DefId and InternalSubsts (for within its trait).\n-            // If the method can never be called from this object, produce None.\n-            trait_methods.map(move |trait_method| {\n-                debug!(\"vtable_methods: trait_method={:?}\", trait_method);\n-                let def_id = trait_method.def_id;\n-\n-                // Some methods cannot be called on an object; skip those.\n-                if !tcx.is_vtable_safe_method(trait_ref.def_id(), &trait_method) {\n-                    debug!(\"vtable_methods: not vtable safe\");\n-                    return None;\n-                }\n-\n-                // The method may have some early-bound lifetimes; add regions for those.\n-                let substs = trait_ref.map_bound(|trait_ref|\n-                    InternalSubsts::for_item(tcx, def_id, |param, _|\n-                        match param.kind {\n-                            GenericParamDefKind::Lifetime => tcx.lifetimes.re_erased.into(),\n-                            GenericParamDefKind::Type { .. } |\n-                            GenericParamDefKind::Const => {\n-                                trait_ref.substs[param.index as usize]\n-                            }\n-                        }\n-                    )\n-                );\n-\n-                // The trait type may have higher-ranked lifetimes in it;\n-                // erase them if they appear, so that we get the type\n-                // at some particular call site.\n-                let substs = tcx.normalize_erasing_late_bound_regions(\n-                    ty::ParamEnv::reveal_all(),\n-                    &substs\n-                );\n+    tcx.arena.alloc_from_iter(supertraits(tcx, trait_ref).flat_map(move |trait_ref| {\n+        let trait_methods = tcx\n+            .associated_items(trait_ref.def_id())\n+            .filter(|item| item.kind == ty::AssocKind::Method);\n+\n+        // Now list each method's DefId and InternalSubsts (for within its trait).\n+        // If the method can never be called from this object, produce None.\n+        trait_methods.map(move |trait_method| {\n+            debug!(\"vtable_methods: trait_method={:?}\", trait_method);\n+            let def_id = trait_method.def_id;\n+\n+            // Some methods cannot be called on an object; skip those.\n+            if !tcx.is_vtable_safe_method(trait_ref.def_id(), &trait_method) {\n+                debug!(\"vtable_methods: not vtable safe\");\n+                return None;\n+            }\n \n-                // It's possible that the method relies on where-clauses that\n-                // do not hold for this particular set of type parameters.\n-                // Note that this method could then never be called, so we\n-                // do not want to try and codegen it, in that case (see #23435).\n-                let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs);\n-                if !normalize_and_test_predicates(tcx, predicates.predicates) {\n-                    debug!(\"vtable_methods: predicates do not hold\");\n-                    return None;\n-                }\n+            // The method may have some early-bound lifetimes; add regions for those.\n+            let substs = trait_ref.map_bound(|trait_ref| {\n+                InternalSubsts::for_item(tcx, def_id, |param, _| match param.kind {\n+                    GenericParamDefKind::Lifetime => tcx.lifetimes.re_erased.into(),\n+                    GenericParamDefKind::Type { .. } | GenericParamDefKind::Const => {\n+                        trait_ref.substs[param.index as usize]\n+                    }\n+                })\n+            });\n+\n+            // The trait type may have higher-ranked lifetimes in it;\n+            // erase them if they appear, so that we get the type\n+            // at some particular call site.\n+            let substs =\n+                tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &substs);\n+\n+            // It's possible that the method relies on where-clauses that\n+            // do not hold for this particular set of type parameters.\n+            // Note that this method could then never be called, so we\n+            // do not want to try and codegen it, in that case (see #23435).\n+            let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs);\n+            if !normalize_and_test_predicates(tcx, predicates.predicates) {\n+                debug!(\"vtable_methods: predicates do not hold\");\n+                return None;\n+            }\n \n-                Some((def_id, substs))\n-            })\n+            Some((def_id, substs))\n         })\n-    )\n+    }))\n }\n \n impl<'tcx, O> Obligation<'tcx, O> {\n-    pub fn new(cause: ObligationCause<'tcx>,\n-               param_env: ty::ParamEnv<'tcx>,\n-               predicate: O)\n-               -> Obligation<'tcx, O>\n-    {\n+    pub fn new(\n+        cause: ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        predicate: O,\n+    ) -> Obligation<'tcx, O> {\n         Obligation { cause, param_env, recursion_depth: 0, predicate }\n     }\n \n-    fn with_depth(cause: ObligationCause<'tcx>,\n-                  recursion_depth: usize,\n-                  param_env: ty::ParamEnv<'tcx>,\n-                  predicate: O)\n-                  -> Obligation<'tcx, O>\n-    {\n+    fn with_depth(\n+        cause: ObligationCause<'tcx>,\n+        recursion_depth: usize,\n+        param_env: ty::ParamEnv<'tcx>,\n+        predicate: O,\n+    ) -> Obligation<'tcx, O> {\n         Obligation { cause, param_env, recursion_depth, predicate }\n     }\n \n-    pub fn misc(span: Span,\n-                body_id: hir::HirId,\n-                param_env: ty::ParamEnv<'tcx>,\n-                trait_ref: O)\n-                -> Obligation<'tcx, O> {\n+    pub fn misc(\n+        span: Span,\n+        body_id: hir::HirId,\n+        param_env: ty::ParamEnv<'tcx>,\n+        trait_ref: O,\n+    ) -> Obligation<'tcx, O> {\n         Obligation::new(ObligationCause::misc(span, body_id), param_env, trait_ref)\n     }\n \n-    pub fn with<P>(&self, value: P) -> Obligation<'tcx,P> {\n-        Obligation { cause: self.cause.clone(),\n-                     param_env: self.param_env,\n-                     recursion_depth: self.recursion_depth,\n-                     predicate: value }\n+    pub fn with<P>(&self, value: P) -> Obligation<'tcx, P> {\n+        Obligation {\n+            cause: self.cause.clone(),\n+            param_env: self.param_env,\n+            recursion_depth: self.recursion_depth,\n+            predicate: value,\n+        }\n     }\n }\n \n impl<'tcx> ObligationCause<'tcx> {\n     #[inline]\n-    pub fn new(span: Span,\n-               body_id: hir::HirId,\n-               code: ObligationCauseCode<'tcx>)\n-               -> ObligationCause<'tcx> {\n+    pub fn new(\n+        span: Span,\n+        body_id: hir::HirId,\n+        code: ObligationCauseCode<'tcx>,\n+    ) -> ObligationCause<'tcx> {\n         ObligationCause { span, body_id, code }\n     }\n \n@@ -1157,17 +1165,20 @@ impl<'tcx, N> Vtable<'tcx, N> {\n         }\n     }\n \n-    pub fn map<M, F>(self, f: F) -> Vtable<'tcx, M> where F: FnMut(N) -> M {\n+    pub fn map<M, F>(self, f: F) -> Vtable<'tcx, M>\n+    where\n+        F: FnMut(N) -> M,\n+    {\n         match self {\n             VtableImpl(i) => VtableImpl(VtableImplData {\n                 impl_def_id: i.impl_def_id,\n                 substs: i.substs,\n                 nested: i.nested.into_iter().map(f).collect(),\n             }),\n             VtableParam(n) => VtableParam(n.into_iter().map(f).collect()),\n-            VtableBuiltin(i) => VtableBuiltin(VtableBuiltinData {\n-                nested: i.nested.into_iter().map(f).collect(),\n-            }),\n+            VtableBuiltin(i) => {\n+                VtableBuiltin(VtableBuiltinData { nested: i.nested.into_iter().map(f).collect() })\n+            }\n             VtableObject(o) => VtableObject(VtableObjectData {\n                 upcast_trait_ref: o.upcast_trait_ref,\n                 vtable_base: o.vtable_base,\n@@ -1201,10 +1212,10 @@ impl<'tcx, N> Vtable<'tcx, N> {\n }\n \n impl<'tcx> FulfillmentError<'tcx> {\n-    fn new(obligation: PredicateObligation<'tcx>,\n-           code: FulfillmentErrorCode<'tcx>)\n-           -> FulfillmentError<'tcx>\n-    {\n+    fn new(\n+        obligation: PredicateObligation<'tcx>,\n+        code: FulfillmentErrorCode<'tcx>,\n+    ) -> FulfillmentError<'tcx> {\n         FulfillmentError { obligation: obligation, code: code, points_at_arg_span: false }\n     }\n }"}, {"sha": "35d5bdaf1820c1b7f672d2a0ef1f071a84392805", "filename": "src/librustc/ty/constness.rs", "status": "modified", "additions": 70, "deletions": 66, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc%2Fty%2Fconstness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc%2Fty%2Fconstness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fconstness.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d", "patch": "@@ -1,41 +1,38 @@\n-use crate::ty::query::Providers;\n-use crate::hir::def_id::DefId;\n use crate::hir;\n+use crate::hir::def_id::DefId;\n+use crate::hir::map::blocks::FnLikeNode;\n+use crate::ty::query::Providers;\n use crate::ty::TyCtxt;\n-use syntax_pos::symbol::Symbol;\n use rustc_target::spec::abi::Abi;\n-use crate::hir::map::blocks::FnLikeNode;\n use syntax::attr;\n+use syntax_pos::symbol::Symbol;\n \n impl<'tcx> TyCtxt<'tcx> {\n     /// Whether the `def_id` counts as const fn in your current crate, considering all active\n     /// feature gates\n     pub fn is_const_fn(self, def_id: DefId) -> bool {\n-        self.is_const_fn_raw(def_id) && match self.is_unstable_const_fn(def_id) {\n-            Some(feature_name) => {\n-                // has a `rustc_const_unstable` attribute, check whether the user enabled the\n-                // corresponding feature gate.\n-                self.features()\n-                    .declared_lib_features\n-                    .iter()\n-                    .any(|&(sym, _)| sym == feature_name)\n-            },\n-            // functions without const stability are either stable user written\n-            // const fn or the user is using feature gates and we thus don't\n-            // care what they do\n-            None => true,\n-        }\n+        self.is_const_fn_raw(def_id)\n+            && match self.is_unstable_const_fn(def_id) {\n+                Some(feature_name) => {\n+                    // has a `rustc_const_unstable` attribute, check whether the user enabled the\n+                    // corresponding feature gate.\n+                    self.features()\n+                        .declared_lib_features\n+                        .iter()\n+                        .any(|&(sym, _)| sym == feature_name)\n+                }\n+                // functions without const stability are either stable user written\n+                // const fn or the user is using feature gates and we thus don't\n+                // care what they do\n+                None => true,\n+            }\n     }\n \n     /// Whether the `def_id` is an unstable const fn and what feature gate is necessary to enable it\n     pub fn is_unstable_const_fn(self, def_id: DefId) -> Option<Symbol> {\n         if self.is_const_fn_raw(def_id) {\n             let const_stab = self.lookup_const_stability(def_id)?;\n-            if const_stab.level.is_unstable() {\n-                Some(const_stab.feature)\n-            } else {\n-                None\n-            }\n+            if const_stab.level.is_unstable() { Some(const_stab.feature) } else { None }\n         } else {\n             None\n         }\n@@ -54,29 +51,31 @@ impl<'tcx> TyCtxt<'tcx> {\n             match self.lookup_const_stability(def_id) {\n                 // `rustc_const_unstable` functions don't need to conform.\n                 Some(&attr::ConstStability { ref level, .. }) if level.is_unstable() => false,\n-                None => if let Some(stab) = self.lookup_stability(def_id) {\n-                    if stab.level.is_stable() {\n-                        self.sess.span_err(\n-                            self.def_span(def_id),\n-                            \"stable const functions must have either `rustc_const_stable` or \\\n+                None => {\n+                    if let Some(stab) = self.lookup_stability(def_id) {\n+                        if stab.level.is_stable() {\n+                            self.sess.span_err(\n+                                self.def_span(def_id),\n+                                \"stable const functions must have either `rustc_const_stable` or \\\n                             `rustc_const_unstable` attribute\",\n-                        );\n-                        // While we errored above, because we don't know if we need to conform, we\n-                        // err on the \"safe\" side and require min_const_fn.\n-                        true\n+                            );\n+                            // While we errored above, because we don't know if we need to conform, we\n+                            // err on the \"safe\" side and require min_const_fn.\n+                            true\n+                        } else {\n+                            // Unstable functions need not conform to min_const_fn.\n+                            false\n+                        }\n                     } else {\n-                        // Unstable functions need not conform to min_const_fn.\n-                        false\n+                        // Internal functions are forced to conform to min_const_fn.\n+                        // Annotate the internal function with a const stability attribute if\n+                        // you need to use unstable features.\n+                        // Note: this is an arbitrary choice that does not affect stability or const\n+                        // safety or anything, it just changes whether we need to annotate some\n+                        // internal functions with `rustc_const_stable` or with `rustc_const_unstable`\n+                        true\n                     }\n-                } else {\n-                    // Internal functions are forced to conform to min_const_fn.\n-                    // Annotate the internal function with a const stability attribute if\n-                    // you need to use unstable features.\n-                    // Note: this is an arbitrary choice that does not affect stability or const\n-                    // safety or anything, it just changes whether we need to annotate some\n-                    // internal functions with `rustc_const_stable` or with `rustc_const_unstable`\n-                    true\n-                },\n+                }\n                 // Everything else needs to conform, because it would be callable from\n                 // other `min_const_fn` functions.\n                 _ => true,\n@@ -88,23 +87,25 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n }\n \n-\n pub fn provide(providers: &mut Providers<'_>) {\n     /// Const evaluability whitelist is here to check evaluability at the\n     /// top level beforehand.\n     fn is_const_intrinsic(tcx: TyCtxt<'_>, def_id: DefId) -> Option<bool> {\n         match tcx.fn_sig(def_id).abi() {\n-            Abi::RustIntrinsic |\n-            Abi::PlatformIntrinsic => Some(tcx.lookup_const_stability(def_id).is_some()),\n-            _ => None\n+            Abi::RustIntrinsic | Abi::PlatformIntrinsic => {\n+                Some(tcx.lookup_const_stability(def_id).is_some())\n+            }\n+            _ => None,\n         }\n     }\n \n     /// Checks whether the function has a `const` modifier or, in case it is an intrinsic, whether\n     /// said intrinsic is on the whitelist for being const callable.\n     fn is_const_fn_raw(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-        let hir_id = tcx.hir().as_local_hir_id(def_id)\n-                              .expect(\"Non-local call to local provider is_const_fn\");\n+        let hir_id = tcx\n+            .hir()\n+            .as_local_hir_id(def_id)\n+            .expect(\"Non-local call to local provider is_const_fn\");\n \n         let node = tcx.hir().get(hir_id);\n \n@@ -120,27 +121,30 @@ pub fn provide(providers: &mut Providers<'_>) {\n     }\n \n     fn is_promotable_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-        tcx.is_const_fn(def_id) && match tcx.lookup_const_stability(def_id) {\n-            Some(stab) => {\n-                if cfg!(debug_assertions) && stab.promotable {\n-                    let sig = tcx.fn_sig(def_id);\n-                    assert_eq!(\n-                        sig.unsafety(),\n-                        hir::Unsafety::Normal,\n-                        \"don't mark const unsafe fns as promotable\",\n-                        // https://github.com/rust-lang/rust/pull/53851#issuecomment-418760682\n-                    );\n+        tcx.is_const_fn(def_id)\n+            && match tcx.lookup_const_stability(def_id) {\n+                Some(stab) => {\n+                    if cfg!(debug_assertions) && stab.promotable {\n+                        let sig = tcx.fn_sig(def_id);\n+                        assert_eq!(\n+                            sig.unsafety(),\n+                            hir::Unsafety::Normal,\n+                            \"don't mark const unsafe fns as promotable\",\n+                            // https://github.com/rust-lang/rust/pull/53851#issuecomment-418760682\n+                        );\n+                    }\n+                    stab.promotable\n                 }\n-                stab.promotable\n-            },\n-            None => false,\n-        }\n+                None => false,\n+            }\n     }\n \n     fn const_fn_is_allowed_fn_ptr(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-        tcx.is_const_fn(def_id) &&\n-            tcx.lookup_const_stability(def_id)\n-                .map(|stab| stab.allow_const_fn_ptr).unwrap_or(false)\n+        tcx.is_const_fn(def_id)\n+            && tcx\n+                .lookup_const_stability(def_id)\n+                .map(|stab| stab.allow_const_fn_ptr)\n+                .unwrap_or(false)\n     }\n \n     *providers = Providers {"}, {"sha": "39341de6367f171e0abf3cbaf01cb2101e404f55", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 435, "deletions": 593, "changes": 1028, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d", "patch": "@@ -1,91 +1,90 @@\n-// ignore-tidy-filelength\n //! Type context book-keeping.\n \n use crate::arena::Arena;\n use crate::dep_graph::DepGraph;\n-use crate::dep_graph::{self, DepNode, DepConstructor};\n-use crate::session::Session;\n-use crate::session::config::{BorrowckMode, OutputFilenames};\n-use crate::session::config::CrateType;\n-use crate::middle;\n-use crate::middle::lang_items::PanicLocationLangItem;\n-use crate::hir::{self, TraitCandidate, HirId, ItemKind, ItemLocalId, Node};\n-use crate::hir::def::{Res, DefKind, Export};\n+use crate::dep_graph::{self, DepConstructor, DepNode};\n+use crate::hir::def::{DefKind, Export, Res};\n use crate::hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use crate::hir::map as hir_map;\n use crate::hir::map::DefPathHash;\n-use crate::lint::{self, Lint};\n-use crate::ich::{StableHashingContext, NodeIdHashingMode};\n+use crate::hir::{self, HirId, ItemKind, ItemLocalId, Node, TraitCandidate};\n+use crate::ich::{NodeIdHashingMode, StableHashingContext};\n use crate::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n use crate::infer::outlives::free_region_map::FreeRegionMap;\n+use crate::lint::{self, Lint};\n+use crate::middle;\n use crate::middle::cstore::CrateStoreDyn;\n use crate::middle::cstore::EncodedMetadata;\n use crate::middle::lang_items;\n+use crate::middle::lang_items::PanicLocationLangItem;\n use crate::middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use crate::middle::stability;\n-use crate::mir::{BodyAndCache, Field, interpret, Local, Place, PlaceElem, ProjectionKind, Promoted};\n-use crate::mir::interpret::{ConstValue, Allocation, Scalar};\n-use crate::ty::subst::{GenericArg, InternalSubsts, SubstsRef, Subst};\n-use crate::ty::ReprOptions;\n+use crate::mir::interpret::{Allocation, ConstValue, Scalar};\n+use crate::mir::{\n+    interpret, BodyAndCache, Field, Local, Place, PlaceElem, ProjectionKind, Promoted,\n+};\n+use crate::session::config::CrateType;\n+use crate::session::config::{BorrowckMode, OutputFilenames};\n+use crate::session::Session;\n use crate::traits;\n-use crate::traits::{Clause, Clauses, GoalKind, Goal, Goals};\n-use crate::ty::{self, DefIdTree, Ty, TypeAndMut};\n-use crate::ty::{TyS, TyKind, List};\n-use crate::ty::{AdtKind, AdtDef, Region, Const};\n-use crate::ty::{PolyFnSig, InferTy, ParamTy, ProjectionTy, ExistentialPredicate, Predicate};\n-use crate::ty::RegionKind;\n-use crate::ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid, ConstVid};\n-use crate::ty::TyKind::*;\n-use crate::ty::{InferConst, ParamConst};\n-use crate::ty::GenericParamDefKind;\n+use crate::traits::{Clause, Clauses, Goal, GoalKind, Goals};\n use crate::ty::layout::{LayoutDetails, TargetDataLayout, VariantIdx};\n use crate::ty::query;\n use crate::ty::steal::Steal;\n-use crate::ty::subst::{UserSubsts, GenericArgKind};\n-use crate::ty::{BoundVar, BindingMode};\n+use crate::ty::subst::{GenericArg, InternalSubsts, Subst, SubstsRef};\n+use crate::ty::subst::{GenericArgKind, UserSubsts};\n use crate::ty::CanonicalPolyFnSig;\n+use crate::ty::GenericParamDefKind;\n+use crate::ty::RegionKind;\n+use crate::ty::ReprOptions;\n+use crate::ty::TyKind::*;\n+use crate::ty::{self, DefIdTree, Ty, TypeAndMut};\n+use crate::ty::{AdtDef, AdtKind, Const, Region};\n+use crate::ty::{BindingMode, BoundVar};\n+use crate::ty::{ConstVid, FloatVar, FloatVid, IntVar, IntVid, TyVar, TyVid};\n+use crate::ty::{ExistentialPredicate, InferTy, ParamTy, PolyFnSig, Predicate, ProjectionTy};\n+use crate::ty::{InferConst, ParamConst};\n+use crate::ty::{List, TyKind, TyS};\n use crate::util::common::ErrorReported;\n use crate::util::nodemap::{DefIdMap, DefIdSet, ItemLocalMap, ItemLocalSet, NodeMap};\n use crate::util::nodemap::{FxHashMap, FxHashSet};\n \n-use errors::DiagnosticBuilder;\n use arena::SyncDroplessArena;\n-use smallvec::SmallVec;\n+use errors::DiagnosticBuilder;\n use rustc_data_structures::profiling::SelfProfilerRef;\n+use rustc_data_structures::sharded::ShardedHashMap;\n use rustc_data_structures::stable_hasher::{\n-    HashStable, StableHasher, StableVec, hash_stable_hashmap,\n+    hash_stable_hashmap, HashStable, StableHasher, StableVec,\n };\n+use rustc_data_structures::sync::{Lock, Lrc, WorkerLocal};\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_data_structures::sharded::ShardedHashMap;\n-use rustc_data_structures::sync::{Lrc, Lock, WorkerLocal};\n+use rustc_macros::HashStable;\n+use rustc_target::spec::abi;\n+use smallvec::SmallVec;\n use std::any::Any;\n use std::borrow::Borrow;\n use std::cmp::Ordering;\n use std::collections::hash_map::{self, Entry};\n-use std::hash::{Hash, Hasher};\n use std::fmt;\n-use std::mem;\n-use std::ops::{Deref, Bound};\n+use std::hash::{Hash, Hasher};\n use std::iter;\n+use std::mem;\n+use std::ops::{Bound, Deref};\n use std::sync::Arc;\n-use rustc_target::spec::abi;\n-use rustc_macros::HashStable;\n use syntax::ast;\n use syntax::attr;\n+use syntax::expand::allocator::AllocatorKind;\n use syntax::source_map::MultiSpan;\n-use syntax::symbol::{Symbol, kw, sym};\n+use syntax::symbol::{kw, sym, Symbol};\n use syntax_pos::Span;\n-use syntax::expand::allocator::AllocatorKind;\n \n pub struct AllArenas {\n     pub interner: SyncDroplessArena,\n }\n \n impl AllArenas {\n     pub fn new() -> Self {\n-        AllArenas {\n-            interner: SyncDroplessArena::default(),\n-        }\n+        AllArenas { interner: SyncDroplessArena::default() }\n     }\n }\n \n@@ -135,20 +134,20 @@ impl<'tcx> CtxtInterners<'tcx> {\n     /// Interns a type.\n     #[allow(rustc::usage_of_ty_tykind)]\n     #[inline(never)]\n-    fn intern_ty(&self,\n-        kind: TyKind<'tcx>\n-    ) -> Ty<'tcx> {\n-        self.type_.intern(kind, |kind| {\n-            let flags = super::flags::FlagComputation::for_kind(&kind);\n-\n-            let ty_struct = TyS {\n-                kind,\n-                flags: flags.flags,\n-                outer_exclusive_binder: flags.outer_exclusive_binder,\n-            };\n+    fn intern_ty(&self, kind: TyKind<'tcx>) -> Ty<'tcx> {\n+        self.type_\n+            .intern(kind, |kind| {\n+                let flags = super::flags::FlagComputation::for_kind(&kind);\n+\n+                let ty_struct = TyS {\n+                    kind,\n+                    flags: flags.flags,\n+                    outer_exclusive_binder: flags.outer_exclusive_binder,\n+                };\n \n-            Interned(self.arena.alloc(ty_struct))\n-        }).0\n+                Interned(self.arena.alloc(ty_struct))\n+            })\n+            .0\n     }\n }\n \n@@ -192,7 +191,7 @@ pub struct CommonConsts<'tcx> {\n \n pub struct LocalTableInContext<'a, V> {\n     local_id_root: Option<DefId>,\n-    data: &'a ItemLocalMap<V>\n+    data: &'a ItemLocalMap<V>,\n }\n \n /// Validate that the given HirId (respectively its `local_id` part) can be\n@@ -202,17 +201,21 @@ pub struct LocalTableInContext<'a, V> {\n /// would be in a different frame of reference and using its `local_id`\n /// would result in lookup errors, or worse, in silently wrong data being\n /// stored/returned.\n-fn validate_hir_id_for_typeck_tables(local_id_root: Option<DefId>,\n-                                     hir_id: hir::HirId,\n-                                     mut_access: bool) {\n+fn validate_hir_id_for_typeck_tables(\n+    local_id_root: Option<DefId>,\n+    hir_id: hir::HirId,\n+    mut_access: bool,\n+) {\n     if let Some(local_id_root) = local_id_root {\n         if hir_id.owner != local_id_root.index {\n             ty::tls::with(|tcx| {\n-                bug!(\"node {} with HirId::owner {:?} cannot be placed in \\\n+                bug!(\n+                    \"node {} with HirId::owner {:?} cannot be placed in \\\n                         TypeckTables with local_id_root {:?}\",\n-                        tcx.hir().node_to_string(hir_id),\n-                        DefId::local(hir_id.owner),\n-                        local_id_root)\n+                    tcx.hir().node_to_string(hir_id),\n+                    DefId::local(hir_id.owner),\n+                    local_id_root\n+                )\n             });\n         }\n     } else {\n@@ -253,7 +256,7 @@ impl<'a, V> ::std::ops::Index<hir::HirId> for LocalTableInContext<'a, V> {\n \n pub struct LocalTableInContextMut<'a, V> {\n     local_id_root: Option<DefId>,\n-    data: &'a mut ItemLocalMap<V>\n+    data: &'a mut ItemLocalMap<V>,\n }\n \n impl<'a, V> LocalTableInContextMut<'a, V> {\n@@ -464,18 +467,16 @@ impl<'tcx> TypeckTables<'tcx> {\n     pub fn qpath_res(&self, qpath: &hir::QPath, id: hir::HirId) -> Res {\n         match *qpath {\n             hir::QPath::Resolved(_, ref path) => path.res,\n-            hir::QPath::TypeRelative(..) => self.type_dependent_def(id)\n+            hir::QPath::TypeRelative(..) => self\n+                .type_dependent_def(id)\n                 .map_or(Res::Err, |(kind, def_id)| Res::Def(kind, def_id)),\n         }\n     }\n \n     pub fn type_dependent_defs(\n         &self,\n     ) -> LocalTableInContext<'_, Result<(DefKind, DefId), ErrorReported>> {\n-        LocalTableInContext {\n-            local_id_root: self.local_id_root,\n-            data: &self.type_dependent_defs\n-        }\n+        LocalTableInContext { local_id_root: self.local_id_root, data: &self.type_dependent_defs }\n     }\n \n     pub fn type_dependent_def(&self, id: HirId) -> Option<(DefKind, DefId)> {\n@@ -492,61 +493,43 @@ impl<'tcx> TypeckTables<'tcx> {\n     ) -> LocalTableInContextMut<'_, Result<(DefKind, DefId), ErrorReported>> {\n         LocalTableInContextMut {\n             local_id_root: self.local_id_root,\n-            data: &mut self.type_dependent_defs\n+            data: &mut self.type_dependent_defs,\n         }\n     }\n \n     pub fn field_indices(&self) -> LocalTableInContext<'_, usize> {\n-        LocalTableInContext {\n-            local_id_root: self.local_id_root,\n-            data: &self.field_indices\n-        }\n+        LocalTableInContext { local_id_root: self.local_id_root, data: &self.field_indices }\n     }\n \n     pub fn field_indices_mut(&mut self) -> LocalTableInContextMut<'_, usize> {\n-        LocalTableInContextMut {\n-            local_id_root: self.local_id_root,\n-            data: &mut self.field_indices\n-        }\n+        LocalTableInContextMut { local_id_root: self.local_id_root, data: &mut self.field_indices }\n     }\n \n-    pub fn user_provided_types(\n-        &self\n-    ) -> LocalTableInContext<'_, CanonicalUserType<'tcx>> {\n-        LocalTableInContext {\n-            local_id_root: self.local_id_root,\n-            data: &self.user_provided_types\n-        }\n+    pub fn user_provided_types(&self) -> LocalTableInContext<'_, CanonicalUserType<'tcx>> {\n+        LocalTableInContext { local_id_root: self.local_id_root, data: &self.user_provided_types }\n     }\n \n     pub fn user_provided_types_mut(\n-        &mut self\n+        &mut self,\n     ) -> LocalTableInContextMut<'_, CanonicalUserType<'tcx>> {\n         LocalTableInContextMut {\n             local_id_root: self.local_id_root,\n-            data: &mut self.user_provided_types\n+            data: &mut self.user_provided_types,\n         }\n     }\n \n     pub fn node_types(&self) -> LocalTableInContext<'_, Ty<'tcx>> {\n-        LocalTableInContext {\n-            local_id_root: self.local_id_root,\n-            data: &self.node_types\n-        }\n+        LocalTableInContext { local_id_root: self.local_id_root, data: &self.node_types }\n     }\n \n     pub fn node_types_mut(&mut self) -> LocalTableInContextMut<'_, Ty<'tcx>> {\n-        LocalTableInContextMut {\n-            local_id_root: self.local_id_root,\n-            data: &mut self.node_types\n-        }\n+        LocalTableInContextMut { local_id_root: self.local_id_root, data: &mut self.node_types }\n     }\n \n     pub fn node_type(&self, id: hir::HirId) -> Ty<'tcx> {\n-        self.node_type_opt(id).unwrap_or_else(||\n-            bug!(\"node_type: no type for node `{}`\",\n-                 tls::with(|tcx| tcx.hir().node_to_string(id)))\n-        )\n+        self.node_type_opt(id).unwrap_or_else(|| {\n+            bug!(\"node_type: no type for node `{}`\", tls::with(|tcx| tcx.hir().node_to_string(id)))\n+        })\n     }\n \n     pub fn node_type_opt(&self, id: hir::HirId) -> Option<Ty<'tcx>> {\n@@ -555,10 +538,7 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     pub fn node_substs_mut(&mut self) -> LocalTableInContextMut<'_, SubstsRef<'tcx>> {\n-        LocalTableInContextMut {\n-            local_id_root: self.local_id_root,\n-            data: &mut self.node_substs\n-        }\n+        LocalTableInContextMut { local_id_root: self.local_id_root, data: &mut self.node_substs }\n     }\n \n     pub fn node_substs(&self, id: hir::HirId) -> SubstsRef<'tcx> {\n@@ -600,39 +580,28 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     pub fn adjustments(&self) -> LocalTableInContext<'_, Vec<ty::adjustment::Adjustment<'tcx>>> {\n-        LocalTableInContext {\n-            local_id_root: self.local_id_root,\n-            data: &self.adjustments\n-        }\n+        LocalTableInContext { local_id_root: self.local_id_root, data: &self.adjustments }\n     }\n \n-    pub fn adjustments_mut(&mut self)\n-                           -> LocalTableInContextMut<'_, Vec<ty::adjustment::Adjustment<'tcx>>> {\n-        LocalTableInContextMut {\n-            local_id_root: self.local_id_root,\n-            data: &mut self.adjustments\n-        }\n+    pub fn adjustments_mut(\n+        &mut self,\n+    ) -> LocalTableInContextMut<'_, Vec<ty::adjustment::Adjustment<'tcx>>> {\n+        LocalTableInContextMut { local_id_root: self.local_id_root, data: &mut self.adjustments }\n     }\n \n-    pub fn expr_adjustments(&self, expr: &hir::Expr)\n-                            -> &[ty::adjustment::Adjustment<'tcx>] {\n+    pub fn expr_adjustments(&self, expr: &hir::Expr) -> &[ty::adjustment::Adjustment<'tcx>] {\n         validate_hir_id_for_typeck_tables(self.local_id_root, expr.hir_id, false);\n         self.adjustments.get(&expr.hir_id.local_id).map_or(&[], |a| &a[..])\n     }\n \n     /// Returns the type of `expr`, considering any `Adjustment`\n     /// entry recorded for that expression.\n     pub fn expr_ty_adjusted(&self, expr: &hir::Expr) -> Ty<'tcx> {\n-        self.expr_adjustments(expr)\n-            .last()\n-            .map_or_else(|| self.expr_ty(expr), |adj| adj.target)\n+        self.expr_adjustments(expr).last().map_or_else(|| self.expr_ty(expr), |adj| adj.target)\n     }\n \n     pub fn expr_ty_adjusted_opt(&self, expr: &hir::Expr) -> Option<Ty<'tcx>> {\n-        self.expr_adjustments(expr)\n-            .last()\n-            .map(|adj| adj.target)\n-            .or_else(|| self.expr_ty_opt(expr))\n+        self.expr_adjustments(expr).last().map(|adj| adj.target).or_else(|| self.expr_ty_opt(expr))\n     }\n \n     pub fn is_method_call(&self, expr: &hir::Expr) -> bool {\n@@ -644,7 +613,7 @@ impl<'tcx> TypeckTables<'tcx> {\n \n         match self.type_dependent_defs().get(expr.hir_id) {\n             Some(Ok((DefKind::Method, _))) => true,\n-            _ => false\n+            _ => false,\n         }\n     }\n \n@@ -656,29 +625,21 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     pub fn pat_binding_modes(&self) -> LocalTableInContext<'_, BindingMode> {\n-        LocalTableInContext {\n-            local_id_root: self.local_id_root,\n-            data: &self.pat_binding_modes\n-        }\n+        LocalTableInContext { local_id_root: self.local_id_root, data: &self.pat_binding_modes }\n     }\n \n-    pub fn pat_binding_modes_mut(&mut self)\n-                           -> LocalTableInContextMut<'_, BindingMode> {\n+    pub fn pat_binding_modes_mut(&mut self) -> LocalTableInContextMut<'_, BindingMode> {\n         LocalTableInContextMut {\n             local_id_root: self.local_id_root,\n-            data: &mut self.pat_binding_modes\n+            data: &mut self.pat_binding_modes,\n         }\n     }\n \n     pub fn pat_adjustments(&self) -> LocalTableInContext<'_, Vec<Ty<'tcx>>> {\n-        LocalTableInContext {\n-            local_id_root: self.local_id_root,\n-            data: &self.pat_adjustments,\n-        }\n+        LocalTableInContext { local_id_root: self.local_id_root, data: &self.pat_adjustments }\n     }\n \n-    pub fn pat_adjustments_mut(&mut self)\n-                               -> LocalTableInContextMut<'_, Vec<Ty<'tcx>>> {\n+    pub fn pat_adjustments_mut(&mut self) -> LocalTableInContextMut<'_, Vec<Ty<'tcx>>> {\n         LocalTableInContextMut {\n             local_id_root: self.local_id_root,\n             data: &mut self.pat_adjustments,\n@@ -690,44 +651,35 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     pub fn closure_kind_origins(&self) -> LocalTableInContext<'_, (Span, ast::Name)> {\n-        LocalTableInContext {\n-            local_id_root: self.local_id_root,\n-            data: &self.closure_kind_origins\n-        }\n+        LocalTableInContext { local_id_root: self.local_id_root, data: &self.closure_kind_origins }\n     }\n \n     pub fn closure_kind_origins_mut(&mut self) -> LocalTableInContextMut<'_, (Span, ast::Name)> {\n         LocalTableInContextMut {\n             local_id_root: self.local_id_root,\n-            data: &mut self.closure_kind_origins\n+            data: &mut self.closure_kind_origins,\n         }\n     }\n \n     pub fn liberated_fn_sigs(&self) -> LocalTableInContext<'_, ty::FnSig<'tcx>> {\n-        LocalTableInContext {\n-            local_id_root: self.local_id_root,\n-            data: &self.liberated_fn_sigs\n-        }\n+        LocalTableInContext { local_id_root: self.local_id_root, data: &self.liberated_fn_sigs }\n     }\n \n     pub fn liberated_fn_sigs_mut(&mut self) -> LocalTableInContextMut<'_, ty::FnSig<'tcx>> {\n         LocalTableInContextMut {\n             local_id_root: self.local_id_root,\n-            data: &mut self.liberated_fn_sigs\n+            data: &mut self.liberated_fn_sigs,\n         }\n     }\n \n     pub fn fru_field_types(&self) -> LocalTableInContext<'_, Vec<Ty<'tcx>>> {\n-        LocalTableInContext {\n-            local_id_root: self.local_id_root,\n-            data: &self.fru_field_types\n-        }\n+        LocalTableInContext { local_id_root: self.local_id_root, data: &self.fru_field_types }\n     }\n \n     pub fn fru_field_types_mut(&mut self) -> LocalTableInContextMut<'_, Vec<Ty<'tcx>>> {\n         LocalTableInContextMut {\n             local_id_root: self.local_id_root,\n-            data: &mut self.fru_field_types\n+            data: &mut self.fru_field_types,\n         }\n     }\n \n@@ -743,7 +695,6 @@ impl<'tcx> TypeckTables<'tcx> {\n     pub fn coercion_casts(&self) -> &ItemLocalSet {\n         &self.coercion_casts\n     }\n-\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckTables<'tcx> {\n@@ -772,7 +723,6 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckTables<'tcx> {\n             ref concrete_opaque_types,\n             ref upvar_list,\n             ref generator_interior_types,\n-\n         } = *self;\n \n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n@@ -786,25 +736,19 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckTables<'tcx> {\n             pat_binding_modes.hash_stable(hcx, hasher);\n             pat_adjustments.hash_stable(hcx, hasher);\n             hash_stable_hashmap(hcx, hasher, upvar_capture_map, |up_var_id, hcx| {\n-                let ty::UpvarId {\n-                    var_path,\n-                    closure_expr_id\n-                } = *up_var_id;\n-\n-                let local_id_root =\n-                    local_id_root.expect(\"trying to hash invalid TypeckTables\");\n-\n-                let var_owner_def_id = DefId {\n-                    krate: local_id_root.krate,\n-                    index: var_path.hir_id.owner,\n-                };\n-                let closure_def_id = DefId {\n-                    krate: local_id_root.krate,\n-                    index: closure_expr_id.to_def_id().index,\n-                };\n-                (hcx.def_path_hash(var_owner_def_id),\n-                 var_path.hir_id.local_id,\n-                 hcx.def_path_hash(closure_def_id))\n+                let ty::UpvarId { var_path, closure_expr_id } = *up_var_id;\n+\n+                let local_id_root = local_id_root.expect(\"trying to hash invalid TypeckTables\");\n+\n+                let var_owner_def_id =\n+                    DefId { krate: local_id_root.krate, index: var_path.hir_id.owner };\n+                let closure_def_id =\n+                    DefId { krate: local_id_root.krate, index: closure_expr_id.to_def_id().index };\n+                (\n+                    hcx.def_path_hash(var_owner_def_id),\n+                    var_path.hir_id.local_id,\n+                    hcx.def_path_hash(closure_def_id),\n+                )\n             });\n \n             closure_kind_origins.hash_stable(hcx, hasher);\n@@ -884,7 +828,7 @@ impl CanonicalUserType<'tcx> {\n                         },\n                     }\n                 })\n-            },\n+            }\n         }\n     }\n }\n@@ -926,10 +870,7 @@ impl<'tcx> CommonTypes<'tcx> {\n             u128: mk(Uint(ast::UintTy::U128)),\n             f32: mk(Float(ast::FloatTy::F32)),\n             f64: mk(Float(ast::FloatTy::F64)),\n-            self_param: mk(ty::Param(ty::ParamTy {\n-                index: 0,\n-                name: kw::SelfUpper,\n-            })),\n+            self_param: mk(ty::Param(ty::ParamTy { index: 0, name: kw::SelfUpper })),\n \n             trait_object_dummy_self: mk(Infer(ty::FreshTy(0))),\n         }\n@@ -938,11 +879,7 @@ impl<'tcx> CommonTypes<'tcx> {\n \n impl<'tcx> CommonLifetimes<'tcx> {\n     fn new(interners: &CtxtInterners<'tcx>) -> CommonLifetimes<'tcx> {\n-        let mk = |r| {\n-            interners.region.intern(r, |r| {\n-                Interned(interners.arena.alloc(r))\n-            }).0\n-        };\n+        let mk = |r| interners.region.intern(r, |r| Interned(interners.arena.alloc(r))).0;\n \n         CommonLifetimes {\n             re_empty: mk(RegionKind::ReEmpty),\n@@ -954,11 +891,7 @@ impl<'tcx> CommonLifetimes<'tcx> {\n \n impl<'tcx> CommonConsts<'tcx> {\n     fn new(interners: &CtxtInterners<'tcx>, types: &CommonTypes<'tcx>) -> CommonConsts<'tcx> {\n-        let mk_const = |c| {\n-            interners.const_.intern(c, |c| {\n-                Interned(interners.arena.alloc(c))\n-            }).0\n-        };\n+        let mk_const = |c| interners.const_.intern(c, |c| Interned(interners.arena.alloc(c))).0;\n \n         CommonConsts {\n             err: mk_const(ty::Const {\n@@ -1030,9 +963,7 @@ pub struct GlobalCtxt<'tcx> {\n \n     /// Map indicating what traits are in scope for places where this\n     /// is relevant; generated by resolve.\n-    trait_map: FxHashMap<DefIndex,\n-                         FxHashMap<ItemLocalId,\n-                                   StableVec<TraitCandidate>>>,\n+    trait_map: FxHashMap<DefIndex, FxHashMap<ItemLocalId, StableVec<TraitCandidate>>>,\n \n     /// Export map produced by name resolution.\n     export_map: FxHashMap<DefId, Vec<Export<hir::HirId>>>,\n@@ -1099,13 +1030,17 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.arena.alloc(Steal::new(mir))\n     }\n \n-    pub fn alloc_steal_promoted(self, promoted: IndexVec<Promoted, BodyAndCache<'tcx>>) ->\n-        &'tcx Steal<IndexVec<Promoted, BodyAndCache<'tcx>>> {\n+    pub fn alloc_steal_promoted(\n+        self,\n+        promoted: IndexVec<Promoted, BodyAndCache<'tcx>>,\n+    ) -> &'tcx Steal<IndexVec<Promoted, BodyAndCache<'tcx>>> {\n         self.arena.alloc(Steal::new(promoted))\n     }\n \n-    pub fn intern_promoted(self, promoted: IndexVec<Promoted, BodyAndCache<'tcx>>) ->\n-        &'tcx IndexVec<Promoted, BodyAndCache<'tcx>> {\n+    pub fn intern_promoted(\n+        self,\n+        promoted: IndexVec<Promoted, BodyAndCache<'tcx>>,\n+    ) -> &'tcx IndexVec<Promoted, BodyAndCache<'tcx>> {\n         self.arena.alloc(promoted)\n     }\n \n@@ -1121,9 +1056,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn intern_const_alloc(self, alloc: Allocation) -> &'tcx Allocation {\n-        self.allocation_interner.intern(alloc, |alloc| {\n-            self.arena.alloc(alloc)\n-        })\n+        self.allocation_interner.intern(alloc, |alloc| self.arena.alloc(alloc))\n     }\n \n     /// Allocates a read-only byte or string literal for `mir::interpret`.\n@@ -1135,21 +1068,15 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn intern_stability(self, stab: attr::Stability) -> &'tcx attr::Stability {\n-        self.stability_interner.intern(stab, |stab| {\n-            self.arena.alloc(stab)\n-        })\n+        self.stability_interner.intern(stab, |stab| self.arena.alloc(stab))\n     }\n \n     pub fn intern_const_stability(self, stab: attr::ConstStability) -> &'tcx attr::ConstStability {\n-        self.const_stability_interner.intern(stab, |stab| {\n-            self.arena.alloc(stab)\n-        })\n+        self.const_stability_interner.intern(stab, |stab| self.arena.alloc(stab))\n     }\n \n     pub fn intern_layout(self, layout: LayoutDetails) -> &'tcx LayoutDetails {\n-        self.layout_interner.intern(layout, |layout| {\n-            self.arena.alloc(layout)\n-        })\n+        self.layout_interner.intern(layout, |layout| self.arena.alloc(layout))\n     }\n \n     /// Returns a range of the start/end indices specified with the\n@@ -1169,8 +1096,10 @@ impl<'tcx> TyCtxt<'tcx> {\n             }\n             span_bug!(attr.span, \"no arguments to `rustc_layout_scalar_valid_range` attribute\");\n         };\n-        (get(sym::rustc_layout_scalar_valid_range_start),\n-         get(sym::rustc_layout_scalar_valid_range_end))\n+        (\n+            get(sym::rustc_layout_scalar_valid_range_start),\n+            get(sym::rustc_layout_scalar_valid_range_end),\n+        )\n     }\n \n     pub fn lift<T: ?Sized + Lift<'tcx>>(self, value: &T) -> Option<T::Lifted> {\n@@ -1218,10 +1147,8 @@ impl<'tcx> TyCtxt<'tcx> {\n             // re-allocate when populating it.\n             let capacity = def_path_tables.clone().map(|(_, t)| t.size()).sum::<usize>();\n \n-            let mut map: FxHashMap<_, _> = FxHashMap::with_capacity_and_hasher(\n-                capacity,\n-                ::std::default::Default::default()\n-            );\n+            let mut map: FxHashMap<_, _> =\n+                FxHashMap::with_capacity_and_hasher(capacity, ::std::default::Default::default());\n \n             for (cnum, def_path_table) in def_path_tables {\n                 def_path_table.add_def_path_hashes_to(cnum, &mut map);\n@@ -1252,33 +1179,34 @@ impl<'tcx> TyCtxt<'tcx> {\n             consts: common_consts,\n             extern_crate_map: resolutions.extern_crate_map,\n             trait_map,\n-            export_map: resolutions.export_map.into_iter().map(|(k, v)| {\n-                let exports: Vec<_> = v.into_iter().map(|e| {\n-                    e.map_id(|id| hir.node_to_hir_id(id))\n-                }).collect();\n-                (k, exports)\n-            }).collect(),\n-            maybe_unused_trait_imports:\n-                resolutions.maybe_unused_trait_imports\n-                    .into_iter()\n-                    .map(|id| hir.local_def_id_from_node_id(id))\n-                    .collect(),\n-            maybe_unused_extern_crates:\n-                resolutions.maybe_unused_extern_crates\n-                    .into_iter()\n-                    .map(|(id, sp)| (hir.local_def_id_from_node_id(id), sp))\n-                    .collect(),\n-            glob_map: resolutions.glob_map.into_iter().map(|(id, names)| {\n-                (hir.local_def_id_from_node_id(id), names)\n-            }).collect(),\n+            export_map: resolutions\n+                .export_map\n+                .into_iter()\n+                .map(|(k, v)| {\n+                    let exports: Vec<_> =\n+                        v.into_iter().map(|e| e.map_id(|id| hir.node_to_hir_id(id))).collect();\n+                    (k, exports)\n+                })\n+                .collect(),\n+            maybe_unused_trait_imports: resolutions\n+                .maybe_unused_trait_imports\n+                .into_iter()\n+                .map(|id| hir.local_def_id_from_node_id(id))\n+                .collect(),\n+            maybe_unused_extern_crates: resolutions\n+                .maybe_unused_extern_crates\n+                .into_iter()\n+                .map(|(id, sp)| (hir.local_def_id_from_node_id(id), sp))\n+                .collect(),\n+            glob_map: resolutions\n+                .glob_map\n+                .into_iter()\n+                .map(|(id, names)| (hir.local_def_id_from_node_id(id), names))\n+                .collect(),\n             extern_prelude: resolutions.extern_prelude,\n             hir_map: hir,\n             def_path_hash_to_def_id,\n-            queries: query::Queries::new(\n-                providers,\n-                extern_providers,\n-                on_disk_query_result_cache,\n-            ),\n+            queries: query::Queries::new(providers, extern_providers, on_disk_query_result_cache),\n             rcache: Default::default(),\n             selection_cache: Default::default(),\n             evaluation_cache: Default::default(),\n@@ -1335,11 +1263,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn def_key(self, id: DefId) -> hir_map::DefKey {\n-        if id.is_local() {\n-            self.hir().def_key(id)\n-        } else {\n-            self.cstore.def_key(id)\n-        }\n+        if id.is_local() { self.hir().def_key(id) } else { self.cstore.def_key(id) }\n     }\n \n     /// Converts a `DefId` into its fully expanded `DefPath` (every\n@@ -1348,21 +1272,13 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Note that if `id` is not local to this crate, the result will\n     ///  be a non-local `DefPath`.\n     pub fn def_path(self, id: DefId) -> hir_map::DefPath {\n-        if id.is_local() {\n-            self.hir().def_path(id)\n-        } else {\n-            self.cstore.def_path(id)\n-        }\n+        if id.is_local() { self.hir().def_path(id) } else { self.cstore.def_path(id) }\n     }\n \n     /// Returns whether or not the crate with CrateNum 'cnum'\n     /// is marked as a private dependency\n     pub fn is_private_dep(self, cnum: CrateNum) -> bool {\n-        if cnum == LOCAL_CRATE {\n-            false\n-        } else {\n-            self.cstore.crate_is_private_dep_untracked(cnum)\n-        }\n+        if cnum == LOCAL_CRATE { false } else { self.cstore.crate_is_private_dep_untracked(cnum) }\n     }\n \n     #[inline]\n@@ -1380,26 +1296,29 @@ impl<'tcx> TyCtxt<'tcx> {\n         // statements within the query system and we'd run into endless\n         // recursion otherwise.\n         let (crate_name, crate_disambiguator) = if def_id.is_local() {\n-            (self.crate_name.clone(),\n-             self.sess.local_crate_disambiguator())\n+            (self.crate_name.clone(), self.sess.local_crate_disambiguator())\n         } else {\n-            (self.cstore.crate_name_untracked(def_id.krate),\n-             self.cstore.crate_disambiguator_untracked(def_id.krate))\n+            (\n+                self.cstore.crate_name_untracked(def_id.krate),\n+                self.cstore.crate_disambiguator_untracked(def_id.krate),\n+            )\n         };\n \n-        format!(\"{}[{}]{}\",\n-                crate_name,\n-                // Don't print the whole crate disambiguator. That's just\n-                // annoying in debug output.\n-                &(crate_disambiguator.to_fingerprint().to_hex())[..4],\n-                self.def_path(def_id).to_string_no_crate())\n+        format!(\n+            \"{}[{}]{}\",\n+            crate_name,\n+            // Don't print the whole crate disambiguator. That's just\n+            // annoying in debug output.\n+            &(crate_disambiguator.to_fingerprint().to_hex())[..4],\n+            self.def_path(def_id).to_string_no_crate()\n+        )\n     }\n \n     pub fn metadata_encoding_version(self) -> Vec<u8> {\n         self.cstore.metadata_encoding_version().to_vec()\n     }\n \n-    pub fn encode_metadata(self)-> EncodedMetadata {\n+    pub fn encode_metadata(self) -> EncodedMetadata {\n         let _prof_timer = self.prof.generic_activity(\"generate_crate_metadata\");\n         self.cstore.encode_metadata(self)\n     }\n@@ -1414,10 +1333,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn create_stable_hashing_context(self) -> StableHashingContext<'tcx> {\n         let krate = self.gcx.hir_map.forest.untracked_krate();\n \n-        StableHashingContext::new(self.sess,\n-                                  krate,\n-                                  self.hir().definitions(),\n-                                  &*self.cstore)\n+        StableHashingContext::new(self.sess, krate, self.hir().definitions(), &*self.cstore)\n     }\n \n     // This method makes sure that we have a DepNode and a Fingerprint for\n@@ -1431,19 +1347,19 @@ impl<'tcx> TyCtxt<'tcx> {\n         for cnum in self.cstore.crates_untracked() {\n             let dep_node = DepNode::new(self, DepConstructor::CrateMetadata(cnum));\n             let crate_hash = self.cstore.crate_hash_untracked(cnum);\n-            self.dep_graph.with_task(dep_node,\n-                                     self,\n-                                     crate_hash,\n-                                     |_, x| x, // No transformation needed\n-                                     dep_graph::hash_result,\n+            self.dep_graph.with_task(\n+                dep_node,\n+                self,\n+                crate_hash,\n+                |_, x| x, // No transformation needed\n+                dep_graph::hash_result,\n             );\n         }\n     }\n \n-    pub fn serialize_query_result_cache<E>(self,\n-                                           encoder: &mut E)\n-                                           -> Result<(), E::Error>\n-        where E: ty::codec::TyEncoder\n+    pub fn serialize_query_result_cache<E>(self, encoder: &mut E) -> Result<(), E::Error>\n+    where\n+        E: ty::codec::TyEncoder,\n     {\n         self.queries.on_disk_cache.serialize(self, encoder)\n     }\n@@ -1492,7 +1408,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         //\n         // * Otherwise, use the behavior requested via `-Z borrowck=...`\n \n-        if self.features().nll { return BorrowckMode::Mir; }\n+        if self.features().nll {\n+            return BorrowckMode::Mir;\n+        }\n \n         self.sess.opts.borrowck_mode\n     }\n@@ -1503,18 +1421,18 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         self.sess.crate_types.borrow().iter().any(|crate_type| {\n             match crate_type {\n-                CrateType::Executable |\n-                CrateType::Staticlib  |\n-                CrateType::ProcMacro  |\n-                CrateType::Cdylib     => false,\n+                CrateType::Executable\n+                | CrateType::Staticlib\n+                | CrateType::ProcMacro\n+                | CrateType::Cdylib => false,\n \n                 // FIXME rust-lang/rust#64319, rust-lang/rust#64872:\n                 // We want to block export of generics from dylibs,\n                 // but we must fix rust-lang/rust#65890 before we can\n                 // do that robustly.\n-                CrateType::Dylib      => true,\n+                CrateType::Dylib => true,\n \n-                CrateType::Rlib       => true,\n+                CrateType::Rlib => true,\n             }\n         })\n     }\n@@ -1523,16 +1441,13 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn is_suitable_region(&self, region: Region<'tcx>) -> Option<FreeRegionInfo> {\n         let (suitable_region_binding_scope, bound_region) = match *region {\n             ty::ReFree(ref free_region) => (free_region.scope, free_region.bound_region),\n-            ty::ReEarlyBound(ref ebr) => (\n-                self.parent(ebr.def_id).unwrap(),\n-                ty::BoundRegion::BrNamed(ebr.def_id, ebr.name),\n-            ),\n+            ty::ReEarlyBound(ref ebr) => {\n+                (self.parent(ebr.def_id).unwrap(), ty::BoundRegion::BrNamed(ebr.def_id, ebr.name))\n+            }\n             _ => return None, // not a free region\n         };\n \n-        let hir_id = self.hir()\n-            .as_local_hir_id(suitable_region_binding_scope)\n-            .unwrap();\n+        let hir_id = self.hir().as_local_hir_id(suitable_region_binding_scope).unwrap();\n         let is_impl_item = match self.hir().find(hir_id) {\n             Some(Node::Item(..)) | Some(Node::TraitItem(..)) => false,\n             Some(Node::ImplItem(..)) => {\n@@ -1548,10 +1463,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         });\n     }\n \n-    pub fn return_type_impl_trait(\n-        &self,\n-        scope_def_id: DefId,\n-    ) -> Option<(Ty<'tcx>, Span)> {\n+    pub fn return_type_impl_trait(&self, scope_def_id: DefId) -> Option<(Ty<'tcx>, Span)> {\n         // HACK: `type_of_def_id()` will fail on these (#55796), so return `None`.\n         let hir_id = self.hir().as_local_hir_id(scope_def_id).unwrap();\n         match self.hir().get(hir_id) {\n@@ -1578,18 +1490,13 @@ impl<'tcx> TyCtxt<'tcx> {\n                     None\n                 }\n             }\n-            _ => None\n+            _ => None,\n         }\n     }\n \n     // Checks if the bound region is in Impl Item.\n-    pub fn is_bound_region_in_impl_item(\n-        &self,\n-        suitable_region_binding_scope: DefId,\n-    ) -> bool {\n-        let container_id = self.associated_item(suitable_region_binding_scope)\n-            .container\n-            .id();\n+    pub fn is_bound_region_in_impl_item(&self, suitable_region_binding_scope: DefId) -> bool {\n+        let container_id = self.associated_item(suitable_region_binding_scope).container.id();\n         if self.impl_trait_ref(container_id).is_some() {\n             // For now, we do not try to target impls of traits. This is\n             // because this message is going to suggest that the user\n@@ -1626,9 +1533,7 @@ impl<'tcx> GlobalCtxt<'tcx> {\n     where\n         F: FnOnce(TyCtxt<'tcx>) -> R,\n     {\n-        let tcx = TyCtxt {\n-            gcx: self,\n-        };\n+        let tcx = TyCtxt { gcx: self };\n         ty::tls::with_related_context(tcx, |icx| {\n             let new_icx = ty::tls::ImplicitCtxt {\n                 tcx,\n@@ -1637,9 +1542,7 @@ impl<'tcx> GlobalCtxt<'tcx> {\n                 layout_depth: icx.layout_depth,\n                 task_deps: icx.task_deps,\n             };\n-            ty::tls::enter_context(&new_icx, |_| {\n-                f(tcx)\n-            })\n+            ty::tls::enter_context(&new_icx, |_| f(tcx))\n         })\n     }\n }\n@@ -1669,64 +1572,64 @@ pub trait Lift<'tcx>: fmt::Debug {\n macro_rules! nop_lift {\n     ($ty:ty => $lifted:ty) => {\n         impl<'a, 'tcx> Lift<'tcx> for $ty {\n-                    type Lifted = $lifted;\n-                    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-                        if tcx.interners.arena.in_arena(*self as *const _) {\n-                            Some(unsafe { mem::transmute(*self) })\n-                        } else {\n-                            None\n-                        }\n-                    }\n+            type Lifted = $lifted;\n+            fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+                if tcx.interners.arena.in_arena(*self as *const _) {\n+                    Some(unsafe { mem::transmute(*self) })\n+                } else {\n+                    None\n                 }\n+            }\n+        }\n     };\n }\n \n macro_rules! nop_list_lift {\n     ($ty:ty => $lifted:ty) => {\n         impl<'a, 'tcx> Lift<'tcx> for &'a List<$ty> {\n-                    type Lifted = &'tcx List<$lifted>;\n-                    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-                        if self.is_empty() {\n-                            return Some(List::empty());\n-                        }\n-                        if tcx.interners.arena.in_arena(*self as *const _) {\n-                            Some(unsafe { mem::transmute(*self) })\n-                        } else {\n-                            None\n-                        }\n-                    }\n+            type Lifted = &'tcx List<$lifted>;\n+            fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+                if self.is_empty() {\n+                    return Some(List::empty());\n                 }\n+                if tcx.interners.arena.in_arena(*self as *const _) {\n+                    Some(unsafe { mem::transmute(*self) })\n+                } else {\n+                    None\n+                }\n+            }\n+        }\n     };\n }\n \n-nop_lift!{Ty<'a> => Ty<'tcx>}\n-nop_lift!{Region<'a> => Region<'tcx>}\n-nop_lift!{Goal<'a> => Goal<'tcx>}\n-nop_lift!{&'a Const<'a> => &'tcx Const<'tcx>}\n+nop_lift! {Ty<'a> => Ty<'tcx>}\n+nop_lift! {Region<'a> => Region<'tcx>}\n+nop_lift! {Goal<'a> => Goal<'tcx>}\n+nop_lift! {&'a Const<'a> => &'tcx Const<'tcx>}\n \n-nop_list_lift!{Goal<'a> => Goal<'tcx>}\n-nop_list_lift!{Clause<'a> => Clause<'tcx>}\n-nop_list_lift!{Ty<'a> => Ty<'tcx>}\n-nop_list_lift!{ExistentialPredicate<'a> => ExistentialPredicate<'tcx>}\n-nop_list_lift!{Predicate<'a> => Predicate<'tcx>}\n-nop_list_lift!{CanonicalVarInfo => CanonicalVarInfo}\n-nop_list_lift!{ProjectionKind => ProjectionKind}\n+nop_list_lift! {Goal<'a> => Goal<'tcx>}\n+nop_list_lift! {Clause<'a> => Clause<'tcx>}\n+nop_list_lift! {Ty<'a> => Ty<'tcx>}\n+nop_list_lift! {ExistentialPredicate<'a> => ExistentialPredicate<'tcx>}\n+nop_list_lift! {Predicate<'a> => Predicate<'tcx>}\n+nop_list_lift! {CanonicalVarInfo => CanonicalVarInfo}\n+nop_list_lift! {ProjectionKind => ProjectionKind}\n \n // This is the impl for `&'a InternalSubsts<'a>`.\n-nop_list_lift!{GenericArg<'a> => GenericArg<'tcx>}\n+nop_list_lift! {GenericArg<'a> => GenericArg<'tcx>}\n \n pub mod tls {\n-    use super::{GlobalCtxt, TyCtxt, ptr_eq};\n+    use super::{ptr_eq, GlobalCtxt, TyCtxt};\n \n-    use std::fmt;\n-    use std::mem;\n-    use syntax_pos;\n+    use crate::dep_graph::TaskDeps;\n     use crate::ty::query;\n     use errors::{Diagnostic, TRACK_DIAGNOSTICS};\n-    use rustc_data_structures::OnDrop;\n-    use rustc_data_structures::sync::{self, Lrc, Lock};\n+    use rustc_data_structures::sync::{self, Lock, Lrc};\n     use rustc_data_structures::thin_vec::ThinVec;\n-    use crate::dep_graph::TaskDeps;\n+    use rustc_data_structures::OnDrop;\n+    use std::fmt;\n+    use std::mem;\n+    use syntax_pos;\n \n     #[cfg(not(parallel_compiler))]\n     use std::cell::Cell;\n@@ -1830,7 +1733,8 @@ pub mod tls {\n \n     /// Sets up the callbacks from libsyntax on the current thread.\n     pub fn with_thread_locals<F, R>(f: F) -> R\n-        where F: FnOnce() -> R\n+    where\n+        F: FnOnce() -> R,\n     {\n         syntax_pos::SPAN_DEBUG.with(|span_dbg| {\n             let original_span_debug = span_dbg.get();\n@@ -1859,9 +1763,7 @@ pub mod tls {\n     where\n         F: FnOnce(&ImplicitCtxt<'a, 'tcx>) -> R,\n     {\n-        set_tlv(context as *const _ as usize, || {\n-            f(&context)\n-        })\n+        set_tlv(context as *const _ as usize, || f(&context))\n     }\n \n     /// Enters `GlobalCtxt` by setting up libsyntax callbacks and\n@@ -1881,19 +1783,10 @@ pub mod tls {\n             GCX_PTR.with(|lock| *lock.lock() = 0);\n         });\n \n-        let tcx = TyCtxt {\n-            gcx,\n-        };\n-        let icx = ImplicitCtxt {\n-            tcx,\n-            query: None,\n-            diagnostics: None,\n-            layout_depth: 0,\n-            task_deps: None,\n-        };\n-        enter_context(&icx, |_| {\n-            f(tcx)\n-        })\n+        let tcx = TyCtxt { gcx };\n+        let icx =\n+            ImplicitCtxt { tcx, query: None, diagnostics: None, layout_depth: 0, task_deps: None };\n+        enter_context(&icx, |_| f(tcx))\n     }\n \n     scoped_thread_local! {\n@@ -1911,16 +1804,9 @@ pub mod tls {\n         let gcx = GCX_PTR.with(|lock| *lock.lock());\n         assert!(gcx != 0);\n         let gcx = &*(gcx as *const GlobalCtxt<'_>);\n-        let tcx = TyCtxt {\n-            gcx,\n-        };\n-        let icx = ImplicitCtxt {\n-            query: None,\n-            diagnostics: None,\n-            tcx,\n-            layout_depth: 0,\n-            task_deps: None,\n-        };\n+        let tcx = TyCtxt { gcx };\n+        let icx =\n+            ImplicitCtxt { query: None, diagnostics: None, tcx, layout_depth: 0, task_deps: None };\n         enter_context(&icx, |_| f(tcx))\n     }\n \n@@ -1962,12 +1848,10 @@ pub mod tls {\n     where\n         F: FnOnce(&ImplicitCtxt<'_, 'tcx>) -> R,\n     {\n-        with_context(|context| {\n-            unsafe {\n-                assert!(ptr_eq(context.tcx.gcx, tcx.gcx));\n-                let context: &ImplicitCtxt<'_, '_> = mem::transmute(context);\n-                f(context)\n-            }\n+        with_context(|context| unsafe {\n+            assert!(ptr_eq(context.tcx.gcx, tcx.gcx));\n+            let context: &ImplicitCtxt<'_, '_> = mem::transmute(context);\n+            f(context)\n         })\n     }\n \n@@ -2069,9 +1953,27 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn print_debug_stats(self) {\n         sty_debug_print!(\n             self,\n-            Adt, Array, Slice, RawPtr, Ref, FnDef, FnPtr, Placeholder,\n-            Generator, GeneratorWitness, Dynamic, Closure, Tuple, Bound,\n-            Param, Infer, UnnormalizedProjection, Projection, Opaque, Foreign);\n+            Adt,\n+            Array,\n+            Slice,\n+            RawPtr,\n+            Ref,\n+            FnDef,\n+            FnPtr,\n+            Placeholder,\n+            Generator,\n+            GeneratorWitness,\n+            Dynamic,\n+            Closure,\n+            Tuple,\n+            Bound,\n+            Param,\n+            Infer,\n+            UnnormalizedProjection,\n+            Projection,\n+            Opaque,\n+            Foreign\n+        );\n \n         println!(\"InternalSubsts interner: #{}\", self.interners.substs.len());\n         println!(\"Region interner: #{}\", self.interners.region.len());\n@@ -2082,16 +1984,15 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n }\n \n-\n /// An entry in an interner.\n struct Interned<'tcx, T: ?Sized>(&'tcx T);\n \n-impl<'tcx, T: 'tcx+?Sized> Clone for Interned<'tcx, T> {\n+impl<'tcx, T: 'tcx + ?Sized> Clone for Interned<'tcx, T> {\n     fn clone(&self) -> Self {\n         Interned(self.0)\n     }\n }\n-impl<'tcx, T: 'tcx+?Sized> Copy for Interned<'tcx, T> {}\n+impl<'tcx, T: 'tcx + ?Sized> Copy for Interned<'tcx, T> {}\n \n // N.B., an `Interned<Ty>` compares and hashes as a `TyKind`.\n impl<'tcx> PartialEq for Interned<'tcx, TyS<'tcx>> {\n@@ -2148,15 +2049,13 @@ impl<'tcx> Borrow<[GenericArg<'tcx>]> for Interned<'tcx, InternalSubsts<'tcx>> {\n     }\n }\n \n-impl<'tcx> Borrow<[ProjectionKind]>\n-    for Interned<'tcx, List<ProjectionKind>> {\n+impl<'tcx> Borrow<[ProjectionKind]> for Interned<'tcx, List<ProjectionKind>> {\n     fn borrow(&self) -> &[ProjectionKind] {\n         &self.0[..]\n     }\n }\n \n-impl<'tcx> Borrow<[PlaceElem<'tcx>]>\n-    for Interned<'tcx, List<PlaceElem<'tcx>>> {\n+impl<'tcx> Borrow<[PlaceElem<'tcx>]> for Interned<'tcx, List<PlaceElem<'tcx>>> {\n     fn borrow(&self) -> &[PlaceElem<'tcx>] {\n         &self.0[..]\n     }\n@@ -2272,10 +2171,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// unsafe.\n     pub fn safe_to_unsafe_fn_ty(self, sig: PolyFnSig<'tcx>) -> Ty<'tcx> {\n         assert_eq!(sig.unsafety(), hir::Unsafety::Normal);\n-        self.mk_fn_ptr(sig.map_bound(|sig| ty::FnSig {\n-            unsafety: hir::Unsafety::Unsafe,\n-            ..sig\n-        }))\n+        self.mk_fn_ptr(sig.map_bound(|sig| ty::FnSig { unsafety: hir::Unsafety::Unsafe, ..sig }))\n     }\n \n     /// Given a closure signature `sig`, returns an equivalent `fn`\n@@ -2289,18 +2185,10 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn coerce_closure_fn_ty(self, sig: PolyFnSig<'tcx>, unsafety: hir::Unsafety) -> Ty<'tcx> {\n         let converted_sig = sig.map_bound(|s| {\n             let params_iter = match s.inputs()[0].kind {\n-                ty::Tuple(params) => {\n-                    params.into_iter().map(|k| k.expect_ty())\n-                }\n+                ty::Tuple(params) => params.into_iter().map(|k| k.expect_ty()),\n                 _ => bug!(),\n             };\n-            self.mk_fn_sig(\n-                params_iter,\n-                s.output(),\n-                s.c_variadic,\n-                unsafety,\n-                abi::Abi::Rust,\n-            )\n+            self.mk_fn_sig(params_iter, s.output(), s.c_variadic, unsafety, abi::Abi::Rust)\n         });\n \n         self.mk_fn_ptr(converted_sig)\n@@ -2314,30 +2202,30 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     pub fn mk_mach_int(self, tm: ast::IntTy) -> Ty<'tcx> {\n         match tm {\n-            ast::IntTy::Isize   => self.types.isize,\n-            ast::IntTy::I8   => self.types.i8,\n-            ast::IntTy::I16  => self.types.i16,\n-            ast::IntTy::I32  => self.types.i32,\n-            ast::IntTy::I64  => self.types.i64,\n-            ast::IntTy::I128  => self.types.i128,\n+            ast::IntTy::Isize => self.types.isize,\n+            ast::IntTy::I8 => self.types.i8,\n+            ast::IntTy::I16 => self.types.i16,\n+            ast::IntTy::I32 => self.types.i32,\n+            ast::IntTy::I64 => self.types.i64,\n+            ast::IntTy::I128 => self.types.i128,\n         }\n     }\n \n     pub fn mk_mach_uint(self, tm: ast::UintTy) -> Ty<'tcx> {\n         match tm {\n-            ast::UintTy::Usize   => self.types.usize,\n-            ast::UintTy::U8   => self.types.u8,\n-            ast::UintTy::U16  => self.types.u16,\n-            ast::UintTy::U32  => self.types.u32,\n-            ast::UintTy::U64  => self.types.u64,\n-            ast::UintTy::U128  => self.types.u128,\n+            ast::UintTy::Usize => self.types.usize,\n+            ast::UintTy::U8 => self.types.u8,\n+            ast::UintTy::U16 => self.types.u16,\n+            ast::UintTy::U32 => self.types.u32,\n+            ast::UintTy::U64 => self.types.u64,\n+            ast::UintTy::U128 => self.types.u128,\n         }\n     }\n \n     pub fn mk_mach_float(self, tm: ast::FloatTy) -> Ty<'tcx> {\n         match tm {\n-            ast::FloatTy::F32  => self.types.f32,\n-            ast::FloatTy::F64  => self.types.f64,\n+            ast::FloatTy::F32 => self.types.f32,\n+            ast::FloatTy::F64 => self.types.f64,\n         }\n     }\n \n@@ -2364,12 +2252,9 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     fn mk_generic_adt(self, wrapper_def_id: DefId, ty_param: Ty<'tcx>) -> Ty<'tcx> {\n         let adt_def = self.adt_def(wrapper_def_id);\n-        let substs = InternalSubsts::for_item(self, wrapper_def_id, |param, substs| {\n-            match param.kind {\n-                GenericParamDefKind::Lifetime |\n-                GenericParamDefKind::Const => {\n-                    bug!()\n-                }\n+        let substs =\n+            InternalSubsts::for_item(self, wrapper_def_id, |param, substs| match param.kind {\n+                GenericParamDefKind::Lifetime | GenericParamDefKind::Const => bug!(),\n                 GenericParamDefKind::Type { has_default, .. } => {\n                     if param.index == 0 {\n                         ty_param.into()\n@@ -2378,8 +2263,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                         self.type_of(param.def_id).subst(self, substs).into()\n                     }\n                 }\n-            }\n-        });\n+            });\n         self.mk_ty(Adt(adt_def, substs))\n     }\n \n@@ -2390,7 +2274,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[inline]\n-    pub fn mk_lang_item(self, ty: Ty<'tcx>, item: lang_items::LangItem)  -> Option<Ty<'tcx>> {\n+    pub fn mk_lang_item(self, ty: Ty<'tcx>, item: lang_items::LangItem) -> Option<Ty<'tcx>> {\n         let def_id = self.lang_items().require(item).ok()?;\n         Some(self.mk_generic_adt(def_id, ty))\n     }\n@@ -2413,22 +2297,22 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_mut_ref(self, r: Region<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::Mutability::Mut })\n+        self.mk_ref(r, TypeAndMut { ty: ty, mutbl: hir::Mutability::Mut })\n     }\n \n     #[inline]\n     pub fn mk_imm_ref(self, r: Region<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::Mutability::Not })\n+        self.mk_ref(r, TypeAndMut { ty: ty, mutbl: hir::Mutability::Not })\n     }\n \n     #[inline]\n     pub fn mk_mut_ptr(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ptr(TypeAndMut {ty: ty, mutbl: hir::Mutability::Mut })\n+        self.mk_ptr(TypeAndMut { ty: ty, mutbl: hir::Mutability::Mut })\n     }\n \n     #[inline]\n     pub fn mk_imm_ptr(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ptr(TypeAndMut {ty: ty, mutbl: hir::Mutability::Not })\n+        self.mk_ptr(TypeAndMut { ty: ty, mutbl: hir::Mutability::Not })\n     }\n \n     #[inline]\n@@ -2466,11 +2350,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_diverging_default(self) -> Ty<'tcx> {\n-        if self.features().never_type_fallback {\n-            self.types.never\n-        } else {\n-            self.types.unit\n-        }\n+        if self.features().never_type_fallback { self.types.never } else { self.types.unit }\n     }\n \n     #[inline]\n@@ -2479,8 +2359,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[inline]\n-    pub fn mk_fn_def(self, def_id: DefId,\n-                     substs: SubstsRef<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_fn_def(self, def_id: DefId, substs: SubstsRef<'tcx>) -> Ty<'tcx> {\n         self.mk_ty(FnDef(def_id, substs))\n     }\n \n@@ -2493,34 +2372,28 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn mk_dynamic(\n         self,\n         obj: ty::Binder<&'tcx List<ExistentialPredicate<'tcx>>>,\n-        reg: ty::Region<'tcx>\n+        reg: ty::Region<'tcx>,\n     ) -> Ty<'tcx> {\n         self.mk_ty(Dynamic(obj, reg))\n     }\n \n     #[inline]\n-    pub fn mk_projection(self,\n-                         item_def_id: DefId,\n-                         substs: SubstsRef<'tcx>)\n-        -> Ty<'tcx> {\n-            self.mk_ty(Projection(ProjectionTy {\n-                item_def_id,\n-                substs,\n-            }))\n-        }\n+    pub fn mk_projection(self, item_def_id: DefId, substs: SubstsRef<'tcx>) -> Ty<'tcx> {\n+        self.mk_ty(Projection(ProjectionTy { item_def_id, substs }))\n+    }\n \n     #[inline]\n-    pub fn mk_closure(self, closure_id: DefId, closure_substs: SubstsRef<'tcx>)\n-                      -> Ty<'tcx> {\n+    pub fn mk_closure(self, closure_id: DefId, closure_substs: SubstsRef<'tcx>) -> Ty<'tcx> {\n         self.mk_ty(Closure(closure_id, closure_substs))\n     }\n \n     #[inline]\n-    pub fn mk_generator(self,\n-                        id: DefId,\n-                        generator_substs: SubstsRef<'tcx>,\n-                        movability: hir::Movability)\n-                        -> Ty<'tcx> {\n+    pub fn mk_generator(\n+        self,\n+        id: DefId,\n+        generator_substs: SubstsRef<'tcx>,\n+        movability: hir::Movability,\n+    ) -> Ty<'tcx> {\n         self.mk_ty(Generator(id, generator_substs, movability))\n     }\n \n@@ -2536,10 +2409,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_const_var(self, v: ConstVid<'tcx>, ty: Ty<'tcx>) -> &'tcx Const<'tcx> {\n-        self.mk_const(ty::Const {\n-            val: ty::ConstKind::Infer(InferConst::Var(v)),\n-            ty,\n-        })\n+        self.mk_const(ty::Const { val: ty::ConstKind::Infer(InferConst::Var(v)), ty })\n     }\n \n     #[inline]\n@@ -2558,15 +2428,8 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[inline]\n-    pub fn mk_const_infer(\n-        self,\n-        ic: InferConst<'tcx>,\n-        ty: Ty<'tcx>,\n-    ) -> &'tcx ty::Const<'tcx> {\n-        self.mk_const(ty::Const {\n-            val: ty::ConstKind::Infer(ic),\n-            ty,\n-        })\n+    pub fn mk_const_infer(self, ic: InferConst<'tcx>, ty: Ty<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        self.mk_const(ty::Const { val: ty::ConstKind::Infer(ic), ty })\n     }\n \n     #[inline]\n@@ -2575,19 +2438,10 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[inline]\n-    pub fn mk_const_param(\n-        self,\n-        index: u32,\n-        name: Symbol,\n-        ty: Ty<'tcx>\n-    ) -> &'tcx Const<'tcx> {\n-        self.mk_const(ty::Const {\n-            val: ty::ConstKind::Param(ParamConst { index, name }),\n-            ty,\n-        })\n+    pub fn mk_const_param(self, index: u32, name: Symbol, ty: Ty<'tcx>) -> &'tcx Const<'tcx> {\n+        self.mk_const(ty::Const { val: ty::ConstKind::Param(ParamConst { index, name }), ty })\n     }\n \n-\n     pub fn mk_param_from_def(self, param: &ty::GenericParamDef) -> GenericArg<'tcx> {\n         match param.kind {\n             GenericParamDefKind::Lifetime => {\n@@ -2647,15 +2501,16 @@ impl<'tcx> TyCtxt<'tcx> {\n         Place { base: place.base, projection: self.intern_place_elems(&projection) }\n     }\n \n-    pub fn intern_existential_predicates(self, eps: &[ExistentialPredicate<'tcx>])\n-        -> &'tcx List<ExistentialPredicate<'tcx>> {\n+    pub fn intern_existential_predicates(\n+        self,\n+        eps: &[ExistentialPredicate<'tcx>],\n+    ) -> &'tcx List<ExistentialPredicate<'tcx>> {\n         assert!(!eps.is_empty());\n         assert!(eps.windows(2).all(|w| w[0].stable_cmp(self, &w[1]) != Ordering::Greater));\n         self._intern_existential_predicates(eps)\n     }\n \n-    pub fn intern_predicates(self, preds: &[Predicate<'tcx>])\n-        -> &'tcx List<Predicate<'tcx>> {\n+    pub fn intern_predicates(self, preds: &[Predicate<'tcx>]) -> &'tcx List<Predicate<'tcx>> {\n         // FIXME consider asking the input slice to be sorted to avoid\n         // re-interning permutations, in which case that would be asserted\n         // here.\n@@ -2668,109 +2523,87 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn intern_type_list(self, ts: &[Ty<'tcx>]) -> &'tcx List<Ty<'tcx>> {\n-        if ts.len() == 0 {\n-            List::empty()\n-        } else {\n-            self._intern_type_list(ts)\n-        }\n+        if ts.len() == 0 { List::empty() } else { self._intern_type_list(ts) }\n     }\n \n     pub fn intern_substs(self, ts: &[GenericArg<'tcx>]) -> &'tcx List<GenericArg<'tcx>> {\n-        if ts.len() == 0 {\n-            List::empty()\n-        } else {\n-            self._intern_substs(ts)\n-        }\n+        if ts.len() == 0 { List::empty() } else { self._intern_substs(ts) }\n     }\n \n     pub fn intern_projs(self, ps: &[ProjectionKind]) -> &'tcx List<ProjectionKind> {\n-        if ps.len() == 0 {\n-            List::empty()\n-        } else {\n-            self._intern_projs(ps)\n-        }\n+        if ps.len() == 0 { List::empty() } else { self._intern_projs(ps) }\n     }\n \n     pub fn intern_place_elems(self, ts: &[PlaceElem<'tcx>]) -> &'tcx List<PlaceElem<'tcx>> {\n-        if ts.len() == 0 {\n-            List::empty()\n-        } else {\n-            self._intern_place_elems(ts)\n-        }\n+        if ts.len() == 0 { List::empty() } else { self._intern_place_elems(ts) }\n     }\n \n     pub fn intern_canonical_var_infos(self, ts: &[CanonicalVarInfo]) -> CanonicalVarInfos<'tcx> {\n-        if ts.len() == 0 {\n-            List::empty()\n-        } else {\n-            self._intern_canonical_var_infos(ts)\n-        }\n+        if ts.len() == 0 { List::empty() } else { self._intern_canonical_var_infos(ts) }\n     }\n \n     pub fn intern_clauses(self, ts: &[Clause<'tcx>]) -> Clauses<'tcx> {\n-        if ts.len() == 0 {\n-            List::empty()\n-        } else {\n-            self._intern_clauses(ts)\n-        }\n+        if ts.len() == 0 { List::empty() } else { self._intern_clauses(ts) }\n     }\n \n     pub fn intern_goals(self, ts: &[Goal<'tcx>]) -> Goals<'tcx> {\n-        if ts.len() == 0 {\n-            List::empty()\n-        } else {\n-            self._intern_goals(ts)\n-        }\n+        if ts.len() == 0 { List::empty() } else { self._intern_goals(ts) }\n     }\n \n-    pub fn mk_fn_sig<I>(self,\n-                        inputs: I,\n-                        output: I::Item,\n-                        c_variadic: bool,\n-                        unsafety: hir::Unsafety,\n-                        abi: abi::Abi)\n-        -> <I::Item as InternIteratorElement<Ty<'tcx>, ty::FnSig<'tcx>>>::Output\n+    pub fn mk_fn_sig<I>(\n+        self,\n+        inputs: I,\n+        output: I::Item,\n+        c_variadic: bool,\n+        unsafety: hir::Unsafety,\n+        abi: abi::Abi,\n+    ) -> <I::Item as InternIteratorElement<Ty<'tcx>, ty::FnSig<'tcx>>>::Output\n     where\n         I: Iterator<Item: InternIteratorElement<Ty<'tcx>, ty::FnSig<'tcx>>>,\n     {\n         inputs.chain(iter::once(output)).intern_with(|xs| ty::FnSig {\n             inputs_and_output: self.intern_type_list(xs),\n-            c_variadic, unsafety, abi\n+            c_variadic,\n+            unsafety,\n+            abi,\n         })\n     }\n \n-    pub fn mk_existential_predicates<I: InternAs<[ExistentialPredicate<'tcx>],\n-                                     &'tcx List<ExistentialPredicate<'tcx>>>>(self, iter: I)\n-                                     -> I::Output {\n+    pub fn mk_existential_predicates<\n+        I: InternAs<[ExistentialPredicate<'tcx>], &'tcx List<ExistentialPredicate<'tcx>>>,\n+    >(\n+        self,\n+        iter: I,\n+    ) -> I::Output {\n         iter.intern_with(|xs| self.intern_existential_predicates(xs))\n     }\n \n-    pub fn mk_predicates<I: InternAs<[Predicate<'tcx>],\n-                                     &'tcx List<Predicate<'tcx>>>>(self, iter: I)\n-                                     -> I::Output {\n+    pub fn mk_predicates<I: InternAs<[Predicate<'tcx>], &'tcx List<Predicate<'tcx>>>>(\n+        self,\n+        iter: I,\n+    ) -> I::Output {\n         iter.intern_with(|xs| self.intern_predicates(xs))\n     }\n \n-    pub fn mk_type_list<I: InternAs<[Ty<'tcx>],\n-                        &'tcx List<Ty<'tcx>>>>(self, iter: I) -> I::Output {\n+    pub fn mk_type_list<I: InternAs<[Ty<'tcx>], &'tcx List<Ty<'tcx>>>>(self, iter: I) -> I::Output {\n         iter.intern_with(|xs| self.intern_type_list(xs))\n     }\n \n-    pub fn mk_substs<I: InternAs<[GenericArg<'tcx>],\n-                     &'tcx List<GenericArg<'tcx>>>>(self, iter: I) -> I::Output {\n+    pub fn mk_substs<I: InternAs<[GenericArg<'tcx>], &'tcx List<GenericArg<'tcx>>>>(\n+        self,\n+        iter: I,\n+    ) -> I::Output {\n         iter.intern_with(|xs| self.intern_substs(xs))\n     }\n \n-    pub fn mk_place_elems<I: InternAs<[PlaceElem<'tcx>],\n-                          &'tcx List<PlaceElem<'tcx>>>>(self, iter: I) -> I::Output {\n+    pub fn mk_place_elems<I: InternAs<[PlaceElem<'tcx>], &'tcx List<PlaceElem<'tcx>>>>(\n+        self,\n+        iter: I,\n+    ) -> I::Output {\n         iter.intern_with(|xs| self.intern_place_elems(xs))\n     }\n \n-    pub fn mk_substs_trait(self,\n-                     self_ty: Ty<'tcx>,\n-                     rest: &[GenericArg<'tcx>])\n-                    -> SubstsRef<'tcx>\n-    {\n+    pub fn mk_substs_trait(self, self_ty: Ty<'tcx>, rest: &[GenericArg<'tcx>]) -> SubstsRef<'tcx> {\n         self.mk_substs(iter::once(self_ty.into()).chain(rest.iter().cloned()))\n     }\n \n@@ -2782,31 +2615,37 @@ impl<'tcx> TyCtxt<'tcx> {\n         iter.intern_with(|xs| self.intern_goals(xs))\n     }\n \n-    pub fn lint_hir<S: Into<MultiSpan>>(self,\n-                                        lint: &'static Lint,\n-                                        hir_id: HirId,\n-                                        span: S,\n-                                        msg: &str) {\n+    pub fn lint_hir<S: Into<MultiSpan>>(\n+        self,\n+        lint: &'static Lint,\n+        hir_id: HirId,\n+        span: S,\n+        msg: &str,\n+    ) {\n         self.struct_span_lint_hir(lint, hir_id, span.into(), msg).emit()\n     }\n \n-    pub fn lint_hir_note<S: Into<MultiSpan>>(self,\n-                                             lint: &'static Lint,\n-                                             hir_id: HirId,\n-                                             span: S,\n-                                             msg: &str,\n-                                             note: &str) {\n+    pub fn lint_hir_note<S: Into<MultiSpan>>(\n+        self,\n+        lint: &'static Lint,\n+        hir_id: HirId,\n+        span: S,\n+        msg: &str,\n+        note: &str,\n+    ) {\n         let mut err = self.struct_span_lint_hir(lint, hir_id, span.into(), msg);\n         err.note(note);\n         err.emit()\n     }\n \n-    pub fn lint_node_note<S: Into<MultiSpan>>(self,\n-                                              lint: &'static Lint,\n-                                              id: hir::HirId,\n-                                              span: S,\n-                                              msg: &str,\n-                                              note: &str) {\n+    pub fn lint_node_note<S: Into<MultiSpan>>(\n+        self,\n+        lint: &'static Lint,\n+        id: hir::HirId,\n+        span: S,\n+        msg: &str,\n+        note: &str,\n+    ) {\n         let mut err = self.struct_span_lint_hir(lint, id, span.into(), msg);\n         err.note(note);\n         err.emit()\n@@ -2837,12 +2676,12 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn lint_level_at_node(\n         self,\n         lint: &'static Lint,\n-        mut id: hir::HirId\n+        mut id: hir::HirId,\n     ) -> (lint::Level, lint::LintSource) {\n         let sets = self.lint_levels(LOCAL_CRATE);\n         loop {\n             if let Some(pair) = sets.level_and_source(lint, id, self.sess) {\n-                return pair\n+                return pair;\n             }\n             let next = self.hir().get_parent_node(id);\n             if next == id {\n@@ -2852,38 +2691,37 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn struct_span_lint_hir<S: Into<MultiSpan>>(self,\n-                                                    lint: &'static Lint,\n-                                                    hir_id: HirId,\n-                                                    span: S,\n-                                                    msg: &str)\n-        -> DiagnosticBuilder<'tcx>\n-    {\n+    pub fn struct_span_lint_hir<S: Into<MultiSpan>>(\n+        self,\n+        lint: &'static Lint,\n+        hir_id: HirId,\n+        span: S,\n+        msg: &str,\n+    ) -> DiagnosticBuilder<'tcx> {\n         let (level, src) = self.lint_level_at_node(lint, hir_id);\n         lint::struct_lint_level(self.sess, lint, level, src, Some(span.into()), msg)\n     }\n \n-    pub fn struct_lint_node(self, lint: &'static Lint, id: HirId, msg: &str)\n-        -> DiagnosticBuilder<'tcx>\n-    {\n+    pub fn struct_lint_node(\n+        self,\n+        lint: &'static Lint,\n+        id: HirId,\n+        msg: &str,\n+    ) -> DiagnosticBuilder<'tcx> {\n         let (level, src) = self.lint_level_at_node(lint, id);\n         lint::struct_lint_level(self.sess, lint, level, src, None, msg)\n     }\n \n     pub fn in_scope_traits(self, id: HirId) -> Option<&'tcx StableVec<TraitCandidate>> {\n-        self.in_scope_traits_map(id.owner)\n-            .and_then(|map| map.get(&id.local_id))\n+        self.in_scope_traits_map(id.owner).and_then(|map| map.get(&id.local_id))\n     }\n \n     pub fn named_region(self, id: HirId) -> Option<resolve_lifetime::Region> {\n-        self.named_region_map(id.owner)\n-            .and_then(|map| map.get(&id.local_id).cloned())\n+        self.named_region_map(id.owner).and_then(|map| map.get(&id.local_id).cloned())\n     }\n \n     pub fn is_late_bound(self, id: HirId) -> bool {\n-        self.is_late_bound_map(id.owner)\n-            .map(|set| set.contains(&id.local_id))\n-            .unwrap_or(false)\n+        self.is_late_bound_map(id.owner).map(|set| set.contains(&id.local_id)).unwrap_or(false)\n     }\n \n     pub fn object_lifetime_defaults(self, id: HirId) -> Option<&'tcx [ObjectLifetimeDefault]> {\n@@ -2895,44 +2733,52 @@ impl<'tcx> TyCtxt<'tcx> {\n pub trait InternAs<T: ?Sized, R> {\n     type Output;\n     fn intern_with<F>(self, f: F) -> Self::Output\n-        where F: FnOnce(&T) -> R;\n+    where\n+        F: FnOnce(&T) -> R;\n }\n \n impl<I, T, R, E> InternAs<[T], R> for I\n-    where E: InternIteratorElement<T, R>,\n-          I: Iterator<Item=E> {\n+where\n+    E: InternIteratorElement<T, R>,\n+    I: Iterator<Item = E>,\n+{\n     type Output = E::Output;\n     fn intern_with<F>(self, f: F) -> Self::Output\n-        where F: FnOnce(&[T]) -> R {\n+    where\n+        F: FnOnce(&[T]) -> R,\n+    {\n         E::intern_with(self, f)\n     }\n }\n \n pub trait InternIteratorElement<T, R>: Sized {\n     type Output;\n-    fn intern_with<I: Iterator<Item=Self>, F: FnOnce(&[T]) -> R>(iter: I, f: F) -> Self::Output;\n+    fn intern_with<I: Iterator<Item = Self>, F: FnOnce(&[T]) -> R>(iter: I, f: F) -> Self::Output;\n }\n \n impl<T, R> InternIteratorElement<T, R> for T {\n     type Output = R;\n-    fn intern_with<I: Iterator<Item=Self>, F: FnOnce(&[T]) -> R>(iter: I, f: F) -> Self::Output {\n+    fn intern_with<I: Iterator<Item = Self>, F: FnOnce(&[T]) -> R>(iter: I, f: F) -> Self::Output {\n         f(&iter.collect::<SmallVec<[_; 8]>>())\n     }\n }\n \n impl<'a, T, R> InternIteratorElement<T, R> for &'a T\n-    where T: Clone + 'a\n+where\n+    T: Clone + 'a,\n {\n     type Output = R;\n-    fn intern_with<I: Iterator<Item=Self>, F: FnOnce(&[T]) -> R>(iter: I, f: F) -> Self::Output {\n+    fn intern_with<I: Iterator<Item = Self>, F: FnOnce(&[T]) -> R>(iter: I, f: F) -> Self::Output {\n         f(&iter.cloned().collect::<SmallVec<[_; 8]>>())\n     }\n }\n \n impl<T, R, E> InternIteratorElement<T, R> for Result<T, E> {\n     type Output = Result<R, E>;\n-    fn intern_with<I: Iterator<Item=Self>, F: FnOnce(&[T]) -> R>(mut iter: I, f: F)\n-            -> Self::Output {\n+    fn intern_with<I: Iterator<Item = Self>, F: FnOnce(&[T]) -> R>(\n+        mut iter: I,\n+        f: F,\n+    ) -> Self::Output {\n         // This code is hot enough that it's worth specializing for the most\n         // common length lists, to avoid the overhead of `SmallVec` creation.\n         // The match arms are in order of frequency. The 1, 2, and 0 cases are\n@@ -2954,9 +2800,7 @@ impl<T, R, E> InternIteratorElement<T, R> for Result<T, E> {\n                 assert!(iter.next().is_none());\n                 f(&[])\n             }\n-            _ => {\n-                f(&iter.collect::<Result<SmallVec<[_; 8]>, _>>()?)\n-            }\n+            _ => f(&iter.collect::<Result<SmallVec<[_; 8]>, _>>()?),\n         })\n     }\n }\n@@ -2990,9 +2834,7 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n         assert_eq!(id, LOCAL_CRATE);\n         middle::diagnostic_items::collect_all(tcx)\n     };\n-    providers.maybe_unused_trait_import = |tcx, id| {\n-        tcx.maybe_unused_trait_imports.contains(&id)\n-    };\n+    providers.maybe_unused_trait_import = |tcx, id| tcx.maybe_unused_trait_imports.contains(&id);\n     providers.maybe_unused_extern_crates = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n         &tcx.maybe_unused_extern_crates[..]"}, {"sha": "900c425fac2da81c7ab8a4a126492e7cdbf32788", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 241, "deletions": 239, "changes": 480, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d", "patch": "@@ -1,13 +1,13 @@\n use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::infer::InferCtxt;\n-use crate::ty::subst::SubstsRef;\n+use crate::middle::lang_items;\n use crate::traits::{self, AssocTypeBoundData};\n+use crate::ty::subst::SubstsRef;\n use crate::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable};\n use std::iter::once;\n use syntax::symbol::{kw, Ident};\n use syntax_pos::Span;\n-use crate::middle::lang_items;\n \n /// Returns the set of obligations needed to make `ty` well-formed.\n /// If `ty` contains unresolved inference variables, this may include\n@@ -22,14 +22,7 @@ pub fn obligations<'a, 'tcx>(\n     ty: Ty<'tcx>,\n     span: Span,\n ) -> Option<Vec<traits::PredicateObligation<'tcx>>> {\n-    let mut wf = WfPredicates {\n-        infcx,\n-        param_env,\n-        body_id,\n-        span,\n-        out: vec![],\n-        item: None,\n-    };\n+    let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![], item: None };\n     if wf.compute(ty) {\n         debug!(\"wf::obligations({:?}, body_id={:?}) = {:?}\", ty, body_id, wf.out);\n         let result = wf.normalize();\n@@ -71,8 +64,7 @@ pub fn predicate_obligations<'a, 'tcx>(\n         ty::Predicate::Trait(ref t) => {\n             wf.compute_trait_ref(&t.skip_binder().trait_ref, Elaborate::None); // (*)\n         }\n-        ty::Predicate::RegionOutlives(..) => {\n-        }\n+        ty::Predicate::RegionOutlives(..) => {}\n         ty::Predicate::TypeOutlives(ref t) => {\n             wf.compute(t.skip_binder().0);\n         }\n@@ -84,10 +76,8 @@ pub fn predicate_obligations<'a, 'tcx>(\n         ty::Predicate::WellFormed(t) => {\n             wf.compute(t);\n         }\n-        ty::Predicate::ObjectSafe(_) => {\n-        }\n-        ty::Predicate::ClosureKind(..) => {\n-        }\n+        ty::Predicate::ObjectSafe(_) => {}\n+        ty::Predicate::ClosureKind(..) => {}\n         ty::Predicate::Subtype(ref data) => {\n             wf.compute(data.skip_binder().a); // (*)\n             wf.compute(data.skip_binder().b); // (*)\n@@ -152,14 +142,15 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         let cause = self.cause(traits::MiscObligation);\n         let infcx = &mut self.infcx;\n         let param_env = self.param_env;\n-        self.out.iter()\n-                .inspect(|pred| assert!(!pred.has_escaping_bound_vars()))\n-                .flat_map(|pred| {\n-                    let mut selcx = traits::SelectionContext::new(infcx);\n-                    let pred = traits::normalize(&mut selcx, param_env, cause.clone(), pred);\n-                    once(pred.value).chain(pred.obligations)\n-                })\n-                .collect()\n+        self.out\n+            .iter()\n+            .inspect(|pred| assert!(!pred.has_escaping_bound_vars()))\n+            .flat_map(|pred| {\n+                let mut selcx = traits::SelectionContext::new(infcx);\n+                let pred = traits::normalize(&mut selcx, param_env, cause.clone(), pred);\n+                once(pred.value).chain(pred.obligations)\n+            })\n+            .collect()\n     }\n \n     /// Pushes the obligations required for `trait_ref` to be WF into `self.out`.\n@@ -171,154 +162,163 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         let param_env = self.param_env;\n \n         let item = &self.item;\n-        let extend_cause_with_original_assoc_item_obligation = |\n-            cause: &mut traits::ObligationCause<'_>,\n-            pred: &ty::Predicate<'_>,\n-            trait_assoc_items: ty::AssocItemsIterator<'_>,\n-        | {\n-            let trait_item = tcx.hir().as_local_hir_id(trait_ref.def_id).and_then(|trait_id| {\n-                tcx.hir().find(trait_id)\n-            });\n-            let (trait_name, trait_generics) = match trait_item {\n-                Some(hir::Node::Item(hir::Item {\n-                    ident,\n-                    kind: hir::ItemKind::Trait(.., generics, _, _),\n-                    ..\n-                })) |\n-                Some(hir::Node::Item(hir::Item {\n-                    ident,\n-                    kind: hir::ItemKind::TraitAlias(generics, _),\n-                    ..\n-                })) => (Some(ident), Some(generics)),\n-                _ => (None, None),\n-            };\n-\n-            let item_span = item.map(|i| tcx.sess.source_map().def_span(i.span));\n-            match pred {\n-                ty::Predicate::Projection(proj) => {\n-                    // The obligation comes not from the current `impl` nor the `trait` being\n-                    // implemented, but rather from a \"second order\" obligation, like in\n-                    // `src/test/ui/associated-types/point-at-type-on-obligation-failure.rs`:\n-                    //\n-                    //   error[E0271]: type mismatch resolving `<Foo2 as Bar2>::Ok == ()`\n-                    //     --> $DIR/point-at-type-on-obligation-failure.rs:13:5\n-                    //      |\n-                    //   LL |     type Ok;\n-                    //      |          -- associated type defined here\n-                    //   ...\n-                    //   LL | impl Bar for Foo {\n-                    //      | ---------------- in this `impl` item\n-                    //   LL |     type Ok = ();\n-                    //      |     ^^^^^^^^^^^^^ expected `u32`, found `()`\n-                    //      |\n-                    //      = note: expected type `u32`\n-                    //                 found type `()`\n-                    //\n-                    // FIXME: we would want to point a span to all places that contributed to this\n-                    // obligation. In the case above, it should be closer to:\n-                    //\n-                    //   error[E0271]: type mismatch resolving `<Foo2 as Bar2>::Ok == ()`\n-                    //     --> $DIR/point-at-type-on-obligation-failure.rs:13:5\n-                    //      |\n-                    //   LL |     type Ok;\n-                    //      |          -- associated type defined here\n-                    //   LL |     type Sibling: Bar2<Ok=Self::Ok>;\n-                    //      |     -------------------------------- obligation set here\n-                    //   ...\n-                    //   LL | impl Bar for Foo {\n-                    //      | ---------------- in this `impl` item\n-                    //   LL |     type Ok = ();\n-                    //      |     ^^^^^^^^^^^^^ expected `u32`, found `()`\n-                    //   ...\n-                    //   LL | impl Bar2 for Foo2 {\n-                    //      | ---------------- in this `impl` item\n-                    //   LL |     type Ok = u32;\n-                    //      |     -------------- obligation set here\n-                    //      |\n-                    //      = note: expected type `u32`\n-                    //                 found type `()`\n-                    if let Some(hir::ItemKind::Impl(.., impl_items)) = item.map(|i| &i.kind) {\n-                        let trait_assoc_item = tcx.associated_item(proj.projection_def_id());\n-                        if let Some(impl_item) = impl_items.iter().filter(|item| {\n-                            item.ident == trait_assoc_item.ident\n-                        }).next() {\n-                            cause.span = impl_item.span;\n-                            cause.code = traits::AssocTypeBound(Box::new(AssocTypeBoundData {\n-                                impl_span: item_span,\n-                                original: trait_assoc_item.ident.span,\n-                                bounds: vec![],\n-                            }));\n+        let extend_cause_with_original_assoc_item_obligation =\n+            |cause: &mut traits::ObligationCause<'_>,\n+             pred: &ty::Predicate<'_>,\n+             trait_assoc_items: ty::AssocItemsIterator<'_>| {\n+                let trait_item = tcx\n+                    .hir()\n+                    .as_local_hir_id(trait_ref.def_id)\n+                    .and_then(|trait_id| tcx.hir().find(trait_id));\n+                let (trait_name, trait_generics) = match trait_item {\n+                    Some(hir::Node::Item(hir::Item {\n+                        ident,\n+                        kind: hir::ItemKind::Trait(.., generics, _, _),\n+                        ..\n+                    }))\n+                    | Some(hir::Node::Item(hir::Item {\n+                        ident,\n+                        kind: hir::ItemKind::TraitAlias(generics, _),\n+                        ..\n+                    })) => (Some(ident), Some(generics)),\n+                    _ => (None, None),\n+                };\n+\n+                let item_span = item.map(|i| tcx.sess.source_map().def_span(i.span));\n+                match pred {\n+                    ty::Predicate::Projection(proj) => {\n+                        // The obligation comes not from the current `impl` nor the `trait` being\n+                        // implemented, but rather from a \"second order\" obligation, like in\n+                        // `src/test/ui/associated-types/point-at-type-on-obligation-failure.rs`:\n+                        //\n+                        //   error[E0271]: type mismatch resolving `<Foo2 as Bar2>::Ok == ()`\n+                        //     --> $DIR/point-at-type-on-obligation-failure.rs:13:5\n+                        //      |\n+                        //   LL |     type Ok;\n+                        //      |          -- associated type defined here\n+                        //   ...\n+                        //   LL | impl Bar for Foo {\n+                        //      | ---------------- in this `impl` item\n+                        //   LL |     type Ok = ();\n+                        //      |     ^^^^^^^^^^^^^ expected `u32`, found `()`\n+                        //      |\n+                        //      = note: expected type `u32`\n+                        //                 found type `()`\n+                        //\n+                        // FIXME: we would want to point a span to all places that contributed to this\n+                        // obligation. In the case above, it should be closer to:\n+                        //\n+                        //   error[E0271]: type mismatch resolving `<Foo2 as Bar2>::Ok == ()`\n+                        //     --> $DIR/point-at-type-on-obligation-failure.rs:13:5\n+                        //      |\n+                        //   LL |     type Ok;\n+                        //      |          -- associated type defined here\n+                        //   LL |     type Sibling: Bar2<Ok=Self::Ok>;\n+                        //      |     -------------------------------- obligation set here\n+                        //   ...\n+                        //   LL | impl Bar for Foo {\n+                        //      | ---------------- in this `impl` item\n+                        //   LL |     type Ok = ();\n+                        //      |     ^^^^^^^^^^^^^ expected `u32`, found `()`\n+                        //   ...\n+                        //   LL | impl Bar2 for Foo2 {\n+                        //      | ---------------- in this `impl` item\n+                        //   LL |     type Ok = u32;\n+                        //      |     -------------- obligation set here\n+                        //      |\n+                        //      = note: expected type `u32`\n+                        //                 found type `()`\n+                        if let Some(hir::ItemKind::Impl(.., impl_items)) = item.map(|i| &i.kind) {\n+                            let trait_assoc_item = tcx.associated_item(proj.projection_def_id());\n+                            if let Some(impl_item) = impl_items\n+                                .iter()\n+                                .filter(|item| item.ident == trait_assoc_item.ident)\n+                                .next()\n+                            {\n+                                cause.span = impl_item.span;\n+                                cause.code = traits::AssocTypeBound(Box::new(AssocTypeBoundData {\n+                                    impl_span: item_span,\n+                                    original: trait_assoc_item.ident.span,\n+                                    bounds: vec![],\n+                                }));\n+                            }\n                         }\n                     }\n-                }\n-                ty::Predicate::Trait(proj) => {\n-                    // An associated item obligation born out of the `trait` failed to be met.\n-                    // Point at the `impl` that failed the obligation, the associated item that\n-                    // needed to meet the obligation, and the definition of that associated item,\n-                    // which should hold the obligation in most cases. An example can be seen in\n-                    // `src/test/ui/associated-types/point-at-type-on-obligation-failure-2.rs`:\n-                    //\n-                    //   error[E0277]: the trait bound `bool: Bar` is not satisfied\n-                    //     --> $DIR/point-at-type-on-obligation-failure-2.rs:8:5\n-                    //      |\n-                    //   LL |     type Assoc: Bar;\n-                    //      |          ----- associated type defined here\n-                    //   ...\n-                    //   LL | impl Foo for () {\n-                    //      | --------------- in this `impl` item\n-                    //   LL |     type Assoc = bool;\n-                    //      |     ^^^^^^^^^^^^^^^^^^ the trait `Bar` is not implemented for `bool`\n-                    //\n-                    // If the obligation comes from the where clause in the `trait`, we point at it:\n-                    //\n-                    //   error[E0277]: the trait bound `bool: Bar` is not satisfied\n-                    //     --> $DIR/point-at-type-on-obligation-failure-2.rs:8:5\n-                    //      |\n-                    //      | trait Foo where <Self as Foo>>::Assoc: Bar {\n-                    //      |                 -------------------------- restricted in this bound\n-                    //   LL |     type Assoc;\n-                    //      |          ----- associated type defined here\n-                    //   ...\n-                    //   LL | impl Foo for () {\n-                    //      | --------------- in this `impl` item\n-                    //   LL |     type Assoc = bool;\n-                    //      |     ^^^^^^^^^^^^^^^^^^ the trait `Bar` is not implemented for `bool`\n-                    if let (\n-                        ty::Projection(ty::ProjectionTy { item_def_id, .. }),\n-                        Some(hir::ItemKind::Impl(.., impl_items)),\n-                    ) = (&proj.skip_binder().self_ty().kind, item.map(|i| &i.kind)) {\n-                        if let Some((impl_item, trait_assoc_item)) = trait_assoc_items\n-                            .filter(|i| i.def_id == *item_def_id)\n-                            .next()\n-                            .and_then(|trait_assoc_item| impl_items.iter()\n-                                .filter(|i| i.ident == trait_assoc_item.ident)\n-                                .next()\n-                                .map(|impl_item| (impl_item, trait_assoc_item)))\n+                    ty::Predicate::Trait(proj) => {\n+                        // An associated item obligation born out of the `trait` failed to be met.\n+                        // Point at the `impl` that failed the obligation, the associated item that\n+                        // needed to meet the obligation, and the definition of that associated item,\n+                        // which should hold the obligation in most cases. An example can be seen in\n+                        // `src/test/ui/associated-types/point-at-type-on-obligation-failure-2.rs`:\n+                        //\n+                        //   error[E0277]: the trait bound `bool: Bar` is not satisfied\n+                        //     --> $DIR/point-at-type-on-obligation-failure-2.rs:8:5\n+                        //      |\n+                        //   LL |     type Assoc: Bar;\n+                        //      |          ----- associated type defined here\n+                        //   ...\n+                        //   LL | impl Foo for () {\n+                        //      | --------------- in this `impl` item\n+                        //   LL |     type Assoc = bool;\n+                        //      |     ^^^^^^^^^^^^^^^^^^ the trait `Bar` is not implemented for `bool`\n+                        //\n+                        // If the obligation comes from the where clause in the `trait`, we point at it:\n+                        //\n+                        //   error[E0277]: the trait bound `bool: Bar` is not satisfied\n+                        //     --> $DIR/point-at-type-on-obligation-failure-2.rs:8:5\n+                        //      |\n+                        //      | trait Foo where <Self as Foo>>::Assoc: Bar {\n+                        //      |                 -------------------------- restricted in this bound\n+                        //   LL |     type Assoc;\n+                        //      |          ----- associated type defined here\n+                        //   ...\n+                        //   LL | impl Foo for () {\n+                        //      | --------------- in this `impl` item\n+                        //   LL |     type Assoc = bool;\n+                        //      |     ^^^^^^^^^^^^^^^^^^ the trait `Bar` is not implemented for `bool`\n+                        if let (\n+                            ty::Projection(ty::ProjectionTy { item_def_id, .. }),\n+                            Some(hir::ItemKind::Impl(.., impl_items)),\n+                        ) = (&proj.skip_binder().self_ty().kind, item.map(|i| &i.kind))\n                         {\n-                            let bounds = trait_generics.map(|generics| get_generic_bound_spans(\n-                                &generics,\n-                                trait_name,\n-                                trait_assoc_item.ident,\n-                            )).unwrap_or_else(Vec::new);\n-                            cause.span = impl_item.span;\n-                            cause.code = traits::AssocTypeBound(Box::new(AssocTypeBoundData {\n-                                impl_span: item_span,\n-                                original: trait_assoc_item.ident.span,\n-                                bounds,\n-                            }));\n+                            if let Some((impl_item, trait_assoc_item)) = trait_assoc_items\n+                                .filter(|i| i.def_id == *item_def_id)\n+                                .next()\n+                                .and_then(|trait_assoc_item| {\n+                                    impl_items\n+                                        .iter()\n+                                        .filter(|i| i.ident == trait_assoc_item.ident)\n+                                        .next()\n+                                        .map(|impl_item| (impl_item, trait_assoc_item))\n+                                })\n+                            {\n+                                let bounds = trait_generics\n+                                    .map(|generics| {\n+                                        get_generic_bound_spans(\n+                                            &generics,\n+                                            trait_name,\n+                                            trait_assoc_item.ident,\n+                                        )\n+                                    })\n+                                    .unwrap_or_else(Vec::new);\n+                                cause.span = impl_item.span;\n+                                cause.code = traits::AssocTypeBound(Box::new(AssocTypeBoundData {\n+                                    impl_span: item_span,\n+                                    original: trait_assoc_item.ident.span,\n+                                    bounds,\n+                                }));\n+                            }\n                         }\n                     }\n+                    _ => {}\n                 }\n-                _ => {}\n-            }\n-        };\n+            };\n \n         if let Elaborate::All = elaborate {\n             let trait_assoc_items = tcx.associated_items(trait_ref.def_id);\n \n-            let predicates = obligations.iter()\n-                .map(|obligation| obligation.predicate.clone())\n-                .collect();\n+            let predicates =\n+                obligations.iter().map(|obligation| obligation.predicate.clone()).collect();\n             let implied_obligations = traits::elaborate_predicates(tcx, predicates);\n             let implied_obligations = implied_obligations.map(|pred| {\n                 let mut cause = cause.clone();\n@@ -334,13 +334,9 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n \n         self.out.extend(obligations);\n \n-        self.out.extend(trait_ref.substs.types()\n-            .filter(|ty| !ty.has_escaping_bound_vars())\n-            .map(|ty| traits::Obligation::new(\n-                cause.clone(),\n-                param_env,\n-                ty::Predicate::WellFormed(ty),\n-            )));\n+        self.out.extend(trait_ref.substs.types().filter(|ty| !ty.has_escaping_bound_vars()).map(\n+            |ty| traits::Obligation::new(cause.clone(), param_env, ty::Predicate::WellFormed(ty)),\n+        ));\n     }\n \n     /// Pushes the obligations required for `trait_ref::Item` to be WF\n@@ -368,9 +364,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n \n             let predicate = ty::Predicate::ConstEvaluatable(def_id, substs);\n             let cause = self.cause(traits::MiscObligation);\n-            self.out.push(traits::Obligation::new(cause,\n-                                                  self.param_env,\n-                                                  predicate));\n+            self.out.push(traits::Obligation::new(cause, self.param_env, predicate));\n         }\n     }\n \n@@ -394,19 +388,19 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         let param_env = self.param_env;\n         while let Some(ty) = subtys.next() {\n             match ty.kind {\n-                ty::Bool |\n-                ty::Char |\n-                ty::Int(..) |\n-                ty::Uint(..) |\n-                ty::Float(..) |\n-                ty::Error |\n-                ty::Str |\n-                ty::GeneratorWitness(..) |\n-                ty::Never |\n-                ty::Param(_) |\n-                ty::Bound(..) |\n-                ty::Placeholder(..) |\n-                ty::Foreign(..) => {\n+                ty::Bool\n+                | ty::Char\n+                | ty::Int(..)\n+                | ty::Uint(..)\n+                | ty::Float(..)\n+                | ty::Error\n+                | ty::Str\n+                | ty::GeneratorWitness(..)\n+                | ty::Never\n+                | ty::Param(_)\n+                | ty::Bound(..)\n+                | ty::Placeholder(..)\n+                | ty::Foreign(..) => {\n                     // WfScalar, WfParameter, etc\n                 }\n \n@@ -453,13 +447,13 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     // WfReference\n                     if !r.has_escaping_bound_vars() && !rty.has_escaping_bound_vars() {\n                         let cause = self.cause(traits::ReferenceOutlivesReferent(ty));\n-                        self.out.push(\n-                            traits::Obligation::new(\n-                                cause,\n-                                param_env,\n-                                ty::Predicate::TypeOutlives(\n-                                    ty::Binder::dummy(\n-                                        ty::OutlivesPredicate(rty, r)))));\n+                        self.out.push(traits::Obligation::new(\n+                            cause,\n+                            param_env,\n+                            ty::Predicate::TypeOutlives(ty::Binder::dummy(ty::OutlivesPredicate(\n+                                rty, r,\n+                            ))),\n+                        ));\n                     }\n                 }\n \n@@ -537,20 +531,18 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     // obligations that don't refer to Self and\n                     // checking those\n \n-                    let defer_to_coercion =\n-                        self.infcx.tcx.features().object_safe_for_dispatch;\n+                    let defer_to_coercion = self.infcx.tcx.features().object_safe_for_dispatch;\n \n                     if !defer_to_coercion {\n                         let cause = self.cause(traits::MiscObligation);\n-                        let component_traits =\n-                            data.auto_traits().chain(data.principal_def_id());\n-                        self.out.extend(\n-                            component_traits.map(|did| traits::Obligation::new(\n+                        let component_traits = data.auto_traits().chain(data.principal_def_id());\n+                        self.out.extend(component_traits.map(|did| {\n+                            traits::Obligation::new(\n                                 cause.clone(),\n                                 param_env,\n-                                ty::Predicate::ObjectSafe(did)\n-                            ))\n-                        );\n+                                ty::Predicate::ObjectSafe(did),\n+                            )\n+                        }));\n                     }\n                 }\n \n@@ -569,16 +561,22 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                 //    is satisfied to ensure termination.)\n                 ty::Infer(_) => {\n                     let ty = self.infcx.shallow_resolve(ty);\n-                    if let ty::Infer(_) = ty.kind { // not yet resolved...\n-                        if ty == ty0 { // ...this is the type we started from! no progress.\n+                    if let ty::Infer(_) = ty.kind {\n+                        // not yet resolved...\n+                        if ty == ty0 {\n+                            // ...this is the type we started from! no progress.\n                             return false;\n                         }\n \n                         let cause = self.cause(traits::MiscObligation);\n-                        self.out.push( // ...not the type we started from, so we made progress.\n-                            traits::Obligation::new(cause,\n-                                                    self.param_env,\n-                                                    ty::Predicate::WellFormed(ty)));\n+                        self.out.push(\n+                            // ...not the type we started from, so we made progress.\n+                            traits::Obligation::new(\n+                                cause,\n+                                self.param_env,\n+                                ty::Predicate::WellFormed(ty),\n+                            ),\n+                        );\n                     } else {\n                         // Yes, resolved, proceed with the\n                         // result. Should never return false because\n@@ -593,27 +591,27 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         return true;\n     }\n \n-    fn nominal_obligations(&mut self,\n-                           def_id: DefId,\n-                           substs: SubstsRef<'tcx>)\n-                           -> Vec<traits::PredicateObligation<'tcx>>\n-    {\n-        let predicates =\n-            self.infcx.tcx.predicates_of(def_id)\n-                          .instantiate(self.infcx.tcx, substs);\n+    fn nominal_obligations(\n+        &mut self,\n+        def_id: DefId,\n+        substs: SubstsRef<'tcx>,\n+    ) -> Vec<traits::PredicateObligation<'tcx>> {\n+        let predicates = self.infcx.tcx.predicates_of(def_id).instantiate(self.infcx.tcx, substs);\n         let cause = self.cause(traits::ItemObligation(def_id));\n-        predicates.predicates\n-                  .into_iter()\n-                  .map(|pred| traits::Obligation::new(cause.clone(),\n-                                                      self.param_env,\n-                                                      pred))\n-                  .filter(|pred| !pred.has_escaping_bound_vars())\n-                  .collect()\n+        predicates\n+            .predicates\n+            .into_iter()\n+            .map(|pred| traits::Obligation::new(cause.clone(), self.param_env, pred))\n+            .filter(|pred| !pred.has_escaping_bound_vars())\n+            .collect()\n     }\n \n-    fn from_object_ty(&mut self, ty: Ty<'tcx>,\n-                      data: ty::Binder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>,\n-                      region: ty::Region<'tcx>) {\n+    fn from_object_ty(\n+        &mut self,\n+        ty: Ty<'tcx>,\n+        data: ty::Binder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>,\n+        region: ty::Region<'tcx>,\n+    ) {\n         // Imagine a type like this:\n         //\n         //     trait Foo { }\n@@ -646,19 +644,20 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         // Note: in fact we only permit builtin traits, not `Bar<'d>`, I\n         // am looking forward to the future here.\n         if !data.has_escaping_bound_vars() && !region.has_escaping_bound_vars() {\n-            let implicit_bounds =\n-                object_region_bounds(self.infcx.tcx, data);\n+            let implicit_bounds = object_region_bounds(self.infcx.tcx, data);\n \n             let explicit_bound = region;\n \n             self.out.reserve(implicit_bounds.len());\n             for implicit_bound in implicit_bounds {\n                 let cause = self.cause(traits::ObjectTypeBound(ty, explicit_bound));\n-                let outlives = ty::Binder::dummy(\n-                    ty::OutlivesPredicate(explicit_bound, implicit_bound));\n-                self.out.push(traits::Obligation::new(cause,\n-                                                      self.param_env,\n-                                                      outlives.to_predicate()));\n+                let outlives =\n+                    ty::Binder::dummy(ty::OutlivesPredicate(explicit_bound, implicit_bound));\n+                self.out.push(traits::Obligation::new(\n+                    cause,\n+                    self.param_env,\n+                    outlives.to_predicate(),\n+                ));\n             }\n         }\n     }\n@@ -679,13 +678,16 @@ pub fn object_region_bounds<'tcx>(\n     // a placeholder type.\n     let open_ty = tcx.mk_ty_infer(ty::FreshTy(0));\n \n-    let predicates = existential_predicates.iter().filter_map(|predicate| {\n-        if let ty::ExistentialPredicate::Projection(_) = *predicate.skip_binder() {\n-            None\n-        } else {\n-            Some(predicate.with_self_ty(tcx, open_ty))\n-        }\n-    }).collect();\n+    let predicates = existential_predicates\n+        .iter()\n+        .filter_map(|predicate| {\n+            if let ty::ExistentialPredicate::Projection(_) = *predicate.skip_binder() {\n+                None\n+            } else {\n+                Some(predicate.with_self_ty(tcx, open_ty))\n+            }\n+        })\n+        .collect();\n \n     tcx.required_region_bounds(open_ty, predicates)\n }"}, {"sha": "818d09ce6914aa00342ae090043dba1994662869", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 251, "deletions": 242, "changes": 493, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d", "patch": "@@ -2,38 +2,38 @@ use crate::attributes;\n use crate::back::bytecode;\n use crate::back::lto::ThinBuffer;\n use crate::base;\n+use crate::common;\n use crate::consts;\n+use crate::context::{get_reloc_model, is_pie_binary};\n use crate::llvm::{self, DiagnosticInfo, PassManager, SMDiagnostic};\n use crate::llvm_util;\n-use crate::ModuleLlvm;\n use crate::type_::Type;\n-use crate::context::{is_pie_binary, get_reloc_model};\n-use crate::common;\n use crate::LlvmCodegenBackend;\n+use crate::ModuleLlvm;\n+use log::debug;\n use rustc::bug;\n use rustc::hir::def_id::LOCAL_CRATE;\n-use rustc_codegen_ssa::back::write::{CodegenContext, ModuleConfig, run_assembler};\n-use rustc_codegen_ssa::traits::*;\n-use rustc::session::config::{self, OutputType, Passes, Lto, Sanitizer, SwitchWithOptPath};\n+use rustc::session::config::{self, Lto, OutputType, Passes, Sanitizer, SwitchWithOptPath};\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n-use rustc_codegen_ssa::{RLIB_BYTECODE_EXTENSION, ModuleCodegen, CompiledModule};\n use rustc::util::common::time_ext;\n-use rustc_fs_util::{path_to_c_string, link_or_copy};\n+use rustc_codegen_ssa::back::write::{run_assembler, CodegenContext, ModuleConfig};\n+use rustc_codegen_ssa::traits::*;\n+use rustc_codegen_ssa::{CompiledModule, ModuleCodegen, RLIB_BYTECODE_EXTENSION};\n use rustc_data_structures::small_c_str::SmallCStr;\n-use rustc_errors::{Handler, FatalError};\n-use log::debug;\n+use rustc_errors::{FatalError, Handler};\n+use rustc_fs_util::{link_or_copy, path_to_c_string};\n \n+use libc::{c_char, c_int, c_uint, c_void, size_t};\n use std::ffi::CString;\n use std::fs;\n use std::io::{self, Write};\n use std::path::{Path, PathBuf};\n+use std::slice;\n use std::str;\n use std::sync::Arc;\n-use std::slice;\n-use libc::{c_int, c_uint, c_void, c_char, size_t};\n \n-pub const RELOC_MODEL_ARGS : [(&str, llvm::RelocMode); 7] = [\n+pub const RELOC_MODEL_ARGS: [(&str, llvm::RelocMode); 7] = [\n     (\"pic\", llvm::RelocMode::PIC),\n     (\"static\", llvm::RelocMode::Static),\n     (\"default\", llvm::RelocMode::Default),\n@@ -50,7 +50,7 @@ pub const CODE_GEN_MODEL_ARGS: &[(&str, llvm::CodeModel)] = &[\n     (\"large\", llvm::CodeModel::Large),\n ];\n \n-pub const TLS_MODEL_ARGS : [(&str, llvm::ThreadLocalMode); 4] = [\n+pub const TLS_MODEL_ARGS: [(&str, llvm::ThreadLocalMode); 4] = [\n     (\"global-dynamic\", llvm::ThreadLocalMode::GeneralDynamic),\n     (\"local-dynamic\", llvm::ThreadLocalMode::LocalDynamic),\n     (\"initial-exec\", llvm::ThreadLocalMode::InitialExec),\n@@ -65,12 +65,13 @@ pub fn llvm_err(handler: &rustc_errors::Handler, msg: &str) -> FatalError {\n }\n \n pub fn write_output_file(\n-        handler: &rustc_errors::Handler,\n-        target: &'ll llvm::TargetMachine,\n-        pm: &llvm::PassManager<'ll>,\n-        m: &'ll llvm::Module,\n-        output: &Path,\n-        file_type: llvm::FileType) -> Result<(), FatalError> {\n+    handler: &rustc_errors::Handler,\n+    target: &'ll llvm::TargetMachine,\n+    pm: &llvm::PassManager<'ll>,\n+    m: &'ll llvm::Module,\n+    output: &Path,\n+    file_type: llvm::FileType,\n+) -> Result<(), FatalError> {\n     unsafe {\n         let output_c = path_to_c_string(output);\n         let result = llvm::LLVMRustWriteOutputFile(target, pm, m, output_c.as_ptr(), file_type);\n@@ -85,23 +86,21 @@ pub fn create_informational_target_machine(\n     sess: &Session,\n     find_features: bool,\n ) -> &'static mut llvm::TargetMachine {\n-    target_machine_factory(sess, config::OptLevel::No, find_features)().unwrap_or_else(|err| {\n-        llvm_err(sess.diagnostic(), &err).raise()\n-    })\n+    target_machine_factory(sess, config::OptLevel::No, find_features)()\n+        .unwrap_or_else(|err| llvm_err(sess.diagnostic(), &err).raise())\n }\n \n pub fn create_target_machine(\n     tcx: TyCtxt<'_>,\n     find_features: bool,\n ) -> &'static mut llvm::TargetMachine {\n     target_machine_factory(&tcx.sess, tcx.backend_optimization_level(LOCAL_CRATE), find_features)()\n-    .unwrap_or_else(|err| {\n-        llvm_err(tcx.sess.diagnostic(), &err).raise()\n-    })\n+        .unwrap_or_else(|err| llvm_err(tcx.sess.diagnostic(), &err).raise())\n }\n \n-pub fn to_llvm_opt_settings(cfg: config::OptLevel) -> (llvm::CodeGenOptLevel, llvm::CodeGenOptSize)\n-{\n+pub fn to_llvm_opt_settings(\n+    cfg: config::OptLevel,\n+) -> (llvm::CodeGenOptLevel, llvm::CodeGenOptSize) {\n     use self::config::OptLevel::*;\n     match cfg {\n         No => (llvm::CodeGenOptLevel::None, llvm::CodeGenOptSizeNone),\n@@ -116,9 +115,11 @@ pub fn to_llvm_opt_settings(cfg: config::OptLevel) -> (llvm::CodeGenOptLevel, ll\n // If find_features is true this won't access `sess.crate_types` by assuming\n // that `is_pie_binary` is false. When we discover LLVM target features\n // `sess.crate_types` is uninitialized so we cannot access it.\n-pub fn target_machine_factory(sess: &Session, optlvl: config::OptLevel, find_features: bool)\n-    -> Arc<dyn Fn() -> Result<&'static mut llvm::TargetMachine, String> + Send + Sync>\n-{\n+pub fn target_machine_factory(\n+    sess: &Session,\n+    optlvl: config::OptLevel,\n+    find_features: bool,\n+) -> Arc<dyn Fn() -> Result<&'static mut llvm::TargetMachine, String> + Send + Sync> {\n     let reloc_model = get_reloc_model(sess);\n \n     let (opt_level, _) = to_llvm_opt_settings(optlvl);\n@@ -127,22 +128,18 @@ pub fn target_machine_factory(sess: &Session, optlvl: config::OptLevel, find_fea\n     let ffunction_sections = sess.target.target.options.function_sections;\n     let fdata_sections = ffunction_sections;\n \n-    let code_model_arg = sess.opts.cg.code_model.as_ref().or(\n-        sess.target.target.options.code_model.as_ref(),\n-    );\n+    let code_model_arg =\n+        sess.opts.cg.code_model.as_ref().or(sess.target.target.options.code_model.as_ref());\n \n     let code_model = match code_model_arg {\n-        Some(s) => {\n-            match CODE_GEN_MODEL_ARGS.iter().find(|arg| arg.0 == s) {\n-                Some(x) => x.1,\n-                _ => {\n-                    sess.err(&format!(\"{:?} is not a valid code model\",\n-                                      code_model_arg));\n-                    sess.abort_if_errors();\n-                    bug!();\n-                }\n+        Some(s) => match CODE_GEN_MODEL_ARGS.iter().find(|arg| arg.0 == s) {\n+            Some(x) => x.1,\n+            _ => {\n+                sess.err(&format!(\"{:?} is not a valid code model\", code_model_arg));\n+                sess.abort_if_errors();\n+                bug!();\n             }\n-        }\n+        },\n         None => llvm::CodeModel::None,\n     };\n \n@@ -152,9 +149,9 @@ pub fn target_machine_factory(sess: &Session, optlvl: config::OptLevel, find_fea\n     // On the wasm target once the `atomics` feature is enabled that means that\n     // we're no longer single-threaded, or otherwise we don't want LLVM to\n     // lower atomic operations to single-threaded operations.\n-    if singlethread &&\n-        sess.target.target.llvm_target.contains(\"wasm32\") &&\n-        features.iter().any(|s| *s == \"+atomics\")\n+    if singlethread\n+        && sess.target.target.llvm_target.contains(\"wasm32\")\n+        && features.iter().any(|s| *s == \"+atomics\")\n     {\n         singlethread = false;\n     }\n@@ -173,7 +170,10 @@ pub fn target_machine_factory(sess: &Session, optlvl: config::OptLevel, find_fea\n     Arc::new(move || {\n         let tm = unsafe {\n             llvm::LLVMRustCreateTargetMachine(\n-                triple.as_ptr(), cpu.as_ptr(), features.as_ptr(), abi.as_ptr(),\n+                triple.as_ptr(),\n+                cpu.as_ptr(),\n+                features.as_ptr(),\n+                abi.as_ptr(),\n                 code_model,\n                 reloc_model,\n                 opt_level,\n@@ -190,19 +190,18 @@ pub fn target_machine_factory(sess: &Session, optlvl: config::OptLevel, find_fea\n         };\n \n         tm.ok_or_else(|| {\n-            format!(\"Could not create LLVM TargetMachine for triple: {}\",\n-                    triple.to_str().unwrap())\n+            format!(\"Could not create LLVM TargetMachine for triple: {}\", triple.to_str().unwrap())\n         })\n     })\n }\n \n pub(crate) fn save_temp_bitcode(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n     module: &ModuleCodegen<ModuleLlvm>,\n-    name: &str\n+    name: &str,\n ) {\n     if !cgcx.save_temps {\n-        return\n+        return;\n     }\n     unsafe {\n         let ext = format!(\"{}.bc\", name);\n@@ -220,9 +219,11 @@ pub struct DiagnosticHandlers<'a> {\n }\n \n impl<'a> DiagnosticHandlers<'a> {\n-    pub fn new(cgcx: &'a CodegenContext<LlvmCodegenBackend>,\n-               handler: &'a Handler,\n-               llcx: &'a llvm::Context) -> Self {\n+    pub fn new(\n+        cgcx: &'a CodegenContext<LlvmCodegenBackend>,\n+        handler: &'a Handler,\n+        llcx: &'a llvm::Context,\n+    ) -> Self {\n         let data = Box::into_raw(Box::new((cgcx, handler)));\n         unsafe {\n             llvm::LLVMRustSetInlineAsmDiagnosticHandler(llcx, inline_asm_handler, data.cast());\n@@ -243,17 +244,17 @@ impl<'a> Drop for DiagnosticHandlers<'a> {\n     }\n }\n \n-unsafe extern \"C\" fn report_inline_asm(cgcx: &CodegenContext<LlvmCodegenBackend>,\n-                                       msg: &str,\n-                                       cookie: c_uint) {\n+unsafe extern \"C\" fn report_inline_asm(\n+    cgcx: &CodegenContext<LlvmCodegenBackend>,\n+    msg: &str,\n+    cookie: c_uint,\n+) {\n     cgcx.diag_emitter.inline_asm_error(cookie as u32, msg.to_owned());\n }\n \n-unsafe extern \"C\" fn inline_asm_handler(diag: &SMDiagnostic,\n-                                        user: *const c_void,\n-                                        cookie: c_uint) {\n+unsafe extern \"C\" fn inline_asm_handler(diag: &SMDiagnostic, user: *const c_void, cookie: c_uint) {\n     if user.is_null() {\n-        return\n+        return;\n     }\n     let (cgcx, _) = *(user as *const (&CodegenContext<LlvmCodegenBackend>, &Handler));\n \n@@ -265,15 +266,13 @@ unsafe extern \"C\" fn inline_asm_handler(diag: &SMDiagnostic,\n \n unsafe extern \"C\" fn diagnostic_handler(info: &DiagnosticInfo, user: *mut c_void) {\n     if user.is_null() {\n-        return\n+        return;\n     }\n     let (cgcx, diag_handler) = *(user as *const (&CodegenContext<LlvmCodegenBackend>, &Handler));\n \n     match llvm::diagnostic::Diagnostic::unpack(info) {\n         llvm::diagnostic::InlineAsm(inline) => {\n-            report_inline_asm(cgcx,\n-                              &llvm::twine_to_string(inline.message),\n-                              inline.cookie);\n+            report_inline_asm(cgcx, &llvm::twine_to_string(inline.message), inline.cookie);\n         }\n \n         llvm::diagnostic::Optimization(opt) => {\n@@ -283,33 +282,35 @@ unsafe extern \"C\" fn diagnostic_handler(info: &DiagnosticInfo, user: *mut c_void\n             };\n \n             if enabled {\n-                diag_handler.note_without_error(&format!(\"optimization {} for {} at {}:{}:{}: {}\",\n-                                                opt.kind.describe(),\n-                                                opt.pass_name,\n-                                                opt.filename,\n-                                                opt.line,\n-                                                opt.column,\n-                                                opt.message));\n+                diag_handler.note_without_error(&format!(\n+                    \"optimization {} for {} at {}:{}:{}: {}\",\n+                    opt.kind.describe(),\n+                    opt.pass_name,\n+                    opt.filename,\n+                    opt.line,\n+                    opt.column,\n+                    opt.message\n+                ));\n             }\n         }\n-        llvm::diagnostic::PGO(diagnostic_ref) |\n-        llvm::diagnostic::Linker(diagnostic_ref) => {\n+        llvm::diagnostic::PGO(diagnostic_ref) | llvm::diagnostic::Linker(diagnostic_ref) => {\n             let msg = llvm::build_string(|s| {\n                 llvm::LLVMRustWriteDiagnosticInfoToString(diagnostic_ref, s)\n-            }).expect(\"non-UTF8 diagnostic\");\n+            })\n+            .expect(\"non-UTF8 diagnostic\");\n             diag_handler.warn(&msg);\n         }\n-        llvm::diagnostic::UnknownDiagnostic(..) => {},\n+        llvm::diagnostic::UnknownDiagnostic(..) => {}\n     }\n }\n \n // Unsafe due to LLVM calls.\n-pub(crate) unsafe fn optimize(cgcx: &CodegenContext<LlvmCodegenBackend>,\n-                   diag_handler: &Handler,\n-                   module: &ModuleCodegen<ModuleLlvm>,\n-                   config: &ModuleConfig)\n-    -> Result<(), FatalError>\n-{\n+pub(crate) unsafe fn optimize(\n+    cgcx: &CodegenContext<LlvmCodegenBackend>,\n+    diag_handler: &Handler,\n+    module: &ModuleCodegen<ModuleLlvm>,\n+    config: &ModuleConfig,\n+) -> Result<(), FatalError> {\n     let _timer = cgcx.prof.generic_activity(\"LLVM_module_optimize\");\n \n     let llmod = module.module_llvm.llmod();\n@@ -376,11 +377,15 @@ pub(crate) unsafe fn optimize(cgcx: &CodegenContext<LlvmCodegenBackend>,\n                 llvm::LLVMAddAnalysisPasses(tm, fpm);\n                 llvm::LLVMAddAnalysisPasses(tm, mpm);\n                 let opt_level = to_llvm_opt_settings(opt_level).0;\n-                let prepare_for_thin_lto = cgcx.lto == Lto::Thin || cgcx.lto == Lto::ThinLocal ||\n-                    (cgcx.lto != Lto::Fat && cgcx.opts.cg.linker_plugin_lto.enabled());\n+                let prepare_for_thin_lto = cgcx.lto == Lto::Thin\n+                    || cgcx.lto == Lto::ThinLocal\n+                    || (cgcx.lto != Lto::Fat && cgcx.opts.cg.linker_plugin_lto.enabled());\n                 with_llvm_pmb(llmod, &config, opt_level, prepare_for_thin_lto, &mut |b| {\n                     llvm::LLVMRustAddLastExtensionPasses(\n-                        b, extra_passes.as_ptr(), extra_passes.len() as size_t);\n+                        b,\n+                        extra_passes.as_ptr(),\n+                        extra_passes.len() as size_t,\n+                    );\n                     llvm::LLVMPassManagerBuilderPopulateFunctionPassManager(b, fpm);\n                     llvm::LLVMPassManagerBuilderPopulateModulePassManager(b, mpm);\n                 });\n@@ -401,13 +406,17 @@ pub(crate) unsafe fn optimize(cgcx: &CodegenContext<LlvmCodegenBackend>,\n             if using_thin_buffers && !have_name_anon_globals_pass {\n                 // As described above, this will probably cause an error in LLVM\n                 if config.no_prepopulate_passes {\n-                    diag_handler.err(\"The current compilation is going to use thin LTO buffers \\\n+                    diag_handler.err(\n+                        \"The current compilation is going to use thin LTO buffers \\\n                                       without running LLVM's NameAnonGlobals pass. \\\n                                       This will likely cause errors in LLVM. Consider adding \\\n-                                      -C passes=name-anon-globals to the compiler command line.\");\n+                                      -C passes=name-anon-globals to the compiler command line.\",\n+                    );\n                 } else {\n-                    bug!(\"We are using thin LTO buffers without running the NameAnonGlobals pass. \\\n-                          This will likely cause errors in LLVM and should never happen.\");\n+                    bug!(\n+                        \"We are using thin LTO buffers without running the NameAnonGlobals pass. \\\n+                          This will likely cause errors in LLVM and should never happen.\"\n+                    );\n                 }\n             }\n         }\n@@ -417,19 +426,19 @@ pub(crate) unsafe fn optimize(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         // Finally, run the actual optimization passes\n         {\n             let _timer = cgcx.prof.generic_activity(\"LLVM_module_optimize_function_passes\");\n-            time_ext(config.time_passes,\n-                        &format!(\"llvm function passes [{}]\", module_name.unwrap()),\n-                        || {\n-                llvm::LLVMRustRunFunctionPassManager(fpm, llmod)\n-            });\n+            time_ext(\n+                config.time_passes,\n+                &format!(\"llvm function passes [{}]\", module_name.unwrap()),\n+                || llvm::LLVMRustRunFunctionPassManager(fpm, llmod),\n+            );\n         }\n         {\n             let _timer = cgcx.prof.generic_activity(\"LLVM_module_optimize_module_passes\");\n-            time_ext(config.time_passes,\n-                    &format!(\"llvm module passes [{}]\", module_name.unwrap()),\n-                    || {\n-                llvm::LLVMRunPassManager(mpm, llmod)\n-            });\n+            time_ext(\n+                config.time_passes,\n+                &format!(\"llvm module passes [{}]\", module_name.unwrap()),\n+                || llvm::LLVMRunPassManager(mpm, llmod),\n+            );\n         }\n \n         // Deallocate managers that we're now done with\n@@ -439,9 +448,7 @@ pub(crate) unsafe fn optimize(cgcx: &CodegenContext<LlvmCodegenBackend>,\n     Ok(())\n }\n \n-unsafe fn add_sanitizer_passes(config: &ModuleConfig,\n-                               passes: &mut Vec<&'static mut llvm::Pass>) {\n-\n+unsafe fn add_sanitizer_passes(config: &ModuleConfig, passes: &mut Vec<&'static mut llvm::Pass>) {\n     let sanitizer = match &config.sanitizer {\n         None => return,\n         Some(s) => s,\n@@ -464,12 +471,12 @@ unsafe fn add_sanitizer_passes(config: &ModuleConfig,\n     }\n }\n \n-pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n-                  diag_handler: &Handler,\n-                  module: ModuleCodegen<ModuleLlvm>,\n-                  config: &ModuleConfig)\n-    -> Result<CompiledModule, FatalError>\n-{\n+pub(crate) unsafe fn codegen(\n+    cgcx: &CodegenContext<LlvmCodegenBackend>,\n+    diag_handler: &Handler,\n+    module: ModuleCodegen<ModuleLlvm>,\n+    config: &ModuleConfig,\n+) -> Result<CompiledModule, FatalError> {\n     let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen\");\n     {\n         let llmod = module.module_llvm.llmod();\n@@ -491,11 +498,14 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         // pass manager passed to the closure should be ensured to not\n         // escape the closure itself, and the manager should only be\n         // used once.\n-        unsafe fn with_codegen<'ll, F, R>(tm: &'ll llvm::TargetMachine,\n-                                          llmod: &'ll llvm::Module,\n-                                          no_builtins: bool,\n-                                          f: F) -> R\n-            where F: FnOnce(&'ll mut PassManager<'ll>) -> R,\n+        unsafe fn with_codegen<'ll, F, R>(\n+            tm: &'ll llvm::TargetMachine,\n+            llmod: &'ll llvm::Module,\n+            no_builtins: bool,\n+            f: F,\n+        ) -> R\n+        where\n+            F: FnOnce(&'ll mut PassManager<'ll>) -> R,\n         {\n             let cpm = llvm::LLVMCreatePassManager();\n             llvm::LLVMAddAnalysisPasses(tm, cpm);\n@@ -519,7 +529,6 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         let bc_out = cgcx.output_filenames.temp_path(OutputType::Bitcode, module_name);\n         let obj_out = cgcx.output_filenames.temp_path(OutputType::Object, module_name);\n \n-\n         if write_bc || config.emit_bc_compressed || config.embed_bitcode {\n             let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_make_bitcode\");\n             let thin = ThinBuffer::new(llmod);\n@@ -552,88 +561,103 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n             embed_bitcode(cgcx, llcx, llmod, None);\n         }\n \n-        time_ext(config.time_passes, &format!(\"codegen passes [{}]\", module_name.unwrap()),\n+        time_ext(\n+            config.time_passes,\n+            &format!(\"codegen passes [{}]\", module_name.unwrap()),\n             || -> Result<(), FatalError> {\n-            if config.emit_ir {\n-                let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_ir\");\n-                let out = cgcx.output_filenames.temp_path(OutputType::LlvmAssembly, module_name);\n-                let out_c = path_to_c_string(&out);\n-\n-                extern \"C\" fn demangle_callback(input_ptr: *const c_char,\n-                                                input_len: size_t,\n-                                                output_ptr: *mut c_char,\n-                                                output_len: size_t) -> size_t {\n-                    let input = unsafe {\n-                        slice::from_raw_parts(input_ptr as *const u8, input_len as usize)\n-                    };\n-\n-                    let input = match str::from_utf8(input) {\n-                        Ok(s) => s,\n-                        Err(_) => return 0,\n-                    };\n-\n-                    let output = unsafe {\n-                        slice::from_raw_parts_mut(output_ptr as *mut u8, output_len as usize)\n-                    };\n-                    let mut cursor = io::Cursor::new(output);\n-\n-                    let demangled = match rustc_demangle::try_demangle(input) {\n-                        Ok(d) => d,\n-                        Err(_) => return 0,\n-                    };\n-\n-                    if let Err(_) = write!(cursor, \"{:#}\", demangled) {\n-                        // Possible only if provided buffer is not big enough\n-                        return 0;\n+                if config.emit_ir {\n+                    let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_ir\");\n+                    let out =\n+                        cgcx.output_filenames.temp_path(OutputType::LlvmAssembly, module_name);\n+                    let out_c = path_to_c_string(&out);\n+\n+                    extern \"C\" fn demangle_callback(\n+                        input_ptr: *const c_char,\n+                        input_len: size_t,\n+                        output_ptr: *mut c_char,\n+                        output_len: size_t,\n+                    ) -> size_t {\n+                        let input = unsafe {\n+                            slice::from_raw_parts(input_ptr as *const u8, input_len as usize)\n+                        };\n+\n+                        let input = match str::from_utf8(input) {\n+                            Ok(s) => s,\n+                            Err(_) => return 0,\n+                        };\n+\n+                        let output = unsafe {\n+                            slice::from_raw_parts_mut(output_ptr as *mut u8, output_len as usize)\n+                        };\n+                        let mut cursor = io::Cursor::new(output);\n+\n+                        let demangled = match rustc_demangle::try_demangle(input) {\n+                            Ok(d) => d,\n+                            Err(_) => return 0,\n+                        };\n+\n+                        if let Err(_) = write!(cursor, \"{:#}\", demangled) {\n+                            // Possible only if provided buffer is not big enough\n+                            return 0;\n+                        }\n+\n+                        cursor.position() as size_t\n                     }\n \n-                    cursor.position() as size_t\n+                    let result =\n+                        llvm::LLVMRustPrintModule(llmod, out_c.as_ptr(), demangle_callback);\n+                    result.into_result().map_err(|()| {\n+                        let msg = format!(\"failed to write LLVM IR to {}\", out.display());\n+                        llvm_err(diag_handler, &msg)\n+                    })?;\n                 }\n \n-                let result =\n-                    llvm::LLVMRustPrintModule(llmod, out_c.as_ptr(), demangle_callback);\n-                result.into_result().map_err(|()| {\n-                    let msg = format!(\"failed to write LLVM IR to {}\", out.display());\n-                    llvm_err(diag_handler, &msg)\n-                })?;\n-            }\n-\n-            if config.emit_asm || asm_to_obj {\n-                let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_asm\");\n-                let path = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n-\n-                // We can't use the same module for asm and binary output, because that triggers\n-                // various errors like invalid IR or broken binaries, so we might have to clone the\n-                // module to produce the asm output\n-                let llmod = if config.emit_obj {\n-                    llvm::LLVMCloneModule(llmod)\n-                } else {\n-                    llmod\n-                };\n-                with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                    write_output_file(diag_handler, tm, cpm, llmod, &path,\n-                                      llvm::FileType::AssemblyFile)\n-                })?;\n-            }\n+                if config.emit_asm || asm_to_obj {\n+                    let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_asm\");\n+                    let path = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n+\n+                    // We can't use the same module for asm and binary output, because that triggers\n+                    // various errors like invalid IR or broken binaries, so we might have to clone the\n+                    // module to produce the asm output\n+                    let llmod = if config.emit_obj { llvm::LLVMCloneModule(llmod) } else { llmod };\n+                    with_codegen(tm, llmod, config.no_builtins, |cpm| {\n+                        write_output_file(\n+                            diag_handler,\n+                            tm,\n+                            cpm,\n+                            llmod,\n+                            &path,\n+                            llvm::FileType::AssemblyFile,\n+                        )\n+                    })?;\n+                }\n \n-            if write_obj {\n-                let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_obj\");\n-                with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                    write_output_file(diag_handler, tm, cpm, llmod, &obj_out,\n-                                      llvm::FileType::ObjectFile)\n-                })?;\n-            } else if asm_to_obj {\n-                let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_asm_to_obj\");\n-                let assembly = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n-                run_assembler(cgcx, diag_handler, &assembly, &obj_out);\n-\n-                if !config.emit_asm && !cgcx.save_temps {\n-                    drop(fs::remove_file(&assembly));\n+                if write_obj {\n+                    let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_obj\");\n+                    with_codegen(tm, llmod, config.no_builtins, |cpm| {\n+                        write_output_file(\n+                            diag_handler,\n+                            tm,\n+                            cpm,\n+                            llmod,\n+                            &obj_out,\n+                            llvm::FileType::ObjectFile,\n+                        )\n+                    })?;\n+                } else if asm_to_obj {\n+                    let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_asm_to_obj\");\n+                    let assembly =\n+                        cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n+                    run_assembler(cgcx, diag_handler, &assembly, &obj_out);\n+\n+                    if !config.emit_asm && !cgcx.save_temps {\n+                        drop(fs::remove_file(&assembly));\n+                    }\n                 }\n-            }\n \n-            Ok(())\n-        })?;\n+                Ok(())\n+            },\n+        )?;\n \n         if copy_bc_to_obj {\n             debug!(\"copying bitcode {:?} to obj {:?}\", bc_out, obj_out);\n@@ -651,10 +675,12 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n \n         drop(handlers);\n     }\n-    Ok(module.into_compiled_module(config.emit_obj,\n-                                   config.emit_bc,\n-                                   config.emit_bc_compressed,\n-                                   &cgcx.output_filenames))\n+    Ok(module.into_compiled_module(\n+        config.emit_obj,\n+        config.emit_bc,\n+        config.emit_bc_compressed,\n+        &cgcx.output_filenames,\n+    ))\n }\n \n /// Embed the bitcode of an LLVM module in the LLVM module itself.\n@@ -675,10 +701,12 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n ///\n /// Basically all of this is us attempting to follow in the footsteps of clang\n /// on iOS. See #35968 for lots more info.\n-unsafe fn embed_bitcode(cgcx: &CodegenContext<LlvmCodegenBackend>,\n-                        llcx: &llvm::Context,\n-                        llmod: &llvm::Module,\n-                        bitcode: Option<&[u8]>) {\n+unsafe fn embed_bitcode(\n+    cgcx: &CodegenContext<LlvmCodegenBackend>,\n+    llcx: &llvm::Context,\n+    llmod: &llvm::Module,\n+    bitcode: Option<&[u8]>,\n+) {\n     let llconst = common::bytes_in_context(llcx, bitcode.unwrap_or(&[]));\n     let llglobal = llvm::LLVMAddGlobal(\n         llmod,\n@@ -687,14 +715,10 @@ unsafe fn embed_bitcode(cgcx: &CodegenContext<LlvmCodegenBackend>,\n     );\n     llvm::LLVMSetInitializer(llglobal, llconst);\n \n-    let is_apple = cgcx.opts.target_triple.triple().contains(\"-ios\") ||\n-                   cgcx.opts.target_triple.triple().contains(\"-darwin\");\n+    let is_apple = cgcx.opts.target_triple.triple().contains(\"-ios\")\n+        || cgcx.opts.target_triple.triple().contains(\"-darwin\");\n \n-    let section = if is_apple {\n-        \"__LLVM,__bitcode\\0\"\n-    } else {\n-        \".llvmbc\\0\"\n-    };\n+    let section = if is_apple { \"__LLVM,__bitcode\\0\" } else { \".llvmbc\\0\" };\n     llvm::LLVMSetSection(llglobal, section.as_ptr().cast());\n     llvm::LLVMRustSetLinkage(llglobal, llvm::Linkage::PrivateLinkage);\n     llvm::LLVMSetGlobalConstant(llglobal, llvm::True);\n@@ -706,28 +730,26 @@ unsafe fn embed_bitcode(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         \"rustc.embedded.cmdline\\0\".as_ptr().cast(),\n     );\n     llvm::LLVMSetInitializer(llglobal, llconst);\n-    let section = if  is_apple {\n-        \"__LLVM,__cmdline\\0\"\n-    } else {\n-        \".llvmcmd\\0\"\n-    };\n+    let section = if is_apple { \"__LLVM,__cmdline\\0\" } else { \".llvmcmd\\0\" };\n     llvm::LLVMSetSection(llglobal, section.as_ptr().cast());\n     llvm::LLVMRustSetLinkage(llglobal, llvm::Linkage::PrivateLinkage);\n }\n \n-pub unsafe fn with_llvm_pmb(llmod: &llvm::Module,\n-                            config: &ModuleConfig,\n-                            opt_level: llvm::CodeGenOptLevel,\n-                            prepare_for_thin_lto: bool,\n-                            f: &mut dyn FnMut(&llvm::PassManagerBuilder)) {\n+pub unsafe fn with_llvm_pmb(\n+    llmod: &llvm::Module,\n+    config: &ModuleConfig,\n+    opt_level: llvm::CodeGenOptLevel,\n+    prepare_for_thin_lto: bool,\n+    f: &mut dyn FnMut(&llvm::PassManagerBuilder),\n+) {\n     use std::ptr;\n \n     // Create the PassManagerBuilder for LLVM. We configure it with\n     // reasonable defaults and prepare it to actually populate the pass\n     // manager.\n     let builder = llvm::LLVMPassManagerBuilderCreate();\n-    let opt_size = config.opt_size.map(|x| to_llvm_opt_settings(x).1)\n-        .unwrap_or(llvm::CodeGenOptSizeNone);\n+    let opt_size =\n+        config.opt_size.map(|x| to_llvm_opt_settings(x).1).unwrap_or(llvm::CodeGenOptSizeNone);\n     let inline_threshold = config.inline_threshold;\n \n     let pgo_gen_path = match config.pgo_gen {\n@@ -740,14 +762,13 @@ pub unsafe fn with_llvm_pmb(llmod: &llvm::Module,\n \n             Some(CString::new(format!(\"{}\", path.display())).unwrap())\n         }\n-        SwitchWithOptPath::Disabled => {\n-            None\n-        }\n+        SwitchWithOptPath::Disabled => None,\n     };\n \n-    let pgo_use_path = config.pgo_use.as_ref().map(|path_buf| {\n-        CString::new(path_buf.to_string_lossy().as_bytes()).unwrap()\n-    });\n+    let pgo_use_path = config\n+        .pgo_use\n+        .as_ref()\n+        .map(|path_buf| CString::new(path_buf.to_string_lossy().as_bytes()).unwrap());\n \n     llvm::LLVMRustConfigurePassManagerBuilder(\n         builder,\n@@ -794,9 +815,7 @@ pub unsafe fn with_llvm_pmb(llmod: &llvm::Module,\n         (llvm::CodeGenOptLevel::Default, ..) => {\n             llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, 225);\n         }\n-        (llvm::CodeGenOptLevel::Other, ..) => {\n-            bug!(\"CodeGenOptLevel::Other selected\")\n-        }\n+        (llvm::CodeGenOptLevel::Other, ..) => bug!(\"CodeGenOptLevel::Other selected\"),\n     }\n \n     f(builder);\n@@ -811,36 +830,28 @@ pub unsafe fn with_llvm_pmb(llmod: &llvm::Module,\n fn create_msvc_imps(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n     llcx: &llvm::Context,\n-    llmod: &llvm::Module\n+    llmod: &llvm::Module,\n ) {\n     if !cgcx.msvc_imps_needed {\n-        return\n+        return;\n     }\n     // The x86 ABI seems to require that leading underscores are added to symbol\n     // names, so we need an extra underscore on x86. There's also a leading\n     // '\\x01' here which disables LLVM's symbol mangling (e.g., no extra\n     // underscores added in front).\n-    let prefix = if cgcx.target_arch == \"x86\" {\n-        \"\\x01__imp__\"\n-    } else {\n-        \"\\x01__imp_\"\n-    };\n+    let prefix = if cgcx.target_arch == \"x86\" { \"\\x01__imp__\" } else { \"\\x01__imp_\" };\n \n     unsafe {\n         let i8p_ty = Type::i8p_llcx(llcx);\n         let globals = base::iter_globals(llmod)\n             .filter(|&val| {\n-                llvm::LLVMRustGetLinkage(val) == llvm::Linkage::ExternalLinkage &&\n-                    llvm::LLVMIsDeclaration(val) == 0\n+                llvm::LLVMRustGetLinkage(val) == llvm::Linkage::ExternalLinkage\n+                    && llvm::LLVMIsDeclaration(val) == 0\n             })\n             .filter_map(|val| {\n                 // Exclude some symbols that we know are not Rust symbols.\n                 let name = llvm::get_value_name(val);\n-                if ignored(name) {\n-                    None\n-                } else {\n-                    Some((val, name))\n-                }\n+                if ignored(name) { None } else { Some((val, name)) }\n             })\n             .map(move |(val, name)| {\n                 let mut imp_name = prefix.as_bytes().to_vec();\n@@ -851,9 +862,7 @@ fn create_msvc_imps(\n             .collect::<Vec<_>>();\n \n         for (imp_name, val) in globals {\n-            let imp = llvm::LLVMAddGlobal(llmod,\n-                                          i8p_ty,\n-                                          imp_name.as_ptr().cast());\n+            let imp = llvm::LLVMAddGlobal(llmod, i8p_ty, imp_name.as_ptr().cast());\n             llvm::LLVMSetInitializer(imp, consts::ptrcast(val, i8p_ty));\n             llvm::LLVMRustSetLinkage(imp, llvm::Linkage::ExternalLinkage);\n         }"}, {"sha": "12c44513159ba24a6dd7f9a5c5579dc121472044", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 59, "deletions": 73, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d", "patch": "@@ -1,27 +1,26 @@\n-use crate::llvm::{self, SetUnnamedAddr, True};\n-use crate::debuginfo;\n-use crate::common::CodegenCx;\n use crate::base;\n+use crate::common::CodegenCx;\n+use crate::debuginfo;\n+use crate::llvm::{self, SetUnnamedAddr, True};\n use crate::type_::Type;\n use crate::type_of::LayoutLlvmExt;\n use crate::value::Value;\n use libc::c_uint;\n+use log::debug;\n use rustc::hir::def_id::DefId;\n-use rustc::mir::interpret::{ConstValue, Allocation, read_target_uint,\n-    Pointer, ErrorHandled};\n-use rustc::mir::mono::MonoItem;\n use rustc::hir::Node;\n-use rustc_target::abi::HasDataLayout;\n-use rustc::ty::{self, Ty, Instance};\n+use rustc::mir::interpret::{read_target_uint, Allocation, ConstValue, ErrorHandled, Pointer};\n+use rustc::mir::mono::MonoItem;\n+use rustc::ty::{self, Instance, Ty};\n+use rustc::{bug, span_bug};\n use rustc_codegen_ssa::traits::*;\n-use syntax::symbol::{Symbol, sym};\n+use rustc_target::abi::HasDataLayout;\n+use syntax::symbol::{sym, Symbol};\n use syntax_pos::Span;\n-use rustc::{bug, span_bug};\n-use log::debug;\n \n-use rustc::ty::layout::{self, Size, Align, LayoutOf};\n+use rustc::ty::layout::{self, Align, LayoutOf, Size};\n \n-use rustc::hir::{self, CodegenFnAttrs, CodegenFnAttrFlags};\n+use rustc::hir::{self, CodegenFnAttrFlags, CodegenFnAttrs};\n \n use std::ffi::CStr;\n \n@@ -51,14 +50,13 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n             // affect interpreter execution (we inspect the result after interpreter execution),\n             // and we properly interpret the relocation as a relocation pointer offset.\n             alloc.inspect_with_undef_and_ptr_outside_interpreter(offset..(offset + pointer_size)),\n-        ).expect(\"const_alloc_to_llvm: could not read relocation pointer\") as u64;\n+        )\n+        .expect(\"const_alloc_to_llvm: could not read relocation pointer\")\n+            as u64;\n         llvals.push(cx.scalar_to_backend(\n             Pointer::new(alloc_id, Size::from_bytes(ptr_offset)).into(),\n-            &layout::Scalar {\n-                value: layout::Primitive::Pointer,\n-                valid_range: 0..=!0\n-            },\n-            cx.type_i8p()\n+            &layout::Scalar { value: layout::Primitive::Pointer, valid_range: 0..=!0 },\n+            cx.type_i8p(),\n         ));\n         next_offset = offset + pointer_size;\n     }\n@@ -84,19 +82,13 @@ pub fn codegen_static_initializer(\n     let static_ = cx.tcx.const_eval_poly(def_id)?;\n \n     let alloc = match static_.val {\n-        ty::ConstKind::Value(ConstValue::ByRef {\n-            alloc, offset,\n-        }) if offset.bytes() == 0 => {\n-            alloc\n-        },\n+        ty::ConstKind::Value(ConstValue::ByRef { alloc, offset }) if offset.bytes() == 0 => alloc,\n         _ => bug!(\"static const eval returned {:#?}\", static_),\n     };\n     Ok((const_alloc_to_llvm(cx, alloc), alloc))\n }\n \n-fn set_global_alignment(cx: &CodegenCx<'ll, '_>,\n-                        gv: &'ll Value,\n-                        mut align: Align) {\n+fn set_global_alignment(cx: &CodegenCx<'ll, '_>, gv: &'ll Value, mut align: Align) {\n     // The target may require greater alignment for globals than the type does.\n     // Note: GCC and Clang also allow `__attribute__((aligned))` on variables,\n     // which can force it to be smaller.  Rust doesn't support this yet.\n@@ -118,7 +110,7 @@ fn check_and_apply_linkage(\n     attrs: &CodegenFnAttrs,\n     ty: Ty<'tcx>,\n     sym: Symbol,\n-    span: Span\n+    span: Span,\n ) -> &'ll Value {\n     let llty = cx.layout_of(ty).llvm_type(cx);\n     let sym = sym.as_str();\n@@ -134,7 +126,9 @@ fn check_and_apply_linkage(\n             cx.layout_of(mt.ty).llvm_type(cx)\n         } else {\n             cx.sess().span_fatal(\n-                span, \"must have type `*const T` or `*mut T` due to `#[linkage]` attribute\")\n+                span,\n+                \"must have type `*const T` or `*mut T` due to `#[linkage]` attribute\",\n+            )\n         };\n         unsafe {\n             // Declare a symbol `foo` with the desired linkage.\n@@ -149,7 +143,7 @@ fn check_and_apply_linkage(\n             // zero.\n             let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n             real_name.push_str(&sym);\n-            let g2 = cx.define_global(&real_name, llty).unwrap_or_else(||{\n+            let g2 = cx.define_global(&real_name, llty).unwrap_or_else(|| {\n                 cx.sess().span_fatal(span, &format!(\"symbol `{}` is already defined\", &sym))\n             });\n             llvm::LLVMRustSetLinkage(g2, llvm::Linkage::InternalLinkage);\n@@ -164,16 +158,12 @@ fn check_and_apply_linkage(\n }\n \n pub fn ptrcast(val: &'ll Value, ty: &'ll Type) -> &'ll Value {\n-    unsafe {\n-        llvm::LLVMConstPointerCast(val, ty)\n-    }\n+    unsafe { llvm::LLVMConstPointerCast(val, ty) }\n }\n \n impl CodegenCx<'ll, 'tcx> {\n     crate fn const_bitcast(&self, val: &'ll Value, ty: &'ll Type) -> &'ll Value {\n-        unsafe {\n-            llvm::LLVMConstBitCast(val, ty)\n-        }\n+        unsafe { llvm::LLVMConstBitCast(val, ty) }\n     }\n \n     crate fn static_addr_of_mut(\n@@ -186,13 +176,12 @@ impl CodegenCx<'ll, 'tcx> {\n             let gv = match kind {\n                 Some(kind) if !self.tcx.sess.fewer_names() => {\n                     let name = self.generate_local_symbol_name(kind);\n-                    let gv = self.define_global(&name[..],\n-                        self.val_ty(cv)).unwrap_or_else(||{\n-                            bug!(\"symbol `{}` is already defined\", name);\n+                    let gv = self.define_global(&name[..], self.val_ty(cv)).unwrap_or_else(|| {\n+                        bug!(\"symbol `{}` is already defined\", name);\n                     });\n                     llvm::LLVMRustSetLinkage(gv, llvm::Linkage::PrivateLinkage);\n                     gv\n-                },\n+                }\n                 _ => self.define_private_global(self.val_ty(cv)),\n             };\n             llvm::LLVMSetInitializer(gv, cv);\n@@ -208,26 +197,24 @@ impl CodegenCx<'ll, 'tcx> {\n             return g;\n         }\n \n-        let defined_in_current_codegen_unit = self.codegen_unit\n-                                                .items()\n-                                                .contains_key(&MonoItem::Static(def_id));\n-        assert!(!defined_in_current_codegen_unit,\n-                \"consts::get_static() should always hit the cache for \\\n+        let defined_in_current_codegen_unit =\n+            self.codegen_unit.items().contains_key(&MonoItem::Static(def_id));\n+        assert!(\n+            !defined_in_current_codegen_unit,\n+            \"consts::get_static() should always hit the cache for \\\n                  statics defined in the same CGU, but did not for `{:?}`\",\n-                 def_id);\n+            def_id\n+        );\n \n         let ty = instance.ty(self.tcx);\n         let sym = self.tcx.symbol_name(instance).name;\n \n         debug!(\"get_static: sym={} instance={:?}\", sym, instance);\n \n         let g = if let Some(id) = self.tcx.hir().as_local_hir_id(def_id) {\n-\n             let llty = self.layout_of(ty).llvm_type(self);\n             let (g, attrs) = match self.tcx.hir().get(id) {\n-                Node::Item(&hir::Item {\n-                    attrs, span, kind: hir::ItemKind::Static(..), ..\n-                }) => {\n+                Node::Item(&hir::Item { attrs, span, kind: hir::ItemKind::Static(..), .. }) => {\n                     let sym_str = sym.as_str();\n                     if let Some(g) = self.get_declared_value(&sym_str) {\n                         if self.val_ty(g) != self.type_ptr_to(llty) {\n@@ -247,13 +234,16 @@ impl CodegenCx<'ll, 'tcx> {\n                 }\n \n                 Node::ForeignItem(&hir::ForeignItem {\n-                    ref attrs, span, kind: hir::ForeignItemKind::Static(..), ..\n+                    ref attrs,\n+                    span,\n+                    kind: hir::ForeignItemKind::Static(..),\n+                    ..\n                 }) => {\n                     let fn_attrs = self.tcx.codegen_fn_attrs(def_id);\n                     (check_and_apply_linkage(&self, &fn_attrs, ty, sym, span), &**attrs)\n                 }\n \n-                item => bug!(\"get_static: expected static, found {:?}\", item)\n+                item => bug!(\"get_static: expected static, found {:?}\", item),\n             };\n \n             debug!(\"get_static: sym={} attrs={:?}\", sym, attrs);\n@@ -283,18 +273,19 @@ impl CodegenCx<'ll, 'tcx> {\n                 llvm::set_thread_local_mode(g, self.tls_model);\n             }\n \n-            let needs_dll_storage_attr =\n-                self.use_dll_storage_attrs && !self.tcx.is_foreign_item(def_id) &&\n+            let needs_dll_storage_attr = self.use_dll_storage_attrs && !self.tcx.is_foreign_item(def_id) &&\n                 // ThinLTO can't handle this workaround in all cases, so we don't\n                 // emit the attrs. Instead we make them unnecessary by disallowing\n                 // dynamic linking when linker plugin based LTO is enabled.\n                 !self.tcx.sess.opts.cg.linker_plugin_lto.enabled();\n \n             // If this assertion triggers, there's something wrong with commandline\n             // argument validation.\n-            debug_assert!(!(self.tcx.sess.opts.cg.linker_plugin_lto.enabled() &&\n-                            self.tcx.sess.target.target.options.is_like_msvc &&\n-                            self.tcx.sess.opts.cg.prefer_dynamic));\n+            debug_assert!(\n+                !(self.tcx.sess.opts.cg.linker_plugin_lto.enabled()\n+                    && self.tcx.sess.target.target.options.is_like_msvc\n+                    && self.tcx.sess.opts.cg.prefer_dynamic)\n+            );\n \n             if needs_dll_storage_attr {\n                 // This item is external but not foreign, i.e., it originates from an external Rust\n@@ -329,12 +320,7 @@ impl CodegenCx<'ll, 'tcx> {\n }\n \n impl StaticMethods for CodegenCx<'ll, 'tcx> {\n-    fn static_addr_of(\n-        &self,\n-        cv: &'ll Value,\n-        align: Align,\n-        kind: Option<&str>,\n-    ) -> &'ll Value {\n+    fn static_addr_of(&self, cv: &'ll Value, align: Align, kind: Option<&str>) -> &'ll Value {\n         if let Some(&gv) = self.const_globals.borrow().get(&cv) {\n             unsafe {\n                 // Upgrade the alignment in cases where the same constant is used with different\n@@ -354,11 +340,7 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n         gv\n     }\n \n-    fn codegen_static(\n-        &self,\n-        def_id: DefId,\n-        is_mutable: bool,\n-    ) {\n+    fn codegen_static(&self, def_id: DefId, is_mutable: bool) {\n         unsafe {\n             let attrs = self.tcx.codegen_fn_attrs(def_id);\n \n@@ -395,7 +377,11 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n                 let visibility = llvm::LLVMRustGetVisibility(g);\n \n                 let new_g = llvm::LLVMRustGetOrInsertGlobal(\n-                    self.llmod, name.as_ptr().cast(), name.len(), val_llty);\n+                    self.llmod,\n+                    name.as_ptr().cast(),\n+                    name.len(),\n+                    val_llty,\n+                );\n \n                 llvm::LLVMRustSetLinkage(new_g, linkage);\n                 llvm::LLVMRustSetVisibility(new_g, visibility);\n@@ -464,7 +450,8 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n                         // The `inspect` method is okay here because we checked relocations, and\n                         // because we are doing this access to inspect the final interpreter state\n                         // (not as part of the interpreter execution).\n-                        alloc.inspect_with_undef_and_ptr_outside_interpreter(0..alloc.len())\n+                        alloc\n+                            .inspect_with_undef_and_ptr_outside_interpreter(0..alloc.len())\n                             .iter()\n                             .all(|b| *b == 0)\n                     };\n@@ -477,7 +464,6 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n                 }\n             }\n \n-\n             // Wasm statics with custom link sections get special treatment as they\n             // go into custom sections of the wasm executable.\n             if self.tcx.sess.opts.target_triple.triple().starts_with(\"wasm32\") {\n@@ -492,8 +478,8 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n                     // The `inspect` method is okay here because we checked relocations, and\n                     // because we are doing this access to inspect the final interpreter state (not\n                     // as part of the interpreter execution).\n-                    let bytes = alloc.inspect_with_undef_and_ptr_outside_interpreter(\n-                        0..alloc.len());\n+                    let bytes =\n+                        alloc.inspect_with_undef_and_ptr_outside_interpreter(0..alloc.len());\n                     let alloc = llvm::LLVMMDStringInContext(\n                         self.llcx,\n                         bytes.as_ptr().cast(),"}, {"sha": "e3c2dfac58b3c5f71fd29e5528ce8d7e2a312411", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 713, "deletions": 733, "changes": 1446, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d", "patch": "@@ -1,56 +1,60 @@\n-use self::RecursiveTypeDescription::*;\n-use self::MemberDescriptionFactory::*;\n use self::EnumDiscriminantInfo::*;\n+use self::MemberDescriptionFactory::*;\n+use self::RecursiveTypeDescription::*;\n \n-use super::utils::{debug_context, DIB, span_start,\n-                   get_namespace_for_item, create_DIArray, is_node_local_to_unit};\n use super::namespace::mangled_name_of_instance;\n use super::type_names::compute_debuginfo_type_name;\n+use super::utils::{\n+    create_DIArray, debug_context, get_namespace_for_item, is_node_local_to_unit, span_start, DIB,\n+};\n use super::CrateDebugContext;\n \n use crate::abi;\n use crate::common::CodegenCx;\n use crate::llvm;\n-use crate::llvm::debuginfo::{DIArray, DIType, DIFile, DIScope, DIDescriptor,\n-                      DICompositeType, DILexicalBlock, DIFlags, DebugEmissionKind};\n+use crate::llvm::debuginfo::{\n+    DIArray, DICompositeType, DIDescriptor, DIFile, DIFlags, DILexicalBlock, DIScope, DIType,\n+    DebugEmissionKind,\n+};\n use crate::llvm_util;\n use crate::value::Value;\n \n-use rustc_codegen_ssa::traits::*;\n-use rustc_index::vec::{Idx, IndexVec};\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc::hir::CodegenFnAttrFlags;\n+use log::debug;\n use rustc::hir::def::CtorKind;\n-use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc::hir::CodegenFnAttrFlags;\n use rustc::ich::NodeIdHashingMode;\n-use rustc::mir::{self, Field, GeneratorLayout};\n use rustc::mir::interpret::truncate;\n-use rustc_data_structures::fingerprint::Fingerprint;\n+use rustc::mir::{self, Field, GeneratorLayout};\n+use rustc::session::config::{self, DebugInfo};\n+use rustc::ty::layout::{\n+    self, Align, Integer, IntegerExt, LayoutOf, PrimitiveExt, Size, TyLayout, VariantIdx,\n+};\n+use rustc::ty::subst::{GenericArgKind, SubstsRef};\n use rustc::ty::Instance;\n use rustc::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n-use rustc::ty::layout::{self, Align, Integer, IntegerExt, LayoutOf,\n-                        PrimitiveExt, Size, TyLayout, VariantIdx};\n-use rustc::ty::subst::{GenericArgKind, SubstsRef};\n-use rustc::session::config::{self, DebugInfo};\n use rustc::util::nodemap::FxHashMap;\n-use rustc_fs_util::path_to_c_string;\n-use rustc_data_structures::small_c_str::SmallCStr;\n+use rustc::{bug, span_bug};\n+use rustc_codegen_ssa::traits::*;\n use rustc_data_structures::const_cstr;\n+use rustc_data_structures::fingerprint::Fingerprint;\n+use rustc_data_structures::small_c_str::SmallCStr;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_fs_util::path_to_c_string;\n+use rustc_index::vec::{Idx, IndexVec};\n use rustc_target::abi::HasDataLayout;\n use syntax::ast;\n use syntax::symbol::{Interner, Symbol};\n-use syntax_pos::{self, Span, FileName};\n-use rustc::{bug, span_bug};\n-use log::debug;\n+use syntax_pos::{self, FileName, Span};\n \n-use libc::{c_uint, c_longlong};\n+use libc::{c_longlong, c_uint};\n use std::collections::hash_map::Entry;\n use std::ffi::CString;\n use std::fmt::{self, Write};\n use std::hash::{Hash, Hasher};\n use std::iter;\n-use std::ptr;\n use std::path::{Path, PathBuf};\n+use std::ptr;\n \n impl PartialEq for llvm::Metadata {\n     fn eq(&self, other: &Self) -> bool {\n@@ -107,17 +111,13 @@ pub struct TypeMap<'ll, 'tcx> {\n     /// A map from types to debuginfo metadata. This is an N:1 mapping.\n     type_to_metadata: FxHashMap<Ty<'tcx>, &'ll DIType>,\n     /// A map from types to `UniqueTypeId`. This is an N:1 mapping.\n-    type_to_unique_id: FxHashMap<Ty<'tcx>, UniqueTypeId>\n+    type_to_unique_id: FxHashMap<Ty<'tcx>, UniqueTypeId>,\n }\n \n impl TypeMap<'ll, 'tcx> {\n     /// Adds a Ty to metadata mapping to the TypeMap. The method will fail if\n     /// the mapping already exists.\n-    fn register_type_with_metadata(\n-        &mut self,\n-        type_: Ty<'tcx>,\n-        metadata: &'ll DIType,\n-    ) {\n+    fn register_type_with_metadata(&mut self, type_: Ty<'tcx>, metadata: &'ll DIType) {\n         if self.type_to_metadata.insert(type_, metadata).is_some() {\n             bug!(\"type metadata for `Ty` '{}' is already in the `TypeMap`!\", type_);\n         }\n@@ -140,10 +140,7 @@ impl TypeMap<'ll, 'tcx> {\n     ///\n     /// This function is used to remove the temporary metadata\n     /// mapping after we've computed the actual metadata.\n-    fn remove_type(\n-        &mut self,\n-        type_: Ty<'tcx>,\n-    ) {\n+    fn remove_type(&mut self, type_: Ty<'tcx>) {\n         if self.type_to_metadata.remove(type_).is_none() {\n             bug!(\"type metadata `Ty` '{}' is not in the `TypeMap`!\", type_);\n         }\n@@ -157,8 +154,10 @@ impl TypeMap<'ll, 'tcx> {\n         metadata: &'ll DIType,\n     ) {\n         if self.unique_id_to_metadata.insert(unique_type_id, metadata).is_some() {\n-            bug!(\"type metadata for unique ID '{}' is already in the `TypeMap`!\",\n-                 self.get_unique_type_id_as_string(unique_type_id));\n+            bug!(\n+                \"type metadata for unique ID '{}' is already in the `TypeMap`!\",\n+                self.get_unique_type_id_as_string(unique_type_id)\n+            );\n         }\n     }\n \n@@ -180,8 +179,11 @@ impl TypeMap<'ll, 'tcx> {\n     /// Gets the `UniqueTypeId` for the given type. If the `UniqueTypeId` for the given\n     /// type has been requested before, this is just a table lookup. Otherwise, an\n     /// ID will be generated and stored for later lookup.\n-    fn get_unique_type_id_of_type<'a>(&mut self, cx: &CodegenCx<'a, 'tcx>,\n-                                      type_: Ty<'tcx>) -> UniqueTypeId {\n+    fn get_unique_type_id_of_type<'a>(\n+        &mut self,\n+        cx: &CodegenCx<'a, 'tcx>,\n+        type_: Ty<'tcx>,\n+    ) -> UniqueTypeId {\n         // Let's see if we already have something in the cache.\n         if let Some(unique_type_id) = self.type_to_unique_id.get(&type_).cloned() {\n             return unique_type_id;\n@@ -209,15 +211,15 @@ impl TypeMap<'ll, 'tcx> {\n     /// Gets the `UniqueTypeId` for an enum variant. Enum variants are not really\n     /// types of their own, so they need special handling. We still need a\n     /// `UniqueTypeId` for them, since to debuginfo they *are* real types.\n-    fn get_unique_type_id_of_enum_variant<'a>(&mut self,\n-                                              cx: &CodegenCx<'a, 'tcx>,\n-                                              enum_type: Ty<'tcx>,\n-                                              variant_name: &str)\n-                                              -> UniqueTypeId {\n+    fn get_unique_type_id_of_enum_variant<'a>(\n+        &mut self,\n+        cx: &CodegenCx<'a, 'tcx>,\n+        enum_type: Ty<'tcx>,\n+        variant_name: &str,\n+    ) -> UniqueTypeId {\n         let enum_type_id = self.get_unique_type_id_of_type(cx, enum_type);\n-        let enum_variant_type_id = format!(\"{}::{}\",\n-                                           self.get_unique_type_id_as_string(enum_type_id),\n-                                           variant_name);\n+        let enum_variant_type_id =\n+            format!(\"{}::{}\", self.get_unique_type_id_as_string(enum_type_id), variant_name);\n         let interner_key = self.unique_id_interner.intern(&enum_variant_type_id);\n         UniqueTypeId(interner_key)\n     }\n@@ -226,8 +228,8 @@ impl TypeMap<'ll, 'tcx> {\n     /// Variant parts are not types and shouldn't really have their own ID,\n     /// but it makes `set_members_of_composite_type()` simpler.\n     fn get_unique_type_id_str_of_enum_variant_part(&mut self, enum_type_id: UniqueTypeId) -> &str {\n-        let variant_part_type_id = format!(\"{}_variant_part\",\n-                                           self.get_unique_type_id_as_string(enum_type_id));\n+        let variant_part_type_id =\n+            format!(\"{}_variant_part\", self.get_unique_type_id_as_string(enum_type_id));\n         let interner_key = self.unique_id_interner.intern(&variant_part_type_id);\n         self.unique_id_interner.get(interner_key)\n     }\n@@ -246,7 +248,7 @@ enum RecursiveTypeDescription<'ll, 'tcx> {\n         member_holding_stub: &'ll DICompositeType,\n         member_description_factory: MemberDescriptionFactory<'ll, 'tcx>,\n     },\n-    FinalMetadata(&'ll DICompositeType)\n+    FinalMetadata(&'ll DICompositeType),\n }\n \n fn create_and_register_recursive_type_forward_declaration(\n@@ -257,7 +259,6 @@ fn create_and_register_recursive_type_forward_declaration(\n     member_holding_stub: &'ll DICompositeType,\n     member_description_factory: MemberDescriptionFactory<'ll, 'tcx>,\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n-\n     // Insert the stub into the `TypeMap` in order to allow for recursive references.\n     let mut type_map = debug_context(cx).type_map.borrow_mut();\n     type_map.register_unique_id_with_metadata(unique_type_id, metadata_stub);\n@@ -294,23 +295,27 @@ impl RecursiveTypeDescription<'ll, 'tcx> {\n                 // function.\n                 {\n                     let type_map = debug_context(cx).type_map.borrow();\n-                    if type_map.find_metadata_for_unique_id(unique_type_id).is_none() ||\n-                       type_map.find_metadata_for_type(unfinished_type).is_none() {\n-                        bug!(\"Forward declaration of potentially recursive type \\\n+                    if type_map.find_metadata_for_unique_id(unique_type_id).is_none()\n+                        || type_map.find_metadata_for_type(unfinished_type).is_none()\n+                    {\n+                        bug!(\n+                            \"Forward declaration of potentially recursive type \\\n                               '{:?}' was not found in TypeMap!\",\n-                             unfinished_type);\n+                            unfinished_type\n+                        );\n                     }\n                 }\n \n                 // ... then create the member descriptions ...\n-                let member_descriptions =\n-                    member_description_factory.create_member_descriptions(cx);\n+                let member_descriptions = member_description_factory.create_member_descriptions(cx);\n \n                 // ... and attach them to the stub to complete it.\n-                set_members_of_composite_type(cx,\n-                                              unfinished_type,\n-                                              member_holding_stub,\n-                                              member_descriptions);\n+                set_members_of_composite_type(\n+                    cx,\n+                    unfinished_type,\n+                    member_holding_stub,\n+                    member_descriptions,\n+                );\n                 return MetadataCreationResult::new(metadata_stub, true);\n             }\n         }\n@@ -320,14 +325,13 @@ impl RecursiveTypeDescription<'ll, 'tcx> {\n /// Returns from the enclosing function if the type metadata with the given\n /// unique ID can be found in the type map.\n macro_rules! return_if_metadata_created_in_meantime {\n-    ($cx: expr, $unique_type_id: expr) => (\n-        if let Some(metadata) = debug_context($cx).type_map\n-            .borrow()\n-            .find_metadata_for_unique_id($unique_type_id)\n+    ($cx: expr, $unique_type_id: expr) => {\n+        if let Some(metadata) =\n+            debug_context($cx).type_map.borrow().find_metadata_for_unique_id($unique_type_id)\n         {\n             return MetadataCreationResult::new(metadata, true);\n         }\n-    )\n+    };\n }\n \n fn fixed_vec_metadata(\n@@ -345,12 +349,11 @@ fn fixed_vec_metadata(\n \n     let upper_bound = match array_or_slice_type.kind {\n         ty::Array(_, len) => len.eval_usize(cx.tcx, ty::ParamEnv::reveal_all()) as c_longlong,\n-        _ => -1\n+        _ => -1,\n     };\n \n-    let subrange = unsafe {\n-        Some(llvm::LLVMRustDIBuilderGetOrCreateSubrange(DIB(cx), 0, upper_bound))\n-    };\n+    let subrange =\n+        unsafe { Some(llvm::LLVMRustDIBuilderGetOrCreateSubrange(DIB(cx), 0, upper_bound)) };\n \n     let subscripts = create_DIArray(DIB(cx), &[subrange]);\n     let metadata = unsafe {\n@@ -359,7 +362,8 @@ fn fixed_vec_metadata(\n             size.bits(),\n             align.bits() as u32,\n             element_type_metadata,\n-            subscripts)\n+            subscripts,\n+        )\n     };\n \n     return MetadataCreationResult::new(metadata, false);\n@@ -406,14 +410,16 @@ fn vec_slice_metadata(\n \n     let file_metadata = unknown_file_metadata(cx);\n \n-    let metadata = composite_type_metadata(cx,\n-                                           slice_ptr_type,\n-                                           &slice_type_name[..],\n-                                           unique_type_id,\n-                                           member_descriptions,\n-                                           NO_SCOPE_METADATA,\n-                                           file_metadata,\n-                                           span);\n+    let metadata = composite_type_metadata(\n+        cx,\n+        slice_ptr_type,\n+        &slice_type_name[..],\n+        unique_type_id,\n+        member_descriptions,\n+        NO_SCOPE_METADATA,\n+        file_metadata,\n+        span,\n+    );\n     MetadataCreationResult::new(metadata, false)\n }\n \n@@ -423,23 +429,21 @@ fn subroutine_type_metadata(\n     signature: ty::PolyFnSig<'tcx>,\n     span: Span,\n ) -> MetadataCreationResult<'ll> {\n-    let signature = cx.tcx.normalize_erasing_late_bound_regions(\n-        ty::ParamEnv::reveal_all(),\n-        &signature,\n-    );\n+    let signature =\n+        cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &signature);\n \n     let signature_metadata: Vec<_> = iter::once(\n         // return type\n         match signature.output().kind {\n             ty::Tuple(ref tys) if tys.is_empty() => None,\n-            _ => Some(type_metadata(cx, signature.output(), span))\n-        }\n-    ).chain(\n+            _ => Some(type_metadata(cx, signature.output(), span)),\n+        },\n+    )\n+    .chain(\n         // regular arguments\n-        signature.inputs().iter().map(|argument_type| {\n-            Some(type_metadata(cx, argument_type, span))\n-        })\n-    ).collect();\n+        signature.inputs().iter().map(|argument_type| Some(type_metadata(cx, argument_type, span))),\n+    )\n+    .collect();\n \n     return_if_metadata_created_in_meantime!(cx, unique_type_id);\n \n@@ -448,9 +452,11 @@ fn subroutine_type_metadata(\n             llvm::LLVMRustDIBuilderCreateSubroutineType(\n                 DIB(cx),\n                 unknown_file_metadata(cx),\n-                create_DIArray(DIB(cx), &signature_metadata[..]))\n+                create_DIArray(DIB(cx), &signature_metadata[..]),\n+            )\n         },\n-        false);\n+        false,\n+    );\n }\n \n // FIXME(1563): This is all a bit of a hack because 'trait pointer' is an ill-\n@@ -470,18 +476,20 @@ fn trait_pointer_metadata(\n     // However, it does not describe the trait's methods.\n \n     let containing_scope = match trait_type.kind {\n-        ty::Dynamic(ref data, ..) =>\n-            data.principal_def_id().map(|did| get_namespace_for_item(cx, did)),\n+        ty::Dynamic(ref data, ..) => {\n+            data.principal_def_id().map(|did| get_namespace_for_item(cx, did))\n+        }\n         _ => {\n-            bug!(\"debuginfo: unexpected trait-object type in \\\n+            bug!(\n+                \"debuginfo: unexpected trait-object type in \\\n                   trait_pointer_metadata(): {:?}\",\n-                 trait_type);\n+                trait_type\n+            );\n         }\n     };\n \n     let trait_object_type = trait_object_type.unwrap_or(trait_type);\n-    let trait_type_name =\n-        compute_debuginfo_type_name(cx.tcx, trait_object_type, false);\n+    let trait_type_name = compute_debuginfo_type_name(cx.tcx, trait_object_type, false);\n \n     let file_metadata = unknown_file_metadata(cx);\n \n@@ -495,9 +503,11 @@ fn trait_pointer_metadata(\n     let member_descriptions = vec![\n         MemberDescription {\n             name: \"pointer\".to_owned(),\n-            type_metadata: type_metadata(cx,\n+            type_metadata: type_metadata(\n+                cx,\n                 cx.tcx.mk_mut_ptr(cx.tcx.types.u8),\n-                syntax_pos::DUMMY_SP),\n+                syntax_pos::DUMMY_SP,\n+            ),\n             offset: layout.fields.offset(0),\n             size: data_ptr_field.size,\n             align: data_ptr_field.align.abi,\n@@ -515,21 +525,19 @@ fn trait_pointer_metadata(\n         },\n     ];\n \n-    composite_type_metadata(cx,\n-                            trait_object_type,\n-                            &trait_type_name[..],\n-                            unique_type_id,\n-                            member_descriptions,\n-                            containing_scope,\n-                            file_metadata,\n-                            syntax_pos::DUMMY_SP)\n+    composite_type_metadata(\n+        cx,\n+        trait_object_type,\n+        &trait_type_name[..],\n+        unique_type_id,\n+        member_descriptions,\n+        containing_scope,\n+        file_metadata,\n+        syntax_pos::DUMMY_SP,\n+    )\n }\n \n-pub fn type_metadata(\n-    cx: &CodegenCx<'ll, 'tcx>,\n-    t: Ty<'tcx>,\n-    usage_site_span: Span,\n-) -> &'ll DIType {\n+pub fn type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>, usage_site_span: Span) -> &'ll DIType {\n     // Get the unique type ID of this type.\n     let unique_type_id = {\n         let mut type_map = debug_context(cx).type_map.borrow_mut();\n@@ -538,7 +546,7 @@ pub fn type_metadata(\n         match type_map.find_metadata_for_type(t) {\n             Some(metadata) => {\n                 return metadata;\n-            },\n+            }\n             None => {\n                 // The Ty is not in the `TypeMap` but maybe we have already seen\n                 // an equivalent type (e.g., only differing in region arguments).\n@@ -552,7 +560,7 @@ pub fn type_metadata(\n                         // return the cached metadata.\n                         type_map.register_type_with_metadata(t, metadata);\n                         return metadata;\n-                    },\n+                    }\n                     None => {\n                         // There really is no type metadata for this type, so\n                         // proceed by creating it.\n@@ -565,82 +573,54 @@ pub fn type_metadata(\n \n     debug!(\"type_metadata: {:?}\", t);\n \n-    let ptr_metadata = |ty: Ty<'tcx>| {\n-        match ty.kind {\n-            ty::Slice(typ) => {\n-                Ok(vec_slice_metadata(cx, t, typ, unique_type_id, usage_site_span))\n-            }\n-            ty::Str => {\n-                Ok(vec_slice_metadata(cx, t, cx.tcx.types.u8, unique_type_id, usage_site_span))\n-            }\n-            ty::Dynamic(..) => {\n-                Ok(MetadataCreationResult::new(\n-                    trait_pointer_metadata(cx, ty, Some(t), unique_type_id),\n-                    false))\n-            }\n-            _ => {\n-                let pointee_metadata = type_metadata(cx, ty, usage_site_span);\n-\n-                if let Some(metadata) = debug_context(cx).type_map\n-                    .borrow()\n-                    .find_metadata_for_unique_id(unique_type_id)\n-                {\n-                    return Err(metadata);\n-                }\n+    let ptr_metadata = |ty: Ty<'tcx>| match ty.kind {\n+        ty::Slice(typ) => Ok(vec_slice_metadata(cx, t, typ, unique_type_id, usage_site_span)),\n+        ty::Str => Ok(vec_slice_metadata(cx, t, cx.tcx.types.u8, unique_type_id, usage_site_span)),\n+        ty::Dynamic(..) => Ok(MetadataCreationResult::new(\n+            trait_pointer_metadata(cx, ty, Some(t), unique_type_id),\n+            false,\n+        )),\n+        _ => {\n+            let pointee_metadata = type_metadata(cx, ty, usage_site_span);\n \n-                Ok(MetadataCreationResult::new(pointer_type_metadata(cx, t, pointee_metadata),\n-                   false))\n+            if let Some(metadata) =\n+                debug_context(cx).type_map.borrow().find_metadata_for_unique_id(unique_type_id)\n+            {\n+                return Err(metadata);\n             }\n+\n+            Ok(MetadataCreationResult::new(pointer_type_metadata(cx, t, pointee_metadata), false))\n         }\n     };\n \n     let MetadataCreationResult { metadata, already_stored_in_typemap } = match t.kind {\n-        ty::Never    |\n-        ty::Bool     |\n-        ty::Char     |\n-        ty::Int(_)   |\n-        ty::Uint(_)  |\n-        ty::Float(_) => {\n+        ty::Never | ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) => {\n             MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n         }\n         ty::Tuple(ref elements) if elements.is_empty() => {\n             MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n         }\n-        ty::Array(typ, _) |\n-        ty::Slice(typ) => {\n+        ty::Array(typ, _) | ty::Slice(typ) => {\n             fixed_vec_metadata(cx, unique_type_id, t, typ, usage_site_span)\n         }\n-        ty::Str => {\n-            fixed_vec_metadata(cx, unique_type_id, t, cx.tcx.types.i8, usage_site_span)\n-        }\n+        ty::Str => fixed_vec_metadata(cx, unique_type_id, t, cx.tcx.types.i8, usage_site_span),\n         ty::Dynamic(..) => {\n-            MetadataCreationResult::new(\n-                trait_pointer_metadata(cx, t, None, unique_type_id),\n-                false)\n+            MetadataCreationResult::new(trait_pointer_metadata(cx, t, None, unique_type_id), false)\n         }\n         ty::Foreign(..) => {\n-            MetadataCreationResult::new(\n-            foreign_type_metadata(cx, t, unique_type_id),\n-            false)\n-        }\n-        ty::RawPtr(ty::TypeAndMut{ty, ..}) |\n-        ty::Ref(_, ty, _) => {\n-            match ptr_metadata(ty) {\n-                Ok(res) => res,\n-                Err(metadata) => return metadata,\n-            }\n-        }\n-        ty::Adt(def, _) if def.is_box() => {\n-            match ptr_metadata(t.boxed_ty()) {\n-                Ok(res) => res,\n-                Err(metadata) => return metadata,\n-            }\n+            MetadataCreationResult::new(foreign_type_metadata(cx, t, unique_type_id), false)\n         }\n+        ty::RawPtr(ty::TypeAndMut { ty, .. }) | ty::Ref(_, ty, _) => match ptr_metadata(ty) {\n+            Ok(res) => res,\n+            Err(metadata) => return metadata,\n+        },\n+        ty::Adt(def, _) if def.is_box() => match ptr_metadata(t.boxed_ty()) {\n+            Ok(res) => res,\n+            Err(metadata) => return metadata,\n+        },\n         ty::FnDef(..) | ty::FnPtr(_) => {\n-\n-            if let Some(metadata) = debug_context(cx).type_map\n-               .borrow()\n-               .find_metadata_for_unique_id(unique_type_id)\n+            if let Some(metadata) =\n+                debug_context(cx).type_map.borrow().find_metadata_for_unique_id(unique_type_id)\n             {\n                 return metadata;\n             }\n@@ -665,81 +645,63 @@ pub fn type_metadata(\n                         SmallCStr::new(\"<recur_type>\").as_ptr(),\n                         size.bits(),\n                         align.bits() as u32,\n-                        DW_ATE_unsigned)\n+                        DW_ATE_unsigned,\n+                    )\n                 }\n             };\n \n             let type_map = &debug_context(cx).type_map;\n             type_map.borrow_mut().register_type_with_metadata(t, temp_type);\n \n-            let fn_metadata = subroutine_type_metadata(cx,\n-                                                       unique_type_id,\n-                                                       t.fn_sig(cx.tcx),\n-                                                       usage_site_span).metadata;\n+            let fn_metadata =\n+                subroutine_type_metadata(cx, unique_type_id, t.fn_sig(cx.tcx), usage_site_span)\n+                    .metadata;\n \n             type_map.borrow_mut().remove_type(t);\n \n-\n             // This is actually a function pointer, so wrap it in pointer DI.\n             MetadataCreationResult::new(pointer_type_metadata(cx, t, fn_metadata), false)\n-\n         }\n         ty::Closure(def_id, substs) => {\n-            let upvar_tys : Vec<_> = substs.as_closure().upvar_tys(def_id, cx.tcx).collect();\n+            let upvar_tys: Vec<_> = substs.as_closure().upvar_tys(def_id, cx.tcx).collect();\n             let containing_scope = get_namespace_for_item(cx, def_id);\n-            prepare_tuple_metadata(cx,\n-                                   t,\n-                                   &upvar_tys,\n-                                   unique_type_id,\n-                                   usage_site_span,\n-                                   Some(containing_scope)).finalize(cx)\n+            prepare_tuple_metadata(\n+                cx,\n+                t,\n+                &upvar_tys,\n+                unique_type_id,\n+                usage_site_span,\n+                Some(containing_scope),\n+            )\n+            .finalize(cx)\n         }\n-        ty::Generator(def_id, substs,  _) => {\n-            let upvar_tys : Vec<_> = substs\n-                .as_generator().prefix_tys(def_id, cx.tcx).map(|t| {\n-                    cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), t)\n-                }).collect();\n-            prepare_enum_metadata(cx,\n-                                  t,\n-                                  def_id,\n-                                  unique_type_id,\n-                                  usage_site_span,\n-                                  upvar_tys).finalize(cx)\n+        ty::Generator(def_id, substs, _) => {\n+            let upvar_tys: Vec<_> = substs\n+                .as_generator()\n+                .prefix_tys(def_id, cx.tcx)\n+                .map(|t| cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), t))\n+                .collect();\n+            prepare_enum_metadata(cx, t, def_id, unique_type_id, usage_site_span, upvar_tys)\n+                .finalize(cx)\n         }\n         ty::Adt(def, ..) => match def.adt_kind() {\n             AdtKind::Struct => {\n-                prepare_struct_metadata(cx,\n-                                        t,\n-                                        unique_type_id,\n-                                        usage_site_span).finalize(cx)\n+                prepare_struct_metadata(cx, t, unique_type_id, usage_site_span).finalize(cx)\n             }\n             AdtKind::Union => {\n-                prepare_union_metadata(cx,\n-                                       t,\n-                                       unique_type_id,\n-                                       usage_site_span).finalize(cx)\n+                prepare_union_metadata(cx, t, unique_type_id, usage_site_span).finalize(cx)\n             }\n             AdtKind::Enum => {\n-                prepare_enum_metadata(cx,\n-                                      t,\n-                                      def.did,\n-                                      unique_type_id,\n-                                      usage_site_span,\n-                                      vec![]).finalize(cx)\n+                prepare_enum_metadata(cx, t, def.did, unique_type_id, usage_site_span, vec![])\n+                    .finalize(cx)\n             }\n         },\n         ty::Tuple(ref elements) => {\n             let tys: Vec<_> = elements.iter().map(|k| k.expect_ty()).collect();\n-            prepare_tuple_metadata(cx,\n-                                   t,\n-                                   &tys,\n-                                   unique_type_id,\n-                                   usage_site_span,\n-                                   NO_SCOPE_METADATA).finalize(cx)\n-        }\n-        _ => {\n-            bug!(\"debuginfo: unexpected type in type_metadata: {:?}\", t)\n+            prepare_tuple_metadata(cx, t, &tys, unique_type_id, usage_site_span, NO_SCOPE_METADATA)\n+                .finalize(cx)\n         }\n+        _ => bug!(\"debuginfo: unexpected type in type_metadata: {:?}\", t),\n     };\n \n     {\n@@ -750,26 +712,30 @@ pub fn type_metadata(\n             let metadata_for_uid = match type_map.find_metadata_for_unique_id(unique_type_id) {\n                 Some(metadata) => metadata,\n                 None => {\n-                    span_bug!(usage_site_span,\n-                              \"expected type metadata for unique \\\n+                    span_bug!(\n+                        usage_site_span,\n+                        \"expected type metadata for unique \\\n                                type ID '{}' to already be in \\\n                                the `debuginfo::TypeMap` but it \\\n                                was not. (Ty = {})\",\n-                              type_map.get_unique_type_id_as_string(unique_type_id),\n-                              t);\n+                        type_map.get_unique_type_id_as_string(unique_type_id),\n+                        t\n+                    );\n                 }\n             };\n \n             match type_map.find_metadata_for_type(t) {\n                 Some(metadata) => {\n                     if metadata != metadata_for_uid {\n-                        span_bug!(usage_site_span,\n-                                  \"mismatch between `Ty` and \\\n+                        span_bug!(\n+                            usage_site_span,\n+                            \"mismatch between `Ty` and \\\n                                    `UniqueTypeId` maps in \\\n                                    `debuginfo::TypeMap`. \\\n                                    UniqueTypeId={}, Ty={}\",\n-                                  type_map.get_unique_type_id_as_string(unique_type_id),\n-                                  t);\n+                            type_map.get_unique_type_id_as_string(unique_type_id),\n+                            t\n+                        );\n                     }\n                 }\n                 None => {\n@@ -785,12 +751,12 @@ pub fn type_metadata(\n     metadata\n }\n \n-pub fn file_metadata(cx: &CodegenCx<'ll, '_>,\n-                     file_name: &FileName,\n-                     defining_crate: CrateNum) -> &'ll DIFile {\n-    debug!(\"file_metadata: file_name: {}, defining_crate: {}\",\n-           file_name,\n-           defining_crate);\n+pub fn file_metadata(\n+    cx: &CodegenCx<'ll, '_>,\n+    file_name: &FileName,\n+    defining_crate: CrateNum,\n+) -> &'ll DIFile {\n+    debug!(\"file_metadata: file_name: {}, defining_crate: {}\", file_name, defining_crate);\n \n     let file_name = Some(file_name.to_string());\n     let directory = if defining_crate == LOCAL_CRATE {\n@@ -807,10 +773,11 @@ pub fn unknown_file_metadata(cx: &CodegenCx<'ll, '_>) -> &'ll DIFile {\n     file_metadata_raw(cx, None, None)\n }\n \n-fn file_metadata_raw(cx: &CodegenCx<'ll, '_>,\n-                     file_name: Option<String>,\n-                     directory: Option<String>)\n-                     -> &'ll DIFile {\n+fn file_metadata_raw(\n+    cx: &CodegenCx<'ll, '_>,\n+    file_name: Option<String>,\n+    directory: Option<String>,\n+) -> &'ll DIFile {\n     let key = (file_name, directory);\n \n     match debug_context(cx).created_files.borrow_mut().entry(key) {\n@@ -819,15 +786,16 @@ fn file_metadata_raw(cx: &CodegenCx<'ll, '_>,\n             let (file_name, directory) = v.key();\n             debug!(\"file_metadata: file_name: {:?}, directory: {:?}\", file_name, directory);\n \n-            let file_name = SmallCStr::new(\n-                if let Some(file_name) = file_name { &file_name } else { \"<unknown>\" });\n-            let directory = SmallCStr::new(\n-                if let Some(directory) = directory { &directory } else { \"\" });\n+            let file_name = SmallCStr::new(if let Some(file_name) = file_name {\n+                &file_name\n+            } else {\n+                \"<unknown>\"\n+            });\n+            let directory =\n+                SmallCStr::new(if let Some(directory) = directory { &directory } else { \"\" });\n \n             let file_metadata = unsafe {\n-                llvm::LLVMRustDIBuilderCreateFile(DIB(cx),\n-                                                  file_name.as_ptr(),\n-                                                  directory.as_ptr())\n+                llvm::LLVMRustDIBuilderCreateFile(DIB(cx), file_name.as_ptr(), directory.as_ptr())\n             };\n \n             v.insert(file_metadata);\n@@ -841,20 +809,13 @@ fn basic_type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n \n     let (name, encoding) = match t.kind {\n         ty::Never => (\"!\", DW_ATE_unsigned),\n-        ty::Tuple(ref elements) if elements.is_empty() =>\n-            (\"()\", DW_ATE_unsigned),\n+        ty::Tuple(ref elements) if elements.is_empty() => (\"()\", DW_ATE_unsigned),\n         ty::Bool => (\"bool\", DW_ATE_boolean),\n         ty::Char => (\"char\", DW_ATE_unsigned_char),\n-        ty::Int(int_ty) => {\n-            (int_ty.name_str(), DW_ATE_signed)\n-        },\n-        ty::Uint(uint_ty) => {\n-            (uint_ty.name_str(), DW_ATE_unsigned)\n-        },\n-        ty::Float(float_ty) => {\n-            (float_ty.name_str(), DW_ATE_float)\n-        },\n-        _ => bug!(\"debuginfo::basic_type_metadata - `t` is invalid type\")\n+        ty::Int(int_ty) => (int_ty.name_str(), DW_ATE_signed),\n+        ty::Uint(uint_ty) => (uint_ty.name_str(), DW_ATE_unsigned),\n+        ty::Float(float_ty) => (float_ty.name_str(), DW_ATE_float),\n+        _ => bug!(\"debuginfo::basic_type_metadata - `t` is invalid type\"),\n     };\n \n     let (size, align) = cx.size_and_align_of(t);\n@@ -865,7 +826,8 @@ fn basic_type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n             name.as_ptr(),\n             size.bits(),\n             align.bits() as u32,\n-            encoding)\n+            encoding,\n+        )\n     };\n \n     return ty_metadata;\n@@ -896,7 +858,8 @@ fn pointer_type_metadata(\n             pointee_type_metadata,\n             pointer_size.bits(),\n             pointer_align.bits() as u32,\n-            name.as_ptr())\n+            name.as_ptr(),\n+        )\n     }\n }\n \n@@ -920,10 +883,8 @@ pub fn compile_unit_metadata(\n     }\n \n     debug!(\"compile_unit_metadata: {:?}\", name_in_debuginfo);\n-    let rustc_producer = format!(\n-        \"rustc version {}\",\n-        option_env!(\"CFG_VERSION\").expect(\"CFG_VERSION\"),\n-    );\n+    let rustc_producer =\n+        format!(\"rustc version {}\", option_env!(\"CFG_VERSION\").expect(\"CFG_VERSION\"),);\n     // FIXME(#41252) Remove \"clang LLVM\" if we can get GDB and LLVM to play nice.\n     let producer = format!(\"clang LLVM ({})\", rustc_producer);\n \n@@ -954,7 +915,10 @@ pub fn compile_unit_metadata(\n \n     unsafe {\n         let file_metadata = llvm::LLVMRustDIBuilderCreateFile(\n-            debug_context.builder, name_in_debuginfo.as_ptr(), work_dir.as_ptr());\n+            debug_context.builder,\n+            name_in_debuginfo.as_ptr(),\n+            work_dir.as_ptr(),\n+        );\n \n         let unit_metadata = llvm::LLVMRustDIBuilderCreateCompileUnit(\n             debug_context.builder,\n@@ -965,27 +929,36 @@ pub fn compile_unit_metadata(\n             flags.as_ptr().cast(),\n             0,\n             split_name.as_ptr().cast(),\n-            kind);\n+            kind,\n+        );\n \n         if tcx.sess.opts.debugging_opts.profile {\n-            let cu_desc_metadata = llvm::LLVMRustMetadataAsValue(debug_context.llcontext,\n-                                                                 unit_metadata);\n+            let cu_desc_metadata =\n+                llvm::LLVMRustMetadataAsValue(debug_context.llcontext, unit_metadata);\n \n             let gcov_cu_info = [\n-                path_to_mdstring(debug_context.llcontext,\n-                                 &tcx.output_filenames(LOCAL_CRATE).with_extension(\"gcno\")),\n-                path_to_mdstring(debug_context.llcontext,\n-                                 &tcx.output_filenames(LOCAL_CRATE).with_extension(\"gcda\")),\n+                path_to_mdstring(\n+                    debug_context.llcontext,\n+                    &tcx.output_filenames(LOCAL_CRATE).with_extension(\"gcno\"),\n+                ),\n+                path_to_mdstring(\n+                    debug_context.llcontext,\n+                    &tcx.output_filenames(LOCAL_CRATE).with_extension(\"gcda\"),\n+                ),\n                 cu_desc_metadata,\n             ];\n-            let gcov_metadata = llvm::LLVMMDNodeInContext(debug_context.llcontext,\n-                                                          gcov_cu_info.as_ptr(),\n-                                                          gcov_cu_info.len() as c_uint);\n+            let gcov_metadata = llvm::LLVMMDNodeInContext(\n+                debug_context.llcontext,\n+                gcov_cu_info.as_ptr(),\n+                gcov_cu_info.len() as c_uint,\n+            );\n \n             let llvm_gcov_ident = const_cstr!(\"llvm.gcov\");\n-            llvm::LLVMAddNamedMetadataOperand(debug_context.llmod,\n-                                              llvm_gcov_ident.as_ptr(),\n-                                              gcov_metadata);\n+            llvm::LLVMAddNamedMetadataOperand(\n+                debug_context.llmod,\n+                llvm_gcov_ident.as_ptr(),\n+                gcov_metadata,\n+            );\n         }\n \n         // Insert `llvm.ident` metadata on the wasm32 targets since that will\n@@ -1009,24 +982,23 @@ pub fn compile_unit_metadata(\n     fn path_to_mdstring(llcx: &'ll llvm::Context, path: &Path) -> &'ll Value {\n         let path_str = path_to_c_string(path);\n         unsafe {\n-            llvm::LLVMMDStringInContext(llcx,\n-                                        path_str.as_ptr(),\n-                                        path_str.as_bytes().len() as c_uint)\n+            llvm::LLVMMDStringInContext(\n+                llcx,\n+                path_str.as_ptr(),\n+                path_str.as_bytes().len() as c_uint,\n+            )\n         }\n     }\n }\n \n struct MetadataCreationResult<'ll> {\n     metadata: &'ll DIType,\n-    already_stored_in_typemap: bool\n+    already_stored_in_typemap: bool,\n }\n \n impl MetadataCreationResult<'ll> {\n     fn new(metadata: &'ll DIType, already_stored_in_typemap: bool) -> Self {\n-        MetadataCreationResult {\n-            metadata,\n-            already_stored_in_typemap,\n-        }\n+        MetadataCreationResult { metadata, already_stored_in_typemap }\n     }\n }\n \n@@ -1044,9 +1016,11 @@ struct MemberDescription<'ll> {\n }\n \n impl<'ll> MemberDescription<'ll> {\n-    fn into_metadata(self,\n-                     cx: &CodegenCx<'ll, '_>,\n-                     composite_type_metadata: &'ll DIScope) -> &'ll DIType {\n+    fn into_metadata(\n+        self,\n+        cx: &CodegenCx<'ll, '_>,\n+        composite_type_metadata: &'ll DIScope,\n+    ) -> &'ll DIType {\n         let member_name = CString::new(self.name).unwrap();\n         unsafe {\n             llvm::LLVMRustDIBuilderCreateVariantMemberType(\n@@ -1063,7 +1037,8 @@ impl<'ll> MemberDescription<'ll> {\n                     Some(value) => Some(cx.const_u64(value)),\n                 },\n                 self.flags,\n-                self.type_metadata)\n+                self.type_metadata,\n+            )\n         }\n     }\n }\n@@ -1077,28 +1052,17 @@ enum MemberDescriptionFactory<'ll, 'tcx> {\n     TupleMDF(TupleMemberDescriptionFactory<'tcx>),\n     EnumMDF(EnumMemberDescriptionFactory<'ll, 'tcx>),\n     UnionMDF(UnionMemberDescriptionFactory<'tcx>),\n-    VariantMDF(VariantMemberDescriptionFactory<'ll, 'tcx>)\n+    VariantMDF(VariantMemberDescriptionFactory<'ll, 'tcx>),\n }\n \n impl MemberDescriptionFactory<'ll, 'tcx> {\n-    fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n-                                  -> Vec<MemberDescription<'ll>> {\n+    fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>) -> Vec<MemberDescription<'ll>> {\n         match *self {\n-            StructMDF(ref this) => {\n-                this.create_member_descriptions(cx)\n-            }\n-            TupleMDF(ref this) => {\n-                this.create_member_descriptions(cx)\n-            }\n-            EnumMDF(ref this) => {\n-                this.create_member_descriptions(cx)\n-            }\n-            UnionMDF(ref this) => {\n-                this.create_member_descriptions(cx)\n-            }\n-            VariantMDF(ref this) => {\n-                this.create_member_descriptions(cx)\n-            }\n+            StructMDF(ref this) => this.create_member_descriptions(cx),\n+            TupleMDF(ref this) => this.create_member_descriptions(cx),\n+            EnumMDF(ref this) => this.create_member_descriptions(cx),\n+            UnionMDF(ref this) => this.create_member_descriptions(cx),\n+            VariantMDF(ref this) => this.create_member_descriptions(cx),\n         }\n     }\n }\n@@ -1115,30 +1079,33 @@ struct StructMemberDescriptionFactory<'tcx> {\n }\n \n impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n-                                  -> Vec<MemberDescription<'ll>> {\n+    fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>) -> Vec<MemberDescription<'ll>> {\n         let layout = cx.layout_of(self.ty);\n-        self.variant.fields.iter().enumerate().map(|(i, f)| {\n-            let name = if self.variant.ctor_kind == CtorKind::Fn {\n-                format!(\"__{}\", i)\n-            } else {\n-                f.ident.to_string()\n-            };\n-            let field = layout.field(cx, i);\n-            MemberDescription {\n-                name,\n-                type_metadata: type_metadata(cx, field.ty, self.span),\n-                offset: layout.fields.offset(i),\n-                size: field.size,\n-                align: field.align.abi,\n-                flags: DIFlags::FlagZero,\n-                discriminant: None,\n-            }\n-        }).collect()\n+        self.variant\n+            .fields\n+            .iter()\n+            .enumerate()\n+            .map(|(i, f)| {\n+                let name = if self.variant.ctor_kind == CtorKind::Fn {\n+                    format!(\"__{}\", i)\n+                } else {\n+                    f.ident.to_string()\n+                };\n+                let field = layout.field(cx, i);\n+                MemberDescription {\n+                    name,\n+                    type_metadata: type_metadata(cx, field.ty, self.span),\n+                    offset: layout.fields.offset(i),\n+                    size: field.size,\n+                    align: field.align.abi,\n+                    flags: DIFlags::FlagZero,\n+                    discriminant: None,\n+                }\n+            })\n+            .collect()\n     }\n }\n \n-\n fn prepare_struct_metadata(\n     cx: &CodegenCx<'ll, 'tcx>,\n     struct_type: Ty<'tcx>,\n@@ -1149,28 +1116,21 @@ fn prepare_struct_metadata(\n \n     let (struct_def_id, variant) = match struct_type.kind {\n         ty::Adt(def, _) => (def.did, def.non_enum_variant()),\n-        _ => bug!(\"prepare_struct_metadata on a non-ADT\")\n+        _ => bug!(\"prepare_struct_metadata on a non-ADT\"),\n     };\n \n     let containing_scope = get_namespace_for_item(cx, struct_def_id);\n \n-    let struct_metadata_stub = create_struct_stub(cx,\n-                                                  struct_type,\n-                                                  &struct_name,\n-                                                  unique_type_id,\n-                                                  Some(containing_scope));\n+    let struct_metadata_stub =\n+        create_struct_stub(cx, struct_type, &struct_name, unique_type_id, Some(containing_scope));\n \n     create_and_register_recursive_type_forward_declaration(\n         cx,\n         struct_type,\n         unique_type_id,\n         struct_metadata_stub,\n         struct_metadata_stub,\n-        StructMDF(StructMemberDescriptionFactory {\n-            ty: struct_type,\n-            variant,\n-            span,\n-        })\n+        StructMDF(StructMemberDescriptionFactory { ty: struct_type, variant, span }),\n     )\n }\n \n@@ -1186,21 +1146,24 @@ struct TupleMemberDescriptionFactory<'tcx> {\n }\n \n impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n-                                  -> Vec<MemberDescription<'ll>> {\n+    fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>) -> Vec<MemberDescription<'ll>> {\n         let layout = cx.layout_of(self.ty);\n-        self.component_types.iter().enumerate().map(|(i, &component_type)| {\n-            let (size, align) = cx.size_and_align_of(component_type);\n-            MemberDescription {\n-                name: format!(\"__{}\", i),\n-                type_metadata: type_metadata(cx, component_type, self.span),\n-                offset: layout.fields.offset(i),\n-                size,\n-                align,\n-                flags: DIFlags::FlagZero,\n-                discriminant: None,\n-            }\n-        }).collect()\n+        self.component_types\n+            .iter()\n+            .enumerate()\n+            .map(|(i, &component_type)| {\n+                let (size, align) = cx.size_and_align_of(component_type);\n+                MemberDescription {\n+                    name: format!(\"__{}\", i),\n+                    type_metadata: type_metadata(cx, component_type, self.span),\n+                    offset: layout.fields.offset(i),\n+                    size,\n+                    align,\n+                    flags: DIFlags::FlagZero,\n+                    discriminant: None,\n+                }\n+            })\n+            .collect()\n     }\n }\n \n@@ -1214,11 +1177,8 @@ fn prepare_tuple_metadata(\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n     let tuple_name = compute_debuginfo_type_name(cx.tcx, tuple_type, false);\n \n-    let struct_stub = create_struct_stub(cx,\n-                                         tuple_type,\n-                                         &tuple_name[..],\n-                                         unique_type_id,\n-                                         containing_scope);\n+    let struct_stub =\n+        create_struct_stub(cx, tuple_type, &tuple_name[..], unique_type_id, containing_scope);\n \n     create_and_register_recursive_type_forward_declaration(\n         cx,\n@@ -1230,7 +1190,7 @@ fn prepare_tuple_metadata(\n             ty: tuple_type,\n             component_types: component_types.to_vec(),\n             span,\n-        })\n+        }),\n     )\n }\n \n@@ -1245,20 +1205,24 @@ struct UnionMemberDescriptionFactory<'tcx> {\n }\n \n impl<'tcx> UnionMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n-                                  -> Vec<MemberDescription<'ll>> {\n-        self.variant.fields.iter().enumerate().map(|(i, f)| {\n-            let field = self.layout.field(cx, i);\n-            MemberDescription {\n-                name: f.ident.to_string(),\n-                type_metadata: type_metadata(cx, field.ty, self.span),\n-                offset: Size::ZERO,\n-                size: field.size,\n-                align: field.align.abi,\n-                flags: DIFlags::FlagZero,\n-                discriminant: None,\n-            }\n-        }).collect()\n+    fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>) -> Vec<MemberDescription<'ll>> {\n+        self.variant\n+            .fields\n+            .iter()\n+            .enumerate()\n+            .map(|(i, f)| {\n+                let field = self.layout.field(cx, i);\n+                MemberDescription {\n+                    name: f.ident.to_string(),\n+                    type_metadata: type_metadata(cx, field.ty, self.span),\n+                    offset: Size::ZERO,\n+                    size: field.size,\n+                    align: field.align.abi,\n+                    flags: DIFlags::FlagZero,\n+                    discriminant: None,\n+                }\n+            })\n+            .collect()\n     }\n }\n \n@@ -1272,28 +1236,21 @@ fn prepare_union_metadata(\n \n     let (union_def_id, variant) = match union_type.kind {\n         ty::Adt(def, _) => (def.did, def.non_enum_variant()),\n-        _ => bug!(\"prepare_union_metadata on a non-ADT\")\n+        _ => bug!(\"prepare_union_metadata on a non-ADT\"),\n     };\n \n     let containing_scope = get_namespace_for_item(cx, union_def_id);\n \n-    let union_metadata_stub = create_union_stub(cx,\n-                                                union_type,\n-                                                &union_name,\n-                                                unique_type_id,\n-                                                containing_scope);\n+    let union_metadata_stub =\n+        create_union_stub(cx, union_type, &union_name, unique_type_id, containing_scope);\n \n     create_and_register_recursive_type_forward_declaration(\n         cx,\n         union_type,\n         unique_type_id,\n         union_metadata_stub,\n         union_metadata_stub,\n-        UnionMDF(UnionMemberDescriptionFactory {\n-            layout: cx.layout_of(union_type),\n-            variant,\n-            span,\n-        })\n+        UnionMDF(UnionMemberDescriptionFactory { layout: cx.layout_of(union_type), variant, span }),\n     )\n }\n \n@@ -1327,8 +1284,7 @@ fn generator_layout_and_saved_local_names(\n ) -> (&'tcx GeneratorLayout<'tcx>, IndexVec<mir::GeneratorSavedLocal, Option<ast::Name>>) {\n     let body = tcx.optimized_mir(def_id);\n     let generator_layout = body.generator_layout.as_ref().unwrap();\n-    let mut generator_saved_local_names =\n-        IndexVec::from_elem(None, &generator_layout.field_tys);\n+    let mut generator_saved_local_names = IndexVec::from_elem(None, &generator_layout.field_tys);\n \n     let state_arg = mir::PlaceBase::Local(mir::Local::new(1));\n     for var in &body.var_debug_info {\n@@ -1372,30 +1328,27 @@ struct EnumMemberDescriptionFactory<'ll, 'tcx> {\n }\n \n impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n-    fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n-                                  -> Vec<MemberDescription<'ll>> {\n+    fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>) -> Vec<MemberDescription<'ll>> {\n         let generator_variant_info_data = match self.enum_type.kind {\n             ty::Generator(def_id, ..) => {\n                 Some(generator_layout_and_saved_local_names(cx.tcx, def_id))\n             }\n             _ => None,\n         };\n \n-        let variant_info_for = |index: VariantIdx| {\n-            match self.enum_type.kind {\n-                ty::Adt(adt, _) => VariantInfo::Adt(&adt.variants[index]),\n-                ty::Generator(_, substs, _) => {\n-                    let (generator_layout, generator_saved_local_names) =\n-                        generator_variant_info_data.as_ref().unwrap();\n-                    VariantInfo::Generator {\n-                        substs,\n-                        generator_layout: *generator_layout,\n-                        generator_saved_local_names,\n-                        variant_index: index,\n-                    }\n+        let variant_info_for = |index: VariantIdx| match self.enum_type.kind {\n+            ty::Adt(adt, _) => VariantInfo::Adt(&adt.variants[index]),\n+            ty::Generator(_, substs, _) => {\n+                let (generator_layout, generator_saved_local_names) =\n+                    generator_variant_info_data.as_ref().unwrap();\n+                VariantInfo::Generator {\n+                    substs,\n+                    generator_layout: *generator_layout,\n+                    generator_saved_local_names,\n+                    variant_index: index,\n                 }\n-                _ => bug!(),\n             }\n+            _ => bug!(),\n         };\n \n         // This will always find the metadata in the type map.\n@@ -1415,36 +1368,32 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                 }\n \n                 let variant_info = variant_info_for(index);\n-                let (variant_type_metadata, member_description_factory) =\n-                    describe_enum_variant(cx,\n-                                          self.layout,\n-                                          variant_info,\n-                                          NoDiscriminant,\n-                                          self_metadata,\n-                                          self.span);\n-\n-                let member_descriptions =\n-                    member_description_factory.create_member_descriptions(cx);\n-\n-                set_members_of_composite_type(cx,\n-                                              self.enum_type,\n-                                              variant_type_metadata,\n-                                              member_descriptions);\n-                vec![\n-                    MemberDescription {\n-                        name: if fallback {\n-                            String::new()\n-                        } else {\n-                            variant_info.variant_name()\n-                        },\n-                        type_metadata: variant_type_metadata,\n-                        offset: Size::ZERO,\n-                        size: self.layout.size,\n-                        align: self.layout.align.abi,\n-                        flags: DIFlags::FlagZero,\n-                        discriminant: None,\n-                    }\n-                ]\n+                let (variant_type_metadata, member_description_factory) = describe_enum_variant(\n+                    cx,\n+                    self.layout,\n+                    variant_info,\n+                    NoDiscriminant,\n+                    self_metadata,\n+                    self.span,\n+                );\n+\n+                let member_descriptions = member_description_factory.create_member_descriptions(cx);\n+\n+                set_members_of_composite_type(\n+                    cx,\n+                    self.enum_type,\n+                    variant_type_metadata,\n+                    member_descriptions,\n+                );\n+                vec![MemberDescription {\n+                    name: if fallback { String::new() } else { variant_info.variant_name() },\n+                    type_metadata: variant_type_metadata,\n+                    offset: Size::ZERO,\n+                    size: self.layout.size,\n+                    align: self.layout.align.abi,\n+                    flags: DIFlags::FlagZero,\n+                    discriminant: None,\n+                }]\n             }\n             layout::Variants::Multiple {\n                 discr_kind: layout::DiscriminantKind::Tag,\n@@ -1455,87 +1404,96 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                 let discriminant_info = if fallback {\n                     RegularDiscriminant {\n                         discr_field: Field::from(discr_index),\n-                        discr_type_metadata: self.discriminant_type_metadata.unwrap()\n+                        discr_type_metadata: self.discriminant_type_metadata.unwrap(),\n                     }\n                 } else {\n                     // This doesn't matter in this case.\n                     NoDiscriminant\n                 };\n-                variants.iter_enumerated().map(|(i, _)| {\n-                    let variant = self.layout.for_variant(cx, i);\n-                    let variant_info = variant_info_for(i);\n-                    let (variant_type_metadata, member_desc_factory) =\n-                        describe_enum_variant(cx,\n-                                              variant,\n-                                              variant_info,\n-                                              discriminant_info,\n-                                              self_metadata,\n-                                              self.span);\n-\n-                    let member_descriptions = member_desc_factory\n-                        .create_member_descriptions(cx);\n-\n-                    set_members_of_composite_type(cx,\n-                                                  self.enum_type,\n-                                                  variant_type_metadata,\n-                                                  member_descriptions);\n-\n-                    MemberDescription {\n-                        name: if fallback {\n-                            String::new()\n-                        } else {\n-                            variant_info.variant_name()\n-                        },\n-                        type_metadata: variant_type_metadata,\n-                        offset: Size::ZERO,\n-                        size: self.layout.size,\n-                        align: self.layout.align.abi,\n-                        flags: DIFlags::FlagZero,\n-                        discriminant: Some(\n-                            self.layout.ty.discriminant_for_variant(cx.tcx, i).unwrap().val as u64\n-                        ),\n-                    }\n-                }).collect()\n+                variants\n+                    .iter_enumerated()\n+                    .map(|(i, _)| {\n+                        let variant = self.layout.for_variant(cx, i);\n+                        let variant_info = variant_info_for(i);\n+                        let (variant_type_metadata, member_desc_factory) = describe_enum_variant(\n+                            cx,\n+                            variant,\n+                            variant_info,\n+                            discriminant_info,\n+                            self_metadata,\n+                            self.span,\n+                        );\n+\n+                        let member_descriptions =\n+                            member_desc_factory.create_member_descriptions(cx);\n+\n+                        set_members_of_composite_type(\n+                            cx,\n+                            self.enum_type,\n+                            variant_type_metadata,\n+                            member_descriptions,\n+                        );\n+\n+                        MemberDescription {\n+                            name: if fallback {\n+                                String::new()\n+                            } else {\n+                                variant_info.variant_name()\n+                            },\n+                            type_metadata: variant_type_metadata,\n+                            offset: Size::ZERO,\n+                            size: self.layout.size,\n+                            align: self.layout.align.abi,\n+                            flags: DIFlags::FlagZero,\n+                            discriminant: Some(\n+                                self.layout.ty.discriminant_for_variant(cx.tcx, i).unwrap().val\n+                                    as u64,\n+                            ),\n+                        }\n+                    })\n+                    .collect()\n             }\n             layout::Variants::Multiple {\n-                discr_kind: layout::DiscriminantKind::Niche {\n-                    ref niche_variants,\n-                    niche_start,\n-                    dataful_variant,\n-                },\n+                discr_kind:\n+                    layout::DiscriminantKind::Niche { ref niche_variants, niche_start, dataful_variant },\n                 ref discr,\n                 ref variants,\n                 discr_index,\n             } => {\n                 if fallback {\n                     let variant = self.layout.for_variant(cx, dataful_variant);\n                     // Create a description of the non-null variant.\n-                    let (variant_type_metadata, member_description_factory) =\n-                        describe_enum_variant(cx,\n-                                              variant,\n-                                              variant_info_for(dataful_variant),\n-                                              OptimizedDiscriminant,\n-                                              self.containing_scope,\n-                                              self.span);\n+                    let (variant_type_metadata, member_description_factory) = describe_enum_variant(\n+                        cx,\n+                        variant,\n+                        variant_info_for(dataful_variant),\n+                        OptimizedDiscriminant,\n+                        self.containing_scope,\n+                        self.span,\n+                    );\n \n                     let variant_member_descriptions =\n                         member_description_factory.create_member_descriptions(cx);\n \n-                    set_members_of_composite_type(cx,\n-                                                  self.enum_type,\n-                                                  variant_type_metadata,\n-                                                  variant_member_descriptions);\n+                    set_members_of_composite_type(\n+                        cx,\n+                        self.enum_type,\n+                        variant_type_metadata,\n+                        variant_member_descriptions,\n+                    );\n \n                     // Encode the information about the null variant in the union\n                     // member's name.\n                     let mut name = String::from(\"RUST$ENCODED$ENUM$\");\n                     // Right now it's not even going to work for `niche_start > 0`,\n                     // and for multiple niche variants it only supports the first.\n-                    fn compute_field_path<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                                    name: &mut String,\n-                                                    layout: TyLayout<'tcx>,\n-                                                    offset: Size,\n-                                                    size: Size) {\n+                    fn compute_field_path<'a, 'tcx>(\n+                        cx: &CodegenCx<'a, 'tcx>,\n+                        name: &mut String,\n+                        layout: TyLayout<'tcx>,\n+                        offset: Size,\n+                        size: Size,\n+                    ) {\n                         for i in 0..layout.fields.count() {\n                             let field_offset = layout.fields.offset(i);\n                             if field_offset > offset {\n@@ -1549,70 +1507,78 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                             }\n                         }\n                     }\n-                    compute_field_path(cx, &mut name,\n-                                       self.layout,\n-                                       self.layout.fields.offset(discr_index),\n-                                       self.layout.field(cx, discr_index).size);\n+                    compute_field_path(\n+                        cx,\n+                        &mut name,\n+                        self.layout,\n+                        self.layout.fields.offset(discr_index),\n+                        self.layout.field(cx, discr_index).size,\n+                    );\n                     variant_info_for(*niche_variants.start()).map_struct_name(|variant_name| {\n                         name.push_str(variant_name);\n                     });\n \n                     // Create the (singleton) list of descriptions of union members.\n-                    vec![\n-                        MemberDescription {\n-                            name,\n-                            type_metadata: variant_type_metadata,\n-                            offset: Size::ZERO,\n-                            size: variant.size,\n-                            align: variant.align.abi,\n-                            flags: DIFlags::FlagZero,\n-                            discriminant: None,\n-                        }\n-                    ]\n+                    vec![MemberDescription {\n+                        name,\n+                        type_metadata: variant_type_metadata,\n+                        offset: Size::ZERO,\n+                        size: variant.size,\n+                        align: variant.align.abi,\n+                        flags: DIFlags::FlagZero,\n+                        discriminant: None,\n+                    }]\n                 } else {\n-                    variants.iter_enumerated().map(|(i, _)| {\n-                        let variant = self.layout.for_variant(cx, i);\n-                        let variant_info = variant_info_for(i);\n-                        let (variant_type_metadata, member_desc_factory) =\n-                            describe_enum_variant(cx,\n-                                                  variant,\n-                                                  variant_info,\n-                                                  OptimizedDiscriminant,\n-                                                  self_metadata,\n-                                                  self.span);\n-\n-                        let member_descriptions = member_desc_factory\n-                            .create_member_descriptions(cx);\n-\n-                        set_members_of_composite_type(cx,\n-                                                      self.enum_type,\n-                                                      variant_type_metadata,\n-                                                      member_descriptions);\n-\n-                        let niche_value = if i == dataful_variant {\n-                            None\n-                        } else {\n-                            let value = (i.as_u32() as u128)\n-                                .wrapping_sub(niche_variants.start().as_u32() as u128)\n-                                .wrapping_add(niche_start);\n-                            let value = truncate(value, discr.value.size(cx));\n-                            // NOTE(eddyb) do *NOT* remove this assert, until\n-                            // we pass the full 128-bit value to LLVM, otherwise\n-                            // truncation will be silent and remain undetected.\n-                            assert_eq!(value as u64 as u128, value);\n-                            Some(value as u64)\n-                        };\n-\n-                        MemberDescription {\n-                            name: variant_info.variant_name(),\n-                            type_metadata: variant_type_metadata,\n-                            offset: Size::ZERO,\n-                            size: self.layout.size,\n-                            align: self.layout.align.abi,\n-                            flags: DIFlags::FlagZero,\n-                            discriminant: niche_value,\n-                        }\n-                    }).collect()\n+                    variants\n+                        .iter_enumerated()\n+                        .map(|(i, _)| {\n+                            let variant = self.layout.for_variant(cx, i);\n+                            let variant_info = variant_info_for(i);\n+                            let (variant_type_metadata, member_desc_factory) =\n+                                describe_enum_variant(\n+                                    cx,\n+                                    variant,\n+                                    variant_info,\n+                                    OptimizedDiscriminant,\n+                                    self_metadata,\n+                                    self.span,\n+                                );\n+\n+                            let member_descriptions =\n+                                member_desc_factory.create_member_descriptions(cx);\n+\n+                            set_members_of_composite_type(\n+                                cx,\n+                                self.enum_type,\n+                                variant_type_metadata,\n+                                member_descriptions,\n+                            );\n+\n+                            let niche_value = if i == dataful_variant {\n+                                None\n+                            } else {\n+                                let value = (i.as_u32() as u128)\n+                                    .wrapping_sub(niche_variants.start().as_u32() as u128)\n+                                    .wrapping_add(niche_start);\n+                                let value = truncate(value, discr.value.size(cx));\n+                                // NOTE(eddyb) do *NOT* remove this assert, until\n+                                // we pass the full 128-bit value to LLVM, otherwise\n+                                // truncation will be silent and remain undetected.\n+                                assert_eq!(value as u64 as u128, value);\n+                                Some(value as u64)\n+                            };\n+\n+                            MemberDescription {\n+                                name: variant_info.variant_name(),\n+                                type_metadata: variant_type_metadata,\n+                                offset: Size::ZERO,\n+                                size: self.layout.size,\n+                                align: self.layout.align.abi,\n+                                flags: DIFlags::FlagZero,\n+                                discriminant: niche_value,\n+                            }\n+                        })\n+                        .collect()\n                 }\n             }\n         }\n@@ -1629,37 +1595,40 @@ struct VariantMemberDescriptionFactory<'ll, 'tcx> {\n }\n \n impl VariantMemberDescriptionFactory<'ll, 'tcx> {\n-    fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n-                                      -> Vec<MemberDescription<'ll>> {\n-        self.args.iter().enumerate().map(|(i, &(ref name, ty))| {\n-            let (size, align) = cx.size_and_align_of(ty);\n-            MemberDescription {\n-                name: name.to_string(),\n-                type_metadata: if use_enum_fallback(cx) {\n-                    match self.discriminant_type_metadata {\n-                        // Discriminant is always the first field of our variant\n-                        // when using the enum fallback.\n-                        Some(metadata) if i == 0 => metadata,\n-                        _ => type_metadata(cx, ty, self.span)\n-                    }\n-                } else {\n-                    type_metadata(cx, ty, self.span)\n-                },\n-                offset: self.offsets[i],\n-                size,\n-                align,\n-                flags: DIFlags::FlagZero,\n-                discriminant: None,\n-            }\n-        }).collect()\n+    fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>) -> Vec<MemberDescription<'ll>> {\n+        self.args\n+            .iter()\n+            .enumerate()\n+            .map(|(i, &(ref name, ty))| {\n+                let (size, align) = cx.size_and_align_of(ty);\n+                MemberDescription {\n+                    name: name.to_string(),\n+                    type_metadata: if use_enum_fallback(cx) {\n+                        match self.discriminant_type_metadata {\n+                            // Discriminant is always the first field of our variant\n+                            // when using the enum fallback.\n+                            Some(metadata) if i == 0 => metadata,\n+                            _ => type_metadata(cx, ty, self.span),\n+                        }\n+                    } else {\n+                        type_metadata(cx, ty, self.span)\n+                    },\n+                    offset: self.offsets[i],\n+                    size,\n+                    align,\n+                    flags: DIFlags::FlagZero,\n+                    discriminant: None,\n+                }\n+            })\n+            .collect()\n     }\n }\n \n #[derive(Copy, Clone)]\n enum EnumDiscriminantInfo<'ll> {\n-    RegularDiscriminant{ discr_field: Field, discr_type_metadata: &'ll DIType },\n+    RegularDiscriminant { discr_field: Field, discr_type_metadata: &'ll DIType },\n     OptimizedDiscriminant,\n-    NoDiscriminant\n+    NoDiscriminant,\n }\n \n #[derive(Copy, Clone)]\n@@ -1677,8 +1646,9 @@ impl<'tcx> VariantInfo<'_, 'tcx> {\n     fn map_struct_name<R>(&self, f: impl FnOnce(&str) -> R) -> R {\n         match self {\n             VariantInfo::Adt(variant) => f(&variant.ident.as_str()),\n-            VariantInfo::Generator { substs, variant_index, .. } =>\n-                f(&substs.as_generator().variant_name(*variant_index)),\n+            VariantInfo::Generator { substs, variant_index, .. } => {\n+                f(&substs.as_generator().variant_name(*variant_index))\n+            }\n         }\n     }\n \n@@ -1697,16 +1667,18 @@ impl<'tcx> VariantInfo<'_, 'tcx> {\n \n     fn field_name(&self, i: usize) -> String {\n         let field_name = match *self {\n-            VariantInfo::Adt(variant) if variant.ctor_kind != CtorKind::Fn =>\n-                Some(variant.fields[i].ident.name),\n+            VariantInfo::Adt(variant) if variant.ctor_kind != CtorKind::Fn => {\n+                Some(variant.fields[i].ident.name)\n+            }\n             VariantInfo::Generator {\n                 generator_layout,\n                 generator_saved_local_names,\n                 variant_index,\n                 ..\n-            } => generator_saved_local_names[\n-                generator_layout.variant_fields[variant_index][i.into()]\n-            ],\n+            } => {\n+                generator_saved_local_names\n+                    [generator_layout.variant_fields[variant_index][i.into()]]\n+            }\n             _ => None,\n         };\n         field_name.map(|name| name.to_string()).unwrap_or_else(|| format!(\"__{}\", i))\n@@ -1726,17 +1698,11 @@ fn describe_enum_variant(\n     span: Span,\n ) -> (&'ll DICompositeType, MemberDescriptionFactory<'ll, 'tcx>) {\n     let metadata_stub = variant.map_struct_name(|variant_name| {\n-        let unique_type_id = debug_context(cx).type_map\n-                                              .borrow_mut()\n-                                              .get_unique_type_id_of_enum_variant(\n-                                                  cx,\n-                                                  layout.ty,\n-                                                  &variant_name);\n-        create_struct_stub(cx,\n-                           layout.ty,\n-                           &variant_name,\n-                           unique_type_id,\n-                           Some(containing_scope))\n+        let unique_type_id = debug_context(cx)\n+            .type_map\n+            .borrow_mut()\n+            .get_unique_type_id_of_enum_variant(cx, layout.ty, &variant_name);\n+        create_struct_stub(cx, layout.ty, &variant_name, unique_type_id, Some(containing_scope))\n     });\n \n     // Build an array of (field name, field type) pairs to be captured in the factory closure.\n@@ -1747,44 +1713,43 @@ fn describe_enum_variant(\n                 // We have the layout of an enum variant, we need the layout of the outer enum\n                 let enum_layout = cx.layout_of(layout.ty);\n                 let offset = enum_layout.fields.offset(discr_field.as_usize());\n-                let args = (\n-                    \"RUST$ENUM$DISR\".to_owned(),\n-                    enum_layout.field(cx, discr_field.as_usize()).ty);\n+                let args =\n+                    (\"RUST$ENUM$DISR\".to_owned(), enum_layout.field(cx, discr_field.as_usize()).ty);\n                 (Some(offset), Some(args))\n             }\n             _ => (None, None),\n         };\n         (\n-            discr_offset.into_iter().chain((0..layout.fields.count()).map(|i| {\n-                layout.fields.offset(i)\n-            })).collect(),\n-            discr_arg.into_iter().chain((0..layout.fields.count()).map(|i| {\n-                (variant.field_name(i), layout.field(cx, i).ty)\n-            })).collect()\n+            discr_offset\n+                .into_iter()\n+                .chain((0..layout.fields.count()).map(|i| layout.fields.offset(i)))\n+                .collect(),\n+            discr_arg\n+                .into_iter()\n+                .chain(\n+                    (0..layout.fields.count())\n+                        .map(|i| (variant.field_name(i), layout.field(cx, i).ty)),\n+                )\n+                .collect(),\n         )\n     } else {\n         (\n-            (0..layout.fields.count()).map(|i| {\n-                layout.fields.offset(i)\n-            }).collect(),\n-            (0..layout.fields.count()).map(|i| {\n-                (variant.field_name(i), layout.field(cx, i).ty)\n-            }).collect()\n+            (0..layout.fields.count()).map(|i| layout.fields.offset(i)).collect(),\n+            (0..layout.fields.count())\n+                .map(|i| (variant.field_name(i), layout.field(cx, i).ty))\n+                .collect(),\n         )\n     };\n \n-    let member_description_factory =\n-        VariantMDF(VariantMemberDescriptionFactory {\n-            offsets,\n-            args,\n-            discriminant_type_metadata: match discriminant_info {\n-                RegularDiscriminant { discr_type_metadata, .. } => {\n-                    Some(discr_type_metadata)\n-                }\n-                _ => None\n-            },\n-            span,\n-        });\n+    let member_description_factory = VariantMDF(VariantMemberDescriptionFactory {\n+        offsets,\n+        args,\n+        discriminant_type_metadata: match discriminant_info {\n+            RegularDiscriminant { discr_type_metadata, .. } => Some(discr_type_metadata),\n+            _ => None,\n+        },\n+        span,\n+    });\n \n     (metadata_stub, member_description_factory)\n }\n@@ -1820,7 +1785,8 @@ fn prepare_enum_metadata(\n                             DIB(cx),\n                             name.as_ptr(),\n                             // FIXME: what if enumeration has i128 discriminant?\n-                            discr.val as u64))\n+                            discr.val as u64,\n+                        ))\n                     }\n                 })\n                 .collect(),\n@@ -1834,22 +1800,21 @@ fn prepare_enum_metadata(\n                             DIB(cx),\n                             name.as_ptr(),\n                             // FIXME: what if enumeration has i128 discriminant?\n-                            variant_index.as_usize() as u64))\n+                            variant_index.as_usize() as u64,\n+                        ))\n                     }\n                 })\n                 .collect(),\n             _ => bug!(),\n         };\n \n         let disr_type_key = (enum_def_id, discr);\n-        let cached_discriminant_type_metadata = debug_context(cx).created_enum_disr_types\n-                                                                 .borrow()\n-                                                                 .get(&disr_type_key).cloned();\n+        let cached_discriminant_type_metadata =\n+            debug_context(cx).created_enum_disr_types.borrow().get(&disr_type_key).cloned();\n         match cached_discriminant_type_metadata {\n             Some(discriminant_type_metadata) => discriminant_type_metadata,\n             None => {\n-                let (discriminant_size, discriminant_align) =\n-                    (discr.size(cx), discr.align(cx));\n+                let (discriminant_size, discriminant_align) = (discr.size(cx), discr.align(cx));\n                 let discriminant_base_type_metadata =\n                     type_metadata(cx, discr.to_ty(cx.tcx), syntax_pos::DUMMY_SP);\n \n@@ -1869,12 +1834,15 @@ fn prepare_enum_metadata(\n                         discriminant_size.bits(),\n                         discriminant_align.abi.bits() as u32,\n                         create_DIArray(DIB(cx), &enumerators_metadata),\n-                        discriminant_base_type_metadata, true)\n+                        discriminant_base_type_metadata,\n+                        true,\n+                    )\n                 };\n \n-                debug_context(cx).created_enum_disr_types\n-                                 .borrow_mut()\n-                                 .insert(disr_type_key, discriminant_type_metadata);\n+                debug_context(cx)\n+                    .created_enum_disr_types\n+                    .borrow_mut()\n+                    .insert(disr_type_key, discriminant_type_metadata);\n \n                 discriminant_type_metadata\n             }\n@@ -1884,33 +1852,34 @@ fn prepare_enum_metadata(\n     let layout = cx.layout_of(enum_type);\n \n     match (&layout.abi, &layout.variants) {\n-        (&layout::Abi::Scalar(_), &layout::Variants::Multiple {\n-            discr_kind: layout::DiscriminantKind::Tag,\n-            ref discr,\n-            ..\n-        }) => return FinalMetadata(discriminant_type_metadata(discr.value)),\n+        (\n+            &layout::Abi::Scalar(_),\n+            &layout::Variants::Multiple {\n+                discr_kind: layout::DiscriminantKind::Tag,\n+                ref discr,\n+                ..\n+            },\n+        ) => return FinalMetadata(discriminant_type_metadata(discr.value)),\n         _ => {}\n     }\n \n     let enum_name = SmallCStr::new(&enum_name);\n     let unique_type_id_str = SmallCStr::new(\n-        debug_context(cx).type_map.borrow().get_unique_type_id_as_string(unique_type_id)\n+        debug_context(cx).type_map.borrow().get_unique_type_id_as_string(unique_type_id),\n     );\n \n     if use_enum_fallback(cx) {\n         let discriminant_type_metadata = match layout.variants {\n-            layout::Variants::Single { .. } |\n-            layout::Variants::Multiple {\n+            layout::Variants::Single { .. }\n+            | layout::Variants::Multiple {\n                 discr_kind: layout::DiscriminantKind::Niche { .. },\n                 ..\n             } => None,\n             layout::Variants::Multiple {\n                 discr_kind: layout::DiscriminantKind::Tag,\n                 ref discr,\n                 ..\n-            } => {\n-                Some(discriminant_type_metadata(discr.value))\n-            }\n+            } => Some(discriminant_type_metadata(discr.value)),\n         };\n \n         let enum_metadata = unsafe {\n@@ -1925,7 +1894,8 @@ fn prepare_enum_metadata(\n                 DIFlags::FlagZero,\n                 None,\n                 0, // RuntimeLang\n-                unique_type_id_str.as_ptr())\n+                unique_type_id_str.as_ptr(),\n+            )\n         };\n \n         return create_and_register_recursive_type_forward_declaration(\n@@ -1968,7 +1938,8 @@ fn prepare_enum_metadata(\n                 layout::F32 => Integer::I32,\n                 layout::F64 => Integer::I64,\n                 layout::Pointer => cx.data_layout().ptr_sized_integer(),\n-            }.to_ty(cx.tcx, false);\n+            }\n+            .to_ty(cx.tcx, false);\n \n             let discr_metadata = basic_type_metadata(cx, discr_type);\n             unsafe {\n@@ -1982,9 +1953,10 @@ fn prepare_enum_metadata(\n                     align.abi.bits() as u32,\n                     layout.fields.offset(discr_index).bits(),\n                     DIFlags::FlagArtificial,\n-                    discr_metadata))\n+                    discr_metadata,\n+                ))\n             }\n-        },\n+        }\n \n         layout::Variants::Multiple {\n             discr_kind: layout::DiscriminantKind::Tag,\n@@ -2007,9 +1979,10 @@ fn prepare_enum_metadata(\n                     align.bits() as u32,\n                     layout.fields.offset(discr_index).bits(),\n                     DIFlags::FlagArtificial,\n-                    discr_metadata))\n+                    discr_metadata,\n+                ))\n             }\n-        },\n+        }\n     };\n \n     let mut outer_fields = match layout.variants {\n@@ -2018,7 +1991,7 @@ fn prepare_enum_metadata(\n             let tuple_mdf = TupleMemberDescriptionFactory {\n                 ty: enum_type,\n                 component_types: outer_field_tys,\n-                span\n+                span,\n             };\n             tuple_mdf\n                 .create_member_descriptions(cx)\n@@ -2029,9 +2002,10 @@ fn prepare_enum_metadata(\n     };\n \n     let variant_part_unique_type_id_str = SmallCStr::new(\n-        debug_context(cx).type_map\n+        debug_context(cx)\n+            .type_map\n             .borrow_mut()\n-            .get_unique_type_id_str_of_enum_variant_part(unique_type_id)\n+            .get_unique_type_id_str_of_enum_variant_part(unique_type_id),\n     );\n     let empty_array = create_DIArray(DIB(cx), &[]);\n     let variant_part = unsafe {\n@@ -2046,7 +2020,8 @@ fn prepare_enum_metadata(\n             DIFlags::FlagZero,\n             discriminator_metadata,\n             empty_array,\n-            variant_part_unique_type_id_str.as_ptr())\n+            variant_part_unique_type_id_str.as_ptr(),\n+        )\n     };\n     outer_fields.push(Some(variant_part));\n \n@@ -2066,7 +2041,8 @@ fn prepare_enum_metadata(\n             type_array,\n             0,\n             None,\n-            unique_type_id_str.as_ptr())\n+            unique_type_id_str.as_ptr(),\n+        )\n     };\n \n     return create_and_register_recursive_type_forward_declaration(\n@@ -2103,24 +2079,25 @@ fn composite_type_metadata(\n     _definition_span: Span,\n ) -> &'ll DICompositeType {\n     // Create the (empty) struct metadata node ...\n-    let composite_type_metadata = create_struct_stub(cx,\n-                                                     composite_type,\n-                                                     composite_type_name,\n-                                                     composite_type_unique_id,\n-                                                     containing_scope);\n+    let composite_type_metadata = create_struct_stub(\n+        cx,\n+        composite_type,\n+        composite_type_name,\n+        composite_type_unique_id,\n+        containing_scope,\n+    );\n     // ... and immediately create and add the member descriptions.\n-    set_members_of_composite_type(cx,\n-                                  composite_type,\n-                                  composite_type_metadata,\n-                                  member_descriptions);\n+    set_members_of_composite_type(cx, composite_type, composite_type_metadata, member_descriptions);\n \n     composite_type_metadata\n }\n \n-fn set_members_of_composite_type(cx: &CodegenCx<'ll, 'tcx>,\n-                                 composite_type: Ty<'tcx>,\n-                                 composite_type_metadata: &'ll DICompositeType,\n-                                 member_descriptions: Vec<MemberDescription<'ll>>) {\n+fn set_members_of_composite_type(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    composite_type: Ty<'tcx>,\n+    composite_type_metadata: &'ll DICompositeType,\n+    member_descriptions: Vec<MemberDescription<'ll>>,\n+) {\n     // In some rare cases LLVM metadata uniquing would lead to an existing type\n     // description being used instead of a new one created in\n     // create_struct_stub. This would cause a hard to trace assertion in\n@@ -2131,8 +2108,10 @@ fn set_members_of_composite_type(cx: &CodegenCx<'ll, 'tcx>,\n         let mut composite_types_completed =\n             debug_context(cx).composite_types_completed.borrow_mut();\n         if !composite_types_completed.insert(&composite_type_metadata) {\n-            bug!(\"debuginfo::set_members_of_composite_type() - \\\n-                  Already completed forward declaration re-encountered.\");\n+            bug!(\n+                \"debuginfo::set_members_of_composite_type() - \\\n+                  Already completed forward declaration re-encountered.\"\n+            );\n         }\n     }\n \n@@ -2145,7 +2124,11 @@ fn set_members_of_composite_type(cx: &CodegenCx<'ll, 'tcx>,\n     unsafe {\n         let type_array = create_DIArray(DIB(cx), &member_metadata[..]);\n         llvm::LLVMRustDICompositeTypeReplaceArrays(\n-            DIB(cx), composite_type_metadata, Some(type_array), type_params);\n+            DIB(cx),\n+            composite_type_metadata,\n+            Some(type_array),\n+            type_params,\n+        );\n     }\n }\n \n@@ -2155,40 +2138,42 @@ fn compute_type_parameters(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>) -> Option<&'\n         if !substs.types().next().is_none() {\n             let generics = cx.tcx.generics_of(def.did);\n             let names = get_parameter_names(cx, generics);\n-            let template_params: Vec<_> = substs.iter().zip(names).filter_map(|(kind, name)| {\n-                if let GenericArgKind::Type(ty) = kind.unpack() {\n-                    let actual_type = cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), ty);\n-                    let actual_type_metadata =\n-                        type_metadata(cx, actual_type, syntax_pos::DUMMY_SP);\n-                    let name = SmallCStr::new(&name.as_str());\n-                    Some(unsafe {\n-\n-                        Some(llvm::LLVMRustDIBuilderCreateTemplateTypeParameter(\n-                            DIB(cx),\n-                            None,\n-                            name.as_ptr(),\n-                            actual_type_metadata,\n-                            unknown_file_metadata(cx),\n-                            0,\n-                            0,\n-                        ))\n-                    })\n-                } else {\n-                    None\n-                }\n-            }).collect();\n+            let template_params: Vec<_> = substs\n+                .iter()\n+                .zip(names)\n+                .filter_map(|(kind, name)| {\n+                    if let GenericArgKind::Type(ty) = kind.unpack() {\n+                        let actual_type =\n+                            cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), ty);\n+                        let actual_type_metadata =\n+                            type_metadata(cx, actual_type, syntax_pos::DUMMY_SP);\n+                        let name = SmallCStr::new(&name.as_str());\n+                        Some(unsafe {\n+                            Some(llvm::LLVMRustDIBuilderCreateTemplateTypeParameter(\n+                                DIB(cx),\n+                                None,\n+                                name.as_ptr(),\n+                                actual_type_metadata,\n+                                unknown_file_metadata(cx),\n+                                0,\n+                                0,\n+                            ))\n+                        })\n+                    } else {\n+                        None\n+                    }\n+                })\n+                .collect();\n \n             return Some(create_DIArray(DIB(cx), &template_params[..]));\n         }\n     }\n     return Some(create_DIArray(DIB(cx), &[]));\n \n-    fn get_parameter_names(cx: &CodegenCx<'_, '_>,\n-                           generics: &ty::Generics)\n-                           -> Vec<Symbol> {\n-        let mut names = generics.parent.map_or(vec![], |def_id| {\n-            get_parameter_names(cx, cx.tcx.generics_of(def_id))\n-        });\n+    fn get_parameter_names(cx: &CodegenCx<'_, '_>, generics: &ty::Generics) -> Vec<Symbol> {\n+        let mut names = generics\n+            .parent\n+            .map_or(vec![], |def_id| get_parameter_names(cx, cx.tcx.generics_of(def_id)));\n         names.extend(generics.params.iter().map(|param| param.name));\n         names\n     }\n@@ -2208,7 +2193,7 @@ fn create_struct_stub(\n \n     let name = SmallCStr::new(struct_type_name);\n     let unique_type_id = SmallCStr::new(\n-        debug_context(cx).type_map.borrow().get_unique_type_id_as_string(unique_type_id)\n+        debug_context(cx).type_map.borrow().get_unique_type_id_as_string(unique_type_id),\n     );\n     let metadata_stub = unsafe {\n         // `LLVMRustDIBuilderCreateStructType()` wants an empty array. A null\n@@ -2229,7 +2214,8 @@ fn create_struct_stub(\n             empty_array,\n             0,\n             None,\n-            unique_type_id.as_ptr())\n+            unique_type_id.as_ptr(),\n+        )\n     };\n \n     metadata_stub\n@@ -2246,7 +2232,7 @@ fn create_union_stub(\n \n     let name = SmallCStr::new(union_type_name);\n     let unique_type_id = SmallCStr::new(\n-        debug_context(cx).type_map.borrow().get_unique_type_id_as_string(unique_type_id)\n+        debug_context(cx).type_map.borrow().get_unique_type_id_as_string(unique_type_id),\n     );\n     let metadata_stub = unsafe {\n         // `LLVMRustDIBuilderCreateUnionType()` wants an empty array. A null\n@@ -2265,7 +2251,8 @@ fn create_union_stub(\n             DIFlags::FlagZero,\n             Some(empty_array),\n             0, // RuntimeLang\n-            unique_type_id.as_ptr())\n+            unique_type_id.as_ptr(),\n+        )\n     };\n \n     metadata_stub\n@@ -2274,11 +2261,7 @@ fn create_union_stub(\n /// Creates debug information for the given global variable.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_global_var_metadata(\n-    cx: &CodegenCx<'ll, '_>,\n-    def_id: DefId,\n-    global: &'ll Value,\n-) {\n+pub fn create_global_var_metadata(cx: &CodegenCx<'ll, '_>, def_id: DefId, global: &'ll Value) {\n     if cx.dbg_cx.is_none() {\n         return;\n     }\n@@ -2317,20 +2300,20 @@ pub fn create_global_var_metadata(\n     let global_align = cx.align_of(variable_type);\n \n     unsafe {\n-        llvm::LLVMRustDIBuilderCreateStaticVariable(DIB(cx),\n-                                                    Some(var_scope),\n-                                                    var_name.as_ptr(),\n-                                                    // If null, linkage_name field is omitted,\n-                                                    // which is what we want for no_mangle statics\n-                                                    linkage_name.as_ref()\n-                                                     .map_or(ptr::null(), |name| name.as_ptr()),\n-                                                    file_metadata,\n-                                                    line_number,\n-                                                    type_metadata,\n-                                                    is_local_to_unit,\n-                                                    global,\n-                                                    None,\n-                                                    global_align.bytes() as u32,\n+        llvm::LLVMRustDIBuilderCreateStaticVariable(\n+            DIB(cx),\n+            Some(var_scope),\n+            var_name.as_ptr(),\n+            // If null, linkage_name field is omitted,\n+            // which is what we want for no_mangle statics\n+            linkage_name.as_ref().map_or(ptr::null(), |name| name.as_ptr()),\n+            file_metadata,\n+            line_number,\n+            type_metadata,\n+            is_local_to_unit,\n+            global,\n+            None,\n+            global_align.bytes() as u32,\n         );\n     }\n }\n@@ -2370,20 +2353,22 @@ pub fn create_vtable_metadata(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>, vtable: &\n             empty_array,\n             0,\n             Some(type_metadata),\n-            name.as_ptr()\n+            name.as_ptr(),\n         );\n \n-        llvm::LLVMRustDIBuilderCreateStaticVariable(DIB(cx),\n-                                                    NO_SCOPE_METADATA,\n-                                                    name.as_ptr(),\n-                                                    ptr::null(),\n-                                                    unknown_file_metadata(cx),\n-                                                    UNKNOWN_LINE_NUMBER,\n-                                                    vtable_type,\n-                                                    true,\n-                                                    vtable,\n-                                                    None,\n-                                                    0);\n+        llvm::LLVMRustDIBuilderCreateStaticVariable(\n+            DIB(cx),\n+            NO_SCOPE_METADATA,\n+            name.as_ptr(),\n+            ptr::null(),\n+            unknown_file_metadata(cx),\n+            UNKNOWN_LINE_NUMBER,\n+            vtable_type,\n+            true,\n+            vtable,\n+            None,\n+            0,\n+        );\n     }\n }\n \n@@ -2395,10 +2380,5 @@ pub fn extend_scope_to_file(\n     defining_crate: CrateNum,\n ) -> &'ll DILexicalBlock {\n     let file_metadata = file_metadata(cx, &file.name, defining_crate);\n-    unsafe {\n-        llvm::LLVMRustDIBuilderCreateLexicalBlockFile(\n-            DIB(cx),\n-            scope_metadata,\n-            file_metadata)\n-    }\n+    unsafe { llvm::LLVMRustDIBuilderCreateLexicalBlockFile(DIB(cx), scope_metadata, file_metadata) }\n }"}, {"sha": "2d783d6d713361c08bc89ab15f3ff050d9f1e5e6", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 143, "deletions": 133, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d", "patch": "@@ -13,58 +13,80 @@\n //!   but one `llvm::Type` corresponds to many `Ty`s; for instance, `tup(int, int,\n //!   int)` and `rec(x=int, y=int, z=int)` will have the same `llvm::Type`.\n \n-use crate::{CachedModuleCodegen, CrateInfo, MemFlags, ModuleCodegen, ModuleKind};\n use crate::back::write::{\n-    OngoingCodegen, start_async_codegen, submit_pre_lto_module_to_llvm,\n-    submit_post_lto_module_to_llvm,\n+    start_async_codegen, submit_post_lto_module_to_llvm, submit_pre_lto_module_to_llvm,\n+    OngoingCodegen,\n };\n-use crate::common::{RealPredicate, TypeKind, IntPredicate};\n+use crate::common::{IntPredicate, RealPredicate, TypeKind};\n use crate::meth;\n use crate::mir;\n use crate::mir::operand::OperandValue;\n use crate::mir::place::PlaceRef;\n use crate::traits::*;\n+use crate::{CachedModuleCodegen, CrateInfo, MemFlags, ModuleCodegen, ModuleKind};\n \n use rustc::hir;\n-use rustc_session::cgu_reuse_tracker::CguReuse;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::middle::cstore::EncodedMetadata;\n+use rustc::middle::cstore::{self, LinkagePreference};\n use rustc::middle::lang_items::StartFnLangItem;\n use rustc::middle::weak_lang_items;\n-use rustc::mir::mono::{CodegenUnitNameBuilder, CodegenUnit, MonoItem};\n-use rustc::ty::{self, Ty, TyCtxt, Instance};\n-use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, VariantIdx, HasTyCtxt};\n-use rustc::ty::layout::{FAT_PTR_ADDR, FAT_PTR_EXTRA};\n-use rustc::ty::query::Providers;\n-use rustc::middle::cstore::{self, LinkagePreference};\n-use rustc::util::common::{time, print_time_passes_entry, set_time_depth, time_depth};\n+use rustc::mir::mono::{CodegenUnit, CodegenUnitNameBuilder, MonoItem};\n use rustc::session::config::{self, EntryFnType, Lto};\n use rustc::session::Session;\n+use rustc::ty::layout::{self, Align, HasTyCtxt, LayoutOf, TyLayout, VariantIdx};\n+use rustc::ty::layout::{FAT_PTR_ADDR, FAT_PTR_EXTRA};\n+use rustc::ty::query::Providers;\n+use rustc::ty::{self, Instance, Ty, TyCtxt};\n+use rustc::util::common::{print_time_passes_entry, set_time_depth, time, time_depth};\n use rustc::util::nodemap::FxHashMap;\n+use rustc_codegen_utils::{check_for_rustc_errors_attr, symbol_names_test};\n use rustc_index::vec::Idx;\n-use rustc_codegen_utils::{symbol_names_test, check_for_rustc_errors_attr};\n+use rustc_session::cgu_reuse_tracker::CguReuse;\n use syntax::attr;\n use syntax_pos::Span;\n \n use std::cmp;\n use std::ops::{Deref, DerefMut};\n-use std::time::{Instant, Duration};\n+use std::time::{Duration, Instant};\n \n-pub fn bin_op_to_icmp_predicate(op: hir::BinOpKind,\n-                                signed: bool)\n-                                -> IntPredicate {\n+pub fn bin_op_to_icmp_predicate(op: hir::BinOpKind, signed: bool) -> IntPredicate {\n     match op {\n         hir::BinOpKind::Eq => IntPredicate::IntEQ,\n         hir::BinOpKind::Ne => IntPredicate::IntNE,\n-        hir::BinOpKind::Lt => if signed { IntPredicate::IntSLT } else { IntPredicate::IntULT },\n-        hir::BinOpKind::Le => if signed { IntPredicate::IntSLE } else { IntPredicate::IntULE },\n-        hir::BinOpKind::Gt => if signed { IntPredicate::IntSGT } else { IntPredicate::IntUGT },\n-        hir::BinOpKind::Ge => if signed { IntPredicate::IntSGE } else { IntPredicate::IntUGE },\n-        op => {\n-            bug!(\"comparison_op_to_icmp_predicate: expected comparison operator, \\\n-                  found {:?}\",\n-                 op)\n+        hir::BinOpKind::Lt => {\n+            if signed {\n+                IntPredicate::IntSLT\n+            } else {\n+                IntPredicate::IntULT\n+            }\n+        }\n+        hir::BinOpKind::Le => {\n+            if signed {\n+                IntPredicate::IntSLE\n+            } else {\n+                IntPredicate::IntULE\n+            }\n+        }\n+        hir::BinOpKind::Gt => {\n+            if signed {\n+                IntPredicate::IntSGT\n+            } else {\n+                IntPredicate::IntUGT\n+            }\n+        }\n+        hir::BinOpKind::Ge => {\n+            if signed {\n+                IntPredicate::IntSGE\n+            } else {\n+                IntPredicate::IntUGE\n+            }\n         }\n+        op => bug!(\n+            \"comparison_op_to_icmp_predicate: expected comparison operator, \\\n+                  found {:?}\",\n+            op\n+        ),\n     }\n }\n \n@@ -77,9 +99,11 @@ pub fn bin_op_to_fcmp_predicate(op: hir::BinOpKind) -> RealPredicate {\n         hir::BinOpKind::Gt => RealPredicate::RealOGT,\n         hir::BinOpKind::Ge => RealPredicate::RealOGE,\n         op => {\n-            bug!(\"comparison_op_to_fcmp_predicate: expected comparison operator, \\\n+            bug!(\n+                \"comparison_op_to_fcmp_predicate: expected comparison operator, \\\n                   found {:?}\",\n-                 op);\n+                op\n+            );\n         }\n     }\n }\n@@ -97,7 +121,7 @@ pub fn compare_simd_types<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             let cmp = bin_op_to_fcmp_predicate(op);\n             let cmp = bx.fcmp(cmp, lhs, rhs);\n             return bx.sext(cmp, ret_ty);\n-        },\n+        }\n         ty::Uint(_) => false,\n         ty::Int(_) => true,\n         _ => bug!(\"compare_simd_types: invalid SIMD type\"),\n@@ -136,17 +160,13 @@ pub fn unsized_info<'tcx, Cx: CodegenMethods<'tcx>>(\n             old_info.expect(\"unsized_info: missing old info for trait upcast\")\n         }\n         (_, &ty::Dynamic(ref data, ..)) => {\n-            let vtable_ptr = cx.layout_of(cx.tcx().mk_mut_ptr(target))\n-                .field(cx, FAT_PTR_EXTRA);\n+            let vtable_ptr = cx.layout_of(cx.tcx().mk_mut_ptr(target)).field(cx, FAT_PTR_EXTRA);\n             cx.const_ptrcast(\n                 meth::get_vtable(cx, source, data.principal()),\n                 cx.backend_type(vtable_ptr),\n             )\n         }\n-        _ => bug!(\n-            \"unsized_info: invalid unsizing {:?} -> {:?}\",\n-            source, target\n-        ),\n+        _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\", source, target),\n     }\n }\n \n@@ -159,12 +179,9 @@ pub fn unsize_thin_ptr<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n ) -> (Bx::Value, Bx::Value) {\n     debug!(\"unsize_thin_ptr: {:?} => {:?}\", src_ty, dst_ty);\n     match (&src_ty.kind, &dst_ty.kind) {\n-        (&ty::Ref(_, a, _),\n-         &ty::Ref(_, b, _)) |\n-        (&ty::Ref(_, a, _),\n-         &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) |\n-        (&ty::RawPtr(ty::TypeAndMut { ty: a, .. }),\n-         &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) => {\n+        (&ty::Ref(_, a, _), &ty::Ref(_, b, _))\n+        | (&ty::Ref(_, a, _), &ty::RawPtr(ty::TypeAndMut { ty: b, .. }))\n+        | (&ty::RawPtr(ty::TypeAndMut { ty: a, .. }), &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) => {\n             assert!(bx.cx().type_is_sized(a));\n             let ptr_ty = bx.cx().type_ptr_to(bx.cx().backend_type(bx.cx().layout_of(b)));\n             (bx.pointercast(src, ptr_ty), unsized_info(bx.cx(), a, b, None))\n@@ -193,8 +210,10 @@ pub fn unsize_thin_ptr<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n             // FIXME(eddyb) move these out of this `match` arm, so they're always\n             // applied, uniformly, no matter the source/destination types.\n-            (bx.bitcast(lldata, bx.cx().scalar_pair_element_backend_type(dst_layout, 0, true)),\n-             bx.bitcast(llextra, bx.cx().scalar_pair_element_backend_type(dst_layout, 1, true)))\n+            (\n+                bx.bitcast(lldata, bx.cx().scalar_pair_element_backend_type(dst_layout, 0, true)),\n+                bx.bitcast(llextra, bx.cx().scalar_pair_element_backend_type(dst_layout, 1, true)),\n+            )\n         }\n         _ => bug!(\"unsize_thin_ptr: called on bad types\"),\n     }\n@@ -210,9 +229,9 @@ pub fn coerce_unsized_into<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     let src_ty = src.layout.ty;\n     let dst_ty = dst.layout.ty;\n     match (&src_ty.kind, &dst_ty.kind) {\n-        (&ty::Ref(..), &ty::Ref(..)) |\n-        (&ty::Ref(..), &ty::RawPtr(..)) |\n-        (&ty::RawPtr(..), &ty::RawPtr(..)) => {\n+        (&ty::Ref(..), &ty::Ref(..))\n+        | (&ty::Ref(..), &ty::RawPtr(..))\n+        | (&ty::RawPtr(..), &ty::RawPtr(..)) => {\n             let (base, info) = match bx.load_operand(src).val {\n                 OperandValue::Pair(base, info) => {\n                     // fat-ptr to fat-ptr unsize preserves the vtable\n@@ -224,10 +243,8 @@ pub fn coerce_unsized_into<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                     let thin_ptr = dst.layout.field(bx.cx(), FAT_PTR_ADDR);\n                     (bx.pointercast(base, bx.cx().backend_type(thin_ptr)), info)\n                 }\n-                OperandValue::Immediate(base) => {\n-                    unsize_thin_ptr(bx, base, src_ty, dst_ty)\n-                }\n-                OperandValue::Ref(..) => bug!()\n+                OperandValue::Immediate(base) => unsize_thin_ptr(bx, base, src_ty, dst_ty),\n+                OperandValue::Ref(..) => bug!(),\n             };\n             OperandValue::Pair(base, info).store(bx, dst);\n         }\n@@ -244,18 +261,21 @@ pub fn coerce_unsized_into<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 }\n \n                 if src_f.layout.ty == dst_f.layout.ty {\n-                    memcpy_ty(bx, dst_f.llval, dst_f.align, src_f.llval, src_f.align,\n-                        src_f.layout, MemFlags::empty());\n+                    memcpy_ty(\n+                        bx,\n+                        dst_f.llval,\n+                        dst_f.align,\n+                        src_f.llval,\n+                        src_f.align,\n+                        src_f.layout,\n+                        MemFlags::empty(),\n+                    );\n                 } else {\n                     coerce_unsized_into(bx, src_f, dst_f);\n                 }\n             }\n         }\n-        _ => bug!(\n-            \"coerce_unsized_into: invalid coercion {:?} -> {:?}\",\n-            src_ty,\n-            dst_ty,\n-        ),\n+        _ => bug!(\"coerce_unsized_into: invalid coercion {:?} -> {:?}\", src_ty, dst_ty,),\n     }\n }\n \n@@ -313,11 +333,7 @@ pub fn from_immediate<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n     val: Bx::Value,\n ) -> Bx::Value {\n-    if bx.cx().val_ty(val) == bx.cx().type_i1() {\n-        bx.zext(val, bx.cx().type_i8())\n-    } else {\n-        val\n-    }\n+    if bx.cx().val_ty(val) == bx.cx().type_i1() { bx.zext(val, bx.cx().type_i8()) } else { val }\n }\n \n pub fn to_immediate<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n@@ -375,7 +391,7 @@ pub fn codegen_instance<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n /// users main function.\n pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(cx: &'a Bx::CodegenCx) {\n     let (main_def_id, span) = match cx.tcx().entry_fn(LOCAL_CRATE) {\n-        Some((def_id, _)) => { (def_id, cx.tcx().def_span(def_id)) },\n+        Some((def_id, _)) => (def_id, cx.tcx().def_span(def_id)),\n         None => return,\n     };\n \n@@ -393,7 +409,7 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(cx: &'\n     match et {\n         Some(EntryFnType::Main) => create_entry_fn::<Bx>(cx, span, main_llfn, main_def_id, true),\n         Some(EntryFnType::Start) => create_entry_fn::<Bx>(cx, span, main_llfn, main_def_id, false),\n-        None => {}    // Do nothing.\n+        None => {} // Do nothing.\n     }\n \n     fn create_entry_fn<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n@@ -417,15 +433,14 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(cx: &'\n         // late-bound regions, since late-bound\n         // regions must appear in the argument\n         // listing.\n-        let main_ret_ty = cx.tcx().erase_regions(\n-            &main_ret_ty.no_bound_vars().unwrap(),\n-        );\n+        let main_ret_ty = cx.tcx().erase_regions(&main_ret_ty.no_bound_vars().unwrap());\n \n         if cx.get_defined_value(\"main\").is_some() {\n             // FIXME: We should be smart and show a better diagnostic here.\n-            cx.sess().struct_span_err(sp, \"entry symbol `main` defined multiple times\")\n-                     .help(\"did you use `#[no_mangle]` on `fn main`? Use `#[start]` instead\")\n-                     .emit();\n+            cx.sess()\n+                .struct_span_err(sp, \"entry symbol `main` defined multiple times\")\n+                .help(\"did you use `#[no_mangle]` on `fn main`? Use `#[start]` instead\")\n+                .emit();\n             cx.sess().abort_if_errors();\n             bug!();\n         }\n@@ -449,10 +464,13 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(cx: &'\n                     ty::ParamEnv::reveal_all(),\n                     start_def_id,\n                     cx.tcx().intern_substs(&[main_ret_ty.into()]),\n-                ).unwrap()\n+                )\n+                .unwrap(),\n             );\n-            (start_fn, vec![bx.pointercast(rust_main, cx.type_ptr_to(cx.type_i8p())),\n-                            arg_argc, arg_argv])\n+            (\n+                start_fn,\n+                vec![bx.pointercast(rust_main, cx.type_ptr_to(cx.type_i8p())), arg_argc, arg_argv],\n+            )\n         } else {\n             debug!(\"using user-defined start fn\");\n             (rust_main, vec![arg_argc, arg_argv])\n@@ -467,9 +485,8 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(cx: &'\n /// Obtain the `argc` and `argv` values to pass to the rust start function.\n fn get_argc_argv<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     cx: &'a Bx::CodegenCx,\n-    bx: &mut Bx\n-) -> (Bx::Value, Bx::Value)\n-{\n+    bx: &mut Bx,\n+) -> (Bx::Value, Bx::Value) {\n     if cx.sess().target.target.options.main_needs_argc_argv {\n         // Params from native `main()` used as args for rust start function\n         let param_argc = bx.get_param(0);\n@@ -496,8 +513,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     check_for_rustc_errors_attr(tcx);\n \n     // Skip crate items and just output metadata in -Z no-codegen mode.\n-    if tcx.sess.opts.debugging_opts.no_codegen ||\n-       !tcx.sess.opts.output_types.should_codegen() {\n+    if tcx.sess.opts.debugging_opts.no_codegen || !tcx.sess.opts.output_types.should_codegen() {\n         let ongoing_codegen = start_async_codegen(backend, tcx, metadata, 1);\n \n         ongoing_codegen.codegen_finished(tcx);\n@@ -538,28 +554,21 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     // linkage, then it's already got an allocator shim and we'll be using that\n     // one instead. If nothing exists then it's our job to generate the\n     // allocator!\n-    let any_dynamic_crate = tcx.dependency_formats(LOCAL_CRATE)\n-        .iter()\n-        .any(|(_, list)| {\n-            use rustc::middle::dependency_format::Linkage;\n-            list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n-        });\n+    let any_dynamic_crate = tcx.dependency_formats(LOCAL_CRATE).iter().any(|(_, list)| {\n+        use rustc::middle::dependency_format::Linkage;\n+        list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n+    });\n     let allocator_module = if any_dynamic_crate {\n         None\n     } else if let Some(kind) = tcx.allocator_kind() {\n-        let llmod_id = cgu_name_builder.build_cgu_name(LOCAL_CRATE,\n-                                                       &[\"crate\"],\n-                                                       Some(\"allocator\")).to_string();\n+        let llmod_id =\n+            cgu_name_builder.build_cgu_name(LOCAL_CRATE, &[\"crate\"], Some(\"allocator\")).to_string();\n         let mut modules = backend.new_metadata(tcx, &llmod_id);\n         time(tcx.sess, \"write allocator module\", || {\n             backend.codegen_allocator(tcx, &mut modules, kind)\n         });\n \n-        Some(ModuleCodegen {\n-            name: llmod_id,\n-            module_llvm: modules,\n-            kind: ModuleKind::Allocator,\n-        })\n+        Some(ModuleCodegen { name: llmod_id, module_llvm: modules, kind: ModuleKind::Allocator })\n     } else {\n         None\n     };\n@@ -570,13 +579,15 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n \n     if need_metadata_module {\n         // Codegen the encoded metadata.\n-        let metadata_cgu_name = cgu_name_builder.build_cgu_name(LOCAL_CRATE,\n-                                                                &[\"crate\"],\n-                                                                Some(\"metadata\")).to_string();\n+        let metadata_cgu_name =\n+            cgu_name_builder.build_cgu_name(LOCAL_CRATE, &[\"crate\"], Some(\"metadata\")).to_string();\n         let mut metadata_llvm_module = backend.new_metadata(tcx, &metadata_cgu_name);\n         time(tcx.sess, \"write compressed metadata\", || {\n-            backend.write_compressed_metadata(tcx, &ongoing_codegen.metadata,\n-                                              &mut metadata_llvm_module);\n+            backend.write_compressed_metadata(\n+                tcx,\n+                &ongoing_codegen.metadata,\n+                &mut metadata_llvm_module,\n+            );\n         });\n \n         let metadata_module = ModuleCodegen {\n@@ -612,19 +623,26 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n                 false\n             }\n             CguReuse::PreLto => {\n-                submit_pre_lto_module_to_llvm(&backend, tcx, &ongoing_codegen.coordinator_send,\n-                CachedModuleCodegen {\n-                    name: cgu.name().to_string(),\n-                    source: cgu.work_product(tcx),\n-                });\n+                submit_pre_lto_module_to_llvm(\n+                    &backend,\n+                    tcx,\n+                    &ongoing_codegen.coordinator_send,\n+                    CachedModuleCodegen {\n+                        name: cgu.name().to_string(),\n+                        source: cgu.work_product(tcx),\n+                    },\n+                );\n                 true\n             }\n             CguReuse::PostLto => {\n-                submit_post_lto_module_to_llvm(&backend, &ongoing_codegen.coordinator_send,\n-                CachedModuleCodegen {\n-                    name: cgu.name().to_string(),\n-                    source: cgu.work_product(tcx),\n-                });\n+                submit_post_lto_module_to_llvm(\n+                    &backend,\n+                    &ongoing_codegen.coordinator_send,\n+                    CachedModuleCodegen {\n+                        name: cgu.name().to_string(),\n+                        source: cgu.work_product(tcx),\n+                    },\n+                );\n                 true\n             }\n         };\n@@ -636,9 +654,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     // -Ztime-passes output manually.\n     let time_depth = time_depth();\n     set_time_depth(time_depth + 1);\n-    print_time_passes_entry(tcx.sess.time_passes(),\n-                            \"codegen to LLVM IR\",\n-                            total_codegen_time);\n+    print_time_passes_entry(tcx.sess.time_passes(), \"codegen to LLVM IR\", total_codegen_time);\n     set_time_depth(time_depth);\n \n     ::rustc_incremental::assert_module_sources::assert_module_sources(tcx);\n@@ -699,13 +715,9 @@ impl<B: ExtraBackendMethods> Drop for AbortCodegenOnDrop<B> {\n }\n \n fn assert_and_save_dep_graph(tcx: TyCtxt<'_>) {\n-    time(tcx.sess,\n-         \"assert dep graph\",\n-         || ::rustc_incremental::assert_dep_graph(tcx));\n+    time(tcx.sess, \"assert dep graph\", || ::rustc_incremental::assert_dep_graph(tcx));\n \n-    time(tcx.sess,\n-         \"serialize dep graph\",\n-         || ::rustc_incremental::save_dep_graph(tcx));\n+    time(tcx.sess, \"serialize dep graph\", || ::rustc_incremental::save_dep_graph(tcx));\n }\n \n impl CrateInfo {\n@@ -765,7 +777,8 @@ impl CrateInfo {\n \n             // No need to look for lang items that are whitelisted and don't\n             // actually need to exist.\n-            let missing = missing.iter()\n+            let missing = missing\n+                .iter()\n                 .cloned()\n                 .filter(|&l| !weak_lang_items::whitelisted(tcx, l))\n                 .collect();\n@@ -812,15 +825,15 @@ pub fn provide_both(providers: &mut Providers<'_>) {\n \n     providers.dllimport_foreign_items = |tcx, krate| {\n         let module_map = tcx.foreign_modules(krate);\n-        let module_map = module_map.iter()\n-            .map(|lib| (lib.def_id, lib))\n-            .collect::<FxHashMap<_, _>>();\n+        let module_map =\n+            module_map.iter().map(|lib| (lib.def_id, lib)).collect::<FxHashMap<_, _>>();\n \n-        let dllimports = tcx.native_libraries(krate)\n+        let dllimports = tcx\n+            .native_libraries(krate)\n             .iter()\n             .filter(|lib| {\n                 if lib.kind != cstore::NativeLibraryKind::NativeUnknown {\n-                    return false\n+                    return false;\n                 }\n                 let cfg = match lib.cfg {\n                     Some(ref cfg) => cfg,\n@@ -835,21 +848,20 @@ pub fn provide_both(providers: &mut Providers<'_>) {\n         tcx.arena.alloc(dllimports)\n     };\n \n-    providers.is_dllimport_foreign_item = |tcx, def_id| {\n-        tcx.dllimport_foreign_items(def_id.krate).contains(&def_id)\n-    };\n+    providers.is_dllimport_foreign_item =\n+        |tcx, def_id| tcx.dllimport_foreign_items(def_id.krate).contains(&def_id);\n }\n \n fn determine_cgu_reuse<'tcx>(tcx: TyCtxt<'tcx>, cgu: &CodegenUnit<'tcx>) -> CguReuse {\n     if !tcx.dep_graph.is_fully_enabled() {\n-        return CguReuse::No\n+        return CguReuse::No;\n     }\n \n     let work_product_id = &cgu.work_product_id();\n     if tcx.dep_graph.previous_work_product(work_product_id).is_none() {\n         // We don't have anything cached for this CGU. This can happen\n         // if the CGU did not exist in the previous session.\n-        return CguReuse::No\n+        return CguReuse::No;\n     }\n \n     // Try to mark the CGU as green. If it we can do so, it means that nothing\n@@ -859,17 +871,15 @@ fn determine_cgu_reuse<'tcx>(tcx: TyCtxt<'tcx>, cgu: &CodegenUnit<'tcx>) -> CguR\n     // know that later). If we are not doing LTO, there is only one optimized\n     // version of each module, so we re-use that.\n     let dep_node = cgu.codegen_dep_node(tcx);\n-    assert!(!tcx.dep_graph.dep_node_exists(&dep_node),\n+    assert!(\n+        !tcx.dep_graph.dep_node_exists(&dep_node),\n         \"CompileCodegenUnit dep-node for CGU `{}` already exists before marking.\",\n-        cgu.name());\n+        cgu.name()\n+    );\n \n     if tcx.dep_graph.try_mark_green(tcx, &dep_node).is_some() {\n         // We can re-use either the pre- or the post-thinlto state\n-        if tcx.sess.lto() != Lto::No {\n-            CguReuse::PreLto\n-        } else {\n-            CguReuse::PostLto\n-        }\n+        if tcx.sess.lto() != Lto::No { CguReuse::PreLto } else { CguReuse::PostLto }\n     } else {\n         CguReuse::No\n     }"}, {"sha": "7399db1f2b950661d5ed8c09ded2cac0bfb5e2c3", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 85, "deletions": 124, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d", "patch": "@@ -1,15 +1,15 @@\n-use super::{FunctionCx, LocalRef};\n use super::operand::OperandValue;\n+use super::{FunctionCx, LocalRef};\n \n-use crate::MemFlags;\n use crate::common::IntPredicate;\n use crate::glue;\n use crate::traits::*;\n+use crate::MemFlags;\n \n-use rustc::ty::{self, Instance, Ty};\n-use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, VariantIdx, HasTyCtxt};\n use rustc::mir;\n use rustc::mir::tcx::PlaceTy;\n+use rustc::ty::layout::{self, Align, HasTyCtxt, LayoutOf, TyLayout, VariantIdx};\n+use rustc::ty::{self, Instance, Ty};\n \n #[derive(Copy, Clone, Debug)]\n pub struct PlaceRef<'tcx, V> {\n@@ -27,31 +27,14 @@ pub struct PlaceRef<'tcx, V> {\n }\n \n impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n-    pub fn new_sized(\n-        llval: V,\n-        layout: TyLayout<'tcx>,\n-    ) -> PlaceRef<'tcx, V> {\n+    pub fn new_sized(llval: V, layout: TyLayout<'tcx>) -> PlaceRef<'tcx, V> {\n         assert!(!layout.is_unsized());\n-        PlaceRef {\n-            llval,\n-            llextra: None,\n-            layout,\n-            align: layout.align.abi\n-        }\n+        PlaceRef { llval, llextra: None, layout, align: layout.align.abi }\n     }\n \n-    pub fn new_sized_aligned(\n-        llval: V,\n-        layout: TyLayout<'tcx>,\n-        align: Align,\n-    ) -> PlaceRef<'tcx, V> {\n+    pub fn new_sized_aligned(llval: V, layout: TyLayout<'tcx>, align: Align) -> PlaceRef<'tcx, V> {\n         assert!(!layout.is_unsized());\n-        PlaceRef {\n-            llval,\n-            llextra: None,\n-            layout,\n-            align\n-        }\n+        PlaceRef { llval, llextra: None, layout, align }\n     }\n \n     fn new_thin_place<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n@@ -60,12 +43,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         layout: TyLayout<'tcx>,\n     ) -> PlaceRef<'tcx, V> {\n         assert!(!bx.cx().type_has_metadata(layout.ty));\n-        PlaceRef {\n-            llval,\n-            llextra: None,\n-            layout,\n-            align: layout.align.abi\n-        }\n+        PlaceRef { llval, llextra: None, layout, align: layout.align.abi }\n     }\n \n     // FIXME(eddyb) pass something else for the name so no work is done\n@@ -92,10 +70,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         Self::alloca(bx, ptr_layout)\n     }\n \n-    pub fn len<Cx: ConstMethods<'tcx, Value = V>>(\n-        &self,\n-        cx: &Cx\n-    ) -> V {\n+    pub fn len<Cx: ConstMethods<'tcx, Value = V>>(&self, cx: &Cx) -> V {\n         if let layout::FieldPlacement::Array { count, .. } = self.layout.fields {\n             if self.layout.is_unsized() {\n                 assert_eq!(count, 0);\n@@ -112,7 +87,8 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n     /// Access a field, at a point when the value's case is known.\n     pub fn project_field<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n-        self, bx: &mut Bx,\n+        self,\n+        bx: &mut Bx,\n         ix: usize,\n     ) -> Self {\n         let field = self.layout.field(bx.cx(), ix);\n@@ -133,11 +109,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n             PlaceRef {\n                 // HACK(eddyb): have to bitcast pointers until LLVM removes pointee types.\n                 llval: bx.pointercast(llval, bx.cx().type_ptr_to(bx.cx().backend_type(field))),\n-                llextra: if bx.cx().type_has_metadata(field.ty) {\n-                    self.llextra\n-                } else {\n-                    None\n-                },\n+                llextra: if bx.cx().type_has_metadata(field.ty) { self.llextra } else { None },\n                 layout: field,\n                 align: effective_field_align,\n             }\n@@ -149,8 +121,10 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         //   * packed struct - there is no alignment padding\n         match field.ty.kind {\n             _ if self.llextra.is_none() => {\n-                debug!(\"unsized field `{}`, of `{:?}` has no metadata for adjustment\",\n-                    ix, self.llval);\n+                debug!(\n+                    \"unsized field `{}`, of `{:?}` has no metadata for adjustment\",\n+                    ix, self.llval\n+                );\n                 return simple();\n             }\n             _ if !field.is_unsized() => return simple(),\n@@ -222,15 +196,18 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n     pub fn codegen_get_discr<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         self,\n         bx: &mut Bx,\n-        cast_to: Ty<'tcx>\n+        cast_to: Ty<'tcx>,\n     ) -> V {\n         let cast_to = bx.cx().immediate_backend_type(bx.cx().layout_of(cast_to));\n         if self.layout.abi.is_uninhabited() {\n             return bx.cx().const_undef(cast_to);\n         }\n         let (discr_scalar, discr_kind, discr_index) = match self.layout.variants {\n             layout::Variants::Single { index } => {\n-                let discr_val = self.layout.ty.discriminant_for_variant(bx.cx().tcx(), index)\n+                let discr_val = self\n+                    .layout\n+                    .ty\n+                    .discriminant_for_variant(bx.cx().tcx(), index)\n                     .map_or(index.as_u32() as u128, |discr| discr.val);\n                 return bx.cx().const_uint_big(cast_to, discr_val);\n             }\n@@ -252,7 +229,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                     // let LLVM interpret the `i1` as signed, because\n                     // then `i1 1` (i.e., `E::B`) is effectively `i8 -1`.\n                     layout::Int(_, signed) => !discr_scalar.is_bool() && signed,\n-                    _ => false\n+                    _ => false,\n                 };\n                 bx.intcast(encoded_discr.immediate(), cast_to, signed)\n             }\n@@ -330,7 +307,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n     pub fn codegen_set_discr<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         &self,\n         bx: &mut Bx,\n-        variant_index: VariantIdx\n+        variant_index: VariantIdx,\n     ) {\n         if self.layout.for_variant(bx.cx(), variant_index).abi.is_uninhabited() {\n             // We play it safe by using a well-defined `abort`, but we could go for immediate UB\n@@ -353,20 +330,19 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                 bx.store(\n                     bx.cx().const_uint_big(bx.cx().backend_type(ptr.layout), to),\n                     ptr.llval,\n-                    ptr.align);\n+                    ptr.align,\n+                );\n             }\n             layout::Variants::Multiple {\n-                discr_kind: layout::DiscriminantKind::Niche {\n-                    dataful_variant,\n-                    ref niche_variants,\n-                    niche_start,\n-                },\n+                discr_kind:\n+                    layout::DiscriminantKind::Niche { dataful_variant, ref niche_variants, niche_start },\n                 discr_index,\n                 ..\n             } => {\n                 if variant_index != dataful_variant {\n-                    if bx.cx().sess().target.target.arch == \"arm\" ||\n-                       bx.cx().sess().target.target.arch == \"aarch64\" {\n+                    if bx.cx().sess().target.target.arch == \"arm\"\n+                        || bx.cx().sess().target.target.arch == \"aarch64\"\n+                    {\n                         // FIXME(#34427): as workaround for LLVM bug on ARM,\n                         // use memset of 0 before assigning niche value.\n                         let fill_byte = bx.cx().const_u8(0);\n@@ -377,8 +353,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                     let niche = self.project_field(bx, discr_index);\n                     let niche_llty = bx.cx().immediate_backend_type(niche.layout);\n                     let niche_value = variant_index.as_u32() - niche_variants.start().as_u32();\n-                    let niche_value = (niche_value as u128)\n-                        .wrapping_add(niche_start);\n+                    let niche_value = (niche_value as u128).wrapping_add(niche_start);\n                     // FIXME(eddyb): check the actual primitive type here.\n                     let niche_llval = if niche_value == 0 {\n                         // HACK(eddyb): using `c_null` as it works on all types.\n@@ -395,7 +370,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n     pub fn project_index<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         &self,\n         bx: &mut Bx,\n-        llindex: V\n+        llindex: V,\n     ) -> Self {\n         // Statically compute the offset if we can, otherwise just use the element size,\n         // as this will yield the lowest alignment.\n@@ -417,7 +392,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n     pub fn project_downcast<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         &self,\n         bx: &mut Bx,\n-        variant_index: VariantIdx\n+        variant_index: VariantIdx,\n     ) -> Self {\n         let mut downcast = *self;\n         downcast.layout = self.layout.for_variant(bx.cx(), variant_index);\n@@ -442,17 +417,14 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn codegen_place(\n         &mut self,\n         bx: &mut Bx,\n-        place_ref: &mir::PlaceRef<'_, 'tcx>\n+        place_ref: &mir::PlaceRef<'_, 'tcx>,\n     ) -> PlaceRef<'tcx, Bx::Value> {\n         debug!(\"codegen_place(place_ref={:?})\", place_ref);\n         let cx = self.cx;\n         let tcx = self.cx.tcx();\n \n         let result = match place_ref {\n-            mir::PlaceRef {\n-                base: mir::PlaceBase::Local(index),\n-                projection: [],\n-            } => {\n+            mir::PlaceRef { base: mir::PlaceBase::Local(index), projection: [] } => {\n                 match self.locals[*index] {\n                     LocalRef::Place(place) => {\n                         return place;\n@@ -466,22 +438,22 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 }\n             }\n             mir::PlaceRef {\n-                base: mir::PlaceBase::Static(box mir::Static {\n-                    ty,\n-                    kind: mir::StaticKind::Promoted(promoted, substs),\n-                    def_id,\n-                }),\n+                base:\n+                    mir::PlaceBase::Static(box mir::Static {\n+                        ty,\n+                        kind: mir::StaticKind::Promoted(promoted, substs),\n+                        def_id,\n+                    }),\n                 projection: [],\n             } => {\n                 let instance = Instance::new(*def_id, self.monomorphize(substs));\n                 let layout = cx.layout_of(self.monomorphize(&ty));\n                 match bx.tcx().const_eval_promoted(instance, *promoted) {\n                     Ok(val) => match val.val {\n                         ty::ConstKind::Value(mir::interpret::ConstValue::ByRef {\n-                            alloc, offset\n-                        }) => {\n-                            bx.cx().from_const_alloc(layout, alloc, offset)\n-                        }\n+                            alloc,\n+                            offset,\n+                        }) => bx.cx().from_const_alloc(layout, alloc, offset),\n                         _ => bug!(\"promoteds should have an allocation: {:?}\", val),\n                     },\n                     Err(_) => {\n@@ -492,97 +464,91 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         bx.abort();\n                         // We still have to return a place but it doesn't matter,\n                         // this code is unreachable.\n-                        let llval = bx.cx().const_undef(\n-                            bx.cx().type_ptr_to(bx.cx().backend_type(layout))\n-                        );\n+                        let llval =\n+                            bx.cx().const_undef(bx.cx().type_ptr_to(bx.cx().backend_type(layout)));\n                         PlaceRef::new_sized(llval, layout)\n                     }\n                 }\n             }\n             mir::PlaceRef {\n-                base: mir::PlaceBase::Static(box mir::Static {\n-                    ty,\n-                    kind: mir::StaticKind::Static,\n-                    def_id,\n-                }),\n+                base:\n+                    mir::PlaceBase::Static(box mir::Static {\n+                        ty,\n+                        kind: mir::StaticKind::Static,\n+                        def_id,\n+                    }),\n                 projection: [],\n             } => {\n                 // NB: The layout of a static may be unsized as is the case when working\n                 // with a static that is an extern_type.\n                 let layout = cx.layout_of(self.monomorphize(&ty));\n                 let static_ = bx.get_static(*def_id);\n                 PlaceRef::new_thin_place(bx, static_, layout)\n-            },\n-            mir::PlaceRef {\n-                base,\n-                projection: [proj_base @ .., mir::ProjectionElem::Deref],\n-            } => {\n+            }\n+            mir::PlaceRef { base, projection: [proj_base @ .., mir::ProjectionElem::Deref] } => {\n                 // Load the pointer from its location.\n-                self.codegen_consume(bx, &mir::PlaceRef {\n-                    base,\n-                    projection: proj_base,\n-                }).deref(bx.cx())\n+                self.codegen_consume(bx, &mir::PlaceRef { base, projection: proj_base })\n+                    .deref(bx.cx())\n             }\n-            mir::PlaceRef {\n-                base,\n-                projection: [proj_base @ .., elem],\n-            } => {\n+            mir::PlaceRef { base, projection: [proj_base @ .., elem] } => {\n                 // FIXME turn this recursion into iteration\n-                let cg_base = self.codegen_place(bx, &mir::PlaceRef {\n-                    base,\n-                    projection: proj_base,\n-                });\n+                let cg_base =\n+                    self.codegen_place(bx, &mir::PlaceRef { base, projection: proj_base });\n \n                 match elem {\n                     mir::ProjectionElem::Deref => bug!(),\n                     mir::ProjectionElem::Field(ref field, _) => {\n                         cg_base.project_field(bx, field.index())\n                     }\n                     mir::ProjectionElem::Index(index) => {\n-                        let index = &mir::Operand::Copy(\n-                            mir::Place::from(*index)\n-                        );\n+                        let index = &mir::Operand::Copy(mir::Place::from(*index));\n                         let index = self.codegen_operand(bx, index);\n                         let llindex = index.immediate();\n                         cg_base.project_index(bx, llindex)\n                     }\n-                    mir::ProjectionElem::ConstantIndex { offset,\n-                                                         from_end: false,\n-                                                         min_length: _ } => {\n+                    mir::ProjectionElem::ConstantIndex {\n+                        offset,\n+                        from_end: false,\n+                        min_length: _,\n+                    } => {\n                         let lloffset = bx.cx().const_usize(*offset as u64);\n                         cg_base.project_index(bx, lloffset)\n                     }\n-                    mir::ProjectionElem::ConstantIndex { offset,\n-                                                         from_end: true,\n-                                                         min_length: _ } => {\n+                    mir::ProjectionElem::ConstantIndex {\n+                        offset,\n+                        from_end: true,\n+                        min_length: _,\n+                    } => {\n                         let lloffset = bx.cx().const_usize(*offset as u64);\n                         let lllen = cg_base.len(bx.cx());\n                         let llindex = bx.sub(lllen, lloffset);\n                         cg_base.project_index(bx, llindex)\n                     }\n                     mir::ProjectionElem::Subslice { from, to, from_end } => {\n-                        let mut subslice = cg_base.project_index(bx,\n-                            bx.cx().const_usize(*from as u64));\n-                        let projected_ty = PlaceTy::from_ty(cg_base.layout.ty)\n-                            .projection_ty(tcx, elem).ty;\n+                        let mut subslice =\n+                            cg_base.project_index(bx, bx.cx().const_usize(*from as u64));\n+                        let projected_ty =\n+                            PlaceTy::from_ty(cg_base.layout.ty).projection_ty(tcx, elem).ty;\n                         subslice.layout = bx.cx().layout_of(self.monomorphize(&projected_ty));\n \n                         if subslice.layout.is_unsized() {\n                             assert!(from_end, \"slice subslices should be `from_end`\");\n-                            subslice.llextra = Some(bx.sub(cg_base.llextra.unwrap(),\n-                                bx.cx().const_usize((*from as u64) + (*to as u64))));\n+                            subslice.llextra = Some(bx.sub(\n+                                cg_base.llextra.unwrap(),\n+                                bx.cx().const_usize((*from as u64) + (*to as u64)),\n+                            ));\n                         }\n \n                         // Cast the place pointer type to the new\n                         // array or slice type (`*[%_; new_len]`).\n-                        subslice.llval = bx.pointercast(subslice.llval,\n-                            bx.cx().type_ptr_to(bx.cx().backend_type(subslice.layout)));\n+                        subslice.llval = bx.pointercast(\n+                            subslice.llval,\n+                            bx.cx().type_ptr_to(bx.cx().backend_type(subslice.layout)),\n+                        );\n \n                         subslice\n                     }\n-                    mir::ProjectionElem::Downcast(_, v) => {\n-                        cg_base.project_downcast(bx, *v)\n-                    }\n+                    mir::ProjectionElem::Downcast(_, v) => cg_base.project_downcast(bx, *v),\n                 }\n             }\n         };\n@@ -592,12 +558,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n     pub fn monomorphized_place_ty(&self, place_ref: &mir::PlaceRef<'_, 'tcx>) -> Ty<'tcx> {\n         let tcx = self.cx.tcx();\n-        let place_ty = mir::Place::ty_from(\n-            place_ref.base,\n-            place_ref.projection,\n-            *self.mir,\n-            tcx,\n-        );\n+        let place_ty = mir::Place::ty_from(place_ref.base, place_ref.projection, *self.mir, tcx);\n         self.monomorphize(&place_ty.ty)\n     }\n }"}, {"sha": "045d06a2e1de09a848793ce543c5dcf14f016caf", "filename": "src/librustc_codegen_utils/symbol_names/v0.rs", "status": "modified", "additions": 52, "deletions": 74, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d", "patch": "@@ -1,13 +1,13 @@\n use rustc::hir;\n use rustc::hir::def_id::{CrateNum, DefId};\n use rustc::hir::map::{DefPathData, DisambiguatedDefPathData};\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable, Instance};\n-use rustc::ty::print::{Printer, Print};\n-use rustc::ty::subst::{GenericArg, Subst, GenericArgKind};\n+use rustc::ty::print::{Print, Printer};\n+use rustc::ty::subst::{GenericArg, GenericArgKind, Subst};\n+use rustc::ty::{self, Instance, Ty, TyCtxt, TypeFoldable};\n use rustc_data_structures::base_n;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_target::spec::abi::Abi;\n-use syntax::ast::{IntTy, UintTy, FloatTy};\n+use syntax::ast::{FloatTy, IntTy, UintTy};\n \n use std::fmt::Write;\n use std::ops::Range;\n@@ -19,8 +19,7 @@ pub(super) fn mangle(\n ) -> String {\n     let def_id = instance.def_id();\n     // FIXME(eddyb) this should ideally not be needed.\n-    let substs =\n-        tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), instance.substs);\n+    let substs = tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), instance.substs);\n \n     let prefix = \"_R\";\n     let mut cx = SymbolMangler {\n@@ -36,12 +35,7 @@ pub(super) fn mangle(\n         out: String::from(prefix),\n     };\n     cx = if instance.is_vtable_shim() {\n-        cx.path_append_ns(\n-            |cx| cx.print_def_path(def_id, substs),\n-            'S',\n-            0,\n-            \"\",\n-        ).unwrap()\n+        cx.path_append_ns(|cx| cx.print_def_path(def_id, substs), 'S', 0, \"\").unwrap()\n     } else {\n         cx.print_def_path(def_id, substs).unwrap()\n     };\n@@ -183,9 +177,10 @@ impl SymbolMangler<'tcx> {\n     fn in_binder<T>(\n         mut self,\n         value: &ty::Binder<T>,\n-        print_value: impl FnOnce(Self, &T) -> Result<Self, !>\n+        print_value: impl FnOnce(Self, &T) -> Result<Self, !>,\n     ) -> Result<Self, !>\n-        where T: TypeFoldable<'tcx>\n+    where\n+        T: TypeFoldable<'tcx>,\n     {\n         let regions = if value.has_late_bound_regions() {\n             self.tcx.collect_referenced_late_bound_regions(value)\n@@ -196,16 +191,20 @@ impl SymbolMangler<'tcx> {\n         let mut lifetime_depths =\n             self.binders.last().map(|b| b.lifetime_depths.end).map_or(0..0, |i| i..i);\n \n-        let lifetimes = regions.into_iter().map(|br| {\n-            match br {\n-                ty::BrAnon(i) => {\n-                    // FIXME(eddyb) for some reason, `anonymize_late_bound_regions` starts at `1`.\n-                    assert_ne!(i, 0);\n-                    i - 1\n-                },\n-                _ => bug!(\"symbol_names: non-anonymized region `{:?}` in `{:?}`\", br, value),\n-            }\n-        }).max().map_or(0, |max| max + 1);\n+        let lifetimes = regions\n+            .into_iter()\n+            .map(|br| {\n+                match br {\n+                    ty::BrAnon(i) => {\n+                        // FIXME(eddyb) for some reason, `anonymize_late_bound_regions` starts at `1`.\n+                        assert_ne!(i, 0);\n+                        i - 1\n+                    }\n+                    _ => bug!(\"symbol_names: non-anonymized region `{:?}` in `{:?}`\", br, value),\n+                }\n+            })\n+            .max()\n+            .map_or(0, |max| max + 1);\n \n         self.push_opt_integer_62(\"G\", lifetimes as u64);\n         lifetime_depths.end += lifetimes;\n@@ -263,17 +262,15 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n         let key = self.tcx.def_key(impl_def_id);\n         let parent_def_id = DefId { index: key.parent.unwrap(), ..impl_def_id };\n \n-        let mut param_env = self.tcx.param_env(impl_def_id)\n-            .with_reveal_all();\n+        let mut param_env = self.tcx.param_env(impl_def_id).with_reveal_all();\n         if !substs.is_empty() {\n             param_env = param_env.subst(self.tcx, substs);\n         }\n \n         match &mut impl_trait_ref {\n             Some(impl_trait_ref) => {\n                 assert_eq!(impl_trait_ref.self_ty(), self_ty);\n-                *impl_trait_ref =\n-                    self.tcx.normalize_erasing_regions(param_env, *impl_trait_ref);\n+                *impl_trait_ref = self.tcx.normalize_erasing_regions(param_env, *impl_trait_ref);\n                 self_ty = impl_trait_ref.self_ty();\n             }\n             None => {\n@@ -289,10 +286,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n         )\n     }\n \n-    fn print_region(\n-        mut self,\n-        region: ty::Region<'_>,\n-    ) -> Result<Self::Region, Self::Error> {\n+    fn print_region(mut self, region: ty::Region<'_>) -> Result<Self::Region, Self::Error> {\n         let i = match *region {\n             // Erased lifetimes use the index 0, for a\n             // shorter mangling of `L_`.\n@@ -318,10 +312,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n         Ok(self)\n     }\n \n-    fn print_type(\n-        mut self,\n-        ty: Ty<'tcx>,\n-    ) -> Result<Self::Type, Self::Error> {\n+    fn print_type(mut self, ty: Ty<'tcx>) -> Result<Self::Type, Self::Error> {\n         // Basic types, never cached (single-character).\n         let basic_type = match ty.kind {\n             ty::Bool => \"b\",\n@@ -345,8 +336,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n             ty::Never => \"z\",\n \n             // Placeholders (should be demangled as `_`).\n-            ty::Param(_) | ty::Bound(..) | ty::Placeholder(_) |\n-            ty::Infer(_) | ty::Error => \"p\",\n+            ty::Param(_) | ty::Bound(..) | ty::Placeholder(_) | ty::Infer(_) | ty::Error => \"p\",\n \n             _ => \"\",\n         };\n@@ -362,14 +352,15 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n \n         match ty.kind {\n             // Basic types, handled above.\n-            ty::Bool | ty::Char | ty::Str |\n-            ty::Int(_) | ty::Uint(_) | ty::Float(_) |\n-            ty::Never => unreachable!(),\n+            ty::Bool | ty::Char | ty::Str | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Never => {\n+                unreachable!()\n+            }\n             ty::Tuple(_) if ty.is_unit() => unreachable!(),\n \n             // Placeholders, also handled as part of basic types.\n-            ty::Param(_) | ty::Bound(..) | ty::Placeholder(_) |\n-            ty::Infer(_) | ty::Error => unreachable!(),\n+            ty::Param(_) | ty::Bound(..) | ty::Placeholder(_) | ty::Infer(_) | ty::Error => {\n+                unreachable!()\n+            }\n \n             ty::Ref(r, ty, mutbl) => {\n                 self.push(match mutbl {\n@@ -409,13 +400,13 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n             }\n \n             // Mangle all nominal types as paths.\n-            ty::Adt(&ty::AdtDef { did: def_id, .. }, substs) |\n-            ty::FnDef(def_id, substs) |\n-            ty::Opaque(def_id, substs) |\n-            ty::Projection(ty::ProjectionTy { item_def_id: def_id, substs }) |\n-            ty::UnnormalizedProjection(ty::ProjectionTy { item_def_id: def_id, substs }) |\n-            ty::Closure(def_id, substs) |\n-            ty::Generator(def_id, substs, _) => {\n+            ty::Adt(&ty::AdtDef { did: def_id, .. }, substs)\n+            | ty::FnDef(def_id, substs)\n+            | ty::Opaque(def_id, substs)\n+            | ty::Projection(ty::ProjectionTy { item_def_id: def_id, substs })\n+            | ty::UnnormalizedProjection(ty::ProjectionTy { item_def_id: def_id, substs })\n+            | ty::Closure(def_id, substs)\n+            | ty::Generator(def_id, substs, _) => {\n                 self = self.print_def_path(def_id, substs)?;\n             }\n             ty::Foreign(def_id) => {\n@@ -460,9 +451,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n                 self = r.print(self)?;\n             }\n \n-            ty::GeneratorWitness(_) => {\n-                bug!(\"symbol_names: unexpected `GeneratorWitness`\")\n-            }\n+            ty::GeneratorWitness(_) => bug!(\"symbol_names: unexpected `GeneratorWitness`\"),\n         }\n \n         // Only cache types that do not refer to an enclosing\n@@ -502,10 +491,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n         Ok(self)\n     }\n \n-    fn print_const(\n-        mut self,\n-        ct: &'tcx ty::Const<'tcx>,\n-    ) -> Result<Self::Const, Self::Error> {\n+    fn print_const(mut self, ct: &'tcx ty::Const<'tcx>) -> Result<Self::Const, Self::Error> {\n         if let Some(&i) = self.compress.as_ref().and_then(|c| c.consts.get(&ct)) {\n             return self.print_backref(i);\n         }\n@@ -514,8 +500,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n         match ct.ty.kind {\n             ty::Uint(_) => {}\n             _ => {\n-                bug!(\"symbol_names: unsupported constant of type `{}` ({:?})\",\n-                    ct.ty, ct);\n+                bug!(\"symbol_names: unsupported constant of type `{}` ({:?})\", ct.ty, ct);\n             }\n         }\n         self = ct.ty.print(self)?;\n@@ -539,10 +524,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n         Ok(self)\n     }\n \n-    fn path_crate(\n-        mut self,\n-        cnum: CrateNum,\n-    ) -> Result<Self::Path, Self::Error> {\n+    fn path_crate(mut self, cnum: CrateNum) -> Result<Self::Path, Self::Error> {\n         self.push(\"C\");\n         let fingerprint = self.tcx.crate_disambiguator(cnum).to_fingerprint();\n         self.push_disambiguator(fingerprint.to_smaller_hash());\n@@ -612,7 +594,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n             print_prefix,\n             ns,\n             disambiguated_data.disambiguator as u64,\n-            name.as_ref().map_or(\"\", |s| &s[..])\n+            name.as_ref().map_or(\"\", |s| &s[..]),\n         )\n     }\n     fn path_generic_args(\n@@ -621,17 +603,13 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n         args: &[GenericArg<'tcx>],\n     ) -> Result<Self::Path, Self::Error> {\n         // Don't print any regions if they're all erased.\n-        let print_regions = args.iter().any(|arg| {\n-            match arg.unpack() {\n-                GenericArgKind::Lifetime(r) => *r != ty::ReErased,\n-                _ => false,\n-            }\n+        let print_regions = args.iter().any(|arg| match arg.unpack() {\n+            GenericArgKind::Lifetime(r) => *r != ty::ReErased,\n+            _ => false,\n         });\n-        let args = args.iter().cloned().filter(|arg| {\n-            match arg.unpack() {\n-                GenericArgKind::Lifetime(_) => print_regions,\n-                _ => true,\n-            }\n+        let args = args.iter().cloned().filter(|arg| match arg.unpack() {\n+            GenericArgKind::Lifetime(_) => print_regions,\n+            _ => true,\n         });\n \n         if args.clone().next().is_none() {"}, {"sha": "fdac4390b2675d5640b0b5677d387a6a32a1a487", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 310, "deletions": 291, "changes": 601, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d", "patch": "@@ -9,26 +9,25 @@\n \n use Destination::*;\n \n-use syntax_pos::{SourceFile, Span, MultiSpan};\n use syntax_pos::source_map::SourceMap;\n+use syntax_pos::{MultiSpan, SourceFile, Span};\n \n+use crate::snippet::{Annotation, AnnotationType, Line, MultilineAnnotation, Style, StyledString};\n+use crate::styled_buffer::StyledBuffer;\n+use crate::Level::Error;\n use crate::{\n-    Level, CodeSuggestion, Diagnostic, SubDiagnostic, pluralize,\n-    SuggestionStyle, DiagnosticId,\n+    pluralize, CodeSuggestion, Diagnostic, DiagnosticId, Level, SubDiagnostic, SuggestionStyle,\n };\n-use crate::Level::Error;\n-use crate::snippet::{Annotation, AnnotationType, Line, MultilineAnnotation, StyledString, Style};\n-use crate::styled_buffer::StyledBuffer;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use std::borrow::Cow;\n-use std::io::prelude::*;\n+use std::cmp::{max, min, Reverse};\n use std::io;\n-use std::cmp::{min, max, Reverse};\n+use std::io::prelude::*;\n use std::path::Path;\n-use termcolor::{StandardStream, ColorChoice, ColorSpec, BufferWriter, Ansi};\n-use termcolor::{WriteColor, Color, Buffer};\n+use termcolor::{Ansi, BufferWriter, ColorChoice, ColorSpec, StandardStream};\n+use termcolor::{Buffer, Color, WriteColor};\n \n /// Describes the way the content of the `rendered` field of the json output is generated\n #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n@@ -57,8 +56,15 @@ impl HumanReadableErrorType {\n     ) -> EmitterWriter {\n         let (short, color_config) = self.unzip();\n         let color = color_config.suggests_using_colors();\n-        EmitterWriter::new(dst, source_map, short, teach, color, terminal_width,\n-            external_macro_backtrace)\n+        EmitterWriter::new(\n+            dst,\n+            source_map,\n+            short,\n+            teach,\n+            color,\n+            terminal_width,\n+            external_macro_backtrace,\n+        )\n     }\n }\n \n@@ -117,15 +123,14 @@ impl Margin {\n     }\n \n     fn was_cut_right(&self, line_len: usize) -> bool {\n-        let right = if self.computed_right == self.span_right ||\n-            self.computed_right == self.label_right\n-        {\n-            // Account for the \"...\" padding given above. Otherwise we end up with code lines that\n-            // do fit but end in \"...\" as if they were trimmed.\n-            self.computed_right - 6\n-        } else {\n-            self.computed_right\n-        };\n+        let right =\n+            if self.computed_right == self.span_right || self.computed_right == self.label_right {\n+                // Account for the \"...\" padding given above. Otherwise we end up with code lines that\n+                // do fit but end in \"...\" as if they were trimmed.\n+                self.computed_right - 6\n+            } else {\n+                self.computed_right\n+            };\n         right < line_len && self.computed_left + self.column_width < line_len\n     }\n \n@@ -156,7 +161,8 @@ impl Margin {\n                 let padding_left = (self.column_width - (self.span_right - self.span_left)) / 5 * 2;\n                 self.computed_left = self.span_left.saturating_sub(padding_left);\n                 self.computed_right = self.computed_left + self.column_width;\n-            } else { // Mostly give up but still don't show the full line.\n+            } else {\n+                // Mostly give up but still don't show the full line.\n                 self.computed_left = self.span_left;\n                 self.computed_right = self.span_right;\n             }\n@@ -240,11 +246,15 @@ pub trait Emitter {\n                     format!(\n                         \"help: {}{}: `{}`\",\n                         sugg.msg,\n-                        if self.source_map().map(|sm| is_case_difference(\n-                            &**sm,\n-                            substitution,\n-                            sugg.substitutions[0].parts[0].span,\n-                        )).unwrap_or(false) {\n+                        if self\n+                            .source_map()\n+                            .map(|sm| is_case_difference(\n+                                &**sm,\n+                                substitution,\n+                                sugg.substitutions[0].parts[0].span,\n+                            ))\n+                            .unwrap_or(false)\n+                        {\n                             \" (notice the capitalization)\"\n                         } else {\n                             \"\"\n@@ -271,37 +281,35 @@ pub trait Emitter {\n     // This does a small \"fix\" for multispans by looking to see if it can find any that\n     // point directly at <*macros>. Since these are often difficult to read, this\n     // will change the span to point at the use site.\n-    fn fix_multispans_in_std_macros(&self,\n-                                    source_map: &Option<Lrc<SourceMap>>,\n-                                    span: &mut MultiSpan,\n-                                    children: &mut Vec<SubDiagnostic>,\n-                                    level: &Level,\n-                                    backtrace: bool) {\n+    fn fix_multispans_in_std_macros(\n+        &self,\n+        source_map: &Option<Lrc<SourceMap>>,\n+        span: &mut MultiSpan,\n+        children: &mut Vec<SubDiagnostic>,\n+        level: &Level,\n+        backtrace: bool,\n+    ) {\n         let mut spans_updated = self.fix_multispan_in_std_macros(source_map, span, backtrace);\n         for child in children.iter_mut() {\n-            spans_updated |= self.fix_multispan_in_std_macros(\n-                                 source_map,\n-                                 &mut child.span,\n-                                 backtrace\n-                             );\n+            spans_updated |=\n+                self.fix_multispan_in_std_macros(source_map, &mut child.span, backtrace);\n         }\n         let msg = if level == &Error {\n             \"this error originates in a macro outside of the current crate \\\n              (in Nightly builds, run with -Z external-macro-backtrace \\\n-              for more info)\".to_string()\n+              for more info)\"\n+                .to_string()\n         } else {\n             \"this warning originates in a macro outside of the current crate \\\n              (in Nightly builds, run with -Z external-macro-backtrace \\\n-              for more info)\".to_string()\n+              for more info)\"\n+                .to_string()\n         };\n \n         if spans_updated {\n             children.push(SubDiagnostic {\n                 level: Level::Note,\n-                message: vec![\n-                    (msg,\n-                     Style::NoStyle),\n-                ],\n+                message: vec![(msg, Style::NoStyle)],\n                 span: MultiSpan::new(),\n                 render_span: None,\n             });\n@@ -311,10 +319,12 @@ pub trait Emitter {\n     // This \"fixes\" MultiSpans that contain Spans that are pointing to locations inside of\n     // <*macros>. Since these locations are often difficult to read, we move these Spans from\n     // <*macros> to their corresponding use site.\n-    fn fix_multispan_in_std_macros(&self,\n-                                   source_map: &Option<Lrc<SourceMap>>,\n-                                   span: &mut MultiSpan,\n-                                   always_backtrace: bool) -> bool {\n+    fn fix_multispan_in_std_macros(\n+        &self,\n+        source_map: &Option<Lrc<SourceMap>>,\n+        span: &mut MultiSpan,\n+        always_backtrace: bool,\n+    ) -> bool {\n         let sm = match source_map {\n             Some(ref sm) => sm,\n             None => return false,\n@@ -340,31 +350,40 @@ pub trait Emitter {\n                     continue;\n                 }\n                 if always_backtrace {\n-                    new_labels.push((trace.def_site_span,\n-                                        format!(\"in this expansion of `{}`{}\",\n-                                                trace.macro_decl_name,\n-                                                if backtrace_len > 2 {\n-                                                    // if backtrace_len == 1 it'll be pointed\n-                                                    // at by \"in this macro invocation\"\n-                                                    format!(\" (#{})\", i + 1)\n-                                                } else {\n-                                                    String::new()\n-                                                })));\n+                    new_labels.push((\n+                        trace.def_site_span,\n+                        format!(\n+                            \"in this expansion of `{}`{}\",\n+                            trace.macro_decl_name,\n+                            if backtrace_len > 2 {\n+                                // if backtrace_len == 1 it'll be pointed\n+                                // at by \"in this macro invocation\"\n+                                format!(\" (#{})\", i + 1)\n+                            } else {\n+                                String::new()\n+                            }\n+                        ),\n+                    ));\n                 }\n                 // Check to make sure we're not in any <*macros>\n-                if !sm.span_to_filename(trace.def_site_span).is_macros() &&\n-                    !trace.macro_decl_name.starts_with(\"desugaring of \") &&\n-                    !trace.macro_decl_name.starts_with(\"#[\") ||\n-                    always_backtrace {\n-                    new_labels.push((trace.call_site,\n-                                        format!(\"in this macro invocation{}\",\n-                                                if backtrace_len > 2 && always_backtrace {\n-                                                    // only specify order when the macro\n-                                                    // backtrace is multiple levels deep\n-                                                    format!(\" (#{})\", i + 1)\n-                                                } else {\n-                                                    String::new()\n-                                                })));\n+                if !sm.span_to_filename(trace.def_site_span).is_macros()\n+                    && !trace.macro_decl_name.starts_with(\"desugaring of \")\n+                    && !trace.macro_decl_name.starts_with(\"#[\")\n+                    || always_backtrace\n+                {\n+                    new_labels.push((\n+                        trace.call_site,\n+                        format!(\n+                            \"in this macro invocation{}\",\n+                            if backtrace_len > 2 && always_backtrace {\n+                                // only specify order when the macro\n+                                // backtrace is multiple levels deep\n+                                format!(\" (#{})\", i + 1)\n+                            } else {\n+                                String::new()\n+                            }\n+                        ),\n+                    ));\n                     if !always_backtrace {\n                         break;\n                     }\n@@ -378,9 +397,7 @@ pub trait Emitter {\n             if sp_label.span.is_dummy() {\n                 continue;\n             }\n-            if sm.span_to_filename(sp_label.span.clone()).is_macros() &&\n-                !always_backtrace\n-            {\n+            if sm.span_to_filename(sp_label.span.clone()).is_macros() && !always_backtrace {\n                 let v = sp_label.span.macro_backtrace();\n                 if let Some(use_site) = v.last() {\n                     before_after.push((sp_label.span.clone(), use_site.call_site.clone()));\n@@ -406,18 +423,22 @@ impl Emitter for EmitterWriter {\n         let mut children = diag.children.clone();\n         let (mut primary_span, suggestions) = self.primary_span_formatted(&diag);\n \n-        self.fix_multispans_in_std_macros(&self.sm,\n-                                          &mut primary_span,\n-                                          &mut children,\n-                                          &diag.level,\n-                                          self.external_macro_backtrace);\n-\n-        self.emit_messages_default(&diag.level,\n-                                   &diag.styled_message(),\n-                                   &diag.code,\n-                                   &primary_span,\n-                                   &children,\n-                                   &suggestions);\n+        self.fix_multispans_in_std_macros(\n+            &self.sm,\n+            &mut primary_span,\n+            &mut children,\n+            &diag.level,\n+            self.external_macro_backtrace,\n+        );\n+\n+        self.emit_messages_default(\n+            &diag.level,\n+            &diag.styled_message(),\n+            &diag.code,\n+            &primary_span,\n+            &children,\n+            &suggestions,\n+        );\n     }\n \n     fn should_show_explain(&self) -> bool {\n@@ -429,7 +450,9 @@ impl Emitter for EmitterWriter {\n pub struct SilentEmitter;\n \n impl Emitter for SilentEmitter {\n-    fn source_map(&self) -> Option<&Lrc<SourceMap>> { None }\n+    fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n+        None\n+    }\n     fn emit_diagnostic(&mut self, _: &Diagnostic) {}\n }\n \n@@ -458,17 +481,13 @@ impl ColorConfig {\n                 }\n             }\n             ColorConfig::Never => ColorChoice::Never,\n-            ColorConfig::Auto if atty::is(atty::Stream::Stderr) => {\n-                ColorChoice::Auto\n-            }\n+            ColorConfig::Auto if atty::is(atty::Stream::Stderr) => ColorChoice::Auto,\n             ColorConfig::Auto => ColorChoice::Never,\n         }\n     }\n     fn suggests_using_colors(self) -> bool {\n         match self {\n-            | ColorConfig::Always\n-            | ColorConfig::Auto\n-            => true,\n+            ColorConfig::Always | ColorConfig::Auto => true,\n             ColorConfig::Never => false,\n         }\n     }\n@@ -540,11 +559,7 @@ impl EmitterWriter {\n     }\n \n     fn maybe_anonymized(&self, line_num: usize) -> String {\n-        if self.ui_testing {\n-            ANONYMIZED_LINE_NUM.to_string()\n-        } else {\n-            line_num.to_string()\n-        }\n+        if self.ui_testing { ANONYMIZED_LINE_NUM.to_string() } else { line_num.to_string() }\n     }\n \n     fn draw_line(\n@@ -563,17 +578,21 @@ impl EmitterWriter {\n         let right = margin.right(line_len);\n         // On long lines, we strip the source line, accounting for unicode.\n         let mut taken = 0;\n-        let code: String = source_string.chars().skip(left).take_while(|ch| {\n-            // Make sure that the trimming on the right will fall within the terminal width.\n-            // FIXME: `unicode_width` sometimes disagrees with terminals on how wide a `char` is.\n-            // For now, just accept that sometimes the code line will be longer than desired.\n-            let next = unicode_width::UnicodeWidthChar::width(*ch).unwrap_or(1);\n-            if taken + next > right - left {\n-                return false;\n-            }\n-            taken += next;\n-            true\n-        }).collect();\n+        let code: String = source_string\n+            .chars()\n+            .skip(left)\n+            .take_while(|ch| {\n+                // Make sure that the trimming on the right will fall within the terminal width.\n+                // FIXME: `unicode_width` sometimes disagrees with terminals on how wide a `char` is.\n+                // For now, just accept that sometimes the code line will be longer than desired.\n+                let next = unicode_width::UnicodeWidthChar::width(*ch).unwrap_or(1);\n+                if taken + next > right - left {\n+                    return false;\n+                }\n+                taken += next;\n+                true\n+            })\n+            .collect();\n         buffer.puts(line_offset, code_offset, &code, Style::Quotation);\n         if margin.was_cut_left() {\n             // We have stripped some code/whitespace from the beginning, make it clear.\n@@ -624,7 +643,9 @@ impl EmitterWriter {\n \n         let left = margin.left(source_string.len()); // Left trim\n         // Account for unicode characters of width !=0 that were removed.\n-        let left = source_string.chars().take(left)\n+        let left = source_string\n+            .chars()\n+            .take(left)\n             .map(|ch| unicode_width::UnicodeWidthChar::width(ch).unwrap_or(1))\n             .sum();\n \n@@ -773,13 +794,14 @@ impl EmitterWriter {\n                 if overlaps(next, annotation, 0)  // This label overlaps with another one and both\n                     && annotation.has_label()     // take space (they have text and are not\n                     && j > i                      // multiline lines).\n-                    && p == 0  // We're currently on the first line, move the label one line down\n+                    && p == 0\n+                // We're currently on the first line, move the label one line down\n                 {\n                     // If we're overlapping with an un-labelled annotation with the same span\n                     // we can just merge them in the output\n                     if next.start_col == annotation.start_col\n-                    && next.end_col == annotation.end_col\n-                    && !next.has_label()\n+                        && next.end_col == annotation.end_col\n+                        && !next.has_label()\n                     {\n                         continue;\n                     }\n@@ -791,7 +813,7 @@ impl EmitterWriter {\n             }\n             annotations_position.push((p, annotation));\n             for (j, next) in annotations.iter().enumerate() {\n-                if j > i  {\n+                if j > i {\n                     let l = next.label.as_ref().map_or(0, |label| label.len() + 2);\n                     if (overlaps(next, annotation, l) // Do not allow two labels to be in the same\n                                                      // line if they overlap including padding, to\n@@ -814,7 +836,8 @@ impl EmitterWriter {\n                         || (overlaps(next, annotation, l)\n                             && next.end_col <= annotation.end_col\n                             && next.has_label()\n-                            && p == 0)  // Avoid #42595.\n+                            && p == 0)\n+                    // Avoid #42595.\n                     {\n                         // This annotation needs a new line in the output.\n                         p += 1;\n@@ -848,10 +871,7 @@ impl EmitterWriter {\n         //   |\n         for pos in 0..=line_len {\n             draw_col_separator(buffer, line_offset + pos + 1, width_offset - 2);\n-            buffer.putc(line_offset + pos + 1,\n-                        width_offset - 2,\n-                        '|',\n-                        Style::LineNumber);\n+            buffer.putc(line_offset + pos + 1, width_offset - 2, '|', Style::LineNumber);\n         }\n \n         // Write the horizontal lines for multiline annotations\n@@ -874,8 +894,7 @@ impl EmitterWriter {\n             };\n             let pos = pos + 1;\n             match annotation.annotation_type {\n-                AnnotationType::MultilineStart(depth) |\n-                AnnotationType::MultilineEnd(depth) => {\n+                AnnotationType::MultilineStart(depth) | AnnotationType::MultilineEnd(depth) => {\n                     draw_range(\n                         buffer,\n                         '_',\n@@ -919,27 +938,23 @@ impl EmitterWriter {\n \n             if pos > 1 && (annotation.has_label() || annotation.takes_space()) {\n                 for p in line_offset + 1..=line_offset + pos {\n-                    buffer.putc(p,\n-                                (code_offset + annotation.start_col).saturating_sub(left),\n-                                '|',\n-                                style);\n+                    buffer.putc(\n+                        p,\n+                        (code_offset + annotation.start_col).saturating_sub(left),\n+                        '|',\n+                        style,\n+                    );\n                 }\n             }\n             match annotation.annotation_type {\n                 AnnotationType::MultilineStart(depth) => {\n                     for p in line_offset + pos + 1..line_offset + line_len + 2 {\n-                        buffer.putc(p,\n-                                    width_offset + depth - 1,\n-                                    '|',\n-                                    style);\n+                        buffer.putc(p, width_offset + depth - 1, '|', style);\n                     }\n                 }\n                 AnnotationType::MultilineEnd(depth) => {\n                     for p in line_offset..=line_offset + pos {\n-                        buffer.putc(p,\n-                                    width_offset + depth - 1,\n-                                    '|',\n-                                    style);\n+                        buffer.putc(p, width_offset + depth - 1, '|', style);\n                     }\n                 }\n                 _ => (),\n@@ -958,11 +973,8 @@ impl EmitterWriter {\n         // 4 |   }\n         //   |  _  test\n         for &(pos, annotation) in &annotations_position {\n-            let style = if annotation.is_primary {\n-                Style::LabelPrimary\n-            } else {\n-                Style::LabelSecondary\n-            };\n+            let style =\n+                if annotation.is_primary { Style::LabelPrimary } else { Style::LabelSecondary };\n             let (pos, col) = if pos == 0 {\n                 (pos + 1, (annotation.end_col + 1).saturating_sub(left))\n             } else {\n@@ -1012,8 +1024,9 @@ impl EmitterWriter {\n                 );\n             }\n         }\n-        annotations_position.iter().filter_map(|&(_, annotation)| {\n-            match annotation.annotation_type {\n+        annotations_position\n+            .iter()\n+            .filter_map(|&(_, annotation)| match annotation.annotation_type {\n                 AnnotationType::MultilineStart(p) | AnnotationType::MultilineEnd(p) => {\n                     let style = if annotation.is_primary {\n                         Style::LabelPrimary\n@@ -1022,10 +1035,9 @@ impl EmitterWriter {\n                     };\n                     Some((p, style))\n                 }\n-                _ => None\n-            }\n-\n-        }).collect::<Vec<_>>()\n+                _ => None,\n+            })\n+            .collect::<Vec<_>>()\n     }\n \n     fn get_multispan_max_line_num(&mut self, msp: &MultiSpan) -> usize {\n@@ -1055,7 +1067,8 @@ impl EmitterWriter {\n \n     fn get_max_line_num(&mut self, span: &MultiSpan, children: &[SubDiagnostic]) -> usize {\n         let primary = self.get_multispan_max_line_num(span);\n-        children.iter()\n+        children\n+            .iter()\n             .map(|sub| self.get_multispan_max_line_num(&sub.span))\n             .max()\n             .unwrap_or(0)\n@@ -1064,13 +1077,14 @@ impl EmitterWriter {\n \n     /// Adds a left margin to every line but the first, given a padding length and the label being\n     /// displayed, keeping the provided highlighting.\n-    fn msg_to_buffer(&self,\n-                     buffer: &mut StyledBuffer,\n-                     msg: &[(String, Style)],\n-                     padding: usize,\n-                     label: &str,\n-                     override_style: Option<Style>) {\n-\n+    fn msg_to_buffer(\n+        &self,\n+        buffer: &mut StyledBuffer,\n+        msg: &[(String, Style)],\n+        padding: usize,\n+        label: &str,\n+        override_style: Option<Style>,\n+    ) {\n         // The extra 5 ` ` is padding that's always needed to align to the `note: `:\n         //\n         //   error: message\n@@ -1144,14 +1158,10 @@ impl EmitterWriter {\n         is_secondary: bool,\n     ) -> io::Result<()> {\n         let mut buffer = StyledBuffer::new();\n-        let header_style = if is_secondary {\n-            Style::HeaderMsg\n-        } else {\n-            Style::MainHeaderMsg\n-        };\n+        let header_style = if is_secondary { Style::HeaderMsg } else { Style::MainHeaderMsg };\n \n-        if !msp.has_primary_spans() && !msp.has_span_labels() && is_secondary\n-           && !self.short_message {\n+        if !msp.has_primary_spans() && !msp.has_span_labels() && is_secondary && !self.short_message\n+        {\n             // This is a secondary message with no span info\n             for _ in 0..max_line_num_len {\n                 buffer.prepend(0, \" \", Style::NoStyle);\n@@ -1189,7 +1199,8 @@ impl EmitterWriter {\n \n         // Make sure our primary file comes first\n         let (primary_lo, sm) = if let (Some(sm), Some(ref primary_span)) =\n-            (self.sm.as_ref(), msp.primary_span().as_ref()) {\n+            (self.sm.as_ref(), msp.primary_span().as_ref())\n+        {\n             if !primary_span.is_dummy() {\n                 (sm.lookup_char_pos(primary_span.lo()), sm)\n             } else {\n@@ -1202,7 +1213,8 @@ impl EmitterWriter {\n             return Ok(());\n         };\n         if let Ok(pos) =\n-            annotated_files.binary_search_by(|x| x.file.name.cmp(&primary_lo.file.name)) {\n+            annotated_files.binary_search_by(|x| x.file.name.cmp(&primary_lo.file.name))\n+        {\n             annotated_files.swap(0, pos);\n         }\n \n@@ -1263,17 +1275,16 @@ impl EmitterWriter {\n                     } else {\n                         String::new()\n                     };\n-                    format!(\"{}:{}{}\",\n-                            annotated_file.file.name,\n-                            sm.doctest_offset_line(\n-                                &annotated_file.file.name, first_line.line_index),\n-                            col)\n+                    format!(\n+                        \"{}:{}{}\",\n+                        annotated_file.file.name,\n+                        sm.doctest_offset_line(&annotated_file.file.name, first_line.line_index),\n+                        col\n+                    )\n                 } else {\n                     annotated_file.file.name.to_string()\n                 };\n-                buffer.append(buffer_msg_line_offset + 1,\n-                              &loc,\n-                              Style::LineAndColumn);\n+                buffer.append(buffer_msg_line_offset + 1, &loc, Style::LineAndColumn);\n                 for _ in 0..max_line_num_len {\n                     buffer.prepend(buffer_msg_line_offset + 1, \" \", Style::NoStyle);\n                 }\n@@ -1282,9 +1293,11 @@ impl EmitterWriter {\n             if !self.short_message {\n                 // Put in the spacer between the location and annotated source\n                 let buffer_msg_line_offset = buffer.num_lines();\n-                draw_col_separator_no_space(&mut buffer,\n-                                            buffer_msg_line_offset,\n-                                            max_line_num_len + 1);\n+                draw_col_separator_no_space(\n+                    &mut buffer,\n+                    buffer_msg_line_offset,\n+                    max_line_num_len + 1,\n+                );\n \n                 // Contains the vertical lines' positions for active multiline annotations\n                 let mut multilines = FxHashMap::default();\n@@ -1295,15 +1308,10 @@ impl EmitterWriter {\n                     let file = annotated_file.file.clone();\n                     let line = &annotated_file.lines[line_idx];\n                     if let Some(source_string) = file.get_line(line.line_index - 1) {\n-                        let leading_whitespace = source_string\n-                            .chars()\n-                            .take_while(|c| c.is_whitespace())\n-                            .count();\n+                        let leading_whitespace =\n+                            source_string.chars().take_while(|c| c.is_whitespace()).count();\n                         if source_string.chars().any(|c| !c.is_whitespace()) {\n-                            whitespace_margin = min(\n-                                whitespace_margin,\n-                                leading_whitespace,\n-                            );\n+                            whitespace_margin = min(whitespace_margin, leading_whitespace);\n                         }\n                     }\n                 }\n@@ -1328,9 +1336,10 @@ impl EmitterWriter {\n                 let mut label_right_margin = 0;\n                 let mut max_line_len = 0;\n                 for line in &annotated_file.lines {\n-                    max_line_len = max(max_line_len, annotated_file.file\n-                        .get_line(line.line_index - 1)\n-                        .map_or(0, |s| s.len()));\n+                    max_line_len = max(\n+                        max_line_len,\n+                        annotated_file.file.get_line(line.line_index - 1).map_or(0, |s| s.len()),\n+                    );\n                     for ann in &line.annotations {\n                         span_right_margin = max(span_right_margin, ann.start_col);\n                         span_right_margin = max(span_right_margin, ann.end_col);\n@@ -1393,32 +1402,31 @@ impl EmitterWriter {\n                     // the code in this line.\n                     for (depth, style) in &multilines {\n                         for line in previous_buffer_line..buffer.num_lines() {\n-                            draw_multiline_line(&mut buffer,\n-                                                line,\n-                                                width_offset,\n-                                                *depth,\n-                                                *style);\n+                            draw_multiline_line(&mut buffer, line, width_offset, *depth, *style);\n                         }\n                     }\n                     // check to see if we need to print out or elide lines that come between\n                     // this annotated line and the next one.\n                     if line_idx < (annotated_file.lines.len() - 1) {\n-                        let line_idx_delta = annotated_file.lines[line_idx + 1].line_index -\n-                                             annotated_file.lines[line_idx].line_index;\n+                        let line_idx_delta = annotated_file.lines[line_idx + 1].line_index\n+                            - annotated_file.lines[line_idx].line_index;\n                         if line_idx_delta > 2 {\n                             let last_buffer_line_num = buffer.num_lines();\n                             buffer.puts(last_buffer_line_num, 0, \"...\", Style::LineNumber);\n \n                             // Set the multiline annotation vertical lines on `...` bridging line.\n                             for (depth, style) in &multilines {\n-                                draw_multiline_line(&mut buffer,\n-                                                    last_buffer_line_num,\n-                                                    width_offset,\n-                                                    *depth,\n-                                                    *style);\n+                                draw_multiline_line(\n+                                    &mut buffer,\n+                                    last_buffer_line_num,\n+                                    width_offset,\n+                                    *depth,\n+                                    *style,\n+                                );\n                             }\n                         } else if line_idx_delta == 2 {\n-                            let unannotated_line = annotated_file.file\n+                            let unannotated_line = annotated_file\n+                                .file\n                                 .get_line(annotated_file.lines[line_idx].line_index)\n                                 .unwrap_or_else(|| Cow::from(\"\"));\n \n@@ -1455,7 +1463,6 @@ impl EmitterWriter {\n         emit_to_destination(&buffer.render(), level, &mut self.dst, self.short_message)?;\n \n         Ok(())\n-\n     }\n \n     fn emit_suggestion_default(\n@@ -1466,7 +1473,7 @@ impl EmitterWriter {\n     ) -> io::Result<()> {\n         let sm = match self.sm {\n             Some(ref sm) => sm,\n-            None => return Ok(())\n+            None => return Ok(()),\n         };\n \n         let mut buffer = StyledBuffer::new();\n@@ -1495,8 +1502,7 @@ impl EmitterWriter {\n             // Only show underline if the suggestion spans a single line and doesn't cover the\n             // entirety of the code output. If you have multiple replacements in the same line\n             // of code, show the underline.\n-            let show_underline = !(parts.len() == 1\n-                && parts[0].snippet.trim() == complete.trim())\n+            let show_underline = !(parts.len() == 1 && parts[0].snippet.trim() == complete.trim())\n                 && complete.lines().count() == 1;\n \n             let lines = sm.span_to_lines(parts[0].span).unwrap();\n@@ -1509,10 +1515,12 @@ impl EmitterWriter {\n             let mut lines = complete.lines();\n             for line in lines.by_ref().take(MAX_HIGHLIGHT_LINES) {\n                 // Print the span column to avoid confusion\n-                buffer.puts(row_num,\n-                            0,\n-                            &self.maybe_anonymized(line_start + line_pos),\n-                            Style::LineNumber);\n+                buffer.puts(\n+                    row_num,\n+                    0,\n+                    &self.maybe_anonymized(line_start + line_pos),\n+                    Style::LineNumber,\n+                );\n                 // print the suggestion\n                 draw_col_separator(&mut buffer, row_num, max_line_num_len + 1);\n                 buffer.append(row_num, line, Style::NoStyle);\n@@ -1532,34 +1540,42 @@ impl EmitterWriter {\n                     let span_end_pos = sm.lookup_char_pos(part.span.hi()).col_display;\n \n                     // Do not underline the leading...\n-                    let start = part.snippet.len()\n-                        .saturating_sub(part.snippet.trim_start().len());\n+                    let start = part.snippet.len().saturating_sub(part.snippet.trim_start().len());\n                     // ...or trailing spaces. Account for substitutions containing unicode\n                     // characters.\n-                    let sub_len: usize = part.snippet.trim().chars()\n+                    let sub_len: usize = part\n+                        .snippet\n+                        .trim()\n+                        .chars()\n                         .map(|ch| unicode_width::UnicodeWidthChar::width(ch).unwrap_or(1))\n                         .sum();\n \n                     let underline_start = (span_start_pos + start) as isize + offset;\n                     let underline_end = (span_start_pos + start + sub_len) as isize + offset;\n                     for p in underline_start..underline_end {\n-                        buffer.putc(row_num,\n-                                    max_line_num_len + 3 + p as usize,\n-                                    '^',\n-                                    Style::UnderlinePrimary);\n+                        buffer.putc(\n+                            row_num,\n+                            max_line_num_len + 3 + p as usize,\n+                            '^',\n+                            Style::UnderlinePrimary,\n+                        );\n                     }\n                     // underline removals too\n                     if underline_start == underline_end {\n-                        for p in underline_start-1..underline_start+1 {\n-                            buffer.putc(row_num,\n-                                        max_line_num_len + 3 + p as usize,\n-                                        '-',\n-                                        Style::UnderlineSecondary);\n+                        for p in underline_start - 1..underline_start + 1 {\n+                            buffer.putc(\n+                                row_num,\n+                                max_line_num_len + 3 + p as usize,\n+                                '-',\n+                                Style::UnderlineSecondary,\n+                            );\n                         }\n                     }\n \n                     // length of the code after substitution\n-                    let full_sub_len = part.snippet.chars()\n+                    let full_sub_len = part\n+                        .snippet\n+                        .chars()\n                         .map(|ch| unicode_width::UnicodeWidthChar::width(ch).unwrap_or(1))\n                         .sum::<usize>() as isize;\n \n@@ -1609,17 +1625,21 @@ impl EmitterWriter {\n \n         match self.emit_message_default(span, message, code, level, max_line_num_len, false) {\n             Ok(()) => {\n-                if !children.is_empty() || suggestions.iter().any(|s| {\n-                    s.style != SuggestionStyle::CompletelyHidden\n-                }) {\n+                if !children.is_empty()\n+                    || suggestions.iter().any(|s| s.style != SuggestionStyle::CompletelyHidden)\n+                {\n                     let mut buffer = StyledBuffer::new();\n                     if !self.short_message {\n                         draw_col_separator_no_space(&mut buffer, 0, max_line_num_len + 1);\n                     }\n-                    match emit_to_destination(&buffer.render(), level, &mut self.dst,\n-                                              self.short_message) {\n+                    match emit_to_destination(\n+                        &buffer.render(),\n+                        level,\n+                        &mut self.dst,\n+                        self.short_message,\n+                    ) {\n                         Ok(()) => (),\n-                        Err(e) => panic!(\"failed to emit error: {}\", e)\n+                        Err(e) => panic!(\"failed to emit error: {}\", e),\n                     }\n                 }\n                 if !self.short_message {\n@@ -1634,7 +1654,7 @@ impl EmitterWriter {\n                             true,\n                         ) {\n                             Err(e) => panic!(\"failed to emit error: {}\", e),\n-                            _ => ()\n+                            _ => (),\n                         }\n                     }\n                     for sugg in suggestions {\n@@ -1650,16 +1670,13 @@ impl EmitterWriter {\n                                 true,\n                             ) {\n                                 Err(e) => panic!(\"failed to emit error: {}\", e),\n-                                _ => ()\n+                                _ => (),\n                             }\n                         } else {\n-                            match self.emit_suggestion_default(\n-                                sugg,\n-                                &Level::Help,\n-                                max_line_num_len,\n-                            ) {\n+                            match self.emit_suggestion_default(sugg, &Level::Help, max_line_num_len)\n+                            {\n                                 Err(e) => panic!(\"failed to emit error: {}\", e),\n-                                _ => ()\n+                                _ => (),\n                             }\n                         }\n                     }\n@@ -1671,12 +1688,10 @@ impl EmitterWriter {\n         let mut dst = self.dst.writable();\n         match writeln!(dst) {\n             Err(e) => panic!(\"failed to emit error: {}\", e),\n-            _ => {\n-                match dst.flush() {\n-                    Err(e) => panic!(\"failed to emit error: {}\", e),\n-                    _ => (),\n-                }\n-            }\n+            _ => match dst.flush() {\n+                Err(e) => panic!(\"failed to emit error: {}\", e),\n+                _ => (),\n+            },\n         }\n     }\n }\n@@ -1686,13 +1701,14 @@ impl FileWithAnnotatedLines {\n     /// This helps us quickly iterate over the whole message (including secondary file spans)\n     pub fn collect_annotations(\n         msp: &MultiSpan,\n-        source_map: &Option<Lrc<SourceMap>>\n+        source_map: &Option<Lrc<SourceMap>>,\n     ) -> Vec<FileWithAnnotatedLines> {\n-        fn add_annotation_to_file(file_vec: &mut Vec<FileWithAnnotatedLines>,\n-                                  file: Lrc<SourceFile>,\n-                                  line_index: usize,\n-                                  ann: Annotation) {\n-\n+        fn add_annotation_to_file(\n+            file_vec: &mut Vec<FileWithAnnotatedLines>,\n+            file: Lrc<SourceFile>,\n+            line_index: usize,\n+            ann: Annotation,\n+        ) {\n             for slot in file_vec.iter_mut() {\n                 // Look through each of our files for the one we're adding to\n                 if slot.file.name == file.name {\n@@ -1704,21 +1720,15 @@ impl FileWithAnnotatedLines {\n                         }\n                     }\n                     // We don't have a line yet, create one\n-                    slot.lines.push(Line {\n-                        line_index,\n-                        annotations: vec![ann],\n-                    });\n+                    slot.lines.push(Line { line_index, annotations: vec![ann] });\n                     slot.lines.sort();\n                     return;\n                 }\n             }\n             // This is the first time we're seeing the file\n             file_vec.push(FileWithAnnotatedLines {\n                 file,\n-                lines: vec![Line {\n-                                line_index,\n-                                annotations: vec![ann],\n-                            }],\n+                lines: vec![Line { line_index, annotations: vec![ann] }],\n                 multiline_depth: 0,\n             });\n         }\n@@ -1776,8 +1786,8 @@ impl FileWithAnnotatedLines {\n             for (_, a) in multiline_annotations.iter_mut() {\n                 // Move all other multiline annotations overlapping with this one\n                 // one level to the right.\n-                if !(ann.same_span(a)) &&\n-                    num_overlap(ann.line_start, ann.line_end, a.line_start, a.line_end, true)\n+                if !(ann.same_span(a))\n+                    && num_overlap(ann.line_start, ann.line_end, a.line_start, a.line_end, true)\n                 {\n                     a.increase_depth();\n                 } else if ann.same_span(a) && &ann != a {\n@@ -1788,7 +1798,7 @@ impl FileWithAnnotatedLines {\n             }\n         }\n \n-        let mut max_depth = 0;  // max overlapping multiline spans\n+        let mut max_depth = 0; // max overlapping multiline spans\n         for (file, ann) in multiline_annotations {\n             max_depth = max(max_depth, ann.depth);\n             let mut end_ann = ann.as_end();\n@@ -1849,15 +1859,23 @@ fn draw_col_separator_no_space(buffer: &mut StyledBuffer, line: usize, col: usiz\n     draw_col_separator_no_space_with_style(buffer, line, col, Style::LineNumber);\n }\n \n-fn draw_col_separator_no_space_with_style(buffer: &mut StyledBuffer,\n-                                          line: usize,\n-                                          col: usize,\n-                                          style: Style) {\n+fn draw_col_separator_no_space_with_style(\n+    buffer: &mut StyledBuffer,\n+    line: usize,\n+    col: usize,\n+    style: Style,\n+) {\n     buffer.putc(line, col, '|', style);\n }\n \n-fn draw_range(buffer: &mut StyledBuffer, symbol: char, line: usize,\n-              col_from: usize, col_to: usize, style: Style) {\n+fn draw_range(\n+    buffer: &mut StyledBuffer,\n+    symbol: char,\n+    line: usize,\n+    col_from: usize,\n+    col_to: usize,\n+    style: Style,\n+) {\n     for col in col_from..col_to {\n         buffer.putc(line, col, symbol, style);\n     }\n@@ -1867,33 +1885,36 @@ fn draw_note_separator(buffer: &mut StyledBuffer, line: usize, col: usize) {\n     buffer.puts(line, col, \"= \", Style::LineNumber);\n }\n \n-fn draw_multiline_line(buffer: &mut StyledBuffer,\n-                       line: usize,\n-                       offset: usize,\n-                       depth: usize,\n-                       style: Style)\n-{\n+fn draw_multiline_line(\n+    buffer: &mut StyledBuffer,\n+    line: usize,\n+    offset: usize,\n+    depth: usize,\n+    style: Style,\n+) {\n     buffer.putc(line, offset + depth - 1, '|', style);\n }\n \n-fn num_overlap(a_start: usize, a_end: usize, b_start: usize, b_end:usize, inclusive: bool) -> bool {\n-    let extra = if inclusive {\n-        1\n-    } else {\n-        0\n-    };\n-    (b_start..b_end + extra).contains(&a_start) ||\n-    (a_start..a_end + extra).contains(&b_start)\n+fn num_overlap(\n+    a_start: usize,\n+    a_end: usize,\n+    b_start: usize,\n+    b_end: usize,\n+    inclusive: bool,\n+) -> bool {\n+    let extra = if inclusive { 1 } else { 0 };\n+    (b_start..b_end + extra).contains(&a_start) || (a_start..a_end + extra).contains(&b_start)\n }\n fn overlaps(a1: &Annotation, a2: &Annotation, padding: usize) -> bool {\n     num_overlap(a1.start_col, a1.end_col + padding, a2.start_col, a2.end_col, false)\n }\n \n-fn emit_to_destination(rendered_buffer: &[Vec<StyledString>],\n-                       lvl: &Level,\n-                       dst: &mut Destination,\n-                       short_message: bool)\n-                       -> io::Result<()> {\n+fn emit_to_destination(\n+    rendered_buffer: &[Vec<StyledString>],\n+    lvl: &Level,\n+    dst: &mut Destination,\n+    short_message: bool,\n+) -> io::Result<()> {\n     use crate::lock;\n \n     let mut dst = dst.writable();\n@@ -1986,26 +2007,22 @@ impl<'a> WritableDst<'a> {\n             Style::MainHeaderMsg => {\n                 spec.set_bold(true);\n                 if cfg!(windows) {\n-                    spec.set_intense(true)\n-                        .set_fg(Some(Color::White));\n+                    spec.set_intense(true).set_fg(Some(Color::White));\n                 }\n             }\n             Style::UnderlinePrimary | Style::LabelPrimary => {\n                 spec = lvl.color();\n                 spec.set_bold(true);\n             }\n-            Style::UnderlineSecondary |\n-            Style::LabelSecondary => {\n-                spec.set_bold(true)\n-                    .set_intense(true);\n+            Style::UnderlineSecondary | Style::LabelSecondary => {\n+                spec.set_bold(true).set_intense(true);\n                 if cfg!(windows) {\n                     spec.set_fg(Some(Color::Cyan));\n                 } else {\n                     spec.set_fg(Some(Color::Blue));\n                 }\n             }\n-            Style::HeaderMsg |\n-            Style::NoStyle => {}\n+            Style::HeaderMsg | Style::NoStyle => {}\n             Style::Level(lvl) => {\n                 spec = lvl.color();\n                 spec.set_bold(true);\n@@ -2022,7 +2039,7 @@ impl<'a> WritableDst<'a> {\n             WritableDst::Terminal(ref mut t) => t.set_color(color),\n             WritableDst::Buffered(_, ref mut t) => t.set_color(color),\n             WritableDst::ColoredRaw(ref mut t) => t.set_color(color),\n-            WritableDst::Raw(_) => Ok(())\n+            WritableDst::Raw(_) => Ok(()),\n         }\n     }\n \n@@ -2073,9 +2090,11 @@ pub fn is_case_difference(sm: &SourceMap, suggested: &str, sp: Span) -> bool {\n     let found = sm.span_to_snippet(sp).unwrap();\n     let ascii_confusables = &['c', 'f', 'i', 'k', 'o', 's', 'u', 'v', 'w', 'x', 'y', 'z'];\n     // All the chars that differ in capitalization are confusable (above):\n-    let confusable = found.chars().zip(suggested.chars()).filter(|(f, s)| f != s).all(|(f, s)| {\n-        (ascii_confusables.contains(&f) || ascii_confusables.contains(&s))\n-    });\n+    let confusable = found\n+        .chars()\n+        .zip(suggested.chars())\n+        .filter(|(f, s)| f != s)\n+        .all(|(f, s)| (ascii_confusables.contains(&f) || ascii_confusables.contains(&s)));\n     confusable && found.to_lowercase() == suggested.to_lowercase()\n             // FIXME: We sometimes suggest the same thing we already have, which is a\n             //        bug, but be defensive against that here."}, {"sha": "b46b26444f61be1c3a1b3475618db180dc052bcb", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 125, "deletions": 173, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d", "patch": "@@ -1,14 +1,14 @@\n use rustc::hir;\n use rustc::hir::Node;\n use rustc::mir::{self, ClearCrossCrate, Local, LocalInfo, Location, ReadOnlyBodyAndCache};\n-use rustc::mir::{Mutability, Place, PlaceRef, PlaceBase, ProjectionElem};\n+use rustc::mir::{Mutability, Place, PlaceBase, PlaceRef, ProjectionElem};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc_index::vec::Idx;\n-use syntax_pos::Span;\n use syntax_pos::symbol::kw;\n+use syntax_pos::Span;\n \n-use crate::borrow_check::MirBorrowckCtxt;\n use crate::borrow_check::diagnostics::BorrowedContentSource;\n+use crate::borrow_check::MirBorrowckCtxt;\n use crate::util::collect_writes::FindAssignments;\n use rustc_errors::Applicability;\n \n@@ -42,16 +42,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         debug!(\"report_mutability_error: access_place_desc={:?}\", access_place_desc);\n \n         match the_place_err {\n-            PlaceRef {\n-                base: PlaceBase::Local(local),\n-                projection: [],\n-            } => {\n+            PlaceRef { base: PlaceBase::Local(local), projection: [] } => {\n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n                 if access_place.as_local().is_some() {\n                     reason = \", as it is not declared as mutable\".to_string();\n                 } else {\n-                    let name = self.local_names[*local]\n-                        .expect(\"immutable unnamed local\");\n+                    let name = self.local_names[*local].expect(\"immutable unnamed local\");\n                     reason = format!(\", as `{}` is not declared as mutable\", name);\n                 }\n             }\n@@ -61,12 +57,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 projection: [proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n             } => {\n                 debug_assert!(is_closure_or_generator(\n-                    Place::ty_from(\n-                        &the_place_err.base,\n-                        proj_base,\n-                        *self.body,\n-                        self.infcx.tcx\n-                    ).ty));\n+                    Place::ty_from(&the_place_err.base, proj_base, *self.body, self.infcx.tcx).ty\n+                ));\n \n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n                 if self.is_upvar_field_projection(access_place.as_ref()).is_some() {\n@@ -77,17 +69,15 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n             }\n \n-            PlaceRef {\n-                base: &PlaceBase::Local(local),\n-                projection: [ProjectionElem::Deref],\n-            } if self.body.local_decls[local].is_ref_for_guard() => {\n+            PlaceRef { base: &PlaceBase::Local(local), projection: [ProjectionElem::Deref] }\n+                if self.body.local_decls[local].is_ref_for_guard() =>\n+            {\n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n                 reason = \", as it is immutable for the pattern guard\".to_string();\n             }\n-            PlaceRef {\n-                base: &PlaceBase::Local(local),\n-                projection: [ProjectionElem::Deref],\n-            } if self.body.local_decls[local].is_ref_to_static() => {\n+            PlaceRef { base: &PlaceBase::Local(local), projection: [ProjectionElem::Deref] }\n+                if self.body.local_decls[local].is_ref_to_static() =>\n+            {\n                 if access_place.projection.len() == 1 {\n                     item_msg = format!(\"immutable static item `{}`\", access_place_desc.unwrap());\n                     reason = String::new();\n@@ -102,13 +92,11 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     }\n                 }\n             }\n-            PlaceRef {\n-                base: _,\n-                projection: [proj_base @ .., ProjectionElem::Deref],\n-            } => {\n-                if the_place_err.base == &PlaceBase::Local(Local::new(1)) &&\n-                    proj_base.is_empty() &&\n-                    !self.upvars.is_empty() {\n+            PlaceRef { base: _, projection: [proj_base @ .., ProjectionElem::Deref] } => {\n+                if the_place_err.base == &PlaceBase::Local(Local::new(1))\n+                    && proj_base.is_empty()\n+                    && !self.upvars.is_empty()\n+                {\n                     item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n                     debug_assert!(self.body.local_decls[Local::new(1)].ty.is_region_ptr());\n                     debug_assert!(is_closure_or_generator(\n@@ -121,12 +109,11 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         .ty\n                     ));\n \n-                    reason =\n-                        if self.is_upvar_field_projection(access_place.as_ref()).is_some() {\n-                            \", as it is a captured variable in a `Fn` closure\".to_string()\n-                        } else {\n-                            \", as `Fn` closures cannot mutate their captured variables\".to_string()\n-                        }\n+                    reason = if self.is_upvar_field_projection(access_place.as_ref()).is_some() {\n+                        \", as it is a captured variable in a `Fn` closure\".to_string()\n+                    } else {\n+                        \", as `Fn` closures cannot mutate their captured variables\".to_string()\n+                    }\n                 } else {\n                     let source = self.borrowed_content_source(PlaceRef {\n                         base: the_place_err.base,\n@@ -149,26 +136,13 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n             }\n \n-            PlaceRef {\n-                base: PlaceBase::Static(_),\n-                ..\n-            }\n-            | PlaceRef {\n-                base: _,\n-                projection: [.., ProjectionElem::Index(_)],\n-            }\n-            | PlaceRef {\n-                base: _,\n-                projection: [.., ProjectionElem::ConstantIndex { .. }],\n-            }\n-            | PlaceRef {\n-                base: _,\n-                projection: [.., ProjectionElem::Subslice { .. }],\n+            PlaceRef { base: PlaceBase::Static(_), .. }\n+            | PlaceRef { base: _, projection: [.., ProjectionElem::Index(_)] }\n+            | PlaceRef { base: _, projection: [.., ProjectionElem::ConstantIndex { .. }] }\n+            | PlaceRef { base: _, projection: [.., ProjectionElem::Subslice { .. }] }\n+            | PlaceRef { base: _, projection: [.., ProjectionElem::Downcast(..)] } => {\n+                bug!(\"Unexpected immutable place.\")\n             }\n-            | PlaceRef {\n-                base: _,\n-                projection: [.., ProjectionElem::Downcast(..)],\n-            } => bug!(\"Unexpected immutable place.\"),\n         }\n \n         debug!(\"report_mutability_error: item_msg={:?}, reason={:?}\", item_msg, reason);\n@@ -191,18 +165,14 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 let borrow_spans = self.borrow_spans(span, location);\n                 let borrow_span = borrow_spans.args_or_use();\n-                err = self.cannot_borrow_path_as_mutable_because(\n-                    borrow_span,\n-                    &item_msg,\n-                    &reason,\n-                );\n+                err = self.cannot_borrow_path_as_mutable_because(borrow_span, &item_msg, &reason);\n                 borrow_spans.var_span_label(\n                     &mut err,\n                     format!(\n                         \"mutable borrow occurs due to use of `{}` in closure\",\n                         // always Some() if the message is printed.\n                         self.describe_place(access_place.as_ref()).unwrap_or_default(),\n-                    )\n+                    ),\n                 );\n                 borrow_span\n             }\n@@ -219,11 +189,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // after the field access).\n             PlaceRef {\n                 base,\n-                projection: [proj_base @ ..,\n-                             ProjectionElem::Deref,\n-                             ProjectionElem::Field(field, _),\n-                             ProjectionElem::Deref,\n-                ],\n+                projection:\n+                    [proj_base @ .., ProjectionElem::Deref, ProjectionElem::Field(field, _), ProjectionElem::Deref],\n             } => {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n \n@@ -239,49 +206,50 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         Applicability::MaybeIncorrect,\n                     );\n                 }\n-            },\n+            }\n \n             // Suggest removing a `&mut` from the use of a mutable reference.\n-            PlaceRef {\n-                base: PlaceBase::Local(local),\n-                projection: [],\n-            } if {\n-                self.body.local_decls.get(*local).map(|local_decl| {\n-                    if let LocalInfo::User(ClearCrossCrate::Set(\n-                        mir::BindingForm::ImplicitSelf(kind)\n-                    )) = local_decl.local_info {\n-                        // Check if the user variable is a `&mut self` and we can therefore\n-                        // suggest removing the `&mut`.\n-                        //\n-                        // Deliberately fall into this case for all implicit self types,\n-                        // so that we don't fall in to the next case with them.\n-                        kind == mir::ImplicitSelfKind::MutRef\n-                    } else if Some(kw::SelfLower) == self.local_names[*local] {\n-                        // Otherwise, check if the name is the self kewyord - in which case\n-                        // we have an explicit self. Do the same thing in this case and check\n-                        // for a `self: &mut Self` to suggest removing the `&mut`.\n-                        if let ty::Ref(\n-                            _, _, hir::Mutability::Mut\n-                        ) = local_decl.ty.kind {\n-                            true\n-                        } else {\n-                            false\n-                        }\n-                    } else {\n-                        false\n-                    }\n-                }).unwrap_or(false)\n-            } => {\n+            PlaceRef { base: PlaceBase::Local(local), projection: [] }\n+                if {\n+                    self.body\n+                        .local_decls\n+                        .get(*local)\n+                        .map(|local_decl| {\n+                            if let LocalInfo::User(ClearCrossCrate::Set(\n+                                mir::BindingForm::ImplicitSelf(kind),\n+                            )) = local_decl.local_info\n+                            {\n+                                // Check if the user variable is a `&mut self` and we can therefore\n+                                // suggest removing the `&mut`.\n+                                //\n+                                // Deliberately fall into this case for all implicit self types,\n+                                // so that we don't fall in to the next case with them.\n+                                kind == mir::ImplicitSelfKind::MutRef\n+                            } else if Some(kw::SelfLower) == self.local_names[*local] {\n+                                // Otherwise, check if the name is the self kewyord - in which case\n+                                // we have an explicit self. Do the same thing in this case and check\n+                                // for a `self: &mut Self` to suggest removing the `&mut`.\n+                                if let ty::Ref(_, _, hir::Mutability::Mut) = local_decl.ty.kind {\n+                                    true\n+                                } else {\n+                                    false\n+                                }\n+                            } else {\n+                                false\n+                            }\n+                        })\n+                        .unwrap_or(false)\n+                } =>\n+            {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n                 err.span_label(span, \"try removing `&mut` here\");\n-            },\n+            }\n \n             // We want to suggest users use `let mut` for local (user\n             // variable) mutations...\n-            PlaceRef {\n-                base: PlaceBase::Local(local),\n-                projection: [],\n-            } if self.body.local_decls[*local].can_be_made_mutable() => {\n+            PlaceRef { base: PlaceBase::Local(local), projection: [] }\n+                if self.body.local_decls[*local].can_be_made_mutable() =>\n+            {\n                 // ... but it doesn't make sense to suggest it on\n                 // variables that are `ref x`, `ref mut x`, `&self`,\n                 // or `&mut self` (such variables are simply not\n@@ -310,8 +278,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n \n                 let upvar_hir_id = self.upvars[upvar_index.index()].var_hir_id;\n-                if let Some(Node::Binding(pat)) = self.infcx.tcx.hir().find(upvar_hir_id)\n-                {\n+                if let Some(Node::Binding(pat)) = self.infcx.tcx.hir().find(upvar_hir_id) {\n                     if let hir::PatKind::Binding(\n                         hir::BindingAnnotation::Unannotated,\n                         _,\n@@ -332,10 +299,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // complete hack to approximate old AST-borrowck\n             // diagnostic: if the span starts with a mutable borrow of\n             // a local variable, then just suggest the user remove it.\n-            PlaceRef {\n-                base: PlaceBase::Local(_),\n-                projection: [],\n-            } if {\n+            PlaceRef { base: PlaceBase::Local(_), projection: [] }\n+                if {\n                     if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n                         snippet.starts_with(\"&mut \")\n                     } else {\n@@ -347,10 +312,9 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 err.span_label(span, \"try removing `&mut` here\");\n             }\n \n-            PlaceRef {\n-                base: PlaceBase::Local(local),\n-                projection: [ProjectionElem::Deref],\n-            } if self.body.local_decls[*local].is_ref_for_guard() => {\n+            PlaceRef { base: PlaceBase::Local(local), projection: [ProjectionElem::Deref] }\n+                if self.body.local_decls[*local].is_ref_for_guard() =>\n+            {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n                 err.note(\n                     \"variables bound in patterns are immutable until the end of the pattern guard\",\n@@ -362,10 +326,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             //\n             // FIXME: can this case be generalized to work for an\n             // arbitrary base for the projection?\n-            PlaceRef {\n-                base: PlaceBase::Local(local),\n-                projection: [ProjectionElem::Deref],\n-            } if self.body.local_decls[*local].is_user_variable() =>\n+            PlaceRef { base: PlaceBase::Local(local), projection: [ProjectionElem::Deref] }\n+                if self.body.local_decls[*local].is_user_variable() =>\n             {\n                 let local_decl = &self.body.local_decls[*local];\n                 let suggestion = match local_decl.local_info {\n@@ -449,41 +411,32 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             PlaceRef {\n                 base,\n                 projection: [ProjectionElem::Deref],\n-            // FIXME document what is this 1 magic number about\n-            } if *base == PlaceBase::Local(Local::new(1)) &&\n-                  !self.upvars.is_empty() =>\n-            {\n+                // FIXME document what is this 1 magic number about\n+            } if *base == PlaceBase::Local(Local::new(1)) && !self.upvars.is_empty() => {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n                 err.span_help(\n                     self.body.span,\n-                    \"consider changing this to accept closures that implement `FnMut`\"\n+                    \"consider changing this to accept closures that implement `FnMut`\",\n                 );\n             }\n \n-            PlaceRef {\n-                base: _,\n-                projection: [.., ProjectionElem::Deref],\n-            } => {\n+            PlaceRef { base: _, projection: [.., ProjectionElem::Deref] } => {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n \n                 match opt_source {\n                     Some(BorrowedContentSource::OverloadedDeref(ty)) => {\n-                        err.help(\n-                            &format!(\n-                                \"trait `DerefMut` is required to modify through a dereference, \\\n+                        err.help(&format!(\n+                            \"trait `DerefMut` is required to modify through a dereference, \\\n                                 but it is not implemented for `{}`\",\n-                                ty,\n-                            ),\n-                        );\n-                    },\n+                            ty,\n+                        ));\n+                    }\n                     Some(BorrowedContentSource::OverloadedIndex(ty)) => {\n-                        err.help(\n-                            &format!(\n-                                \"trait `IndexMut` is required to modify indexed content, \\\n+                        err.help(&format!(\n+                            \"trait `IndexMut` is required to modify indexed content, \\\n                                 but it is not implemented for `{}`\",\n-                                ty,\n-                            ),\n-                        );\n+                            ty,\n+                        ));\n                     }\n                     _ => (),\n                 }\n@@ -503,17 +456,20 @@ fn suggest_ampmut_self<'tcx>(\n     local_decl: &mir::LocalDecl<'tcx>,\n ) -> (Span, String) {\n     let sp = local_decl.source_info.span;\n-    (sp, match tcx.sess.source_map().span_to_snippet(sp) {\n-        Ok(snippet) => {\n-            let lt_pos = snippet.find('\\'');\n-            if let Some(lt_pos) = lt_pos {\n-                format!(\"&{}mut self\", &snippet[lt_pos..snippet.len() - 4])\n-            } else {\n-                \"&mut self\".to_string()\n+    (\n+        sp,\n+        match tcx.sess.source_map().span_to_snippet(sp) {\n+            Ok(snippet) => {\n+                let lt_pos = snippet.find('\\'');\n+                if let Some(lt_pos) = lt_pos {\n+                    format!(\"&{}mut self\", &snippet[lt_pos..snippet.len() - 4])\n+                } else {\n+                    \"&mut self\".to_string()\n+                }\n             }\n-        }\n-        _ => \"&mut self\".to_string()\n-    })\n+            _ => \"&mut self\".to_string(),\n+        },\n+    )\n }\n \n // When we want to suggest a user change a local variable to be a `&mut`, there\n@@ -542,10 +498,9 @@ fn suggest_ampmut<'tcx>(\n     if !locations.is_empty() {\n         let assignment_rhs_span = body.source_info(locations[0]).span;\n         if let Ok(src) = tcx.sess.source_map().span_to_snippet(assignment_rhs_span) {\n-            if let (true, Some(ws_pos)) = (\n-                src.starts_with(\"&'\"),\n-                src.find(|c: char| -> bool { c.is_whitespace() }),\n-            ) {\n+            if let (true, Some(ws_pos)) =\n+                (src.starts_with(\"&'\"), src.find(|c: char| -> bool { c.is_whitespace() }))\n+            {\n                 let lt_name = &src[1..ws_pos];\n                 let ty = &src[ws_pos..];\n                 return (assignment_rhs_span, format!(\"&{} mut {}\", lt_name, ty));\n@@ -567,10 +522,9 @@ fn suggest_ampmut<'tcx>(\n     };\n \n     if let Ok(src) = tcx.sess.source_map().span_to_snippet(highlight_span) {\n-        if let (true, Some(ws_pos)) = (\n-            src.starts_with(\"&'\"),\n-            src.find(|c: char| -> bool { c.is_whitespace() }),\n-        ) {\n+        if let (true, Some(ws_pos)) =\n+            (src.starts_with(\"&'\"), src.find(|c: char| -> bool { c.is_whitespace() }))\n+        {\n             let lt_name = &src[1..ws_pos];\n             let ty = &src[ws_pos..];\n             return (highlight_span, format!(\"&{} mut{}\", lt_name, ty));\n@@ -579,12 +533,14 @@ fn suggest_ampmut<'tcx>(\n \n     let ty_mut = local_decl.ty.builtin_deref(true).unwrap();\n     assert_eq!(ty_mut.mutbl, hir::Mutability::Not);\n-    (highlight_span,\n-     if local_decl.ty.is_region_ptr() {\n-         format!(\"&mut {}\", ty_mut.ty)\n-     } else {\n-         format!(\"*mut {}\", ty_mut.ty)\n-     })\n+    (\n+        highlight_span,\n+        if local_decl.ty.is_region_ptr() {\n+            format!(\"&mut {}\", ty_mut.ty)\n+        } else {\n+            format!(\"*mut {}\", ty_mut.ty)\n+        },\n+    )\n }\n \n fn is_closure_or_generator(ty: Ty<'_>) -> bool {\n@@ -613,10 +569,11 @@ fn annotate_struct_field(\n             // Now we're dealing with the actual struct that we're going to suggest a change to,\n             // we can expect a field that is an immutable reference to a type.\n             if let hir::Node::Field(field) = node {\n-                if let hir::TyKind::Rptr(lifetime, hir::MutTy {\n-                    mutbl: hir::Mutability::Not,\n-                    ref ty\n-                }) = field.ty.kind {\n+                if let hir::TyKind::Rptr(\n+                    lifetime,\n+                    hir::MutTy { mutbl: hir::Mutability::Not, ref ty },\n+                ) = field.ty.kind\n+                {\n                     // Get the snippets in two parts - the named lifetime (if there is one) and\n                     // type being referenced, that way we can reconstruct the snippet without loss\n                     // of detail.\n@@ -629,10 +586,7 @@ fn annotate_struct_field(\n \n                     return Some((\n                         field.ty.span,\n-                        format!(\n-                            \"&{}mut {}\",\n-                            lifetime_snippet, &*type_snippet,\n-                        ),\n+                        format!(\"&{}mut {}\", lifetime_snippet, &*type_snippet,),\n                     ));\n                 }\n             }\n@@ -645,9 +599,7 @@ fn annotate_struct_field(\n /// If possible, suggest replacing `ref` with `ref mut`.\n fn suggest_ref_mut(tcx: TyCtxt<'_>, binding_span: Span) -> Option<String> {\n     let hi_src = tcx.sess.source_map().span_to_snippet(binding_span).ok()?;\n-    if hi_src.starts_with(\"ref\")\n-        && hi_src[\"ref\".len()..].starts_with(rustc_lexer::is_whitespace)\n-    {\n+    if hi_src.starts_with(\"ref\") && hi_src[\"ref\".len()..].starts_with(rustc_lexer::is_whitespace) {\n         let replacement = format!(\"ref mut{}\", &hi_src[\"ref\".len()..]);\n         Some(replacement)\n     } else {"}, {"sha": "db7db03bde00205fe36800f690dfa88f403e1546", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 289, "deletions": 394, "changes": 683, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d", "patch": "@@ -1,60 +1,57 @@\n //! This pass type-checks the MIR to ensure it is not broken.\n \n-use std::{fmt, iter, mem};\n use std::rc::Rc;\n+use std::{fmt, iter, mem};\n \n use either::Either;\n \n use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime, NLLRegionVariableOrigin};\n use rustc::infer::canonical::QueryRegionConstraints;\n use rustc::infer::outlives::env::RegionBoundPairs;\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc::mir::*;\n+use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime, NLLRegionVariableOrigin};\n use rustc::mir::interpret::PanicInfo;\n use rustc::mir::tcx::PlaceTy;\n use rustc::mir::visit::{NonMutatingUseContext, PlaceContext, Visitor};\n-use rustc::traits::{self, ObligationCause, PredicateObligations};\n-use rustc::traits::query::{Fallible, NoSolution};\n+use rustc::mir::*;\n use rustc::traits::query::type_op;\n use rustc::traits::query::type_op::custom::CustomTypeOp;\n-use rustc::ty::{\n-    self, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, RegionVid, ToPolyTraitRef, Ty,\n-    TyCtxt, UserType,\n-    UserTypeAnnotationIndex,\n-};\n+use rustc::traits::query::{Fallible, NoSolution};\n+use rustc::traits::{self, ObligationCause, PredicateObligations};\n use rustc::ty::adjustment::PointerCast;\n use rustc::ty::cast::CastTy;\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::layout::VariantIdx;\n use rustc::ty::subst::{GenericArgKind, Subst, SubstsRef, UserSubsts};\n+use rustc::ty::{\n+    self, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, RegionVid, ToPolyTraitRef, Ty,\n+    TyCtxt, UserType, UserTypeAnnotationIndex,\n+};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_error_codes::*;\n use rustc_index::vec::{Idx, IndexVec};\n-use syntax_pos::{DUMMY_SP, Span};\n+use syntax_pos::{Span, DUMMY_SP};\n \n+use crate::dataflow::move_paths::MoveData;\n use crate::dataflow::FlowAtLocation;\n use crate::dataflow::MaybeInitializedPlaces;\n-use crate::dataflow::move_paths::MoveData;\n use crate::transform::promote_consts::should_suggest_const_in_array_repeat_expressions_attribute;\n \n use crate::borrow_check::{\n     borrow_set::BorrowSet,\n+    constraints::{OutlivesConstraint, OutlivesConstraintSet},\n+    facts::AllFacts,\n     location::LocationTable,\n-    constraints::{OutlivesConstraintSet, OutlivesConstraint},\n     member_constraints::MemberConstraintSet,\n-    facts::AllFacts,\n+    nll::ToRegionVid,\n     region_infer::values::{\n         LivenessValues, PlaceholderIndex, PlaceholderIndices, RegionValueElements,\n     },\n     region_infer::{ClosureRegionRequirementsExt, TypeTest},\n-    type_check::free_region_relations::{\n-        CreateResult, UniversalRegionRelations,\n-    },\n-    universal_regions::{DefiningTy, UniversalRegions},\n-    nll::ToRegionVid,\n     renumber,\n+    type_check::free_region_relations::{CreateResult, UniversalRegionRelations},\n+    universal_regions::{DefiningTy, UniversalRegions},\n };\n \n macro_rules! span_mirbug {\n@@ -172,26 +169,14 @@ pub(crate) fn type_check<'tcx>(\n         &mut borrowck_context,\n         &universal_region_relations,\n         |mut cx| {\n-            cx.equate_inputs_and_outputs(\n-                &body,\n-                universal_regions,\n-                &normalized_inputs_and_output);\n-            liveness::generate(\n-                &mut cx,\n-                body,\n-                elements,\n-                flow_inits,\n-                move_data,\n-                location_table);\n+            cx.equate_inputs_and_outputs(&body, universal_regions, &normalized_inputs_and_output);\n+            liveness::generate(&mut cx, body, elements, flow_inits, move_data, location_table);\n \n             translate_outlives_facts(&mut cx);\n         },\n     );\n \n-    MirTypeckResults {\n-        constraints,\n-        universal_region_relations,\n-    }\n+    MirTypeckResults { constraints, universal_region_relations }\n }\n \n fn type_check_internal<'a, 'tcx, R>(\n@@ -235,25 +220,23 @@ fn translate_outlives_facts(typeck: &mut TypeChecker<'_, '_>) {\n     if let Some(facts) = cx.all_facts {\n         let _prof_timer = typeck.infcx.tcx.prof.generic_activity(\"polonius_fact_generation\");\n         let location_table = cx.location_table;\n-        facts\n-            .outlives\n-            .extend(cx.constraints.outlives_constraints.outlives().iter().flat_map(\n-                |constraint: &OutlivesConstraint| {\n-                    if let Some(from_location) = constraint.locations.from_location() {\n-                        Either::Left(iter::once((\n-                            constraint.sup,\n-                            constraint.sub,\n-                            location_table.mid_index(from_location),\n-                        )))\n-                    } else {\n-                        Either::Right(\n-                            location_table\n-                                .all_points()\n-                                .map(move |location| (constraint.sup, constraint.sub, location)),\n-                        )\n-                    }\n-                },\n-            ));\n+        facts.outlives.extend(cx.constraints.outlives_constraints.outlives().iter().flat_map(\n+            |constraint: &OutlivesConstraint| {\n+                if let Some(from_location) = constraint.locations.from_location() {\n+                    Either::Left(iter::once((\n+                        constraint.sup,\n+                        constraint.sub,\n+                        location_table.mid_index(from_location),\n+                    )))\n+                } else {\n+                    Either::Right(\n+                        location_table\n+                            .all_points()\n+                            .map(move |location| (constraint.sup, constraint.sub, location)),\n+                    )\n+                }\n+            },\n+        ));\n     }\n }\n \n@@ -311,7 +294,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n             if let Err(terr) = self.cx.relate_type_and_user_type(\n                 constant.literal.ty,\n                 ty::Variance::Invariant,\n-                &UserTypeProjection { base: annotation_index, projs: vec![], },\n+                &UserTypeProjection { base: annotation_index, projs: vec![] },\n                 location.to_locations(),\n                 ConstraintCategory::Boring,\n             ) {\n@@ -331,24 +314,18 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                     location.to_locations(),\n                     ConstraintCategory::Boring,\n                     self.cx.param_env.and(type_op::ascribe_user_type::AscribeUserType::new(\n-                        constant.literal.ty, def_id, UserSubsts { substs, user_self_ty: None },\n+                        constant.literal.ty,\n+                        def_id,\n+                        UserSubsts { substs, user_self_ty: None },\n                     )),\n                 ) {\n-                    span_mirbug!(\n-                        self,\n-                        constant,\n-                        \"bad constant type {:?} ({:?})\",\n-                        constant,\n-                        terr\n-                    );\n+                    span_mirbug!(self, constant, \"bad constant type {:?} ({:?})\", constant, terr);\n                 }\n             }\n             if let ty::FnDef(def_id, substs) = constant.literal.ty.kind {\n                 let tcx = self.tcx();\n \n-                let instantiated_predicates = tcx\n-                    .predicates_of(def_id)\n-                    .instantiate(tcx, substs);\n+                let instantiated_predicates = tcx.predicates_of(def_id).instantiate(tcx, substs);\n                 self.cx.normalize_and_prove_instantiated_predicates(\n                     instantiated_predicates,\n                     location.to_locations(),\n@@ -451,29 +428,25 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         debug!(\"sanitize_place: {:?}\", place);\n \n         let mut place_ty = match &place.base {\n-            PlaceBase::Local(index) =>\n-                PlaceTy::from_ty(self.body.local_decls[*index].ty),\n+            PlaceBase::Local(index) => PlaceTy::from_ty(self.body.local_decls[*index].ty),\n             PlaceBase::Static(box Static { kind, ty, def_id }) => {\n                 let san_ty = self.sanitize_type(place, ty);\n                 let check_err =\n-                    |verifier: &mut TypeVerifier<'a, 'b, 'tcx>,\n-                     place: &Place<'tcx>,\n-                     ty,\n-                     san_ty| {\n+                    |verifier: &mut TypeVerifier<'a, 'b, 'tcx>, place: &Place<'tcx>, ty, san_ty| {\n                         if let Err(terr) = verifier.cx.eq_types(\n                             san_ty,\n                             ty,\n                             location.to_locations(),\n                             ConstraintCategory::Boring,\n                         ) {\n                             span_mirbug!(\n-                            verifier,\n-                            place,\n-                            \"bad promoted type ({:?}: {:?}): {:?}\",\n-                            ty,\n-                            san_ty,\n-                            terr\n-                        );\n+                                verifier,\n+                                place,\n+                                \"bad promoted type ({:?}: {:?}): {:?}\",\n+                                ty,\n+                                san_ty,\n+                                terr\n+                            );\n                         };\n                     };\n                 match kind {\n@@ -501,10 +474,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n             if let PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) = context {\n                 let is_promoted = match place.as_ref() {\n                     PlaceRef {\n-                        base: &PlaceBase::Static(box Static {\n-                            kind: StaticKind::Promoted(..),\n-                            ..\n-                        }),\n+                        base: &PlaceBase::Static(box Static { kind: StaticKind::Promoted(..), .. }),\n                         projection: &[],\n                     } => true,\n                     _ => false,\n@@ -553,7 +523,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n     fn sanitize_promoted(\n         &mut self,\n         promoted_body: ReadOnlyBodyAndCache<'b, 'tcx>,\n-        location: Location\n+        location: Location,\n     ) {\n         // Determine the constraints from the promoted MIR by running the type\n         // checker on the promoted MIR, then transfer the constraints back to\n@@ -566,32 +536,30 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         let all_facts = &mut None;\n         let mut constraints = Default::default();\n         let mut closure_bounds = Default::default();\n-        let mut liveness_constraints = LivenessValues::new(\n-            Rc::new(RegionValueElements::new(&promoted_body)),\n-        );\n+        let mut liveness_constraints =\n+            LivenessValues::new(Rc::new(RegionValueElements::new(&promoted_body)));\n         // Don't try to add borrow_region facts for the promoted MIR\n \n         let mut swap_constraints = |this: &mut Self| {\n             mem::swap(this.cx.borrowck_context.all_facts, all_facts);\n             mem::swap(\n                 &mut this.cx.borrowck_context.constraints.outlives_constraints,\n-                &mut constraints\n+                &mut constraints,\n             );\n             mem::swap(\n                 &mut this.cx.borrowck_context.constraints.closure_bounds_mapping,\n-                &mut closure_bounds\n+                &mut closure_bounds,\n             );\n             mem::swap(\n                 &mut this.cx.borrowck_context.constraints.liveness_constraints,\n-                &mut liveness_constraints\n+                &mut liveness_constraints,\n             );\n         };\n \n         swap_constraints(self);\n \n         self.visit_body(promoted_body);\n \n-\n         if !self.errors_reported {\n             // if verifier failed, don't do further checks to avoid ICEs\n             self.cx.typeck_mir(promoted_body);\n@@ -616,23 +584,23 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n             self.cx.borrowck_context.constraints.outlives_constraints.push(constraint)\n         }\n         for live_region in liveness_constraints.rows() {\n-            self.cx.borrowck_context.constraints.liveness_constraints\n+            self.cx\n+                .borrowck_context\n+                .constraints\n+                .liveness_constraints\n                 .add_element(live_region, location);\n         }\n \n         if !closure_bounds.is_empty() {\n-            let combined_bounds_mapping = closure_bounds\n-                .into_iter()\n-                .flat_map(|(_, value)| value)\n-                .collect();\n-            let existing = self.cx.borrowck_context\n+            let combined_bounds_mapping =\n+                closure_bounds.into_iter().flat_map(|(_, value)| value).collect();\n+            let existing = self\n+                .cx\n+                .borrowck_context\n                 .constraints\n                 .closure_bounds_mapping\n                 .insert(location, combined_bounds_mapping);\n-            assert!(\n-                existing.is_none(),\n-                \"Multiple promoteds/closures at the same location.\"\n-            );\n+            assert!(existing.is_none(), \"Multiple promoteds/closures at the same location.\");\n         }\n     }\n \n@@ -649,64 +617,51 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         match *pi {\n             ProjectionElem::Deref => {\n                 let deref_ty = base_ty.builtin_deref(true);\n-                PlaceTy::from_ty(\n-                    deref_ty.map(|t| t.ty).unwrap_or_else(|| {\n-                        span_mirbug_and_err!(self, place, \"deref of non-pointer {:?}\", base_ty)\n-                    })\n-                )\n+                PlaceTy::from_ty(deref_ty.map(|t| t.ty).unwrap_or_else(|| {\n+                    span_mirbug_and_err!(self, place, \"deref of non-pointer {:?}\", base_ty)\n+                }))\n             }\n             ProjectionElem::Index(i) => {\n                 let index_ty = Place::from(i).ty(self.body, tcx).ty;\n                 if index_ty != tcx.types.usize {\n-                    PlaceTy::from_ty(\n-                        span_mirbug_and_err!(self, i, \"index by non-usize {:?}\", i),\n-                    )\n+                    PlaceTy::from_ty(span_mirbug_and_err!(self, i, \"index by non-usize {:?}\", i))\n                 } else {\n-                    PlaceTy::from_ty(\n-                        base_ty.builtin_index().unwrap_or_else(|| {\n-                            span_mirbug_and_err!(self, place, \"index of non-array {:?}\", base_ty)\n-                        }),\n-                    )\n+                    PlaceTy::from_ty(base_ty.builtin_index().unwrap_or_else(|| {\n+                        span_mirbug_and_err!(self, place, \"index of non-array {:?}\", base_ty)\n+                    }))\n                 }\n             }\n             ProjectionElem::ConstantIndex { .. } => {\n                 // consider verifying in-bounds\n-                PlaceTy::from_ty(\n-                    base_ty.builtin_index().unwrap_or_else(|| {\n-                        span_mirbug_and_err!(self, place, \"index of non-array {:?}\", base_ty)\n-                    }),\n-                )\n+                PlaceTy::from_ty(base_ty.builtin_index().unwrap_or_else(|| {\n+                    span_mirbug_and_err!(self, place, \"index of non-array {:?}\", base_ty)\n+                }))\n             }\n-            ProjectionElem::Subslice { from, to, from_end } => PlaceTy::from_ty(\n-                match base_ty.kind {\n+            ProjectionElem::Subslice { from, to, from_end } => {\n+                PlaceTy::from_ty(match base_ty.kind {\n                     ty::Array(inner, _) => {\n                         assert!(!from_end, \"array subslices should not use from_end\");\n                         tcx.mk_array(inner, (to - from) as u64)\n                     }\n                     ty::Slice(..) => {\n                         assert!(from_end, \"slice subslices should use from_end\");\n                         base_ty\n-                    },\n+                    }\n                     _ => span_mirbug_and_err!(self, place, \"slice of non-array {:?}\", base_ty),\n-                },\n-            ),\n+                })\n+            }\n             ProjectionElem::Downcast(maybe_name, index) => match base_ty.kind {\n                 ty::Adt(adt_def, _substs) if adt_def.is_enum() => {\n                     if index.as_usize() >= adt_def.variants.len() {\n-                        PlaceTy::from_ty(\n-                            span_mirbug_and_err!(\n-                                self,\n-                                place,\n-                                \"cast to variant #{:?} but enum only has {:?}\",\n-                                index,\n-                                adt_def.variants.len()\n-                            ),\n-                        )\n+                        PlaceTy::from_ty(span_mirbug_and_err!(\n+                            self,\n+                            place,\n+                            \"cast to variant #{:?} but enum only has {:?}\",\n+                            index,\n+                            adt_def.variants.len()\n+                        ))\n                     } else {\n-                        PlaceTy {\n-                            ty: base_ty,\n-                            variant_index: Some(index),\n-                        }\n+                        PlaceTy { ty: base_ty, variant_index: Some(index) }\n                     }\n                 }\n                 // We do not need to handle generators here, because this runs\n@@ -724,26 +679,28 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                         span_mirbug_and_err!(self, place, \"can't downcast {:?}\", base_ty)\n                     };\n                     PlaceTy::from_ty(ty)\n-                },\n+                }\n             },\n             ProjectionElem::Field(field, fty) => {\n                 let fty = self.sanitize_type(place, fty);\n                 match self.field_ty(place, base, field, location) {\n-                    Ok(ty) => if let Err(terr) = self.cx.eq_types(\n-                        ty,\n-                        fty,\n-                        location.to_locations(),\n-                        ConstraintCategory::Boring,\n-                    ) {\n-                        span_mirbug!(\n-                            self,\n-                            place,\n-                            \"bad field access ({:?}: {:?}): {:?}\",\n+                    Ok(ty) => {\n+                        if let Err(terr) = self.cx.eq_types(\n                             ty,\n                             fty,\n-                            terr\n-                        );\n-                    },\n+                            location.to_locations(),\n+                            ConstraintCategory::Boring,\n+                        ) {\n+                            span_mirbug!(\n+                                self,\n+                                place,\n+                                \"bad field access ({:?}: {:?}): {:?}\",\n+                                ty,\n+                                fty,\n+                                terr\n+                            );\n+                        }\n+                    }\n                     Err(FieldAccessError::OutOfRange { field_count }) => span_mirbug!(\n                         self,\n                         place,\n@@ -778,31 +735,30 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                     let mut variants = substs.as_generator().state_tys(def_id, tcx);\n                     let mut variant = match variants.nth(variant_index.into()) {\n                         Some(v) => v,\n-                        None => {\n-                            bug!(\"variant_index of generator out of range: {:?}/{:?}\",\n-                                 variant_index,\n-                                 substs.as_generator().state_tys(def_id, tcx).count())\n-                        }\n+                        None => bug!(\n+                            \"variant_index of generator out of range: {:?}/{:?}\",\n+                            variant_index,\n+                            substs.as_generator().state_tys(def_id, tcx).count()\n+                        ),\n                     };\n                     return match variant.nth(field.index()) {\n                         Some(ty) => Ok(ty),\n-                        None => Err(FieldAccessError::OutOfRange {\n-                            field_count: variant.count(),\n-                        }),\n-                    }\n+                        None => Err(FieldAccessError::OutOfRange { field_count: variant.count() }),\n+                    };\n                 }\n                 _ => bug!(\"can't have downcast of non-adt non-generator type\"),\n-            }\n+            },\n             PlaceTy { ty, variant_index: None } => match ty.kind {\n-                ty::Adt(adt_def, substs) if !adt_def.is_enum() =>\n-                    (&adt_def.variants[VariantIdx::new(0)], substs),\n+                ty::Adt(adt_def, substs) if !adt_def.is_enum() => {\n+                    (&adt_def.variants[VariantIdx::new(0)], substs)\n+                }\n                 ty::Closure(def_id, substs) => {\n                     return match substs.as_closure().upvar_tys(def_id, tcx).nth(field.index()) {\n                         Some(ty) => Ok(ty),\n                         None => Err(FieldAccessError::OutOfRange {\n                             field_count: substs.as_closure().upvar_tys(def_id, tcx).count(),\n                         }),\n-                    }\n+                    };\n                 }\n                 ty::Generator(def_id, substs, _) => {\n                     // Only prefix fields (upvars and current state) are\n@@ -812,33 +768,29 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                         None => Err(FieldAccessError::OutOfRange {\n                             field_count: substs.as_generator().prefix_tys(def_id, tcx).count(),\n                         }),\n-                    }\n+                    };\n                 }\n                 ty::Tuple(tys) => {\n                     return match tys.get(field.index()) {\n                         Some(&ty) => Ok(ty.expect_ty()),\n-                        None => Err(FieldAccessError::OutOfRange {\n-                            field_count: tys.len(),\n-                        }),\n-                    }\n+                        None => Err(FieldAccessError::OutOfRange { field_count: tys.len() }),\n+                    };\n                 }\n                 _ => {\n                     return Ok(span_mirbug_and_err!(\n                         self,\n                         parent,\n                         \"can't project out of {:?}\",\n                         base_ty\n-                    ))\n+                    ));\n                 }\n             },\n         };\n \n         if let Some(field) = variant.fields.get(field.index()) {\n             Ok(self.cx.normalize(&field.ty(tcx, substs), location))\n         } else {\n-            Err(FieldAccessError::OutOfRange {\n-                field_count: variant.fields.len(),\n-            })\n+            Err(FieldAccessError::OutOfRange { field_count: variant.fields.len() })\n         }\n     }\n }\n@@ -1029,13 +981,12 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     fn check_user_type_annotations(&mut self) {\n         debug!(\n             \"check_user_type_annotations: user_type_annotations={:?}\",\n-             self.user_type_annotations\n+            self.user_type_annotations\n         );\n         for user_annotation in self.user_type_annotations {\n             let CanonicalUserTypeAnnotation { span, ref user_ty, inferred_ty } = *user_annotation;\n-            let (annotation, _) = self.infcx.instantiate_canonical_with_fresh_inference_vars(\n-                span, user_ty\n-            );\n+            let (annotation, _) =\n+                self.infcx.instantiate_canonical_with_fresh_inference_vars(span, user_ty);\n             match annotation {\n                 UserType::Ty(mut ty) => {\n                     ty = self.normalize(ty, Locations::All(span));\n@@ -1061,13 +1012,15 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         Locations::All(span),\n                         ConstraintCategory::TypeAnnotation,\n                     );\n-                },\n+                }\n                 UserType::TypeOf(def_id, user_substs) => {\n                     if let Err(terr) = self.fully_perform_op(\n                         Locations::All(span),\n                         ConstraintCategory::BoringNoLocation,\n                         self.param_env.and(type_op::ascribe_user_type::AscribeUserType::new(\n-                            inferred_ty, def_id, user_substs,\n+                            inferred_ty,\n+                            def_id,\n+                            user_substs,\n                         )),\n                     ) {\n                         span_mirbug!(\n@@ -1080,7 +1033,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             terr\n                         );\n                     }\n-                },\n+                }\n             }\n         }\n     }\n@@ -1116,10 +1069,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         category: ConstraintCategory,\n         data: &QueryRegionConstraints<'tcx>,\n     ) {\n-        debug!(\n-            \"push_region_constraints: constraints generated at {:?} are {:#?}\",\n-            locations, data\n-        );\n+        debug!(\"push_region_constraints: constraints generated at {:?} are {:#?}\", locations, data);\n \n         constraint_conversion::ConstraintConversion::new(\n             self.infcx,\n@@ -1130,7 +1080,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             locations,\n             category,\n             &mut self.borrowck_context.constraints,\n-        ).convert_all(data);\n+        )\n+        .convert_all(data);\n     }\n \n     /// Convenient wrapper around `relate_tys::relate_types` -- see\n@@ -1229,8 +1180,10 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             );\n             curr_projected_ty = projected_ty;\n         }\n-        debug!(\"user_ty base: {:?} freshened: {:?} projs: {:?} yields: {:?}\",\n-                user_ty.base, annotated_type, user_ty.projs, curr_projected_ty);\n+        debug!(\n+            \"user_ty base: {:?} freshened: {:?} projs: {:?} yields: {:?}\",\n+            user_ty.base, annotated_type, user_ty.projs, curr_projected_ty\n+        );\n \n         let ty = curr_projected_ty.ty;\n         self.relate_types(a, v, ty, locations, category)?;\n@@ -1280,16 +1233,19 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                          revealed_ty={:?}\",\n                         output_ty, opaque_type_map, revealed_ty\n                     );\n-                    obligations.add(infcx\n-                        .at(&ObligationCause::dummy(), param_env)\n-                        .eq(output_ty, revealed_ty)?);\n+                    obligations.add(\n+                        infcx\n+                            .at(&ObligationCause::dummy(), param_env)\n+                            .eq(output_ty, revealed_ty)?,\n+                    );\n \n                     for (&opaque_def_id, opaque_decl) in &opaque_type_map {\n                         let opaque_defn_ty = tcx.type_of(opaque_def_id);\n                         let opaque_defn_ty = opaque_defn_ty.subst(tcx, opaque_decl.substs);\n                         let opaque_defn_ty = renumber::renumber_regions(infcx, &opaque_defn_ty);\n                         let concrete_is_opaque = infcx\n-                            .resolve_vars_if_possible(&opaque_decl.concrete_ty).is_impl_trait();\n+                            .resolve_vars_if_possible(&opaque_decl.concrete_ty)\n+                            .is_impl_trait();\n \n                         debug!(\n                             \"eq_opaque_type_and_type: concrete_ty={:?}={:?} opaque_defn_ty={:?} \\\n@@ -1321,9 +1277,11 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         // gets 'revealed' into\n \n                         if !concrete_is_opaque {\n-                            obligations.add(infcx\n-                                .at(&ObligationCause::dummy(), param_env)\n-                                .eq(opaque_decl.concrete_ty, opaque_defn_ty)?);\n+                            obligations.add(\n+                                infcx\n+                                    .at(&ObligationCause::dummy(), param_env)\n+                                    .eq(opaque_decl.concrete_ty, opaque_defn_ty)?,\n+                            );\n                         }\n                     }\n \n@@ -1356,10 +1314,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                 &opaque_decl,\n                                 universal_region_relations,\n                             );\n-                            Ok(InferOk {\n-                                value: (),\n-                                obligations: vec![],\n-                            })\n+                            Ok(InferOk { value: (), obligations: vec![] })\n                         },\n                         || \"opaque_type_map\".to_string(),\n                     ),\n@@ -1377,33 +1332,33 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         &mut self,\n         body: ReadOnlyBodyAndCache<'_, 'tcx>,\n         stmt: &Statement<'tcx>,\n-        location: Location)\n-    {\n+        location: Location,\n+    ) {\n         debug!(\"check_stmt: {:?}\", stmt);\n         let tcx = self.tcx();\n         match stmt.kind {\n-            StatementKind::Assign(box(ref place, ref rv)) => {\n+            StatementKind::Assign(box (ref place, ref rv)) => {\n                 // Assignments to temporaries are not \"interesting\";\n                 // they are not caused by the user, but rather artifacts\n                 // of lowering. Assignments to other sorts of places *are* interesting\n                 // though.\n                 let category = match place.as_local() {\n-                    Some(RETURN_PLACE) => if let BorrowCheckContext {\n-                        universal_regions:\n-                            UniversalRegions {\n-                                defining_ty: DefiningTy::Const(def_id, _),\n-                                ..\n-                            },\n-                        ..\n-                    } = self.borrowck_context {\n-                        if tcx.is_static(*def_id) {\n-                            ConstraintCategory::UseAsStatic\n+                    Some(RETURN_PLACE) => {\n+                        if let BorrowCheckContext {\n+                            universal_regions:\n+                                UniversalRegions { defining_ty: DefiningTy::Const(def_id, _), .. },\n+                            ..\n+                        } = self.borrowck_context\n+                        {\n+                            if tcx.is_static(*def_id) {\n+                                ConstraintCategory::UseAsStatic\n+                            } else {\n+                                ConstraintCategory::UseAsConst\n+                            }\n                         } else {\n-                            ConstraintCategory::UseAsConst\n+                            ConstraintCategory::Return\n                         }\n-                    } else {\n-                        ConstraintCategory::Return\n-                    },\n+                    }\n                     Some(l) if !body.local_decls[l].is_user_variable() => {\n                         ConstraintCategory::Boring\n                     }\n@@ -1431,7 +1386,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     if let Err(terr) = self.relate_type_and_user_type(\n                         rv_ty,\n                         ty::Variance::Invariant,\n-                        &UserTypeProjection { base: annotation_index, projs: vec![], },\n+                        &UserTypeProjection { base: annotation_index, projs: vec![] },\n                         location.to_locations(),\n                         ConstraintCategory::Boring,\n                     ) {\n@@ -1460,10 +1415,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     );\n                 }\n             }\n-            StatementKind::SetDiscriminant {\n-                ref place,\n-                variant_index,\n-            } => {\n+            StatementKind::SetDiscriminant { ref place, variant_index } => {\n                 let place_type = place.ty(*body, tcx).ty;\n                 let adt = match place_type.kind {\n                     ty::Adt(adt, _) if adt.is_enum() => adt,\n@@ -1485,7 +1437,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     );\n                 };\n             }\n-            StatementKind::AscribeUserType(box(ref place, ref projection), variance) => {\n+            StatementKind::AscribeUserType(box (ref place, ref projection), variance) => {\n                 let place_ty = place.ty(*body, tcx).ty;\n                 if let Err(terr) = self.relate_type_and_user_type(\n                     place_ty,\n@@ -1536,12 +1488,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 // no checks needed for these\n             }\n \n-            TerminatorKind::DropAndReplace {\n-                ref location,\n-                ref value,\n-                target: _,\n-                unwind: _,\n-            } => {\n+            TerminatorKind::DropAndReplace { ref location, ref value, target: _, unwind: _ } => {\n                 let place_ty = location.ty(body, tcx).ty;\n                 let rv_ty = value.ty(body, tcx);\n \n@@ -1559,11 +1506,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     );\n                 }\n             }\n-            TerminatorKind::SwitchInt {\n-                ref discr,\n-                switch_ty,\n-                ..\n-            } => {\n+            TerminatorKind::SwitchInt { ref discr, switch_ty, .. } => {\n                 let discr_ty = discr.ty(body, tcx);\n                 if let Err(terr) = self.sub_types(\n                     discr_ty,\n@@ -1585,13 +1528,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 }\n                 // FIXME: check the values\n             }\n-            TerminatorKind::Call {\n-                ref func,\n-                ref args,\n-                ref destination,\n-                from_hir_call,\n-                ..\n-            } => {\n+            TerminatorKind::Call { ref func, ref args, ref destination, from_hir_call, .. } => {\n                 let func_ty = func.ty(body, tcx);\n                 debug!(\"check_terminator: call, func_ty={:?}\", func_ty);\n                 let sig = match func_ty.kind {\n@@ -1623,9 +1560,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 // output) types in the signature must be live, since\n                 // all the inputs that fed into it were live.\n                 for &late_bound_region in map.values() {\n-                    let region_vid = self.borrowck_context\n-                        .universal_regions\n-                        .to_region_vid(late_bound_region);\n+                    let region_vid =\n+                        self.borrowck_context.universal_regions.to_region_vid(late_bound_region);\n                     self.borrowck_context\n                         .constraints\n                         .liveness_constraints\n@@ -1634,9 +1570,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n                 self.check_call_inputs(body, term, &sig, args, term_location, from_hir_call);\n             }\n-            TerminatorKind::Assert {\n-                ref cond, ref msg, ..\n-            } => {\n+            TerminatorKind::Assert { ref cond, ref msg, .. } => {\n                 let cond_ty = cond.ty(body, tcx);\n                 if cond_ty != tcx.types.bool {\n                     span_mirbug!(self, term, \"bad Assert ({:?}, not bool\", cond_ty);\n@@ -1694,10 +1628,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     Some(RETURN_PLACE) => {\n                         if let BorrowCheckContext {\n                             universal_regions:\n-                                UniversalRegions {\n-                                    defining_ty: DefiningTy::Const(def_id, _),\n-                                    ..\n-                                },\n+                                UniversalRegions { defining_ty: DefiningTy::Const(def_id, _), .. },\n                             ..\n                         } = self.borrowck_context\n                         {\n@@ -1789,21 +1720,31 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             TerminatorKind::Goto { target } => {\n                 self.assert_iscleanup(body, block_data, target, is_cleanup)\n             }\n-            TerminatorKind::SwitchInt { ref targets, .. } => for target in targets {\n-                self.assert_iscleanup(body, block_data, *target, is_cleanup);\n-            },\n-            TerminatorKind::Resume => if !is_cleanup {\n-                span_mirbug!(self, block_data, \"resume on non-cleanup block!\")\n-            },\n-            TerminatorKind::Abort => if !is_cleanup {\n-                span_mirbug!(self, block_data, \"abort on non-cleanup block!\")\n-            },\n-            TerminatorKind::Return => if is_cleanup {\n-                span_mirbug!(self, block_data, \"return on cleanup block\")\n-            },\n-            TerminatorKind::GeneratorDrop { .. } => if is_cleanup {\n-                span_mirbug!(self, block_data, \"generator_drop in cleanup block\")\n-            },\n+            TerminatorKind::SwitchInt { ref targets, .. } => {\n+                for target in targets {\n+                    self.assert_iscleanup(body, block_data, *target, is_cleanup);\n+                }\n+            }\n+            TerminatorKind::Resume => {\n+                if !is_cleanup {\n+                    span_mirbug!(self, block_data, \"resume on non-cleanup block!\")\n+                }\n+            }\n+            TerminatorKind::Abort => {\n+                if !is_cleanup {\n+                    span_mirbug!(self, block_data, \"abort on non-cleanup block!\")\n+                }\n+            }\n+            TerminatorKind::Return => {\n+                if is_cleanup {\n+                    span_mirbug!(self, block_data, \"return on cleanup block\")\n+                }\n+            }\n+            TerminatorKind::GeneratorDrop { .. } => {\n+                if is_cleanup {\n+                    span_mirbug!(self, block_data, \"generator_drop in cleanup block\")\n+                }\n+            }\n             TerminatorKind::Yield { resume, drop, .. } => {\n                 if is_cleanup {\n                     span_mirbug!(self, block_data, \"yield in cleanup block\")\n@@ -1816,11 +1757,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             TerminatorKind::Unreachable => {}\n             TerminatorKind::Drop { target, unwind, .. }\n             | TerminatorKind::DropAndReplace { target, unwind, .. }\n-            | TerminatorKind::Assert {\n-                target,\n-                cleanup: unwind,\n-                ..\n-            } => {\n+            | TerminatorKind::Assert { target, cleanup: unwind, .. } => {\n                 self.assert_iscleanup(body, block_data, target, is_cleanup);\n                 if let Some(unwind) = unwind {\n                     if is_cleanup {\n@@ -1829,11 +1766,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     self.assert_iscleanup(body, block_data, unwind, true);\n                 }\n             }\n-            TerminatorKind::Call {\n-                ref destination,\n-                cleanup,\n-                ..\n-            } => {\n+            TerminatorKind::Call { ref destination, cleanup, .. } => {\n                 if let &Some((_, target)) = destination {\n                     self.assert_iscleanup(body, block_data, target, is_cleanup);\n                 }\n@@ -1844,25 +1777,15 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     self.assert_iscleanup(body, block_data, cleanup, true);\n                 }\n             }\n-            TerminatorKind::FalseEdges {\n-                real_target,\n-                imaginary_target,\n-            } => {\n+            TerminatorKind::FalseEdges { real_target, imaginary_target } => {\n                 self.assert_iscleanup(body, block_data, real_target, is_cleanup);\n                 self.assert_iscleanup(body, block_data, imaginary_target, is_cleanup);\n             }\n-            TerminatorKind::FalseUnwind {\n-                real_target,\n-                unwind,\n-            } => {\n+            TerminatorKind::FalseUnwind { real_target, unwind } => {\n                 self.assert_iscleanup(body, block_data, real_target, is_cleanup);\n                 if let Some(unwind) = unwind {\n                     if is_cleanup {\n-                        span_mirbug!(\n-                            self,\n-                            block_data,\n-                            \"cleanup in cleanup block via false unwind\"\n-                        );\n+                        span_mirbug!(self, block_data, \"cleanup in cleanup block via false unwind\");\n                     }\n                     self.assert_iscleanup(body, block_data, unwind, true);\n                 }\n@@ -1878,13 +1801,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         iscleanuppad: bool,\n     ) {\n         if body[bb].is_cleanup != iscleanuppad {\n-            span_mirbug!(\n-                self,\n-                ctxt,\n-                \"cleanuppad mismatch: {:?} should be {:?}\",\n-                bb,\n-                iscleanuppad\n-            );\n+            span_mirbug!(self, ctxt, \"cleanuppad mismatch: {:?} should be {:?}\", bb, iscleanuppad);\n         }\n     }\n \n@@ -1958,9 +1875,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 if let Some(field) = variant.fields.get(adj_field_index) {\n                     Ok(self.normalize(field.ty(tcx, substs), location))\n                 } else {\n-                    Err(FieldAccessError::OutOfRange {\n-                        field_count: variant.fields.len(),\n-                    })\n+                    Err(FieldAccessError::OutOfRange { field_count: variant.fields.len() })\n                 }\n             }\n             AggregateKind::Closure(def_id, substs) => {\n@@ -1993,51 +1908,57 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         &mut self,\n         body: ReadOnlyBodyAndCache<'_, 'tcx>,\n         rvalue: &Rvalue<'tcx>,\n-        location: Location)\n-    {\n+        location: Location,\n+    ) {\n         let tcx = self.tcx();\n \n         match rvalue {\n             Rvalue::Aggregate(ak, ops) => {\n                 self.check_aggregate_rvalue(&body, rvalue, ak, ops, location)\n             }\n \n-            Rvalue::Repeat(operand, len) => if *len > 1 {\n-                if let Operand::Move(_) = operand {\n-                    // While this is located in `nll::typeck` this error is not an NLL error, it's\n-                    // a required check to make sure that repeated elements implement `Copy`.\n-                    let span = body.source_info(location).span;\n-                    let ty = operand.ty(*body, tcx);\n-                    if !self.infcx.type_is_copy_modulo_regions(self.param_env, ty, span) {\n-                        // To determine if `const_in_array_repeat_expressions` feature gate should\n-                        // be mentioned, need to check if the rvalue is promotable.\n-                        let should_suggest =\n-                            should_suggest_const_in_array_repeat_expressions_attribute(\n-                                tcx, self.mir_def_id, body, operand);\n-                        debug!(\"check_rvalue: should_suggest={:?}\", should_suggest);\n-\n-                        self.infcx.report_selection_error(\n-                            &traits::Obligation::new(\n-                                ObligationCause::new(\n-                                    span,\n-                                    self.tcx().hir().def_index_to_hir_id(self.mir_def_id.index),\n-                                    traits::ObligationCauseCode::RepeatVec(should_suggest),\n-                                ),\n-                                self.param_env,\n-                                ty::Predicate::Trait(ty::Binder::bind(ty::TraitPredicate {\n-                                    trait_ref: ty::TraitRef::new(\n-                                        self.tcx().lang_items().copy_trait().unwrap(),\n-                                        tcx.mk_substs_trait(ty, &[]),\n+            Rvalue::Repeat(operand, len) => {\n+                if *len > 1 {\n+                    if let Operand::Move(_) = operand {\n+                        // While this is located in `nll::typeck` this error is not an NLL error, it's\n+                        // a required check to make sure that repeated elements implement `Copy`.\n+                        let span = body.source_info(location).span;\n+                        let ty = operand.ty(*body, tcx);\n+                        if !self.infcx.type_is_copy_modulo_regions(self.param_env, ty, span) {\n+                            // To determine if `const_in_array_repeat_expressions` feature gate should\n+                            // be mentioned, need to check if the rvalue is promotable.\n+                            let should_suggest =\n+                                should_suggest_const_in_array_repeat_expressions_attribute(\n+                                    tcx,\n+                                    self.mir_def_id,\n+                                    body,\n+                                    operand,\n+                                );\n+                            debug!(\"check_rvalue: should_suggest={:?}\", should_suggest);\n+\n+                            self.infcx.report_selection_error(\n+                                &traits::Obligation::new(\n+                                    ObligationCause::new(\n+                                        span,\n+                                        self.tcx().hir().def_index_to_hir_id(self.mir_def_id.index),\n+                                        traits::ObligationCauseCode::RepeatVec(should_suggest),\n                                     ),\n-                                })),\n-                            ),\n-                            &traits::SelectionError::Unimplemented,\n-                            false,\n-                            false,\n-                        );\n+                                    self.param_env,\n+                                    ty::Predicate::Trait(ty::Binder::bind(ty::TraitPredicate {\n+                                        trait_ref: ty::TraitRef::new(\n+                                            self.tcx().lang_items().copy_trait().unwrap(),\n+                                            tcx.mk_substs_trait(ty, &[]),\n+                                        ),\n+                                    })),\n+                                ),\n+                                &traits::SelectionError::Unimplemented,\n+                                false,\n+                                false,\n+                            );\n+                        }\n                     }\n                 }\n-            },\n+            }\n \n             Rvalue::NullaryOp(_, ty) => {\n                 // Even with unsized locals cannot box an unsized value.\n@@ -2206,18 +2127,17 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         }\n                     }\n \n-                    CastKind::Pointer(PointerCast::ArrayToPointer)  => {\n+                    CastKind::Pointer(PointerCast::ArrayToPointer) => {\n                         let ty_from = op.ty(*body, tcx);\n \n                         let opt_ty_elem = match ty_from.kind {\n-                            ty::RawPtr(\n-                                ty::TypeAndMut { mutbl: hir::Mutability::Not, ty: array_ty }\n-                            ) => {\n-                                match array_ty.kind {\n-                                    ty::Array(ty_elem, _) => Some(ty_elem),\n-                                    _ => None,\n-                                }\n-                            }\n+                            ty::RawPtr(ty::TypeAndMut {\n+                                mutbl: hir::Mutability::Not,\n+                                ty: array_ty,\n+                            }) => match array_ty.kind {\n+                                ty::Array(ty_elem, _) => Some(ty_elem),\n+                                _ => None,\n+                            },\n                             _ => None,\n                         };\n \n@@ -2235,11 +2155,10 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         };\n \n                         let ty_to = match ty.kind {\n-                            ty::RawPtr(\n-                                ty::TypeAndMut { mutbl: hir::Mutability::Not, ty: ty_to }\n-                            ) => {\n-                                ty_to\n-                            }\n+                            ty::RawPtr(ty::TypeAndMut {\n+                                mutbl: hir::Mutability::Not,\n+                                ty: ty_to,\n+                            }) => ty_to,\n                             _ => {\n                                 span_mirbug!(\n                                     self,\n@@ -2278,13 +2197,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             | (_, Some(CastTy::FnPtr))\n                             | (Some(CastTy::Float), Some(CastTy::Ptr(_)))\n                             | (Some(CastTy::Ptr(_)), Some(CastTy::Float))\n-                            | (Some(CastTy::FnPtr), Some(CastTy::Float)) => span_mirbug!(\n-                                self,\n-                                rvalue,\n-                                \"Invalid cast {:?} -> {:?}\",\n-                                ty_from,\n-                                ty,\n-                            ),\n+                            | (Some(CastTy::FnPtr), Some(CastTy::Float)) => {\n+                                span_mirbug!(self, rvalue, \"Invalid cast {:?} -> {:?}\", ty_from, ty,)\n+                            }\n                             (Some(CastTy::Int(_)), Some(CastTy::Int(_)))\n                             | (Some(CastTy::Float), Some(CastTy::Int(_)))\n                             | (Some(CastTy::Int(_)), Some(CastTy::Float))\n@@ -2312,25 +2227,24 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 let ty_left = left.ty(*body, tcx);\n                 if let ty::RawPtr(_) | ty::FnPtr(_) = ty_left.kind {\n                     let ty_right = right.ty(*body, tcx);\n-                    let common_ty = self.infcx.next_ty_var(\n-                        TypeVariableOrigin {\n-                            kind: TypeVariableOriginKind::MiscVariable,\n-                            span: body.source_info(location).span,\n-                        }\n-                    );\n+                    let common_ty = self.infcx.next_ty_var(TypeVariableOrigin {\n+                        kind: TypeVariableOriginKind::MiscVariable,\n+                        span: body.source_info(location).span,\n+                    });\n                     self.sub_types(\n                         common_ty,\n                         ty_left,\n                         location.to_locations(),\n-                        ConstraintCategory::Boring\n-                    ).unwrap_or_else(|err| {\n+                        ConstraintCategory::Boring,\n+                    )\n+                    .unwrap_or_else(|err| {\n                         bug!(\"Could not equate type variable with {:?}: {:?}\", ty_left, err)\n                     });\n                     if let Err(terr) = self.sub_types(\n                         common_ty,\n                         ty_right,\n                         location.to_locations(),\n-                        ConstraintCategory::Boring\n+                        ConstraintCategory::Boring,\n                     ) {\n                         span_mirbug!(\n                             self,\n@@ -2447,13 +2361,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         borrowed_place: &Place<'tcx>,\n     ) {\n         // These constraints are only meaningful during borrowck:\n-        let BorrowCheckContext {\n-            borrow_set,\n-            location_table,\n-            all_facts,\n-            constraints,\n-            ..\n-        } = self.borrowck_context;\n+        let BorrowCheckContext { borrow_set, location_table, all_facts, constraints, .. } =\n+            self.borrowck_context;\n \n         // In Polonius mode, we also push a `borrow_region` fact\n         // linking the loan to the region (in some cases, though,\n@@ -2646,25 +2555,20 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                 &closure_region_requirements.outlives_requirements[idx];\n                             Some((\n                                 (r1_vid, r2_vid),\n-                                (\n-                                    outlives_requirements.category,\n-                                    outlives_requirements.blame_span,\n-                                ),\n+                                (outlives_requirements.category, outlives_requirements.blame_span),\n                             ))\n                         }\n                         GenericArgKind::Type(_) | GenericArgKind::Const(_) => None,\n                     }\n                 })\n                 .collect();\n \n-            let existing = self.borrowck_context\n+            let existing = self\n+                .borrowck_context\n                 .constraints\n                 .closure_bounds_mapping\n                 .insert(location, bounds_mapping);\n-            assert!(\n-                existing.is_none(),\n-                \"Multiple closures at the same location.\"\n-            );\n+            assert!(existing.is_none(), \"Multiple closures at the same location.\");\n \n             self.push_region_constraints(\n                 location.to_locations(),\n@@ -2683,9 +2587,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         category: ConstraintCategory,\n     ) {\n         self.prove_predicates(\n-            Some(ty::Predicate::Trait(\n-                trait_ref.to_poly_trait_ref().to_poly_trait_predicate(),\n-            )),\n+            Some(ty::Predicate::Trait(trait_ref.to_poly_trait_ref().to_poly_trait_predicate())),\n             locations,\n             category,\n         );\n@@ -2709,10 +2611,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         category: ConstraintCategory,\n     ) {\n         for predicate in predicates {\n-            debug!(\n-                \"prove_predicates(predicate={:?}, locations={:?})\",\n-                predicate, locations,\n-            );\n+            debug!(\"prove_predicates(predicate={:?}, locations={:?})\", predicate, locations,);\n \n             self.prove_predicate(predicate, locations, category);\n         }\n@@ -2724,17 +2623,15 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         locations: Locations,\n         category: ConstraintCategory,\n     ) {\n-        debug!(\n-            \"prove_predicate(predicate={:?}, location={:?})\",\n-            predicate, locations,\n-        );\n+        debug!(\"prove_predicate(predicate={:?}, location={:?})\", predicate, locations,);\n \n         let param_env = self.param_env;\n         self.fully_perform_op(\n             locations,\n             category,\n             param_env.and(type_op::prove_predicate::ProvePredicate::new(predicate)),\n-        ).unwrap_or_else(|NoSolution| {\n+        )\n+        .unwrap_or_else(|NoSolution| {\n             span_mirbug!(self, NoSolution, \"could not prove {:?}\", predicate);\n         })\n     }\n@@ -2748,10 +2645,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         }\n \n         for (block, block_data) in body.basic_blocks().iter_enumerated() {\n-            let mut location = Location {\n-                block,\n-                statement_index: 0,\n-            };\n+            let mut location = Location { block, statement_index: 0 };\n             for stmt in &block_data.statements {\n                 if !stmt.source_info.span.is_dummy() {\n                     self.last_span = stmt.source_info.span;\n@@ -2775,7 +2669,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             location.to_locations(),\n             ConstraintCategory::Boring,\n             param_env.and(type_op::normalize::Normalize::new(value)),\n-        ).unwrap_or_else(|NoSolution| {\n+        )\n+        .unwrap_or_else(|NoSolution| {\n             span_mirbug!(self, NoSolution, \"failed to normalize `{:?}`\", value);\n             value\n         })"}, {"sha": "ee218d84cd8b56dc70f3584b9fed982a7a85bc53", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 25, "deletions": 77, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d", "patch": "@@ -46,25 +46,16 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         scope: Option<region::Scope>,\n         expr: Expr<'tcx>,\n     ) -> BlockAnd<Rvalue<'tcx>> {\n-        debug!(\n-            \"expr_as_rvalue(block={:?}, scope={:?}, expr={:?})\",\n-            block, scope, expr\n-        );\n+        debug!(\"expr_as_rvalue(block={:?}, scope={:?}, expr={:?})\", block, scope, expr);\n \n         let this = self;\n         let expr_span = expr.span;\n         let source_info = this.source_info(expr_span);\n \n         match expr.kind {\n-            ExprKind::Scope {\n-                region_scope,\n-                lint_level,\n-                value,\n-            } => {\n+            ExprKind::Scope { region_scope, lint_level, value } => {\n                 let region_scope = (region_scope, source_info);\n-                this.in_scope(region_scope, lint_level, |this| {\n-                    this.as_rvalue(block, scope, value)\n-                })\n+                this.in_scope(region_scope, lint_level, |this| this.as_rvalue(block, scope, value))\n             }\n             ExprKind::Repeat { value, count } => {\n                 let value_operand = unpack!(block = this.as_operand(block, scope, value));\n@@ -106,35 +97,26 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // The `Box<T>` temporary created here is not a part of the HIR,\n                 // and therefore is not considered during generator OIBIT\n                 // determination. See the comment about `box` at `yield_in_scope`.\n-                let result = this\n-                    .local_decls\n-                    .push(LocalDecl::new_internal(expr.ty, expr_span));\n+                let result = this.local_decls.push(LocalDecl::new_internal(expr.ty, expr_span));\n                 this.cfg.push(\n                     block,\n-                    Statement {\n-                        source_info,\n-                        kind: StatementKind::StorageLive(result),\n-                    },\n+                    Statement { source_info, kind: StatementKind::StorageLive(result) },\n                 );\n                 if let Some(scope) = scope {\n                     // schedule a shallow free of that memory, lest we unwind:\n-                    this.schedule_drop_storage_and_value(\n-                        expr_span,\n-                        scope,\n-                        result,\n-                    );\n+                    this.schedule_drop_storage_and_value(expr_span, scope, result);\n                 }\n \n                 // malloc some memory of suitable type (thus far, uninitialized):\n                 let box_ = Rvalue::NullaryOp(NullOp::Box, value.ty);\n-                this.cfg\n-                    .push_assign(block, source_info, &Place::from(result), box_);\n+                this.cfg.push_assign(block, source_info, &Place::from(result), box_);\n \n                 // initialize the box contents:\n                 unpack!(\n                     block = this.into(\n                         &this.hir.tcx().mk_place_deref(Place::from(result)),\n-                        block, value\n+                        block,\n+                        value\n                     )\n                 );\n                 block.and(Rvalue::Use(Operand::Move(Place::from(result))))\n@@ -193,12 +175,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                 block.and(Rvalue::Aggregate(box AggregateKind::Tuple, fields))\n             }\n-            ExprKind::Closure {\n-                closure_id,\n-                substs,\n-                upvars,\n-                movability,\n-            } => {\n+            ExprKind::Closure { closure_id, substs, upvars, movability } => {\n                 // see (*) above\n                 let operands: Vec<_> = upvars\n                     .into_iter()\n@@ -225,9 +202,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                 match upvar.kind {\n                                     ExprKind::Borrow {\n                                         borrow_kind:\n-                                            BorrowKind::Mut {\n-                                                allow_two_phase_borrow: false,\n-                                            },\n+                                            BorrowKind::Mut { allow_two_phase_borrow: false },\n                                         arg,\n                                     } => unpack!(\n                                         block = this.limit_capture_mutability(\n@@ -238,7 +213,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                 }\n                             }\n                         }\n-                    }).collect();\n+                    })\n+                    .collect();\n                 let result = match substs {\n                     UpvarSubsts::Generator(substs) => {\n                         // We implicitly set the discriminant to 0. See\n@@ -261,11 +237,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 this.cfg.terminate(\n                     block,\n                     source_info,\n-                    TerminatorKind::Yield {\n-                        value: value,\n-                        resume: resume,\n-                        drop: cleanup,\n-                    },\n+                    TerminatorKind::Yield { value: value, resume: resume, drop: cleanup },\n                 );\n                 resume.and(this.unit_rvalue())\n             }\n@@ -414,29 +386,17 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let this = self;\n \n         let source_info = this.source_info(upvar_span);\n-        let temp = this\n-            .local_decls\n-            .push(LocalDecl::new_temp(upvar_ty, upvar_span));\n+        let temp = this.local_decls.push(LocalDecl::new_temp(upvar_ty, upvar_span));\n \n-        this.cfg.push(\n-            block,\n-            Statement {\n-                source_info,\n-                kind: StatementKind::StorageLive(temp),\n-            },\n-        );\n+        this.cfg.push(block, Statement { source_info, kind: StatementKind::StorageLive(temp) });\n \n         let arg_place = unpack!(block = this.as_place(block, arg));\n \n         let mutability = match arg_place.as_ref() {\n-            PlaceRef {\n-                base: &PlaceBase::Local(local),\n-                projection: &[],\n-            } => this.local_decls[local].mutability,\n-            PlaceRef {\n-                base: &PlaceBase::Local(local),\n-                projection: &[ProjectionElem::Deref],\n-            } => {\n+            PlaceRef { base: &PlaceBase::Local(local), projection: &[] } => {\n+                this.local_decls[local].mutability\n+            }\n+            PlaceRef { base: &PlaceBase::Local(local), projection: &[ProjectionElem::Deref] } => {\n                 debug_assert!(\n                     this.local_decls[local].is_ref_for_guard(),\n                     \"Unexpected capture place\",\n@@ -449,16 +409,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n             | PlaceRef {\n                 ref base,\n-                projection: &[\n-                    ref proj_base @ ..,\n-                    ProjectionElem::Field(upvar_index, _),\n-                    ProjectionElem::Deref\n-                ],\n+                projection:\n+                    &[ref proj_base @ .., ProjectionElem::Field(upvar_index, _), ProjectionElem::Deref],\n             } => {\n-                let place = PlaceRef {\n-                    base,\n-                    projection: proj_base,\n-                };\n+                let place = PlaceRef { base, projection: proj_base };\n \n                 // Not projected from the implicit `self` in a closure.\n                 debug_assert!(\n@@ -480,9 +434,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         let borrow_kind = match mutability {\n             Mutability::Not => BorrowKind::Unique,\n-            Mutability::Mut => BorrowKind::Mut {\n-                allow_two_phase_borrow: false,\n-            },\n+            Mutability::Mut => BorrowKind::Mut { allow_two_phase_borrow: false },\n         };\n \n         this.cfg.push_assign(\n@@ -496,11 +448,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // anything because no values with a destructor can be created in\n         // a constant at this time, even if the type may need dropping.\n         if let Some(temp_lifetime) = temp_lifetime {\n-            this.schedule_drop_storage_and_value(\n-                upvar_span,\n-                temp_lifetime,\n-                temp,\n-            );\n+            this.schedule_drop_storage_and_value(upvar_span, temp_lifetime, temp);\n         }\n \n         block.and(Operand::Move(Place::from(temp)))"}, {"sha": "e1a51e2fb35e51d92decbaa905c1d16f53ebc972", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 169, "deletions": 281, "changes": 450, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d", "patch": "@@ -11,13 +11,13 @@ use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n use crate::hair::{self, *};\n use rustc::hir::HirId;\n-use rustc::mir::*;\n use rustc::middle::region;\n-use rustc::ty::{self, CanonicalUserTypeAnnotation, Ty};\n+use rustc::mir::*;\n use rustc::ty::layout::VariantIdx;\n-use rustc_index::bit_set::BitSet;\n+use rustc::ty::{self, CanonicalUserTypeAnnotation, Ty};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use smallvec::{SmallVec, smallvec};\n+use rustc_index::bit_set::BitSet;\n+use smallvec::{smallvec, SmallVec};\n use syntax::ast::Name;\n use syntax_pos::Span;\n \n@@ -139,9 +139,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         // create binding start block for link them by false edges\n         let candidate_count = arms.iter().map(|c| c.top_pats_hack().len()).sum::<usize>();\n-        let pre_binding_blocks: Vec<_> = (0..candidate_count)\n-            .map(|_| self.cfg.start_new_block())\n-            .collect();\n+        let pre_binding_blocks: Vec<_> =\n+            (0..candidate_count).map(|_| self.cfg.start_new_block()).collect();\n \n         let mut match_has_guard = false;\n \n@@ -155,29 +154,25 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             .map(|arm| {\n                 let arm_has_guard = arm.guard.is_some();\n                 match_has_guard |= arm_has_guard;\n-                let arm_candidates: Vec<_> = arm.top_pats_hack()\n+                let arm_candidates: Vec<_> = arm\n+                    .top_pats_hack()\n                     .iter()\n                     .zip(candidate_pre_binding_blocks.by_ref())\n-                    .map(\n-                        |(pattern, pre_binding_block)| {\n-                            Candidate {\n-                                span: pattern.span,\n-                                match_pairs: smallvec![\n-                                    MatchPair::new(scrutinee_place.clone(), pattern),\n-                                ],\n-                                bindings: vec![],\n-                                ascriptions: vec![],\n-                                otherwise_block: if arm_has_guard {\n-                                    Some(self.cfg.start_new_block())\n-                                } else {\n-                                    None\n-                                },\n-                                pre_binding_block: *pre_binding_block,\n-                                next_candidate_pre_binding_block:\n-                                    next_candidate_pre_binding_blocks.next().copied(),\n-                            }\n+                    .map(|(pattern, pre_binding_block)| Candidate {\n+                        span: pattern.span,\n+                        match_pairs: smallvec![MatchPair::new(scrutinee_place.clone(), pattern),],\n+                        bindings: vec![],\n+                        ascriptions: vec![],\n+                        otherwise_block: if arm_has_guard {\n+                            Some(self.cfg.start_new_block())\n+                        } else {\n+                            None\n                         },\n-                    )\n+                        pre_binding_block: *pre_binding_block,\n+                        next_candidate_pre_binding_block: next_candidate_pre_binding_blocks\n+                            .next()\n+                            .copied(),\n+                    })\n                     .collect();\n                 (arm, arm_candidates)\n             })\n@@ -226,50 +221,53 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // Step 5. Create everything else: the guards and the arms.\n         let match_scope = self.scopes.topmost();\n \n-        let arm_end_blocks: Vec<_> = arm_candidates.into_iter().map(|(arm, mut candidates)| {\n-            let arm_source_info = self.source_info(arm.span);\n-            let arm_scope = (arm.scope, arm_source_info);\n-            self.in_scope(arm_scope, arm.lint_level, |this| {\n-                let body = this.hir.mirror(arm.body.clone());\n-                let scope = this.declare_bindings(\n-                    None,\n-                    arm.span,\n-                    &arm.top_pats_hack()[0],\n-                    ArmHasGuard(arm.guard.is_some()),\n-                    Some((Some(&scrutinee_place), scrutinee_span)),\n-                );\n-\n-                let arm_block;\n-                if candidates.len() == 1 {\n-                    arm_block = this.bind_and_guard_matched_candidate(\n-                        candidates.pop().unwrap(),\n-                        arm.guard.clone(),\n-                        &fake_borrow_temps,\n-                        scrutinee_span,\n-                        match_scope,\n+        let arm_end_blocks: Vec<_> = arm_candidates\n+            .into_iter()\n+            .map(|(arm, mut candidates)| {\n+                let arm_source_info = self.source_info(arm.span);\n+                let arm_scope = (arm.scope, arm_source_info);\n+                self.in_scope(arm_scope, arm.lint_level, |this| {\n+                    let body = this.hir.mirror(arm.body.clone());\n+                    let scope = this.declare_bindings(\n+                        None,\n+                        arm.span,\n+                        &arm.top_pats_hack()[0],\n+                        ArmHasGuard(arm.guard.is_some()),\n+                        Some((Some(&scrutinee_place), scrutinee_span)),\n                     );\n-                } else {\n-                    arm_block = this.cfg.start_new_block();\n-                    for candidate in candidates {\n-                        this.clear_top_scope(arm.scope);\n-                        let binding_end = this.bind_and_guard_matched_candidate(\n-                            candidate,\n+\n+                    let arm_block;\n+                    if candidates.len() == 1 {\n+                        arm_block = this.bind_and_guard_matched_candidate(\n+                            candidates.pop().unwrap(),\n                             arm.guard.clone(),\n                             &fake_borrow_temps,\n                             scrutinee_span,\n                             match_scope,\n                         );\n-                        this.cfg.goto(binding_end, source_info, arm_block);\n+                    } else {\n+                        arm_block = this.cfg.start_new_block();\n+                        for candidate in candidates {\n+                            this.clear_top_scope(arm.scope);\n+                            let binding_end = this.bind_and_guard_matched_candidate(\n+                                candidate,\n+                                arm.guard.clone(),\n+                                &fake_borrow_temps,\n+                                scrutinee_span,\n+                                match_scope,\n+                            );\n+                            this.cfg.goto(binding_end, source_info, arm_block);\n+                        }\n                     }\n-                }\n \n-                if let Some(source_scope) = scope {\n-                    this.source_scope = source_scope;\n-                }\n+                    if let Some(source_scope) = scope {\n+                        this.source_scope = source_scope;\n+                    }\n \n-                this.into(destination, arm_block, body)\n+                    this.into(destination, arm_block, body)\n+                })\n             })\n-        }).collect();\n+            .collect();\n \n         // all the arm blocks will rejoin here\n         let end_block = self.cfg.start_new_block();\n@@ -291,12 +289,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ) -> BlockAnd<()> {\n         match *irrefutable_pat.kind {\n             // Optimize the case of `let x = ...` to write directly into `x`\n-            PatKind::Binding {\n-                mode: BindingMode::ByValue,\n-                var,\n-                subpattern: None,\n-                ..\n-            } => {\n+            PatKind::Binding { mode: BindingMode::ByValue, var, subpattern: None, .. } => {\n                 let place =\n                     self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard);\n                 unpack!(block = self.into(&place, block, initializer));\n@@ -318,20 +311,19 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // dubious way, so it may be that the test is kind of\n             // broken.\n             PatKind::AscribeUserType {\n-                subpattern: Pat {\n-                    kind: box PatKind::Binding {\n-                        mode: BindingMode::ByValue,\n-                        var,\n-                        subpattern: None,\n+                subpattern:\n+                    Pat {\n+                        kind:\n+                            box PatKind::Binding {\n+                                mode: BindingMode::ByValue,\n+                                var,\n+                                subpattern: None,\n+                                ..\n+                            },\n                         ..\n                     },\n-                    ..\n-                },\n-                ascription: hair::pattern::Ascription {\n-                    user_ty: pat_ascription_ty,\n-                    variance: _,\n-                    user_ty_span,\n-                },\n+                ascription:\n+                    hair::pattern::Ascription { user_ty: pat_ascription_ty, variance: _, user_ty_span },\n             } => {\n                 let place =\n                     self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard);\n@@ -353,10 +345,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     Statement {\n                         source_info: ty_source_info,\n                         kind: StatementKind::AscribeUserType(\n-                            box(\n-                                place,\n-                                user_ty,\n-                            ),\n+                            box (place, user_ty),\n                             // We always use invariant as the variance here. This is because the\n                             // variance field from the ascription refers to the variance to use\n                             // when applying the type to the value being matched, but this\n@@ -504,13 +493,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ) -> Place<'tcx> {\n         let local_id = self.var_local_id(var, for_guard);\n         let source_info = self.source_info(span);\n-        self.cfg.push(\n-            block,\n-            Statement {\n-                source_info,\n-                kind: StatementKind::StorageLive(local_id),\n-            },\n-        );\n+        self.cfg.push(block, Statement { source_info, kind: StatementKind::StorageLive(local_id) });\n         let region_scope = self.hir.region_scope_tree.var_scope(var.local_id);\n         self.schedule_drop(span, region_scope, local_id, DropKind::Storage);\n         Place::from(local_id)\n@@ -519,12 +502,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub fn schedule_drop_for_binding(&mut self, var: HirId, span: Span, for_guard: ForGuard) {\n         let local_id = self.var_local_id(var, for_guard);\n         let region_scope = self.hir.region_scope_tree.var_scope(var.local_id);\n-        self.schedule_drop(\n-            span,\n-            region_scope,\n-            local_id,\n-            DropKind::Value,\n-        );\n+        self.schedule_drop(span, region_scope, local_id, DropKind::Value);\n     }\n \n     pub(super) fn visit_bindings(\n@@ -544,31 +522,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ) {\n         debug!(\"visit_bindings: pattern={:?} pattern_user_ty={:?}\", pattern, pattern_user_ty);\n         match *pattern.kind {\n-            PatKind::Binding {\n-                mutability,\n-                name,\n-                mode,\n-                var,\n-                ty,\n-                ref subpattern,\n-                ..\n-            } => {\n+            PatKind::Binding { mutability, name, mode, var, ty, ref subpattern, .. } => {\n                 f(self, mutability, name, mode, var, pattern.span, ty, pattern_user_ty.clone());\n                 if let Some(subpattern) = subpattern.as_ref() {\n                     self.visit_bindings(subpattern, pattern_user_ty, f);\n                 }\n             }\n \n-            PatKind::Array {\n-                ref prefix,\n-                ref slice,\n-                ref suffix,\n-            }\n-            | PatKind::Slice {\n-                ref prefix,\n-                ref slice,\n-                ref suffix,\n-            } => {\n+            PatKind::Array { ref prefix, ref slice, ref suffix }\n+            | PatKind::Slice { ref prefix, ref slice, ref suffix } => {\n                 let from = u32::try_from(prefix.len()).unwrap();\n                 let to = u32::try_from(suffix.len()).unwrap();\n                 for subpattern in prefix {\n@@ -590,11 +552,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             PatKind::AscribeUserType {\n                 ref subpattern,\n-                ascription: hair::pattern::Ascription {\n-                    ref user_ty,\n-                    user_ty_span,\n-                    variance: _,\n-                },\n+                ascription: hair::pattern::Ascription { ref user_ty, user_ty_span, variance: _ },\n             } => {\n                 // This corresponds to something like\n                 //\n@@ -627,8 +585,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             PatKind::Variant { adt_def, substs: _, variant_index, ref subpatterns } => {\n                 for subpattern in subpatterns {\n-                    let subpattern_user_ty = pattern_user_ty.clone().variant(\n-                        adt_def, variant_index, subpattern.field);\n+                    let subpattern_user_ty =\n+                        pattern_user_ty.clone().variant(adt_def, variant_index, subpattern.field);\n                     self.visit_bindings(&subpattern.pattern, subpattern_user_ty, f);\n                 }\n             }\n@@ -736,10 +694,7 @@ enum TestKind<'tcx> {\n     Range(PatRange<'tcx>),\n \n     /// Test length of the slice is equal to len\n-    Len {\n-        len: u64,\n-        op: BinOp,\n-    },\n+    Len { len: u64, op: BinOp },\n }\n \n #[derive(Debug)]\n@@ -789,10 +744,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ) {\n         debug!(\n             \"matched_candidate(span={:?}, candidates={:?}, start_block={:?}, otherwise_block={:?})\",\n-            span,\n-            candidates,\n-            start_block,\n-            otherwise_block,\n+            span, candidates, start_block, otherwise_block,\n         );\n \n         // Start by simplifying candidates. Once this process is complete, all\n@@ -805,22 +757,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // The candidates are sorted by priority. Check to see whether the\n         // higher priority candidates (and hence at the front of the slice)\n         // have satisfied all their match pairs.\n-        let fully_matched = candidates\n-            .iter()\n-            .take_while(|c| c.match_pairs.is_empty())\n-            .count();\n-        debug!(\n-            \"match_candidates: {:?} candidates fully matched\",\n-            fully_matched\n-        );\n+        let fully_matched = candidates.iter().take_while(|c| c.match_pairs.is_empty()).count();\n+        debug!(\"match_candidates: {:?} candidates fully matched\", fully_matched);\n         let (matched_candidates, unmatched_candidates) = candidates.split_at_mut(fully_matched);\n \n         let block: BasicBlock = if !matched_candidates.is_empty() {\n-            let otherwise_block = self.select_matched_candidates(\n-                matched_candidates,\n-                start_block,\n-                fake_borrows,\n-            );\n+            let otherwise_block =\n+                self.select_matched_candidates(matched_candidates, start_block, fake_borrows);\n \n             if let Some(last_otherwise_block) = otherwise_block {\n                 last_otherwise_block\n@@ -848,13 +791,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n \n         // Test for the remaining candidates.\n-        self.test_candidates(\n-            span,\n-            unmatched_candidates,\n-            block,\n-            otherwise_block,\n-            fake_borrows,\n-        );\n+        self.test_candidates(span, unmatched_candidates, block, otherwise_block, fake_borrows);\n     }\n \n     /// Link up matched candidates. For example, if we have something like\n@@ -903,8 +840,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         //     _ => 3,\n         // }\n         if let Some(fake_borrows) = fake_borrows {\n-            for Binding { source, .. }\n-                in matched_candidates.iter().flat_map(|candidate| &candidate.bindings)\n+            for Binding { source, .. } in\n+                matched_candidates.iter().flat_map(|candidate| &candidate.bindings)\n             {\n                 if let Some(i) =\n                     source.projection.iter().rposition(|elem| *elem == ProjectionElem::Deref)\n@@ -924,8 +861,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             .position(|c| c.otherwise_block.is_none())\n             .unwrap_or(matched_candidates.len() - 1);\n \n-        let (reachable_candidates, unreachable_candidates)\n-            = matched_candidates.split_at_mut(fully_matched_with_guard + 1);\n+        let (reachable_candidates, unreachable_candidates) =\n+            matched_candidates.split_at_mut(fully_matched_with_guard + 1);\n \n         let first_candidate = &reachable_candidates[0];\n         let first_prebinding_block = first_candidate.pre_binding_block;\n@@ -967,7 +904,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n         }\n \n-\n         let last_candidate = reachable_candidates.last().unwrap();\n         if let Some(otherwise) = last_candidate.otherwise_block {\n             let source_info = self.source_info(last_candidate.span);\n@@ -1114,11 +1050,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // may want to add cases based on the candidates that are\n         // available\n         match test.kind {\n-            TestKind::SwitchInt {\n-                switch_ty,\n-                ref mut options,\n-                ref mut indices,\n-            } => {\n+            TestKind::SwitchInt { switch_ty, ref mut options, ref mut indices } => {\n                 for candidate in candidates.iter() {\n                     if !self.add_cases_to_switch(\n                         &match_place,\n@@ -1131,10 +1063,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     }\n                 }\n             }\n-            TestKind::Switch {\n-                adt_def: _,\n-                ref mut variants,\n-            } => {\n+            TestKind::Switch { adt_def: _, ref mut variants } => {\n                 for candidate in candidates.iter() {\n                     if !self.add_variants_to_switch(&match_place, candidate, variants) {\n                         break;\n@@ -1145,18 +1074,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n \n         // Insert a Shallow borrow of any places that is switched on.\n-        fake_borrows.as_mut().map(|fb| {\n-            fb.insert(match_place.clone())\n-        });\n+        fake_borrows.as_mut().map(|fb| fb.insert(match_place.clone()));\n \n         // perform the test, branching to one of N blocks. For each of\n         // those N possible outcomes, create a (initially empty)\n         // vector of candidates. Those are the candidates that still\n         // apply if the test has that particular outcome.\n-        debug!(\n-            \"match_candidates: test={:?} match_pair={:?}\",\n-            test, match_pair\n-        );\n+        debug!(\"match_candidates: test={:?} match_pair={:?}\", test, match_pair);\n         let mut target_candidates: Vec<Vec<&mut Candidate<'pat, 'tcx>>> = vec![];\n         target_candidates.resize_with(test.targets(), Default::default);\n \n@@ -1201,38 +1125,36 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 otherwise_block = Some(remainder_start.unwrap());\n             };\n \n-            target_candidates.into_iter().map(|mut candidates| {\n-                if candidates.len() != 0 {\n-                    let candidate_start = &mut None;\n-                    this.match_candidates(\n-                        span,\n-                        candidate_start,\n-                        otherwise_block,\n-                        &mut *candidates,\n-                        fake_borrows,\n-                    );\n-                    candidate_start.unwrap()\n-                } else {\n-                    *otherwise_block.get_or_insert_with(|| {\n-                        let unreachable = this.cfg.start_new_block();\n-                        let source_info = this.source_info(span);\n-                        this.cfg.terminate(\n-                            unreachable,\n-                            source_info,\n-                            TerminatorKind::Unreachable,\n+            target_candidates\n+                .into_iter()\n+                .map(|mut candidates| {\n+                    if candidates.len() != 0 {\n+                        let candidate_start = &mut None;\n+                        this.match_candidates(\n+                            span,\n+                            candidate_start,\n+                            otherwise_block,\n+                            &mut *candidates,\n+                            fake_borrows,\n                         );\n-                        unreachable\n-                    })\n-                }\n-            }).collect()\n+                        candidate_start.unwrap()\n+                    } else {\n+                        *otherwise_block.get_or_insert_with(|| {\n+                            let unreachable = this.cfg.start_new_block();\n+                            let source_info = this.source_info(span);\n+                            this.cfg.terminate(\n+                                unreachable,\n+                                source_info,\n+                                TerminatorKind::Unreachable,\n+                            );\n+                            unreachable\n+                        })\n+                    }\n+                })\n+                .collect()\n         };\n \n-        self.perform_test(\n-            block,\n-            &match_place,\n-            &test,\n-            make_target_blocks,\n-        );\n+        self.perform_test(block, &match_place, &test, make_target_blocks);\n     }\n \n     // Determine the fake borrows that are needed to ensure that the place\n@@ -1249,8 +1171,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let mut all_fake_borrows = Vec::with_capacity(fake_borrows.len());\n \n         // Insert a Shallow borrow of the prefixes of any fake borrows.\n-        for place in fake_borrows\n-        {\n+        for place in fake_borrows {\n             let mut cursor = place.projection.as_ref();\n             while let [proj_base @ .., elem] = cursor {\n                 cursor = proj_base;\n@@ -1259,10 +1180,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     // Insert a shallow borrow after a deref. For other\n                     // projections the borrow of prefix_cursor will\n                     // conflict with any mutation of base.\n-                    all_fake_borrows.push(PlaceRef {\n-                        base: &place.base,\n-                        projection: proj_base,\n-                    });\n+                    all_fake_borrows.push(PlaceRef { base: &place.base, projection: proj_base });\n                 }\n             }\n \n@@ -1275,21 +1193,23 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         debug!(\"add_fake_borrows all_fake_borrows = {:?}\", all_fake_borrows);\n \n-        all_fake_borrows.into_iter().map(|matched_place| {\n-            let fake_borrow_deref_ty = Place::ty_from(\n-                matched_place.base,\n-                matched_place.projection,\n-                &self.local_decls,\n-                tcx,\n-            )\n-            .ty;\n-            let fake_borrow_ty = tcx.mk_imm_ref(tcx.lifetimes.re_erased, fake_borrow_deref_ty);\n-            let fake_borrow_temp = self.local_decls.push(\n-                LocalDecl::new_temp(fake_borrow_ty, temp_span)\n-            );\n-\n-            (matched_place, fake_borrow_temp)\n-        }).collect()\n+        all_fake_borrows\n+            .into_iter()\n+            .map(|matched_place| {\n+                let fake_borrow_deref_ty = Place::ty_from(\n+                    matched_place.base,\n+                    matched_place.projection,\n+                    &self.local_decls,\n+                    tcx,\n+                )\n+                .ty;\n+                let fake_borrow_ty = tcx.mk_imm_ref(tcx.lifetimes.re_erased, fake_borrow_deref_ty);\n+                let fake_borrow_temp =\n+                    self.local_decls.push(LocalDecl::new_temp(fake_borrow_ty, temp_span));\n+\n+                (matched_place, fake_borrow_temp)\n+            })\n+            .collect()\n     }\n }\n \n@@ -1424,10 +1344,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         if let Some(guard) = guard {\n             let tcx = self.hir.tcx();\n \n-            self.bind_matched_candidate_for_guard(\n-                block,\n-                &candidate.bindings,\n-            );\n+            self.bind_matched_candidate_for_guard(block, &candidate.bindings);\n             let guard_frame = GuardFrame {\n                 locals: candidate\n                     .bindings\n@@ -1449,12 +1366,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         projection: tcx.intern_place_elems(place.projection),\n                     },\n                 );\n-                self.cfg.push_assign(\n-                    block,\n-                    scrutinee_source_info,\n-                    &Place::from(*temp),\n-                    borrow,\n-                );\n+                self.cfg.push_assign(block, scrutinee_source_info, &Place::from(*temp), borrow);\n             }\n \n             // the block to branch to if the guard fails; if there is no\n@@ -1464,13 +1376,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             };\n             let source_info = self.source_info(guard.span);\n             let guard_end = self.source_info(tcx.sess.source_map().end_point(guard.span));\n-            let (post_guard_block, otherwise_post_guard_block)\n-                = self.test_bool(block, guard, source_info);\n+            let (post_guard_block, otherwise_post_guard_block) =\n+                self.test_bool(block, guard, source_info);\n             let guard_frame = self.guard_context.pop().unwrap();\n-            debug!(\n-                \"Exiting guard building context with locals: {:?}\",\n-                guard_frame\n-            );\n+            debug!(\"Exiting guard building context with locals: {:?}\", guard_frame);\n \n             for &(_, temp) in fake_borrows {\n                 let cause = FakeReadCause::ForMatchGuard;\n@@ -1520,10 +1429,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let cause = FakeReadCause::ForGuardBinding;\n                 self.cfg.push_fake_read(post_guard_block, guard_end, cause, Place::from(local_id));\n             }\n-            self.bind_matched_candidate_for_arm_body(\n-                post_guard_block,\n-                by_value_bindings,\n-            );\n+            self.bind_matched_candidate_for_arm_body(post_guard_block, by_value_bindings);\n \n             post_guard_block\n         } else {\n@@ -1544,37 +1450,28 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             debug!(\n                 \"adding user ascription at span {:?} of place {:?} and {:?}\",\n-                source_info.span,\n-                ascription.source,\n-                ascription.user_ty,\n+                source_info.span, ascription.source, ascription.user_ty,\n             );\n \n             let user_ty = ascription.user_ty.clone().user_ty(\n                 &mut self.canonical_user_type_annotations,\n                 ascription.source.ty(&self.local_decls, self.hir.tcx()).ty,\n-                source_info.span\n+                source_info.span,\n             );\n             self.cfg.push(\n                 block,\n                 Statement {\n                     source_info,\n                     kind: StatementKind::AscribeUserType(\n-                        box(\n-                            ascription.source.clone(),\n-                            user_ty,\n-                        ),\n+                        box (ascription.source.clone(), user_ty),\n                         ascription.variance,\n                     ),\n                 },\n             );\n         }\n     }\n \n-    fn bind_matched_candidate_for_guard(\n-        &mut self,\n-        block: BasicBlock,\n-        bindings: &[Binding<'tcx>],\n-    ) {\n+    fn bind_matched_candidate_for_guard(&mut self, block: BasicBlock, bindings: &[Binding<'tcx>]) {\n         debug!(\"bind_matched_candidate_for_guard(block={:?}, bindings={:?})\", block, bindings);\n \n         // Assign each of the bindings. Since we are binding for a\n@@ -1593,8 +1490,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             match binding.binding_mode {\n                 BindingMode::ByValue => {\n                     let rvalue = Rvalue::Ref(re_erased, BorrowKind::Shared, binding.source.clone());\n-                    self.cfg\n-                        .push_assign(block, source_info, &ref_for_guard, rvalue);\n+                    self.cfg.push_assign(block, source_info, &ref_for_guard, rvalue);\n                 }\n                 BindingMode::ByRef(borrow_kind) => {\n                     let value_for_arm = self.storage_live_binding(\n@@ -1605,11 +1501,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     );\n \n                     let rvalue = Rvalue::Ref(re_erased, borrow_kind, binding.source.clone());\n-                    self.cfg\n-                        .push_assign(block, source_info, &value_for_arm, rvalue);\n+                    self.cfg.push_assign(block, source_info, &value_for_arm, rvalue);\n                     let rvalue = Rvalue::Ref(re_erased, BorrowKind::Shared, value_for_arm);\n-                    self.cfg\n-                        .push_assign(block, source_info, &ref_for_guard, rvalue);\n+                    self.cfg.push_assign(block, source_info, &ref_for_guard, rvalue);\n                 }\n             }\n         }\n@@ -1619,7 +1513,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         block: BasicBlock,\n         bindings: impl IntoIterator<Item = &'b Binding<'tcx>>,\n-    ) where 'tcx: 'b {\n+    ) where\n+        'tcx: 'b,\n+    {\n         debug!(\"bind_matched_candidate_for_arm_body(block={:?})\", block);\n \n         let re_erased = self.hir.tcx().lifetimes.re_erased;\n@@ -1667,10 +1563,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         );\n \n         let tcx = self.hir.tcx();\n-        let debug_source_info = SourceInfo {\n-            span: source_info.span,\n-            scope: visibility_scope,\n-        };\n+        let debug_source_info = SourceInfo { span: source_info.span, scope: visibility_scope };\n         let binding_mode = match mode {\n             BindingMode::ByValue => ty::BindingMode::BindByValue(mutability.into()),\n             BindingMode::ByRef(_) => ty::BindingMode::BindByReference(mutability.into()),\n@@ -1683,18 +1576,16 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             source_info,\n             internal: false,\n             is_block_tail: None,\n-            local_info: LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n-                VarBindingForm {\n-                    binding_mode,\n-                    // hypothetically, `visit_bindings` could try to unzip\n-                    // an outermost hir::Ty as we descend, matching up\n-                    // idents in pat; but complex w/ unclear UI payoff.\n-                    // Instead, just abandon providing diagnostic info.\n-                    opt_ty_info: None,\n-                    opt_match_place,\n-                    pat_span,\n-                },\n-            ))),\n+            local_info: LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+                binding_mode,\n+                // hypothetically, `visit_bindings` could try to unzip\n+                // an outermost hir::Ty as we descend, matching up\n+                // idents in pat; but complex w/ unclear UI payoff.\n+                // Instead, just abandon providing diagnostic info.\n+                opt_ty_info: None,\n+                opt_match_place,\n+                pat_span,\n+            }))),\n         };\n         let for_arm_body = self.local_decls.push(local);\n         self.var_debug_info.push(VarDebugInfo {\n@@ -1719,10 +1610,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 source_info: debug_source_info,\n                 place: ref_for_guard.into(),\n             });\n-            LocalsForNode::ForGuard {\n-                ref_for_guard,\n-                for_arm_body,\n-            }\n+            LocalsForNode::ForGuard { ref_for_guard, for_arm_body }\n         } else {\n             LocalsForNode::One(for_arm_body)\n         };"}, {"sha": "327372beb47b76e1a15a04c4cb8b21c989b2cd28", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 244, "deletions": 264, "changes": 508, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d", "patch": "@@ -1,22 +1,22 @@\n use crate::build;\n use crate::build::scope::DropKind;\n use crate::hair::cx::Cx;\n-use crate::hair::{LintLevel, BindingMode, PatKind};\n+use crate::hair::{BindingMode, LintLevel, PatKind};\n use crate::transform::MirSource;\n use crate::util as mir_util;\n use rustc::hir;\n-use rustc::hir::{Node, GeneratorKind};\n use rustc::hir::def_id::DefId;\n+use rustc::hir::{GeneratorKind, Node};\n use rustc::middle::lang_items;\n use rustc::middle::region;\n use rustc::mir::*;\n-use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Subst;\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::nodemap::HirIdMap;\n+use rustc_index::vec::{Idx, IndexVec};\n+use rustc_target::spec::abi::Abi;\n use rustc_target::spec::PanicStrategy;\n-use rustc_index::vec::{IndexVec, Idx};\n use std::u32;\n-use rustc_target::spec::abi::Abi;\n use syntax::attr::{self, UnwindAttr};\n use syntax::symbol::kw;\n use syntax_pos::Span;\n@@ -30,40 +30,27 @@ pub fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> BodyAndCache<'_> {\n     // Figure out what primary body this item has.\n     let (body_id, return_ty_span) = match tcx.hir().get(id) {\n         Node::Expr(hir::Expr { kind: hir::ExprKind::Closure(_, decl, body_id, _, _), .. })\n-        | Node::Item(\n-            hir::Item {\n-                kind: hir::ItemKind::Fn(hir::FnSig { decl, .. }, _, body_id),\n-                ..\n-            }\n-        )\n-        | Node::ImplItem(\n-            hir::ImplItem {\n-                kind: hir::ImplItemKind::Method(hir::FnSig { decl, .. }, body_id),\n-                ..\n-            }\n-        )\n-        | Node::TraitItem(\n-            hir::TraitItem {\n-                kind: hir::TraitItemKind::Method(\n-                    hir::FnSig { decl, .. },\n-                    hir::TraitMethod::Provided(body_id),\n-                ),\n-                ..\n-            }\n-        ) => {\n-            (*body_id, decl.output.span())\n-        }\n+        | Node::Item(hir::Item {\n+            kind: hir::ItemKind::Fn(hir::FnSig { decl, .. }, _, body_id),\n+            ..\n+        })\n+        | Node::ImplItem(hir::ImplItem {\n+            kind: hir::ImplItemKind::Method(hir::FnSig { decl, .. }, body_id),\n+            ..\n+        })\n+        | Node::TraitItem(hir::TraitItem {\n+            kind:\n+                hir::TraitItemKind::Method(hir::FnSig { decl, .. }, hir::TraitMethod::Provided(body_id)),\n+            ..\n+        }) => (*body_id, decl.output.span()),\n         Node::Item(hir::Item { kind: hir::ItemKind::Static(ty, _, body_id), .. })\n         | Node::Item(hir::Item { kind: hir::ItemKind::Const(ty, body_id), .. })\n         | Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Const(ty, body_id), .. })\n-        | Node::TraitItem(\n-            hir::TraitItem { kind: hir::TraitItemKind::Const(ty, Some(body_id)), .. }\n-        ) => {\n-            (*body_id, ty.span)\n-        }\n-        Node::AnonConst(hir::AnonConst { body, hir_id, .. }) => {\n-            (*body, tcx.hir().span(*hir_id))\n-        }\n+        | Node::TraitItem(hir::TraitItem {\n+            kind: hir::TraitItemKind::Const(ty, Some(body_id)),\n+            ..\n+        }) => (*body_id, ty.span),\n+        Node::AnonConst(hir::AnonConst { body, hir_id, .. }) => (*body, tcx.hir().span(*hir_id)),\n \n         _ => span_bug!(tcx.hir().span(id), \"can't build MIR for {:?}\", def_id),\n     };\n@@ -100,61 +87,54 @@ pub fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> BodyAndCache<'_> {\n             };\n \n             let body = tcx.hir().body(body_id);\n-            let explicit_arguments =\n-                body.params\n-                    .iter()\n-                    .enumerate()\n-                    .map(|(index, arg)| {\n-                        let owner_id = tcx.hir().body_owner(body_id);\n-                        let opt_ty_info;\n-                        let self_arg;\n-                        if let Some(ref fn_decl) = tcx.hir().fn_decl_by_hir_id(owner_id) {\n-                            opt_ty_info = fn_decl.inputs.get(index).map(|ty| ty.span);\n-                            self_arg = if index == 0 && fn_decl.implicit_self.has_implicit_self() {\n-                                match fn_decl.implicit_self {\n-                                    hir::ImplicitSelfKind::Imm => Some(ImplicitSelfKind::Imm),\n-                                    hir::ImplicitSelfKind::Mut => Some(ImplicitSelfKind::Mut),\n-                                    hir::ImplicitSelfKind::ImmRef => Some(ImplicitSelfKind::ImmRef),\n-                                    hir::ImplicitSelfKind::MutRef => Some(ImplicitSelfKind::MutRef),\n-                                    _ => None,\n-                                }\n-                            } else {\n-                                None\n-                            };\n-                        } else {\n-                            opt_ty_info = None;\n-                            self_arg = None;\n+            let explicit_arguments = body.params.iter().enumerate().map(|(index, arg)| {\n+                let owner_id = tcx.hir().body_owner(body_id);\n+                let opt_ty_info;\n+                let self_arg;\n+                if let Some(ref fn_decl) = tcx.hir().fn_decl_by_hir_id(owner_id) {\n+                    opt_ty_info = fn_decl.inputs.get(index).map(|ty| ty.span);\n+                    self_arg = if index == 0 && fn_decl.implicit_self.has_implicit_self() {\n+                        match fn_decl.implicit_self {\n+                            hir::ImplicitSelfKind::Imm => Some(ImplicitSelfKind::Imm),\n+                            hir::ImplicitSelfKind::Mut => Some(ImplicitSelfKind::Mut),\n+                            hir::ImplicitSelfKind::ImmRef => Some(ImplicitSelfKind::ImmRef),\n+                            hir::ImplicitSelfKind::MutRef => Some(ImplicitSelfKind::MutRef),\n+                            _ => None,\n                         }\n+                    } else {\n+                        None\n+                    };\n+                } else {\n+                    opt_ty_info = None;\n+                    self_arg = None;\n+                }\n \n-                        // C-variadic fns also have a `VaList` input that's not listed in `fn_sig`\n-                        // (as it's created inside the body itself, not passed in from outside).\n-                        let ty = if fn_sig.c_variadic && index == fn_sig.inputs().len() {\n-                            let va_list_did = tcx.require_lang_item(\n-                                lang_items::VaListTypeLangItem,\n-                                Some(arg.span),\n-                            );\n-                            let region = tcx.mk_region(ty::ReScope(region::Scope {\n-                                id: body.value.hir_id.local_id,\n-                                data: region::ScopeData::CallSite\n-                            }));\n-\n-                            tcx.type_of(va_list_did).subst(tcx, &[region.into()])\n-                        } else {\n-                            fn_sig.inputs()[index]\n-                        };\n+                // C-variadic fns also have a `VaList` input that's not listed in `fn_sig`\n+                // (as it's created inside the body itself, not passed in from outside).\n+                let ty = if fn_sig.c_variadic && index == fn_sig.inputs().len() {\n+                    let va_list_did =\n+                        tcx.require_lang_item(lang_items::VaListTypeLangItem, Some(arg.span));\n+                    let region = tcx.mk_region(ty::ReScope(region::Scope {\n+                        id: body.value.hir_id.local_id,\n+                        data: region::ScopeData::CallSite,\n+                    }));\n+\n+                    tcx.type_of(va_list_did).subst(tcx, &[region.into()])\n+                } else {\n+                    fn_sig.inputs()[index]\n+                };\n \n-                        ArgInfo(ty, opt_ty_info, Some(&arg), self_arg)\n-                    });\n+                ArgInfo(ty, opt_ty_info, Some(&arg), self_arg)\n+            });\n \n             let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n \n             let (yield_ty, return_ty) = if body.generator_kind.is_some() {\n                 let gen_sig = match ty.kind {\n-                    ty::Generator(gen_def_id, gen_substs, ..) =>\n-                        gen_substs.as_generator().sig(gen_def_id, tcx),\n-                    _ =>\n-                        span_bug!(tcx.hir().span(id),\n-                                  \"generator w/o generator type: {:?}\", ty),\n+                    ty::Generator(gen_def_id, gen_substs, ..) => {\n+                        gen_substs.as_generator().sig(gen_def_id, tcx)\n+                    }\n+                    _ => span_bug!(tcx.hir().span(id), \"generator w/o generator type: {:?}\", ty),\n                 };\n                 (Some(gen_sig.yield_ty), gen_sig.return_ty)\n             } else {\n@@ -191,8 +171,7 @@ pub fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> BodyAndCache<'_> {\n             build::construct_const(cx, body_id, return_ty, return_ty_span)\n         };\n \n-        mir_util::dump_mir(tcx, None, \"mir_map\", &0,\n-                           MirSource::item(def_id), &body, |_, _| Ok(()) );\n+        mir_util::dump_mir(tcx, None, \"mir_map\", &0, MirSource::item(def_id), &body, |_, _| Ok(()));\n \n         lints::check(tcx, &body, def_id);\n \n@@ -214,7 +193,7 @@ fn liberated_closure_env_ty(\n \n     let (closure_def_id, closure_substs) = match closure_ty.kind {\n         ty::Closure(closure_def_id, closure_substs) => (closure_def_id, closure_substs),\n-        _ => bug!(\"closure expr does not have closure type: {:?}\", closure_ty)\n+        _ => bug!(\"closure expr does not have closure type: {:?}\", closure_ty),\n     };\n \n     let closure_env_ty = tcx.closure_env_ty(closure_def_id, closure_substs).unwrap();\n@@ -232,7 +211,7 @@ pub enum BlockFrame {\n     Statement {\n         /// If true, then statement discards result from evaluating\n         /// the expression (such as examples 1 and 2 above).\n-        ignores_expr_result: bool\n+        ignores_expr_result: bool,\n     },\n \n     /// Evaluation is currently within the tail expression of a block.\n@@ -243,7 +222,7 @@ pub enum BlockFrame {\n         /// the result of evaluating the block's tail expression.\n         ///\n         /// Example: `let _ = { STMT_1; EXPR };`\n-        tail_result_is_ignored: bool\n+        tail_result_is_ignored: bool,\n     },\n \n     /// Generic mark meaning that the block occurred as a subexpression\n@@ -258,19 +237,17 @@ impl BlockFrame {\n         match *self {\n             BlockFrame::TailExpr { .. } => true,\n \n-            BlockFrame::Statement { .. } |\n-            BlockFrame::SubExpr => false,\n+            BlockFrame::Statement { .. } | BlockFrame::SubExpr => false,\n         }\n     }\n     fn is_statement(&self) -> bool {\n         match *self {\n             BlockFrame::Statement { .. } => true,\n \n-            BlockFrame::TailExpr { .. } |\n-            BlockFrame::SubExpr => false,\n+            BlockFrame::TailExpr { .. } | BlockFrame::SubExpr => false,\n         }\n     }\n- }\n+}\n \n #[derive(Debug)]\n struct BlockContext(Vec<BlockFrame>);\n@@ -348,9 +325,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n }\n \n impl BlockContext {\n-    fn new() -> Self { BlockContext(vec![]) }\n-    fn push(&mut self, bf: BlockFrame) { self.0.push(bf); }\n-    fn pop(&mut self) -> Option<BlockFrame> { self.0.pop() }\n+    fn new() -> Self {\n+        BlockContext(vec![])\n+    }\n+    fn push(&mut self, bf: BlockFrame) {\n+        self.0.push(bf);\n+    }\n+    fn pop(&mut self) -> Option<BlockFrame> {\n+        self.0.pop()\n+    }\n \n     /// Traverses the frames on the `BlockContext`, searching for either\n     /// the first block-tail expression frame with no intervening\n@@ -367,8 +350,9 @@ impl BlockContext {\n             match bf {\n                 BlockFrame::SubExpr => continue,\n                 BlockFrame::Statement { .. } => break,\n-                &BlockFrame::TailExpr { tail_result_is_ignored } =>\n-                    return Some(BlockTailInfo { tail_result_is_ignored })\n+                &BlockFrame::TailExpr { tail_result_is_ignored } => {\n+                    return Some(BlockTailInfo { tail_result_is_ignored });\n+                }\n             }\n         }\n \n@@ -390,8 +374,8 @@ impl BlockContext {\n             Some(BlockFrame::SubExpr) => false,\n \n             // otherwise: use accumulated is_ignored state.\n-            Some(BlockFrame::TailExpr { tail_result_is_ignored: ignored }) |\n-            Some(BlockFrame::Statement { ignores_expr_result: ignored }) => *ignored,\n+            Some(BlockFrame::TailExpr { tail_result_is_ignored: ignored })\n+            | Some(BlockFrame::Statement { ignores_expr_result: ignored }) => *ignored,\n         }\n     }\n }\n@@ -422,9 +406,7 @@ struct GuardFrameLocal {\n \n impl GuardFrameLocal {\n     fn new(id: hir::HirId, _binding_mode: BindingMode) -> Self {\n-        GuardFrameLocal {\n-            id: id,\n-        }\n+        GuardFrameLocal { id: id }\n     }\n }\n \n@@ -457,13 +439,18 @@ enum ForGuard {\n impl LocalsForNode {\n     fn local_id(&self, for_guard: ForGuard) -> Local {\n         match (self, for_guard) {\n-            (&LocalsForNode::One(local_id), ForGuard::OutsideGuard) |\n-            (&LocalsForNode::ForGuard { ref_for_guard: local_id, .. }, ForGuard::RefWithinGuard) |\n-            (&LocalsForNode::ForGuard { for_arm_body: local_id, .. }, ForGuard::OutsideGuard) =>\n-                local_id,\n+            (&LocalsForNode::One(local_id), ForGuard::OutsideGuard)\n+            | (\n+                &LocalsForNode::ForGuard { ref_for_guard: local_id, .. },\n+                ForGuard::RefWithinGuard,\n+            )\n+            | (&LocalsForNode::ForGuard { for_arm_body: local_id, .. }, ForGuard::OutsideGuard) => {\n+                local_id\n+            }\n \n-            (&LocalsForNode::One(_), ForGuard::RefWithinGuard) =>\n-                bug!(\"anything with one local should never be within a guard.\"),\n+            (&LocalsForNode::One(_), ForGuard::RefWithinGuard) => {\n+                bug!(\"anything with one local should never be within a guard.\")\n+            }\n         }\n     }\n }\n@@ -503,20 +490,16 @@ impl BlockAndExtension for BasicBlock {\n /// Update a block pointer and return the value.\n /// Use it like `let x = unpack!(block = self.foo(block, foo))`.\n macro_rules! unpack {\n-    ($x:ident = $c:expr) => {\n-        {\n-            let BlockAnd(b, v) = $c;\n-            $x = b;\n-            v\n-        }\n-    };\n-\n-    ($c:expr) => {\n-        {\n-            let BlockAnd(b, ()) = $c;\n-            b\n-        }\n-    };\n+    ($x:ident = $c:expr) => {{\n+        let BlockAnd(b, v) = $c;\n+        $x = b;\n+        v\n+    }};\n+\n+    ($c:expr) => {{\n+        let BlockAnd(b, ()) = $c;\n+        b\n+    }};\n }\n \n fn should_abort_on_panic(tcx: TyCtxt<'_>, fn_def_id: DefId, _abi: Abi) -> bool {\n@@ -525,10 +508,14 @@ fn should_abort_on_panic(tcx: TyCtxt<'_>, fn_def_id: DefId, _abi: Abi) -> bool {\n     let unwind_attr = attr::find_unwind_attr(Some(tcx.sess.diagnostic()), attrs);\n \n     // We never unwind, so it's not relevant to stop an unwind.\n-    if tcx.sess.panic_strategy() != PanicStrategy::Unwind { return false; }\n+    if tcx.sess.panic_strategy() != PanicStrategy::Unwind {\n+        return false;\n+    }\n \n     // We cannot add landing pads, so don't add one.\n-    if tcx.sess.no_landing_pads() { return false; }\n+    if tcx.sess.no_landing_pads() {\n+        return false;\n+    }\n \n     // This is a special case: some functions have a C abi but are meant to\n     // unwind anyway. Don't stop them.\n@@ -555,7 +542,7 @@ fn construct_fn<'a, 'tcx, A>(\n     body: &'tcx hir::Body<'tcx>,\n ) -> Body<'tcx>\n where\n-    A: Iterator<Item=ArgInfo<'tcx>>\n+    A: Iterator<Item = ArgInfo<'tcx>>,\n {\n     let arguments: Vec<_> = arguments.collect();\n \n@@ -565,64 +552,71 @@ where\n \n     let fn_def_id = tcx_hir.local_def_id(fn_id);\n \n-    let mut builder = Builder::new(hir,\n+    let mut builder = Builder::new(\n+        hir,\n         span,\n         arguments.len(),\n         safety,\n         return_ty,\n         return_ty_span,\n-        body.generator_kind);\n+        body.generator_kind,\n+    );\n \n-    let call_site_scope = region::Scope {\n-        id: body.value.hir_id.local_id,\n-        data: region::ScopeData::CallSite\n-    };\n-    let arg_scope = region::Scope {\n-        id: body.value.hir_id.local_id,\n-        data: region::ScopeData::Arguments\n-    };\n+    let call_site_scope =\n+        region::Scope { id: body.value.hir_id.local_id, data: region::ScopeData::CallSite };\n+    let arg_scope =\n+        region::Scope { id: body.value.hir_id.local_id, data: region::ScopeData::Arguments };\n     let mut block = START_BLOCK;\n     let source_info = builder.source_info(span);\n     let call_site_s = (call_site_scope, source_info);\n-    unpack!(block = builder.in_scope(call_site_s, LintLevel::Inherited, |builder| {\n-        if should_abort_on_panic(tcx, fn_def_id, abi) {\n-            builder.schedule_abort();\n-        }\n+    unpack!(\n+        block = builder.in_scope(call_site_s, LintLevel::Inherited, |builder| {\n+            if should_abort_on_panic(tcx, fn_def_id, abi) {\n+                builder.schedule_abort();\n+            }\n \n-        let arg_scope_s = (arg_scope, source_info);\n-        // `return_block` is called when we evaluate a `return` expression, so\n-        // we just use `START_BLOCK` here.\n-        unpack!(block = builder.in_breakable_scope(\n-            None,\n-            START_BLOCK,\n-            Place::return_place(),\n-            |builder| {\n-                builder.in_scope(arg_scope_s, LintLevel::Inherited, |builder| {\n-                    builder.args_and_body(block, fn_def_id, &arguments, arg_scope, &body.value)\n-                })\n-            },\n-        ));\n-        // Attribute epilogue to function's closing brace\n-        let fn_end = span.shrink_to_hi();\n-        let source_info = builder.source_info(fn_end);\n-        let return_block = builder.return_block();\n-        builder.cfg.goto(block, source_info, return_block);\n-        builder.cfg.terminate(return_block, source_info, TerminatorKind::Return);\n-        // Attribute any unreachable codepaths to the function's closing brace\n-        if let Some(unreachable_block) = builder.cached_unreachable_block {\n-            builder.cfg.terminate(unreachable_block, source_info, TerminatorKind::Unreachable);\n-        }\n-        return_block.unit()\n-    }));\n+            let arg_scope_s = (arg_scope, source_info);\n+            // `return_block` is called when we evaluate a `return` expression, so\n+            // we just use `START_BLOCK` here.\n+            unpack!(\n+                block = builder.in_breakable_scope(\n+                    None,\n+                    START_BLOCK,\n+                    Place::return_place(),\n+                    |builder| {\n+                        builder.in_scope(arg_scope_s, LintLevel::Inherited, |builder| {\n+                            builder.args_and_body(\n+                                block,\n+                                fn_def_id,\n+                                &arguments,\n+                                arg_scope,\n+                                &body.value,\n+                            )\n+                        })\n+                    },\n+                )\n+            );\n+            // Attribute epilogue to function's closing brace\n+            let fn_end = span.shrink_to_hi();\n+            let source_info = builder.source_info(fn_end);\n+            let return_block = builder.return_block();\n+            builder.cfg.goto(block, source_info, return_block);\n+            builder.cfg.terminate(return_block, source_info, TerminatorKind::Return);\n+            // Attribute any unreachable codepaths to the function's closing brace\n+            if let Some(unreachable_block) = builder.cached_unreachable_block {\n+                builder.cfg.terminate(unreachable_block, source_info, TerminatorKind::Unreachable);\n+            }\n+            return_block.unit()\n+        })\n+    );\n     assert_eq!(block, builder.return_block());\n \n     let mut spread_arg = None;\n     if abi == Abi::RustCall {\n         // RustCall pseudo-ABI untuples the last argument.\n         spread_arg = Some(Local::new(arguments.len()));\n     }\n-    info!(\"fn_id {:?} has attrs {:?}\", fn_def_id,\n-          tcx.get_attrs(fn_def_id));\n+    info!(\"fn_id {:?} has attrs {:?}\", fn_def_id, tcx.get_attrs(fn_def_id));\n \n     let mut body = builder.finish();\n     body.spread_arg = spread_arg;\n@@ -638,15 +632,7 @@ fn construct_const<'a, 'tcx>(\n     let tcx = hir.tcx();\n     let owner_id = tcx.hir().body_owner(body_id);\n     let span = tcx.hir().span(owner_id);\n-    let mut builder = Builder::new(\n-        hir,\n-        span,\n-        0,\n-        Safety::Safe,\n-        const_ty,\n-        const_ty_span,\n-        None,\n-    );\n+    let mut builder = Builder::new(hir, span, 0, Safety::Safe, const_ty, const_ty_span, None);\n \n     let mut block = START_BLOCK;\n     let ast_expr = &tcx.hir().body(body_id).value;\n@@ -662,17 +648,13 @@ fn construct_const<'a, 'tcx>(\n     // Constants may be match expressions in which case an unreachable block may\n     // be created, so terminate it properly.\n     if let Some(unreachable_block) = builder.cached_unreachable_block {\n-        builder.cfg.terminate(unreachable_block, source_info,\n-                              TerminatorKind::Unreachable);\n+        builder.cfg.terminate(unreachable_block, source_info, TerminatorKind::Unreachable);\n     }\n \n     builder.finish()\n }\n \n-fn construct_error<'a, 'tcx>(\n-    hir: Cx<'a, 'tcx>,\n-    body_id: hir::BodyId\n-) -> Body<'tcx> {\n+fn construct_error<'a, 'tcx>(hir: Cx<'a, 'tcx>, body_id: hir::BodyId) -> Body<'tcx> {\n     let owner_id = hir.tcx().hir().body_owner(body_id);\n     let span = hir.tcx().hir().span(owner_id);\n     let ty = hir.tcx().types.err;\n@@ -683,14 +665,15 @@ fn construct_error<'a, 'tcx>(\n }\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n-    fn new(hir: Cx<'a, 'tcx>,\n-           span: Span,\n-           arg_count: usize,\n-           safety: Safety,\n-           return_ty: Ty<'tcx>,\n-           return_span: Span,\n-           generator_kind: Option<GeneratorKind>)\n-           -> Builder<'a, 'tcx> {\n+    fn new(\n+        hir: Cx<'a, 'tcx>,\n+        span: Span,\n+        arg_count: usize,\n+        safety: Safety,\n+        return_ty: Ty<'tcx>,\n+        return_span: Span,\n+        generator_kind: Option<GeneratorKind>,\n+    ) -> Builder<'a, 'tcx> {\n         let lint_level = LintLevel::Explicit(hir.root_lint_level);\n         let mut builder = Builder {\n             hir,\n@@ -722,7 +705,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         assert_eq!(builder.cfg.start_new_block(), START_BLOCK);\n         assert_eq!(\n             builder.new_source_scope(span, lint_level, Some(safety)),\n-            OUTERMOST_SOURCE_SCOPE);\n+            OUTERMOST_SOURCE_SCOPE\n+        );\n         builder.source_scopes[OUTERMOST_SOURCE_SCOPE].parent_scope = None;\n \n         builder\n@@ -744,23 +728,23 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             self.var_debug_info,\n             self.fn_span,\n             self.hir.control_flow_destroyed(),\n-            self.generator_kind\n+            self.generator_kind,\n         )\n     }\n \n-    fn args_and_body(&mut self,\n-                     mut block: BasicBlock,\n-                     fn_def_id: DefId,\n-                     arguments: &[ArgInfo<'tcx>],\n-                     argument_scope: region::Scope,\n-                     ast_body: &'tcx hir::Expr)\n-                     -> BlockAnd<()>\n-    {\n+    fn args_and_body(\n+        &mut self,\n+        mut block: BasicBlock,\n+        fn_def_id: DefId,\n+        arguments: &[ArgInfo<'tcx>],\n+        argument_scope: region::Scope,\n+        ast_body: &'tcx hir::Expr,\n+    ) -> BlockAnd<()> {\n         // Allocate locals for the function arguments\n         for &ArgInfo(ty, _, arg_opt, _) in arguments.iter() {\n             let source_info = SourceInfo {\n                 scope: OUTERMOST_SOURCE_SCOPE,\n-                span: arg_opt.map_or(self.fn_span, |arg| arg.pat.span)\n+                span: arg_opt.map_or(self.fn_span, |arg| arg.pat.span),\n             };\n             let arg_local = self.local_decls.push(LocalDecl {\n                 mutability: Mutability::Mut,\n@@ -804,51 +788,54 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let (def_id, upvar_substs) = match closure_ty.kind {\n                 ty::Closure(def_id, substs) => (def_id, ty::UpvarSubsts::Closure(substs)),\n                 ty::Generator(def_id, substs, _) => (def_id, ty::UpvarSubsts::Generator(substs)),\n-                _ => span_bug!(self.fn_span, \"upvars with non-closure env ty {:?}\", closure_ty)\n+                _ => span_bug!(self.fn_span, \"upvars with non-closure env ty {:?}\", closure_ty),\n             };\n             let upvar_tys = upvar_substs.upvar_tys(def_id, tcx);\n             let upvars_with_tys = upvars.iter().zip(upvar_tys);\n-            self.upvar_mutbls = upvars_with_tys.enumerate().map(|(i, ((&var_id, &upvar_id), ty))| {\n-                let capture = hir_tables.upvar_capture(upvar_id);\n-\n-                let mut mutability = Mutability::Not;\n-                let mut name = kw::Invalid;\n-                if let Some(Node::Binding(pat)) = tcx_hir.find(var_id) {\n-                    if let hir::PatKind::Binding(_, _, ident, _) = pat.kind {\n-                        name = ident.name;\n-                        match hir_tables.extract_binding_mode(tcx.sess, pat.hir_id, pat.span) {\n-                            Some(ty::BindByValue(hir::Mutability::Mut)) => {\n-                                mutability = Mutability::Mut;\n+            self.upvar_mutbls = upvars_with_tys\n+                .enumerate()\n+                .map(|(i, ((&var_id, &upvar_id), ty))| {\n+                    let capture = hir_tables.upvar_capture(upvar_id);\n+\n+                    let mut mutability = Mutability::Not;\n+                    let mut name = kw::Invalid;\n+                    if let Some(Node::Binding(pat)) = tcx_hir.find(var_id) {\n+                        if let hir::PatKind::Binding(_, _, ident, _) = pat.kind {\n+                            name = ident.name;\n+                            match hir_tables.extract_binding_mode(tcx.sess, pat.hir_id, pat.span) {\n+                                Some(ty::BindByValue(hir::Mutability::Mut)) => {\n+                                    mutability = Mutability::Mut;\n+                                }\n+                                Some(_) => mutability = Mutability::Not,\n+                                _ => {}\n                             }\n-                            Some(_) => mutability = Mutability::Not,\n-                            _ => {}\n                         }\n                     }\n-                }\n \n-                let mut projs = closure_env_projs.clone();\n-                projs.push(ProjectionElem::Field(Field::new(i), ty));\n-                match capture {\n-                    ty::UpvarCapture::ByValue => {}\n-                    ty::UpvarCapture::ByRef(..) => {\n-                        projs.push(ProjectionElem::Deref);\n-                    }\n-                };\n+                    let mut projs = closure_env_projs.clone();\n+                    projs.push(ProjectionElem::Field(Field::new(i), ty));\n+                    match capture {\n+                        ty::UpvarCapture::ByValue => {}\n+                        ty::UpvarCapture::ByRef(..) => {\n+                            projs.push(ProjectionElem::Deref);\n+                        }\n+                    };\n \n-                self.var_debug_info.push(VarDebugInfo {\n-                    name,\n-                    source_info: SourceInfo {\n-                        scope: OUTERMOST_SOURCE_SCOPE,\n-                        span: tcx_hir.span(var_id),\n-                    },\n-                    place: Place {\n-                        base: closure_env_arg.into(),\n-                        projection: tcx.intern_place_elems(&projs),\n-                    },\n-                });\n+                    self.var_debug_info.push(VarDebugInfo {\n+                        name,\n+                        source_info: SourceInfo {\n+                            scope: OUTERMOST_SOURCE_SCOPE,\n+                            span: tcx_hir.span(var_id),\n+                        },\n+                        place: Place {\n+                            base: closure_env_arg.into(),\n+                            projection: tcx.intern_place_elems(&projs),\n+                        },\n+                    });\n \n-                mutability\n-            }).collect();\n+                    mutability\n+                })\n+                .collect();\n         }\n \n         let mut scope = None;\n@@ -862,7 +849,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // Make sure we drop (parts of) the argument even when not matched on.\n             self.schedule_drop(\n                 arg_opt.as_ref().map_or(ast_body.span, |arg| arg.pat.span),\n-                argument_scope, local, DropKind::Value,\n+                argument_scope,\n+                local,\n+                DropKind::Value,\n             );\n \n             if let Some(arg) = arg_opt {\n@@ -881,22 +870,19 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     } => {\n                         self.local_decls[local].mutability = mutability;\n                         self.local_decls[local].source_info.scope = self.source_scope;\n-                        self.local_decls[local].local_info =\n-                            if let Some(kind) = self_binding {\n-                                LocalInfo::User(ClearCrossCrate::Set(\n-                                    BindingForm::ImplicitSelf(*kind),\n-                                ))\n-                            } else {\n-                                let binding_mode = ty::BindingMode::BindByValue(mutability.into());\n-                                LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n-                                    VarBindingForm {\n-                                        binding_mode,\n-                                        opt_ty_info,\n-                                        opt_match_place: Some((Some(place.clone()), span)),\n-                                        pat_span: span,\n-                                    },\n-                                )))\n-                            };\n+                        self.local_decls[local].local_info = if let Some(kind) = self_binding {\n+                            LocalInfo::User(ClearCrossCrate::Set(BindingForm::ImplicitSelf(*kind)))\n+                        } else {\n+                            let binding_mode = ty::BindingMode::BindByValue(mutability.into());\n+                            LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n+                                VarBindingForm {\n+                                    binding_mode,\n+                                    opt_ty_info,\n+                                    opt_match_place: Some((Some(place.clone()), span)),\n+                                    pat_span: span,\n+                                },\n+                            )))\n+                        };\n                         self.var_indices.insert(var, LocalsForNode::One(local));\n                     }\n                     _ => {\n@@ -927,13 +913,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         arg_hir_id: hir::HirId,\n         original_source_scope: SourceScope,\n-        pattern_span: Span\n+        pattern_span: Span,\n     ) {\n         let tcx = self.hir.tcx();\n-        let current_root = tcx.maybe_lint_level_root_bounded(\n-            arg_hir_id,\n-            self.hir.root_lint_level\n-        );\n+        let current_root = tcx.maybe_lint_level_root_bounded(arg_hir_id, self.hir.root_lint_level);\n         let parent_root = tcx.maybe_lint_level_root_bounded(\n             self.source_scopes[original_source_scope]\n                 .local_data\n@@ -943,11 +926,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             self.hir.root_lint_level,\n         );\n         if current_root != parent_root {\n-            self.source_scope = self.new_source_scope(\n-                pattern_span,\n-                LintLevel::Explicit(current_root),\n-                None\n-            );\n+            self.source_scope =\n+                self.new_source_scope(pattern_span, LintLevel::Explicit(current_root), None);\n         }\n     }\n "}, {"sha": "6cb73e0c8d7d5c0ba67be96af1f1a054b71486eb", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 117, "deletions": 169, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d", "patch": "@@ -1,30 +1,31 @@\n // Not in interpret to make sure we do not use private implementation details\n \n-use std::fmt;\n-use std::error::Error;\n use std::borrow::{Borrow, Cow};\n-use std::hash::Hash;\n use std::collections::hash_map::Entry;\n use std::convert::TryInto;\n+use std::error::Error;\n+use std::fmt;\n+use std::hash::Hash;\n \n+use crate::interpret::eval_nullary_intrinsic;\n use rustc::hir::def::DefKind;\n use rustc::hir::def_id::DefId;\n-use rustc::mir::interpret::{ConstEvalErr, ErrorHandled, ScalarMaybeUndef};\n use rustc::mir;\n-use rustc::ty::{self, Ty, TyCtxt, subst::Subst};\n-use rustc::ty::layout::{self, HasTyCtxt, LayoutOf, VariantIdx};\n+use rustc::mir::interpret::{ConstEvalErr, ErrorHandled, ScalarMaybeUndef};\n use rustc::traits::Reveal;\n+use rustc::ty::layout::{self, HasTyCtxt, LayoutOf, VariantIdx};\n+use rustc::ty::{self, subst::Subst, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n-use crate::interpret::eval_nullary_intrinsic;\n \n-use syntax::{source_map::{Span, DUMMY_SP}, symbol::Symbol};\n+use syntax::{\n+    source_map::{Span, DUMMY_SP},\n+    symbol::Symbol,\n+};\n \n-use crate::interpret::{self,\n-    PlaceTy, MPlaceTy, OpTy, ImmTy, Immediate, Scalar, Pointer,\n-    RawConst, ConstValue, Machine,\n-    InterpResult, InterpErrorInfo, GlobalId, InterpCx, StackPopCleanup, AssertMessage,\n-    Allocation, AllocId, MemoryKind, Memory,\n-    snapshot, RefTracking, intern_const_alloc_recursive,\n+use crate::interpret::{\n+    self, intern_const_alloc_recursive, snapshot, AllocId, Allocation, AssertMessage, ConstValue,\n+    GlobalId, ImmTy, Immediate, InterpCx, InterpErrorInfo, InterpResult, MPlaceTy, Machine, Memory,\n+    MemoryKind, OpTy, PlaceTy, Pointer, RawConst, RefTracking, Scalar, StackPopCleanup,\n };\n \n /// Number of steps until the detector even starts doing anything.\n@@ -94,7 +95,7 @@ fn op_to_const<'tcx>(\n             let ptr = mplace.ptr.to_ptr().unwrap();\n             let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n             ConstValue::ByRef { alloc, offset: ptr.offset }\n-        },\n+        }\n         // see comment on `let try_as_immediate` above\n         Err(ImmTy { imm: Immediate::Scalar(x), .. }) => match x {\n             ScalarMaybeUndef::Scalar(s) => ConstValue::Scalar(s),\n@@ -108,30 +109,23 @@ fn op_to_const<'tcx>(\n                 let ptr = mplace.ptr.to_ptr().unwrap();\n                 let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n                 ConstValue::ByRef { alloc, offset: ptr.offset }\n-            },\n+            }\n         },\n         Err(ImmTy { imm: Immediate::ScalarPair(a, b), .. }) => {\n             let (data, start) = match a.not_undef().unwrap() {\n-                Scalar::Ptr(ptr) => (\n-                    ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id),\n-                    ptr.offset.bytes(),\n-                ),\n+                Scalar::Ptr(ptr) => {\n+                    (ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id), ptr.offset.bytes())\n+                }\n                 Scalar::Raw { .. } => (\n-                    ecx.tcx.intern_const_alloc(Allocation::from_byte_aligned_bytes(\n-                        b\"\" as &[u8],\n-                    )),\n+                    ecx.tcx.intern_const_alloc(Allocation::from_byte_aligned_bytes(b\"\" as &[u8])),\n                     0,\n                 ),\n             };\n             let len = b.to_machine_usize(&ecx.tcx.tcx).unwrap();\n             let start = start.try_into().unwrap();\n             let len: usize = len.try_into().unwrap();\n-            ConstValue::Slice {\n-                data,\n-                start,\n-                end: start + len,\n-            }\n-        },\n+            ConstValue::Slice { data, start, end: start + len }\n+        }\n     };\n     ecx.tcx.mk_const(ty::Const { val: ty::ConstKind::Value(val), ty: op.layout.ty })\n }\n@@ -159,7 +153,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n         let decl = body.local_decls.get(arg).expect(\"arg missing from local_decls\");\n         let layout = ecx.layout_of(decl.ty.subst(tcx, cid.instance.substs))?;\n         assert!(layout.is_zst())\n-    };\n+    }\n \n     ecx.push_stack_frame(\n         cid.instance,\n@@ -196,11 +190,7 @@ impl fmt::Display for ConstEvalError {\n         use self::ConstEvalError::*;\n         match *self {\n             NeedsRfc(ref msg) => {\n-                write!(\n-                    f,\n-                    \"\\\"{}\\\" needs an rfc before being allowed inside constants\",\n-                    msg\n-                )\n+                write!(f, \"\\\"{}\\\" needs an rfc before being allowed inside constants\", msg)\n             }\n             ConstAccessesStatic => write!(f, \"constant accesses static\"),\n         }\n@@ -251,38 +241,32 @@ impl<'mir, 'tcx> CompileTimeInterpreter<'mir, 'tcx> {\n impl<K: Hash + Eq, V> interpret::AllocMap<K, V> for FxHashMap<K, V> {\n     #[inline(always)]\n     fn contains_key<Q: ?Sized + Hash + Eq>(&mut self, k: &Q) -> bool\n-        where K: Borrow<Q>\n+    where\n+        K: Borrow<Q>,\n     {\n         FxHashMap::contains_key(self, k)\n     }\n \n     #[inline(always)]\n-    fn insert(&mut self, k: K, v: V) -> Option<V>\n-    {\n+    fn insert(&mut self, k: K, v: V) -> Option<V> {\n         FxHashMap::insert(self, k, v)\n     }\n \n     #[inline(always)]\n     fn remove<Q: ?Sized + Hash + Eq>(&mut self, k: &Q) -> Option<V>\n-        where K: Borrow<Q>\n+    where\n+        K: Borrow<Q>,\n     {\n         FxHashMap::remove(self, k)\n     }\n \n     #[inline(always)]\n     fn filter_map_collect<T>(&self, mut f: impl FnMut(&K, &V) -> Option<T>) -> Vec<T> {\n-        self.iter()\n-            .filter_map(move |(k, v)| f(k, &*v))\n-            .collect()\n+        self.iter().filter_map(move |(k, v)| f(k, &*v)).collect()\n     }\n \n     #[inline(always)]\n-    fn get_or<E>(\n-        &self,\n-        k: K,\n-        vacant: impl FnOnce() -> Result<V, E>\n-    ) -> Result<&V, E>\n-    {\n+    fn get_or<E>(&self, k: K, vacant: impl FnOnce() -> Result<V, E>) -> Result<&V, E> {\n         match self.get(&k) {\n             Some(v) => Ok(v),\n             None => {\n@@ -293,12 +277,7 @@ impl<K: Hash + Eq, V> interpret::AllocMap<K, V> for FxHashMap<K, V> {\n     }\n \n     #[inline(always)]\n-    fn get_mut_or<E>(\n-        &mut self,\n-        k: K,\n-        vacant: impl FnOnce() -> Result<V, E>\n-    ) -> Result<&mut V, E>\n-    {\n+    fn get_mut_or<E>(&mut self, k: K, vacant: impl FnOnce() -> Result<V, E>) -> Result<&mut V, E> {\n         match self.entry(k) {\n             Entry::Occupied(e) => Ok(e.into_mut()),\n             Entry::Vacant(e) => {\n@@ -347,7 +326,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n         ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n-        _unwind: Option<mir::BasicBlock> // unwinding is not supported in consts\n+        _unwind: Option<mir::BasicBlock>, // unwinding is not supported in consts\n     ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n         debug!(\"find_mir_or_eval_fn: {:?}\", instance);\n \n@@ -387,10 +366,11 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n             Ok(body) => *body,\n             Err(err) => {\n                 if let err_unsup!(NoMirFor(ref path)) = err.kind {\n-                    return Err(\n-                        ConstEvalError::NeedsRfc(format!(\"calling extern function `{}`\", path))\n-                            .into(),\n-                    );\n+                    return Err(ConstEvalError::NeedsRfc(format!(\n+                        \"calling extern function `{}`\",\n+                        path\n+                    ))\n+                    .into());\n                 }\n                 return Err(err);\n             }\n@@ -402,7 +382,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         fn_val: !,\n         _args: &[OpTy<'tcx>],\n         _ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n-        _unwind: Option<mir::BasicBlock>\n+        _unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n         match fn_val {}\n     }\n@@ -413,16 +393,14 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n         ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n-        _unwind: Option<mir::BasicBlock>\n+        _unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n         if ecx.emulate_intrinsic(span, instance, args, ret)? {\n             return Ok(());\n         }\n         // An intrinsic that we do not support\n         let intrinsic_name = ecx.tcx.item_name(instance.def_id());\n-        Err(\n-            ConstEvalError::NeedsRfc(format!(\"calling intrinsic `{}`\", intrinsic_name)).into()\n-        )\n+        Err(ConstEvalError::NeedsRfc(format!(\"calling intrinsic `{}`\", intrinsic_name)).into())\n     }\n \n     fn assert_panic(\n@@ -450,22 +428,15 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n             OverflowNeg => err_panic!(OverflowNeg),\n             DivisionByZero => err_panic!(DivisionByZero),\n             RemainderByZero => err_panic!(RemainderByZero),\n-            ResumedAfterReturn(generator_kind)\n-                => err_panic!(ResumedAfterReturn(*generator_kind)),\n-            ResumedAfterPanic(generator_kind)\n-                => err_panic!(ResumedAfterPanic(*generator_kind)),\n+            ResumedAfterReturn(generator_kind) => err_panic!(ResumedAfterReturn(*generator_kind)),\n+            ResumedAfterPanic(generator_kind) => err_panic!(ResumedAfterPanic(*generator_kind)),\n             Panic { .. } => bug!(\"`Panic` variant cannot occur in MIR\"),\n         }\n         .into())\n     }\n \n-    fn ptr_to_int(\n-        _mem: &Memory<'mir, 'tcx, Self>,\n-        _ptr: Pointer,\n-    ) -> InterpResult<'tcx, u64> {\n-        Err(\n-            ConstEvalError::NeedsRfc(\"pointer-to-integer cast\".to_string()).into(),\n-        )\n+    fn ptr_to_int(_mem: &Memory<'mir, 'tcx, Self>, _ptr: Pointer) -> InterpResult<'tcx, u64> {\n+        Err(ConstEvalError::NeedsRfc(\"pointer-to-integer cast\".to_string()).into())\n     }\n \n     fn binary_ptr_op(\n@@ -474,9 +445,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         _left: ImmTy<'tcx>,\n         _right: ImmTy<'tcx>,\n     ) -> InterpResult<'tcx, (Scalar, bool, Ty<'tcx>)> {\n-        Err(\n-            ConstEvalError::NeedsRfc(\"pointer arithmetic or comparison\".to_string()).into(),\n-        )\n+        Err(ConstEvalError::NeedsRfc(\"pointer arithmetic or comparison\".to_string()).into())\n     }\n \n     fn find_foreign_static(\n@@ -498,20 +467,15 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     }\n \n     #[inline(always)]\n-    fn tag_static_base_pointer(\n-        _memory_extra: &MemoryExtra,\n-        _id: AllocId,\n-    ) -> Self::PointerTag {\n+    fn tag_static_base_pointer(_memory_extra: &MemoryExtra, _id: AllocId) -> Self::PointerTag {\n         ()\n     }\n \n     fn box_alloc(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _dest: PlaceTy<'tcx>,\n     ) -> InterpResult<'tcx> {\n-        Err(\n-            ConstEvalError::NeedsRfc(\"heap allocations via `box` keyword\".to_string()).into(),\n-        )\n+        Err(ConstEvalError::NeedsRfc(\"heap allocations via `box` keyword\".to_string()).into())\n     }\n \n     fn before_terminator(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n@@ -530,12 +494,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         }\n \n         let span = ecx.frame().span;\n-        ecx.machine.loop_detector.observe_and_analyze(\n-            *ecx.tcx,\n-            span,\n-            &ecx.memory,\n-            &ecx.stack[..],\n-        )\n+        ecx.machine.loop_detector.observe_and_analyze(*ecx.tcx, span, &ecx.memory, &ecx.stack[..])\n     }\n \n     #[inline(always)]\n@@ -643,11 +602,7 @@ fn validate_and_turn_into_const<'tcx>(\n         let mplace = ecx.raw_const_to_mplace(constant)?;\n         let mut ref_tracking = RefTracking::new(mplace);\n         while let Some((mplace, path)) = ref_tracking.todo.pop() {\n-            ecx.validate_operand(\n-                mplace.into(),\n-                path,\n-                Some(&mut ref_tracking),\n-            )?;\n+            ecx.validate_operand(mplace.into(), path, Some(&mut ref_tracking))?;\n         }\n         // Now that we validated, turn this into a proper constant.\n         // Statics/promoteds are always `ByRef`, for the rest `op_to_const` decides\n@@ -693,7 +648,7 @@ pub fn const_eval_validated_provider<'tcx>(\n                 // Promoteds should never be \"too generic\" when getting evaluated.\n                 // They either don't get evaluated, or we are in a monomorphic context\n                 assert!(key.value.promoted.is_none());\n-            },\n+            }\n             // dedupliate calls\n             other => return other,\n         }\n@@ -707,17 +662,14 @@ pub fn const_eval_validated_provider<'tcx>(\n             ty::FnDef(_, substs) => substs,\n             _ => bug!(\"intrinsic with type {:?}\", ty),\n         };\n-        return eval_nullary_intrinsic(tcx, key.param_env, def_id, substs)\n-            .map_err(|error| {\n-                let span = tcx.def_span(def_id);\n-                let error = ConstEvalErr { error: error.kind, stacktrace: vec![], span };\n-                error.report_as_error(tcx.at(span), \"could not evaluate nullary intrinsic\")\n-            })\n+        return eval_nullary_intrinsic(tcx, key.param_env, def_id, substs).map_err(|error| {\n+            let span = tcx.def_span(def_id);\n+            let error = ConstEvalErr { error: error.kind, stacktrace: vec![], span };\n+            error.report_as_error(tcx.at(span), \"could not evaluate nullary intrinsic\")\n+        });\n     }\n \n-    tcx.const_eval_raw(key).and_then(|val| {\n-        validate_and_turn_into_const(tcx, val, key)\n-    })\n+    tcx.const_eval_raw(key).and_then(|val| validate_and_turn_into_const(tcx, val, key))\n }\n \n pub fn const_eval_raw_provider<'tcx>(\n@@ -737,7 +689,7 @@ pub fn const_eval_raw_provider<'tcx>(\n         key.param_env.reveal = Reveal::UserFacing;\n         match tcx.const_eval_raw(key) {\n             // try again with reveal all as requested\n-            Err(ErrorHandled::TooGeneric) => {},\n+            Err(ErrorHandled::TooGeneric) => {}\n             // dedupliate calls\n             other => return other,\n         }\n@@ -770,72 +722,68 @@ pub fn const_eval_raw_provider<'tcx>(\n     );\n \n     let res = ecx.load_mir(cid.instance.def, cid.promoted);\n-    res.and_then(\n-        |body| eval_body_using_ecx(&mut ecx, cid, *body)\n-    ).and_then(|place| {\n-        Ok(RawConst {\n-            alloc_id: place.ptr.assert_ptr().alloc_id,\n-            ty: place.layout.ty\n+    res.and_then(|body| eval_body_using_ecx(&mut ecx, cid, *body))\n+        .and_then(|place| {\n+            Ok(RawConst { alloc_id: place.ptr.assert_ptr().alloc_id, ty: place.layout.ty })\n         })\n-    }).map_err(|error| {\n-        let err = error_to_const_error(&ecx, error);\n-        // errors in statics are always emitted as fatal errors\n-        if is_static {\n-            // Ensure that if the above error was either `TooGeneric` or `Reported`\n-            // an error must be reported.\n-            let v = err.report_as_error(ecx.tcx, \"could not evaluate static initializer\");\n-            tcx.sess.delay_span_bug(\n-                err.span,\n-                &format!(\"static eval failure did not emit an error: {:#?}\", v)\n-            );\n-            v\n-        } else if def_id.is_local() {\n-            // constant defined in this crate, we can figure out a lint level!\n-            match tcx.def_kind(def_id) {\n-                // constants never produce a hard error at the definition site. Anything else is\n-                // a backwards compatibility hazard (and will break old versions of winapi for sure)\n-                //\n-                // note that validation may still cause a hard error on this very same constant,\n-                // because any code that existed before validation could not have failed validation\n-                // thus preventing such a hard error from being a backwards compatibility hazard\n-                Some(DefKind::Const) | Some(DefKind::AssocConst) => {\n-                    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-                    err.report_as_lint(\n-                        tcx.at(tcx.def_span(def_id)),\n-                        \"any use of this value will cause an error\",\n-                        hir_id,\n-                        Some(err.span),\n-                    )\n-                },\n-                // promoting runtime code is only allowed to error if it references broken constants\n-                // any other kind of error will be reported to the user as a deny-by-default lint\n-                _ => if let Some(p) = cid.promoted {\n-                    let span = tcx.promoted_mir(def_id)[p].span;\n-                    if let err_inval!(ReferencedConstant) = err.error {\n-                        err.report_as_error(\n-                            tcx.at(span),\n-                            \"evaluation of constant expression failed\",\n-                        )\n-                    } else {\n+        .map_err(|error| {\n+            let err = error_to_const_error(&ecx, error);\n+            // errors in statics are always emitted as fatal errors\n+            if is_static {\n+                // Ensure that if the above error was either `TooGeneric` or `Reported`\n+                // an error must be reported.\n+                let v = err.report_as_error(ecx.tcx, \"could not evaluate static initializer\");\n+                tcx.sess.delay_span_bug(\n+                    err.span,\n+                    &format!(\"static eval failure did not emit an error: {:#?}\", v),\n+                );\n+                v\n+            } else if def_id.is_local() {\n+                // constant defined in this crate, we can figure out a lint level!\n+                match tcx.def_kind(def_id) {\n+                    // constants never produce a hard error at the definition site. Anything else is\n+                    // a backwards compatibility hazard (and will break old versions of winapi for sure)\n+                    //\n+                    // note that validation may still cause a hard error on this very same constant,\n+                    // because any code that existed before validation could not have failed validation\n+                    // thus preventing such a hard error from being a backwards compatibility hazard\n+                    Some(DefKind::Const) | Some(DefKind::AssocConst) => {\n+                        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n                         err.report_as_lint(\n-                            tcx.at(span),\n-                            \"reaching this expression at runtime will panic or abort\",\n-                            tcx.hir().as_local_hir_id(def_id).unwrap(),\n+                            tcx.at(tcx.def_span(def_id)),\n+                            \"any use of this value will cause an error\",\n+                            hir_id,\n                             Some(err.span),\n                         )\n                     }\n-                // anything else (array lengths, enum initializers, constant patterns) are reported\n-                // as hard errors\n-                } else {\n-                    err.report_as_error(\n-                        ecx.tcx,\n-                        \"evaluation of constant value failed\",\n-                    )\n-                },\n+                    // promoting runtime code is only allowed to error if it references broken constants\n+                    // any other kind of error will be reported to the user as a deny-by-default lint\n+                    _ => {\n+                        if let Some(p) = cid.promoted {\n+                            let span = tcx.promoted_mir(def_id)[p].span;\n+                            if let err_inval!(ReferencedConstant) = err.error {\n+                                err.report_as_error(\n+                                    tcx.at(span),\n+                                    \"evaluation of constant expression failed\",\n+                                )\n+                            } else {\n+                                err.report_as_lint(\n+                                    tcx.at(span),\n+                                    \"reaching this expression at runtime will panic or abort\",\n+                                    tcx.hir().as_local_hir_id(def_id).unwrap(),\n+                                    Some(err.span),\n+                                )\n+                            }\n+                        // anything else (array lengths, enum initializers, constant patterns) are reported\n+                        // as hard errors\n+                        } else {\n+                            err.report_as_error(ecx.tcx, \"evaluation of constant value failed\")\n+                        }\n+                    }\n+                }\n+            } else {\n+                // use of broken constant from other crate\n+                err.report_as_error(ecx.tcx, \"could not evaluate constant\")\n             }\n-        } else {\n-            // use of broken constant from other crate\n-            err.report_as_error(ecx.tcx, \"could not evaluate constant\")\n-        }\n-    })\n+        })\n }"}, {"sha": "a558f0671e182be498dff4a26e2471a3e2103a71", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 126, "deletions": 145, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d", "patch": "@@ -7,21 +7,21 @@ use std::hash::Hash;\n \n use rustc::mir;\n use rustc::mir::interpret::truncate;\n-use rustc::ty::{self, Ty};\n use rustc::ty::layout::{\n-    self, Size, Align, LayoutOf, TyLayout, HasDataLayout, VariantIdx, PrimitiveExt\n+    self, Align, HasDataLayout, LayoutOf, PrimitiveExt, Size, TyLayout, VariantIdx,\n };\n use rustc::ty::TypeFoldable;\n+use rustc::ty::{self, Ty};\n use rustc_macros::HashStable;\n \n use super::{\n-    GlobalId, AllocId, Allocation, Scalar, InterpResult, Pointer, PointerArithmetic,\n-    InterpCx, Machine, AllocMap, AllocationExtra,\n-    RawConst, Immediate, ImmTy, ScalarMaybeUndef, Operand, OpTy, MemoryKind, LocalValue,\n+    AllocId, AllocMap, Allocation, AllocationExtra, GlobalId, ImmTy, Immediate, InterpCx,\n+    InterpResult, LocalValue, Machine, MemoryKind, OpTy, Operand, Pointer, PointerArithmetic,\n+    RawConst, Scalar, ScalarMaybeUndef,\n };\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable)]\n-pub struct MemPlace<Tag=(), Id=AllocId> {\n+pub struct MemPlace<Tag = (), Id = AllocId> {\n     /// A place may have an integral pointer for ZSTs, and since it might\n     /// be turned back into a reference before ever being dereferenced.\n     /// However, it may never be undef.\n@@ -34,20 +34,17 @@ pub struct MemPlace<Tag=(), Id=AllocId> {\n }\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable)]\n-pub enum Place<Tag=(), Id=AllocId> {\n+pub enum Place<Tag = (), Id = AllocId> {\n     /// A place referring to a value allocated in the `Memory` system.\n     Ptr(MemPlace<Tag, Id>),\n \n     /// To support alloc-free locals, we are able to write directly to a local.\n     /// (Without that optimization, we'd just always be a `MemPlace`.)\n-    Local {\n-        frame: usize,\n-        local: mir::Local,\n-    },\n+    Local { frame: usize, local: mir::Local },\n }\n \n #[derive(Copy, Clone, Debug)]\n-pub struct PlaceTy<'tcx, Tag=()> {\n+pub struct PlaceTy<'tcx, Tag = ()> {\n     place: Place<Tag>, // Keep this private; it helps enforce invariants.\n     pub layout: TyLayout<'tcx>,\n }\n@@ -62,7 +59,7 @@ impl<'tcx, Tag> ::std::ops::Deref for PlaceTy<'tcx, Tag> {\n \n /// A MemPlace with its layout. Constructing it is only possible in this module.\n #[derive(Copy, Clone, Debug, Hash, Eq, PartialEq)]\n-pub struct MPlaceTy<'tcx, Tag=()> {\n+pub struct MPlaceTy<'tcx, Tag = ()> {\n     mplace: MemPlace<Tag>,\n     pub layout: TyLayout<'tcx>,\n }\n@@ -78,22 +75,15 @@ impl<'tcx, Tag> ::std::ops::Deref for MPlaceTy<'tcx, Tag> {\n impl<'tcx, Tag> From<MPlaceTy<'tcx, Tag>> for PlaceTy<'tcx, Tag> {\n     #[inline(always)]\n     fn from(mplace: MPlaceTy<'tcx, Tag>) -> Self {\n-        PlaceTy {\n-            place: Place::Ptr(mplace.mplace),\n-            layout: mplace.layout\n-        }\n+        PlaceTy { place: Place::Ptr(mplace.mplace), layout: mplace.layout }\n     }\n }\n \n impl<Tag> MemPlace<Tag> {\n     /// Replace ptr tag, maintain vtable tag (if any)\n     #[inline]\n     pub fn replace_tag(self, new_tag: Tag) -> Self {\n-        MemPlace {\n-            ptr: self.ptr.erase_tag().with_tag(new_tag),\n-            align: self.align,\n-            meta: self.meta,\n-        }\n+        MemPlace { ptr: self.ptr.erase_tag().with_tag(new_tag), align: self.align, meta: self.meta }\n     }\n \n     #[inline]\n@@ -107,11 +97,7 @@ impl<Tag> MemPlace<Tag> {\n \n     #[inline(always)]\n     pub fn from_scalar_ptr(ptr: Scalar<Tag>, align: Align) -> Self {\n-        MemPlace {\n-            ptr,\n-            align,\n-            meta: None,\n-        }\n+        MemPlace { ptr, align, meta: None }\n     }\n \n     /// Produces a Place that will error if attempted to be read from or written to\n@@ -156,19 +142,16 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n         MPlaceTy {\n             mplace: MemPlace::from_scalar_ptr(\n                 Scalar::from_uint(layout.align.abi.bytes(), cx.pointer_size()),\n-                layout.align.abi\n+                layout.align.abi,\n             ),\n-            layout\n+            layout,\n         }\n     }\n \n     /// Replace ptr tag, maintain vtable tag (if any)\n     #[inline]\n     pub fn replace_tag(self, new_tag: Tag) -> Self {\n-        MPlaceTy {\n-            mplace: self.mplace.replace_tag(new_tag),\n-            layout: self.layout,\n-        }\n+        MPlaceTy { mplace: self.mplace.replace_tag(new_tag), layout: self.layout }\n     }\n \n     #[inline]\n@@ -179,10 +162,7 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n         layout: TyLayout<'tcx>,\n         cx: &impl HasDataLayout,\n     ) -> InterpResult<'tcx, Self> {\n-        Ok(MPlaceTy {\n-            mplace: self.mplace.offset(offset, meta, cx)?,\n-            layout,\n-        })\n+        Ok(MPlaceTy { mplace: self.mplace.offset(offset, meta, cx)?, layout })\n     }\n \n     #[inline]\n@@ -195,8 +175,7 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n         if self.layout.is_unsized() {\n             // We need to consult `meta` metadata\n             match self.layout.ty.kind {\n-                ty::Slice(..) | ty::Str =>\n-                    return self.mplace.meta.unwrap().to_machine_usize(cx),\n+                ty::Slice(..) | ty::Str => return self.mplace.meta.unwrap().to_machine_usize(cx),\n                 _ => bug!(\"len not supported on unsized type {:?}\", self.layout.ty),\n             }\n         } else {\n@@ -256,7 +235,6 @@ impl<Tag: ::std::fmt::Debug> Place<Tag> {\n         match self {\n             Place::Ptr(mplace) => mplace,\n             _ => bug!(\"assert_mem_place: expected Place::Ptr, got {:?}\", self),\n-\n         }\n     }\n }\n@@ -288,9 +266,8 @@ where\n         &self,\n         val: ImmTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n-        let pointee_type = val.layout.ty.builtin_deref(true)\n-            .expect(\"`ref_to_mplace` called on non-ptr type\")\n-            .ty;\n+        let pointee_type =\n+            val.layout.ty.builtin_deref(true).expect(\"`ref_to_mplace` called on non-ptr type\").ty;\n         let layout = self.layout_of(pointee_type)?;\n         let (ptr, meta) = match *val {\n             Immediate::Scalar(ptr) => (ptr.not_undef()?, None),\n@@ -347,7 +324,8 @@ where\n         &self,\n         mut place: MPlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n-        let (size, align) = self.size_and_align_of_mplace(place)?\n+        let (size, align) = self\n+            .size_and_align_of_mplace(place)?\n             .unwrap_or((place.layout.size, place.layout.align.abi));\n         assert!(place.mplace.align <= align, \"dynamic alignment less strict than static one?\");\n         place.mplace.align = align; // maximally strict checking\n@@ -379,8 +357,9 @@ where\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         // Not using the layout method because we want to compute on u64\n         let offset = match base.layout.fields {\n-            layout::FieldPlacement::Arbitrary { ref offsets, .. } =>\n-                offsets[usize::try_from(field).unwrap()],\n+            layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n+                offsets[usize::try_from(field).unwrap()]\n+            }\n             layout::FieldPlacement::Array { stride, .. } => {\n                 let len = base.len(self)?;\n                 if field >= len {\n@@ -390,9 +369,13 @@ where\n                 stride * field\n             }\n             layout::FieldPlacement::Union(count) => {\n-                assert!(field < count as u64,\n-                        \"Tried to access field {} of union {:#?} with {} fields\",\n-                        field, base.layout, count);\n+                assert!(\n+                    field < count as u64,\n+                    \"Tried to access field {} of union {:#?} with {} fields\",\n+                    field,\n+                    base.layout,\n+                    count\n+                );\n                 // Offset is always 0\n                 Size::from_bytes(0)\n             }\n@@ -409,13 +392,14 @@ where\n             let align = match self.size_and_align_of(base.meta, field_layout)? {\n                 Some((_, align)) => align,\n                 None if offset == Size::ZERO =>\n-                    // An extern type at offset 0, we fall back to its static alignment.\n-                    // FIXME: Once we have made decisions for how to handle size and alignment\n-                    // of `extern type`, this should be adapted.  It is just a temporary hack\n-                    // to get some code to work that probably ought to work.\n-                    field_layout.align.abi,\n-                None =>\n-                    bug!(\"Cannot compute offset for extern type field at non-0 offset\"),\n+                // An extern type at offset 0, we fall back to its static alignment.\n+                // FIXME: Once we have made decisions for how to handle size and alignment\n+                // of `extern type`, this should be adapted.  It is just a temporary hack\n+                // to get some code to work that probably ought to work.\n+                {\n+                    field_layout.align.abi\n+                }\n+                None => bug!(\"Cannot compute offset for extern type field at non-0 offset\"),\n             };\n             (base.meta, offset.align_to(align))\n         } else {\n@@ -467,8 +451,7 @@ where\n         // Not using layout method because that works with usize, and does not work with slices\n         // (that have count 0 in their layout).\n         let from_offset = match base.layout.fields {\n-            layout::FieldPlacement::Array { stride, .. } =>\n-                stride * from,\n+            layout::FieldPlacement::Array { stride, .. } => stride * from,\n             _ => bug!(\"Unexpected layout of index access: {:#?}\", base.layout),\n         };\n \n@@ -477,14 +460,12 @@ where\n         let (meta, ty) = match base.layout.ty.kind {\n             // It is not nice to match on the type, but that seems to be the only way to\n             // implement this.\n-            ty::Array(inner, _) =>\n-                (None, self.tcx.mk_array(inner, inner_len)),\n+            ty::Array(inner, _) => (None, self.tcx.mk_array(inner, inner_len)),\n             ty::Slice(..) => {\n                 let len = Scalar::from_uint(inner_len, self.pointer_size());\n                 (Some(len), base.layout.ty)\n             }\n-            _ =>\n-                bug!(\"cannot subslice non-array type: `{:?}`\", base.layout.ty),\n+            _ => bug!(\"cannot subslice non-array type: `{:?}`\", base.layout.ty),\n         };\n         let layout = self.layout_of(ty)?;\n         base.offset(from_offset, meta, layout, self)\n@@ -520,11 +501,7 @@ where\n                 self.mplace_field(base, u64::try_from(n).unwrap())?\n             }\n \n-            ConstantIndex {\n-                offset,\n-                min_length,\n-                from_end,\n-            } => {\n+            ConstantIndex { offset, min_length, from_end } => {\n                 let n = base.len(self)?;\n                 if n < min_length as u64 {\n                     // This can only be reached in ConstProp and non-rustc-MIR.\n@@ -542,8 +519,9 @@ where\n                 self.mplace_field(base, index)?\n             }\n \n-            Subslice { from, to, from_end } =>\n-                self.mplace_subslice(base, u64::from(from), u64::from(to), from_end)?,\n+            Subslice { from, to, from_end } => {\n+                self.mplace_subslice(base, u64::from(from), u64::from(to), from_end)?\n+            }\n         })\n     }\n \n@@ -569,8 +547,9 @@ where\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         // Downcast just changes the layout\n         Ok(match base.place {\n-            Place::Ptr(mplace) =>\n-                self.mplace_downcast(MPlaceTy { mplace, layout: base.layout }, variant)?.into(),\n+            Place::Ptr(mplace) => {\n+                self.mplace_downcast(MPlaceTy { mplace, layout: base.layout }, variant)?.into()\n+            }\n             Place::Local { .. } => {\n                 let layout = base.layout.for_variant(self, variant);\n                 PlaceTy { layout, ..base }\n@@ -586,7 +565,7 @@ where\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         use rustc::mir::ProjectionElem::*;\n         Ok(match *proj_elem {\n-            Field(field, _) =>  self.place_field(base, field.index() as u64)?,\n+            Field(field, _) => self.place_field(base, field.index() as u64)?,\n             Downcast(_, variant) => self.place_downcast(base, variant)?,\n             Deref => self.deref_operand(self.place_to_op(base)?)?.into(),\n             // For the other variants, we have to force an allocation.\n@@ -602,7 +581,7 @@ where\n     /// `eval_place` and `eval_place_to_op`.\n     pub(super) fn eval_static_to_mplace(\n         &self,\n-        place_static: &mir::Static<'tcx>\n+        place_static: &mir::Static<'tcx>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         use rustc::mir::StaticKind;\n \n@@ -617,10 +596,7 @@ where\n                     throw_inval!(TooGeneric);\n                 }\n \n-                self.const_eval_raw(GlobalId {\n-                    instance,\n-                    promoted: Some(promoted),\n-                })?\n+                self.const_eval_raw(GlobalId { instance, promoted: Some(promoted) })?\n             }\n \n             StaticKind::Static => {\n@@ -674,19 +650,14 @@ where\n                         // bail out.\n                         None => Place::null(&*self),\n                     },\n-                    layout: self.layout_of(\n-                        self.subst_from_frame_and_normalize_erasing_regions(\n-                            self.frame().body.return_ty()\n-                        )\n-                    )?,\n+                    layout: self.layout_of(self.subst_from_frame_and_normalize_erasing_regions(\n+                        self.frame().body.return_ty(),\n+                    ))?,\n                 }\n-            },\n+            }\n             PlaceBase::Local(local) => PlaceTy {\n                 // This works even for dead/uninitialized locals; we check further when writing\n-                place: Place::Local {\n-                    frame: self.cur_frame(),\n-                    local: *local,\n-                },\n+                place: Place::Local { frame: self.cur_frame(), local: *local },\n                 layout: self.layout_of_local(self.frame(), *local, None)?,\n             },\n             PlaceBase::Static(place_static) => self.eval_static_to_mplace(&place_static)?.into(),\n@@ -756,13 +727,19 @@ where\n             // This is a very common path, avoid some checks in release mode\n             assert!(!dest.layout.is_unsized(), \"Cannot write unsized data\");\n             match src {\n-                Immediate::Scalar(ScalarMaybeUndef::Scalar(Scalar::Ptr(_))) =>\n-                    assert_eq!(self.pointer_size(), dest.layout.size,\n-                        \"Size mismatch when writing pointer\"),\n-                Immediate::Scalar(ScalarMaybeUndef::Scalar(Scalar::Raw { size, .. })) =>\n-                    assert_eq!(Size::from_bytes(size.into()), dest.layout.size,\n-                        \"Size mismatch when writing bits\"),\n-                Immediate::Scalar(ScalarMaybeUndef::Undef) => {}, // undef can have any size\n+                Immediate::Scalar(ScalarMaybeUndef::Scalar(Scalar::Ptr(_))) => assert_eq!(\n+                    self.pointer_size(),\n+                    dest.layout.size,\n+                    \"Size mismatch when writing pointer\"\n+                ),\n+                Immediate::Scalar(ScalarMaybeUndef::Scalar(Scalar::Raw { size, .. })) => {\n+                    assert_eq!(\n+                        Size::from_bytes(size.into()),\n+                        dest.layout.size,\n+                        \"Size mismatch when writing bits\"\n+                    )\n+                }\n+                Immediate::Scalar(ScalarMaybeUndef::Undef) => {} // undef can have any size\n                 Immediate::ScalarPair(_, _) => {\n                     // FIXME: Can we check anything here?\n                 }\n@@ -785,7 +762,7 @@ where\n                         mplace\n                     }\n                 }\n-            },\n+            }\n             Place::Ptr(mplace) => mplace, // already referring to memory\n         };\n         let dest = MPlaceTy { mplace, layout: dest.layout };\n@@ -808,8 +785,7 @@ where\n         // wrong type.\n \n         // Invalid places are a thing: the return place of a diverging function\n-        let ptr = match self.check_mplace_access(dest, None)?\n-        {\n+        let ptr = match self.check_mplace_access(dest, None)? {\n             Some(ptr) => ptr,\n             None => return Ok(()), // zero-sized access\n         };\n@@ -821,12 +797,16 @@ where\n         match value {\n             Immediate::Scalar(scalar) => {\n                 match dest.layout.abi {\n-                    layout::Abi::Scalar(_) => {}, // fine\n-                    _ => bug!(\"write_immediate_to_mplace: invalid Scalar layout: {:#?}\",\n-                            dest.layout)\n+                    layout::Abi::Scalar(_) => {} // fine\n+                    _ => {\n+                        bug!(\"write_immediate_to_mplace: invalid Scalar layout: {:#?}\", dest.layout)\n+                    }\n                 }\n                 self.memory.get_raw_mut(ptr.alloc_id)?.write_scalar(\n-                    tcx, ptr, scalar, dest.layout.size\n+                    tcx,\n+                    ptr,\n+                    scalar,\n+                    dest.layout.size,\n                 )\n             }\n             Immediate::ScalarPair(a_val, b_val) => {\n@@ -835,8 +815,10 @@ where\n                 // which `ptr.offset(b_offset)` cannot possibly fail to satisfy.\n                 let (a, b) = match dest.layout.abi {\n                     layout::Abi::ScalarPair(ref a, ref b) => (&a.value, &b.value),\n-                    _ => bug!(\"write_immediate_to_mplace: invalid ScalarPair layout: {:#?}\",\n-                              dest.layout)\n+                    _ => bug!(\n+                        \"write_immediate_to_mplace: invalid ScalarPair layout: {:#?}\",\n+                        dest.layout\n+                    ),\n                 };\n                 let (a_size, b_size) = (a.size(self), b.size(self));\n                 let b_offset = a_size.align_to(b.align(self).abi);\n@@ -846,12 +828,8 @@ where\n                 // but that does not work: We could be a newtype around a pair, then the\n                 // fields do not match the `ScalarPair` components.\n \n-                self.memory\n-                    .get_raw_mut(ptr.alloc_id)?\n-                    .write_scalar(tcx, ptr, a_val, a_size)?;\n-                self.memory\n-                    .get_raw_mut(b_ptr.alloc_id)?\n-                    .write_scalar(tcx, b_ptr, b_val, b_size)\n+                self.memory.get_raw_mut(ptr.alloc_id)?.write_scalar(tcx, ptr, a_val, a_size)?;\n+                self.memory.get_raw_mut(b_ptr.alloc_id)?.write_scalar(tcx, b_ptr, b_val, b_size)\n             }\n         }\n     }\n@@ -885,8 +863,12 @@ where\n     ) -> InterpResult<'tcx> {\n         // We do NOT compare the types for equality, because well-typed code can\n         // actually \"transmute\" `&mut T` to `&T` in an assignment without a cast.\n-        assert!(src.layout.details == dest.layout.details,\n-            \"Layout mismatch when copying!\\nsrc: {:#?}\\ndest: {:#?}\", src, dest);\n+        assert!(\n+            src.layout.details == dest.layout.details,\n+            \"Layout mismatch when copying!\\nsrc: {:#?}\\ndest: {:#?}\",\n+            src,\n+            dest\n+        );\n \n         // Let us see if the layout is simple so we take a shortcut, avoid force_allocation.\n         let src = match self.try_read_immediate(src)? {\n@@ -906,28 +888,27 @@ where\n         // is being initialized!\n         let (dest, size) = self.force_allocation_maybe_sized(dest, src.meta)?;\n         let size = size.unwrap_or_else(|| {\n-            assert!(!dest.layout.is_unsized(),\n-                \"Cannot copy into already initialized unsized place\");\n+            assert!(\n+                !dest.layout.is_unsized(),\n+                \"Cannot copy into already initialized unsized place\"\n+            );\n             dest.layout.size\n         });\n         assert_eq!(src.meta, dest.meta, \"Can only copy between equally-sized instances\");\n \n-        let src = self.check_mplace_access(src, Some(size))\n+        let src = self\n+            .check_mplace_access(src, Some(size))\n             .expect(\"places should be checked on creation\");\n-        let dest = self.check_mplace_access(dest, Some(size))\n+        let dest = self\n+            .check_mplace_access(dest, Some(size))\n             .expect(\"places should be checked on creation\");\n         let (src_ptr, dest_ptr) = match (src, dest) {\n             (Some(src_ptr), Some(dest_ptr)) => (src_ptr, dest_ptr),\n             (None, None) => return Ok(()), // zero-sized copy\n             _ => bug!(\"The pointers should both be Some or both None\"),\n         };\n \n-        self.memory.copy(\n-            src_ptr,\n-            dest_ptr,\n-            size,\n-            /*nonoverlapping*/ true,\n-        )\n+        self.memory.copy(src_ptr, dest_ptr, size, /*nonoverlapping*/ true)\n     }\n \n     /// Copies the data from an operand to a place. The layouts may disagree, but they must\n@@ -942,12 +923,18 @@ where\n             return self.copy_op(src, dest);\n         }\n         // We still require the sizes to match.\n-        assert!(src.layout.size == dest.layout.size,\n-            \"Size mismatch when transmuting!\\nsrc: {:#?}\\ndest: {:#?}\", src, dest);\n+        assert!(\n+            src.layout.size == dest.layout.size,\n+            \"Size mismatch when transmuting!\\nsrc: {:#?}\\ndest: {:#?}\",\n+            src,\n+            dest\n+        );\n         // Unsized copies rely on interpreting `src.meta` with `dest.layout`, we want\n         // to avoid that here.\n-        assert!(!src.layout.is_unsized() && !dest.layout.is_unsized(),\n-            \"Cannot transmute unsized data\");\n+        assert!(\n+            !src.layout.is_unsized() && !dest.layout.is_unsized(),\n+            \"Cannot transmute unsized data\"\n+        );\n \n         // The hard case is `ScalarPair`.  `src` is already read from memory in this case,\n         // using `src.layout` to figure out which bytes to use for the 1st and 2nd field.\n@@ -1006,7 +993,8 @@ where\n                         // that has different alignment than the outer field.\n                         // We also need to support unsized types, and hence cannot use `allocate`.\n                         let local_layout = self.layout_of_local(&self.stack[frame], local, None)?;\n-                        let (size, align) = self.size_and_align_of(meta, local_layout)?\n+                        let (size, align) = self\n+                            .size_and_align_of(meta, local_layout)?\n                             .expect(\"Cannot allocate for non-dyn-sized type\");\n                         let ptr = self.memory.allocate(size, align, MemoryKind::Stack);\n                         let mplace = MemPlace { ptr: ptr.into(), align, meta };\n@@ -1026,7 +1014,7 @@ where\n                     Err(mplace) => (mplace, None), // this already was an indirect local\n                 }\n             }\n-            Place::Ptr(mplace) => (mplace, None)\n+            Place::Ptr(mplace) => (mplace, None),\n         };\n         // Return with the original layout, so that the caller can go on\n         Ok((MPlaceTy { mplace, layout: place.layout }, size))\n@@ -1057,11 +1045,8 @@ where\n     ) -> MPlaceTy<'tcx, M::PointerTag> {\n         let ptr = self.memory.allocate_static_bytes(str.as_bytes(), kind);\n         let meta = Scalar::from_uint(str.len() as u128, self.pointer_size());\n-        let mplace = MemPlace {\n-            ptr: ptr.into(),\n-            align: Align::from_bytes(1).unwrap(),\n-            meta: Some(meta),\n-        };\n+        let mplace =\n+            MemPlace { ptr: ptr.into(), align: Align::from_bytes(1).unwrap(), meta: Some(meta) };\n \n         let layout = self.layout_of(self.tcx.mk_static_str()).unwrap();\n         MPlaceTy { mplace, layout }\n@@ -1072,7 +1057,6 @@ where\n         variant_index: VariantIdx,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n-\n         // Layout computation excludes uninhabited variants from consideration\n         // therefore there's no way to represent those variants in the given layout.\n         if dest.layout.for_variant(self, variant_index).abi.is_uninhabited() {\n@@ -1105,11 +1089,8 @@ where\n                 self.write_scalar(Scalar::from_uint(discr_val, size), discr_dest)?;\n             }\n             layout::Variants::Multiple {\n-                discr_kind: layout::DiscriminantKind::Niche {\n-                    dataful_variant,\n-                    ref niche_variants,\n-                    niche_start,\n-                },\n+                discr_kind:\n+                    layout::DiscriminantKind::Niche { dataful_variant, ref niche_variants, niche_start },\n                 discr: ref discr_layout,\n                 discr_index,\n                 ..\n@@ -1119,7 +1100,8 @@ where\n \n                 if variant_index != dataful_variant {\n                     let variants_start = niche_variants.start().as_u32();\n-                    let variant_index_relative = variant_index.as_u32()\n+                    let variant_index_relative = variant_index\n+                        .as_u32()\n                         .checked_sub(variants_start)\n                         .expect(\"overflow computing relative variant idx\");\n                     // We need to use machine arithmetic when taking into account `niche_start`:\n@@ -1156,8 +1138,10 @@ where\n \n     /// Turn a place with a `dyn Trait` type into a place with the actual dynamic type.\n     /// Also return some more information so drop doesn't have to run the same code twice.\n-    pub(super) fn unpack_dyn_trait(&self, mplace: MPlaceTy<'tcx, M::PointerTag>)\n-    -> InterpResult<'tcx, (ty::Instance<'tcx>, MPlaceTy<'tcx, M::PointerTag>)> {\n+    pub(super) fn unpack_dyn_trait(\n+        &self,\n+        mplace: MPlaceTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, (ty::Instance<'tcx>, MPlaceTy<'tcx, M::PointerTag>)> {\n         let vtable = mplace.vtable(); // also sanity checks the type\n         let (instance, ty) = self.read_drop_type_from_vtable(vtable)?;\n         let layout = self.layout_of(ty)?;\n@@ -1170,10 +1154,7 @@ where\n             assert_eq!(align, layout.align.abi);\n         }\n \n-        let mplace = MPlaceTy {\n-            mplace: MemPlace { meta: None, ..*mplace },\n-            layout\n-        };\n+        let mplace = MPlaceTy { mplace: MemPlace { meta: None, ..*mplace }, layout };\n         Ok((instance, mplace))\n     }\n }"}, {"sha": "0a783337ad15069cdf64fcb5d76c41f739b15f59", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d"}, {"sha": "c3a5175abac53b678d1012d60ee7f30597d502e6", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 183, "deletions": 110, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d"}, {"sha": "979489319a5d38794abb97e061a9fca197cf6515", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 501, "deletions": 384, "changes": 885, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d"}, {"sha": "800c40ffdb173b25f961cb711b1f237015daa1e7", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 497, "deletions": 414, "changes": 911, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d"}, {"sha": "5f0fbcc3b0fd9b65d3a7ab4973a5110fec91174e", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 591, "deletions": 571, "changes": 1162, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d"}, {"sha": "8a74143de01351148dbdd7f9408401274526dd7e", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 76, "deletions": 61, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d"}, {"sha": "7daa489374fabf6fe6cd2cabf7521f63df483506", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 217, "deletions": 235, "changes": 452, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d"}, {"sha": "0b26933459f2527bbda96b18479286ad9864b608", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 152, "deletions": 177, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d"}, {"sha": "8e79cc13895629fd771762c9620d9fa6d5e5f0b9", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1023, "deletions": 1024, "changes": 2047, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d"}, {"sha": "4c349a27c215a23cefa818e7a1f207dfbc8dcf04", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 191, "deletions": 225, "changes": 416, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d"}, {"sha": "862c6c56c78f8aadc638b46fc6da101fb8af4dcd", "filename": "src/librustdoc/html/markdown/tests.rs", "status": "modified", "additions": 162, "deletions": 71, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustdoc%2Fhtml%2Fmarkdown%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibrustdoc%2Fhtml%2Fmarkdown%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown%2Ftests.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d"}, {"sha": "500e62b1cb59d290fc1b5467ef1281aee1cfc1c1", "filename": "src/libstd/sys/sgx/abi/mem.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmem.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d"}, {"sha": "95be564b33030f8cf505f6d78a1c341c54bd6739", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 181, "deletions": 132, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d"}, {"sha": "2ca0224812bab062bee70243c09df705205f0c19", "filename": "src/libsyntax_expand/parse/lexer/tests.rs", "status": "modified", "additions": 10, "deletions": 28, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibsyntax_expand%2Fparse%2Flexer%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibsyntax_expand%2Fparse%2Flexer%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fparse%2Flexer%2Ftests.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d"}, {"sha": "154ccb256216c591ff700ea9a5663879409662d0", "filename": "src/libsyntax_expand/parse/tests.rs", "status": "modified", "additions": 106, "deletions": 89, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibsyntax_expand%2Fparse%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibsyntax_expand%2Fparse%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fparse%2Ftests.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d"}, {"sha": "edf427edaae156c9b8678be9eb9b98f89b09e731", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 205, "deletions": 144, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d"}, {"sha": "481163a1a9abe7a75e54cc64153a501019fe3411", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 160, "deletions": 110, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6891388e661c2bbf965a330ff73bf8c08a7dbf7d/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=6891388e661c2bbf965a330ff73bf8c08a7dbf7d"}]}