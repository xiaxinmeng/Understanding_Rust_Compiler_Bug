{"sha": "9e85589ad3ba61169cd7722520981c1bebb5b542", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllODU1ODlhZDNiYTYxMTY5Y2Q3NzIyNTIwOTgxYzFiZWJiNWI1NDI=", "commit": {"author": {"name": "Seo Sanghyeon", "email": "sanxiyn@gmail.com", "date": "2013-02-26T18:58:46Z"}, "committer": {"name": "Seo Sanghyeon", "email": "sanxiyn@gmail.com", "date": "2013-03-11T10:01:51Z"}, "message": "Implement vector destructuring from tail", "tree": {"sha": "1d68ce130c65097656972cb71e084fbcaf410555", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d68ce130c65097656972cb71e084fbcaf410555"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e85589ad3ba61169cd7722520981c1bebb5b542", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e85589ad3ba61169cd7722520981c1bebb5b542", "html_url": "https://github.com/rust-lang/rust/commit/9e85589ad3ba61169cd7722520981c1bebb5b542", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e85589ad3ba61169cd7722520981c1bebb5b542/comments", "author": {"login": "sanxiyn", "id": 45249, "node_id": "MDQ6VXNlcjQ1MjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/45249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sanxiyn", "html_url": "https://github.com/sanxiyn", "followers_url": "https://api.github.com/users/sanxiyn/followers", "following_url": "https://api.github.com/users/sanxiyn/following{/other_user}", "gists_url": "https://api.github.com/users/sanxiyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/sanxiyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sanxiyn/subscriptions", "organizations_url": "https://api.github.com/users/sanxiyn/orgs", "repos_url": "https://api.github.com/users/sanxiyn/repos", "events_url": "https://api.github.com/users/sanxiyn/events{/privacy}", "received_events_url": "https://api.github.com/users/sanxiyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sanxiyn", "id": 45249, "node_id": "MDQ6VXNlcjQ1MjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/45249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sanxiyn", "html_url": "https://github.com/sanxiyn", "followers_url": "https://api.github.com/users/sanxiyn/followers", "following_url": "https://api.github.com/users/sanxiyn/following{/other_user}", "gists_url": "https://api.github.com/users/sanxiyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/sanxiyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sanxiyn/subscriptions", "organizations_url": "https://api.github.com/users/sanxiyn/orgs", "repos_url": "https://api.github.com/users/sanxiyn/repos", "events_url": "https://api.github.com/users/sanxiyn/events{/privacy}", "received_events_url": "https://api.github.com/users/sanxiyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58618fb8cfd791a930261ff68ae6bc77e0bc4412", "url": "https://api.github.com/repos/rust-lang/rust/commits/58618fb8cfd791a930261ff68ae6bc77e0bc4412", "html_url": "https://github.com/rust-lang/rust/commit/58618fb8cfd791a930261ff68ae6bc77e0bc4412"}], "stats": {"total": 400, "additions": 241, "deletions": 159}, "files": [{"sha": "6e998864def57e658e0366e9509a0e89de9904b6", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9e85589ad3ba61169cd7722520981c1bebb5b542/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e85589ad3ba61169cd7722520981c1bebb5b542/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=9e85589ad3ba61169cd7722520981c1bebb5b542", "patch": "@@ -617,17 +617,17 @@ pub impl GatherLoanCtxt {\n                 }\n               }\n \n-              ast::pat_vec(_, Some(tail_pat)) => {\n-                  // The `tail_pat` here creates a slice into the\n+              ast::pat_vec(_, Some(slice_pat), _) => {\n+                  // The `slice_pat` here creates a slice into the\n                   // original vector.  This is effectively a borrow of\n                   // the elements of the vector being matched.\n \n-                  let tail_ty = self.tcx().ty(tail_pat);\n-                  let (tail_mutbl, tail_r) =\n-                      self.vec_slice_info(tail_pat, tail_ty);\n+                  let slice_ty = self.tcx().ty(slice_pat);\n+                  let (slice_mutbl, slice_r) =\n+                      self.vec_slice_info(slice_pat, slice_ty);\n                   let mcx = self.bccx.mc_ctxt();\n-                  let cmt_index = mcx.cat_index(tail_pat, cmt);\n-                  self.guarantee_valid(cmt_index, tail_mutbl, tail_r);\n+                  let cmt_index = mcx.cat_index(slice_pat, cmt);\n+                  self.guarantee_valid(cmt_index, slice_mutbl, slice_r);\n               }\n \n               _ => {}\n@@ -637,7 +637,7 @@ pub impl GatherLoanCtxt {\n \n     fn vec_slice_info(@mut self,\n                       pat: @ast::pat,\n-                      tail_ty: ty::t) -> (ast::mutability, ty::Region) {\n+                      slice_ty: ty::t) -> (ast::mutability, ty::Region) {\n         /*!\n          *\n          * In a pattern like [a, b, ..c], normally `c` has slice type,\n@@ -646,9 +646,9 @@ pub impl GatherLoanCtxt {\n          * to recurse through rptrs.\n          */\n \n-        match ty::get(tail_ty).sty {\n-            ty::ty_evec(tail_mt, ty::vstore_slice(tail_r)) => {\n-                (tail_mt.mutbl, tail_r)\n+        match ty::get(slice_ty).sty {\n+            ty::ty_evec(slice_mt, ty::vstore_slice(slice_r)) => {\n+                (slice_mt.mutbl, slice_r)\n             }\n \n             ty::ty_rptr(_, ref mt) => {\n@@ -658,7 +658,7 @@ pub impl GatherLoanCtxt {\n             _ => {\n                 self.tcx().sess.span_bug(\n                     pat.span,\n-                    fmt!(\"Type of tail pattern is not a slice\"));\n+                    fmt!(\"Type of slice pattern is not a slice\"));\n             }\n         }\n     }"}, {"sha": "a7fb1506d181b0a65aab9d81308839d9e288e286", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9e85589ad3ba61169cd7722520981c1bebb5b542/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e85589ad3ba61169cd7722520981c1bebb5b542/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=9e85589ad3ba61169cd7722520981c1bebb5b542", "patch": "@@ -244,7 +244,9 @@ pub fn is_useful(cx: @MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n               ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n                 let max_len = do m.foldr(0) |r, max_len| {\n                   match /*bad*/copy r[0].node {\n-                    pat_vec(elems, _) => uint::max(elems.len(), max_len),\n+                    pat_vec(before, _, after) => {\n+                      uint::max(before.len() + after.len(), max_len)\n+                    }\n                     _ => max_len\n                   }\n                 };\n@@ -322,10 +324,10 @@ pub fn pat_ctor_id(cx: @MatchCheckCtxt, p: @pat) -> Option<ctor> {\n       pat_box(_) | pat_uniq(_) | pat_tup(_) | pat_region(*) => {\n         Some(single)\n       }\n-      pat_vec(elems, tail) => {\n-        match tail {\n+      pat_vec(before, slice, after) => {\n+        match slice {\n           Some(_) => None,\n-          None => Some(vec(elems.len()))\n+          None => Some(vec(before.len() + after.len()))\n         }\n       }\n     }\n@@ -393,47 +395,47 @@ pub fn missing_ctor(cx: @MatchCheckCtxt,\n       }\n       ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n \n-        // Find the lengths and tails of all vector patterns.\n+        // Find the lengths and slices of all vector patterns.\n         let vec_pat_lens = do m.filter_mapped |r| {\n             match r[0].node {\n-                pat_vec(ref elems, ref tail) => {\n-                    Some((elems.len(), tail.is_some()))\n+                pat_vec(ref before, ref slice, ref after) => {\n+                    Some((before.len() + after.len(), slice.is_some()))\n                 }\n                 _ => None\n             }\n         };\n \n         // Sort them by length such that for patterns of the same length,\n-        // those with a destructured tail come first.\n+        // those with a destructured slice come first.\n         let mut sorted_vec_lens = sort::merge_sort(vec_pat_lens,\n-            |&(len1, tail1), &(len2, tail2)| {\n+            |&(len1, slice1), &(len2, slice2)| {\n                 if len1 == len2 {\n-                    tail1 > tail2\n+                    slice1 > slice2\n                 } else {\n                     len1 <= len2\n                 }\n             }\n         );\n         vec::dedup(&mut sorted_vec_lens);\n \n-        let mut found_tail = false;\n+        let mut found_slice = false;\n         let mut next = 0;\n         let mut missing = None;\n-        for sorted_vec_lens.each |&(length, tail)| {\n+        for sorted_vec_lens.each |&(length, slice)| {\n             if length != next {\n                 missing = Some(next);\n                 break;\n             }\n-            if tail {\n-                found_tail = true;\n+            if slice {\n+                found_slice = true;\n                 break;\n             }\n             next += 1;\n         }\n \n         // We found patterns of all lengths within <0, next), yet there was no\n-        // pattern with a tail - therefore, we report vec(next) as missing.\n-        if !found_tail {\n+        // pattern with a slice - therefore, we report vec(next) as missing.\n+        if !found_slice {\n             missing = Some(next);\n         }\n         match missing {\n@@ -621,19 +623,25 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                     compare_const_vals(c_hi, v_hi) <= 0;\n           if match_ { Some(vec::from_slice(r.tail())) } else { None }\n       }\n-            pat_vec(elems, tail) => {\n+            pat_vec(before, slice, after) => {\n                 match ctor_id {\n                     vec(_) => {\n-                        let num_elements = elems.len();\n-                        if num_elements < arity && tail.is_some() {\n+                        let num_elements = before.len() + after.len();\n+                        if num_elements < arity && slice.is_some() {\n                             Some(vec::append(\n-                                vec::append(elems, vec::from_elem(\n-                                    arity - num_elements, wild()\n-                                )),\n-                                vec::from_slice(r.tail())\n+                                vec::concat(&[\n+                                    before,\n+                                    vec::from_elem(\n+                                        arity - num_elements, wild()),\n+                                    after\n+                                ]),\n+                                r.tail()\n                             ))\n                         } else if num_elements == arity {\n-                            Some(vec::append(elems, r.tail()))\n+                            Some(vec::append(\n+                                vec::append(before, after),\n+                                r.tail()\n+                            ))\n                         } else {\n                             None\n                         }"}, {"sha": "85ff970be1cac5912a36b66ea8a836af7657c6bb", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9e85589ad3ba61169cd7722520981c1bebb5b542/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e85589ad3ba61169cd7722520981c1bebb5b542/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=9e85589ad3ba61169cd7722520981c1bebb5b542", "patch": "@@ -963,16 +963,19 @@ pub impl mem_categorization_ctxt {\n             self.cat_pattern(subcmt, subpat, op);\n           }\n \n-          ast::pat_vec(ref pats, opt_tail_pat) => {\n-              for pats.each |pat| {\n+          ast::pat_vec(ref before, slice, ref after) => {\n+              for before.each |pat| {\n                   let elt_cmt = self.cat_index(*pat, cmt);\n                   self.cat_pattern(elt_cmt, *pat, op);\n               }\n-\n-              for opt_tail_pat.each |tail_pat| {\n-                  let tail_ty = self.tcx.ty(*tail_pat);\n-                  let tail_cmt = self.cat_rvalue(*tail_pat, tail_ty);\n-                  self.cat_pattern(tail_cmt, *tail_pat, op);\n+              for slice.each |slice_pat| {\n+                  let slice_ty = self.tcx.ty(*slice_pat);\n+                  let slice_cmt = self.cat_rvalue(*slice_pat, slice_ty);\n+                  self.cat_pattern(slice_cmt, *slice_pat, op);\n+              }\n+              for after.each |pat| {\n+                  let elt_cmt = self.cat_index(*pat, cmt);\n+                  self.cat_pattern(elt_cmt, *pat, op);\n               }\n           }\n "}, {"sha": "d4a7c104500ba031f70ecdc883e3e9e3d30af2b0", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 56, "deletions": 32, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/9e85589ad3ba61169cd7722520981c1bebb5b542/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e85589ad3ba61169cd7722520981c1bebb5b542/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=9e85589ad3ba61169cd7722520981c1bebb5b542", "patch": "@@ -190,7 +190,7 @@ pub enum Opt {\n     var(/* disr val */int, @adt::Repr),\n     range(@ast::expr, @ast::expr),\n     vec_len_eq(uint),\n-    vec_len_ge(uint)\n+    vec_len_ge(uint, /* slice */uint)\n }\n \n pub fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n@@ -235,7 +235,7 @@ pub fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n       }\n       (&var(a, _), &var(b, _)) => a == b,\n       (&vec_len_eq(a), &vec_len_eq(b)) => a == b,\n-      (&vec_len_ge(a), &vec_len_ge(b)) => a == b,\n+      (&vec_len_ge(a, _), &vec_len_ge(b, _)) => a == b,\n       _ => false\n     }\n }\n@@ -273,7 +273,7 @@ pub fn trans_opt(bcx: block, o: &Opt) -> opt_result {\n         vec_len_eq(n) => {\n             return single_result(rslt(bcx, C_int(ccx, n as int)));\n         }\n-        vec_len_ge(n) => {\n+        vec_len_ge(n, _) => {\n             return lower_bound(rslt(bcx, C_int(ccx, n as int)));\n         }\n     }\n@@ -565,18 +565,22 @@ pub fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n                     None\n                 }\n             }\n-            ast::pat_vec(elems, tail) => {\n-                match tail {\n+            ast::pat_vec(before, slice, after) => {\n+                match slice {\n                     Some(_) => {\n-                        if opt_eq(tcx, &vec_len_ge(elems.len()), opt) {\n-                            Some(vec::append_one(elems, tail.get()))\n+                        let n = before.len() + after.len();\n+                        let i = before.len();\n+                        if opt_eq(tcx, &vec_len_ge(n, i), opt) {\n+                            Some(vec::concat(\n+                                &[before, ~[slice.get()], after]))\n                         } else {\n                             None\n                         }\n                     }\n                     None => {\n-                        if opt_eq(tcx, &vec_len_eq(elems.len()), opt) {\n-                            Some(copy elems)\n+                        let n = before.len();\n+                        if opt_eq(tcx, &vec_len_eq(n), opt) {\n+                            Some(copy before)\n                         } else {\n                             None\n                         }\n@@ -807,10 +811,11 @@ pub fn get_options(bcx: block, m: &[@Match], col: uint) -> ~[Opt] {\n             ast::pat_range(l1, l2) => {\n                 add_to_set(ccx.tcx, &mut found, range(l1, l2));\n             }\n-            ast::pat_vec(elems, tail) => {\n-                let opt = match tail {\n-                    None => vec_len_eq(elems.len()),\n-                    Some(_) => vec_len_ge(elems.len())\n+            ast::pat_vec(before, slice, after) => {\n+                let opt = match slice {\n+                    None => vec_len_eq(before.len()),\n+                    Some(_) => vec_len_ge(before.len() + after.len(),\n+                                          before.len())\n                 };\n                 add_to_set(ccx.tcx, &mut found, opt);\n             }\n@@ -841,35 +846,49 @@ pub fn extract_variant_args(bcx: block,\n pub fn extract_vec_elems(bcx: block,\n                          pat_id: ast::node_id,\n                          elem_count: uint,\n-                         tail: bool,\n-                         val: ValueRef)\n+                         slice: Option<uint>,\n+                         val: ValueRef,\n+                         count: ValueRef)\n                       -> ExtractedBlock {\n     let _icx = bcx.insn_ctxt(\"match::extract_vec_elems\");\n     let vt = tvec::vec_types(bcx, node_id_type(bcx, pat_id));\n     let unboxed = load_if_immediate(bcx, val, vt.vec_ty);\n     let (base, len) = tvec::get_base_and_len(bcx, unboxed, vt.vec_ty);\n \n     let mut elems = do vec::from_fn(elem_count) |i| {\n-        GEPi(bcx, base, ~[i])\n+        match slice {\n+            None => GEPi(bcx, base, ~[i]),\n+            Some(n) if i < n => GEPi(bcx, base, ~[i]),\n+            Some(n) if i > n => {\n+                InBoundsGEP(bcx, base, ~[\n+                    Sub(bcx, count,\n+                        C_int(bcx.ccx(), (elem_count - i) as int))])\n+            }\n+            _ => unsafe { llvm::LLVMGetUndef(vt.llunit_ty) }\n+        }\n     };\n-    if tail {\n-        let tail_offset = Mul(bcx, vt.llunit_size,\n-            C_int(bcx.ccx(), elem_count as int)\n+    if slice.is_some() {\n+        let n = slice.get();\n+        let slice_offset = Mul(bcx, vt.llunit_size,\n+            C_int(bcx.ccx(), n as int)\n+        );\n+        let slice_begin = tvec::pointer_add(bcx, base, slice_offset);\n+        let slice_len_offset = Mul(bcx, vt.llunit_size,\n+            C_int(bcx.ccx(), (elem_count - 1u) as int)\n         );\n-        let tail_begin = tvec::pointer_add(bcx, base, tail_offset);\n-        let tail_len = Sub(bcx, len, tail_offset);\n-        let tail_ty = ty::mk_evec(bcx.tcx(),\n+        let slice_len = Sub(bcx, len, slice_len_offset);\n+        let slice_ty = ty::mk_evec(bcx.tcx(),\n             ty::mt {ty: vt.unit_ty, mutbl: ast::m_imm},\n             ty::vstore_slice(ty::re_static)\n         );\n-        let scratch = scratch_datum(bcx, tail_ty, false);\n-        Store(bcx, tail_begin,\n+        let scratch = scratch_datum(bcx, slice_ty, false);\n+        Store(bcx, slice_begin,\n             GEPi(bcx, scratch.val, [0u, abi::slice_elt_base])\n         );\n-        Store(bcx, tail_len,\n+        Store(bcx, slice_len,\n             GEPi(bcx, scratch.val, [0u, abi::slice_elt_len])\n         );\n-        elems.push(scratch.val);\n+        elems[n] = scratch.val;\n         scratch.add_clean(bcx);\n     }\n \n@@ -1367,7 +1386,7 @@ pub fn compile_submatch(bcx: block,\n                 test_val = Load(bcx, val);\n                 kind = compare;\n             },\n-            vec_len_eq(_) | vec_len_ge(_) => {\n+            vec_len_eq(*) | vec_len_ge(*) => {\n                 let vt = tvec::vec_types(bcx, node_id_type(bcx, pat_id));\n                 let unboxed = load_if_immediate(bcx, val, vt.vec_ty);\n                 let (_, len) = tvec::get_base_and_len(\n@@ -1511,12 +1530,17 @@ pub fn compile_submatch(bcx: block,\n                 unpacked = argvals;\n                 opt_cx = new_bcx;\n             }\n-            vec_len_eq(n) | vec_len_ge(n) => {\n-                let tail = match *opt {\n-                    vec_len_ge(_) => true,\n-                    _ => false\n+            vec_len_eq(n) | vec_len_ge(n, _) => {\n+                let n = match *opt {\n+                    vec_len_ge(*) => n + 1u,\n+                    _ => n\n+                };\n+                let slice = match *opt {\n+                    vec_len_ge(_, i) => Some(i),\n+                    _ => None\n                 };\n-                let args = extract_vec_elems(opt_cx, pat_id, n, tail, val);\n+                let args = extract_vec_elems(opt_cx, pat_id, n, slice,\n+                    val, test_val);\n                 size = args.vals.len();\n                 unpacked = /*bad*/copy args.vals;\n                 opt_cx = args.bcx;"}, {"sha": "4b7def26fd559a4f7907aa844625f8eafbd38cde", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9e85589ad3ba61169cd7722520981c1bebb5b542/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e85589ad3ba61169cd7722520981c1bebb5b542/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=9e85589ad3ba61169cd7722520981c1bebb5b542", "patch": "@@ -509,7 +509,7 @@ pub fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n           }\n         }\n       }\n-      ast::pat_vec(elts, tail) => {\n+      ast::pat_vec(before, slice, after) => {\n         let default_region_var =\n             fcx.infcx().next_region_var_with_lb(\n                 pat.span, pcx.block_region\n@@ -538,21 +538,23 @@ pub fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             );\n           }\n         };\n-        for elts.each |elt| {\n+        for before.each |elt| {\n             check_pat(pcx, *elt, elt_type.ty);\n         }\n-        fcx.write_ty(pat.id, expected);\n-\n-        match tail {\n-            Some(tail_pat) => {\n+        match slice {\n+            Some(slice_pat) => {\n                 let slice_ty = ty::mk_evec(tcx,\n                     ty::mt {ty: elt_type.ty, mutbl: elt_type.mutbl},\n                     ty::vstore_slice(region_var)\n                 );\n-                check_pat(pcx, tail_pat, slice_ty);\n+                check_pat(pcx, slice_pat, slice_ty);\n             }\n             None => ()\n         }\n+        for after.each |elt| {\n+            check_pat(pcx, *elt, elt_type.ty);\n+        }\n+        fcx.write_ty(pat.id, expected);\n       }\n     }\n }"}, {"sha": "55d027549e30cd3d5ec5a878ffc1cec8666ed8b2", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e85589ad3ba61169cd7722520981c1bebb5b542/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e85589ad3ba61169cd7722520981c1bebb5b542/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=9e85589ad3ba61169cd7722520981c1bebb5b542", "patch": "@@ -896,7 +896,7 @@ pub mod guarantor {\n             }\n             ast::pat_lit(*) => {}\n             ast::pat_range(*) => {}\n-            ast::pat_vec(ref ps, ref opt_tail_pat) => {\n+            ast::pat_vec(ref before, ref slice, ref after) => {\n                 let vec_ty = rcx.resolve_node_type(pat.id);\n                 if !ty::type_contains_err(vec_ty) {\n                     let vstore = ty::ty_vstore(vec_ty);\n@@ -906,11 +906,11 @@ pub mod guarantor {\n                         ty::vstore_box => None\n                     };\n \n-                    link_ref_bindings_in_pats(rcx, ps, guarantor1);\n-\n-                    for opt_tail_pat.each |p| {\n-                        link_ref_bindings_in_pat(rcx, *p, guarantor);\n+                    link_ref_bindings_in_pats(rcx, before, guarantor1);\n+                    for slice.each |&p| {\n+                        link_ref_bindings_in_pat(rcx, p, guarantor);\n                     }\n+                    link_ref_bindings_in_pats(rcx, after, guarantor1);\n                 }\n             }\n         }"}, {"sha": "f3e73823f69b32c235cb95c07f4d3d211ca4940a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e85589ad3ba61169cd7722520981c1bebb5b542/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e85589ad3ba61169cd7722520981c1bebb5b542/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=9e85589ad3ba61169cd7722520981c1bebb5b542", "patch": "@@ -309,7 +309,9 @@ pub enum pat_ {\n     pat_region(@pat), // borrowed pointer pattern\n     pat_lit(@expr),\n     pat_range(@expr, @expr),\n-    pat_vec(~[@pat], Option<@pat>)\n+    // [a, b, ..i, y, z] is represented as\n+    // pat_vec(~[a, b], Some(i), ~[y, z])\n+    pat_vec(~[@pat], Option<@pat>, ~[@pat])\n }\n \n #[auto_encode]"}, {"sha": "7b0e72e6e956e6dcdf1d9b36142c3e97762fef06", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9e85589ad3ba61169cd7722520981c1bebb5b542/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e85589ad3ba61169cd7722520981c1bebb5b542/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=9e85589ad3ba61169cd7722520981c1bebb5b542", "patch": "@@ -533,12 +533,15 @@ pub fn walk_pat(pat: @pat, it: fn(@pat)) {\n         pat_box(s) | pat_uniq(s) | pat_region(s) => {\n             walk_pat(s, it)\n         }\n-        pat_vec(ref elts, ref tail) => {\n-            for elts.each |p| {\n+        pat_vec(ref before, ref slice, ref after) => {\n+            for before.each |p| {\n                 walk_pat(*p, it)\n             }\n-            for tail.each |tail| {\n-                walk_pat(*tail, it)\n+            for slice.each |p| {\n+                walk_pat(*p, it)\n+            }\n+            for after.each |p| {\n+                walk_pat(*p, it)\n             }\n         }\n         pat_wild | pat_lit(_) | pat_range(_, _) | pat_ident(_, _, _) |"}, {"sha": "2a5fe7887704d89fa3e6a5f8395355bcbd6e738d", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9e85589ad3ba61169cd7722520981c1bebb5b542/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e85589ad3ba61169cd7722520981c1bebb5b542/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=9e85589ad3ba61169cd7722520981c1bebb5b542", "patch": "@@ -416,10 +416,11 @@ pub fn noop_fold_pat(p: &pat_, fld: @ast_fold) -> pat_ {\n         pat_range(e1, e2) => {\n             pat_range(fld.fold_expr(e1), fld.fold_expr(e2))\n         },\n-        pat_vec(ref elts, ref tail) => {\n+        pat_vec(ref before, ref slice, ref after) => {\n             pat_vec(\n-                elts.map(|x| fld.fold_pat(*x)),\n-                tail.map(|tail| fld.fold_pat(*tail))\n+                before.map(|x| fld.fold_pat(*x)),\n+                slice.map(|x| fld.fold_pat(*x)),\n+                after.map(|x| fld.fold_pat(*x))\n             )\n         }\n     }"}, {"sha": "38cd09abad42b2fcfba9f211c0ab2f1a63a046f3", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9e85589ad3ba61169cd7722520981c1bebb5b542/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e85589ad3ba61169cd7722520981c1bebb5b542/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9e85589ad3ba61169cd7722520981c1bebb5b542", "patch": "@@ -2024,37 +2024,46 @@ pub impl Parser {\n     fn parse_pat_vec_elements(\n         &self,\n         refutable: bool\n-    ) -> (~[@pat], Option<@pat>) {\n-        let mut elements = ~[];\n-        let mut tail = None;\n+    ) -> (~[@pat], Option<@pat>, ~[@pat]) {\n+        let mut before = ~[];\n+        let mut slice = None;\n+        let mut after = ~[];\n         let mut first = true;\n+        let mut before_slice = true;\n \n         while *self.token != token::RBRACKET {\n             if first { first = false; }\n             else { self.expect(&token::COMMA); }\n \n-            let mut is_tail = false;\n-            if *self.token == token::DOTDOT {\n-                self.bump();\n-                is_tail = true;\n+            let mut is_slice = false;\n+            if before_slice {\n+                if *self.token == token::DOTDOT {\n+                    self.bump();\n+                    is_slice = true;\n+                    before_slice = false;\n+                }\n             }\n \n             let subpat = self.parse_pat(refutable);\n-            if is_tail {\n+            if is_slice {\n                 match subpat {\n                     @ast::pat { node: pat_wild, _ } => (),\n                     @ast::pat { node: pat_ident(_, _, _), _ } => (),\n                     @ast::pat { span, _ } => self.span_fatal(\n                         span, ~\"expected an identifier or `_`\"\n                     )\n                 }\n-                tail = Some(subpat);\n-                break;\n+                slice = Some(subpat);\n+            } else {\n+                if before_slice {\n+                    before.push(subpat);\n+                } else {\n+                    after.push(subpat);\n+                }\n             }\n-\n-            elements.push(subpat);\n         }\n-        return (elements, tail);\n+\n+        (before, slice, after)\n     }\n \n     fn parse_pat_fields(&self, refutable: bool) -> (~[ast::field_pat], bool) {\n@@ -2208,10 +2217,11 @@ pub impl Parser {\n           }\n           token::LBRACKET => {\n             self.bump();\n-            let (elements, tail) = self.parse_pat_vec_elements(refutable);\n+            let (before, slice, after) =\n+                self.parse_pat_vec_elements(refutable);\n             hi = self.span.hi;\n             self.expect(&token::RBRACKET);\n-            pat = ast::pat_vec(elements, tail);\n+            pat = ast::pat_vec(before, slice, after);\n           }\n           copy tok => {\n             if !is_ident_or_path(&tok)"}, {"sha": "c81c1c8bd0e1a6f070ee318091924ab0c07a8373", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9e85589ad3ba61169cd7722520981c1bebb5b542/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e85589ad3ba61169cd7722520981c1bebb5b542/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9e85589ad3ba61169cd7722520981c1bebb5b542", "patch": "@@ -1609,13 +1609,19 @@ pub fn print_pat(s: @ps, &&pat: @ast::pat, refutable: bool) {\n         word(s.s, ~\"..\");\n         print_expr(s, end);\n       }\n-      ast::pat_vec(elts, tail) => {\n+      ast::pat_vec(before, slice, after) => {\n         word(s.s, ~\"[\");\n-        commasep(s, inconsistent, elts, |s, p| print_pat(s, p, refutable));\n-        for tail.each |tail| {\n-            if vec::len(elts) != 0u { word_space(s, ~\",\"); }\n+        do commasep(s, inconsistent, before) |s, p| {\n+            print_pat(s, p, refutable);\n+        }\n+        for slice.each |&p| {\n+            if !before.is_empty() { word_space(s, ~\",\"); }\n             word(s.s, ~\"..\");\n-            print_pat(s, *tail, refutable);\n+            print_pat(s, p, refutable);\n+            if !after.is_empty() { word_space(s, ~\",\"); }\n+        }\n+        do commasep(s, inconsistent, after) |s, p| {\n+            print_pat(s, p, refutable);\n         }\n         word(s.s, ~\"]\");\n       }"}, {"sha": "f04894729bd0c2a5b9d92d9ec29dab7cdc46fb8e", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9e85589ad3ba61169cd7722520981c1bebb5b542/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e85589ad3ba61169cd7722520981c1bebb5b542/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=9e85589ad3ba61169cd7722520981c1bebb5b542", "patch": "@@ -287,11 +287,14 @@ pub fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n             (v.visit_expr)(e2, e, v);\n         }\n         pat_wild => (),\n-        pat_vec(ref elts, ref tail) => {\n-            for elts.each |elt| {\n+        pat_vec(ref before, ref slice, ref after) => {\n+            for before.each |elt| {\n+                (v.visit_pat)(*elt, e, v);\n+            }\n+            for slice.each |elt| {\n                 (v.visit_pat)(*elt, e, v);\n             }\n-            for tail.each |tail| {\n+            for after.each |tail| {\n                 (v.visit_pat)(*tail, e, v);\n             }\n         }"}, {"sha": "4174120b291c615aee1e5a4e53e0e968917b80ba", "filename": "src/test/compile-fail/alt-vec-invalid-2.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/58618fb8cfd791a930261ff68ae6bc77e0bc4412/src%2Ftest%2Fcompile-fail%2Falt-vec-invalid-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58618fb8cfd791a930261ff68ae6bc77e0bc4412/src%2Ftest%2Fcompile-fail%2Falt-vec-invalid-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-vec-invalid-2.rs?ref=58618fb8cfd791a930261ff68ae6bc77e0bc4412", "patch": "@@ -1,6 +0,0 @@\n-fn main() {\n-    match ~[] {\n-        [_, ..tail, _] => {}, //~ ERROR: expected `]` but found `,`\n-        _ => ()\n-    }\n-}"}, {"sha": "2cf2d5b93b056c5db559089cc0dd392af5d4d092", "filename": "src/test/compile-fail/alt-vec-invalid.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e85589ad3ba61169cd7722520981c1bebb5b542/src%2Ftest%2Fcompile-fail%2Falt-vec-invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e85589ad3ba61169cd7722520981c1bebb5b542/src%2Ftest%2Fcompile-fail%2Falt-vec-invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-vec-invalid.rs?ref=9e85589ad3ba61169cd7722520981c1bebb5b542", "patch": "@@ -1,7 +1,7 @@\n fn main() {\n     let a = ~[];\n     match a {\n-        [1, ..tail, ..tail] => {}, //~ ERROR: expected `]` but found `,`\n+        [1, ..tail, ..tail] => {}, //~ ERROR: unexpected token: `..`\n         _ => ()\n     }\n }"}, {"sha": "c8a0dbedd5d95476197f0f010bb7dd5d7912db4c", "filename": "src/test/compile-fail/borrowck-vec-pattern-element-loan.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9e85589ad3ba61169cd7722520981c1bebb5b542/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e85589ad3ba61169cd7722520981c1bebb5b542/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs?ref=9e85589ad3ba61169cd7722520981c1bebb5b542", "patch": "@@ -1,15 +1,28 @@\n fn a() -> &[int] {\n     let vec = [1, 2, 3, 4];\n     let tail = match vec { //~ ERROR illegal borrow\n-        [_a, ..tail] => tail,\n-        _ => fail!(~\"foo\")\n+        [_, ..tail] => tail,\n+        _ => fail!(~\"a\")\n     };\n     tail\n }\n \n-fn main() {\n-    let tail = a();\n-    for tail.each |n| {\n-        io::println(fmt!(\"%d\", *n));\n-    }\n+fn b() -> &[int] {\n+    let vec = [1, 2, 3, 4];\n+    let init = match vec { //~ ERROR illegal borrow\n+        [..init, _] => init,\n+        _ => fail!(~\"b\")\n+    };\n+    init\n }\n+\n+fn c() -> &[int] {\n+    let vec = [1, 2, 3, 4];\n+    let slice = match vec { //~ ERROR illegal borrow\n+        [_, ..slice, _] => slice,\n+        _ => fail!(~\"c\")\n+    };\n+    slice\n+}\n+\n+fn main() {}"}, {"sha": "1df90bf681cfb1df102ec2a590d1f637232a4a28", "filename": "src/test/run-pass/vec-matching-fold.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9e85589ad3ba61169cd7722520981c1bebb5b542/src%2Ftest%2Frun-pass%2Fvec-matching-fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e85589ad3ba61169cd7722520981c1bebb5b542/src%2Ftest%2Frun-pass%2Fvec-matching-fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching-fold.rs?ref=9e85589ad3ba61169cd7722520981c1bebb5b542", "patch": "@@ -0,0 +1,33 @@\n+fn foldl<T, U: Copy>(\n+    values: &[T],\n+    initial: U,\n+    function: &fn(partial: U, element: &T) -> U\n+) -> U {\n+    match values {\n+        [head, ..tail] =>\n+            foldl(tail, function(initial, &head), function),\n+        [] => copy initial\n+    }\n+}\n+\n+fn foldr<T, U: Copy>(\n+    values: &[T],\n+    initial: U,\n+    function: &fn(element: &T, partial: U) -> U\n+) -> U {\n+    match values {\n+        [..head, tail] =>\n+            foldr(head, function(&tail, initial), function),\n+        [] => copy initial\n+    }\n+}\n+\n+pub fn main() {\n+    let x = [1, 2, 3, 4, 5];\n+\n+    let product = foldl(x, 1, |a, b| a * *b);\n+    fail_unless!(product == 120);\n+\n+    let sum = foldr(x, 0, |a, b| *a + b);\n+    fail_unless!(sum == 15);\n+}"}, {"sha": "e1243e18f5ffbde1720605d7fd2dd9ab5c5e3312", "filename": "src/test/run-pass/vec-matching.rs", "status": "modified", "additions": 7, "deletions": 27, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9e85589ad3ba61169cd7722520981c1bebb5b542/src%2Ftest%2Frun-pass%2Fvec-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e85589ad3ba61169cd7722520981c1bebb5b542/src%2Ftest%2Frun-pass%2Fvec-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching.rs?ref=9e85589ad3ba61169cd7722520981c1bebb5b542", "patch": "@@ -1,33 +1,13 @@\n-fn foldl<T, U: Copy>(\n-    values: &[T],\n-    initial: U,\n-    function: &fn(partial: U, element: &T) -> U\n-) -> U {\n-    match values {\n-        [head, ..tail] =>\n-            foldl(tail, function(initial, &head), function),\n-        _ => copy initial\n-    }\n-}\n-\n pub fn main() {\n-    let x = [1, 2, 3, 4, 5];\n+    let x = [1];\n     match x {\n-        [a, b, c, d, e, f] => {\n-            ::core::util::unreachable();\n-        }\n-        [a, b, c, d, e] => {\n+        [_, _, _, _, _, .._] => ::core::util::unreachable(),\n+        [.._, _, _, _, _] => ::core::util::unreachable(),\n+        [_, .._, _, _] => ::core::util::unreachable(),\n+        [_, _] => ::core::util::unreachable(),\n+        [a] => {\n             fail_unless!(a == 1);\n-            fail_unless!(b == 2);\n-            fail_unless!(c == 3);\n-            fail_unless!(d == 4);\n-            fail_unless!(e == 5);\n-        }\n-        _ => {\n-            ::core::util::unreachable();\n         }\n+        [] => ::core::util::unreachable()\n     }\n-\n-    let product = foldl(x, 1, |a, b| a * *b);\n-    fail_unless!(product == 120);\n }"}]}