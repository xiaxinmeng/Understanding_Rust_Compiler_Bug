{"sha": "af6b4821c163e5ad22868a270541dc0b7a04534f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmNmI0ODIxYzE2M2U1YWQyMjg2OGEyNzA1NDFkYzBiN2EwNDUzNGY=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2011-05-27T00:33:33Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-27T02:42:33Z"}, "message": "Handle circularity in glob imports in a more elegant fashion.", "tree": {"sha": "daecf97eff705d79a0f1b75586bad226a4aaf8f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/daecf97eff705d79a0f1b75586bad226a4aaf8f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af6b4821c163e5ad22868a270541dc0b7a04534f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af6b4821c163e5ad22868a270541dc0b7a04534f", "html_url": "https://github.com/rust-lang/rust/commit/af6b4821c163e5ad22868a270541dc0b7a04534f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af6b4821c163e5ad22868a270541dc0b7a04534f/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fe3d821ac26615e1d5228864ece4d08531c2237", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fe3d821ac26615e1d5228864ece4d08531c2237", "html_url": "https://github.com/rust-lang/rust/commit/7fe3d821ac26615e1d5228864ece4d08531c2237"}], "stats": {"total": 196, "additions": 108, "deletions": 88}, "files": [{"sha": "aad180c60f8d30494a00d10cda9109f2f0c91363", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 87, "deletions": 75, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/af6b4821c163e5ad22868a270541dc0b7a04534f/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af6b4821c163e5ad22868a270541dc0b7a04534f/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=af6b4821c163e5ad22868a270541dc0b7a04534f", "patch": "@@ -43,7 +43,7 @@ tag scope {\n }\n \n tag import_state {\n-    todo(@ast::view_item, list[scope]);\n+    todo(@ast::view_item, list[scope]); // only used for explicit imports\n     resolving(span);\n     resolved(option::t[def] /* value */,\n              option::t[def] /* type */,\n@@ -77,7 +77,8 @@ tag mod_index_entry {\n type mod_index = hashmap[ident,list[mod_index_entry]];\n \n type indexed_mod = rec(option::t[ast::_mod] m, \n-                       mod_index index, vec[def] glob_imports);\n+                       mod_index index, vec[def] glob_imports,\n+                       hashmap[str,import_state] glob_imported_names);\n /* native modules can't contain tags, and we don't store their ASTs because we\n    only need to look at them to determine exports, which they can't control.*/\n // It should be safe to use index to memoize lookups of globbed names.\n@@ -141,7 +142,9 @@ fn map_crate(&@env e, &ast::crate c) {\n     // Register the top-level mod\n     e.mod_map.insert(-1, @rec(m=some(c.node.module),\n                               index=index_mod(c.node.module),\n-                              glob_imports=vec::empty[def]()));\n+                              glob_imports=vec::empty[def](),\n+                              glob_imported_names\n+                              =new_str_hash[import_state]()));\n     walk::walk_crate(index_names, c);\n \n     fn index_vi(@env e, @mutable list[scope] sc, &@ast::view_item i) {\n@@ -158,14 +161,18 @@ fn map_crate(&@env e, &ast::crate c) {\n             case (ast::item_mod(_, ?md, ?defid)) {\n                 e.mod_map.insert(defid._1, \n                                  @rec(m=some(md), index=index_mod(md),\n-                                      glob_imports=vec::empty[def]()));\n+                                      glob_imports=vec::empty[def](),\n+                                      glob_imported_names\n+                                      =new_str_hash[import_state]()));\n                 e.ast_map.insert(defid, i);\n             }\n             case (ast::item_native_mod(_, ?nmd, ?defid)) {\n                 e.mod_map.insert(defid._1, \n                                  @rec(m=none[ast::_mod], \n                                       index=index_nmod(nmd),\n-                                      glob_imports=vec::empty[def]()));\n+                                      glob_imports=vec::empty[def](),\n+                                      glob_imported_names\n+                                      =new_str_hash[import_state]()));\n                 e.ast_map.insert(defid, i);\n             }\n             case (ast::item_const(_, _, _, ?defid, _)) {\n@@ -542,12 +549,11 @@ fn lookup_in_scope(&env e, list[scope] sc, &span sp, &ident id, namespace ns)\n     fn in_scope(&env e, &span sp, &ident id, &scope s, namespace ns)\n         -> option::t[def] {\n         //not recursing through globs\n-        let list[def] no_m = nil[def];\n \n         alt (s) {\n             case (scope_crate(?c)) {\n                 auto defid = tup(ast::local_crate, -1);\n-                ret lookup_in_local_mod(e, defid, no_m, sp, id, ns, inside);\n+                ret lookup_in_local_mod(e, defid, sp, id, ns, inside);\n             }\n             case (scope_item(?it)) {\n                 alt (it.node) {\n@@ -563,12 +569,10 @@ fn lookup_in_scope(&env e, list[scope] sc, &span sp, &ident id, namespace ns)\n                         }\n                     }\n                     case (ast::item_mod(_, _, ?defid)) {\n-                        ret lookup_in_local_mod(e, defid, no_m, sp, \n-                                                id, ns, inside);\n+                        ret lookup_in_local_mod(e, defid, sp, id, ns, inside);\n                     }\n                     case (ast::item_native_mod(_, ?m, ?defid)) {\n-                        ret lookup_in_local_native_mod(e, defid, no_m, \n-                                                       sp, id, ns);\n+                        ret lookup_in_local_native_mod(e, defid, sp, id, ns);\n                     }\n                     case (ast::item_ty(_, _, ?ty_params, _, _)) {\n                         if (ns == ns_type) {\n@@ -796,44 +800,27 @@ fn lookup_in_mod_strict(&env e, def m, &span sp, &ident id,\n \n fn lookup_in_mod(&env e, def m, &span sp, &ident id, namespace ns, dir dr)\n     -> option::t[def] {\n-    be lookup_in_mod_recursively(e, cons[def](m, @nil[def]), sp, id, ns, dr);\n-}\n-\n-// this list is simply the stack of glob imports we have passed through\n-// (preventing cyclic glob imports from diverging)\n-fn lookup_in_mod_recursively(&env e, list[def] m, &span sp, &ident id, \n-                             namespace ns, dir dr) -> option::t[def] {\n+    auto defid = ast::def_id_of_def(m);\n+    if (defid._0 != ast::local_crate) {\n+        // examining a module in an external crate\n+        auto cached = e.ext_cache.find(tup(defid,id,ns));\n+        if (!option::is_none(cached)) { ret cached; }\n+        auto path = [id];\n+        if (defid._1 != -1) {\n+            path = e.ext_map.get(defid) + path;\n+        }\n+        auto fnd = lookup_external(e, defid._0, path, ns);\n+        if (!option::is_none(fnd)) {\n+            e.ext_cache.insert(tup(defid,id,ns), option::get(fnd));\n+        }\n+        ret fnd;\n+    }\n     alt (m) {\n-        case (cons[def](?mod_def, ?tl)) {\n-            if (list::has(*tl, mod_def)) {\n-                ret none[def]; // import glob cycle detected; we're done\n-            }\n-            auto defid = ast::def_id_of_def(mod_def);\n-            if (defid._0 != ast::local_crate) {\n-                // examining a module in an external crate\n-                auto cached = e.ext_cache.find(tup(defid,id,ns));\n-                if (!option::is_none(cached)) { ret cached; }\n-                auto path = [id];\n-                if (defid._1 != -1) {\n-                    path = e.ext_map.get(defid) + path;\n-                }\n-                auto fnd = lookup_external(e, defid._0, path, ns);\n-                if (!option::is_none(fnd)) {\n-                    e.ext_cache.insert(tup(defid,id,ns), option::get(fnd));\n-                }\n-                ret fnd;\n-            }\n-            alt (mod_def) {\n-                case (ast::def_mod(?defid)) {\n-                    ret lookup_in_local_mod(e, defid, m, sp, id, ns, dr);\n-                }\n-                case (ast::def_native_mod(?defid)) {\n-                    ret lookup_in_local_native_mod(e, defid, m, sp, id, ns);\n-                }\n-            }\n+        case (ast::def_mod(?defid)) {\n+            ret lookup_in_local_mod(e, defid, sp, id, ns, dr);\n         }\n-        case (_) { \n-            e.sess.bug(\"lookup_in_mod_recursively needs a module\"); fail;\n+        case (ast::def_native_mod(?defid)) {\n+            ret lookup_in_local_native_mod(e, defid, sp, id, ns);\n         }\n     }\n }\n@@ -872,18 +859,18 @@ fn lookup_import(&env e, def_id defid, namespace ns) -> option::t[def] {\n }\n \n \n-fn lookup_in_local_native_mod(&env e, def_id defid, list[def] m, &span sp,\n+fn lookup_in_local_native_mod(&env e, def_id defid, &span sp,\n                               &ident id, namespace ns) -> option::t[def] {\n-    ret lookup_in_local_mod(e, defid, m, sp, id, ns, inside);\n+    ret lookup_in_local_mod(e, defid, sp, id, ns, inside);\n }\n \n-fn lookup_in_local_mod(&env e, def_id defid, list[def] m, &span sp, \n+fn lookup_in_local_mod(&env e, def_id defid, &span sp, \n                        &ident id, namespace ns, dir dr) -> option::t[def] {\n     auto info = e.mod_map.get(defid._1);\n-    if (dr == outside && !ast::is_exported(id, option::get(info.m))) {\n-        // if we're in a native mod, then dr==inside, so info.m is some _mod\n-        ret none[def]; // name is not visible\n-    }\n+     if (dr == outside && !ast::is_exported(id, option::get(info.m))) {\n+         // if we're in a native mod, then dr==inside, so info.m is some _mod\n+         ret none[def]; // name is not visible\n+     }\n     alt(info.index.find(id)) {\n         case (none[list[mod_index_entry]]) { }\n         case (some[list[mod_index_entry]](?lst)) {\n@@ -900,31 +887,56 @@ fn lookup_in_local_mod(&env e, def_id defid, list[def] m, &span sp,\n         }\n     }\n     // not local or explicitly imported; try globs:\n-    ret lookup_glob_in_mod(e, info, m, sp, id, ns, dr);\n+    ret lookup_glob_in_mod(e, info, sp, id, ns, dr);\n }\n \n-fn lookup_glob_in_mod(&env e, @indexed_mod info, list[def] m, &span sp, \n-                      &ident id, namespace ns, dir dr) -> option::t[def] {\n-    fn l_i_m_r(&env e, list[def] prev_ms, &def m, &span sp, &ident id, \n-               namespace ns, dir dr) -> option::t[def] {\n-        be lookup_in_mod_recursively(e, cons[def](m, @prev_ms), \n-                                     sp, id, ns, dr);\n+fn lookup_glob_in_mod(&env e, @indexed_mod info, &span sp, \n+                      &ident id, namespace wanted_ns, dir dr)\n+    -> option::t[def] {\n+    fn per_ns(&env e, @indexed_mod info, &span sp, &ident id, \n+              namespace ns, dir dr) -> option::t[def] {\n+        fn l_i_m_r(&env e, &def m, &span sp, &ident id, \n+                   namespace ns, dir dr) -> option::t[def] {\n+            be lookup_in_mod(e, m, sp, id, ns, dr);\n+        }\n+\n+        auto matches = vec::filter_map[def, def]\n+            (bind l_i_m_r(e, _, sp, id, ns, dr), \n+             info.glob_imports);\n+        if (vec::len(matches) == 0u) {\n+            ret none[def];\n+        } else if (vec::len(matches) == 1u){\n+            ret some[def](matches.(0));\n+        } else {\n+            for (def match in matches) {\n+                e.sess.span_note(e.ast_map.get\n+                                 (ast::def_id_of_def(match)).span,\n+                                 \"'\" + id + \"' is defined here.\");\n+            }\n+            e.sess.span_err(sp, \"'\" + id + \"' is glob-imported from\" +\n+                            \" multiple different modules.\");\n+            fail;\n+        }\n     }\n-    auto matches = vec::filter_map[def, def]\n-        (bind l_i_m_r(e, m, _, sp, id, ns, dr), \n-         info.glob_imports);\n-    if (vec::len(matches) == 0u) {\n-        ret none[def];\n-    } else if (vec::len(matches) == 1u){\n-        ret some[def](matches.(0));\n-    } else {\n-        for (def match in matches) {\n-            e.sess.span_note(e.ast_map.get(ast::def_id_of_def(match)).span,\n-                             \"'\" + id + \"' is defined here.\");\n+    // since we don't know what names we have in advance,\n+    // absence takes the place of todo()\n+    if(!info.glob_imported_names.contains_key(id)) {\n+        info.glob_imported_names.insert(id, resolving(sp));\n+        auto val = per_ns(e, info, sp, id, ns_value, dr);\n+        auto typ = per_ns(e, info, sp, id, ns_type, dr);\n+        auto md  = per_ns(e, info, sp, id, ns_module, dr);\n+        info.glob_imported_names.insert(id, resolved(val, typ, md));\n+    }\n+    alt (info.glob_imported_names.get(id)) {\n+        case (todo(_,_)) { e.sess.bug(\"Shouldn't've put a todo in.\"); }\n+        case (resolving(?sp)) {\n+            ret none[def]; //circularity is okay in import globs\n+        }\n+        case (resolved(?val, ?typ, ?md)) {\n+            ret alt (wanted_ns) { case (ns_value) { val }\n+                                  case (ns_type) { typ }\n+                                  case (ns_module) { md } };\n         }\n-        e.sess.span_err(sp, \"'\" + id + \"' is glob-imported from\" +\n-                        \" multiple different modules.\");\n-        fail;\n     }\n }\n "}, {"sha": "5e4a4227d6abb1caeaace4cd62414bab57b71209", "filename": "src/test/compile-fail/import-glob-multiple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af6b4821c163e5ad22868a270541dc0b7a04534f/src%2Ftest%2Fcompile-fail%2Fimport-glob-multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af6b4821c163e5ad22868a270541dc0b7a04534f/src%2Ftest%2Fcompile-fail%2Fimport-glob-multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-glob-multiple.rs?ref=af6b4821c163e5ad22868a270541dc0b7a04534f", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: common2\n+// error-pattern:common2\n \n import mod1::*;\n import mod2::*;"}, {"sha": "921d449af130513adb1e7fc1cafe6c9a32a10139", "filename": "src/test/run-pass/import-glob-circular.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/af6b4821c163e5ad22868a270541dc0b7a04534f/src%2Ftest%2Frun-pass%2Fimport-glob-circular.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af6b4821c163e5ad22868a270541dc0b7a04534f/src%2Ftest%2Frun-pass%2Fimport-glob-circular.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-glob-circular.rs?ref=af6b4821c163e5ad22868a270541dc0b7a04534f", "patch": "@@ -3,39 +3,47 @@ import test2::*;\n \n mod circ1 {\n   import circ1::*;\n-  fn f1() {\n-    log \"f1\";\n+  fn f1() -> uint {\n+    ret 1u\n   }\n   fn common() -> uint {\n-    ret 0u;\n+    ret 1u;\n   }\n }\n \n mod circ2 {\n   import circ2::*;\n-  fn f2() {\n-    log \"f2\";\n+  fn f2() -> uint {\n+    ret 2u;\n   }\n   fn common() -> uint {\n-    ret 1u;\n+    ret 2u;\n   }\n }\n \n mod test1 {\n   import circ1::*;\n   fn test1() {\n-    f1();\n-    f2();\n-    assert(common() == 0u);\n+    assert(f1() == 1u);\n+    //make sure that cached lookups work...\n+    assert(f1() == 1u);\n+    assert(f2() == 2u);\n+    assert(f2() == 2u);\n+    assert(common() == 1u);\n+    assert(common() == 1u);\n   }\n }\n \n mod test2 {\n   import circ2::*;\n   fn test2() {\n-    f1();\n-    f2();\n-    assert(common() == 1u);\n+    assert(f1() == 1u);\n+    //make sure that cached lookups work...\n+    assert(f1() == 1u);\n+    assert(f2() == 2u);\n+    assert(f2() == 2u);\n+    assert(common() == 2u);    \n+    assert(common() == 2u);\n   }\n }\n "}]}