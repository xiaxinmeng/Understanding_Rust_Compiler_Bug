{"sha": "e7a73881e916d08c3edd97369c127e451b4717c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3YTczODgxZTkxNmQwOGMzZWRkOTczNjljMTI3ZTQ1MWI0NzE3Yzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-25T19:06:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-25T19:06:02Z"}, "message": "Auto merge of #28610 - nrc:fmt6, r=brson", "tree": {"sha": "706aaada3d0a2c0d2777af1e035e2e5e18fb1081", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/706aaada3d0a2c0d2777af1e035e2e5e18fb1081"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7a73881e916d08c3edd97369c127e451b4717c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7a73881e916d08c3edd97369c127e451b4717c8", "html_url": "https://github.com/rust-lang/rust/commit/e7a73881e916d08c3edd97369c127e451b4717c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7a73881e916d08c3edd97369c127e451b4717c8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c2e3fbe909be15cbc3a0a981950acd99360bedb", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c2e3fbe909be15cbc3a0a981950acd99360bedb", "html_url": "https://github.com/rust-lang/rust/commit/6c2e3fbe909be15cbc3a0a981950acd99360bedb"}, {"sha": "459f7720b99db16f3b9017820b1979698ba8c90b", "url": "https://api.github.com/repos/rust-lang/rust/commits/459f7720b99db16f3b9017820b1979698ba8c90b", "html_url": "https://github.com/rust-lang/rust/commit/459f7720b99db16f3b9017820b1979698ba8c90b"}], "stats": {"total": 364, "additions": 258, "deletions": 106}, "files": [{"sha": "ceca44fc1ac295f2b97ff269e2e73c778aef6e4f", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 61, "deletions": 23, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/e7a73881e916d08c3edd97369c127e451b4717c8/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a73881e916d08c3edd97369c127e451b4717c8/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=e7a73881e916d08c3edd97369c127e451b4717c8", "patch": "@@ -214,7 +214,9 @@ impl<T> Arc<T> {\n     #[stable(feature = \"arc_unique\", since = \"1.4.0\")]\n     pub fn try_unwrap(this: Self) -> Result<T, Self> {\n         // See `drop` for why all these atomics are like this\n-        if this.inner().strong.compare_and_swap(1, 0, Release) != 1 { return Err(this) }\n+        if this.inner().strong.compare_and_swap(1, 0, Release) != 1 {\n+            return Err(this)\n+        }\n \n         atomic::fence(Acquire);\n \n@@ -251,7 +253,9 @@ impl<T: ?Sized> Arc<T> {\n             let cur = this.inner().weak.load(Relaxed);\n \n             // check if the weak counter is currently \"locked\"; if so, spin.\n-            if cur == usize::MAX { continue }\n+            if cur == usize::MAX {\n+                continue\n+            }\n \n             // NOTE: this code currently ignores the possibility of overflow\n             // into usize::MAX; in general both Rc and Arc need to be adjusted\n@@ -303,7 +307,9 @@ impl<T: ?Sized> Arc<T> {\n \n         if self.inner().weak.fetch_sub(1, Release) == 1 {\n             atomic::fence(Acquire);\n-            deallocate(ptr as *mut u8, size_of_val(&*ptr), align_of_val(&*ptr))\n+            deallocate(ptr as *mut u8,\n+                       size_of_val(&*ptr),\n+                       align_of_val(&*ptr))\n         }\n     }\n }\n@@ -348,7 +354,9 @@ impl<T: ?Sized> Clone for Arc<T> {\n         // We abort because such a program is incredibly degenerate, and we\n         // don't care to support it.\n         if old_size > MAX_REFCOUNT {\n-            unsafe { abort(); }\n+            unsafe {\n+                abort();\n+            }\n         }\n \n         Arc { _ptr: self._ptr }\n@@ -556,7 +564,9 @@ impl<T: ?Sized> Drop for Arc<T> {\n         // Because `fetch_sub` is already atomic, we do not need to synchronize\n         // with other threads unless we are going to delete the object. This\n         // same logic applies to the below `fetch_sub` to the `weak` count.\n-        if self.inner().strong.fetch_sub(1, Release) != 1 { return }\n+        if self.inner().strong.fetch_sub(1, Release) != 1 {\n+            return\n+        }\n \n         // This fence is needed to prevent reordering of use of the data and\n         // deletion of the data.  Because it is marked `Release`, the decreasing\n@@ -578,7 +588,7 @@ impl<T: ?Sized> Drop for Arc<T> {\n         atomic::fence(Acquire);\n \n         unsafe {\n-            self.drop_slow()\n+            self.drop_slow();\n         }\n     }\n }\n@@ -613,11 +623,15 @@ impl<T: ?Sized> Weak<T> {\n             // \"stale\" read of 0 is fine), and any other value is\n             // confirmed via the CAS below.\n             let n = inner.strong.load(Relaxed);\n-            if n == 0 { return None }\n+            if n == 0 {\n+                return None\n+            }\n \n             // Relaxed is valid for the same reason it is on Arc's Clone impl\n             let old = inner.strong.compare_and_swap(n, n + 1, Relaxed);\n-            if old == n { return Some(Arc { _ptr: self._ptr }) }\n+            if old == n {\n+                return Some(Arc { _ptr: self._ptr })\n+            }\n         }\n     }\n \n@@ -653,7 +667,9 @@ impl<T: ?Sized> Clone for Weak<T> {\n \n         // See comments in Arc::clone() for why we do this (for mem::forget).\n         if old_size > MAX_REFCOUNT {\n-            unsafe { abort(); }\n+            unsafe {\n+                abort();\n+            }\n         }\n \n         return Weak { _ptr: self._ptr }\n@@ -705,9 +721,11 @@ impl<T: ?Sized> Drop for Weak<T> {\n         // ref, which can only happen after the lock is released.\n         if self.inner().weak.fetch_sub(1, Release) == 1 {\n             atomic::fence(Acquire);\n-            unsafe { deallocate(ptr as *mut u8,\n-                                size_of_val(&*ptr),\n-                                align_of_val(&*ptr)) }\n+            unsafe {\n+                deallocate(ptr as *mut u8,\n+                           size_of_val(&*ptr),\n+                           align_of_val(&*ptr))\n+            }\n         }\n     }\n }\n@@ -727,7 +745,9 @@ impl<T: ?Sized + PartialEq> PartialEq for Arc<T> {\n     ///\n     /// five == Arc::new(5);\n     /// ```\n-    fn eq(&self, other: &Arc<T>) -> bool { *(*self) == *(*other) }\n+    fn eq(&self, other: &Arc<T>) -> bool {\n+        *(*self) == *(*other)\n+    }\n \n     /// Inequality for two `Arc<T>`s.\n     ///\n@@ -742,7 +762,9 @@ impl<T: ?Sized + PartialEq> PartialEq for Arc<T> {\n     ///\n     /// five != Arc::new(5);\n     /// ```\n-    fn ne(&self, other: &Arc<T>) -> bool { *(*self) != *(*other) }\n+    fn ne(&self, other: &Arc<T>) -> bool {\n+        *(*self) != *(*other)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + PartialOrd> PartialOrd for Arc<T> {\n@@ -776,7 +798,9 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Arc<T> {\n     ///\n     /// five < Arc::new(5);\n     /// ```\n-    fn lt(&self, other: &Arc<T>) -> bool { *(*self) < *(*other) }\n+    fn lt(&self, other: &Arc<T>) -> bool {\n+        *(*self) < *(*other)\n+    }\n \n     /// 'Less-than or equal to' comparison for two `Arc<T>`s.\n     ///\n@@ -791,7 +815,9 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Arc<T> {\n     ///\n     /// five <= Arc::new(5);\n     /// ```\n-    fn le(&self, other: &Arc<T>) -> bool { *(*self) <= *(*other) }\n+    fn le(&self, other: &Arc<T>) -> bool {\n+        *(*self) <= *(*other)\n+    }\n \n     /// Greater-than comparison for two `Arc<T>`s.\n     ///\n@@ -806,7 +832,9 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Arc<T> {\n     ///\n     /// five > Arc::new(5);\n     /// ```\n-    fn gt(&self, other: &Arc<T>) -> bool { *(*self) > *(*other) }\n+    fn gt(&self, other: &Arc<T>) -> bool {\n+        *(*self) > *(*other)\n+    }\n \n     /// 'Greater-than or equal to' comparison for two `Arc<T>`s.\n     ///\n@@ -821,11 +849,15 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Arc<T> {\n     ///\n     /// five >= Arc::new(5);\n     /// ```\n-    fn ge(&self, other: &Arc<T>) -> bool { *(*self) >= *(*other) }\n+    fn ge(&self, other: &Arc<T>) -> bool {\n+        *(*self) >= *(*other)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Ord> Ord for Arc<T> {\n-    fn cmp(&self, other: &Arc<T>) -> Ordering { (**self).cmp(&**other) }\n+    fn cmp(&self, other: &Arc<T>) -> Ordering {\n+        (**self).cmp(&**other)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Eq> Eq for Arc<T> {}\n@@ -854,7 +886,9 @@ impl<T> fmt::Pointer for Arc<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Default> Default for Arc<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn default() -> Arc<T> { Arc::new(Default::default()) }\n+    fn default() -> Arc<T> {\n+        Arc::new(Default::default())\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1015,7 +1049,7 @@ mod tests {\n     #[test]\n     fn weak_self_cyclic() {\n         struct Cycle {\n-            x: Mutex<Option<Weak<Cycle>>>\n+            x: Mutex<Option<Weak<Cycle>>>,\n         }\n \n         let a = Arc::new(Cycle { x: Mutex::new(None) });\n@@ -1095,7 +1129,9 @@ mod tests {\n \n     // Make sure deriving works with Arc<T>\n     #[derive(Eq, Ord, PartialEq, PartialOrd, Clone, Debug, Default)]\n-    struct Foo { inner: Arc<i32> }\n+    struct Foo {\n+        inner: Arc<i32>,\n+    }\n \n     #[test]\n     fn test_unsized() {\n@@ -1108,5 +1144,7 @@ mod tests {\n }\n \n impl<T: ?Sized> borrow::Borrow<T> for Arc<T> {\n-    fn borrow(&self) -> &T { &**self }\n+    fn borrow(&self) -> &T {\n+        &**self\n+    }\n }"}, {"sha": "1529187da064c05550974edc92755fdb91ead193", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 67, "deletions": 34, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/e7a73881e916d08c3edd97369c127e451b4717c8/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a73881e916d08c3edd97369c127e451b4717c8/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=e7a73881e916d08c3edd97369c127e451b4717c8", "patch": "@@ -66,7 +66,7 @@ use core::mem;\n use core::ops::{CoerceUnsized, Deref, DerefMut};\n use core::ops::{Placer, Boxed, Place, InPlace, BoxPlace};\n use core::ptr::{self, Unique};\n-use core::raw::{TraitObject};\n+use core::raw::TraitObject;\n \n /// A value that represents the heap. This is the default place that the `box`\n /// keyword allocates into when no place is supplied.\n@@ -95,7 +95,9 @@ pub const HEAP: ExchangeHeapSingleton =\n            reason = \"may be renamed; uncertain about custom allocator design\",\n            issue = \"27779\")]\n #[derive(Copy, Clone)]\n-pub struct ExchangeHeapSingleton { _force_singleton: () }\n+pub struct ExchangeHeapSingleton {\n+    _force_singleton: (),\n+}\n \n /// A pointer type for heap allocation.\n ///\n@@ -126,7 +128,7 @@ pub struct Box<T: ?Sized>(Unique<T>);\n #[unstable(feature = \"placement_in\",\n            reason = \"placement box design is still being worked out.\",\n            issue = \"27779\")]\n-pub struct IntermediateBox<T: ?Sized>{\n+pub struct IntermediateBox<T: ?Sized> {\n     ptr: *mut u8,\n     size: usize,\n     align: usize,\n@@ -152,9 +154,7 @@ fn make_place<T>() -> IntermediateBox<T> {\n     let p = if size == 0 {\n         heap::EMPTY as *mut u8\n     } else {\n-        let p = unsafe {\n-            heap::allocate(size, align)\n-        };\n+        let p = unsafe { heap::allocate(size, align) };\n         if p.is_null() {\n             panic!(\"Box make_place allocation failure.\");\n         }\n@@ -165,18 +165,24 @@ fn make_place<T>() -> IntermediateBox<T> {\n }\n \n impl<T> BoxPlace<T> for IntermediateBox<T> {\n-    fn make_place() -> IntermediateBox<T> { make_place() }\n+    fn make_place() -> IntermediateBox<T> {\n+        make_place()\n+    }\n }\n \n impl<T> InPlace<T> for IntermediateBox<T> {\n     type Owner = Box<T>;\n-    unsafe fn finalize(self) -> Box<T> { finalize(self) }\n+    unsafe fn finalize(self) -> Box<T> {\n+        finalize(self)\n+    }\n }\n \n impl<T> Boxed for Box<T> {\n     type Data = T;\n     type Place = IntermediateBox<T>;\n-    unsafe fn finalize(b: IntermediateBox<T>) -> Box<T> { finalize(b) }\n+    unsafe fn finalize(b: IntermediateBox<T>) -> Box<T> {\n+        finalize(b)\n+    }\n }\n \n impl<T> Placer<T> for ExchangeHeapSingleton {\n@@ -190,9 +196,7 @@ impl<T> Placer<T> for ExchangeHeapSingleton {\n impl<T: ?Sized> Drop for IntermediateBox<T> {\n     fn drop(&mut self) {\n         if self.size > 0 {\n-            unsafe {\n-                heap::deallocate(self.ptr, self.size, self.align)\n-            }\n+            unsafe { heap::deallocate(self.ptr, self.size, self.align) }\n         }\n     }\n }\n@@ -256,13 +260,17 @@ impl<T : ?Sized> Box<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Default> Default for Box<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn default() -> Box<T> { box Default::default() }\n+    fn default() -> Box<T> {\n+        box Default::default()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for Box<[T]> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn default() -> Box<[T]> { Box::<[T; 0]>::new([]) }\n+    fn default() -> Box<[T]> {\n+        Box::<[T; 0]>::new([])\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -275,8 +283,11 @@ impl<T: Clone> Clone for Box<T> {\n     /// let x = Box::new(5);\n     /// let y = x.clone();\n     /// ```\n+    #[rustfmt_skip]\n     #[inline]\n-    fn clone(&self) -> Box<T> { box {(**self).clone()} }\n+    fn clone(&self) -> Box<T> {\n+        box { (**self).clone() }\n+    }\n     /// Copies `source`'s contents into `self` without creating a new allocation.\n     ///\n     /// # Examples\n@@ -311,9 +322,13 @@ impl Clone for Box<str> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + PartialEq> PartialEq for Box<T> {\n     #[inline]\n-    fn eq(&self, other: &Box<T>) -> bool { PartialEq::eq(&**self, &**other) }\n+    fn eq(&self, other: &Box<T>) -> bool {\n+        PartialEq::eq(&**self, &**other)\n+    }\n     #[inline]\n-    fn ne(&self, other: &Box<T>) -> bool { PartialEq::ne(&**self, &**other) }\n+    fn ne(&self, other: &Box<T>) -> bool {\n+        PartialEq::ne(&**self, &**other)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + PartialOrd> PartialOrd for Box<T> {\n@@ -322,13 +337,21 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Box<T> {\n         PartialOrd::partial_cmp(&**self, &**other)\n     }\n     #[inline]\n-    fn lt(&self, other: &Box<T>) -> bool { PartialOrd::lt(&**self, &**other) }\n+    fn lt(&self, other: &Box<T>) -> bool {\n+        PartialOrd::lt(&**self, &**other)\n+    }\n     #[inline]\n-    fn le(&self, other: &Box<T>) -> bool { PartialOrd::le(&**self, &**other) }\n+    fn le(&self, other: &Box<T>) -> bool {\n+        PartialOrd::le(&**self, &**other)\n+    }\n     #[inline]\n-    fn ge(&self, other: &Box<T>) -> bool { PartialOrd::ge(&**self, &**other) }\n+    fn ge(&self, other: &Box<T>) -> bool {\n+        PartialOrd::ge(&**self, &**other)\n+    }\n     #[inline]\n-    fn gt(&self, other: &Box<T>) -> bool { PartialOrd::gt(&**self, &**other) }\n+    fn gt(&self, other: &Box<T>) -> bool {\n+        PartialOrd::gt(&**self, &**other)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Ord> Ord for Box<T> {\n@@ -356,8 +379,7 @@ impl Box<Any> {\n             unsafe {\n                 // Get the raw representation of the trait object\n                 let raw = Box::into_raw(self);\n-                let to: TraitObject =\n-                    mem::transmute::<*mut Any, TraitObject>(raw);\n+                let to: TraitObject = mem::transmute::<*mut Any, TraitObject>(raw);\n \n                 // Extract the data pointer\n                 Ok(Box::from_raw(to.data as *mut T))\n@@ -408,23 +430,33 @@ impl<T> fmt::Pointer for Box<T> {\n impl<T: ?Sized> Deref for Box<T> {\n     type Target = T;\n \n-    fn deref(&self) -> &T { &**self }\n+    fn deref(&self) -> &T {\n+        &**self\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> DerefMut for Box<T> {\n-    fn deref_mut(&mut self) -> &mut T { &mut **self }\n+    fn deref_mut(&mut self) -> &mut T {\n+        &mut **self\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: Iterator + ?Sized> Iterator for Box<I> {\n     type Item = I::Item;\n-    fn next(&mut self) -> Option<I::Item> { (**self).next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { (**self).size_hint() }\n+    fn next(&mut self) -> Option<I::Item> {\n+        (**self).next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (**self).size_hint()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for Box<I> {\n-    fn next_back(&mut self) -> Option<I::Item> { (**self).next_back() }\n+    fn next_back(&mut self) -> Option<I::Item> {\n+        (**self).next_back()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: ExactSizeIterator + ?Sized> ExactSizeIterator for Box<I> {}\n@@ -506,10 +538,7 @@ impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<Box<U>> for Box<T> {}\n #[stable(feature = \"box_slice_clone\", since = \"1.3.0\")]\n impl<T: Clone> Clone for Box<[T]> {\n     fn clone(&self) -> Self {\n-        let mut new = BoxBuilder {\n-            data: RawVec::with_capacity(self.len()),\n-            len: 0\n-        };\n+        let mut new = BoxBuilder { data: RawVec::with_capacity(self.len()), len: 0 };\n \n         let mut target = new.data.ptr();\n \n@@ -555,9 +584,13 @@ impl<T: Clone> Clone for Box<[T]> {\n }\n \n impl<T: ?Sized> borrow::Borrow<T> for Box<T> {\n-    fn borrow(&self) -> &T { &**self }\n+    fn borrow(&self) -> &T {\n+        &**self\n+    }\n }\n \n impl<T: ?Sized> borrow::BorrowMut<T> for Box<T> {\n-    fn borrow_mut(&mut self) -> &mut T { &mut **self }\n+    fn borrow_mut(&mut self) -> &mut T {\n+        &mut **self\n+    }\n }"}, {"sha": "7f3dadcf24d230998fb6a7084365e672a603824e", "filename": "src/liballoc/boxed_test.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e7a73881e916d08c3edd97369c127e451b4717c8/src%2Fliballoc%2Fboxed_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a73881e916d08c3edd97369c127e451b4717c8/src%2Fliballoc%2Fboxed_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed_test.rs?ref=e7a73881e916d08c3edd97369c127e451b4717c8", "patch": "@@ -34,12 +34,16 @@ fn any_move() {\n     let b = Box::new(Test) as Box<Any>;\n \n     match a.downcast::<i32>() {\n-        Ok(a) => { assert!(a == Box::new(8)); }\n-        Err(..) => panic!()\n+        Ok(a) => {\n+            assert!(a == Box::new(8));\n+        }\n+        Err(..) => panic!(),\n     }\n     match b.downcast::<Test>() {\n-        Ok(a) => { assert!(a == Box::new(Test)); }\n-        Err(..) => panic!()\n+        Ok(a) => {\n+            assert!(a == Box::new(Test));\n+        }\n+        Err(..) => panic!(),\n     }\n \n     let a = Box::new(8) as Box<Any>;\n@@ -70,7 +74,8 @@ fn test_show() {\n \n #[test]\n fn deref() {\n-    fn homura<T: Deref<Target=i32>>(_: T) { }\n+    fn homura<T: Deref<Target = i32>>(_: T) {\n+    }\n     homura(Box::new(765));\n }\n "}, {"sha": "6961702cbc09d4c66766646b8a1ef4e4f803b834", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e7a73881e916d08c3edd97369c127e451b4717c8/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a73881e916d08c3edd97369c127e451b4717c8/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=e7a73881e916d08c3edd97369c127e451b4717c8", "patch": "@@ -22,18 +22,24 @@ extern {\n     #[allocator]\n     fn __rust_allocate(size: usize, align: usize) -> *mut u8;\n     fn __rust_deallocate(ptr: *mut u8, old_size: usize, align: usize);\n-    fn __rust_reallocate(ptr: *mut u8, old_size: usize, size: usize,\n-                         align: usize) -> *mut u8;\n-    fn __rust_reallocate_inplace(ptr: *mut u8, old_size: usize, size: usize,\n-                               align: usize) -> usize;\n+    fn __rust_reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8;\n+    fn __rust_reallocate_inplace(ptr: *mut u8,\n+                                 old_size: usize,\n+                                 size: usize,\n+                                 align: usize)\n+                                 -> usize;\n     fn __rust_usable_size(size: usize, align: usize) -> usize;\n }\n \n #[inline(always)]\n fn check_size_and_alignment(size: usize, align: usize) {\n     debug_assert!(size != 0);\n-    debug_assert!(size <= isize::MAX as usize, \"Tried to allocate too much: {} bytes\", size);\n-    debug_assert!(usize::is_power_of_two(align), \"Invalid alignment of allocation: {}\", align);\n+    debug_assert!(size <= isize::MAX as usize,\n+                  \"Tried to allocate too much: {} bytes\",\n+                  size);\n+    debug_assert!(usize::is_power_of_two(align),\n+                  \"Invalid alignment of allocation: {}\",\n+                  align);\n }\n \n // FIXME: #13996: mark the `allocate` and `reallocate` return value as `noalias`\n@@ -84,8 +90,11 @@ pub unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usiz\n /// create the allocation referenced by `ptr`. The `old_size` parameter may be\n /// any value in range_inclusive(requested_size, usable_size).\n #[inline]\n-pub unsafe fn reallocate_inplace(ptr: *mut u8, old_size: usize, size: usize,\n-                                 align: usize) -> usize {\n+pub unsafe fn reallocate_inplace(ptr: *mut u8,\n+                                 old_size: usize,\n+                                 size: usize,\n+                                 align: usize)\n+                                 -> usize {\n     check_size_and_alignment(size, align);\n     __rust_reallocate_inplace(ptr, old_size, size, align)\n }\n@@ -124,7 +133,9 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n         EMPTY as *mut u8\n     } else {\n         let ptr = allocate(size, align);\n-        if ptr.is_null() { ::oom() }\n+        if ptr.is_null() {\n+            ::oom()\n+        }\n         ptr\n     }\n }\n@@ -148,7 +159,9 @@ mod tests {\n         unsafe {\n             let size = 4000;\n             let ptr = heap::allocate(size, 8);\n-            if ptr.is_null() { ::oom() }\n+            if ptr.is_null() {\n+                ::oom()\n+            }\n             let ret = heap::reallocate_inplace(ptr, size, size, 8);\n             heap::deallocate(ptr, size, 8);\n             assert_eq!(ret, heap::usable_size(size, 8));"}, {"sha": "98c729aaba43308639767b7a1de4b09be2fd3154", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e7a73881e916d08c3edd97369c127e451b4717c8/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a73881e916d08c3edd97369c127e451b4717c8/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=e7a73881e916d08c3edd97369c127e451b4717c8", "patch": "@@ -107,8 +107,12 @@ extern crate alloc_system;\n \n // Allow testing this library\n \n-#[cfg(test)] #[macro_use] extern crate std;\n-#[cfg(test)] #[macro_use] extern crate log;\n+#[cfg(test)]\n+#[macro_use]\n+extern crate std;\n+#[cfg(test)]\n+#[macro_use]\n+extern crate log;\n \n // Heaps provided for low-level allocation strategies\n \n@@ -123,7 +127,9 @@ pub mod heap;\n #[cfg(not(test))]\n pub mod boxed;\n #[cfg(test)]\n-mod boxed { pub use std::boxed::{Box, HEAP}; }\n+mod boxed {\n+    pub use std::boxed::{Box, HEAP};\n+}\n #[cfg(test)]\n mod boxed_test;\n pub mod arc;"}, {"sha": "dd2db6fab086dd8539a13763677d60e413cb5410", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 40, "deletions": 12, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e7a73881e916d08c3edd97369c127e451b4717c8/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a73881e916d08c3edd97369c127e451b4717c8/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=e7a73881e916d08c3edd97369c127e451b4717c8", "patch": "@@ -58,7 +58,11 @@ impl<T> RawVec<T> {\n     pub fn new() -> Self {\n         unsafe {\n             // !0 is usize::MAX. This branch should be stripped at compile time.\n-            let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };\n+            let cap = if mem::size_of::<T>() == 0 {\n+                !0\n+            } else {\n+                0\n+            };\n \n             // heap::EMPTY doubles as \"unallocated\" and \"zero-sized allocation\"\n             RawVec { ptr: Unique::new(heap::EMPTY as *mut T), cap: cap }\n@@ -92,7 +96,9 @@ impl<T> RawVec<T> {\n             } else {\n                 let align = mem::align_of::<T>();\n                 let ptr = heap::allocate(alloc_size, align);\n-                if ptr.is_null() { oom() }\n+                if ptr.is_null() {\n+                    oom()\n+                }\n                 ptr\n             };\n \n@@ -133,7 +139,11 @@ impl<T> RawVec<T> {\n     ///\n     /// This will always be `usize::MAX` if `T` is zero-sized.\n     pub fn cap(&self) -> usize {\n-        if mem::size_of::<T>() == 0 { !0 } else { self.cap }\n+        if mem::size_of::<T>() == 0 {\n+            !0\n+        } else {\n+            self.cap\n+        }\n     }\n \n     /// Doubles the size of the type's backing allocation. This is common enough\n@@ -190,7 +200,11 @@ impl<T> RawVec<T> {\n \n             let (new_cap, ptr) = if self.cap == 0 {\n                 // skip to 4 because tiny Vec's are dumb; but not if that would cause overflow\n-                let new_cap = if elem_size > (!0) / 8 { 1 } else { 4 };\n+                let new_cap = if elem_size > (!0) / 8 {\n+                    1\n+                } else {\n+                    4\n+                };\n                 let ptr = heap::allocate(new_cap * elem_size, align);\n                 (new_cap, ptr)\n             } else {\n@@ -207,7 +221,9 @@ impl<T> RawVec<T> {\n             };\n \n             // If allocate or reallocate fail, we'll get `null` back\n-            if ptr.is_null() { oom() }\n+            if ptr.is_null() {\n+                oom()\n+            }\n \n             self.ptr = Unique::new(ptr as *mut _);\n             self.cap = new_cap;\n@@ -246,7 +262,9 @@ impl<T> RawVec<T> {\n \n             // Don't actually need any more capacity.\n             // Wrapping in case they gave a bad `used_cap`.\n-            if self.cap().wrapping_sub(used_cap) >= needed_extra_cap { return; }\n+            if self.cap().wrapping_sub(used_cap) >= needed_extra_cap {\n+                return;\n+            }\n \n             // Nothing we can really do about these checks :(\n             let new_cap = used_cap.checked_add(needed_extra_cap).expect(\"capacity overflow\");\n@@ -263,7 +281,9 @@ impl<T> RawVec<T> {\n             };\n \n             // If allocate or reallocate fail, we'll get `null` back\n-            if ptr.is_null() { oom() }\n+            if ptr.is_null() {\n+                oom()\n+            }\n \n             self.ptr = Unique::new(ptr as *mut _);\n             self.cap = new_cap;\n@@ -326,7 +346,9 @@ impl<T> RawVec<T> {\n \n             // Don't actually need any more capacity.\n             // Wrapping in case they give a bas `used_cap`\n-            if self.cap().wrapping_sub(used_cap) >= needed_extra_cap { return; }\n+            if self.cap().wrapping_sub(used_cap) >= needed_extra_cap {\n+                return;\n+            }\n \n             // Nothing we can really do about these checks :(\n             let new_cap = used_cap.checked_add(needed_extra_cap)\n@@ -346,7 +368,9 @@ impl<T> RawVec<T> {\n             };\n \n             // If allocate or reallocate fail, we'll get `null` back\n-            if ptr.is_null() { oom() }\n+            if ptr.is_null() {\n+                oom()\n+            }\n \n             self.ptr = Unique::new(ptr as *mut _);\n             self.cap = new_cap;\n@@ -374,7 +398,8 @@ impl<T> RawVec<T> {\n         }\n \n         // This check is my waterloo; it's the only thing Vec wouldn't have to do.\n-        assert!(self.cap >= amount, \"Tried to shrink to a larger capacity\");\n+        assert!(self.cap >= amount,\n+                \"Tried to shrink to a larger capacity\");\n \n         if amount == 0 {\n             mem::replace(self, RawVec::new());\n@@ -386,7 +411,9 @@ impl<T> RawVec<T> {\n                                            self.cap * elem_size,\n                                            amount * elem_size,\n                                            align);\n-                if ptr.is_null() { oom() }\n+                if ptr.is_null() {\n+                    oom()\n+                }\n                 self.ptr = Unique::new(ptr as *mut _);\n             }\n             self.cap = amount;\n@@ -446,6 +473,7 @@ impl<T> Drop for RawVec<T> {\n #[inline]\n fn alloc_guard(alloc_size: usize) {\n     if core::usize::BITS < 64 {\n-        assert!(alloc_size <= ::core::isize::MAX as usize, \"capacity overflow\");\n+        assert!(alloc_size <= ::core::isize::MAX as usize,\n+                \"capacity overflow\");\n     }\n }"}, {"sha": "3507f123a6f153c3b060ff3f5b5a403e5c0d8775", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 48, "deletions": 19, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/e7a73881e916d08c3edd97369c127e451b4717c8/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a73881e916d08c3edd97369c127e451b4717c8/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=e7a73881e916d08c3edd97369c127e451b4717c8", "patch": "@@ -213,7 +213,7 @@ impl<T> Rc<T> {\n                 _ptr: NonZero::new(Box::into_raw(box RcBox {\n                     strong: Cell::new(1),\n                     weak: Cell::new(1),\n-                    value: value\n+                    value: value,\n                 })),\n             }\n         }\n@@ -290,13 +290,17 @@ impl<T: ?Sized> Rc<T> {\n     #[inline]\n     #[unstable(feature = \"rc_counts\", reason = \"not clearly useful\",\n                issue = \"28356\")]\n-    pub fn weak_count(this: &Self) -> usize { this.weak() - 1 }\n+    pub fn weak_count(this: &Self) -> usize {\n+        this.weak() - 1\n+    }\n \n     /// Get the number of strong references to this value.\n     #[inline]\n     #[unstable(feature = \"rc_counts\", reason = \"not clearly useful\",\n                issue = \"28356\")]\n-    pub fn strong_count(this: &Self) -> usize { this.strong() }\n+    pub fn strong_count(this: &Self) -> usize {\n+        this.strong()\n+    }\n \n     /// Returns true if there are no other `Rc` or `Weak<T>` values that share\n     /// the same inner value.\n@@ -451,7 +455,7 @@ impl<T: ?Sized> Drop for Rc<T> {\n         unsafe {\n             let ptr = *self._ptr;\n             if !(*(&ptr as *const _ as *const *const ())).is_null() &&\n-                ptr as *const () as usize != mem::POST_DROP_USIZE {\n+               ptr as *const () as usize != mem::POST_DROP_USIZE {\n                 self.dec_strong();\n                 if self.strong() == 0 {\n                     // destroy the contained object\n@@ -530,7 +534,9 @@ impl<T: ?Sized + PartialEq> PartialEq for Rc<T> {\n     /// five == Rc::new(5);\n     /// ```\n     #[inline(always)]\n-    fn eq(&self, other: &Rc<T>) -> bool { **self == **other }\n+    fn eq(&self, other: &Rc<T>) -> bool {\n+        **self == **other\n+    }\n \n     /// Inequality for two `Rc<T>`s.\n     ///\n@@ -546,7 +552,9 @@ impl<T: ?Sized + PartialEq> PartialEq for Rc<T> {\n     /// five != Rc::new(5);\n     /// ```\n     #[inline(always)]\n-    fn ne(&self, other: &Rc<T>) -> bool { **self != **other }\n+    fn ne(&self, other: &Rc<T>) -> bool {\n+        **self != **other\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -586,7 +594,9 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Rc<T> {\n     /// five < Rc::new(5);\n     /// ```\n     #[inline(always)]\n-    fn lt(&self, other: &Rc<T>) -> bool { **self < **other }\n+    fn lt(&self, other: &Rc<T>) -> bool {\n+        **self < **other\n+    }\n \n     /// 'Less-than or equal to' comparison for two `Rc<T>`s.\n     ///\n@@ -602,7 +612,9 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Rc<T> {\n     /// five <= Rc::new(5);\n     /// ```\n     #[inline(always)]\n-    fn le(&self, other: &Rc<T>) -> bool { **self <= **other }\n+    fn le(&self, other: &Rc<T>) -> bool {\n+        **self <= **other\n+    }\n \n     /// Greater-than comparison for two `Rc<T>`s.\n     ///\n@@ -618,7 +630,9 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Rc<T> {\n     /// five > Rc::new(5);\n     /// ```\n     #[inline(always)]\n-    fn gt(&self, other: &Rc<T>) -> bool { **self > **other }\n+    fn gt(&self, other: &Rc<T>) -> bool {\n+        **self > **other\n+    }\n \n     /// 'Greater-than or equal to' comparison for two `Rc<T>`s.\n     ///\n@@ -634,7 +648,9 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Rc<T> {\n     /// five >= Rc::new(5);\n     /// ```\n     #[inline(always)]\n-    fn ge(&self, other: &Rc<T>) -> bool { **self >= **other }\n+    fn ge(&self, other: &Rc<T>) -> bool {\n+        **self >= **other\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -653,7 +669,9 @@ impl<T: ?Sized + Ord> Ord for Rc<T> {\n     /// five.partial_cmp(&Rc::new(5));\n     /// ```\n     #[inline]\n-    fn cmp(&self, other: &Rc<T>) -> Ordering { (**self).cmp(&**other) }\n+    fn cmp(&self, other: &Rc<T>) -> Ordering {\n+        (**self).cmp(&**other)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -764,12 +782,13 @@ impl<T: ?Sized> Drop for Weak<T> {\n         unsafe {\n             let ptr = *self._ptr;\n             if !(*(&ptr as *const _ as *const *const ())).is_null() &&\n-                ptr as *const () as usize != mem::POST_DROP_USIZE {\n+               ptr as *const () as usize != mem::POST_DROP_USIZE {\n                 self.dec_weak();\n                 // the weak count starts at 1, and will only go to zero if all\n                 // the strong pointers have disappeared.\n                 if self.weak() == 0 {\n-                    deallocate(ptr as *mut u8, size_of_val(&*ptr),\n+                    deallocate(ptr as *mut u8,\n+                               size_of_val(&*ptr),\n                                align_of_val(&*ptr))\n                 }\n             }\n@@ -821,26 +840,34 @@ trait RcBoxPtr<T: ?Sized> {\n     fn inner(&self) -> &RcBox<T>;\n \n     #[inline]\n-    fn strong(&self) -> usize { self.inner().strong.get() }\n+    fn strong(&self) -> usize {\n+        self.inner().strong.get()\n+    }\n \n     #[inline]\n     fn inc_strong(&self) {\n         self.inner().strong.set(self.strong().checked_add(1).unwrap_or_else(|| unsafe { abort() }));\n     }\n \n     #[inline]\n-    fn dec_strong(&self) { self.inner().strong.set(self.strong() - 1); }\n+    fn dec_strong(&self) {\n+        self.inner().strong.set(self.strong() - 1);\n+    }\n \n     #[inline]\n-    fn weak(&self) -> usize { self.inner().weak.get() }\n+    fn weak(&self) -> usize {\n+        self.inner().weak.get()\n+    }\n \n     #[inline]\n     fn inc_weak(&self) {\n         self.inner().weak.set(self.weak().checked_add(1).unwrap_or_else(|| unsafe { abort() }));\n     }\n \n     #[inline]\n-    fn dec_weak(&self) { self.inner().weak.set(self.weak() - 1); }\n+    fn dec_weak(&self) {\n+        self.inner().weak.set(self.weak() - 1);\n+    }\n }\n \n impl<T: ?Sized> RcBoxPtr<T> for Rc<T> {\n@@ -928,7 +955,7 @@ mod tests {\n     #[test]\n     fn weak_self_cyclic() {\n         struct Cycle {\n-            x: RefCell<Option<Weak<Cycle>>>\n+            x: RefCell<Option<Weak<Cycle>>>,\n         }\n \n         let a = Rc::new(Cycle { x: RefCell::new(None) });\n@@ -1086,5 +1113,7 @@ mod tests {\n }\n \n impl<T: ?Sized> borrow::Borrow<T> for Rc<T> {\n-    fn borrow(&self) -> &T { &**self }\n+    fn borrow(&self) -> &T {\n+        &**self\n+    }\n }"}]}