{"sha": "0e326d4780a9c0125b354f1bb6cf65b7feb05271", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlMzI2ZDQ3ODBhOWMwMTI1YjM1NGYxYmI2Y2Y2NWI3ZmViMDUyNzE=", "commit": {"author": {"name": "ggomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-06-28T17:40:40Z"}, "committer": {"name": "ggomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-06-29T11:28:49Z"}, "message": "Add error codes in libsyntax", "tree": {"sha": "ebe85305ab506e478358deae38a506f9d2e0a0fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebe85305ab506e478358deae38a506f9d2e0a0fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e326d4780a9c0125b354f1bb6cf65b7feb05271", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e326d4780a9c0125b354f1bb6cf65b7feb05271", "html_url": "https://github.com/rust-lang/rust/commit/0e326d4780a9c0125b354f1bb6cf65b7feb05271", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e326d4780a9c0125b354f1bb6cf65b7feb05271/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea0dc9297283daff6486807f43e190b4eb561412", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea0dc9297283daff6486807f43e190b4eb561412", "html_url": "https://github.com/rust-lang/rust/commit/ea0dc9297283daff6486807f43e190b4eb561412"}], "stats": {"total": 197, "additions": 142, "deletions": 55}, "files": [{"sha": "3e9b08c3cf29e475e4d796501a5d3673b849ebfb", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 65, "deletions": 40, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/0e326d4780a9c0125b354f1bb6cf65b7feb05271/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e326d4780a9c0125b354f1bb6cf65b7feb05271/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=0e326d4780a9c0125b354f1bb6cf65b7feb05271", "patch": "@@ -34,6 +34,27 @@ thread_local! {\n     static USED_ATTRS: RefCell<Vec<u64>> = RefCell::new(Vec::new())\n }\n \n+enum AttrError {\n+    MultipleItem(InternedString),\n+    UnknownMetaItem(InternedString),\n+    MissingSince,\n+    MissingFeature,\n+    MultipleStabilityLevels,\n+}\n+\n+fn handle_errors(diag: &Handler, span: Span, error: AttrError) {\n+    match error {\n+        AttrError::MultipleItem(item) => span_err!(diag, span, E0538,\n+                                                   \"multiple '{}' items\", item),\n+        AttrError::UnknownMetaItem(item) => span_err!(diag, span, E0541,\n+                                                      \"unknown meta item '{}'\", item),\n+        AttrError::MissingSince => span_err!(diag, span, E0542, \"missing 'since'\"),\n+        AttrError::MissingFeature => span_err!(diag, span, E0546, \"missing 'feature'\"),\n+        AttrError::MultipleStabilityLevels => span_err!(diag, span, E0544,\n+                                                        \"multiple stability levels\"),\n+    }\n+}\n+\n pub fn mark_used(attr: &Attribute) {\n     let AttrId(id) = attr.node.id;\n     USED_ATTRS.with(|slot| {\n@@ -303,10 +324,10 @@ pub fn find_export_name_attr(diag: &Handler, attrs: &[Attribute]) -> Option<Inte\n             if let s@Some(_) = attr.value_str() {\n                 s\n             } else {\n-                diag.struct_span_err(attr.span,\n-                                     \"export_name attribute has invalid format\")\n-                    .help(\"use #[export_name=\\\"*\\\"]\")\n-                    .emit();\n+                struct_span_err!(diag, attr.span, E0533,\n+                                 \"export_name attribute has invalid format\")\n+                                .help(\"use #[export_name=\\\"*\\\"]\")\n+                                .emit();\n                 None\n             }\n         } else {\n@@ -339,14 +360,16 @@ pub fn find_inline_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> In\n             MetaItemKind::List(ref n, ref items) if n == \"inline\" => {\n                 mark_used(attr);\n                 if items.len() != 1 {\n-                    diagnostic.map(|d|{ d.span_err(attr.span, \"expected one argument\"); });\n+                    diagnostic.map(|d|{ span_err!(d, attr.span, E0534, \"expected one argument\"); });\n                     InlineAttr::None\n                 } else if contains_name(&items[..], \"always\") {\n                     InlineAttr::Always\n                 } else if contains_name(&items[..], \"never\") {\n                     InlineAttr::Never\n                 } else {\n-                    diagnostic.map(|d|{ d.span_err((*items[0]).span, \"invalid argument\"); });\n+                    diagnostic.map(|d| {\n+                        span_err!(d, (*items[0]).span, E0535, \"invalid argument\");\n+                    });\n                     InlineAttr::None\n                 }\n             }\n@@ -374,13 +397,13 @@ pub fn cfg_matches(cfgs: &[P<MetaItem>], cfg: &ast::MetaItem,\n             mis.iter().all(|mi| cfg_matches(cfgs, &mi, sess, features)),\n         ast::MetaItemKind::List(ref pred, ref mis) if &pred[..] == \"not\" => {\n             if mis.len() != 1 {\n-                sess.span_diagnostic.span_err(cfg.span, \"expected 1 cfg-pattern\");\n+                span_err!(sess.span_diagnostic, cfg.span, E0536, \"expected 1 cfg-pattern\");\n                 return false;\n             }\n             !cfg_matches(cfgs, &mis[0], sess, features)\n         }\n         ast::MetaItemKind::List(ref pred, _) => {\n-            sess.span_diagnostic.span_err(cfg.span, &format!(\"invalid predicate `{}`\", pred));\n+            span_err!(sess.span_diagnostic, cfg.span, E0537, \"invalid predicate `{}`\", pred);\n             false\n         },\n         ast::MetaItemKind::Word(_) | ast::MetaItemKind::NameValue(..) => {\n@@ -446,23 +469,23 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n         if let Some(metas) = attr.meta_item_list() {\n             let get = |meta: &MetaItem, item: &mut Option<InternedString>| {\n                 if item.is_some() {\n-                    diagnostic.span_err(meta.span, &format!(\"multiple '{}' items\",\n-                                                             meta.name()));\n+                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()));\n                     return false\n                 }\n                 if let Some(v) = meta.value_str() {\n                     *item = Some(v);\n                     true\n                 } else {\n-                    diagnostic.span_err(meta.span, \"incorrect meta item\");\n+                    span_err!(diagnostic, meta.span, E0539, \"incorrect meta item\");\n                     false\n                 }\n             };\n \n             match tag {\n                 \"rustc_deprecated\" => {\n                     if rustc_depr.is_some() {\n-                        diagnostic.span_err(item_sp, \"multiple rustc_deprecated attributes\");\n+                        span_err!(diagnostic, item_sp, E0540,\n+                                  \"multiple rustc_deprecated attributes\");\n                         break\n                     }\n \n@@ -473,8 +496,8 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                             \"since\" => if !get(meta, &mut since) { continue 'outer },\n                             \"reason\" => if !get(meta, &mut reason) { continue 'outer },\n                             _ => {\n-                                diagnostic.span_err(meta.span, &format!(\"unknown meta item '{}'\",\n-                                                                        meta.name()));\n+                                handle_errors(diagnostic, meta.span,\n+                                              AttrError::UnknownMetaItem(meta.name()));\n                                 continue 'outer\n                             }\n                         }\n@@ -488,18 +511,18 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                             })\n                         }\n                         (None, _) => {\n-                            diagnostic.span_err(attr.span(), \"missing 'since'\");\n+                            handle_errors(diagnostic, attr.span(), AttrError::MissingSince);\n                             continue\n                         }\n                         _ => {\n-                            diagnostic.span_err(attr.span(), \"missing 'reason'\");\n+                            span_err!(diagnostic, attr.span(), E0543, \"missing 'reason'\");\n                             continue\n                         }\n                     }\n                 }\n                 \"unstable\" => {\n                     if stab.is_some() {\n-                        diagnostic.span_err(item_sp, \"multiple stability levels\");\n+                        handle_errors(diagnostic, attr.span(), AttrError::MultipleStabilityLevels);\n                         break\n                     }\n \n@@ -512,8 +535,8 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                             \"reason\" => if !get(meta, &mut reason) { continue 'outer },\n                             \"issue\" => if !get(meta, &mut issue) { continue 'outer },\n                             _ => {\n-                                diagnostic.span_err(meta.span, &format!(\"unknown meta item '{}'\",\n-                                                                        meta.name()));\n+                                handle_errors(diagnostic, meta.span,\n+                                              AttrError::UnknownMetaItem(meta.name()));\n                                 continue 'outer\n                             }\n                         }\n@@ -528,7 +551,8 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                                         if let Ok(issue) = issue.parse() {\n                                             issue\n                                         } else {\n-                                            diagnostic.span_err(attr.span(), \"incorrect 'issue'\");\n+                                            span_err!(diagnostic, attr.span(), E0545,\n+                                                      \"incorrect 'issue'\");\n                                             continue\n                                         }\n                                     }\n@@ -538,18 +562,18 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                             })\n                         }\n                         (None, _, _) => {\n-                            diagnostic.span_err(attr.span(), \"missing 'feature'\");\n+                            handle_errors(diagnostic, attr.span(), AttrError::MissingFeature);\n                             continue\n                         }\n                         _ => {\n-                            diagnostic.span_err(attr.span(), \"missing 'issue'\");\n+                            span_err!(diagnostic, attr.span(), E0547, \"missing 'issue'\");\n                             continue\n                         }\n                     }\n                 }\n                 \"stable\" => {\n                     if stab.is_some() {\n-                        diagnostic.span_err(item_sp, \"multiple stability levels\");\n+                        handle_errors(diagnostic, attr.span(), AttrError::MultipleStabilityLevels);\n                         break\n                     }\n \n@@ -560,8 +584,8 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                             \"feature\" => if !get(meta, &mut feature) { continue 'outer },\n                             \"since\" => if !get(meta, &mut since) { continue 'outer },\n                             _ => {\n-                                diagnostic.span_err(meta.span, &format!(\"unknown meta item '{}'\",\n-                                                                        meta.name()));\n+                                handle_errors(diagnostic, meta.span,\n+                                              AttrError::UnknownMetaItem(meta.name()));\n                                 continue 'outer\n                             }\n                         }\n@@ -578,19 +602,19 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                             })\n                         }\n                         (None, _) => {\n-                            diagnostic.span_err(attr.span(), \"missing 'feature'\");\n+                            handle_errors(diagnostic, attr.span(), AttrError::MissingFeature);\n                             continue\n                         }\n                         _ => {\n-                            diagnostic.span_err(attr.span(), \"missing 'since'\");\n+                            handle_errors(diagnostic, attr.span(), AttrError::MissingSince);\n                             continue\n                         }\n                     }\n                 }\n                 _ => unreachable!()\n             }\n         } else {\n-            diagnostic.span_err(attr.span(), \"incorrect stability attribute type\");\n+            span_err!(diagnostic, attr.span(), E0548, \"incorrect stability attribute type\");\n             continue\n         }\n     }\n@@ -603,8 +627,9 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n             }\n             stab.rustc_depr = Some(rustc_depr);\n         } else {\n-            diagnostic.span_err(item_sp, \"rustc_deprecated attribute must be paired with \\\n-                                          either stable or unstable attribute\");\n+            span_err!(diagnostic, item_sp, E0549,\n+                      \"rustc_deprecated attribute must be paired with \\\n+                       either stable or unstable attribute\");\n         }\n     }\n \n@@ -627,22 +652,21 @@ fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n         mark_used(attr);\n \n         if depr.is_some() {\n-            diagnostic.span_err(item_sp, \"multiple deprecated attributes\");\n+            span_err!(diagnostic, item_sp, E0550, \"multiple deprecated attributes\");\n             break\n         }\n \n         depr = if let Some(metas) = attr.meta_item_list() {\n             let get = |meta: &MetaItem, item: &mut Option<InternedString>| {\n                 if item.is_some() {\n-                    diagnostic.span_err(meta.span, &format!(\"multiple '{}' items\",\n-                                                             meta.name()));\n+                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()));\n                     return false\n                 }\n                 if let Some(v) = meta.value_str() {\n                     *item = Some(v);\n                     true\n                 } else {\n-                    diagnostic.span_err(meta.span, \"incorrect meta item\");\n+                    span_err!(diagnostic, meta.span, E0551, \"incorrect meta item\");\n                     false\n                 }\n             };\n@@ -654,8 +678,8 @@ fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n                     \"since\" => if !get(meta, &mut since) { continue 'outer },\n                     \"note\" => if !get(meta, &mut note) { continue 'outer },\n                     _ => {\n-                        diagnostic.span_err(meta.span, &format!(\"unknown meta item '{}'\",\n-                                                                meta.name()));\n+                        handle_errors(diagnostic, meta.span,\n+                                      AttrError::UnknownMetaItem(meta.name()));\n                         continue 'outer\n                     }\n                 }\n@@ -689,7 +713,7 @@ pub fn require_unique_names(diagnostic: &Handler, metas: &[P<MetaItem>]) {\n \n         if !set.insert(name.clone()) {\n             panic!(diagnostic.span_fatal(meta.span,\n-                                  &format!(\"duplicate meta item `{}`\", name)));\n+                                         &format!(\"duplicate meta item `{}`\", name)));\n         }\n     }\n }\n@@ -718,8 +742,8 @@ pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr>\n                                 Some(ity) => Some(ReprInt(item.span, ity)),\n                                 None => {\n                                     // Not a word we recognize\n-                                    diagnostic.span_err(item.span,\n-                                                        \"unrecognized representation hint\");\n+                                    span_err!(diagnostic, item.span, E0552,\n+                                              \"unrecognized representation hint\");\n                                     None\n                                 }\n                             }\n@@ -731,7 +755,8 @@ pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr>\n                         }\n                     }\n                     // Not a word:\n-                    _ => diagnostic.span_err(item.span, \"unrecognized enum representation hint\")\n+                    _ => span_err!(diagnostic, item.span, E0553,\n+                                   \"unrecognized enum representation hint\"),\n                 }\n             }\n         }"}, {"sha": "d2a76ca92d0b39a7040c71906a45a1cce8c48a20", "filename": "src/libsyntax/diagnostic_list.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0e326d4780a9c0125b354f1bb6cf65b7feb05271/src%2Flibsyntax%2Fdiagnostic_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e326d4780a9c0125b354f1bb6cf65b7feb05271/src%2Flibsyntax%2Fdiagnostic_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic_list.rs?ref=0e326d4780a9c0125b354f1bb6cf65b7feb05271", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(non_snake_case)]\n+\n+// Error messages for EXXXX errors.\n+// Each message should start and end with a new line, and be wrapped to 80 characters.\n+// In vim you can `:set tw=80` and use `gq` to wrap paragraphs. Use `:set tw=0` to disable.\n+register_long_diagnostics! {\n+\n+E0533: r##\"\n+```compile_fail,E0533\n+#[export_name]\n+pub fn something() {}\n+```\n+\"##,\n+\n+}\n+\n+\n+register_diagnostics! {\n+    E0534,\n+    E0535,\n+    E0536,\n+    E0537,\n+    E0538,\n+    E0539,\n+    E0540,\n+    E0541,\n+    E0542,\n+    E0543,\n+    E0544,\n+    E0545,\n+    E0546,\n+    E0547,\n+    E0548,\n+    E0549,\n+    E0550,\n+    E0551,\n+    E0552,\n+    E0553,\n+    E0554,\n+    E0555,\n+    E0556,\n+    E0557,\n+    E0558,\n+}"}, {"sha": "bc2aa59ff09d6c6f32419b323f0a1178e42294eb", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0e326d4780a9c0125b354f1bb6cf65b7feb05271/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e326d4780a9c0125b354f1bb6cf65b7feb05271/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=0e326d4780a9c0125b354f1bb6cf65b7feb05271", "patch": "@@ -1103,17 +1103,16 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute]) -> F\n \n         match attr.meta_item_list() {\n             None => {\n-                span_handler.span_err(attr.span, \"malformed feature attribute, \\\n-                                                  expected #![feature(...)]\");\n+                span_err!(span_handler, attr.span, E0555,\n+                          \"malformed feature attribute, expected #![feature(...)]\");\n             }\n             Some(list) => {\n                 for mi in list {\n                     let name = match mi.node {\n                         ast::MetaItemKind::Word(ref word) => (*word).clone(),\n                         _ => {\n-                            span_handler.span_err(mi.span,\n-                                                  \"malformed feature, expected just \\\n-                                                   one word\");\n+                            span_err!(span_handler, mi.span, E0556,\n+                                      \"malformed feature, expected just one word\");\n                             continue\n                         }\n                     };\n@@ -1123,7 +1122,7 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute]) -> F\n                     }\n                     else if let Some(&(_, _, _)) = REMOVED_FEATURES.iter()\n                         .find(|& &(n, _, _)| name == n) {\n-                        span_handler.span_err(mi.span, \"feature has been removed\");\n+                        span_err!(span_handler, mi.span, E0557, \"feature has been removed\");\n                     }\n                     else if let Some(&(_, _, _)) = ACCEPTED_FEATURES.iter()\n                         .find(|& &(n, _, _)| name == n) {\n@@ -1179,9 +1178,9 @@ fn maybe_stage_features(span_handler: &Handler, krate: &ast::Crate,\n         for attr in &krate.attrs {\n             if attr.check_name(\"feature\") {\n                 let release_channel = option_env!(\"CFG_RELEASE_CHANNEL\").unwrap_or(\"(unknown)\");\n-                let ref msg = format!(\"#[feature] may not be used on the {} release channel\",\n-                                      release_channel);\n-                span_handler.span_err(attr.span, msg);\n+                span_err!(span_handler, attr.span, E0558,\n+                          \"#[feature] may not be used on the {} release channel\",\n+                          release_channel);\n             }\n         }\n     }"}, {"sha": "9599ce681b296483ad24b231e6d4e7486c029d13", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0e326d4780a9c0125b354f1bb6cf65b7feb05271/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e326d4780a9c0125b354f1bb6cf65b7feb05271/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=0e326d4780a9c0125b354f1bb6cf65b7feb05271", "patch": "@@ -33,6 +33,7 @@\n #![feature(str_escape)]\n #![feature(unicode)]\n #![feature(question_mark)]\n+#![feature(rustc_diagnostic_macros)]\n \n extern crate serialize;\n extern crate term;\n@@ -66,6 +67,18 @@ macro_rules! panictry {\n     })\n }\n \n+#[macro_use]\n+pub mod diagnostics {\n+    #[macro_use]\n+    pub mod macros;\n+    pub mod plugin;\n+    pub mod metadata;\n+}\n+\n+// NB: This module needs to be declared first so diagnostics are\n+// registered before they are used.\n+pub mod diagnostic_list;\n+\n pub mod util {\n     pub mod interner;\n     pub mod lev_distance;\n@@ -80,12 +93,6 @@ pub mod util {\n     pub use self::thin_vec::ThinVec;\n }\n \n-pub mod diagnostics {\n-    pub mod macros;\n-    pub mod plugin;\n-    pub mod metadata;\n-}\n-\n pub mod json;\n \n pub mod syntax {\n@@ -130,3 +137,5 @@ pub mod ext {\n         pub mod macro_rules;\n     }\n }\n+\n+__build_diagnostic_array! { libsyntax, DIAGNOSTICS }"}]}