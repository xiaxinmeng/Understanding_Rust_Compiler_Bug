{"sha": "a1c34493d4d733fedf2a8609d7426a425eb7cf84", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExYzM0NDkzZDRkNzMzZmVkZjJhODYwOWQ3NDI2YTQyNWViN2NmODQ=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-04-04T17:19:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-04T17:19:58Z"}, "message": "Rollup merge of #73945 - est31:unused_externs, r=Mark-Simulacrum\n\nAdd an unstable --json=unused-externs flag to print unused externs\n\nThis adds an unstable flag to print a list of the extern names not used by cargo.\n\nThis PR will enable cargo to collect unused dependencies from all units and provide warnings.\nThe companion PR to cargo is: https://github.com/rust-lang/cargo/pull/8437\n\nThe goal is eventual stabilization of this flag in rustc as well as in cargo.\n\nDiscussion of this feature is mostly contained inside these threads: #57274 #72342 #72603\n\nThe feature builds upon the internal datastructures added by #72342\n\nExterns are uniquely identified by name and the information is sufficient for cargo.\nIf the mode is enabled, rustc will print json messages like:\n\n```\n{\"unused_extern_names\":[\"byteorder\",\"openssl\",\"webpki\"]}\n```\n\nFor a crate that got passed byteorder, openssl and webpki dependencies but needed none of them.\n\n### Q: Why not pass -Wunused-crate-dependencies?\nA: See [ehuss's comment here](https://github.com/rust-lang/rust/issues/57274#issuecomment-624839355)\n   TLDR: it's cleaner. Rust's warning system wasn't built to be filtered or edited by cargo.\n   Even a basic implementation of the feature would have to change the \"n warnings emitted\" line that rustc prints at the end.\n   Cargo ideally wants to synthesize its own warnings anyways. For example, it would be hard for rustc to emit warnings like\n   \"dependency foo is only used by dev targets\", suggesting to make it a dev-dependency instead.\n\n### Q: Make rustc emit used or unused externs?\nA: Emitting used externs has the advantage that it simplifies cargo's collection job.\n   However, emitting unused externs creates less data to be communicated between rustc and cargo.\n   Often you want to paste a cargo command obtained from `cargo build -vv` for doing something\n   completely unrelated. The message is emitted always, even if no warning or error is emitted.\n   At that point, even this tiny difference in \"noise\" matters. That's why I went with emitting unused externs.\n\n### Q: One json msg per extern or a collective json msg?\nA: Same as above, the data format should be concise. Having 30 lines for the 30 crates a crate uses would be disturbing to readers.\n   Also it helps the cargo implementation to know that there aren't more unused deps coming.\n\n### Q: Why use names of externs instead of e.g. paths?\nA: Names are both sufficient as well as neccessary to uniquely identify a passed `--extern` arg.\n   Names are sufficient because you *must* pass a name when passing an `--extern` arg.\n   Passing a path is optional on the other hand so rustc might also figure out a crate's location from the file system.\n   You can also put multiple paths for the same extern name, via e.g. `--extern hello=/usr/lib/hello.rmeta --extern hello=/usr/local/lib/hello.rmeta`,\n   but rustc will only ever use one of those paths.\n   Also, paths don't identify a dependency uniquely as it is possible to have multiple different extern names point to the same path.\n   So paths are ill-suited for identification.\n\n### Q: What about 2015 edition crates?\nA: They are fully supported.\n   Even on the 2015 edition, an explicit `--extern` flag is is required to enable `extern crate foo;` to work (outside of sysroot crates, which this flag doesn't warn about anyways).\n   So the lint would still fire on 2015 edition crates if you haven't included a dependency specified in Cargo.toml using `extern crate foo;` or similar.\n   The lint won't fire if your sole use in the crate is through a `extern crate foo;`   statement, but that's not its job.\n   For detecting unused `extern crate foo` statements, there is the `unused_extern_crates` lint\n   which can be enabled by `#![warn(unused_extern_crates)]` or similar.\n\ncc ```@jsgf``` ```@ehuss``` ```@petrochenkov``` ```@estebank```", "tree": {"sha": "03fd5fad00d9adf01b8cc7cfa59bcf99038a610c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03fd5fad00d9adf01b8cc7cfa59bcf99038a610c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1c34493d4d733fedf2a8609d7426a425eb7cf84", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgafU+CRBK7hj4Ov3rIwAAdHIIAIDG8BGD/i0XqR8dJf4/5P1I\npElYPdTYdaUxHe4Qr8XoykVurnN1yEBnea1ZELrSh+TQsv9GAQN8Gklf4dGSU44X\neDQuZQs+Qw3huyJOpFoJE9LE/q2ewxSYLE2IV61h9+3rS/qsCD0Bv5QwmND3RQOe\n3Hj65ioNI5F5I3sWXm0i+Ii1M1uWDo96bISKpmabV11aW6okNUmRBqw9LJ7uR1Gw\n8l6OSB1uJJWC27yWW0zIRAnyv9GKL6SnsmNVJ7axrTibplDplC53OyNv4pNqks/h\n8M20sxMXdYr1zQVYKuxFhcEJ7Sv5wypI2UmW9MYl2Yo0OI+EmBd4WaQSI32WUIk=\n=RP49\n-----END PGP SIGNATURE-----\n", "payload": "tree 03fd5fad00d9adf01b8cc7cfa59bcf99038a610c\nparent b1ea2618d3fef50981c566564cf234b4b98f6328\nparent d018ef180d9bc4e852457fd83fda0bec8452baf6\nauthor Dylan DPC <dylan.dpc@gmail.com> 1617556798 +0200\ncommitter GitHub <noreply@github.com> 1617556798 +0200\n\nRollup merge of #73945 - est31:unused_externs, r=Mark-Simulacrum\n\nAdd an unstable --json=unused-externs flag to print unused externs\n\nThis adds an unstable flag to print a list of the extern names not used by cargo.\n\nThis PR will enable cargo to collect unused dependencies from all units and provide warnings.\nThe companion PR to cargo is: https://github.com/rust-lang/cargo/pull/8437\n\nThe goal is eventual stabilization of this flag in rustc as well as in cargo.\n\nDiscussion of this feature is mostly contained inside these threads: #57274 #72342 #72603\n\nThe feature builds upon the internal datastructures added by #72342\n\nExterns are uniquely identified by name and the information is sufficient for cargo.\nIf the mode is enabled, rustc will print json messages like:\n\n```\n{\"unused_extern_names\":[\"byteorder\",\"openssl\",\"webpki\"]}\n```\n\nFor a crate that got passed byteorder, openssl and webpki dependencies but needed none of them.\n\n### Q: Why not pass -Wunused-crate-dependencies?\nA: See [ehuss's comment here](https://github.com/rust-lang/rust/issues/57274#issuecomment-624839355)\n   TLDR: it's cleaner. Rust's warning system wasn't built to be filtered or edited by cargo.\n   Even a basic implementation of the feature would have to change the \"n warnings emitted\" line that rustc prints at the end.\n   Cargo ideally wants to synthesize its own warnings anyways. For example, it would be hard for rustc to emit warnings like\n   \"dependency foo is only used by dev targets\", suggesting to make it a dev-dependency instead.\n\n### Q: Make rustc emit used or unused externs?\nA: Emitting used externs has the advantage that it simplifies cargo's collection job.\n   However, emitting unused externs creates less data to be communicated between rustc and cargo.\n   Often you want to paste a cargo command obtained from `cargo build -vv` for doing something\n   completely unrelated. The message is emitted always, even if no warning or error is emitted.\n   At that point, even this tiny difference in \"noise\" matters. That's why I went with emitting unused externs.\n\n### Q: One json msg per extern or a collective json msg?\nA: Same as above, the data format should be concise. Having 30 lines for the 30 crates a crate uses would be disturbing to readers.\n   Also it helps the cargo implementation to know that there aren't more unused deps coming.\n\n### Q: Why use names of externs instead of e.g. paths?\nA: Names are both sufficient as well as neccessary to uniquely identify a passed `--extern` arg.\n   Names are sufficient because you *must* pass a name when passing an `--extern` arg.\n   Passing a path is optional on the other hand so rustc might also figure out a crate's location from the file system.\n   You can also put multiple paths for the same extern name, via e.g. `--extern hello=/usr/lib/hello.rmeta --extern hello=/usr/local/lib/hello.rmeta`,\n   but rustc will only ever use one of those paths.\n   Also, paths don't identify a dependency uniquely as it is possible to have multiple different extern names point to the same path.\n   So paths are ill-suited for identification.\n\n### Q: What about 2015 edition crates?\nA: They are fully supported.\n   Even on the 2015 edition, an explicit `--extern` flag is is required to enable `extern crate foo;` to work (outside of sysroot crates, which this flag doesn't warn about anyways).\n   So the lint would still fire on 2015 edition crates if you haven't included a dependency specified in Cargo.toml using `extern crate foo;` or similar.\n   The lint won't fire if your sole use in the crate is through a `extern crate foo;`   statement, but that's not its job.\n   For detecting unused `extern crate foo` statements, there is the `unused_extern_crates` lint\n   which can be enabled by `#![warn(unused_extern_crates)]` or similar.\n\ncc ```@jsgf``` ```@ehuss``` ```@petrochenkov``` ```@estebank```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1c34493d4d733fedf2a8609d7426a425eb7cf84", "html_url": "https://github.com/rust-lang/rust/commit/a1c34493d4d733fedf2a8609d7426a425eb7cf84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1c34493d4d733fedf2a8609d7426a425eb7cf84/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1ea2618d3fef50981c566564cf234b4b98f6328", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1ea2618d3fef50981c566564cf234b4b98f6328", "html_url": "https://github.com/rust-lang/rust/commit/b1ea2618d3fef50981c566564cf234b4b98f6328"}, {"sha": "d018ef180d9bc4e852457fd83fda0bec8452baf6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d018ef180d9bc4e852457fd83fda0bec8452baf6", "html_url": "https://github.com/rust-lang/rust/commit/d018ef180d9bc4e852457fd83fda0bec8452baf6"}], "stats": {"total": 231, "additions": 218, "deletions": 13}, "files": [{"sha": "a58caf2667b063422046e32ebdf2ed020ce5f1eb", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a1c34493d4d733fedf2a8609d7426a425eb7cf84/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c34493d4d733fedf2a8609d7426a425eb7cf84/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=a1c34493d4d733fedf2a8609d7426a425eb7cf84", "patch": "@@ -195,6 +195,9 @@ pub trait Emitter {\n \n     fn emit_future_breakage_report(&mut self, _diags: Vec<(FutureBreakage, Diagnostic)>) {}\n \n+    /// Emit list of unused externs\n+    fn emit_unused_externs(&mut self, _lint_level: &str, _unused_externs: &[&str]) {}\n+\n     /// Checks if should show explanations about \"rustc --explain\"\n     fn should_show_explain(&self) -> bool {\n         true"}, {"sha": "40277006462d2b55cebe960d4ee8a6451311b6a6", "filename": "compiler/rustc_errors/src/json.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a1c34493d4d733fedf2a8609d7426a425eb7cf84/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c34493d4d733fedf2a8609d7426a425eb7cf84/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson.rs?ref=a1c34493d4d733fedf2a8609d7426a425eb7cf84", "patch": "@@ -159,6 +159,19 @@ impl Emitter for JsonEmitter {\n         }\n     }\n \n+    fn emit_unused_externs(&mut self, lint_level: &str, unused_externs: &[&str]) {\n+        let data = UnusedExterns { lint_level, unused_extern_names: unused_externs };\n+        let result = if self.pretty {\n+            writeln!(&mut self.dst, \"{}\", as_pretty_json(&data))\n+        } else {\n+            writeln!(&mut self.dst, \"{}\", as_json(&data))\n+        }\n+        .and_then(|_| self.dst.flush());\n+        if let Err(e) = result {\n+            panic!(\"failed to print unused externs: {:?}\", e);\n+        }\n+    }\n+\n     fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n         Some(&self.sm)\n     }\n@@ -322,6 +335,18 @@ struct FutureIncompatReport {\n     future_incompat_report: Vec<FutureBreakageItem>,\n }\n \n+// NOTE: Keep this in sync with the equivalent structs in rustdoc's\n+// doctest component (as well as cargo).\n+// We could unify this struct the one in rustdoc but they have different\n+// ownership semantics, so doing so would create wasteful allocations.\n+#[derive(Encodable)]\n+struct UnusedExterns<'a, 'b, 'c> {\n+    /// The severity level of the unused dependencies lint\n+    lint_level: &'a str,\n+    /// List of unused externs by their names.\n+    unused_extern_names: &'b [&'c str],\n+}\n+\n impl Diagnostic {\n     fn from_errors_diagnostic(diag: &crate::Diagnostic, je: &JsonEmitter) -> Diagnostic {\n         let sugg = diag.suggestions.iter().map(|sugg| Diagnostic {"}, {"sha": "0d1f55a6b00eee194ff4eadb5936338ca86db0bc", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a1c34493d4d733fedf2a8609d7426a425eb7cf84/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c34493d4d733fedf2a8609d7426a425eb7cf84/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=a1c34493d4d733fedf2a8609d7426a425eb7cf84", "patch": "@@ -765,6 +765,10 @@ impl Handler {\n         self.inner.borrow_mut().emitter.emit_future_breakage_report(diags)\n     }\n \n+    pub fn emit_unused_externs(&self, lint_level: &str, unused_externs: &[&str]) {\n+        self.inner.borrow_mut().emit_unused_externs(lint_level, unused_externs)\n+    }\n+\n     pub fn delay_as_bug(&self, diagnostic: Diagnostic) {\n         self.inner.borrow_mut().delay_as_bug(diagnostic)\n     }\n@@ -839,6 +843,10 @@ impl HandlerInner {\n         self.emitter.emit_artifact_notification(path, artifact_type);\n     }\n \n+    fn emit_unused_externs(&mut self, lint_level: &str, unused_externs: &[&str]) {\n+        self.emitter.emit_unused_externs(lint_level, unused_externs);\n+    }\n+\n     fn treat_err_as_bug(&self) -> bool {\n         self.flags.treat_err_as_bug.map_or(false, |c| self.err_count() >= c.get())\n     }"}, {"sha": "02e62a2cee951d62044871a00e208ab5901a75e4", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a1c34493d4d733fedf2a8609d7426a425eb7cf84/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c34493d4d733fedf2a8609d7426a425eb7cf84/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=a1c34493d4d733fedf2a8609d7426a425eb7cf84", "patch": "@@ -16,6 +16,7 @@ use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_hir::definitions::Definitions;\n use rustc_hir::Crate;\n use rustc_lint::LintStore;\n+use rustc_metadata::creader::CStore;\n use rustc_middle::arena::Arena;\n use rustc_middle::dep_graph::DepGraph;\n use rustc_middle::middle;\n@@ -831,6 +832,12 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n                 });\n \n                 sess.time(\"looking_for_derive_registrar\", || proc_macro_decls::find(tcx));\n+\n+                let cstore = tcx\n+                    .cstore_as_any()\n+                    .downcast_ref::<CStore>()\n+                    .expect(\"`tcx.cstore` is not a `CStore`\");\n+                cstore.report_unused_deps(tcx);\n             },\n             {\n                 par_iter(&tcx.hir().krate().modules).for_each(|(&module, _)| {"}, {"sha": "26db3a5f39d7c80e8ee0aa1b2960a13c5ecfc3b9", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a1c34493d4d733fedf2a8609d7426a425eb7cf84/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c34493d4d733fedf2a8609d7426a425eb7cf84/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=a1c34493d4d733fedf2a8609d7426a425eb7cf84", "patch": "@@ -46,6 +46,9 @@ pub struct CStore {\n     /// This map is used to verify we get no hash conflicts between\n     /// `StableCrateId` values.\n     stable_crate_ids: FxHashMap<StableCrateId, CrateNum>,\n+\n+    /// Unused externs of the crate\n+    unused_externs: Vec<Symbol>,\n }\n \n pub struct CrateLoader<'a> {\n@@ -190,6 +193,27 @@ impl CStore {\n     crate fn has_global_allocator(&self) -> bool {\n         self.has_global_allocator\n     }\n+\n+    pub fn report_unused_deps(&self, tcx: TyCtxt<'_>) {\n+        // We put the check for the option before the lint_level_at_node call\n+        // because the call mutates internal state and introducing it\n+        // leads to some ui tests failing.\n+        if !tcx.sess.opts.json_unused_externs {\n+            return;\n+        }\n+        let level = tcx\n+            .lint_level_at_node(lint::builtin::UNUSED_CRATE_DEPENDENCIES, rustc_hir::CRATE_HIR_ID)\n+            .0;\n+        if level != lint::Level::Allow {\n+            let unused_externs =\n+                self.unused_externs.iter().map(|ident| ident.to_ident_string()).collect::<Vec<_>>();\n+            let unused_externs = unused_externs.iter().map(String::as_str).collect::<Vec<&str>>();\n+            tcx.sess\n+                .parse_sess\n+                .span_diagnostic\n+                .emit_unused_externs(level.as_str(), &unused_externs);\n+        }\n+    }\n }\n \n impl<'a> CrateLoader<'a> {\n@@ -217,6 +241,7 @@ impl<'a> CrateLoader<'a> {\n                 allocator_kind: None,\n                 has_global_allocator: false,\n                 stable_crate_ids,\n+                unused_externs: Vec::new(),\n             },\n             used_extern_options: Default::default(),\n         }\n@@ -904,11 +929,17 @@ impl<'a> CrateLoader<'a> {\n                 // Don't worry about pathless `--extern foo` sysroot references\n                 continue;\n             }\n-            if self.used_extern_options.contains(&Symbol::intern(name)) {\n+            let name_interned = Symbol::intern(name);\n+            if self.used_extern_options.contains(&name_interned) {\n                 continue;\n             }\n \n             // Got a real unused --extern\n+            if self.sess.opts.json_unused_externs {\n+                self.cstore.unused_externs.push(name_interned);\n+                continue;\n+            }\n+\n             let diag = match self.sess.opts.extern_dep_specs.get(name) {\n                 Some(loc) => BuiltinLintDiagnostics::ExternDepSpec(name.clone(), loc.into()),\n                 None => {\n@@ -941,9 +972,9 @@ impl<'a> CrateLoader<'a> {\n         self.inject_allocator_crate(krate);\n         self.inject_panic_runtime(krate);\n \n-        info!(\"{:?}\", CrateDump(&self.cstore));\n-\n         self.report_unused_deps(krate);\n+\n+        info!(\"{:?}\", CrateDump(&self.cstore));\n     }\n \n     pub fn process_extern_crate("}, {"sha": "c7d561f760b964c05a25d0ad598e8c9f83d5b876", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a1c34493d4d733fedf2a8609d7426a425eb7cf84/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c34493d4d733fedf2a8609d7426a425eb7cf84/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=a1c34493d4d733fedf2a8609d7426a425eb7cf84", "patch": "@@ -456,6 +456,10 @@ impl Externs {\n     pub fn iter(&self) -> BTreeMapIter<'_, String, ExternEntry> {\n         self.0.iter()\n     }\n+\n+    pub fn len(&self) -> usize {\n+        self.0.len()\n+    }\n }\n \n impl ExternEntry {\n@@ -698,6 +702,7 @@ impl Default for Options {\n             remap_path_prefix: Vec::new(),\n             edition: DEFAULT_EDITION,\n             json_artifact_notifications: false,\n+            json_unused_externs: false,\n             pretty: None,\n         }\n     }\n@@ -1196,15 +1201,23 @@ pub fn parse_color(matches: &getopts::Matches) -> ColorConfig {\n     }\n }\n \n+/// Possible json config files\n+pub struct JsonConfig {\n+    pub json_rendered: HumanReadableErrorType,\n+    pub json_artifact_notifications: bool,\n+    pub json_unused_externs: bool,\n+}\n+\n /// Parse the `--json` flag.\n ///\n /// The first value returned is how to render JSON diagnostics, and the second\n /// is whether or not artifact notifications are enabled.\n-pub fn parse_json(matches: &getopts::Matches) -> (HumanReadableErrorType, bool) {\n+pub fn parse_json(matches: &getopts::Matches) -> JsonConfig {\n     let mut json_rendered: fn(ColorConfig) -> HumanReadableErrorType =\n         HumanReadableErrorType::Default;\n     let mut json_color = ColorConfig::Never;\n     let mut json_artifact_notifications = false;\n+    let mut json_unused_externs = false;\n     for option in matches.opt_strs(\"json\") {\n         // For now conservatively forbid `--color` with `--json` since `--json`\n         // won't actually be emitting any colors and anything colorized is\n@@ -1221,14 +1234,20 @@ pub fn parse_json(matches: &getopts::Matches) -> (HumanReadableErrorType, bool)\n                 \"diagnostic-short\" => json_rendered = HumanReadableErrorType::Short,\n                 \"diagnostic-rendered-ansi\" => json_color = ColorConfig::Always,\n                 \"artifacts\" => json_artifact_notifications = true,\n+                \"unused-externs\" => json_unused_externs = true,\n                 s => early_error(\n                     ErrorOutputType::default(),\n                     &format!(\"unknown `--json` option `{}`\", s),\n                 ),\n             }\n         }\n     }\n-    (json_rendered(json_color), json_artifact_notifications)\n+\n+    JsonConfig {\n+        json_rendered: json_rendered(json_color),\n+        json_artifact_notifications,\n+        json_unused_externs,\n+    }\n }\n \n /// Parses the `--error-format` flag.\n@@ -1806,7 +1825,8 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let edition = parse_crate_edition(matches);\n \n-    let (json_rendered, json_artifact_notifications) = parse_json(matches);\n+    let JsonConfig { json_rendered, json_artifact_notifications, json_unused_externs } =\n+        parse_json(matches);\n \n     let error_format = parse_error_format(matches, color, json_rendered);\n \n@@ -1819,6 +1839,14 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     let mut debugging_opts = build_debugging_options(matches, error_format);\n     check_debug_option_stability(&debugging_opts, error_format, json_rendered);\n \n+    if !debugging_opts.unstable_options && json_unused_externs {\n+        early_error(\n+            error_format,\n+            \"the `-Z unstable-options` flag must also be passed to enable \\\n+            the flag `--json=unused-externs`\",\n+        );\n+    }\n+\n     let output_types = parse_output_types(&debugging_opts, matches, error_format);\n \n     let mut cg = build_codegen_options(matches, error_format);\n@@ -1979,6 +2007,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         remap_path_prefix,\n         edition,\n         json_artifact_notifications,\n+        json_unused_externs,\n         pretty,\n     }\n }"}, {"sha": "dd35cb97275bcac27a48937dc32ffb0708c21a7b", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a1c34493d4d733fedf2a8609d7426a425eb7cf84/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c34493d4d733fedf2a8609d7426a425eb7cf84/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=a1c34493d4d733fedf2a8609d7426a425eb7cf84", "patch": "@@ -147,6 +147,9 @@ top_level_options!(\n         // by the compiler.\n         json_artifact_notifications: bool [TRACKED],\n \n+        // `true` if we're emitting a JSON blob containing the unused externs\n+        json_unused_externs: bool [UNTRACKED],\n+\n         pretty: Option<PpMode> [UNTRACKED],\n     }\n );"}, {"sha": "0b9fb46fc55691876178ef0d05c1725370f05a93", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a1c34493d4d733fedf2a8609d7426a425eb7cf84/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c34493d4d733fedf2a8609d7426a425eb7cf84/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=a1c34493d4d733fedf2a8609d7426a425eb7cf84", "patch": "@@ -154,6 +154,8 @@ crate struct Options {\n     /// If this option is set to `true`, rustdoc will only run checks and not generate\n     /// documentation.\n     crate run_check: bool,\n+    /// Whether doctests should emit unused externs\n+    crate json_unused_externs: bool,\n }\n \n impl fmt::Debug for Options {\n@@ -352,7 +354,8 @@ impl Options {\n         }\n \n         let color = config::parse_color(&matches);\n-        let (json_rendered, _artifacts) = config::parse_json(&matches);\n+        let config::JsonConfig { json_rendered, json_unused_externs, .. } =\n+            config::parse_json(&matches);\n         let error_format = config::parse_error_format(&matches, color, json_rendered);\n \n         let codegen_options = build_codegen_options(matches, error_format);\n@@ -687,6 +690,7 @@ impl Options {\n             },\n             crate_name,\n             output_format,\n+            json_unused_externs,\n         })\n     }\n "}, {"sha": "6f6ed0eb68413c8d9a2de99ad4b1d9017c3d166d", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 101, "deletions": 6, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/a1c34493d4d733fedf2a8609d7426a425eb7cf84/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c34493d4d733fedf2a8609d7426a425eb7cf84/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=a1c34493d4d733fedf2a8609d7426a425eb7cf84", "patch": "@@ -1,5 +1,5 @@\n use rustc_ast as ast;\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{ColorConfig, ErrorReported};\n use rustc_hir as hir;\n@@ -23,6 +23,8 @@ use std::panic;\n use std::path::PathBuf;\n use std::process::{self, Command, Stdio};\n use std::str;\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+use std::sync::{Arc, Mutex};\n \n use crate::clean::Attributes;\n use crate::config::Options;\n@@ -104,8 +106,10 @@ crate fn run(options: Options) -> Result<(), ErrorReported> {\n \n     let mut test_args = options.test_args.clone();\n     let display_warnings = options.display_warnings;\n+    let externs = options.externs.clone();\n+    let json_unused_externs = options.json_unused_externs;\n \n-    let tests = interface::run_compiler(config, |compiler| {\n+    let res = interface::run_compiler(config, |compiler| {\n         compiler.enter(|queries| {\n             let _lower_to_hir = queries.lower_to_hir()?;\n \n@@ -151,12 +155,15 @@ crate fn run(options: Options) -> Result<(), ErrorReported> {\n             });\n             compiler.session().abort_if_errors();\n \n-            let ret: Result<_, ErrorReported> = Ok(collector.tests);\n+            let unused_extern_reports = collector.unused_extern_reports.clone();\n+            let compiling_test_count = collector.compiling_test_count.load(Ordering::SeqCst);\n+            let ret: Result<_, ErrorReported> =\n+                Ok((collector.tests, unused_extern_reports, compiling_test_count));\n             ret\n         })\n     });\n-    let tests = match tests {\n-        Ok(tests) => tests,\n+    let (tests, unused_extern_reports, compiling_test_count) = match res {\n+        Ok(res) => res,\n         Err(ErrorReported) => return Err(ErrorReported),\n     };\n \n@@ -168,6 +175,44 @@ crate fn run(options: Options) -> Result<(), ErrorReported> {\n         Some(testing::Options::new().display_output(display_warnings)),\n     );\n \n+    // Collect and warn about unused externs, but only if we've gotten\n+    // reports for each doctest\n+    if json_unused_externs {\n+        let unused_extern_reports: Vec<_> =\n+            std::mem::take(&mut unused_extern_reports.lock().unwrap());\n+        if unused_extern_reports.len() == compiling_test_count {\n+            let extern_names = externs.iter().map(|(name, _)| name).collect::<FxHashSet<&String>>();\n+            let mut unused_extern_names = unused_extern_reports\n+                .iter()\n+                .map(|uexts| uexts.unused_extern_names.iter().collect::<FxHashSet<&String>>())\n+                .fold(extern_names, |uextsa, uextsb| {\n+                    uextsa.intersection(&uextsb).map(|v| *v).collect::<FxHashSet<&String>>()\n+                })\n+                .iter()\n+                .map(|v| (*v).clone())\n+                .collect::<Vec<String>>();\n+            unused_extern_names.sort();\n+            // Take the most severe lint level\n+            let lint_level = unused_extern_reports\n+                .iter()\n+                .map(|uexts| uexts.lint_level.as_str())\n+                .max_by_key(|v| match *v {\n+                    \"warn\" => 1,\n+                    \"deny\" => 2,\n+                    \"forbid\" => 3,\n+                    // The allow lint level is not expected,\n+                    // as if allow is specified, no message\n+                    // is to be emitted.\n+                    v => unreachable!(\"Invalid lint level '{}'\", v),\n+                })\n+                .unwrap_or(\"warn\")\n+                .to_string();\n+            let uext = UnusedExterns { lint_level, unused_extern_names };\n+            let unused_extern_json = serde_json::to_string(&uext).unwrap();\n+            eprintln!(\"{}\", unused_extern_json);\n+        }\n+    }\n+\n     Ok(())\n }\n \n@@ -235,6 +280,18 @@ impl DirState {\n     }\n }\n \n+// NOTE: Keep this in sync with the equivalent structs in rustc\n+// and cargo.\n+// We could unify this struct the one in rustc but they have different\n+// ownership semantics, so doing so would create wasteful allocations.\n+#[derive(serde::Serialize, serde::Deserialize)]\n+struct UnusedExterns {\n+    /// Lint level of the unused_crate_dependencies lint\n+    lint_level: String,\n+    /// List of unused externs by their names.\n+    unused_extern_names: Vec<String>,\n+}\n+\n fn run_test(\n     test: &str,\n     cratename: &str,\n@@ -253,6 +310,7 @@ fn run_test(\n     outdir: DirState,\n     path: PathBuf,\n     test_id: &str,\n+    report_unused_externs: impl Fn(UnusedExterns),\n ) -> Result<(), TestFailure> {\n     let (test, line_offset, supports_color) =\n         make_test(test, Some(cratename), as_test_harness, opts, edition, Some(test_id));\n@@ -278,6 +336,12 @@ fn run_test(\n     if as_test_harness {\n         compiler.arg(\"--test\");\n     }\n+    if options.json_unused_externs && !compile_fail {\n+        compiler.arg(\"--error-format=json\");\n+        compiler.arg(\"--json\").arg(\"unused-externs\");\n+        compiler.arg(\"-Z\").arg(\"unstable-options\");\n+        compiler.arg(\"-W\").arg(\"unused_crate_dependencies\");\n+    }\n     for lib_str in &options.lib_strs {\n         compiler.arg(\"-L\").arg(&lib_str);\n     }\n@@ -337,7 +401,26 @@ fn run_test(\n             eprint!(\"{}\", self.0);\n         }\n     }\n-    let out = str::from_utf8(&output.stderr).unwrap();\n+    let mut out_lines = str::from_utf8(&output.stderr)\n+        .unwrap()\n+        .lines()\n+        .filter(|l| {\n+            if let Ok(uext) = serde_json::from_str::<UnusedExterns>(l) {\n+                report_unused_externs(uext);\n+                false\n+            } else {\n+                true\n+            }\n+        })\n+        .collect::<Vec<_>>();\n+\n+    // Add a \\n to the end to properly terminate the last line,\n+    // but only if there was output to be printed\n+    if out_lines.len() > 0 {\n+        out_lines.push(\"\");\n+    }\n+\n+    let out = out_lines.join(\"\\n\");\n     let _bomb = Bomb(&out);\n     match (output.status.success(), compile_fail) {\n         (true, true) => {\n@@ -721,6 +804,8 @@ crate struct Collector {\n     source_map: Option<Lrc<SourceMap>>,\n     filename: Option<PathBuf>,\n     visited_tests: FxHashMap<(String, usize), usize>,\n+    unused_extern_reports: Arc<Mutex<Vec<UnusedExterns>>>,\n+    compiling_test_count: AtomicUsize,\n }\n \n impl Collector {\n@@ -745,6 +830,8 @@ impl Collector {\n             source_map,\n             filename,\n             visited_tests: FxHashMap::default(),\n+            unused_extern_reports: Default::default(),\n+            compiling_test_count: AtomicUsize::new(0),\n         }\n     }\n \n@@ -791,6 +878,10 @@ impl Tester for Collector {\n         let runtool_args = self.options.runtool_args.clone();\n         let target = self.options.target.clone();\n         let target_str = target.to_string();\n+        let unused_externs = self.unused_extern_reports.clone();\n+        if !config.compile_fail {\n+            self.compiling_test_count.fetch_add(1, Ordering::SeqCst);\n+        }\n \n         // FIXME(#44940): if doctests ever support path remapping, then this filename\n         // needs to be the result of `SourceMap::span_to_unmapped_path`.\n@@ -846,6 +937,9 @@ impl Tester for Collector {\n                 test_type: testing::TestType::DocTest,\n             },\n             testfn: testing::DynTestFn(box move || {\n+                let report_unused_externs = |uext| {\n+                    unused_externs.lock().unwrap().push(uext);\n+                };\n                 let res = run_test(\n                     &test,\n                     &cratename,\n@@ -864,6 +958,7 @@ impl Tester for Collector {\n                     outdir,\n                     path,\n                     &test_id,\n+                    report_unused_externs,\n                 );\n \n                 if let Err(err) = res {"}]}