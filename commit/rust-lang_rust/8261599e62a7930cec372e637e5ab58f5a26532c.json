{"sha": "8261599e62a7930cec372e637e5ab58f5a26532c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyNjE1OTllNjJhNzkzMGNlYzM3MmU2MzdlNWFiNThmNWEyNjUzMmM=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-06-30T20:58:48Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-07-01T20:56:55Z"}, "message": "Refactoring", "tree": {"sha": "4d1f3e4ab398a5ddd4892ea2e30db714e1709579", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d1f3e4ab398a5ddd4892ea2e30db714e1709579"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8261599e62a7930cec372e637e5ab58f5a26532c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8261599e62a7930cec372e637e5ab58f5a26532c", "html_url": "https://github.com/rust-lang/rust/commit/8261599e62a7930cec372e637e5ab58f5a26532c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8261599e62a7930cec372e637e5ab58f5a26532c/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15dcb5bfc51753aad5527888ec5a1c9381e8d1e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/15dcb5bfc51753aad5527888ec5a1c9381e8d1e1", "html_url": "https://github.com/rust-lang/rust/commit/15dcb5bfc51753aad5527888ec5a1c9381e8d1e1"}], "stats": {"total": 137, "additions": 70, "deletions": 67}, "files": [{"sha": "3205141e604c2769d9b4721822d8fb21f4ffbfc2", "filename": "src/librustc/ast_map/mod.rs", "status": "modified", "additions": 70, "deletions": 67, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/8261599e62a7930cec372e637e5ab58f5a26532c/src%2Flibrustc%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8261599e62a7930cec372e637e5ab58f5a26532c/src%2Flibrustc%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fast_map%2Fmod.rs?ref=8261599e62a7930cec372e637e5ab58f5a26532c", "patch": "@@ -121,15 +121,14 @@ pub enum Node<'ast> {\n     NodeLifetime(&'ast Lifetime),\n }\n \n-/// Represents an entry and its parent NodeID and parent_node NodeID, see\n-/// get_parent_node for the distinction.\n+/// Represents an entry and its parent NodeID.\n /// The odd layout is to bring down the total size.\n #[derive(Copy, Debug)]\n enum MapEntry<'ast> {\n     /// Placeholder for holes in the map.\n     NotPresent,\n \n-    /// All the node types, with a parent and scope ID.\n+    /// All the node types, with a parent ID.\n     EntryItem(NodeId, &'ast Item),\n     EntryForeignItem(NodeId, &'ast ForeignItem),\n     EntryTraitItem(NodeId, &'ast TraitItem),\n@@ -162,21 +161,21 @@ struct InlinedParent {\n }\n \n impl<'ast> MapEntry<'ast> {\n-    fn from_node(s: NodeId, node: Node<'ast>) -> MapEntry<'ast> {\n+    fn from_node(p: NodeId, node: Node<'ast>) -> MapEntry<'ast> {\n         match node {\n-            NodeItem(n) => EntryItem(s, n),\n-            NodeForeignItem(n) => EntryForeignItem(s, n),\n-            NodeTraitItem(n) => EntryTraitItem(s, n),\n-            NodeImplItem(n) => EntryImplItem(s, n),\n-            NodeVariant(n) => EntryVariant(s, n),\n-            NodeExpr(n) => EntryExpr(s, n),\n-            NodeStmt(n) => EntryStmt(s, n),\n-            NodeArg(n) => EntryArg(s, n),\n-            NodeLocal(n) => EntryLocal(s, n),\n-            NodePat(n) => EntryPat(s, n),\n-            NodeBlock(n) => EntryBlock(s, n),\n-            NodeStructCtor(n) => EntryStructCtor(s, n),\n-            NodeLifetime(n) => EntryLifetime(s, n)\n+            NodeItem(n) => EntryItem(p, n),\n+            NodeForeignItem(n) => EntryForeignItem(p, n),\n+            NodeTraitItem(n) => EntryTraitItem(p, n),\n+            NodeImplItem(n) => EntryImplItem(p, n),\n+            NodeVariant(n) => EntryVariant(p, n),\n+            NodeExpr(n) => EntryExpr(p, n),\n+            NodeStmt(n) => EntryStmt(p, n),\n+            NodeArg(n) => EntryArg(p, n),\n+            NodeLocal(n) => EntryLocal(p, n),\n+            NodePat(n) => EntryPat(p, n),\n+            NodeBlock(n) => EntryBlock(p, n),\n+            NodeStructCtor(n) => EntryStructCtor(p, n),\n+            NodeLifetime(n) => EntryLifetime(p, n)\n         }\n     }\n \n@@ -284,83 +283,87 @@ impl<'ast> Map<'ast> {\n         self.find_entry(id).and_then(|x| x.to_node())\n     }\n \n-    /// Retrieve the parent NodeId for `id`, or `id` itself if no\n-    /// parent is registered in this map.\n-    pub fn get_parent(&self, id: NodeId) -> NodeId {\n-        let mut id = id;\n+    /// Similar to get_parent, returns the parent node id or id if there is no\n+    /// parent.\n+    /// This function returns the immediate parent in the AST, whereas get_parent\n+    /// returns the enclosing item. Note that this might not be the actual parent\n+    /// node in the AST - some kinds of nodes are not in the map and these will\n+    /// never appear as the parent_node. So you can always walk the parent_nodes\n+    /// from a node to the root of the ast (unless you get the same id back here\n+    /// that can happen if the id is not in the map itself or is just weird).\n+    pub fn get_parent_node(&self, id: NodeId) -> NodeId {\n+        self.find_entry(id).and_then(|x| x.parent_node()).unwrap_or(id)\n+    }\n+\n+    /// If there is some error when walking the parents (e.g., a node does not\n+    /// have a parent in the map or a node can't be found), then we return the\n+    /// last good node id we found. Note that reaching the crate root (id == 0),\n+    /// is not an error, since items in the crate module have the crate root as\n+    /// parent.\n+    fn walk_parent_nodes<F>(&self, start_id: NodeId, found: F) -> Result<NodeId, NodeId>\n+        where F: Fn(&Node<'ast>) -> bool\n+    {\n+        let mut id = start_id;\n         loop {\n             let parent_node = self.get_parent_node(id);\n             if parent_node == 0 {\n-                return parent_node;\n+                return Ok(0);\n             }\n             if parent_node == id {\n-                return id;\n+                return Err(id);\n             }\n \n             let node = self.find_entry(parent_node);\n             if node.is_none() {\n-                return id;\n+                return Err(id);\n             }\n             let node = node.unwrap().to_node();\n             match node {\n-                Some(node) => match node {\n-                    NodeItem(_) |\n-                    NodeForeignItem(_) |\n-                    NodeTraitItem(_) |\n-                    NodeImplItem(_) => {\n-                        return parent_node;\n+                Some(ref node) => {\n+                    if found(node) {\n+                        return Ok(parent_node);\n                     }\n-                    _ => {}\n-                },\n+                }\n                 None => {\n-                    return parent_node;\n+                    return Err(parent_node);\n                 }\n             }\n             id = parent_node;\n         }\n     }\n \n-    /// Similar to get_parent, returns the parent node id or id if there is no\n-    /// parent.\n-    /// This function returns the most direct parent in the AST, whereas get_parent\n-    /// returns the enclosing item. Note that this might not be the actual parent\n-    /// node in the AST - some kinds of nodes are not in the map and these will\n-    /// never appear as the parent_node. So you can always walk the parent_nodes\n-    /// from a node to the root of the ast (unless you get the same id back here\n-    /// that can happen if the id is not in the map itself or is just weird).\n-    pub fn get_parent_node(&self, id: NodeId) -> NodeId {\n-        self.find_entry(id).and_then(|x| x.parent_node()).unwrap_or(id)\n+    /// Retrieve the NodeId for `id`'s parent item, or `id` itself if no\n+    /// parent item is in this map. The \"parent item\" is the closest parent node\n+    /// in the AST which is recorded by the map and is an item, either an item\n+    /// in a module, trait, or impl.\n+    pub fn get_parent(&self, id: NodeId) -> NodeId {\n+        match self.walk_parent_nodes(id, |node| match *node {\n+            NodeItem(_) |\n+            NodeForeignItem(_) |\n+            NodeTraitItem(_) |\n+            NodeImplItem(_) => true,\n+            _ => false,\n+        }) {\n+            Ok(id) => id,\n+            Err(id) => id,\n+        }\n     }\n \n     /// Returns the nearest enclosing scope. A scope is an item or block.\n     /// FIXME it is not clear to me that all items qualify as scopes - statics\n     /// and associated types probably shouldn't, for example. Behaviour in this\n     /// regard should be expected to be highly unstable.\n     pub fn get_enclosing_scope(&self, id: NodeId) -> Option<NodeId> {\n-        let mut last_id = id;\n-        // Walk up the chain of parents until we find a 'scope'.\n-        loop {\n-            let cur_id = self.get_parent_node(last_id);\n-            if cur_id == last_id {\n-                return None;\n-            }\n-\n-            if cur_id == 0 {\n-                return Some(0);\n-            }\n-\n-            match self.get(cur_id) {\n-                NodeItem(_) |\n-                NodeForeignItem(_) |\n-                NodeTraitItem(_) |\n-                NodeImplItem(_) |\n-                NodeBlock(_) => {\n-                    return Some(cur_id);\n-                }\n-                _ => {}\n-            }\n-\n-            last_id = cur_id;\n+        match self.walk_parent_nodes(id, |node| match *node {\n+            NodeItem(_) |\n+            NodeForeignItem(_) |\n+            NodeTraitItem(_) |\n+            NodeImplItem(_) |\n+            NodeBlock(_) => true,\n+            _ => false,\n+        }) {\n+            Ok(id) => Some(id),\n+            Err(_) => None,\n         }\n     }\n "}]}