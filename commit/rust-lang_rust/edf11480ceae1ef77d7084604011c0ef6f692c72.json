{"sha": "edf11480ceae1ef77d7084604011c0ef6f692c72", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkZjExNDgwY2VhZTFlZjc3ZDcwODQ2MDQwMTFjMGVmNmY2OTJjNzI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-17T16:00:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-17T16:00:43Z"}, "message": "Merge #8065\n\n8065: Better handling of block doc comments r=Veykril a=Veykril\n\nMoves doc string processing to `Attrs::docs`, as we need the indent info from all comments before being able to know how much to strip\r\n\r\nCloses #7774\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "6d1da24b8e275d8e36a12a48e1cdc9de0f8e1ec4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d1da24b8e275d8e36a12a48e1cdc9de0f8e1ec4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edf11480ceae1ef77d7084604011c0ef6f692c72", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgUierCRBK7hj4Ov3rIwAAdHIIAA8Gq9KuLDXoTb0FI0EsHgRC\n4K657uSGMei89qqqS7dLAsuHuEEQqKHlniR5qivkwbVgJ/LRukSMvtZZbM8mzbxe\nDPUwJ/OM2I7e7FLRHHzORjo1bnqj2XBRoUaANDrHKIG7ppMKPeHJr1ek6zmkQ9Pb\nPykzJWIw/2kiNEWgX/wRVsXT+FuqhFVK9bCIaYvtoLmIb3tTKY2nTn3T9ynulvVC\nL76jndEgfSvN8/QKnVgVSTVUN62IoPw8rC91RRIiRvezHRtP3miUEbrboF9B/ygc\ndlRlrMeAfdZHgHnrui7yp4HHihXhSLpAyHH/9b8LgP64FdJvrj6LikdrD4O52qU=\n=ACJO\n-----END PGP SIGNATURE-----\n", "payload": "tree 6d1da24b8e275d8e36a12a48e1cdc9de0f8e1ec4\nparent baa19991688c6bdd99b63b8dc6f539be44da0350\nparent 5734b347ddfff0d285d3eecf5735cac30271696c\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1615996843 +0000\ncommitter GitHub <noreply@github.com> 1615996843 +0000\n\nMerge #8065\n\n8065: Better handling of block doc comments r=Veykril a=Veykril\n\nMoves doc string processing to `Attrs::docs`, as we need the indent info from all comments before being able to know how much to strip\r\n\r\nCloses #7774\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edf11480ceae1ef77d7084604011c0ef6f692c72", "html_url": "https://github.com/rust-lang/rust/commit/edf11480ceae1ef77d7084604011c0ef6f692c72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edf11480ceae1ef77d7084604011c0ef6f692c72/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "baa19991688c6bdd99b63b8dc6f539be44da0350", "url": "https://api.github.com/repos/rust-lang/rust/commits/baa19991688c6bdd99b63b8dc6f539be44da0350", "html_url": "https://github.com/rust-lang/rust/commit/baa19991688c6bdd99b63b8dc6f539be44da0350"}, {"sha": "5734b347ddfff0d285d3eecf5735cac30271696c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5734b347ddfff0d285d3eecf5735cac30271696c", "html_url": "https://github.com/rust-lang/rust/commit/5734b347ddfff0d285d3eecf5735cac30271696c"}], "stats": {"total": 375, "additions": 235, "deletions": 140}, "files": [{"sha": "b7353d868b22668f0ce987bfe3f2ced91a188541", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 56, "deletions": 49, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/edf11480ceae1ef77d7084604011c0ef6f692c72/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edf11480ceae1ef77d7084604011c0ef6f692c72/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=edf11480ceae1ef77d7084604011c0ef6f692c72", "patch": "@@ -76,37 +76,23 @@ impl ops::Deref for Attrs {\n impl RawAttrs {\n     pub(crate) const EMPTY: Self = Self { entries: None };\n \n-    pub(crate) fn new(owner: &dyn AttrsOwner, hygiene: &Hygiene) -> Self {\n-        let attrs: Vec<_> = collect_attrs(owner).collect();\n-        let entries = if attrs.is_empty() {\n-            // Avoid heap allocation\n-            None\n-        } else {\n-            Some(\n-                attrs\n-                    .into_iter()\n-                    .enumerate()\n-                    .flat_map(|(i, attr)| match attr {\n-                        Either::Left(attr) => Attr::from_src(attr, hygiene).map(|attr| (i, attr)),\n-                        Either::Right(comment) => comment.doc_comment().map(|doc| {\n-                            (\n-                                i,\n-                                Attr {\n-                                    index: 0,\n-                                    input: Some(AttrInput::Literal(SmolStr::new(doc))),\n-                                    path: ModPath::from(hir_expand::name!(doc)),\n-                                },\n-                            )\n-                        }),\n-                    })\n-                    .map(|(i, attr)| Attr { index: i as u32, ..attr })\n-                    .collect(),\n-            )\n-        };\n-        Self { entries }\n+    pub(crate) fn new(owner: &dyn ast::AttrsOwner, hygiene: &Hygiene) -> Self {\n+        let entries = collect_attrs(owner)\n+            .enumerate()\n+            .flat_map(|(i, attr)| match attr {\n+                Either::Left(attr) => Attr::from_src(attr, hygiene, i as u32),\n+                Either::Right(comment) => comment.doc_comment().map(|doc| Attr {\n+                    index: i as u32,\n+                    input: Some(AttrInput::Literal(SmolStr::new(doc))),\n+                    path: ModPath::from(hir_expand::name!(doc)),\n+                }),\n+            })\n+            .collect::<Arc<_>>();\n+\n+        Self { entries: if entries.is_empty() { None } else { Some(entries) } }\n     }\n \n-    fn from_attrs_owner(db: &dyn DefDatabase, owner: InFile<&dyn AttrsOwner>) -> Self {\n+    fn from_attrs_owner(db: &dyn DefDatabase, owner: InFile<&dyn ast::AttrsOwner>) -> Self {\n         let hygiene = Hygiene::new(db.upcast(), owner.file_id);\n         Self::new(owner.value, &hygiene)\n     }\n@@ -162,7 +148,7 @@ impl RawAttrs {\n                     let attr = ast::Attr::parse(&format!(\"#[{}]\", tree)).ok()?;\n                     // FIXME hygiene\n                     let hygiene = Hygiene::new_unhygienic();\n-                    Attr::from_src(attr, &hygiene).map(|attr| Attr { index, ..attr })\n+                    Attr::from_src(attr, &hygiene, index)\n                 });\n \n                 let cfg_options = &crate_graph[krate].cfg_options;\n@@ -192,7 +178,7 @@ impl Attrs {\n                     Some(it) => {\n                         let raw_attrs = RawAttrs::from_attrs_owner(\n                             db,\n-                            it.as_ref().map(|it| it as &dyn AttrsOwner),\n+                            it.as_ref().map(|it| it as &dyn ast::AttrsOwner),\n                         );\n                         match mod_data.definition_source(db) {\n                             InFile { file_id, value: ModuleSource::SourceFile(file) } => raw_attrs\n@@ -203,9 +189,9 @@ impl Attrs {\n                     None => RawAttrs::from_attrs_owner(\n                         db,\n                         mod_data.definition_source(db).as_ref().map(|src| match src {\n-                            ModuleSource::SourceFile(file) => file as &dyn AttrsOwner,\n-                            ModuleSource::Module(module) => module as &dyn AttrsOwner,\n-                            ModuleSource::BlockExpr(block) => block as &dyn AttrsOwner,\n+                            ModuleSource::SourceFile(file) => file as &dyn ast::AttrsOwner,\n+                            ModuleSource::Module(module) => module as &dyn ast::AttrsOwner,\n+                            ModuleSource::BlockExpr(block) => block as &dyn ast::AttrsOwner,\n                         }),\n                     ),\n                 }\n@@ -263,7 +249,7 @@ impl Attrs {\n         let mut res = ArenaMap::default();\n \n         for (id, var) in src.value.iter() {\n-            let attrs = RawAttrs::from_attrs_owner(db, src.with_value(var as &dyn AttrsOwner))\n+            let attrs = RawAttrs::from_attrs_owner(db, src.with_value(var as &dyn ast::AttrsOwner))\n                 .filter(db, krate);\n \n             res.insert(id, attrs)\n@@ -297,7 +283,7 @@ impl Attrs {\n     /// Constructs a map that maps the lowered `Attr`s in this `Attrs` back to its original syntax nodes.\n     ///\n     /// `owner` must be the original owner of the attributes.\n-    pub fn source_map(&self, owner: &dyn AttrsOwner) -> AttrSourceMap {\n+    pub fn source_map(&self, owner: &dyn ast::AttrsOwner) -> AttrSourceMap {\n         AttrSourceMap { attrs: collect_attrs(owner).collect() }\n     }\n \n@@ -325,15 +311,34 @@ impl Attrs {\n             AttrInput::Literal(s) => Some(s),\n             AttrInput::TokenTree(_) => None,\n         });\n-        // FIXME: Replace `Itertools::intersperse` with `Iterator::intersperse[_with]` until the\n-        // libstd api gets stabilized (https://github.com/rust-lang/rust/issues/79524).\n-        let docs = Itertools::intersperse(docs, &SmolStr::new_inline(\"\\n\"))\n-            .map(|it| it.as_str())\n-            .collect::<String>();\n-        if docs.is_empty() {\n+        let indent = docs\n+            .clone()\n+            .flat_map(|s| s.lines())\n+            .filter(|line| !line.chars().all(|c| c.is_whitespace()))\n+            .map(|line| line.chars().take_while(|c| c.is_whitespace()).count())\n+            .min()\n+            .unwrap_or(0);\n+        let mut buf = String::new();\n+        for doc in docs {\n+            // str::lines doesn't yield anything for the empty string\n+            if !doc.is_empty() {\n+                buf.extend(Itertools::intersperse(\n+                    doc.lines().map(|line| {\n+                        line.char_indices()\n+                            .nth(indent)\n+                            .map_or(line, |(offset, _)| &line[offset..])\n+                            .trim_end()\n+                    }),\n+                    \"\\n\",\n+                ));\n+            }\n+            buf.push('\\n');\n+        }\n+        buf.pop();\n+        if buf.is_empty() {\n             None\n         } else {\n-            Some(Documentation(docs))\n+            Some(Documentation(buf))\n         }\n     }\n }\n@@ -407,7 +412,7 @@ pub enum AttrInput {\n }\n \n impl Attr {\n-    fn from_src(ast: ast::Attr, hygiene: &Hygiene) -> Option<Attr> {\n+    fn from_src(ast: ast::Attr, hygiene: &Hygiene, index: u32) -> Option<Attr> {\n         let path = ModPath::from_src(ast.path()?, hygiene)?;\n         let input = if let Some(lit) = ast.literal() {\n             let value = match lit.kind() {\n@@ -420,7 +425,7 @@ impl Attr {\n         } else {\n             None\n         };\n-        Some(Attr { index: 0, path, input })\n+        Some(Attr { index, path, input })\n     }\n \n     /// Maps this lowered `Attr` back to its original syntax node.\n@@ -429,7 +434,7 @@ impl Attr {\n     ///\n     /// Note that the returned syntax node might be a `#[cfg_attr]`, or a doc comment, instead of\n     /// the attribute represented by `Attr`.\n-    pub fn to_src(&self, owner: &dyn AttrsOwner) -> Either<ast::Attr, ast::Comment> {\n+    pub fn to_src(&self, owner: &dyn ast::AttrsOwner) -> Either<ast::Attr, ast::Comment> {\n         collect_attrs(owner).nth(self.index as usize).unwrap_or_else(|| {\n             panic!(\"cannot find `Attr` at index {} in {}\", self.index, owner.syntax())\n         })\n@@ -508,7 +513,7 @@ impl<'a> AttrQuery<'a> {\n         self.attrs().next().is_some()\n     }\n \n-    pub fn attrs(self) -> impl Iterator<Item = &'a Attr> {\n+    pub fn attrs(self) -> impl Iterator<Item = &'a Attr> + Clone {\n         let key = self.key;\n         self.attrs\n             .iter()\n@@ -521,7 +526,7 @@ where\n     N: ast::AttrsOwner,\n {\n     let src = InFile::new(src.file_id, src.to_node(db.upcast()));\n-    RawAttrs::from_attrs_owner(db, src.as_ref().map(|it| it as &dyn AttrsOwner))\n+    RawAttrs::from_attrs_owner(db, src.as_ref().map(|it| it as &dyn ast::AttrsOwner))\n }\n \n fn attrs_from_item_tree<N: ItemTreeNode>(id: ItemTreeId<N>, db: &dyn DefDatabase) -> RawAttrs {\n@@ -530,7 +535,9 @@ fn attrs_from_item_tree<N: ItemTreeNode>(id: ItemTreeId<N>, db: &dyn DefDatabase\n     tree.raw_attrs(mod_item.into()).clone()\n }\n \n-fn collect_attrs(owner: &dyn AttrsOwner) -> impl Iterator<Item = Either<ast::Attr, ast::Comment>> {\n+fn collect_attrs(\n+    owner: &dyn ast::AttrsOwner,\n+) -> impl Iterator<Item = Either<ast::Attr, ast::Comment>> {\n     let (inner_attrs, inner_docs) = inner_attributes(owner.syntax())\n         .map_or((None, None), |(attrs, docs)| ((Some(attrs), Some(docs))));\n "}, {"sha": "5072ecea025d76790894bc08e78389850f67a16c", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/edf11480ceae1ef77d7084604011c0ef6f692c72/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edf11480ceae1ef77d7084604011c0ef6f692c72/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=edf11480ceae1ef77d7084604011c0ef6f692c72", "patch": "@@ -95,12 +95,10 @@ fn extract_positioned_link_from_comment(\n     let comment_range = comment.syntax().text_range();\n     let doc_comment = comment.doc_comment()?;\n     let def_links = extract_definitions_from_markdown(doc_comment);\n+    let start = comment_range.start() + TextSize::from(comment.prefix().len() as u32);\n     let (def_link, ns, _) = def_links.iter().min_by_key(|(_, _, def_link_range)| {\n-        let matched_position = comment_range.start() + TextSize::from(def_link_range.start as u32);\n-        match position.offset.checked_sub(matched_position) {\n-            Some(distance) => distance,\n-            None => comment_range.end(),\n-        }\n+        let matched_position = start + TextSize::from(def_link_range.start as u32);\n+        position.offset.checked_sub(matched_position).unwrap_or_else(|| comment_range.end())\n     })?;\n     Some((def_link.to_string(), *ns))\n }"}, {"sha": "15d309d7d61146971bef759951d9085746f7466a", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 56, "deletions": 4, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/edf11480ceae1ef77d7084604011c0ef6f692c72/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edf11480ceae1ef77d7084604011c0ef6f692c72/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=edf11480ceae1ef77d7084604011c0ef6f692c72", "patch": "@@ -1533,12 +1533,21 @@ fn my() {}\n     fn test_hover_struct_doc_comment() {\n         check(\n             r#\"\n-/// bar docs\n+/// This is an example\n+/// multiline doc\n+///\n+/// # Example\n+///\n+/// ```\n+/// let five = 5;\n+///\n+/// assert_eq!(6, my_crate::add_one(5));\n+/// ```\n struct Bar;\n \n fn foo() { let bar = Ba$0r; }\n \"#,\n-            expect![[r#\"\n+            expect![[r##\"\n                 *Bar*\n \n                 ```rust\n@@ -1551,8 +1560,17 @@ fn foo() { let bar = Ba$0r; }\n \n                 ---\n \n-                bar docs\n-            \"#]],\n+                This is an example\n+                multiline doc\n+\n+                # Example\n+\n+                ```\n+                let five = 5;\n+\n+                assert_eq!(6, my_crate::add_one(5));\n+                ```\n+            \"##]],\n         );\n     }\n \n@@ -3423,6 +3441,40 @@ mod Foo$0 {\n         );\n     }\n \n+    #[test]\n+    fn hover_doc_block_style_indentend() {\n+        check(\n+            r#\"\n+/**\n+    foo\n+    ```rust\n+    let x = 3;\n+    ```\n+*/\n+fn foo$0() {}\n+\"#,\n+            expect![[r#\"\n+                *foo*\n+\n+                ```rust\n+                test\n+                ```\n+\n+                ```rust\n+                fn foo()\n+                ```\n+\n+                ---\n+\n+                foo\n+\n+                ```rust\n+                let x = 3;\n+                ```\n+            \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn hover_comments_dont_highlight_parent() {\n         check_hover_no_result("}, {"sha": "bea020b06128f2c4c4944e652faec99b93f6d2ff", "filename": "crates/ide/src/runnables.rs", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/edf11480ceae1ef77d7084604011c0ef6f692c72/crates%2Fide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edf11480ceae1ef77d7084604011c0ef6f692c72/crates%2Fide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frunnables.rs?ref=edf11480ceae1ef77d7084604011c0ef6f692c72", "patch": "@@ -576,6 +576,20 @@ fn should_have_runnable_1() {}\n /// ```\n fn should_have_runnable_2() {}\n \n+/**\n+```rust\n+let z = 55;\n+```\n+*/\n+fn should_have_no_runnable_3() {}\n+\n+/**\n+    ```rust\n+    let z = 55;\n+    ```\n+*/\n+fn should_have_no_runnable_4() {}\n+\n /// ```no_run\n /// let z = 55;\n /// ```\n@@ -616,7 +630,7 @@ fn should_have_no_runnable_6() {}\n struct StructWithRunnable(String);\n \n \"#,\n-            &[&BIN, &DOCTEST, &DOCTEST, &DOCTEST, &DOCTEST],\n+            &[&BIN, &DOCTEST, &DOCTEST, &DOCTEST, &DOCTEST, &DOCTEST, &DOCTEST],\n             expect![[r#\"\n                 [\n                     Runnable {\n@@ -682,7 +696,37 @@ struct StructWithRunnable(String);\n                             file_id: FileId(\n                                 0,\n                             ),\n-                            full_range: 756..821,\n+                            full_range: 256..320,\n+                            name: \"should_have_no_runnable_3\",\n+                        },\n+                        kind: DocTest {\n+                            test_id: Path(\n+                                \"should_have_no_runnable_3\",\n+                            ),\n+                        },\n+                        cfg: None,\n+                    },\n+                    Runnable {\n+                        nav: NavigationTarget {\n+                            file_id: FileId(\n+                                0,\n+                            ),\n+                            full_range: 322..398,\n+                            name: \"should_have_no_runnable_4\",\n+                        },\n+                        kind: DocTest {\n+                            test_id: Path(\n+                                \"should_have_no_runnable_4\",\n+                            ),\n+                        },\n+                        cfg: None,\n+                    },\n+                    Runnable {\n+                        nav: NavigationTarget {\n+                            file_id: FileId(\n+                                0,\n+                            ),\n+                            full_range: 900..965,\n                             name: \"StructWithRunnable\",\n                         },\n                         kind: DocTest {"}, {"sha": "d9ea7b7ea10985e99d5b5d55cb0acf196d457e61", "filename": "crates/ide_completion/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edf11480ceae1ef77d7084604011c0ef6f692c72/crates%2Fide_completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edf11480ceae1ef77d7084604011c0ef6f692c72/crates%2Fide_completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Flib.rs?ref=edf11480ceae1ef77d7084604011c0ef6f692c72", "patch": "@@ -255,7 +255,7 @@ fn foo() {\n     bar.fo$0;\n }\n \"#,\n-            DetailAndDocumentation { detail: \"fn(&self)\", documentation: \" Do the foo\" },\n+            DetailAndDocumentation { detail: \"fn(&self)\", documentation: \"Do the foo\" },\n         );\n     }\n "}, {"sha": "7e26c3ccfd570727f044c3f88b427214db787d9e", "filename": "crates/ide_db/src/call_info.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/edf11480ceae1ef77d7084604011c0ef6f692c72/crates%2Fide_db%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edf11480ceae1ef77d7084604011c0ef6f692c72/crates%2Fide_db%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fcall_info.rs?ref=edf11480ceae1ef77d7084604011c0ef6f692c72", "patch": "@@ -53,15 +53,15 @@ pub fn call_info(db: &RootDatabase, position: FilePosition) -> Option<CallInfo>\n \n     match callable.kind() {\n         hir::CallableKind::Function(func) => {\n-            res.doc = func.docs(db).map(|it| it.as_str().to_string());\n+            res.doc = func.docs(db).map(|it| it.into());\n             format_to!(res.signature, \"fn {}\", func.name(db));\n         }\n         hir::CallableKind::TupleStruct(strukt) => {\n-            res.doc = strukt.docs(db).map(|it| it.as_str().to_string());\n+            res.doc = strukt.docs(db).map(|it| it.into());\n             format_to!(res.signature, \"struct {}\", strukt.name(db));\n         }\n         hir::CallableKind::TupleEnumVariant(variant) => {\n-            res.doc = variant.docs(db).map(|it| it.as_str().to_string());\n+            res.doc = variant.docs(db).map(|it| it.into());\n             format_to!(\n                 res.signature,\n                 \"enum {}::{}\","}, {"sha": "75ab3eb6ea7936f55df7191bcb69bbb0ab6cff75", "filename": "crates/ide_db/src/call_info/tests.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/edf11480ceae1ef77d7084604011c0ef6f692c72/crates%2Fide_db%2Fsrc%2Fcall_info%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edf11480ceae1ef77d7084604011c0ef6f692c72/crates%2Fide_db%2Fsrc%2Fcall_info%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fcall_info%2Ftests.rs?ref=edf11480ceae1ef77d7084604011c0ef6f692c72", "patch": "@@ -220,11 +220,11 @@ fn bar() {\n }\n \"#,\n         expect![[r#\"\n-                test\n-                ------\n-                fn foo(j: u32) -> u32\n-                (<j: u32>)\n-            \"#]],\n+            test\n+            ------\n+            fn foo(j: u32) -> u32\n+            (<j: u32>)\n+        \"#]],\n     );\n }\n \n@@ -249,19 +249,19 @@ pub fn do() {\n     add_one($0\n }\"#,\n         expect![[r##\"\n-                Adds one to the number given.\n+            Adds one to the number given.\n \n-                # Examples\n+            # Examples\n \n-                ```\n-                let five = 5;\n+            ```\n+            let five = 5;\n \n-                assert_eq!(6, my_crate::add_one(5));\n-                ```\n-                ------\n-                fn add_one(x: i32) -> i32\n-                (<x: i32>)\n-            \"##]],\n+            assert_eq!(6, my_crate::add_one(5));\n+            ```\n+            ------\n+            fn add_one(x: i32) -> i32\n+            (<x: i32>)\n+        \"##]],\n     );\n }\n \n@@ -291,19 +291,19 @@ pub fn do_it() {\n }\n \"#,\n         expect![[r##\"\n-                Adds one to the number given.\n+            Adds one to the number given.\n \n-                # Examples\n+            # Examples\n \n-                ```\n-                let five = 5;\n+            ```\n+            let five = 5;\n \n-                assert_eq!(6, my_crate::add_one(5));\n-                ```\n-                ------\n-                fn add_one(x: i32) -> i32\n-                (<x: i32>)\n-            \"##]],\n+            assert_eq!(6, my_crate::add_one(5));\n+            ```\n+            ------\n+            fn add_one(x: i32) -> i32\n+            (<x: i32>)\n+        \"##]],\n     );\n }\n \n@@ -335,13 +335,13 @@ pub fn foo(mut r: WriteHandler<()>) {\n }\n \"#,\n         expect![[r#\"\n-                Method is called when writer finishes.\n+            Method is called when writer finishes.\n \n-                By default this method stops actor's `Context`.\n-                ------\n-                fn finished(&mut self, ctx: &mut {unknown})\n-                (<ctx: &mut {unknown}>)\n-            \"#]],\n+            By default this method stops actor's `Context`.\n+            ------\n+            fn finished(&mut self, ctx: &mut {unknown})\n+            (<ctx: &mut {unknown}>)\n+        \"#]],\n     );\n }\n \n@@ -389,11 +389,11 @@ fn main() {\n }\n \"#,\n         expect![[r#\"\n-                A cool tuple struct\n-                ------\n-                struct S(u32, i32)\n-                (u32, <i32>)\n-            \"#]],\n+            A cool tuple struct\n+            ------\n+            struct S(u32, i32)\n+            (u32, <i32>)\n+        \"#]],\n     );\n }\n \n@@ -431,11 +431,11 @@ fn main() {\n }\n \"#,\n         expect![[r#\"\n-                A Variant\n-                ------\n-                enum E::A(i32)\n-                (<i32>)\n-            \"#]],\n+            A Variant\n+            ------\n+            enum E::A(i32)\n+            (<i32>)\n+        \"#]],\n     );\n }\n "}, {"sha": "38e0b04efbef90bc8d9afd456b415d5ba2e3ce60", "filename": "crates/syntax/src/ast.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/edf11480ceae1ef77d7084604011c0ef6f692c72/crates%2Fsyntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edf11480ceae1ef77d7084604011c0ef6f692c72/crates%2Fsyntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast.rs?ref=edf11480ceae1ef77d7084604011c0ef6f692c72", "patch": "@@ -118,7 +118,7 @@ fn test_doc_comment_none() {\n     .ok()\n     .unwrap();\n     let module = file.syntax().descendants().find_map(Module::cast).unwrap();\n-    assert!(module.doc_comment_text().is_none());\n+    assert!(module.doc_comments().doc_comment_text().is_none());\n }\n \n #[test]\n@@ -133,7 +133,7 @@ fn test_outer_doc_comment_of_items() {\n     .ok()\n     .unwrap();\n     let module = file.syntax().descendants().find_map(Module::cast).unwrap();\n-    assert_eq!(\"doc\", module.doc_comment_text().unwrap());\n+    assert_eq!(\" doc\", module.doc_comments().doc_comment_text().unwrap());\n }\n \n #[test]\n@@ -148,7 +148,7 @@ fn test_inner_doc_comment_of_items() {\n     .ok()\n     .unwrap();\n     let module = file.syntax().descendants().find_map(Module::cast).unwrap();\n-    assert!(module.doc_comment_text().is_none());\n+    assert!(module.doc_comments().doc_comment_text().is_none());\n }\n \n #[test]\n@@ -162,7 +162,7 @@ fn test_doc_comment_of_statics() {\n     .ok()\n     .unwrap();\n     let st = file.syntax().descendants().find_map(Static::cast).unwrap();\n-    assert_eq!(\"Number of levels\", st.doc_comment_text().unwrap());\n+    assert_eq!(\" Number of levels\", st.doc_comments().doc_comment_text().unwrap());\n }\n \n #[test]\n@@ -181,7 +181,10 @@ fn test_doc_comment_preserves_indents() {\n     .ok()\n     .unwrap();\n     let module = file.syntax().descendants().find_map(Module::cast).unwrap();\n-    assert_eq!(\"doc1\\n```\\nfn foo() {\\n    // ...\\n}\\n```\", module.doc_comment_text().unwrap());\n+    assert_eq!(\n+        \" doc1\\n ```\\n fn foo() {\\n     // ...\\n }\\n ```\",\n+        module.doc_comments().doc_comment_text().unwrap()\n+    );\n }\n \n #[test]\n@@ -198,7 +201,7 @@ fn test_doc_comment_preserves_newlines() {\n     .ok()\n     .unwrap();\n     let module = file.syntax().descendants().find_map(Module::cast).unwrap();\n-    assert_eq!(\"this\\nis\\nmod\\nfoo\", module.doc_comment_text().unwrap());\n+    assert_eq!(\" this\\n is\\n mod\\n foo\", module.doc_comments().doc_comment_text().unwrap());\n }\n \n #[test]\n@@ -212,7 +215,7 @@ fn test_doc_comment_single_line_block_strips_suffix() {\n     .ok()\n     .unwrap();\n     let module = file.syntax().descendants().find_map(Module::cast).unwrap();\n-    assert_eq!(\"this is mod foo\", module.doc_comment_text().unwrap());\n+    assert_eq!(\" this is mod foo\", module.doc_comments().doc_comment_text().unwrap());\n }\n \n #[test]\n@@ -226,7 +229,7 @@ fn test_doc_comment_single_line_block_strips_suffix_whitespace() {\n     .ok()\n     .unwrap();\n     let module = file.syntax().descendants().find_map(Module::cast).unwrap();\n-    assert_eq!(\"this is mod foo \", module.doc_comment_text().unwrap());\n+    assert_eq!(\" this is mod foo \", module.doc_comments().doc_comment_text().unwrap());\n }\n \n #[test]\n@@ -245,8 +248,8 @@ fn test_doc_comment_multi_line_block_strips_suffix() {\n     .unwrap();\n     let module = file.syntax().descendants().find_map(Module::cast).unwrap();\n     assert_eq!(\n-        \"        this\\n        is\\n        mod foo\\n        \",\n-        module.doc_comment_text().unwrap()\n+        \"\\n        this\\n        is\\n        mod foo\\n        \",\n+        module.doc_comments().doc_comment_text().unwrap()\n     );\n }\n \n@@ -259,8 +262,8 @@ fn test_comments_preserve_trailing_whitespace() {\n     .unwrap();\n     let def = file.syntax().descendants().find_map(Struct::cast).unwrap();\n     assert_eq!(\n-        \"Representation of a Realm.   \\nIn the specification these are called Realm Records.\",\n-        def.doc_comment_text().unwrap()\n+        \" Representation of a Realm.   \\n In the specification these are called Realm Records.\",\n+        def.doc_comments().doc_comment_text().unwrap()\n     );\n }\n \n@@ -276,7 +279,7 @@ fn test_four_slash_line_comment() {\n     .ok()\n     .unwrap();\n     let module = file.syntax().descendants().find_map(Module::cast).unwrap();\n-    assert_eq!(\"doc comment\", module.doc_comment_text().unwrap());\n+    assert_eq!(\" doc comment\", module.doc_comments().doc_comment_text().unwrap());\n }\n \n #[test]"}, {"sha": "6c242d1265825b22859f62ce753a38afdd9030f0", "filename": "crates/syntax/src/ast/token_ext.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/edf11480ceae1ef77d7084604011c0ef6f692c72/crates%2Fsyntax%2Fsrc%2Fast%2Ftoken_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edf11480ceae1ef77d7084604011c0ef6f692c72/crates%2Fsyntax%2Fsrc%2Fast%2Ftoken_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Ftoken_ext.rs?ref=edf11480ceae1ef77d7084604011c0ef6f692c72", "patch": "@@ -33,23 +33,20 @@ impl ast::Comment {\n         prefix\n     }\n \n-    /// Returns the textual content of a doc comment block as a single string.\n-    /// That is, strips leading `///` (+ optional 1 character of whitespace),\n-    /// trailing `*/`, trailing whitespace and then joins the lines.\n+    /// Returns the textual content of a doc comment node as a single string with prefix and suffix\n+    /// removed.\n     pub fn doc_comment(&self) -> Option<&str> {\n         let kind = self.kind();\n         match kind {\n             CommentKind { shape, doc: Some(_) } => {\n                 let prefix = kind.prefix();\n                 let text = &self.text()[prefix.len()..];\n-                let ws = text.chars().next().filter(|c| c.is_whitespace());\n-                let text = ws.map_or(text, |ws| &text[ws.len_utf8()..]);\n-                match shape {\n-                    CommentShape::Block if text.ends_with(\"*/\") => {\n-                        Some(&text[..text.len() - \"*/\".len()])\n-                    }\n-                    _ => Some(text),\n-                }\n+                let text = if shape == CommentShape::Block {\n+                    text.strip_suffix(\"*/\").unwrap_or(text)\n+                } else {\n+                    text\n+                };\n+                Some(text)\n             }\n             _ => None,\n         }"}, {"sha": "ddd2136370bd1c9a132f51767a15eb090d72b476", "filename": "crates/syntax/src/ast/traits.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/edf11480ceae1ef77d7084604011c0ef6f692c72/crates%2Fsyntax%2Fsrc%2Fast%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edf11480ceae1ef77d7084604011c0ef6f692c72/crates%2Fsyntax%2Fsrc%2Fast%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Ftraits.rs?ref=edf11480ceae1ef77d7084604011c0ef6f692c72", "patch": "@@ -1,8 +1,6 @@\n //! Various traits that are implemented by ast nodes.\n //!\n //! The implementations are usually trivial, and live in generated.rs\n-use itertools::Itertools;\n-\n use crate::{\n     ast::{self, support, AstChildren, AstNode, AstToken},\n     syntax_node::SyntaxElementChildren,\n@@ -76,23 +74,19 @@ pub trait DocCommentsOwner: AttrsOwner {\n     fn doc_comments(&self) -> CommentIter {\n         CommentIter { iter: self.syntax().children_with_tokens() }\n     }\n-\n-    fn doc_comment_text(&self) -> Option<String> {\n-        self.doc_comments().doc_comment_text()\n-    }\n }\n \n impl CommentIter {\n     pub fn from_syntax_node(syntax_node: &ast::SyntaxNode) -> CommentIter {\n         CommentIter { iter: syntax_node.children_with_tokens() }\n     }\n \n-    /// Returns the textual content of a doc comment block as a single string.\n-    /// That is, strips leading `///` (+ optional 1 character of whitespace),\n-    /// trailing `*/`, trailing whitespace and then joins the lines.\n+    #[cfg(test)]\n     pub fn doc_comment_text(self) -> Option<String> {\n-        let docs =\n-            self.filter_map(|comment| comment.doc_comment().map(ToOwned::to_owned)).join(\"\\n\");\n+        let docs = itertools::Itertools::join(\n+            &mut self.filter_map(|comment| comment.doc_comment().map(ToOwned::to_owned)),\n+            \"\\n\",\n+        );\n         if docs.is_empty() {\n             None\n         } else {"}]}