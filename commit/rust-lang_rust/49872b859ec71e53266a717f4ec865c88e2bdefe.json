{"sha": "49872b859ec71e53266a717f4ec865c88e2bdefe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5ODcyYjg1OWVjNzFlNTMyNjZhNzE3ZjRlYzg2NWM4OGUyYmRlZmU=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-02-28T15:50:28Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-04-08T20:40:52Z"}, "message": "rustc: add a TyLayout helper for type-related layout queries.", "tree": {"sha": "01a7a60f212e5bb2a2e88b7af9e1cc8645c20964", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01a7a60f212e5bb2a2e88b7af9e1cc8645c20964"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49872b859ec71e53266a717f4ec865c88e2bdefe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49872b859ec71e53266a717f4ec865c88e2bdefe", "html_url": "https://github.com/rust-lang/rust/commit/49872b859ec71e53266a717f4ec865c88e2bdefe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49872b859ec71e53266a717f4ec865c88e2bdefe/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a61011761deeab9e308e6d103b1dc7aaf334f6e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/a61011761deeab9e308e6d103b1dc7aaf334f6e3", "html_url": "https://github.com/rust-lang/rust/commit/a61011761deeab9e308e6d103b1dc7aaf334f6e3"}], "stats": {"total": 250, "additions": 237, "deletions": 13}, "files": [{"sha": "8d68eff9251735afc27445cfa0eb98981f0d21f8", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 234, "deletions": 10, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/49872b859ec71e53266a717f4ec865c88e2bdefe/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49872b859ec71e53266a717f4ec865c88e2bdefe/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=49872b859ec71e53266a717f4ec865c88e2bdefe", "patch": "@@ -25,6 +25,7 @@ use std::cmp;\n use std::fmt;\n use std::i64;\n use std::iter;\n+use std::ops::Deref;\n \n /// Parsed [Data layout](http://llvm.org/docs/LangRef.html#data-layout)\n /// for a target, which contains everything needed to compute layouts.\n@@ -904,7 +905,8 @@ pub enum Layout {\n         /// If true, the size is exact, otherwise it's only a lower bound.\n         sized: bool,\n         align: Align,\n-        size: Size\n+        element_size: Size,\n+        count: u64\n     },\n \n     /// TyRawPtr or TyRef with a !Sized pointee.\n@@ -1087,25 +1089,35 @@ impl<'a, 'gcx, 'tcx> Layout {\n             // Arrays and slices.\n             ty::TyArray(element, count) => {\n                 let element = element.layout(infcx)?;\n+                let element_size = element.size(dl);\n+                // FIXME(eddyb) Don't use host `usize` for array lengths.\n+                let usize_count: usize = count;\n+                let count = usize_count as u64;\n+                if element_size.checked_mul(count, dl).is_none() {\n+                    return Err(LayoutError::SizeOverflow(ty));\n+                }\n                 Array {\n                     sized: true,\n                     align: element.align(dl),\n-                    size: element.size(dl).checked_mul(count as u64, dl)\n-                                 .map_or(Err(LayoutError::SizeOverflow(ty)), Ok)?\n+                    element_size: element_size,\n+                    count: count\n                 }\n             }\n             ty::TySlice(element) => {\n+                let element = element.layout(infcx)?;\n                 Array {\n                     sized: false,\n-                    align: element.layout(infcx)?.align(dl),\n-                    size: Size::from_bytes(0)\n+                    align: element.align(dl),\n+                    element_size: element.size(dl),\n+                    count: 0\n                 }\n             }\n             ty::TyStr => {\n                 Array {\n                     sized: false,\n                     align: dl.i8_align,\n-                    size: Size::from_bytes(0)\n+                    element_size: Size::from_bytes(1),\n+                    count: 0\n                 }\n             }\n \n@@ -1447,15 +1459,23 @@ impl<'a, 'gcx, 'tcx> Layout {\n             }\n \n             Vector { element, count } => {\n-                let elem_size = element.size(dl);\n-                let vec_size = match elem_size.checked_mul(count, dl) {\n+                let element_size = element.size(dl);\n+                let vec_size = match element_size.checked_mul(count, dl) {\n                     Some(size) => size,\n                     None => bug!(\"Layout::size({:?}): {} * {} overflowed\",\n-                                 self, elem_size.bytes(), count)\n+                                 self, element_size.bytes(), count)\n                 };\n                 vec_size.abi_align(self.align(dl))\n             }\n \n+            Array { element_size, count, .. } => {\n+                match element_size.checked_mul(count, dl) {\n+                    Some(size) => size,\n+                    None => bug!(\"Layout::size({:?}): {} * {} overflowed\",\n+                                 self, element_size.bytes(), count)\n+                }\n+            }\n+\n             FatPointer { metadata, .. } => {\n                 // Effectively a (ptr, meta) tuple.\n                 Pointer.size(dl).abi_align(metadata.align(dl))\n@@ -1464,7 +1484,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n             }\n \n             CEnum { discr, .. } => Int(discr).size(dl),\n-            Array { size, .. } | General { size, .. } => size,\n+            General { size, .. } => size,\n             UntaggedUnion { ref variants } => variants.stride(),\n \n             Univariant { ref variant, .. } |\n@@ -1513,6 +1533,59 @@ impl<'a, 'gcx, 'tcx> Layout {\n             }\n         }\n     }\n+\n+    pub fn field_offset(&self,\n+                        dl: &TargetDataLayout,\n+                        i: usize,\n+                        variant_index: Option<usize>)\n+                        -> Size {\n+        match *self {\n+            Scalar { .. } |\n+            CEnum { .. } |\n+            UntaggedUnion { .. } |\n+            RawNullablePointer { .. } => {\n+                Size::from_bytes(0)\n+            }\n+\n+            Vector { element, count } => {\n+                let element_size = element.size(dl);\n+                let i = i as u64;\n+                assert!(i < count);\n+                Size::from_bytes(element_size.bytes() * count)\n+            }\n+\n+            Array { element_size, count, .. } => {\n+                let i = i as u64;\n+                assert!(i < count);\n+                Size::from_bytes(element_size.bytes() * count)\n+            }\n+\n+            FatPointer { metadata, .. } => {\n+                // Effectively a (ptr, meta) tuple.\n+                assert!(i < 2);\n+                if i == 0 {\n+                    Size::from_bytes(0)\n+                } else {\n+                    Pointer.size(dl).abi_align(metadata.align(dl))\n+                }\n+            }\n+\n+            Univariant { ref variant, .. } => variant.offsets[i],\n+\n+            General { ref variants, .. } => {\n+                let v = variant_index.expect(\"variant index required\");\n+                variants[v].offsets[i + 1]\n+            }\n+\n+            StructWrappedNullablePointer { nndiscr, ref nonnull, .. } => {\n+                if Some(nndiscr as usize) == variant_index {\n+                    nonnull.offsets[i]\n+                } else {\n+                    Size::from_bytes(0)\n+                }\n+            }\n+        }\n+    }\n }\n \n /// Type size \"skeleton\", i.e. the only information determining a type's size.\n@@ -1658,3 +1731,154 @@ impl<'a, 'gcx, 'tcx> SizeSkeleton<'gcx> {\n         }\n     }\n }\n+\n+/// A pair of a type and its layout. Implements various\n+/// type traversal APIs (e.g. recursing into fields).\n+#[derive(Copy, Clone, Debug)]\n+pub struct TyLayout<'tcx> {\n+    pub ty: Ty<'tcx>,\n+    pub layout: &'tcx Layout,\n+    pub variant_index: Option<usize>,\n+}\n+\n+impl<'tcx> Deref for TyLayout<'tcx> {\n+    type Target = Layout;\n+    fn deref(&self) -> &Layout {\n+        self.layout\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> TyLayout<'gcx> {\n+    pub fn of(infcx: &InferCtxt<'a, 'gcx, 'tcx>, ty: Ty<'gcx>)\n+              -> Result<Self, LayoutError<'gcx>> {\n+        let ty = normalize_associated_type(infcx, ty);\n+\n+        Ok(TyLayout {\n+            ty: ty,\n+            layout: ty.layout(infcx)?,\n+            variant_index: None\n+        })\n+    }\n+\n+    pub fn for_variant(&self, variant_index: usize) -> Self {\n+        TyLayout {\n+            variant_index: Some(variant_index),\n+            ..*self\n+        }\n+    }\n+\n+    pub fn field_offset(&self, dl: &TargetDataLayout, i: usize) -> Size {\n+        self.layout.field_offset(dl, i, self.variant_index)\n+    }\n+\n+    pub fn field_count(&self) -> usize {\n+        // Handle enum/union through the type rather than Layout.\n+        if let ty::TyAdt(def, _) = self.ty.sty {\n+            let v = self.variant_index.unwrap_or(0);\n+            if def.variants.is_empty() {\n+                assert_eq!(v, 0);\n+                return 0;\n+            } else {\n+                return def.variants[v].fields.len();\n+            }\n+        }\n+\n+        match *self.layout {\n+            Scalar { .. } => {\n+                bug!(\"TyLayout::field_count({:?}): not applicable\", self)\n+            }\n+\n+            // Handled above (the TyAdt case).\n+            CEnum { .. } |\n+            General { .. } |\n+            UntaggedUnion { .. } |\n+            RawNullablePointer { .. } |\n+            StructWrappedNullablePointer { .. } => bug!(),\n+\n+            FatPointer { .. } => 2,\n+\n+            Vector { count, .. } |\n+            Array { count, .. } => {\n+                let usize_count = count as usize;\n+                assert_eq!(usize_count as u64, count);\n+                usize_count\n+            }\n+\n+            Univariant { ref variant, .. } => variant.offsets.len(),\n+        }\n+    }\n+\n+    pub fn field_type(&self, tcx: TyCtxt<'a, 'gcx, 'gcx>, i: usize) -> Ty<'gcx> {\n+        let ptr_field_type = |pointee: Ty<'gcx>| {\n+            let slice = |element: Ty<'gcx>| {\n+                assert!(i < 2);\n+                if i == 0 {\n+                    tcx.mk_mut_ptr(element)\n+                } else {\n+                    tcx.types.usize\n+                }\n+            };\n+            match tcx.struct_tail(pointee).sty {\n+                ty::TySlice(element) => slice(element),\n+                ty::TyStr => slice(tcx.types.u8),\n+                ty::TyDynamic(..) => tcx.mk_mut_ptr(tcx.mk_nil()),\n+                _ => bug!(\"TyLayout::field_type({:?}): not applicable\", self)\n+            }\n+        };\n+\n+        match self.ty.sty {\n+            ty::TyBool |\n+            ty::TyChar |\n+            ty::TyInt(_) |\n+            ty::TyUint(_) |\n+            ty::TyFloat(_) |\n+            ty::TyFnPtr(_) |\n+            ty::TyNever |\n+            ty::TyFnDef(..) |\n+            ty::TyDynamic(..) => {\n+                bug!(\"TyLayout::field_type({:?}): not applicable\", self)\n+            }\n+\n+            // Potentially-fat pointers.\n+            ty::TyRef(_, ty::TypeAndMut { ty: pointee, .. }) |\n+            ty::TyRawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n+                ptr_field_type(pointee)\n+            }\n+            ty::TyAdt(def, _) if def.is_box() => {\n+                ptr_field_type(self.ty.boxed_ty())\n+            }\n+\n+            // Arrays and slices.\n+            ty::TyArray(element, _) |\n+            ty::TySlice(element) => element,\n+            ty::TyStr => tcx.types.u8,\n+\n+            // Tuples and closures.\n+            ty::TyClosure(def_id, ref substs) => {\n+                substs.upvar_tys(def_id, tcx).nth(i).unwrap()\n+            }\n+\n+            ty::TyTuple(tys, _) => tys[i],\n+\n+            // SIMD vector types.\n+            ty::TyAdt(def, ..) if def.repr.simd => {\n+                self.ty.simd_type(tcx)\n+            }\n+\n+            // ADTs.\n+            ty::TyAdt(def, substs) => {\n+                def.variants[self.variant_index.unwrap_or(0)].fields[i].ty(tcx, substs)\n+            }\n+\n+            ty::TyProjection(_) | ty::TyAnon(..) | ty::TyParam(_) |\n+            ty::TyInfer(_) | ty::TyError => {\n+                bug!(\"TyLayout::field_type: unexpected type `{}`\", self.ty)\n+            }\n+        }\n+    }\n+\n+    pub fn field(&self, infcx: &InferCtxt<'a, 'gcx, 'tcx>, i: usize)\n+                 -> Result<Self, LayoutError<'gcx>> {\n+        TyLayout::of(infcx, self.field_type(infcx.tcx.global_tcx(), i))\n+    }\n+}"}, {"sha": "3649216eaa85eebd9900fcd46c230569ad976c68", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49872b859ec71e53266a717f4ec865c88e2bdefe/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49872b859ec71e53266a717f4ec865c88e2bdefe/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=49872b859ec71e53266a717f4ec865c88e2bdefe", "patch": "@@ -828,9 +828,9 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         TypeOfDepthLock(self.local())\n     }\n \n-    pub fn layout_of(&self, ty: Ty<'tcx>) -> &'tcx ty::layout::Layout {\n+    pub fn layout_of(&self, ty: Ty<'tcx>) -> ty::layout::TyLayout<'tcx> {\n         self.tcx().infer_ctxt((), traits::Reveal::All).enter(|infcx| {\n-            ty.layout(&infcx).unwrap_or_else(|e| {\n+            ty::layout::TyLayout::of(&infcx, ty).unwrap_or_else(|e| {\n                 match e {\n                     ty::layout::LayoutError::SizeOverflow(_) =>\n                         self.sess().fatal(&e.to_string()),"}, {"sha": "93798e7bd3330c01aeb84e410860df739e2ccfe7", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49872b859ec71e53266a717f4ec865c88e2bdefe/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49872b859ec71e53266a717f4ec865c88e2bdefe/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=49872b859ec71e53266a717f4ec865c88e2bdefe", "patch": "@@ -1564,7 +1564,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         enum_llvm_type,\n         EnumMDF(EnumMemberDescriptionFactory {\n             enum_type: enum_type,\n-            type_rep: type_rep,\n+            type_rep: type_rep.layout,\n             discriminant_type_metadata: discriminant_type_metadata,\n             containing_scope: containing_scope,\n             file_metadata: file_metadata,"}]}