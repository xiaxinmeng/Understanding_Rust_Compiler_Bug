{"sha": "b753e77cbe175fc6e336387029290e9d19f1243a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3NTNlNzdjYmUxNzVmYzZlMzM2Mzg3MDI5MjkwZTlkMTlmMTI0M2E=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-02-24T16:38:57Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-02-24T16:38:57Z"}, "message": "Rustfmt and sort all `use` items", "tree": {"sha": "74947098008106d685e15341c5ae9fa90aaf87d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74947098008106d685e15341c5ae9fa90aaf87d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b753e77cbe175fc6e336387029290e9d19f1243a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b753e77cbe175fc6e336387029290e9d19f1243a", "html_url": "https://github.com/rust-lang/rust/commit/b753e77cbe175fc6e336387029290e9d19f1243a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b753e77cbe175fc6e336387029290e9d19f1243a/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d299b5d4d9c6d66cfe7f9ba081a1de646b6dc310", "url": "https://api.github.com/repos/rust-lang/rust/commits/d299b5d4d9c6d66cfe7f9ba081a1de646b6dc310", "html_url": "https://github.com/rust-lang/rust/commit/d299b5d4d9c6d66cfe7f9ba081a1de646b6dc310"}], "stats": {"total": 556, "additions": 279, "deletions": 277}, "files": [{"sha": "822fbd16c326df93bbd9c78f696e0c095efe0d0f", "filename": "src/approx_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fapprox_const.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,8 +1,8 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n use std::f64::consts as f64;\n-use utils::span_lint;\n use syntax::ast::{Lit, LitKind, FloatTy};\n+use utils::span_lint;\n \n /// **What it does:** This lint checks for floating point literals that approximate constants which are defined in [`std::f32::consts`](https://doc.rust-lang.org/stable/std/f32/consts/#constants) or [`std::f64::consts`](https://doc.rust-lang.org/stable/std/f64/consts/#constants), respectively, suggesting to use the predefined constant.\n ///"}, {"sha": "363809c37bbe5aee31a4766944860915ccec19dd", "filename": "src/attrs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattrs.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,12 +1,12 @@\n //! checks for attributes\n \n+use reexport::*;\n use rustc::lint::*;\n use rustc_front::hir::*;\n-use reexport::*;\n use semver::Version;\n-use syntax::codemap::Span;\n-use syntax::attr::*;\n use syntax::ast::{Attribute, Lit, LitKind, MetaItemKind};\n+use syntax::attr::*;\n+use syntax::codemap::Span;\n use utils::{in_macro, match_path, span_lint, BEGIN_UNWIND};\n \n /// **What it does:** This lint checks for items annotated with `#[inline(always)]`, unless the annotated function is empty or simply panics."}, {"sha": "0e09122bcc6eb4a00dd9af6368083e596f9a6e2c", "filename": "src/bit_mask.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbit_mask.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -3,8 +3,8 @@ use rustc::middle::const_eval::lookup_const_by_id;\n use rustc::middle::def::{Def, PathResolution};\n use rustc_front::hir::*;\n use rustc_front::util::is_comparison_binop;\n-use syntax::codemap::Span;\n use syntax::ast::LitKind;\n+use syntax::codemap::Span;\n \n use utils::span_lint;\n "}, {"sha": "6db77a5ce939afed25dbdec542bd232c901a8843", "filename": "src/block_in_if_condition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fblock_in_if_condition.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,5 +1,5 @@\n-use rustc_front::hir::*;\n use rustc::lint::{LateLintPass, LateContext, LintArray, LintPass};\n+use rustc_front::hir::*;\n use rustc_front::intravisit::{Visitor, walk_expr};\n use utils::*;\n "}, {"sha": "cf32a9a2c8253861008733006633d6f9cd2af53a", "filename": "src/consts.rs", "status": "modified", "additions": 37, "deletions": 22, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -95,9 +95,7 @@ impl PartialEq for Constant {\n             (&Constant::Byte(l), &Constant::Byte(r)) => l == r,\n             (&Constant::Char(l), &Constant::Char(r)) => l == r,\n             (&Constant::Int(0, _, _), &Constant::Int(0, _, _)) => true,\n-            (&Constant::Int(lv, _, lneg), &Constant::Int(rv, _, rneg)) => {\n-                lv == rv && lneg == rneg\n-            }\n+            (&Constant::Int(lv, _, lneg), &Constant::Int(rv, _, rneg)) => lv == rv && lneg == rneg,\n             (&Constant::Float(ref ls, _), &Constant::Float(ref rs, _)) => {\n                 // we want `Fw32 == FwAny` and `FwAny == Fw64`, by transitivity we must have\n                 // `Fw32 == Fw64` so don\u2019t compare them\n@@ -116,7 +114,9 @@ impl PartialEq for Constant {\n }\n \n impl Hash for Constant {\n-    fn hash<H>(&self, state: &mut H) where H: Hasher {\n+    fn hash<H>(&self, state: &mut H)\n+        where H: Hasher\n+    {\n         match *self {\n             Constant::Str(ref s, ref k) => {\n                 s.hash(state);\n@@ -144,7 +144,7 @@ impl Hash for Constant {\n             Constant::Bool(b) => {\n                 b.hash(state);\n             }\n-            Constant::Vec(ref v) | Constant::Tuple(ref v)=> {\n+            Constant::Vec(ref v) | Constant::Tuple(ref v) => {\n                 v.hash(state);\n             }\n             Constant::Repeat(ref c, l) => {\n@@ -210,7 +210,9 @@ fn constant_not(o: Constant) -> Option<Constant> {\n     use self::Constant::*;\n     match o {\n         Bool(b) => Some(Bool(!b)),\n-        Int(value, LitIntType::Signed(ity), Sign::Plus) if value != ::std::u64::MAX => Some(Int(value + 1, LitIntType::Signed(ity), Sign::Minus)),\n+        Int(value, LitIntType::Signed(ity), Sign::Plus) if value != ::std::u64::MAX => {\n+            Some(Int(value + 1, LitIntType::Signed(ity), Sign::Minus))\n+        }\n         Int(0, LitIntType::Signed(ity), Sign::Minus) => Some(Int(1, LitIntType::Signed(ity), Sign::Minus)),\n         Int(value, LitIntType::Signed(ity), Sign::Minus) => Some(Int(value - 1, LitIntType::Signed(ity), Sign::Plus)),\n         Int(value, LitIntType::Unsigned(ity), Sign::Plus) => {\n@@ -224,7 +226,7 @@ fn constant_not(o: Constant) -> Option<Constant> {\n                 }  // refuse to guess\n             };\n             Some(Int(!value & mask, LitIntType::Unsigned(ity), Sign::Plus))\n-        },\n+        }\n         _ => None,\n     }\n }\n@@ -388,7 +390,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n                         (Constant::Byte(l8), Constant::Byte(r8)) => l8.checked_add(r8).map(Constant::Byte),\n                         (Constant::Int(l64, lty, lsign), Constant::Int(r64, rty, rsign)) => {\n                             add_ints(l64, r64, lty, rty, lsign, rsign)\n-                        },\n+                        }\n                         // TODO: float (would need bignum library?)\n                         _ => None,\n                     }\n@@ -406,7 +408,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n                         }\n                         (Constant::Int(l64, lty, lsign), Constant::Int(r64, rty, rsign)) => {\n                             add_ints(l64, r64, lty, rty, lsign, neg_sign(rsign))\n-                        },\n+                        }\n                         _ => None,\n                     }\n                 })\n@@ -438,7 +440,11 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n             match (l, r) {\n                 (Constant::Int(l64, lty, lsign), Constant::Int(r64, rty, rsign)) => {\n                     f(l64, r64).and_then(|value| {\n-                        let sign = if lsign == rsign { Sign::Plus } else { Sign::Minus };\n+                        let sign = if lsign == rsign {\n+                            Sign::Plus\n+                        } else {\n+                            Sign::Minus\n+                        };\n                         unify_int_type(lty, rty).map(|ty| Constant::Int(value, ty, sign))\n                     })\n                 }\n@@ -504,19 +510,28 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n }\n \n fn add_ints(l64: u64, r64: u64, lty: LitIntType, rty: LitIntType, lsign: Sign, rsign: Sign) -> Option<Constant> {\n-    let ty = if let Some(ty) = unify_int_type(lty, rty) { ty } else { return None; };\n+    let ty = if let Some(ty) = unify_int_type(lty, rty) {\n+        ty\n+    } else {\n+        return None;\n+    };\n+\n     match (lsign, rsign) {\n         (Sign::Plus, Sign::Plus) => l64.checked_add(r64).map(|v| Constant::Int(v, ty, Sign::Plus)),\n-        (Sign::Plus, Sign::Minus) => if r64 > l64 {\n-            Some(Constant::Int(r64 - l64, ty, Sign::Minus))\n-        } else {\n-            Some(Constant::Int(l64 - r64, ty, Sign::Plus))\n-        },\n-        (Sign::Minus, Sign::Minus) =>  l64.checked_add(r64).map(|v| Constant::Int(v, ty, Sign::Minus)),\n-        (Sign::Minus, Sign::Plus) => if l64 > r64 {\n-            Some(Constant::Int(l64 - r64, ty, Sign::Minus))\n-        } else {\n-            Some(Constant::Int(r64 - l64, ty, Sign::Plus))\n-        },\n+        (Sign::Plus, Sign::Minus) => {\n+            if r64 > l64 {\n+                Some(Constant::Int(r64 - l64, ty, Sign::Minus))\n+            } else {\n+                Some(Constant::Int(l64 - r64, ty, Sign::Plus))\n+            }\n+        }\n+        (Sign::Minus, Sign::Minus) => l64.checked_add(r64).map(|v| Constant::Int(v, ty, Sign::Minus)),\n+        (Sign::Minus, Sign::Plus) => {\n+            if l64 > r64 {\n+                Some(Constant::Int(l64 - r64, ty, Sign::Minus))\n+            } else {\n+                Some(Constant::Int(r64 - l64, ty, Sign::Plus))\n+            }\n+        }\n     }\n }"}, {"sha": "1995e2901ad86a09079e88566b191c4df0265bdc", "filename": "src/copies.rs", "status": "modified", "additions": 43, "deletions": 31, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcopies.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -61,11 +61,7 @@ pub struct CopyAndPaste;\n \n impl LintPass for CopyAndPaste {\n     fn get_lints(&self) -> LintArray {\n-        lint_array![\n-            IFS_SAME_COND,\n-            IF_SAME_THEN_ELSE,\n-            MATCH_SAME_ARMS\n-        ]\n+        lint_array![IFS_SAME_COND, IF_SAME_THEN_ELSE, MATCH_SAME_ARMS]\n     }\n }\n \n@@ -89,35 +85,43 @@ impl LateLintPass for CopyAndPaste {\n \n /// Implementation of `IF_SAME_THEN_ELSE`.\n fn lint_same_then_else(cx: &LateContext, blocks: &[&Block]) {\n-    let hash : &Fn(&&Block) -> u64 = &|block| -> u64 {\n+    let hash: &Fn(&&Block) -> u64 = &|block| -> u64 {\n         let mut h = SpanlessHash::new(cx);\n         h.hash_block(block);\n         h.finish()\n     };\n \n-    let eq : &Fn(&&Block, &&Block) -> bool = &|&lhs, &rhs| -> bool {\n+    let eq: &Fn(&&Block, &&Block) -> bool = &|&lhs, &rhs| -> bool {\n         SpanlessEq::new(cx).eq_block(lhs, rhs)\n     };\n \n     if let Some((i, j)) = search_same(blocks, hash, eq) {\n-        span_note_and_lint(cx, IF_SAME_THEN_ELSE, j.span, \"this `if` has identical blocks\", i.span, \"same as this\");\n+        span_note_and_lint(cx,\n+                           IF_SAME_THEN_ELSE,\n+                           j.span,\n+                           \"this `if` has identical blocks\",\n+                           i.span,\n+                           \"same as this\");\n     }\n }\n \n /// Implementation of `IFS_SAME_COND`.\n fn lint_same_cond(cx: &LateContext, conds: &[&Expr]) {\n-    let hash : &Fn(&&Expr) -> u64 = &|expr| -> u64 {\n+    let hash: &Fn(&&Expr) -> u64 = &|expr| -> u64 {\n         let mut h = SpanlessHash::new(cx);\n         h.hash_expr(expr);\n         h.finish()\n     };\n \n-    let eq : &Fn(&&Expr, &&Expr) -> bool = &|&lhs, &rhs| -> bool {\n-        SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, rhs)\n-    };\n+    let eq: &Fn(&&Expr, &&Expr) -> bool = &|&lhs, &rhs| -> bool { SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, rhs) };\n \n     if let Some((i, j)) = search_same(conds, hash, eq) {\n-        span_note_and_lint(cx, IFS_SAME_COND, j.span, \"this `if` has the same condition as a previous if\", i.span, \"same as this\");\n+        span_note_and_lint(cx,\n+                           IFS_SAME_COND,\n+                           j.span,\n+                           \"this `if` has the same condition as a previous if\",\n+                           i.span,\n+                           \"same as this\");\n     }\n }\n \n@@ -137,7 +141,12 @@ fn lint_match_arms(cx: &LateContext, expr: &Expr) {\n \n     if let ExprMatch(_, ref arms, MatchSource::Normal) = expr.node {\n         if let Some((i, j)) = search_same(&**arms, hash, eq) {\n-            span_note_and_lint(cx, MATCH_SAME_ARMS, j.body.span, \"this `match` has identical arm bodies\", i.body.span, \"same as this\");\n+            span_note_and_lint(cx,\n+                               MATCH_SAME_ARMS,\n+                               j.body.span,\n+                               \"this `match` has identical arm bodies\",\n+                               i.body.span,\n+                               \"same as this\");\n         }\n     }\n }\n@@ -155,8 +164,7 @@ fn if_sequence(mut expr: &Expr) -> (SmallVector<&Expr>, SmallVector<&Block>) {\n \n         if let Some(ref else_expr) = *else_expr {\n             expr = else_expr;\n-        }\n-        else {\n+        } else {\n             break;\n         }\n     }\n@@ -188,7 +196,7 @@ fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> HashMap<Interned\n                 if let Some(ref as_pat) = *as_pat {\n                     bindings_impl(cx, as_pat, map);\n                 }\n-            },\n+            }\n             PatKind::Struct(_, ref fields, _) => {\n                 for pat in fields {\n                     bindings_impl(cx, &pat.node.pat, map);\n@@ -210,7 +218,12 @@ fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> HashMap<Interned\n                     bindings_impl(cx, pat, map);\n                 }\n             }\n-            PatKind::TupleStruct(..) | PatKind::Lit(..) | PatKind::QPath(..) | PatKind::Range(..) | PatKind::Wild | PatKind::Path(..) => (),\n+            PatKind::TupleStruct(..) |\n+            PatKind::Lit(..) |\n+            PatKind::QPath(..) |\n+            PatKind::Range(..) |\n+            PatKind::Wild |\n+            PatKind::Path(..) => (),\n         }\n     }\n \n@@ -219,36 +232,35 @@ fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> HashMap<Interned\n     result\n }\n \n-fn search_same<T, Hash, Eq>(exprs: &[T],\n-                            hash: Hash,\n-                            eq: Eq) -> Option<(&T, &T)>\n-where Hash: Fn(&T) -> u64,\n-      Eq: Fn(&T, &T) -> bool {\n+fn search_same<T, Hash, Eq>(exprs: &[T], hash: Hash, eq: Eq) -> Option<(&T, &T)>\n+    where Hash: Fn(&T) -> u64,\n+          Eq: Fn(&T, &T) -> bool\n+{\n     // common cases\n     if exprs.len() < 2 {\n         return None;\n-    }\n-    else if exprs.len() == 2 {\n+    } else if exprs.len() == 2 {\n         return if eq(&exprs[0], &exprs[1]) {\n             Some((&exprs[0], &exprs[1]))\n-        }\n-        else {\n+        } else {\n             None\n-        }\n+        };\n     }\n \n-    let mut map : HashMap<_, Vec<&_>> = HashMap::with_capacity(exprs.len());\n+    let mut map: HashMap<_, Vec<&_>> = HashMap::with_capacity(exprs.len());\n \n     for expr in exprs {\n         match map.entry(hash(expr)) {\n             Entry::Occupied(o) => {\n                 for o in o.get() {\n                     if eq(&o, expr) {\n-                        return Some((&o, expr))\n+                        return Some((&o, expr));\n                     }\n                 }\n             }\n-            Entry::Vacant(v) => { v.insert(vec![expr]); }\n+            Entry::Vacant(v) => {\n+                v.insert(vec![expr]);\n+            }\n         }\n     }\n "}, {"sha": "3f956f1fc41b8b7cd4dfcbf07b7e8f8dc7eec608", "filename": "src/cyclomatic_complexity.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcyclomatic_complexity.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,13 +1,13 @@\n //! calculate cyclomatic complexity and warn about overly complex functions\n \n use rustc::lint::*;\n-use rustc_front::hir::*;\n use rustc::middle::cfg::CFG;\n use rustc::middle::ty;\n-use syntax::codemap::Span;\n-use syntax::attr::*;\n-use syntax::ast::Attribute;\n+use rustc_front::hir::*;\n use rustc_front::intravisit::{Visitor, walk_expr};\n+use syntax::ast::Attribute;\n+use syntax::attr::*;\n+use syntax::codemap::Span;\n \n use utils::{in_macro, LimitStack, span_help_and_lint};\n "}, {"sha": "5f7e67925bd83d0e98c2690edf2f0264807848d8", "filename": "src/drop_ref.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fdrop_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fdrop_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdrop_ref.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,8 +1,7 @@\n use rustc::lint::*;\n-use rustc_front::hir::*;\n use rustc::middle::ty;\n+use rustc_front::hir::*;\n use syntax::codemap::Span;\n-\n use utils::DROP_PATH;\n use utils::{match_def_path, span_note_and_lint};\n "}, {"sha": "5b542a7d67b3c374cfdaece84b12974355eea443", "filename": "src/enum_glob_use.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fenum_glob_use.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,13 +1,13 @@\n //! lint on `use`ing all variants of an enum\n \n-use rustc::lint::{LateLintPass, LintPass, LateContext, LintArray, LintContext};\n-use rustc_front::hir::*;\n use rustc::front::map::Node::NodeItem;\n use rustc::front::map::definitions::DefPathData;\n+use rustc::lint::{LateLintPass, LintPass, LateContext, LintArray, LintContext};\n use rustc::middle::ty::TyEnum;\n-use utils::span_lint;\n-use syntax::codemap::Span;\n+use rustc_front::hir::*;\n use syntax::ast::NodeId;\n+use syntax::codemap::Span;\n+use utils::span_lint;\n \n /// **What it does:** Warns when `use`ing all variants of an enum\n ///"}, {"sha": "a95fca8c6c47564a071fc97f1044f33f81352d00", "filename": "src/enum_variants.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fenum_variants.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,10 +1,9 @@\n //! lint on enum variants that are prefixed or suffixed by the same characters\n \n use rustc::lint::*;\n-use syntax::attr::*;\n use syntax::ast::*;\n+use syntax::attr::*;\n use syntax::parse::token::InternedString;\n-\n use utils::span_help_and_lint;\n use utils::{camel_case_from, camel_case_until};\n \n@@ -95,7 +94,7 @@ impl EarlyLintPass for EnumVariantNames {\n             } else if !post.is_empty() {\n                 (\"post\", post)\n             } else {\n-                return\n+                return;\n             };\n             span_help_and_lint(cx,\n                                ENUM_VARIANT_NAMES,"}, {"sha": "09ac6325f96f45ff4230fc3dcd018403102d1ad5", "filename": "src/eq_op.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feq_op.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,7 +1,6 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n use rustc_front::util as ast_util;\n-\n use utils::{SpanlessEq, span_lint};\n \n /// **What it does:** This lint checks for equal operands to comparison, logical and bitwise,"}, {"sha": "bcc1cb16870fd9ccf4fbc107f34422c0915753f1", "filename": "src/escape.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fescape.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,13 +1,13 @@\n-use rustc::lint::*;\n use rustc::front::map::Node::{NodeExpr, NodeStmt};\n-use rustc_front::hir::*;\n-use rustc_front::intravisit as visit;\n-use rustc::middle::ty;\n-use rustc::middle::ty::adjustment::AutoAdjustment;\n+use rustc::lint::*;\n use rustc::middle::expr_use_visitor::*;\n use rustc::middle::infer;\n use rustc::middle::mem_categorization::{cmt, Categorization};\n+use rustc::middle::ty::adjustment::AutoAdjustment;\n+use rustc::middle::ty;\n use rustc::util::nodemap::NodeSet;\n+use rustc_front::hir::*;\n+use rustc_front::intravisit as visit;\n use syntax::ast::NodeId;\n use syntax::codemap::Span;\n use utils::span_lint;"}, {"sha": "e28411cc79cb22abb8a61cf253b164ac5ce8a99f", "filename": "src/eta_reduction.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feta_reduction.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,10 +1,8 @@\n use rustc::lint::*;\n-use rustc_front::hir::*;\n use rustc::middle::ty;\n-\n+use rustc_front::hir::*;\n use utils::{snippet_opt, span_lint_and_then, is_adjusted};\n \n-\n #[allow(missing_copy_implementations)]\n pub struct EtaPass;\n "}, {"sha": "8a0da7bcd9f45332e401b692108d4d6c2306a923", "filename": "src/identity_op.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fidentity_op.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,8 +1,7 @@\n+use consts::{constant_simple, Constant, Sign};\n use rustc::lint::*;\n use rustc_front::hir::*;\n use syntax::codemap::Span;\n-\n-use consts::{constant_simple, Constant, Sign};\n use utils::{span_lint, snippet, in_macro};\n \n /// **What it does:** This lint checks for identity operations, e.g. `x + 0`."}, {"sha": "a2ab72469429028d1edd79ac566d882466958a30", "filename": "src/items_after_statements.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fitems_after_statements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fitems_after_statements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems_after_statements.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,8 +1,8 @@\n //! lint when items are used after statements\n \n use rustc::lint::*;\n-use syntax::attr::*;\n use syntax::ast::*;\n+use syntax::attr::*;\n use utils::in_macro;\n \n /// **What it does:** This lints checks for items declared after some statement in a block"}, {"sha": "6963592592d18e12725162a3874075e3e7b8c2e9", "filename": "src/len_zero.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flen_zero.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,13 +1,10 @@\n use rustc::lint::*;\n-use rustc_front::hir::*;\n-use syntax::ast::Name;\n-use syntax::ptr::P;\n-use syntax::codemap::{Span, Spanned};\n use rustc::middle::def_id::DefId;\n use rustc::middle::ty::{self, MethodTraitItemId, ImplOrTraitItemId};\n-\n-use syntax::ast::{Lit, LitKind};\n-\n+use rustc_front::hir::*;\n+use syntax::ast::{Lit, LitKind, Name};\n+use syntax::codemap::{Span, Spanned};\n+use syntax::ptr::P;\n use utils::{get_item_name, snippet, span_lint, walk_ptrs_ty};\n \n /// **What it does:** This lint checks for getting the length of something via `.len()` just to compare to zero, and suggests using `.is_empty()` where applicable."}, {"sha": "72fdba07d32de447620bf80d250f7a1d2b13b314", "filename": "src/lifetimes.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flifetimes.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,11 +1,10 @@\n-use rustc_front::hir::*;\n use reexport::*;\n use rustc::lint::*;\n-use syntax::codemap::Span;\n-use rustc_front::intravisit::{Visitor, walk_ty, walk_ty_param_bound, walk_fn_decl, walk_generics};\n use rustc::middle::def::Def;\n+use rustc_front::hir::*;\n+use rustc_front::intravisit::{Visitor, walk_ty, walk_ty_param_bound, walk_fn_decl, walk_generics};\n use std::collections::{HashSet, HashMap};\n-\n+use syntax::codemap::Span;\n use utils::{in_external_macro, span_lint};\n \n /// **What it does:** This lint checks for lifetime annotations which can be removed by relying on lifetime elision."}, {"sha": "ce2ae94cd30db8aa5caa8744c34b6b4ea9d7bd3f", "filename": "src/loops.rs", "status": "modified", "additions": 44, "deletions": 43, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -351,9 +351,9 @@ fn check_for_loop_range(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, ex\n             // linting condition: we only indexed one variable\n             if visitor.indexed.len() == 1 {\n                 let (indexed, indexed_extent) = visitor.indexed\n-                                     .into_iter()\n-                                     .next()\n-                                     .unwrap_or_else(|| unreachable!() /* len == 1 */);\n+                                                       .into_iter()\n+                                                       .next()\n+                                                       .unwrap_or_else(|| unreachable!() /* len == 1 */);\n \n                 // ensure that the indexed variable was declared before the loop, see #601\n                 let pat_extent = cx.tcx.region_maps.var_scope(pat.id);\n@@ -438,8 +438,12 @@ fn check_for_loop_reverse_range(cx: &LateContext, arg: &Expr, expr: &Expr) {\n                 // who think that this will iterate from the larger value to the\n                 // smaller value.\n                 let (sup, eq) = match (start_idx, stop_idx) {\n-                    (ConstVal::Int(start_idx), ConstVal::Int(stop_idx)) => (start_idx > stop_idx, start_idx == stop_idx),\n-                    (ConstVal::Uint(start_idx), ConstVal::Uint(stop_idx)) => (start_idx > stop_idx, start_idx == stop_idx),\n+                    (ConstVal::Int(start_idx), ConstVal::Int(stop_idx)) => {\n+                        (start_idx > stop_idx, start_idx == stop_idx)\n+                    }\n+                    (ConstVal::Uint(start_idx), ConstVal::Uint(stop_idx)) => {\n+                        (start_idx > stop_idx, start_idx == stop_idx)\n+                    }\n                     _ => (false, false),\n                 };\n \n@@ -515,26 +519,25 @@ fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n fn check_arg_type(cx: &LateContext, pat: &Pat, arg: &Expr) {\n     let ty = cx.tcx.expr_ty(arg);\n     if match_type(cx, ty, &OPTION_PATH) {\n-        span_help_and_lint(\n-            cx,\n-            FOR_LOOP_OVER_OPTION,\n-            arg.span,\n-            &format!(\"for loop over `{0}`, which is an `Option`. This is more readably written as \\\n-                      an `if let` statement.\", snippet(cx, arg.span, \"_\")),\n-            &format!(\"consider replacing `for {0} in {1}` with `if let Some({0}) = {1}`\",\n-                     snippet(cx, pat.span, \"_\"), snippet(cx, arg.span, \"_\"))\n-        );\n-    }\n-    else if match_type(cx, ty, &RESULT_PATH) {\n-        span_help_and_lint(\n-            cx,\n-            FOR_LOOP_OVER_RESULT,\n-            arg.span,\n-            &format!(\"for loop over `{0}`, which is a `Result`. This is more readably written as \\\n-                      an `if let` statement.\", snippet(cx, arg.span, \"_\")),\n-            &format!(\"consider replacing `for {0} in {1}` with `if let Ok({0}) = {1}`\",\n-                     snippet(cx, pat.span, \"_\"), snippet(cx, arg.span, \"_\"))\n-        );\n+        span_help_and_lint(cx,\n+                           FOR_LOOP_OVER_OPTION,\n+                           arg.span,\n+                           &format!(\"for loop over `{0}`, which is an `Option`. This is more readably written as an \\\n+                                     `if let` statement.\",\n+                                    snippet(cx, arg.span, \"_\")),\n+                           &format!(\"consider replacing `for {0} in {1}` with `if let Some({0}) = {1}`\",\n+                                    snippet(cx, pat.span, \"_\"),\n+                                    snippet(cx, arg.span, \"_\")));\n+    } else if match_type(cx, ty, &RESULT_PATH) {\n+        span_help_and_lint(cx,\n+                           FOR_LOOP_OVER_RESULT,\n+                           arg.span,\n+                           &format!(\"for loop over `{0}`, which is a `Result`. This is more readably written as an \\\n+                                     `if let` statement.\",\n+                                    snippet(cx, arg.span, \"_\")),\n+                           &format!(\"consider replacing `for {0} in {1}` with `if let Ok({0}) = {1}`\",\n+                                    snippet(cx, pat.span, \"_\"),\n+                                    snippet(cx, arg.span, \"_\")));\n     }\n }\n \n@@ -590,31 +593,29 @@ fn check_for_loop_over_map_kv(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Ex\n             let (pat_span, kind) = match (&pat[0].node, &pat[1].node) {\n                 (key, _) if pat_is_wild(key, body) => (&pat[1].span, \"values\"),\n                 (_, value) if pat_is_wild(value, body) => (&pat[0].span, \"keys\"),\n-                _ => return\n+                _ => return,\n             };\n \n             let ty = walk_ptrs_ty(cx.tcx.expr_ty(arg));\n             let arg_span = if let ExprAddrOf(_, ref expr) = arg.node {\n                 expr.span\n-            }\n-            else {\n+            } else {\n                 arg.span\n             };\n \n-            if match_type(cx, ty, &HASHMAP_PATH) ||\n-               match_type(cx, ty, &BTREEMAP_PATH) {\n+            if match_type(cx, ty, &HASHMAP_PATH) || match_type(cx, ty, &BTREEMAP_PATH) {\n                 span_lint_and_then(cx,\n-                          FOR_KV_MAP,\n-                          expr.span,\n-                          &format!(\"you seem to want to iterate on a map's {}\", kind),\n-                          |db| {\n-                    db.span_suggestion(expr.span,\n-                                       \"use the corresponding method\",\n-                                       format!(\"for {} in {}.{}() {{...}}\",\n-                                               snippet(cx, *pat_span, \"..\"),\n-                                               snippet(cx, arg_span, \"..\"),\n-                                               kind));\n-                });\n+                                   FOR_KV_MAP,\n+                                   expr.span,\n+                                   &format!(\"you seem to want to iterate on a map's {}\", kind),\n+                                   |db| {\n+                                       db.span_suggestion(expr.span,\n+                                                          \"use the corresponding method\",\n+                                                          format!(\"for {} in {}.{}() {{...}}\",\n+                                                                  snippet(cx, *pat_span, \"..\"),\n+                                                                  snippet(cx, arg_span, \"..\"),\n+                                                                  kind));\n+                                   });\n             }\n         }\n     }\n@@ -632,7 +633,7 @@ fn pat_is_wild(pat: &PatKind, body: &Expr) -> bool {\n             };\n             walk_expr(&mut visitor, body);\n             !visitor.used\n-        },\n+        }\n         _ => false,\n     }\n }\n@@ -647,7 +648,7 @@ impl<'a> Visitor<'a> for UsedVisitor {\n         if let ExprPath(None, ref path) = expr.node {\n             if path.segments.len() == 1 && path.segments[0].identifier == self.var {\n                 self.used = true;\n-                return\n+                return;\n             }\n         }\n "}, {"sha": "8a4e1d770dc431f3b976f65f57cca7b55ad2493c", "filename": "src/map_clone.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmap_clone.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,8 +1,10 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n use utils::{CLONE_PATH, OPTION_PATH};\n-use utils::{is_adjusted, match_path, match_trait_method, match_type, snippet, span_help_and_lint};\n-use utils::{walk_ptrs_ty, walk_ptrs_ty_depth};\n+use utils::{\n+    is_adjusted, match_path, match_trait_method, match_type, snippet, span_help_and_lint,\n+    walk_ptrs_ty, walk_ptrs_ty_depth\n+};\n \n /// **What it does:** This lint checks for mapping clone() over an iterator.\n ///"}, {"sha": "35c0dbb39502aa06c0ec1bb9843221abe3c6fdc7", "filename": "src/matches.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -7,7 +7,6 @@ use rustc_front::hir::*;\n use std::cmp::Ordering;\n use syntax::ast::LitKind;\n use syntax::codemap::Span;\n-\n use utils::{COW_PATH, OPTION_PATH, RESULT_PATH};\n use utils::{match_type, snippet, span_lint, span_note_and_lint, span_lint_and_then, in_external_macro, expr_block};\n \n@@ -139,20 +138,20 @@ fn check_single_match(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     if arms.len() == 2 &&\n        arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n        arms[1].pats.len() == 1 && arms[1].guard.is_none() {\n-           let els = if is_unit_expr(&arms[1].body) {\n-               None\n-           } else if let ExprBlock(_) = arms[1].body.node {\n-               // matches with blocks that contain statements are prettier as `if let + else`\n-               Some(&*arms[1].body)\n-           } else {\n-               // allow match arms with just expressions\n-               return;\n-           };\n-           let ty = cx.tcx.expr_ty(ex);\n-           if ty.sty != ty::TyBool || cx.current_level(MATCH_BOOL) == Allow {\n-                check_single_match_single_pattern(cx, ex, arms, expr, els);\n-                check_single_match_opt_like(cx, ex, arms, expr, ty, els);\n-           }\n+        let els = if is_unit_expr(&arms[1].body) {\n+            None\n+        } else if let ExprBlock(_) = arms[1].body.node {\n+            // matches with blocks that contain statements are prettier as `if let + else`\n+            Some(&*arms[1].body)\n+        } else {\n+            // allow match arms with just expressions\n+            return;\n+        };\n+        let ty = cx.tcx.expr_ty(ex);\n+        if ty.sty != ty::TyBool || cx.current_level(MATCH_BOOL) == Allow {\n+            check_single_match_single_pattern(cx, ex, arms, expr, els);\n+            check_single_match_opt_like(cx, ex, arms, expr, ty, els);\n+        }\n     }\n }\n \n@@ -194,11 +193,11 @@ fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr:\n     let path = match arms[1].pats[0].node {\n         PatKind::TupleStruct(ref path, Some(ref inner)) => {\n             // contains any non wildcard patterns? e.g. Err(err)\n-            if inner.iter().any(|pat| if let PatKind::Wild = pat.node { false } else { true }) {\n+            if inner.iter().any(|pat| pat.node != PatKind::Wild) {\n                 return;\n             }\n             path.to_string()\n-        },\n+        }\n         PatKind::TupleStruct(ref path, None) => path.to_string(),\n         PatKind::Ident(BindByValue(MutImmutable), ident, None) => ident.node.to_string(),\n         _ => return,"}, {"sha": "6ef779cd79e8a87331f1ea15360fbda7c0da673a", "filename": "src/methods.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,21 +1,20 @@\n use rustc::lint::*;\n-use rustc::middle::const_eval::{ConstVal, eval_const_expr_partial};\n use rustc::middle::const_eval::EvalHint::ExprTypeChecked;\n+use rustc::middle::const_eval::{ConstVal, eval_const_expr_partial};\n+use rustc::middle::cstore::CrateStore;\n use rustc::middle::subst::{Subst, TypeSpace};\n use rustc::middle::ty;\n use rustc_front::hir::*;\n use std::borrow::Cow;\n use std::{fmt, iter};\n use syntax::codemap::Span;\n use syntax::ptr::P;\n-\n use utils::{get_trait_def_id, implements_trait, in_external_macro, in_macro, match_path, match_trait_method,\n             match_type, method_chain_args, snippet, snippet_opt, span_lint, span_lint_and_then, span_note_and_lint,\n             walk_ptrs_ty, walk_ptrs_ty_depth};\n use utils::{BTREEMAP_ENTRY_PATH, DEFAULT_TRAIT_PATH, HASHMAP_ENTRY_PATH, OPTION_PATH, RESULT_PATH, STRING_PATH,\n-            VEC_PATH,};\n+            VEC_PATH};\n use utils::MethodArgs;\n-use rustc::middle::cstore::CrateStore;\n \n #[derive(Clone)]\n pub struct MethodsPass;\n@@ -439,12 +438,10 @@ impl LateLintPass for MethodsPass {\n \n                             if let Some(&ret_ty) = ret_ty {\n                                 ret_ty.walk().any(|t| t == ty)\n-                            }\n-                            else {\n+                            } else {\n                                 false\n                             }\n-                        }\n-                        else {\n+                        } else {\n                             false\n                         };\n \n@@ -961,9 +958,9 @@ impl SelfKind {\n     fn matches(&self, slf: &ExplicitSelf_, allow_value_for_ref: bool) -> bool {\n         match (self, slf) {\n             (&SelfKind::Value, &SelfValue(_)) |\n-                (&SelfKind::Ref, &SelfRegion(_, Mutability::MutImmutable, _)) |\n-                (&SelfKind::RefMut, &SelfRegion(_, Mutability::MutMutable, _)) |\n-                (&SelfKind::No, &SelfStatic) => true,\n+            (&SelfKind::Ref, &SelfRegion(_, Mutability::MutImmutable, _)) |\n+            (&SelfKind::RefMut, &SelfRegion(_, Mutability::MutMutable, _)) |\n+            (&SelfKind::No, &SelfStatic) => true,\n             (&SelfKind::Ref, &SelfValue(_)) | (&SelfKind::RefMut, &SelfValue(_)) => allow_value_for_ref,\n             (_, &SelfExplicit(ref ty, _)) => self.matches_explicit_type(ty, allow_value_for_ref),\n             _ => false,\n@@ -973,10 +970,10 @@ impl SelfKind {\n     fn matches_explicit_type(&self, ty: &Ty, allow_value_for_ref: bool) -> bool {\n         match (self, &ty.node) {\n             (&SelfKind::Value, &TyPath(..)) |\n-                (&SelfKind::Ref, &TyRptr(_, MutTy { mutbl: Mutability::MutImmutable, .. })) |\n-                (&SelfKind::RefMut, &TyRptr(_, MutTy { mutbl: Mutability::MutMutable, .. })) => true,\n+            (&SelfKind::Ref, &TyRptr(_, MutTy { mutbl: Mutability::MutImmutable, .. })) |\n+            (&SelfKind::RefMut, &TyRptr(_, MutTy { mutbl: Mutability::MutMutable, .. })) => true,\n             (&SelfKind::Ref, &TyPath(..)) |\n-                (&SelfKind::RefMut, &TyPath(..)) => allow_value_for_ref,\n+            (&SelfKind::RefMut, &TyPath(..)) => allow_value_for_ref,\n             _ => false,\n         }\n     }"}, {"sha": "0560bf15604c918ad153ae00fec59f6f91925d4a", "filename": "src/minmax.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fminmax.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,11 +1,9 @@\n+use consts::{Constant, constant_simple};\n use rustc::lint::*;\n use rustc_front::hir::*;\n-use syntax::ptr::P;\n use std::cmp::{PartialOrd, Ordering};\n-\n-use consts::{Constant, constant_simple};\n+use syntax::ptr::P;\n use utils::{match_def_path, span_lint};\n-use self::MinMax::{Min, Max};\n \n /// **What it does:** This lint checks for expressions where `std::cmp::min` and `max` are used to clamp values, but switched so that the result is constant.\n ///\n@@ -36,7 +34,7 @@ impl LateLintPass for MinMaxPass {\n                     return;\n                 }\n                 match (outer_max, outer_c.partial_cmp(&inner_c)) {\n-                    (_, None) | (Max, Some(Ordering::Less)) | (Min, Some(Ordering::Greater)) => (),\n+                    (_, None) | (MinMax::Max, Some(Ordering::Less)) | (MinMax::Min, Some(Ordering::Greater)) => (),\n                     _ => {\n                         span_lint(cx, MIN_MAX, expr.span, \"this min/max combination leads to constant result\");\n                     }\n@@ -58,9 +56,9 @@ fn min_max<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(MinMax, Constant, &'\n             let def_id = cx.tcx.def_map.borrow()[&path.id].def_id();\n \n             if match_def_path(cx, def_id, &[\"core\", \"cmp\", \"min\"]) {\n-                fetch_const(args, Min)\n+                fetch_const(args, MinMax::Min)\n             } else if match_def_path(cx, def_id, &[\"core\", \"cmp\", \"max\"]) {\n-                fetch_const(args, Max)\n+                fetch_const(args, MinMax::Max)\n             } else {\n                 None\n             }"}, {"sha": "fae780e4ced01396c2d4874181591f6cd7e28874", "filename": "src/misc.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,15 +1,14 @@\n+use reexport::*;\n use rustc::lint::*;\n-use syntax::ptr::P;\n+use rustc::middle::const_eval::ConstVal::Float;\n+use rustc::middle::const_eval::EvalHint::ExprTypeChecked;\n+use rustc::middle::const_eval::eval_const_expr_partial;\n+use rustc::middle::ty;\n use rustc_front::hir::*;\n-use reexport::*;\n+use rustc_front::intravisit::FnKind;\n use rustc_front::util::{is_comparison_binop, binop_to_string};\n use syntax::codemap::{Span, Spanned, ExpnFormat};\n-use rustc_front::intravisit::FnKind;\n-use rustc::middle::ty;\n-use rustc::middle::const_eval::ConstVal::Float;\n-use rustc::middle::const_eval::eval_const_expr_partial;\n-use rustc::middle::const_eval::EvalHint::ExprTypeChecked;\n-\n+use syntax::ptr::P;\n use utils::{get_item_name, match_path, snippet, get_parent_expr, span_lint};\n use utils::{span_lint_and_then, walk_ptrs_ty, is_integer_literal, implements_trait};\n "}, {"sha": "604e60021037f3b8e052371a7e1f40db0dbea41b", "filename": "src/misc_early.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc_early.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,11 +1,8 @@\n use rustc::lint::*;\n-\n use std::collections::HashMap;\n-\n use syntax::ast::*;\n use syntax::codemap::Span;\n use syntax::visit::FnKind;\n-\n use utils::{span_lint, span_help_and_lint};\n \n /// **What it does:** This lint checks for structure field patterns bound to wildcards."}, {"sha": "c8f86330b938624d1e3321dd368021c18c93fa2e", "filename": "src/mut_mut.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmut_mut.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,7 +1,6 @@\n use rustc::lint::*;\n-use rustc_front::hir::*;\n use rustc::middle::ty::{TypeAndMut, TyRef};\n-\n+use rustc_front::hir::*;\n use utils::{in_external_macro, span_lint};\n \n /// **What it does:** This lint checks for instances of `mut mut` references."}, {"sha": "0e5b038f27d355412f20fcf0f6ec50a9187faac6", "filename": "src/mut_reference.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmut_reference.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,8 +1,8 @@\n use rustc::lint::*;\n-use rustc_front::hir::*;\n-use utils::span_lint;\n use rustc::middle::ty::{TypeAndMut, TypeVariants, MethodCall, TyS};\n+use rustc_front::hir::*;\n use syntax::ptr::P;\n+use utils::span_lint;\n \n /// **What it does:** This lint detects giving a mutable reference to a function that only requires an immutable reference.\n ///"}, {"sha": "c8f5e3c79190b38409956c436ee43b38e7c44cd1", "filename": "src/mutex_atomic.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmutex_atomic.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -3,12 +3,10 @@\n //! This lint is **warn** by default\n \n use rustc::lint::{LintPass, LintArray, LateLintPass, LateContext};\n+use rustc::middle::subst::ParamSpace;\n+use rustc::middle::ty;\n use rustc_front::hir::Expr;\n-\n use syntax::ast;\n-use rustc::middle::ty;\n-use rustc::middle::subst::ParamSpace;\n-\n use utils::{span_lint, MUTEX_PATH, match_type};\n \n /// **What it does:** This lint checks for usages of `Mutex<X>` where an atomic will do."}, {"sha": "625f8b0ca7832993488ac67f3563b071142363f3", "filename": "src/needless_bool.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fneedless_bool.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -4,10 +4,8 @@\n \n use rustc::lint::*;\n use rustc_front::hir::*;\n-\n use syntax::ast::LitKind;\n use syntax::codemap::Spanned;\n-\n use utils::{span_lint, span_lint_and_then, snippet};\n \n /// **What it does:** This lint checks for expressions of the form `if c { true } else { false }` (or vice versa) and suggest using the condition directly."}, {"sha": "f80ac48320ec995e5dc232e1024ddcc806be38a0", "filename": "src/needless_features.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fneedless_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fneedless_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fneedless_features.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -4,7 +4,6 @@\n \n use rustc::lint::*;\n use rustc_front::hir::*;\n-\n use utils::span_lint;\n use utils;\n "}, {"sha": "e335946915045ebb1d2df5efccedea4f1b406f97", "filename": "src/needless_update.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fneedless_update.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,7 +1,6 @@\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::middle::ty::TyStruct;\n use rustc_front::hir::{Expr, ExprStruct};\n-\n use utils::span_lint;\n \n /// **What it does:** This lint warns on needlessly including a base struct on update when all fields are changed anyway."}, {"sha": "65dfeb0d4be6ce0cb696fdfc54df1a0abc8b4178", "filename": "src/no_effect.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fno_effect.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,10 +1,7 @@\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::middle::def::Def;\n-use rustc_front::hir::{Expr, Expr_};\n-use rustc_front::hir::{Stmt, StmtSemi};\n-\n-use utils::in_macro;\n-use utils::span_lint;\n+use rustc_front::hir::{Expr, Expr_, Stmt, StmtSemi};\n+use utils::{in_macro, span_lint};\n \n /// **What it does:** This lint checks for statements which have no effect.\n ///"}, {"sha": "e3f61afcf1c80465a9ade135faaea2cc62256fc4", "filename": "src/open_options.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fopen_options.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,8 +1,8 @@\n use rustc::lint::*;\n use rustc_front::hir::{Expr, ExprMethodCall, ExprLit};\n-use utils::{walk_ptrs_ty_depth, match_type, span_lint, OPEN_OPTIONS_PATH};\n-use syntax::codemap::{Span, Spanned};\n use syntax::ast::LitKind;\n+use syntax::codemap::{Span, Spanned};\n+use utils::{walk_ptrs_ty_depth, match_type, span_lint, OPEN_OPTIONS_PATH};\n \n /// **What it does:** This lint checks for duplicate open options as well as combinations that make no sense.\n ///"}, {"sha": "60a3ce1a461eb5ecfac7dfe2d5837937c6766f80", "filename": "src/panic.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpanic.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,7 +1,6 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n use syntax::ast::LitKind;\n-\n use utils::{span_lint, in_external_macro, match_path, BEGIN_UNWIND};\n \n /// **What it does:** This lint checks for missing parameters in `panic!`."}, {"sha": "7e24f55d1b457a3d37a17ba54ad5c09d85633328", "filename": "src/precedence.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprecedence.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,7 +1,6 @@\n use rustc::lint::*;\n-use syntax::codemap::Spanned;\n use syntax::ast::*;\n-\n+use syntax::codemap::Spanned;\n use utils::{span_lint, snippet};\n \n /// **What it does:** This lint checks for operations where precedence may be unclear and suggests to add parentheses. Currently it catches the following:"}, {"sha": "d7d83bfb437fe4d531278c36d7fa781327747594", "filename": "src/print.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprint.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,6 +1,6 @@\n+use rustc::front::map::Node::{NodeItem, NodeImplItem};\n use rustc::lint::*;\n use rustc_front::hir::*;\n-use rustc::front::map::Node::{NodeItem, NodeImplItem};\n use utils::{FMT_ARGUMENTV1_NEW_PATH, DEBUG_FMT_METHOD_PATH, IO_PRINT_PATH};\n use utils::{is_expn_of, match_path, span_lint};\n "}, {"sha": "c02e5609b8c786a82b04f125e2e93a4d0efc07a5", "filename": "src/ptr_arg.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fptr_arg.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -2,13 +2,12 @@\n //!\n //! This lint is **warn** by default\n \n-use rustc::lint::*;\n-use rustc_front::hir::*;\n use rustc::front::map::NodeItem;\n+use rustc::lint::*;\n use rustc::middle::ty;\n-\n-use utils::{span_lint, match_type};\n+use rustc_front::hir::*;\n use utils::{STRING_PATH, VEC_PATH};\n+use utils::{span_lint, match_type};\n \n /// **What it does:** This lint checks for function arguments of type `&String` or `&Vec` unless the references are mutable.\n ///"}, {"sha": "f58b6319d5773452d0fa10fb071b44b817ab5e73", "filename": "src/regex.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fregex.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,13 +1,13 @@\n use regex_syntax;\n-use std::error::Error;\n+use rustc::lint::*;\n+use rustc::middle::const_eval::EvalHint::ExprTypeChecked;\n+use rustc::middle::const_eval::{eval_const_expr_partial, ConstVal};\n+use rustc_front::hir::*;\n use std::collections::HashSet;\n+use std::error::Error;\n use syntax::ast::{LitKind, NodeId};\n use syntax::codemap::{Span, BytePos};\n use syntax::parse::token::InternedString;\n-use rustc_front::hir::*;\n-use rustc::middle::const_eval::{eval_const_expr_partial, ConstVal};\n-use rustc::middle::const_eval::EvalHint::ExprTypeChecked;\n-use rustc::lint::*;\n \n use utils::{is_expn_of, match_path, match_type, REGEX_NEW_PATH, span_lint, span_help_and_lint};\n \n@@ -54,7 +54,7 @@ declare_lint! {\n #[derive(Clone, Default)]\n pub struct RegexPass {\n     spans: HashSet<Span>,\n-    last: Option<NodeId>\n+    last: Option<NodeId>,\n }\n \n impl LintPass for RegexPass {\n@@ -86,10 +86,10 @@ impl LateLintPass for RegexPass {\n             self.last = Some(block.id);\n         }}\n     }\n-    \n+\n     fn check_block_post(&mut self, _: &LateContext, block: &Block) {\n         if self.last.map_or(false, |id| block.id == id) {\n-             self.last = None;\n+            self.last = None;\n         }\n     }\n \n@@ -145,15 +145,15 @@ impl LateLintPass for RegexPass {\n fn str_span(base: Span, s: &str, c: usize) -> Span {\n     let lo = match s.char_indices().nth(c) {\n         Some((b, _)) => base.lo + BytePos(b as u32),\n-        _ => base.hi\n+        _ => base.hi,\n     };\n     Span{ lo: lo, hi: lo, ..base }\n }\n \n fn const_str(cx: &LateContext, e: &Expr) -> Option<InternedString> {\n     match eval_const_expr_partial(cx.tcx, e, ExprTypeChecked, None) {\n         Ok(ConstVal::Str(r)) => Some(r),\n-        _ => None\n+        _ => None,\n     }\n }\n \n@@ -165,20 +165,21 @@ fn is_trivial_regex(s: &regex_syntax::Expr) -> Option<&'static str> {\n         Expr::Literal {..} => Some(\"consider using `str::contains`\"),\n         Expr::Concat(ref exprs) => {\n             match exprs.len() {\n-                2 => match (&exprs[0], &exprs[1]) {\n-                    (&Expr::StartText, &Expr::EndText) => Some(\"consider using `str::is_empty`\"),\n-                    (&Expr::StartText, &Expr::Literal {..}) => Some(\"consider using `str::starts_with`\"),\n-                    (&Expr::Literal {..}, &Expr::EndText) => Some(\"consider using `str::ends_with`\"),\n-                    _ => None,\n-                },\n+                2 => {\n+                    match (&exprs[0], &exprs[1]) {\n+                        (&Expr::StartText, &Expr::EndText) => Some(\"consider using `str::is_empty`\"),\n+                        (&Expr::StartText, &Expr::Literal {..}) => Some(\"consider using `str::starts_with`\"),\n+                        (&Expr::Literal {..}, &Expr::EndText) => Some(\"consider using `str::ends_with`\"),\n+                        _ => None,\n+                    }\n+                }\n                 3 => {\n                     if let (&Expr::StartText, &Expr::Literal {..}, &Expr::EndText) = (&exprs[0], &exprs[1], &exprs[2]) {\n                         Some(\"consider using `==` on `str`s\")\n-                    }\n-                    else {\n+                    } else {\n                         None\n                     }\n-                },\n+                }\n                 _ => None,\n             }\n         }"}, {"sha": "43ea378017333fd92089587a84b11eb328127980", "filename": "src/returns.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Freturns.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,6 +1,5 @@\n use rustc::lint::*;\n use syntax::ast::*;\n-// use reexport::*;\n use syntax::codemap::{Span, Spanned};\n use syntax::visit::FnKind;\n "}, {"sha": "baf5c9b8872c6f67c5a7a8c5523347c0e222771b", "filename": "src/shadow.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshadow.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,12 +1,10 @@\n-use std::ops::Deref;\n-use rustc_front::hir::*;\n use reexport::*;\n-use syntax::codemap::Span;\n-use rustc_front::intravisit::{Visitor, FnKind};\n-\n use rustc::lint::*;\n use rustc::middle::def::Def;\n-\n+use rustc_front::hir::*;\n+use rustc_front::intravisit::{Visitor, FnKind};\n+use std::ops::Deref;\n+use syntax::codemap::Span;\n use utils::{is_from_for_desugar, in_external_macro, snippet, span_lint, span_note_and_lint, DiagnosticWrapper};\n \n /// **What it does:** This lint checks for bindings that shadow other bindings already in scope, while just changing reference level or mutability."}, {"sha": "fdba6302a4676e66b6b08d6bf30db7e4e420d56c", "filename": "src/strings.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstrings.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -6,10 +6,9 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n use syntax::codemap::Spanned;\n-\n-use utils::{match_type, span_lint, walk_ptrs_ty, get_parent_expr};\n-use utils::SpanlessEq;\n use utils::STRING_PATH;\n+use utils::SpanlessEq;\n+use utils::{match_type, span_lint, walk_ptrs_ty, get_parent_expr};\n \n /// **What it does:** This lint matches code of the form `x = x + y` (without `let`!).\n ///"}, {"sha": "c945fd7148e7b410ec5eb384d12f4c177f9c52c3", "filename": "src/temporary_assignment.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftemporary_assignment.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,6 +1,5 @@\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc_front::hir::{Expr, ExprAssign, ExprField, ExprStruct, ExprTup, ExprTupField};\n-\n use utils::is_adjusted;\n use utils::span_lint;\n "}, {"sha": "248aab32baa4bd6833b9556d284b4d6ba32d36c1", "filename": "src/types.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,13 +1,12 @@\n+use reexport::*;\n use rustc::lint::*;\n+use rustc::middle::const_eval;\n+use rustc::middle::ty;\n use rustc_front::hir::*;\n-use reexport::*;\n-use rustc_front::util::{is_comparison_binop, binop_to_string};\n-use syntax::codemap::Span;\n use rustc_front::intravisit::{FnKind, Visitor, walk_ty};\n-use rustc::middle::ty;\n-use rustc::middle::const_eval;\n+use rustc_front::util::{is_comparison_binop, binop_to_string};\n use syntax::ast::{IntTy, UintTy, FloatTy};\n-\n+use syntax::codemap::Span;\n use utils::*;\n \n /// Handles all the linting of funky types\n@@ -618,7 +617,7 @@ enum AbsurdComparisonResult {\n }\n \n fn detect_absurd_comparison<'a>(cx: &LateContext, op: BinOp_, lhs: &'a Expr, rhs: &'a Expr)\n-                            -> Option<(ExtremeExpr<'a>, AbsurdComparisonResult)> {\n+                                -> Option<(ExtremeExpr<'a>, AbsurdComparisonResult)> {\n     use types::ExtremeType::*;\n     use types::AbsurdComparisonResult::*;\n     type Extr<'a> = ExtremeExpr<'a>;\n@@ -704,7 +703,10 @@ fn detect_extreme_expr<'a>(cx: &LateContext, expr: &'a Expr) -> Option<ExtremeEx\n \n         _ => return None,\n     };\n-    Some(ExtremeExpr { which: which, expr: expr })\n+    Some(ExtremeExpr {\n+        which: which,\n+        expr: expr,\n+    })\n }\n \n impl LateLintPass for AbsurdExtremeComparisons {\n@@ -721,16 +723,20 @@ impl LateLintPass for AbsurdExtremeComparisons {\n                     let conclusion = match result {\n                         AlwaysFalse => \"this comparison is always false\".to_owned(),\n                         AlwaysTrue => \"this comparison is always true\".to_owned(),\n-                        InequalityImpossible =>\n-                            format!(\"the case where the two sides are not equal never occurs, \\\n-                                     consider using {} == {} instead\",\n+                        InequalityImpossible => {\n+                            format!(\"the case where the two sides are not equal never occurs, consider using {} == {} \\\n+                                     instead\",\n                                     snippet(cx, lhs.span, \"lhs\"),\n-                                    snippet(cx, rhs.span, \"rhs\")),\n+                                    snippet(cx, rhs.span, \"rhs\"))\n+                        }\n                     };\n \n                     let help = format!(\"because {} is the {} value for this type, {}\",\n                                        snippet(cx, culprit.expr.span, \"x\"),\n-                                       match culprit.which { Minimum => \"minimum\", Maximum => \"maximum\" },\n+                                       match culprit.which {\n+                                           Minimum => \"minimum\",\n+                                           Maximum => \"maximum\",\n+                                       },\n                                        conclusion);\n \n                     span_help_and_lint(cx, ABSURD_EXTREME_COMPARISONS, expr.span, msg, &help);"}, {"sha": "0f21822ea08f5e6886bba3b04dac59c5ace726cf", "filename": "src/unicode.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Funicode.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,11 +1,8 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n-use syntax::codemap::Span;\n-\n use syntax::ast::LitKind;\n-\n+use syntax::codemap::Span;\n use unicode_normalization::UnicodeNormalization;\n-\n use utils::{snippet, span_help_and_lint};\n \n /// **What it does:** This lint checks for the unicode zero-width space in the code."}, {"sha": "faa2082b7d0a3f3a2d54d0e0e23ca91c1a3f5334", "filename": "src/utils/hir.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fhir.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -19,11 +19,17 @@ pub struct SpanlessEq<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n     pub fn new(cx: &'a LateContext<'a, 'tcx>) -> Self {\n-        SpanlessEq { cx: cx, ignore_fn: false }\n+        SpanlessEq {\n+            cx: cx,\n+            ignore_fn: false,\n+        }\n     }\n \n     pub fn ignore_fn(self) -> Self {\n-        SpanlessEq { cx: self.cx, ignore_fn: true }\n+        SpanlessEq {\n+            cx: self.cx,\n+            ignore_fn: true,\n+        }\n     }\n \n     /// Check whether two statements are the same.\n@@ -40,15 +46,15 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n                 }\n             }\n             (&StmtExpr(ref l, _), &StmtExpr(ref r, _)) |\n-                (&StmtSemi(ref l, _), &StmtSemi(ref r, _)) => self.eq_expr(l, r),\n+            (&StmtSemi(ref l, _), &StmtSemi(ref r, _)) => self.eq_expr(l, r),\n             _ => false,\n         }\n     }\n \n     /// Check whether two blocks are the same.\n     pub fn eq_block(&self, left: &Block, right: &Block) -> bool {\n         over(&left.stmts, &right.stmts, |l, r| self.eq_stmt(l, r)) &&\n-            both(&left.expr, &right.expr, |l, r| self.eq_expr(l, r))\n+        both(&left.expr, &right.expr, |l, r| self.eq_expr(l, r))\n     }\n \n     // ok, it\u2019s a big function, but mostly one big match with simples cases\n@@ -77,9 +83,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             (&ExprAssignOp(ref lo, ref ll, ref lr), &ExprAssignOp(ref ro, ref rl, ref rr)) => {\n                 lo.node == ro.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n             }\n-            (&ExprBlock(ref l), &ExprBlock(ref r)) => {\n-                self.eq_block(l, r)\n-            }\n+            (&ExprBlock(ref l), &ExprBlock(ref r)) => self.eq_block(l, r),\n             (&ExprBinary(lop, ref ll, ref lr), &ExprBinary(rop, ref rl, ref rr)) => {\n                 lop.node == rop.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n             }\n@@ -267,7 +271,10 @@ pub struct SpanlessHash<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n     pub fn new(cx: &'a LateContext<'a, 'tcx>) -> Self {\n-        SpanlessHash { cx: cx, s: SipHasher::new() }\n+        SpanlessHash {\n+            cx: cx,\n+            s: SipHasher::new(),\n+        }\n     }\n \n     pub fn finish(&self) -> u64 {\n@@ -389,7 +396,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 let c: fn(_) -> _ = ExprLit;\n                 c.hash(&mut self.s);\n                 l.hash(&mut self.s);\n-            },\n+            }\n             ExprLoop(ref b, ref i) => {\n                 let c: fn(_, _) -> _ = ExprLoop;\n                 c.hash(&mut self.s);\n@@ -466,7 +473,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 let c: fn(_) -> _ = ExprTup;\n                 c.hash(&mut self.s);\n                 self.hash_exprs(tup);\n-            },\n+            }\n             ExprTupField(ref le, li) => {\n                 let c: fn(_, _) -> _ = ExprTupField;\n                 c.hash(&mut self.s);\n@@ -491,7 +498,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 c.hash(&mut self.s);\n \n                 self.hash_exprs(v);\n-            },\n+            }\n             ExprWhile(ref cond, ref b, l) => {\n                 let c: fn(_, _, _) -> _ = ExprWhile;\n                 c.hash(&mut self.s);"}, {"sha": "a8708eb8f7f3d9ceae57a488d3fb3e81e8a147f3", "filename": "src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fmod.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -9,7 +9,7 @@ use std::borrow::Cow;\n use std::mem;\n use std::ops::{Deref, DerefMut};\n use std::str::FromStr;\n-use syntax::ast::{LitKind, self};\n+use syntax::ast::{self, LitKind};\n use syntax::codemap::{ExpnInfo, Span, ExpnFormat};\n use syntax::errors::DiagnosticBuilder;\n use syntax::ptr::P;"}, {"sha": "1d119b05176212fd0ac57d99f35fac23a51d706b", "filename": "src/zero_div_zero.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b753e77cbe175fc6e336387029290e9d19f1243a/src%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fzero_div_zero.rs?ref=b753e77cbe175fc6e336387029290e9d19f1243a", "patch": "@@ -1,8 +1,7 @@\n+use consts::{Constant, constant_simple, FloatWidth};\n use rustc::lint::*;\n use rustc_front::hir::*;\n-\n use utils::span_help_and_lint;\n-use consts::{Constant, constant_simple, FloatWidth};\n \n /// `ZeroDivZeroPass` is a pass that checks for a binary expression that consists\n /// `of 0.0/0.0`, which is always NaN. It is more clear to replace instances of"}]}