{"sha": "b0006dff1041f0eea718ca29607cd6ec372e4e30", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwMDA2ZGZmMTA0MWYwZWVhNzE4Y2EyOTYwN2NkNmVjMzcyZTRlMzA=", "commit": {"author": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-09-05T16:15:28Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-09-06T15:02:25Z"}, "message": "A few cosmetic improvements to code & comments in liballoc and libcore", "tree": {"sha": "de6d8a0d438052c300a561078082bb1f2d62c203", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de6d8a0d438052c300a561078082bb1f2d62c203"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0006dff1041f0eea718ca29607cd6ec372e4e30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0006dff1041f0eea718ca29607cd6ec372e4e30", "html_url": "https://github.com/rust-lang/rust/commit/b0006dff1041f0eea718ca29607cd6ec372e4e30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0006dff1041f0eea718ca29607cd6ec372e4e30/comments", "author": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "html_url": "https://github.com/rust-lang/rust/commit/1fb3c4ec7ca37d33bd1e68cce669d171c2752615"}], "stats": {"total": 220, "additions": 109, "deletions": 111}, "files": [{"sha": "ecb5948f11b363447d0738106c8175be60e06346", "filename": "src/liballoc/collections/linked_list/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0006dff1041f0eea718ca29607cd6ec372e4e30/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0006dff1041f0eea718ca29607cd6ec372e4e30/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs?ref=b0006dff1041f0eea718ca29607cd6ec372e4e30", "patch": "@@ -102,8 +102,8 @@ fn test_append() {\n         assert_eq!(m.pop_front(), Some(elt))\n     }\n     assert_eq!(n.len(), 0);\n-    // let's make sure it's working properly, since we\n-    // did some direct changes to private members\n+    // Let's make sure it's working properly, since we\n+    // did some direct changes to private members.\n     n.push_back(3);\n     assert_eq!(n.len(), 1);\n     assert_eq!(n.pop_front(), Some(3));"}, {"sha": "f1c5904afe6fcde5822fffdc15a7051ee6d84064", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 74, "deletions": 76, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/b0006dff1041f0eea718ca29607cd6ec372e4e30/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0006dff1041f0eea718ca29607cd6ec372e4e30/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=b0006dff1041f0eea718ca29607cd6ec372e4e30", "patch": "@@ -19,26 +19,26 @@ mod tests;\n /// involved. This type is excellent for building your own data structures like Vec and VecDeque.\n /// In particular:\n ///\n-/// * Produces Unique::empty() on zero-sized types\n-/// * Produces Unique::empty() on zero-length allocations\n-/// * Catches all overflows in capacity computations (promotes them to \"capacity overflow\" panics)\n-/// * Guards against 32-bit systems allocating more than isize::MAX bytes\n-/// * Guards against overflowing your length\n-/// * Aborts on OOM or calls handle_alloc_error as applicable\n-/// * Avoids freeing Unique::empty()\n-/// * Contains a ptr::Unique and thus endows the user with all related benefits\n+/// * Produces `Unique::empty()` on zero-sized types.\n+/// * Produces `Unique::empty()` on zero-length allocations.\n+/// * Catches all overflows in capacity computations (promotes them to \"capacity overflow\" panics).\n+/// * Guards against 32-bit systems allocating more than isize::MAX bytes.\n+/// * Guards against overflowing your length.\n+/// * Aborts on OOM or calls `handle_alloc_error` as applicable.\n+/// * Avoids freeing `Unique::empty()`.\n+/// * Contains a `ptr::Unique` and thus endows the user with all related benefits.\n ///\n /// This type does not in anyway inspect the memory that it manages. When dropped it *will*\n-/// free its memory, but it *won't* try to Drop its contents. It is up to the user of RawVec\n-/// to handle the actual things *stored* inside of a RawVec.\n+/// free its memory, but it *won't* try to drop its contents. It is up to the user of `RawVec`\n+/// to handle the actual things *stored* inside of a `RawVec`.\n ///\n-/// Note that a RawVec always forces its capacity to be usize::MAX for zero-sized types.\n-/// This enables you to use capacity growing logic catch the overflows in your length\n+/// Note that a `RawVec` always forces its capacity to be `usize::MAX` for zero-sized types.\n+/// This enables you to use capacity-growing logic catch the overflows in your length\n /// that might occur with zero-sized types.\n ///\n-/// However this means that you need to be careful when round-tripping this type\n-/// with a `Box<[T]>`: `capacity()` won't yield the len. However `with_capacity`,\n-/// `shrink_to_fit`, and `from_box` will actually set RawVec's private capacity\n+/// The above means that you need to be careful when round-tripping this type with a\n+/// `Box<[T]>`, since `capacity()` won't yield the length. However, `with_capacity`,\n+/// `shrink_to_fit`, and `from_box` will actually set `RawVec`'s private capacity\n /// field. This allows zero-sized types to not be special-cased by consumers of\n /// this type.\n #[allow(missing_debug_implementations)]\n@@ -49,14 +49,14 @@ pub struct RawVec<T, A: Alloc = Global> {\n }\n \n impl<T, A: Alloc> RawVec<T, A> {\n-    /// Like `new` but parameterized over the choice of allocator for\n-    /// the returned RawVec.\n+    /// Like `new`, but parameterized over the choice of allocator for\n+    /// the returned `RawVec`.\n     pub const fn new_in(a: A) -> Self {\n-        // !0 is usize::MAX. This branch should be stripped at compile time.\n-        // FIXME(mark-i-m): use this line when `if`s are allowed in `const`\n+        // `!0` is `usize::MAX`. This branch should be stripped at compile time.\n+        // FIXME(mark-i-m): use this line when `if`s are allowed in `const`:\n         //let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };\n \n-        // Unique::empty() doubles as \"unallocated\" and \"zero-sized allocation\"\n+        // `Unique::empty()` doubles as \"unallocated\" and \"zero-sized allocation\".\n         RawVec {\n             ptr: Unique::empty(),\n             // FIXME(mark-i-m): use `cap` when ifs are allowed in const\n@@ -65,15 +65,15 @@ impl<T, A: Alloc> RawVec<T, A> {\n         }\n     }\n \n-    /// Like `with_capacity` but parameterized over the choice of\n-    /// allocator for the returned RawVec.\n+    /// Like `with_capacity`, but parameterized over the choice of\n+    /// allocator for the returned `RawVec`.\n     #[inline]\n     pub fn with_capacity_in(capacity: usize, a: A) -> Self {\n         RawVec::allocate_in(capacity, false, a)\n     }\n \n-    /// Like `with_capacity_zeroed` but parameterized over the choice\n-    /// of allocator for the returned RawVec.\n+    /// Like `with_capacity_zeroed`, but parameterized over the choice\n+    /// of allocator for the returned `RawVec`.\n     #[inline]\n     pub fn with_capacity_zeroed_in(capacity: usize, a: A) -> Self {\n         RawVec::allocate_in(capacity, true, a)\n@@ -86,7 +86,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             let alloc_size = capacity.checked_mul(elem_size).unwrap_or_else(|| capacity_overflow());\n             alloc_guard(alloc_size).unwrap_or_else(|_| capacity_overflow());\n \n-            // handles ZSTs and `capacity = 0` alike\n+            // Handles ZSTs and `capacity == 0` alike.\n             let ptr = if alloc_size == 0 {\n                 NonNull::<T>::dangling()\n             } else {\n@@ -113,20 +113,20 @@ impl<T, A: Alloc> RawVec<T, A> {\n }\n \n impl<T> RawVec<T, Global> {\n-    /// Creates the biggest possible RawVec (on the system heap)\n-    /// without allocating. If T has positive size, then this makes a\n-    /// RawVec with capacity 0. If T has 0 size, then it makes a\n-    /// RawVec with capacity `usize::MAX`. Useful for implementing\n+    /// Creates the biggest possible `RawVec` (on the system heap)\n+    /// without allocating. If `T` has positive size, then this makes a\n+    /// `RawVec` with capacity `0`. If `T` is zero-sized, then it makes a\n+    /// `RawVec` with capacity `usize::MAX`. Useful for implementing\n     /// delayed allocation.\n     pub const fn new() -> Self {\n         Self::new_in(Global)\n     }\n \n-    /// Creates a RawVec (on the system heap) with exactly the\n+    /// Creates a `RawVec` (on the system heap) with exactly the\n     /// capacity and alignment requirements for a `[T; capacity]`. This is\n-    /// equivalent to calling RawVec::new when `capacity` is 0 or T is\n+    /// equivalent to calling `RawVec::new` when `capacity` is `0` or `T` is\n     /// zero-sized. Note that if `T` is zero-sized this means you will\n-    /// *not* get a RawVec with the requested capacity!\n+    /// *not* get a `RawVec` with the requested capacity.\n     ///\n     /// # Panics\n     ///\n@@ -136,27 +136,27 @@ impl<T> RawVec<T, Global> {\n     ///\n     /// # Aborts\n     ///\n-    /// Aborts on OOM\n+    /// Aborts on OOM.\n     #[inline]\n     pub fn with_capacity(capacity: usize) -> Self {\n         RawVec::allocate_in(capacity, false, Global)\n     }\n \n-    /// Like `with_capacity` but guarantees the buffer is zeroed.\n+    /// Like `with_capacity`, but guarantees the buffer is zeroed.\n     #[inline]\n     pub fn with_capacity_zeroed(capacity: usize) -> Self {\n         RawVec::allocate_in(capacity, true, Global)\n     }\n }\n \n impl<T, A: Alloc> RawVec<T, A> {\n-    /// Reconstitutes a RawVec from a pointer, capacity, and allocator.\n+    /// Reconstitutes a `RawVec` from a pointer, capacity, and allocator.\n     ///\n     /// # Undefined Behavior\n     ///\n-    /// The ptr must be allocated (via the given allocator `a`), and with the given capacity. The\n-    /// capacity cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n-    /// If the ptr and capacity come from a RawVec created via `a`, then this is guaranteed.\n+    /// The `ptr` must be allocated (via the given allocator `a`), and with the given `capacity`.\n+    /// The `capacity` cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n+    /// If the `ptr` and `capacity` come from a `RawVec` created via `a`, then this is guaranteed.\n     pub unsafe fn from_raw_parts_in(ptr: *mut T, capacity: usize, a: A) -> Self {\n         RawVec {\n             ptr: Unique::new_unchecked(ptr),\n@@ -167,13 +167,13 @@ impl<T, A: Alloc> RawVec<T, A> {\n }\n \n impl<T> RawVec<T, Global> {\n-    /// Reconstitutes a RawVec from a pointer, capacity.\n+    /// Reconstitutes a `RawVec` from a pointer and capacity.\n     ///\n     /// # Undefined Behavior\n     ///\n-    /// The ptr must be allocated (on the system heap), and with the given capacity. The\n-    /// capacity cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n-    /// If the ptr and capacity come from a RawVec, then this is guaranteed.\n+    /// The `ptr` must be allocated (on the system heap), and with the given `capacity`.\n+    /// Th `capacity` cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n+    /// If the `ptr` and `capacity` come from a `RawVec`, then this is guaranteed.\n     pub unsafe fn from_raw_parts(ptr: *mut T, capacity: usize) -> Self {\n         RawVec {\n             ptr: Unique::new_unchecked(ptr),\n@@ -194,7 +194,7 @@ impl<T> RawVec<T, Global> {\n \n impl<T, A: Alloc> RawVec<T, A> {\n     /// Gets a raw pointer to the start of the allocation. Note that this is\n-    /// Unique::empty() if `capacity = 0` or T is zero-sized. In the former case, you must\n+    /// `Unique::empty()` if `capacity == 0` or `T` is zero-sized. In the former case, you must\n     /// be careful.\n     pub fn ptr(&self) -> *mut T {\n         self.ptr.as_ptr()\n@@ -212,12 +212,12 @@ impl<T, A: Alloc> RawVec<T, A> {\n         }\n     }\n \n-    /// Returns a shared reference to the allocator backing this RawVec.\n+    /// Returns a shared reference to the allocator backing this `RawVec`.\n     pub fn alloc(&self) -> &A {\n         &self.a\n     }\n \n-    /// Returns a mutable reference to the allocator backing this RawVec.\n+    /// Returns a mutable reference to the allocator backing this `RawVec`.\n     pub fn alloc_mut(&mut self) -> &mut A {\n         &mut self.a\n     }\n@@ -247,7 +247,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     ///\n     /// # Panics\n     ///\n-    /// * Panics if T is zero-sized on the assumption that you managed to exhaust\n+    /// * Panics if `T` is zero-sized on the assumption that you managed to exhaust\n     ///   all `usize::MAX` slots in your imaginary buffer.\n     /// * Panics on 32-bit platforms if the requested capacity exceeds\n     ///   `isize::MAX` bytes.\n@@ -290,20 +290,20 @@ impl<T, A: Alloc> RawVec<T, A> {\n         unsafe {\n             let elem_size = mem::size_of::<T>();\n \n-            // since we set the capacity to usize::MAX when elem_size is\n-            // 0, getting to here necessarily means the RawVec is overfull.\n+            // Since we set the capacity to `usize::MAX` when `elem_size` is\n+            // 0, getting to here necessarily means the `RawVec` is overfull.\n             assert!(elem_size != 0, \"capacity overflow\");\n \n             let (new_cap, uniq) = match self.current_layout() {\n                 Some(cur) => {\n                     // Since we guarantee that we never allocate more than\n-                    // isize::MAX bytes, `elem_size * self.cap <= isize::MAX` as\n+                    // `isize::MAX` bytes, `elem_size * self.cap <= isize::MAX` as\n                     // a precondition, so this can't overflow. Additionally the\n                     // alignment will never be too large as to \"not be\n                     // satisfiable\", so `Layout::from_size_align` will always\n                     // return `Some`.\n                     //\n-                    // tl;dr; we bypass runtime checks due to dynamic assertions\n+                    // TL;DR, we bypass runtime checks due to dynamic assertions\n                     // in this module, allowing us to use\n                     // `from_size_align_unchecked`.\n                     let new_cap = 2 * self.cap;\n@@ -320,8 +320,8 @@ impl<T, A: Alloc> RawVec<T, A> {\n                     }\n                 }\n                 None => {\n-                    // skip to 4 because tiny Vec's are dumb; but not if that\n-                    // would cause overflow\n+                    // Skip to 4 because tiny `Vec`'s are dumb; but not if that\n+                    // would cause overflow.\n                     let new_cap = if elem_size > (!0) / 8 { 1 } else { 4 };\n                     match self.a.alloc_array::<T>(new_cap) {\n                         Ok(ptr) => (new_cap, ptr.into()),\n@@ -342,7 +342,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     ///\n     /// # Panics\n     ///\n-    /// * Panics if T is zero-sized on the assumption that you managed to exhaust\n+    /// * Panics if `T` is zero-sized on the assumption that you managed to exhaust\n     ///   all `usize::MAX` slots in your imaginary buffer.\n     /// * Panics on 32-bit platforms if the requested capacity exceeds\n     ///   `isize::MAX` bytes.\n@@ -356,15 +356,15 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 None => return false, // nothing to double\n             };\n \n-            // since we set the capacity to usize::MAX when elem_size is\n-            // 0, getting to here necessarily means the RawVec is overfull.\n+            // Since we set the capacity to `usize::MAX` when `elem_size` is\n+            // 0, getting to here necessarily means the `RawVec` is overfull.\n             assert!(elem_size != 0, \"capacity overflow\");\n \n-            // Since we guarantee that we never allocate more than isize::MAX\n+            // Since we guarantee that we never allocate more than `isize::MAX`\n             // bytes, `elem_size * self.cap <= isize::MAX` as a precondition, so\n             // this can't overflow.\n             //\n-            // Similarly like with `double` above we can go straight to\n+            // Similarly to with `double` above, we can go straight to\n             // `Layout::from_size_align_unchecked` as we know this won't\n             // overflow and the alignment is sufficiently small.\n             let new_cap = 2 * self.cap;\n@@ -409,7 +409,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     ///\n     /// # Aborts\n     ///\n-    /// Aborts on OOM\n+    /// Aborts on OOM.\n     pub fn reserve_exact(&mut self, used_capacity: usize, needed_extra_capacity: usize) {\n         match self.reserve_internal(used_capacity, needed_extra_capacity, Infallible, Exact) {\n             Err(CapacityOverflow) => capacity_overflow(),\n@@ -424,7 +424,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     fn amortized_new_size(&self, used_capacity: usize, needed_extra_capacity: usize)\n         -> Result<usize, TryReserveError> {\n \n-        // Nothing we can really do about these checks :(\n+        // Nothing we can really do about these checks, sadly.\n         let required_cap = used_capacity.checked_add(needed_extra_capacity)\n             .ok_or(CapacityOverflow)?;\n         // Cannot overflow, because `cap <= isize::MAX`, and type of `cap` is `usize`.\n@@ -459,7 +459,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     ///\n     /// # Aborts\n     ///\n-    /// Aborts on OOM\n+    /// Aborts on OOM.\n     ///\n     /// # Examples\n     ///\n@@ -538,7 +538,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n \n             // Here, `cap < used_capacity + needed_extra_capacity <= new_cap`\n             // (regardless of whether `self.cap - used_capacity` wrapped).\n-            // Therefore we can safely call grow_in_place.\n+            // Therefore, we can safely call `grow_in_place`.\n \n             let new_layout = Layout::new::<T>().repeat(new_cap).unwrap().0;\n             // FIXME: may crash and burn on over-reserve\n@@ -576,14 +576,14 @@ impl<T, A: Alloc> RawVec<T, A> {\n             return;\n         }\n \n-        // This check is my waterloo; it's the only thing Vec wouldn't have to do.\n+        // This check is my waterloo; it's the only thing `Vec` wouldn't have to do.\n         assert!(self.cap >= amount, \"Tried to shrink to a larger capacity\");\n \n         if amount == 0 {\n             // We want to create a new zero-length vector within the\n-            // same allocator.  We use ptr::write to avoid an\n+            // same allocator. We use `ptr::write` to avoid an\n             // erroneous attempt to drop the contents, and we use\n-            // ptr::read to sidestep condition against destructuring\n+            // `ptr::read` to sidestep condition against destructuring\n             // types that implement Drop.\n \n             unsafe {\n@@ -600,7 +600,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 //\n                 // We also know that `self.cap` is greater than `amount`, and\n                 // consequently we don't need runtime checks for creating either\n-                // layout\n+                // layout.\n                 let old_size = elem_size * self.cap;\n                 let new_size = elem_size * amount;\n                 let align = mem::align_of::<T>();\n@@ -653,7 +653,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 return Ok(());\n             }\n \n-            // Nothing we can really do about these checks :(\n+            // Nothing we can really do about these checks, sadly.\n             let new_cap = match strategy {\n                 Exact => used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?,\n                 Amortized => self.amortized_new_size(used_capacity, needed_extra_capacity)?,\n@@ -692,15 +692,15 @@ impl<T> RawVec<T, Global> {\n     /// Converts the entire buffer into `Box<[T]>`.\n     ///\n     /// Note that this will correctly reconstitute any `cap` changes\n-    /// that may have been performed. (see description of type for details)\n+    /// that may have been performed. (See description of type for details.)\n     ///\n     /// # Undefined Behavior\n     ///\n     /// All elements of `RawVec<T, Global>` must be initialized. Notice that\n     /// the rules around uninitialized boxed values are not finalized yet,\n     /// but until they are, it is advisable to avoid them.\n     pub unsafe fn into_box(self) -> Box<[T]> {\n-        // NOTE: not calling `capacity()` here, actually using the real `cap` field!\n+        // NOTE: not calling `capacity()` here; actually using the real `cap` field!\n         let slice = slice::from_raw_parts_mut(self.ptr(), self.cap);\n         let output: Box<[T]> = Box::from_raw(slice);\n         mem::forget(self);\n@@ -709,7 +709,7 @@ impl<T> RawVec<T, Global> {\n }\n \n impl<T, A: Alloc> RawVec<T, A> {\n-    /// Frees the memory owned by the RawVec *without* trying to Drop its contents.\n+    /// Frees the memory owned by the `RawVec` *without* trying to drop its contents.\n     pub unsafe fn dealloc_buffer(&mut self) {\n         let elem_size = mem::size_of::<T>();\n         if elem_size != 0 {\n@@ -721,22 +721,20 @@ impl<T, A: Alloc> RawVec<T, A> {\n }\n \n unsafe impl<#[may_dangle] T, A: Alloc> Drop for RawVec<T, A> {\n-    /// Frees the memory owned by the RawVec *without* trying to Drop its contents.\n+    /// Frees the memory owned by the `RawVec` *without* trying to drop its contents.\n     fn drop(&mut self) {\n         unsafe { self.dealloc_buffer(); }\n     }\n }\n \n-\n-\n // We need to guarantee the following:\n-// * We don't ever allocate `> isize::MAX` byte-size objects\n-// * We don't overflow `usize::MAX` and actually allocate too little\n+// * We don't ever allocate `> isize::MAX` byte-size objects.\n+// * We don't overflow `usize::MAX` and actually allocate too little.\n //\n // On 64-bit we just need to check for overflow since trying to allocate\n // `> isize::MAX` bytes will surely fail. On 32-bit and 16-bit we need to add\n // an extra guard for this in case we're running on a platform which can use\n-// all 4GB in user-space. e.g., PAE or x32\n+// all 4GB in user-space, e.g., PAE or x32.\n \n #[inline]\n fn alloc_guard(alloc_size: usize) -> Result<(), TryReserveError> {\n@@ -751,5 +749,5 @@ fn alloc_guard(alloc_size: usize) -> Result<(), TryReserveError> {\n // ensure that the code generation related to these panics is minimal as there's\n // only one location which panics rather than a bunch throughout the module.\n fn capacity_overflow() -> ! {\n-    panic!(\"capacity overflow\")\n+    panic!(\"capacity overflow\");\n }"}, {"sha": "d35b62fc1ef15ce8b18ac8bd7628b38a3c9190ee", "filename": "src/liballoc/raw_vec/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b0006dff1041f0eea718ca29607cd6ec372e4e30/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0006dff1041f0eea718ca29607cd6ec372e4e30/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec%2Ftests.rs?ref=b0006dff1041f0eea718ca29607cd6ec372e4e30", "patch": "@@ -5,12 +5,12 @@ fn allocator_param() {\n     use crate::alloc::AllocErr;\n \n     // Writing a test of integration between third-party\n-    // allocators and RawVec is a little tricky because the RawVec\n+    // allocators and `RawVec` is a little tricky because the `RawVec`\n     // API does not expose fallible allocation methods, so we\n     // cannot check what happens when allocator is exhausted\n     // (beyond detecting a panic).\n     //\n-    // Instead, this just checks that the RawVec methods do at\n+    // Instead, this just checks that the `RawVec` methods do at\n     // least go through the Allocator API when it reserves\n     // storage.\n \n@@ -44,7 +44,7 @@ fn allocator_param() {\n fn reserve_does_not_overallocate() {\n     {\n         let mut v: RawVec<u32> = RawVec::new();\n-        // First `reserve` allocates like `reserve_exact`\n+        // First, `reserve` allocates like `reserve_exact`.\n         v.reserve(0, 9);\n         assert_eq!(9, v.capacity());\n     }"}, {"sha": "439f24e95ca0d2b4b7d0100993c4623b5480513d", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0006dff1041f0eea718ca29607cd6ec372e4e30/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0006dff1041f0eea718ca29607cd6ec372e4e30/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=b0006dff1041f0eea718ca29607cd6ec372e4e30", "patch": "@@ -567,7 +567,7 @@ impl<T: ?Sized> Rc<T> {\n     ///     let x = Rc::from_raw(x_ptr);\n     ///     assert_eq!(&*x, \"hello\");\n     ///\n-    ///     // Further calls to `Rc::from_raw(x_ptr)` would be memory unsafe.\n+    ///     // Further calls to `Rc::from_raw(x_ptr)` would be memory-unsafe.\n     /// }\n     ///\n     /// // The memory was freed when `x` went out of scope above, so `x_ptr` is now dangling!"}, {"sha": "3bf22a87feaa77f5c855ba69a55b53046609229e", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0006dff1041f0eea718ca29607cd6ec372e4e30/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0006dff1041f0eea718ca29607cd6ec372e4e30/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=b0006dff1041f0eea718ca29607cd6ec372e4e30", "patch": "@@ -547,7 +547,7 @@ impl<T: ?Sized> Arc<T> {\n     ///     let x = Arc::from_raw(x_ptr);\n     ///     assert_eq!(&*x, \"hello\");\n     ///\n-    ///     // Further calls to `Arc::from_raw(x_ptr)` would be memory unsafe.\n+    ///     // Further calls to `Arc::from_raw(x_ptr)` would be memory-unsafe.\n     /// }\n     ///\n     /// // The memory was freed when `x` went out of scope above, so `x_ptr` is now dangling!"}, {"sha": "0afbf4f134679b7343de55c5e8377a577cfd2323", "filename": "src/libcore/any.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b0006dff1041f0eea718ca29607cd6ec372e4e30/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0006dff1041f0eea718ca29607cd6ec372e4e30/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=b0006dff1041f0eea718ca29607cd6ec372e4e30", "patch": "@@ -153,13 +153,13 @@ impl dyn Any {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is<T: Any>(&self) -> bool {\n-        // Get TypeId of the type this function is instantiated with\n+        // Get `TypeId` of the type this function is instantiated with.\n         let t = TypeId::of::<T>();\n \n-        // Get TypeId of the type in the trait object\n+        // Get `TypeId` of the type in the trait object.\n         let concrete = self.type_id();\n \n-        // Compare both TypeIds on equality\n+        // Compare both `TypeId`s on equality.\n         t == concrete\n     }\n "}, {"sha": "347e7dce6e67d242e7a68bf1a63c41917eea250b", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0006dff1041f0eea718ca29607cd6ec372e4e30/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0006dff1041f0eea718ca29607cd6ec372e4e30/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=b0006dff1041f0eea718ca29607cd6ec372e4e30", "patch": "@@ -602,10 +602,10 @@ unsafe impl<T: ?Sized> Freeze for *mut T {}\n unsafe impl<T: ?Sized> Freeze for &T {}\n unsafe impl<T: ?Sized> Freeze for &mut T {}\n \n-/// Types which can be safely moved after being pinned.\n+/// Types that can be safely moved after being pinned.\n ///\n /// Since Rust itself has no notion of immovable types, and considers moves\n-/// (e.g. through assignment or [`mem::replace`]) to always be safe,\n+/// (e.g., through assignment or [`mem::replace`]) to always be safe,\n /// this trait cannot prevent types from moving by itself.\n ///\n /// Instead it is used to prevent moves through the type system,"}, {"sha": "13ccc9b252a775cbf82564e5b7ca1e21184d1fd1", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0006dff1041f0eea718ca29607cd6ec372e4e30/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0006dff1041f0eea718ca29607cd6ec372e4e30/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=b0006dff1041f0eea718ca29607cd6ec372e4e30", "patch": "@@ -1042,7 +1042,7 @@ impl<T: ?Sized> *const T {\n         (self as *const u8) == null()\n     }\n \n-    /// Cast to a pointer to a different type\n+    /// Casts to a pointer of another type.\n     #[stable(feature = \"ptr_cast\", since = \"1.38.0\")]\n     #[inline]\n     pub const fn cast<U>(self) -> *const U {\n@@ -1726,7 +1726,7 @@ impl<T: ?Sized> *mut T {\n         (self as *mut u8) == null_mut()\n     }\n \n-    /// Cast to a pointer to a different type\n+    /// Casts to a pointer of another type.\n     #[stable(feature = \"ptr_cast\", since = \"1.38.0\")]\n     #[inline]\n     pub const fn cast<U>(self) -> *mut U {"}, {"sha": "7dcd57f1f985888e9c109fd5fa8c6c3ae6305d1f", "filename": "src/libcore/ptr/non_null.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0006dff1041f0eea718ca29607cd6ec372e4e30/src%2Flibcore%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0006dff1041f0eea718ca29607cd6ec372e4e30/src%2Flibcore%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fnon_null.rs?ref=b0006dff1041f0eea718ca29607cd6ec372e4e30", "patch": "@@ -125,7 +125,7 @@ impl<T: ?Sized> NonNull<T> {\n         &mut *self.as_ptr()\n     }\n \n-    /// Cast to a pointer of another type\n+    /// Casts to a pointer of another type.\n     #[stable(feature = \"nonnull_cast\", since = \"1.27.0\")]\n     #[inline]\n     pub const fn cast<U>(self) -> NonNull<U> {"}, {"sha": "b89893692698c2ca0b4d4f6ce23a5ec42c900966", "filename": "src/libstd/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0006dff1041f0eea718ca29607cd6ec372e4e30/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0006dff1041f0eea718ca29607cd6ec372e4e30/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=b0006dff1041f0eea718ca29607cd6ec372e4e30", "patch": "@@ -290,7 +290,7 @@ impl Error for VarError {\n ///\n /// Note that while concurrent access to environment variables is safe in Rust,\n /// some platforms only expose inherently unsafe non-threadsafe APIs for\n-/// inspecting the environment. As a result extra care needs to be taken when\n+/// inspecting the environment. As a result, extra care needs to be taken when\n /// auditing calls to unsafe external FFI functions to ensure that any external\n /// environment accesses are properly synchronized with accesses in Rust.\n ///"}, {"sha": "19a77a48d9a48932506b3fd168bda618964fa02a", "filename": "src/libstd/error.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b0006dff1041f0eea718ca29607cd6ec372e4e30/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0006dff1041f0eea718ca29607cd6ec372e4e30/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=b0006dff1041f0eea718ca29607cd6ec372e4e30", "patch": "@@ -196,10 +196,10 @@ pub trait Error: Debug + Display {\n     #[stable(feature = \"error_source\", since = \"1.30.0\")]\n     fn source(&self) -> Option<&(dyn Error + 'static)> { None }\n \n-    /// Gets the `TypeId` of `self`\n+    /// Gets the `TypeId` of `self`.\n     #[doc(hidden)]\n     #[unstable(feature = \"error_type_id\",\n-               reason = \"this is memory unsafe to override in user code\",\n+               reason = \"this is memory-unsafe to override in user code\",\n                issue = \"60784\")]\n     fn type_id(&self, _: private::Internal) -> TypeId where Self: 'static {\n         TypeId::of::<Self>()\n@@ -601,19 +601,19 @@ impl Error for char::ParseCharError {\n     }\n }\n \n-// copied from any.rs\n+// Copied from `any.rs`.\n impl dyn Error + 'static {\n     /// Returns `true` if the boxed type is the same as `T`\n     #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n     #[inline]\n     pub fn is<T: Error + 'static>(&self) -> bool {\n-        // Get TypeId of the type this function is instantiated with\n+        // Get `TypeId` of the type this function is instantiated with.\n         let t = TypeId::of::<T>();\n \n-        // Get TypeId of the type in the trait object\n+        // Get `TypeId` of the type in the trait object.\n         let boxed = self.type_id(private::Internal);\n \n-        // Compare both TypeIds on equality\n+        // Compare both `TypeId`s on equality.\n         t == boxed\n     }\n \n@@ -647,21 +647,21 @@ impl dyn Error + 'static {\n }\n \n impl dyn Error + 'static + Send {\n-    /// Forwards to the method defined on the type `Any`.\n+    /// Forwards to the method defined on the type `dyn Error`.\n     #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n     #[inline]\n     pub fn is<T: Error + 'static>(&self) -> bool {\n         <dyn Error + 'static>::is::<T>(self)\n     }\n \n-    /// Forwards to the method defined on the type `Any`.\n+    /// Forwards to the method defined on the type `dyn Error`.\n     #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n     #[inline]\n     pub fn downcast_ref<T: Error + 'static>(&self) -> Option<&T> {\n         <dyn Error + 'static>::downcast_ref::<T>(self)\n     }\n \n-    /// Forwards to the method defined on the type `Any`.\n+    /// Forwards to the method defined on the type `dyn Error`.\n     #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n     #[inline]\n     pub fn downcast_mut<T: Error + 'static>(&mut self) -> Option<&mut T> {\n@@ -670,21 +670,21 @@ impl dyn Error + 'static + Send {\n }\n \n impl dyn Error + 'static + Send + Sync {\n-    /// Forwards to the method defined on the type `Any`.\n+    /// Forwards to the method defined on the type `dyn Error`.\n     #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n     #[inline]\n     pub fn is<T: Error + 'static>(&self) -> bool {\n         <dyn Error + 'static>::is::<T>(self)\n     }\n \n-    /// Forwards to the method defined on the type `Any`.\n+    /// Forwards to the method defined on the type `dyn Error`.\n     #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n     #[inline]\n     pub fn downcast_ref<T: Error + 'static>(&self) -> Option<&T> {\n         <dyn Error + 'static>::downcast_ref::<T>(self)\n     }\n \n-    /// Forwards to the method defined on the type `Any`.\n+    /// Forwards to the method defined on the type `dyn Error`.\n     #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n     #[inline]\n     pub fn downcast_mut<T: Error + 'static>(&mut self) -> Option<&mut T> {\n@@ -695,7 +695,7 @@ impl dyn Error + 'static + Send + Sync {\n impl dyn Error {\n     #[inline]\n     #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n-    /// Attempt to downcast the box to a concrete type.\n+    /// Attempts to downcast the box to a concrete type.\n     pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<dyn Error>> {\n         if self.is::<T>() {\n             unsafe {\n@@ -863,12 +863,12 @@ impl<'a> Iterator for ErrorIter<'a> {\n impl dyn Error + Send {\n     #[inline]\n     #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n-    /// Attempt to downcast the box to a concrete type.\n+    /// Attempts to downcast the box to a concrete type.\n     pub fn downcast<T: Error + 'static>(self: Box<Self>)\n                                         -> Result<Box<T>, Box<dyn Error + Send>> {\n         let err: Box<dyn Error> = self;\n         <dyn Error>::downcast(err).map_err(|s| unsafe {\n-            // reapply the Send marker\n+            // Reapply the `Send` marker.\n             transmute::<Box<dyn Error>, Box<dyn Error + Send>>(s)\n         })\n     }\n@@ -877,12 +877,12 @@ impl dyn Error + Send {\n impl dyn Error + Send + Sync {\n     #[inline]\n     #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n-    /// Attempt to downcast the box to a concrete type.\n+    /// Attempts to downcast the box to a concrete type.\n     pub fn downcast<T: Error + 'static>(self: Box<Self>)\n                                         -> Result<Box<T>, Box<Self>> {\n         let err: Box<dyn Error> = self;\n         <dyn Error>::downcast(err).map_err(|s| unsafe {\n-            // reapply the Send+Sync marker\n+            // Reapply the `Send + Sync` marker.\n             transmute::<Box<dyn Error>, Box<dyn Error + Send + Sync>>(s)\n         })\n     }"}, {"sha": "3ce2b68d858eba032511d8c46a5686cc112b8583", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0006dff1041f0eea718ca29607cd6ec372e4e30/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0006dff1041f0eea718ca29607cd6ec372e4e30/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=b0006dff1041f0eea718ca29607cd6ec372e4e30", "patch": "@@ -615,7 +615,7 @@ impl CString {\n }\n \n // Turns this `CString` into an empty string to prevent\n-// memory unsafe code from working by accident. Inline\n+// memory-unsafe code from working by accident. Inline\n // to prevent LLVM from optimizing it away in debug builds.\n #[stable(feature = \"cstring_drop\", since = \"1.13.0\")]\n impl Drop for CString {"}, {"sha": "c50025ab7d1deb47a2a9a48a8dc02952cd4146a3", "filename": "src/libstd/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0006dff1041f0eea718ca29607cd6ec372e4e30/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0006dff1041f0eea718ca29607cd6ec372e4e30/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=b0006dff1041f0eea718ca29607cd6ec372e4e30", "patch": "@@ -1595,7 +1595,7 @@ pub fn id() -> u32 {\n \n /// A trait for implementing arbitrary return types in the `main` function.\n ///\n-/// The c-main function only supports to return integers as return type.\n+/// The C-main function only supports to return integers as return type.\n /// So, every type implementing the `Termination` trait has to be converted\n /// to an integer.\n ///"}]}