{"sha": "89fcc00581fcde08924b8a13a43bb2387b67243e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5ZmNjMDA1ODFmY2RlMDg5MjRiOGExM2E0M2JiMjM4N2I2NzI0M2U=", "commit": {"author": {"name": "Benjamin Herr", "email": "ben@0x539.de", "date": "2016-03-31T18:07:23Z"}, "committer": {"name": "Benjamin Herr", "email": "ben@0x539.de", "date": "2016-03-31T20:06:52Z"}, "message": "librustc_const_eval: use bug!(), span_bug!()", "tree": {"sha": "55627982eb3752f4a958b95ddaa0414fbc41f8be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55627982eb3752f4a958b95ddaa0414fbc41f8be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89fcc00581fcde08924b8a13a43bb2387b67243e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89fcc00581fcde08924b8a13a43bb2387b67243e", "html_url": "https://github.com/rust-lang/rust/commit/89fcc00581fcde08924b8a13a43bb2387b67243e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89fcc00581fcde08924b8a13a43bb2387b67243e/comments", "author": {"login": "ben0x539", "id": 24142, "node_id": "MDQ6VXNlcjI0MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/24142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ben0x539", "html_url": "https://github.com/ben0x539", "followers_url": "https://api.github.com/users/ben0x539/followers", "following_url": "https://api.github.com/users/ben0x539/following{/other_user}", "gists_url": "https://api.github.com/users/ben0x539/gists{/gist_id}", "starred_url": "https://api.github.com/users/ben0x539/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ben0x539/subscriptions", "organizations_url": "https://api.github.com/users/ben0x539/orgs", "repos_url": "https://api.github.com/users/ben0x539/repos", "events_url": "https://api.github.com/users/ben0x539/events{/privacy}", "received_events_url": "https://api.github.com/users/ben0x539/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ben0x539", "id": 24142, "node_id": "MDQ6VXNlcjI0MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/24142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ben0x539", "html_url": "https://github.com/ben0x539", "followers_url": "https://api.github.com/users/ben0x539/followers", "following_url": "https://api.github.com/users/ben0x539/following{/other_user}", "gists_url": "https://api.github.com/users/ben0x539/gists{/gist_id}", "starred_url": "https://api.github.com/users/ben0x539/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ben0x539/subscriptions", "organizations_url": "https://api.github.com/users/ben0x539/orgs", "repos_url": "https://api.github.com/users/ben0x539/repos", "events_url": "https://api.github.com/users/ben0x539/events{/privacy}", "received_events_url": "https://api.github.com/users/ben0x539/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "url": "https://api.github.com/repos/rust-lang/rust/commits/c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "html_url": "https://github.com/rust-lang/rust/commit/c59ea491eae7d1fbfb0f73fe3579effdf9281b47"}], "stats": {"total": 89, "additions": 43, "deletions": 46}, "files": [{"sha": "a46d72840b72857721356b00f871c430ade2e221", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 29, "deletions": 32, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/89fcc00581fcde08924b8a13a43bb2387b67243e/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89fcc00581fcde08924b8a13a43bb2387b67243e/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=89fcc00581fcde08924b8a13a43bb2387b67243e", "patch": "@@ -339,20 +339,20 @@ fn check_arms(cx: &MatchCheckCtxt,\n                             // `Some(<head>)` and `None`. It's impossible to have an unreachable\n                             // pattern\n                             // (see libsyntax/ext/expand.rs for the full expansion of a for loop)\n-                            cx.tcx.sess.span_bug(pat.span, \"unreachable for-loop pattern\")\n+                            span_bug!(pat.span, \"unreachable for-loop pattern\")\n                         },\n \n                         hir::MatchSource::Normal => {\n                             span_err!(cx.tcx.sess, pat.span, E0001, \"unreachable pattern\")\n                         },\n \n                         hir::MatchSource::TryDesugar => {\n-                            cx.tcx.sess.span_bug(pat.span, \"unreachable try pattern\")\n+                            span_bug!(pat.span, \"unreachable try pattern\")\n                         },\n                     }\n                 }\n                 Useful => (),\n-                UsefulWithWitness(_) => unreachable!()\n+                UsefulWithWitness(_) => bug!()\n             }\n             if guard.is_none() {\n                 let Matrix(mut rows) = seen;\n@@ -384,9 +384,9 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix, source: hir:\n                     let witness = match witnesses[0].node {\n                         PatKind::TupleStruct(_, Some(ref pats)) => match &pats[..] {\n                             [ref pat] => &**pat,\n-                            _ => unreachable!(),\n+                            _ => bug!(),\n                         },\n-                        _ => unreachable!(),\n+                        _ => bug!(),\n                     };\n                     span_err!(cx.tcx.sess, sp, E0297,\n                         \"refutable pattern in `for` loop binding: \\\n@@ -399,7 +399,7 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix, source: hir:\n                     }).collect();\n                     const LIMIT: usize = 3;\n                     let joined_patterns = match pattern_strings.len() {\n-                        0 => unreachable!(),\n+                        0 => bug!(),\n                         1 => format!(\"`{}`\", pattern_strings[0]),\n                         2...LIMIT => {\n                             let (tail, head) = pattern_strings.split_last().unwrap();\n@@ -420,14 +420,14 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix, source: hir:\n         NotUseful => {\n             // This is good, wildcard pattern isn't reachable\n         },\n-        _ => unreachable!()\n+        _ => bug!()\n     }\n }\n \n fn const_val_to_expr(value: &ConstVal) -> P<hir::Expr> {\n     let node = match value {\n         &ConstVal::Bool(b) => ast::LitKind::Bool(b),\n-        _ => unreachable!()\n+        _ => bug!()\n     };\n     P(hir::Expr {\n         id: 0,\n@@ -579,14 +579,14 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n                         assert_eq!(pats_len, n);\n                         PatKind::Vec(pats.collect(), None, hir::HirVec::new())\n                     },\n-                    _ => unreachable!()\n+                    _ => bug!()\n                 },\n                 ty::TySlice(_) => match ctor {\n                     &Slice(n) => {\n                         assert_eq!(pats_len, n);\n                         PatKind::Vec(pats.collect(), None, hir::HirVec::new())\n                     },\n-                    _ => unreachable!()\n+                    _ => bug!()\n                 },\n                 ty::TyStr => PatKind::Wild,\n \n@@ -791,17 +791,16 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n         PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..) | PatKind::Ident(..) =>\n             match cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def() {\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n-                    cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n-                                                    been rewritten\"),\n+                    span_bug!(pat.span, \"const pattern should've \\\n+                                         been rewritten\"),\n                 Def::Struct(..) | Def::TyAlias(..) => vec![Single],\n                 Def::Variant(_, id) => vec![Variant(id)],\n                 Def::Local(..) => vec![],\n-                def => cx.tcx.sess.span_bug(pat.span, &format!(\"pat_constructors: unexpected \\\n-                                                                definition {:?}\", def)),\n+                def => span_bug!(pat.span, \"pat_constructors: unexpected \\\n+                                            definition {:?}\", def),\n             },\n         PatKind::QPath(..) =>\n-            cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n-                                            been rewritten\"),\n+            span_bug!(pat.span, \"const pattern should've been rewritten\"),\n         PatKind::Lit(ref expr) =>\n             vec!(ConstantValue(eval_const_expr(cx.tcx, &expr))),\n         PatKind::Range(ref lo, ref hi) =>\n@@ -837,7 +836,7 @@ pub fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> us\n             ty::TySlice(_) => match *ctor {\n                 Slice(length) => length,\n                 ConstantValue(_) => 0,\n-                _ => unreachable!()\n+                _ => bug!()\n             },\n             ty::TyStr => 0,\n             _ => 1\n@@ -856,7 +855,7 @@ fn range_covered_by_constructor(ctor: &Constructor,\n         ConstantValue(ref value)        => (value, value),\n         ConstantRange(ref from, ref to) => (from, to),\n         Single                          => return Some(true),\n-        _                               => unreachable!()\n+        _                               => bug!()\n     };\n     let cmp_from = compare_const_vals(c_from, from);\n     let cmp_to = compare_const_vals(c_to, to);\n@@ -889,22 +888,22 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n             match def {\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n-                    cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n-                                                    been rewritten\"),\n+                    span_bug!(pat_span, \"const pattern should've \\\n+                                         been rewritten\"),\n                 Def::Variant(_, id) if *constructor != Variant(id) => None,\n                 Def::Variant(..) | Def::Struct(..) => Some(Vec::new()),\n                 Def::Local(..) => Some(vec![DUMMY_WILD_PAT; arity]),\n-                _ => cx.tcx.sess.span_bug(pat_span, &format!(\"specialize: unexpected \\\n-                                                              definition {:?}\", def)),\n+                _ => span_bug!(pat_span, \"specialize: unexpected \\\n+                                          definition {:?}\", def),\n             }\n         }\n \n         PatKind::TupleStruct(_, ref args) => {\n             let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n             match def {\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n-                    cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n-                                                    been rewritten\"),\n+                    span_bug!(pat_span, \"const pattern should've \\\n+                                         been rewritten\"),\n                 Def::Variant(_, id) if *constructor != Variant(id) => None,\n                 Def::Variant(..) | Def::Struct(..) => {\n                     Some(match args {\n@@ -917,8 +916,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         }\n \n         PatKind::QPath(_, _) => {\n-            cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n-                                            been rewritten\")\n+            span_bug!(pat_span, \"const pattern should've been rewritten\")\n         }\n \n         PatKind::Struct(_, ref pattern_fields, _) => {\n@@ -1062,7 +1060,7 @@ fn is_refutable<A, F>(cx: &MatchCheckCtxt, pat: &Pat, refutable: F) -> Option<A>\n     match is_useful(cx, &pats, &[DUMMY_WILD_PAT], ConstructWitness) {\n         UsefulWithWitness(pats) => Some(refutable(&pats[0])),\n         NotUseful => None,\n-        Useful => unreachable!()\n+        Useful => bug!()\n     }\n }\n \n@@ -1119,12 +1117,11 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                     PatKind::Ident(hir::BindByRef(_), _, _) => {\n                     }\n                     _ => {\n-                        cx.tcx.sess.span_bug(\n+                        span_bug!(\n                             p.span,\n-                            &format!(\"binding pattern {} is not an \\\n-                                     identifier: {:?}\",\n-                                    p.id,\n-                                    p.node));\n+                            \"binding pattern {} is not an identifier: {:?}\",\n+                            p.id,\n+                            p.node);\n                     }\n                 }\n             }"}, {"sha": "4790e4819378d6fa2467ca03093527191a0c2722", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/89fcc00581fcde08924b8a13a43bb2387b67243e/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89fcc00581fcde08924b8a13a43bb2387b67243e/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=89fcc00581fcde08924b8a13a43bb2387b67243e", "patch": "@@ -286,7 +286,7 @@ pub fn const_expr_to_pat(tcx: &ty::TyCtxt, expr: &Expr, pat_id: ast::NodeId, spa\n                     node: PatKind::Lit(P(expr.clone())),\n                     span: span,\n                 })),\n-                _ => unreachable!()\n+                _ => bug!()\n             };\n             let pats = try!(args.iter()\n                                 .map(|expr| const_expr_to_pat(tcx, &**expr,\n@@ -330,7 +330,7 @@ pub fn const_expr_to_pat(tcx: &ty::TyCtxt, expr: &Expr, pat_id: ast::NodeId, spa\n                     let (expr, _ty) = lookup_const_by_id(tcx, def_id, substs).unwrap();\n                     return const_expr_to_pat(tcx, expr, pat_id, span);\n                 },\n-                _ => unreachable!(),\n+                _ => bug!(),\n             }\n         }\n \n@@ -588,7 +588,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n                         IntTy::I64 => if n == I64_OVERFLOW {\n                             return Ok(Integral(Isize(Is64(::std::i64::MIN))));\n                         },\n-                        _ => unreachable!(),\n+                        _ => bug!(),\n                     }\n                 },\n                 _ => {},\n@@ -697,7 +697,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n                     Some(IntType::UnsignedInt(ty)) => ty_hint.checked_or(tcx.mk_mach_uint(ty)),\n                     Some(IntType::SignedInt(ty)) => ty_hint.checked_or(tcx.mk_mach_int(ty)),\n                     // we had a type hint, so we can't have an unknown type\n-                    None => unreachable!(),\n+                    None => bug!(),\n                 };\n                 eval_const_expr_partial(tcx, &base, hint, fn_args)?\n             },\n@@ -798,7 +798,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n       hir::ExprBlock(ref block) => {\n         match block.expr {\n             Some(ref expr) => eval_const_expr_partial(tcx, &expr, ty_hint, fn_args)?,\n-            None => unreachable!(),\n+            None => bug!(),\n         }\n       }\n       hir::ExprType(ref e, _) => eval_const_expr_partial(tcx, &e, ty_hint, fn_args)?,\n@@ -813,7 +813,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n         let idx_hint = ty_hint.checked_or(tcx.types.usize);\n         let idx = match eval_const_expr_partial(tcx, idx, idx_hint, fn_args)? {\n             Integral(Usize(i)) => i.as_u64(tcx.sess.target.uint_type),\n-            Integral(_) => unreachable!(),\n+            Integral(_) => bug!(),\n             _ => signal!(idx, IndexNotInt),\n         };\n         assert_eq!(idx as usize as u64, idx);\n@@ -823,7 +823,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n                 assert_eq!(n as usize as u64, n);\n                 eval_const_expr_partial(tcx, &v[idx as usize], ty_hint, fn_args)?\n             } else {\n-                unreachable!()\n+                bug!()\n             },\n \n             Repeat(_, n) if idx >= n => signal!(e, IndexOutOfBounds),\n@@ -840,7 +840,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n             },\n \n             Str(ref s) if idx as usize >= s.len() => signal!(e, IndexOutOfBounds),\n-            Str(_) => unimplemented!(), // FIXME: return a const char\n+            Str(_) => bug!(\"unimplemented\"), // FIXME: return a const char\n             _ => signal!(e, IndexedNonVec),\n         }\n       }\n@@ -867,7 +867,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n                     signal!(e, TupleIndexOutOfBounds);\n                 }\n             } else {\n-                unreachable!()\n+                bug!()\n             }\n         } else {\n             signal!(base, ExpectedConstTuple);\n@@ -888,7 +888,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n                     signal!(e, MissingStructField);\n                 }\n             } else {\n-                unreachable!()\n+                bug!()\n             }\n         } else {\n             signal!(base, ExpectedConstStruct);\n@@ -1025,7 +1025,7 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n             }\n         }\n         _ => {\n-            tcx.sess.span_bug(\n+            span_bug!(\n                 ti.span,\n                 \"resolve_trait_associated_const: unexpected vtable type\")\n         }\n@@ -1127,7 +1127,7 @@ fn lit_to_const<'tcx>(lit: &ast::LitKind,\n                     let int_ty = tcx.enum_repr_type(hints.iter().next());\n                     infer(Infer(n), tcx, &int_ty.to_ty(tcx).sty, span).map(Integral)\n                 },\n-                Some(ty_hint) => panic!(\"bad ty_hint: {:?}, {:?}\", ty_hint, lit),\n+                Some(ty_hint) => bug!(\"bad ty_hint: {:?}, {:?}\", ty_hint, lit),\n             }\n         },\n         LitKind::Int(n, Unsigned(ity)) => {\n@@ -1140,7 +1140,7 @@ fn lit_to_const<'tcx>(lit: &ast::LitKind,\n                 Ok(Float(x))\n             } else {\n                 // FIXME(#31407) this is only necessary because float parsing is buggy\n-                tcx.sess.span_bug(span, \"could not evaluate float literal (see issue #31407)\");\n+                span_bug!(span, \"could not evaluate float literal (see issue #31407)\");\n             }\n         }\n         LitKind::Bool(b) => Ok(Bool(b)),"}, {"sha": "b74fc121e391dd53b4e9210c5d5fedf28e2e61f7", "filename": "src/librustc_const_eval/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89fcc00581fcde08924b8a13a43bb2387b67243e/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89fcc00581fcde08924b8a13a43bb2387b67243e/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=89fcc00581fcde08924b8a13a43bb2387b67243e", "patch": "@@ -32,7 +32,7 @@\n \n #[macro_use] extern crate syntax;\n #[macro_use] extern crate log;\n-extern crate rustc;\n+#[macro_use] extern crate rustc;\n extern crate rustc_front;\n extern crate rustc_back;\n extern crate rustc_const_math;"}]}