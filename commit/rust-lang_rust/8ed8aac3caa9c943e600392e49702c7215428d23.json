{"sha": "8ed8aac3caa9c943e600392e49702c7215428d23", "node_id": "C_kwDOAAsO6NoAKDhlZDhhYWMzY2FhOWM5NDNlNjAwMzkyZTQ5NzAyYzcyMTU0MjhkMjM", "commit": {"author": {"name": "finalchild", "email": "finalchild2@gmail.com", "date": "2022-08-18T17:21:35Z"}, "committer": {"name": "finalchild", "email": "finalchild2@gmail.com", "date": "2022-08-21T16:11:59Z"}, "message": "Fix `build_format` not unescaping braces properly\n\nCo-authored-by: RanolP <public.ranolp@gmail.com>", "tree": {"sha": "629ad871be9de445ae8714d890e8d16b0ddd0ca4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/629ad871be9de445ae8714d890e8d16b0ddd0ca4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ed8aac3caa9c943e600392e49702c7215428d23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ed8aac3caa9c943e600392e49702c7215428d23", "html_url": "https://github.com/rust-lang/rust/commit/8ed8aac3caa9c943e600392e49702c7215428d23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ed8aac3caa9c943e600392e49702c7215428d23/comments", "author": {"login": "finalchild", "id": 8557044, "node_id": "MDQ6VXNlcjg1NTcwNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/8557044?v=4", "gravatar_id": "", "url": "https://api.github.com/users/finalchild", "html_url": "https://github.com/finalchild", "followers_url": "https://api.github.com/users/finalchild/followers", "following_url": "https://api.github.com/users/finalchild/following{/other_user}", "gists_url": "https://api.github.com/users/finalchild/gists{/gist_id}", "starred_url": "https://api.github.com/users/finalchild/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/finalchild/subscriptions", "organizations_url": "https://api.github.com/users/finalchild/orgs", "repos_url": "https://api.github.com/users/finalchild/repos", "events_url": "https://api.github.com/users/finalchild/events{/privacy}", "received_events_url": "https://api.github.com/users/finalchild/received_events", "type": "User", "site_admin": false}, "committer": {"login": "finalchild", "id": 8557044, "node_id": "MDQ6VXNlcjg1NTcwNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/8557044?v=4", "gravatar_id": "", "url": "https://api.github.com/users/finalchild", "html_url": "https://github.com/finalchild", "followers_url": "https://api.github.com/users/finalchild/followers", "following_url": "https://api.github.com/users/finalchild/following{/other_user}", "gists_url": "https://api.github.com/users/finalchild/gists{/gist_id}", "starred_url": "https://api.github.com/users/finalchild/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/finalchild/subscriptions", "organizations_url": "https://api.github.com/users/finalchild/orgs", "repos_url": "https://api.github.com/users/finalchild/repos", "events_url": "https://api.github.com/users/finalchild/events{/privacy}", "received_events_url": "https://api.github.com/users/finalchild/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b28cc097cfbdc9e2f105a7e644389266027bcf7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b28cc097cfbdc9e2f105a7e644389266027bcf7d", "html_url": "https://github.com/rust-lang/rust/commit/b28cc097cfbdc9e2f105a7e644389266027bcf7d"}], "stats": {"total": 59, "additions": 32, "deletions": 27}, "files": [{"sha": "ad9ecd39b9e85a29989670027afba4cdeed1bf97", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 32, "deletions": 27, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/8ed8aac3caa9c943e600392e49702c7215428d23/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed8aac3caa9c943e600392e49702c7215428d23/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=8ed8aac3caa9c943e600392e49702c7215428d23", "patch": "@@ -235,35 +235,40 @@ pub(crate) trait HasFieldMap {\n         // the referenced fields. Leaves `it` sitting on the closing brace of the format string, so\n         // the next call to `it.next()` retrieves the next character.\n         while let Some(c) = it.next() {\n-            if c == '{' && *it.peek().unwrap_or(&'\\0') != '{' {\n-                let mut eat_argument = || -> Option<String> {\n-                    let mut result = String::new();\n-                    // Format specifiers look like:\n-                    //\n-                    //   format   := '{' [ argument ] [ ':' format_spec ] '}' .\n-                    //\n-                    // Therefore, we only need to eat until ':' or '}' to find the argument.\n-                    while let Some(c) = it.next() {\n-                        result.push(c);\n-                        let next = *it.peek().unwrap_or(&'\\0');\n-                        if next == '}' {\n-                            break;\n-                        } else if next == ':' {\n-                            // Eat the ':' character.\n-                            assert_eq!(it.next().unwrap(), ':');\n-                            break;\n-                        }\n-                    }\n-                    // Eat until (and including) the matching '}'\n-                    while it.next()? != '}' {\n-                        continue;\n+            if c != '{' {\n+                continue;\n+            }\n+            if *it.peek().unwrap_or(&'\\0') == '{' {\n+                assert_eq!(it.next().unwrap(), '{');\n+                continue;\n+            }\n+            let mut eat_argument = || -> Option<String> {\n+                let mut result = String::new();\n+                // Format specifiers look like:\n+                //\n+                //   format   := '{' [ argument ] [ ':' format_spec ] '}' .\n+                //\n+                // Therefore, we only need to eat until ':' or '}' to find the argument.\n+                while let Some(c) = it.next() {\n+                    result.push(c);\n+                    let next = *it.peek().unwrap_or(&'\\0');\n+                    if next == '}' {\n+                        break;\n+                    } else if next == ':' {\n+                        // Eat the ':' character.\n+                        assert_eq!(it.next().unwrap(), ':');\n+                        break;\n                     }\n-                    Some(result)\n-                };\n-\n-                if let Some(referenced_field) = eat_argument() {\n-                    referenced_fields.insert(referenced_field);\n                 }\n+                // Eat until (and including) the matching '}'\n+                while it.next()? != '}' {\n+                    continue;\n+                }\n+                Some(result)\n+            };\n+\n+            if let Some(referenced_field) = eat_argument() {\n+                referenced_fields.insert(referenced_field);\n             }\n         }\n "}]}