{"sha": "dba944a6b79caf0056ddd282de01de70a0ff8a36", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiYTk0NGE2Yjc5Y2FmMDA1NmRkZDI4MmRlMDFkZTcwYTBmZjhhMzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-01T21:08:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-01T21:08:23Z"}, "message": "Auto merge of #69808 - cjgillot:vtbl, r=pnkfelix\n\nAvoid duplicating code for each query\n\nThere are at the moment roughly 170 queries in librustc.\nThe way `ty::query` is structured, a lot of code is duplicated for each query.\nI suspect this to be responsible for a part of librustc'c compile time.\n\nThe first part of this PR reduces the amount of code generic on the query,\nreplacing it by code generic on the key-value types. I can split it out if needed.\n\nIn a second part, the non-inlined methods in the `QueryAccessors` and `QueryDescription` traits\nare made into a virtual dispatch table. This allows to reduce even more the number of generated\nfunctions.\n\nThis allows to save 1.5s on check build, and 10% on the size of the librustc.rlib.\n(Attributed roughly half and half).\nMy computer is not good enough to measure properly compiling time.\nI have no idea of the effect on performance. A perf run may be required.\n\ncc #65031", "tree": {"sha": "b7834f3648b3421f8b79ad6e26e54e5d1a2a1477", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7834f3648b3421f8b79ad6e26e54e5d1a2a1477"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dba944a6b79caf0056ddd282de01de70a0ff8a36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dba944a6b79caf0056ddd282de01de70a0ff8a36", "html_url": "https://github.com/rust-lang/rust/commit/dba944a6b79caf0056ddd282de01de70a0ff8a36", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dba944a6b79caf0056ddd282de01de70a0ff8a36/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f65393b9abf5e70d0b9a8080558f17c5625bd40", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f65393b9abf5e70d0b9a8080558f17c5625bd40", "html_url": "https://github.com/rust-lang/rust/commit/7f65393b9abf5e70d0b9a8080558f17c5625bd40"}, {"sha": "e4976d0caf6a4b9d9d3ec8979427c6e744c8c38d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4976d0caf6a4b9d9d3ec8979427c6e744c8c38d", "html_url": "https://github.com/rust-lang/rust/commit/e4976d0caf6a4b9d9d3ec8979427c6e744c8c38d"}], "stats": {"total": 343, "additions": 240, "deletions": 103}, "files": [{"sha": "5f5bae66cfc659b52151e5297f071794079ffb65", "filename": "src/librustc_macros/src/query.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dba944a6b79caf0056ddd282de01de70a0ff8a36/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dba944a6b79caf0056ddd282de01de70a0ff8a36/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fquery.rs?ref=dba944a6b79caf0056ddd282de01de70a0ff8a36", "patch": "@@ -365,7 +365,7 @@ fn add_query_description_impl(\n             #[allow(unused_variables, unused_braces)]\n             fn cache_on_disk(\n                 #tcx: TyCtxt<'tcx>,\n-                #key: Self::Key,\n+                #key: &Self::Key,\n                 #value: Option<&Self::Value>\n             ) -> bool {\n                 #expr\n@@ -441,7 +441,7 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n                                             .unwrap_or(false));\n \n                             let key = <#arg as DepNodeParams<TyCtxt<'_>>>::recover($tcx, $dep_node).unwrap();\n-                            if queries::#name::cache_on_disk($tcx, key, None) {\n+                            if queries::#name::cache_on_disk($tcx, &key, None) {\n                                 let _ = $tcx.#name(key);\n                             }\n                         }"}, {"sha": "330379008801057ffd765b411d3219ceb080ed0a", "filename": "src/librustc_middle/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/dba944a6b79caf0056ddd282de01de70a0ff8a36/src%2Flibrustc_middle%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dba944a6b79caf0056ddd282de01de70a0ff8a36/src%2Flibrustc_middle%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fdep_graph%2Fdep_node.rs?ref=dba944a6b79caf0056ddd282de01de70a0ff8a36", "patch": "@@ -183,31 +183,10 @@ macro_rules! define_dep_nodes {\n                     // tuple args\n                     $({\n                         erase!($tuple_arg_ty);\n-                        let hash = DepNodeParams::to_fingerprint(&arg, _tcx);\n-                        let dep_node = DepNode {\n-                            kind: DepKind::$variant,\n-                            hash\n-                        };\n-\n-                        #[cfg(debug_assertions)]\n-                        {\n-                            if !dep_node.kind.can_reconstruct_query_key() &&\n-                            (_tcx.sess.opts.debugging_opts.incremental_info ||\n-                                _tcx.sess.opts.debugging_opts.query_dep_graph)\n-                            {\n-                                _tcx.dep_graph.register_dep_node_debug_str(dep_node, || {\n-                                    arg.to_debug_str(_tcx)\n-                                });\n-                            }\n-                        }\n-\n-                        return dep_node;\n+                        return DepNode::construct(_tcx, DepKind::$variant, &arg)\n                     })*\n \n-                    DepNode {\n-                        kind: DepKind::$variant,\n-                        hash: Fingerprint::ZERO,\n-                    }\n+                    return DepNode::construct(_tcx, DepKind::$variant, &())\n                 }\n             )*\n         }"}, {"sha": "207c6d0fbff0fd83f00ac6777f74a8e08b14ea57", "filename": "src/librustc_middle/dep_graph/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dba944a6b79caf0056ddd282de01de70a0ff8a36/src%2Flibrustc_middle%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dba944a6b79caf0056ddd282de01de70a0ff8a36/src%2Flibrustc_middle%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fdep_graph%2Fmod.rs?ref=dba944a6b79caf0056ddd282de01de70a0ff8a36", "patch": "@@ -98,6 +98,10 @@ impl<'tcx> DepContext for TyCtxt<'tcx> {\n     fn debug_dep_tasks(&self) -> bool {\n         self.sess.opts.debugging_opts.dep_tasks\n     }\n+    fn debug_dep_node(&self) -> bool {\n+        self.sess.opts.debugging_opts.incremental_info\n+            || self.sess.opts.debugging_opts.query_dep_graph\n+    }\n \n     fn try_force_from_dep_node(&self, dep_node: &DepNode) -> bool {\n         // FIXME: This match is just a workaround for incremental bugs and should"}, {"sha": "105b0f8f2cf3af7a9faa7897e0673f7db3ad7bc4", "filename": "src/librustc_middle/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dba944a6b79caf0056ddd282de01de70a0ff8a36/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dba944a6b79caf0056ddd282de01de70a0ff8a36/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs?ref=dba944a6b79caf0056ddd282de01de70a0ff8a36", "patch": "@@ -1,4 +1,4 @@\n-use crate::dep_graph::{self, DepConstructor, DepNode, DepNodeParams};\n+use crate::dep_graph::{self, DepNode, DepNodeParams};\n use crate::hir::exports::Export;\n use crate::hir::map;\n use crate::infer::canonical::{self, Canonical};"}, {"sha": "760fdbe8522f436d65423cc7a519d38db3a98208", "filename": "src/librustc_middle/ty/query/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dba944a6b79caf0056ddd282de01de70a0ff8a36/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dba944a6b79caf0056ddd282de01de70a0ff8a36/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs?ref=dba944a6b79caf0056ddd282de01de70a0ff8a36", "patch": "@@ -1009,7 +1009,7 @@ where\n \n     state.iter_results(|results| {\n         for (key, value, dep_node) in results {\n-            if Q::cache_on_disk(tcx, key.clone(), Some(&value)) {\n+            if Q::cache_on_disk(tcx, &key, Some(&value)) {\n                 let dep_node = SerializedDepNodeIndex::new(dep_node.index());\n \n                 // Record position of the cache entry."}, {"sha": "d6d4335e9388d7bdaf653b2ea0a0f210225f7edd", "filename": "src/librustc_middle/ty/query/plumbing.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dba944a6b79caf0056ddd282de01de70a0ff8a36/src%2Flibrustc_middle%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dba944a6b79caf0056ddd282de01de70a0ff8a36/src%2Flibrustc_middle%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fplumbing.rs?ref=dba944a6b79caf0056ddd282de01de70a0ff8a36", "patch": "@@ -348,12 +348,6 @@ macro_rules! define_queries_inner {\n                 &tcx.queries.$name\n             }\n \n-            #[allow(unused)]\n-            #[inline(always)]\n-            fn to_dep_node(tcx: TyCtxt<$tcx>, key: &Self::Key) -> DepNode {\n-                DepConstructor::$node(tcx, *key)\n-            }\n-\n             #[inline]\n             fn compute(tcx: TyCtxt<'tcx>, key: Self::Key) -> Self::Value {\n                 let provider = tcx.queries.providers.get(key.query_crate())"}, {"sha": "36343365ab6c44d1686189fd403b9babb50a9f70", "filename": "src/librustc_query_system/dep_graph/dep_node.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dba944a6b79caf0056ddd282de01de70a0ff8a36/src%2Flibrustc_query_system%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dba944a6b79caf0056ddd282de01de70a0ff8a36/src%2Flibrustc_query_system%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fdep_node.rs?ref=dba944a6b79caf0056ddd282de01de70a0ff8a36", "patch": "@@ -64,6 +64,24 @@ impl<K: DepKind> DepNode<K> {\n         debug_assert!(!kind.has_params());\n         DepNode { kind, hash: Fingerprint::ZERO }\n     }\n+\n+    pub fn construct<Ctxt, Key>(tcx: Ctxt, kind: K, arg: &Key) -> DepNode<K>\n+    where\n+        Ctxt: crate::query::QueryContext<DepKind = K>,\n+        Key: DepNodeParams<Ctxt>,\n+    {\n+        let hash = arg.to_fingerprint(tcx);\n+        let dep_node = DepNode { kind, hash };\n+\n+        #[cfg(debug_assertions)]\n+        {\n+            if !kind.can_reconstruct_query_key() && tcx.debug_dep_node() {\n+                tcx.dep_graph().register_dep_node_debug_str(dep_node, || arg.to_debug_str(tcx));\n+            }\n+        }\n+\n+        return dep_node;\n+    }\n }\n \n impl<K: DepKind> fmt::Debug for DepNode<K> {\n@@ -120,6 +138,12 @@ where\n     }\n }\n \n+impl<Ctxt: DepContext> DepNodeParams<Ctxt> for () {\n+    fn to_fingerprint(&self, _: Ctxt) -> Fingerprint {\n+        Fingerprint::ZERO\n+    }\n+}\n+\n /// A \"work product\" corresponds to a `.o` (or other) file that we\n /// save in between runs. These IDs do not have a `DefId` but rather\n /// some independent path or string that persists between runs without"}, {"sha": "f571e902211cd1996640f60bb02bb2c07b27caf9", "filename": "src/librustc_query_system/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dba944a6b79caf0056ddd282de01de70a0ff8a36/src%2Flibrustc_query_system%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dba944a6b79caf0056ddd282de01de70a0ff8a36/src%2Flibrustc_query_system%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fmod.rs?ref=dba944a6b79caf0056ddd282de01de70a0ff8a36", "patch": "@@ -28,6 +28,7 @@ pub trait DepContext: Copy {\n     fn create_stable_hashing_context(&self) -> Self::StableHashingContext;\n \n     fn debug_dep_tasks(&self) -> bool;\n+    fn debug_dep_node(&self) -> bool;\n \n     /// Try to force a dep node to execute and see if it's green.\n     fn try_force_from_dep_node(&self, dep_node: &DepNode<Self::DepKind>) -> bool;"}, {"sha": "f031b54346fa9b9eba98f91444985d3ff89f6155", "filename": "src/librustc_query_system/query/config.rs", "status": "modified", "additions": 76, "deletions": 3, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/dba944a6b79caf0056ddd282de01de70a0ff8a36/src%2Flibrustc_query_system%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dba944a6b79caf0056ddd282de01de70a0ff8a36/src%2Flibrustc_query_system%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fquery%2Fconfig.rs?ref=dba944a6b79caf0056ddd282de01de70a0ff8a36", "patch": "@@ -24,6 +24,53 @@ pub trait QueryConfig<CTX> {\n     type Stored: Clone;\n }\n \n+pub(crate) struct QueryVtable<CTX: QueryContext, K, V> {\n+    pub anon: bool,\n+    pub dep_kind: CTX::DepKind,\n+    pub eval_always: bool,\n+\n+    // Don't use this method to compute query results, instead use the methods on TyCtxt\n+    pub compute: fn(CTX, K) -> V,\n+\n+    pub hash_result: fn(&mut CTX::StableHashingContext, &V) -> Option<Fingerprint>,\n+    pub handle_cycle_error: fn(CTX, CycleError<CTX::Query>) -> V,\n+    pub cache_on_disk: fn(CTX, &K, Option<&V>) -> bool,\n+    pub try_load_from_disk: fn(CTX, SerializedDepNodeIndex) -> Option<V>,\n+}\n+\n+impl<CTX: QueryContext, K, V> QueryVtable<CTX, K, V> {\n+    pub(crate) fn to_dep_node(&self, tcx: CTX, key: &K) -> DepNode<CTX::DepKind>\n+    where\n+        K: crate::dep_graph::DepNodeParams<CTX>,\n+    {\n+        DepNode::construct(tcx, self.dep_kind, key)\n+    }\n+\n+    pub(crate) fn compute(&self, tcx: CTX, key: K) -> V {\n+        (self.compute)(tcx, key)\n+    }\n+\n+    pub(crate) fn hash_result(\n+        &self,\n+        hcx: &mut CTX::StableHashingContext,\n+        value: &V,\n+    ) -> Option<Fingerprint> {\n+        (self.hash_result)(hcx, value)\n+    }\n+\n+    pub(crate) fn handle_cycle_error(&self, tcx: CTX, error: CycleError<CTX::Query>) -> V {\n+        (self.handle_cycle_error)(tcx, error)\n+    }\n+\n+    pub(crate) fn cache_on_disk(&self, tcx: CTX, key: &K, value: Option<&V>) -> bool {\n+        (self.cache_on_disk)(tcx, key, value)\n+    }\n+\n+    pub(crate) fn try_load_from_disk(&self, tcx: CTX, index: SerializedDepNodeIndex) -> Option<V> {\n+        (self.try_load_from_disk)(tcx, index)\n+    }\n+}\n+\n pub trait QueryAccessors<CTX: QueryContext>: QueryConfig<CTX> {\n     const ANON: bool;\n     const EVAL_ALWAYS: bool;\n@@ -34,7 +81,12 @@ pub trait QueryAccessors<CTX: QueryContext>: QueryConfig<CTX> {\n     // Don't use this method to access query results, instead use the methods on TyCtxt\n     fn query_state<'a>(tcx: CTX) -> &'a QueryState<CTX, Self::Cache>;\n \n-    fn to_dep_node(tcx: CTX, key: &Self::Key) -> DepNode<CTX::DepKind>;\n+    fn to_dep_node(tcx: CTX, key: &Self::Key) -> DepNode<CTX::DepKind>\n+    where\n+        Self::Key: crate::dep_graph::DepNodeParams<CTX>,\n+    {\n+        DepNode::construct(tcx, Self::DEP_KIND, key)\n+    }\n \n     // Don't use this method to compute query results, instead use the methods on TyCtxt\n     fn compute(tcx: CTX, key: Self::Key) -> Self::Value;\n@@ -51,7 +103,7 @@ pub trait QueryDescription<CTX: QueryContext>: QueryAccessors<CTX> {\n     fn describe(tcx: CTX, key: Self::Key) -> Cow<'static, str>;\n \n     #[inline]\n-    fn cache_on_disk(_: CTX, _: Self::Key, _: Option<&Self::Value>) -> bool {\n+    fn cache_on_disk(_: CTX, _: &Self::Key, _: Option<&Self::Value>) -> bool {\n         false\n     }\n \n@@ -60,6 +112,27 @@ pub trait QueryDescription<CTX: QueryContext>: QueryAccessors<CTX> {\n     }\n }\n \n+pub(crate) trait QueryVtableExt<CTX: QueryContext, K, V> {\n+    const VTABLE: QueryVtable<CTX, K, V>;\n+}\n+\n+impl<CTX, Q> QueryVtableExt<CTX, Q::Key, Q::Value> for Q\n+where\n+    CTX: QueryContext,\n+    Q: QueryDescription<CTX>,\n+{\n+    const VTABLE: QueryVtable<CTX, Q::Key, Q::Value> = QueryVtable {\n+        anon: Q::ANON,\n+        dep_kind: Q::DEP_KIND,\n+        eval_always: Q::EVAL_ALWAYS,\n+        compute: Q::compute,\n+        hash_result: Q::hash_result,\n+        handle_cycle_error: Q::handle_cycle_error,\n+        cache_on_disk: Q::cache_on_disk,\n+        try_load_from_disk: Q::try_load_from_disk,\n+    };\n+}\n+\n impl<CTX: QueryContext, M> QueryDescription<CTX> for M\n where\n     M: QueryAccessors<CTX, Key = DefId>,\n@@ -73,7 +146,7 @@ where\n         }\n     }\n \n-    default fn cache_on_disk(_: CTX, _: Self::Key, _: Option<&Self::Value>) -> bool {\n+    default fn cache_on_disk(_: CTX, _: &Self::Key, _: Option<&Self::Value>) -> bool {\n         false\n     }\n "}, {"sha": "cc7d0a157035578311fd942daa348c7768c40b7b", "filename": "src/librustc_query_system/query/plumbing.rs", "status": "modified", "additions": 129, "deletions": 67, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/dba944a6b79caf0056ddd282de01de70a0ff8a36/src%2Flibrustc_query_system%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dba944a6b79caf0056ddd282de01de70a0ff8a36/src%2Flibrustc_query_system%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fquery%2Fplumbing.rs?ref=dba944a6b79caf0056ddd282de01de70a0ff8a36", "patch": "@@ -5,7 +5,7 @@\n use crate::dep_graph::{DepKind, DepNode};\n use crate::dep_graph::{DepNodeIndex, SerializedDepNodeIndex};\n use crate::query::caches::QueryCache;\n-use crate::query::config::QueryDescription;\n+use crate::query::config::{QueryDescription, QueryVtable, QueryVtableExt};\n use crate::query::job::{QueryInfo, QueryJob, QueryJobId, QueryJobInfo, QueryShardJobId};\n use crate::query::QueryContext;\n \n@@ -29,7 +29,7 @@ use std::ptr;\n #[cfg(debug_assertions)]\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n-pub struct QueryStateShard<CTX: QueryContext, K, C> {\n+pub(super) struct QueryStateShard<CTX: QueryContext, K, C> {\n     pub(super) cache: C,\n     active: FxHashMap<K, QueryResult<CTX>>,\n \n@@ -80,6 +80,7 @@ enum QueryResult<CTX: QueryContext> {\n }\n \n impl<CTX: QueryContext, C: QueryCache> QueryState<CTX, C> {\n+    #[inline(always)]\n     pub fn iter_results<R>(\n         &self,\n         f: impl for<'a> FnOnce(\n@@ -89,6 +90,7 @@ impl<CTX: QueryContext, C: QueryCache> QueryState<CTX, C> {\n         self.cache.iter(&self.shards, |shard| &mut shard.cache, f)\n     }\n \n+    #[inline(always)]\n     pub fn all_inactive(&self) -> bool {\n         let shards = self.shards.lock_shards();\n         shards.iter().all(|shard| shard.active.is_empty())\n@@ -168,14 +170,15 @@ where\n     /// This function is inlined because that results in a noticeable speed-up\n     /// for some compile-time benchmarks.\n     #[inline(always)]\n-    fn try_start<'a, 'b, Q>(\n+    fn try_start<'a, 'b>(\n         tcx: CTX,\n+        state: &'b QueryState<CTX, C>,\n         span: Span,\n         key: &C::Key,\n         mut lookup: QueryLookup<'a, CTX, C::Key, C::Sharded>,\n+        query: &QueryVtable<CTX, C::Key, C::Value>,\n     ) -> TryGetJob<'b, CTX, C>\n     where\n-        Q: QueryDescription<CTX, Key = C::Key, Stored = C::Stored, Value = C::Value, Cache = C>,\n         CTX: QueryContext,\n     {\n         let lock = &mut *lookup.lock;\n@@ -194,7 +197,7 @@ where\n                         };\n \n                         // Create the id of the job we're waiting for\n-                        let id = QueryJobId::new(job.id, lookup.shard, Q::DEP_KIND);\n+                        let id = QueryJobId::new(job.id, lookup.shard, query.dep_kind);\n \n                         (job.latch(id), _query_blocked_prof_timer)\n                     }\n@@ -209,15 +212,14 @@ where\n                 lock.jobs = id;\n                 let id = QueryShardJobId(NonZeroU32::new(id).unwrap());\n \n-                let global_id = QueryJobId::new(id, lookup.shard, Q::DEP_KIND);\n+                let global_id = QueryJobId::new(id, lookup.shard, query.dep_kind);\n \n                 let job = tcx.current_query_job();\n                 let job = QueryJob::new(id, span, job);\n \n                 entry.insert(QueryResult::Started(job));\n \n-                let owner =\n-                    JobOwner { state: Q::query_state(tcx), id: global_id, key: (*key).clone() };\n+                let owner = JobOwner { state, id: global_id, key: (*key).clone() };\n                 return TryGetJob::NotYetStarted(owner);\n             }\n         };\n@@ -227,8 +229,8 @@ where\n         // so we just return the error.\n         #[cfg(not(parallel_compiler))]\n         return TryGetJob::Cycle(cold_path(|| {\n-            let value = Q::handle_cycle_error(tcx, latch.find_cycle_in_stack(tcx, span));\n-            Q::query_state(tcx).cache.store_nocache(value)\n+            let value = query.handle_cycle_error(tcx, latch.find_cycle_in_stack(tcx, span));\n+            state.cache.store_nocache(value)\n         }));\n \n         // With parallel queries we might just have to wait on some other\n@@ -238,14 +240,14 @@ where\n             let result = latch.wait_on(tcx, span);\n \n             if let Err(cycle) = result {\n-                let value = Q::handle_cycle_error(tcx, cycle);\n-                let value = Q::query_state(tcx).cache.store_nocache(value);\n+                let value = query.handle_cycle_error(tcx, cycle);\n+                let value = state.cache.store_nocache(value);\n                 return TryGetJob::Cycle(value);\n             }\n \n             let cached = try_get_cached(\n                 tcx,\n-                Q::query_state(tcx),\n+                state,\n                 (*key).clone(),\n                 |value, index| (value.clone(), index),\n                 |_, _| panic!(\"value must be in cache after waiting\"),\n@@ -382,17 +384,21 @@ where\n }\n \n #[inline(always)]\n-fn try_execute_query<Q, CTX>(\n+fn try_execute_query<CTX, C>(\n     tcx: CTX,\n+    state: &QueryState<CTX, C>,\n     span: Span,\n-    key: Q::Key,\n-    lookup: QueryLookup<'_, CTX, Q::Key, <Q::Cache as QueryCache>::Sharded>,\n-) -> Q::Stored\n+    key: C::Key,\n+    lookup: QueryLookup<'_, CTX, C::Key, C::Sharded>,\n+    query: &QueryVtable<CTX, C::Key, C::Value>,\n+) -> C::Stored\n where\n-    Q: QueryDescription<CTX>,\n+    C: QueryCache,\n+    C::Key: Eq + Clone + Debug + crate::dep_graph::DepNodeParams<CTX>,\n+    C::Stored: Clone,\n     CTX: QueryContext,\n {\n-    let job = match JobOwner::try_start::<Q>(tcx, span, &key, lookup) {\n+    let job = match JobOwner::try_start(tcx, state, span, &key, lookup, query) {\n         TryGetJob::NotYetStarted(job) => job,\n         TryGetJob::Cycle(result) => return result,\n         #[cfg(parallel_compiler)]\n@@ -406,15 +412,15 @@ where\n     // expensive for some `DepKind`s.\n     if !tcx.dep_graph().is_fully_enabled() {\n         let null_dep_node = DepNode::new_no_params(DepKind::NULL);\n-        return force_query_with_job::<Q, _>(tcx, key, job, null_dep_node).0;\n+        return force_query_with_job(tcx, key, job, null_dep_node, query).0;\n     }\n \n-    if Q::ANON {\n+    if query.anon {\n         let prof_timer = tcx.profiler().query_provider();\n \n         let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n             tcx.start_query(job.id, diagnostics, |tcx| {\n-                tcx.dep_graph().with_anon_task(Q::DEP_KIND, || Q::compute(tcx, key))\n+                tcx.dep_graph().with_anon_task(query.dep_kind, || query.compute(tcx, key))\n             })\n         });\n \n@@ -429,22 +435,23 @@ where\n         return job.complete(tcx, result, dep_node_index);\n     }\n \n-    let dep_node = Q::to_dep_node(tcx, &key);\n+    let dep_node = query.to_dep_node(tcx, &key);\n \n-    if !Q::EVAL_ALWAYS {\n+    if !query.eval_always {\n         // The diagnostics for this query will be\n         // promoted to the current session during\n         // `try_mark_green()`, so we can ignore them here.\n         let loaded = tcx.start_query(job.id, None, |tcx| {\n             let marked = tcx.dep_graph().try_mark_green_and_read(tcx, &dep_node);\n             marked.map(|(prev_dep_node_index, dep_node_index)| {\n                 (\n-                    load_from_disk_and_cache_in_memory::<Q, _>(\n+                    load_from_disk_and_cache_in_memory(\n                         tcx,\n                         key.clone(),\n                         prev_dep_node_index,\n                         dep_node_index,\n                         &dep_node,\n+                        query,\n                     ),\n                     dep_node_index,\n                 )\n@@ -455,31 +462,31 @@ where\n         }\n     }\n \n-    let (result, dep_node_index) = force_query_with_job::<Q, _>(tcx, key, job, dep_node);\n+    let (result, dep_node_index) = force_query_with_job(tcx, key, job, dep_node, query);\n     tcx.dep_graph().read_index(dep_node_index);\n     result\n }\n \n-fn load_from_disk_and_cache_in_memory<Q, CTX>(\n+fn load_from_disk_and_cache_in_memory<CTX, K, V>(\n     tcx: CTX,\n-    key: Q::Key,\n+    key: K,\n     prev_dep_node_index: SerializedDepNodeIndex,\n     dep_node_index: DepNodeIndex,\n     dep_node: &DepNode<CTX::DepKind>,\n-) -> Q::Value\n+    query: &QueryVtable<CTX, K, V>,\n+) -> V\n where\n     CTX: QueryContext,\n-    Q: QueryDescription<CTX>,\n {\n     // Note this function can be called concurrently from the same query\n     // We must ensure that this is handled correctly.\n \n     debug_assert!(tcx.dep_graph().is_green(dep_node));\n \n     // First we try to load the result from the on-disk cache.\n-    let result = if Q::cache_on_disk(tcx, key.clone(), None) {\n+    let result = if query.cache_on_disk(tcx, &key, None) {\n         let prof_timer = tcx.profiler().incr_cache_loading();\n-        let result = Q::try_load_from_disk(tcx, prev_dep_node_index);\n+        let result = query.try_load_from_disk(tcx, prev_dep_node_index);\n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n         // We always expect to find a cached result for things that\n@@ -503,7 +510,7 @@ where\n         let prof_timer = tcx.profiler().query_provider();\n \n         // The dep-graph for this computation is already in-place.\n-        let result = tcx.dep_graph().with_ignore(|| Q::compute(tcx, key));\n+        let result = tcx.dep_graph().with_ignore(|| query.compute(tcx, key));\n \n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n@@ -513,22 +520,22 @@ where\n     // If `-Zincremental-verify-ich` is specified, re-hash results from\n     // the cache and make sure that they have the expected fingerprint.\n     if unlikely!(tcx.incremental_verify_ich()) {\n-        incremental_verify_ich::<Q, _>(tcx, &result, dep_node, dep_node_index);\n+        incremental_verify_ich(tcx, &result, dep_node, dep_node_index, query);\n     }\n \n     result\n }\n \n #[inline(never)]\n #[cold]\n-fn incremental_verify_ich<Q, CTX>(\n+fn incremental_verify_ich<CTX, K, V>(\n     tcx: CTX,\n-    result: &Q::Value,\n+    result: &V,\n     dep_node: &DepNode<CTX::DepKind>,\n     dep_node_index: DepNodeIndex,\n+    query: &QueryVtable<CTX, K, V>,\n ) where\n     CTX: QueryContext,\n-    Q: QueryDescription<CTX>,\n {\n     assert!(\n         Some(tcx.dep_graph().fingerprint_of(dep_node_index))\n@@ -540,7 +547,7 @@ fn incremental_verify_ich<Q, CTX>(\n     debug!(\"BEGIN verify_ich({:?})\", dep_node);\n     let mut hcx = tcx.create_stable_hashing_context();\n \n-    let new_hash = Q::hash_result(&mut hcx, result).unwrap_or(Fingerprint::ZERO);\n+    let new_hash = query.hash_result(&mut hcx, result).unwrap_or(Fingerprint::ZERO);\n     debug!(\"END verify_ich({:?})\", dep_node);\n \n     let old_hash = tcx.dep_graph().fingerprint_of(dep_node_index);\n@@ -549,14 +556,17 @@ fn incremental_verify_ich<Q, CTX>(\n }\n \n #[inline(always)]\n-fn force_query_with_job<Q, CTX>(\n+fn force_query_with_job<C, CTX>(\n     tcx: CTX,\n-    key: Q::Key,\n-    job: JobOwner<'_, CTX, Q::Cache>,\n+    key: C::Key,\n+    job: JobOwner<'_, CTX, C>,\n     dep_node: DepNode<CTX::DepKind>,\n-) -> (Q::Stored, DepNodeIndex)\n+    query: &QueryVtable<CTX, C::Key, C::Value>,\n+) -> (C::Stored, DepNodeIndex)\n where\n-    Q: QueryDescription<CTX>,\n+    C: QueryCache,\n+    C::Key: Eq + Clone + Debug,\n+    C::Stored: Clone,\n     CTX: QueryContext,\n {\n     // If the following assertion triggers, it can have two reasons:\n@@ -577,16 +587,16 @@ where\n \n     let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n         tcx.start_query(job.id, diagnostics, |tcx| {\n-            if Q::EVAL_ALWAYS {\n+            if query.eval_always {\n                 tcx.dep_graph().with_eval_always_task(\n                     dep_node,\n                     tcx,\n                     key,\n-                    Q::compute,\n-                    Q::hash_result,\n+                    query.compute,\n+                    query.hash_result,\n                 )\n             } else {\n-                tcx.dep_graph().with_task(dep_node, tcx, key, Q::compute, Q::hash_result)\n+                tcx.dep_graph().with_task(dep_node, tcx, key, query.compute, query.hash_result)\n             }\n         })\n     });\n@@ -605,22 +615,28 @@ where\n }\n \n #[inline(never)]\n-pub fn get_query<Q, CTX>(tcx: CTX, span: Span, key: Q::Key) -> Q::Stored\n+fn get_query_impl<CTX, C>(\n+    tcx: CTX,\n+    state: &QueryState<CTX, C>,\n+    span: Span,\n+    key: C::Key,\n+    query: &QueryVtable<CTX, C::Key, C::Value>,\n+) -> C::Stored\n where\n-    Q: QueryDescription<CTX>,\n     CTX: QueryContext,\n+    C: QueryCache,\n+    C::Key: Eq + Clone + crate::dep_graph::DepNodeParams<CTX>,\n+    C::Stored: Clone,\n {\n-    debug!(\"ty::query::get_query<{}>(key={:?}, span={:?})\", Q::NAME, key, span);\n-\n     try_get_cached(\n         tcx,\n-        Q::query_state(tcx),\n+        state,\n         key,\n         |value, index| {\n             tcx.dep_graph().read_index(index);\n             value.clone()\n         },\n-        |key, lookup| try_execute_query::<Q, _>(tcx, span, key, lookup),\n+        |key, lookup| try_execute_query(tcx, state, span, key, lookup, query),\n     )\n }\n \n@@ -631,20 +647,26 @@ where\n /// side-effects -- e.g., in order to report errors for erroneous programs.\n ///\n /// Note: The optimization is only available during incr. comp.\n-pub fn ensure_query<Q, CTX>(tcx: CTX, key: Q::Key)\n-where\n-    Q: QueryDescription<CTX>,\n+#[inline(never)]\n+fn ensure_query_impl<CTX, C>(\n+    tcx: CTX,\n+    state: &QueryState<CTX, C>,\n+    key: C::Key,\n+    query: &QueryVtable<CTX, C::Key, C::Value>,\n+) where\n+    C: QueryCache,\n+    C::Key: Eq + Clone + crate::dep_graph::DepNodeParams<CTX>,\n     CTX: QueryContext,\n {\n-    if Q::EVAL_ALWAYS {\n-        let _ = get_query::<Q, _>(tcx, DUMMY_SP, key);\n+    if query.eval_always {\n+        let _ = get_query_impl(tcx, state, DUMMY_SP, key, query);\n         return;\n     }\n \n     // Ensuring an anonymous query makes no sense\n-    assert!(!Q::ANON);\n+    assert!(!query.anon);\n \n-    let dep_node = Q::to_dep_node(tcx, &key);\n+    let dep_node = query.to_dep_node(tcx, &key);\n \n     match tcx.dep_graph().try_mark_green_and_read(tcx, &dep_node) {\n         None => {\n@@ -654,37 +676,77 @@ where\n             // DepNodeIndex. We must invoke the query itself. The performance cost\n             // this introduces should be negligible as we'll immediately hit the\n             // in-memory cache, or another query down the line will.\n-            let _ = get_query::<Q, _>(tcx, DUMMY_SP, key);\n+            let _ = get_query_impl(tcx, state, DUMMY_SP, key, query);\n         }\n         Some((_, dep_node_index)) => {\n             tcx.profiler().query_cache_hit(dep_node_index.into());\n         }\n     }\n }\n \n-pub fn force_query<Q, CTX>(tcx: CTX, key: Q::Key, span: Span, dep_node: DepNode<CTX::DepKind>)\n-where\n-    Q: QueryDescription<CTX>,\n+#[inline(never)]\n+fn force_query_impl<CTX, C>(\n+    tcx: CTX,\n+    state: &QueryState<CTX, C>,\n+    key: C::Key,\n+    span: Span,\n+    dep_node: DepNode<CTX::DepKind>,\n+    query: &QueryVtable<CTX, C::Key, C::Value>,\n+) where\n+    C: QueryCache,\n+    C::Key: Eq + Clone + crate::dep_graph::DepNodeParams<CTX>,\n     CTX: QueryContext,\n {\n     // We may be concurrently trying both execute and force a query.\n     // Ensure that only one of them runs the query.\n \n     try_get_cached(\n         tcx,\n-        Q::query_state(tcx),\n+        state,\n         key,\n         |_, _| {\n             // Cache hit, do nothing\n         },\n         |key, lookup| {\n-            let job = match JobOwner::try_start::<Q>(tcx, span, &key, lookup) {\n+            let job = match JobOwner::try_start(tcx, state, span, &key, lookup, query) {\n                 TryGetJob::NotYetStarted(job) => job,\n                 TryGetJob::Cycle(_) => return,\n                 #[cfg(parallel_compiler)]\n                 TryGetJob::JobCompleted(_) => return,\n             };\n-            force_query_with_job::<Q, _>(tcx, key, job, dep_node);\n+            force_query_with_job(tcx, key, job, dep_node, query);\n         },\n     );\n }\n+\n+#[inline(always)]\n+pub fn get_query<Q, CTX>(tcx: CTX, span: Span, key: Q::Key) -> Q::Stored\n+where\n+    Q: QueryDescription<CTX>,\n+    Q::Key: crate::dep_graph::DepNodeParams<CTX>,\n+    CTX: QueryContext,\n+{\n+    debug!(\"ty::query::get_query<{}>(key={:?}, span={:?})\", Q::NAME, key, span);\n+\n+    get_query_impl(tcx, Q::query_state(tcx), span, key, &Q::VTABLE)\n+}\n+\n+#[inline(always)]\n+pub fn ensure_query<Q, CTX>(tcx: CTX, key: Q::Key)\n+where\n+    Q: QueryDescription<CTX>,\n+    Q::Key: crate::dep_graph::DepNodeParams<CTX>,\n+    CTX: QueryContext,\n+{\n+    ensure_query_impl(tcx, Q::query_state(tcx), key, &Q::VTABLE)\n+}\n+\n+#[inline(always)]\n+pub fn force_query<Q, CTX>(tcx: CTX, key: Q::Key, span: Span, dep_node: DepNode<CTX::DepKind>)\n+where\n+    Q: QueryDescription<CTX>,\n+    Q::Key: crate::dep_graph::DepNodeParams<CTX>,\n+    CTX: QueryContext,\n+{\n+    force_query_impl(tcx, Q::query_state(tcx), key, span, dep_node, &Q::VTABLE)\n+}"}]}