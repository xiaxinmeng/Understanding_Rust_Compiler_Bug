{"sha": "6e4af4a2d19fe3a1e01c8acf23b6e3a4c0c6bd18", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlNGFmNGEyZDE5ZmUzYTFlMDFjOGFjZjIzYjZlM2E0YzBjNmJkMTg=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-01-18T21:21:29Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-02-19T16:51:56Z"}, "message": "Move definition of callbacks to parent module.", "tree": {"sha": "ae7542f6add59dc979c9e0b03e548ba32db586cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae7542f6add59dc979c9e0b03e548ba32db586cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e4af4a2d19fe3a1e01c8acf23b6e3a4c0c6bd18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e4af4a2d19fe3a1e01c8acf23b6e3a4c0c6bd18", "html_url": "https://github.com/rust-lang/rust/commit/6e4af4a2d19fe3a1e01c8acf23b6e3a4c0c6bd18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e4af4a2d19fe3a1e01c8acf23b6e3a4c0c6bd18/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4b1158f7845fe237053876abe1e690333c39bbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4b1158f7845fe237053876abe1e690333c39bbe", "html_url": "https://github.com/rust-lang/rust/commit/a4b1158f7845fe237053876abe1e690333c39bbe"}], "stats": {"total": 171, "additions": 88, "deletions": 83}, "files": [{"sha": "c090e2de1f48a1143585da0cfabdbcf5d5c660d2", "filename": "compiler/rustc_middle/src/ty/query/mod.rs", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/6e4af4a2d19fe3a1e01c8acf23b6e3a4c0c6bd18/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e4af4a2d19fe3a1e01c8acf23b6e3a4c0c6bd18/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs?ref=6e4af4a2d19fe3a1e01c8acf23b6e3a4c0c6bd18", "patch": "@@ -86,6 +86,93 @@ pub use self::on_disk_cache::OnDiskCache;\n mod profiling_support;\n pub use self::profiling_support::alloc_self_profile_query_strings;\n \n+#[derive(Copy, Clone)]\n+pub struct TyCtxtAt<'tcx> {\n+    pub tcx: TyCtxt<'tcx>,\n+    pub span: Span,\n+}\n+\n+impl Deref for TyCtxtAt<'tcx> {\n+    type Target = TyCtxt<'tcx>;\n+    #[inline(always)]\n+    fn deref(&self) -> &Self::Target {\n+        &self.tcx\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct TyCtxtEnsure<'tcx> {\n+    pub tcx: TyCtxt<'tcx>,\n+}\n+\n+impl TyCtxt<'tcx> {\n+    /// Returns a transparent wrapper for `TyCtxt`, which ensures queries\n+    /// are executed instead of just returning their results.\n+    #[inline(always)]\n+    pub fn ensure(self) -> TyCtxtEnsure<'tcx> {\n+        TyCtxtEnsure { tcx: self }\n+    }\n+\n+    /// Returns a transparent wrapper for `TyCtxt` which uses\n+    /// `span` as the location of queries performed through it.\n+    #[inline(always)]\n+    pub fn at(self, span: Span) -> TyCtxtAt<'tcx> {\n+        TyCtxtAt { tcx: self, span }\n+    }\n+}\n+\n+macro_rules! define_callbacks {\n+    (<$tcx:tt>\n+     $($(#[$attr:meta])*\n+        [$($modifiers:tt)*] fn $name:ident($($K:tt)*) -> $V:ty,)*) => {\n+\n+        impl TyCtxtEnsure<$tcx> {\n+            $($(#[$attr])*\n+            #[inline(always)]\n+            pub fn $name(self, key: query_helper_param_ty!($($K)*)) {\n+                let key = key.into_query_param();\n+                let cached = try_get_cached(self.tcx, &self.tcx.query_caches.$name, &key, |_| {});\n+\n+                let lookup = match cached {\n+                    Ok(()) => return,\n+                    Err(lookup) => lookup,\n+                };\n+\n+                self.tcx.queries.$name(self.tcx, DUMMY_SP, key, lookup, QueryMode::Ensure);\n+            })*\n+        }\n+\n+        impl TyCtxt<$tcx> {\n+            $($(#[$attr])*\n+            #[inline(always)]\n+            #[must_use]\n+            pub fn $name(self, key: query_helper_param_ty!($($K)*)) -> query_stored::$name<$tcx>\n+            {\n+                self.at(DUMMY_SP).$name(key)\n+            })*\n+        }\n+\n+        impl TyCtxtAt<$tcx> {\n+            $($(#[$attr])*\n+            #[inline(always)]\n+            pub fn $name(self, key: query_helper_param_ty!($($K)*)) -> query_stored::$name<$tcx>\n+            {\n+                let key = key.into_query_param();\n+                let cached = try_get_cached(self.tcx, &self.tcx.query_caches.$name, &key, |value| {\n+                    value.clone()\n+                });\n+\n+                let lookup = match cached {\n+                    Ok(value) => return value,\n+                    Err(lookup) => lookup,\n+                };\n+\n+                self.tcx.queries.$name(self.tcx, self.span, key, lookup, QueryMode::Get).unwrap()\n+            })*\n+        }\n+    }\n+}\n+\n // Each of these queries corresponds to a function pointer field in the\n // `Providers` struct for requesting a value of that type, and a method\n // on `tcx: TyCtxt` (and `tcx.at(span)`) for doing that request in a way\n@@ -99,6 +186,7 @@ pub use self::profiling_support::alloc_self_profile_query_strings;\n // as they will raise an fatal error on query cycles instead.\n \n rustc_query_append! { [define_queries!][<'tcx>] }\n+rustc_query_append! { [define_callbacks!][<'tcx>] }\n \n mod sealed {\n     use super::{DefId, LocalDefId};"}, {"sha": "0f38de35e51fa7eb8f25fe234a6db5546a254f79", "filename": "compiler/rustc_middle/src/ty/query/plumbing.rs", "status": "modified", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/6e4af4a2d19fe3a1e01c8acf23b6e3a4c0c6bd18/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e4af4a2d19fe3a1e01c8acf23b6e3a4c0c6bd18/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs?ref=6e4af4a2d19fe3a1e01c8acf23b6e3a4c0c6bd18", "patch": "@@ -456,89 +456,6 @@ macro_rules! define_queries {\n             }\n         })*\n \n-        #[derive(Copy, Clone)]\n-        pub struct TyCtxtEnsure<'tcx> {\n-            pub tcx: TyCtxt<'tcx>,\n-        }\n-\n-        impl TyCtxtEnsure<$tcx> {\n-            $($(#[$attr])*\n-            #[inline(always)]\n-            pub fn $name(self, key: query_helper_param_ty!($($K)*)) {\n-                let key = key.into_query_param();\n-                let cached = try_get_cached(self.tcx, &self.tcx.query_caches.$name, &key, |_| {});\n-\n-                let lookup = match cached {\n-                    Ok(()) => return,\n-                    Err(lookup) => lookup,\n-                };\n-\n-                self.tcx.queries.$name(self.tcx, DUMMY_SP, key, lookup, QueryMode::Ensure);\n-            })*\n-        }\n-\n-        #[derive(Copy, Clone)]\n-        pub struct TyCtxtAt<'tcx> {\n-            pub tcx: TyCtxt<'tcx>,\n-            pub span: Span,\n-        }\n-\n-        impl Deref for TyCtxtAt<'tcx> {\n-            type Target = TyCtxt<'tcx>;\n-            #[inline(always)]\n-            fn deref(&self) -> &Self::Target {\n-                &self.tcx\n-            }\n-        }\n-\n-        impl TyCtxt<$tcx> {\n-            /// Returns a transparent wrapper for `TyCtxt`, which ensures queries\n-            /// are executed instead of just returning their results.\n-            #[inline(always)]\n-            pub fn ensure(self) -> TyCtxtEnsure<$tcx> {\n-                TyCtxtEnsure {\n-                    tcx: self,\n-                }\n-            }\n-\n-            /// Returns a transparent wrapper for `TyCtxt` which uses\n-            /// `span` as the location of queries performed through it.\n-            #[inline(always)]\n-            pub fn at(self, span: Span) -> TyCtxtAt<$tcx> {\n-                TyCtxtAt {\n-                    tcx: self,\n-                    span\n-                }\n-            }\n-\n-            $($(#[$attr])*\n-            #[inline(always)]\n-            #[must_use]\n-            pub fn $name(self, key: query_helper_param_ty!($($K)*)) -> query_stored::$name<$tcx>\n-            {\n-                self.at(DUMMY_SP).$name(key)\n-            })*\n-        }\n-\n-        impl TyCtxtAt<$tcx> {\n-            $($(#[$attr])*\n-            #[inline(always)]\n-            pub fn $name(self, key: query_helper_param_ty!($($K)*)) -> query_stored::$name<$tcx>\n-            {\n-                let key = key.into_query_param();\n-                let cached = try_get_cached(self.tcx, &self.tcx.query_caches.$name, &key, |value| {\n-                    value.clone()\n-                });\n-\n-                let lookup = match cached {\n-                    Ok(value) => return value,\n-                    Err(lookup) => lookup,\n-                };\n-\n-                self.tcx.queries.$name(self.tcx, self.span, key, lookup, QueryMode::Get).unwrap()\n-            })*\n-        }\n-\n         define_provider_struct! {\n             tcx: $tcx,\n             input: ($(([$($modifiers)*] [$name] [$($K)*] [$V]))*)"}]}