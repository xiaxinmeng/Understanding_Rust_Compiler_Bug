{"sha": "b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3NWZlODEwNTVmNThiNmRlNDVmZjZmOWM1ZDQwNzcyZGMxZmE2ZGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-08T12:15:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-08T12:15:47Z"}, "message": "Auto merge of #28897 - steveklabnik:rollup, r=steveklabnik\n\n- Successful merges: #28836, #28856, #28874, #28876, #28878, #28880, #28882, #28885, #28889, #28896\n- Failed merges:", "tree": {"sha": "7c542679fc8fd7bf67bb716b7d20f6c70f93a9a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c542679fc8fd7bf67bb716b7d20f6c70f93a9a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc", "html_url": "https://github.com/rust-lang/rust/commit/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bcd27eb7d50978e823e61e477f2a4c2201ca34bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcd27eb7d50978e823e61e477f2a4c2201ca34bf", "html_url": "https://github.com/rust-lang/rust/commit/bcd27eb7d50978e823e61e477f2a4c2201ca34bf"}, {"sha": "0fbf7eaf8186811fad17ad66b9ea68cbe4906df5", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fbf7eaf8186811fad17ad66b9ea68cbe4906df5", "html_url": "https://github.com/rust-lang/rust/commit/0fbf7eaf8186811fad17ad66b9ea68cbe4906df5"}], "stats": {"total": 262, "additions": 178, "deletions": 84}, "files": [{"sha": "3851187b520349e09cb5150775b06bbc6cc212a2", "filename": "src/doc/style/style/comments.md", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc/src%2Fdoc%2Fstyle%2Fstyle%2Fcomments.md", "raw_url": "https://github.com/rust-lang/rust/raw/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc/src%2Fdoc%2Fstyle%2Fstyle%2Fcomments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Fcomments.md?ref=b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc", "patch": "@@ -85,3 +85,20 @@ Use inner doc comments _only_ to document crates and file-level modules:\n //!\n //! The core library is a something something...\n ```\n+\n+### Explain context.\n+\n+Rust doesn't have special constructors, only functions that return new\n+instances.  These aren't visible in the automatically generated documentation\n+for a type, so you should specifically link to them:\n+\n+``` rust\n+/// An iterator that yields `None` forever after the underlying iterator\n+/// yields `None` once.\n+///\n+/// These can be created through\n+/// [`iter.fuse()`](trait.Iterator.html#method.fuse).\n+pub struct Fuse<I> {\n+    // ...\n+}\n+```"}, {"sha": "9ef6d5c2bffbb4e083b8d7528aaa470eb2e05f79", "filename": "src/doc/trpl/advanced-linking.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc/src%2Fdoc%2Ftrpl%2Fadvanced-linking.md", "raw_url": "https://github.com/rust-lang/rust/raw/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc/src%2Fdoc%2Ftrpl%2Fadvanced-linking.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fadvanced-linking.md?ref=b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc", "patch": "@@ -26,7 +26,7 @@ shells out to the system linker (`gcc` on most systems, `link.exe` on MSVC),\n so it makes sense to provide extra command line\n arguments, but this will not always be the case. In the future `rustc` may use\n LLVM directly to link native libraries, in which case `link_args` will have no\n-meaning. You can achieve the same effect as the `link-args` attribute with the\n+meaning. You can achieve the same effect as the `link_args` attribute with the\n `-C link-args` argument to `rustc`.\n \n It is highly recommended to *not* use this attribute, and rather use the more\n@@ -71,7 +71,7 @@ Dynamic linking on Linux can be undesirable if you wish to use new library\n features on old systems or target systems which do not have the required\n dependencies for your program to run.\n \n-Static linking is supported via an alternative `libc`, `musl`. You can compile\n+Static linking is supported via an alternative `libc`, [`musl`](http://www.musl-libc.org). You can compile\n your own version of Rust with `musl` enabled and install it into a custom\n directory with the instructions below:\n "}, {"sha": "7d4452a4c847047d9478913034bcef43148ff17b", "filename": "src/doc/trpl/closures.md", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc/src%2Fdoc%2Ftrpl%2Fclosures.md", "raw_url": "https://github.com/rust-lang/rust/raw/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc/src%2Fdoc%2Ftrpl%2Fclosures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fclosures.md?ref=b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc", "patch": "@@ -1,9 +1,10 @@\n % Closures\n \n-Rust not only has named functions, but anonymous functions as well. Anonymous\n-functions that have an associated environment are called \u2018closures\u2019, because they\n-close over an environment. Rust has a really great implementation of them, as\n-we\u2019ll see.\n+Sometimes it is useful to wrap up a function and _free variables_ for better\n+clarity and reuse. The free variables that can be used come from the\n+enclosing scope and are \u2018closed over\u2019 when used in the function. From this, we\n+get the name \u2018closures\u2019 and Rust provides a really great implementation of\n+them, as we\u2019ll see.\n \n # Syntax\n \n@@ -34,7 +35,7 @@ assert_eq!(4, plus_two(2));\n ```\n \n You\u2019ll notice a few things about closures that are a bit different from regular\n-functions defined with `fn`. The first is that we did not need to\n+named functions defined with `fn`. The first is that we did not need to\n annotate the types of arguments the closure takes or the values it returns. We\n can:\n \n@@ -44,14 +45,15 @@ let plus_one = |x: i32| -> i32 { x + 1 };\n assert_eq!(2, plus_one(1));\n ```\n \n-But we don\u2019t have to. Why is this? Basically, it was chosen for ergonomic reasons.\n-While specifying the full type for named functions is helpful with things like\n-documentation and type inference, the types of closures are rarely documented\n-since they\u2019re anonymous, and they don\u2019t cause the kinds of error-at-a-distance\n-problems that inferring named function types can.\n+But we don\u2019t have to. Why is this? Basically, it was chosen for ergonomic\n+reasons. While specifying the full type for named functions is helpful with\n+things like documentation and type inference, the full type signatures of\n+closures are rarely documented since they\u2019re anonymous, and they don\u2019t cause\n+the kinds of error-at-a-distance problems that inferring named function types\n+can.\n \n-The second is that the syntax is similar, but a bit different. I\u2019ve added spaces\n-here for easier comparison:\n+The second is that the syntax is similar, but a bit different. I\u2019ve added\n+spaces here for easier comparison:\n \n ```rust\n fn  plus_one_v1   (x: i32) -> i32 { x + 1 }\n@@ -63,8 +65,8 @@ Small differences, but they\u2019re similar.\n \n # Closures and their environment\n \n-Closures are called such because they \u2018close over their environment\u2019. It\n-looks like this:\n+The environment for a closure can include bindings from its enclosing scope in\n+addition to parameters and local bindings. It looks like this:\n \n ```rust\n let num = 5;\n@@ -197,9 +199,10 @@ frame.  Without `move`, a closure may be tied to the stack frame that created\n it, while a `move` closure is self-contained. This means that you cannot\n generally return a non-`move` closure from a function, for example.\n \n-But before we talk about taking and returning closures, we should talk some more\n-about the way that closures are implemented. As a systems language, Rust gives\n-you tons of control over what your code does, and closures are no different.\n+But before we talk about taking and returning closures, we should talk some\n+more about the way that closures are implemented. As a systems language, Rust\n+gives you tons of control over what your code does, and closures are no\n+different.\n \n # Closure implementation\n \n@@ -288,9 +291,9 @@ isn\u2019t interesting. The next part is:\n #   some_closure(1) }\n ```\n \n-Because `Fn` is a trait, we can bound our generic with it. In this case, our closure\n-takes a `i32` as an argument and returns an `i32`, and so the generic bound we use\n-is `Fn(i32) -> i32`.\n+Because `Fn` is a trait, we can bound our generic with it. In this case, our\n+closure takes a `i32` as an argument and returns an `i32`, and so the generic\n+bound we use is `Fn(i32) -> i32`.\n \n There\u2019s one other key point here: because we\u2019re bounding a generic with a\n trait, this will get monomorphized, and therefore, we\u2019ll be doing static\n@@ -452,7 +455,7 @@ autogenerated name.\n The error also points out that the return type is expected to be a reference,\n but what we are trying to return is not. Further, we cannot directly assign a\n `'static` lifetime to an object. So we'll take a different approach and return\n-a \"trait object\" by `Box`ing up the `Fn`. This _almost_ works:\n+a \u2018trait object\u2019 by `Box`ing up the `Fn`. This _almost_ works:\n \n ```rust,ignore\n fn factory() -> Box<Fn(i32) -> i32> {"}, {"sha": "4a4648c7b563f4fe4bbcab815e54dbc9da7d6eb5", "filename": "src/doc/trpl/crates-and-modules.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "raw_url": "https://github.com/rust-lang/rust/raw/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md?ref=b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc", "patch": "@@ -563,8 +563,8 @@ What's going on here?\n First, both `extern crate` and `use` allow renaming the thing that is being\n imported. So the crate is still called \"phrases\", but here we will refer\n to it as \"sayings\". Similarly, the first `use` statement pulls in the\n-`japanese::farewells` module from the crate, but makes it available as\n-`jp_farewells` as opposed to simply `farewells`. This can help to avoid\n+`japanese::greetings` module from the crate, but makes it available as\n+`ja_greetings` as opposed to simply `greetings`. This can help to avoid\n ambiguity when importing similarly-named items from different places.\n \n The second `use` statement uses a star glob to bring in _all_ symbols from the"}, {"sha": "3350df4ff7f18031f2332630427d657272ada092", "filename": "src/doc/trpl/iterators.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc/src%2Fdoc%2Ftrpl%2Fiterators.md", "raw_url": "https://github.com/rust-lang/rust/raw/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc/src%2Fdoc%2Ftrpl%2Fiterators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fiterators.md?ref=b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc", "patch": "@@ -42,12 +42,12 @@ loop is just a handy way to write this `loop`/`match`/`break` construct.\n `for` loops aren't the only thing that uses iterators, however. Writing your\n own iterator involves implementing the `Iterator` trait. While doing that is\n outside of the scope of this guide, Rust provides a number of useful iterators\n-to accomplish various tasks. Before we talk about those, we should talk about a\n-Rust anti-pattern. And that's using ranges like this.\n+to accomplish various tasks. But first, a few notes about limitations of ranges.\n \n-Yes, we just talked about how ranges are cool. But ranges are also very\n-primitive. For example, if you needed to iterate over the contents of a vector,\n-you may be tempted to write this:\n+Ranges are very primitive, and we often can use better alternatives. Consider\n+following Rust anti-pattern: using ranges to emulate a C-style `for` loop. Let\u2019s\n+suppose you needed to iterate over the contents of a vector. You may be tempted\n+to write this:\n \n ```rust\n let nums = vec![1, 2, 3];\n@@ -281,8 +281,8 @@ If you are trying to execute a closure on an iterator for its side effects,\n just use `for` instead.\n \n There are tons of interesting iterator adapters. `take(n)` will return an\n-iterator over the next `n` elements of the original iterator. Let's try it out with our infinite\n-iterator from before:\n+iterator over the next `n` elements of the original iterator. Let's try it out\n+with an infinite iterator:\n \n ```rust\n for i in (1..).take(5) {"}, {"sha": "23569dd1b917e776461f8473aa01f55bb72a1e6d", "filename": "src/doc/trpl/lifetimes.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc/src%2Fdoc%2Ftrpl%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc/src%2Fdoc%2Ftrpl%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flifetimes.md?ref=b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc", "patch": "@@ -43,11 +43,11 @@ With that in mind, let\u2019s learn about lifetimes.\n Lending out a reference to a resource that someone else owns can be\n complicated. For example, imagine this set of operations:\n \n-- I acquire a handle to some kind of resource.\n-- I lend you a reference to the resource.\n-- I decide I\u2019m done with the resource, and deallocate it, while you still have\n+1. I acquire a handle to some kind of resource.\n+2. I lend you a reference to the resource.\n+3. I decide I\u2019m done with the resource, and deallocate it, while you still have\n   your reference.\n-- You decide to use the resource.\n+4. You decide to use the resource.\n \n Uh oh! Your reference is pointing to an invalid resource. This is called a\n dangling pointer or \u2018use after free\u2019, when the resource is memory."}, {"sha": "3d22066c72574a96727b3258644cf0303337c505", "filename": "src/doc/trpl/patterns.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc/src%2Fdoc%2Ftrpl%2Fpatterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc/src%2Fdoc%2Ftrpl%2Fpatterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpatterns.md?ref=b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc", "patch": "@@ -299,7 +299,7 @@ match x {\n ```\n \n This prints `no`, because the `if` applies to the whole of `4 | 5`, and not to\n-just the `5`, In other words, the the precedence of `if` behaves like this:\n+just the `5`. In other words, the precedence of `if` behaves like this:\n \n ```text\n (4 | 5) if y => ..."}, {"sha": "0d4c0bb6480086c34a71e37ed13c45458cf26e1e", "filename": "src/libcore/fmt/builders.rs", "status": "modified", "additions": 48, "deletions": 14, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc/src%2Flibcore%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc/src%2Flibcore%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fbuilders.rs?ref=b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc", "patch": "@@ -61,7 +61,8 @@ pub struct DebugStruct<'a, 'b: 'a> {\n     has_fields: bool,\n }\n \n-pub fn debug_struct_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>, name: &str)\n+pub fn debug_struct_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>,\n+                                name: &str)\n                                 -> DebugStruct<'a, 'b> {\n     let result = fmt.write_str(name);\n     DebugStruct {\n@@ -84,7 +85,8 @@ impl<'a, 'b: 'a> DebugStruct<'a, 'b> {\n \n             if self.is_pretty() {\n                 let mut writer = PadAdapter::new(self.fmt);\n-                fmt::write(&mut writer, format_args!(\"{}\\n{}: {:#?}\", prefix, name, value))\n+                fmt::write(&mut writer,\n+                           format_args!(\"{}\\n{}: {:#?}\", prefix, name, value))\n             } else {\n                 write!(self.fmt, \"{} {}: {:?}\", prefix, name, value)\n             }\n@@ -195,10 +197,18 @@ impl<'a, 'b: 'a> DebugInner<'a, 'b> {\n         self.result = self.result.and_then(|_| {\n             if self.is_pretty() {\n                 let mut writer = PadAdapter::new(self.fmt);\n-                let prefix = if self.has_fields { \",\" } else { \"\" };\n+                let prefix = if self.has_fields {\n+                    \",\"\n+                } else {\n+                    \"\"\n+                };\n                 fmt::write(&mut writer, format_args!(\"{}\\n{:#?}\", prefix, entry))\n             } else {\n-                let prefix = if self.has_fields { \", \" } else { \"\" };\n+                let prefix = if self.has_fields {\n+                    \", \"\n+                } else {\n+                    \"\"\n+                };\n                 write!(self.fmt, \"{}{:?}\", prefix, entry)\n             }\n         });\n@@ -207,7 +217,11 @@ impl<'a, 'b: 'a> DebugInner<'a, 'b> {\n     }\n \n     pub fn finish(&mut self) {\n-        let prefix = if self.is_pretty() && self.has_fields { \"\\n\" } else { \"\" };\n+        let prefix = if self.is_pretty() && self.has_fields {\n+            \"\\n\"\n+        } else {\n+            \"\"\n+        };\n         self.result = self.result.and_then(|_| self.fmt.write_str(prefix));\n     }\n \n@@ -232,7 +246,7 @@ pub fn debug_set_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugSet<'a, 'b\n             fmt: fmt,\n             result: result,\n             has_fields: false,\n-        }\n+        },\n     }\n }\n \n@@ -247,7 +261,9 @@ impl<'a, 'b: 'a> DebugSet<'a, 'b> {\n     /// Adds the contents of an iterator of entries to the set output.\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n     pub fn entries<D, I>(&mut self, entries: I) -> &mut DebugSet<'a, 'b>\n-            where D: fmt::Debug, I: IntoIterator<Item=D> {\n+        where D: fmt::Debug,\n+              I: IntoIterator<Item = D>\n+    {\n         for entry in entries {\n             self.entry(&entry);\n         }\n@@ -278,7 +294,7 @@ pub fn debug_list_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugList<'a,\n             fmt: fmt,\n             result: result,\n             has_fields: false,\n-        }\n+        },\n     }\n }\n \n@@ -293,7 +309,9 @@ impl<'a, 'b: 'a> DebugList<'a, 'b> {\n     /// Adds the contents of an iterator of entries to the list output.\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n     pub fn entries<D, I>(&mut self, entries: I) -> &mut DebugList<'a, 'b>\n-            where D: fmt::Debug, I: IntoIterator<Item=D> {\n+        where D: fmt::Debug,\n+              I: IntoIterator<Item = D>\n+    {\n         for entry in entries {\n             self.entry(&entry);\n         }\n@@ -335,10 +353,19 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n         self.result = self.result.and_then(|_| {\n             if self.is_pretty() {\n                 let mut writer = PadAdapter::new(self.fmt);\n-                let prefix = if self.has_fields { \",\" } else { \"\" };\n-                fmt::write(&mut writer, format_args!(\"{}\\n{:#?}: {:#?}\", prefix, key, value))\n+                let prefix = if self.has_fields {\n+                    \",\"\n+                } else {\n+                    \"\"\n+                };\n+                fmt::write(&mut writer,\n+                           format_args!(\"{}\\n{:#?}: {:#?}\", prefix, key, value))\n             } else {\n-                let prefix = if self.has_fields { \", \" } else { \"\" };\n+                let prefix = if self.has_fields {\n+                    \", \"\n+                } else {\n+                    \"\"\n+                };\n                 write!(self.fmt, \"{}{:?}: {:?}\", prefix, key, value)\n             }\n         });\n@@ -350,7 +377,10 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n     /// Adds the contents of an iterator of entries to the map output.\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n     pub fn entries<K, V, I>(&mut self, entries: I) -> &mut DebugMap<'a, 'b>\n-            where K: fmt::Debug, V: fmt::Debug, I: IntoIterator<Item=(K, V)> {\n+        where K: fmt::Debug,\n+              V: fmt::Debug,\n+              I: IntoIterator<Item = (K, V)>\n+    {\n         for (k, v) in entries {\n             self.entry(&k, &v);\n         }\n@@ -360,7 +390,11 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n     /// Finishes output and returns any error encountered.\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n     pub fn finish(&mut self) -> fmt::Result {\n-        let prefix = if self.is_pretty() && self.has_fields { \"\\n\" } else { \"\" };\n+        let prefix = if self.is_pretty() && self.has_fields {\n+            \"\\n\"\n+        } else {\n+            \"\"\n+        };\n         self.result.and_then(|_| write!(self.fmt, \"{}}}\", prefix))\n     }\n "}, {"sha": "23642790a88984ffe707820183d7dcb521d6ce06", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc", "patch": "@@ -48,7 +48,9 @@ trait GenericRadix {\n     fn base(&self) -> u8;\n \n     /// A radix-specific prefix string.\n-    fn prefix(&self) -> &'static str { \"\" }\n+    fn prefix(&self) -> &'static str {\n+        \"\"\n+    }\n \n     /// Converts an integer to corresponding radix digit.\n     fn digit(&self, x: u8) -> u8;\n@@ -70,7 +72,10 @@ trait GenericRadix {\n                 x = x / base;                  // Deaccumulate the number.\n                 *byte = self.digit(n.to_u8()); // Store the digit in the buffer.\n                 curr -= 1;\n-                if x == zero { break };        // No more digits left to accumulate.\n+                if x == zero {\n+                    // No more digits left to accumulate.\n+                    break\n+                };\n             }\n         } else {\n             // Do the same as above, but accounting for two's complement.\n@@ -79,7 +84,10 @@ trait GenericRadix {\n                 x = x / base;                  // Deaccumulate the number.\n                 *byte = self.digit(n.to_u8()); // Store the digit in the buffer.\n                 curr -= 1;\n-                if x == zero { break };        // No more digits left to accumulate.\n+                if x == zero {\n+                    // No more digits left to accumulate.\n+                    break\n+                };\n             }\n         }\n         let buf = unsafe { str::from_utf8_unchecked(&buf[curr..]) };\n@@ -141,13 +149,17 @@ pub struct Radix {\n \n impl Radix {\n     fn new(base: u8) -> Radix {\n-        assert!(2 <= base && base <= 36, \"the base must be in the range of 2..36: {}\", base);\n+        assert!(2 <= base && base <= 36,\n+                \"the base must be in the range of 2..36: {}\",\n+                base);\n         Radix { base: base }\n     }\n }\n \n impl GenericRadix for Radix {\n-    fn base(&self) -> u8 { self.base }\n+    fn base(&self) -> u8 {\n+        self.base\n+    }\n     fn digit(&self, x: u8) -> u8 {\n         match x {\n             x @  0 ... 9 => b'0' + x,"}, {"sha": "f889045a3f59568b14eeca4689a0bf21c11975d1", "filename": "src/libcore/fmt/rt/v1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs?ref=b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc", "patch": "@@ -53,5 +53,5 @@ pub enum Count {\n #[derive(Copy, Clone)]\n pub enum Position {\n     Next,\n-    At(usize)\n+    At(usize),\n }"}, {"sha": "4e038f455e1bea1bc5b17d851fbfea1f7bfdaaa1", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc", "patch": "@@ -100,7 +100,9 @@ pub trait Hash {\n \n     /// Feeds a slice of this type into the state provided.\n     #[stable(feature = \"hash_slice\", since = \"1.3.0\")]\n-    fn hash_slice<H: Hasher>(data: &[Self], state: &mut H) where Self: Sized {\n+    fn hash_slice<H: Hasher>(data: &[Self], state: &mut H)\n+        where Self: Sized\n+    {\n         for piece in data {\n             piece.hash(state);\n         }\n@@ -121,7 +123,9 @@ pub trait Hasher {\n     /// Write a single `u8` into this hasher\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n-    fn write_u8(&mut self, i: u8) { self.write(&[i]) }\n+    fn write_u8(&mut self, i: u8) {\n+        self.write(&[i])\n+    }\n     /// Write a single `u16` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n@@ -145,32 +149,41 @@ pub trait Hasher {\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n     fn write_usize(&mut self, i: usize) {\n         let bytes = unsafe {\n-            ::slice::from_raw_parts(&i as *const usize as *const u8,\n-                                    mem::size_of::<usize>())\n+            ::slice::from_raw_parts(&i as *const usize as *const u8, mem::size_of::<usize>())\n         };\n         self.write(bytes);\n     }\n \n     /// Write a single `i8` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n-    fn write_i8(&mut self, i: i8) { self.write_u8(i as u8) }\n+    fn write_i8(&mut self, i: i8) {\n+        self.write_u8(i as u8)\n+    }\n     /// Write a single `i16` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n-    fn write_i16(&mut self, i: i16) { self.write_u16(i as u16) }\n+    fn write_i16(&mut self, i: i16) {\n+        self.write_u16(i as u16)\n+    }\n     /// Write a single `i32` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n-    fn write_i32(&mut self, i: i32) { self.write_u32(i as u32) }\n+    fn write_i32(&mut self, i: i32) {\n+        self.write_u32(i as u32)\n+    }\n     /// Write a single `i64` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n-    fn write_i64(&mut self, i: i64) { self.write_u64(i as u64) }\n+    fn write_i64(&mut self, i: i64) {\n+        self.write_u64(i as u64)\n+    }\n     /// Write a single `isize` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n-    fn write_isize(&mut self, i: isize) { self.write_usize(i as usize) }\n+    fn write_isize(&mut self, i: isize) {\n+        self.write_usize(i as usize)\n+    }\n }\n \n //////////////////////////////////////////////////////////////////////////////"}, {"sha": "722d77a8a11efeccdc26f0eecfdf8eb905a1f999", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc", "patch": "@@ -37,12 +37,12 @@ pub struct SipHasher {\n     // and simd implementations of SipHash will use vectors\n     // of v02 and v13. By placing them in this order in the struct,\n     // the compiler can pick up on just a few simd optimizations by itself.\n-    v0: u64,      // hash state\n+    v0: u64, // hash state\n     v2: u64,\n     v1: u64,\n     v3: u64,\n     tail: u64, // unprocessed bytes le\n-    ntail: usize,  // how many bytes in tail are valid\n+    ntail: usize, // how many bytes in tail are valid\n }\n \n // sadly, these macro definitions can't appear later,\n@@ -80,8 +80,7 @@ macro_rules! u8to64_le {\n unsafe fn load_u64_le(buf: &[u8], i: usize) -> u64 {\n     debug_assert!(i + 8 <= buf.len());\n     let mut data = 0u64;\n-    ptr::copy_nonoverlapping(buf.get_unchecked(i),\n-                             &mut data as *mut _ as *mut u8, 8);\n+    ptr::copy_nonoverlapping(buf.get_unchecked(i), &mut data as *mut _ as *mut u8, 8);\n     data.to_le()\n }\n \n@@ -152,12 +151,12 @@ impl Hasher for SipHasher {\n         if self.ntail != 0 {\n             needed = 8 - self.ntail;\n             if length < needed {\n-                self.tail |= u8to64_le!(msg, 0, length) << 8*self.ntail;\n+                self.tail |= u8to64_le!(msg, 0, length) << 8 * self.ntail;\n                 self.ntail += length;\n                 return\n             }\n \n-            let m = self.tail | u8to64_le!(msg, 0, needed) << 8*self.ntail;\n+            let m = self.tail | u8to64_le!(msg, 0, needed) << 8 * self.ntail;\n \n             self.v3 ^= m;\n             compress!(self.v0, self.v1, self.v2, self.v3);"}, {"sha": "0e4c6d1676e63cf60c9a5ff7369cb9e024f94eb9", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc", "patch": "@@ -706,7 +706,8 @@ impl<T> Option<T> {\n }\n \n impl<'a, T: Clone> Option<&'a T> {\n-    /// Maps an Option<&T> to an Option<T> by cloning the contents of the Option.\n+    /// Maps an `Option<&T>` to an `Option<T>` by cloning the contents of the\n+    /// option.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn cloned(self) -> Option<T> {\n         self.map(|t| t.clone())"}, {"sha": "05236a7a6fb2823fffee6d1b20ea2105953d4edb", "filename": "src/librustc_trans/diagnostics.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc/src%2Flibrustc_trans%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc/src%2Flibrustc_trans%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdiagnostics.rs?ref=b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc", "patch": "@@ -12,6 +12,21 @@\n \n register_long_diagnostics! {\n \n+E0515: r##\"\n+A constant index expression was out of bounds. Erroneous code example:\n+\n+```\n+let x = &[0, 1, 2][7]; // error: const index-expr is out of bounds\n+```\n+\n+Please specify a valid index (not inferior to 0 or superior to array length).\n+Example:\n+\n+```\n+let x = &[0, 1, 2][2]; // ok!\n+```\n+\"##,\n+\n }\n \n register_diagnostics! {"}, {"sha": "0cae0ae59ba5703c5771ee311a4725d6bb917dd7", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc", "patch": "@@ -628,8 +628,8 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             if iv >= len {\n                 // FIXME #3170: report this earlier on in the const-eval\n                 // pass. Reporting here is a bit late.\n-                cx.sess().span_err(e.span,\n-                                   \"const index-expr is out of bounds\");\n+                span_err!(cx.sess(), e.span, E0515,\n+                          \"const index-expr is out of bounds\");\n                 C_undef(val_ty(arr).element_type())\n             } else {\n                 const_get_elt(cx, arr, &[iv as c_uint])"}, {"sha": "5c8db524cc2edeec729b4efb9949333bace83422", "filename": "src/test/run-pass/lexer-crlf-line-endings-string-literal-doc-comment.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc/src%2Ftest%2Frun-pass%2Flexer-crlf-line-endings-string-literal-doc-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc/src%2Ftest%2Frun-pass%2Flexer-crlf-line-endings-string-literal-doc-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flexer-crlf-line-endings-string-literal-doc-comment.rs?ref=b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc", "patch": "@@ -1,7 +1,7 @@\n // ignore-tidy-cr ignore-license\r\n // ignore-tidy-cr (repeated again because of tidy bug)\r\n // license is ignored because tidy can't handle the CRLF here properly.\r\n-\n+\r\n // Copyright 2014 The Rust Project Developers. See the COPYRIGHT\r\n // file at the top-level directory of this distribution and at\r\n // http://rust-lang.org/COPYRIGHT.\r\n@@ -11,33 +11,33 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\r\n // option. This file may not be copied, modified, or distributed\r\n // except according to those terms.\r\n-\n+\r\n // NB: this file needs CRLF line endings. The .gitattributes file in\r\n // this directory should enforce it.\r\n-\n+\r\n // ignore-pretty\r\n-\n+\r\n /// Doc comment that ends in CRLF\r\n pub fn foo() {}\r\n-\n+\r\n /** Block doc comment that\r\n  *  contains CRLF characters\r\n  */\r\n pub fn bar() {}\r\n-\n+\r\n fn main() {\r\n     let s = \"string\r\n literal\";\r\n     assert_eq!(s, \"string\\nliteral\");\r\n-\n+\r\n     let s = \"literal with \\\r\n              escaped newline\";\r\n     assert_eq!(s, \"literal with escaped newline\");\r\n-\n+\r\n     let s = r\"string\r\n literal\";\r\n     assert_eq!(s, \"string\\nliteral\");\r\n-\n+\r\n     // validate that our source file has CRLF endings\r\n     let source = include_str!(\"lexer-crlf-line-endings-string-literal-doc-comment.rs\");\r\n     assert!(source.contains(\"string\\r\\nliteral\"));\r"}]}