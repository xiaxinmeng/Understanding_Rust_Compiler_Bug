{"sha": "71bdb8481760f7c6b8540d3dd176ed54a92c0f31", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxYmRiODQ4MTc2MGY3YzZiODU0MGQzZGQxNzZlZDU0YTkyYzBmMzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-27T08:12:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-27T08:12:29Z"}, "message": "Auto merge of #76955 - jyn514:refactor-diagnostics, r=euclio\n\nRefactor and fix intra-doc link diagnostics, and fix links to primitives\n\nCloses https://github.com/rust-lang/rust/issues/76925, closes https://github.com/rust-lang/rust/issues/76693, closes https://github.com/rust-lang/rust/issues/76692.\n\nOriginally I only meant to fix #76925. But the hack with `has_primitive` was so bad it was easier to fix the primitive issues than to try and work around it.\n\nNote that this still has one bug: `std::primitive::i32::MAX` does not resolve. However, this fixes the ICE so I'm fine with fixing the link in a later PR.\n\nThis is part of a series of refactors to make #76467 possible.\n\nThis is best reviewed commit-by-commit; it has detailed commit messages.\n\nr? `@euclio`", "tree": {"sha": "ff759d0a968f0e6f310c88eaf27d618764b021be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff759d0a968f0e6f310c88eaf27d618764b021be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71bdb8481760f7c6b8540d3dd176ed54a92c0f31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71bdb8481760f7c6b8540d3dd176ed54a92c0f31", "html_url": "https://github.com/rust-lang/rust/commit/71bdb8481760f7c6b8540d3dd176ed54a92c0f31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71bdb8481760f7c6b8540d3dd176ed54a92c0f31/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9e5e6a53aef5cd1b939ecfa18f56bdf5bf0451c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9e5e6a53aef5cd1b939ecfa18f56bdf5bf0451c", "html_url": "https://github.com/rust-lang/rust/commit/c9e5e6a53aef5cd1b939ecfa18f56bdf5bf0451c"}, {"sha": "049d29bac580b958cdff6e898dad22de09a27958", "url": "https://api.github.com/repos/rust-lang/rust/commits/049d29bac580b958cdff6e898dad22de09a27958", "html_url": "https://github.com/rust-lang/rust/commit/049d29bac580b958cdff6e898dad22de09a27958"}], "stats": {"total": 608, "additions": 329, "deletions": 279}, "files": [{"sha": "636f67a77c890a4035373c58d5550110d106948c", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/71bdb8481760f7c6b8540d3dd176ed54a92c0f31/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71bdb8481760f7c6b8540d3dd176ed54a92c0f31/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=71bdb8481760f7c6b8540d3dd176ed54a92c0f31", "patch": "@@ -2004,6 +2004,30 @@ pub enum PrimTy {\n     Char,\n }\n \n+impl PrimTy {\n+    pub fn name_str(self) -> &'static str {\n+        match self {\n+            PrimTy::Int(i) => i.name_str(),\n+            PrimTy::Uint(u) => u.name_str(),\n+            PrimTy::Float(f) => f.name_str(),\n+            PrimTy::Str => \"str\",\n+            PrimTy::Bool => \"bool\",\n+            PrimTy::Char => \"char\",\n+        }\n+    }\n+\n+    pub fn name(self) -> Symbol {\n+        match self {\n+            PrimTy::Int(i) => i.name(),\n+            PrimTy::Uint(u) => u.name(),\n+            PrimTy::Float(f) => f.name(),\n+            PrimTy::Str => sym::str,\n+            PrimTy::Bool => sym::bool,\n+            PrimTy::Char => sym::char,\n+        }\n+    }\n+}\n+\n #[derive(Debug, HashStable_Generic)]\n pub struct BareFnTy<'hir> {\n     pub unsafety: Unsafety,"}, {"sha": "5d74a3da9a2050f1ba80020407b89d85af10f3c4", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 204, "deletions": 231, "changes": 435, "blob_url": "https://github.com/rust-lang/rust/blob/71bdb8481760f7c6b8540d3dd176ed54a92c0f31/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71bdb8481760f7c6b8540d3dd176ed54a92c0f31/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=71bdb8481760f7c6b8540d3dd176ed54a92c0f31", "patch": "@@ -57,45 +57,16 @@ enum ResolutionFailure<'a> {\n     /// This resolved, but with the wrong namespace.\n     /// `Namespace` is the expected namespace (as opposed to the actual).\n     WrongNamespace(Res, Namespace),\n-    /// This has a partial resolution, but is not in the TypeNS and so cannot\n-    /// have associated items or fields.\n-    CannotHaveAssociatedItems(Res, Namespace),\n-    /// `name` is the base name of the path (not necessarily the whole link)\n-    NotInScope { module_id: DefId, name: Cow<'a, str> },\n-    /// this is a primitive type without an impls (no associated methods)\n-    /// when will this actually happen?\n-    /// the `Res` is the primitive it resolved to\n-    NoPrimitiveImpl(Res, String),\n-    /// `[u8::not_found]`\n-    /// the `Res` is the primitive it resolved to\n-    NoPrimitiveAssocItem { res: Res, prim_name: &'a str, assoc_item: Symbol },\n-    /// `[S::not_found]`\n-    /// the `String` is the associated item that wasn't found\n-    NoAssocItem(Res, Symbol),\n+    /// The link failed to resolve. `resolution_failure` should look to see if there's\n+    /// a more helpful error that can be given.\n+    NotResolved { module_id: DefId, partial_res: Option<Res>, unresolved: Cow<'a, str> },\n     /// should not ever happen\n     NoParentItem,\n-    /// this could be an enum variant, but the last path fragment wasn't resolved.\n-    /// the `String` is the variant that didn't exist\n-    NotAVariant(Res, Symbol),\n     /// used to communicate that this should be ignored, but shouldn't be reported to the user\n     Dummy,\n }\n \n impl ResolutionFailure<'a> {\n-    // A partial or full resolution\n-    fn res(&self) -> Option<Res> {\n-        use ResolutionFailure::*;\n-        match self {\n-            NoPrimitiveAssocItem { res, .. }\n-            | NoAssocItem(res, _)\n-            | NoPrimitiveImpl(res, _)\n-            | NotAVariant(res, _)\n-            | WrongNamespace(res, _)\n-            | CannotHaveAssociatedItems(res, _) => Some(*res),\n-            NotInScope { .. } | NoParentItem | Dummy => None,\n-        }\n-    }\n-\n     // This resolved fully (not just partially) but is erroneous for some other reason\n     fn full_res(&self) -> Option<Res> {\n         match self {\n@@ -130,22 +101,25 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         path_str: &'path str,\n         current_item: &Option<String>,\n         module_id: DefId,\n-        extra_fragment: &Option<String>,\n     ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n         let cx = self.cx;\n+        let no_res = || ResolutionFailure::NotResolved {\n+            module_id,\n+            partial_res: None,\n+            unresolved: path_str.into(),\n+        };\n \n         debug!(\"looking for enum variant {}\", path_str);\n         let mut split = path_str.rsplitn(3, \"::\");\n-        let variant_field_name = split\n+        let (variant_field_str, variant_field_name) = split\n             .next()\n-            .map(|f| Symbol::intern(f))\n+            .map(|f| (f, Symbol::intern(f)))\n             .expect(\"fold_item should ensure link is non-empty\");\n-        let variant_name =\n+        let (variant_str, variant_name) =\n             // we're not sure this is a variant at all, so use the full string\n-            split.next().map(|f| Symbol::intern(f)).ok_or_else(|| ResolutionFailure::NotInScope {\n-                module_id,\n-                name: path_str.into(),\n-            })?;\n+            // If there's no second component, the link looks like `[path]`.\n+            // So there's no partial res and we should say the whole link failed to resolve.\n+            split.next().map(|f| (f, Symbol::intern(f))).ok_or_else(no_res)?;\n         let path = split\n             .next()\n             .map(|f| {\n@@ -156,18 +130,17 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 }\n                 f.to_owned()\n             })\n-            .ok_or_else(|| ResolutionFailure::NotInScope {\n-                module_id,\n-                name: variant_name.to_string().into(),\n-            })?;\n+            // If there's no third component, we saw `[a::b]` before and it failed to resolve.\n+            // So there's no partial res.\n+            .ok_or_else(no_res)?;\n         let ty_res = cx\n             .enter_resolver(|resolver| {\n                 resolver.resolve_str_path_error(DUMMY_SP, &path, TypeNS, module_id)\n             })\n             .map(|(_, res)| res)\n             .unwrap_or(Res::Err);\n         if let Res::Err = ty_res {\n-            return Err(ResolutionFailure::NotInScope { module_id, name: path.into() }.into());\n+            return Err(no_res().into());\n         }\n         let ty_res = ty_res.map_id(|_| panic!(\"unexpected node_id\"));\n         match ty_res {\n@@ -190,38 +163,27 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                                 ty_res,\n                                 Some(format!(\n                                     \"variant.{}.field.{}\",\n-                                    variant_name, variant_field_name\n+                                    variant_str, variant_field_name\n                                 )),\n                             ))\n                         } else {\n-                            Err(ResolutionFailure::NotAVariant(ty_res, variant_field_name).into())\n+                            Err(ResolutionFailure::NotResolved {\n+                                module_id,\n+                                partial_res: Some(Res::Def(DefKind::Enum, def.did)),\n+                                unresolved: variant_field_str.into(),\n+                            }\n+                            .into())\n                         }\n                     }\n                     _ => unreachable!(),\n                 }\n             }\n-            // `variant_field` looks at 3 different path segments in a row.\n-            // But `NoAssocItem` assumes there are only 2. Check to see if there's\n-            // an intermediate segment that resolves.\n-            _ => {\n-                let intermediate_path = format!(\"{}::{}\", path, variant_name);\n-                // NOTE: we have to be careful here, because we're already in `resolve`.\n-                // We know this doesn't recurse forever because we use a shorter path each time.\n-                // NOTE: this uses `TypeNS` because nothing else has a valid path segment after\n-                let kind = if let Some(intermediate) = self.check_full_res(\n-                    TypeNS,\n-                    &intermediate_path,\n-                    module_id,\n-                    current_item,\n-                    extra_fragment,\n-                ) {\n-                    ResolutionFailure::NoAssocItem(intermediate, variant_field_name)\n-                } else {\n-                    // Even with the shorter path, it didn't resolve, so say that.\n-                    ResolutionFailure::NoAssocItem(ty_res, variant_name)\n-                };\n-                Err(kind.into())\n+            _ => Err(ResolutionFailure::NotResolved {\n+                module_id,\n+                partial_res: Some(ty_res),\n+                unresolved: variant_str.into(),\n             }\n+            .into()),\n         }\n     }\n \n@@ -242,11 +204,11 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 false,\n             ) {\n                 if let SyntaxExtensionKind::LegacyBang { .. } = ext.kind {\n-                    return Some(Ok(res.map_id(|_| panic!(\"unexpected id\"))));\n+                    return Ok(res.map_id(|_| panic!(\"unexpected id\")));\n                 }\n             }\n             if let Some(res) = resolver.all_macros().get(&Symbol::intern(path_str)) {\n-                return Some(Ok(res.map_id(|_| panic!(\"unexpected id\"))));\n+                return Ok(res.map_id(|_| panic!(\"unexpected id\")));\n             }\n             debug!(\"resolving {} as a macro in the module {:?}\", path_str, module_id);\n             if let Ok((_, res)) =\n@@ -255,28 +217,14 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 // don't resolve builtins like `#[derive]`\n                 if let Res::Def(..) = res {\n                     let res = res.map_id(|_| panic!(\"unexpected node_id\"));\n-                    return Some(Ok(res));\n-                }\n-            }\n-            None\n-        })\n-        // This weird control flow is so we don't borrow the resolver more than once at a time\n-        .unwrap_or_else(|| {\n-            let mut split = path_str.rsplitn(2, \"::\");\n-            if let Some((parent, base)) = split.next().and_then(|x| Some((split.next()?, x))) {\n-                if let Some(res) = self.check_full_res(TypeNS, parent, module_id, &None, &None) {\n-                    return Err(if matches!(res, Res::PrimTy(_)) {\n-                        ResolutionFailure::NoPrimitiveAssocItem {\n-                            res,\n-                            prim_name: parent,\n-                            assoc_item: Symbol::intern(base),\n-                        }\n-                    } else {\n-                        ResolutionFailure::NoAssocItem(res, Symbol::intern(base))\n-                    });\n+                    return Ok(res);\n                 }\n             }\n-            Err(ResolutionFailure::NotInScope { module_id, name: path_str.into() })\n+            Err(ResolutionFailure::NotResolved {\n+                module_id,\n+                partial_res: None,\n+                unresolved: path_str.into(),\n+            })\n         })\n     }\n \n@@ -312,13 +260,13 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     return handle_variant(cx, res, extra_fragment);\n                 }\n                 // Not a trait item; just return what we found.\n-                Res::PrimTy(..) => {\n+                Res::PrimTy(ty) => {\n                     if extra_fragment.is_some() {\n                         return Err(ErrorKind::AnchorFailure(\n                             AnchorFailure::RustdocAnchorConflict(res),\n                         ));\n                     }\n-                    return Ok((res, Some(path_str.to_owned())));\n+                    return Ok((res, Some(ty.name_str().to_owned())));\n                 }\n                 Res::Def(DefKind::Mod, _) => {\n                     return Ok((res, extra_fragment.clone()));\n@@ -331,6 +279,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             if value != (ns == ValueNS) {\n                 return Err(ResolutionFailure::WrongNamespace(res, ns).into());\n             }\n+        // FIXME: why is this necessary?\n         } else if let Some((path, prim)) = is_primitive(path_str, ns) {\n             if extra_fragment.is_some() {\n                 return Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(prim)));\n@@ -341,7 +290,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         // Try looking for methods and associated items.\n         let mut split = path_str.rsplitn(2, \"::\");\n         // this can be an `unwrap()` because we ensure the link is never empty\n-        let item_name = Symbol::intern(split.next().unwrap());\n+        let (item_str, item_name) = split.next().map(|i| (i, Symbol::intern(i))).unwrap();\n         let path_root = split\n             .next()\n             .map(|f| {\n@@ -356,12 +305,20 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             // So we can be sure that `rustc_resolve` was accurate when it said it wasn't resolved.\n             .ok_or_else(|| {\n                 debug!(\"found no `::`, assumming {} was correctly not in scope\", item_name);\n-                ResolutionFailure::NotInScope { module_id, name: item_name.to_string().into() }\n+                ResolutionFailure::NotResolved {\n+                    module_id,\n+                    partial_res: None,\n+                    unresolved: item_str.into(),\n+                }\n             })?;\n \n         if let Some((path, prim)) = is_primitive(&path_root, TypeNS) {\n-            let impls = primitive_impl(cx, &path)\n-                .ok_or_else(|| ResolutionFailure::NoPrimitiveImpl(prim, path_root.into()))?;\n+            let impls =\n+                primitive_impl(cx, &path).ok_or_else(|| ResolutionFailure::NotResolved {\n+                    module_id,\n+                    partial_res: Some(prim),\n+                    unresolved: item_str.into(),\n+                })?;\n             for &impl_ in impls {\n                 let link = cx\n                     .tcx\n@@ -377,7 +334,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         ty::AssocKind::Const => \"associatedconstant\",\n                         ty::AssocKind::Type => \"associatedtype\",\n                     })\n-                    .map(|out| (prim, Some(format!(\"{}#{}.{}\", path, out, item_name))));\n+                    .map(|out| (prim, Some(format!(\"{}#{}.{}\", path, out, item_str))));\n                 if let Some(link) = link {\n                     return Ok(link);\n                 }\n@@ -388,10 +345,10 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 item_name,\n                 ns.descr()\n             );\n-            return Err(ResolutionFailure::NoPrimitiveAssocItem {\n-                res: prim,\n-                prim_name: path,\n-                assoc_item: item_name,\n+            return Err(ResolutionFailure::NotResolved {\n+                module_id,\n+                partial_res: Some(prim),\n+                unresolved: item_str.into(),\n             }\n             .into());\n         }\n@@ -405,25 +362,14 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         let ty_res = match ty_res {\n             Err(()) | Ok(Res::Err) => {\n                 return if ns == Namespace::ValueNS {\n-                    self.variant_field(path_str, current_item, module_id, extra_fragment)\n+                    self.variant_field(path_str, current_item, module_id)\n                 } else {\n-                    // See if it only broke because of the namespace.\n-                    let kind = cx.enter_resolver(|resolver| {\n-                        // NOTE: this doesn't use `check_full_res` because we explicitly want to ignore `TypeNS` (we already checked it)\n-                        for &ns in &[MacroNS, ValueNS] {\n-                            match resolver\n-                                .resolve_str_path_error(DUMMY_SP, &path_root, ns, module_id)\n-                            {\n-                                Ok((_, Res::Err)) | Err(()) => {}\n-                                Ok((_, res)) => {\n-                                    let res = res.map_id(|_| panic!(\"unexpected node_id\"));\n-                                    return ResolutionFailure::CannotHaveAssociatedItems(res, ns);\n-                                }\n-                            }\n-                        }\n-                        ResolutionFailure::NotInScope { module_id, name: path_root.into() }\n-                    });\n-                    Err(kind.into())\n+                    Err(ResolutionFailure::NotResolved {\n+                        module_id,\n+                        partial_res: None,\n+                        unresolved: path_root.into(),\n+                    }\n+                    .into())\n                 };\n             }\n             Ok(res) => res,\n@@ -473,7 +419,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         // but the disambiguator logic expects the associated item.\n                         // Store the kind in a side channel so that only the disambiguator logic looks at it.\n                         self.kind_side_channel.set(Some((kind.as_def_kind(), id)));\n-                        Ok((ty_res, Some(format!(\"{}.{}\", out, item_name))))\n+                        Ok((ty_res, Some(format!(\"{}.{}\", out, item_str))))\n                     })\n                 } else if ns == Namespace::ValueNS {\n                     debug!(\"looking for variants or fields named {} for {:?}\", item_name, did);\n@@ -516,7 +462,12 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     }\n                 } else {\n                     // We already know this isn't in ValueNS, so no need to check variant_field\n-                    return Err(ResolutionFailure::NoAssocItem(ty_res, item_name).into());\n+                    return Err(ResolutionFailure::NotResolved {\n+                        module_id,\n+                        partial_res: Some(ty_res),\n+                        unresolved: item_str.into(),\n+                    }\n+                    .into());\n                 }\n             }\n             Res::Def(DefKind::Trait, did) => cx\n@@ -540,16 +491,21 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(ty_res)))\n                     } else {\n                         let res = Res::Def(item.kind.as_def_kind(), item.def_id);\n-                        Ok((res, Some(format!(\"{}.{}\", kind, item_name))))\n+                        Ok((res, Some(format!(\"{}.{}\", kind, item_str))))\n                     }\n                 }),\n             _ => None,\n         };\n         res.unwrap_or_else(|| {\n             if ns == Namespace::ValueNS {\n-                self.variant_field(path_str, current_item, module_id, extra_fragment)\n+                self.variant_field(path_str, current_item, module_id)\n             } else {\n-                Err(ResolutionFailure::NoAssocItem(ty_res, item_name).into())\n+                Err(ResolutionFailure::NotResolved {\n+                    module_id,\n+                    partial_res: Some(ty_res),\n+                    unresolved: item_str.into(),\n+                }\n+                .into())\n             }\n         })\n     }\n@@ -1044,12 +1000,12 @@ impl LinkCollector<'_, '_> {\n                 suggest_disambiguator(resolved, diag, path_str, dox, sp, &link_range);\n             });\n         };\n-        if let Res::PrimTy(_) = res {\n+        if let Res::PrimTy(..) = res {\n             match disambiguator {\n                 Some(Disambiguator::Primitive | Disambiguator::Namespace(_)) | None => {\n                     item.attrs.links.push(ItemLink {\n                         link: ori_link,\n-                        link_text: path_str.to_owned(),\n+                        link_text,\n                         did: None,\n                         fragment,\n                     });\n@@ -1127,6 +1083,8 @@ impl LinkCollector<'_, '_> {\n                         // We only looked in one namespace. Try to give a better error if possible.\n                         if kind.full_res().is_none() {\n                             let other_ns = if ns == ValueNS { TypeNS } else { ValueNS };\n+                            // FIXME: really it should be `resolution_failure` that does this, not `resolve_with_disambiguator`\n+                            // See https://github.com/rust-lang/rust/pull/76955#discussion_r493953382 for a good approach\n                             for &new_ns in &[other_ns, MacroNS] {\n                                 if let Some(res) = self.check_full_res(\n                                     new_ns,\n@@ -1529,7 +1487,6 @@ fn resolution_failure(\n         dox,\n         &link_range,\n         |diag, sp| {\n-            let in_scope = kinds.iter().any(|kind| kind.res().is_some());\n             let item = |res: Res| {\n                 format!(\n                     \"the {} `{}`\",\n@@ -1550,53 +1507,142 @@ fn resolution_failure(\n             // ignore duplicates\n             let mut variants_seen = SmallVec::<[_; 3]>::new();\n             for mut failure in kinds {\n-                // Check if _any_ parent of the path gets resolved.\n-                // If so, report it and say the first which failed; if not, say the first path segment didn't resolve.\n-                if let ResolutionFailure::NotInScope { module_id, name } = &mut failure {\n-                    let mut current = name.as_ref();\n-                    loop {\n-                        current = match current.rsplitn(2, \"::\").nth(1) {\n-                            Some(p) => p,\n-                            None => {\n-                                *name = current.to_owned().into();\n-                                break;\n-                            }\n-                        };\n-                        if let Some(res) =\n-                            collector.check_full_res(TypeNS, &current, *module_id, &None, &None)\n-                        {\n-                            failure = ResolutionFailure::NoAssocItem(res, Symbol::intern(current));\n-                            break;\n-                        }\n-                    }\n-                }\n                 let variant = std::mem::discriminant(&failure);\n                 if variants_seen.contains(&variant) {\n                     continue;\n                 }\n                 variants_seen.push(variant);\n-                let note = match failure {\n-                    ResolutionFailure::NotInScope { module_id, name, .. } => {\n-                        if in_scope {\n-                            continue;\n+\n+                if let ResolutionFailure::NotResolved { module_id, partial_res, unresolved } =\n+                    &mut failure\n+                {\n+                    use DefKind::*;\n+\n+                    let module_id = *module_id;\n+                    // FIXME(jynelson): this might conflict with my `Self` fix in #76467\n+                    // FIXME: maybe use itertools `collect_tuple` instead?\n+                    fn split(path: &str) -> Option<(&str, &str)> {\n+                        let mut splitter = path.rsplitn(2, \"::\");\n+                        splitter.next().and_then(|right| splitter.next().map(|left| (left, right)))\n+                    }\n+\n+                    // Check if _any_ parent of the path gets resolved.\n+                    // If so, report it and say the first which failed; if not, say the first path segment didn't resolve.\n+                    let mut name = path_str;\n+                    'outer: loop {\n+                        let (start, end) = if let Some(x) = split(name) {\n+                            x\n+                        } else {\n+                            // avoid bug that marked [Quux::Z] as missing Z, not Quux\n+                            if partial_res.is_none() {\n+                                *unresolved = name.into();\n+                            }\n+                            break;\n+                        };\n+                        name = start;\n+                        for &ns in &[TypeNS, ValueNS, MacroNS] {\n+                            if let Some(res) =\n+                                collector.check_full_res(ns, &start, module_id, &None, &None)\n+                            {\n+                                debug!(\"found partial_res={:?}\", res);\n+                                *partial_res = Some(res);\n+                                *unresolved = end.into();\n+                                break 'outer;\n+                            }\n                         }\n-                        // NOTE: uses an explicit `continue` so the `note:` will come before the `help:`\n-                        let module_name = collector.cx.tcx.item_name(module_id);\n-                        let note = format!(\"no item named `{}` in `{}`\", name, module_name);\n+                        *unresolved = end.into();\n+                    }\n+\n+                    let last_found_module = match *partial_res {\n+                        Some(Res::Def(DefKind::Mod, id)) => Some(id),\n+                        None => Some(module_id),\n+                        _ => None,\n+                    };\n+                    // See if this was a module: `[path]` or `[std::io::nope]`\n+                    if let Some(module) = last_found_module {\n+                        let module_name = collector.cx.tcx.item_name(module);\n+                        let note = format!(\n+                            \"the module `{}` contains no item named `{}`\",\n+                            module_name, unresolved\n+                        );\n                         if let Some(span) = sp {\n                             diag.span_label(span, &note);\n                         } else {\n                             diag.note(&note);\n                         }\n-                        // If the link has `::` in the path, assume it's meant to be an intra-doc link\n+                        // If the link has `::` in it, assume it was meant to be an intra-doc link.\n+                        // Otherwise, the `[]` might be unrelated.\n+                        // FIXME: don't show this for autolinks (`<>`), `()` style links, or reference links\n                         if !path_str.contains(\"::\") {\n-                            // Otherwise, the `[]` might be unrelated.\n-                            // FIXME(https://github.com/raphlinus/pulldown-cmark/issues/373):\n-                            // don't show this for autolinks (`<>`), `()` style links, or reference links\n                             diag.help(r#\"to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\"#);\n                         }\n                         continue;\n                     }\n+\n+                    // Otherwise, it must be an associated item or variant\n+                    let res = partial_res.expect(\"None case was handled by `last_found_module`\");\n+                    let diagnostic_name;\n+                    let (kind, name) = match res {\n+                        Res::Def(kind, def_id) => {\n+                            diagnostic_name = collector.cx.tcx.item_name(def_id).as_str();\n+                            (Some(kind), &*diagnostic_name)\n+                        }\n+                        Res::PrimTy(ty) => (None, ty.name_str()),\n+                        _ => unreachable!(\"only ADTs and primitives are in scope at module level\"),\n+                    };\n+                    let path_description = if let Some(kind) = kind {\n+                        match kind {\n+                            Mod | ForeignMod => \"inner item\",\n+                            Struct => \"field or associated item\",\n+                            Enum | Union => \"variant or associated item\",\n+                            Variant\n+                            | Field\n+                            | Closure\n+                            | Generator\n+                            | AssocTy\n+                            | AssocConst\n+                            | AssocFn\n+                            | Fn\n+                            | Macro(_)\n+                            | Const\n+                            | ConstParam\n+                            | ExternCrate\n+                            | Use\n+                            | LifetimeParam\n+                            | Ctor(_, _)\n+                            | AnonConst => {\n+                                let note = assoc_item_not_allowed(res);\n+                                if let Some(span) = sp {\n+                                    diag.span_label(span, &note);\n+                                } else {\n+                                    diag.note(&note);\n+                                }\n+                                return;\n+                            }\n+                            Trait | TyAlias | ForeignTy | OpaqueTy | TraitAlias | TyParam\n+                            | Static => \"associated item\",\n+                            Impl | GlobalAsm => unreachable!(\"not a path\"),\n+                        }\n+                    } else {\n+                        \"associated item\"\n+                    };\n+                    let note = format!(\n+                        \"the {} `{}` has no {} named `{}`\",\n+                        res.descr(),\n+                        name,\n+                        disambiguator.map_or(path_description, |d| d.descr()),\n+                        unresolved,\n+                    );\n+                    if let Some(span) = sp {\n+                        diag.span_label(span, &note);\n+                    } else {\n+                        diag.note(&note);\n+                    }\n+\n+                    continue;\n+                }\n+                let note = match failure {\n+                    ResolutionFailure::NotResolved { .. } => unreachable!(\"handled above\"),\n                     ResolutionFailure::Dummy => continue,\n                     ResolutionFailure::WrongNamespace(res, expected_ns) => {\n                         if let Res::Def(kind, _) = res {\n@@ -1621,79 +1667,6 @@ fn resolution_failure(\n                         diag.level = rustc_errors::Level::Bug;\n                         \"all intra doc links should have a parent item\".to_owned()\n                     }\n-                    ResolutionFailure::NoPrimitiveImpl(res, _) => format!(\n-                        \"this link partially resolves to {}, which does not have any associated items\",\n-                        item(res),\n-                    ),\n-                    ResolutionFailure::NoPrimitiveAssocItem { prim_name, assoc_item, .. } => {\n-                        format!(\n-                            \"the builtin type `{}` does not have an associated item named `{}`\",\n-                            prim_name, assoc_item\n-                        )\n-                    }\n-                    ResolutionFailure::NoAssocItem(res, assoc_item) => {\n-                        use DefKind::*;\n-\n-                        let (kind, def_id) = match res {\n-                            Res::Def(kind, def_id) => (kind, def_id),\n-                            x => unreachable!(\n-                                \"primitives are covered above and other `Res` variants aren't possible at module scope: {:?}\",\n-                                x,\n-                            ),\n-                        };\n-                        let name = collector.cx.tcx.item_name(def_id);\n-                        let path_description = if let Some(disambiguator) = disambiguator {\n-                            disambiguator.descr()\n-                        } else {\n-                            match kind {\n-                                Mod | ForeignMod => \"inner item\",\n-                                Struct => \"field or associated item\",\n-                                Enum | Union => \"variant or associated item\",\n-                                Variant\n-                                | Field\n-                                | Closure\n-                                | Generator\n-                                | AssocTy\n-                                | AssocConst\n-                                | AssocFn\n-                                | Fn\n-                                | Macro(_)\n-                                | Const\n-                                | ConstParam\n-                                | ExternCrate\n-                                | Use\n-                                | LifetimeParam\n-                                | Ctor(_, _)\n-                                | AnonConst => {\n-                                    let note = assoc_item_not_allowed(res);\n-                                    if let Some(span) = sp {\n-                                        diag.span_label(span, &note);\n-                                    } else {\n-                                        diag.note(&note);\n-                                    }\n-                                    return;\n-                                }\n-                                Trait | TyAlias | ForeignTy | OpaqueTy | TraitAlias | TyParam\n-                                | Static => \"associated item\",\n-                                Impl | GlobalAsm => unreachable!(\"not a path\"),\n-                            }\n-                        };\n-                        format!(\n-                            \"the {} `{}` has no {} named `{}`\",\n-                            res.descr(),\n-                            name,\n-                            path_description,\n-                            assoc_item\n-                        )\n-                    }\n-                    ResolutionFailure::CannotHaveAssociatedItems(res, _) => {\n-                        assoc_item_not_allowed(res)\n-                    }\n-                    ResolutionFailure::NotAVariant(res, variant) => format!(\n-                        \"this link partially resolves to {}, but there is no variant named {}\",\n-                        item(res),\n-                        variant\n-                    ),\n                 };\n                 if let Some(span) = sp {\n                     diag.span_label(span, &note);"}, {"sha": "33260fa0e1e6608fb5bf4a2f5b27c9aae891c526", "filename": "src/test/rustdoc-ui/deny-intra-link-resolution-failure.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71bdb8481760f7c6b8540d3dd176ed54a92c0f31/src%2Ftest%2Frustdoc-ui%2Fdeny-intra-link-resolution-failure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/71bdb8481760f7c6b8540d3dd176ed54a92c0f31/src%2Ftest%2Frustdoc-ui%2Fdeny-intra-link-resolution-failure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdeny-intra-link-resolution-failure.stderr?ref=71bdb8481760f7c6b8540d3dd176ed54a92c0f31", "patch": "@@ -2,7 +2,7 @@ error: unresolved link to `v2`\n   --> $DIR/deny-intra-link-resolution-failure.rs:3:6\n    |\n LL | /// [v2]\n-   |      ^^ no item named `v2` in `deny_intra_link_resolution_failure`\n+   |      ^^ the module `deny_intra_link_resolution_failure` contains no item named `v2`\n    |\n note: the lint level is defined here\n   --> $DIR/deny-intra-link-resolution-failure.rs:1:9"}, {"sha": "0278caf308776742e7f478dde6ec310a27b63997", "filename": "src/test/rustdoc-ui/intra-link-errors.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/71bdb8481760f7c6b8540d3dd176ed54a92c0f31/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71bdb8481760f7c6b8540d3dd176ed54a92c0f31/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.rs?ref=71bdb8481760f7c6b8540d3dd176ed54a92c0f31", "patch": "@@ -6,19 +6,23 @@\n \n /// [path::to::nonexistent::module]\n //~^ ERROR unresolved link\n-//~| NOTE no item named `path` in `intra_link_errors`\n+//~| NOTE `intra_link_errors` contains no item named `path`\n \n /// [path::to::nonexistent::macro!]\n //~^ ERROR unresolved link\n-//~| NOTE no item named `path` in `intra_link_errors`\n+//~| NOTE `intra_link_errors` contains no item named `path`\n \n /// [type@path::to::nonexistent::type]\n //~^ ERROR unresolved link\n-//~| NOTE no item named `path` in `intra_link_errors`\n+//~| NOTE `intra_link_errors` contains no item named `path`\n \n /// [std::io::not::here]\n //~^ ERROR unresolved link\n-//~| NOTE the module `io` has no inner item\n+//~| NOTE `io` contains no item named `not`\n+\n+/// [type@std::io::not::here]\n+//~^ ERROR unresolved link\n+//~| NOTE `io` contains no item named `not`\n \n /// [std::io::Error::x]\n //~^ ERROR unresolved link\n@@ -32,6 +36,10 @@\n //~^ ERROR unresolved link\n //~| NOTE `f` is a function, not a module\n \n+/// [f::A!]\n+//~^ ERROR unresolved link\n+//~| NOTE `f` is a function, not a module\n+\n /// [S::A]\n //~^ ERROR unresolved link\n //~| NOTE struct `S` has no field or associated item\n@@ -46,7 +54,16 @@\n \n /// [u8::not_found]\n //~^ ERROR unresolved link\n-//~| NOTE the builtin type `u8` does not have an associated item named `not_found`\n+//~| NOTE the builtin type `u8` has no associated item named `not_found`\n+\n+/// [std::primitive::u8::not_found]\n+//~^ ERROR unresolved link\n+//~| NOTE the builtin type `u8` has no associated item named `not_found`\n+\n+/// [type@Vec::into_iter]\n+//~^ ERROR unresolved link\n+//~| HELP to link to the associated function, add parentheses\n+//~| NOTE this link resolves to the associated function `into_iter`\n \n /// [S!]\n //~^ ERROR unresolved link"}, {"sha": "b63f799535a1f99e917aa9e8648433634660eab3", "filename": "src/test/rustdoc-ui/intra-link-errors.stderr", "status": "modified", "additions": 45, "deletions": 18, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/71bdb8481760f7c6b8540d3dd176ed54a92c0f31/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/71bdb8481760f7c6b8540d3dd176ed54a92c0f31/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.stderr?ref=71bdb8481760f7c6b8540d3dd176ed54a92c0f31", "patch": "@@ -2,7 +2,7 @@ error: unresolved link to `path::to::nonexistent::module`\n   --> $DIR/intra-link-errors.rs:7:6\n    |\n LL | /// [path::to::nonexistent::module]\n-   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no item named `path` in `intra_link_errors`\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the module `intra_link_errors` contains no item named `path`\n    |\n note: the lint level is defined here\n   --> $DIR/intra-link-errors.rs:1:9\n@@ -14,64 +14,91 @@ error: unresolved link to `path::to::nonexistent::macro`\n   --> $DIR/intra-link-errors.rs:11:6\n    |\n LL | /// [path::to::nonexistent::macro!]\n-   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no item named `path` in `intra_link_errors`\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the module `intra_link_errors` contains no item named `path`\n \n error: unresolved link to `path::to::nonexistent::type`\n   --> $DIR/intra-link-errors.rs:15:6\n    |\n LL | /// [type@path::to::nonexistent::type]\n-   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no item named `path` in `intra_link_errors`\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the module `intra_link_errors` contains no item named `path`\n \n error: unresolved link to `std::io::not::here`\n   --> $DIR/intra-link-errors.rs:19:6\n    |\n LL | /// [std::io::not::here]\n-   |      ^^^^^^^^^^^^^^^^^^ the module `io` has no inner item named `not`\n+   |      ^^^^^^^^^^^^^^^^^^ the module `io` contains no item named `not`\n \n-error: unresolved link to `std::io::Error::x`\n+error: unresolved link to `std::io::not::here`\n   --> $DIR/intra-link-errors.rs:23:6\n    |\n+LL | /// [type@std::io::not::here]\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^ the module `io` contains no item named `not`\n+\n+error: unresolved link to `std::io::Error::x`\n+  --> $DIR/intra-link-errors.rs:27:6\n+   |\n LL | /// [std::io::Error::x]\n    |      ^^^^^^^^^^^^^^^^^ the struct `Error` has no field or associated item named `x`\n \n error: unresolved link to `std::io::ErrorKind::x`\n-  --> $DIR/intra-link-errors.rs:27:6\n+  --> $DIR/intra-link-errors.rs:31:6\n    |\n LL | /// [std::io::ErrorKind::x]\n    |      ^^^^^^^^^^^^^^^^^^^^^ the enum `ErrorKind` has no variant or associated item named `x`\n \n error: unresolved link to `f::A`\n-  --> $DIR/intra-link-errors.rs:31:6\n+  --> $DIR/intra-link-errors.rs:35:6\n    |\n LL | /// [f::A]\n    |      ^^^^ `f` is a function, not a module or type, and cannot have associated items\n \n+error: unresolved link to `f::A`\n+  --> $DIR/intra-link-errors.rs:39:6\n+   |\n+LL | /// [f::A!]\n+   |      ^^^^^ `f` is a function, not a module or type, and cannot have associated items\n+\n error: unresolved link to `S::A`\n-  --> $DIR/intra-link-errors.rs:35:6\n+  --> $DIR/intra-link-errors.rs:43:6\n    |\n LL | /// [S::A]\n    |      ^^^^ the struct `S` has no field or associated item named `A`\n \n error: unresolved link to `S::fmt`\n-  --> $DIR/intra-link-errors.rs:39:6\n+  --> $DIR/intra-link-errors.rs:47:6\n    |\n LL | /// [S::fmt]\n    |      ^^^^^^ the struct `S` has no field or associated item named `fmt`\n \n error: unresolved link to `E::D`\n-  --> $DIR/intra-link-errors.rs:43:6\n+  --> $DIR/intra-link-errors.rs:51:6\n    |\n LL | /// [E::D]\n    |      ^^^^ the enum `E` has no variant or associated item named `D`\n \n error: unresolved link to `u8::not_found`\n-  --> $DIR/intra-link-errors.rs:47:6\n+  --> $DIR/intra-link-errors.rs:55:6\n    |\n LL | /// [u8::not_found]\n-   |      ^^^^^^^^^^^^^ the builtin type `u8` does not have an associated item named `not_found`\n+   |      ^^^^^^^^^^^^^ the builtin type `u8` has no associated item named `not_found`\n+\n+error: unresolved link to `std::primitive::u8::not_found`\n+  --> $DIR/intra-link-errors.rs:59:6\n+   |\n+LL | /// [std::primitive::u8::not_found]\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the builtin type `u8` has no associated item named `not_found`\n+\n+error: unresolved link to `Vec::into_iter`\n+  --> $DIR/intra-link-errors.rs:63:6\n+   |\n+LL | /// [type@Vec::into_iter]\n+   |      ^^^^^^^^^^^^^^^^^^^\n+   |      |\n+   |      this link resolves to the associated function `into_iter`, which is not in the type namespace\n+   |      help: to link to the associated function, add parentheses: `Vec::into_iter()`\n \n error: unresolved link to `S`\n-  --> $DIR/intra-link-errors.rs:51:6\n+  --> $DIR/intra-link-errors.rs:68:6\n    |\n LL | /// [S!]\n    |      ^^\n@@ -80,7 +107,7 @@ LL | /// [S!]\n    |      help: to link to the struct, prefix with `struct@`: `struct@S`\n \n error: unresolved link to `T::g`\n-  --> $DIR/intra-link-errors.rs:69:6\n+  --> $DIR/intra-link-errors.rs:86:6\n    |\n LL | /// [type@T::g]\n    |      ^^^^^^^^^\n@@ -89,13 +116,13 @@ LL | /// [type@T::g]\n    |      help: to link to the associated function, add parentheses: `T::g()`\n \n error: unresolved link to `T::h`\n-  --> $DIR/intra-link-errors.rs:74:6\n+  --> $DIR/intra-link-errors.rs:91:6\n    |\n LL | /// [T::h!]\n    |      ^^^^^ the trait `T` has no macro named `h`\n \n error: unresolved link to `S::h`\n-  --> $DIR/intra-link-errors.rs:61:6\n+  --> $DIR/intra-link-errors.rs:78:6\n    |\n LL | /// [type@S::h]\n    |      ^^^^^^^^^\n@@ -104,13 +131,13 @@ LL | /// [type@S::h]\n    |      help: to link to the associated function, add parentheses: `S::h()`\n \n error: unresolved link to `m`\n-  --> $DIR/intra-link-errors.rs:81:6\n+  --> $DIR/intra-link-errors.rs:98:6\n    |\n LL | /// [m()]\n    |      ^^^\n    |      |\n    |      this link resolves to the macro `m`, which is not in the value namespace\n    |      help: to link to the macro, add an exclamation mark: `m!`\n \n-error: aborting due to 16 previous errors\n+error: aborting due to 20 previous errors\n "}, {"sha": "d946aa939800c61aa20e19b03fb5a0f9af29db55", "filename": "src/test/rustdoc-ui/intra-link-span-ice-55723.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71bdb8481760f7c6b8540d3dd176ed54a92c0f31/src%2Ftest%2Frustdoc-ui%2Fintra-link-span-ice-55723.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/71bdb8481760f7c6b8540d3dd176ed54a92c0f31/src%2Ftest%2Frustdoc-ui%2Fintra-link-span-ice-55723.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-span-ice-55723.stderr?ref=71bdb8481760f7c6b8540d3dd176ed54a92c0f31", "patch": "@@ -2,7 +2,7 @@ error: unresolved link to `i`\n   --> $DIR/intra-link-span-ice-55723.rs:9:10\n    |\n LL | /// \uff08arr[i]\uff09\n-   |           ^ no item named `i` in `intra_link_span_ice_55723`\n+   |           ^ the module `intra_link_span_ice_55723` contains no item named `i`\n    |\n note: the lint level is defined here\n   --> $DIR/intra-link-span-ice-55723.rs:1:9"}, {"sha": "76a2ac0c8cf02848d1e3fa299c231032874cb070", "filename": "src/test/rustdoc-ui/intra-links-warning-crlf.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/71bdb8481760f7c6b8540d3dd176ed54a92c0f31/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning-crlf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/71bdb8481760f7c6b8540d3dd176ed54a92c0f31/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning-crlf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning-crlf.stderr?ref=71bdb8481760f7c6b8540d3dd176ed54a92c0f31", "patch": "@@ -2,7 +2,7 @@ warning: unresolved link to `error`\n   --> $DIR/intra-links-warning-crlf.rs:7:6\n    |\n LL | /// [error]\n-   |      ^^^^^ no item named `error` in `intra_links_warning_crlf`\n+   |      ^^^^^ the module `intra_links_warning_crlf` contains no item named `error`\n    |\n    = note: `#[warn(broken_intra_doc_links)]` on by default\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n@@ -11,23 +11,23 @@ warning: unresolved link to `error1`\n   --> $DIR/intra-links-warning-crlf.rs:12:11\n    |\n LL | /// docs [error1]\n-   |           ^^^^^^ no item named `error1` in `intra_links_warning_crlf`\n+   |           ^^^^^^ the module `intra_links_warning_crlf` contains no item named `error1`\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error2`\n   --> $DIR/intra-links-warning-crlf.rs:15:11\n    |\n LL | /// docs [error2]\n-   |           ^^^^^^ no item named `error2` in `intra_links_warning_crlf`\n+   |           ^^^^^^ the module `intra_links_warning_crlf` contains no item named `error2`\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error`\n   --> $DIR/intra-links-warning-crlf.rs:23:20\n    |\n LL |  * It also has an [error].\n-   |                    ^^^^^ no item named `error` in `intra_links_warning_crlf`\n+   |                    ^^^^^ the module `intra_links_warning_crlf` contains no item named `error`\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n "}, {"sha": "09db465df59fb96025917218e33afa7c0d659851", "filename": "src/test/rustdoc-ui/intra-links-warning.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/71bdb8481760f7c6b8540d3dd176ed54a92c0f31/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/71bdb8481760f7c6b8540d3dd176ed54a92c0f31/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning.stderr?ref=71bdb8481760f7c6b8540d3dd176ed54a92c0f31", "patch": "@@ -10,53 +10,53 @@ warning: unresolved link to `Bar::foo`\n   --> $DIR/intra-links-warning.rs:3:35\n    |\n LL |        //! Test with [Foo::baz], [Bar::foo], ...\n-   |                                   ^^^^^^^^ no item named `Bar` in `intra_links_warning`\n+   |                                   ^^^^^^^^ the module `intra_links_warning` contains no item named `Bar`\n \n warning: unresolved link to `Uniooon::X`\n   --> $DIR/intra-links-warning.rs:6:13\n    |\n LL |      //! , [Uniooon::X] and [Qux::Z].\n-   |             ^^^^^^^^^^ no item named `Uniooon` in `intra_links_warning`\n+   |             ^^^^^^^^^^ the module `intra_links_warning` contains no item named `Uniooon`\n \n warning: unresolved link to `Qux::Z`\n   --> $DIR/intra-links-warning.rs:6:30\n    |\n LL |      //! , [Uniooon::X] and [Qux::Z].\n-   |                              ^^^^^^ no item named `Qux` in `intra_links_warning`\n+   |                              ^^^^^^ the module `intra_links_warning` contains no item named `Qux`\n \n warning: unresolved link to `Uniooon::X`\n   --> $DIR/intra-links-warning.rs:10:14\n    |\n LL |       //! , [Uniooon::X] and [Qux::Z].\n-   |              ^^^^^^^^^^ no item named `Uniooon` in `intra_links_warning`\n+   |              ^^^^^^^^^^ the module `intra_links_warning` contains no item named `Uniooon`\n \n warning: unresolved link to `Qux::Z`\n   --> $DIR/intra-links-warning.rs:10:31\n    |\n LL |       //! , [Uniooon::X] and [Qux::Z].\n-   |                               ^^^^^^ no item named `Qux` in `intra_links_warning`\n+   |                               ^^^^^^ the module `intra_links_warning` contains no item named `Qux`\n \n warning: unresolved link to `Qux:Y`\n   --> $DIR/intra-links-warning.rs:14:13\n    |\n LL |        /// [Qux:Y]\n-   |             ^^^^^ no item named `Qux:Y` in `intra_links_warning`\n+   |             ^^^^^ the module `intra_links_warning` contains no item named `Qux:Y`\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error`\n   --> $DIR/intra-links-warning.rs:58:30\n    |\n LL |  * time to introduce a link [error]*/\n-   |                              ^^^^^ no item named `error` in `intra_links_warning`\n+   |                              ^^^^^ the module `intra_links_warning` contains no item named `error`\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error`\n   --> $DIR/intra-links-warning.rs:64:30\n    |\n LL |  * time to introduce a link [error]\n-   |                              ^^^^^ no item named `error` in `intra_links_warning`\n+   |                              ^^^^^ the module `intra_links_warning` contains no item named `error`\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n@@ -70,7 +70,7 @@ LL | #[doc = \"single line [error]\"]\n            \n            single line [error]\n                         ^^^^^\n-   = note: no item named `error` in `intra_links_warning`\n+   = note: the module `intra_links_warning` contains no item named `error`\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error`\n@@ -83,7 +83,7 @@ LL | #[doc = \"single line with \\\"escaping\\\" [error]\"]\n            \n            single line with \"escaping\" [error]\n                                         ^^^^^\n-   = note: no item named `error` in `intra_links_warning`\n+   = note: the module `intra_links_warning` contains no item named `error`\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error`\n@@ -98,46 +98,46 @@ LL | | /// [error]\n            \n            [error]\n             ^^^^^\n-   = note: no item named `error` in `intra_links_warning`\n+   = note: the module `intra_links_warning` contains no item named `error`\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error1`\n   --> $DIR/intra-links-warning.rs:80:11\n    |\n LL | /// docs [error1]\n-   |           ^^^^^^ no item named `error1` in `intra_links_warning`\n+   |           ^^^^^^ the module `intra_links_warning` contains no item named `error1`\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error2`\n   --> $DIR/intra-links-warning.rs:82:11\n    |\n LL | /// docs [error2]\n-   |           ^^^^^^ no item named `error2` in `intra_links_warning`\n+   |           ^^^^^^ the module `intra_links_warning` contains no item named `error2`\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `BarA`\n   --> $DIR/intra-links-warning.rs:21:10\n    |\n LL | /// bar [BarA] bar\n-   |          ^^^^ no item named `BarA` in `intra_links_warning`\n+   |          ^^^^ the module `intra_links_warning` contains no item named `BarA`\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `BarB`\n   --> $DIR/intra-links-warning.rs:27:9\n    |\n LL |  * bar [BarB] bar\n-   |         ^^^^ no item named `BarB` in `intra_links_warning`\n+   |         ^^^^ the module `intra_links_warning` contains no item named `BarB`\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `BarC`\n   --> $DIR/intra-links-warning.rs:34:6\n    |\n LL | bar [BarC] bar\n-   |      ^^^^ no item named `BarC` in `intra_links_warning`\n+   |      ^^^^ the module `intra_links_warning` contains no item named `BarC`\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n@@ -151,7 +151,7 @@ LL | #[doc = \"Foo\\nbar [BarD] bar\\nbaz\"]\n            \n            bar [BarD] bar\n                 ^^^^\n-   = note: no item named `BarD` in `intra_links_warning`\n+   = note: the module `intra_links_warning` contains no item named `BarD`\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `BarF`\n@@ -167,7 +167,7 @@ LL | f!(\"Foo\\nbar [BarF] bar\\nbaz\");\n            \n            bar [BarF] bar\n                 ^^^^\n-   = note: no item named `BarF` in `intra_links_warning`\n+   = note: the module `intra_links_warning` contains no item named `BarF`\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n    = note: this warning originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n "}, {"sha": "4e9134ea469bd80d68531aa33735e289ad29f226", "filename": "src/test/rustdoc-ui/lint-group.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71bdb8481760f7c6b8540d3dd176ed54a92c0f31/src%2Ftest%2Frustdoc-ui%2Flint-group.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/71bdb8481760f7c6b8540d3dd176ed54a92c0f31/src%2Ftest%2Frustdoc-ui%2Flint-group.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Flint-group.stderr?ref=71bdb8481760f7c6b8540d3dd176ed54a92c0f31", "patch": "@@ -32,7 +32,7 @@ error: unresolved link to `error`\n   --> $DIR/lint-group.rs:9:29\n    |\n LL | /// what up, let's make an [error]\n-   |                             ^^^^^ no item named `error` in `lint_group`\n+   |                             ^^^^^ the module `lint_group` contains no item named `error`\n    |\n note: the lint level is defined here\n   --> $DIR/lint-group.rs:7:9"}, {"sha": "daf7075a91740359157af834bb7b50b42447d0c3", "filename": "src/test/rustdoc/intra-link-associated-items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71bdb8481760f7c6b8540d3dd176ed54a92c0f31/src%2Ftest%2Frustdoc%2Fintra-link-associated-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71bdb8481760f7c6b8540d3dd176ed54a92c0f31/src%2Ftest%2Frustdoc%2Fintra-link-associated-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-associated-items.rs?ref=71bdb8481760f7c6b8540d3dd176ed54a92c0f31", "patch": "@@ -3,8 +3,10 @@\n \n /// [`std::collections::BTreeMap::into_iter`]\n /// [`String::from`] is ambiguous as to which `From` impl\n+/// [Vec::into_iter()] uses a disambiguator\n // @has 'intra_link_associated_items/fn.foo.html' '//a[@href=\"https://doc.rust-lang.org/nightly/alloc/collections/btree/map/struct.BTreeMap.html#method.into_iter\"]' 'std::collections::BTreeMap::into_iter'\n // @has 'intra_link_associated_items/fn.foo.html' '//a[@href=\"https://doc.rust-lang.org/nightly/alloc/string/struct.String.html#method.from\"]' 'String::from'\n+// @has 'intra_link_associated_items/fn.foo.html' '//a[@href=\"https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.into_iter\"]' 'Vec::into_iter'\n pub fn foo() {}\n \n /// Link to [MyStruct], [link from struct][MyStruct::method], [MyStruct::clone], [MyStruct::Input]"}, {"sha": "8f69b894a223d8af4687fff4f28b014a52a1647b", "filename": "src/test/rustdoc/primitive-link.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/71bdb8481760f7c6b8540d3dd176ed54a92c0f31/src%2Ftest%2Frustdoc%2Fprimitive-link.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71bdb8481760f7c6b8540d3dd176ed54a92c0f31/src%2Ftest%2Frustdoc%2Fprimitive-link.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fprimitive-link.rs?ref=71bdb8481760f7c6b8540d3dd176ed54a92c0f31", "patch": "@@ -4,6 +4,13 @@\n \n // @has foo/struct.Foo.html '//*[@class=\"docblock\"]/p/a[@href=\"https://doc.rust-lang.org/nightly/std/primitive.u32.html\"]' 'u32'\n // @has foo/struct.Foo.html '//*[@class=\"docblock\"]/p/a[@href=\"https://doc.rust-lang.org/nightly/std/primitive.i64.html\"]' 'i64'\n+// @has foo/struct.Foo.html '//*[@class=\"docblock\"]/p/a[@href=\"https://doc.rust-lang.org/nightly/std/primitive.i32.html\"]' 'std::primitive::i32'\n+// @has foo/struct.Foo.html '//*[@class=\"docblock\"]/p/a[@href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\"]' 'std::primitive::str'\n+\n+// FIXME: this doesn't resolve\n+// @ has foo/struct.Foo.html '//*[@class=\"docblock\"]/p/a[@href=\"https://doc.rust-lang.org/nightly/std/primitive.i32.html#associatedconstant.MAX\"]' 'std::primitive::i32::MAX'\n \n /// It contains [`u32`] and [i64].\n+/// It also links to [std::primitive::i32], [std::primitive::str],\n+/// and [`std::primitive::i32::MAX`].\n pub struct Foo;"}]}