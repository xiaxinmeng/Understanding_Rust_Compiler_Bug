{"sha": "82e3405efe5ffd2bc214d32b581d5cfc1157eb8d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyZTM0MDVlZmU1ZmZkMmJjMjE0ZDMyYjU4MWQ1Y2ZjMTE1N2ViOGQ=", "commit": {"author": {"name": "Jubilee", "email": "46493976+workingjubilee@users.noreply.github.com", "date": "2021-07-24T23:01:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-24T23:01:57Z"}, "message": "Merge pull request #142 from rust-lang/feature/traits\n\nCombine LanesAtMost32 and SimdArray into a single trait \"Vector\"\r\n\r\nAttempts to fix some unresolved questions in #139 regarding `SimdArray` having a generic parameter.\r\n\r\nIn particular, this made it not appropriate for replacing `LanesAtMost32`.  Additionally, it made it impossible to use in a context where you otherwise don't know the lane count, e.g. `impl Vector`.\r\n\r\nAn unfortunate side effect of this change is that scatter/gather no longer work in the trait (nor does anything else that references the lane count in a type.  This requires the super-unstable `const_evaluatable_checked` feature).\r\n\r\nI also threw in the change from `as_slice` to `as_array` as discussed in zulip, and fixes #51.", "tree": {"sha": "4051bef1cbb11b4c9c53acc0ea26eefcbd6503b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4051bef1cbb11b4c9c53acc0ea26eefcbd6503b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg/JvlCRBK7hj4Ov3rIwAAUKIIAD7DoxGDcKJk/WBBDLTTTcpo\nzRlKF15ss71W2FkUv+5wSPFP3DK13XegiHax0BRZo13iPvAE13IQjbox2Qwu36Xh\n/sZQ4vmg6wDr151ryT9f3ymOVZPEhfly3bfLrO3zxLxRFzjj8FrkELfyVz5ljmBQ\nIRA60QI+G5YpyrWJgYJ3Yn+xPGrU/0moNgZhoVIEE1iFVUZ1KTroyP7fHt6aQb+2\ne5fG8H5DYHcwBxHE11r2npngC1q5Flda+PbStjyXrbBO2YpVXU4dmLtOuitsdZTV\ny3PDJ3aKDp7gZXGpp5da7MP9IDNd9o0tJZ+aUPBLec2r/bFWtsfVgqcrhV4MB9M=\n=WIbR\n-----END PGP SIGNATURE-----\n", "payload": "tree 4051bef1cbb11b4c9c53acc0ea26eefcbd6503b2\nparent 732b7edfab46b33e3861172eb867b139a9425574\nparent 97c25dd7465f4db60c013d7688b809a7da5388a6\nauthor Jubilee <46493976+workingjubilee@users.noreply.github.com> 1627167717 -0700\ncommitter GitHub <noreply@github.com> 1627167717 -0700\n\nMerge pull request #142 from rust-lang/feature/traits\n\nCombine LanesAtMost32 and SimdArray into a single trait \"Vector\"\r\n\r\nAttempts to fix some unresolved questions in #139 regarding `SimdArray` having a generic parameter.\r\n\r\nIn particular, this made it not appropriate for replacing `LanesAtMost32`.  Additionally, it made it impossible to use in a context where you otherwise don't know the lane count, e.g. `impl Vector`.\r\n\r\nAn unfortunate side effect of this change is that scatter/gather no longer work in the trait (nor does anything else that references the lane count in a type.  This requires the super-unstable `const_evaluatable_checked` feature).\r\n\r\nI also threw in the change from `as_slice` to `as_array` as discussed in zulip, and fixes #51."}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d", "html_url": "https://github.com/rust-lang/rust/commit/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "732b7edfab46b33e3861172eb867b139a9425574", "url": "https://api.github.com/repos/rust-lang/rust/commits/732b7edfab46b33e3861172eb867b139a9425574", "html_url": "https://github.com/rust-lang/rust/commit/732b7edfab46b33e3861172eb867b139a9425574"}, {"sha": "97c25dd7465f4db60c013d7688b809a7da5388a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/97c25dd7465f4db60c013d7688b809a7da5388a6", "html_url": "https://github.com/rust-lang/rust/commit/97c25dd7465f4db60c013d7688b809a7da5388a6"}], "stats": {"total": 1457, "additions": 637, "deletions": 820}, "files": [{"sha": "25c53097bebe08853237b2d929f9b5ba92ac4567", "filename": "crates/core_simd/src/array.rs", "status": "removed", "additions": 0, "deletions": 253, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/732b7edfab46b33e3861172eb867b139a9425574/crates%2Fcore_simd%2Fsrc%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/732b7edfab46b33e3861172eb867b139a9425574/crates%2Fcore_simd%2Fsrc%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Farray.rs?ref=732b7edfab46b33e3861172eb867b139a9425574", "patch": "@@ -1,253 +0,0 @@\n-use crate::intrinsics;\n-use crate::masks::*;\n-use crate::vector::ptr::{SimdConstPtr, SimdMutPtr};\n-use crate::vector::*;\n-\n-/// A representation of a vector as an \"array\" with indices, implementing\n-/// operations applicable to any vector type based solely on \"having lanes\",\n-/// and describing relationships between vector and scalar types.\n-pub trait SimdArray<const LANES: usize>: crate::LanesAtMost32\n-where\n-    SimdUsize<LANES>: crate::LanesAtMost32,\n-    SimdIsize<LANES>: crate::LanesAtMost32,\n-    MaskSize<LANES>: crate::Mask,\n-    Self: Sized,\n-{\n-    /// The scalar type in every lane of this vector type.\n-    type Scalar: Copy + Sized;\n-    /// The number of lanes for this vector.\n-    const LANES: usize = LANES;\n-\n-    /// Generates a SIMD vector with the same value in every lane.\n-    #[must_use]\n-    fn splat(val: Self::Scalar) -> Self;\n-\n-    /// SIMD gather: construct a SIMD vector by reading from a slice, using potentially discontiguous indices.\n-    /// If an index is out of bounds, that lane instead selects the value from the \"or\" vector.\n-    /// ```\n-    /// # #![feature(portable_simd)]\n-    /// # use core_simd::*;\n-    /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-    /// let idxs = SimdUsize::<4>::from_array([9, 3, 0, 5]);\n-    /// let alt = SimdI32::from_array([-5, -4, -3, -2]);\n-    ///\n-    /// let result = SimdI32::<4>::gather_or(&vec, idxs, alt); // Note the lane that is out-of-bounds.\n-    /// assert_eq!(result, SimdI32::from_array([-5, 13, 10, 15]));\n-    /// ```\n-    #[must_use]\n-    #[inline]\n-    fn gather_or(slice: &[Self::Scalar], idxs: SimdUsize<LANES>, or: Self) -> Self {\n-        Self::gather_select(slice, MaskSize::splat(true), idxs, or)\n-    }\n-\n-    /// SIMD gather: construct a SIMD vector by reading from a slice, using potentially discontiguous indices.\n-    /// Out-of-bounds indices instead use the default value for that lane (0).\n-    /// ```\n-    /// # #![feature(portable_simd)]\n-    /// # use core_simd::*;\n-    /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-    /// let idxs = SimdUsize::<4>::from_array([9, 3, 0, 5]);\n-    ///\n-    /// let result = SimdI32::<4>::gather_or_default(&vec, idxs); // Note the lane that is out-of-bounds.\n-    /// assert_eq!(result, SimdI32::from_array([0, 13, 10, 15]));\n-    /// ```\n-    #[must_use]\n-    #[inline]\n-    fn gather_or_default(slice: &[Self::Scalar], idxs: SimdUsize<LANES>) -> Self\n-    where\n-        Self::Scalar: Default,\n-    {\n-        Self::gather_or(slice, idxs, Self::splat(Self::Scalar::default()))\n-    }\n-\n-    /// SIMD gather: construct a SIMD vector by reading from a slice, using potentially discontiguous indices.\n-    /// Out-of-bounds or masked indices instead select the value from the \"or\" vector.\n-    /// ```\n-    /// # #![feature(portable_simd)]\n-    /// # use core_simd::*;\n-    /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-    /// let idxs = SimdUsize::<4>::from_array([9, 3, 0, 5]);\n-    /// let alt = SimdI32::from_array([-5, -4, -3, -2]);\n-    /// let mask = MaskSize::from_array([true, true, true, false]); // Note the mask of the last lane.\n-    ///\n-    /// let result = SimdI32::<4>::gather_select(&vec, mask, idxs, alt); // Note the lane that is out-of-bounds.\n-    /// assert_eq!(result, SimdI32::from_array([-5, 13, 10, -2]));\n-    /// ```\n-    #[must_use]\n-    #[inline]\n-    fn gather_select(\n-        slice: &[Self::Scalar],\n-        mask: MaskSize<LANES>,\n-        idxs: SimdUsize<LANES>,\n-        or: Self,\n-    ) -> Self {\n-        let mask = (mask & idxs.lanes_lt(SimdUsize::splat(slice.len()))).to_int();\n-        let base_ptr = SimdConstPtr::splat(slice.as_ptr());\n-        // Ferris forgive me, I have done pointer arithmetic here.\n-        let ptrs = base_ptr.wrapping_add(idxs);\n-        // SAFETY: The ptrs have been bounds-masked to prevent memory-unsafe reads insha'allah\n-        unsafe { intrinsics::simd_gather(or, ptrs, mask) }\n-    }\n-\n-    /// SIMD scatter: write a SIMD vector's values into a slice, using potentially discontiguous indices.\n-    /// Out-of-bounds indices are not written.\n-    /// `scatter` writes \"in order\", so if an index receives two writes, only the last is guaranteed.\n-    /// ```\n-    /// # #![feature(portable_simd)]\n-    /// # use core_simd::*;\n-    /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-    /// let idxs = SimdUsize::<4>::from_array([9, 3, 0, 0]);\n-    /// let vals = SimdI32::from_array([-27, 82, -41, 124]);\n-    ///\n-    /// vals.scatter(&mut vec, idxs); // index 0 receives two writes.\n-    /// assert_eq!(vec, vec![124, 11, 12, 82, 14, 15, 16, 17, 18]);\n-    /// ```\n-    #[inline]\n-    fn scatter(self, slice: &mut [Self::Scalar], idxs: SimdUsize<LANES>) {\n-        self.scatter_select(slice, MaskSize::splat(true), idxs)\n-    }\n-\n-    /// SIMD scatter: write a SIMD vector's values into a slice, using potentially discontiguous indices.\n-    /// Out-of-bounds or masked indices are not written.\n-    /// `scatter_select` writes \"in order\", so if an index receives two writes, only the last is guaranteed.\n-    /// ```\n-    /// # #![feature(portable_simd)]\n-    /// # use core_simd::*;\n-    /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-    /// let idxs = SimdUsize::<4>::from_array([9, 3, 0, 0]);\n-    /// let vals = SimdI32::from_array([-27, 82, -41, 124]);\n-    /// let mask = MaskSize::from_array([true, true, true, false]); // Note the mask of the last lane.\n-    ///\n-    /// vals.scatter_select(&mut vec, mask, idxs); // index 0's second write is masked, thus omitted.\n-    /// assert_eq!(vec, vec![-41, 11, 12, 82, 14, 15, 16, 17, 18]);\n-    /// ```\n-    #[inline]\n-    fn scatter_select(\n-        self,\n-        slice: &mut [Self::Scalar],\n-        mask: MaskSize<LANES>,\n-        idxs: SimdUsize<LANES>,\n-    ) {\n-        // We must construct our scatter mask before we derive a pointer!\n-        let mask = (mask & idxs.lanes_lt(SimdUsize::splat(slice.len()))).to_int();\n-        // SAFETY: This block works with *mut T derived from &mut 'a [T],\n-        // which means it is delicate in Rust's borrowing model, circa 2021:\n-        // &mut 'a [T] asserts uniqueness, so deriving &'a [T] invalidates live *mut Ts!\n-        // Even though this block is largely safe methods, it must be almost exactly this way\n-        // to prevent invalidating the raw ptrs while they're live.\n-        // Thus, entering this block requires all values to use being already ready:\n-        // 0. idxs we want to write to, which are used to construct the mask.\n-        // 1. mask, which depends on an initial &'a [T] and the idxs.\n-        // 2. actual values to scatter (self).\n-        // 3. &mut [T] which will become our base ptr.\n-        unsafe {\n-            // Now Entering \u2622\ufe0f *mut T Zone\n-            let base_ptr = SimdMutPtr::splat(slice.as_mut_ptr());\n-            // Ferris forgive me, I have done pointer arithmetic here.\n-            let ptrs = base_ptr.wrapping_add(idxs);\n-            // The ptrs have been bounds-masked to prevent memory-unsafe writes insha'allah\n-            intrinsics::simd_scatter(self, ptrs, mask)\n-            // Cleared \u2622\ufe0f *mut T Zone\n-        }\n-    }\n-}\n-\n-macro_rules! impl_simdarray_for {\n-    ($simd:ident {type Scalar = $scalar:ident;}) => {\n-        impl<const LANES: usize> SimdArray<LANES> for $simd<LANES>\n-            where SimdUsize<LANES>: crate::LanesAtMost32,\n-            SimdIsize<LANES>: crate::LanesAtMost32,\n-            MaskSize<LANES>: crate::Mask,\n-            Self: crate::LanesAtMost32,\n-        {\n-            type Scalar = $scalar;\n-\n-            #[must_use]\n-            #[inline]\n-            fn splat(val: Self::Scalar) -> Self {\n-                [val; LANES].into()\n-            }\n-        }\n-    };\n-\n-    ($simd:ident $impl:tt) => {\n-        impl<const LANES: usize> SimdArray<LANES> for $simd<LANES>\n-            where SimdUsize<LANES>: crate::LanesAtMost32,\n-            SimdIsize<LANES>: crate::LanesAtMost32,\n-            MaskSize<LANES>: crate::Mask,\n-            Self: crate::LanesAtMost32,\n-        $impl\n-    }\n-}\n-\n-impl_simdarray_for! {\n-    SimdUsize {\n-        type Scalar = usize;\n-    }\n-}\n-\n-impl_simdarray_for! {\n-    SimdIsize {\n-        type Scalar = isize;\n-    }\n-}\n-\n-impl_simdarray_for! {\n-    SimdI8 {\n-        type Scalar = i8;\n-    }\n-}\n-\n-impl_simdarray_for! {\n-    SimdI16 {\n-        type Scalar = i16;\n-    }\n-}\n-\n-impl_simdarray_for! {\n-    SimdI32 {\n-        type Scalar = i32;\n-    }\n-}\n-\n-impl_simdarray_for! {\n-    SimdI64 {\n-        type Scalar = i64;\n-    }\n-}\n-\n-impl_simdarray_for! {\n-    SimdU8 {\n-        type Scalar = u8;\n-    }\n-}\n-\n-impl_simdarray_for! {\n-    SimdU16 {\n-        type Scalar = u16;\n-    }\n-}\n-\n-impl_simdarray_for! {\n-    SimdU32 {\n-        type Scalar = u32;\n-    }\n-}\n-\n-impl_simdarray_for! {\n-    SimdU64 {\n-        type Scalar = u64;\n-    }\n-}\n-\n-impl_simdarray_for! {\n-    SimdF32 {\n-        type Scalar = f32;\n-    }\n-}\n-\n-impl_simdarray_for! {\n-    SimdF64 {\n-        type Scalar = f64;\n-    }\n-}"}, {"sha": "c5e9be9015fe6bcc8b039de325e8dda0ab0311a3", "filename": "crates/core_simd/src/comparisons.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs?ref=82e3405efe5ffd2bc214d32b581d5cfc1157eb8d", "patch": "@@ -1,13 +1,11 @@\n-use crate::LanesAtMost32;\n+use crate::{LaneCount, SupportedLaneCount};\n \n macro_rules! implement_mask_ops {\n     { $($vector:ident => $mask:ident ($inner_ty:ident),)* } => {\n         $(\n             impl<const LANES: usize> crate::$vector<LANES>\n             where\n-                crate::$vector<LANES>: LanesAtMost32,\n-                crate::$inner_ty<LANES>: LanesAtMost32,\n-                crate::$mask<LANES>: crate::Mask,\n+                LaneCount<LANES>: SupportedLaneCount,\n             {\n                 /// Test if each lane is equal to the corresponding lane in `other`.\n                 #[inline]"}, {"sha": "50602829d4828a8179b19cb1273cbdc748791825", "filename": "crates/core_simd/src/first.rs", "status": "removed", "additions": 0, "deletions": 124, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/732b7edfab46b33e3861172eb867b139a9425574/crates%2Fcore_simd%2Fsrc%2Ffirst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/732b7edfab46b33e3861172eb867b139a9425574/crates%2Fcore_simd%2Fsrc%2Ffirst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Ffirst.rs?ref=732b7edfab46b33e3861172eb867b139a9425574", "patch": "@@ -1,124 +0,0 @@\n-/// Implements common traits on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n-macro_rules! impl_vector {\n-    { $name:ident, $type:ty } => {\n-        impl<const LANES: usize> $name<LANES> where Self: crate::LanesAtMost32 {\n-            /// Construct a SIMD vector by setting all lanes to the given value.\n-            pub const fn splat(value: $type) -> Self {\n-                Self([value; LANES])\n-            }\n-\n-            /// Returns a slice containing the entire SIMD vector.\n-            pub const fn as_slice(&self) -> &[$type] {\n-                &self.0\n-            }\n-\n-            /// Returns a mutable slice containing the entire SIMD vector.\n-            pub fn as_mut_slice(&mut self) -> &mut [$type] {\n-                &mut self.0\n-            }\n-\n-            /// Converts an array to a SIMD vector.\n-            pub const fn from_array(array: [$type; LANES]) -> Self {\n-                Self(array)\n-            }\n-\n-            /// Converts a SIMD vector to an array.\n-            pub const fn to_array(self) -> [$type; LANES] {\n-                // workaround for rust-lang/rust#80108\n-                // TODO fix this\n-                #[cfg(target_arch = \"wasm32\")]\n-                {\n-                    let mut arr = [self.0[0]; LANES];\n-                    let mut i = 0;\n-                    while i < LANES {\n-                        arr[i] = self.0[i];\n-                        i += 1;\n-                    }\n-                    arr\n-                }\n-\n-                #[cfg(not(target_arch = \"wasm32\"))]\n-                {\n-                    self.0\n-                }\n-            }\n-        }\n-\n-        impl<const LANES: usize> Copy for $name<LANES> where Self: crate::LanesAtMost32 {}\n-\n-        impl<const LANES: usize> Clone for $name<LANES> where Self: crate::LanesAtMost32 {\n-            #[inline]\n-            fn clone(&self) -> Self {\n-                *self\n-            }\n-        }\n-\n-        impl<const LANES: usize> Default for $name<LANES> where Self: crate::LanesAtMost32 {\n-            #[inline]\n-            fn default() -> Self {\n-                Self::splat(<$type>::default())\n-            }\n-        }\n-\n-        impl<const LANES: usize> PartialEq for $name<LANES> where Self: crate::LanesAtMost32 {\n-            #[inline]\n-            fn eq(&self, other: &Self) -> bool {\n-                // TODO use SIMD equality\n-                self.to_array() == other.to_array()\n-            }\n-        }\n-\n-        impl<const LANES: usize> PartialOrd for $name<LANES> where Self: crate::LanesAtMost32 {\n-            #[inline]\n-            fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n-                // TODO use SIMD equalitya\n-                self.to_array().partial_cmp(other.as_ref())\n-            }\n-        }\n-\n-        // array references\n-        impl<const LANES: usize> AsRef<[$type; LANES]> for $name<LANES> where Self: crate::LanesAtMost32 {\n-            #[inline]\n-            fn as_ref(&self) -> &[$type; LANES] {\n-                &self.0\n-            }\n-        }\n-\n-        impl<const LANES: usize> AsMut<[$type; LANES]> for $name<LANES> where Self: crate::LanesAtMost32 {\n-            #[inline]\n-            fn as_mut(&mut self) -> &mut [$type; LANES] {\n-                &mut self.0\n-            }\n-        }\n-\n-        // slice references\n-        impl<const LANES: usize> AsRef<[$type]> for $name<LANES> where Self: crate::LanesAtMost32 {\n-            #[inline]\n-            fn as_ref(&self) -> &[$type] {\n-                &self.0\n-            }\n-        }\n-\n-        impl<const LANES: usize> AsMut<[$type]> for $name<LANES> where Self: crate::LanesAtMost32 {\n-            #[inline]\n-            fn as_mut(&mut self) -> &mut [$type] {\n-                &mut self.0\n-            }\n-        }\n-\n-        // vector/array conversion\n-        impl<const LANES: usize> From<[$type; LANES]> for $name<LANES> where Self: crate::LanesAtMost32 {\n-            fn from(array: [$type; LANES]) -> Self {\n-                Self(array)\n-            }\n-        }\n-\n-        impl <const LANES: usize> From<$name<LANES>> for [$type; LANES] where $name<LANES>: crate::LanesAtMost32 {\n-            fn from(vector: $name<LANES>) -> Self {\n-                vector.to_array()\n-            }\n-        }\n-\n-        impl_shuffle_2pow_lanes!{ $name }\n-    }\n-}"}, {"sha": "78ae5ce3fceab275831199b94a9b5f69bb992e3f", "filename": "crates/core_simd/src/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Ffmt.rs?ref=82e3405efe5ffd2bc214d32b581d5cfc1157eb8d", "patch": "@@ -35,7 +35,7 @@ macro_rules! impl_fmt_trait {\n             $( // repeat trait\n                 impl<const LANES: usize> core::fmt::$trait for crate::$type<LANES>\n                 where\n-                    Self: crate::LanesAtMost32,\n+                    crate::LaneCount<LANES>: crate::SupportedLaneCount,\n                 {\n                     fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n                         $format(self.as_ref(), f)"}, {"sha": "0020ea5f2016f56017357fc78038f1e08aa9b3fd", "filename": "crates/core_simd/src/iter.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fiter.rs?ref=82e3405efe5ffd2bc214d32b581d5cfc1157eb8d", "patch": "@@ -1,8 +1,10 @@\n+use crate::{LaneCount, SupportedLaneCount};\n+\n macro_rules! impl_traits {\n     { $type:ident } => {\n         impl<const LANES: usize> core::iter::Sum<Self> for crate::$type<LANES>\n         where\n-            Self: crate::LanesAtMost32,\n+            LaneCount<LANES>: SupportedLaneCount,\n         {\n             fn sum<I: core::iter::Iterator<Item = Self>>(iter: I) -> Self {\n                 iter.fold(Default::default(), core::ops::Add::add)\n@@ -11,7 +13,7 @@ macro_rules! impl_traits {\n \n         impl<const LANES: usize> core::iter::Product<Self> for crate::$type<LANES>\n         where\n-            Self: crate::LanesAtMost32,\n+            LaneCount<LANES>: SupportedLaneCount,\n         {\n             fn product<I: core::iter::Iterator<Item = Self>>(iter: I) -> Self {\n                 iter.fold(Default::default(), core::ops::Mul::mul)\n@@ -20,7 +22,7 @@ macro_rules! impl_traits {\n \n         impl<'a, const LANES: usize> core::iter::Sum<&'a Self> for crate::$type<LANES>\n         where\n-            Self: crate::LanesAtMost32,\n+            LaneCount<LANES>: SupportedLaneCount,\n         {\n             fn sum<I: core::iter::Iterator<Item = &'a Self>>(iter: I) -> Self {\n                 iter.fold(Default::default(), core::ops::Add::add)\n@@ -29,7 +31,7 @@ macro_rules! impl_traits {\n \n         impl<'a, const LANES: usize> core::iter::Product<&'a Self> for crate::$type<LANES>\n         where\n-            Self: crate::LanesAtMost32,\n+            LaneCount<LANES>: SupportedLaneCount,\n         {\n             fn product<I: core::iter::Iterator<Item = &'a Self>>(iter: I) -> Self {\n                 iter.fold(Default::default(), core::ops::Mul::mul)"}, {"sha": "8fe204dff98e458f2c943cca4d34332950d95e64", "filename": "crates/core_simd/src/lane_count.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Flane_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Flane_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Flane_count.rs?ref=82e3405efe5ffd2bc214d32b581d5cfc1157eb8d", "patch": "@@ -0,0 +1,43 @@\n+mod sealed {\n+    pub trait Sealed {}\n+}\n+use sealed::Sealed;\n+\n+/// A type representing a vector lane count.\n+pub struct LaneCount<const LANES: usize>;\n+\n+/// Helper trait for vector lane counts.\n+pub trait SupportedLaneCount: Sealed {\n+    /// The bitmask representation of a mask.\n+    type BitMask: Copy + Default + AsRef<[u8]> + AsMut<[u8]>;\n+\n+    #[doc(hidden)]\n+    type IntBitMask;\n+}\n+\n+impl<const LANES: usize> Sealed for LaneCount<LANES> {}\n+\n+impl SupportedLaneCount for LaneCount<1> {\n+    type BitMask = [u8; 1];\n+    type IntBitMask = u8;\n+}\n+impl SupportedLaneCount for LaneCount<2> {\n+    type BitMask = [u8; 1];\n+    type IntBitMask = u8;\n+}\n+impl SupportedLaneCount for LaneCount<4> {\n+    type BitMask = [u8; 1];\n+    type IntBitMask = u8;\n+}\n+impl SupportedLaneCount for LaneCount<8> {\n+    type BitMask = [u8; 1];\n+    type IntBitMask = u8;\n+}\n+impl SupportedLaneCount for LaneCount<16> {\n+    type BitMask = [u8; 2];\n+    type IntBitMask = u16;\n+}\n+impl SupportedLaneCount for LaneCount<32> {\n+    type BitMask = [u8; 4];\n+    type IntBitMask = u32;\n+}"}, {"sha": "2d84b1306ea5a50f3b43f0644d4a00d8b3eed17f", "filename": "crates/core_simd/src/lanes_at_most_32.rs", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/732b7edfab46b33e3861172eb867b139a9425574/crates%2Fcore_simd%2Fsrc%2Flanes_at_most_32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/732b7edfab46b33e3861172eb867b139a9425574/crates%2Fcore_simd%2Fsrc%2Flanes_at_most_32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Flanes_at_most_32.rs?ref=732b7edfab46b33e3861172eb867b139a9425574", "patch": "@@ -1,54 +0,0 @@\n-/// Implemented for vectors that are supported by the implementation.\n-pub trait LanesAtMost32: sealed::Sealed {\n-    #[doc(hidden)]\n-    type BitMask: Into<u64>;\n-}\n-\n-mod sealed {\n-    pub trait Sealed {}\n-}\n-\n-macro_rules! impl_for {\n-    { $name:ident } => {\n-        impl<const LANES: usize> sealed::Sealed for $name<LANES>\n-        where\n-            $name<LANES>: LanesAtMost32,\n-        {}\n-\n-        impl LanesAtMost32 for $name<1> {\n-            type BitMask = u8;\n-        }\n-        impl LanesAtMost32 for $name<2> {\n-            type BitMask = u8;\n-        }\n-        impl LanesAtMost32 for $name<4> {\n-            type BitMask = u8;\n-        }\n-        impl LanesAtMost32 for $name<8> {\n-            type BitMask = u8;\n-        }\n-        impl LanesAtMost32 for $name<16> {\n-            type BitMask = u16;\n-        }\n-        impl LanesAtMost32 for $name<32> {\n-            type BitMask = u32;\n-        }\n-    }\n-}\n-\n-use crate::*;\n-\n-impl_for! { SimdU8 }\n-impl_for! { SimdU16 }\n-impl_for! { SimdU32 }\n-impl_for! { SimdU64 }\n-impl_for! { SimdUsize }\n-\n-impl_for! { SimdI8 }\n-impl_for! { SimdI16 }\n-impl_for! { SimdI32 }\n-impl_for! { SimdI64 }\n-impl_for! { SimdIsize }\n-\n-impl_for! { SimdF32 }\n-impl_for! { SimdF64 }"}, {"sha": "d8149efe9c7f8a25138f11c6fa60579dbe012cca", "filename": "crates/core_simd/src/lib.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Flib.rs?ref=82e3405efe5ffd2bc214d32b581d5cfc1157eb8d", "patch": "@@ -12,8 +12,6 @@\n #![unstable(feature = \"portable_simd\", issue = \"86656\")]\n //! Portable SIMD module.\n \n-#[macro_use]\n-mod first;\n #[macro_use]\n mod permute;\n #[macro_use]\n@@ -29,20 +27,16 @@ mod comparisons;\n mod fmt;\n mod intrinsics;\n mod iter;\n+mod math;\n mod ops;\n mod round;\n mod vendor;\n \n-mod math;\n-\n-mod lanes_at_most_32;\n-pub use lanes_at_most_32::LanesAtMost32;\n+mod lane_count;\n+pub use lane_count::*;\n \n mod masks;\n pub use masks::*;\n \n mod vector;\n pub use vector::*;\n-\n-mod array;\n-pub use array::SimdArray;"}, {"sha": "d3338a6d366eec7559880bcaea466ac4e386dde5", "filename": "crates/core_simd/src/masks.rs", "status": "renamed", "additions": 56, "deletions": 98, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks.rs?ref=82e3405efe5ffd2bc214d32b581d5cfc1157eb8d", "patch": "@@ -4,28 +4,28 @@\n \n #[cfg_attr(\n     not(all(target_arch = \"x86_64\", target_feature = \"avx512f\")),\n-    path = \"full_masks.rs\"\n+    path = \"masks/full_masks.rs\"\n )]\n #[cfg_attr(\n     all(target_arch = \"x86_64\", target_feature = \"avx512f\"),\n-    path = \"bitmask.rs\"\n+    path = \"masks/bitmask.rs\"\n )]\n mod mask_impl;\n \n-use crate::{LanesAtMost32, SimdI16, SimdI32, SimdI64, SimdI8, SimdIsize};\n+use crate::{SimdI16, SimdI32, SimdI64, SimdI8, SimdIsize};\n \n mod sealed {\n     pub trait Sealed {}\n }\n \n /// Helper trait for mask types.\n pub trait Mask: sealed::Sealed {\n-    /// The bitmask representation of a mask.\n-    type BitMask: Copy + Default + AsRef<[u8]> + AsMut<[u8]>;\n+    /// The number of lanes for this mask.\n+    const LANES: usize;\n \n-    // TODO remove this when rustc intrinsics are more flexible\n-    #[doc(hidden)]\n-    type IntBitMask;\n+    /// Generates a mask with the same value in every lane.\n+    #[must_use]\n+    fn splat(val: bool) -> Self;\n }\n \n macro_rules! define_opaque_mask {\n@@ -38,45 +38,30 @@ macro_rules! define_opaque_mask {\n         #[allow(non_camel_case_types)]\n         pub struct $name<const LANES: usize>($inner_ty)\n         where\n-            $bits_ty<LANES>: LanesAtMost32,\n-            Self: Mask;\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount;\n \n         impl<const LANES: usize> sealed::Sealed for $name<LANES>\n         where\n-            $bits_ty<LANES>: LanesAtMost32,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {}\n-        impl Mask for $name<1> {\n-            type BitMask = [u8; 1];\n-            type IntBitMask = u8;\n-        }\n-        impl Mask for $name<2> {\n-            type BitMask = [u8; 1];\n-            type IntBitMask = u8;\n-        }\n-        impl Mask for $name<4> {\n-            type BitMask = [u8; 1];\n-            type IntBitMask = u8;\n-        }\n-        impl Mask for $name<8> {\n-            type BitMask = [u8; 1];\n-            type IntBitMask = u8;\n-        }\n-        impl Mask for $name<16> {\n-            type BitMask = [u8; 2];\n-            type IntBitMask = u16;\n-        }\n-        impl Mask for $name<32> {\n-            type BitMask = [u8; 4];\n-            type IntBitMask = u32;\n+\n+        impl<const LANES: usize> Mask for $name<LANES>\n+        where\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n+        {\n+            const LANES: usize = LANES;\n+\n+            #[inline]\n+            fn splat(value: bool) -> Self {\n+                Self::splat(value)\n+            }\n         }\n \n         impl_opaque_mask_reductions! { $name, $bits_ty }\n \n         impl<const LANES: usize> $name<LANES>\n         where\n-            $bits_ty<LANES>: LanesAtMost32,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             /// Construct a mask by setting all lanes to the given value.\n             pub fn splat(value: bool) -> Self {\n@@ -175,21 +160,20 @@ macro_rules! define_opaque_mask {\n             }\n \n             /// Convert this mask to a bitmask, with one bit set per lane.\n-            pub fn to_bitmask(self) -> <Self as Mask>::BitMask {\n-                self.0.to_bitmask::<Self>()\n+            pub fn to_bitmask(self) -> <crate::LaneCount<LANES> as crate::SupportedLaneCount>::BitMask {\n+                self.0.to_bitmask()\n             }\n \n             /// Convert a bitmask to a mask.\n-            pub fn from_bitmask(bitmask: <Self as Mask>::BitMask) -> Self {\n-                Self(<$inner_ty>::from_bitmask::<Self>(bitmask))\n+            pub fn from_bitmask(bitmask: <crate::LaneCount<LANES> as crate::SupportedLaneCount>::BitMask) -> Self {\n+                Self(<$inner_ty>::from_bitmask(bitmask))\n             }\n         }\n \n         // vector/array conversion\n         impl<const LANES: usize> From<[bool; LANES]> for $name<LANES>\n         where\n-            $bits_ty<LANES>: crate::LanesAtMost32,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             fn from(array: [bool; LANES]) -> Self {\n                 Self::from_array(array)\n@@ -198,8 +182,7 @@ macro_rules! define_opaque_mask {\n \n         impl <const LANES: usize> From<$name<LANES>> for [bool; LANES]\n         where\n-            $bits_ty<LANES>: crate::LanesAtMost32,\n-            $name<LANES>: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             fn from(vector: $name<LANES>) -> Self {\n                 vector.to_array()\n@@ -208,14 +191,12 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> Copy for $name<LANES>\n         where\n-            $bits_ty<LANES>: LanesAtMost32,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {}\n \n         impl<const LANES: usize> Clone for $name<LANES>\n         where\n-            $bits_ty<LANES>: LanesAtMost32,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             #[inline]\n             fn clone(&self) -> Self {\n@@ -225,8 +206,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> Default for $name<LANES>\n         where\n-            $bits_ty<LANES>: LanesAtMost32,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             #[inline]\n             fn default() -> Self {\n@@ -236,8 +216,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> PartialEq for $name<LANES>\n         where\n-            $bits_ty<LANES>: LanesAtMost32,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             #[inline]\n             fn eq(&self, other: &Self) -> bool {\n@@ -247,8 +226,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> PartialOrd for $name<LANES>\n         where\n-            $bits_ty<LANES>: LanesAtMost32,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             #[inline]\n             fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n@@ -258,8 +236,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::fmt::Debug for $name<LANES>\n         where\n-            $bits_ty<LANES>: crate::LanesAtMost32,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n                 f.debug_list()\n@@ -270,8 +247,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitAnd for $name<LANES>\n         where\n-            $bits_ty<LANES>: LanesAtMost32,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             type Output = Self;\n             #[inline]\n@@ -282,8 +258,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitAnd<bool> for $name<LANES>\n         where\n-            $bits_ty<LANES>: LanesAtMost32,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             type Output = Self;\n             #[inline]\n@@ -294,8 +269,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitAnd<$name<LANES>> for bool\n         where\n-            $bits_ty<LANES>: LanesAtMost32,\n-            $name<LANES>: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -306,8 +280,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitOr for $name<LANES>\n         where\n-            $bits_ty<LANES>: LanesAtMost32,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             type Output = Self;\n             #[inline]\n@@ -318,8 +291,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitOr<bool> for $name<LANES>\n         where\n-            $bits_ty<LANES>: LanesAtMost32,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             type Output = Self;\n             #[inline]\n@@ -330,8 +302,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitOr<$name<LANES>> for bool\n         where\n-            $bits_ty<LANES>: LanesAtMost32,\n-            $name<LANES>: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -342,8 +313,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitXor for $name<LANES>\n         where\n-            $bits_ty<LANES>: LanesAtMost32,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             type Output = Self;\n             #[inline]\n@@ -354,8 +324,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitXor<bool> for $name<LANES>\n         where\n-            $bits_ty<LANES>: LanesAtMost32,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             type Output = Self;\n             #[inline]\n@@ -366,8 +335,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitXor<$name<LANES>> for bool\n         where\n-            $bits_ty<LANES>: LanesAtMost32,\n-            $name<LANES>: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -378,8 +346,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::Not for $name<LANES>\n         where\n-            $bits_ty<LANES>: LanesAtMost32,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -390,8 +357,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitAndAssign for $name<LANES>\n         where\n-            $bits_ty<LANES>: LanesAtMost32,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             #[inline]\n             fn bitand_assign(&mut self, rhs: Self) {\n@@ -401,8 +367,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitAndAssign<bool> for $name<LANES>\n         where\n-            $bits_ty<LANES>: LanesAtMost32,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             #[inline]\n             fn bitand_assign(&mut self, rhs: bool) {\n@@ -412,8 +377,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitOrAssign for $name<LANES>\n         where\n-            $bits_ty<LANES>: LanesAtMost32,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             #[inline]\n             fn bitor_assign(&mut self, rhs: Self) {\n@@ -423,8 +387,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitOrAssign<bool> for $name<LANES>\n         where\n-            $bits_ty<LANES>: LanesAtMost32,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             #[inline]\n             fn bitor_assign(&mut self, rhs: bool) {\n@@ -434,8 +397,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitXorAssign for $name<LANES>\n         where\n-            $bits_ty<LANES>: LanesAtMost32,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             #[inline]\n             fn bitxor_assign(&mut self, rhs: Self) {\n@@ -445,8 +407,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitXorAssign<bool> for $name<LANES>\n         where\n-            $bits_ty<LANES>: LanesAtMost32,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             #[inline]\n             fn bitxor_assign(&mut self, rhs: bool) {\n@@ -460,39 +421,39 @@ define_opaque_mask! {\n     /// Mask for vectors with `LANES` 8-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct Mask8<const LANES: usize>(mask_impl::Mask8<Self, LANES>);\n+    struct Mask8<const LANES: usize>(mask_impl::Mask8<LANES>);\n     @bits SimdI8\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` 16-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct Mask16<const LANES: usize>(mask_impl::Mask16<Self, LANES>);\n+    struct Mask16<const LANES: usize>(mask_impl::Mask16<LANES>);\n     @bits SimdI16\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` 32-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct Mask32<const LANES: usize>(mask_impl::Mask32<Self, LANES>);\n+    struct Mask32<const LANES: usize>(mask_impl::Mask32<LANES>);\n     @bits SimdI32\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` 64-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct Mask64<const LANES: usize>(mask_impl::Mask64<Self, LANES>);\n+    struct Mask64<const LANES: usize>(mask_impl::Mask64<LANES>);\n     @bits SimdI64\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` pointer-width elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct MaskSize<const LANES: usize>(mask_impl::MaskSize<Self, LANES>);\n+    struct MaskSize<const LANES: usize>(mask_impl::MaskSize<LANES>);\n     @bits SimdIsize\n }\n \n@@ -555,10 +516,7 @@ macro_rules! impl_from {\n         $(\n         impl<const LANES: usize> From<$from<LANES>> for $to<LANES>\n         where\n-            crate::$from_inner<LANES>: crate::LanesAtMost32,\n-            crate::$to_inner<LANES>: crate::LanesAtMost32,\n-            $from<LANES>: Mask,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             fn from(value: $from<LANES>) -> Self {\n                 Self(value.0.into())", "previous_filename": "crates/core_simd/src/masks/mod.rs"}, {"sha": "b6897728988b8b66a270b35bebe03535f78e09ab", "filename": "crates/core_simd/src/masks/bitmask.rs", "status": "modified", "additions": 83, "deletions": 70, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs?ref=82e3405efe5ffd2bc214d32b581d5cfc1157eb8d", "patch": "@@ -1,50 +1,81 @@\n-use crate::Mask;\n-use core::marker::PhantomData;\n+use crate::{LaneCount, SupportedLaneCount};\n \n /// Helper trait for limiting int conversion types\n pub trait ConvertToInt {}\n-impl<const LANES: usize> ConvertToInt for crate::SimdI8<LANES> where Self: crate::LanesAtMost32 {}\n-impl<const LANES: usize> ConvertToInt for crate::SimdI16<LANES> where Self: crate::LanesAtMost32 {}\n-impl<const LANES: usize> ConvertToInt for crate::SimdI32<LANES> where Self: crate::LanesAtMost32 {}\n-impl<const LANES: usize> ConvertToInt for crate::SimdI64<LANES> where Self: crate::LanesAtMost32 {}\n-impl<const LANES: usize> ConvertToInt for crate::SimdIsize<LANES> where Self: crate::LanesAtMost32 {}\n+impl<const LANES: usize> ConvertToInt for crate::SimdI8<LANES> where\n+    LaneCount<LANES>: SupportedLaneCount\n+{\n+}\n+impl<const LANES: usize> ConvertToInt for crate::SimdI16<LANES> where\n+    LaneCount<LANES>: SupportedLaneCount\n+{\n+}\n+impl<const LANES: usize> ConvertToInt for crate::SimdI32<LANES> where\n+    LaneCount<LANES>: SupportedLaneCount\n+{\n+}\n+impl<const LANES: usize> ConvertToInt for crate::SimdI64<LANES> where\n+    LaneCount<LANES>: SupportedLaneCount\n+{\n+}\n+impl<const LANES: usize> ConvertToInt for crate::SimdIsize<LANES> where\n+    LaneCount<LANES>: SupportedLaneCount\n+{\n+}\n \n /// A mask where each lane is represented by a single bit.\n #[repr(transparent)]\n-pub struct BitMask<T: Mask, const LANES: usize>(T::BitMask, PhantomData<[(); LANES]>);\n+pub struct BitMask<const LANES: usize>(<LaneCount<LANES> as SupportedLaneCount>::BitMask)\n+where\n+    LaneCount<LANES>: SupportedLaneCount;\n \n-impl<T: Mask, const LANES: usize> Copy for BitMask<T, LANES> {}\n+impl<const LANES: usize> Copy for BitMask<LANES> where LaneCount<LANES>: SupportedLaneCount {}\n \n-impl<T: Mask, const LANES: usize> Clone for BitMask<T, LANES> {\n+impl<const LANES: usize> Clone for BitMask<LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n     fn clone(&self) -> Self {\n         *self\n     }\n }\n \n-impl<T: Mask, const LANES: usize> PartialEq for BitMask<T, LANES> {\n+impl<const LANES: usize> PartialEq for BitMask<LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n     fn eq(&self, other: &Self) -> bool {\n         self.0.as_ref() == other.0.as_ref()\n     }\n }\n \n-impl<T: Mask, const LANES: usize> PartialOrd for BitMask<T, LANES> {\n+impl<const LANES: usize> PartialOrd for BitMask<LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n     fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n         self.0.as_ref().partial_cmp(other.0.as_ref())\n     }\n }\n \n-impl<T: Mask, const LANES: usize> Eq for BitMask<T, LANES> {}\n+impl<const LANES: usize> Eq for BitMask<LANES> where LaneCount<LANES>: SupportedLaneCount {}\n \n-impl<T: Mask, const LANES: usize> Ord for BitMask<T, LANES> {\n+impl<const LANES: usize> Ord for BitMask<LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n     fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n         self.0.as_ref().cmp(other.0.as_ref())\n     }\n }\n \n-impl<T: Mask, const LANES: usize> BitMask<T, LANES> {\n+impl<const LANES: usize> BitMask<LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n     #[inline]\n     pub fn splat(value: bool) -> Self {\n-        let mut mask = T::BitMask::default();\n+        let mut mask = <LaneCount<LANES> as SupportedLaneCount>::BitMask::default();\n         if value {\n             mask.as_mut().fill(u8::MAX)\n         } else {\n@@ -53,12 +84,12 @@ impl<T: Mask, const LANES: usize> BitMask<T, LANES> {\n         if LANES % 8 > 0 {\n             *mask.as_mut().last_mut().unwrap() &= u8::MAX >> (8 - LANES % 8);\n         }\n-        Self(mask, PhantomData)\n+        Self(mask)\n     }\n \n     #[inline]\n     pub unsafe fn test_unchecked(&self, lane: usize) -> bool {\n-        (self.0.as_ref()[lane / 8] >> lane % 8) & 0x1 > 0\n+        (self.0.as_ref()[lane / 8] >> (lane % 8)) & 0x1 > 0\n     }\n \n     #[inline]\n@@ -72,41 +103,38 @@ impl<T: Mask, const LANES: usize> BitMask<T, LANES> {\n         V: ConvertToInt + Default + core::ops::Not<Output = V>,\n     {\n         unsafe {\n-            let mask: T::IntBitMask = core::mem::transmute_copy(&self);\n+            let mask: <LaneCount<LANES> as SupportedLaneCount>::IntBitMask =\n+                core::mem::transmute_copy(&self);\n             crate::intrinsics::simd_select_bitmask(mask, !V::default(), V::default())\n         }\n     }\n \n     #[inline]\n     pub unsafe fn from_int_unchecked<V>(value: V) -> Self\n     where\n-        V: crate::LanesAtMost32,\n+        V: crate::Vector,\n     {\n         // TODO remove the transmute when rustc is more flexible\n         assert_eq!(\n-            core::mem::size_of::<T::IntBitMask>(),\n-            core::mem::size_of::<T::BitMask>()\n+            core::mem::size_of::<<crate::LaneCount::<LANES> as crate::SupportedLaneCount>::BitMask>(\n+            ),\n+            core::mem::size_of::<\n+                <crate::LaneCount::<LANES> as crate::SupportedLaneCount>::IntBitMask,\n+            >(),\n         );\n-        let mask: T::IntBitMask = crate::intrinsics::simd_bitmask(value);\n-        Self(core::mem::transmute_copy(&mask), PhantomData)\n+        let mask: <LaneCount<LANES> as SupportedLaneCount>::IntBitMask =\n+            crate::intrinsics::simd_bitmask(value);\n+        Self(core::mem::transmute_copy(&mask))\n     }\n \n     #[inline]\n-    pub fn to_bitmask<U: Mask>(self) -> U::BitMask {\n-        assert_eq!(\n-            core::mem::size_of::<T::BitMask>(),\n-            core::mem::size_of::<U::BitMask>()\n-        );\n-        unsafe { core::mem::transmute_copy(&self.0) }\n+    pub fn to_bitmask(self) -> <LaneCount<LANES> as SupportedLaneCount>::BitMask {\n+        self.0\n     }\n \n     #[inline]\n-    pub fn from_bitmask<U: Mask>(bitmask: U::BitMask) -> Self {\n-        assert_eq!(\n-            core::mem::size_of::<T::BitMask>(),\n-            core::mem::size_of::<U::BitMask>()\n-        );\n-        unsafe { core::mem::transmute_copy(&bitmask) }\n+    pub fn from_bitmask(bitmask: <LaneCount<LANES> as SupportedLaneCount>::BitMask) -> Self {\n+        Self(bitmask)\n     }\n \n     #[inline]\n@@ -120,9 +148,10 @@ impl<T: Mask, const LANES: usize> BitMask<T, LANES> {\n     }\n }\n \n-impl<T: Mask, const LANES: usize> core::ops::BitAnd for BitMask<T, LANES>\n+impl<const LANES: usize> core::ops::BitAnd for BitMask<LANES>\n where\n-    T::BitMask: Default + AsRef<[u8]> + AsMut<[u8]>,\n+    LaneCount<LANES>: SupportedLaneCount,\n+    <LaneCount<LANES> as SupportedLaneCount>::BitMask: Default + AsRef<[u8]> + AsMut<[u8]>,\n {\n     type Output = Self;\n     #[inline]\n@@ -134,9 +163,10 @@ where\n     }\n }\n \n-impl<T: Mask, const LANES: usize> core::ops::BitOr for BitMask<T, LANES>\n+impl<const LANES: usize> core::ops::BitOr for BitMask<LANES>\n where\n-    T::BitMask: Default + AsRef<[u8]> + AsMut<[u8]>,\n+    LaneCount<LANES>: SupportedLaneCount,\n+    <LaneCount<LANES> as SupportedLaneCount>::BitMask: Default + AsRef<[u8]> + AsMut<[u8]>,\n {\n     type Output = Self;\n     #[inline]\n@@ -148,7 +178,10 @@ where\n     }\n }\n \n-impl<T: Mask, const LANES: usize> core::ops::BitXor for BitMask<T, LANES> {\n+impl<const LANES: usize> core::ops::BitXor for BitMask<LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n     type Output = Self;\n     #[inline]\n     fn bitxor(mut self, rhs: Self) -> Self::Output {\n@@ -159,7 +192,10 @@ impl<T: Mask, const LANES: usize> core::ops::BitXor for BitMask<T, LANES> {\n     }\n }\n \n-impl<T: Mask, const LANES: usize> core::ops::Not for BitMask<T, LANES> {\n+impl<const LANES: usize> core::ops::Not for BitMask<LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n     type Output = Self;\n     #[inline]\n     fn not(mut self) -> Self::Output {\n@@ -173,31 +209,8 @@ impl<T: Mask, const LANES: usize> core::ops::Not for BitMask<T, LANES> {\n     }\n }\n \n-pub type Mask8<T, const LANES: usize> = BitMask<T, LANES>;\n-pub type Mask16<T, const LANES: usize> = BitMask<T, LANES>;\n-pub type Mask32<T, const LANES: usize> = BitMask<T, LANES>;\n-pub type Mask64<T, const LANES: usize> = BitMask<T, LANES>;\n-pub type MaskSize<T, const LANES: usize> = BitMask<T, LANES>;\n-\n-macro_rules! impl_from {\n-    { $from:ident ($from_inner:ident) => $($to:ident ($to_inner:ident)),* } => {\n-        $(\n-        impl<const LANES: usize> From<$from<crate::$from<LANES>, LANES>> for $to<crate::$to<LANES>, LANES>\n-        where\n-            crate::$from_inner<LANES>: crate::LanesAtMost32,\n-            crate::$to_inner<LANES>: crate::LanesAtMost32,\n-            crate::$from<LANES>: crate::Mask,\n-            crate::$to<LANES>: crate::Mask,\n-        {\n-            fn from(value: $from<crate::$from<LANES>, LANES>) -> Self {\n-                unsafe { core::mem::transmute_copy(&value) }\n-            }\n-        }\n-        )*\n-    }\n-}\n-impl_from! { Mask8 (SimdI8) => Mask16 (SimdI16), Mask32 (SimdI32), Mask64 (SimdI64), MaskSize (SimdIsize) }\n-impl_from! { Mask16 (SimdI16) => Mask32 (SimdI32), Mask64 (SimdI64), MaskSize (SimdIsize), Mask8 (SimdI8) }\n-impl_from! { Mask32 (SimdI32) => Mask64 (SimdI64), MaskSize (SimdIsize), Mask8 (SimdI8), Mask16 (SimdI16) }\n-impl_from! { Mask64 (SimdI64) => MaskSize (SimdIsize), Mask8 (SimdI8), Mask16 (SimdI16), Mask32 (SimdI32) }\n-impl_from! { MaskSize (SimdIsize) => Mask8 (SimdI8), Mask16 (SimdI16), Mask32 (SimdI32), Mask64 (SimdI64) }\n+pub type Mask8<const LANES: usize> = BitMask<LANES>;\n+pub type Mask16<const LANES: usize> = BitMask<LANES>;\n+pub type Mask32<const LANES: usize> = BitMask<LANES>;\n+pub type Mask64<const LANES: usize> = BitMask<LANES>;\n+pub type MaskSize<const LANES: usize> = BitMask<LANES>;"}, {"sha": "af36571134eeeac1f9a312542cc18f32db0e6d89", "filename": "crates/core_simd/src/masks/full_masks.rs", "status": "modified", "additions": 50, "deletions": 51, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs?ref=82e3405efe5ffd2bc214d32b581d5cfc1157eb8d", "patch": "@@ -1,8 +1,5 @@\n //! Masks that take up full SIMD vector registers.\n \n-use crate::Mask;\n-use core::marker::PhantomData;\n-\n macro_rules! define_mask {\n     {\n         $(#[$attr:meta])*\n@@ -12,62 +9,62 @@ macro_rules! define_mask {\n     } => {\n         $(#[$attr])*\n         #[repr(transparent)]\n-        pub struct $name<T: Mask, const $lanes: usize>(crate::$type<$lanes2>, PhantomData<T>)\n+        pub struct $name<const $lanes: usize>(crate::$type<$lanes>)\n         where\n-            crate::$type<LANES>: crate::LanesAtMost32;\n+            crate::LaneCount<$lanes>: crate::SupportedLaneCount;\n \n         impl_full_mask_reductions! { $name, $type }\n \n-        impl<T: Mask, const LANES: usize> Copy for $name<T, LANES>\n+        impl<const LANES: usize> Copy for $name<LANES>\n         where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {}\n \n-        impl<T: Mask, const LANES: usize> Clone for $name<T, LANES>\n+        impl<const LANES: usize> Clone for $name<LANES>\n         where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             #[inline]\n             fn clone(&self) -> Self {\n                 *self\n             }\n         }\n \n-        impl<T: Mask, const LANES: usize> PartialEq for $name<T, LANES>\n+        impl<const LANES: usize> PartialEq for $name<LANES>\n         where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             fn eq(&self, other: &Self) -> bool {\n                 self.0 == other.0\n             }\n         }\n \n-        impl<T: Mask, const LANES: usize> PartialOrd for $name<T, LANES>\n+        impl<const LANES: usize> PartialOrd for $name<LANES>\n         where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n                 self.0.partial_cmp(&other.0)\n             }\n         }\n \n-        impl<T: Mask, const LANES: usize> Eq for $name<T, LANES>\n+        impl<const LANES: usize> Eq for $name<LANES>\n         where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {}\n \n-        impl<T: Mask, const LANES: usize> Ord for $name<T, LANES>\n+        impl<const LANES: usize> Ord for $name<LANES>\n         where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n                 self.0.cmp(&other.0)\n             }\n         }\n \n-        impl<T: Mask, const LANES: usize> $name<T, LANES>\n+        impl<const LANES: usize> $name<LANES>\n         where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             pub fn splat(value: bool) -> Self {\n                 Self(\n@@ -78,7 +75,6 @@ macro_rules! define_mask {\n                             0\n                         }\n                     ),\n-                    PhantomData,\n                 )\n             }\n \n@@ -103,16 +99,19 @@ macro_rules! define_mask {\n \n             #[inline]\n             pub unsafe fn from_int_unchecked(value: crate::$type<LANES>) -> Self {\n-                Self(value, PhantomData)\n+                Self(value)\n             }\n \n             #[inline]\n-            pub fn to_bitmask<U: crate::Mask>(self) -> U::BitMask {\n+            pub fn to_bitmask(self) -> <crate::LaneCount::<LANES> as crate::SupportedLaneCount>::BitMask {\n                 unsafe {\n-                    // TODO remove the transmute when rustc is more flexible\n-                    assert_eq!(core::mem::size_of::<U::IntBitMask>(), core::mem::size_of::<U::BitMask>());\n-                    let mask: U::IntBitMask = crate::intrinsics::simd_bitmask(self.0);\n-                    let mut bitmask: U::BitMask = core::mem::transmute_copy(&mask);\n+                    // TODO remove the transmute when rustc can use arrays of u8 as bitmasks\n+                    assert_eq!(\n+                        core::mem::size_of::<<crate::LaneCount::<LANES> as crate::SupportedLaneCount>::BitMask>(),\n+                        core::mem::size_of::<<crate::LaneCount::<LANES> as crate::SupportedLaneCount>::IntBitMask>(),\n+                    );\n+                    let bitmask: <crate::LaneCount::<LANES> as crate::SupportedLaneCount>::IntBitMask = crate::intrinsics::simd_bitmask(self.0);\n+                    let mut bitmask: <crate::LaneCount::<LANES> as crate::SupportedLaneCount>::BitMask = core::mem::transmute_copy(&bitmask);\n \n                     // There is a bug where LLVM appears to implement this operation with the wrong\n                     // bit order.\n@@ -128,7 +127,7 @@ macro_rules! define_mask {\n             }\n \n             #[inline]\n-            pub fn from_bitmask<U: crate::Mask>(mut bitmask: U::BitMask) -> Self {\n+            pub fn from_bitmask(mut bitmask: <crate::LaneCount::<LANES> as crate::SupportedLaneCount>::BitMask) -> Self {\n                 unsafe {\n                     // There is a bug where LLVM appears to implement this operation with the wrong\n                     // bit order.\n@@ -139,9 +138,12 @@ macro_rules! define_mask {\n                         }\n                     }\n \n-                    // TODO remove the transmute when rustc is more flexible\n-                    assert_eq!(core::mem::size_of::<U::IntBitMask>(), core::mem::size_of::<U::BitMask>());\n-                    let bitmask: U::IntBitMask = core::mem::transmute_copy(&bitmask);\n+                    // TODO remove the transmute when rustc can use arrays of u8 as bitmasks\n+                    assert_eq!(\n+                        core::mem::size_of::<<crate::LaneCount::<LANES> as crate::SupportedLaneCount>::BitMask>(),\n+                        core::mem::size_of::<<crate::LaneCount::<LANES> as crate::SupportedLaneCount>::IntBitMask>(),\n+                    );\n+                    let bitmask: <crate::LaneCount::<LANES> as crate::SupportedLaneCount>::IntBitMask = core::mem::transmute_copy(&bitmask);\n \n                     Self::from_int_unchecked(crate::intrinsics::simd_select_bitmask(\n                         bitmask,\n@@ -152,56 +154,56 @@ macro_rules! define_mask {\n             }\n         }\n \n-        impl<T: Mask, const LANES: usize> core::convert::From<$name<T, LANES>> for crate::$type<LANES>\n+        impl<const LANES: usize> core::convert::From<$name<LANES>> for crate::$type<LANES>\n         where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n-            fn from(value: $name<T, LANES>) -> Self {\n+            fn from(value: $name<LANES>) -> Self {\n                 value.0\n             }\n         }\n \n-        impl<T: Mask, const LANES: usize> core::ops::BitAnd for $name<T, LANES>\n+        impl<const LANES: usize> core::ops::BitAnd for $name<LANES>\n         where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             type Output = Self;\n             #[inline]\n             fn bitand(self, rhs: Self) -> Self {\n-                Self(self.0 & rhs.0, PhantomData)\n+                Self(self.0 & rhs.0)\n             }\n         }\n \n-        impl<T: Mask, const LANES: usize> core::ops::BitOr for $name<T, LANES>\n+        impl<const LANES: usize> core::ops::BitOr for $name<LANES>\n         where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             type Output = Self;\n             #[inline]\n             fn bitor(self, rhs: Self) -> Self {\n-                Self(self.0 | rhs.0, PhantomData)\n+                Self(self.0 | rhs.0)\n             }\n         }\n \n-        impl<T: Mask, const LANES: usize> core::ops::BitXor for $name<T, LANES>\n+        impl<const LANES: usize> core::ops::BitXor for $name<LANES>\n         where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             type Output = Self;\n             #[inline]\n             fn bitxor(self, rhs: Self) -> Self::Output {\n-                Self(self.0 ^ rhs.0, PhantomData)\n+                Self(self.0 ^ rhs.0)\n             }\n         }\n \n-        impl<T: Mask, const LANES: usize> core::ops::Not for $name<T, LANES>\n+        impl<const LANES: usize> core::ops::Not for $name<LANES>\n         where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             type Output = Self;\n             #[inline]\n             fn not(self) -> Self::Output {\n-                Self(!self.0, PhantomData)\n+                Self(!self.0)\n             }\n         }\n     }\n@@ -240,14 +242,11 @@ define_mask! {\n macro_rules! impl_from {\n     { $from:ident ($from_inner:ident) => $($to:ident ($to_inner:ident)),* } => {\n         $(\n-        impl<const LANES: usize, T, U> From<$from<T, LANES>> for $to<U, LANES>\n+        impl<const LANES: usize> From<$from<LANES>> for $to<LANES>\n         where\n-            crate::$from_inner<LANES>: crate::LanesAtMost32,\n-            crate::$to_inner<LANES>: crate::LanesAtMost32,\n-            T: crate::Mask,\n-            U: crate::Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n-            fn from(value: $from<T, LANES>) -> Self {\n+            fn from(value: $from<LANES>) -> Self {\n                 let mut new = Self::splat(false);\n                 for i in 0..LANES {\n                     unsafe { new.set_unchecked(i, value.test_unchecked(i)) }"}, {"sha": "28720eb13e3c5167ba5a7d10b9a01e9f5a2d6443", "filename": "crates/core_simd/src/math.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Fmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Fmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmath.rs?ref=82e3405efe5ffd2bc214d32b581d5cfc1157eb8d", "patch": "@@ -1,6 +1,6 @@\n macro_rules! impl_uint_arith {\n     ($(($name:ident, $n:ident)),+) => {\n-        $( impl<const LANES: usize> $name<LANES> where Self: crate::LanesAtMost32 {\n+        $( impl<const LANES: usize> $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n \n             /// Lanewise saturating add.\n             ///\n@@ -44,7 +44,7 @@ macro_rules! impl_uint_arith {\n \n macro_rules! impl_int_arith {\n     ($(($name:ident, $n:ident)),+) => {\n-        $( impl<const LANES: usize> $name<LANES> where Self: crate::LanesAtMost32 {\n+        $( impl<const LANES: usize> $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n \n             /// Lanewise saturating add.\n             ///"}, {"sha": "c75090aab9c5048f5d74f28040f188f1a7906560", "filename": "crates/core_simd/src/ops.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fops.rs?ref=82e3405efe5ffd2bc214d32b581d5cfc1157eb8d", "patch": "@@ -1,4 +1,4 @@\n-use crate::LanesAtMost32;\n+use crate::{LaneCount, SupportedLaneCount};\n \n /// Checks if the right-hand side argument of a left- or right-shift would cause overflow.\n fn invalid_shift_rhs<T>(rhs: T) -> bool\n@@ -16,7 +16,7 @@ macro_rules! impl_ref_ops {\n     {\n         impl<const $lanes:ident: usize> core::ops::$trait:ident<$rhs:ty> for $type:ty\n         where\n-            $($bound:path: LanesAtMost32,)*\n+            LaneCount<$lanes2:ident>: SupportedLaneCount,\n         {\n             type Output = $output:ty;\n \n@@ -26,7 +26,7 @@ macro_rules! impl_ref_ops {\n     } => {\n         impl<const $lanes: usize> core::ops::$trait<$rhs> for $type\n         where\n-            $($bound: LanesAtMost32,)*\n+            LaneCount<$lanes2>: SupportedLaneCount,\n         {\n             type Output = $output;\n \n@@ -36,7 +36,7 @@ macro_rules! impl_ref_ops {\n \n         impl<const $lanes: usize> core::ops::$trait<&'_ $rhs> for $type\n         where\n-            $($bound: LanesAtMost32,)*\n+            LaneCount<$lanes2>: SupportedLaneCount,\n         {\n             type Output = <$type as core::ops::$trait<$rhs>>::Output;\n \n@@ -48,7 +48,7 @@ macro_rules! impl_ref_ops {\n \n         impl<const $lanes: usize> core::ops::$trait<$rhs> for &'_ $type\n         where\n-            $($bound: LanesAtMost32,)*\n+            LaneCount<$lanes2>: SupportedLaneCount,\n         {\n             type Output = <$type as core::ops::$trait<$rhs>>::Output;\n \n@@ -60,7 +60,7 @@ macro_rules! impl_ref_ops {\n \n         impl<const $lanes: usize> core::ops::$trait<&'_ $rhs> for &'_ $type\n         where\n-            $($bound: LanesAtMost32,)*\n+            LaneCount<$lanes2>: SupportedLaneCount,\n         {\n             type Output = <$type as core::ops::$trait<$rhs>>::Output;\n \n@@ -75,23 +75,23 @@ macro_rules! impl_ref_ops {\n     {\n         impl<const $lanes:ident: usize> core::ops::$trait:ident<$rhs:ty> for $type:ty\n         where\n-            $($bound:path: LanesAtMost32,)*\n+            LaneCount<$lanes2:ident>: SupportedLaneCount,\n         {\n             $(#[$attrs:meta])*\n             fn $fn:ident(&mut $self_tok:ident, $rhs_arg:ident: $rhs_arg_ty:ty) $body:tt\n         }\n     } => {\n         impl<const $lanes: usize> core::ops::$trait<$rhs> for $type\n         where\n-            $($bound: LanesAtMost32,)*\n+            LaneCount<$lanes2>: SupportedLaneCount,\n         {\n             $(#[$attrs])*\n             fn $fn(&mut $self_tok, $rhs_arg: $rhs_arg_ty) $body\n         }\n \n         impl<const $lanes: usize> core::ops::$trait<&'_ $rhs> for $type\n         where\n-            $($bound: LanesAtMost32,)*\n+            LaneCount<$lanes2>: SupportedLaneCount,\n         {\n             $(#[$attrs])*\n             fn $fn(&mut $self_tok, $rhs_arg: &$rhs_arg_ty) {\n@@ -104,23 +104,23 @@ macro_rules! impl_ref_ops {\n     {\n         impl<const $lanes:ident: usize> core::ops::$trait:ident for $type:ty\n         where\n-            $($bound:path: LanesAtMost32,)*\n+            LaneCount<$lanes2:ident>: SupportedLaneCount,\n         {\n             type Output = $output:ty;\n             fn $fn:ident($self_tok:ident) -> Self::Output $body:tt\n         }\n     } => {\n         impl<const $lanes: usize> core::ops::$trait for $type\n         where\n-            $($bound: LanesAtMost32,)*\n+            LaneCount<$lanes2>: SupportedLaneCount,\n         {\n             type Output = $output;\n             fn $fn($self_tok) -> Self::Output $body\n         }\n \n         impl<const $lanes: usize> core::ops::$trait for &'_ $type\n         where\n-            $($bound: LanesAtMost32,)*\n+            LaneCount<$lanes2>: SupportedLaneCount,\n         {\n             type Output = <$type as core::ops::$trait>::Output;\n             fn $fn($self_tok) -> Self::Output {\n@@ -167,7 +167,7 @@ macro_rules! impl_op {\n         impl_ref_ops! {\n             impl<const LANES: usize> core::ops::Not for crate::$type<LANES>\n             where\n-                crate::$type<LANES>: LanesAtMost32,\n+                LaneCount<LANES>: SupportedLaneCount,\n             {\n                 type Output = Self;\n                 fn not(self) -> Self::Output {\n@@ -181,7 +181,7 @@ macro_rules! impl_op {\n         impl_ref_ops! {\n             impl<const LANES: usize> core::ops::Neg for crate::$type<LANES>\n             where\n-                crate::$type<LANES>: LanesAtMost32,\n+                LaneCount<LANES>: SupportedLaneCount,\n             {\n                 type Output = Self;\n                 fn neg(self) -> Self::Output {\n@@ -194,7 +194,7 @@ macro_rules! impl_op {\n     { impl Index for $type:ident, $scalar:ty } => {\n         impl<I, const LANES: usize> core::ops::Index<I> for crate::$type<LANES>\n         where\n-            Self: LanesAtMost32,\n+            LaneCount<LANES>: SupportedLaneCount,\n             I: core::slice::SliceIndex<[$scalar]>,\n         {\n             type Output = I::Output;\n@@ -206,7 +206,7 @@ macro_rules! impl_op {\n \n         impl<I, const LANES: usize> core::ops::IndexMut<I> for crate::$type<LANES>\n         where\n-            Self: LanesAtMost32,\n+            LaneCount<LANES>: SupportedLaneCount,\n             I: core::slice::SliceIndex<[$scalar]>,\n         {\n             fn index_mut(&mut self, index: I) -> &mut Self::Output {\n@@ -221,7 +221,7 @@ macro_rules! impl_op {\n         impl_ref_ops! {\n             impl<const LANES: usize> core::ops::$trait<Self> for crate::$type<LANES>\n             where\n-                crate::$type<LANES>: LanesAtMost32,\n+                LaneCount<LANES>: SupportedLaneCount,\n             {\n                 type Output = Self;\n \n@@ -237,7 +237,7 @@ macro_rules! impl_op {\n         impl_ref_ops! {\n             impl<const LANES: usize> core::ops::$trait<$scalar> for crate::$type<LANES>\n             where\n-                crate::$type<LANES>: LanesAtMost32,\n+                LaneCount<LANES>: SupportedLaneCount,\n             {\n                 type Output = Self;\n \n@@ -251,7 +251,7 @@ macro_rules! impl_op {\n         impl_ref_ops! {\n             impl<const LANES: usize> core::ops::$trait<crate::$type<LANES>> for $scalar\n             where\n-                crate::$type<LANES>: LanesAtMost32,\n+                LaneCount<LANES>: SupportedLaneCount,\n             {\n                 type Output = crate::$type<LANES>;\n \n@@ -265,7 +265,7 @@ macro_rules! impl_op {\n         impl_ref_ops! {\n             impl<const LANES: usize> core::ops::$assign_trait<Self> for crate::$type<LANES>\n             where\n-                crate::$type<LANES>: LanesAtMost32,\n+                LaneCount<LANES>: SupportedLaneCount,\n             {\n                 #[inline]\n                 fn $assign_trait_fn(&mut self, rhs: Self) {\n@@ -279,7 +279,7 @@ macro_rules! impl_op {\n         impl_ref_ops! {\n             impl<const LANES: usize> core::ops::$assign_trait<$scalar> for crate::$type<LANES>\n             where\n-                crate::$type<LANES>: LanesAtMost32,\n+                LaneCount<LANES>: SupportedLaneCount,\n             {\n                 #[inline]\n                 fn $assign_trait_fn(&mut self, rhs: $scalar) {\n@@ -325,13 +325,13 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::Div<Self> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: LanesAtMost32,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         type Output = Self;\n \n                         #[inline]\n                         fn div(self, rhs: Self) -> Self::Output {\n-                            if rhs.as_slice()\n+                            if rhs.as_array()\n                                 .iter()\n                                 .any(|x| *x == 0)\n                             {\n@@ -340,8 +340,8 @@ macro_rules! impl_unsigned_int_ops {\n \n                             // Guards for div(MIN, -1),\n                             // this check only applies to signed ints\n-                            if <$scalar>::MIN != 0 && self.as_slice().iter()\n-                                    .zip(rhs.as_slice().iter())\n+                            if <$scalar>::MIN != 0 && self.as_array().iter()\n+                                    .zip(rhs.as_array().iter())\n                                     .any(|(x,y)| *x == <$scalar>::MIN && *y == -1 as _) {\n                                 panic!(\"attempt to divide with overflow\");\n                             }\n@@ -353,7 +353,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::Div<$scalar> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: LanesAtMost32,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         type Output = Self;\n \n@@ -363,7 +363,7 @@ macro_rules! impl_unsigned_int_ops {\n                                 panic!(\"attempt to divide by zero\");\n                             }\n                             if <$scalar>::MIN != 0 &&\n-                                self.as_slice().iter().any(|x| *x == <$scalar>::MIN) &&\n+                                self.as_array().iter().any(|x| *x == <$scalar>::MIN) &&\n                                 rhs == -1 as _ {\n                                     panic!(\"attempt to divide with overflow\");\n                             }\n@@ -376,7 +376,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::Div<crate::$vector<LANES>> for $scalar\n                     where\n-                        crate::$vector<LANES>: LanesAtMost32,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         type Output = crate::$vector<LANES>;\n \n@@ -390,7 +390,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::DivAssign<Self> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: LanesAtMost32,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         #[inline]\n                         fn div_assign(&mut self, rhs: Self) {\n@@ -402,7 +402,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::DivAssign<$scalar> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: LanesAtMost32,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         #[inline]\n                         fn div_assign(&mut self, rhs: $scalar) {\n@@ -415,13 +415,13 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::Rem<Self> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: LanesAtMost32,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         type Output = Self;\n \n                         #[inline]\n                         fn rem(self, rhs: Self) -> Self::Output {\n-                            if rhs.as_slice()\n+                            if rhs.as_array()\n                                 .iter()\n                                 .any(|x| *x == 0)\n                             {\n@@ -430,8 +430,8 @@ macro_rules! impl_unsigned_int_ops {\n \n                             // Guards for rem(MIN, -1)\n                             // this branch applies the check only to signed ints\n-                            if <$scalar>::MIN != 0 && self.as_slice().iter()\n-                                    .zip(rhs.as_slice().iter())\n+                            if <$scalar>::MIN != 0 && self.as_array().iter()\n+                                    .zip(rhs.as_array().iter())\n                                     .any(|(x,y)| *x == <$scalar>::MIN && *y == -1 as _) {\n                                 panic!(\"attempt to calculate the remainder with overflow\");\n                             }\n@@ -443,7 +443,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::Rem<$scalar> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: LanesAtMost32,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         type Output = Self;\n \n@@ -453,7 +453,7 @@ macro_rules! impl_unsigned_int_ops {\n                                 panic!(\"attempt to calculate the remainder with a divisor of zero\");\n                             }\n                             if <$scalar>::MIN != 0 &&\n-                                self.as_slice().iter().any(|x| *x == <$scalar>::MIN) &&\n+                                self.as_array().iter().any(|x| *x == <$scalar>::MIN) &&\n                                 rhs == -1 as _ {\n                                     panic!(\"attempt to calculate the remainder with overflow\");\n                             }\n@@ -466,7 +466,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::Rem<crate::$vector<LANES>> for $scalar\n                     where\n-                        crate::$vector<LANES>: LanesAtMost32,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         type Output = crate::$vector<LANES>;\n \n@@ -480,7 +480,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::RemAssign<Self> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: LanesAtMost32,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         #[inline]\n                         fn rem_assign(&mut self, rhs: Self) {\n@@ -492,7 +492,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::RemAssign<$scalar> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: LanesAtMost32,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         #[inline]\n                         fn rem_assign(&mut self, rhs: $scalar) {\n@@ -505,14 +505,14 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::Shl<Self> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: LanesAtMost32,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         type Output = Self;\n \n                         #[inline]\n                         fn shl(self, rhs: Self) -> Self::Output {\n                             // TODO there is probably a better way of doing this\n-                            if rhs.as_slice()\n+                            if rhs.as_array()\n                                 .iter()\n                                 .copied()\n                                 .any(invalid_shift_rhs)\n@@ -527,7 +527,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::Shl<$scalar> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: LanesAtMost32,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         type Output = Self;\n \n@@ -546,7 +546,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::ShlAssign<Self> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: LanesAtMost32,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         #[inline]\n                         fn shl_assign(&mut self, rhs: Self) {\n@@ -558,7 +558,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::ShlAssign<$scalar> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: LanesAtMost32,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         #[inline]\n                         fn shl_assign(&mut self, rhs: $scalar) {\n@@ -570,14 +570,14 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::Shr<Self> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: LanesAtMost32,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         type Output = Self;\n \n                         #[inline]\n                         fn shr(self, rhs: Self) -> Self::Output {\n                             // TODO there is probably a better way of doing this\n-                            if rhs.as_slice()\n+                            if rhs.as_array()\n                                 .iter()\n                                 .copied()\n                                 .any(invalid_shift_rhs)\n@@ -592,7 +592,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::Shr<$scalar> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: LanesAtMost32,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         type Output = Self;\n \n@@ -611,7 +611,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::ShrAssign<Self> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: LanesAtMost32,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         #[inline]\n                         fn shr_assign(&mut self, rhs: Self) {\n@@ -623,7 +623,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::ShrAssign<$scalar> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: LanesAtMost32,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         #[inline]\n                         fn shr_assign(&mut self, rhs: $scalar) {"}, {"sha": "df227d09e3420860a1a5d1ecc76b8142ce7a105a", "filename": "crates/core_simd/src/reduction.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Freduction.rs?ref=82e3405efe5ffd2bc214d32b581d5cfc1157eb8d", "patch": "@@ -2,7 +2,7 @@ macro_rules! impl_integer_reductions {\n     { $name:ident, $scalar:ty } => {\n         impl<const LANES: usize> crate::$name<LANES>\n         where\n-            Self: crate::LanesAtMost32\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             /// Horizontal wrapping add.  Returns the sum of the lanes of the vector, with wrapping addition.\n             #[inline]\n@@ -56,15 +56,15 @@ macro_rules! impl_float_reductions {\n     { $name:ident, $scalar:ty } => {\n         impl<const LANES: usize> crate::$name<LANES>\n         where\n-            Self: crate::LanesAtMost32\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n \n             /// Horizontal add.  Returns the sum of the lanes of the vector.\n             #[inline]\n             pub fn horizontal_sum(self) -> $scalar {\n                 // LLVM sum is inaccurate on i586\n                 if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n-                    self.as_slice().iter().sum()\n+                    self.as_array().iter().sum()\n                 } else {\n                     unsafe { crate::intrinsics::simd_reduce_add_ordered(self, 0.) }\n                 }\n@@ -75,7 +75,7 @@ macro_rules! impl_float_reductions {\n             pub fn horizontal_product(self) -> $scalar {\n                 // LLVM product is inaccurate on i586\n                 if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n-                    self.as_slice().iter().product()\n+                    self.as_array().iter().product()\n                 } else {\n                     unsafe { crate::intrinsics::simd_reduce_mul_ordered(self, 1.) }\n                 }\n@@ -104,9 +104,9 @@ macro_rules! impl_float_reductions {\n \n macro_rules! impl_full_mask_reductions {\n     { $name:ident, $bits_ty:ident } => {\n-        impl<T: crate::Mask, const LANES: usize> $name<T, LANES>\n+        impl<const LANES: usize> $name<LANES>\n         where\n-            crate::$bits_ty<LANES>: crate::LanesAtMost32\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             #[inline]\n             pub fn any(self) -> bool {\n@@ -125,8 +125,7 @@ macro_rules! impl_opaque_mask_reductions {\n     { $name:ident, $bits_ty:ident } => {\n         impl<const LANES: usize> $name<LANES>\n         where\n-            crate::$bits_ty<LANES>: crate::LanesAtMost32,\n-            $name<LANES>: crate::Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             /// Returns true if any lane is set, or false otherwise.\n             #[inline]"}, {"sha": "74cae0cf989830779f4bc5ee2bf4e5c575828d06", "filename": "crates/core_simd/src/round.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Fround.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Fround.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fround.rs?ref=82e3405efe5ffd2bc214d32b581d5cfc1157eb8d", "patch": "@@ -5,7 +5,7 @@ macro_rules! implement {\n         #[cfg(feature = \"std\")]\n         impl<const LANES: usize> crate::$type<LANES>\n         where\n-            Self: crate::LanesAtMost32,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             /// Returns the smallest integer greater than or equal to each lane.\n             #[must_use = \"method returns a new vector and does not mutate the original value\"]\n@@ -41,13 +41,7 @@ macro_rules! implement {\n             pub fn fract(self) -> Self {\n                 self - self.trunc()\n             }\n-        }\n \n-        impl<const LANES: usize> crate::$type<LANES>\n-        where\n-            Self: crate::LanesAtMost32,\n-            crate::$int_type<LANES>: crate::LanesAtMost32,\n-        {\n             /// Rounds toward zero and converts to the same-width integer type, assuming that\n             /// the value is finite and fits in that type.\n             ///"}, {"sha": "d70e8a66b95fcedb15fa1572ab26e1c845de74cc", "filename": "crates/core_simd/src/select.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fselect.rs?ref=82e3405efe5ffd2bc214d32b581d5cfc1157eb8d", "patch": "@@ -14,12 +14,10 @@ macro_rules! impl_select {\n         $mask:ident ($bits_ty:ident): $($type:ident),*\n     } => {\n         $(\n-        impl<const LANES: usize> Sealed for crate::$type<LANES> where Self: crate::LanesAtMost32 {}\n+        impl<const LANES: usize> Sealed for crate::$type<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {}\n         impl<const LANES: usize> Select<crate::$mask<LANES>> for crate::$type<LANES>\n         where\n-            crate::$mask<LANES>: crate::Mask,\n-            crate::$bits_ty<LANES>: crate::LanesAtMost32,\n-            Self: crate::LanesAtMost32,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             #[doc(hidden)]\n             #[inline]\n@@ -31,13 +29,12 @@ macro_rules! impl_select {\n \n         impl<const LANES: usize> Sealed for crate::$mask<LANES>\n         where\n-            Self: crate::Mask,\n-            crate::$bits_ty<LANES>: crate::LanesAtMost32,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {}\n+\n         impl<const LANES: usize> Select<Self> for crate::$mask<LANES>\n         where\n-            Self: crate::Mask,\n-            crate::$bits_ty<LANES>: crate::LanesAtMost32,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             #[doc(hidden)]\n             #[inline]\n@@ -48,8 +45,7 @@ macro_rules! impl_select {\n \n         impl<const LANES: usize> crate::$mask<LANES>\n         where\n-            Self: crate::Mask,\n-            crate::$bits_ty<LANES>: crate::LanesAtMost32,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             /// Choose lanes from two vectors.\n             ///"}, {"sha": "0823391049fdcbca0bed9846f312b0fd9fb32eae", "filename": "crates/core_simd/src/to_bytes.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fto_bytes.rs?ref=82e3405efe5ffd2bc214d32b581d5cfc1157eb8d", "patch": "@@ -18,11 +18,14 @@ pub trait ToBytes: Sealed {\n macro_rules! impl_to_bytes {\n     { $name:ident, $($int_width:literal -> $byte_width:literal),* } => {\n         $(\n-        impl Sealed for crate::$name<$int_width> where Self: crate::LanesAtMost32 {}\n+        impl Sealed for crate::$name<$int_width>\n+        where\n+            crate::LaneCount<$int_width>: crate::SupportedLaneCount,\n+        {}\n+\n         impl ToBytes for crate::$name<$int_width>\n         where\n-            Self: crate::LanesAtMost32,\n-            crate::SimdU8<$byte_width>: crate::LanesAtMost32,\n+            crate::LaneCount<$int_width>: crate::SupportedLaneCount,\n         {\n             type Bytes = crate::SimdU8<$byte_width>;\n             fn to_bytes_impl(self) -> Self::Bytes {\n@@ -36,7 +39,8 @@ macro_rules! impl_to_bytes {\n \n         impl<const LANES: usize> crate::$name<LANES>\n         where\n-            Self: ToBytes + crate::LanesAtMost32,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n+            Self: ToBytes,\n         {\n             /// Return the memory representation of this integer as a byte array in native byte\n             /// order."}, {"sha": "1f6df533767e0b360c469aa5e9de4625b2a5fe69", "filename": "crates/core_simd/src/vector.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector.rs?ref=82e3405efe5ffd2bc214d32b581d5cfc1157eb8d", "patch": "@@ -1,3 +1,6 @@\n+#[macro_use]\n+mod vector_impl;\n+\n mod float;\n mod int;\n mod uint;\n@@ -8,3 +11,22 @@ pub use uint::*;\n \n // Vectors of pointers are not for public use at the current time.\n pub(crate) mod ptr;\n+\n+mod sealed {\n+    pub trait Sealed {}\n+}\n+\n+/// A representation of a vector as an \"array\" with indices, implementing\n+/// operations applicable to any vector type based solely on \"having lanes\",\n+/// and describing relationships between vector and scalar types.\n+pub trait Vector: sealed::Sealed {\n+    /// The scalar type in every lane of this vector type.\n+    type Scalar: Copy + Sized;\n+\n+    /// The number of lanes for this vector.\n+    const LANES: usize;\n+\n+    /// Generates a SIMD vector with the same value in every lane.\n+    #[must_use]\n+    fn splat(val: Self::Scalar) -> Self;\n+}"}, {"sha": "bdeccd037a80e3d0907ef2073c86a6ac5f335f7a", "filename": "crates/core_simd/src/vector/float.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs?ref=82e3405efe5ffd2bc214d32b581d5cfc1157eb8d", "patch": "@@ -1,5 +1,7 @@\n #![allow(non_camel_case_types)]\n \n+use crate::{LaneCount, SupportedLaneCount};\n+\n /// Implements inherent methods for a float vector `$name` containing multiple\n /// `$lanes` of float `$type`, which uses `$bits_ty` as its binary\n /// representation. Called from `define_float_vector!`.\n@@ -10,8 +12,7 @@ macro_rules! impl_float_vector {\n \n         impl<const LANES: usize> $name<LANES>\n         where\n-            Self: crate::LanesAtMost32,\n-            crate::$bits_ty<LANES>: crate::LanesAtMost32,\n+            LaneCount<LANES>: SupportedLaneCount,\n         {\n             /// Raw transmutation to an unsigned integer vector type with the\n             /// same size and number of lanes.\n@@ -74,15 +75,7 @@ macro_rules! impl_float_vector {\n             pub fn to_radians(self) -> Self {\n                 self * Self::splat($type::to_radians(1.))\n             }\n-        }\n \n-        impl<const LANES: usize> $name<LANES>\n-        where\n-            Self: crate::LanesAtMost32,\n-            crate::$bits_ty<LANES>: crate::LanesAtMost32,\n-            crate::$mask_impl_ty<LANES>: crate::LanesAtMost32,\n-            crate::$mask_ty<LANES>: crate::Mask,\n-        {\n             /// Returns true for each lane if it has a positive sign, including\n             /// `+0.0`, `NaN`s with positive sign bit and positive infinity.\n             #[inline]\n@@ -197,15 +190,15 @@ macro_rules! impl_float_vector {\n #[repr(simd)]\n pub struct SimdF32<const LANES: usize>([f32; LANES])\n where\n-    Self: crate::LanesAtMost32;\n+    LaneCount<LANES>: SupportedLaneCount;\n \n impl_float_vector! { SimdF32, f32, SimdU32, Mask32, SimdI32 }\n \n /// A SIMD vector of containing `LANES` `f64` values.\n #[repr(simd)]\n pub struct SimdF64<const LANES: usize>([f64; LANES])\n where\n-    Self: crate::LanesAtMost32;\n+    LaneCount<LANES>: SupportedLaneCount;\n \n impl_float_vector! { SimdF64, f64, SimdU64, Mask64, SimdI64 }\n "}, {"sha": "73c737762fb6003b76fbad02e83a54eba19f5c91", "filename": "crates/core_simd/src/vector/int.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs?ref=82e3405efe5ffd2bc214d32b581d5cfc1157eb8d", "patch": "@@ -1,36 +1,39 @@\n #![allow(non_camel_case_types)]\n \n+use crate::{LaneCount, SupportedLaneCount};\n+\n /// Implements additional integer traits (Eq, Ord, Hash) on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n macro_rules! impl_integer_vector {\n     { $name:ident, $type:ty, $mask_ty:ident, $mask_impl_ty:ident } => {\n         impl_vector! { $name, $type }\n         impl_integer_reductions! { $name, $type }\n \n-        impl<const LANES: usize> Eq for $name<LANES> where Self: crate::LanesAtMost32 {}\n+        impl<const LANES: usize> Eq for $name<LANES> where LaneCount<LANES>: SupportedLaneCount {}\n \n-        impl<const LANES: usize> Ord for $name<LANES> where Self: crate::LanesAtMost32 {\n+        impl<const LANES: usize> Ord for $name<LANES> where LaneCount<LANES>: SupportedLaneCount {\n             #[inline]\n             fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n                 // TODO use SIMD cmp\n-                self.to_array().cmp(other.as_ref())\n+                self.as_array().cmp(other.as_ref())\n             }\n         }\n \n-        impl<const LANES: usize> core::hash::Hash for $name<LANES> where Self: crate::LanesAtMost32 {\n+        impl<const LANES: usize> core::hash::Hash for $name<LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n             #[inline]\n             fn hash<H>(&self, state: &mut H)\n             where\n                 H: core::hash::Hasher\n             {\n-                self.as_slice().hash(state)\n+                self.as_array().hash(state)\n             }\n         }\n \n         impl<const LANES: usize> $name<LANES>\n         where\n-            Self: crate::LanesAtMost32,\n-            crate::$mask_impl_ty<LANES>: crate::LanesAtMost32,\n-            crate::$mask_ty<LANES>: crate::Mask,\n+            LaneCount<LANES>: SupportedLaneCount,\n         {\n             /// Returns true for each positive lane and false if it is zero or negative.\n             #[inline]\n@@ -63,39 +66,39 @@ macro_rules! impl_integer_vector {\n #[repr(simd)]\n pub struct SimdIsize<const LANES: usize>([isize; LANES])\n where\n-    Self: crate::LanesAtMost32;\n+    LaneCount<LANES>: SupportedLaneCount;\n \n impl_integer_vector! { SimdIsize, isize, MaskSize, SimdIsize }\n \n /// A SIMD vector of containing `LANES` `i16` values.\n #[repr(simd)]\n pub struct SimdI16<const LANES: usize>([i16; LANES])\n where\n-    Self: crate::LanesAtMost32;\n+    LaneCount<LANES>: SupportedLaneCount;\n \n impl_integer_vector! { SimdI16, i16, Mask16, SimdI16 }\n \n /// A SIMD vector of containing `LANES` `i32` values.\n #[repr(simd)]\n pub struct SimdI32<const LANES: usize>([i32; LANES])\n where\n-    Self: crate::LanesAtMost32;\n+    LaneCount<LANES>: SupportedLaneCount;\n \n impl_integer_vector! { SimdI32, i32, Mask32, SimdI32 }\n \n /// A SIMD vector of containing `LANES` `i64` values.\n #[repr(simd)]\n pub struct SimdI64<const LANES: usize>([i64; LANES])\n where\n-    Self: crate::LanesAtMost32;\n+    LaneCount<LANES>: SupportedLaneCount;\n \n impl_integer_vector! { SimdI64, i64, Mask64, SimdI64 }\n \n /// A SIMD vector of containing `LANES` `i8` values.\n #[repr(simd)]\n pub struct SimdI8<const LANES: usize>([i8; LANES])\n where\n-    Self: crate::LanesAtMost32;\n+    LaneCount<LANES>: SupportedLaneCount;\n \n impl_integer_vector! { SimdI8, i8, Mask8, SimdI8 }\n "}, {"sha": "9dd1bfd0f3659daf3d0fd54509971d088119a79a", "filename": "crates/core_simd/src/vector/ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs?ref=82e3405efe5ffd2bc214d32b581d5cfc1157eb8d", "patch": "@@ -1,5 +1,5 @@\n //! Private implementation details of public gather/scatter APIs.\n-use crate::SimdUsize;\n+use crate::{LaneCount, SimdUsize, SupportedLaneCount};\n use core::mem;\n \n /// A vector of *const T.\n@@ -9,7 +9,7 @@ pub(crate) struct SimdConstPtr<T, const LANES: usize>([*const T; LANES]);\n \n impl<T, const LANES: usize> SimdConstPtr<T, LANES>\n where\n-    SimdUsize<LANES>: crate::LanesAtMost32,\n+    LaneCount<LANES>: SupportedLaneCount,\n     T: Sized,\n {\n     #[inline]\n@@ -35,7 +35,7 @@ pub(crate) struct SimdMutPtr<T, const LANES: usize>([*mut T; LANES]);\n \n impl<T, const LANES: usize> SimdMutPtr<T, LANES>\n where\n-    SimdUsize<LANES>: crate::LanesAtMost32,\n+    LaneCount<LANES>: SupportedLaneCount,\n     T: Sized,\n {\n     #[inline]"}, {"sha": "b19f694872aecbc9c9461e464fb97230b2371ccc", "filename": "crates/core_simd/src/vector/uint.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs?ref=82e3405efe5ffd2bc214d32b581d5cfc1157eb8d", "patch": "@@ -1,28 +1,33 @@\n #![allow(non_camel_case_types)]\n \n+use crate::{LaneCount, SupportedLaneCount};\n+\n /// Implements additional integer traits (Eq, Ord, Hash) on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n macro_rules! impl_unsigned_vector {\n     { $name:ident, $type:ty } => {\n         impl_vector! { $name, $type }\n         impl_integer_reductions! { $name, $type }\n \n-        impl<const LANES: usize> Eq for $name<LANES> where Self: crate::LanesAtMost32 {}\n+        impl<const LANES: usize> Eq for $name<LANES> where LaneCount<LANES>: SupportedLaneCount {}\n \n-        impl<const LANES: usize> Ord for $name<LANES> where Self: crate::LanesAtMost32 {\n+        impl<const LANES: usize> Ord for $name<LANES> where LaneCount<LANES>: SupportedLaneCount {\n             #[inline]\n             fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n                 // TODO use SIMD cmp\n-                self.to_array().cmp(other.as_ref())\n+                self.as_array().cmp(other.as_ref())\n             }\n         }\n \n-        impl<const LANES: usize> core::hash::Hash for $name<LANES> where Self: crate::LanesAtMost32 {\n+        impl<const LANES: usize> core::hash::Hash for $name<LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n             #[inline]\n             fn hash<H>(&self, state: &mut H)\n             where\n                 H: core::hash::Hasher\n             {\n-                self.as_slice().hash(state)\n+                self.as_array().hash(state)\n             }\n         }\n     }\n@@ -32,39 +37,39 @@ macro_rules! impl_unsigned_vector {\n #[repr(simd)]\n pub struct SimdUsize<const LANES: usize>([usize; LANES])\n where\n-    Self: crate::LanesAtMost32;\n+    LaneCount<LANES>: SupportedLaneCount;\n \n impl_unsigned_vector! { SimdUsize, usize }\n \n /// A SIMD vector of containing `LANES` `u16` values.\n #[repr(simd)]\n pub struct SimdU16<const LANES: usize>([u16; LANES])\n where\n-    Self: crate::LanesAtMost32;\n+    LaneCount<LANES>: SupportedLaneCount;\n \n impl_unsigned_vector! { SimdU16, u16 }\n \n /// A SIMD vector of containing `LANES` `u32` values.\n #[repr(simd)]\n pub struct SimdU32<const LANES: usize>([u32; LANES])\n where\n-    Self: crate::LanesAtMost32;\n+    LaneCount<LANES>: SupportedLaneCount;\n \n impl_unsigned_vector! { SimdU32, u32 }\n \n /// A SIMD vector of containing `LANES` `u64` values.\n #[repr(simd)]\n pub struct SimdU64<const LANES: usize>([u64; LANES])\n where\n-    Self: crate::LanesAtMost32;\n+    LaneCount<LANES>: SupportedLaneCount;\n \n impl_unsigned_vector! { SimdU64, u64 }\n \n /// A SIMD vector of containing `LANES` `u8` values.\n #[repr(simd)]\n pub struct SimdU8<const LANES: usize>([u8; LANES])\n where\n-    Self: crate::LanesAtMost32;\n+    LaneCount<LANES>: SupportedLaneCount;\n \n impl_unsigned_vector! { SimdU8, u8 }\n "}, {"sha": "58ea244adfcb097637604c53eb72f508ffaf2729", "filename": "crates/core_simd/src/vector/vector_impl.rs", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Fvector%2Fvector_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Fcore_simd%2Fsrc%2Fvector%2Fvector_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fvector_impl.rs?ref=82e3405efe5ffd2bc214d32b581d5cfc1157eb8d", "patch": "@@ -0,0 +1,257 @@\n+/// Implements common traits on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n+macro_rules! impl_vector {\n+    { $name:ident, $type:ty } => {\n+        impl<const LANES: usize> crate::vector::sealed::Sealed for $name<LANES>\n+        where\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n+        {}\n+\n+        impl<const LANES: usize> crate::vector::Vector for $name<LANES>\n+        where\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n+        {\n+            type Scalar = $type;\n+            const LANES: usize = LANES;\n+\n+            #[inline]\n+            fn splat(val: Self::Scalar) -> Self {\n+                Self::splat(val)\n+            }\n+        }\n+\n+        impl<const LANES: usize> $name<LANES>\n+        where\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n+        {\n+            /// Construct a SIMD vector by setting all lanes to the given value.\n+            pub const fn splat(value: $type) -> Self {\n+                Self([value; LANES])\n+            }\n+\n+            /// Returns an array reference containing the entire SIMD vector.\n+            pub const fn as_array(&self) -> &[$type; LANES] {\n+                &self.0\n+            }\n+\n+            /// Returns a mutable array reference containing the entire SIMD vector.\n+            pub fn as_mut_array(&mut self) -> &mut [$type; LANES] {\n+                &mut self.0\n+            }\n+\n+            /// Converts an array to a SIMD vector.\n+            pub const fn from_array(array: [$type; LANES]) -> Self {\n+                Self(array)\n+            }\n+\n+            /// Converts a SIMD vector to an array.\n+            pub const fn to_array(self) -> [$type; LANES] {\n+                self.0\n+            }\n+\n+            /// SIMD gather: construct a SIMD vector by reading from a slice, using potentially discontiguous indices.\n+            /// If an index is out of bounds, that lane instead selects the value from the \"or\" vector.\n+            /// ```\n+            /// # #![feature(portable_simd)]\n+            /// # use core_simd::*;\n+            /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n+            /// let idxs = SimdUsize::<4>::from_array([9, 3, 0, 5]);\n+            /// let alt = SimdI32::from_array([-5, -4, -3, -2]);\n+            ///\n+            /// let result = SimdI32::<4>::gather_or(&vec, idxs, alt); // Note the lane that is out-of-bounds.\n+            /// assert_eq!(result, SimdI32::from_array([-5, 13, 10, 15]));\n+            /// ```\n+            #[must_use]\n+            #[inline]\n+            pub fn gather_or(slice: &[$type], idxs: crate::SimdUsize<LANES>, or: Self) -> Self {\n+                Self::gather_select(slice, crate::MaskSize::splat(true), idxs, or)\n+            }\n+\n+            /// SIMD gather: construct a SIMD vector by reading from a slice, using potentially discontiguous indices.\n+            /// Out-of-bounds indices instead use the default value for that lane (0).\n+            /// ```\n+            /// # #![feature(portable_simd)]\n+            /// # use core_simd::*;\n+            /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n+            /// let idxs = SimdUsize::<4>::from_array([9, 3, 0, 5]);\n+            ///\n+            /// let result = SimdI32::<4>::gather_or_default(&vec, idxs); // Note the lane that is out-of-bounds.\n+            /// assert_eq!(result, SimdI32::from_array([0, 13, 10, 15]));\n+            /// ```\n+            #[must_use]\n+            #[inline]\n+            pub fn gather_or_default(slice: &[$type], idxs: crate::SimdUsize<LANES>) -> Self {\n+                Self::gather_or(slice, idxs, Self::splat(<$type>::default()))\n+            }\n+\n+            /// SIMD gather: construct a SIMD vector by reading from a slice, using potentially discontiguous indices.\n+            /// Out-of-bounds or masked indices instead select the value from the \"or\" vector.\n+            /// ```\n+            /// # #![feature(portable_simd)]\n+            /// # use core_simd::*;\n+            /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n+            /// let idxs = SimdUsize::<4>::from_array([9, 3, 0, 5]);\n+            /// let alt = SimdI32::from_array([-5, -4, -3, -2]);\n+            /// let mask = MaskSize::from_array([true, true, true, false]); // Note the mask of the last lane.\n+            ///\n+            /// let result = SimdI32::<4>::gather_select(&vec, mask, idxs, alt); // Note the lane that is out-of-bounds.\n+            /// assert_eq!(result, SimdI32::from_array([-5, 13, 10, -2]));\n+            /// ```\n+            #[must_use]\n+            #[inline]\n+            pub fn gather_select(\n+                slice: &[$type],\n+                mask: crate::MaskSize<LANES>,\n+                idxs: crate::SimdUsize<LANES>,\n+                or: Self,\n+            ) -> Self\n+            {\n+                let mask = (mask & idxs.lanes_lt(crate::SimdUsize::splat(slice.len()))).to_int();\n+                let base_ptr = crate::vector::ptr::SimdConstPtr::splat(slice.as_ptr());\n+                // Ferris forgive me, I have done pointer arithmetic here.\n+                let ptrs = base_ptr.wrapping_add(idxs);\n+                // SAFETY: The ptrs have been bounds-masked to prevent memory-unsafe reads insha'allah\n+                unsafe { crate::intrinsics::simd_gather(or, ptrs, mask) }\n+            }\n+\n+            /// SIMD scatter: write a SIMD vector's values into a slice, using potentially discontiguous indices.\n+            /// Out-of-bounds indices are not written.\n+            /// `scatter` writes \"in order\", so if an index receives two writes, only the last is guaranteed.\n+            /// ```\n+            /// # #![feature(portable_simd)]\n+            /// # use core_simd::*;\n+            /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n+            /// let idxs = SimdUsize::<4>::from_array([9, 3, 0, 0]);\n+            /// let vals = SimdI32::from_array([-27, 82, -41, 124]);\n+            ///\n+            /// vals.scatter(&mut vec, idxs); // index 0 receives two writes.\n+            /// assert_eq!(vec, vec![124, 11, 12, 82, 14, 15, 16, 17, 18]);\n+            /// ```\n+            #[inline]\n+            pub fn scatter(self, slice: &mut [$type], idxs: crate::SimdUsize<LANES>) {\n+                self.scatter_select(slice, crate::MaskSize::splat(true), idxs)\n+            }\n+\n+            /// SIMD scatter: write a SIMD vector's values into a slice, using potentially discontiguous indices.\n+            /// Out-of-bounds or masked indices are not written.\n+            /// `scatter_select` writes \"in order\", so if an index receives two writes, only the last is guaranteed.\n+            /// ```\n+            /// # #![feature(portable_simd)]\n+            /// # use core_simd::*;\n+            /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n+            /// let idxs = SimdUsize::<4>::from_array([9, 3, 0, 0]);\n+            /// let vals = SimdI32::from_array([-27, 82, -41, 124]);\n+            /// let mask = MaskSize::from_array([true, true, true, false]); // Note the mask of the last lane.\n+            ///\n+            /// vals.scatter_select(&mut vec, mask, idxs); // index 0's second write is masked, thus omitted.\n+            /// assert_eq!(vec, vec![-41, 11, 12, 82, 14, 15, 16, 17, 18]);\n+            /// ```\n+            #[inline]\n+            pub fn scatter_select(\n+                self,\n+                slice: &mut [$type],\n+                mask: crate::MaskSize<LANES>,\n+                idxs: crate::SimdUsize<LANES>,\n+            )\n+            {\n+                // We must construct our scatter mask before we derive a pointer!\n+                let mask = (mask & idxs.lanes_lt(crate::SimdUsize::splat(slice.len()))).to_int();\n+                // SAFETY: This block works with *mut T derived from &mut 'a [T],\n+                // which means it is delicate in Rust's borrowing model, circa 2021:\n+                // &mut 'a [T] asserts uniqueness, so deriving &'a [T] invalidates live *mut Ts!\n+                // Even though this block is largely safe methods, it must be almost exactly this way\n+                // to prevent invalidating the raw ptrs while they're live.\n+                // Thus, entering this block requires all values to use being already ready:\n+                // 0. idxs we want to write to, which are used to construct the mask.\n+                // 1. mask, which depends on an initial &'a [T] and the idxs.\n+                // 2. actual values to scatter (self).\n+                // 3. &mut [T] which will become our base ptr.\n+                unsafe {\n+                    // Now Entering \u2622\ufe0f *mut T Zone\n+                    let base_ptr = crate::vector::ptr::SimdMutPtr::splat(slice.as_mut_ptr());\n+                    // Ferris forgive me, I have done pointer arithmetic here.\n+                    let ptrs = base_ptr.wrapping_add(idxs);\n+                    // The ptrs have been bounds-masked to prevent memory-unsafe writes insha'allah\n+                    crate::intrinsics::simd_scatter(self, ptrs, mask)\n+                    // Cleared \u2622\ufe0f *mut T Zone\n+                }\n+            }\n+        }\n+\n+        impl<const LANES: usize> Copy for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {}\n+\n+        impl<const LANES: usize> Clone for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n+            #[inline]\n+            fn clone(&self) -> Self {\n+                *self\n+            }\n+        }\n+\n+        impl<const LANES: usize> Default for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n+            #[inline]\n+            fn default() -> Self {\n+                Self::splat(<$type>::default())\n+            }\n+        }\n+\n+        impl<const LANES: usize> PartialEq for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n+            #[inline]\n+            fn eq(&self, other: &Self) -> bool {\n+                // TODO use SIMD equality\n+                self.to_array() == other.to_array()\n+            }\n+        }\n+\n+        impl<const LANES: usize> PartialOrd for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n+            #[inline]\n+            fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n+                // TODO use SIMD equalitya\n+                self.to_array().partial_cmp(other.as_ref())\n+            }\n+        }\n+\n+        // array references\n+        impl<const LANES: usize> AsRef<[$type; LANES]> for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n+            #[inline]\n+            fn as_ref(&self) -> &[$type; LANES] {\n+                &self.0\n+            }\n+        }\n+\n+        impl<const LANES: usize> AsMut<[$type; LANES]> for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n+            #[inline]\n+            fn as_mut(&mut self) -> &mut [$type; LANES] {\n+                &mut self.0\n+            }\n+        }\n+\n+        // slice references\n+        impl<const LANES: usize> AsRef<[$type]> for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n+            #[inline]\n+            fn as_ref(&self) -> &[$type] {\n+                &self.0\n+            }\n+        }\n+\n+        impl<const LANES: usize> AsMut<[$type]> for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n+            #[inline]\n+            fn as_mut(&mut self) -> &mut [$type] {\n+                &mut self.0\n+            }\n+        }\n+\n+        // vector/array conversion\n+        impl<const LANES: usize> From<[$type; LANES]> for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n+            fn from(array: [$type; LANES]) -> Self {\n+                Self(array)\n+            }\n+        }\n+\n+        impl <const LANES: usize> From<$name<LANES>> for [$type; LANES] where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n+            fn from(vector: $name<LANES>) -> Self {\n+                vector.to_array()\n+            }\n+        }\n+\n+        impl_shuffle_2pow_lanes!{ $name }\n+    }\n+}"}, {"sha": "5c6478876f30be88797794d6c571fceb62193a1a", "filename": "crates/test_helpers/src/lib.rs", "status": "modified", "additions": 2, "deletions": 34, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Ftest_helpers%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82e3405efe5ffd2bc214d32b581d5cfc1157eb8d/crates%2Ftest_helpers%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_helpers%2Fsrc%2Flib.rs?ref=82e3405efe5ffd2bc214d32b581d5cfc1157eb8d", "patch": "@@ -335,23 +335,7 @@ macro_rules! test_lanes {\n \n                 fn implementation<const $lanes: usize>()\n                 where\n-                    core_simd::SimdU8<$lanes>: core_simd::LanesAtMost32,\n-                    core_simd::SimdU16<$lanes>: core_simd::LanesAtMost32,\n-                    core_simd::SimdU32<$lanes>: core_simd::LanesAtMost32,\n-                    core_simd::SimdU64<$lanes>: core_simd::LanesAtMost32,\n-                    core_simd::SimdUsize<$lanes>: core_simd::LanesAtMost32,\n-                    core_simd::SimdI8<$lanes>: core_simd::LanesAtMost32,\n-                    core_simd::SimdI16<$lanes>: core_simd::LanesAtMost32,\n-                    core_simd::SimdI32<$lanes>: core_simd::LanesAtMost32,\n-                    core_simd::SimdI64<$lanes>: core_simd::LanesAtMost32,\n-                    core_simd::SimdIsize<$lanes>: core_simd::LanesAtMost32,\n-                    core_simd::SimdF32<$lanes>: core_simd::LanesAtMost32,\n-                    core_simd::SimdF64<$lanes>: core_simd::LanesAtMost32,\n-                    core_simd::Mask8<$lanes>: core_simd::Mask,\n-                    core_simd::Mask16<$lanes>: core_simd::Mask,\n-                    core_simd::Mask32<$lanes>: core_simd::Mask,\n-                    core_simd::Mask64<$lanes>: core_simd::Mask,\n-                    core_simd::MaskSize<$lanes>: core_simd::Mask,\n+                    core_simd::LaneCount<$lanes>: core_simd::SupportedLaneCount,\n                 $body\n \n                 #[cfg(target_arch = \"wasm32\")]\n@@ -409,23 +393,7 @@ macro_rules! test_lanes_panic {\n \n                 fn implementation<const $lanes: usize>()\n                 where\n-                    core_simd::SimdU8<$lanes>: core_simd::LanesAtMost32,\n-                    core_simd::SimdU16<$lanes>: core_simd::LanesAtMost32,\n-                    core_simd::SimdU32<$lanes>: core_simd::LanesAtMost32,\n-                    core_simd::SimdU64<$lanes>: core_simd::LanesAtMost32,\n-                    core_simd::SimdUsize<$lanes>: core_simd::LanesAtMost32,\n-                    core_simd::SimdI8<$lanes>: core_simd::LanesAtMost32,\n-                    core_simd::SimdI16<$lanes>: core_simd::LanesAtMost32,\n-                    core_simd::SimdI32<$lanes>: core_simd::LanesAtMost32,\n-                    core_simd::SimdI64<$lanes>: core_simd::LanesAtMost32,\n-                    core_simd::SimdIsize<$lanes>: core_simd::LanesAtMost32,\n-                    core_simd::SimdF32<$lanes>: core_simd::LanesAtMost32,\n-                    core_simd::SimdF64<$lanes>: core_simd::LanesAtMost32,\n-                    core_simd::Mask8<$lanes>: core_simd::Mask,\n-                    core_simd::Mask16<$lanes>: core_simd::Mask,\n-                    core_simd::Mask32<$lanes>: core_simd::Mask,\n-                    core_simd::Mask64<$lanes>: core_simd::Mask,\n-                    core_simd::MaskSize<$lanes>: core_simd::Mask,\n+                    core_simd::LaneCount<$lanes>: core_simd::SupportedLaneCount,\n                 $body\n \n                 #[test]"}]}