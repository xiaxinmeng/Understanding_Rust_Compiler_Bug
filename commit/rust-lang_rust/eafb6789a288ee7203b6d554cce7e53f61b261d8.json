{"sha": "eafb6789a288ee7203b6d554cce7e53f61b261d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhZmI2Nzg5YTI4OGVlNzIwM2I2ZDU1NGNjZTdlNTNmNjFiMjYxZDg=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-18T20:05:58Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-18T20:05:58Z"}, "message": "Stop creating function pairs for static functions\n\nThese are now called directly. When taking their value, a null pointer is added\nto create a pair.", "tree": {"sha": "eae0aa94a6e98b6f4194274ecc3f89b72e01ffa7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eae0aa94a6e98b6f4194274ecc3f89b72e01ffa7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eafb6789a288ee7203b6d554cce7e53f61b261d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eafb6789a288ee7203b6d554cce7e53f61b261d8", "html_url": "https://github.com/rust-lang/rust/commit/eafb6789a288ee7203b6d554cce7e53f61b261d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eafb6789a288ee7203b6d554cce7e53f61b261d8/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8640e67e3ff97f64ab5afdf6c788d335e491696e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8640e67e3ff97f64ab5afdf6c788d335e491696e", "html_url": "https://github.com/rust-lang/rust/commit/8640e67e3ff97f64ab5afdf6c788d335e491696e"}], "stats": {"total": 129, "additions": 43, "deletions": 86}, "files": [{"sha": "0d89296594bbbd582b943e218d841517c3086d79", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 40, "deletions": 82, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/eafb6789a288ee7203b6d554cce7e53f61b261d8/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eafb6789a288ee7203b6d554cce7e53f61b261d8/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=eafb6789a288ee7203b6d554cce7e53f61b261d8", "patch": "@@ -244,10 +244,9 @@ fn type_of_ty_param_kinds_and_ty(lcx: @local_ctxt, sp: span,\n     let cx = lcx.ccx;\n     let t = tpt.ty;\n     alt ty::struct(cx.tcx, t) {\n-      ty::ty_fn(_, _, _, _, _) {\n+      ty::ty_fn(_, _, _, _, _) | ty::ty_native_fn(_, _, _) {\n         check returns_non_ty_var(cx, t);\n-        let llfnty = type_of_fn_from_ty(cx, sp, t, std::vec::len(tpt.kinds));\n-        ret T_fn_pair(*cx, llfnty);\n+        ret type_of_fn_from_ty(cx, sp, t, std::vec::len(tpt.kinds));\n       }\n       _ {\n         // fall through\n@@ -328,10 +327,9 @@ fn decl_fastcall_fn(llmod: ModuleRef, name: str, llty: TypeRef) -> ValueRef {\n // not valid to simply declare a function as internal.\n fn decl_internal_fastcall_fn(llmod: ModuleRef, name: str, llty: TypeRef) ->\n    ValueRef {\n-    let llfn = decl_fn(llmod, name, lib::llvm::LLVMFastCallConv, llty);\n+    let llfn = decl_fastcall_fn(llmod, name, llty);\n     llvm::LLVMSetLinkage(llfn,\n                          lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n-    let _: () = str::as_buf(\"rust\", {|buf| llvm::LLVMSetGC(llfn, buf) });\n     ret llfn;\n }\n \n@@ -1418,12 +1416,8 @@ fn trans_res_drop(cx: @block_ctxt, rs: ValueRef, did: ast::def_id,\n     let val = GEP_tup_like(cx, tup_ty, rs, [0, 1]);\n     cx = val.bcx;\n     // Find and call the actual destructor.\n-    let dtor_pair = trans_common::get_res_dtor(ccx, cx.sp, did, inner_t);\n-    let dtor_addr =\n-        Load(cx, GEP(cx, dtor_pair, [C_int(0), C_int(abi::fn_field_code)]));\n-    let dtor_env =\n-        Load(cx, GEP(cx, dtor_pair, [C_int(0), C_int(abi::fn_field_box)]));\n-    let args = [cx.fcx.llretptr, cx.fcx.lltaskptr, dtor_env];\n+    let dtor_addr = trans_common::get_res_dtor(ccx, cx.sp, did, inner_t);\n+    let args = [cx.fcx.llretptr, cx.fcx.lltaskptr, null_env_ptr(cx)];\n     for tp: ty::t in tps {\n         let ti: option::t<@tydesc_info> = none;\n         let td = get_tydesc(cx, tp, false, tps_normal, ti).result;\n@@ -2842,6 +2836,10 @@ type lval_maybe_callee = {bcx: @block_ctxt,\n                           env: callee_env,\n                           generic: option::t<generic_info>};\n \n+fn null_env_ptr(bcx: @block_ctxt) -> ValueRef {\n+    C_null(T_opaque_closure_ptr(*bcx_ccx(bcx)))\n+}\n+\n fn lval_mem(bcx: @block_ctxt, val: ValueRef) -> lval_result {\n     ret {bcx: bcx, val: val, is_mem: true};\n }\n@@ -2866,8 +2864,8 @@ fn lval_static_fn(bcx: @block_ctxt, tpt: ty::ty_param_kinds_and_ty,\n                   fn_id: ast::def_id, id: ast::node_id) -> lval_maybe_callee {\n     let val = if fn_id.crate == ast::local_crate {\n         // Internal reference.\n-        assert (bcx_ccx(bcx).fn_pairs.contains_key(fn_id.node));\n-        bcx_ccx(bcx).fn_pairs.get(fn_id.node)\n+        assert (bcx_ccx(bcx).item_ids.contains_key(fn_id.node));\n+        bcx_ccx(bcx).item_ids.get(fn_id.node)\n     } else {\n         // External reference.\n         trans_external_path(bcx, fn_id, tpt)\n@@ -2886,7 +2884,7 @@ fn lval_static_fn(bcx: @block_ctxt, tpt: ty::ty_param_kinds_and_ty,\n         }\n         gen = some({item_type: tpt.ty, static_tis: tis, tydescs: tydescs});\n     }\n-    ret {bcx: bcx, val: val, is_mem: true, env: is_closure, generic: gen};\n+    ret {bcx: bcx, val: val, is_mem: true, env: null_env, generic: gen};\n }\n \n fn lookup_discriminant(lcx: @local_ctxt, vid: ast::def_id) -> ValueRef {\n@@ -3176,7 +3174,7 @@ fn maybe_add_env(bcx: @block_ctxt, c: lval_maybe_callee)\n         (c.is_mem, c.val)\n     } else {\n         let env = alt c.env {\n-          null_env. { C_null(T_opaque_closure_ptr(*bcx_ccx(bcx))) }\n+          null_env. { null_env_ptr(bcx) }\n           some_env(e) { e }\n         };\n         let llfnty = llvm::LLVMGetElementType(val_ty(c.val));\n@@ -3353,8 +3351,7 @@ fn trans_bind_thunk(cx: @local_ctxt, sp: span, incoming_fty: ty::t,\n     // out the pointer to the target function from the environment. The\n     // target function lives in the first binding spot.\n     let (lltargetfn, lltargetenv, starting_idx) = alt target_fn {\n-      some(fptr) {\n-        (fptr, C_null(T_opaque_closure_ptr(*bcx_ccx(bcx))), 0)\n+      some(fptr) { (fptr, null_env_ptr(bcx), 0)\n       }\n       none. {\n         // Silly check\n@@ -3747,7 +3744,7 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n     let faddr = f_res.val;\n     let llenv;\n     alt f_res.env {\n-      null_env. { llenv = C_null(T_opaque_closure_ptr(*bcx_ccx(cx))); }\n+      null_env. { llenv = null_env_ptr(cx); }\n       some_env(e) { llenv = e; }\n       is_closure. {\n         // It's a closure. Have to fetch the elements\n@@ -4054,7 +4051,8 @@ fn trans_expr_out(cx: @block_ctxt, e: @ast::expr, output: out_method) ->\n             alt fn_res {\n               some(fn_pair) { fn_pair }\n               none. {\n-                {fn_pair: create_fn_pair(ccx, s, llfnty, llfn, false),\n+                {fn_pair: create_real_fn_pair(cx, llfnty, llfn,\n+                                              null_env_ptr(cx)),\n                  bcx: cx}\n               }\n             };\n@@ -5488,17 +5486,17 @@ fn get_pair_fn_ty(llpairty: TypeRef) -> TypeRef {\n     ret struct_elt(llpairty, 0u);\n }\n \n-fn decl_fn_and_pair(ccx: @crate_ctxt, sp: span, path: [str], flav: str,\n-                    ty_params: [ast::ty_param], node_id: ast::node_id) {\n+fn register_fn(ccx: @crate_ctxt, sp: span, path: [str], flav: str,\n+               ty_params: [ast::ty_param], node_id: ast::node_id) {\n     // FIXME: pull this out\n     let t = node_id_type(ccx, node_id);\n     check returns_non_ty_var(ccx, t);\n-    decl_fn_and_pair_full(ccx, sp, path, flav, ty_params, node_id, t);\n+    register_fn_full(ccx, sp, path, flav, ty_params, node_id, t);\n }\n \n-fn decl_fn_and_pair_full(ccx: @crate_ctxt, sp: span, path: [str], _flav: str,\n-                         ty_params: [ast::ty_param], node_id: ast::node_id,\n-                         node_type: ty::t)\n+fn register_fn_full(ccx: @crate_ctxt, sp: span, path: [str], _flav: str,\n+                    ty_params: [ast::ty_param], node_id: ast::node_id,\n+                    node_type: ty::t)\n     : returns_non_ty_var(ccx, node_type) {\n     let path = path;\n     let llfty =\n@@ -5510,14 +5508,12 @@ fn decl_fn_and_pair_full(ccx: @crate_ctxt, sp: span, path: [str], _flav: str,\n                            ast_util::ret_by_ref(rs), inputs, output,\n                            vec::len(ty_params));\n       }\n-      _ { ccx.sess.bug(\"decl_fn_and_pair(): fn item doesn't have fn type!\"); }\n+      _ { ccx.sess.bug(\"register_fn(): fn item doesn't have fn type!\"); }\n     }\n-    let s: str = mangle_internal_name_by_path(ccx, path);\n-    let llfn: ValueRef = decl_internal_fastcall_fn(ccx.llmod, s, llfty);\n-    // Declare the global constant pair that points to it.\n-\n     let ps: str = mangle_exported_name(ccx, path, node_type);\n-    register_fn_pair(ccx, ps, llfty, llfn, node_id);\n+    let llfn: ValueRef = decl_fastcall_fn(ccx.llmod, ps, llfty);\n+    ccx.item_ids.insert(node_id, llfn);\n+    ccx.item_symbols.insert(node_id, ps);\n \n     let is_main: bool = is_main_name(path) && !ccx.sess.get_opts().library;\n     if is_main { create_main_wrapper(ccx, sp, llfn, node_type); }\n@@ -5580,28 +5576,6 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n     }\n }\n \n-\n-// Create a closure: a pair containing (1) a ValueRef, pointing to where the\n-// fn's definition is in the executable we're creating, and (2) a pointer to\n-// space for the function's environment.\n-fn create_fn_pair(cx: @crate_ctxt, ps: str, llfnty: TypeRef, llfn: ValueRef,\n-                  external: bool) -> ValueRef {\n-    let gvar =\n-        str::as_buf(ps,\n-                    {|buf|\n-                        llvm::LLVMAddGlobal(cx.llmod, T_fn_pair(*cx, llfnty),\n-                                            buf)\n-                    });\n-    let pair = C_struct([llfn, C_null(T_opaque_closure_ptr(*cx))]);\n-    llvm::LLVMSetInitializer(gvar, pair);\n-    llvm::LLVMSetGlobalConstant(gvar, True);\n-    if !external {\n-        llvm::LLVMSetLinkage(gvar,\n-                             lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n-    }\n-    ret gvar;\n-}\n-\n // Create a /real/ closure: this is like create_fn_pair, but creates a\n // a fn value on the stack with a specified environment (which need not be\n // on the stack).\n@@ -5619,26 +5593,14 @@ fn create_real_fn_pair(cx: @block_ctxt, llfnty: TypeRef, llfn: ValueRef,\n     ret pair;\n }\n \n-fn register_fn_pair(cx: @crate_ctxt, ps: str, llfnty: TypeRef, llfn: ValueRef,\n-                    id: ast::node_id) {\n-    // FIXME: We should also hide the unexported pairs in crates.\n-\n-    let gvar =\n-        create_fn_pair(cx, ps, llfnty, llfn, cx.sess.get_opts().library);\n-    cx.item_ids.insert(id, llfn);\n-    cx.item_symbols.insert(id, ps);\n-    cx.fn_pairs.insert(id, gvar);\n-}\n-\n-\n // Returns the number of type parameters that the given native function has.\n fn native_fn_ty_param_count(cx: @crate_ctxt, id: ast::node_id) -> uint {\n     let count;\n     let native_item =\n         alt cx.ast_map.find(id) { some(ast_map::node_native_item(i)) { i } };\n     alt native_item.node {\n       ast::native_item_ty. {\n-        cx.sess.bug(\"decl_native_fn_and_pair(): native fn isn't \\\n+        cx.sess.bug(\"register_native_fn(): native fn isn't \\\n                         actually a fn\");\n       }\n       ast::native_item_fn(_, _, tps) {\n@@ -5659,23 +5621,20 @@ fn native_fn_wrapper_type(cx: @crate_ctxt, sp: span, ty_param_count: uint,\n     }\n }\n \n-fn decl_native_fn_and_pair(ccx: @crate_ctxt, sp: span, path: [str], name: str,\n+fn register_native_fn(ccx: @crate_ctxt, sp: span, path: [str], name: str,\n                            id: ast::node_id) {\n     let path = path;\n     let num_ty_param = native_fn_ty_param_count(ccx, id);\n     // Declare the wrapper.\n \n     let t = node_id_type(ccx, id);\n     let wrapper_type = native_fn_wrapper_type(ccx, sp, num_ty_param, t);\n-    let s: str = mangle_internal_name_by_path(ccx, path);\n-    let wrapper_fn: ValueRef =\n-        decl_internal_fastcall_fn(ccx.llmod, s, wrapper_type);\n-    // Declare the global constant pair that points to it.\n-\n     let ps: str = mangle_exported_name(ccx, path, node_id_type(ccx, id));\n-    register_fn_pair(ccx, ps, wrapper_type, wrapper_fn, id);\n-    // Build the wrapper.\n+    let wrapper_fn = decl_fastcall_fn(ccx.llmod, ps, wrapper_type);\n+    ccx.item_ids.insert(id, wrapper_fn);\n+    ccx.item_symbols.insert(id, ps);\n \n+    // Build the wrapper.\n     let fcx = new_fn_ctxt(new_local_ctxt(ccx), sp, wrapper_fn);\n     let bcx = new_top_block_ctxt(fcx);\n     let lltop = bcx.llbb;\n@@ -5858,7 +5817,7 @@ fn collect_native_item(ccx: @crate_ctxt, i: @ast::native_item, pt: [str],\n     alt i.node {\n       ast::native_item_fn(_, _, _) {\n         if !ccx.obj_methods.contains_key(i.id) {\n-            decl_native_fn_and_pair(ccx, i.span, pt, i.ident, i.id);\n+            register_native_fn(ccx, i.span, pt, i.ident, i.id);\n         }\n       }\n       _ { }\n@@ -5892,25 +5851,25 @@ fn collect_item_2(ccx: @crate_ctxt, i: @ast::item, pt: [str], v: vt<[str]>) {\n     alt i.node {\n       ast::item_fn(f, tps) {\n         if !ccx.obj_methods.contains_key(i.id) {\n-            decl_fn_and_pair(ccx, i.span, new_pt, \"fn\", tps, i.id);\n+            register_fn(ccx, i.span, new_pt, \"fn\", tps, i.id);\n         }\n       }\n       ast::item_obj(ob, tps, ctor_id) {\n-        decl_fn_and_pair(ccx, i.span, new_pt, \"obj_ctor\", tps, ctor_id);\n+        register_fn(ccx, i.span, new_pt, \"obj_ctor\", tps, ctor_id);\n         for m: @ast::method in ob.methods {\n             ccx.obj_methods.insert(m.node.id, ());\n         }\n       }\n       ast::item_res(_, dtor_id, tps, ctor_id) {\n-        decl_fn_and_pair(ccx, i.span, new_pt, \"res_ctor\", tps, ctor_id);\n+        register_fn(ccx, i.span, new_pt, \"res_ctor\", tps, ctor_id);\n         // Note that the destructor is associated with the item's id, not\n         // the dtor_id. This is a bit counter-intuitive, but simplifies\n         // ty_res, which would have to carry around two def_ids otherwise\n         // -- one to identify the type, and one to find the dtor symbol.\n         let t = node_id_type(ccx, dtor_id);\n         // FIXME: how to get rid of this check?\n         check returns_non_ty_var(ccx, t);\n-        decl_fn_and_pair_full(ccx, i.span, new_pt, \"res_dtor\", tps, i.id, t);\n+        register_fn_full(ccx, i.span, new_pt, \"res_dtor\", tps, i.id, t);\n       }\n       _ { }\n     }\n@@ -5935,8 +5894,8 @@ fn collect_tag_ctor(ccx: @crate_ctxt, i: @ast::item, pt: [str],\n       ast::item_tag(variants, tps) {\n         for variant: ast::variant in variants {\n             if std::vec::len(variant.node.args) != 0u {\n-                decl_fn_and_pair(ccx, i.span, new_pt + [variant.node.name],\n-                                 \"tag\", tps, variant.node.id);\n+                register_fn(ccx, i.span, new_pt + [variant.node.name],\n+                            \"tag\", tps, variant.node.id);\n             }\n         }\n       }\n@@ -6209,7 +6168,6 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           tag_sizes: tag_sizes,\n           discrims: new_int_hash::<ValueRef>(),\n           discrim_symbols: new_int_hash::<str>(),\n-          fn_pairs: new_int_hash::<ValueRef>(),\n           consts: new_int_hash::<ValueRef>(),\n           obj_methods: new_int_hash::<()>(),\n           tydescs: tydescs,"}, {"sha": "5304f6d97de2175478e4834b8e6682c22dd54f25", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eafb6789a288ee7203b6d554cce7e53f61b261d8/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eafb6789a288ee7203b6d554cce7e53f61b261d8/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=eafb6789a288ee7203b6d554cce7e53f61b261d8", "patch": "@@ -105,7 +105,6 @@ type crate_ctxt =\n      tag_sizes: hashmap<ty::t, uint>,\n      discrims: hashmap<ast::node_id, ValueRef>,\n      discrim_symbols: hashmap<ast::node_id, str>,\n-     fn_pairs: hashmap<ast::node_id, ValueRef>,\n      consts: hashmap<ast::node_id, ValueRef>,\n      obj_methods: hashmap<ast::node_id, ()>,\n      tydescs: hashmap<ty::t, @tydesc_info>,\n@@ -328,7 +327,7 @@ fn revoke_clean(cx: @block_ctxt, val: ValueRef, t: ty::t) -> @block_ctxt {\n fn get_res_dtor(ccx: @crate_ctxt, sp: span, did: ast::def_id, inner_t: ty::t)\n    -> ValueRef {\n     if did.crate == ast::local_crate {\n-        alt ccx.fn_pairs.find(did.node) {\n+        alt ccx.item_ids.find(did.node) {\n           some(x) { ret x; }\n           _ { ccx.tcx.sess.bug(\"get_res_dtor: can't find resource dtor!\"); }\n         }\n@@ -343,8 +342,7 @@ fn get_res_dtor(ccx: @crate_ctxt, sp: span, did: ast::def_id, inner_t: ty::t)\n                          nil_res, params);\n     ret trans::get_extern_const(ccx.externs, ccx.llmod,\n                                 csearch::get_symbol(ccx.sess.get_cstore(),\n-                                                    did),\n-                                T_fn_pair(*ccx, f_t));\n+                                                    did), f_t);\n }\n \n tag block_kind {"}, {"sha": "8393aa3ad4c1f6bf763b34319573108769ca447d", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eafb6789a288ee7203b6d554cce7e53f61b261d8/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eafb6789a288ee7203b6d554cce7e53f61b261d8/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=eafb6789a288ee7203b6d554cce7e53f61b261d8", "patch": "@@ -1586,6 +1586,7 @@ fn ty_fn_args(cx: ctxt, fty: t) -> [arg] {\n fn ty_fn_proto(cx: ctxt, fty: t) -> ast::proto {\n     alt struct(cx, fty) {\n       ty::ty_fn(p, _, _, _, _) { ret p; }\n+      ty::ty_native_fn(_, _, _) { ret ast::proto_fn; }\n       _ { cx.sess.bug(\"ty_fn_proto() called on non-fn type\"); }\n     }\n }"}]}