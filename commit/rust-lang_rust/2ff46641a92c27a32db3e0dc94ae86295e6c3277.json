{"sha": "2ff46641a92c27a32db3e0dc94ae86295e6c3277", "node_id": "C_kwDOAAsO6NoAKDJmZjQ2NjQxYTkyYzI3YTMyZGIzZTBkYzk0YWU4NjI5NWU2YzMyNzc", "commit": {"author": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-09-26T14:42:12Z"}, "committer": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2023-01-30T17:11:35Z"}, "message": "incremental: migrate diagnostics\n\nMigrate the `rustc_incremental` crate's diagnostics to translatable\ndiagnostic structs.\n\nSigned-off-by: David Wood <david.wood@huawei.com>", "tree": {"sha": "a195b20cc8254c906535717f3f37a6fd074cedbe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a195b20cc8254c906535717f3f37a6fd074cedbe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ff46641a92c27a32db3e0dc94ae86295e6c3277", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ff46641a92c27a32db3e0dc94ae86295e6c3277", "html_url": "https://github.com/rust-lang/rust/commit/2ff46641a92c27a32db3e0dc94ae86295e6c3277", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ff46641a92c27a32db3e0dc94ae86295e6c3277/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2575b1abc97e1352b307163ac7de2142aded22a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/2575b1abc97e1352b307163ac7de2142aded22a5", "html_url": "https://github.com/rust-lang/rust/commit/2575b1abc97e1352b307163ac7de2142aded22a5"}], "stats": {"total": 870, "additions": 617, "deletions": 253}, "files": [{"sha": "4852ee0d9595cce228848c111ade539948223938", "filename": "compiler/rustc_error_messages/locales/en-US/incremental.ftl", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/2ff46641a92c27a32db3e0dc94ae86295e6c3277/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fincremental.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/2ff46641a92c27a32db3e0dc94ae86295e6c3277/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fincremental.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fincremental.ftl?ref=2ff46641a92c27a32db3e0dc94ae86295e6c3277", "patch": "@@ -0,0 +1,118 @@\n+incremental_unrecognized_depnode = unrecognized `DepNode` variant: {$name}\n+\n+incremental_missing_depnode = missing `DepNode` variant\n+\n+incremental_missing_if_this_changed = no `#[rustc_if_this_changed]` annotation detected\n+\n+incremental_no_path = no path from `{$source}` to `{$target}`\n+\n+incremental_ok = OK\n+\n+incremental_unknown_reuse_kind = unknown cgu-reuse-kind `{$kind}` specified\n+\n+incremental_missing_query_depgraph =\n+    found CGU-reuse attribute but `-Zquery-dep-graph` was not specified\n+\n+incremental_malformed_cgu_name =\n+    found malformed codegen unit name `{$user_path}`. codegen units names must always start with the name of the crate (`{$crate_name}` in this case).\n+\n+incremental_no_module_named =\n+    no module named `{$user_path}` (mangled: {$cgu_name}). available modules: {$cgu_names}\n+\n+incremental_field_associated_value_expected = associated value expected for `{$name}`\n+\n+incremental_no_field = no field `{$name}`\n+\n+incremental_assertion_auto =\n+    `except` specified DepNodes that can not be affected for \\\"{$name}\\\": \\\"{$e}\\\"\n+\n+incremental_undefined_clean_dirty_assertions_item =\n+    clean/dirty auto-assertions not yet defined for Node::Item.node={$kind}\n+\n+incremental_undefined_clean_dirty_assertions =\n+    clean/dirty auto-assertions not yet defined for {$kind}\n+\n+incremental_repeated_depnode_label = dep-node label `{$label}` is repeated\n+\n+incremental_unrecognized_depnode_label = dep-node label `{$label}` not recognized\n+\n+incremental_not_dirty = `{$dep_node_str}` should be dirty but is not\n+\n+incremental_not_clean = `{$dep_node_str}` should be clean but is not\n+\n+incremental_not_loaded = `{$dep_node_str}` should have been loaded from disk but it was not\n+\n+incremental_unknown_item = unknown item `{$name}`\n+\n+incremental_no_cfg = no cfg attribute\n+\n+incremental_associated_value_expected_for = associated value expected for `{$ident}`\n+\n+incremental_associated_value_expected = expected an associated value\n+\n+incremental_unchecked_clean = found unchecked `#[rustc_clean]` attribute\n+\n+incremental_delete_old = unable to delete old {$name} at `{$path}`: {$err}\n+\n+incremental_create_new = failed to create {$name} at `{$path}`: {$err}\n+\n+incremental_write_new = failed to write {$name} to `{$path}`: {$err}\n+\n+incremental_canonicalize_path = incremental compilation: error canonicalizing path `{$path}`: {$err}\n+\n+incremental_create_incr_comp_dir =\n+    could not create incremental compilation {$tag} directory `{$path}`: {$err}\n+\n+incremental_create_lock =\n+    incremental compilation: could not create session directory lock file: {$lock_err}\n+incremental_lock_unsupported =\n+    the filesystem for the incremental path at {$session_dir} does not appear to support locking, consider changing the incremental path to a filesystem that supports locking or disable incremental compilation\n+incremental_cargo_help_1 =\n+    incremental compilation can be disabled by setting the environment variable CARGO_INCREMENTAL=0 (see https://doc.rust-lang.org/cargo/reference/profiles.html#incremental)\n+incremental_cargo_help_2 =\n+    the entire build directory can be changed to a different filesystem by setting the environment variable CARGO_TARGET_DIR to a different path (see https://doc.rust-lang.org/cargo/reference/config.html#buildtarget-dir)\n+\n+incremental_delete_lock =\n+    error deleting lock file for incremental compilation session directory `{$path}`: {$err}\n+\n+incremental_hard_link_failed =\n+    hard linking files in the incremental compilation cache failed. copying files instead. consider moving the cache directory to a file system which supports hard linking in session dir `{$path}`\n+\n+incremental_delete_partial = failed to delete partly initialized session dir `{$path}`: {$err}\n+\n+incremental_delete_full = error deleting incremental compilation session directory `{$path}`: {$err}\n+\n+incremental_finalize = error finalizing incremental compilation session directory `{$path}`: {$err}\n+\n+incremental_invalid_gc_failed =\n+    failed to garbage collect invalid incremental compilation session directory `{$path}`: {$err}\n+\n+incremental_finalized_gc_failed =\n+    failed to garbage collect finalized incremental compilation session directory `{$path}`: {$err}\n+\n+incremental_session_gc_failed =\n+    failed to garbage collect incremental compilation session directory `{$path}`: {$err}\n+\n+incremental_assert_not_loaded =\n+    we asserted that the incremental cache should not be loaded, but it was loaded\n+\n+incremental_assert_loaded =\n+    we asserted that an existing incremental cache directory should be successfully loaded, but it was not\n+\n+incremental_delete_incompatible =\n+    failed to delete invalidated or incompatible incremental compilation session directory contents `{$path}`: {$err}\n+\n+incremental_load_dep_graph = could not load dep-graph from `{$path}`: {$err}\n+\n+incremental_decode_incr_cache = could not decode incremental cache: {$err}\n+\n+incremental_write_dep_graph = failed to write dependency graph to `{$path}`: {$err}\n+\n+incremental_move_dep_graph = failed to move dependency graph from `{$from}` to `{$to}`: {$err}\n+\n+incremental_create_dep_graph = failed to create dependency graph at `{$path}`: {$err}\n+\n+incremental_copy_workproduct_to_cache =\n+    error copying object file `{$from}` to incremental directory as `{$to}`: {$err}\n+\n+incremental_delete_workproduct = file-system error deleting outdated file `{$path}`: {$err}"}, {"sha": "1882d4b698e61c481462ce5be8b8ed09d5f13411", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ff46641a92c27a32db3e0dc94ae86295e6c3277/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ff46641a92c27a32db3e0dc94ae86295e6c3277/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=2ff46641a92c27a32db3e0dc94ae86295e6c3277", "patch": "@@ -52,6 +52,7 @@ fluent_messages! {\n     expand => \"../locales/en-US/expand.ftl\",\n     hir_analysis => \"../locales/en-US/hir_analysis.ftl\",\n     hir_typeck => \"../locales/en-US/hir_typeck.ftl\",\n+    incremental => \"../locales/en-US/incremental.ftl\",\n     infer => \"../locales/en-US/infer.ftl\",\n     interface => \"../locales/en-US/interface.ftl\",\n     lint => \"../locales/en-US/lint.ftl\","}, {"sha": "22bd12f2e63616cb48508fc621d6e417ecffb0ee", "filename": "compiler/rustc_incremental/src/assert_dep_graph.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2ff46641a92c27a32db3e0dc94ae86295e6c3277/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ff46641a92c27a32db3e0dc94ae86295e6c3277/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs?ref=2ff46641a92c27a32db3e0dc94ae86295e6c3277", "patch": "@@ -33,6 +33,7 @@\n //! fn baz() { foo(); }\n //! ```\n \n+use crate::errors;\n use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::implementation::{Direction, NodeIndex, INCOMING, OUTGOING};\n@@ -133,12 +134,10 @@ impl<'tcx> IfThisChanged<'tcx> {\n                     Some(n) => {\n                         match DepNode::from_label_string(self.tcx, n.as_str(), def_path_hash) {\n                             Ok(n) => n,\n-                            Err(()) => {\n-                                self.tcx.sess.span_fatal(\n-                                    attr.span,\n-                                    &format!(\"unrecognized DepNode variant {:?}\", n),\n-                                );\n-                            }\n+                            Err(()) => self.tcx.sess.emit_fatal(errors::UnrecognizedDepNode {\n+                                span: attr.span,\n+                                name: n,\n+                            }),\n                         }\n                     }\n                 };\n@@ -149,16 +148,14 @@ impl<'tcx> IfThisChanged<'tcx> {\n                     Some(n) => {\n                         match DepNode::from_label_string(self.tcx, n.as_str(), def_path_hash) {\n                             Ok(n) => n,\n-                            Err(()) => {\n-                                self.tcx.sess.span_fatal(\n-                                    attr.span,\n-                                    &format!(\"unrecognized DepNode variant {:?}\", n),\n-                                );\n-                            }\n+                            Err(()) => self.tcx.sess.emit_fatal(errors::UnrecognizedDepNode {\n+                                span: attr.span,\n+                                name: n,\n+                            }),\n                         }\n                     }\n                     None => {\n-                        self.tcx.sess.span_fatal(attr.span, \"missing DepNode variant\");\n+                        self.tcx.sess.emit_fatal(errors::MissingDepNode { span: attr.span });\n                     }\n                 };\n                 self.then_this_would_need.push((\n@@ -204,7 +201,7 @@ fn check_paths<'tcx>(tcx: TyCtxt<'tcx>, if_this_changed: &Sources, then_this_wou\n     // Return early here so as not to construct the query, which is not cheap.\n     if if_this_changed.is_empty() {\n         for &(target_span, _, _, _) in then_this_would_need {\n-            tcx.sess.span_err(target_span, \"no `#[rustc_if_this_changed]` annotation detected\");\n+            tcx.sess.emit_err(errors::MissingIfThisChanged { span: target_span });\n         }\n         return;\n     }\n@@ -213,16 +210,13 @@ fn check_paths<'tcx>(tcx: TyCtxt<'tcx>, if_this_changed: &Sources, then_this_wou\n             let dependents = query.transitive_predecessors(source_dep_node);\n             for &(target_span, ref target_pass, _, ref target_dep_node) in then_this_would_need {\n                 if !dependents.contains(&target_dep_node) {\n-                    tcx.sess.span_err(\n-                        target_span,\n-                        &format!(\n-                            \"no path from `{}` to `{}`\",\n-                            tcx.def_path_str(source_def_id),\n-                            target_pass\n-                        ),\n-                    );\n+                    tcx.sess.emit_err(errors::NoPath {\n+                        span: target_span,\n+                        source: tcx.def_path_str(source_def_id),\n+                        target: *target_pass,\n+                    });\n                 } else {\n-                    tcx.sess.span_err(target_span, \"OK\");\n+                    tcx.sess.emit_err(errors::Ok { span: target_span });\n                 }\n             }\n         }"}, {"sha": "2968a0e1203a991028a11b9006e7f54e28c74574", "filename": "compiler/rustc_incremental/src/assert_module_sources.rs", "status": "modified", "additions": 21, "deletions": 29, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2ff46641a92c27a32db3e0dc94ae86295e6c3277/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ff46641a92c27a32db3e0dc94ae86295e6c3277/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs?ref=2ff46641a92c27a32db3e0dc94ae86295e6c3277", "patch": "@@ -22,6 +22,7 @@\n //! allows for doing a more fine-grained check to see if pre- or post-lto data\n //! was re-used.\n \n+use crate::errors;\n use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def_id::LOCAL_CRATE;\n@@ -66,21 +67,17 @@ impl<'tcx> AssertModuleSource<'tcx> {\n                 sym::post_dash_lto => (CguReuse::PostLto, ComparisonKind::Exact),\n                 sym::any => (CguReuse::PreLto, ComparisonKind::AtLeast),\n                 other => {\n-                    self.tcx.sess.span_fatal(\n-                        attr.span,\n-                        &format!(\"unknown cgu-reuse-kind `{}` specified\", other),\n-                    );\n+                    self.tcx\n+                        .sess\n+                        .emit_fatal(errors::UnknownReuseKind { span: attr.span, kind: other });\n                 }\n             }\n         } else {\n             return;\n         };\n \n         if !self.tcx.sess.opts.unstable_opts.query_dep_graph {\n-            self.tcx.sess.span_fatal(\n-                attr.span,\n-                \"found CGU-reuse attribute but `-Zquery-dep-graph` was not specified\",\n-            );\n+            self.tcx.sess.emit_fatal(errors::MissingQueryDepGraph { span: attr.span });\n         }\n \n         if !self.check_config(attr) {\n@@ -92,13 +89,11 @@ impl<'tcx> AssertModuleSource<'tcx> {\n         let crate_name = self.tcx.crate_name(LOCAL_CRATE).to_string();\n \n         if !user_path.starts_with(&crate_name) {\n-            let msg = format!(\n-                \"Found malformed codegen unit name `{}`. \\\n-                Codegen units names must always start with the name of the \\\n-                crate (`{}` in this case).\",\n-                user_path, crate_name\n-            );\n-            self.tcx.sess.span_fatal(attr.span, &msg);\n+            self.tcx.sess.emit_fatal(errors::MalformedCguName {\n+                span: attr.span,\n+                user_path,\n+                crate_name,\n+            });\n         }\n \n         // Split of the \"special suffix\" if there is one.\n@@ -125,15 +120,12 @@ impl<'tcx> AssertModuleSource<'tcx> {\n             let mut cgu_names: Vec<&str> =\n                 self.available_cgus.iter().map(|cgu| cgu.as_str()).collect();\n             cgu_names.sort();\n-            self.tcx.sess.span_err(\n-                attr.span,\n-                &format!(\n-                    \"no module named `{}` (mangled: {}). Available modules: {}\",\n-                    user_path,\n-                    cgu_name,\n-                    cgu_names.join(\", \")\n-                ),\n-            );\n+            self.tcx.sess.emit_err(errors::NoModuleNamed {\n+                span: attr.span,\n+                user_path,\n+                cgu_name,\n+                cgu_names: cgu_names.join(\", \"),\n+            });\n         }\n \n         self.tcx.sess.cgu_reuse_tracker.set_expectation(\n@@ -151,15 +143,15 @@ impl<'tcx> AssertModuleSource<'tcx> {\n                 if let Some(value) = item.value_str() {\n                     return value;\n                 } else {\n-                    self.tcx.sess.span_fatal(\n-                        item.span(),\n-                        &format!(\"associated value expected for `{}`\", name),\n-                    );\n+                    self.tcx.sess.emit_fatal(errors::FieldAssociatedValueExpected {\n+                        span: item.span(),\n+                        name,\n+                    });\n                 }\n             }\n         }\n \n-        self.tcx.sess.span_fatal(attr.span, &format!(\"no field `{}`\", name));\n+        self.tcx.sess.emit_fatal(errors::NoField { span: attr.span, name });\n     }\n \n     /// Scan for a `cfg=\"foo\"` attribute and check whether we have a"}, {"sha": "deb8767836543470144a8c3952ef6ab07e8f63a9", "filename": "compiler/rustc_incremental/src/errors.rs", "status": "added", "additions": 364, "deletions": 0, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/2ff46641a92c27a32db3e0dc94ae86295e6c3277/compiler%2Frustc_incremental%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ff46641a92c27a32db3e0dc94ae86295e6c3277/compiler%2Frustc_incremental%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Ferrors.rs?ref=2ff46641a92c27a32db3e0dc94ae86295e6c3277", "patch": "@@ -0,0 +1,364 @@\n+use rustc_macros::Diagnostic;\n+use rustc_span::{symbol::Ident, Span, Symbol};\n+use std::path::{Path, PathBuf};\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_unrecognized_depnode)]\n+pub struct UnrecognizedDepNode {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_missing_depnode)]\n+pub struct MissingDepNode {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_missing_if_this_changed)]\n+pub struct MissingIfThisChanged {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_ok)]\n+pub struct Ok {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_no_path)]\n+pub struct NoPath {\n+    #[primary_span]\n+    pub span: Span,\n+    pub target: Symbol,\n+    pub source: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_unknown_reuse_kind)]\n+pub struct UnknownReuseKind {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_missing_query_depgraph)]\n+pub struct MissingQueryDepGraph {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_malformed_cgu_name)]\n+pub struct MalformedCguName {\n+    #[primary_span]\n+    pub span: Span,\n+    pub user_path: String,\n+    pub crate_name: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_no_module_named)]\n+pub struct NoModuleNamed<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub user_path: &'a str,\n+    pub cgu_name: Symbol,\n+    pub cgu_names: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_field_associated_value_expected)]\n+pub struct FieldAssociatedValueExpected {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_no_field)]\n+pub struct NoField {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_assertion_auto)]\n+pub struct AssertionAuto<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: &'a str,\n+    pub e: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_undefined_clean_dirty_assertions_item)]\n+pub struct UndefinedCleanDirtyItem {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_undefined_clean_dirty_assertions)]\n+pub struct UndefinedCleanDirty {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_repeated_depnode_label)]\n+pub struct RepeatedDepNodeLabel<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub label: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_unrecognized_depnode_label)]\n+pub struct UnrecognizedDepNodeLabel<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub label: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_not_dirty)]\n+pub struct NotDirty<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub dep_node_str: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_not_clean)]\n+pub struct NotClean<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub dep_node_str: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_not_loaded)]\n+pub struct NotLoaded<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub dep_node_str: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_unknown_item)]\n+pub struct UnknownItem {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_no_cfg)]\n+pub struct NoCfg {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_associated_value_expected_for)]\n+pub struct AssociatedValueExpectedFor {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ident: Ident,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_associated_value_expected)]\n+pub struct AssociatedValueExpected {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_unchecked_clean)]\n+pub struct UncheckedClean {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_delete_old)]\n+pub struct DeleteOld<'a> {\n+    pub name: &'a str,\n+    pub path: PathBuf,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_create_new)]\n+pub struct CreateNew<'a> {\n+    pub name: &'a str,\n+    pub path: PathBuf,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_write_new)]\n+pub struct WriteNew<'a> {\n+    pub name: &'a str,\n+    pub path: PathBuf,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_canonicalize_path)]\n+pub struct CanonicalizePath {\n+    pub path: PathBuf,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_create_incr_comp_dir)]\n+pub struct CreateIncrCompDir<'a> {\n+    pub tag: &'a str,\n+    pub path: &'a Path,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_create_lock)]\n+pub struct CreateLock<'a> {\n+    pub lock_err: std::io::Error,\n+    pub session_dir: &'a Path,\n+    #[note(incremental_lock_unsupported)]\n+    pub is_unsupported_lock: Option<()>,\n+    #[help(incremental_cargo_help_1)]\n+    #[help(incremental_cargo_help_2)]\n+    pub is_cargo: Option<()>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_delete_lock)]\n+pub struct DeleteLock<'a> {\n+    pub path: &'a Path,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_hard_link_failed)]\n+pub struct HardLinkFailed<'a> {\n+    pub path: &'a Path,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_delete_partial)]\n+pub struct DeletePartial<'a> {\n+    pub path: &'a Path,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_delete_full)]\n+pub struct DeleteFull<'a> {\n+    pub path: &'a Path,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_finalize)]\n+pub struct Finalize<'a> {\n+    pub path: &'a Path,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_invalid_gc_failed)]\n+pub struct InvalidGcFailed<'a> {\n+    pub path: &'a Path,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_finalized_gc_failed)]\n+pub struct FinalizedGcFailed<'a> {\n+    pub path: &'a Path,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_session_gc_failed)]\n+pub struct SessionGcFailed<'a> {\n+    pub path: &'a Path,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_assert_not_loaded)]\n+pub struct AssertNotLoaded;\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_assert_loaded)]\n+pub struct AssertLoaded;\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_delete_incompatible)]\n+pub struct DeleteIncompatible {\n+    pub path: PathBuf,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_load_dep_graph)]\n+pub struct LoadDepGraph {\n+    pub path: PathBuf,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_decode_incr_cache)]\n+pub struct DecodeIncrCache {\n+    pub err: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_write_dep_graph)]\n+pub struct WriteDepGraph<'a> {\n+    pub path: &'a Path,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_move_dep_graph)]\n+pub struct MoveDepGraph<'a> {\n+    pub from: &'a Path,\n+    pub to: &'a Path,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_create_dep_graph)]\n+pub struct CreateDepGraph<'a> {\n+    pub path: &'a Path,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_copy_workproduct_to_cache)]\n+pub struct CopyWorkProductToCache<'a> {\n+    pub from: &'a Path,\n+    pub to: &'a Path,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_delete_workproduct)]\n+pub struct DeleteWorkProduct<'a> {\n+    pub path: &'a Path,\n+    pub err: std::io::Error,\n+}"}, {"sha": "3c58cfa38f28021241f8a70c0538d1cf8bf3f807", "filename": "compiler/rustc_incremental/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ff46641a92c27a32db3e0dc94ae86295e6c3277/compiler%2Frustc_incremental%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ff46641a92c27a32db3e0dc94ae86295e6c3277/compiler%2Frustc_incremental%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Flib.rs?ref=2ff46641a92c27a32db3e0dc94ae86295e6c3277", "patch": "@@ -2,8 +2,11 @@\n \n #![deny(missing_docs)]\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n+#![feature(never_type)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n #[macro_use]\n extern crate rustc_middle;\n@@ -12,6 +15,7 @@ extern crate tracing;\n \n mod assert_dep_graph;\n pub mod assert_module_sources;\n+mod errors;\n mod persist;\n \n use assert_dep_graph::assert_dep_graph;"}, {"sha": "c6e63998c7935fe887445845a65cf794cb579d81", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 26, "deletions": 37, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/2ff46641a92c27a32db3e0dc94ae86295e6c3277/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ff46641a92c27a32db3e0dc94ae86295e6c3277/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=2ff46641a92c27a32db3e0dc94ae86295e6c3277", "patch": "@@ -19,6 +19,7 @@\n //! Errors are reported if we are in the suitable configuration but\n //! the required condition is not met.\n \n+use crate::errors;\n use rustc_ast::{self as ast, Attribute, NestedMetaItem};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def_id::LocalDefId;\n@@ -196,11 +197,7 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n         let loaded_from_disk = self.loaded_from_disk(attr);\n         for e in except.iter() {\n             if !auto.remove(e) {\n-                let msg = format!(\n-                    \"`except` specified DepNodes that can not be affected for \\\"{}\\\": \\\"{}\\\"\",\n-                    name, e\n-                );\n-                self.tcx.sess.span_fatal(attr.span, &msg);\n+                self.tcx.sess.emit_fatal(errors::AssertionAuto { span: attr.span, name, e });\n             }\n         }\n         Assertion { clean: auto, dirty: except, loaded_from_disk }\n@@ -282,14 +279,10 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n                     // An implementation, eg `impl<A> Trait for Foo { .. }`\n                     HirItem::Impl { .. } => (\"ItemKind::Impl\", LABELS_IMPL),\n \n-                    _ => self.tcx.sess.span_fatal(\n-                        attr.span,\n-                        &format!(\n-                            \"clean/dirty auto-assertions not yet defined \\\n-                             for Node::Item.node={:?}\",\n-                            item.kind\n-                        ),\n-                    ),\n+                    _ => self.tcx.sess.emit_fatal(errors::UndefinedCleanDirtyItem {\n+                        span: attr.span,\n+                        kind: format!(\"{:?}\", item.kind),\n+                    }),\n                 }\n             }\n             HirNode::TraitItem(item) => match item.kind {\n@@ -302,10 +295,10 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n                 ImplItemKind::Const(..) => (\"NodeImplConst\", LABELS_CONST_IN_IMPL),\n                 ImplItemKind::Type(..) => (\"NodeImplType\", LABELS_CONST_IN_IMPL),\n             },\n-            _ => self.tcx.sess.span_fatal(\n-                attr.span,\n-                &format!(\"clean/dirty auto-assertions not yet defined for {:?}\", node),\n-            ),\n+            _ => self.tcx.sess.emit_fatal(errors::UndefinedCleanDirty {\n+                span: attr.span,\n+                kind: format!(\"{:?}\", node),\n+            }),\n         };\n         let labels =\n             Labels::from_iter(labels.iter().flat_map(|s| s.iter().map(|l| (*l).to_string())));\n@@ -318,16 +311,15 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n             let label = label.trim();\n             if DepNode::has_label_string(label) {\n                 if out.contains(label) {\n-                    self.tcx.sess.span_fatal(\n-                        item.span(),\n-                        &format!(\"dep-node label `{}` is repeated\", label),\n-                    );\n+                    self.tcx\n+                        .sess\n+                        .emit_fatal(errors::RepeatedDepNodeLabel { span: item.span(), label });\n                 }\n                 out.insert(label.to_string());\n             } else {\n                 self.tcx\n                     .sess\n-                    .span_fatal(item.span(), &format!(\"dep-node label `{}` not recognized\", label));\n+                    .emit_fatal(errors::UnrecognizedDepNodeLabel { span: item.span(), label });\n             }\n         }\n         out\n@@ -348,7 +340,7 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n             let dep_node_str = self.dep_node_str(&dep_node);\n             self.tcx\n                 .sess\n-                .span_err(item_span, &format!(\"`{}` should be dirty but is not\", dep_node_str));\n+                .emit_err(errors::NotDirty { span: item_span, dep_node_str: &dep_node_str });\n         }\n     }\n \n@@ -359,7 +351,7 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n             let dep_node_str = self.dep_node_str(&dep_node);\n             self.tcx\n                 .sess\n-                .span_err(item_span, &format!(\"`{}` should be clean but is not\", dep_node_str));\n+                .emit_err(errors::NotClean { span: item_span, dep_node_str: &dep_node_str });\n         }\n     }\n \n@@ -368,10 +360,9 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n \n         if !self.tcx.dep_graph.debug_was_loaded_from_disk(dep_node) {\n             let dep_node_str = self.dep_node_str(&dep_node);\n-            self.tcx.sess.span_err(\n-                item_span,\n-                &format!(\"`{}` should have been loaded from disk but it was not\", dep_node_str),\n-            );\n+            self.tcx\n+                .sess\n+                .emit_err(errors::NotLoaded { span: item_span, dep_node_str: &dep_node_str });\n         }\n     }\n \n@@ -412,12 +403,12 @@ fn check_config(tcx: TyCtxt<'_>, attr: &Attribute) -> bool {\n             debug!(\"check_config: searching for cfg {:?}\", value);\n             cfg = Some(config.contains(&(value, None)));\n         } else if !(item.has_name(EXCEPT) || item.has_name(LOADED_FROM_DISK)) {\n-            tcx.sess.span_err(attr.span, &format!(\"unknown item `{}`\", item.name_or_empty()));\n+            tcx.sess.emit_err(errors::UnknownItem { span: attr.span, name: item.name_or_empty() });\n         }\n     }\n \n     match cfg {\n-        None => tcx.sess.span_fatal(attr.span, \"no cfg attribute\"),\n+        None => tcx.sess.emit_fatal(errors::NoCfg { span: attr.span }),\n         Some(c) => c,\n     }\n }\n@@ -426,13 +417,11 @@ fn expect_associated_value(tcx: TyCtxt<'_>, item: &NestedMetaItem) -> Symbol {\n     if let Some(value) = item.value_str() {\n         value\n     } else {\n-        let msg = if let Some(ident) = item.ident() {\n-            format!(\"associated value expected for `{}`\", ident)\n+        if let Some(ident) = item.ident() {\n+            tcx.sess.emit_fatal(errors::AssociatedValueExpectedFor { span: item.span(), ident });\n         } else {\n-            \"expected an associated value\".to_string()\n-        };\n-\n-        tcx.sess.span_fatal(item.span(), &msg);\n+            tcx.sess.emit_fatal(errors::AssociatedValueExpected { span: item.span() });\n+        }\n     }\n }\n \n@@ -456,7 +445,7 @@ impl<'tcx> FindAllAttrs<'tcx> {\n     fn report_unchecked_attrs(&self, mut checked_attrs: FxHashSet<ast::AttrId>) {\n         for attr in &self.found_attrs {\n             if !checked_attrs.contains(&attr.id) {\n-                self.tcx.sess.span_err(attr.span, \"found unchecked `#[rustc_clean]` attribute\");\n+                self.tcx.sess.emit_err(errors::UncheckedClean { span: attr.span });\n                 checked_attrs.insert(attr.id);\n             }\n         }"}, {"sha": "dc981c6179eeb5b66d7f6f11190a762e115e5b46", "filename": "compiler/rustc_incremental/src/persist/file_format.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2ff46641a92c27a32db3e0dc94ae86295e6c3277/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ff46641a92c27a32db3e0dc94ae86295e6c3277/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs?ref=2ff46641a92c27a32db3e0dc94ae86295e6c3277", "patch": "@@ -9,15 +9,15 @@\n //! compiler versions don't change frequently for the typical user, being\n //! conservative here practically has no downside.\n \n-use std::env;\n-use std::fs;\n-use std::io::{self, Read};\n-use std::path::{Path, PathBuf};\n-\n+use crate::errors;\n use rustc_data_structures::memmap::Mmap;\n use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n use rustc_serialize::Encoder;\n use rustc_session::Session;\n+use std::env;\n+use std::fs;\n+use std::io::{self, Read};\n+use std::path::{Path, PathBuf};\n \n /// The first few bytes of files generated by incremental compilation.\n const FILE_MAGIC: &[u8] = b\"RSIC\";\n@@ -60,20 +60,15 @@ where\n         }\n         Err(err) if err.kind() == io::ErrorKind::NotFound => (),\n         Err(err) => {\n-            sess.err(&format!(\n-                \"unable to delete old {} at `{}`: {}\",\n-                name,\n-                path_buf.display(),\n-                err\n-            ));\n+            sess.emit_err(errors::DeleteOld { name, path: path_buf, err });\n             return;\n         }\n     }\n \n     let mut encoder = match FileEncoder::new(&path_buf) {\n         Ok(encoder) => encoder,\n         Err(err) => {\n-            sess.err(&format!(\"failed to create {} at `{}`: {}\", name, path_buf.display(), err));\n+            sess.emit_err(errors::CreateNew { name, path: path_buf, err });\n             return;\n         }\n     };\n@@ -90,7 +85,7 @@ where\n             debug!(\"save: data written to disk successfully\");\n         }\n         Err(err) => {\n-            sess.err(&format!(\"failed to write {} to `{}`: {}\", name, path_buf.display(), err));\n+            sess.emit_err(errors::WriteNew { name, path: path_buf, err });\n         }\n     }\n }"}, {"sha": "73d7e3becab484725e15f8b9bb7e51e4d6acd1b5", "filename": "compiler/rustc_incremental/src/persist/fs.rs", "status": "modified", "additions": 18, "deletions": 93, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/2ff46641a92c27a32db3e0dc94ae86295e6c3277/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ff46641a92c27a32db3e0dc94ae86295e6c3277/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs?ref=2ff46641a92c27a32db3e0dc94ae86295e6c3277", "patch": "@@ -103,6 +103,7 @@\n //! unsupported file system and emit a warning in that case. This is not yet\n //! implemented.\n \n+use crate::errors;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::{base_n, flock};\n@@ -225,12 +226,7 @@ pub fn prepare_session_directory(\n     let crate_dir = match crate_dir.canonicalize() {\n         Ok(v) => v,\n         Err(err) => {\n-            let reported = sess.err(&format!(\n-                \"incremental compilation: error canonicalizing path `{}`: {}\",\n-                crate_dir.display(),\n-                err\n-            ));\n-            return Err(reported);\n+            return Err(sess.emit_err(errors::CanonicalizePath { path: crate_dir, err }));\n         }\n     };\n \n@@ -273,14 +269,7 @@ pub fn prepare_session_directory(\n             debug!(\"successfully copied data from: {}\", source_directory.display());\n \n             if !allows_links {\n-                sess.warn(&format!(\n-                    \"Hard linking files in the incremental \\\n-                                        compilation cache failed. Copying files \\\n-                                        instead. Consider moving the cache \\\n-                                        directory to a file system which supports \\\n-                                        hard linking in session dir `{}`\",\n-                    session_dir.display()\n-                ));\n+                sess.emit_warning(errors::HardLinkFailed { path: &session_dir });\n             }\n \n             sess.init_incr_comp_session(session_dir, directory_lock, true);\n@@ -295,12 +284,7 @@ pub fn prepare_session_directory(\n             // Try to remove the session directory we just allocated. We don't\n             // know if there's any garbage in it from the failed copy action.\n             if let Err(err) = safe_remove_dir_all(&session_dir) {\n-                sess.warn(&format!(\n-                    \"Failed to delete partly initialized \\\n-                                    session dir `{}`: {}\",\n-                    session_dir.display(),\n-                    err\n-                ));\n+                sess.emit_warning(errors::DeletePartial { path: &session_dir, err });\n             }\n \n             delete_session_dir_lock_file(sess, &lock_file_path);\n@@ -332,12 +316,7 @@ pub fn finalize_session_directory(sess: &Session, svh: Svh) {\n         );\n \n         if let Err(err) = safe_remove_dir_all(&*incr_comp_session_dir) {\n-            sess.warn(&format!(\n-                \"Error deleting incremental compilation \\\n-                                session directory `{}`: {}\",\n-                incr_comp_session_dir.display(),\n-                err\n-            ));\n+            sess.emit_warning(errors::DeleteFull { path: &incr_comp_session_dir, err });\n         }\n \n         let lock_file_path = lock_file_path(&*incr_comp_session_dir);\n@@ -380,12 +359,7 @@ pub fn finalize_session_directory(sess: &Session, svh: Svh) {\n         }\n         Err(e) => {\n             // Warn about the error. However, no need to abort compilation now.\n-            sess.warn(&format!(\n-                \"Error finalizing incremental compilation \\\n-                               session directory `{}`: {}\",\n-                incr_comp_session_dir.display(),\n-                e\n-            ));\n+            sess.emit_warning(errors::Finalize { path: &incr_comp_session_dir, err: e });\n \n             debug!(\"finalize_session_directory() - error, marking as invalid\");\n             // Drop the file lock, so we can garage collect\n@@ -488,16 +462,7 @@ fn create_dir(sess: &Session, path: &Path, dir_tag: &str) -> Result<(), ErrorGua\n             debug!(\"{} directory created successfully\", dir_tag);\n             Ok(())\n         }\n-        Err(err) => {\n-            let reported = sess.err(&format!(\n-                \"Could not create incremental compilation {} \\\n-                               directory `{}`: {}\",\n-                dir_tag,\n-                path.display(),\n-                err\n-            ));\n-            Err(reported)\n-        }\n+        Err(err) => Err(sess.emit_err(errors::CreateIncrCompDir { tag: dir_tag, path, err })),\n     }\n }\n \n@@ -518,46 +483,20 @@ fn lock_directory(\n         // the lock should be exclusive\n         Ok(lock) => Ok((lock, lock_file_path)),\n         Err(lock_err) => {\n-            let mut err = sess.struct_err(&format!(\n-                \"incremental compilation: could not create \\\n-                 session directory lock file: {}\",\n-                lock_err\n-            ));\n-            if flock::Lock::error_unsupported(&lock_err) {\n-                err.note(&format!(\n-                    \"the filesystem for the incremental path at {} \\\n-                     does not appear to support locking, consider changing the \\\n-                     incremental path to a filesystem that supports locking \\\n-                     or disable incremental compilation\",\n-                    session_dir.display()\n-                ));\n-                if std::env::var_os(\"CARGO\").is_some() {\n-                    err.help(\n-                        \"incremental compilation can be disabled by setting the \\\n-                         environment variable CARGO_INCREMENTAL=0 (see \\\n-                         https://doc.rust-lang.org/cargo/reference/profiles.html#incremental)\",\n-                    );\n-                    err.help(\n-                        \"the entire build directory can be changed to a different \\\n-                        filesystem by setting the environment variable CARGO_TARGET_DIR \\\n-                        to a different path (see \\\n-                        https://doc.rust-lang.org/cargo/reference/config.html#buildtarget-dir)\",\n-                    );\n-                }\n-            }\n-            Err(err.emit())\n+            let is_unsupported_lock = flock::Lock::error_unsupported(&lock_err).then_some(());\n+            Err(sess.emit_err(errors::CreateLock {\n+                lock_err,\n+                session_dir,\n+                is_unsupported_lock,\n+                is_cargo: std::env::var_os(\"CARGO\").map(|_| ()),\n+            }))\n         }\n     }\n }\n \n fn delete_session_dir_lock_file(sess: &Session, lock_file_path: &Path) {\n     if let Err(err) = safe_remove_file(&lock_file_path) {\n-        sess.warn(&format!(\n-            \"Error deleting lock file for incremental \\\n-                            compilation session directory `{}`: {}\",\n-            lock_file_path.display(),\n-            err\n-        ));\n+        sess.emit_warning(errors::DeleteLock { path: lock_file_path, err });\n     }\n }\n \n@@ -774,12 +713,7 @@ pub fn garbage_collect_session_directories(sess: &Session) -> io::Result<()> {\n         if !lock_file_to_session_dir.values().any(|dir| *dir == directory_name) {\n             let path = crate_directory.join(directory_name);\n             if let Err(err) = safe_remove_dir_all(&path) {\n-                sess.warn(&format!(\n-                    \"Failed to garbage collect invalid incremental \\\n-                                    compilation session directory `{}`: {}\",\n-                    path.display(),\n-                    err\n-                ));\n+                sess.emit_warning(errors::InvalidGcFailed { path: &path, err });\n             }\n         }\n     }\n@@ -885,12 +819,7 @@ pub fn garbage_collect_session_directories(sess: &Session) -> io::Result<()> {\n         debug!(\"garbage_collect_session_directories() - deleting `{}`\", path.display());\n \n         if let Err(err) = safe_remove_dir_all(&path) {\n-            sess.warn(&format!(\n-                \"Failed to garbage collect finalized incremental \\\n-                                compilation session directory `{}`: {}\",\n-                path.display(),\n-                err\n-            ));\n+            sess.emit_warning(errors::FinalizedGcFailed { path: &path, err });\n         } else {\n             delete_session_dir_lock_file(sess, &lock_file_path(&path));\n         }\n@@ -907,11 +836,7 @@ fn delete_old(sess: &Session, path: &Path) {\n     debug!(\"garbage_collect_session_directories() - deleting `{}`\", path.display());\n \n     if let Err(err) = safe_remove_dir_all(&path) {\n-        sess.warn(&format!(\n-            \"Failed to garbage collect incremental compilation session directory `{}`: {}\",\n-            path.display(),\n-            err\n-        ));\n+        sess.emit_warning(errors::SessionGcFailed { path: &path, err });\n     } else {\n         delete_session_dir_lock_file(sess, &lock_file_path(&path));\n     }"}, {"sha": "d5097065dda2e8c5eb3d7cbdd012329f1ac9f4bf", "filename": "compiler/rustc_incremental/src/persist/load.rs", "status": "modified", "additions": 24, "deletions": 30, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/2ff46641a92c27a32db3e0dc94ae86295e6c3277/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ff46641a92c27a32db3e0dc94ae86295e6c3277/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs?ref=2ff46641a92c27a32db3e0dc94ae86295e6c3277", "patch": "@@ -1,5 +1,6 @@\n //! Code to save/load the dep-graph from files.\n \n+use crate::errors;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::memmap::Mmap;\n use rustc_middle::dep_graph::{SerializedDepGraph, WorkProduct, WorkProductId};\n@@ -8,7 +9,7 @@ use rustc_serialize::opaque::MemDecoder;\n use rustc_serialize::Decodable;\n use rustc_session::config::IncrementalStateAssertion;\n use rustc_session::Session;\n-use std::path::Path;\n+use std::path::{Path, PathBuf};\n \n use super::data::*;\n use super::file_format;\n@@ -27,11 +28,10 @@ pub enum LoadResult<T> {\n     },\n     /// The file either didn't exist or was produced by an incompatible compiler version.\n     DataOutOfDate,\n-    /// An error occurred.\n-    Error {\n-        #[allow(missing_docs)]\n-        message: String,\n-    },\n+    /// Loading the dep graph failed.\n+    LoadDepGraph(PathBuf, std::io::Error),\n+    /// Decoding loaded incremental cache failed.\n+    DecodeIncrCache(Box<dyn std::any::Any + Send>),\n }\n \n impl<T: Default> LoadResult<T> {\n@@ -40,36 +40,31 @@ impl<T: Default> LoadResult<T> {\n         // Check for errors when using `-Zassert-incremental-state`\n         match (sess.opts.assert_incr_state, &self) {\n             (Some(IncrementalStateAssertion::NotLoaded), LoadResult::Ok { .. }) => {\n-                sess.fatal(\n-                    \"We asserted that the incremental cache should not be loaded, \\\n-                         but it was loaded.\",\n-                );\n+                sess.emit_fatal(errors::AssertNotLoaded);\n             }\n             (\n                 Some(IncrementalStateAssertion::Loaded),\n-                LoadResult::Error { .. } | LoadResult::DataOutOfDate,\n+                LoadResult::LoadDepGraph(..)\n+                | LoadResult::DecodeIncrCache(..)\n+                | LoadResult::DataOutOfDate,\n             ) => {\n-                sess.fatal(\n-                    \"We asserted that an existing incremental cache directory should \\\n-                         be successfully loaded, but it was not.\",\n-                );\n+                sess.emit_fatal(errors::AssertLoaded);\n             }\n             _ => {}\n         };\n \n         match self {\n-            LoadResult::Error { message } => {\n-                sess.warn(&message);\n+            LoadResult::LoadDepGraph(path, err) => {\n+                sess.emit_warning(errors::LoadDepGraph { path, err });\n+                Default::default()\n+            }\n+            LoadResult::DecodeIncrCache(err) => {\n+                sess.emit_warning(errors::DecodeIncrCache { err: format!(\"{err:?}\") });\n                 Default::default()\n             }\n             LoadResult::DataOutOfDate => {\n                 if let Err(err) = delete_all_session_dir_contents(sess) {\n-                    sess.err(&format!(\n-                        \"Failed to delete invalidated or incompatible \\\n-                         incremental compilation session directory contents `{}`: {}.\",\n-                        dep_graph_path(sess).display(),\n-                        err\n-                    ));\n+                    sess.emit_err(errors::DeleteIncompatible { path: dep_graph_path(sess), err });\n                 }\n                 Default::default()\n             }\n@@ -90,9 +85,7 @@ fn load_data(\n             // compiler version. Neither is an error.\n             LoadResult::DataOutOfDate\n         }\n-        Err(err) => LoadResult::Error {\n-            message: format!(\"could not load dep-graph from `{}`: {}\", path.display(), err),\n-        },\n+        Err(err) => LoadResult::LoadDepGraph(path.to_path_buf(), err),\n     }\n }\n \n@@ -114,9 +107,9 @@ impl<T> MaybeAsync<LoadResult<T>> {\n     pub fn open(self) -> LoadResult<T> {\n         match self {\n             MaybeAsync::Sync(result) => result,\n-            MaybeAsync::Async(handle) => handle.join().unwrap_or_else(|e| LoadResult::Error {\n-                message: format!(\"could not decode incremental cache: {:?}\", e),\n-            }),\n+            MaybeAsync::Async(handle) => {\n+                handle.join().unwrap_or_else(|e| LoadResult::DecodeIncrCache(e))\n+            }\n         }\n     }\n }\n@@ -185,7 +178,8 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n \n         match load_data(report_incremental_info, &path, nightly_build) {\n             LoadResult::DataOutOfDate => LoadResult::DataOutOfDate,\n-            LoadResult::Error { message } => LoadResult::Error { message },\n+            LoadResult::LoadDepGraph(path, err) => LoadResult::LoadDepGraph(path, err),\n+            LoadResult::DecodeIncrCache(err) => LoadResult::DecodeIncrCache(err),\n             LoadResult::Ok { data: (bytes, start_pos) } => {\n                 let mut decoder = MemDecoder::new(&bytes, start_pos);\n                 let prev_commandline_args_hash = u64::decode(&mut decoder);"}, {"sha": "27be56eac6f998091b0a39bc6a64400e07b27608", "filename": "compiler/rustc_incremental/src/persist/save.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2ff46641a92c27a32db3e0dc94ae86295e6c3277/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ff46641a92c27a32db3e0dc94ae86295e6c3277/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs?ref=2ff46641a92c27a32db3e0dc94ae86295e6c3277", "patch": "@@ -1,3 +1,4 @@\n+use crate::errors;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::join;\n use rustc_middle::dep_graph::{DepGraph, SerializedDepGraph, WorkProduct, WorkProductId};\n@@ -59,19 +60,14 @@ pub fn save_dep_graph(tcx: TyCtxt<'_>) {\n             move || {\n                 sess.time(\"incr_comp_persist_dep_graph\", || {\n                     if let Err(err) = tcx.dep_graph.encode(&tcx.sess.prof) {\n-                        sess.err(&format!(\n-                            \"failed to write dependency graph to `{}`: {}\",\n-                            staging_dep_graph_path.display(),\n-                            err\n-                        ));\n+                        sess.emit_err(errors::WriteDepGraph { path: &staging_dep_graph_path, err });\n                     }\n                     if let Err(err) = fs::rename(&staging_dep_graph_path, &dep_graph_path) {\n-                        sess.err(&format!(\n-                            \"failed to move dependency graph from `{}` to `{}`: {}\",\n-                            staging_dep_graph_path.display(),\n-                            dep_graph_path.display(),\n-                            err\n-                        ));\n+                        sess.emit_err(errors::MoveDepGraph {\n+                            from: &staging_dep_graph_path,\n+                            to: &dep_graph_path,\n+                            err,\n+                        });\n                     }\n                 });\n             },\n@@ -163,11 +159,7 @@ pub fn build_dep_graph(\n     let mut encoder = match FileEncoder::new(&path_buf) {\n         Ok(encoder) => encoder,\n         Err(err) => {\n-            sess.err(&format!(\n-                \"failed to create dependency graph at `{}`: {}\",\n-                path_buf.display(),\n-                err\n-            ));\n+            sess.emit_err(errors::CreateDepGraph { path: &path_buf, err });\n             return None;\n         }\n     };"}, {"sha": "dc98fbeb0d1669f9bbcd54dd3e392ca0fdc4ea92", "filename": "compiler/rustc_incremental/src/persist/work_product.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2ff46641a92c27a32db3e0dc94ae86295e6c3277/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fwork_product.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ff46641a92c27a32db3e0dc94ae86295e6c3277/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fwork_product.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fwork_product.rs?ref=2ff46641a92c27a32db3e0dc94ae86295e6c3277", "patch": "@@ -2,6 +2,7 @@\n //!\n //! [work products]: WorkProduct\n \n+use crate::errors;\n use crate::persist::fs::*;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_fs_util::link_or_copy;\n@@ -28,12 +29,11 @@ pub fn copy_cgu_workproduct_to_incr_comp_cache_dir(\n                 let _ = saved_files.insert(ext.to_string(), file_name);\n             }\n             Err(err) => {\n-                sess.warn(&format!(\n-                    \"error copying object file `{}` to incremental directory as `{}`: {}\",\n-                    path.display(),\n-                    path_in_incr_dir.display(),\n-                    err\n-                ));\n+                sess.emit_warning(errors::CopyWorkProductToCache {\n+                    from: &path,\n+                    to: &path_in_incr_dir,\n+                    err,\n+                });\n             }\n         }\n     }\n@@ -49,11 +49,7 @@ pub fn delete_workproduct_files(sess: &Session, work_product: &WorkProduct) {\n     for (_, path) in &work_product.saved_files {\n         let path = in_incr_comp_dir_sess(sess, path);\n         if let Err(err) = std_fs::remove_file(&path) {\n-            sess.warn(&format!(\n-                \"file-system error deleting outdated file `{}`: {}\",\n-                path.display(),\n-                err\n-            ));\n+            sess.emit_warning(errors::DeleteWorkProduct { path: &path, err });\n         }\n     }\n }"}, {"sha": "6ce1370927bc1eb776da0deb2514064f22cfaee2", "filename": "tests/run-make/incremental-session-fail/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ff46641a92c27a32db3e0dc94ae86295e6c3277/tests%2Frun-make%2Fincremental-session-fail%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/2ff46641a92c27a32db3e0dc94ae86295e6c3277/tests%2Frun-make%2Fincremental-session-fail%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fincremental-session-fail%2FMakefile?ref=2ff46641a92c27a32db3e0dc94ae86295e6c3277", "patch": "@@ -9,6 +9,6 @@ all:\n \ttouch $(SESSION_DIR)\n \t# Check exit code is 1 for an error, and not 101 for ICE.\n \t$(RUSTC) foo.rs --crate-type=rlib -C incremental=$(SESSION_DIR) > $(OUTPUT_FILE) 2>&1; [ $$? -eq 1 ]\n-\t$(CGREP) \"Could not create incremental compilation crate directory\" < $(OUTPUT_FILE)\n+\t$(CGREP) \"could not create incremental compilation crate directory\" < $(OUTPUT_FILE)\n \t# -v tests are fragile, hopefully this text won't change\n \t$(CGREP) -v \"internal compiler error\" < $(OUTPUT_FILE)"}]}