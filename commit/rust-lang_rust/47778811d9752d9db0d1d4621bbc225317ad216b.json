{"sha": "47778811d9752d9db0d1d4621bbc225317ad216b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3Nzc4ODExZDk3NTJkOWRiMGQxZDQ2MjFiYmMyMjUzMTdhZDIxNmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-12T03:08:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-12T03:08:14Z"}, "message": "Auto merge of #48528 - bitshifter:repr_packed, r=eddyb\n\nImplementation of `#[repr(packed(n))]` RFC 1399.\n\nTracking issue https://github.com/rust-lang/rust/issues/33158.", "tree": {"sha": "4dbd337ce77fbadb02d50a974f51eaaaf419d124", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4dbd337ce77fbadb02d50a974f51eaaaf419d124"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47778811d9752d9db0d1d4621bbc225317ad216b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47778811d9752d9db0d1d4621bbc225317ad216b", "html_url": "https://github.com/rust-lang/rust/commit/47778811d9752d9db0d1d4621bbc225317ad216b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47778811d9752d9db0d1d4621bbc225317ad216b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "url": "https://api.github.com/repos/rust-lang/rust/commits/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "html_url": "https://github.com/rust-lang/rust/commit/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81"}, {"sha": "15d1c4d2139611fcb87a2c802bd015b5f4f0aed8", "url": "https://api.github.com/repos/rust-lang/rust/commits/15d1c4d2139611fcb87a2c802bd015b5f4f0aed8", "html_url": "https://github.com/rust-lang/rust/commit/15d1c4d2139611fcb87a2c802bd015b5f4f0aed8"}], "stats": {"total": 1006, "additions": 844, "deletions": 162}, "files": [{"sha": "2dd763d04b0abf6e03e00eb075200a24931f7875", "filename": "src/doc/unstable-book/src/language-features/repr-packed.md", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-packed.md", "raw_url": "https://github.com/rust-lang/rust/raw/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-packed.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-packed.md?ref=47778811d9752d9db0d1d4621bbc225317ad216b", "patch": "@@ -0,0 +1,8 @@\n+# `repr_packed`\n+\n+The tracking issue for this feature is [#33158]\n+\n+[#33158]: https://github.com/rust-lang/rust/issues/33158\n+\n+------------------------\n+"}, {"sha": "df4060e71e53eb03d2e6bcb9cff3b97d51a78f4f", "filename": "src/librustc/session/code_stats.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Flibrustc%2Fsession%2Fcode_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Flibrustc%2Fsession%2Fcode_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fcode_stats.rs?ref=47778811d9752d9db0d1d4621bbc225317ad216b", "patch": "@@ -62,6 +62,7 @@ pub struct TypeSizeInfo {\n     pub type_description: String,\n     pub align: u64,\n     pub overall_size: u64,\n+    pub packed: bool,\n     pub opt_discr_size: Option<u64>,\n     pub variants: Vec<VariantInfo>,\n }\n@@ -79,13 +80,15 @@ impl CodeStats {\n                                          type_desc: S,\n                                          align: Align,\n                                          overall_size: Size,\n+                                         packed: bool,\n                                          opt_discr_size: Option<Size>,\n                                          variants: Vec<VariantInfo>) {\n         let info = TypeSizeInfo {\n             kind,\n             type_description: type_desc.to_string(),\n             align: align.abi(),\n             overall_size: overall_size.bytes(),\n+            packed: packed,\n             opt_discr_size: opt_discr_size.map(|s| s.bytes()),\n             variants,\n         };\n@@ -153,24 +156,26 @@ impl CodeStats {\n                 for field in fields.iter() {\n                     let FieldInfo { ref name, offset, size, align } = *field;\n \n-                    // Include field alignment in output only if it caused padding injection\n-                    if min_offset != offset {\n-                        if offset > min_offset {\n-                            let pad = offset - min_offset;\n-                            println!(\"print-type-size {}padding: {} bytes\",\n-                                     indent, pad);\n-                            println!(\"print-type-size {}field `.{}`: {} bytes, \\\n-                                      alignment: {} bytes\",\n-                                     indent, name, size, align);\n-                        } else {\n-                            println!(\"print-type-size {}field `.{}`: {} bytes, \\\n-                                      offset: {} bytes, \\\n-                                      alignment: {} bytes\",\n-                                     indent, name, size, offset, align);\n-                        }\n-                    } else {\n+                    if offset > min_offset {\n+                        let pad = offset - min_offset;\n+                        println!(\"print-type-size {}padding: {} bytes\",\n+                                 indent, pad);\n+                    }\n+\n+                    if offset < min_offset {\n+                        // if this happens something is very wrong\n+                        println!(\"print-type-size {}field `.{}`: {} bytes, \\\n+                                  offset: {} bytes, \\\n+                                  alignment: {} bytes\",\n+                                 indent, name, size, offset, align);\n+                    } else if info.packed || offset == min_offset {\n                         println!(\"print-type-size {}field `.{}`: {} bytes\",\n                                  indent, name, size);\n+                    } else {\n+                        // Include field alignment in output only if it caused padding injection\n+                        println!(\"print-type-size {}field `.{}`: {} bytes, \\\n+                                  alignment: {} bytes\",\n+                                 indent, name, size, align);\n                     }\n \n                     min_offset = offset + size;"}, {"sha": "5c522cbc31516dcba149643fe9f48e418d978560", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 52, "deletions": 26, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=47778811d9752d9db0d1d4621bbc225317ad216b", "patch": "@@ -12,7 +12,7 @@ pub use self::Integer::*;\n pub use self::Primitive::*;\n \n use session::{self, DataTypeKind, Session};\n-use ty::{self, Ty, TyCtxt, TypeFoldable, ReprOptions, ReprFlags};\n+use ty::{self, Ty, TyCtxt, TypeFoldable, ReprOptions};\n \n use syntax::ast::{self, FloatTy, IntTy, UintTy};\n use syntax::attr;\n@@ -344,8 +344,8 @@ impl AddAssign for Size {\n /// a maximum capacity of 2<sup>31</sup> - 1 or 2147483647.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct Align {\n-    abi: u8,\n-    pref: u8,\n+    abi_pow2: u8,\n+    pref_pow2: u8,\n }\n \n impl Align {\n@@ -377,17 +377,17 @@ impl Align {\n         };\n \n         Ok(Align {\n-            abi: log2(abi)?,\n-            pref: log2(pref)?,\n+            abi_pow2: log2(abi)?,\n+            pref_pow2: log2(pref)?,\n         })\n     }\n \n     pub fn abi(self) -> u64 {\n-        1 << self.abi\n+        1 << self.abi_pow2\n     }\n \n     pub fn pref(self) -> u64 {\n-        1 << self.pref\n+        1 << self.pref_pow2\n     }\n \n     pub fn abi_bits(self) -> u64 {\n@@ -400,15 +400,15 @@ impl Align {\n \n     pub fn min(self, other: Align) -> Align {\n         Align {\n-            abi: cmp::min(self.abi, other.abi),\n-            pref: cmp::min(self.pref, other.pref),\n+            abi_pow2: cmp::min(self.abi_pow2, other.abi_pow2),\n+            pref_pow2: cmp::min(self.pref_pow2, other.pref_pow2),\n         }\n     }\n \n     pub fn max(self, other: Align) -> Align {\n         Align {\n-            abi: cmp::max(self.abi, other.abi),\n-            pref: cmp::max(self.pref, other.pref),\n+            abi_pow2: cmp::max(self.abi_pow2, other.abi_pow2),\n+            pref_pow2: cmp::max(self.pref_pow2, other.pref_pow2),\n         }\n     }\n }\n@@ -974,6 +974,11 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 bug!(\"struct cannot be packed and aligned\");\n             }\n \n+            let pack = {\n+                let pack = repr.pack as u64;\n+                Align::from_bytes(pack, pack).unwrap()\n+            };\n+\n             let mut align = if packed {\n                 dl.i8_align\n             } else {\n@@ -984,8 +989,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             let mut offsets = vec![Size::from_bytes(0); fields.len()];\n             let mut inverse_memory_index: Vec<u32> = (0..fields.len() as u32).collect();\n \n-            // Anything with repr(C) or repr(packed) doesn't optimize.\n-            let mut optimize = (repr.flags & ReprFlags::IS_UNOPTIMISABLE).is_empty();\n+            let mut optimize = !repr.inhibit_struct_field_reordering_opt();\n             if let StructKind::Prefixed(_, align) = kind {\n                 optimize &= align.abi() == 1;\n             }\n@@ -997,18 +1001,21 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     fields.len()\n                 };\n                 let optimizing = &mut inverse_memory_index[..end];\n+                let field_align = |f: &TyLayout| {\n+                    if packed { f.align.min(pack).abi() } else { f.align.abi() }\n+                };\n                 match kind {\n                     StructKind::AlwaysSized |\n                     StructKind::MaybeUnsized => {\n                         optimizing.sort_by_key(|&x| {\n                             // Place ZSTs first to avoid \"interesting offsets\",\n                             // especially with only one or two non-ZST fields.\n                             let f = &fields[x as usize];\n-                            (!f.is_zst(), cmp::Reverse(f.align.abi()))\n-                        })\n+                            (!f.is_zst(), cmp::Reverse(field_align(f)))\n+                        });\n                     }\n                     StructKind::Prefixed(..) => {\n-                        optimizing.sort_by_key(|&x| fields[x as usize].align.abi());\n+                        optimizing.sort_by_key(|&x| field_align(&fields[x as usize]));\n                     }\n                 }\n             }\n@@ -1022,7 +1029,10 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             let mut offset = Size::from_bytes(0);\n \n             if let StructKind::Prefixed(prefix_size, prefix_align) = kind {\n-                if !packed {\n+                if packed {\n+                    let prefix_align = prefix_align.min(pack);\n+                    align = align.max(prefix_align);\n+                } else {\n                     align = align.max(prefix_align);\n                 }\n                 offset = prefix_size.abi_align(prefix_align);\n@@ -1044,7 +1054,12 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 }\n \n                 // Invariant: offset < dl.obj_size_bound() <= 1<<61\n-                if !packed {\n+                if packed {\n+                    let field_pack = field.align.min(pack);\n+                    offset = offset.abi_align(field_pack);\n+                    align = align.max(field_pack);\n+                }\n+                else {\n                     offset = offset.abi_align(field.align);\n                     align = align.max(field.align);\n                 }\n@@ -1377,7 +1392,12 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                         bug!(\"Union cannot be packed and aligned\");\n                     }\n \n-                    let mut align = if def.repr.packed() {\n+                    let pack = {\n+                        let pack = def.repr.pack as u64;\n+                        Align::from_bytes(pack, pack).unwrap()\n+                    };\n+\n+                    let mut align = if packed {\n                         dl.i8_align\n                     } else {\n                         dl.aggregate_align\n@@ -1393,7 +1413,10 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     for field in &variants[0] {\n                         assert!(!field.is_unsized());\n \n-                        if !packed {\n+                        if packed {\n+                            let field_pack = field.align.min(pack);\n+                            align = align.max(field_pack);\n+                        } else {\n                             align = align.max(field.align);\n                         }\n                         size = cmp::max(size, field.size);\n@@ -1740,12 +1763,13 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n \n     fn record_layout_for_printing_outlined(self, layout: TyLayout<'tcx>) {\n         // (delay format until we actually need it)\n-        let record = |kind, opt_discr_size, variants| {\n+        let record = |kind, packed, opt_discr_size, variants| {\n             let type_desc = format!(\"{:?}\", layout.ty);\n             self.tcx.sess.code_stats.borrow_mut().record_type_size(kind,\n                                                                    type_desc,\n                                                                    layout.align,\n                                                                    layout.size,\n+                                                                   packed,\n                                                                    opt_discr_size,\n                                                                    variants);\n         };\n@@ -1758,7 +1782,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n \n             ty::TyClosure(..) => {\n                 debug!(\"print-type-size t: `{:?}` record closure\", layout.ty);\n-                record(DataTypeKind::Closure, None, vec![]);\n+                record(DataTypeKind::Closure, false, None, vec![]);\n                 return;\n             }\n \n@@ -1769,6 +1793,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n         };\n \n         let adt_kind = adt_def.adt_kind();\n+        let adt_packed = adt_def.repr.packed();\n \n         let build_variant_info = |n: Option<ast::Name>,\n                                   flds: &[ast::Name],\n@@ -1821,14 +1846,15 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     let fields: Vec<_> =\n                         variant_def.fields.iter().map(|f| f.name).collect();\n                     record(adt_kind.into(),\n+                           adt_packed,\n                            None,\n                            vec![build_variant_info(Some(variant_def.name),\n                                                    &fields,\n                                                    layout)]);\n                 } else {\n                     // (This case arises for *empty* enums; so give it\n                     // zero variants.)\n-                    record(adt_kind.into(), None, vec![]);\n+                    record(adt_kind.into(), adt_packed, None, vec![]);\n                 }\n             }\n \n@@ -1845,7 +1871,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                                             layout.for_variant(self, i))\n                     })\n                     .collect();\n-                record(adt_kind.into(), match layout.variants {\n+                record(adt_kind.into(), adt_packed, match layout.variants {\n                     Variants::Tagged { ref discr, .. } => Some(discr.value.size(self)),\n                     _ => None\n                 }, variant_infos);\n@@ -2518,8 +2544,8 @@ impl_stable_hash_for!(enum ::ty::layout::Primitive {\n });\n \n impl_stable_hash_for!(struct ::ty::layout::Align {\n-    abi,\n-    pref\n+    abi_pow2,\n+    pref_pow2\n });\n \n impl_stable_hash_for!(struct ::ty::layout::Size {"}, {"sha": "33b59eda7ce2ccb6ba54b27a3a3016f4e0afc7c0", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=47778811d9752d9db0d1d4621bbc225317ad216b", "patch": "@@ -1623,15 +1623,13 @@ bitflags! {\n     #[derive(RustcEncodable, RustcDecodable, Default)]\n     pub struct ReprFlags: u8 {\n         const IS_C               = 1 << 0;\n-        const IS_PACKED          = 1 << 1;\n-        const IS_SIMD            = 1 << 2;\n-        const IS_TRANSPARENT     = 1 << 3;\n+        const IS_SIMD            = 1 << 1;\n+        const IS_TRANSPARENT     = 1 << 2;\n         // Internal only for now. If true, don't reorder fields.\n-        const IS_LINEAR          = 1 << 4;\n+        const IS_LINEAR          = 1 << 3;\n \n         // Any of these flags being set prevent field reordering optimisation.\n         const IS_UNOPTIMISABLE   = ReprFlags::IS_C.bits |\n-                                   ReprFlags::IS_PACKED.bits |\n                                    ReprFlags::IS_SIMD.bits |\n                                    ReprFlags::IS_LINEAR.bits;\n     }\n@@ -1648,11 +1646,13 @@ impl_stable_hash_for!(struct ReprFlags {\n pub struct ReprOptions {\n     pub int: Option<attr::IntType>,\n     pub align: u32,\n+    pub pack: u32,\n     pub flags: ReprFlags,\n }\n \n impl_stable_hash_for!(struct ReprOptions {\n     align,\n+    pack,\n     int,\n     flags\n });\n@@ -1662,11 +1662,19 @@ impl ReprOptions {\n         let mut flags = ReprFlags::empty();\n         let mut size = None;\n         let mut max_align = 0;\n+        let mut min_pack = 0;\n         for attr in tcx.get_attrs(did).iter() {\n             for r in attr::find_repr_attrs(tcx.sess.diagnostic(), attr) {\n                 flags.insert(match r {\n                     attr::ReprC => ReprFlags::IS_C,\n-                    attr::ReprPacked => ReprFlags::IS_PACKED,\n+                    attr::ReprPacked(pack) => {\n+                        min_pack = if min_pack > 0 {\n+                            cmp::min(pack, min_pack)\n+                        } else {\n+                            pack\n+                        };\n+                        ReprFlags::empty()\n+                    },\n                     attr::ReprTransparent => ReprFlags::IS_TRANSPARENT,\n                     attr::ReprSimd => ReprFlags::IS_SIMD,\n                     attr::ReprInt(i) => {\n@@ -1685,15 +1693,15 @@ impl ReprOptions {\n         if !tcx.consider_optimizing(|| format!(\"Reorder fields of {:?}\", tcx.item_path_str(did))) {\n             flags.insert(ReprFlags::IS_LINEAR);\n         }\n-        ReprOptions { int: size, align: max_align, flags: flags }\n+        ReprOptions { int: size, align: max_align, pack: min_pack, flags: flags }\n     }\n \n     #[inline]\n     pub fn simd(&self) -> bool { self.flags.contains(ReprFlags::IS_SIMD) }\n     #[inline]\n     pub fn c(&self) -> bool { self.flags.contains(ReprFlags::IS_C) }\n     #[inline]\n-    pub fn packed(&self) -> bool { self.flags.contains(ReprFlags::IS_PACKED) }\n+    pub fn packed(&self) -> bool { self.pack > 0 }\n     #[inline]\n     pub fn transparent(&self) -> bool { self.flags.contains(ReprFlags::IS_TRANSPARENT) }\n     #[inline]\n@@ -1709,6 +1717,12 @@ impl ReprOptions {\n     pub fn inhibit_enum_layout_opt(&self) -> bool {\n         self.c() || self.int.is_some()\n     }\n+\n+    /// Returns true if this `#[repr()]` should inhibit struct field reordering\n+    /// optimizations, such as with repr(C) or repr(packed(1)).\n+    pub fn inhibit_struct_field_reordering_opt(&self) -> bool {\n+        !(self.flags & ReprFlags::IS_UNOPTIMISABLE).is_empty() || (self.pack == 1)\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> AdtDef {"}, {"sha": "a60ba4c6d16669cfb0805d494dd8754b5a5f51ea", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=47778811d9752d9db0d1d4621bbc225317ad216b", "patch": "@@ -1553,8 +1553,19 @@ pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId\n }\n \n fn check_packed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId) {\n-    if tcx.adt_def(def_id).repr.packed() {\n-        if tcx.adt_def(def_id).repr.align > 0 {\n+    let repr = tcx.adt_def(def_id).repr;\n+    if repr.packed() {\n+        for attr in tcx.get_attrs(def_id).iter() {\n+            for r in attr::find_repr_attrs(tcx.sess.diagnostic(), attr) {\n+                if let attr::ReprPacked(pack) = r {\n+                    if pack != repr.pack {\n+                        struct_span_err!(tcx.sess, sp, E0634,\n+                                         \"type has conflicting packed representation hints\").emit();\n+                    }\n+                }\n+            }\n+        }\n+        if repr.align > 0 {\n             struct_span_err!(tcx.sess, sp, E0587,\n                              \"type has conflicting packed and align representation hints\").emit();\n         }"}, {"sha": "5a53c008f6c317d9f518ea3b77c004e2e40ad438", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=47778811d9752d9db0d1d4621bbc225317ad216b", "patch": "@@ -4836,14 +4836,15 @@ register_diagnostics! {\n //  E0563, // cannot determine a type for this `impl Trait`: {} // removed in 6383de15\n     E0564, // only named lifetimes are allowed in `impl Trait`,\n            // but `{}` was found in the type `{}`\n-    E0587, // struct has conflicting packed and align representation hints\n-    E0588, // packed struct cannot transitively contain a `[repr(align)]` struct\n+    E0587, // type has conflicting packed and align representation hints\n+    E0588, // packed type cannot transitively contain a `[repr(align)]` type\n     E0592, // duplicate definitions with name `{}`\n //  E0613, // Removed (merged with E0609)\n     E0640, // infer outlives\n     E0627, // yield statement outside of generator literal\n     E0632, // cannot provide explicit type parameters when `impl Trait` is used in\n            // argument position.\n+    E0634, // type has conflicting packed representaton hints\n     E0641, // cannot cast to/from a pointer with an unknown kind\n     E0645, // trait aliases not finished\n     E0907, // type inside generator must be known in this context"}, {"sha": "c68a743303a277b315536756208488aba62837ee", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 30, "deletions": 16, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=47778811d9752d9db0d1d4621bbc225317ad216b", "patch": "@@ -993,7 +993,7 @@ pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr>\n                     let word = &*mi.ident.name.as_str();\n                     let hint = match word {\n                         \"C\" => Some(ReprC),\n-                        \"packed\" => Some(ReprPacked),\n+                        \"packed\" => Some(ReprPacked(1)),\n                         \"simd\" => Some(ReprSimd),\n                         \"transparent\" => Some(ReprTransparent),\n                         _ => match int_type_of_word(word) {\n@@ -1009,27 +1009,41 @@ pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr>\n                         acc.push(h);\n                     }\n                 } else if let Some((name, value)) = item.name_value_literal() {\n-                    if name == \"align\" {\n-                        recognised = true;\n-                        let mut align_error = None;\n-                        if let ast::LitKind::Int(align, ast::LitIntType::Unsuffixed) = value.node {\n-                            if align.is_power_of_two() {\n+                    let parse_alignment = |node: &ast::LitKind| -> Result<u32, &'static str> {\n+                        if let ast::LitKind::Int(literal, ast::LitIntType::Unsuffixed) = node {\n+                            if literal.is_power_of_two() {\n                                 // rustc::ty::layout::Align restricts align to <= 2147483647\n-                                if align <= 2147483647 {\n-                                    acc.push(ReprAlign(align as u32));\n+                                if *literal <= 2147483647 {\n+                                    Ok(*literal as u32)\n                                 } else {\n-                                    align_error = Some(\"larger than 2147483647\");\n+                                    Err(\"larger than 2147483647\")\n                                 }\n                             } else {\n-                                align_error = Some(\"not a power of two\");\n+                                Err(\"not a power of two\")\n                             }\n                         } else {\n-                            align_error = Some(\"not an unsuffixed integer\");\n-                        }\n-                        if let Some(align_error) = align_error {\n-                            span_err!(diagnostic, item.span, E0589,\n-                                      \"invalid `repr(align)` attribute: {}\", align_error);\n+                            Err(\"not an unsuffixed integer\")\n                         }\n+                    };\n+\n+                    let mut literal_error = None;\n+                    if name == \"align\" {\n+                        recognised = true;\n+                        match parse_alignment(&value.node) {\n+                            Ok(literal) => acc.push(ReprAlign(literal)),\n+                            Err(message) => literal_error = Some(message)\n+                        };\n+                    }\n+                    else if name == \"packed\" {\n+                        recognised = true;\n+                        match parse_alignment(&value.node) {\n+                            Ok(literal) => acc.push(ReprPacked(literal)),\n+                            Err(message) => literal_error = Some(message)\n+                        };\n+                    }\n+                    if let Some(literal_error) = literal_error {\n+                        span_err!(diagnostic, item.span, E0589,\n+                                  \"invalid `repr(align)` attribute: {}\", literal_error);\n                     }\n                 }\n                 if !recognised {\n@@ -1065,7 +1079,7 @@ fn int_type_of_word(s: &str) -> Option<IntType> {\n pub enum ReprAttr {\n     ReprInt(IntType),\n     ReprC,\n-    ReprPacked,\n+    ReprPacked(u32),\n     ReprSimd,\n     ReprTransparent,\n     ReprAlign(u32),"}, {"sha": "df39757d1ebf174478164c96163641e1a98cc62c", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=47778811d9752d9db0d1d4621bbc225317ad216b", "patch": "@@ -432,6 +432,9 @@ declare_features! (\n     // Parentheses in patterns\n     (active, pattern_parentheses, \"1.26.0\", None, None),\n \n+    // Allows `#[repr(packed)]` attribute on structs\n+    (active, repr_packed, \"1.26.0\", Some(33158), None),\n+\n     // `use path as _;` and `extern crate c as _;`\n     (active, underscore_imports, \"1.26.0\", Some(48216), None),\n \n@@ -1439,19 +1442,20 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             }\n         }\n \n-        // allow attr_literals in #[repr(align(x))]\n-        let mut is_repr_align = false;\n+        // allow attr_literals in #[repr(align(x))] and #[repr(packed(n))]\n+        let mut allow_attr_literal = false;\n         if attr.path == \"repr\" {\n             if let Some(content) = attr.meta_item_list() {\n-                is_repr_align = content.iter().any(|c| c.check_name(\"align\"));\n+                allow_attr_literal = content.iter().any(\n+                    |c| c.check_name(\"align\") || c.check_name(\"packed\"));\n             }\n         }\n \n         if self.context.features.proc_macro && attr::is_known(attr) {\n             return\n         }\n \n-        if !is_repr_align {\n+        if !allow_attr_literal {\n             let meta = panictry!(attr.parse_meta(self.context.parse_sess));\n             if contains_novel_literal(&meta) {\n                 gate_feature_post!(&self, attr_literals, attr.span,\n@@ -1535,6 +1539,13 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                                                \"the `#[repr(transparent)]` attribute \\\n                                                is experimental\");\n                         }\n+                        if let Some((name, _)) = item.name_value_literal() {\n+                            if name == \"packed\" {\n+                                gate_feature_post!(&self, repr_packed, attr.span,\n+                                                   \"the `#[repr(packed(n))]` attribute \\\n+                                                   is experimental\");\n+                            }\n+                        }\n                     }\n                 }\n             }"}, {"sha": "66053e037e1b4d18188e54a5ed114a381f054d4e", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=47778811d9752d9db0d1d4621bbc225317ad216b", "patch": "@@ -413,8 +413,12 @@ impl<'a> TraitDef<'a> {\n         match *item {\n             Annotatable::Item(ref item) => {\n                 let is_packed = item.attrs.iter().any(|attr| {\n-                    attr::find_repr_attrs(&cx.parse_sess.span_diagnostic, attr)\n-                        .contains(&attr::ReprPacked)\n+                    for r in attr::find_repr_attrs(&cx.parse_sess.span_diagnostic, attr) {\n+                        if let attr::ReprPacked(_) = r {\n+                            return true;\n+                        }\n+                    }\n+                    false\n                 });\n                 let has_no_type_params = match item.node {\n                     ast::ItemKind::Struct(_, ref generics) |\n@@ -831,7 +835,7 @@ fn find_repr_type_name(diagnostic: &Handler, type_attrs: &[ast::Attribute]) -> &\n     for a in type_attrs {\n         for r in &attr::find_repr_attrs(diagnostic, a) {\n             repr_type_name = match *r {\n-                attr::ReprPacked | attr::ReprSimd | attr::ReprAlign(_) | attr::ReprTransparent =>\n+                attr::ReprPacked(_) | attr::ReprSimd | attr::ReprAlign(_) | attr::ReprTransparent =>\n                     continue,\n \n                 attr::ReprC => \"i32\","}, {"sha": "0693eae7d7884f443698839d13da5d75e75a695f", "filename": "src/test/codegen/packed.rs", "status": "modified", "additions": 71, "deletions": 13, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Fcodegen%2Fpacked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Fcodegen%2Fpacked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fpacked.rs?ref=47778811d9752d9db0d1d4621bbc225317ad216b", "patch": "@@ -11,60 +11,118 @@\n // compile-flags: -C no-prepopulate-passes\n \n #![crate_type = \"lib\"]\n+#![feature(repr_packed)]\n \n #[repr(packed)]\n-pub struct Packed {\n+pub struct Packed1 {\n     dealign: u8,\n     data: u32\n }\n \n-// CHECK-LABEL: @write_pkd\n+#[repr(packed(2))]\n+pub struct Packed2 {\n+    dealign: u8,\n+    data: u32\n+}\n+\n+// CHECK-LABEL: @write_pkd1\n #[no_mangle]\n-pub fn write_pkd(pkd: &mut Packed) -> u32 {\n+pub fn write_pkd1(pkd: &mut Packed1) -> u32 {\n // CHECK: %{{.*}} = load i32, i32* %{{.*}}, align 1\n // CHECK: store i32 42, i32* %{{.*}}, align 1\n     let result = pkd.data;\n     pkd.data = 42;\n     result\n }\n \n+// CHECK-LABEL: @write_pkd2\n+#[no_mangle]\n+pub fn write_pkd2(pkd: &mut Packed2) -> u32 {\n+// CHECK: %{{.*}} = load i32, i32* %{{.*}}, align 2\n+// CHECK: store i32 42, i32* %{{.*}}, align 2\n+    let result = pkd.data;\n+    pkd.data = 42;\n+    result\n+}\n+\n pub struct Array([i32; 8]);\n #[repr(packed)]\n-pub struct BigPacked {\n+pub struct BigPacked1 {\n+    dealign: u8,\n+    data: Array\n+}\n+\n+#[repr(packed(2))]\n+pub struct BigPacked2 {\n     dealign: u8,\n     data: Array\n }\n \n-// CHECK-LABEL: @call_pkd\n+// CHECK-LABEL: @call_pkd1\n #[no_mangle]\n-pub fn call_pkd(f: fn() -> Array) -> BigPacked {\n+pub fn call_pkd1(f: fn() -> Array) -> BigPacked1 {\n // CHECK: [[ALLOCA:%[_a-z0-9]+]] = alloca %Array\n // CHECK: call void %{{.*}}(%Array* noalias nocapture sret dereferenceable(32) [[ALLOCA]])\n // CHECK: call void @llvm.memcpy.{{.*}}(i8* %{{.*}}, i8* %{{.*}}, i{{[0-9]+}} 32, i32 1, i1 false)\n     // check that calls whose destination is a field of a packed struct\n     // go through an alloca rather than calling the function with an\n     // unaligned destination.\n-    BigPacked { dealign: 0, data: f() }\n+    BigPacked1 { dealign: 0, data: f() }\n+}\n+\n+// CHECK-LABEL: @call_pkd2\n+#[no_mangle]\n+pub fn call_pkd2(f: fn() -> Array) -> BigPacked2 {\n+// CHECK: [[ALLOCA:%[_a-z0-9]+]] = alloca %Array\n+// CHECK: call void %{{.*}}(%Array* noalias nocapture sret dereferenceable(32) [[ALLOCA]])\n+// CHECK: call void @llvm.memcpy.{{.*}}(i8* %{{.*}}, i8* %{{.*}}, i{{[0-9]+}} 32, i32 2, i1 false)\n+    // check that calls whose destination is a field of a packed struct\n+    // go through an alloca rather than calling the function with an\n+    // unaligned destination.\n+    BigPacked2 { dealign: 0, data: f() }\n }\n \n #[repr(packed)]\n #[derive(Copy, Clone)]\n-pub struct PackedPair(u8, u32);\n+pub struct Packed1Pair(u8, u32);\n \n-// CHECK-LABEL: @pkd_pair\n+#[repr(packed(2))]\n+#[derive(Copy, Clone)]\n+pub struct Packed2Pair(u8, u32);\n+\n+// CHECK-LABEL: @pkd1_pair\n #[no_mangle]\n-pub fn pkd_pair(pair1: &mut PackedPair, pair2: &mut PackedPair) {\n+pub fn pkd1_pair(pair1: &mut Packed1Pair, pair2: &mut Packed1Pair) {\n // CHECK: call void @llvm.memcpy.{{.*}}(i8* %{{.*}}, i8* %{{.*}}, i{{[0-9]+}} 5, i32 1, i1 false)\n     *pair2 = *pair1;\n }\n \n+// CHECK-LABEL: @pkd2_pair\n+#[no_mangle]\n+pub fn pkd2_pair(pair1: &mut Packed2Pair, pair2: &mut Packed2Pair) {\n+// CHECK: call void @llvm.memcpy.{{.*}}(i8* %{{.*}}, i8* %{{.*}}, i{{[0-9]+}} 6, i32 2, i1 false)\n+    *pair2 = *pair1;\n+}\n+\n #[repr(packed)]\n #[derive(Copy, Clone)]\n-pub struct PackedNestedPair((u32, u32));\n+pub struct Packed1NestedPair((u32, u32));\n+\n+#[repr(packed(2))]\n+#[derive(Copy, Clone)]\n+pub struct Packed2NestedPair((u32, u32));\n \n-// CHECK-LABEL: @pkd_nested_pair\n+// CHECK-LABEL: @pkd1_nested_pair\n #[no_mangle]\n-pub fn pkd_nested_pair(pair1: &mut PackedNestedPair, pair2: &mut PackedNestedPair) {\n+pub fn pkd1_nested_pair(pair1: &mut Packed1NestedPair, pair2: &mut Packed1NestedPair) {\n // CHECK: call void @llvm.memcpy.{{.*}}(i8* %{{.*}}, i8* %{{.*}}, i{{[0-9]+}} 8, i32 1, i1 false)\n     *pair2 = *pair1;\n }\n+\n+// CHECK-LABEL: @pkd2_nested_pair\n+#[no_mangle]\n+pub fn pkd2_nested_pair(pair1: &mut Packed2NestedPair, pair2: &mut Packed2NestedPair) {\n+// CHECK: call void @llvm.memcpy.{{.*}}(i8* %{{.*}}, i8* %{{.*}}, i{{[0-9]+}} 8, i32 2, i1 false)\n+    *pair2 = *pair1;\n+}\n+"}, {"sha": "426f60c6b098c5c4d9c9c2720ffc26826a3b2032", "filename": "src/test/compile-fail/conflicting-repr-hints.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Fcompile-fail%2Fconflicting-repr-hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Fcompile-fail%2Fconflicting-repr-hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconflicting-repr-hints.rs?ref=47778811d9752d9db0d1d4621bbc225317ad216b", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![allow(dead_code)]\n+#![feature(repr_packed)]\n \n #[repr(C)]\n enum A { A }\n@@ -36,6 +37,16 @@ struct G(i32); //~ ERROR type has conflicting packed and align representation hi\n #[repr(packed)]\n struct H(i32); //~ ERROR type has conflicting packed and align representation hints\n \n+#[repr(packed, packed(2))]\n+struct I(i32); //~ ERROR type has conflicting packed representation hints\n+\n+#[repr(packed(2))]\n+#[repr(packed)]\n+struct J(i32); //~ ERROR type has conflicting packed representation hints\n+\n+#[repr(packed, packed(1))]\n+struct K(i32);\n+\n #[repr(packed, align(8))]\n union X { //~ ERROR type has conflicting packed and align representation hints\n     i: i32"}, {"sha": "2b6a151574ad9abaf3f2c1c7d5562a1f9f84846a", "filename": "src/test/run-pass/align-struct.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Frun-pass%2Falign-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Frun-pass%2Falign-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falign-struct.rs?ref=47778811d9752d9db0d1d4621bbc225317ad216b", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n #![feature(box_syntax)]\n+#![feature(repr_packed)]\n \n use std::mem;\n \n@@ -60,6 +61,18 @@ struct AlignContainsPacked {\n     b: Packed,\n }\n \n+#[repr(C, packed(4))]\n+struct Packed4C {\n+    a: u32,\n+    b: u64,\n+}\n+\n+#[repr(align(16))]\n+struct AlignContainsPacked4C {\n+    a: Packed4C,\n+    b: u64,\n+}\n+\n // The align limit was originally smaller (2^15).\n // Check that it works with big numbers.\n #[repr(align(0x10000))]\n@@ -218,6 +231,15 @@ pub fn main() {\n     assert_eq!(mem::size_of_val(&a), 16);\n     assert!(is_aligned_to(&a, 16));\n \n+    assert_eq!(mem::align_of::<AlignContainsPacked4C>(), 16);\n+    assert_eq!(mem::size_of::<AlignContainsPacked4C>(), 32);\n+    let a = AlignContainsPacked4C { a: Packed4C{ a: 1, b: 2 }, b: 3 };\n+    assert_eq!(mem::align_of_val(&a), 16);\n+    assert_eq!(mem::align_of_val(&a.a), 4);\n+    assert_eq!(mem::align_of_val(&a.b), mem::align_of::<u64>());\n+    assert_eq!(mem::size_of_val(&a), 32);\n+    assert!(is_aligned_to(&a, 16));\n+\n     let mut large = box AlignLarge {\n         stuff: [0; 0x10000],\n     };"}, {"sha": "828be41cd41576ce2fcdbf42506de2bda9974d85", "filename": "src/test/run-pass/auxiliary/packed.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Frun-pass%2Fauxiliary%2Fpacked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Frun-pass%2Fauxiliary%2Fpacked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fpacked.rs?ref=47778811d9752d9db0d1d4621bbc225317ad216b", "patch": "@@ -8,8 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(repr_packed)]\n+\n #[repr(packed)]\n-pub struct S {\n+pub struct P1S5 {\n     a: u8,\n     b: u32\n }\n+\n+#[repr(packed(2))]\n+pub struct P2S6 {\n+    a: u8,\n+    b: u32,\n+    c: u8\n+}\n+\n+#[repr(C, packed(2))]\n+pub struct P2CS8 {\n+    a: u8,\n+    b: u32,\n+    c: u8\n+}"}, {"sha": "ce4585607e9b1096fa0ae3308bc7216544f9ef6f", "filename": "src/test/run-pass/issue-48159.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Frun-pass%2Fissue-48159.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Frun-pass%2Fissue-48159.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-48159.rs?ref=47778811d9752d9db0d1d4621bbc225317ad216b", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(repr_packed)]\n+#![allow(non_camel_case_types)]\n+\n+use std::mem;\n+\n+pub enum c_void {}\n+\n+type uintptr_t = usize;\n+type int16_t = u16;\n+type uint16_t = int16_t;\n+type uint32_t = u32;\n+type intptr_t = uintptr_t;\n+\n+#[repr(C)]\n+#[repr(packed(4))]\n+pub struct kevent {\n+    pub ident: uintptr_t,\n+    pub filter: int16_t,\n+    pub flags: uint16_t,\n+    pub fflags: uint32_t,\n+    pub data: intptr_t,\n+    pub udata: *mut c_void,\n+}\n+\n+fn main() {\n+    assert_eq!(mem::align_of::<kevent>(), 4);\n+}"}, {"sha": "c8a8643ed6b98f069faf46780e28105bf387025b", "filename": "src/test/run-pass/packed-struct-borrow-element.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Frun-pass%2Fpacked-struct-borrow-element.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Frun-pass%2Fpacked-struct-borrow-element.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-borrow-element.rs?ref=47778811d9752d9db0d1d4621bbc225317ad216b", "patch": "@@ -10,15 +10,36 @@\n \n // ignore-emscripten weird assertion?\n \n+#![feature(repr_packed)]\n+\n #[repr(packed)]\n-struct Foo {\n+struct Foo1 {\n+    bar: u8,\n+    baz: usize\n+}\n+\n+#[repr(packed(2))]\n+struct Foo2 {\n+    bar: u8,\n+    baz: usize\n+}\n+\n+#[repr(C, packed(4))]\n+struct Foo4C {\n     bar: u8,\n     baz: usize\n }\n \n pub fn main() {\n-    let foo = Foo { bar: 1, baz: 2 };\n+    let foo = Foo1 { bar: 1, baz: 2 };\n     let brw = unsafe { &foo.baz };\n+    assert_eq!(*brw, 2);\n \n+    let foo = Foo2 { bar: 1, baz: 2 };\n+    let brw = unsafe { &foo.baz };\n+    assert_eq!(*brw, 2);\n+\n+    let foo = Foo4C { bar: 1, baz: 2 };\n+    let brw = unsafe { &foo.baz };\n     assert_eq!(*brw, 2);\n }"}, {"sha": "127d873b2d97ab94ba6392876e37e64c583099cf", "filename": "src/test/run-pass/packed-struct-generic-size.rs", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-size.rs?ref=47778811d9752d9db0d1d4621bbc225317ad216b", "patch": "@@ -8,18 +8,45 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(repr_packed)]\n \n use std::mem;\n \n #[repr(packed)]\n-struct S<T, S> {\n+struct P1<T, S> {\n     a: T,\n     b: u8,\n     c: S\n }\n \n+#[repr(packed(2))]\n+struct P2<T, S> {\n+    a: T,\n+    b: u8,\n+    c: S\n+}\n+\n+#[repr(C, packed(4))]\n+struct P4C<T, S> {\n+    a: T,\n+    b: u8,\n+    c: S\n+}\n+\n+macro_rules! check {\n+    ($t:ty, $align:expr, $size:expr) => ({\n+        assert_eq!(mem::align_of::<$t>(), $align);\n+        assert_eq!(mem::size_of::<$t>(), $size);\n+    });\n+}\n+\n pub fn main() {\n-    assert_eq!(mem::size_of::<S<u8, u8>>(), 3);\n+    check!(P1::<u8, u8>, 1, 3);\n+    check!(P1::<u64, u16>, 1, 11);\n+\n+    check!(P2::<u8, u8>, 1, 3);\n+    check!(P2::<u64, u16>, 2, 12);\n \n-    assert_eq!(mem::size_of::<S<u64, u16>>(), 11);\n+    check!(P4C::<u8, u8>, 1, 3);\n+    check!(P4C::<u16, u64>, 4, 12);\n }"}, {"sha": "c02d524d763d3937203a1e942dc052749913bd30", "filename": "src/test/run-pass/packed-struct-match.rs", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Frun-pass%2Fpacked-struct-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Frun-pass%2Fpacked-struct-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-match.rs?ref=47778811d9752d9db0d1d4621bbc225317ad216b", "patch": "@@ -8,17 +8,46 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(repr_packed)]\n \n #[repr(packed)]\n-struct Foo {\n+struct Foo1 {\n+    bar: u8,\n+    baz: usize\n+}\n+\n+#[repr(packed(2))]\n+struct Foo2 {\n+    bar: u8,\n+    baz: usize\n+}\n+\n+#[repr(C, packed(4))]\n+struct Foo4C {\n     bar: u8,\n     baz: usize\n }\n \n pub fn main() {\n-    let foo = Foo { bar: 1, baz: 2 };\n-    match foo {\n-        Foo {bar, baz} => {\n+    let foo1 = Foo1 { bar: 1, baz: 2 };\n+    match foo1 {\n+        Foo1 {bar, baz} => {\n+            assert_eq!(bar, 1);\n+            assert_eq!(baz, 2);\n+        }\n+    }\n+\n+    let foo2 = Foo2 { bar: 1, baz: 2 };\n+    match foo2 {\n+        Foo2 {bar, baz} => {\n+            assert_eq!(bar, 1);\n+            assert_eq!(baz, 2);\n+        }\n+    }\n+\n+    let foo4 = Foo4C { bar: 1, baz: 2 };\n+    match foo4 {\n+        Foo4C {bar, baz} => {\n             assert_eq!(bar, 1);\n             assert_eq!(baz, 2);\n         }"}, {"sha": "48f34554ca1429c9a0dd5bb5e3abc7a689c0288c", "filename": "src/test/run-pass/packed-struct-size-xc.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Frun-pass%2Fpacked-struct-size-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Frun-pass%2Fpacked-struct-size-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-size-xc.rs?ref=47778811d9752d9db0d1d4621bbc225317ad216b", "patch": "@@ -15,6 +15,15 @@ extern crate packed;\n \n use std::mem;\n \n+macro_rules! check {\n+    ($t:ty, $align:expr, $size:expr) => ({\n+        assert_eq!(mem::align_of::<$t>(), $align);\n+        assert_eq!(mem::size_of::<$t>(), $size);\n+    });\n+}\n+\n pub fn main() {\n-    assert_eq!(mem::size_of::<packed::S>(), 5);\n+    check!(packed::P1S5, 1, 5);\n+    check!(packed::P2S6, 2, 6);\n+    check!(packed::P2CS8, 2, 8);\n }"}, {"sha": "f8e23610fe2302d55fe9486b148728d01bddb26e", "filename": "src/test/run-pass/packed-struct-size.rs", "status": "modified", "additions": 112, "deletions": 14, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Frun-pass%2Fpacked-struct-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Frun-pass%2Fpacked-struct-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-size.rs?ref=47778811d9752d9db0d1d4621bbc225317ad216b", "patch": "@@ -7,60 +7,158 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-\n+#![feature(repr_packed)]\n \n \n use std::mem;\n \n #[repr(packed)]\n-struct S4 {\n+struct P1S4 {\n+    a: u8,\n+    b: [u8;  3],\n+}\n+\n+#[repr(packed(2))]\n+struct P2S4 {\n     a: u8,\n     b: [u8;  3],\n }\n \n #[repr(packed)]\n-struct S5 {\n+struct P1S5 {\n+    a: u8,\n+    b: u32\n+}\n+\n+#[repr(packed(2))]\n+struct P2S2 {\n+    a: u8,\n+    b: u8\n+}\n+\n+#[repr(packed(2))]\n+struct P2S6 {\n     a: u8,\n     b: u32\n }\n \n+#[repr(packed(2))]\n+struct P2S12 {\n+    a: u32,\n+    b: u64\n+}\n+\n #[repr(packed)]\n-struct S13 {\n+struct P1S13 {\n     a: i64,\n     b: f32,\n     c: u8,\n }\n \n+#[repr(packed(2))]\n+struct P2S14 {\n+    a: i64,\n+    b: f32,\n+    c: u8,\n+}\n+\n+#[repr(packed(4))]\n+struct P4S16 {\n+    a: u8,\n+    b: f32,\n+    c: i64,\n+    d: u16,\n+}\n+\n+#[repr(C, packed(4))]\n+struct P4CS20 {\n+    a: u8,\n+    b: f32,\n+    c: i64,\n+    d: u16,\n+}\n+\n enum Foo {\n     Bar = 1,\n     Baz = 2\n }\n \n #[repr(packed)]\n-struct S3_Foo {\n+struct P1S3_Foo {\n+    a: u8,\n+    b: u16,\n+    c: Foo\n+}\n+\n+#[repr(packed(2))]\n+struct P2_Foo {\n+    a: Foo,\n+}\n+\n+#[repr(packed(2))]\n+struct P2S3_Foo {\n     a: u8,\n     b: u16,\n     c: Foo\n }\n \n #[repr(packed)]\n-struct S7_Option {\n+struct P1S7_Option {\n+    a: f32,\n+    b: u8,\n+    c: u16,\n+    d: Option<Box<f64>>\n+}\n+\n+#[repr(packed(2))]\n+struct P2_Option {\n+    a: Option<Box<f64>>\n+}\n+\n+#[repr(packed(2))]\n+struct P2S7_Option {\n     a: f32,\n     b: u8,\n     c: u16,\n     d: Option<Box<f64>>\n }\n \n // Placing packed structs in statics should work\n-static TEST_S4: S4 = S4 { a: 1, b: [2, 3, 4] };\n-static TEST_S5: S5 = S5 { a: 3, b: 67 };\n-static TEST_S3_Foo: S3_Foo = S3_Foo { a: 1, b: 2, c: Foo::Baz };\n+static TEST_P1S4: P1S4 = P1S4 { a: 1, b: [2, 3, 4] };\n+static TEST_P1S5: P1S5 = P1S5 { a: 3, b: 67 };\n+static TEST_P1S3_Foo: P1S3_Foo = P1S3_Foo { a: 1, b: 2, c: Foo::Baz };\n+static TEST_P2S2: P2S2 = P2S2 { a: 1, b: 2 };\n+static TEST_P2S4: P2S4 = P2S4 { a: 1, b: [2, 3, 4] };\n+static TEST_P2S6: P2S6 = P2S6 { a: 1, b: 2 };\n+static TEST_P2S12: P2S12 = P2S12 { a: 1, b: 2 };\n+static TEST_P4S16: P4S16 = P4S16 { a: 1, b: 2.0, c: 3, d: 4 };\n+static TEST_P4CS20: P4CS20 = P4CS20 { a: 1, b: 2.0, c: 3, d: 4 };\n \n+fn align_to(value: usize, align: usize) -> usize {\n+    (value + (align - 1)) & !(align - 1)\n+}\n+\n+macro_rules! check {\n+    ($t:ty, $align:expr, $size:expr) => ({\n+        assert_eq!(mem::align_of::<$t>(), $align);\n+        assert_eq!(mem::size_of::<$t>(), $size);\n+    });\n+}\n \n pub fn main() {\n-    assert_eq!(mem::size_of::<S4>(), 4);\n-    assert_eq!(mem::size_of::<S5>(), 5);\n-    assert_eq!(mem::size_of::<S13>(), 13);\n-    assert_eq!(mem::size_of::<S3_Foo>(), 3 + mem::size_of::<Foo>());\n-    assert_eq!(mem::size_of::<S7_Option>(), 7 + mem::size_of::<Option<Box<f64>>>());\n+    check!(P1S4, 1, 4);\n+    check!(P1S5, 1, 5);\n+    check!(P1S13, 1, 13);\n+    check!(P1S3_Foo, 1, 3 + mem::size_of::<Foo>());\n+    check!(P1S7_Option, 1, 7 + mem::size_of::<Option<Box<f64>>>());\n+\n+    check!(P2S2, 1, 2);\n+    check!(P2S4, 1, 4);\n+    check!(P2S6, 2, 6);\n+    check!(P2S12, 2, 12);\n+    check!(P2S14, 2, 14);\n+    check!(P4S16, 4, 16);\n+    check!(P4CS20, 4, 20);\n+    check!(P2S3_Foo, 2, align_to(3 + mem::size_of::<P2_Foo>(), 2));\n+    check!(P2S7_Option, 2, align_to(7 + mem::size_of::<P2_Option>(), 2));\n }"}, {"sha": "9d8b3d0d07412a5a36a1ba0f5041976ec8210990", "filename": "src/test/run-pass/packed-struct-vec.rs", "status": "modified", "additions": 89, "deletions": 10, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs?ref=47778811d9752d9db0d1d4621bbc225317ad216b", "patch": "@@ -8,44 +8,123 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(repr_packed)]\n+\n use std::fmt;\n use std::mem;\n \n #[repr(packed)]\n #[derive(Copy, Clone)]\n-struct Foo {\n+struct Foo1 {\n     bar: u8,\n     baz: u64\n }\n \n-impl PartialEq for Foo {\n-    fn eq(&self, other: &Foo) -> bool {\n+impl PartialEq for Foo1 {\n+    fn eq(&self, other: &Foo1) -> bool {\n         self.bar == other.bar && self.baz == other.baz\n     }\n }\n \n-impl fmt::Debug for Foo {\n+impl fmt::Debug for Foo1 {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let bar = self.bar;\n         let baz = self.baz;\n \n-        f.debug_struct(\"Foo\")\n+        f.debug_struct(\"Foo1\")\n+            .field(\"bar\", &bar)\n+            .field(\"baz\", &baz)\n+            .finish()\n+    }\n+}\n+\n+#[repr(packed(2))]\n+#[derive(Copy, Clone)]\n+struct Foo2 {\n+    bar: u8,\n+    baz: u64\n+}\n+\n+impl PartialEq for Foo2 {\n+    fn eq(&self, other: &Foo2) -> bool {\n+        self.bar == other.bar && self.baz == other.baz\n+    }\n+}\n+\n+impl fmt::Debug for Foo2 {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let bar = self.bar;\n+        let baz = self.baz;\n+\n+        f.debug_struct(\"Foo2\")\n+            .field(\"bar\", &bar)\n+            .field(\"baz\", &baz)\n+            .finish()\n+    }\n+}\n+\n+#[repr(C, packed(4))]\n+#[derive(Copy, Clone)]\n+struct Foo4C {\n+    bar: u8,\n+    baz: u64\n+}\n+\n+impl PartialEq for Foo4C {\n+    fn eq(&self, other: &Foo4C) -> bool {\n+        self.bar == other.bar && self.baz == other.baz\n+    }\n+}\n+\n+impl fmt::Debug for Foo4C {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let bar = self.bar;\n+        let baz = self.baz;\n+\n+        f.debug_struct(\"Foo4C\")\n             .field(\"bar\", &bar)\n             .field(\"baz\", &baz)\n             .finish()\n     }\n }\n \n pub fn main() {\n-    let foos = [Foo { bar: 1, baz: 2 }; 10];\n+    let foo1s = [Foo1 { bar: 1, baz: 2 }; 10];\n+\n+    assert_eq!(mem::align_of::<[Foo1; 10]>(), 1);\n+    assert_eq!(mem::size_of::<[Foo1; 10]>(), 90);\n+\n+    for i in 0..10 {\n+        assert_eq!(foo1s[i], Foo1 { bar: 1, baz: 2});\n+    }\n+\n+    for &foo in &foo1s {\n+        assert_eq!(foo, Foo1 { bar: 1, baz: 2 });\n+    }\n+\n+    let foo2s = [Foo2 { bar: 1, baz: 2 }; 10];\n+\n+    assert_eq!(mem::align_of::<[Foo2; 10]>(), 2);\n+    assert_eq!(mem::size_of::<[Foo2; 10]>(), 100);\n+\n+    for i in 0..10 {\n+        assert_eq!(foo2s[i], Foo2 { bar: 1, baz: 2});\n+    }\n+\n+    for &foo in &foo2s {\n+        assert_eq!(foo, Foo2 { bar: 1, baz: 2 });\n+    }\n+\n+    let foo4s = [Foo4C { bar: 1, baz: 2 }; 10];\n \n-    assert_eq!(mem::size_of::<[Foo; 10]>(), 90);\n+    assert_eq!(mem::align_of::<[Foo4C; 10]>(), 4);\n+    assert_eq!(mem::size_of::<[Foo4C; 10]>(), 120);\n \n     for i in 0..10 {\n-        assert_eq!(foos[i], Foo { bar: 1, baz: 2});\n+        assert_eq!(foo4s[i], Foo4C { bar: 1, baz: 2});\n     }\n \n-    for &foo in &foos {\n-        assert_eq!(foo, Foo { bar: 1, baz: 2 });\n+    for &foo in &foo4s {\n+        assert_eq!(foo, Foo4C { bar: 1, baz: 2 });\n     }\n }"}, {"sha": "9def6ac28e552de90171eabf8209bdb34bb51403", "filename": "src/test/run-pass/packed-tuple-struct-size.rs", "status": "modified", "additions": 54, "deletions": 14, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-size.rs?ref=47778811d9752d9db0d1d4621bbc225317ad216b", "patch": "@@ -8,40 +8,80 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+#![feature(repr_packed)]\n \n use std::mem;\n \n #[repr(packed)]\n-struct S4(u8,[u8;  3]);\n+struct P1S4(u8,[u8;  3]);\n+\n+#[repr(packed(2))]\n+struct P2S4(u8,[u8;  3]);\n \n #[repr(packed)]\n-struct S5(u8, u32);\n+struct P1S5(u8, u32);\n+\n+#[repr(packed(2))]\n+struct P2S6(u8, u32);\n \n #[repr(packed)]\n-struct S13(i64, f32, u8);\n+struct P1S13(i64, f32, u8);\n+\n+#[repr(packed(2))]\n+struct P2S14(i64, f32, u8);\n+\n+#[repr(packed(4))]\n+struct P4S16(u8, f32, i64, u16);\n+\n+#[repr(C, packed(4))]\n+struct P4CS20(u8, f32, i64, u16);\n \n enum Foo {\n     Bar = 1,\n     Baz = 2\n }\n \n #[repr(packed)]\n-struct S3_Foo(u8, u16, Foo);\n+struct P1S3_Foo(u8, u16, Foo);\n+\n+#[repr(packed(2))]\n+struct P2_Foo(Foo);\n+\n+#[repr(packed(2))]\n+struct P2S3_Foo(u8, u16, Foo);\n \n #[repr(packed)]\n-struct S7_Option(f32, u8, u16, Option<Box<f64>>);\n+struct P1S7_Option(f32, u8, u16, Option<Box<f64>>);\n \n-pub fn main() {\n-    assert_eq!(mem::size_of::<S4>(), 4);\n+#[repr(packed(2))]\n+struct P2_Option(Option<Box<f64>>);\n+\n+#[repr(packed(2))]\n+struct P2S7_Option(f32, u8, u16, Option<Box<f64>>);\n \n-    assert_eq!(mem::size_of::<S5>(), 5);\n+fn align_to(value: usize, align: usize) -> usize {\n+    (value + (align - 1)) & !(align - 1)\n+}\n \n-    assert_eq!(mem::size_of::<S13>(), 13);\n+macro_rules! check {\n+    ($t:ty, $align:expr, $size:expr) => ({\n+        assert_eq!(mem::align_of::<$t>(), $align);\n+        assert_eq!(mem::size_of::<$t>(), $size);\n+    });\n+}\n \n-    assert_eq!(mem::size_of::<S3_Foo>(),\n-               3 + mem::size_of::<Foo>());\n+pub fn main() {\n+    check!(P1S4, 1, 4);\n+    check!(P1S5, 1, 5);\n+    check!(P1S13, 1, 13);\n+    check!(P1S3_Foo, 1, 3 + mem::size_of::<Foo>());\n+    check!(P1S7_Option, 1, 7 + mem::size_of::<Option<Box<f64>>>());\n \n-    assert_eq!(mem::size_of::<S7_Option>(),\n-              7 + mem::size_of::<Option<Box<f64>>>());\n+    check!(P2S4, 1, 4);\n+    check!(P2S6, 2, 6);\n+    check!(P2S14, 2, 14);\n+    check!(P4S16, 4, 16);\n+    check!(P4CS20, 4, 20);\n+    check!(P2S3_Foo, 2, align_to(3 + mem::size_of::<P2_Foo>(), 2));\n+    check!(P2S7_Option, 2, align_to(7 + mem::size_of::<P2_Option>(), 2));\n }"}, {"sha": "61bb04fece0952ce42dbef7808971997ed3e3ed4", "filename": "src/test/run-pass/union/union-packed.rs", "status": "modified", "additions": 93, "deletions": 19, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Frun-pass%2Funion%2Funion-packed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Frun-pass%2Funion%2Funion-packed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-packed.rs?ref=47778811d9752d9db0d1d4621bbc225317ad216b", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![feature(untagged_unions)]\n+#![feature(repr_packed)]\n \n use std::mem::{size_of, size_of_val, align_of, align_of_val};\n \n@@ -18,7 +19,13 @@ struct S {\n }\n \n #[repr(packed)]\n-struct Sp {\n+struct Sp1 {\n+    a: u16,\n+    b: [u8; 3],\n+}\n+\n+#[repr(packed(2))]\n+struct Sp2 {\n     a: u16,\n     b: [u8; 3],\n }\n@@ -29,15 +36,30 @@ union U {\n }\n \n #[repr(packed)]\n-union Up {\n+union Up1 {\n+    a: u16,\n+    b: [u8; 3],\n+}\n+\n+#[repr(packed(2))]\n+union Up2 {\n+    a: u16,\n+    b: [u8; 3],\n+}\n+\n+#[repr(C, packed(4))]\n+union Up4c {\n     a: u16,\n     b: [u8; 3],\n }\n \n const CS: S = S { a: 0, b: [0, 0, 0] };\n-const CSP: Sp = Sp { a: 0, b: [0, 0, 0] };\n+const CSP1: Sp1 = Sp1 { a: 0, b: [0, 0, 0] };\n+const CSP2: Sp2 = Sp2 { a: 0, b: [0, 0, 0] };\n const CU: U = U { b: [0, 0, 0] };\n-const CUP: Up = Up { b: [0, 0, 0] };\n+const CUP1: Up1 = Up1 { b: [0, 0, 0] };\n+const CUP2: Up2 = Up2 { b: [0, 0, 0] };\n+const CUP4C: Up4c = Up4c { b: [0, 0, 0] };\n \n fn main() {\n     let s = S { a: 0, b: [0, 0, 0] };\n@@ -48,13 +70,21 @@ fn main() {\n     assert_eq!(align_of_val(&s), 2);\n     assert_eq!(align_of_val(&CS), 2);\n \n-    let sp = Sp { a: 0, b: [0, 0, 0] };\n-    assert_eq!(size_of::<Sp>(), 5);\n-    assert_eq!(size_of_val(&sp), 5);\n-    assert_eq!(size_of_val(&CSP), 5);\n-    assert_eq!(align_of::<Sp>(), 1);\n-    assert_eq!(align_of_val(&sp), 1);\n-    assert_eq!(align_of_val(&CSP), 1);\n+    let sp1 = Sp1 { a: 0, b: [0, 0, 0] };\n+    assert_eq!(size_of::<Sp1>(), 5);\n+    assert_eq!(size_of_val(&sp1), 5);\n+    assert_eq!(size_of_val(&CSP1), 5);\n+    assert_eq!(align_of::<Sp1>(), 1);\n+    assert_eq!(align_of_val(&sp1), 1);\n+    assert_eq!(align_of_val(&CSP1), 1);\n+\n+    let sp2 = Sp2 { a: 0, b: [0, 0, 0] };\n+    assert_eq!(size_of::<Sp2>(), 6);\n+    assert_eq!(size_of_val(&sp2), 6);\n+    assert_eq!(size_of_val(&CSP2), 6);\n+    assert_eq!(align_of::<Sp2>(), 2);\n+    assert_eq!(align_of_val(&sp2), 2);\n+    assert_eq!(align_of_val(&CSP2), 2);\n \n     let u = U { b: [0, 0, 0] };\n     assert_eq!(size_of::<U>(), 4);\n@@ -64,19 +94,35 @@ fn main() {\n     assert_eq!(align_of_val(&u), 2);\n     assert_eq!(align_of_val(&CU), 2);\n \n-    let up = Up { b: [0, 0, 0] };\n-    assert_eq!(size_of::<Up>(), 3);\n-    assert_eq!(size_of_val(&up), 3);\n-    assert_eq!(size_of_val(&CUP), 3);\n-    assert_eq!(align_of::<Up>(), 1);\n-    assert_eq!(align_of_val(&up), 1);\n-    assert_eq!(align_of_val(&CUP), 1);\n+    let Up1 = Up1 { b: [0, 0, 0] };\n+    assert_eq!(size_of::<Up1>(), 3);\n+    assert_eq!(size_of_val(&Up1), 3);\n+    assert_eq!(size_of_val(&CUP1), 3);\n+    assert_eq!(align_of::<Up1>(), 1);\n+    assert_eq!(align_of_val(&Up1), 1);\n+    assert_eq!(align_of_val(&CUP1), 1);\n+\n+    let up2 = Up2 { b: [0, 0, 0] };\n+    assert_eq!(size_of::<Up2>(), 4);\n+    assert_eq!(size_of_val(&up2), 4);\n+    assert_eq!(size_of_val(&CUP2), 4);\n+    assert_eq!(align_of::<Up2>(), 2);\n+    assert_eq!(align_of_val(&up2), 2);\n+    assert_eq!(align_of_val(&CUP2), 2);\n+\n+    let up4c = Up4c { b: [0, 0, 0] };\n+    assert_eq!(size_of::<Up4c>(), 4);\n+    assert_eq!(size_of_val(&up4c), 4);\n+    assert_eq!(size_of_val(&CUP4C), 4);\n+    assert_eq!(align_of::<Up4c>(), 2);\n+    assert_eq!(align_of_val(&up4c), 2);\n+    assert_eq!(align_of_val(&CUP4C), 2);\n \n     hybrid::check_hybrid();\n }\n \n mod hybrid {\n-    use std::mem::size_of;\n+    use std::mem::{size_of, align_of};\n \n     #[repr(packed)]\n     struct S1 {\n@@ -96,9 +142,37 @@ mod hybrid {\n         u: U,\n     }\n \n+    #[repr(C, packed(2))]\n+    struct S1C {\n+        a: u16,\n+        b: u8,\n+    }\n+\n+    #[repr(C, packed(2))]\n+    union UC {\n+        s: S1,\n+        c: u16,\n+    }\n+\n+    #[repr(C, packed(2))]\n+    struct S2C {\n+        d: u8,\n+        u: UC,\n+    }\n+\n     pub fn check_hybrid() {\n+        assert_eq!(align_of::<S1>(), 1);\n         assert_eq!(size_of::<S1>(), 3);\n+        assert_eq!(align_of::<U>(), 1);\n         assert_eq!(size_of::<U>(), 3);\n+        assert_eq!(align_of::<S2>(), 1);\n         assert_eq!(size_of::<S2>(), 4);\n+\n+        assert_eq!(align_of::<S1C>(), 2);\n+        assert_eq!(size_of::<S1C>(), 4);\n+        assert_eq!(align_of::<UC>(), 2);\n+        assert_eq!(size_of::<UC>(), 4);\n+        assert_eq!(align_of::<S2C>(), 2);\n+        assert_eq!(size_of::<S2C>(), 6);\n     }\n }"}, {"sha": "12bb152b4674953cc77f280e9aa9d243ff75f3bf", "filename": "src/test/ui/feature-gate-repr_packed.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Fui%2Ffeature-gate-repr_packed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Fui%2Ffeature-gate-repr_packed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-repr_packed.rs?ref=47778811d9752d9db0d1d4621bbc225317ad216b", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[repr(packed(1))] //~ error: the `#[repr(packed(n))]` attribute is experimental\n+struct Foo(u64);\n+\n+fn main() {}"}, {"sha": "d0faf9d90bd5c88f7f3d688b6c3b8e703eac4c99", "filename": "src/test/ui/feature-gate-repr_packed.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Fui%2Ffeature-gate-repr_packed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Fui%2Ffeature-gate-repr_packed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-repr_packed.stderr?ref=47778811d9752d9db0d1d4621bbc225317ad216b", "patch": "@@ -0,0 +1,11 @@\n+error[E0658]: the `#[repr(packed(n))]` attribute is experimental (see issue #33158)\n+  --> $DIR/feature-gate-repr_packed.rs:11:1\n+   |\n+LL | #[repr(packed(1))] //~ error: the `#[repr(packed(n))]` attribute is experimental\n+   | ^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(repr_packed)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "5d8c932625808eff9e9d2907ec30811a1013f356", "filename": "src/test/ui/print_type_sizes/packed.rs", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Fui%2Fprint_type_sizes%2Fpacked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Fui%2Fprint_type_sizes%2Fpacked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fpacked.rs?ref=47778811d9752d9db0d1d4621bbc225317ad216b", "patch": "@@ -21,10 +21,34 @@\n \n #![allow(dead_code)]\n #![feature(start)]\n+#![feature(repr_packed)]\n \n #[derive(Default)]\n #[repr(packed)]\n-struct Packed {\n+struct Packed1 {\n+    a: u8,\n+    b: u8,\n+    g: i32,\n+    c: u8,\n+    h: i16,\n+    d: u8,\n+}\n+\n+#[derive(Default)]\n+#[repr(packed(2))]\n+struct Packed2 {\n+    a: u8,\n+    b: u8,\n+    g: i32,\n+    c: u8,\n+    h: i16,\n+    d: u8,\n+}\n+\n+#[derive(Default)]\n+#[repr(packed(2))]\n+#[repr(C)]\n+struct Packed2C {\n     a: u8,\n     b: u8,\n     g: i32,\n@@ -45,7 +69,9 @@ struct Padded {\n \n #[start]\n fn start(_: isize, _: *const *const u8) -> isize {\n-    let _c: Packed = Default::default();\n-    let _d: Padded = Default::default();\n+    let _c: Packed1 = Default::default();\n+    let _d: Packed2 = Default::default();\n+    let _e: Packed2C = Default::default();\n+    let _f: Padded = Default::default();\n     0\n }"}, {"sha": "58e1bac9eb794ebe6e1f61cd14675f8c2dae9792", "filename": "src/test/ui/print_type_sizes/packed.stdout", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Fui%2Fprint_type_sizes%2Fpacked.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/47778811d9752d9db0d1d4621bbc225317ad216b/src%2Ftest%2Fui%2Fprint_type_sizes%2Fpacked.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fpacked.stdout?ref=47778811d9752d9db0d1d4621bbc225317ad216b", "patch": "@@ -1,3 +1,12 @@\n+print-type-size type: `Packed2C`: 12 bytes, alignment: 2 bytes\n+print-type-size     field `.a`: 1 bytes\n+print-type-size     field `.b`: 1 bytes\n+print-type-size     field `.g`: 4 bytes\n+print-type-size     field `.c`: 1 bytes\n+print-type-size     padding: 1 bytes\n+print-type-size     field `.h`: 2 bytes\n+print-type-size     field `.d`: 1 bytes\n+print-type-size     end padding: 1 bytes\n print-type-size type: `Padded`: 12 bytes, alignment: 4 bytes\n print-type-size     field `.g`: 4 bytes\n print-type-size     field `.h`: 2 bytes\n@@ -6,10 +15,17 @@ print-type-size     field `.b`: 1 bytes\n print-type-size     field `.c`: 1 bytes\n print-type-size     field `.d`: 1 bytes\n print-type-size     end padding: 2 bytes\n-print-type-size type: `Packed`: 10 bytes, alignment: 1 bytes\n+print-type-size type: `Packed1`: 10 bytes, alignment: 1 bytes\n print-type-size     field `.a`: 1 bytes\n print-type-size     field `.b`: 1 bytes\n print-type-size     field `.g`: 4 bytes\n print-type-size     field `.c`: 1 bytes\n print-type-size     field `.h`: 2 bytes\n print-type-size     field `.d`: 1 bytes\n+print-type-size type: `Packed2`: 10 bytes, alignment: 2 bytes\n+print-type-size     field `.g`: 4 bytes\n+print-type-size     field `.h`: 2 bytes\n+print-type-size     field `.a`: 1 bytes\n+print-type-size     field `.b`: 1 bytes\n+print-type-size     field `.c`: 1 bytes\n+print-type-size     field `.d`: 1 bytes"}]}