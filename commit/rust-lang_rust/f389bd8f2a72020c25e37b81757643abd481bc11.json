{"sha": "f389bd8f2a72020c25e37b81757643abd481bc11", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzODliZDhmMmE3MjAyMGMyNWUzN2I4MTc1NzY0M2FiZDQ4MWJjMTE=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-07-02T16:10:24Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-07-19T05:55:24Z"}, "message": "debuginfo: Support for tuple-style enums (WIP)", "tree": {"sha": "670ed90cdb00198a61b731b6e5a721985bf20511", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/670ed90cdb00198a61b731b6e5a721985bf20511"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f389bd8f2a72020c25e37b81757643abd481bc11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f389bd8f2a72020c25e37b81757643abd481bc11", "html_url": "https://github.com/rust-lang/rust/commit/f389bd8f2a72020c25e37b81757643abd481bc11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f389bd8f2a72020c25e37b81757643abd481bc11/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "739f3eece9c341f4f1e70b8a0417853ed2a09cbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/739f3eece9c341f4f1e70b8a0417853ed2a09cbc", "html_url": "https://github.com/rust-lang/rust/commit/739f3eece9c341f4f1e70b8a0417853ed2a09cbc"}], "stats": {"total": 351, "additions": 261, "deletions": 90}, "files": [{"sha": "1ce4108b3b55d87be4a769952e9b49df9f59c0e5", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f389bd8f2a72020c25e37b81757643abd481bc11/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f389bd8f2a72020c25e37b81757643abd481bc11/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=f389bd8f2a72020c25e37b81757643abd481bc11", "patch": "@@ -2115,7 +2115,21 @@ pub mod llvm {\n             AlignInBits: c_ulonglong,\n             Elements: ValueRef,\n             ClassType: ValueRef) -> ValueRef;\n-}}\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderCreateUnionType(\n+            Builder: DIBuilderRef,\n+            Scope: ValueRef,\n+            Name: *c_char,\n+            File: ValueRef,\n+            LineNumber: c_uint,\n+            SizeInBits: c_ulonglong,\n+            AlignInBits: c_ulonglong,\n+            Flags: c_uint ,\n+            Elements: ValueRef,\n+            RunTimeLang : c_uint) -> ValueRef;\n+    }\n+}\n \n pub fn SetInstructionCallConv(Instr: ValueRef, CC: CallConv) {\n     unsafe {"}, {"sha": "86bdf509d65831403461ff38e583bd89692af57b", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 99, "deletions": 45, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/f389bd8f2a72020c25e37b81757643abd481bc11/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f389bd8f2a72020c25e37b81757643abd481bc11/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=f389bd8f2a72020c25e37b81757643abd481bc11", "patch": "@@ -501,9 +501,9 @@ fn create_struct(cx: &mut CrateContext,\n                  fields: ~[ty::field],\n                  span: span)\n               -> DICompositeType {\n-    debug!(\"create_struct: %?\", ty::get(struct_type));\n-\n     let struct_name = ty_to_str(cx.tcx, struct_type);\n+    debug!(\"create_struct: %s\", struct_name);\n+\n     let struct_llvm_type = type_of::type_of(cx, struct_type);\n \n     let field_llvm_types = fields.map(|field| type_of::type_of(cx, field.mt.ty));\n@@ -526,7 +526,7 @@ fn create_tuple(cx: &mut CrateContext,\n                 span: span)\n              -> DICompositeType {\n \n-    let tuple_name = \"tuple\"; // this should have a better name\n+    let tuple_name = ty_to_str(cx.tcx, tuple_type);\n     let tuple_llvm_type = type_of::type_of(cx, tuple_type);\n     // Create a vec of empty strings. A vec::build_n() function would be nice for this.\n     let mut component_names : ~[~str] = vec::with_capacity(component_types.len());\n@@ -548,61 +548,117 @@ fn create_tuple(cx: &mut CrateContext,\n fn create_enum_md(cx: &mut CrateContext,\n                   enum_type: ty::t,\n                   enum_def_id: ast::def_id,\n-                  span: span) -> DIType {\n+                  substs: &ty::substs,\n+                  span: span)\n+               -> DIType {\n \n     let enum_name = ty_to_str(cx.tcx, enum_type);\n-    let discriminator_llvm_type = Type::enum_discrim(cx);\n-    let discriminator_size = machine::llsize_of_alloc(cx, discriminator_llvm_type);\n-    let discriminator_align = machine::llalign_of_min(cx, discriminator_llvm_type);\n-\n-    assert!(Type::enum_discrim(cx) == cx.int_type);\n-    let discriminator_type_md = get_or_create_type(cx, ty::mk_int(), span);\n \n+    // For empty enums there is an early exit. Just describe it as an empty struct with the\n+    // appropriate name\n     if ty::type_is_empty(cx.tcx, enum_type) {\n-        // XXX: This should not \"rename\" the type to nil\n-        return get_or_create_type(cx, ty::mk_nil(), span);\n+        return create_composite_type(cx, Type::nil(), enum_name, &[], &[], &[], span);\n     }\n \n-    if ty::type_is_c_like_enum(cx.tcx, enum_type) {\n+    // Prepare some data (llvm type, size, align, ...) about the discriminant. This data will be\n+    // needed in all of the following cases.\n+    let discriminant_llvm_type = Type::enum_discrim(cx);\n+    let discriminant_size = machine::llsize_of_alloc(cx, discriminant_llvm_type);\n+    let discriminant_align = machine::llalign_of_min(cx, discriminant_llvm_type);\n+    assert!(Type::enum_discrim(cx) == cx.int_type);\n+    let discriminant_type_md = get_or_create_type(cx, ty::mk_int(), span);\n+\n+\n+    let variants : &[ty::VariantInfo] = *ty::enum_variants(cx.tcx, enum_def_id);\n \n-        let variants : &[ty::VariantInfo] = *ty::enum_variants(cx.tcx, enum_def_id);\n+    let enumerators : ~[(~str, int)] = variants\n+        .iter()\n+        .transform(|v| (cx.sess.str_of(v.name).to_owned(), v.disr_val))\n+        .collect();\n+\n+    let enumerators_md : ~[DIDescriptor] =\n+        do enumerators.iter().transform |&(name,value)| {\n+            do name.as_c_str |name| { unsafe {\n+                llvm::LLVMDIBuilderCreateEnumerator(\n+                    DIB(cx),\n+                    name,\n+                    value as c_ulonglong)\n+            }}\n+        }.collect();\n \n-        let enumerators : ~[(~str, int)] = variants\n-            .iter()\n-            .transform(|v| (cx.sess.str_of(v.name).to_owned(), v.disr_val))\n-            .collect();\n+    let loc = span_start(cx, span);\n+    let file_metadata = get_or_create_file(cx, loc.file.name);\n \n-        let enumerators_md : ~[DIDescriptor] =\n-            do enumerators.iter().transform |&(name,value)| {\n-                do name.as_c_str |name| { unsafe {\n-                    llvm::LLVMDIBuilderCreateEnumerator(\n-                        DIB(cx),\n-                        name,\n-                        value as c_ulonglong)\n-                }}\n-            }.collect();\n+    let discriminant_type_md = do enum_name.as_c_str |enum_name| { unsafe {\n+        llvm::LLVMDIBuilderCreateEnumerationType(\n+            DIB(cx),\n+            file_metadata,\n+            enum_name,\n+            file_metadata,\n+            loc.line as c_uint,\n+            bytes_to_bits(discriminant_size),\n+            bytes_to_bits(discriminant_align),\n+            create_DIArray(DIB(cx), enumerators_md),\n+            discriminant_type_md)\n+    }};\n \n-        let loc = span_start(cx, span);\n-        let file_metadata = get_or_create_file(cx, loc.file.name);\n+    if ty::type_is_c_like_enum(cx.tcx, enum_type) {\n+        return discriminant_type_md;\n+    }\n \n-        return do enum_name.as_c_str |enum_name| { unsafe {\n-            llvm::LLVMDIBuilderCreateEnumerationType(\n+    let variants_md = do variants.map |&vi| {\n+\n+        let raw_types : &[ty::t] = vi.args;\n+        let arg_types = do raw_types.map |&raw_type| { ty::subst(cx.tcx, substs, raw_type) };\n+        let arg_llvm_types = ~[discriminant_llvm_type] + do arg_types.map |&ty| { type_of::type_of(cx, ty) };\n+        let arg_names = ~[~\"\"] + arg_types.map(|_| ~\"\");\n+        let arg_md = ~[discriminant_type_md] + do arg_types.map |&ty| { get_or_create_type(cx, ty, span) };\n+\n+        let variant_llvm_type = Type::struct_(arg_llvm_types, false);\n+        let variant_type_size = machine::llsize_of_alloc(cx, variant_llvm_type);\n+        let variant_type_align = machine::llalign_of_min(cx, variant_llvm_type);\n+\n+        let variant_type_md = create_composite_type(\n+            cx,\n+            variant_llvm_type,\n+            &\"\",\n+            arg_llvm_types,\n+            arg_names,\n+            arg_md,\n+            span);\n+\n+        do \"\".as_c_str |name| { unsafe {\n+            llvm::LLVMDIBuilderCreateMemberType(\n                 DIB(cx),\n                 file_metadata,\n-                enum_name,\n+                name,\n                 file_metadata,\n                 loc.line as c_uint,\n-                bytes_to_bits(discriminator_size),\n-                bytes_to_bits(discriminator_align),\n-                create_DIArray(DIB(cx), enumerators_md),\n-                discriminator_type_md)\n-        }};\n-    }\n-\n-    cx.sess.bug(\"\");\n-}\n+                bytes_to_bits(variant_type_size),\n+                bytes_to_bits(variant_type_align),\n+                bytes_to_bits(0),\n+                0,\n+                variant_type_md)\n+        }}\n+    };\n \n+    let enum_llvm_type = type_of::type_of(cx, enum_type);\n+    let enum_type_size = machine::llsize_of_alloc(cx, enum_llvm_type);\n+    let enum_type_align = machine::llalign_of_min(cx, enum_llvm_type);\n \n+    return do \"\".as_c_str |enum_name| { unsafe { llvm::LLVMDIBuilderCreateUnionType(\n+        DIB(cx),\n+        file_metadata,\n+        enum_name,\n+        file_metadata,\n+        loc.line as c_uint,\n+        bytes_to_bits(enum_type_size),\n+        bytes_to_bits(enum_type_align),\n+        0, // Flags\n+        create_DIArray(DIB(cx), variants_md),\n+        0) // RuntimeLang\n+    }};\n+}\n \n \n /// Creates debug information for a composite type, that is, anything that results in a LLVM struct.\n@@ -899,10 +955,8 @@ fn get_or_create_type(cx: &mut CrateContext, t: ty::t, span: span) -> DIType {\n                 }\n             }\n         },\n-        ty::ty_enum(def_id, ref _substs) => {\n-            //cx.sess.span_note(span, \"debuginfo for enum NYI\");\n-            //create_unimpl_ty(cx, t)\n-            create_enum_md(cx, t, def_id, span)\n+        ty::ty_enum(def_id, ref substs) => {\n+            create_enum_md(cx, t, def_id, substs, span)\n         },\n         ty::ty_box(ref mt) |\n         ty::ty_uniq(ref mt) => {"}, {"sha": "2a1f26bf441086903445fb6d32bd9aa64725049a", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 66, "deletions": 42, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/f389bd8f2a72020c25e37b81757643abd481bc11/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f389bd8f2a72020c25e37b81757643abd481bc11/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=f389bd8f2a72020c25e37b81757643abd481bc11", "patch": "@@ -565,8 +565,8 @@ extern \"C\" bool LLVMRustStartMultithreading() {\n typedef DIBuilder* DIBuilderRef;\n \n template<typename DIT>\n-DIT unwrapDI(LLVMValueRef ref) { \n-    return DIT(ref ? unwrap<MDNode>(ref) : NULL); \n+DIT unwrapDI(LLVMValueRef ref) {\n+    return DIT(ref ? unwrap<MDNode>(ref) : NULL);\n }\n \n extern \"C\" DIBuilderRef LLVMDIBuilderCreate(LLVMModuleRef M) {\n@@ -604,21 +604,21 @@ extern \"C\" LLVMValueRef LLVMDIBuilderCreateFile(\n \n extern \"C\" LLVMValueRef LLVMDIBuilderCreateSubroutineType(\n     DIBuilderRef Builder,\n-    LLVMValueRef File, \n+    LLVMValueRef File,\n     LLVMValueRef ParameterTypes) {\n     return wrap(Builder->createSubroutineType(\n-        unwrapDI<DIFile>(File), \n+        unwrapDI<DIFile>(File),\n         unwrapDI<DIArray>(ParameterTypes)));\n }\n \n extern \"C\" LLVMValueRef LLVMDIBuilderCreateFunction(\n     DIBuilderRef Builder,\n-    LLVMValueRef Scope, \n+    LLVMValueRef Scope,\n     const char* Name,\n     const char* LinkageName,\n-    LLVMValueRef File,  \n+    LLVMValueRef File,\n     unsigned LineNo,\n-    LLVMValueRef Ty, \n+    LLVMValueRef Ty,\n     bool isLocalToUnit,\n     bool isDefinition,\n     unsigned ScopeLine,\n@@ -628,11 +628,11 @@ extern \"C\" LLVMValueRef LLVMDIBuilderCreateFunction(\n     LLVMValueRef TParam,\n     LLVMValueRef Decl) {\n     return wrap(Builder->createFunction(\n-        unwrapDI<DIScope>(Scope), Name, LinkageName, \n-        unwrapDI<DIFile>(File), LineNo, \n-        unwrapDI<DIType>(Ty), isLocalToUnit, isDefinition, ScopeLine, \n+        unwrapDI<DIScope>(Scope), Name, LinkageName,\n+        unwrapDI<DIFile>(File), LineNo,\n+        unwrapDI<DIType>(Ty), isLocalToUnit, isDefinition, ScopeLine,\n         Flags, isOptimized,\n-        unwrap<Function>(Fn), \n+        unwrap<Function>(Fn),\n         unwrapDI<MDNode*>(TParam),\n         unwrapDI<MDNode*>(Decl)));\n }\n@@ -644,10 +644,10 @@ extern \"C\" LLVMValueRef LLVMDIBuilderCreateBasicType(\n     uint64_t AlignInBits,\n     unsigned Encoding) {\n     return wrap(Builder->createBasicType(\n-        Name, SizeInBits, \n+        Name, SizeInBits,\n         AlignInBits, Encoding));\n }\n-    \n+\n extern \"C\" LLVMValueRef LLVMDIBuilderCreatePointerType(\n     DIBuilderRef Builder,\n     LLVMValueRef PointeeTy,\n@@ -672,11 +672,11 @@ extern \"C\" LLVMValueRef LLVMDIBuilderCreateStructType(\n     unsigned RunTimeLang,\n     LLVMValueRef VTableHolder) {\n     return wrap(Builder->createStructType(\n-        unwrapDI<DIDescriptor>(Scope), Name, \n-        unwrapDI<DIFile>(File), LineNumber, \n-        SizeInBits, AlignInBits, Flags, \n-        unwrapDI<DIType>(DerivedFrom), \n-        unwrapDI<DIArray>(Elements), RunTimeLang, \n+        unwrapDI<DIDescriptor>(Scope), Name,\n+        unwrapDI<DIFile>(File), LineNumber,\n+        SizeInBits, AlignInBits, Flags,\n+        unwrapDI<DIType>(DerivedFrom),\n+        unwrapDI<DIArray>(Elements), RunTimeLang,\n         unwrapDI<MDNode*>(VTableHolder)));\n }\n \n@@ -692,23 +692,23 @@ extern \"C\" LLVMValueRef LLVMDIBuilderCreateMemberType(\n     unsigned Flags,\n     LLVMValueRef Ty) {\n     return wrap(Builder->createMemberType(\n-        unwrapDI<DIDescriptor>(Scope), Name, \n+        unwrapDI<DIDescriptor>(Scope), Name,\n         unwrapDI<DIFile>(File), LineNo,\n-        SizeInBits, AlignInBits, OffsetInBits, Flags, \n+        SizeInBits, AlignInBits, OffsetInBits, Flags,\n         unwrapDI<DIType>(Ty)));\n }\n-    \n+\n extern \"C\" LLVMValueRef LLVMDIBuilderCreateLexicalBlock(\n     DIBuilderRef Builder,\n     LLVMValueRef Scope,\n     LLVMValueRef File,\n     unsigned Line,\n     unsigned Col) {\n     return wrap(Builder->createLexicalBlock(\n-        unwrapDI<DIDescriptor>(Scope), \n+        unwrapDI<DIDescriptor>(Scope),\n         unwrapDI<DIFile>(File), Line, Col));\n }\n-    \n+\n extern \"C\" LLVMValueRef LLVMDIBuilderCreateLocalVariable(\n     DIBuilderRef Builder,\n     unsigned Tag,\n@@ -720,45 +720,45 @@ extern \"C\" LLVMValueRef LLVMDIBuilderCreateLocalVariable(\n     bool AlwaysPreserve,\n     unsigned Flags,\n     unsigned ArgNo) {\n-    return wrap(Builder->createLocalVariable(Tag, \n-        unwrapDI<DIDescriptor>(Scope), Name, \n-        unwrapDI<DIFile>(File), \n-        LineNo, \n+    return wrap(Builder->createLocalVariable(Tag,\n+        unwrapDI<DIDescriptor>(Scope), Name,\n+        unwrapDI<DIFile>(File),\n+        LineNo,\n         unwrapDI<DIType>(Ty), AlwaysPreserve, Flags, ArgNo));\n }\n \n extern \"C\" LLVMValueRef LLVMDIBuilderCreateArrayType(\n     DIBuilderRef Builder,\n-    uint64_t Size,  \n-    uint64_t AlignInBits,  \n-    LLVMValueRef Ty, \n+    uint64_t Size,\n+    uint64_t AlignInBits,\n+    LLVMValueRef Ty,\n     LLVMValueRef Subscripts) {\n     return wrap(Builder->createArrayType(Size, AlignInBits,\n-        unwrapDI<DIType>(Ty), \n+        unwrapDI<DIType>(Ty),\n         unwrapDI<DIArray>(Subscripts)));\n }\n \n extern \"C\" LLVMValueRef LLVMDIBuilderCreateVectorType(\n     DIBuilderRef Builder,\n-    uint64_t Size,  \n-    uint64_t AlignInBits,  \n-    LLVMValueRef Ty, \n+    uint64_t Size,\n+    uint64_t AlignInBits,\n+    LLVMValueRef Ty,\n     LLVMValueRef Subscripts) {\n     return wrap(Builder->createVectorType(Size, AlignInBits,\n-        unwrapDI<DIType>(Ty), \n+        unwrapDI<DIType>(Ty),\n         unwrapDI<DIArray>(Subscripts)));\n }\n \n extern \"C\" LLVMValueRef LLVMDIBuilderGetOrCreateSubrange(\n-    DIBuilderRef Builder, \n-    int64_t Lo, \n+    DIBuilderRef Builder,\n+    int64_t Lo,\n     int64_t Count) {\n     return wrap(Builder->getOrCreateSubrange(Lo, Count));\n }\n \n extern \"C\" LLVMValueRef LLVMDIBuilderGetOrCreateArray(\n     DIBuilderRef Builder,\n-    LLVMValueRef* Ptr, \n+    LLVMValueRef* Ptr,\n     unsigned Count) {\n     return wrap(Builder->getOrCreateArray(\n         ArrayRef<Value*>(reinterpret_cast<Value**>(Ptr), Count)));\n@@ -770,8 +770,8 @@ extern \"C\" LLVMValueRef LLVMDIBuilderInsertDeclareAtEnd(\n     LLVMValueRef VarInfo,\n     LLVMBasicBlockRef InsertAtEnd) {\n     return wrap(Builder->insertDeclare(\n-        unwrap(Val), \n-        unwrapDI<DIVariable>(VarInfo), \n+        unwrap(Val),\n+        unwrapDI<DIVariable>(VarInfo),\n         unwrap(InsertAtEnd)));\n }\n \n@@ -781,8 +781,8 @@ extern \"C\" LLVMValueRef LLVMDIBuilderInsertDeclareBefore(\n     LLVMValueRef VarInfo,\n     LLVMValueRef InsertBefore) {\n     return wrap(Builder->insertDeclare(\n-        unwrap(Val), \n-        unwrapDI<DIVariable>(VarInfo), \n+        unwrap(Val),\n+        unwrapDI<DIVariable>(VarInfo),\n         unwrap<Instruction>(InsertBefore)));\n }\n \n@@ -814,4 +814,28 @@ extern \"C\" LLVMValueRef LLVMDIBuilderCreateEnumerationType(\n         AlignInBits,\n         unwrapDI<DIArray>(Elements),\n         unwrapDI<DIType>(ClassType)));\n+}\n+\n+extern \"C\" LLVMValueRef LLVMDIBuilderCreateUnionType(\n+    DIBuilderRef Builder,\n+    LLVMValueRef Scope,\n+    const char* Name,\n+    LLVMValueRef File,\n+    unsigned LineNumber,\n+    uint64_t SizeInBits,\n+    uint64_t AlignInBits,\n+    unsigned Flags,\n+    LLVMValueRef Elements,\n+    unsigned RunTimeLang)\n+{\n+    return wrap(Builder->createUnionType(\n+        unwrapDI<DIDescriptor>(Scope),\n+        Name,\n+        unwrapDI<DIFile>(File),\n+        LineNumber,\n+        SizeInBits,\n+        AlignInBits,\n+        Flags,\n+        unwrapDI<DIArray>(Elements),\n+        RunTimeLang));\n }\n\\ No newline at end of file"}, {"sha": "3071cb2d326c747da617db597aae9ca63aaf8dca", "filename": "src/test/debug-info/c-style-enum.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f389bd8f2a72020c25e37b81757643abd481bc11/src%2Ftest%2Fdebug-info%2Fc-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f389bd8f2a72020c25e37b81757643abd481bc11/src%2Ftest%2Fdebug-info%2Fc-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fc-style-enum.rs?ref=f389bd8f2a72020c25e37b81757643abd481bc11", "patch": "@@ -31,19 +31,25 @@\n // debugger:print manual_one_million\n // check:$6 = OneMillion\n \n+// debugger:print single_variant\n+// check:$7 = TheOnlyVariant\n \n-enum AutoDiscriminator {\n+enum AutoDiscriminant {\n     One,\n     Two,\n     Three\n }\n \n-enum ManualDiscriminator {\n+enum ManualDiscriminant {\n     OneHundred = 100,\n     OneThousand = 1000,\n     OneMillion = 1000000\n }\n \n+enum SingleVariant {\n+    TheOnlyVariant\n+}\n+\n fn main() {\n \n     let auto_one = One;\n@@ -54,6 +60,8 @@ fn main() {\n     let manual_one_thousand = OneThousand;\n     let manual_one_million = OneMillion;\n \n+    let single_variant = TheOnlyVariant;\n+\n     zzz();\n }\n "}, {"sha": "09f41ee9f42674e062abd3066cf8223afaac4382", "filename": "src/test/debug-info/nil-enum.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f389bd8f2a72020c25e37b81757643abd481bc11/src%2Ftest%2Fdebug-info%2Fnil-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f389bd8f2a72020c25e37b81757643abd481bc11/src%2Ftest%2Fdebug-info%2Fnil-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fnil-enum.rs?ref=f389bd8f2a72020c25e37b81757643abd481bc11", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print first\n+// check:$1 = {<No data fields>}\n+\n+// debugger:print second\n+// check:$2 = {<No data fields>}\n+\n+enum ANilEnum {}\n+enum AnotherNilEnum {}\n+\n+// I (mw) am not sure this test case makes much sense...\n+// Also, it relies on some implementation details:\n+// 1. That empty enums as well as '()' are represented as empty structs\n+// 2. That gdb prints the string \"{<No data fields>}\" for empty structs (which may change some time)\n+fn main() {\n+    unsafe {\n+        let first : ANilEnum = std::cast::transmute(());\n+        let second : AnotherNilEnum = std::cast::transmute(());\n+\n+        zzz();\n+    }\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "00144aa1bb5379c495a29c27c724e34afe79d476", "filename": "src/test/debug-info/tuple-style-enum.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f389bd8f2a72020c25e37b81757643abd481bc11/src%2Ftest%2Fdebug-info%2Ftuple-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f389bd8f2a72020c25e37b81757643abd481bc11/src%2Ftest%2Fdebug-info%2Ftuple-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Ftuple-style-enum.rs?ref=f389bd8f2a72020c25e37b81757643abd481bc11", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:set print union on\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print case2\n+// check:$1 = {Case1, 0, 1}\n+\n+enum Test {\n+    Case1(i32, i64),\n+    Case2(bool, i16, i32)\n+}\n+\n+fn main() {\n+\n+    let case1 = Case1(110, 220);\n+    let case2 = Case2(false, 2, 3);\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}]}