{"sha": "5fb099dc786c1bee7116fecb4965d34ad5e0a4a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmYjA5OWRjNzg2YzFiZWU3MTE2ZmVjYjQ5NjVkMzRhZDVlMGE0YTU=", "commit": {"author": {"name": "Cedric", "email": "cedric.brancourt@gmail.com", "date": "2019-06-08T08:49:46Z"}, "committer": {"name": "Cedric", "email": "cedric.brancourt@gmail.com", "date": "2019-06-08T08:49:46Z"}, "message": "use pattern matching for slices destructuring", "tree": {"sha": "12064e001712a29691980ab7d52284cd3da5bdc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12064e001712a29691980ab7d52284cd3da5bdc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fb099dc786c1bee7116fecb4965d34ad5e0a4a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fb099dc786c1bee7116fecb4965d34ad5e0a4a5", "html_url": "https://github.com/rust-lang/rust/commit/5fb099dc786c1bee7116fecb4965d34ad5e0a4a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fb099dc786c1bee7116fecb4965d34ad5e0a4a5/comments", "author": {"login": "Electron-libre", "id": 5979, "node_id": "MDQ6VXNlcjU5Nzk=", "avatar_url": "https://avatars.githubusercontent.com/u/5979?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Electron-libre", "html_url": "https://github.com/Electron-libre", "followers_url": "https://api.github.com/users/Electron-libre/followers", "following_url": "https://api.github.com/users/Electron-libre/following{/other_user}", "gists_url": "https://api.github.com/users/Electron-libre/gists{/gist_id}", "starred_url": "https://api.github.com/users/Electron-libre/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Electron-libre/subscriptions", "organizations_url": "https://api.github.com/users/Electron-libre/orgs", "repos_url": "https://api.github.com/users/Electron-libre/repos", "events_url": "https://api.github.com/users/Electron-libre/events{/privacy}", "received_events_url": "https://api.github.com/users/Electron-libre/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Electron-libre", "id": 5979, "node_id": "MDQ6VXNlcjU5Nzk=", "avatar_url": "https://avatars.githubusercontent.com/u/5979?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Electron-libre", "html_url": "https://github.com/Electron-libre", "followers_url": "https://api.github.com/users/Electron-libre/followers", "following_url": "https://api.github.com/users/Electron-libre/following{/other_user}", "gists_url": "https://api.github.com/users/Electron-libre/gists{/gist_id}", "starred_url": "https://api.github.com/users/Electron-libre/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Electron-libre/subscriptions", "organizations_url": "https://api.github.com/users/Electron-libre/orgs", "repos_url": "https://api.github.com/users/Electron-libre/repos", "events_url": "https://api.github.com/users/Electron-libre/events{/privacy}", "received_events_url": "https://api.github.com/users/Electron-libre/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1c60d292e2dd2deff7084208274f9a02f750d43", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1c60d292e2dd2deff7084208274f9a02f750d43", "html_url": "https://github.com/rust-lang/rust/commit/c1c60d292e2dd2deff7084208274f9a02f750d43"}], "stats": {"total": 104, "additions": 45, "deletions": 59}, "files": [{"sha": "b958a760e82789dfd418ab92ac41ad37d1e3e556", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5fb099dc786c1bee7116fecb4965d34ad5e0a4a5/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb099dc786c1bee7116fecb4965d34ad5e0a4a5/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=5fb099dc786c1bee7116fecb4965d34ad5e0a4a5", "patch": "@@ -33,8 +33,8 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt<'_>,\n                                    span: Span,\n                                    token_tree: &[TokenTree])\n                                    -> Box<dyn MacResult+'cx> {\n-    let code = match (token_tree.len(), token_tree.get(0)) {\n-        (1, Some(&TokenTree::Token(Token { kind: token::Ident(code, _), .. }))) => code,\n+    let code = match token_tree {\n+        &[TokenTree::Token(Token { kind: token::Ident(code, _), .. })] => code,\n         _ => unreachable!()\n     };\n \n@@ -66,22 +66,15 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt<'_>,\n                                        span: Span,\n                                        token_tree: &[TokenTree])\n                                        -> Box<dyn MacResult+'cx> {\n-    let (code, description) = match (\n-        token_tree.len(),\n-        token_tree.get(0),\n-        token_tree.get(1),\n-        token_tree.get(2)\n-    ) {\n-        (1, Some(&TokenTree::Token(Token { kind: token::Ident(code, _), .. })), None, None) => {\n+    let (code, description) = match  token_tree {\n+        &[TokenTree::Token(Token { kind: token::Ident(code, _), .. })] => {\n             (code, None)\n         },\n-        (3, Some(&TokenTree::Token(Token { kind: token::Ident(code, _), .. })),\n-            Some(&TokenTree::Token(Token { kind: token::Comma, .. })),\n-            Some(&TokenTree::Token(Token {\n-                kind: token::Literal(token::Lit { symbol, .. }), ..\n-            }))) => {\n+        &[TokenTree::Token(Token { kind: token::Ident(code, _), .. }),\n+          TokenTree::Token(Token { kind: token::Comma, .. }),\n+          TokenTree::Token(Token { kind: token::Literal(token::Lit { symbol, .. }), ..})] => {\n             (code, Some(symbol))\n-        }\n+        },\n         _ => unreachable!()\n     };\n "}, {"sha": "1d5f1001ac962676c06c000bc042b07fa10bf391", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 24, "deletions": 31, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5fb099dc786c1bee7116fecb4965d34ad5e0a4a5/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb099dc786c1bee7116fecb4965d34ad5e0a4a5/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=5fb099dc786c1bee7116fecb4965d34ad5e0a4a5", "patch": "@@ -424,47 +424,40 @@ mod tests {\n                 string_to_stream(\"macro_rules! zip (($a)=>($a))\".to_string()).trees().collect();\n             let tts: &[TokenTree] = &tts[..];\n \n-            match (tts.len(), tts.get(0), tts.get(1), tts.get(2), tts.get(3)) {\n-                (\n-                    4,\n-                    Some(&TokenTree::Token(Token {\n-                        kind: token::Ident(name_macro_rules, false), ..\n-                    })),\n-                    Some(&TokenTree::Token(Token { kind: token::Not, .. })),\n-                    Some(&TokenTree::Token(Token { kind: token::Ident(name_zip, false), .. })),\n-                    Some(&TokenTree::Delimited(_, macro_delim, ref macro_tts)),\n-                )\n+            match tts {\n+               &[TokenTree::Token(Token {kind: token::Ident(name_macro_rules, false), ..}),\n+                 TokenTree::Token(Token { kind: token::Not, .. }),\n+                 TokenTree::Token(Token { kind: token::Ident(name_zip, false), .. }),\n+                 TokenTree::Delimited(_, macro_delim, ref macro_tts)\n+                ]\n                 if name_macro_rules == sym::macro_rules && name_zip.as_str() == \"zip\" => {\n                     let tts = &macro_tts.trees().collect::<Vec<_>>();\n-                    match (tts.len(), tts.get(0), tts.get(1), tts.get(2)) {\n-                        (\n-                            3,\n-                            Some(&TokenTree::Delimited(_, first_delim, ref first_tts)),\n-                            Some(&TokenTree::Token(Token { kind: token::FatArrow, .. })),\n-                            Some(&TokenTree::Delimited(_, second_delim, ref second_tts)),\n-                        )\n+                    match tts {\n+                        &[\n+                            TokenTree::Delimited(_, first_delim, ref first_tts),\n+                            TokenTree::Token(Token { kind: token::FatArrow, .. }),\n+                            TokenTree::Delimited(_, second_delim, ref second_tts),\n+                        ]\n                         if macro_delim == token::Paren => {\n                             let tts = &first_tts.trees().collect::<Vec<_>>();\n-                            match (tts.len(), tts.get(0), tts.get(1)) {\n-                                (\n-                                    2,\n-                                    Some(&TokenTree::Token(Token { kind: token::Dollar, .. })),\n-                                    Some(&TokenTree::Token(Token {\n+                            match tts {\n+                                &[\n+                                    TokenTree::Token(Token { kind: token::Dollar, .. }),\n+                                    TokenTree::Token(Token {\n                                         kind: token::Ident(name, false), ..\n-                                    })),\n-                                )\n+                                    }),\n+                                ]\n                                 if first_delim == token::Paren && name.as_str() == \"a\" => {},\n                                 _ => panic!(\"value 3: {:?} {:?}\", first_delim, first_tts),\n                             }\n                             let tts = &second_tts.trees().collect::<Vec<_>>();\n-                            match (tts.len(), tts.get(0), tts.get(1)) {\n-                                (\n-                                    2,\n-                                    Some(&TokenTree::Token(Token { kind: token::Dollar, .. })),\n-                                    Some(&TokenTree::Token(Token {\n+                            match tts {\n+                                &[\n+                                    TokenTree::Token(Token { kind: token::Dollar, .. }),\n+                                    TokenTree::Token(Token {\n                                         kind: token::Ident(name, false), ..\n-                                    })),\n-                                )\n+                                    }),\n+                                ]\n                                 if second_delim == token::Paren && name.as_str() == \"a\" => {},\n                                 _ => panic!(\"value 4: {:?} {:?}\", second_delim, second_tts),\n                             }"}, {"sha": "844865d57c7ad04102534e86736abd736c2fabe2", "filename": "src/libsyntax_ext/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fb099dc786c1bee7116fecb4965d34ad5e0a4a5/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb099dc786c1bee7116fecb4965d34ad5e0a4a5/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs?ref=5fb099dc786c1bee7116fecb4965d34ad5e0a4a5", "patch": "@@ -82,8 +82,8 @@ pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<\n         // }\n \n         let new = {\n-            let other_f = match (other_fs.len(), other_fs.get(0)) {\n-                (1, Some(o_f)) => o_f,\n+            let other_f = match other_fs {\n+                [o_f] => o_f,\n                 _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\"),\n             };\n "}, {"sha": "732bb234389a0aedd1ccf474f36d27ec3621d8b2", "filename": "src/libsyntax_ext/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fb099dc786c1bee7116fecb4965d34ad5e0a4a5/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb099dc786c1bee7116fecb4965d34ad5e0a4a5/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=5fb099dc786c1bee7116fecb4965d34ad5e0a4a5", "patch": "@@ -25,8 +25,8 @@ pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt<'_>,\n              -> P<Expr>\n     {\n         let op = |cx: &mut ExtCtxt<'_>, span: Span, self_f: P<Expr>, other_fs: &[P<Expr>]| {\n-            let other_f = match (other_fs.len(), other_fs.get(0)) {\n-                (1, Some(o_f)) => o_f,\n+            let other_f = match other_fs {\n+                [o_f] => o_f,\n                 _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\"),\n             };\n "}, {"sha": "a30a7d78222f47202e348f5a53b6ee694e67c242", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5fb099dc786c1bee7116fecb4965d34ad5e0a4a5/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb099dc786c1bee7116fecb4965d34ad5e0a4a5/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=5fb099dc786c1bee7116fecb4965d34ad5e0a4a5", "patch": "@@ -143,8 +143,8 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_\n                 // }\n \n                 let new = {\n-                    let other_f = match (other_fs.len(), other_fs.get(0)) {\n-                        (1, Some(o_f)) => o_f,\n+                    let other_f = match other_fs {\n+                        [o_f] => o_f,\n                                 _ => {\n                                     cx.span_bug(span,\n                                         \"not exactly 2 arguments in `derive(PartialOrd)`\")\n@@ -193,8 +193,8 @@ fn cs_op(less: bool,\n     };\n \n     let par_cmp = |cx: &mut ExtCtxt<'_>, span, self_f: P<Expr>, other_fs: &[P<Expr>], default| {\n-        let other_f = match (other_fs.len(), other_fs.get(0)) {\n-            (1, Some(o_f)) => o_f,\n+        let other_f = match other_fs {\n+            [o_f] => o_f,\n             _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n         };\n "}, {"sha": "7ad04aebf6e2ea6e4d5bfc2c5c49b0d3f5165216", "filename": "src/libsyntax_ext/deriving/hash.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fb099dc786c1bee7116fecb4965d34ad5e0a4a5/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb099dc786c1bee7116fecb4965d34ad5e0a4a5/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs?ref=5fb099dc786c1bee7116fecb4965d34ad5e0a4a5", "patch": "@@ -52,8 +52,8 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt<'_>,\n }\n \n fn hash_substructure(cx: &mut ExtCtxt<'_>, trait_span: Span, substr: &Substructure<'_>) -> P<Expr> {\n-    let state_expr = match (substr.nonself_args.len(), substr.nonself_args.get(0)) {\n-        (1, Some(o_f)) => o_f,\n+    let state_expr = match &substr.nonself_args {\n+        &[o_f] => o_f,\n         _ => {\n             cx.span_bug(trait_span,\n                         \"incorrect number of arguments in `derive(Hash)`\")"}, {"sha": "512513e9b414c8d1aa2cdff8811755f55be18e3a", "filename": "src/libsyntax_ext/trace_macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5fb099dc786c1bee7116fecb4965d34ad5e0a4a5/src%2Flibsyntax_ext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb099dc786c1bee7116fecb4965d34ad5e0a4a5/src%2Flibsyntax_ext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftrace_macros.rs?ref=5fb099dc786c1bee7116fecb4965d34ad5e0a4a5", "patch": "@@ -16,11 +16,11 @@ pub fn expand_trace_macros(cx: &mut ExtCtxt<'_>,\n                                        feature_gate::EXPLAIN_TRACE_MACROS);\n     }\n \n-    match (tt.len(), tt.first()) {\n-        (1, Some(TokenTree::Token(token))) if token.is_keyword(kw::True) => {\n+    match tt {\n+        [TokenTree::Token(token)] if token.is_keyword(kw::True) => {\n             cx.set_trace_macros(true);\n         }\n-        (1, Some(TokenTree::Token(token))) if token.is_keyword(kw::False) => {\n+        [TokenTree::Token(token)] if token.is_keyword(kw::False) => {\n             cx.set_trace_macros(false);\n         }\n         _ => cx.span_err(sp, \"trace_macros! accepts only `true` or `false`\"),"}]}