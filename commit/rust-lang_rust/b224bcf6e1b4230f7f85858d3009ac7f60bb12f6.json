{"sha": "b224bcf6e1b4230f7f85858d3009ac7f60bb12f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyMjRiY2Y2ZTFiNDIzMGY3Zjg1ODU4ZDMwMDlhYzdmNjBiYjEyZjY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-03-22T20:44:20Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-03-22T20:44:20Z"}, "message": "Add an LLVM-instruction-counting mode to trans.\n\nPipe to xdu to see a trans call graph of generated insns.", "tree": {"sha": "c1c6208f05f9dd7fc20058aaca439557a7507166", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1c6208f05f9dd7fc20058aaca439557a7507166"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b224bcf6e1b4230f7f85858d3009ac7f60bb12f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b224bcf6e1b4230f7f85858d3009ac7f60bb12f6", "html_url": "https://github.com/rust-lang/rust/commit/b224bcf6e1b4230f7f85858d3009ac7f60bb12f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b224bcf6e1b4230f7f85858d3009ac7f60bb12f6/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc07280b087c89506ad7e5f66f4f88b18d06be2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc07280b087c89506ad7e5f66f4f88b18d06be2e", "html_url": "https://github.com/rust-lang/rust/commit/dc07280b087c89506ad7e5f66f4f88b18d06be2e"}], "stats": {"total": 426, "additions": 404, "deletions": 22}, "files": [{"sha": "2bbce0e2cb510f3d93d8d1ce309d79c3d0252af0", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b224bcf6e1b4230f7f85858d3009ac7f60bb12f6/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b224bcf6e1b4230f7f85858d3009ac7f60bb12f6/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=b224bcf6e1b4230f7f85858d3009ac7f60bb12f6", "patch": "@@ -386,6 +386,7 @@ fn build_session_options(match: getopts::match,\n     let stats = opt_present(match, \"stats\");\n     let time_passes = opt_present(match, \"time-passes\");\n     let time_llvm_passes = opt_present(match, \"time-llvm-passes\");\n+    let count_llvm_insns = opt_present(match, \"count-llvm-insns\");\n     let sysroot_opt = getopts::opt_maybe_str(match, \"sysroot\");\n     let target_opt = getopts::opt_maybe_str(match, \"target\");\n     let mut no_asm_comments = getopts::opt_present(match, \"no-asm-comments\");\n@@ -433,6 +434,7 @@ fn build_session_options(match: getopts::match,\n           save_temps: save_temps,\n           stats: stats,\n           time_passes: time_passes,\n+          count_llvm_insns: count_llvm_insns,\n           time_llvm_passes: time_llvm_passes,\n           output_type: output_type,\n           addl_lib_search_paths: addl_lib_search_paths,\n@@ -513,6 +515,7 @@ fn opts() -> [getopts::opt] {\n          optflag(\"c\"), optflag(\"g\"), optflag(\"save-temps\"),\n          optopt(\"sysroot\"), optopt(\"target\"), optflag(\"stats\"),\n          optflag(\"time-passes\"), optflag(\"time-llvm-passes\"),\n+         optflag(\"count-llvm-insns\"),\n          optflag(\"no-verify\"),\n          optflag(\"no-lint-ctypes\"),\n          optmulti(\"cfg\"), optflag(\"test\"),"}, {"sha": "fe5587e0faff1e760b55933f36d4793976fefa29", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b224bcf6e1b4230f7f85858d3009ac7f60bb12f6/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b224bcf6e1b4230f7f85858d3009ac7f60bb12f6/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=b224bcf6e1b4230f7f85858d3009ac7f60bb12f6", "patch": "@@ -62,6 +62,7 @@ Options:\n \n     --time-passes      Time the individual phases of the compiler\n     --time-llvm-passes Time the individual phases of the LLVM backend\n+    --count-llvm-insns Count and categorize generated LLVM instructions\n     -v --version       Print version info and exit\n     --warn-unused-imports\n                        Warn about unnecessary imports"}, {"sha": "79f9a44aaa0f2d22631d9b16c2ccbfdda67e38a7", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b224bcf6e1b4230f7f85858d3009ac7f60bb12f6/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b224bcf6e1b4230f7f85858d3009ac7f60bb12f6/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=b224bcf6e1b4230f7f85858d3009ac7f60bb12f6", "patch": "@@ -35,6 +35,7 @@ type options =\n      save_temps: bool,\n      stats: bool,\n      time_passes: bool,\n+     count_llvm_insns: bool,\n      time_llvm_passes: bool,\n      output_type: back::link::output_type,\n      addl_lib_search_paths: [str],"}, {"sha": "0705114495c0a07103fd53dc0121767cb3943ea2", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b224bcf6e1b4230f7f85858d3009ac7f60bb12f6/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b224bcf6e1b4230f7f85858d3009ac7f60bb12f6/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=b224bcf6e1b4230f7f85858d3009ac7f60bb12f6", "patch": "@@ -40,6 +40,7 @@ enum opt_result {\n     range_result(result, result),\n }\n fn trans_opt(bcx: block, o: opt) -> opt_result {\n+    let _icx = bcx.insn_ctxt(\"alt::trans_opt\");\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n     alt o {\n@@ -259,6 +260,7 @@ fn get_options(ccx: @crate_ctxt, m: match, col: uint) -> [opt] {\n fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n                         vdefs: {enm: def_id, var: def_id}, val: ValueRef) ->\n    {vals: [ValueRef], bcx: block} {\n+    let _icx = bcx.insn_ctxt(\"alt::extract_variant_args\");\n     let ccx = bcx.fcx.ccx;\n     let mut bcx = bcx;\n     let enum_ty_substs = alt check ty::get(node_id_type(bcx, pat_id)).struct {\n@@ -358,6 +360,7 @@ fn pick_col(m: match) -> uint {\n \n fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n                     chk: option<mk_fail>, &exits: [exit_node]) {\n+    let _icx = bcx.insn_ctxt(\"alt::compile_submatch\");\n     let mut bcx = bcx;\n     let tcx = bcx.tcx(), dm = tcx.def_map;\n     if m.len() == 0u { Br(bcx, option::get(chk)()); ret; }\n@@ -564,6 +567,7 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n // Returns false for unreachable blocks\n fn make_phi_bindings(bcx: block, map: [exit_node],\n                      ids: pat_util::pat_id_map) -> bool {\n+    let _icx = bcx.insn_ctxt(\"alt::make_phi_bindings\");\n     let our_block = bcx.llbb as uint;\n     let mut success = true, bcx = bcx;\n     ids.items {|name, node_id|\n@@ -609,13 +613,15 @@ fn make_phi_bindings(bcx: block, map: [exit_node],\n \n fn trans_alt(bcx: block, expr: @ast::expr, arms: [ast::arm],\n              mode: ast::alt_mode, dest: dest) -> block {\n+    let _icx = bcx.insn_ctxt(\"alt::trans_alt\");\n     with_scope(bcx, \"alt\") {|bcx|\n         trans_alt_inner(bcx, expr, arms, mode, dest)\n     }\n }\n \n fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: [ast::arm],\n                    mode: ast::alt_mode, dest: dest) -> block {\n+    let _icx = scope_cx.insn_ctxt(\"alt::trans_alt_inner\");\n     let bcx = scope_cx, tcx = bcx.tcx();\n     let mut bodies = [], match = [];\n \n@@ -675,6 +681,7 @@ fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: [ast::arm],\n // Not alt-related, but similar to the pattern-munging code above\n fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n                         make_copy: bool) -> block {\n+    let _icx = bcx.insn_ctxt(\"alt::bind_irrefutable_pat\");\n     let ccx = bcx.fcx.ccx;\n     let mut bcx = bcx;\n "}, {"sha": "bc63f46f780257a9afe0f6faad2edb6d53c7d67d", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 182, "deletions": 14, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/b224bcf6e1b4230f7f85858d3009ac7f60bb12f6/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b224bcf6e1b4230f7f85858d3009ac7f60bb12f6/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=b224bcf6e1b4230f7f85858d3009ac7f60bb12f6", "patch": "@@ -80,6 +80,33 @@ fn dup_for_join(dest: dest) -> dest {\n     }\n }\n \n+resource icx_popper(ccx: @crate_ctxt) {\n+    if (ccx.sess.opts.count_llvm_insns) {\n+        vec::pop(*ccx.stats.llvm_insn_ctxt);\n+    }\n+}\n+\n+impl ccx_icx for @crate_ctxt {\n+    fn insn_ctxt(s: str) -> icx_popper {\n+        if (self.sess.opts.count_llvm_insns) {\n+            *self.stats.llvm_insn_ctxt += [s];\n+        }\n+        icx_popper(self)\n+    }\n+}\n+\n+impl bcx_icx for block {\n+    fn insn_ctxt(s: str) -> icx_popper {\n+        self.ccx().insn_ctxt(s)\n+    }\n+}\n+\n+impl fcx_icx for fn_ctxt {\n+    fn insn_ctxt(s: str) -> icx_popper {\n+        self.ccx.insn_ctxt(s)\n+    }\n+}\n+\n fn join_returns(parent_cx: block, in_cxs: [block],\n                 in_ds: [dest], out_dest: dest) -> block {\n     let out = sub_block(parent_cx, \"join\");\n@@ -179,6 +206,7 @@ fn get_simple_extern_fn(cx: block,\n                         externs: hashmap<str, ValueRef>,\n                         llmod: ModuleRef,\n                         name: str, n_args: int) -> ValueRef {\n+    let _icx = cx.insn_ctxt(\"get_simple_extern_fn\");\n     let ccx = cx.fcx.ccx;\n     let inputs = vec::from_elem(n_args as uint, ccx.int_type);\n     let output = ccx.int_type;\n@@ -189,6 +217,7 @@ fn get_simple_extern_fn(cx: block,\n fn trans_native_call(cx: block, externs: hashmap<str, ValueRef>,\n                      llmod: ModuleRef, name: str, args: [ValueRef]) ->\n    ValueRef {\n+    let _icx = cx.insn_ctxt(\"trans_native_call\");\n     let n = args.len() as int;\n     let llnative: ValueRef =\n         get_simple_extern_fn(cx, externs, llmod, name, n);\n@@ -200,27 +229,32 @@ fn trans_native_call(cx: block, externs: hashmap<str, ValueRef>,\n }\n \n fn trans_free(cx: block, v: ValueRef) -> block {\n+    let _icx = cx.insn_ctxt(\"trans_free\");\n     Call(cx, cx.ccx().upcalls.free, [PointerCast(cx, v, T_ptr(T_i8()))]);\n     cx\n }\n \n fn trans_shared_free(cx: block, v: ValueRef) -> block {\n+    let _icx = cx.insn_ctxt(\"trans_shared_free\");\n     Call(cx, cx.ccx().upcalls.shared_free,\n          [PointerCast(cx, v, T_ptr(T_i8()))]);\n     ret cx;\n }\n \n fn umax(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n+    let _icx = cx.insn_ctxt(\"umax\");\n     let cond = ICmp(cx, lib::llvm::IntULT, a, b);\n     ret Select(cx, cond, b, a);\n }\n \n fn umin(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n+    let _icx = cx.insn_ctxt(\"umin\");\n     let cond = ICmp(cx, lib::llvm::IntULT, a, b);\n     ret Select(cx, cond, a, b);\n }\n \n fn alloca(cx: block, t: TypeRef) -> ValueRef {\n+    let _icx = cx.insn_ctxt(\"alloca\");\n     if cx.unreachable { ret llvm::LLVMGetUndef(t); }\n     ret Alloca(raw_block(cx.fcx, cx.fcx.llstaticallocas), t);\n }\n@@ -229,6 +263,7 @@ fn alloca(cx: block, t: TypeRef) -> ValueRef {\n // The type of the returned pointer is always i8*.  If you care about the\n // return type, use bump_ptr().\n fn ptr_offs(bcx: block, base: ValueRef, sz: ValueRef) -> ValueRef {\n+    let _icx = bcx.insn_ctxt(\"ptr_offs\");\n     let raw = PointerCast(bcx, base, T_ptr(T_i8()));\n     InBoundsGEP(bcx, raw, [sz])\n }\n@@ -237,6 +272,7 @@ fn ptr_offs(bcx: block, base: ValueRef, sz: ValueRef) -> ValueRef {\n // to a given type.\n fn bump_ptr(bcx: block, t: ty::t, base: ValueRef, sz: ValueRef) ->\n    ValueRef {\n+    let _icx = bcx.insn_ctxt(\"bump_ptr\");\n     let ccx = bcx.ccx();\n     let bumped = ptr_offs(bcx, base, sz);\n     let typ = T_ptr(type_of(ccx, t));\n@@ -249,6 +285,7 @@ fn bump_ptr(bcx: block, t: ty::t, base: ValueRef, sz: ValueRef) ->\n fn GEP_enum(bcx: block, llblobptr: ValueRef, enum_id: ast::def_id,\n             variant_id: ast::def_id, ty_substs: [ty::t],\n             ix: uint) -> result {\n+    let _icx = bcx.insn_ctxt(\"GEP_enum\");\n     let ccx = bcx.ccx();\n     let variant = ty::enum_variant_with_id(ccx.tcx, enum_id, variant_id);\n     assert ix < variant.args.len();\n@@ -265,6 +302,7 @@ fn GEP_enum(bcx: block, llblobptr: ValueRef, enum_id: ast::def_id,\n // and a size indicating how much space we want malloc'd.\n fn trans_shared_malloc(cx: block, llptr_ty: TypeRef, llsize: ValueRef)\n    -> result {\n+    let _icx = cx.insn_ctxt(\"opaque_shared_malloc\");\n     let rval = Call(cx, cx.ccx().upcalls.shared_malloc, [llsize]);\n     ret rslt(cx, PointerCast(cx, rval, llptr_ty));\n }\n@@ -277,6 +315,7 @@ fn trans_shared_malloc(cx: block, llptr_ty: TypeRef, llsize: ValueRef)\n fn opaque_box_body(bcx: block,\n                       body_t: ty::t,\n                       boxptr: ValueRef) -> ValueRef {\n+    let _icx = bcx.insn_ctxt(\"opaque_box_body\");\n     let ccx = bcx.ccx();\n     let boxptr = PointerCast(bcx, boxptr, T_ptr(T_box_header(ccx)));\n     let bodyptr = GEPi(bcx, boxptr, [1]);\n@@ -288,6 +327,7 @@ fn opaque_box_body(bcx: block,\n // header.\n fn trans_malloc_boxed_raw(bcx: block, t: ty::t,\n                           &static_ti: option<@tydesc_info>) -> result {\n+    let _icx = bcx.insn_ctxt(\"trans_malloc_boxed_raw\");\n     let mut bcx = bcx;\n     let ccx = bcx.ccx();\n \n@@ -309,6 +349,7 @@ fn trans_malloc_boxed_raw(bcx: block, t: ty::t,\n // initializes the reference count to 1, and pulls out the body and rc\n fn trans_malloc_boxed(bcx: block, t: ty::t) ->\n    {bcx: block, box: ValueRef, body: ValueRef} {\n+    let _icx = bcx.insn_ctxt(\"trans_malloc_boxed\");\n     let mut ti = none;\n     let {bcx, val:box} = trans_malloc_boxed_raw(bcx, t, ti);\n     let body = GEPi(bcx, box, [0, abi::box_field_body]);\n@@ -396,6 +437,7 @@ fn note_unique_llvm_symbol(ccx: @crate_ctxt, sym: str) {\n \n // Generates the declaration for (but doesn't emit) a type descriptor.\n fn declare_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n+    let _icx = ccx.insn_ctxt(\"declare_tydesc\");\n     log(debug, \"+++ declare_tydesc \" + ty_to_str(ccx.tcx, t));\n     let llty = type_of(ccx, t);\n     let llsize = llsize_of(ccx, llty);\n@@ -425,6 +467,7 @@ type glue_helper = fn@(block, ValueRef, ty::t);\n \n fn declare_generic_glue(ccx: @crate_ctxt, t: ty::t, llfnty: TypeRef,\n                         name: str) -> ValueRef {\n+    let _icx = ccx.insn_ctxt(\"declare_generic_glue\");\n     let name = name;\n     let mut fn_nm;\n     //XXX this triggers duplicate LLVM symbols\n@@ -441,6 +484,7 @@ fn declare_generic_glue(ccx: @crate_ctxt, t: ty::t, llfnty: TypeRef,\n \n fn make_generic_glue_inner(ccx: @crate_ctxt, t: ty::t,\n                            llfn: ValueRef, helper: glue_helper) -> ValueRef {\n+    let _icx = ccx.insn_ctxt(\"make_generic_glue_inner\");\n     let fcx = new_fn_ctxt(ccx, [], llfn, none);\n     lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n     ccx.stats.n_glues_created += 1u;\n@@ -463,6 +507,7 @@ fn make_generic_glue_inner(ccx: @crate_ctxt, t: ty::t,\n fn make_generic_glue(ccx: @crate_ctxt, t: ty::t, llfn: ValueRef,\n                      helper: glue_helper, name: str)\n     -> ValueRef {\n+    let _icx = ccx.insn_ctxt(\"make_generic_glue\");\n     if !ccx.sess.opts.stats {\n         ret make_generic_glue_inner(ccx, t, llfn, helper);\n     }\n@@ -476,6 +521,7 @@ fn make_generic_glue(ccx: @crate_ctxt, t: ty::t, llfn: ValueRef,\n }\n \n fn emit_tydescs(ccx: @crate_ctxt) {\n+    let _icx = ccx.insn_ctxt(\"emit_tydescs\");\n     ccx.tydescs.items {|key, val|\n         let glue_fn_ty = T_ptr(T_glue_fn(ccx));\n         let ti = val;\n@@ -526,6 +572,7 @@ fn emit_tydescs(ccx: @crate_ctxt) {\n }\n \n fn make_take_glue(cx: block, v: ValueRef, t: ty::t) {\n+    let _icx = cx.insn_ctxt(\"make_take_glue\");\n     let mut bcx = cx;\n     // NB: v is a *pointer* to type t here, not a direct value.\n     bcx = alt ty::get(t).struct {\n@@ -562,6 +609,7 @@ fn make_take_glue(cx: block, v: ValueRef, t: ty::t) {\n }\n \n fn incr_refcnt_of_boxed(cx: block, box_ptr: ValueRef) -> block {\n+    let _icx = cx.insn_ctxt(\"incr_refcnt_of_boxed\");\n     let ccx = cx.ccx();\n     maybe_validate_box(cx, box_ptr);\n     let rc_ptr = GEPi(cx, box_ptr, [0, abi::box_field_refcnt]);\n@@ -575,6 +623,7 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n     // v is a pointer to the actual box component of the type here. The\n     // ValueRef will have the wrong type here (make_generic_glue is casting\n     // everything to a pointer to the type that the glue acts on).\n+    let _icx = bcx.insn_ctxt(\"make_free_glue\");\n     let ccx = bcx.ccx();\n     let bcx = alt ty::get(t).struct {\n       ty::ty_box(body_mt) {\n@@ -611,6 +660,7 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n \n fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n+    let _icx = bcx.insn_ctxt(\"make_drop_glue\");\n     let ccx = bcx.ccx();\n     let bcx = alt ty::get(t).struct {\n       ty::ty_box(_) | ty::ty_opaque_box {\n@@ -644,6 +694,7 @@ fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n \n fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id, substs: [ty::t])\n    -> ValueRef {\n+    let _icx = ccx.insn_ctxt(\"trans_res_dtor\");\n     let did = if did.crate != ast::local_crate && substs.len() > 0u {\n         maybe_instantiate_inline(ccx, did)\n     } else { did };\n@@ -653,6 +704,7 @@ fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id, substs: [ty::t])\n \n fn trans_res_drop(bcx: block, rs: ValueRef, did: ast::def_id,\n                   inner_t: ty::t, tps: [ty::t]) -> block {\n+    let _icx = bcx.insn_ctxt(\"trans_res_drop\");\n     let ccx = bcx.ccx();\n     let inner_t_s = ty::substitute_type_params(ccx.tcx, tps, inner_t);\n \n@@ -689,6 +741,7 @@ fn maybe_validate_box(_cx: block, _box_ptr: ValueRef) {\n }\n \n fn decr_refcnt_maybe_free(bcx: block, box_ptr: ValueRef, t: ty::t) -> block {\n+    let _icx = bcx.insn_ctxt(\"decr_refcnt_maybe_free\");\n     let ccx = bcx.ccx();\n     maybe_validate_box(bcx, box_ptr);\n \n@@ -742,6 +795,7 @@ fn compare_scalar_types(cx: block, lhs: ValueRef, rhs: ValueRef,\n // A helper function to do the actual comparison of scalar values.\n fn compare_scalar_values(cx: block, lhs: ValueRef, rhs: ValueRef,\n                          nt: scalar_type, op: ast::binop) -> ValueRef {\n+    let _icx = cx.insn_ctxt(\"compare_scalar_values\");\n     fn die_(cx: block) -> ! {\n         cx.tcx().sess.bug(\"compare_scalar_values: must be a\\\n           comparison operator\");\n@@ -812,9 +866,12 @@ fn store_inbounds(cx: block, v: ValueRef, p: ValueRef,\n // Iterates through the elements of a structural type.\n fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n                       f: val_and_ty_fn) -> block {\n+    let _icx = cx.insn_ctxt(\"iter_structural_ty\");\n+\n     fn iter_variant(cx: block, a_tup: ValueRef,\n                     variant: ty::variant_info, tps: [ty::t], tid: ast::def_id,\n                     f: val_and_ty_fn) -> block {\n+        let _icx = cx.insn_ctxt(\"iter_variant\");\n         if variant.args.len() == 0u { ret cx; }\n         let fn_ty = variant.ctor_ty;\n         let ccx = cx.ccx();\n@@ -922,6 +979,7 @@ fn lazily_emit_all_tydesc_glue(ccx: @crate_ctxt,\n \n fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: int,\n                            static_ti: option<@tydesc_info>) {\n+    let _icx = ccx.insn_ctxt(\"lazily_emit_tydesc_glue\");\n     alt static_ti {\n       none { }\n       some(ti) {\n@@ -977,6 +1035,7 @@ fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: int,\n \n fn call_tydesc_glue_full(cx: block, v: ValueRef, tydesc: ValueRef,\n                          field: int, static_ti: option<@tydesc_info>) {\n+    let _icx = cx.insn_ctxt(\"call_tydesc_glue_full\");\n     lazily_emit_tydesc_glue(cx.ccx(), field, static_ti);\n     if cx.unreachable { ret; }\n \n@@ -1014,6 +1073,7 @@ fn call_tydesc_glue_full(cx: block, v: ValueRef, tydesc: ValueRef,\n \n fn call_tydesc_glue(cx: block, v: ValueRef, t: ty::t, field: int) ->\n    block {\n+    let _icx = cx.insn_ctxt(\"call_tydesc_glue\");\n     let mut ti: option<@tydesc_info> = none;\n     let {bcx: bcx, val: td} = get_tydesc(cx, t, ti);\n     call_tydesc_glue_full(bcx, v, td, field, ti);\n@@ -1024,7 +1084,7 @@ fn call_cmp_glue(cx: block, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n                  llop: ValueRef) -> result {\n     // We can't use call_tydesc_glue_full() and friends here because compare\n     // glue has a special signature.\n-\n+    let _icx = cx.insn_ctxt(\"call_cmp_glue\");\n     let bcx = cx;\n \n     let r = spill_if_immediate(bcx, lhs, t);\n@@ -1051,20 +1111,23 @@ fn call_cmp_glue(cx: block, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n }\n \n fn take_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n+    let _icx = cx.insn_ctxt(\"take_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n         ret call_tydesc_glue(cx, v, t, abi::tydesc_field_take_glue);\n     }\n     ret cx;\n }\n \n fn drop_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n+    let _icx = cx.insn_ctxt(\"drop_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n         ret call_tydesc_glue(cx, v, t, abi::tydesc_field_drop_glue);\n     }\n     ret cx;\n }\n \n fn drop_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n+    let _icx = bcx.insn_ctxt(\"drop_ty_immediate\");\n     alt ty::get(t).struct {\n       ty::ty_uniq(_) | ty::ty_vec(_) | ty::ty_str { free_ty(bcx, v, t) }\n       ty::ty_box(_) | ty::ty_opaque_box {\n@@ -1075,6 +1138,7 @@ fn drop_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n }\n \n fn take_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> result {\n+    let _icx = bcx.insn_ctxt(\"take_ty_immediate\");\n     alt ty::get(t).struct {\n       ty::ty_box(_) | ty::ty_opaque_box {\n         rslt(incr_refcnt_of_boxed(bcx, v), v)\n@@ -1088,6 +1152,7 @@ fn take_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> result {\n }\n \n fn free_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n+    let _icx = cx.insn_ctxt(\"free_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n         ret call_tydesc_glue(cx, v, t, abi::tydesc_field_free_glue);\n     }\n@@ -1100,7 +1165,7 @@ fn call_memmove(cx: block, dst: ValueRef, src: ValueRef,\n     // alignment is statically known (it must be nothing more than a constant\n     // int, or LLVM complains -- not even a constant element of a tydesc\n     // works).\n-\n+    let _icx = cx.insn_ctxt(\"call_memmove\");\n     let ccx = cx.ccx();\n     let key = alt ccx.sess.targ_cfg.arch {\n       session::arch_x86 | session::arch_arm { \"llvm.memmove.p0i8.p0i8.i32\" }\n@@ -1121,6 +1186,7 @@ fn call_memmove(cx: block, dst: ValueRef, src: ValueRef,\n \n fn memmove_ty(bcx: block, dst: ValueRef, src: ValueRef, t: ty::t) ->\n     block {\n+    let _icx = bcx.insn_ctxt(\"memmove_ty\");\n     let ccx = bcx.ccx();\n     if ty::type_is_structural(t) {\n         let llsz = llsize_of(ccx, type_of(ccx, t));\n@@ -1143,6 +1209,7 @@ fn type_is_structural_or_param(t: ty::t) -> bool {\n \n fn copy_val(cx: block, action: copy_action, dst: ValueRef,\n             src: ValueRef, t: ty::t) -> block {\n+    let _icx = cx.insn_ctxt(\"copy_val\");\n     if action == DROP_EXISTING &&\n         (type_is_structural_or_param(t) ||\n          ty::type_is_unique(t)) {\n@@ -1159,6 +1226,7 @@ fn copy_val(cx: block, action: copy_action, dst: ValueRef,\n \n fn copy_val_no_check(bcx: block, action: copy_action, dst: ValueRef,\n                      src: ValueRef, t: ty::t) -> block {\n+    let _icx = bcx.insn_ctxt(\"copy_val_no_check\");\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n     if ty::type_is_scalar(t) {\n@@ -1189,6 +1257,7 @@ fn copy_val_no_check(bcx: block, action: copy_action, dst: ValueRef,\n // doesn't need to be dropped.\n fn move_val(cx: block, action: copy_action, dst: ValueRef,\n             src: lval_result, t: ty::t) -> block {\n+    let _icx = cx.insn_ctxt(\"move_val\");\n     let mut src_val = src.val;\n     let tcx = cx.tcx();\n     let mut cx = cx;\n@@ -1221,6 +1290,7 @@ fn move_val(cx: block, action: copy_action, dst: ValueRef,\n fn store_temp_expr(cx: block, action: copy_action, dst: ValueRef,\n                    src: lval_result, t: ty::t, last_use: bool)\n     -> block {\n+    let _icx = cx.insn_ctxt(\"trans_temp_expr\");\n     // Lvals in memory are not temporaries. Copy them.\n     if src.kind != temporary && !last_use {\n         let v = if src.kind == owned {\n@@ -1234,6 +1304,7 @@ fn store_temp_expr(cx: block, action: copy_action, dst: ValueRef,\n }\n \n fn trans_crate_lit(cx: @crate_ctxt, lit: ast::lit) -> ValueRef {\n+    let _icx = cx.insn_ctxt(\"trans_crate_lit\");\n     alt lit.node {\n       ast::lit_int(i, t) { C_integral(T_int_ty(cx, t), i as u64, True) }\n       ast::lit_uint(u, t) { C_integral(T_uint_ty(cx, t), u, False) }\n@@ -1247,6 +1318,7 @@ fn trans_crate_lit(cx: @crate_ctxt, lit: ast::lit) -> ValueRef {\n }\n \n fn trans_lit(cx: block, lit: ast::lit, dest: dest) -> block {\n+    let _icx = cx.insn_ctxt(\"trans_lit\");\n     if dest == ignore { ret cx; }\n     alt lit.node {\n       ast::lit_str(s) { ret tvec::trans_str(cx, s, dest); }\n@@ -1258,6 +1330,7 @@ fn trans_lit(cx: block, lit: ast::lit, dest: dest) -> block {\n \n fn trans_unary(bcx: block, op: ast::unop, e: @ast::expr,\n                un_expr: @ast::expr, dest: dest) -> block {\n+    let _icx = bcx.insn_ctxt(\"trans_unary\");\n     // Check for user-defined method call\n     alt bcx.ccx().maps.method_map.find(un_expr.id) {\n       some(origin) {\n@@ -1309,6 +1382,7 @@ fn trans_unary(bcx: block, op: ast::unop, e: @ast::expr,\n }\n \n fn trans_addr_of(cx: block, e: @ast::expr, dest: dest) -> block {\n+    let _icx = cx.insn_ctxt(\"trans_addr_of\");\n     let mut {bcx, val, kind} = trans_temp_lval(cx, e);\n     let ety = expr_ty(cx, e);\n     let is_immediate = ty::type_is_immediate(ety);\n@@ -1321,6 +1395,7 @@ fn trans_addr_of(cx: block, e: @ast::expr, dest: dest) -> block {\n \n fn trans_compare(cx: block, op: ast::binop, lhs: ValueRef,\n                  _lhs_t: ty::t, rhs: ValueRef, rhs_t: ty::t) -> result {\n+    let _icx = cx.insn_ctxt(\"trans_compare\");\n     if ty::type_is_scalar(rhs_t) {\n       let rs = compare_scalar_types(cx, lhs, rhs, rhs_t, op);\n       ret rslt(rs.bcx, rs.val);\n@@ -1366,7 +1441,6 @@ fn cast_shift_rhs(op: ast::binop,\n                   trunc: fn(ValueRef, TypeRef) -> ValueRef,\n                   zext: fn(ValueRef, TypeRef) -> ValueRef\n                  ) -> ValueRef {\n-\n     // Shifts may have any size int on the rhs\n     if ast_util::is_shift_binop(op) {\n         let rhs_llty = val_ty(rhs);\n@@ -1392,6 +1466,7 @@ fn cast_shift_rhs(op: ast::binop,\n fn trans_eager_binop(cx: block, op: ast::binop, lhs: ValueRef,\n                      lhs_t: ty::t, rhs: ValueRef, rhs_t: ty::t, dest: dest)\n     -> block {\n+    let _icx = cx.insn_ctxt(\"trans_eager_binop\");\n     if dest == ignore { ret cx; }\n     let intype = {\n         if ty::type_is_bot(lhs_t) { rhs_t }\n@@ -1447,6 +1522,7 @@ fn trans_eager_binop(cx: block, op: ast::binop, lhs: ValueRef,\n \n fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n                    dst: @ast::expr, src: @ast::expr) -> block {\n+    let _icx = bcx.insn_ctxt(\"trans_assign_op\");\n     let t = expr_ty(bcx, src);\n     let lhs_res = trans_lval(bcx, dst);\n     assert (lhs_res.kind == owned);\n@@ -1491,6 +1567,7 @@ fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n }\n \n fn autoderef(cx: block, v: ValueRef, t: ty::t) -> result_t {\n+    let _icx = cx.insn_ctxt(\"autoderef\");\n     let mut v1: ValueRef = v;\n     let mut t1: ty::t = t;\n     let ccx = cx.ccx();\n@@ -1541,7 +1618,7 @@ enum lazy_binop_ty { lazy_and, lazy_or }\n \n fn trans_lazy_binop(bcx: block, op: lazy_binop_ty, a: @ast::expr,\n                     b: @ast::expr, dest: dest) -> block {\n-\n+    let _icx = bcx.insn_ctxt(\"trans_lazy_binop\");\n     let {bcx: past_lhs, val: lhs} = with_scope_result(bcx, \"lhs\")\n         {|bcx| trans_temp_expr(bcx, a)};\n     if past_lhs.unreachable { ret past_lhs; }\n@@ -1562,6 +1639,7 @@ fn trans_lazy_binop(bcx: block, op: lazy_binop_ty, a: @ast::expr,\n \n fn trans_binary(bcx: block, op: ast::binop, lhs: @ast::expr,\n                 rhs: @ast::expr, dest: dest, ex: @ast::expr) -> block {\n+    let _icx = bcx.insn_ctxt(\"trans_binary\");\n     // User-defined operators\n     alt bcx.ccx().maps.method_map.find(ex.id) {\n       some(origin) {\n@@ -1596,6 +1674,7 @@ fn trans_binary(bcx: block, op: ast::binop, lhs: @ast::expr,\n fn trans_if(cx: block, cond: @ast::expr, thn: ast::blk,\n             els: option<@ast::expr>, dest: dest)\n     -> block {\n+    let _icx = cx.insn_ctxt(\"trans_if\");\n     let {bcx, val: cond_val} = trans_temp_expr(cx, cond);\n \n     let then_dest = dup_for_join(dest);\n@@ -1633,6 +1712,7 @@ fn trans_if(cx: block, cond: @ast::expr, thn: ast::blk,\n \n fn trans_for(cx: block, local: @ast::local, seq: @ast::expr,\n              body: ast::blk) -> block {\n+    let _icx = cx.insn_ctxt(\"trans_for\");\n     fn inner(bcx: block, local: @ast::local, curr: ValueRef, t: ty::t,\n              body: ast::blk, outer_next_cx: block) -> block {\n         let next_cx = sub_block(bcx, \"next\");\n@@ -1665,6 +1745,7 @@ fn trans_for(cx: block, local: @ast::local, seq: @ast::expr,\n \n fn trans_while(cx: block, cond: @ast::expr, body: ast::blk)\n     -> block {\n+    let _icx = cx.insn_ctxt(\"trans_while\");\n     let next_cx = sub_block(cx, \"while next\");\n     let loop_cx = loop_scope_block(cx, cont_self, next_cx,\n                                    \"while loop\", body.span);\n@@ -1682,6 +1763,7 @@ fn trans_while(cx: block, cond: @ast::expr, body: ast::blk)\n \n fn trans_do_while(cx: block, body: ast::blk, cond: @ast::expr) ->\n     block {\n+    let _icx = cx.insn_ctxt(\"trans_do_while\");\n     let next_cx = sub_block(cx, \"next\");\n     let body_cx =\n         loop_scope_block(cx, cont_self, next_cx,\n@@ -1697,6 +1779,7 @@ fn trans_do_while(cx: block, body: ast::blk, cond: @ast::expr) ->\n }\n \n fn trans_loop(cx:block, body: ast::blk) -> block {\n+    let _icx = cx.insn_ctxt(\"trans_loop\");\n     let next_cx = sub_block(cx, \"next\");\n     let body_cx =\n         loop_scope_block(cx, cont_self, next_cx,\n@@ -1830,6 +1913,7 @@ fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: [ty::t],\n fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n                   vtables: option<typeck::vtable_res>)\n     -> {val: ValueRef, must_cast: bool, intrinsic: bool} {\n+    let _icx = ccx.insn_ctxt(\"monomorphic_fn\");\n     let mut must_cast = false;\n     let substs = vec::map(real_substs, {|t|\n         alt normalize_for_monomorphization(ccx.tcx, t) {\n@@ -1932,6 +2016,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n \n fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n     -> ast::def_id {\n+    let _icx = ccx.insn_ctxt(\"maybe_instantiate_inline\");\n     alt ccx.external.find(fn_id) {\n       some(some(node_id)) {\n         // Already inline\n@@ -1988,6 +2073,7 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n \n fn lval_intrinsic_fn(bcx: block, val: ValueRef, tys: [ty::t],\n                      id: ast::node_id) -> lval_maybe_callee {\n+    let _icx = bcx.insn_ctxt(\"lval_intrinsic_fn\");\n     fn add_tydesc_params(ccx: @crate_ctxt, llfty: TypeRef, n: uint)\n         -> TypeRef {\n         let out_ty = llvm::LLVMGetReturnType(llfty);\n@@ -2016,6 +2102,7 @@ fn lval_intrinsic_fn(bcx: block, val: ValueRef, tys: [ty::t],\n \n fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id)\n     -> lval_maybe_callee {\n+    let _icx = bcx.insn_ctxt(\"lval_static_fn\");\n     let vts = option::map(bcx.ccx().maps.vtable_map.find(id), {|vts|\n         impl::resolve_vtables_in_fn_ctxt(bcx.fcx, vts)\n     });\n@@ -2025,6 +2112,7 @@ fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id)\n fn lval_static_fn_inner(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n                         tys: [ty::t], vtables: option<typeck::vtable_res>)\n     -> lval_maybe_callee {\n+    let _icx = bcx.insn_ctxt(\"lval_static_fn_inner\");\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n     let tpt = ty::lookup_item_type(tcx, fn_id);\n \n@@ -2078,6 +2166,7 @@ fn lval_static_fn_inner(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n }\n \n fn lookup_discriminant(ccx: @crate_ctxt, vid: ast::def_id) -> ValueRef {\n+    let _icx = ccx.insn_ctxt(\"lookup_discriminant\");\n     alt ccx.discrims.find(vid) {\n       none {\n         // It's an external discriminant that we haven't seen yet.\n@@ -2096,6 +2185,7 @@ fn lookup_discriminant(ccx: @crate_ctxt, vid: ast::def_id) -> ValueRef {\n }\n \n fn trans_local_var(cx: block, def: ast::def) -> local_var_result {\n+    let _icx = cx.insn_ctxt(\"trans_local_var\");\n     fn take_local(table: hashmap<ast::node_id, local_val>,\n                   id: ast::node_id) -> local_var_result {\n         alt table.find(id) {\n@@ -2135,6 +2225,7 @@ fn trans_local_var(cx: block, def: ast::def) -> local_var_result {\n // gets turned into a record field name.\n fn trans_path(cx: block, id: ast::node_id, path: @ast::path)\n     -> lval_maybe_callee {\n+    let _icx = cx.insn_ctxt(\"trans_path\");\n     alt cx.tcx().def_map.find(id) {\n       none { cx.sess().bug(\"trans_path: unbound node ID\"); }\n       some(df) {\n@@ -2145,6 +2236,7 @@ fn trans_path(cx: block, id: ast::node_id, path: @ast::path)\n \n fn trans_var(cx: block, def: ast::def, id: ast::node_id, path: @ast::path)\n     -> lval_maybe_callee {\n+    let _icx = cx.insn_ctxt(\"trans_var\");\n     let ccx = cx.ccx();\n     alt def {\n       ast::def_fn(did, _) {\n@@ -2199,6 +2291,7 @@ fn trans_var(cx: block, def: ast::def, id: ast::node_id, path: @ast::path)\n \n fn trans_rec_field(bcx: block, base: @ast::expr,\n                    field: ast::ident) -> lval_result {\n+    let _icx = bcx.insn_ctxt(\"trans_rec_field\");\n     let {bcx, val} = trans_temp_expr(bcx, base);\n     let {bcx, val, ty} = autoderef(bcx, val, expr_ty(bcx, base));\n     let fields = alt ty::get(ty).struct {\n@@ -2215,6 +2308,7 @@ fn trans_rec_field(bcx: block, base: @ast::expr,\n \n fn trans_index(cx: block, ex: @ast::expr, base: @ast::expr,\n                idx: @ast::expr) -> lval_result {\n+    let _icx = cx.insn_ctxt(\"trans_index\");\n     let base_ty = expr_ty(cx, base);\n     let exp = trans_temp_expr(cx, base);\n     let lv = autoderef(exp.bcx, exp.val, base_ty);\n@@ -2257,6 +2351,7 @@ fn expr_is_lval(bcx: block, e: @ast::expr) -> bool {\n }\n \n fn trans_callee(bcx: block, e: @ast::expr) -> lval_maybe_callee {\n+    let _icx = bcx.insn_ctxt(\"trans_callee\");\n     alt e.node {\n       ast::expr_path(path) { ret trans_path(bcx, e.id, path); }\n       ast::expr_field(base, ident, _) {\n@@ -2283,6 +2378,7 @@ fn trans_callee(bcx: block, e: @ast::expr) -> lval_maybe_callee {\n // represented as an alloca or heap, hence needs a 'load' to be used as an\n // immediate).\n fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n+    let _icx = cx.insn_ctxt(\"trans_lval\");\n     alt e.node {\n       ast::expr_path(p) {\n           let v = trans_path(cx, e.id, p);\n@@ -2343,6 +2439,7 @@ fn lval_maybe_callee_to_lval(c: lval_maybe_callee, ty: ty::t) -> lval_result {\n \n fn int_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n             llsrc: ValueRef, signed: bool) -> ValueRef {\n+    let _icx = bcx.insn_ctxt(\"int_cast\");\n     let srcsz = llvm::LLVMGetIntTypeWidth(llsrctype);\n     let dstsz = llvm::LLVMGetIntTypeWidth(lldsttype);\n     ret if dstsz == srcsz {\n@@ -2356,6 +2453,7 @@ fn int_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n \n fn float_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n               llsrc: ValueRef) -> ValueRef {\n+    let _icx = bcx.insn_ctxt(\"float_cast\");\n     let srcsz = lib::llvm::float_width(llsrctype);\n     let dstsz = lib::llvm::float_width(lldsttype);\n     ret if dstsz > srcsz {\n@@ -2378,6 +2476,7 @@ fn cast_type_kind(t: ty::t) -> cast_kind {\n \n fn trans_cast(cx: block, e: @ast::expr, id: ast::node_id,\n               dest: dest) -> block {\n+    let _icx = cx.insn_ctxt(\"trans_cast\");\n     let ccx = cx.ccx();\n     let t_out = node_id_type(cx, id);\n     alt ty::get(t_out).struct {\n@@ -2443,6 +2542,7 @@ fn trans_cast(cx: block, e: @ast::expr, id: ast::node_id,\n // call takes place:\n fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n                   &temp_cleanups: [ValueRef]) -> result {\n+    let _icx = cx.insn_ctxt(\"trans_arg_expr\");\n     let ccx = cx.ccx();\n     let e_ty = expr_ty(cx, e);\n     let is_bot = ty::type_is_bot(e_ty);\n@@ -2522,7 +2622,7 @@ enum call_args {\n fn trans_args(cx: block, llenv: ValueRef, args: call_args, fn_ty: ty::t,\n               dest: dest, generic_intrinsic: bool)\n     -> {bcx: block, args: [ValueRef], retslot: ValueRef} {\n-\n+    let _icx = cx.insn_ctxt(\"trans_args\");\n     let mut temp_cleanups = [];\n     let arg_tys = ty::ty_fn_args(fn_ty);\n     let mut llargs: [ValueRef] = [];\n@@ -2592,6 +2692,7 @@ fn trans_args(cx: block, llenv: ValueRef, args: call_args, fn_ty: ty::t,\n fn trans_call(in_cx: block, f: @ast::expr,\n               args: call_args, id: ast::node_id, dest: dest)\n     -> block {\n+    let _icx = in_cx.insn_ctxt(\"trans_call\");\n     trans_call_inner(in_cx, expr_ty(in_cx, f), node_id_type(in_cx, id),\n                      {|cx| trans_callee(cx, f)}, args, dest)\n }\n@@ -2673,6 +2774,7 @@ fn invoke_full(bcx: block, llfn: ValueRef, llargs: [ValueRef])\n fn invoke_(bcx: block, llfn: ValueRef, llargs: [ValueRef],\n            invoker: fn(block, ValueRef, [ValueRef],\n                        BasicBlockRef, BasicBlockRef)) -> block {\n+    let _icx = bcx.insn_ctxt(\"invoke_\");\n     // FIXME: May be worth turning this into a plain call when there are no\n     // cleanups to run\n     if bcx.unreachable { ret bcx; }\n@@ -2688,6 +2790,7 @@ fn invoke_(bcx: block, llfn: ValueRef, llargs: [ValueRef],\n }\n \n fn get_landing_pad(bcx: block) -> BasicBlockRef {\n+    let _icx = bcx.insn_ctxt(\"get_landing_pad\");\n     fn in_lpad_scope_cx(bcx: block, f: fn(scope_info)) {\n         let mut bcx = bcx;\n         loop {\n@@ -2749,6 +2852,7 @@ fn get_landing_pad(bcx: block) -> BasicBlockRef {\n }\n \n fn trans_tup(bcx: block, elts: [@ast::expr], dest: dest) -> block {\n+    let _icx = bcx.insn_ctxt(\"trans_tup\");\n     let mut bcx = bcx;\n     let addr = alt dest {\n       ignore {\n@@ -2774,6 +2878,7 @@ fn trans_tup(bcx: block, elts: [@ast::expr], dest: dest) -> block {\n fn trans_rec(bcx: block, fields: [ast::field],\n              base: option<@ast::expr>, id: ast::node_id,\n              dest: dest) -> block {\n+    let _icx = bcx.insn_ctxt(\"trans_rec\");\n     let t = node_id_type(bcx, id);\n     let mut bcx = bcx;\n     let addr = alt dest {\n@@ -2841,6 +2946,7 @@ fn trans_expr_save_in(bcx: block, e: @ast::expr, dest: ValueRef)\n // trans_expr_save_in. For intermediates where you don't care about lval-ness,\n // use trans_temp_expr.\n fn trans_temp_lval(bcx: block, e: @ast::expr) -> lval_result {\n+    let _icx = bcx.insn_ctxt(\"trans_temp_lval\");\n     let mut bcx = bcx;\n     if expr_is_lval(bcx, e) {\n         ret trans_lval(bcx, e);\n@@ -2866,6 +2972,7 @@ fn trans_temp_lval(bcx: block, e: @ast::expr) -> lval_result {\n // Use only for intermediate values. See trans_expr and trans_expr_save_in for\n // expressions that must 'end up somewhere' (or get ignored).\n fn trans_temp_expr(bcx: block, e: @ast::expr) -> result {\n+    let _icx = bcx.insn_ctxt(\"trans_temp_expr\");\n     let mut {bcx, val, kind} = trans_temp_lval(bcx, e);\n     if kind == owned {\n         val = load_if_immediate(bcx, val, expr_ty(bcx, e));\n@@ -2878,6 +2985,7 @@ fn trans_temp_expr(bcx: block, e: @ast::expr) -> result {\n // - exprs returning nil or bot always get dest=ignore\n // - exprs with non-immediate type never get dest=by_val\n fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n+    let _icx = bcx.insn_ctxt(\"trans_expr\");\n     let tcx = bcx.tcx();\n     debuginfo::update_source_pos(bcx, e.span);\n \n@@ -3163,16 +3271,19 @@ fn do_spill_noroot(cx: block, v: ValueRef) -> ValueRef {\n }\n \n fn spill_if_immediate(cx: block, v: ValueRef, t: ty::t) -> result {\n+    let _icx = cx.insn_ctxt(\"spill_if_immediate\");\n     if ty::type_is_immediate(t) { ret do_spill(cx, v, t); }\n     ret rslt(cx, v);\n }\n \n fn load_if_immediate(cx: block, v: ValueRef, t: ty::t) -> ValueRef {\n+    let _icx = cx.insn_ctxt(\"load_if_immediate\");\n     if ty::type_is_immediate(t) { ret Load(cx, v); }\n     ret v;\n }\n \n fn trans_log(lvl: @ast::expr, bcx: block, e: @ast::expr) -> block {\n+    let _icx = bcx.insn_ctxt(\"trans_log\");\n     let ccx = bcx.ccx();\n     if ty::type_is_bot(expr_ty(bcx, lvl)) {\n        ret trans_expr(bcx, lvl, ignore);\n@@ -3218,6 +3329,7 @@ fn trans_log(lvl: @ast::expr, bcx: block, e: @ast::expr) -> block {\n }\n \n fn trans_check_expr(bcx: block, e: @ast::expr, s: str) -> block {\n+    let _icx = bcx.insn_ctxt(\"trans_check_expr\");\n     let expr_str = s + \" \" + expr_to_str(e) + \" failed\";\n     let {bcx, val} = with_scope_result(bcx, \"check\") {|bcx|\n         trans_temp_expr(bcx, e)\n@@ -3229,6 +3341,7 @@ fn trans_check_expr(bcx: block, e: @ast::expr, s: str) -> block {\n \n fn trans_fail_expr(bcx: block, sp_opt: option<span>,\n                    fail_expr: option<@ast::expr>) -> block {\n+    let _icx = bcx.insn_ctxt(\"trans_fail_expr\");\n     let mut bcx = bcx;\n     alt fail_expr {\n       some(expr) {\n@@ -3256,12 +3369,14 @@ fn trans_fail_expr(bcx: block, sp_opt: option<span>,\n \n fn trans_fail(bcx: block, sp_opt: option<span>, fail_str: str) ->\n     block {\n+    let _icx = bcx.insn_ctxt(\"trans_fail\");\n     let V_fail_str = C_cstr(bcx.ccx(), fail_str);\n     ret trans_fail_value(bcx, sp_opt, V_fail_str);\n }\n \n fn trans_fail_value(bcx: block, sp_opt: option<span>,\n                     V_fail_str: ValueRef) -> block {\n+    let _icx = bcx.insn_ctxt(\"trans_fail_value\");\n     let ccx = bcx.ccx();\n     let {V_filename, V_line} = alt sp_opt {\n       some(sp) {\n@@ -3285,6 +3400,7 @@ fn trans_fail_value(bcx: block, sp_opt: option<span>,\n \n fn trans_break_cont(bcx: block, to_end: bool)\n     -> block {\n+    let _icx = bcx.insn_ctxt(\"trans_break_cont\");\n     // Locate closest loop block, outputting cleanup as we go.\n     let mut unwind = bcx;\n     let mut target = bcx;\n@@ -3325,6 +3441,7 @@ fn trans_cont(cx: block) -> block {\n }\n \n fn trans_ret(bcx: block, e: option<@ast::expr>) -> block {\n+    let _icx = bcx.insn_ctxt(\"trans_ret\");\n     let mut bcx = bcx;\n     alt e {\n       some(x) { bcx = trans_expr_save_in(bcx, x, bcx.fcx.llretptr); }\n@@ -3335,15 +3452,20 @@ fn trans_ret(bcx: block, e: option<@ast::expr>) -> block {\n     ret bcx;\n }\n \n-fn build_return(bcx: block) { Br(bcx, bcx.fcx.llreturn); }\n+fn build_return(bcx: block) {\n+    let _icx = bcx.insn_ctxt(\"build_return\");\n+    Br(bcx, bcx.fcx.llreturn);\n+}\n \n fn trans_be(cx: block, e: @ast::expr) -> block {\n     // FIXME: Turn this into a real tail call once\n     // calling convention issues are settled\n+    let _icx = cx.insn_ctxt(\"trans_be\");\n     ret trans_ret(cx, some(e));\n }\n \n fn init_local(bcx: block, local: @ast::local) -> block {\n+    let _icx = bcx.insn_ctxt(\"init_local\");\n     let ty = node_id_type(bcx, local.node.id);\n     let llptr = alt bcx.fcx.lllocals.find(local.node.id) {\n       some(local_mem(v)) { v }\n@@ -3390,6 +3512,7 @@ fn init_local(bcx: block, local: @ast::local) -> block {\n \n fn zero_alloca(cx: block, llptr: ValueRef, t: ty::t)\n     -> block {\n+    let _icx = cx.insn_ctxt(\"zero_alloca\");\n     let bcx = cx;\n     let ccx = cx.ccx();\n     let llty = type_of(ccx, t);\n@@ -3398,6 +3521,7 @@ fn zero_alloca(cx: block, llptr: ValueRef, t: ty::t)\n }\n \n fn trans_stmt(cx: block, s: ast::stmt) -> block {\n+    let _icx = cx.insn_ctxt(\"trans_stmt\");\n     #debug[\"trans_stmt(%s)\", stmt_to_str(s)];\n \n     if (!cx.sess().opts.no_asm_comments) {\n@@ -3509,6 +3633,7 @@ fn raw_block(fcx: fn_ctxt, llbb: BasicBlockRef) -> block {\n // trans_block_cleanups runs all the cleanup functions for the block.\n fn trans_block_cleanups(bcx: block, cleanup_cx: block) ->\n    block {\n+    let _icx = bcx.insn_ctxt(\"trans_block_cleanups\");\n     if bcx.unreachable { ret bcx; }\n     let mut bcx = bcx;\n     alt check cleanup_cx.kind {\n@@ -3526,6 +3651,7 @@ fn trans_block_cleanups(bcx: block, cleanup_cx: block) ->\n // instruction.\n fn cleanup_and_leave(bcx: block, upto: option<BasicBlockRef>,\n                      leave: option<BasicBlockRef>) {\n+    let _icx = bcx.insn_ctxt(\"cleanup_and_leave\");\n     let mut cur = bcx, bcx = bcx;\n     loop {\n         alt cur.kind {\n@@ -3560,31 +3686,36 @@ fn cleanup_and_leave(bcx: block, upto: option<BasicBlockRef>,\n \n fn cleanup_and_Br(bcx: block, upto: block,\n                   target: BasicBlockRef) {\n+    let _icx = bcx.insn_ctxt(\"cleanup_and_Br\");\n     cleanup_and_leave(bcx, some(upto.llbb), some(target));\n }\n \n fn leave_block(bcx: block, out_of: block) -> block {\n+    let _icx = bcx.insn_ctxt(\"leave_block\");\n     let next_cx = sub_block(block_parent(out_of), \"next\");\n     if bcx.unreachable { Unreachable(next_cx); }\n     cleanup_and_Br(bcx, out_of, next_cx.llbb);\n     next_cx\n }\n \n fn with_scope(bcx: block, name: str, f: fn(block) -> block) -> block {\n+    let _icx = bcx.insn_ctxt(\"with_scope\");\n     let scope_cx = scope_block(bcx, name);\n     Br(bcx, scope_cx.llbb);\n     leave_block(f(scope_cx), scope_cx)\n }\n \n fn with_scope_result(bcx: block, name: str, f: fn(block) -> result)\n     -> result {\n+    let _icx = bcx.insn_ctxt(\"with_scope_result\");\n     let scope_cx = scope_block(bcx, name);\n     Br(bcx, scope_cx.llbb);\n     let {bcx, val} = f(scope_cx);\n     {bcx: leave_block(bcx, scope_cx), val: val}\n }\n \n fn with_cond(bcx: block, val: ValueRef, f: fn(block) -> block) -> block {\n+    let _icx = bcx.insn_ctxt(\"with_cond\");\n     let next_cx = sub_block(bcx, \"next\"), cond_cx = sub_block(bcx, \"cond\");\n     CondBr(bcx, val, cond_cx.llbb, next_cx.llbb);\n     let after_cx = f(cond_cx);\n@@ -3609,6 +3740,7 @@ fn block_locals(b: ast::blk, it: fn(@ast::local)) {\n }\n \n fn alloc_ty(cx: block, t: ty::t) -> result {\n+    let _icx = cx.insn_ctxt(\"alloc_ty\");\n     let bcx = cx, ccx = cx.ccx();\n     let llty = type_of(ccx, t);\n     assert !ty::type_has_params(t);\n@@ -3625,6 +3757,7 @@ fn alloc_ty(cx: block, t: ty::t) -> result {\n }\n \n fn alloc_local(cx: block, local: @ast::local) -> block {\n+    let _icx = cx.insn_ctxt(\"alloc_local\");\n     let t = node_id_type(cx, local.node.id);\n     let simple_name = alt local.node.pat.node {\n       ast::pat_ident(pth, none) { some(path_to_ident(pth)) }\n@@ -3655,6 +3788,7 @@ fn alloc_local(cx: block, local: @ast::local) -> block {\n \n fn trans_block(bcx: block, b: ast::blk, dest: dest)\n     -> block {\n+    let _icx = bcx.insn_ctxt(\"trans_block\");\n     let mut bcx = bcx;\n     block_locals(b) {|local| bcx = alloc_local(bcx, local); };\n     for s: @ast::stmt in b.node.stmts {\n@@ -3737,6 +3871,7 @@ fn new_fn_ctxt(ccx: @crate_ctxt, path: path, llfndecl: ValueRef,\n fn create_llargs_for_fn_args(cx: fn_ctxt,\n                              ty_self: self_arg,\n                              args: [ast::arg]) {\n+    let _icx = cx.insn_ctxt(\"create_llargs_for_fn_args\");\n     // Skip the implicit arguments 0, and 1.\n     let mut arg_n = first_real_arg;\n     alt ty_self {\n@@ -3761,6 +3896,7 @@ fn create_llargs_for_fn_args(cx: fn_ctxt,\n \n fn copy_args_to_allocas(fcx: fn_ctxt, bcx: block, args: [ast::arg],\n                         arg_tys: [ty::arg]) -> block {\n+    let _icx = fcx.insn_ctxt(\"copy_args_to_allocas\");\n     let tcx = bcx.tcx();\n     let mut arg_n: uint = 0u, bcx = bcx;\n     let epic_fail = fn@() -> ! {\n@@ -3797,12 +3933,14 @@ fn copy_args_to_allocas(fcx: fn_ctxt, bcx: block, args: [ast::arg],\n // Ties up the llstaticallocas -> llloadenv -> lltop edges,\n // and builds the return block.\n fn finish_fn(fcx: fn_ctxt, lltop: BasicBlockRef) {\n+    let _icx = fcx.insn_ctxt(\"finish_fn\");\n     tie_up_header_blocks(fcx, lltop);\n     let ret_cx = raw_block(fcx, fcx.llreturn);\n     RetVoid(ret_cx);\n }\n \n fn tie_up_header_blocks(fcx: fn_ctxt, lltop: BasicBlockRef) {\n+    let _icx = fcx.insn_ctxt(\"tie_up_header_blocks\");\n     Br(raw_block(fcx, fcx.llstaticallocas), fcx.llloadenv);\n     Br(raw_block(fcx, fcx.llloadenv), lltop);\n }\n@@ -3818,6 +3956,7 @@ fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n                  param_substs: option<param_substs>,\n                  id: ast::node_id, maybe_self_id: option<@ast::expr>,\n                  maybe_load_env: fn(fn_ctxt)) {\n+    let _icx = ccx.insn_ctxt(\"trans_closure\");\n     set_uwtable(llfndecl);\n \n     // Set up arguments to the function.\n@@ -3873,6 +4012,7 @@ fn trans_fn(ccx: @crate_ctxt,\n     let do_time = ccx.sess.opts.stats;\n     let start = if do_time { time::get_time() }\n                 else { {sec: 0u32, usec: 0u32} };\n+    let _icx = ccx.insn_ctxt(\"trans_fn\");\n     trans_closure(ccx, path, decl, body, llfndecl, ty_self,\n                   param_substs, id, maybe_self_id, {|fcx|\n         if ccx.sess.opts.extra_debuginfo {\n@@ -3888,6 +4028,7 @@ fn trans_fn(ccx: @crate_ctxt,\n fn trans_res_ctor(ccx: @crate_ctxt, path: path, dtor: ast::fn_decl,\n                   ctor_id: ast::node_id,\n                   param_substs: option<param_substs>, llfndecl: ValueRef) {\n+    let _icx = ccx.insn_ctxt(\"trans_res_ctor\");\n     // Create a function for the constructor\n     let fcx = new_fn_ctxt_w_id(ccx, path, llfndecl, ctor_id,\n                                none, param_substs, none);\n@@ -3916,6 +4057,7 @@ fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n                       variant: ast::variant, disr: int, is_degen: bool,\n                       param_substs: option<param_substs>,\n                       llfndecl: ValueRef) {\n+    let _icx = ccx.insn_ctxt(\"trans_enum_variant\");\n     // Translate variant arguments to function arguments.\n     let mut fn_args = [], i = 0u;\n     for varg in variant.node.args {\n@@ -3971,6 +4113,7 @@ fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n // duplicate constants. I think. Maybe LLVM has a magical mode\n // that does so later on?\n fn trans_const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n+    let _icx = cx.insn_ctxt(\"trans_const_expr\");\n     alt e.node {\n       ast::expr_lit(lit) { ret trans_crate_lit(cx, *lit); }\n       ast::expr_binary(b, e1, e2) {\n@@ -4065,6 +4208,7 @@ fn trans_const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n }\n \n fn trans_const(ccx: @crate_ctxt, e: @ast::expr, id: ast::node_id) {\n+    let _icx = ccx.insn_ctxt(\"trans_const\");\n     let v = trans_const_expr(ccx, e);\n \n     // The scalars come back as 1st class LLVM vals\n@@ -4075,6 +4219,7 @@ fn trans_const(ccx: @crate_ctxt, e: @ast::expr, id: ast::node_id) {\n }\n \n fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n+    let _icx = ccx.insn_ctxt(\"trans_item\");\n     let path = alt check ccx.tcx.items.get(item.id) {\n       ast_map::node_item(_, p) { p }\n     };\n@@ -4224,6 +4369,7 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n // only as a convenience for humans working with the code, to organize names\n // and control visibility.\n fn trans_mod(ccx: @crate_ctxt, m: ast::_mod) {\n+    let _icx = ccx.insn_ctxt(\"trans_mod\");\n     for item in m.items { trans_item(ccx, *item); }\n }\n \n@@ -4454,6 +4600,7 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n \n // The constant translation pass.\n fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n+    let _icx = ccx.insn_ctxt(\"trans_constant\");\n     alt it.node {\n       ast::item_enum(variants, _) {\n         let vi = ty::enum_variants(ccx.tcx, {crate: ast::local_crate,\n@@ -4728,6 +4875,8 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n                mutable n_glues_created: 0u,\n                mutable n_null_glues: 0u,\n                mutable n_real_glues: 0u,\n+               llvm_insn_ctxt: @mutable [],\n+               llvm_insns: str_hash(),\n                fn_times: @mutable []},\n           upcalls:\n               upcall::declare_upcalls(targ_cfg, tn, tydesc_type,\n@@ -4742,8 +4891,18 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           crate_map: crate_map,\n           dbg_cx: dbg_cx,\n           mutable do_not_commit_warning_issued: false};\n-    trans_constants(ccx, crate);\n-    trans_mod(ccx, crate.node.module);\n+\n+\n+    {\n+        let _icx = ccx.insn_ctxt(\"data\");\n+        trans_constants(ccx, crate);\n+    }\n+\n+    {\n+        let _icx = ccx.insn_ctxt(\"text\");\n+        trans_mod(ccx, crate.node.module);\n+    }\n+\n     fill_crate_map(ccx, crate_map);\n     emit_tydescs(ccx);\n     gen_shape_tables(ccx);\n@@ -4752,14 +4911,23 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n     // Translate the metadata.\n     write_metadata(ccx, crate);\n     if ccx.sess.opts.stats {\n-        #error(\"--- trans stats ---\");\n-        #error(\"n_static_tydescs: %u\", ccx.stats.n_static_tydescs);\n-        #error(\"n_glues_created: %u\", ccx.stats.n_glues_created);\n-        #error(\"n_null_glues: %u\", ccx.stats.n_null_glues);\n-        #error(\"n_real_glues: %u\", ccx.stats.n_real_glues);\n+        io::println(\"--- trans stats ---\");\n+        io::println(#fmt(\"n_static_tydescs: %u\",\n+                         ccx.stats.n_static_tydescs));\n+        io::println(#fmt(\"n_glues_created: %u\",\n+                         ccx.stats.n_glues_created));\n+        io::println(#fmt(\"n_null_glues: %u\", ccx.stats.n_null_glues));\n+        io::println(#fmt(\"n_real_glues: %u\", ccx.stats.n_real_glues));\n \n         for timing: {ident: str, time: int} in *ccx.stats.fn_times {\n-            #error(\"time: %s took %d ms\", timing.ident, timing.time);\n+            io::println(#fmt(\"time: %s took %d ms\", timing.ident,\n+                             timing.time));\n+        }\n+    }\n+\n+    if ccx.sess.opts.count_llvm_insns {\n+        ccx.stats.llvm_insns.items() { |k, v|\n+            io::println(#fmt(\"%-7u %s\", v, k));\n         }\n     }\n     ret (llmod, link_meta);"}, {"sha": "c547c36db765a03e10ec209380f6d8ffd739023f", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 141, "deletions": 4, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/b224bcf6e1b4230f7f85858d3009ac7f60bb12f6/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b224bcf6e1b4230f7f85858d3009ac7f60bb12f6/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=b224bcf6e1b4230f7f85858d3009ac7f60bb12f6", "patch": "@@ -1,3 +1,4 @@\n+import std::map::{hashmap, str_hash};\n import libc::{c_uint, c_int};\n import lib::llvm::llvm;\n import syntax::codemap;\n@@ -13,6 +14,46 @@ fn B(cx: block) -> BuilderRef {\n     ret b;\n }\n \n+fn count_insn(cx: block, category: str) {\n+    if (cx.ccx().sess.opts.count_llvm_insns) {\n+\n+        let h = cx.ccx().stats.llvm_insns;\n+        let mut v = cx.ccx().stats.llvm_insn_ctxt;\n+\n+        // Build version of path with cycles removed.\n+\n+        // Pass 1: scan table mapping str -> rightmost pos.\n+        let mm = str_hash();\n+        let len = vec::len(*v);\n+        let mut i = 0u;\n+        while i < len {\n+            mm.insert(copy v[i], i);\n+            i += 1u;\n+        }\n+\n+\n+        // Pass 2: concat strings for each elt, skipping\n+        // forwards over any cycles by advancing to rightmost\n+        // occurrence of each element in path.\n+        let mut s = \".\";\n+        i = 0u;\n+        while i < len {\n+            let e = v[i];\n+            i = mm.get(e);\n+            s += \"/\";\n+            s += e;\n+            i += 1u;\n+        }\n+\n+        s += \"/\";\n+        s += category;\n+\n+        let n = alt h.find(s) { some(n) { n } _ { 0u } };\n+        h.insert(s, n+1u);\n+    }\n+}\n+\n+\n // The difference between a block being unreachable and being terminated is\n // somewhat obscure, and has to do with error checking. When a block is\n // terminated, we're saying that trying to add any further statements in the\n@@ -25,13 +66,15 @@ fn RetVoid(cx: block) {\n     if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n+    count_insn(cx, \"retvoid\");\n     llvm::LLVMBuildRetVoid(B(cx));\n }\n \n fn Ret(cx: block, V: ValueRef) {\n     if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n+    count_insn(cx, \"ret\");\n     llvm::LLVMBuildRet(B(cx), V);\n }\n \n@@ -49,6 +92,7 @@ fn Br(cx: block, Dest: BasicBlockRef) {\n     if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n+    count_insn(cx, \"br\");\n     llvm::LLVMBuildBr(B(cx), Dest);\n }\n \n@@ -57,6 +101,7 @@ fn CondBr(cx: block, If: ValueRef, Then: BasicBlockRef,\n     if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n+    count_insn(cx, \"condbr\");\n     llvm::LLVMBuildCondBr(B(cx), If, Then, Else);\n }\n \n@@ -77,6 +122,7 @@ fn IndirectBr(cx: block, Addr: ValueRef, NumDests: uint) {\n     if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n+    count_insn(cx, \"indirectbr\");\n     llvm::LLVMBuildIndirectBr(B(cx), Addr, NumDests as c_uint);\n }\n \n@@ -97,6 +143,7 @@ fn Invoke(cx: block, Fn: ValueRef, Args: [ValueRef],\n            str::connect(vec::map(Args, {|a|val_str(cx.ccx().tn, a)}),\n                         \", \")];\n     unsafe {\n+        count_insn(cx, \"invoke\");\n         llvm::LLVMBuildInvoke(B(cx), Fn, vec::unsafe::to_ptr(Args),\n                               Args.len() as c_uint, Then, Catch,\n                               noname());\n@@ -109,6 +156,7 @@ fn FastInvoke(cx: block, Fn: ValueRef, Args: [ValueRef],\n     assert (!cx.terminated);\n     cx.terminated = true;\n     unsafe {\n+        count_insn(cx, \"fastinvoke\");\n         let v = llvm::LLVMBuildInvoke(B(cx), Fn, vec::unsafe::to_ptr(Args),\n                                       Args.len() as c_uint,\n                                       Then, Catch, noname());\n@@ -119,7 +167,10 @@ fn FastInvoke(cx: block, Fn: ValueRef, Args: [ValueRef],\n fn Unreachable(cx: block) {\n     if cx.unreachable { ret; }\n     cx.unreachable = true;\n-    if !cx.terminated { llvm::LLVMBuildUnreachable(B(cx)); }\n+    if !cx.terminated {\n+        count_insn(cx, \"unreachable\");\n+        llvm::LLVMBuildUnreachable(B(cx));\n+    }\n }\n \n fn _Undef(val: ValueRef) -> ValueRef {\n@@ -129,182 +180,218 @@ fn _Undef(val: ValueRef) -> ValueRef {\n /* Arithmetic */\n fn Add(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n+    count_insn(cx, \"add\");\n     ret llvm::LLVMBuildAdd(B(cx), LHS, RHS, noname());\n }\n \n fn NSWAdd(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n+    count_insn(cx, \"nswadd\");\n     ret llvm::LLVMBuildNSWAdd(B(cx), LHS, RHS, noname());\n }\n \n fn NUWAdd(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n+    count_insn(cx, \"nuwadd\");\n     ret llvm::LLVMBuildNUWAdd(B(cx), LHS, RHS, noname());\n }\n \n fn FAdd(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n+    count_insn(cx, \"fadd\");\n     ret llvm::LLVMBuildFAdd(B(cx), LHS, RHS, noname());\n }\n \n fn Sub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n+    count_insn(cx, \"sub\");\n     ret llvm::LLVMBuildSub(B(cx), LHS, RHS, noname());\n }\n \n fn NSWSub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n+    count_insn(cx, \"nwsub\");\n     ret llvm::LLVMBuildNSWSub(B(cx), LHS, RHS, noname());\n }\n \n fn NUWSub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n+    count_insn(cx, \"nuwsub\");\n     ret llvm::LLVMBuildNUWSub(B(cx), LHS, RHS, noname());\n }\n \n fn FSub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n+    count_insn(cx, \"sub\");\n     ret llvm::LLVMBuildFSub(B(cx), LHS, RHS, noname());\n }\n \n fn Mul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n+    count_insn(cx, \"mul\");\n     ret llvm::LLVMBuildMul(B(cx), LHS, RHS, noname());\n }\n \n fn NSWMul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n+    count_insn(cx, \"nswmul\");\n     ret llvm::LLVMBuildNSWMul(B(cx), LHS, RHS, noname());\n }\n \n fn NUWMul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n+    count_insn(cx, \"nuwmul\");\n     ret llvm::LLVMBuildNUWMul(B(cx), LHS, RHS, noname());\n }\n \n fn FMul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n+    count_insn(cx, \"fmul\");\n     ret llvm::LLVMBuildFMul(B(cx), LHS, RHS, noname());\n }\n \n fn UDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n+    count_insn(cx, \"udiv\");\n     ret llvm::LLVMBuildUDiv(B(cx), LHS, RHS, noname());\n }\n \n fn SDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n+    count_insn(cx, \"sdiv\");\n     ret llvm::LLVMBuildSDiv(B(cx), LHS, RHS, noname());\n }\n \n fn ExactSDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n+    count_insn(cx, \"extractsdiv\");\n     ret llvm::LLVMBuildExactSDiv(B(cx), LHS, RHS, noname());\n }\n \n fn FDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n+    count_insn(cx, \"fdiv\");\n     ret llvm::LLVMBuildFDiv(B(cx), LHS, RHS, noname());\n }\n \n fn URem(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n+    count_insn(cx, \"urem\");\n     ret llvm::LLVMBuildURem(B(cx), LHS, RHS, noname());\n }\n \n fn SRem(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n+    count_insn(cx, \"srem\");\n     ret llvm::LLVMBuildSRem(B(cx), LHS, RHS, noname());\n }\n \n fn FRem(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n+    count_insn(cx, \"frem\");\n     ret llvm::LLVMBuildFRem(B(cx), LHS, RHS, noname());\n }\n \n fn Shl(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n+    count_insn(cx, \"shl\");\n     ret llvm::LLVMBuildShl(B(cx), LHS, RHS, noname());\n }\n \n fn LShr(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n+    count_insn(cx, \"lshr\");\n     ret llvm::LLVMBuildLShr(B(cx), LHS, RHS, noname());\n }\n \n fn AShr(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n+    count_insn(cx, \"ashr\");\n     ret llvm::LLVMBuildAShr(B(cx), LHS, RHS, noname());\n }\n \n fn And(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n+    count_insn(cx, \"and\");\n     ret llvm::LLVMBuildAnd(B(cx), LHS, RHS, noname());\n }\n \n fn Or(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n+    count_insn(cx, \"or\");\n     ret llvm::LLVMBuildOr(B(cx), LHS, RHS, noname());\n }\n \n fn Xor(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n+    count_insn(cx, \"xor\");\n     ret llvm::LLVMBuildXor(B(cx), LHS, RHS, noname());\n }\n \n fn BinOp(cx: block, Op: Opcode, LHS: ValueRef, RHS: ValueRef) ->\n    ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n+    count_insn(cx, \"binop\");\n     ret llvm::LLVMBuildBinOp(B(cx), Op, LHS, RHS, noname());\n }\n \n fn Neg(cx: block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(V); }\n+    count_insn(cx, \"neg\");\n     ret llvm::LLVMBuildNeg(B(cx), V, noname());\n }\n \n fn NSWNeg(cx: block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(V); }\n+    count_insn(cx, \"nswneg\");\n     ret llvm::LLVMBuildNSWNeg(B(cx), V, noname());\n }\n \n fn NUWNeg(cx: block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(V); }\n+    count_insn(cx, \"nuwneg\");\n     ret llvm::LLVMBuildNUWNeg(B(cx), V, noname());\n }\n fn FNeg(cx: block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(V); }\n+    count_insn(cx, \"fneg\");\n     ret llvm::LLVMBuildFNeg(B(cx), V, noname());\n }\n \n fn Not(cx: block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(V); }\n+    count_insn(cx, \"not\");\n     ret llvm::LLVMBuildNot(B(cx), V, noname());\n }\n \n /* Memory */\n fn Malloc(cx: block, Ty: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_i8())); }\n+    count_insn(cx, \"malloc\");\n     ret llvm::LLVMBuildMalloc(B(cx), Ty, noname());\n }\n \n fn ArrayMalloc(cx: block, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_i8())); }\n+    count_insn(cx, \"arraymalloc\");\n     ret llvm::LLVMBuildArrayMalloc(B(cx), Ty, Val, noname());\n }\n \n fn Alloca(cx: block, Ty: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(Ty)); }\n+    count_insn(cx, \"alloca\");\n     ret llvm::LLVMBuildAlloca(B(cx), Ty, noname());\n }\n \n fn ArrayAlloca(cx: block, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(Ty)); }\n+    count_insn(cx, \"arrayalloca\");\n     ret llvm::LLVMBuildArrayAlloca(B(cx), Ty, Val, noname());\n }\n \n fn Free(cx: block, PointerVal: ValueRef) {\n     if cx.unreachable { ret; }\n+    count_insn(cx, \"free\");\n     llvm::LLVMBuildFree(B(cx), PointerVal);\n }\n \n@@ -316,6 +403,7 @@ fn Load(cx: block, PointerVal: ValueRef) -> ValueRef {\n             llvm::LLVMGetElementType(ty) } else { ccx.int_type };\n         ret llvm::LLVMGetUndef(eltty);\n     }\n+    count_insn(cx, \"load\");\n     ret llvm::LLVMBuildLoad(B(cx), PointerVal, noname());\n }\n \n@@ -324,13 +412,15 @@ fn Store(cx: block, Val: ValueRef, Ptr: ValueRef) {\n     #debug[\"Store %s -> %s\",\n            val_str(cx.ccx().tn, Val),\n            val_str(cx.ccx().tn, Ptr)];\n+    count_insn(cx, \"store\");\n     llvm::LLVMBuildStore(B(cx), Val, Ptr);\n }\n \n fn GEP(cx: block, Pointer: ValueRef, Indices: [ValueRef]) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_nil())); }\n     unsafe {\n-        ret llvm::LLVMBuildGEP(B(cx), Pointer, vec::unsafe::to_ptr(Indices),\n+    count_insn(cx, \"gep\");\n+    ret llvm::LLVMBuildGEP(B(cx), Pointer, vec::unsafe::to_ptr(Indices),\n                                Indices.len() as c_uint, noname());\n     }\n }\n@@ -340,14 +430,16 @@ fn GEP(cx: block, Pointer: ValueRef, Indices: [ValueRef]) -> ValueRef {\n fn GEPi(cx: block, base: ValueRef, ixs: [int]) -> ValueRef {\n     let mut v: [ValueRef] = [];\n     for i: int in ixs { v += [C_i32(i as i32)]; }\n+    count_insn(cx, \"gepi\");\n     ret InBoundsGEP(cx, base, v);\n }\n \n fn InBoundsGEP(cx: block, Pointer: ValueRef, Indices: [ValueRef]) ->\n    ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_nil())); }\n     unsafe {\n-        ret llvm::LLVMBuildInBoundsGEP(B(cx), Pointer,\n+        count_insn(cx, \"inboundsgep\");\n+    ret llvm::LLVMBuildInBoundsGEP(B(cx), Pointer,\n                                        vec::unsafe::to_ptr(Indices),\n                                        Indices.len() as c_uint,\n                                        noname());\n@@ -356,116 +448,138 @@ fn InBoundsGEP(cx: block, Pointer: ValueRef, Indices: [ValueRef]) ->\n \n fn StructGEP(cx: block, Pointer: ValueRef, Idx: uint) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_nil())); }\n+    count_insn(cx, \"structgep\");\n     ret llvm::LLVMBuildStructGEP(B(cx), Pointer, Idx as c_uint, noname());\n }\n \n fn GlobalString(cx: block, _Str: *libc::c_char) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_i8())); }\n+    count_insn(cx, \"globalstring\");\n     ret llvm::LLVMBuildGlobalString(B(cx), _Str, noname());\n }\n \n fn GlobalStringPtr(cx: block, _Str: *libc::c_char) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_i8())); }\n+    count_insn(cx, \"globalstringptr\");\n     ret llvm::LLVMBuildGlobalStringPtr(B(cx), _Str, noname());\n }\n \n /* Casts */\n fn Trunc(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    count_insn(cx, \"trunc\");\n     ret llvm::LLVMBuildTrunc(B(cx), Val, DestTy, noname());\n }\n \n fn ZExt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    count_insn(cx, \"zext\");\n     ret llvm::LLVMBuildZExt(B(cx), Val, DestTy, noname());\n }\n \n fn SExt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    count_insn(cx, \"sext\");\n     ret llvm::LLVMBuildSExt(B(cx), Val, DestTy, noname());\n }\n \n fn FPToUI(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    count_insn(cx, \"fptoui\");\n     ret llvm::LLVMBuildFPToUI(B(cx), Val, DestTy, noname());\n }\n \n fn FPToSI(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    count_insn(cx, \"fptosi\");\n     ret llvm::LLVMBuildFPToSI(B(cx), Val, DestTy, noname());\n }\n \n fn UIToFP(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    count_insn(cx, \"uitofp\");\n     ret llvm::LLVMBuildUIToFP(B(cx), Val, DestTy, noname());\n }\n \n fn SIToFP(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    count_insn(cx, \"sitofp\");\n     ret llvm::LLVMBuildSIToFP(B(cx), Val, DestTy, noname());\n }\n \n fn FPTrunc(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    count_insn(cx, \"fptrunc\");\n     ret llvm::LLVMBuildFPTrunc(B(cx), Val, DestTy, noname());\n }\n \n fn FPExt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    count_insn(cx, \"fpext\");\n     ret llvm::LLVMBuildFPExt(B(cx), Val, DestTy, noname());\n }\n \n fn PtrToInt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    count_insn(cx, \"ptrtoint\");\n     ret llvm::LLVMBuildPtrToInt(B(cx), Val, DestTy, noname());\n }\n \n fn IntToPtr(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    count_insn(cx, \"inttoptr\");\n     ret llvm::LLVMBuildIntToPtr(B(cx), Val, DestTy, noname());\n }\n \n fn BitCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    count_insn(cx, \"bitcast\");\n     ret llvm::LLVMBuildBitCast(B(cx), Val, DestTy, noname());\n }\n \n fn ZExtOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) ->\n    ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    count_insn(cx, \"zextorbitcast\");\n     ret llvm::LLVMBuildZExtOrBitCast(B(cx), Val, DestTy, noname());\n }\n \n fn SExtOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) ->\n    ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    count_insn(cx, \"sextorbitcast\");\n     ret llvm::LLVMBuildSExtOrBitCast(B(cx), Val, DestTy, noname());\n }\n \n fn TruncOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) ->\n    ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    count_insn(cx, \"truncorbitcast\");\n     ret llvm::LLVMBuildTruncOrBitCast(B(cx), Val, DestTy, noname());\n }\n \n fn Cast(cx: block, Op: Opcode, Val: ValueRef, DestTy: TypeRef,\n         _Name: *u8) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    count_insn(cx, \"cast\");\n     ret llvm::LLVMBuildCast(B(cx), Op, Val, DestTy, noname());\n }\n \n fn PointerCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    count_insn(cx, \"pointercast\");\n     ret llvm::LLVMBuildPointerCast(B(cx), Val, DestTy, noname());\n }\n \n fn IntCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    count_insn(cx, \"intcast\");\n     ret llvm::LLVMBuildIntCast(B(cx), Val, DestTy, noname());\n }\n \n fn FPCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    count_insn(cx, \"fpcast\");\n     ret llvm::LLVMBuildFPCast(B(cx), Val, DestTy, noname());\n }\n \n@@ -474,18 +588,21 @@ fn FPCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n fn ICmp(cx: block, Op: IntPredicate, LHS: ValueRef, RHS: ValueRef)\n     -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_i1()); }\n+    count_insn(cx, \"icmp\");\n     ret llvm::LLVMBuildICmp(B(cx), Op as c_uint, LHS, RHS, noname());\n }\n \n fn FCmp(cx: block, Op: RealPredicate, LHS: ValueRef, RHS: ValueRef)\n     -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_i1()); }\n+    count_insn(cx, \"fcmp\");\n     ret llvm::LLVMBuildFCmp(B(cx), Op as c_uint, LHS, RHS, noname());\n }\n \n /* Miscellaneous instructions */\n fn EmptyPhi(cx: block, Ty: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(Ty); }\n+    count_insn(cx, \"emptyphi\");\n     ret llvm::LLVMBuildPhi(B(cx), Ty, noname());\n }\n \n@@ -495,6 +612,7 @@ fn Phi(cx: block, Ty: TypeRef, vals: [ValueRef], bbs: [BasicBlockRef])\n     assert vals.len() == bbs.len();\n     let phi = EmptyPhi(cx, Ty);\n     unsafe {\n+        count_insn(cx, \"addincoming\");\n         llvm::LLVMAddIncoming(phi, vec::unsafe::to_ptr(vals),\n                               vec::unsafe::to_ptr(bbs),\n                               vals.len() as c_uint);\n@@ -516,6 +634,7 @@ fn _UndefReturn(cx: block, Fn: ValueRef) -> ValueRef {\n     let ty = val_ty(Fn);\n     let retty = if llvm::LLVMGetTypeKind(ty) == 8 as c_int {\n         llvm::LLVMGetReturnType(ty) } else { ccx.int_type };\n+        count_insn(cx, \"\");\n     ret llvm::LLVMGetUndef(retty);\n }\n \n@@ -536,6 +655,7 @@ fn add_comment(bcx: block, text: str) {\n         let comment_text = \"; \" + sanitized;\n         let asm = str::as_c_str(comment_text, {|c|\n             str::as_c_str(\"\", {|e|\n+                count_insn(bcx, \"inlineasm\");\n                 llvm::LLVMConstInlineAsm(T_fn([], T_void()), c, e,\n                                          False, False)\n             })\n@@ -547,6 +667,7 @@ fn add_comment(bcx: block, text: str) {\n fn Call(cx: block, Fn: ValueRef, Args: [ValueRef]) -> ValueRef {\n     if cx.unreachable { ret _UndefReturn(cx, Fn); }\n     unsafe {\n+        count_insn(cx, \"call\");\n         ret llvm::LLVMBuildCall(B(cx), Fn, vec::unsafe::to_ptr(Args),\n                                 Args.len() as c_uint, noname());\n     }\n@@ -555,6 +676,7 @@ fn Call(cx: block, Fn: ValueRef, Args: [ValueRef]) -> ValueRef {\n fn FastCall(cx: block, Fn: ValueRef, Args: [ValueRef]) -> ValueRef {\n     if cx.unreachable { ret _UndefReturn(cx, Fn); }\n     unsafe {\n+        count_insn(cx, \"fastcall\");\n         let v = llvm::LLVMBuildCall(B(cx), Fn, vec::unsafe::to_ptr(Args),\n                                     Args.len() as c_uint, noname());\n         lib::llvm::SetInstructionCallConv(v, lib::llvm::FastCallConv);\n@@ -566,6 +688,7 @@ fn CallWithConv(cx: block, Fn: ValueRef, Args: [ValueRef],\n                 Conv: CallConv) -> ValueRef {\n     if cx.unreachable { ret _UndefReturn(cx, Fn); }\n     unsafe {\n+        count_insn(cx, \"callwithconv\");\n         let v = llvm::LLVMBuildCall(B(cx), Fn, vec::unsafe::to_ptr(Args),\n                                     Args.len() as c_uint, noname());\n         lib::llvm::SetInstructionCallConv(v, Conv);\n@@ -576,57 +699,67 @@ fn CallWithConv(cx: block, Fn: ValueRef, Args: [ValueRef],\n fn Select(cx: block, If: ValueRef, Then: ValueRef, Else: ValueRef) ->\n    ValueRef {\n     if cx.unreachable { ret _Undef(Then); }\n+    count_insn(cx, \"select\");\n     ret llvm::LLVMBuildSelect(B(cx), If, Then, Else, noname());\n }\n \n fn VAArg(cx: block, list: ValueRef, Ty: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(Ty); }\n+    count_insn(cx, \"vaarg\");\n     ret llvm::LLVMBuildVAArg(B(cx), list, Ty, noname());\n }\n \n fn ExtractElement(cx: block, VecVal: ValueRef, Index: ValueRef) ->\n    ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_nil()); }\n+    count_insn(cx, \"extractelement\");\n     ret llvm::LLVMBuildExtractElement(B(cx), VecVal, Index, noname());\n }\n \n fn InsertElement(cx: block, VecVal: ValueRef, EltVal: ValueRef,\n                  Index: ValueRef) {\n     if cx.unreachable { ret; }\n+    count_insn(cx, \"insertelement\");\n     llvm::LLVMBuildInsertElement(B(cx), VecVal, EltVal, Index, noname());\n }\n \n fn ShuffleVector(cx: block, V1: ValueRef, V2: ValueRef,\n                  Mask: ValueRef) {\n     if cx.unreachable { ret; }\n+    count_insn(cx, \"shufflevector\");\n     llvm::LLVMBuildShuffleVector(B(cx), V1, V2, Mask, noname());\n }\n \n fn ExtractValue(cx: block, AggVal: ValueRef, Index: uint) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_nil()); }\n+    count_insn(cx, \"extractvalue\");\n     ret llvm::LLVMBuildExtractValue(B(cx), AggVal, Index as c_uint, noname());\n }\n \n fn InsertValue(cx: block, AggVal: ValueRef, EltVal: ValueRef,\n                Index: uint) {\n     if cx.unreachable { ret; }\n+    count_insn(cx, \"insertvalue\");\n     llvm::LLVMBuildInsertValue(B(cx), AggVal, EltVal, Index as c_uint,\n                                noname());\n }\n \n fn IsNull(cx: block, Val: ValueRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_i1()); }\n+    count_insn(cx, \"isnull\");\n     ret llvm::LLVMBuildIsNull(B(cx), Val, noname());\n }\n \n fn IsNotNull(cx: block, Val: ValueRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_i1()); }\n+    count_insn(cx, \"isnotnull\");\n     ret llvm::LLVMBuildIsNotNull(B(cx), Val, noname());\n }\n \n fn PtrDiff(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let ccx = cx.fcx.ccx;\n     if cx.unreachable { ret llvm::LLVMGetUndef(ccx.int_type); }\n+    count_insn(cx, \"ptrdiff\");\n     ret llvm::LLVMBuildPtrDiff(B(cx), LHS, RHS, noname());\n }\n \n@@ -642,6 +775,7 @@ fn Trap(cx: block) {\n     assert (T as int != 0);\n     let Args: [ValueRef] = [];\n     unsafe {\n+        count_insn(cx, \"trap\");\n         llvm::LLVMBuildCall(b, T, vec::unsafe::to_ptr(Args),\n                             Args.len() as c_uint, noname());\n     }\n@@ -650,17 +784,20 @@ fn Trap(cx: block) {\n fn LandingPad(cx: block, Ty: TypeRef, PersFn: ValueRef,\n               NumClauses: uint) -> ValueRef {\n     assert !cx.terminated && !cx.unreachable;\n+    count_insn(cx, \"landingpad\");\n     ret llvm::LLVMBuildLandingPad(B(cx), Ty, PersFn,\n                                   NumClauses as c_uint, noname());\n }\n \n-fn SetCleanup(_cx: block, LandingPad: ValueRef) {\n+fn SetCleanup(cx: block, LandingPad: ValueRef) {\n+    count_insn(cx, \"setcleanup\");\n     llvm::LLVMSetCleanup(LandingPad, lib::llvm::True);\n }\n \n fn Resume(cx: block, Exn: ValueRef) -> ValueRef {\n     assert (!cx.terminated);\n     cx.terminated = true;\n+    count_insn(cx, \"resume\");\n     ret llvm::LLVMBuildResume(B(cx), Exn);\n }\n "}, {"sha": "4bcb9cc1647fb5f40a85d99df677c30c3e48dd5e", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b224bcf6e1b4230f7f85858d3009ac7f60bb12f6/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b224bcf6e1b4230f7f85858d3009ac7f60bb12f6/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=b224bcf6e1b4230f7f85858d3009ac7f60bb12f6", "patch": "@@ -146,10 +146,11 @@ fn allocate_cbox(bcx: block,\n                  ck: ty::closure_kind,\n                  cdata_ty: ty::t)\n     -> (block, ValueRef, [ValueRef]) {\n-\n+    let _icx = bcx.insn_ctxt(\"closure::allocate_cbox\");\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n \n     fn nuke_ref_count(bcx: block, box: ValueRef) {\n+        let _icx = bcx.insn_ctxt(\"closure::nuke_ref_count\");\n         // Initialize ref count to arbitrary value for debugging:\n         let ccx = bcx.ccx();\n         let box = PointerCast(bcx, box, T_opaque_box_ptr(ccx));\n@@ -211,7 +212,7 @@ type closure_result = {\n fn store_environment(bcx: block,\n                      bound_values: [environment_value],\n                      ck: ty::closure_kind) -> closure_result {\n-\n+    let _icx = bcx.insn_ctxt(\"closure::store_environment\");\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n \n     // compute the shape of the closure\n@@ -287,6 +288,7 @@ fn build_closure(bcx0: block,\n                  cap_vars: [capture::capture_var],\n                  ck: ty::closure_kind,\n                  id: ast::node_id) -> closure_result {\n+    let _icx = bcx0.insn_ctxt(\"closure::build_closure\");\n     // If we need to, package up the iterator body to call\n     let mut env_vals = [];\n     let mut bcx = bcx0;\n@@ -332,6 +334,7 @@ fn load_environment(fcx: fn_ctxt,\n                     cdata_ty: ty::t,\n                     cap_vars: [capture::capture_var],\n                     ck: ty::closure_kind) {\n+    let _icx = fcx.insn_ctxt(\"closure::load_environment\");\n     let bcx = raw_block(fcx, fcx.llloadenv);\n \n     // Load a pointer to the closure data, skipping over the box header:\n@@ -365,6 +368,7 @@ fn trans_expr_fn(bcx: block,\n                  id: ast::node_id,\n                  cap_clause: ast::capture_clause,\n                  dest: dest) -> block {\n+    let _icx = bcx.insn_ctxt(\"closure::trans_expr_fn\");\n     if dest == ignore { ret bcx; }\n     let ccx = bcx.ccx(), bcx = bcx;\n     let fty = node_id_type(bcx, id);\n@@ -401,6 +405,7 @@ fn trans_expr_fn(bcx: block,\n \n fn trans_bind(cx: block, f: @ast::expr, args: [option<@ast::expr>],\n               id: ast::node_id, dest: dest) -> block {\n+    let _icx = cx.insn_ctxt(\"closure::trans_bind\");\n     let f_res = trans_callee(cx, f);\n     ret trans_bind_1(cx, expr_ty(cx, f), f_res, args,\n                      node_id_type(cx, id), dest);\n@@ -410,6 +415,7 @@ fn trans_bind_1(cx: block, outgoing_fty: ty::t,\n                 f_res: lval_maybe_callee,\n                 args: [option<@ast::expr>], pair_ty: ty::t,\n                 dest: dest) -> block {\n+    let _icx = cx.insn_ctxt(\"closure::trans_bind1\");\n     assert option::is_none(f_res.tds);\n     let ccx = cx.ccx();\n     let mut bound: [@ast::expr] = [];\n@@ -472,6 +478,7 @@ fn make_fn_glue(\n     t: ty::t,\n     glue_fn: fn@(block, v: ValueRef, t: ty::t) -> block)\n     -> block {\n+    let _icx = cx.insn_ctxt(\"closure::make_fn_glue\");\n     let bcx = cx;\n     let tcx = cx.tcx();\n \n@@ -500,6 +507,7 @@ fn make_opaque_cbox_take_glue(\n     cboxptr: ValueRef)     // ptr to ptr to the opaque closure\n     -> block {\n     // Easy cases:\n+    let _icx = bcx.insn_ctxt(\"closure::make_opaque_cbox_take_glue\");\n     alt ck {\n       ty::ck_block { ret bcx; }\n       ty::ck_box { ret incr_refcnt_of_boxed(bcx, Load(bcx, cboxptr)); }\n@@ -546,6 +554,7 @@ fn make_opaque_cbox_drop_glue(\n     ck: ty::closure_kind,\n     cboxptr: ValueRef)     // ptr to the opaque closure\n     -> block {\n+    let _icx = bcx.insn_ctxt(\"closure::make_opaque_cbox_drop_glue\");\n     alt ck {\n       ty::ck_block { bcx }\n       ty::ck_box {\n@@ -564,6 +573,7 @@ fn make_opaque_cbox_free_glue(\n     ck: ty::closure_kind,\n     cbox: ValueRef)     // ptr to the opaque closure\n     -> block {\n+    let _icx = bcx.insn_ctxt(\"closure::make_opaque_cbox_free_glue\");\n     alt ck {\n       ty::ck_block { ret bcx; }\n       ty::ck_box | ty::ck_uniq { /* hard cases: */ }\n@@ -614,6 +624,7 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n                     cdata_ty: ty::t,\n                     target_info: target_info)\n     -> {val: ValueRef, ty: TypeRef} {\n+    let _icx = ccx.insn_ctxt(\"closure::trans_bind_thunk\");\n     let tcx = ccx.tcx;\n     #debug[\"trans_bind_thunk[incoming_fty=%s,outgoing_fty=%s,\\\n             cdata_ty=%s]\","}, {"sha": "192bfbffbf5813dc597f58bfe1f2b0d78fa84549", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b224bcf6e1b4230f7f85858d3009ac7f60bb12f6/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b224bcf6e1b4230f7f85858d3009ac7f60bb12f6/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=b224bcf6e1b4230f7f85858d3009ac7f60bb12f6", "patch": "@@ -50,11 +50,14 @@ type tydesc_info =\n  * task such as bringing a task to life, allocating memory, etc.\n  *\n  */\n+\n type stats =\n     {mutable n_static_tydescs: uint,\n      mutable n_glues_created: uint,\n      mutable n_null_glues: uint,\n      mutable n_real_glues: uint,\n+     llvm_insn_ctxt: @mutable [str],\n+     llvm_insns: hashmap<str, uint>,\n      fn_times: @mutable [{ident: str, time: int}]};\n \n resource BuilderRef_res(B: BuilderRef) { llvm::LLVMDisposeBuilder(B); }"}, {"sha": "7593482c1fbbba6d7265c9e1bcecfecff7917643", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b224bcf6e1b4230f7f85858d3009ac7f60bb12f6/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b224bcf6e1b4230f7f85858d3009ac7f60bb12f6/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=b224bcf6e1b4230f7f85858d3009ac7f60bb12f6", "patch": "@@ -16,6 +16,7 @@ import std::map::hashmap;\n \n fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n               methods: [@ast::method], tps: [ast::ty_param]) {\n+    let _icx = ccx.insn_ctxt(\"impl::trans_impl\");\n     if tps.len() > 0u { ret; }\n     let sub_path = path + [path_name(name)];\n     for m in methods {\n@@ -29,6 +30,7 @@ fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n }\n \n fn trans_self_arg(bcx: block, base: @ast::expr) -> result {\n+    let _icx = bcx.insn_ctxt(\"impl::trans_self_arg\");\n     let basety = expr_ty(bcx, base);\n     let m_by_ref = ast::expl(ast::by_ref);\n     let mut temp_cleanups = [];\n@@ -46,6 +48,7 @@ fn trans_self_arg(bcx: block, base: @ast::expr) -> result {\n fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n                        self: @ast::expr, origin: typeck::method_origin)\n     -> lval_maybe_callee {\n+    let _icx = bcx.insn_ctxt(\"impl::trans_method_callee\");\n     alt origin {\n       typeck::method_static(did) {\n         let {bcx, val} = trans_self_arg(bcx, self);\n@@ -69,6 +72,7 @@ fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n fn trans_vtable_callee(bcx: block, env: callee_env, vtable: ValueRef,\n                        callee_id: ast::node_id, n_method: uint)\n     -> lval_maybe_callee {\n+    let _icx = bcx.insn_ctxt(\"impl::trans_vtable_callee\");\n     let bcx = bcx, ccx = bcx.ccx();\n     let fty = node_id_type(bcx, callee_id);\n     let llfty = type_of::type_of_fn_from_ty(ccx, fty);\n@@ -105,6 +109,7 @@ fn trans_monomorphized_callee(bcx: block, callee_id: ast::node_id,\n                               base: @ast::expr, iface_id: ast::def_id,\n                               n_method: uint, n_param: uint, n_bound: uint,\n                               substs: param_substs) -> lval_maybe_callee {\n+    let _icx = bcx.insn_ctxt(\"impl::trans_monomorphized_callee\");\n     alt find_vtable_in_fn_ctxt(substs, n_param, n_bound) {\n       typeck::vtable_static(impl_did, impl_substs, sub_origins) {\n         let ccx = bcx.ccx();\n@@ -135,6 +140,7 @@ fn trans_monomorphized_callee(bcx: block, callee_id: ast::node_id,\n fn trans_iface_callee(bcx: block, base: @ast::expr,\n                       callee_id: ast::node_id, n_method: uint)\n     -> lval_maybe_callee {\n+    let _icx = bcx.insn_ctxt(\"impl::trans_iface_callee\");\n     let {bcx, val} = trans_temp_expr(bcx, base);\n     let vtable = Load(bcx, PointerCast(bcx, GEPi(bcx, val, [0, 0]),\n                                      T_ptr(T_ptr(T_vtable()))));\n@@ -220,6 +226,7 @@ fn get_vtable(ccx: @crate_ctxt, origin: typeck::vtable_origin)\n }\n \n fn make_vtable(ccx: @crate_ctxt, ptrs: [ValueRef]) -> ValueRef {\n+    let _icx = ccx.insn_ctxt(\"impl::make_vtable\");\n     let tbl = C_struct(ptrs);\n     let vt_gvar = str::as_c_str(ccx.names(\"vtable\"), {|buf|\n         llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl), buf)\n@@ -232,6 +239,7 @@ fn make_vtable(ccx: @crate_ctxt, ptrs: [ValueRef]) -> ValueRef {\n \n fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: [ty::t],\n                     vtables: typeck::vtable_res) -> ValueRef {\n+    let _icx = ccx.insn_ctxt(\"impl::make_impl_vtable\");\n     let tcx = ccx.tcx;\n     let ifce_id = ty::ty_to_def_id(option::get(ty::impl_iface(tcx, impl_id)));\n     let has_tps = (*ty::lookup_item_type(ccx.tcx, impl_id).bounds).len() > 0u;\n@@ -255,6 +263,7 @@ fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: [ty::t],\n \n fn trans_cast(bcx: block, val: @ast::expr, id: ast::node_id, dest: dest)\n     -> block {\n+    let _icx = bcx.insn_ctxt(\"impl::trans_cast\");\n     if dest == ignore { ret trans_expr(bcx, val, ignore); }\n     let ccx = bcx.ccx();\n     let v_ty = expr_ty(bcx, val);"}, {"sha": "bcb4889349cbab429064c68b9ed8882edaef28fe", "filename": "src/rustc/middle/trans/native.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b224bcf6e1b4230f7f85858d3009ac7f60bb12f6/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b224bcf6e1b4230f7f85858d3009ac7f60bb12f6/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs?ref=b224bcf6e1b4230f7f85858d3009ac7f60bb12f6", "patch": "@@ -492,6 +492,7 @@ fn build_wrap_fn_(ccx: @crate_ctxt,\n                   arg_builder: wrap_arg_builder,\n                   ret_builder: wrap_ret_builder) {\n \n+    let _icx = ccx.insn_ctxt(\"native::build_wrap_fn_\");\n     let fcx = new_fn_ctxt(ccx, [], llwrapfn, none);\n     let bcx = top_scope_block(fcx, none);\n     let lltop = bcx.llbb;\n@@ -550,13 +551,19 @@ fn build_wrap_fn_(ccx: @crate_ctxt,\n // perhaps do so in the future.\n fn trans_native_mod(ccx: @crate_ctxt,\n                     native_mod: ast::native_mod, abi: ast::native_abi) {\n+\n+    let _icx = ccx.insn_ctxt(\"native::trans_native_mod\");\n+\n     fn build_shim_fn(ccx: @crate_ctxt,\n                      native_item: @ast::native_item,\n                      tys: @c_stack_tys,\n                      cc: lib::llvm::CallConv) -> ValueRef {\n \n+        let _icx = ccx.insn_ctxt(\"native::build_shim_fn\");\n+\n         fn build_args(bcx: block, tys: @c_stack_tys,\n                       llargbundle: ValueRef) -> [ValueRef] {\n+            let _icx = bcx.insn_ctxt(\"native::shim::build_args\");\n             let mut llargvals = [];\n             let mut i = 0u;\n             let n = vec::len(tys.arg_tys);\n@@ -602,6 +609,7 @@ fn trans_native_mod(ccx: @crate_ctxt,\n \n         fn build_ret(bcx: block, tys: @c_stack_tys,\n                      llargbundle: ValueRef, llretval: ValueRef)  {\n+            let _icx = bcx.insn_ctxt(\"native::shim::build_ret\");\n             alt tys.x86_64_tys {\n                 some(x86_64) {\n                     vec::iteri(x86_64.attrs) {|i, a|\n@@ -666,8 +674,11 @@ fn trans_native_mod(ccx: @crate_ctxt,\n                      llshimfn: ValueRef,\n                      llwrapfn: ValueRef) {\n \n+        let _icx = ccx.insn_ctxt(\"native::build_wrap_fn\");\n+\n         fn build_args(bcx: block, tys: @c_stack_tys,\n                       llwrapfn: ValueRef, llargbundle: ValueRef) {\n+            let _icx = bcx.insn_ctxt(\"native::wrap::build_args\");\n             let mut i = 0u;\n             let n = vec::len(tys.arg_tys);\n             let implicit_args = first_real_arg; // ret + env\n@@ -684,6 +695,7 @@ fn trans_native_mod(ccx: @crate_ctxt,\n \n         fn build_ret(bcx: block, _tys: @c_stack_tys,\n                      _llargbundle: ValueRef) {\n+            let _icx = bcx.insn_ctxt(\"native::wrap::build_ret\");\n             RetVoid(bcx);\n         }\n \n@@ -718,9 +730,12 @@ fn trans_native_mod(ccx: @crate_ctxt,\n fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n                   body: ast::blk, llwrapfn: ValueRef, id: ast::node_id) {\n \n+    let _icx = ccx.insn_ctxt(\"native::build_crust_fn\");\n+\n     fn build_rust_fn(ccx: @crate_ctxt, path: ast_map::path,\n                      decl: ast::fn_decl, body: ast::blk,\n                      id: ast::node_id) -> ValueRef {\n+        let _icx = ccx.insn_ctxt(\"native::crust::build_rust_fn\");\n         let t = ty::node_id_to_type(ccx.tcx, id);\n         let ps = link::mangle_internal_name_by_path(\n             ccx, path + [ast_map::path_name(\"__rust_abi\")]);\n@@ -734,8 +749,11 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n     fn build_shim_fn(ccx: @crate_ctxt, path: ast_map::path,\n                      llrustfn: ValueRef, tys: @c_stack_tys) -> ValueRef {\n \n+        let _icx = ccx.insn_ctxt(\"native::crust::build_shim_fn\");\n+\n         fn build_args(bcx: block, tys: @c_stack_tys,\n                       llargbundle: ValueRef) -> [ValueRef] {\n+            let _icx = bcx.insn_ctxt(\"native::crust::shim::build_args\");\n             let mut llargvals = [];\n             let mut i = 0u;\n             let n = vec::len(tys.arg_tys);\n@@ -767,8 +785,11 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n     fn build_wrap_fn(ccx: @crate_ctxt, llshimfn: ValueRef,\n                      llwrapfn: ValueRef, tys: @c_stack_tys) {\n \n+        let _icx = ccx.insn_ctxt(\"native::crust::build_wrap_fn\");\n+\n         fn build_args(bcx: block, tys: @c_stack_tys,\n                       llwrapfn: ValueRef, llargbundle: ValueRef) {\n+            let _icx = bcx.insn_ctxt(\"native::crust::wrap::build_args\");\n             alt tys.x86_64_tys {\n                 option::some(x86_64) {\n                     let mut atys = x86_64.arg_tys;\n@@ -827,6 +848,7 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n \n         fn build_ret(bcx: block, tys: @c_stack_tys,\n                      llargbundle: ValueRef) {\n+            let _icx = bcx.insn_ctxt(\"native::crust::wrap::build_ret\");\n             alt tys.x86_64_tys {\n                 option::some(x86_64) {\n                     if x86_64.sret || !tys.ret_def {\n@@ -872,6 +894,7 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n fn register_crust_fn(ccx: @crate_ctxt, sp: span,\n                      path: ast_map::path, node_id: ast::node_id)\n     -> ValueRef {\n+    let _icx = ccx.insn_ctxt(\"native::register_crust_fn\");\n     let t = ty::node_id_to_type(ccx.tcx, node_id);\n     let (llargtys, llretty, ret_ty) = c_arg_and_ret_lltys(ccx, node_id);\n     ret if ccx.sess.targ_cfg.arch == arch_x86_64 {\n@@ -907,6 +930,7 @@ fn abi_of_native_fn(ccx: @crate_ctxt, i: @ast::native_item)\n \n fn decl_native_fn(ccx: @crate_ctxt, i: @ast::native_item,\n                   pth: ast_map::path) -> ValueRef {\n+    let _icx = ccx.insn_ctxt(\"native::decl_native_fn\");\n     alt i.node {\n       ast::native_item_fn(_, _) {\n         let node_type = ty::node_id_to_type(ccx.tcx, i.id);"}, {"sha": "bcf73ca97748a2f6d6cd7e1cc84ab5464b0d6cff", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b224bcf6e1b4230f7f85858d3009ac7f60bb12f6/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b224bcf6e1b4230f7f85858d3009ac7f60bb12f6/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=b224bcf6e1b4230f7f85858d3009ac7f60bb12f6", "patch": "@@ -14,7 +14,6 @@ import syntax::ast;\n import syntax::ast_util::dummy_sp;\n import syntax::util::interner;\n import util::common;\n-import trans::build::{Load, Store, Add, GEPi};\n import syntax::codemap::span;\n \n import std::map::hashmap;"}, {"sha": "1bd765200de8d2ba7d604c61b57b4357c82e6bf1", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b224bcf6e1b4230f7f85858d3009ac7f60bb12f6/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b224bcf6e1b4230f7f85858d3009ac7f60bb12f6/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=b224bcf6e1b4230f7f85858d3009ac7f60bb12f6", "patch": "@@ -5,27 +5,31 @@ import back::abi;\n import base::{call_memmove, trans_shared_malloc,\n                INIT, copy_val, load_if_immediate, get_tydesc,\n                sub_block, do_spill_noroot,\n-               dest};\n+               dest, bcx_icx};\n import shape::llsize_of;\n import build::*;\n import common::*;\n \n fn get_fill(bcx: block, vptr: ValueRef) -> ValueRef {\n+    let _icx = bcx.insn_ctxt(\"tvec::get_fill\");\n     Load(bcx, GEPi(bcx, vptr, [0, abi::vec_elt_fill]))\n }\n fn get_dataptr(bcx: block, vptr: ValueRef, unit_ty: TypeRef)\n     -> ValueRef {\n+    let _icx = bcx.insn_ctxt(\"tvec::get_dataptr\");\n     let ptr = GEPi(bcx, vptr, [0, abi::vec_elt_elems]);\n     PointerCast(bcx, ptr, T_ptr(unit_ty))\n }\n \n fn pointer_add(bcx: block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n+    let _icx = bcx.insn_ctxt(\"tvec::pointer_add\");\n     let old_ty = val_ty(ptr);\n     let bptr = PointerCast(bcx, ptr, T_ptr(T_i8()));\n     ret PointerCast(bcx, InBoundsGEP(bcx, bptr, [bytes]), old_ty);\n }\n \n fn alloc_raw(bcx: block, fill: ValueRef, alloc: ValueRef) -> result {\n+    let _icx = bcx.insn_ctxt(\"tvec::alloc_raw\");\n     let ccx = bcx.ccx();\n     let llvecty = ccx.opaque_vec_type;\n     let vecsize = Add(bcx, alloc, llsize_of(ccx, llvecty));\n@@ -43,6 +47,7 @@ type alloc_result =\n      llunitty: TypeRef};\n \n fn alloc(bcx: block, vec_ty: ty::t, elts: uint) -> alloc_result {\n+    let _icx = bcx.insn_ctxt(\"tvec::alloc\");\n     let ccx = bcx.ccx();\n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n     let llunitty = type_of::type_of(ccx, unit_ty);\n@@ -62,6 +67,7 @@ fn alloc(bcx: block, vec_ty: ty::t, elts: uint) -> alloc_result {\n }\n \n fn duplicate(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> result {\n+    let _icx = bcx.insn_ctxt(\"tvec::duplicate\");\n     let ccx = bcx.ccx();\n     let fill = get_fill(bcx, vptr);\n     let size = Add(bcx, fill, llsize_of(ccx, ccx.opaque_vec_type));\n@@ -77,6 +83,7 @@ fn duplicate(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> result {\n }\n fn make_free_glue(bcx: block, vptr: ValueRef, vec_ty: ty::t) ->\n    block {\n+    let _icx = bcx.insn_ctxt(\"tvec::make_free_glue\");\n     let tcx = bcx.tcx(), unit_ty = ty::sequence_element_type(tcx, vec_ty);\n     base::with_cond(bcx, IsNotNull(bcx, vptr)) {|bcx|\n         let bcx = if ty::type_needs_drop(tcx, unit_ty) {\n@@ -88,6 +95,7 @@ fn make_free_glue(bcx: block, vptr: ValueRef, vec_ty: ty::t) ->\n \n fn trans_vec(bcx: block, args: [@ast::expr], id: ast::node_id,\n              dest: dest) -> block {\n+    let _icx = bcx.insn_ctxt(\"tvec::trans_vec\");\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n     if dest == base::ignore {\n@@ -118,6 +126,7 @@ fn trans_vec(bcx: block, args: [@ast::expr], id: ast::node_id,\n }\n \n fn trans_str(bcx: block, s: str, dest: dest) -> block {\n+    let _icx = bcx.insn_ctxt(\"tvec::trans_str\");\n     let veclen = str::len(s) + 1u; // +1 for \\0\n     let {bcx: bcx, val: sptr, _} =\n         alloc(bcx, ty::mk_str(bcx.tcx()), veclen);\n@@ -131,6 +140,7 @@ fn trans_str(bcx: block, s: str, dest: dest) -> block {\n \n fn trans_append(bcx: block, vec_ty: ty::t, lhsptr: ValueRef,\n                 rhs: ValueRef) -> block {\n+    let _icx = bcx.insn_ctxt(\"tvec::trans_append\");\n     // Cast to opaque interior vector types if necessary.\n     let ccx = bcx.ccx();\n     let unit_ty = ty::sequence_element_type(ccx.tcx, vec_ty);\n@@ -172,6 +182,7 @@ fn trans_append(bcx: block, vec_ty: ty::t, lhsptr: ValueRef,\n \n fn trans_append_literal(bcx: block, vptrptr: ValueRef, vec_ty: ty::t,\n                         vals: [@ast::expr]) -> block {\n+    let _icx = bcx.insn_ctxt(\"tvec::trans_append_literal\");\n     let ccx = bcx.ccx();\n     let elt_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n     let mut ti = none;\n@@ -193,6 +204,7 @@ fn trans_append_literal(bcx: block, vptrptr: ValueRef, vec_ty: ty::t,\n \n fn trans_add(bcx: block, vec_ty: ty::t, lhs: ValueRef,\n              rhs: ValueRef, dest: dest) -> block {\n+    let _icx = bcx.insn_ctxt(\"tvec::trans_add\");\n     let ccx = bcx.ccx();\n \n     if ty::get(vec_ty).struct == ty::ty_str {\n@@ -233,6 +245,7 @@ type iter_vec_block = fn(block, ValueRef, ty::t) -> block;\n \n fn iter_vec_raw(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n                 fill: ValueRef, f: iter_vec_block) -> block {\n+    let _icx = bcx.insn_ctxt(\"tvec::iter_vec_raw\");\n     let ccx = bcx.ccx();\n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n     let llunitty = type_of::type_of(ccx, unit_ty);\n@@ -262,6 +275,7 @@ fn iter_vec_raw(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n \n fn iter_vec(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n             f: iter_vec_block) -> block {\n+    let _icx = bcx.insn_ctxt(\"tvec::iter_vec\");\n     let vptr = PointerCast(bcx, vptr, T_ptr(bcx.ccx().opaque_vec_type));\n     ret iter_vec_raw(bcx, vptr, vec_ty, get_fill(bcx, vptr), f);\n }"}, {"sha": "ad52a0a3a2b5e06f62540947cafbc10ea8d762da", "filename": "src/rustc/middle/trans/uniq.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b224bcf6e1b4230f7f85858d3009ac7f60bb12f6/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b224bcf6e1b4230f7f85858d3009ac7f60bb12f6/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=b224bcf6e1b4230f7f85858d3009ac7f60bb12f6", "patch": "@@ -9,6 +9,7 @@ export trans_uniq, make_free_glue, autoderef, duplicate, alloc_uniq;\n \n fn trans_uniq(bcx: block, contents: @ast::expr,\n               node_id: ast::node_id, dest: dest) -> block {\n+    let _icx = bcx.insn_ctxt(\"uniq::trans_uniq\");\n     let uniq_ty = node_id_type(bcx, node_id);\n     let {bcx, val: llptr} = alloc_uniq(bcx, uniq_ty);\n     add_clean_free(bcx, llptr, true);\n@@ -19,6 +20,7 @@ fn trans_uniq(bcx: block, contents: @ast::expr,\n \n fn alloc_uniq(cx: block, uniq_ty: ty::t) -> result {\n     let bcx = cx;\n+    let _icx = bcx.insn_ctxt(\"uniq::alloc_uniq\");\n     let contents_ty = content_ty(uniq_ty);\n     let llty = type_of::type_of(bcx.ccx(), contents_ty);\n     let llsz = llsize_of(bcx.ccx(), llty);\n@@ -28,6 +30,7 @@ fn alloc_uniq(cx: block, uniq_ty: ty::t) -> result {\n \n fn make_free_glue(bcx: block, vptr: ValueRef, t: ty::t)\n     -> block {\n+    let _icx = bcx.insn_ctxt(\"uniq::make_free_glue\");\n     with_cond(bcx, IsNotNull(bcx, vptr)) {|bcx|\n         let bcx = drop_ty(bcx, vptr, content_ty(t));\n         trans_shared_free(bcx, vptr)\n@@ -47,6 +50,7 @@ fn autoderef(v: ValueRef, t: ty::t) -> {v: ValueRef, t: ty::t} {\n }\n \n fn duplicate(bcx: block, v: ValueRef, t: ty::t) -> result {\n+    let _icx = bcx.insn_ctxt(\"uniq::duplicate\");\n     let content_ty = content_ty(t);\n     let {bcx, val: llptr} = alloc_uniq(bcx, t);\n "}, {"sha": "83044447ec6b3c2860713a967d99baf6d69b4983", "filename": "src/rustdoc/astsrv.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b224bcf6e1b4230f7f85858d3009ac7f60bb12f6/src%2Frustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b224bcf6e1b4230f7f85858d3009ac7f60bb12f6/src%2Frustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fastsrv.rs?ref=b224bcf6e1b4230f7f85858d3009ac7f60bb12f6", "patch": "@@ -137,6 +137,7 @@ fn build_session() -> (session::session, @mutable bool) {\n         save_temps: false,\n         stats: false,\n         time_passes: false,\n+        count_llvm_insns: false,\n         time_llvm_passes: false,\n         output_type: link::output_type_exe,\n         addl_lib_search_paths: [],"}]}