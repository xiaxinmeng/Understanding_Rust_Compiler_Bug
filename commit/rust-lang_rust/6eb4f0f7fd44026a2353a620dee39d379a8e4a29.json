{"sha": "6eb4f0f7fd44026a2353a620dee39d379a8e4a29", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlYjRmMGY3ZmQ0NDAyNmEyMzUzYTYyMGRlZTM5ZDM3OWE4ZTRhMjk=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-04-16T22:32:28Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-04-25T10:26:47Z"}, "message": "Ensure derive(PartialOrd) is no longer accidentally exponential\n\nPreviously, two comparison operations would be generated for each field, each of which could delegate to another derived PartialOrd. Now we use ordering and optional chaining to ensure each pair of fields is only compared once.", "tree": {"sha": "32a1651b426cfd9bf19338ff65f86d4ac3fa5409", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32a1651b426cfd9bf19338ff65f86d4ac3fa5409"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6eb4f0f7fd44026a2353a620dee39d379a8e4a29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6eb4f0f7fd44026a2353a620dee39d379a8e4a29", "html_url": "https://github.com/rust-lang/rust/commit/6eb4f0f7fd44026a2353a620dee39d379a8e4a29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6eb4f0f7fd44026a2353a620dee39d379a8e4a29/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc794209681d6b11a63282bcd1513caa50127816", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc794209681d6b11a63282bcd1513caa50127816", "html_url": "https://github.com/rust-lang/rust/commit/cc794209681d6b11a63282bcd1513caa50127816"}], "stats": {"total": 187, "additions": 90, "deletions": 97}, "files": [{"sha": "e248f471395a491b118644f02c15a0d252aa26a3", "filename": "src/etc/generate-deriving-span-tests.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6eb4f0f7fd44026a2353a620dee39d379a8e4a29/src%2Fetc%2Fgenerate-deriving-span-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/6eb4f0f7fd44026a2353a620dee39d379a8e4a29/src%2Fetc%2Fgenerate-deriving-span-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgenerate-deriving-span-tests.py?ref=6eb4f0f7fd44026a2353a620dee39d379a8e4a29", "patch": "@@ -122,7 +122,7 @@ def write_file(name, string):\n \n for (trait, supers, errs) in [('Clone', [], 1),\n                               ('PartialEq', [], 2),\n-                              ('PartialOrd', ['PartialEq'], 5),\n+                              ('PartialOrd', ['PartialEq'], 2),\n                               ('Eq', ['PartialEq'], 1),\n                               ('Ord', ['Eq', 'PartialOrd', 'PartialEq'], 1),\n                               ('Debug', [], 1),"}, {"sha": "b352e4b0a7eb957c11e197c3754a6e147e99d74f", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 83, "deletions": 70, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/6eb4f0f7fd44026a2353a620dee39d379a8e4a29/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eb4f0f7fd44026a2353a620dee39d379a8e4a29/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=6eb4f0f7fd44026a2353a620dee39d379a8e4a29", "patch": "@@ -14,7 +14,7 @@ use deriving::{path_local, pathvec_std, path_std};\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n-use syntax::ast::{self, BinOpKind, Expr, MetaItem};\n+use syntax::ast::{self, BinOpKind, Expr, MetaItem, Ident};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n@@ -147,34 +147,37 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<\n             // as the outermost one, and the last as the innermost.\n             false,\n             |cx, span, old, self_f, other_fs| {\n-        // match new {\n-        //     Some(::std::cmp::Ordering::Equal) => old,\n-        //     cmp => cmp\n-        // }\n+                // match new {\n+                //     Some(::std::cmp::Ordering::Equal) => old,\n+                //     cmp => cmp\n+                // }\n \n-        let new = {\n-            let other_f = match (other_fs.len(), other_fs.get(0)) {\n-                (1, Some(o_f)) => o_f,\n-                _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n-            };\n+                let new = {\n+                    let other_f = match (other_fs.len(), other_fs.get(0)) {\n+                        (1, Some(o_f)) => o_f,\n+                                _ => {\n+                                    cx.span_bug(span,\n+                                        \"not exactly 2 arguments in `derive(PartialOrd)`\")\n+                                }\n+                    };\n \n-            let args = vec![\n-                    cx.expr_addr_of(span, self_f),\n-                    cx.expr_addr_of(span, other_f.clone()),\n-                ];\n+                    let args = vec![\n+                            cx.expr_addr_of(span, self_f),\n+                            cx.expr_addr_of(span, other_f.clone()),\n+                        ];\n \n-            cx.expr_call_global(span, partial_cmp_path.clone(), args)\n-        };\n+                    cx.expr_call_global(span, partial_cmp_path.clone(), args)\n+                };\n \n-        let eq_arm = cx.arm(span,\n-                            vec![cx.pat_some(span, cx.pat_path(span, ordering.clone()))],\n-                            old);\n-        let neq_arm = cx.arm(span,\n-                             vec![cx.pat_ident(span, test_id)],\n-                             cx.expr_ident(span, test_id));\n+                let eq_arm = cx.arm(span,\n+                                    vec![cx.pat_some(span, cx.pat_path(span, ordering.clone()))],\n+                                    old);\n+                let neq_arm = cx.arm(span,\n+                                    vec![cx.pat_ident(span, test_id)],\n+                                    cx.expr_ident(span, test_id));\n \n-        cx.expr_match(span, new, vec![eq_arm, neq_arm])\n-    },\n+                cx.expr_match(span, new, vec![eq_arm, neq_arm])\n+            },\n             equals_expr.clone(),\n             Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n         if self_args.len() != 2 {\n@@ -189,78 +192,77 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<\n }\n \n /// Strict inequality.\n-fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n-    let strict_op = if less { BinOpKind::Lt } else { BinOpKind::Gt };\n-    cs_fold1(false, // need foldr,\n+fn cs_op(less: bool,\n+         inclusive: bool,\n+         cx: &mut ExtCtxt,\n+         span: Span,\n+         substr: &Substructure) -> P<Expr> {\n+    let ordering_path = |cx: &mut ExtCtxt, name: &str| {\n+        cx.expr_path(cx.path_global(span, cx.std_path(&[\"cmp\", \"Ordering\", name])))\n+    };\n+\n+    let par_cmp = |cx: &mut ExtCtxt, span: Span, self_f: P<Expr>, other_fs: &[P<Expr>]| {\n+        let other_f = match (other_fs.len(), other_fs.get(0)) {\n+            (1, Some(o_f)) => o_f,\n+            _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n+        };\n+\n+        // `self.fi.partial_cmp(other.fi)`\n+        let cmp = cx.expr_method_call(span,\n+                                      cx.expr_addr_of(span, self_f),\n+                                      Ident::from_str(\"partial_cmp\"),\n+                                      vec![cx.expr_addr_of(span, other_f.clone())]);\n+\n+        let default = ordering_path(cx, if less { \"Greater\" } else { \"Less\" });\n+        // `_.unwrap_or(Ordering::Greater/Less)`\n+        cx.expr_method_call(span, cmp, Ident::from_str(\"unwrap_or\"), vec![default])\n+    };\n+\n+    let fold = cs_fold1(false, // need foldr\n         |cx, span, subexpr, self_f, other_fs| {\n-            // build up a series of chain ||'s and &&'s from the inside\n+            // build up a series of `partial_cmp`s from the inside\n             // out (hence foldr) to get lexical ordering, i.e. for op ==\n             // `ast::lt`\n             //\n             // ```\n-            // self.f1 < other.f1 || (!(other.f1 < self.f1) &&\n-            // self.f2 < other.f2\n-            // )\n+            // self.f1.partial_cmp(other.f1).unwrap_or(Ordering::Greater)\n+            //     .then_with(|| self.f2.partial_cmp(other.f2).unwrap_or(Ordering::Greater))\n+            // == Ordering::Less\n             // ```\n             //\n             // and for op ==\n             // `ast::le`\n             //\n             // ```\n-            // self.f1 < other.f1 || (self.f1 == other.f1 &&\n-            // self.f2 <= other.f2\n-            // )\n+            // self.f1.partial_cmp(other.f1).unwrap_or(Ordering::Greater)\n+            //     .then_with(|| self.f2.partial_cmp(other.f2).unwrap_or(Ordering::Greater))\n+            // != Ordering::Greater\n             // ```\n             //\n             // The optimiser should remove the redundancy. We explicitly\n             // get use the binops to avoid auto-deref dereferencing too many\n             // layers of pointers, if the type includes pointers.\n-            //\n-            let other_f = match (other_fs.len(), other_fs.get(0)) {\n-                (1, Some(o_f)) => o_f,\n-                _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n-            };\n \n-            let strict_ineq = cx.expr_binary(span, strict_op, self_f.clone(), other_f.clone());\n+            // `self.fi.partial_cmp(other.fi).unwrap_or(Ordering::Greater/Less)`\n+            let par_cmp = par_cmp(cx, span, self_f, other_fs);\n \n-            let deleg_cmp = if !equal {\n-                cx.expr_unary(span,\n-                            ast::UnOp::Not,\n-                            cx.expr_binary(span, strict_op, other_f.clone(), self_f))\n-            } else {\n-                cx.expr_binary(span, BinOpKind::Eq, self_f, other_f.clone())\n-            };\n-\n-            let and = cx.expr_binary(span, BinOpKind::And, deleg_cmp, subexpr);\n-            cx.expr_binary(span, BinOpKind::Or, strict_ineq, and)\n+            // `self.fi.partial_cmp(other.fi).unwrap_or(Ordering::Greater/Less).then_with(...)`\n+            cx.expr_method_call(span,\n+                                par_cmp,\n+                                Ident::from_str(\"then_with\"),\n+                                vec![cx.lambda0(span, subexpr)])\n         },\n         |cx, args| {\n             match args {\n-                Some((span, self_f, other_fs)) => {\n-                    // Special-case the base case to generate cleaner code with\n-                    // fewer operations (e.g. `<=` instead of `<` and `==`).\n-                    let other_f = match (other_fs.len(), other_fs.get(0)) {\n-                        (1, Some(o_f)) => o_f,\n-                        _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n-                    };\n-\n-                    let op = match (less, equal) {\n-                        (false, false) => BinOpKind::Gt,\n-                        (false, true) => BinOpKind::Ge,\n-                        (true, false) => BinOpKind::Lt,\n-                        (true, true) => BinOpKind::Le,\n-                    };\n-\n-                    cx.expr_binary(span, op, self_f, other_f.clone())\n-                }\n-                None => cx.expr_bool(span, equal)\n+                Some((span, self_f, other_fs)) => par_cmp(cx, span, self_f, other_fs),\n+                None => ordering_path(cx, if less { \"Less\" } else { \"Equal\" })\n             }\n         },\n         Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n             if self_args.len() != 2 {\n                 cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n             } else {\n-                let op = match (less, equal) {\n+                let op = match (less, inclusive) {\n                     (false, false) => GtOp,\n                     (false, true) => GeOp,\n                     (true, false) => LtOp,\n@@ -271,5 +273,16 @@ fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt, span: Span, substr: &Substru\n         }),\n         cx,\n         span,\n-        substr)\n+        substr);\n+\n+    match *substr.fields {\n+        EnumMatching(..) |\n+        Struct(..) => {\n+            let ordering = ordering_path(cx, if less ^ inclusive { \"Less\" } else { \"Greater\" });\n+            let comp_op = if inclusive { BinOpKind::Ne } else { BinOpKind::Eq };\n+\n+            cx.expr_binary(span, comp_op, fold, ordering)\n+        }\n+        _ => fold\n+    }\n }"}, {"sha": "37e638c0553356a7d7c3f4806e8c2f8722b97e46", "filename": "src/test/compile-fail/derives-span-PartialOrd-enum-struct-variant.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6eb4f0f7fd44026a2353a620dee39d379a8e4a29/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eb4f0f7fd44026a2353a620dee39d379a8e4a29/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-enum-struct-variant.rs?ref=6eb4f0f7fd44026a2353a620dee39d379a8e4a29", "patch": "@@ -18,9 +18,6 @@ enum Enum {\n    A {\n      x: Error //~ ERROR\n //~^ ERROR\n-//~^^ ERROR\n-//~^^^ ERROR\n-//~^^^^ ERROR\n    }\n }\n "}, {"sha": "da1281fc1c102bf3ed3c7645beb3c0b7e410d8c5", "filename": "src/test/compile-fail/derives-span-PartialOrd-enum.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6eb4f0f7fd44026a2353a620dee39d379a8e4a29/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eb4f0f7fd44026a2353a620dee39d379a8e4a29/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-enum.rs?ref=6eb4f0f7fd44026a2353a620dee39d379a8e4a29", "patch": "@@ -18,9 +18,6 @@ enum Enum {\n    A(\n      Error //~ ERROR\n //~^ ERROR\n-//~^^ ERROR\n-//~^^^ ERROR\n-//~^^^^ ERROR\n      )\n }\n "}, {"sha": "fcc0593ab5e4c3d0e8135c6c2977e3aab98e22ec", "filename": "src/test/compile-fail/derives-span-PartialOrd-struct.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6eb4f0f7fd44026a2353a620dee39d379a8e4a29/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eb4f0f7fd44026a2353a620dee39d379a8e4a29/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-struct.rs?ref=6eb4f0f7fd44026a2353a620dee39d379a8e4a29", "patch": "@@ -17,9 +17,6 @@ struct Error;\n struct Struct {\n     x: Error //~ ERROR\n //~^ ERROR\n-//~^^ ERROR\n-//~^^^ ERROR\n-//~^^^^ ERROR\n }\n \n fn main() {}"}, {"sha": "24f75213e3f7a53896e34e4b392a89199d116a1b", "filename": "src/test/compile-fail/derives-span-PartialOrd-tuple-struct.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6eb4f0f7fd44026a2353a620dee39d379a8e4a29/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eb4f0f7fd44026a2353a620dee39d379a8e4a29/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-tuple-struct.rs?ref=6eb4f0f7fd44026a2353a620dee39d379a8e4a29", "patch": "@@ -17,9 +17,6 @@ struct Error;\n struct Struct(\n     Error //~ ERROR\n //~^ ERROR\n-//~^^ ERROR\n-//~^^^ ERROR\n-//~^^^^ ERROR\n );\n \n fn main() {}"}, {"sha": "434ad3c4f0799b0183b83946d0aab016c30d3e29", "filename": "src/test/compile-fail/range_traits-1.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6eb4f0f7fd44026a2353a620dee39d379a8e4a29/src%2Ftest%2Fcompile-fail%2Frange_traits-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eb4f0f7fd44026a2353a620dee39d379a8e4a29/src%2Ftest%2Fcompile-fail%2Frange_traits-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange_traits-1.rs?ref=6eb4f0f7fd44026a2353a620dee39d379a8e4a29", "patch": "@@ -15,35 +15,27 @@ struct AllTheRanges {\n     a: Range<usize>,\n     //~^ ERROR PartialOrd\n     //~^^ ERROR Ord\n-    //~^^^ ERROR binary operation `<` cannot be applied to type\n-    //~^^^^ ERROR binary operation `>` cannot be applied to type\n+    //~^^^ the trait bound\n     b: RangeTo<usize>,\n     //~^ ERROR PartialOrd\n     //~^^ ERROR Ord\n-    //~^^^ ERROR binary operation `<` cannot be applied to type\n-    //~^^^^ ERROR binary operation `>` cannot be applied to type\n+    //~^^^ no method named `partial_cmp`\n     c: RangeFrom<usize>,\n     //~^ ERROR PartialOrd\n     //~^^ ERROR Ord\n-    //~^^^ ERROR binary operation `<` cannot be applied to type\n-    //~^^^^ ERROR binary operation `>` cannot be applied to type\n+    //~^^^ the trait bound\n     d: RangeFull,\n     //~^ ERROR PartialOrd\n     //~^^ ERROR Ord\n-    //~^^^ ERROR binary operation `<` cannot be applied to type\n-    //~^^^^ ERROR binary operation `>` cannot be applied to type\n+    //~^^^ no method named `partial_cmp`\n     e: RangeInclusive<usize>,\n     //~^ ERROR PartialOrd\n     //~^^ ERROR Ord\n-    //~^^^ ERROR binary operation `<` cannot be applied to type\n-    //~^^^^ ERROR binary operation `>` cannot be applied to type\n+    //~^^^ the trait bound\n     f: RangeToInclusive<usize>,\n     //~^ ERROR PartialOrd\n     //~^^ ERROR Ord\n-    //~^^^ ERROR binary operation `<` cannot be applied to type\n-    //~^^^^ ERROR binary operation `>` cannot be applied to type\n-    //~^^^^^ ERROR binary operation `<=` cannot be applied to type\n-    //~^^^^^^ ERROR binary operation `>=` cannot be applied to type\n+    //~^^^ no method named `partial_cmp`\n }\n \n fn main() {}"}]}