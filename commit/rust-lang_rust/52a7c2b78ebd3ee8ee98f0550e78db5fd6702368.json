{"sha": "52a7c2b78ebd3ee8ee98f0550e78db5fd6702368", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyYTdjMmI3OGViZDNlZThlZTk4ZjA1NTBlNzhkYjVmZDY3MDIzNjg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-05T02:06:27Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-06T18:09:07Z"}, "message": "rustc: Make object methods into interior vectors", "tree": {"sha": "9922a16854677b7708a2f5939b20723e47648ee6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9922a16854677b7708a2f5939b20723e47648ee6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52a7c2b78ebd3ee8ee98f0550e78db5fd6702368", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52a7c2b78ebd3ee8ee98f0550e78db5fd6702368", "html_url": "https://github.com/rust-lang/rust/commit/52a7c2b78ebd3ee8ee98f0550e78db5fd6702368", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52a7c2b78ebd3ee8ee98f0550e78db5fd6702368/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75c5f9bdba8ca83dd4897d56051e42b928c2a571", "url": "https://api.github.com/repos/rust-lang/rust/commits/75c5f9bdba8ca83dd4897d56051e42b928c2a571", "html_url": "https://github.com/rust-lang/rust/commit/75c5f9bdba8ca83dd4897d56051e42b928c2a571"}], "stats": {"total": 94, "additions": 49, "deletions": 45}, "files": [{"sha": "f6d4678401374e0a1e325d7409e6b470b94882e1", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/52a7c2b78ebd3ee8ee98f0550e78db5fd6702368/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52a7c2b78ebd3ee8ee98f0550e78db5fd6702368/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=52a7c2b78ebd3ee8ee98f0550e78db5fd6702368", "patch": "@@ -227,7 +227,7 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n         }\n         case ('O') {\n             assert (next(st) as char == '[');\n-            let vec[ty::method] methods = [];\n+            let ty::method[] methods = ~[];\n             while (peek(st) as char != ']') {\n                 auto proto;\n                 alt (next(st) as char) {\n@@ -240,12 +240,12 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n                 }\n                 auto func = parse_ty_fn(st, sd);\n                 methods +=\n-                    [rec(proto=proto,\n-                         ident=name,\n-                         inputs=func._0,\n-                         output=func._1,\n-                         cf=func._2,\n-                         constrs=func._3)];\n+                    ~[rec(proto=proto,\n+                          ident=name,\n+                          inputs=func._0,\n+                          output=func._1,\n+                          cf=func._2,\n+                          constrs=func._3)];\n             }\n             st.pos += 1u;\n             ret ty::mk_obj(st.tcx, methods);"}, {"sha": "82ff2d1b857ef3e2cf8eed4041e44aa97ea519ab", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/52a7c2b78ebd3ee8ee98f0550e78db5fd6702368/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52a7c2b78ebd3ee8ee98f0550e78db5fd6702368/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=52a7c2b78ebd3ee8ee98f0550e78db5fd6702368", "patch": "@@ -269,7 +269,7 @@ tag sty {\n     ty_rec(field[]);\n     ty_fn(ast::proto, arg[], t, controlflow, (@constr_def)[]);\n     ty_native_fn(ast::native_abi, arg[], t);\n-    ty_obj(vec[method]);\n+    ty_obj(method[]);\n     ty_res(def_id, t, t[]);\n     ty_var(int); // type variable\n     ty_param(uint); // fn/tag type param\n@@ -604,7 +604,7 @@ fn mk_native_fn(&ctxt cx, &ast::native_abi abi, &arg[] args, &t ty) -> t {\n     ret gen_ty(cx, ty_native_fn(abi, args, ty));\n }\n \n-fn mk_obj(&ctxt cx, &vec[method] meths) -> t {\n+fn mk_obj(&ctxt cx, &method[] meths) -> t {\n     ret gen_ty(cx, ty_obj(meths));\n }\n \n@@ -799,20 +799,20 @@ fn fold_ty(&ctxt cx, fold_mode fld, t ty_0) -> t {\n                                         fold_ty(cx, fld, ret_ty)), ty);\n         }\n         case (ty_obj(?methods)) {\n-            let vec[method] new_methods = [];\n+            let method[] new_methods = ~[];\n             for (method m in methods) {\n                 let arg[] new_args = ~[];\n                 for (arg a in m.inputs) {\n                     new_args += ~[rec(mode=a.mode,\n                                       ty=fold_ty(cx, fld, a.ty))];\n                 }\n                 new_methods +=\n-                    [rec(proto=m.proto,\n-                         ident=m.ident,\n-                         inputs=new_args,\n-                         output=fold_ty(cx, fld, m.output),\n-                         cf=m.cf,\n-                         constrs=m.constrs)];\n+                    ~[rec(proto=m.proto,\n+                          ident=m.ident,\n+                          inputs=new_args,\n+                          output=fold_ty(cx, fld, m.output),\n+                          cf=m.cf,\n+                          constrs=m.constrs)];\n             }\n             ty = copy_cname(cx, mk_obj(cx, new_methods), ty);\n         }\n@@ -1634,8 +1634,8 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n         case (ty_obj(?methods_a)) {\n             alt (b) {\n                 case (ty_obj(?methods_b)) {\n-                    auto len = vec::len[method](methods_a);\n-                    if (len != vec::len[method](methods_b)) { ret false; }\n+                    auto len = ivec::len[method](methods_a);\n+                    if (len != ivec::len[method](methods_b)) { ret false; }\n                     auto i = 0u;\n                     while (i < len) {\n                         auto m_a = methods_a.(i);\n@@ -1941,17 +1941,17 @@ fn field_idx(&session::session sess, &span sp, &ast::ident id,\n }\n \n fn method_idx(&session::session sess, &span sp, &ast::ident id,\n-              &vec[method] meths) -> uint {\n+              &method[] meths) -> uint {\n     let uint i = 0u;\n     for (method m in meths) { if (str::eq(m.ident, id)) { ret i; } i += 1u; }\n     sess.span_fatal(sp, \"unknown method '\" + id + \"' of obj\");\n }\n \n-fn sort_methods(&vec[method] meths) -> vec[method] {\n+fn sort_methods(&method[] meths) -> method[] {\n     fn method_lteq(&method a, &method b) -> bool {\n         ret str::lteq(a.ident, b.ident);\n     }\n-    ret std::sort::merge_sort[method](bind method_lteq(_, _), meths);\n+    ret std::sort::ivector::merge_sort[method](bind method_lteq(_, _), meths);\n }\n \n fn is_lval(&@ast::expr expr) -> bool {\n@@ -2191,12 +2191,12 @@ mod unify {\n         }\n     }\n     fn unify_obj(&@ctxt cx, &t expected, &t actual,\n-                 &vec[method] expected_meths, &vec[method] actual_meths) ->\n+                 &method[] expected_meths, &method[] actual_meths) ->\n        result {\n-        let vec[method] result_meths = [];\n+        let method[] result_meths = ~[];\n         let uint i = 0u;\n-        let uint expected_len = vec::len[method](expected_meths);\n-        let uint actual_len = vec::len[method](actual_meths);\n+        let uint expected_len = ivec::len[method](expected_meths);\n+        let uint actual_len = ivec::len[method](actual_meths);\n         if (expected_len != actual_len) { ret ures_err(terr_meth_count); }\n         while (i < expected_len) {\n             auto e_meth = expected_meths.(i);\n@@ -2214,10 +2214,10 @@ mod unify {\n                     alt (struct(cx.tcx, tfn)) {\n                         case (ty_fn(?proto, ?ins, ?out, ?cf, ?constrs)) {\n                             result_meths +=\n-                                [rec(inputs=ins,\n-                                     output=out,\n-                                     cf=cf,\n-                                     constrs=constrs with e_meth)];\n+                                ~[rec(inputs=ins,\n+                                      output=out,\n+                                      cf=cf,\n+                                      constrs=constrs with e_meth)];\n                         }\n                     }\n                 }"}, {"sha": "854a3983e7ec4a8ce3167076dcebdb413959744d", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/52a7c2b78ebd3ee8ee98f0550e78db5fd6702368/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52a7c2b78ebd3ee8ee98f0550e78db5fd6702368/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=52a7c2b78ebd3ee8ee98f0550e78db5fd6702368", "patch": "@@ -364,7 +364,7 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n             cname = some(path_to_str(path));\n         }\n         case (ast::ty_obj(?meths)) {\n-            let vec[ty::method] tmeths = [];\n+            let ty::method[] tmeths = ~[];\n             for (ast::ty_method m in meths) {\n                 auto ins = ~[];\n                 for (ast::ty_arg ta in m.node.inputs) {\n@@ -383,7 +383,7 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n                         output=out,\n                         cf=m.node.cf,\n                         constrs=out_constrs);\n-                vec::push[ty::method](tmeths, new_m);\n+                tmeths += ~[new_m];\n             }\n             typ = ty::mk_obj(tcx, ty::sort_methods(tmeths));\n         }\n@@ -717,9 +717,12 @@ mod collect {\n             write::ty_only(cx.tcx, variant.node.id, result_ty);\n         }\n     }\n-    fn get_obj_method_types(&@ctxt cx, &ast::_obj object) -> vec[ty::method] {\n-        ret vec::map[@ast::method,\n-                     method](bind ty_of_method(cx, _), object.methods);\n+    fn get_obj_method_types(&@ctxt cx, &ast::_obj object) -> ty::method[] {\n+        auto meths = ~[];\n+        for (@ast::method m in object.methods) {\n+            meths += ~[ty_of_method(cx, m)];\n+        }\n+        ret meths;\n     }\n     fn convert(@ctxt cx, @mutable option::t[ast::native_abi] abi,\n                &@ast::item it) {\n@@ -2133,7 +2136,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                     let uint ix =\n                         ty::method_idx(fcx.ccx.tcx.sess, expr.span, field,\n                                        methods);\n-                    if (ix >= vec::len[ty::method](methods)) {\n+                    if (ix >= ivec::len[ty::method](methods)) {\n                         fcx.ccx.tcx.sess.span_fatal(expr.span,\n                                                   \"bad index on obj\");\n                     }\n@@ -2267,21 +2270,21 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                         constrs=out_constrs);\n             }\n             fn get_anon_obj_method_types(@fn_ctxt fcx,\n-                                         &ast::anon_obj anon_obj) ->\n-               vec[ty::method] {\n+                                         &ast::anon_obj anon_obj)\n+                -> ty::method[] {\n \n-                let vec[ty::method] methods = [];\n+                let ty::method[] methods = ~[];\n \n                 // Outer methods.\n-                methods += vec::map[@ast::method,\n-                                    method](bind ty_of_method(fcx.ccx, _),\n-                                            anon_obj.methods);\n+                for (@ast::method m in anon_obj.methods) {\n+                    methods += ~[ty_of_method(fcx.ccx, m)];\n+                }\n \n                 // Inner methods.\n \n                 // Typecheck 'with_obj'.  If it exists, it had better have\n                 // object type.\n-                let vec[ty::method] with_obj_methods = [];\n+                let ty::method[] with_obj_methods = ~[];\n                 alt (anon_obj.with_obj) {\n                     case (none) { }\n                     case (some(?e)) {"}, {"sha": "170a8157a17dce11b58dd520387671c1068eb7e7", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/52a7c2b78ebd3ee8ee98f0550e78db5fd6702368/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52a7c2b78ebd3ee8ee98f0550e78db5fd6702368/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=52a7c2b78ebd3ee8ee98f0550e78db5fd6702368", "patch": "@@ -133,9 +133,10 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n                            ast::return, ~[]);\n         }\n         case (ty_obj(?meths)) {\n-            auto f = bind method_to_str(cx, _);\n-            auto m = vec::map[method, str](f, meths);\n-            s += \"obj {\\n\\t\" + str::connect(m, \"\\n\\t\") + \"\\n}\";\n+            // TODO: Remove this ivec->vec conversion.\n+            auto strs = [];\n+            for (method m in meths) { strs += [method_to_str(cx, m)]; }\n+            s += \"obj {\\n\\t\" + str::connect(strs, \"\\n\\t\") + \"\\n}\";\n         }\n         case (ty_res(?id, _, _)) {\n             s += \"<resource#\" + int::str(id._0) + \":\" + int::str(id._1) + \">\";"}]}