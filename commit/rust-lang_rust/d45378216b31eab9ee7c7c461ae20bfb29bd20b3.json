{"sha": "d45378216b31eab9ee7c7c461ae20bfb29bd20b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0NTM3ODIxNmIzMWVhYjllZTdjN2M0NjFhZTIwYmZiMjliZDIwYjM=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2018-04-18T15:38:12Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2018-05-17T19:46:02Z"}, "message": "Change align_offset to support different strides\n\nThis is necessary if we want to implement `[T]::align_to` and is more\nuseful in general.\n\nThis implementation effort has begun during the All Hands and represents\na month of my futile efforts to do any sort of maths. Luckily, I\nfound the very very nice Chris McDonald (cjm) on IRC who figured out the\ncore formulas for me! All the thanks for existence of this PR go to\nthem!\n\nAnyway\u2026 Those formulas were mangled by yours truly into the arcane forms\nyou see here to squeeze out the best assembly possible on most of the\nmodern architectures (x86 and ARM were evaluated in practice). I mean,\njust look at it: *one actual* modulo operation and everything else is\njust the cheap single cycle ops! Admitedly, the naive solution might be\nfaster in some common scenarios, but this code absolutely butchers the\nnaive solution on the worst case scenario.\n\nAlas, the result of this arcane magic also means that the code pretty\nheavily relies on the preconditions holding true and breaking those\npreconditions will unleash the UB-est of all UBs! So don\u2019t.", "tree": {"sha": "a877f965ad968a4fb32bd5f54d9b3e75de7c613d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a877f965ad968a4fb32bd5f54d9b3e75de7c613d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d45378216b31eab9ee7c7c461ae20bfb29bd20b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d45378216b31eab9ee7c7c461ae20bfb29bd20b3", "html_url": "https://github.com/rust-lang/rust/commit/d45378216b31eab9ee7c7c461ae20bfb29bd20b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d45378216b31eab9ee7c7c461ae20bfb29bd20b3/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90463a6bdcd18c60e18a1cc810fc6453b96f7d54", "url": "https://api.github.com/repos/rust-lang/rust/commits/90463a6bdcd18c60e18a1cc810fc6453b96f7d54", "html_url": "https://github.com/rust-lang/rust/commit/90463a6bdcd18c60e18a1cc810fc6453b96f7d54"}], "stats": {"total": 431, "additions": 363, "deletions": 68}, "files": [{"sha": "510a5bb3df7bae453f8d4928fa1569bb2c4483ca", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d45378216b31eab9ee7c7c461ae20bfb29bd20b3/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45378216b31eab9ee7c7c461ae20bfb29bd20b3/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=d45378216b31eab9ee7c7c461ae20bfb29bd20b3", "patch": "@@ -1463,15 +1463,26 @@ extern \"rust-intrinsic\" {\n     /// source as well as std's catch implementation.\n     pub fn try(f: fn(*mut u8), data: *mut u8, local_ptr: *mut u8) -> i32;\n \n-    /// Computes the byte offset that needs to be applied to `ptr` in order to\n-    /// make it aligned to `align`.\n-    /// If it is not possible to align `ptr`, the implementation returns\n+    #[cfg(stage0)]\n+    /// docs my friends, its friday!\n+    pub fn align_offset(ptr: *const (), align: usize) -> usize;\n+\n+    /// Computes the offset that needs to be applied to the pointer in order to make it aligned to\n+    /// `align`.\n+    ///\n+    /// If it is not possible to align the pointer, the implementation returns\n     /// `usize::max_value()`.\n     ///\n-    /// There are no guarantees whatsover that offsetting the pointer will not\n-    /// overflow or go beyond the allocation that `ptr` points into.\n-    /// It is up to the caller to ensure that the returned offset is correct\n-    /// in all terms other than alignment.\n+    /// The offset is expressed in number of `T` elements, and not bytes. The value returned can be\n+    /// used with the `offset` or `offset_to` methods.\n+    ///\n+    /// There are no guarantees whatsover that offsetting the pointer will not overflow or go\n+    /// beyond the allocation that the pointer points into. It is up to the caller to ensure that\n+    /// the returned offset is correct in all terms other than alignment.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// `align` must be a power-of-two.\n     ///\n     /// # Examples\n     ///\n@@ -1485,7 +1496,7 @@ extern \"rust-intrinsic\" {\n     /// # unsafe {\n     /// let x = [5u8, 6u8, 7u8, 8u8, 9u8];\n     /// let ptr = &x[n] as *const u8;\n-    /// let offset = align_offset(ptr as *const (), align_of::<u16>());\n+    /// let offset = align_offset(ptr, align_of::<u16>());\n     /// if offset < x.len() - n - 1 {\n     ///     let u16_ptr = ptr.offset(offset as isize) as *const u16;\n     ///     assert_ne!(*u16_ptr, 500);\n@@ -1495,7 +1506,8 @@ extern \"rust-intrinsic\" {\n     /// }\n     /// # } }\n     /// ```\n-    pub fn align_offset(ptr: *const (), align: usize) -> usize;\n+    #[cfg(not(stage0))]\n+    pub fn align_offset<T>(ptr: *const T, align: usize) -> usize;\n \n     /// Emits a `!nontemporal` store according to LLVM (see their docs).\n     /// Probably will never become stable."}, {"sha": "a762a8a6f924d6d038a5c373139612e7f47de037", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 213, "deletions": 46, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/d45378216b31eab9ee7c7c461ae20bfb29bd20b3/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45378216b31eab9ee7c7c461ae20bfb29bd20b3/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=d45378216b31eab9ee7c7c461ae20bfb29bd20b3", "patch": "@@ -1433,15 +1433,22 @@ impl<T: ?Sized> *const T {\n         copy_nonoverlapping(self, dest, count)\n     }\n \n-    /// Computes the byte offset that needs to be applied in order to\n-    /// make the pointer aligned to `align`.\n+    /// Computes the offset that needs to be applied to the pointer in order to make it aligned to\n+    /// `align`.\n+    ///\n     /// If it is not possible to align the pointer, the implementation returns\n     /// `usize::max_value()`.\n     ///\n-    /// There are no guarantees whatsover that offsetting the pointer will not\n-    /// overflow or go beyond the allocation that the pointer points into.\n-    /// It is up to the caller to ensure that the returned offset is correct\n-    /// in all terms other than alignment.\n+    /// The offset is expressed in number of `T` elements, and not bytes. The value returned can be\n+    /// used with the `offset` or `offset_to` methods.\n+    ///\n+    /// There are no guarantees whatsover that offsetting the pointer will not overflow or go\n+    /// beyond the allocation that the pointer points into. It is up to the caller to ensure that\n+    /// the returned offset is correct in all terms other than alignment.\n+    ///\n+    /// # Panics\n+    ///\n+    /// The function panics if `align` is not a power-of-two.\n     ///\n     /// # Examples\n     ///\n@@ -1465,13 +1472,30 @@ impl<T: ?Sized> *const T {\n     /// # } }\n     /// ```\n     #[unstable(feature = \"align_offset\", issue = \"44488\")]\n-    pub fn align_offset(self, align: usize) -> usize {\n+    #[cfg(not(stage0))]\n+    pub fn align_offset(self, align: usize) -> usize where T: Sized {\n+        if !align.is_power_of_two() {\n+            panic!(\"align_offset: align is not a power-of-two\");\n+        }\n         unsafe {\n-            intrinsics::align_offset(self as *const _, align)\n+            intrinsics::align_offset(self, align)\n+        }\n+    }\n+\n+    /// definitely docs.\n+    #[unstable(feature = \"align_offset\", issue = \"44488\")]\n+    #[cfg(stage0)]\n+    pub fn align_offset(self, align: usize) -> usize where T: Sized {\n+        if !align.is_power_of_two() {\n+            panic!(\"align_offset: align is not a power-of-two\");\n+        }\n+        unsafe {\n+            intrinsics::align_offset(self as *const (), align)\n         }\n     }\n }\n \n+\n #[lang = \"mut_ptr\"]\n impl<T: ?Sized> *mut T {\n     /// Returns `true` if the pointer is null.\n@@ -1804,44 +1828,6 @@ impl<T: ?Sized> *mut T {\n         (self as *const T).wrapping_offset_from(origin)\n     }\n \n-    /// Computes the byte offset that needs to be applied in order to\n-    /// make the pointer aligned to `align`.\n-    /// If it is not possible to align the pointer, the implementation returns\n-    /// `usize::max_value()`.\n-    ///\n-    /// There are no guarantees whatsover that offsetting the pointer will not\n-    /// overflow or go beyond the allocation that the pointer points into.\n-    /// It is up to the caller to ensure that the returned offset is correct\n-    /// in all terms other than alignment.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Accessing adjacent `u8` as `u16`\n-    ///\n-    /// ```\n-    /// # #![feature(align_offset)]\n-    /// # fn foo(n: usize) {\n-    /// # use std::mem::align_of;\n-    /// # unsafe {\n-    /// let x = [5u8, 6u8, 7u8, 8u8, 9u8];\n-    /// let ptr = &x[n] as *const u8;\n-    /// let offset = ptr.align_offset(align_of::<u16>());\n-    /// if offset < x.len() - n - 1 {\n-    ///     let u16_ptr = ptr.offset(offset as isize) as *const u16;\n-    ///     assert_ne!(*u16_ptr, 500);\n-    /// } else {\n-    ///     // while the pointer can be aligned via `offset`, it would point\n-    ///     // outside the allocation\n-    /// }\n-    /// # } }\n-    /// ```\n-    #[unstable(feature = \"align_offset\", issue = \"44488\")]\n-    pub fn align_offset(self, align: usize) -> usize {\n-        unsafe {\n-            intrinsics::align_offset(self as *const _, align)\n-        }\n-    }\n-\n     /// Calculates the offset from a pointer (convenience for `.offset(count as isize)`).\n     ///\n     /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n@@ -2511,8 +2497,189 @@ impl<T: ?Sized> *mut T {\n     {\n         swap(self, with)\n     }\n+\n+    /// Computes the offset that needs to be applied to the pointer in order to make it aligned to\n+    /// `align`.\n+    ///\n+    /// If it is not possible to align the pointer, the implementation returns\n+    /// `usize::max_value()`.\n+    ///\n+    /// The offset is expressed in number of `T` elements, and not bytes. The value returned can be\n+    /// used with the `offset` or `offset_to` methods.\n+    ///\n+    /// There are no guarantees whatsover that offsetting the pointer will not overflow or go\n+    /// beyond the allocation that the pointer points into. It is up to the caller to ensure that\n+    /// the returned offset is correct in all terms other than alignment.\n+    ///\n+    /// # Panics\n+    ///\n+    /// The function panics if `align` is not a power-of-two.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Accessing adjacent `u8` as `u16`\n+    ///\n+    /// ```\n+    /// # #![feature(align_offset)]\n+    /// # fn foo(n: usize) {\n+    /// # use std::mem::align_of;\n+    /// # unsafe {\n+    /// let x = [5u8, 6u8, 7u8, 8u8, 9u8];\n+    /// let ptr = &x[n] as *const u8;\n+    /// let offset = ptr.align_offset(align_of::<u16>());\n+    /// if offset < x.len() - n - 1 {\n+    ///     let u16_ptr = ptr.offset(offset as isize) as *const u16;\n+    ///     assert_ne!(*u16_ptr, 500);\n+    /// } else {\n+    ///     // while the pointer can be aligned via `offset`, it would point\n+    ///     // outside the allocation\n+    /// }\n+    /// # } }\n+    /// ```\n+    #[unstable(feature = \"align_offset\", issue = \"44488\")]\n+    #[cfg(not(stage0))]\n+    pub fn align_offset(self, align: usize) -> usize where T: Sized {\n+        if !align.is_power_of_two() {\n+            panic!(\"align_offset: align is not a power-of-two\");\n+        }\n+        unsafe {\n+            intrinsics::align_offset(self, align)\n+        }\n+    }\n+\n+    /// definitely docs.\n+    #[unstable(feature = \"align_offset\", issue = \"44488\")]\n+    #[cfg(stage0)]\n+    pub fn align_offset(self, align: usize) -> usize where T: Sized {\n+        if !align.is_power_of_two() {\n+            panic!(\"align_offset: align is not a power-of-two\");\n+        }\n+        unsafe {\n+            intrinsics::align_offset(self as *const (), align)\n+        }\n+    }\n }\n \n+/// Align pointer `p`.\n+///\n+/// Calculate offset (in terms of elements of `stride` stride) that has to be applied\n+/// to pointer `p` so that pointer `p` would get aligned to `a`.\n+///\n+/// This is an implementation of the `align_offset` intrinsic for the case where `stride > 1`.\n+///\n+/// Note: This implementation has been carefully tailored to not panic. It is UB for this to panic.\n+/// The only real change that can be made here is change of `INV_TABLE_MOD_16` and associated\n+/// constants.\n+///\n+/// If we ever decide to make it possible to call the intrinsic with `a` that is not a\n+/// power-of-two, it will probably be more prudent to just change to a naive implementation rather\n+/// than trying to adapt this to accomodate that change.\n+///\n+/// Any questions go to @nagisa.\n+#[lang=\"align_offset\"]\n+#[cfg(not(stage0))]\n+unsafe fn align_offset(p: *const (), a: usize, stride: usize) -> usize {\n+    /// Calculate multiplicative modular inverse of `x` modulo `m`.\n+    ///\n+    /// This implementation is tailored for align_offset and has following preconditions:\n+    ///\n+    /// * `m` is a power-of-two;\n+    /// * `x < m`; (if `x \u2265 m`, pass in `x % m` instead)\n+    ///\n+    /// Implementation of this function shall not panic. Ever.\n+    fn mod_inv(x: usize, m: usize) -> usize {\n+        /// Multiplicative modular inverse table modulo 2\u2074 = 16.\n+        ///\n+        /// Note, that this table does not contain values where inverse does not exist (i.e. for\n+        /// `0\u207b\u00b9 mod 16`, `2\u207b\u00b9 mod 16`, etc.)\n+        static INV_TABLE_MOD_16: [usize; 8] = [1, 11, 13, 7, 9, 3, 5, 15];\n+        /// Modulo for which the `INV_TABLE_MOD_16` is intended.\n+        const INV_TABLE_MOD: usize = 16;\n+        /// INV_TABLE_MOD\u00b2\n+        const INV_TABLE_MOD_SQUARED: usize = INV_TABLE_MOD * INV_TABLE_MOD;\n+\n+        let table_inverse = INV_TABLE_MOD_16[(x & (INV_TABLE_MOD - 1)) >> 1];\n+        if m <= INV_TABLE_MOD {\n+            return table_inverse & (m - 1);\n+        } else {\n+            // We iterate \"up\" using the following formula:\n+            //\n+            // $$ xy \u2261 1 (mod 2\u207f) \u2192 xy (2 - xy) \u2261 1 (mod 2\u00b2\u207f) $$\n+            //\n+            // until 2\u00b2\u207f \u2265 m. Then we can reduce to our desired `m` by taking the result `mod m`.\n+            let mut inverse = table_inverse;\n+            let mut going_mod = INV_TABLE_MOD_SQUARED;\n+            loop {\n+                // y = y * (2 - xy) mod n\n+                //\n+                // Note, that we use wrapping operations here intentionally \u2013 the original formula\n+                // uses e.g. subtraction `mod n`. It is entirely fine to do them `mod\n+                // usize::max_value()` instead, because we take the result `mod n` at the end\n+                // anyway.\n+                inverse = inverse.wrapping_mul(\n+                    2usize.wrapping_sub(x.wrapping_mul(inverse))\n+                ) & (going_mod - 1);\n+                if going_mod > m {\n+                    return inverse & (m - 1);\n+                }\n+                going_mod = going_mod.wrapping_mul(going_mod);\n+            }\n+        }\n+    }\n+\n+    let a_minus_one = a.wrapping_sub(1);\n+    let pmoda = p as usize & a_minus_one;\n+    let smoda = stride & a_minus_one;\n+    // a is power-of-two so cannot be 0. stride = 0 is handled by the intrinsic.\n+    let gcdpow = intrinsics::cttz_nonzero(stride).min(intrinsics::cttz_nonzero(a));\n+    let gcd = 1usize << gcdpow;\n+\n+    if pmoda == 0 {\n+        // Already aligned. Yay!\n+        return 0;\n+    }\n+\n+    if gcd == 1 {\n+        // This branch solves for the variable $o$ in following linear congruence equation:\n+        //\n+        // \u23b0 p + o \u2261 0 (mod a)   # $p + o$ must be aligned to specified alignment $a$\n+        // \u23b1     o \u2261 0 (mod s)   # offset $o$ must be a multiple of stride $s$\n+        //\n+        // where\n+        //\n+        // * a, s are co-prime\n+        //\n+        // This gives us the formula below:\n+        //\n+        // o = (a - (p mod a)) * (s\u207b\u00b9 mod a) * s\n+        //\n+        // The first term is \u201cthe relative alignment of p to a\u201d, the second term is \u201chow does\n+        // incrementing p by one s change the relative alignment of p\u201d, the third term is\n+        // translating change in units of s to a byte count.\n+        //\n+        // Furthermore, the result produced by this solution is not \u201cminimal\u201d, so it is necessary\n+        // to take the result $o mod lcm(s, a)$. Since $s$ and $a$ are co-prime (i.e. $gcd(s, a) =\n+        // 1$) and $lcm(s, a) = s * a / gcd(s, a)$, we can replace $lcm(s, a)$ with just a $s * a$.\n+        //\n+        // (Author note: we decided later on to express the offset in \"elements\" rather than bytes,\n+        // which drops the multiplication by `s` on both sides of the modulo.)\n+        return intrinsics::unchecked_rem(a.wrapping_sub(pmoda).wrapping_mul(mod_inv(smoda, a)), a);\n+    }\n+\n+    if p as usize & (gcd - 1) == 0 {\n+        // This can be aligned, but `a` and `stride` are not co-prime, so a somewhat adapted\n+        // formula is used.\n+        let j = a.wrapping_sub(pmoda) >> gcdpow;\n+        let k = smoda >> gcdpow;\n+        return intrinsics::unchecked_rem(j.wrapping_mul(mod_inv(k, a)), a >> gcdpow);\n+    }\n+\n+    // Cannot be aligned at all.\n+    return usize::max_value();\n+}\n+\n+\n+\n // Equality for pointers\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> PartialEq for *const T {"}, {"sha": "6b3c1fcddc27986db00298f9624f6c663e5137dd", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d45378216b31eab9ee7c7c461ae20bfb29bd20b3/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45378216b31eab9ee7c7c461ae20bfb29bd20b3/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=d45378216b31eab9ee7c7c461ae20bfb29bd20b3", "patch": "@@ -1696,6 +1696,28 @@ impl<T> [T] {\n                 self.as_mut_ptr(), other.as_mut_ptr(), self.len());\n         }\n     }\n+\n+    // #[unstable(feature = \"slice_align_to\", issue = \"44488\")]\n+    // pub fn align_to<U>(&self) -> (&[T], &[U], &[T]) {\n+    //     // First, find at what point do we split between the first and 2nd slice.\n+    //     let x = self.as_ptr();\n+    //     let offset = x.align_offset(::mem::align_of::<U>());\n+    //     if offset > x * ::mem::size_of::<T>() {\n+    //         return (self, [], []);\n+    //     }\n+\n+    // }\n+\n+    // #[unstable(feature = \"slice_align_to\", issue = \"44488\")]\n+    // pub fn align_to_mut<U>(&mut self) -> (&mut [T], &mut [U], &mut [T]) {\n+    // }\n+}}\n+\n+#[lang = \"slice\"]\n+#[cfg(not(test))]\n+#[cfg(not(stage0))]\n+impl<T> [T] {\n+    slice_core_methods!();\n }\n \n #[lang = \"slice_u8\"]"}, {"sha": "d70f994e87ba7f878cf3cc208ee4117759b7fa09", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d45378216b31eab9ee7c7c461ae20bfb29bd20b3/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45378216b31eab9ee7c7c461ae20bfb29bd20b3/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=d45378216b31eab9ee7c7c461ae20bfb29bd20b3", "patch": "@@ -348,6 +348,9 @@ language_item_table! {\n     I128ShroFnLangItem,              \"i128_shro\",               i128_shro_fn;\n     U128ShroFnLangItem,              \"u128_shro\",               u128_shro_fn;\n \n+    // Align offset for stride != 1, must not panic.\n+    AlignOffsetLangItem,             \"align_offset\",            align_offset_fn;\n+\n     TerminationTraitLangItem,        \"termination\",             termination;\n }\n "}, {"sha": "93351651db94a15b613a685db9b17fce9c213002", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d45378216b31eab9ee7c7c461ae20bfb29bd20b3/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45378216b31eab9ee7c7c461ae20bfb29bd20b3/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=d45378216b31eab9ee7c7c461ae20bfb29bd20b3", "patch": "@@ -25,6 +25,7 @@ use type_of::LayoutLlvmExt;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{HasDataLayout, LayoutOf};\n use rustc::hir;\n+use rustc::middle::lang_items::AlignOffsetLangItem;\n use syntax::ast;\n use syntax::symbol::Symbol;\n use builder::Builder;\n@@ -390,16 +391,29 @@ pub fn codegen_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n         }\n \n         \"align_offset\" => {\n-            // `ptr as usize`\n-            let ptr_val = bx.ptrtoint(args[0].immediate(), bx.cx.isize_ty);\n-            // `ptr_val % align`\n-            let align = args[1].immediate();\n-            let offset = bx.urem(ptr_val, align);\n+            let (ptr, align) = (args[0].immediate(), args[1].immediate());\n+            let stride_of_t = bx.cx.layout_of(substs.type_at(0)).size_and_align().0.bytes();\n+            let stride = C_usize(bx.cx, stride_of_t);\n             let zero = C_null(bx.cx.isize_ty);\n-            // `offset == 0`\n-            let is_zero = bx.icmp(llvm::IntPredicate::IntEQ, offset, zero);\n-            // `if offset == 0 { 0 } else { align - offset }`\n-            bx.select(is_zero, zero, bx.sub(align, offset))\n+            let max = C_int(cx.isize_ty, -1); // -1isize (wherein I cheat horribly to make !0usize)\n+\n+            if stride_of_t <= 1 {\n+                // offset = ptr as usize % align => offset = ptr as usize & (align - 1)\n+                let modmask = bx.sub(align, C_usize(bx.cx, 1));\n+                let offset = bx.and(bx.ptrtoint(ptr, bx.cx.isize_ty), modmask);\n+                let is_zero = bx.icmp(llvm::IntPredicate::IntEQ, offset, zero);\n+                // if offset == 0 { 0 } else { if stride_of_t == 1 { align - offset } else { !0 } }\n+                bx.select(is_zero, zero, if stride_of_t == 1 {\n+                    bx.sub(align, offset)\n+                } else {\n+                    max\n+                })\n+            } else {\n+                let did = ::common::langcall(bx.tcx(), Some(span), \"\", AlignOffsetLangItem);\n+                let instance = ty::Instance::mono(bx.tcx(), did);\n+                let llfn = ::callee::get_fn(bx.cx, instance);\n+                bx.call(llfn, &[ptr, align, stride], None)\n+            }\n         }\n         name if name.starts_with(\"simd_\") => {\n             match generic_simd_intrinsic(bx, name,"}, {"sha": "db6062db1fb1cc08ddd524ad2d0791d156b16200", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d45378216b31eab9ee7c7c461ae20bfb29bd20b3/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45378216b31eab9ee7c7c461ae20bfb29bd20b3/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=d45378216b31eab9ee7c7c461ae20bfb29bd20b3", "patch": "@@ -315,8 +315,7 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n \n             \"align_offset\" => {\n-                let ptr_ty = tcx.mk_imm_ptr(tcx.mk_nil());\n-                (0, vec![ptr_ty, tcx.types.usize], tcx.types.usize)\n+                (1, vec![tcx.mk_imm_ptr(param(0)), tcx.types.usize], tcx.types.usize)\n             },\n \n             \"nontemporal_store\" => {"}, {"sha": "f7d427cb7b26c8d989a2053f5a0cf429860e8df1", "filename": "src/test/run-pass/align-offset-sign.rs", "status": "modified", "additions": 80, "deletions": 2, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/d45378216b31eab9ee7c7c461ae20bfb29bd20b3/src%2Ftest%2Frun-pass%2Falign-offset-sign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45378216b31eab9ee7c7c461ae20bfb29bd20b3/src%2Ftest%2Frun-pass%2Falign-offset-sign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falign-offset-sign.rs?ref=d45378216b31eab9ee7c7c461ae20bfb29bd20b3", "patch": "@@ -10,7 +10,85 @@\n \n #![feature(align_offset)]\n \n+#[derive(Clone, Copy)]\n+#[repr(packed)]\n+struct A3(u16, u8);\n+struct A4(u32);\n+#[repr(packed)]\n+struct A5(u32, u8);\n+#[repr(packed)]\n+struct A6(u32, u16);\n+#[repr(packed)]\n+struct A7(u32, u16, u8);\n+#[repr(packed)]\n+struct A8(u32, u32);\n+#[repr(packed)]\n+struct A9(u32, u32, u8);\n+#[repr(packed)]\n+struct A10(u32, u32, u16);\n+\n+unsafe fn test_weird_stride<T>(ptr: *const T, align: usize) -> bool {\n+    let numptr = ptr as usize;\n+    let mut expected = usize::max_value();\n+    // Naive but definitely correct way to find the *first* aligned element of stride::<T>.\n+    for el in (0..align) {\n+        if (numptr + el * ::std::mem::size_of::<T>()) % align == 0 {\n+            expected = el;\n+            break;\n+        }\n+    }\n+    let got = ptr.align_offset(align);\n+    if got != expected {\n+        eprintln!(\"aligning {:p} (with stride of {}) to {}, expected {}, got {}\", ptr, ::std::mem::size_of::<T>(), align, expected, got);\n+        return true;\n+    }\n+    return false;\n+}\n+\n fn main() {\n-    let x = 1 as *const u8;\n-    assert_eq!(x.align_offset(8), 7);\n+    unsafe {\n+        // For pointers of stride = 0, the pointer is already aligned or it cannot be aligned at\n+        // all, because no amount of elements will align the pointer.\n+        let mut p = 1;\n+        while p < 1024 {\n+            assert_eq!((p as *const ()).align_offset(p), 0);\n+            if (p != 1) {\n+                assert_eq!(((p + 1) as *const ()).align_offset(p), !0);\n+            }\n+            p = (p + 1).next_power_of_two();\n+        }\n+\n+        // For pointers of stride = 1, the pointer can always be aligned. The offset is equal to\n+        // number of bytes.\n+        let mut align = 1;\n+        while align < 1024 {\n+            for ptr in 1..2*align {\n+                let expected = ptr % align;\n+                let offset = if expected == 0 { 0 } else { align - expected };\n+                assert_eq!((ptr as *const u8).align_offset(align), offset,\n+                           \"ptr = {}, align = {}, size = 1\", ptr, align);\n+                align = (align + 1).next_power_of_two();\n+            }\n+        }\n+\n+\n+        // For pointers of stride != 1, we verify the algorithm against the naivest possible\n+        // implementation\n+        let mut align = 1;\n+        let mut x = false;\n+        while align < 1024 {\n+            for ptr in 1usize..4*align {\n+                x |= test_weird_stride::<A3>(ptr as *const A3, align);\n+                x |= test_weird_stride::<A4>(ptr as *const A4, align);\n+                x |= test_weird_stride::<A5>(ptr as *const A5, align);\n+                x |= test_weird_stride::<A6>(ptr as *const A6, align);\n+                x |= test_weird_stride::<A7>(ptr as *const A7, align);\n+                x |= test_weird_stride::<A8>(ptr as *const A8, align);\n+                x |= test_weird_stride::<A9>(ptr as *const A9, align);\n+                x |= test_weird_stride::<A10>(ptr as *const A10, align);\n+            }\n+            align = (align + 1).next_power_of_two();\n+        }\n+        assert!(!x);\n+    }\n }"}]}