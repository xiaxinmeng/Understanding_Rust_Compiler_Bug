{"sha": "eaaa3c30bf132a3f67ac0a925853e5a2f6f6baf7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhYWEzYzMwYmYxMzJhM2Y2N2FjMGE5MjU4NTNlNWEyZjZmNmJhZjc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-12-14T00:50:11Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-12-14T22:32:23Z"}, "message": "translate unique closure env better", "tree": {"sha": "d49ee7ff75e516306328eb3fd3d6767693a6e28b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d49ee7ff75e516306328eb3fd3d6767693a6e28b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eaaa3c30bf132a3f67ac0a925853e5a2f6f6baf7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eaaa3c30bf132a3f67ac0a925853e5a2f6f6baf7", "html_url": "https://github.com/rust-lang/rust/commit/eaaa3c30bf132a3f67ac0a925853e5a2f6f6baf7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eaaa3c30bf132a3f67ac0a925853e5a2f6f6baf7/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e51c29fab02c0315ebeef83acd4c01c135d32c46", "url": "https://api.github.com/repos/rust-lang/rust/commits/e51c29fab02c0315ebeef83acd4c01c135d32c46", "html_url": "https://github.com/rust-lang/rust/commit/e51c29fab02c0315ebeef83acd4c01c135d32c46"}], "stats": {"total": 74, "additions": 49, "deletions": 25}, "files": [{"sha": "40625b993b169626d239375bf5b6694d1cea6929", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 47, "deletions": 24, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/eaaa3c30bf132a3f67ac0a925853e5a2f6f6baf7/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaaa3c30bf132a3f67ac0a925853e5a2f6f6baf7/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=eaaa3c30bf132a3f67ac0a925853e5a2f6f6baf7", "patch": "@@ -2553,9 +2553,27 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n                      bound_values: [environment_value],\n                      mode: closure_constr_mode) ->\n    {ptr: ValueRef, ptrty: ty::t, bcx: @block_ctxt} {\n-    let ccx = bcx_ccx(bcx);\n+\n+    fn dummy_environment_box(bcx: @block_ctxt, r: result)\n+        -> (@block_ctxt, ValueRef, ValueRef) {\n+        // Prevent glue from trying to free this.\n+        let ccx = bcx_ccx(bcx);\n+        let ref_cnt = GEPi(bcx, r.val, [0, abi::box_rc_field_refcnt]);\n+        Store(r.bcx, C_int(ccx, 2), ref_cnt);\n+        let closure = GEPi(r.bcx, r.val, [0, abi::box_rc_field_body]);\n+        (r.bcx, closure, r.val)\n+    }\n+\n+    fn clone_tydesc(bcx: @block_ctxt,\n+                    mode: closure_constr_mode,\n+                    td: ValueRef) -> ValueRef {\n+        ret alt mode {\n+          for_block. | for_closure. { td }\n+          for_send. { Call(bcx, bcx_ccx(bcx).upcalls.clone_type_desc, [td]) }\n+        };\n+    }\n+\n     let tcx = bcx_tcx(bcx);\n-    // Synthesize a closure type.\n \n     // First, synthesize a tuple type containing the types of all the\n     // bound expressions.\n@@ -2591,26 +2609,37 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n     // Finally, synthesize a type for that whole vector.\n     let closure_ty: ty::t = ty::mk_tup(tcx, closure_tys);\n \n-    let temp_cleanups = [], bcx = bcx;\n+    let temp_cleanups = [];\n+\n     // Allocate a box that can hold something closure-sized.\n-    let (closure, box) = alt mode {\n-      for_closure. | for_send. {\n+    //\n+    // For now, no matter what kind of closure we have, we always allocate\n+    // space for a ref cnt in the closure.  If the closure is a block or\n+    // unique closure, this ref count isn't really used: we initialize it to 2\n+    // so that it will never drop to zero.  This is a hack and could go away\n+    // but then we'd have to modify the code to do the right thing when\n+    // casting from a shared closure to a block.\n+    let (bcx, closure, box) = alt mode {\n+      for_closure. {\n         let r = trans_malloc_boxed(bcx, closure_ty);\n         add_clean_free(bcx, r.box, false);\n         temp_cleanups += [r.box];\n-        bcx = r.bcx;\n-        (r.body, r.box)\n+        (r.bcx, r.body, r.box)\n+      }\n+      for_send. {\n+        // Dummy up a box in the exchange heap.\n+        let tup_ty = ty::mk_tup(tcx, [ty::mk_int(tcx), closure_ty]);\n+        let box_ty = ty::mk_uniq(tcx, {ty: tup_ty, mut: ast::imm});\n+        check trans_uniq::type_is_unique_box(bcx, box_ty);\n+        let r = trans_uniq::alloc_uniq(bcx, box_ty);\n+        add_clean_free(bcx, r.val, true);\n+        dummy_environment_box(bcx, r)\n       }\n       for_block. {\n-        // We need to dummy up a box on the stack\n+        // Dummy up a box on the stack,\n         let ty = ty::mk_tup(tcx, [ty::mk_int(tcx), closure_ty]);\n         let r = alloc_ty(bcx, ty);\n-        bcx = r.bcx;\n-        // Prevent glue from trying to free this.\n-        Store(bcx,\n-              C_int(ccx, 2),\n-              GEPi(bcx, r.val, [0, abi::box_rc_field_refcnt]));\n-        (GEPi(bcx, r.val, [0, abi::box_rc_field_body]), r.val)\n+        dummy_environment_box(bcx, r)\n       }\n     };\n \n@@ -2624,7 +2653,8 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n         bcx = bindings_tydesc.bcx;\n-        Store(bcx, bindings_tydesc.val, bound_tydesc);\n+        let td = clone_tydesc(bcx, mode, bindings_tydesc.val);\n+        Store(bcx, td, bound_tydesc);\n       }\n       for_block. {}\n     }\n@@ -2675,15 +2705,8 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n     i = 0u;\n     for td: ValueRef in lltydescs {\n         let ty_param_slot = GEPi(bcx, ty_params_slot.val, [0, i as int]);\n-        alt mode {\n-          for_closure. | for_block. {\n-            Store(bcx, td, ty_param_slot);\n-          }\n-          for_send. {\n-            let cloned_td = Call(bcx, ccx.upcalls.clone_type_desc, [td]);\n-            Store(bcx, cloned_td, ty_param_slot);\n-          }\n-        }\n+        let cloned_td = clone_tydesc(bcx, mode, td);\n+        Store(bcx, cloned_td, ty_param_slot);\n         i += 1u;\n     }\n "}, {"sha": "6b420a43091991006b23ee013fd5d66e8ac3b876", "filename": "src/comp/middle/trans_uniq.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eaaa3c30bf132a3f67ac0a925853e5a2f6f6baf7/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaaa3c30bf132a3f67ac0a925853e5a2f6f6baf7/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs?ref=eaaa3c30bf132a3f67ac0a925853e5a2f6f6baf7", "patch": "@@ -15,7 +15,8 @@ import trans::{\n     dest\n };\n \n-export trans_uniq, make_free_glue, type_is_unique_box, autoderef, duplicate;\n+export trans_uniq, make_free_glue, type_is_unique_box, autoderef, duplicate,\n+       alloc_uniq;\n \n pure fn type_is_unique_box(bcx: @block_ctxt, ty: ty::t) -> bool {\n     ty::type_is_unique_box(bcx_tcx(bcx), ty)"}]}