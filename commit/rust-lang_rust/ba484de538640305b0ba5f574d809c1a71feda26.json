{"sha": "ba484de538640305b0ba5f574d809c1a71feda26", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhNDg0ZGU1Mzg2NDAzMDViMGJhNWY1NzRkODA5YzFhNzFmZWRhMjY=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-12-28T15:34:05Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-01-23T09:30:39Z"}, "message": "Move some code around", "tree": {"sha": "40a6d4a241063c60ffedb12e909588028180eaf6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40a6d4a241063c60ffedb12e909588028180eaf6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba484de538640305b0ba5f574d809c1a71feda26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba484de538640305b0ba5f574d809c1a71feda26", "html_url": "https://github.com/rust-lang/rust/commit/ba484de538640305b0ba5f574d809c1a71feda26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba484de538640305b0ba5f574d809c1a71feda26/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da0309c71163fb2a31e966ef79a02a6b76139654", "url": "https://api.github.com/repos/rust-lang/rust/commits/da0309c71163fb2a31e966ef79a02a6b76139654", "html_url": "https://github.com/rust-lang/rust/commit/da0309c71163fb2a31e966ef79a02a6b76139654"}], "stats": {"total": 131, "additions": 76, "deletions": 55}, "files": [{"sha": "566bf70a3d26c509ec2769128c282d66713bde20", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 76, "deletions": 55, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/ba484de538640305b0ba5f574d809c1a71feda26/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba484de538640305b0ba5f574d809c1a71feda26/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=ba484de538640305b0ba5f574d809c1a71feda26", "patch": "@@ -2514,7 +2514,7 @@ where\n         extra_args: &[Ty<'tcx>],\n         caller_location: Option<Ty<'tcx>>,\n         codegen_fn_attr_flags: CodegenFnAttrFlags,\n-        mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgAbi<'tcx, Ty<'tcx>>,\n+        make_self_ptr_thin: bool,\n     ) -> Self;\n     fn adjust_for_abi(&mut self, cx: &C, abi: SpecAbi);\n }\n@@ -2574,9 +2574,7 @@ where\n         // Assume that fn pointers may always unwind\n         let codegen_fn_attr_flags = CodegenFnAttrFlags::UNWIND;\n \n-        call::FnAbi::new_internal(cx, sig, extra_args, None, codegen_fn_attr_flags, |ty, _| {\n-            ArgAbi::new(cx.layout_of(ty))\n-        })\n+        call::FnAbi::new_internal(cx, sig, extra_args, None, codegen_fn_attr_flags, false)\n     }\n \n     fn of_instance(cx: &C, instance: ty::Instance<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n@@ -2590,55 +2588,14 @@ where\n \n         let attrs = cx.tcx().codegen_fn_attrs(instance.def_id()).flags;\n \n-        call::FnAbi::new_internal(cx, sig, extra_args, caller_location, attrs, |ty, arg_idx| {\n-            let mut layout = cx.layout_of(ty);\n-            // Don't pass the vtable, it's not an argument of the virtual fn.\n-            // Instead, pass just the data pointer, but give it the type `*const/mut dyn Trait`\n-            // or `&/&mut dyn Trait` because this is special-cased elsewhere in codegen\n-            if let (ty::InstanceDef::Virtual(..), Some(0)) = (&instance.def, arg_idx) {\n-                let fat_pointer_ty = if layout.is_unsized() {\n-                    // unsized `self` is passed as a pointer to `self`\n-                    // FIXME (mikeyhew) change this to use &own if it is ever added to the language\n-                    cx.tcx().mk_mut_ptr(layout.ty)\n-                } else {\n-                    match layout.abi {\n-                        Abi::ScalarPair(..) => (),\n-                        _ => bug!(\"receiver type has unsupported layout: {:?}\", layout),\n-                    }\n-\n-                    // In the case of Rc<Self>, we need to explicitly pass a *mut RcBox<Self>\n-                    // with a Scalar (not ScalarPair) ABI. This is a hack that is understood\n-                    // elsewhere in the compiler as a method on a `dyn Trait`.\n-                    // To get the type `*mut RcBox<Self>`, we just keep unwrapping newtypes until we\n-                    // get a built-in pointer type\n-                    let mut fat_pointer_layout = layout;\n-                    'descend_newtypes: while !fat_pointer_layout.ty.is_unsafe_ptr()\n-                        && !fat_pointer_layout.ty.is_region_ptr()\n-                    {\n-                        for i in 0..fat_pointer_layout.fields.count() {\n-                            let field_layout = fat_pointer_layout.field(cx, i);\n-\n-                            if !field_layout.is_zst() {\n-                                fat_pointer_layout = field_layout;\n-                                continue 'descend_newtypes;\n-                            }\n-                        }\n-\n-                        bug!(\"receiver has no non-zero-sized fields {:?}\", fat_pointer_layout);\n-                    }\n-\n-                    fat_pointer_layout.ty\n-                };\n-\n-                // we now have a type like `*mut RcBox<dyn Trait>`\n-                // change its layout to that of `*mut ()`, a thin pointer, but keep the same type\n-                // this is understood as a special case elsewhere in the compiler\n-                let unit_pointer_ty = cx.tcx().mk_mut_ptr(cx.tcx().mk_unit());\n-                layout = cx.layout_of(unit_pointer_ty);\n-                layout.ty = fat_pointer_ty;\n-            }\n-            ArgAbi::new(layout)\n-        })\n+        call::FnAbi::new_internal(\n+            cx,\n+            sig,\n+            extra_args,\n+            caller_location,\n+            attrs,\n+            matches!(instance.def, ty::InstanceDef::Virtual(..)),\n+        )\n     }\n \n     fn new_internal(\n@@ -2647,7 +2604,7 @@ where\n         extra_args: &[Ty<'tcx>],\n         caller_location: Option<Ty<'tcx>>,\n         codegen_fn_attr_flags: CodegenFnAttrFlags,\n-        mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgAbi<'tcx, Ty<'tcx>>,\n+        force_thin_self_ptr: bool,\n     ) -> Self {\n         debug!(\"FnAbi::new_internal({:?}, {:?})\", sig, extra_args);\n \n@@ -2778,7 +2735,18 @@ where\n \n         let arg_of = |ty: Ty<'tcx>, arg_idx: Option<usize>| {\n             let is_return = arg_idx.is_none();\n-            let mut arg = mk_arg_type(ty, arg_idx);\n+\n+            let layout = if force_thin_self_ptr && arg_idx == Some(0) {\n+                // Don't pass the vtable, it's not an argument of the virtual fn.\n+                // Instead, pass just the data pointer, but give it the type `*const/mut dyn Trait`\n+                // or `&/&mut dyn Trait` because this is special-cased elsewhere in codegen\n+                make_thin_self_ptr(cx, cx.layout_of(ty))\n+            } else {\n+                cx.layout_of(ty)\n+            };\n+\n+            let mut arg = ArgAbi::new(layout);\n+\n             if arg.layout.is_zst() {\n                 // For some forsaken reason, x86_64-pc-windows-gnu\n                 // doesn't ignore zero-sized struct arguments.\n@@ -2912,3 +2880,56 @@ where\n         }\n     }\n }\n+\n+fn make_thin_self_ptr<'tcx, C>(\n+    cx: &C,\n+    mut layout: TyAndLayout<'tcx>,\n+) -> TyAndLayout<'tcx>\n+where C: LayoutOf<Ty = Ty<'tcx>, TyAndLayout = TyAndLayout<'tcx>>\n+        //+ HasDataLayout\n+        //+ HasTargetSpec\n+        + HasTyCtxt<'tcx>\n+        + HasParamEnv<'tcx>\n+{\n+    let fat_pointer_ty = if layout.is_unsized() {\n+        // unsized `self` is passed as a pointer to `self`\n+        // FIXME (mikeyhew) change this to use &own if it is ever added to the language\n+        cx.tcx().mk_mut_ptr(layout.ty)\n+    } else {\n+        match layout.abi {\n+            Abi::ScalarPair(..) => (),\n+            _ => bug!(\"receiver type has unsupported layout: {:?}\", layout),\n+        }\n+\n+        // In the case of Rc<Self>, we need to explicitly pass a *mut RcBox<Self>\n+        // with a Scalar (not ScalarPair) ABI. This is a hack that is understood\n+        // elsewhere in the compiler as a method on a `dyn Trait`.\n+        // To get the type `*mut RcBox<Self>`, we just keep unwrapping newtypes until we\n+        // get a built-in pointer type\n+        let mut fat_pointer_layout = layout;\n+        'descend_newtypes: while !fat_pointer_layout.ty.is_unsafe_ptr()\n+            && !fat_pointer_layout.ty.is_region_ptr()\n+        {\n+            for i in 0..fat_pointer_layout.fields.count() {\n+                let field_layout = fat_pointer_layout.field(cx, i);\n+\n+                if !field_layout.is_zst() {\n+                    fat_pointer_layout = field_layout;\n+                    continue 'descend_newtypes;\n+                }\n+            }\n+\n+            bug!(\"receiver has no non-zero-sized fields {:?}\", fat_pointer_layout);\n+        }\n+\n+        fat_pointer_layout.ty\n+    };\n+\n+    // we now have a type like `*mut RcBox<dyn Trait>`\n+    // change its layout to that of `*mut ()`, a thin pointer, but keep the same type\n+    // this is understood as a special case elsewhere in the compiler\n+    let unit_pointer_ty = cx.tcx().mk_mut_ptr(cx.tcx().mk_unit());\n+    layout = cx.layout_of(unit_pointer_ty);\n+    layout.ty = fat_pointer_ty;\n+    layout\n+}"}]}