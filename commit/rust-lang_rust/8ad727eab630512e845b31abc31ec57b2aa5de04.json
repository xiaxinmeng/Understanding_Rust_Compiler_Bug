{"sha": "8ad727eab630512e845b31abc31ec57b2aa5de04", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhZDcyN2VhYjYzMDUxMmU4NDViMzFhYmMzMWVjNTdiMmFhNWRlMDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-10T03:36:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-10T03:36:17Z"}, "message": "Auto merge of #58498 - euclio:e0432-suggestions, r=estebank\n\nuse structured suggestions for E0432", "tree": {"sha": "6a29189725f6feafbe8eb569c1a7434b53172dff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a29189725f6feafbe8eb569c1a7434b53172dff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ad727eab630512e845b31abc31ec57b2aa5de04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ad727eab630512e845b31abc31ec57b2aa5de04", "html_url": "https://github.com/rust-lang/rust/commit/8ad727eab630512e845b31abc31ec57b2aa5de04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ad727eab630512e845b31abc31ec57b2aa5de04/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26b4cb48484382032522384318e70ceb0fbc4a41", "url": "https://api.github.com/repos/rust-lang/rust/commits/26b4cb48484382032522384318e70ceb0fbc4a41", "html_url": "https://github.com/rust-lang/rust/commit/26b4cb48484382032522384318e70ceb0fbc4a41"}, {"sha": "4bbe8839dddb4a87b91dfe8af6e81b7d8b9cc478", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bbe8839dddb4a87b91dfe8af6e81b7d8b9cc478", "html_url": "https://github.com/rust-lang/rust/commit/4bbe8839dddb4a87b91dfe8af6e81b7d8b9cc478"}], "stats": {"total": 462, "additions": 310, "deletions": 152}, "files": [{"sha": "b50e37519d46312772cee12352b32c686ed0fea2", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 69, "deletions": 25, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8ad727eab630512e845b31abc31ec57b2aa5de04", "patch": "@@ -137,6 +137,9 @@ impl Ord for BindingError {\n     }\n }\n \n+/// A span, message, replacement text, and applicability.\n+type Suggestion = (Span, String, String, Applicability);\n+\n enum ResolutionError<'a> {\n     /// Error E0401: can't use type or const parameters from outer function.\n     GenericParamsFromOuterFunction(Def),\n@@ -166,7 +169,7 @@ enum ResolutionError<'a> {\n     /// Error E0431: `self` import can only appear in an import list with a non-empty prefix.\n     SelfImportOnlyInImportListWithNonEmptyPrefix,\n     /// Error E0433: failed to resolve.\n-    FailedToResolve(&'a str),\n+    FailedToResolve { label: String, suggestion: Option<Suggestion> },\n     /// Error E0434: can't capture dynamic environment in a fn item.\n     CannotCaptureDynamicEnvironmentInFnItem,\n     /// Error E0435: attempt to use a non-constant value in a constant.\n@@ -380,10 +383,15 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver<'_>,\n             err.span_label(span, \"can only appear in an import list with a non-empty prefix\");\n             err\n         }\n-        ResolutionError::FailedToResolve(msg) => {\n+        ResolutionError::FailedToResolve { label, suggestion } => {\n             let mut err = struct_span_err!(resolver.session, span, E0433,\n-                                           \"failed to resolve: {}\", msg);\n-            err.span_label(span, msg);\n+                                           \"failed to resolve: {}\", &label);\n+            err.span_label(span, label);\n+\n+            if let Some((span, msg, suggestion, applicability)) = suggestion {\n+                err.span_suggestion(span, &msg, suggestion, applicability);\n+            }\n+\n             err\n         }\n         ResolutionError::CannotCaptureDynamicEnvironmentInFnItem => {\n@@ -1050,7 +1058,12 @@ enum PathResult<'a> {\n     Module(ModuleOrUniformRoot<'a>),\n     NonModule(PathResolution),\n     Indeterminate,\n-    Failed(Span, String, bool /* is the error from the last segment? */),\n+    Failed {\n+        span: Span,\n+        label: String,\n+        suggestion: Option<Suggestion>,\n+        is_error_from_last_segment: bool,\n+    },\n }\n \n enum ModuleKind {\n@@ -1775,13 +1788,18 @@ impl<'a> Resolver<'a> {\n             PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 =>\n                 path_res.base_def(),\n             PathResult::NonModule(..) => {\n-                let msg = \"type-relative paths are not supported in this context\";\n-                error_callback(self, span, ResolutionError::FailedToResolve(msg));\n+                error_callback(self, span, ResolutionError::FailedToResolve {\n+                    label: String::from(\"type-relative paths are not supported in this context\"),\n+                    suggestion: None,\n+                });\n                 Def::Err\n             }\n             PathResult::Module(..) | PathResult::Indeterminate => unreachable!(),\n-            PathResult::Failed(span, msg, _) => {\n-                error_callback(self, span, ResolutionError::FailedToResolve(&msg));\n+            PathResult::Failed { span, label, suggestion, .. } => {\n+                error_callback(self, span, ResolutionError::FailedToResolve {\n+                    label,\n+                    suggestion,\n+                });\n                 Def::Err\n             }\n         };\n@@ -3429,7 +3447,7 @@ impl<'a> Resolver<'a> {\n             // Such behavior is required for backward compatibility.\n             // The same fallback is used when `a` resolves to nothing.\n             PathResult::Module(ModuleOrUniformRoot::Module(_)) |\n-            PathResult::Failed(..)\n+            PathResult::Failed { .. }\n                     if (ns == TypeNS || path.len() > 1) &&\n                        self.primitive_type_table.primitive_types\n                            .contains_key(&path[0].ident.name) => {\n@@ -3438,11 +3456,11 @@ impl<'a> Resolver<'a> {\n             }\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n                 PathResolution::new(module.def().unwrap()),\n-            PathResult::Failed(span, msg, false) => {\n-                resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n+            PathResult::Failed { is_error_from_last_segment: false, span, label, suggestion } => {\n+                resolve_error(self, span, ResolutionError::FailedToResolve { label, suggestion });\n                 err_path_resolution()\n             }\n-            PathResult::Module(..) | PathResult::Failed(..) => return None,\n+            PathResult::Module(..) | PathResult::Failed { .. } => return None,\n             PathResult::Indeterminate => bug!(\"indetermined path result in resolve_qpath\"),\n         };\n \n@@ -3550,7 +3568,12 @@ impl<'a> Resolver<'a> {\n                         }\n                     }\n                     let msg = \"there are too many initial `super`s.\".to_string();\n-                    return PathResult::Failed(ident.span, msg, false);\n+                    return PathResult::Failed {\n+                        span: ident.span,\n+                        label: msg,\n+                        suggestion: None,\n+                        is_error_from_last_segment: false,\n+                    };\n                 }\n                 if i == 0 {\n                     if name == keywords::SelfLower.name() {\n@@ -3587,12 +3610,17 @@ impl<'a> Resolver<'a> {\n                 } else {\n                     format!(\"`{}`\", name)\n                 };\n-                let msg = if i == 1 && path[0].ident.name == keywords::PathRoot.name() {\n+                let label = if i == 1 && path[0].ident.name == keywords::PathRoot.name() {\n                     format!(\"global paths cannot start with {}\", name_str)\n                 } else {\n                     format!(\"{} in paths can only be used in start position\", name_str)\n                 };\n-                return PathResult::Failed(ident.span, msg, false);\n+                return PathResult::Failed {\n+                    span: ident.span,\n+                    label,\n+                    suggestion: None,\n+                    is_error_from_last_segment: false,\n+                };\n             }\n \n             let binding = if let Some(module) = module {\n@@ -3653,9 +3681,12 @@ impl<'a> Resolver<'a> {\n                             def, path.len() - i - 1\n                         ));\n                     } else {\n-                        return PathResult::Failed(ident.span,\n-                                                  format!(\"not a module `{}`\", ident),\n-                                                  is_last);\n+                        return PathResult::Failed {\n+                            span: ident.span,\n+                            label: format!(\"not a module `{}`\", ident),\n+                            suggestion: None,\n+                            is_error_from_last_segment: is_last,\n+                        };\n                     }\n                 }\n                 Err(Undetermined) => return PathResult::Indeterminate,\n@@ -3671,27 +3702,40 @@ impl<'a> Resolver<'a> {\n                         Some(ModuleOrUniformRoot::Module(module)) => module.def(),\n                         _ => None,\n                     };\n-                    let msg = if module_def == self.graph_root.def() {\n+                    let (label, suggestion) = if module_def == self.graph_root.def() {\n                         let is_mod = |def| match def { Def::Mod(..) => true, _ => false };\n                         let mut candidates =\n                             self.lookup_import_candidates(ident, TypeNS, is_mod);\n                         candidates.sort_by_cached_key(|c| {\n                             (c.path.segments.len(), c.path.to_string())\n                         });\n                         if let Some(candidate) = candidates.get(0) {\n-                            format!(\"did you mean `{}`?\", candidate.path)\n+                            (\n+                                String::from(\"unresolved import\"),\n+                                Some((\n+                                    ident.span,\n+                                    String::from(\"a similar path exists\"),\n+                                    candidate.path.to_string(),\n+                                    Applicability::MaybeIncorrect,\n+                                )),\n+                            )\n                         } else if !ident.is_reserved() {\n-                            format!(\"maybe a missing `extern crate {};`?\", ident)\n+                            (format!(\"maybe a missing `extern crate {};`?\", ident), None)\n                         } else {\n                             // the parser will already have complained about the keyword being used\n                             return PathResult::NonModule(err_path_resolution());\n                         }\n                     } else if i == 0 {\n-                        format!(\"use of undeclared type or module `{}`\", ident)\n+                        (format!(\"use of undeclared type or module `{}`\", ident), None)\n                     } else {\n-                        format!(\"could not find `{}` in `{}`\", ident, path[i - 1].ident)\n+                        (format!(\"could not find `{}` in `{}`\", ident, path[i - 1].ident), None)\n+                    };\n+                    return PathResult::Failed {\n+                        span: ident.span,\n+                        label,\n+                        suggestion,\n+                        is_error_from_last_segment: is_last,\n                     };\n-                    return PathResult::Failed(ident.span, msg, is_last);\n                 }\n             }\n         }"}, {"sha": "8e4b2a9a4cb1ace9b1500939626c8aa79b6dc7b3", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=8ad727eab630512e845b31abc31ec57b2aa5de04", "patch": "@@ -426,9 +426,9 @@ impl<'a> Resolver<'a> {\n                     Ok(path_res.base_def())\n                 }\n                 PathResult::Indeterminate if !force => return Err(Determinacy::Undetermined),\n-                PathResult::NonModule(..) | PathResult::Indeterminate | PathResult::Failed(..) => {\n-                    Err(Determinacy::Determined)\n-                }\n+                PathResult::NonModule(..)\n+                | PathResult::Indeterminate\n+                | PathResult::Failed { .. } => Err(Determinacy::Determined),\n                 PathResult::Module(..) => unreachable!(),\n             };\n \n@@ -990,14 +990,17 @@ impl<'a> Resolver<'a> {\n                     let def = path_res.base_def();\n                     check_consistency(self, &path, path_span, kind, initial_def, def);\n                 }\n-                path_res @ PathResult::NonModule(..) | path_res @ PathResult::Failed(..) => {\n-                    let (span, msg) = if let PathResult::Failed(span, msg, ..) = path_res {\n-                        (span, msg)\n+                path_res @ PathResult::NonModule(..) | path_res @ PathResult::Failed { .. } => {\n+                    let (span, label) = if let PathResult::Failed { span, label, .. } = path_res {\n+                        (span, label)\n                     } else {\n                         (path_span, format!(\"partially resolved path in {} {}\",\n                                             kind.article(), kind.descr()))\n                     };\n-                    resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n+                    resolve_error(self, span, ResolutionError::FailedToResolve {\n+                        label,\n+                        suggestion: None\n+                    });\n                 }\n                 PathResult::Module(..) | PathResult::Indeterminate => unreachable!(),\n             }"}, {"sha": "9daffd522bf2c3ee47ea89426b70eaf2e1c85161", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 135, "deletions": 72, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=8ad727eab630512e845b31abc31ec57b2aa5de04", "patch": "@@ -6,9 +6,11 @@ use crate::Namespace::{self, TypeNS, MacroNS};\n use crate::{NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyError};\n use crate::{Resolver, Segment};\n use crate::{names_to_string, module_to_string};\n-use crate::{resolve_error, ResolutionError};\n+use crate::{resolve_error, ResolutionError, Suggestion};\n use crate::macros::ParentScope;\n \n+use errors::Applicability;\n+\n use rustc_data_structures::ptr_key::PtrKey;\n use rustc::ty;\n use rustc::lint::builtin::BuiltinLintDiagnostics;\n@@ -27,7 +29,7 @@ use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::{struct_span_err, unwrap_or};\n use syntax_pos::{MultiSpan, Span};\n \n-use log::debug;\n+use log::*;\n \n use std::cell::{Cell, RefCell};\n use std::{mem, ptr};\n@@ -623,6 +625,16 @@ impl<'a> Resolver<'a> {\n     }\n }\n \n+/// An error that may be transformed into a diagnostic later. Used to combine multiple unresolved\n+/// import errors within the same use tree into a single diagnostic.\n+#[derive(Debug, Clone)]\n+struct UnresolvedImportError {\n+    span: Span,\n+    label: Option<String>,\n+    note: Option<String>,\n+    suggestion: Option<Suggestion>,\n+}\n+\n pub struct ImportResolver<'a, 'b: 'a> {\n     pub resolver: &'a mut Resolver<'b>,\n }\n@@ -675,14 +687,14 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             self.finalize_resolutions_in(module);\n         }\n \n-        let mut errors = false;\n+        let mut has_errors = false;\n         let mut seen_spans = FxHashSet::default();\n-        let mut error_vec = Vec::new();\n+        let mut errors = vec![];\n         let mut prev_root_id: NodeId = NodeId::from_u32(0);\n         for i in 0 .. self.determined_imports.len() {\n             let import = self.determined_imports[i];\n-            if let Some((span, err, note)) = self.finalize_import(import) {\n-                errors = true;\n+            if let Some(err) = self.finalize_import(import) {\n+                has_errors = true;\n \n                 if let SingleImport { source, ref source_bindings, .. } = import.subclass {\n                     if source.name == \"self\" {\n@@ -696,82 +708,95 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 // If the error is a single failed import then create a \"fake\" import\n                 // resolution for it so that later resolve stages won't complain.\n                 self.import_dummy_binding(import);\n-                if prev_root_id.as_u32() != 0 &&\n-                    prev_root_id.as_u32() != import.root_id.as_u32() &&\n-                    !error_vec.is_empty(){\n-                    // in case of new import line, throw diagnostic message\n-                    // for previous line.\n-                    let mut empty_vec = vec![];\n-                    mem::swap(&mut empty_vec, &mut error_vec);\n-                    self.throw_unresolved_import_error(empty_vec, None);\n+                if prev_root_id.as_u32() != 0\n+                        && prev_root_id.as_u32() != import.root_id.as_u32()\n+                        && !errors.is_empty() {\n+                    // In the case of a new import line, throw a diagnostic message\n+                    // for the previous line.\n+                    self.throw_unresolved_import_error(errors, None);\n+                    errors = vec![];\n                 }\n-                if !seen_spans.contains(&span) {\n+                if !seen_spans.contains(&err.span) {\n                     let path = import_path_to_string(\n                         &import.module_path.iter().map(|seg| seg.ident).collect::<Vec<_>>(),\n                         &import.subclass,\n-                        span,\n+                        err.span,\n                     );\n-                    error_vec.push((span, path, err, note));\n-                    seen_spans.insert(span);\n+                    seen_spans.insert(err.span);\n+                    errors.push((path, err));\n                     prev_root_id = import.root_id;\n                 }\n             }\n         }\n \n-        if !error_vec.is_empty() {\n-            self.throw_unresolved_import_error(error_vec.clone(), None);\n+        if !errors.is_empty() {\n+            self.throw_unresolved_import_error(errors.clone(), None);\n         }\n \n         // Report unresolved imports only if no hard error was already reported\n         // to avoid generating multiple errors on the same import.\n-        if !errors {\n+        if !has_errors {\n             for import in &self.indeterminate_imports {\n-                self.throw_unresolved_import_error(error_vec, Some(MultiSpan::from(import.span)));\n+                self.throw_unresolved_import_error(errors, Some(MultiSpan::from(import.span)));\n                 break;\n             }\n         }\n     }\n \n     fn throw_unresolved_import_error(\n         &self,\n-        error_vec: Vec<(Span, String, String, Option<String>)>,\n+        errors: Vec<(String, UnresolvedImportError)>,\n         span: Option<MultiSpan>,\n     ) {\n-        let max_span_label_msg_count = 10;  // upper limit on number of span_label message.\n-        let (span, msg, note) = if error_vec.is_empty() {\n+        /// Upper limit on the number of `span_label` messages.\n+        const MAX_LABEL_COUNT: usize = 10;\n+\n+        let (span, msg, note) = if errors.is_empty() {\n             (span.unwrap(), \"unresolved import\".to_string(), None)\n         } else {\n             let span = MultiSpan::from_spans(\n-                error_vec.clone().into_iter()\n-                .map(|elem: (Span, String, String, Option<String>)| elem.0)\n-                .collect()\n+                errors\n+                    .iter()\n+                    .map(|(_, err)| err.span)\n+                    .collect(),\n             );\n \n-            let note: Option<String> = error_vec.clone().into_iter()\n-                .filter_map(|elem: (Span, String, String, Option<String>)| elem.3)\n+            let note = errors\n+                .iter()\n+                .filter_map(|(_, err)| err.note.as_ref())\n                 .last();\n \n-            let path_vec: Vec<String> = error_vec.clone().into_iter()\n-                .map(|elem: (Span, String, String, Option<String>)| format!(\"`{}`\", elem.1))\n-                .collect();\n-            let path = path_vec.join(\", \");\n+            let paths = errors\n+                .iter()\n+                .map(|(path, _)| format!(\"`{}`\", path))\n+                .collect::<Vec<_>>();\n+\n             let msg = format!(\n                 \"unresolved import{} {}\",\n-                if path_vec.len() > 1 { \"s\" } else { \"\" },\n-                path\n+                if paths.len() > 1 { \"s\" } else { \"\" },\n+                paths.join(\", \"),\n             );\n \n             (span, msg, note)\n         };\n \n-        let mut err = struct_span_err!(self.resolver.session, span, E0432, \"{}\", &msg);\n-        for span_error in error_vec.into_iter().take(max_span_label_msg_count) {\n-            err.span_label(span_error.0, span_error.2);\n+        let mut diag = struct_span_err!(self.resolver.session, span, E0432, \"{}\", &msg);\n+\n+        if let Some(note) = &note {\n+            diag.note(note);\n         }\n-        if let Some(note) = note {\n-            err.note(&note);\n+\n+        for (_, err) in errors.into_iter().take(MAX_LABEL_COUNT) {\n+            if let Some(label) = err.label {\n+                diag.span_label(err.span, label);\n+            }\n+\n+            if let Some((span, msg, suggestion, applicability)) = err.suggestion {\n+                diag.span_suggestion(span, &msg, suggestion, applicability);\n+            }\n         }\n-        err.emit();\n+\n+        diag.emit();\n     }\n \n     /// Attempts to resolve the given import, returning true if its resolution is determined.\n@@ -802,7 +827,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             match path_res {\n                 PathResult::Module(module) => module,\n                 PathResult::Indeterminate => return false,\n-                PathResult::NonModule(..) | PathResult::Failed(..) => return true,\n+                PathResult::NonModule(..) | PathResult::Failed { .. } => return true,\n             }\n         };\n \n@@ -866,11 +891,14 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         !indeterminate\n     }\n \n-    // If appropriate, returns an error to report.\n+    /// Performs final import resolution, consistency checks and error reporting.\n+    ///\n+    /// Optionally returns an unresolved import error. This error is buffered and used to\n+    /// consolidate multiple unresolved import errors into a single diagnostic.\n     fn finalize_import(\n         &mut self,\n         directive: &'b ImportDirective<'b>\n-    ) -> Option<(Span, String, Option<String>)> {\n+    ) -> Option<UnresolvedImportError> {\n         self.current_module = directive.parent_scope.module;\n \n         let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n@@ -896,25 +924,48 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n \n                 module\n             }\n-            PathResult::Failed(span, msg, false) => {\n+            PathResult::Failed { is_error_from_last_segment: false, span, label, suggestion } => {\n                 if no_ambiguity {\n                     assert!(directive.imported_module.get().is_none());\n-                    resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n+                    resolve_error(self, span, ResolutionError::FailedToResolve {\n+                        label,\n+                        suggestion,\n+                    });\n                 }\n                 return None;\n             }\n-            PathResult::Failed(span, msg, true) => {\n+            PathResult::Failed { is_error_from_last_segment: true, span, label, suggestion } => {\n                 if no_ambiguity {\n                     assert!(directive.imported_module.get().is_none());\n-                    return Some(match self.make_path_suggestion(span, directive.module_path.clone(),\n-                                                                &directive.parent_scope) {\n-                        Some((suggestion, note)) => (\n-                            span,\n-                            format!(\"did you mean `{}`?\", Segment::names_to_string(&suggestion)),\n-                            note,\n-                        ),\n-                        None => (span, msg, None),\n-                    });\n+                    let err = match self.make_path_suggestion(\n+                        span,\n+                        directive.module_path.clone(),\n+                        &directive.parent_scope,\n+                    ) {\n+                        Some((suggestion, note)) => {\n+                            UnresolvedImportError {\n+                                span,\n+                                label: None,\n+                                note,\n+                                suggestion: Some((\n+                                    span,\n+                                    String::from(\"a similar path exists\"),\n+                                    Segment::names_to_string(&suggestion),\n+                                    Applicability::MaybeIncorrect,\n+                                )),\n+                            }\n+                        }\n+                        None => {\n+                            UnresolvedImportError {\n+                                span,\n+                                label: Some(label),\n+                                note: None,\n+                                suggestion,\n+                            }\n+                        }\n+                    };\n+\n+                    return Some(err);\n                 }\n                 return None;\n             }\n@@ -950,11 +1001,12 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 if let ModuleOrUniformRoot::Module(module) = module {\n                     if module.def_id() == directive.parent_scope.module.def_id() {\n                         // Importing a module into itself is not allowed.\n-                        return Some((\n-                            directive.span,\n-                            \"Cannot glob-import a module into itself.\".to_string(),\n-                            None,\n-                        ));\n+                        return Some(UnresolvedImportError {\n+                            span: directive.span,\n+                            label: Some(String::from(\"cannot glob-import a module into itself\")),\n+                            note: None,\n+                            suggestion: None,\n+                        });\n                     }\n                 }\n                 if !is_prelude &&\n@@ -1059,31 +1111,42 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                         _ => Some(&i.name),\n                     }\n                 });\n+\n                 let lev_suggestion =\n-                    match find_best_match_for_name(names, &ident.as_str(), None) {\n-                        Some(name) => format!(\". Did you mean to use `{}`?\", name),\n-                        None => String::new(),\n-                    };\n-                let msg = match module {\n+                    find_best_match_for_name(names, &ident.as_str(), None).map(|suggestion| {\n+                        (\n+                            ident.span,\n+                            String::from(\"a similar name exists in the module\"),\n+                            suggestion.to_string(),\n+                            Applicability::MaybeIncorrect,\n+                        )\n+                    });\n+\n+                let label = match module {\n                     ModuleOrUniformRoot::Module(module) => {\n                         let module_str = module_to_string(module);\n                         if let Some(module_str) = module_str {\n-                            format!(\"no `{}` in `{}`{}\", ident, module_str, lev_suggestion)\n+                            format!(\"no `{}` in `{}`\", ident, module_str)\n                         } else {\n-                            format!(\"no `{}` in the root{}\", ident, lev_suggestion)\n+                            format!(\"no `{}` in the root\", ident)\n                         }\n                     }\n                     _ => {\n                         if !ident.is_path_segment_keyword() {\n-                            format!(\"no `{}` external crate{}\", ident, lev_suggestion)\n+                            format!(\"no `{}` external crate\", ident)\n                         } else {\n                             // HACK(eddyb) this shows up for `self` & `super`, which\n                             // should work instead - for now keep the same error message.\n-                            format!(\"no `{}` in the root{}\", ident, lev_suggestion)\n+                            format!(\"no `{}` in the root\", ident)\n                         }\n                     }\n                 };\n-                Some((directive.span, msg, None))\n+                Some(UnresolvedImportError {\n+                    span: directive.span,\n+                    label: Some(label),\n+                    note: None,\n+                    suggestion: lev_suggestion,\n+                })\n             } else {\n                 // `resolve_ident_in_module` reported a privacy error.\n                 self.import_dummy_binding(directive);"}, {"sha": "603b29aa989fda920a636523a88428e466393a2b", "filename": "src/test/ui/extenv/issue-55897.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Ftest%2Fui%2Fextenv%2Fissue-55897.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Ftest%2Fui%2Fextenv%2Fissue-55897.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextenv%2Fissue-55897.stderr?ref=8ad727eab630512e845b31abc31ec57b2aa5de04", "patch": "@@ -8,7 +8,10 @@ error[E0432]: unresolved import `prelude`\n   --> $DIR/issue-55897.rs:1:5\n    |\n LL | use prelude::*; //~ ERROR unresolved import `prelude`\n-   |     ^^^^^^^ did you mean `std::prelude`?\n+   |     ^^^^^^^\n+   |     |\n+   |     unresolved import\n+   |     help: a similar path exists: `std::prelude`\n \n error: cannot determine resolution for the macro `env`\n   --> $DIR/issue-55897.rs:6:22"}, {"sha": "3170dd2fae10824b9e338fc985ca203cd093909f", "filename": "src/test/ui/import.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Ftest%2Fui%2Fimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Ftest%2Fui%2Fimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimport.rs?ref=8ad727eab630512e845b31abc31ec57b2aa5de04", "patch": "@@ -1,6 +1,8 @@\n use zed::bar;\n use zed::baz; //~ ERROR unresolved import `zed::baz` [E0432]\n-              //~^ no `baz` in `zed`. Did you mean to use `bar`?\n+              //~| no `baz` in `zed`\n+              //~| HELP a similar name exists in the module\n+              //~| SUGGESTION bar\n \n \n mod zed {"}, {"sha": "bfbb6560d49d9d2c6063fddfa386c8205c9c7327", "filename": "src/test/ui/import.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Ftest%2Fui%2Fimport.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Ftest%2Fui%2Fimport.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimport.stderr?ref=8ad727eab630512e845b31abc31ec57b2aa5de04", "patch": "@@ -2,16 +2,19 @@ error[E0432]: unresolved import `zed::baz`\n   --> $DIR/import.rs:2:5\n    |\n LL | use zed::baz; //~ ERROR unresolved import `zed::baz` [E0432]\n-   |     ^^^^^^^^ no `baz` in `zed`. Did you mean to use `bar`?\n+   |     ^^^^^---\n+   |     |    |\n+   |     |    help: a similar name exists in the module: `bar`\n+   |     no `baz` in `zed`\n \n error[E0432]: unresolved import `foo`\n-  --> $DIR/import.rs:8:9\n+  --> $DIR/import.rs:10:9\n    |\n LL |     use foo; //~ ERROR unresolved import `foo` [E0432]\n    |         ^^^ no `foo` in the root\n \n error[E0603]: unresolved item `foo` is private\n-  --> $DIR/import.rs:13:10\n+  --> $DIR/import.rs:15:10\n    |\n LL |     zed::foo(); //~ ERROR `foo` is private\n    |          ^^^"}, {"sha": "a3474b2f7dbf1abba58f09911de8633eec95bf50", "filename": "src/test/ui/imports/issue-55457.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Ftest%2Fui%2Fimports%2Fissue-55457.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Ftest%2Fui%2Fimports%2Fissue-55457.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-55457.stderr?ref=8ad727eab630512e845b31abc31ec57b2aa5de04", "patch": "@@ -2,7 +2,10 @@ error[E0432]: unresolved import `NonExistent`\n   --> $DIR/issue-55457.rs:1:5\n    |\n LL | use NonExistent; //~ ERROR unresolved import `NonExistent`\n-   |     ^^^^^^^^^^^ no `NonExistent` in the root. Did you mean to use `non_existent`?\n+   |     ^^^^^^^^^^^\n+   |     |\n+   |     no `NonExistent` in the root\n+   |     help: a similar name exists in the module: `non_existent`\n \n error[E0432]: unresolved import `non_existent`\n   --> $DIR/issue-55457.rs:2:5"}, {"sha": "40f2b7fd2eebd4f87213abc405cdd9ac9bddc31d", "filename": "src/test/ui/inaccessible-test-modules.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Ftest%2Fui%2Finaccessible-test-modules.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Ftest%2Fui%2Finaccessible-test-modules.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finaccessible-test-modules.stderr?ref=8ad727eab630512e845b31abc31ec57b2aa5de04", "patch": "@@ -2,13 +2,19 @@ error[E0432]: unresolved import `__test`\n   --> $DIR/inaccessible-test-modules.rs:5:5\n    |\n LL | use __test as x; //~ ERROR unresolved import `__test`\n-   |     ^^^^^^^^^^^ no `__test` in the root. Did you mean to use `test`?\n+   |     ------^^^^^\n+   |     |\n+   |     no `__test` in the root\n+   |     help: a similar name exists in the module: `test`\n \n error[E0432]: unresolved import `__test_reexports`\n   --> $DIR/inaccessible-test-modules.rs:6:5\n    |\n LL | use __test_reexports as y; //~ ERROR unresolved import `__test_reexports`\n-   |     ^^^^^^^^^^^^^^^^^^^^^ no `__test_reexports` in the root. Did you mean to use `__test_reexports`?\n+   |     ----------------^^^^^\n+   |     |\n+   |     no `__test_reexports` in the root\n+   |     help: a similar name exists in the module: `__test_reexports`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "09300ffc78793e508f018725b7c63aa75e4d4eaa", "filename": "src/test/ui/issues/issue-31212.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Ftest%2Fui%2Fissues%2Fissue-31212.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Ftest%2Fui%2Fissues%2Fissue-31212.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-31212.stderr?ref=8ad727eab630512e845b31abc31ec57b2aa5de04", "patch": "@@ -2,7 +2,7 @@ error[E0432]: unresolved import `self::*`\n   --> $DIR/issue-31212.rs:5:13\n    |\n LL |     pub use self::*; //~ ERROR unresolved\n-   |             ^^^^^^^ Cannot glob-import a module into itself.\n+   |             ^^^^^^^ cannot glob-import a module into itself\n \n error[E0425]: cannot find function `f` in module `foo`\n   --> $DIR/issue-31212.rs:9:10"}, {"sha": "1c566938f9d0e15425238a44689d037a7768469d", "filename": "src/test/ui/issues/issue-8208.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Ftest%2Fui%2Fissues%2Fissue-8208.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Ftest%2Fui%2Fissues%2Fissue-8208.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-8208.rs?ref=8ad727eab630512e845b31abc31ec57b2aa5de04", "patch": "@@ -1,14 +1,14 @@\n use self::*; //~ ERROR: unresolved import `self::*` [E0432]\n-             //~^ Cannot glob-import a module into itself.\n+             //~^ cannot glob-import a module into itself\n \n mod foo {\n     use foo::*; //~ ERROR: unresolved import `foo::*` [E0432]\n-                //~^ Cannot glob-import a module into itself.\n+                //~^ cannot glob-import a module into itself\n \n     mod bar {\n         use super::bar::*;\n         //~^ ERROR: unresolved import `super::bar::*` [E0432]\n-        //~| Cannot glob-import a module into itself.\n+        //~| cannot glob-import a module into itself\n     }\n \n }"}, {"sha": "a042dce1ac1d0352f1682a2d08fbb68511f0a6f7", "filename": "src/test/ui/issues/issue-8208.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Ftest%2Fui%2Fissues%2Fissue-8208.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Ftest%2Fui%2Fissues%2Fissue-8208.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-8208.stderr?ref=8ad727eab630512e845b31abc31ec57b2aa5de04", "patch": "@@ -2,19 +2,19 @@ error[E0432]: unresolved import `self::*`\n   --> $DIR/issue-8208.rs:1:5\n    |\n LL | use self::*; //~ ERROR: unresolved import `self::*` [E0432]\n-   |     ^^^^^^^ Cannot glob-import a module into itself.\n+   |     ^^^^^^^ cannot glob-import a module into itself\n \n error[E0432]: unresolved import `foo::*`\n   --> $DIR/issue-8208.rs:5:9\n    |\n LL |     use foo::*; //~ ERROR: unresolved import `foo::*` [E0432]\n-   |         ^^^^^^ Cannot glob-import a module into itself.\n+   |         ^^^^^^ cannot glob-import a module into itself\n \n error[E0432]: unresolved import `super::bar::*`\n   --> $DIR/issue-8208.rs:9:13\n    |\n LL |         use super::bar::*;\n-   |             ^^^^^^^^^^^^^ Cannot glob-import a module into itself.\n+   |             ^^^^^^^^^^^^^ cannot glob-import a module into itself\n \n error: aborting due to 3 previous errors\n "}, {"sha": "91a01cc0fa2310f9f318b07e2f421023f095ffc3", "filename": "src/test/ui/resolve_self_super_hint.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Ftest%2Fui%2Fresolve_self_super_hint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Ftest%2Fui%2Fresolve_self_super_hint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve_self_super_hint.rs?ref=8ad727eab630512e845b31abc31ec57b2aa5de04", "patch": "@@ -5,19 +5,23 @@ mod a {\n     extern crate alloc;\n     use alloc::HashMap;\n     //~^ ERROR unresolved import `alloc` [E0432]\n-    //~| did you mean `self::alloc`?\n+    //~| HELP a similar path exists\n+    //~| SUGGESTION self::alloc\n     mod b {\n         use alloc::HashMap;\n         //~^ ERROR unresolved import `alloc` [E0432]\n-        //~| did you mean `super::alloc`?\n+        //~| HELP a similar path exists\n+        //~| SUGGESTION super::alloc\n         mod c {\n             use alloc::HashMap;\n             //~^ ERROR unresolved import `alloc` [E0432]\n-            //~| did you mean `a::alloc`?\n+            //~| HELP a similar path exists\n+            //~| SUGGESTION a::alloc\n             mod d {\n                 use alloc::HashMap;\n                 //~^ ERROR unresolved import `alloc` [E0432]\n-                //~| did you mean `a::alloc`?\n+                //~| HELP a similar path exists\n+                //~| SUGGESTION a::alloc\n             }\n         }\n     }"}, {"sha": "03214cad8e41a6e151299d1b850a21cdd47b571b", "filename": "src/test/ui/resolve_self_super_hint.stderr", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Ftest%2Fui%2Fresolve_self_super_hint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Ftest%2Fui%2Fresolve_self_super_hint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve_self_super_hint.stderr?ref=8ad727eab630512e845b31abc31ec57b2aa5de04", "patch": "@@ -2,25 +2,31 @@ error[E0432]: unresolved import `alloc`\n   --> $DIR/resolve_self_super_hint.rs:6:9\n    |\n LL |     use alloc::HashMap;\n-   |         ^^^^^ did you mean `self::alloc`?\n+   |         ^^^^^ help: a similar path exists: `self::alloc`\n \n error[E0432]: unresolved import `alloc`\n-  --> $DIR/resolve_self_super_hint.rs:10:13\n+  --> $DIR/resolve_self_super_hint.rs:11:13\n    |\n LL |         use alloc::HashMap;\n-   |             ^^^^^ did you mean `super::alloc`?\n+   |             ^^^^^ help: a similar path exists: `super::alloc`\n \n error[E0432]: unresolved import `alloc`\n-  --> $DIR/resolve_self_super_hint.rs:14:17\n+  --> $DIR/resolve_self_super_hint.rs:16:17\n    |\n LL |             use alloc::HashMap;\n-   |                 ^^^^^ did you mean `a::alloc`?\n+   |                 ^^^^^\n+   |                 |\n+   |                 unresolved import\n+   |                 help: a similar path exists: `a::alloc`\n \n error[E0432]: unresolved import `alloc`\n-  --> $DIR/resolve_self_super_hint.rs:18:21\n+  --> $DIR/resolve_self_super_hint.rs:21:21\n    |\n LL |                 use alloc::HashMap;\n-   |                     ^^^^^ did you mean `a::alloc`?\n+   |                     ^^^^^\n+   |                     |\n+   |                     unresolved import\n+   |                     help: a similar path exists: `a::alloc`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "1978138a688780bd63e76c6c959ec9e3ced05d19", "filename": "src/test/ui/rust-2018/issue-54006.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Ftest%2Fui%2Frust-2018%2Fissue-54006.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Ftest%2Fui%2Frust-2018%2Fissue-54006.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fissue-54006.stderr?ref=8ad727eab630512e845b31abc31ec57b2aa5de04", "patch": "@@ -2,7 +2,7 @@ error[E0432]: unresolved import `alloc`\n   --> $DIR/issue-54006.rs:6:5\n    |\n LL | use alloc::vec;\n-   |     ^^^^^ did you mean `core::alloc`?\n+   |     ^^^^^ help: a similar path exists: `core::alloc`\n \n error: cannot determine resolution for the macro `vec`\n   --> $DIR/issue-54006.rs:10:18"}, {"sha": "fafb35ec50d6dcfe23edb37f209f92f2aa4a29a8", "filename": "src/test/ui/rust-2018/local-path-suggestions-2015.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2015.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2015.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2015.stderr?ref=8ad727eab630512e845b31abc31ec57b2aa5de04", "patch": "@@ -2,7 +2,10 @@ error[E0432]: unresolved import `foobar`\n   --> $DIR/local-path-suggestions-2015.rs:24:5\n    |\n LL | use foobar::Baz; //~ ERROR unresolved import `foobar`\n-   |     ^^^^^^ did you mean `aux_baz::foobar`?\n+   |     ^^^^^^\n+   |     |\n+   |     unresolved import\n+   |     help: a similar path exists: `aux_baz::foobar`\n \n error: aborting due to previous error\n "}, {"sha": "759977b3f0629bc9c18a717729c90e11f55b0326", "filename": "src/test/ui/rust-2018/local-path-suggestions-2018.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2018.stderr?ref=8ad727eab630512e845b31abc31ec57b2aa5de04", "patch": "@@ -2,15 +2,15 @@ error[E0432]: unresolved import `foo`\n   --> $DIR/local-path-suggestions-2018.rs:10:9\n    |\n LL |     use foo::Bar; //~ ERROR unresolved import `foo`\n-   |         ^^^ did you mean `crate::foo`?\n+   |         ^^^ help: a similar path exists: `crate::foo`\n    |\n    = note: `use` statements changed in Rust 2018; read more at <https://doc.rust-lang.org/edition-guide/rust-2018/module-system/path-clarity.html>\n \n error[E0432]: unresolved import `foobar`\n   --> $DIR/local-path-suggestions-2018.rs:19:5\n    |\n LL | use foobar::Baz; //~ ERROR unresolved import `foobar`\n-   |     ^^^^^^ did you mean `baz::foobar`?\n+   |     ^^^^^^ help: a similar path exists: `baz::foobar`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "4c7d4bb935331c3d6f20f3b3200c71c15a088b12", "filename": "src/test/ui/unresolved/unresolved-import.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Ftest%2Fui%2Funresolved%2Funresolved-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Ftest%2Fui%2Funresolved%2Funresolved-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funresolved%2Funresolved-import.rs?ref=8ad727eab630512e845b31abc31ec57b2aa5de04", "patch": "@@ -1,16 +1,20 @@\n-// ignore-tidy-linelength\n-\n use foo::bar; //~ ERROR unresolved import `foo` [E0432]\n               //~^ maybe a missing `extern crate foo;`?\n \n use bar::Baz as x; //~ ERROR unresolved import `bar::Baz` [E0432]\n-                   //~^ no `Baz` in `bar`. Did you mean to use `Bar`?\n+                   //~| no `Baz` in `bar`\n+                   //~| HELP a similar name exists in the module\n+                   //~| SUGGESTION Bar\n \n use food::baz; //~ ERROR unresolved import `food::baz`\n-               //~^ no `baz` in `food`. Did you mean to use `bag`?\n+               //~| no `baz` in `food`\n+               //~| HELP a similar name exists in the module\n+               //~| SUGGESTION bag\n \n use food::{beens as Foo}; //~ ERROR unresolved import `food::beens` [E0432]\n-                          //~^ no `beens` in `food`. Did you mean to use `beans`?\n+                          //~| no `beens` in `food`\n+                          //~| HELP a similar name exists in the module\n+                          //~| SUGGESTION beans\n \n mod bar {\n     pub struct Bar;\n@@ -32,7 +36,8 @@ mod m {\n     }\n \n     use MyEnum::*; //~ ERROR unresolved import `MyEnum` [E0432]\n-                   //~^ did you mean `self::MyEnum`?\n+                   //~| HELP a similar path exists\n+                   //~| SUGGESTION self::MyEnum\n }\n \n mod items {\n@@ -41,7 +46,8 @@ mod items {\n     }\n \n     use Enum::*; //~ ERROR unresolved import `Enum` [E0432]\n-                 //~^ did you mean `self::Enum`?\n+                 //~| HELP a similar path exists\n+                 //~| SUGGESTION self::Enum\n \n     fn item() {}\n }"}, {"sha": "4f2fef938c975a4547ec16b68e26bc7a839a77f6", "filename": "src/test/ui/unresolved/unresolved-import.stderr", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Ftest%2Fui%2Funresolved%2Funresolved-import.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Ftest%2Fui%2Funresolved%2Funresolved-import.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funresolved%2Funresolved-import.stderr?ref=8ad727eab630512e845b31abc31ec57b2aa5de04", "patch": "@@ -1,38 +1,47 @@\n error[E0432]: unresolved import `foo`\n-  --> $DIR/unresolved-import.rs:3:5\n+  --> $DIR/unresolved-import.rs:1:5\n    |\n LL | use foo::bar; //~ ERROR unresolved import `foo` [E0432]\n    |     ^^^ maybe a missing `extern crate foo;`?\n \n error[E0432]: unresolved import `bar::Baz`\n-  --> $DIR/unresolved-import.rs:6:5\n+  --> $DIR/unresolved-import.rs:4:5\n    |\n LL | use bar::Baz as x; //~ ERROR unresolved import `bar::Baz` [E0432]\n-   |     ^^^^^^^^^^^^^ no `Baz` in `bar`. Did you mean to use `Bar`?\n+   |     ^^^^^---^^^^^\n+   |     |    |\n+   |     |    help: a similar name exists in the module: `Bar`\n+   |     no `Baz` in `bar`\n \n error[E0432]: unresolved import `food::baz`\n   --> $DIR/unresolved-import.rs:9:5\n    |\n LL | use food::baz; //~ ERROR unresolved import `food::baz`\n-   |     ^^^^^^^^^ no `baz` in `food`. Did you mean to use `bag`?\n+   |     ^^^^^^---\n+   |     |     |\n+   |     |     help: a similar name exists in the module: `bag`\n+   |     no `baz` in `food`\n \n error[E0432]: unresolved import `food::beens`\n-  --> $DIR/unresolved-import.rs:12:12\n+  --> $DIR/unresolved-import.rs:14:12\n    |\n LL | use food::{beens as Foo}; //~ ERROR unresolved import `food::beens` [E0432]\n-   |            ^^^^^^^^^^^^ no `beens` in `food`. Did you mean to use `beans`?\n+   |            -----^^^^^^^\n+   |            |\n+   |            no `beens` in `food`\n+   |            help: a similar name exists in the module: `beans`\n \n error[E0432]: unresolved import `MyEnum`\n-  --> $DIR/unresolved-import.rs:34:9\n+  --> $DIR/unresolved-import.rs:38:9\n    |\n LL |     use MyEnum::*; //~ ERROR unresolved import `MyEnum` [E0432]\n-   |         ^^^^^^ did you mean `self::MyEnum`?\n+   |         ^^^^^^ help: a similar path exists: `self::MyEnum`\n \n error[E0432]: unresolved import `Enum`\n-  --> $DIR/unresolved-import.rs:43:9\n+  --> $DIR/unresolved-import.rs:48:9\n    |\n LL |     use Enum::*; //~ ERROR unresolved import `Enum` [E0432]\n-   |         ^^^^ did you mean `self::Enum`?\n+   |         ^^^^ help: a similar path exists: `self::Enum`\n \n error: aborting due to 6 previous errors\n "}, {"sha": "7234c8ec621cd9de1da9b8479e75abb524ad3b32", "filename": "src/test/ui/use/use-nested-groups-error.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Ftest%2Fui%2Fuse%2Fuse-nested-groups-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ad727eab630512e845b31abc31ec57b2aa5de04/src%2Ftest%2Fui%2Fuse%2Fuse-nested-groups-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-nested-groups-error.stderr?ref=8ad727eab630512e845b31abc31ec57b2aa5de04", "patch": "@@ -2,7 +2,10 @@ error[E0432]: unresolved import `a::b1::C1`\n   --> $DIR/use-nested-groups-error.rs:9:14\n    |\n LL | use a::{b1::{C1, C2}, B2};\n-   |              ^^ no `C1` in `a::b1`. Did you mean to use `C2`?\n+   |              ^^\n+   |              |\n+   |              no `C1` in `a::b1`\n+   |              help: a similar name exists in the module: `C2`\n \n error: aborting due to previous error\n "}]}