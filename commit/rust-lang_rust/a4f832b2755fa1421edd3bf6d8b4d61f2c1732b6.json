{"sha": "a4f832b2755fa1421edd3bf6d8b4d61f2c1732b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0ZjgzMmIyNzU1ZmExNDIxZWRkM2JmNmQ4YjRkNjFmMmMxNzMyYjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-27T18:10:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-27T18:10:35Z"}, "message": "Auto merge of #86445 - sexxi-goose:box_fix, r=nikomatsakis\n\n2229: Capture box completely in move closures\n\nEven if the content from box is used in a sharef-ref context,\nwe capture the box entirerly.\n\nThis is motivated by:\n1) We only capture data that is on the stack.\n2) Capturing data from within the box might end up moving more data than\nthe user anticipated.\n\nCloses https://github.com/rust-lang/project-rfc-2229/issues/50\n\nr? `@nikomatsakis`", "tree": {"sha": "3a57797f7696d89939a42085cc2836aa3ba6447f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a57797f7696d89939a42085cc2836aa3ba6447f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4f832b2755fa1421edd3bf6d8b4d61f2c1732b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4f832b2755fa1421edd3bf6d8b4d61f2c1732b6", "html_url": "https://github.com/rust-lang/rust/commit/a4f832b2755fa1421edd3bf6d8b4d61f2c1732b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4f832b2755fa1421edd3bf6d8b4d61f2c1732b6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9cdb2d3d59bad2843330535a41d0ebbb831fe57e", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cdb2d3d59bad2843330535a41d0ebbb831fe57e", "html_url": "https://github.com/rust-lang/rust/commit/9cdb2d3d59bad2843330535a41d0ebbb831fe57e"}, {"sha": "d37a07ffbefd6772a68c25f18d35a7fe5b82942e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d37a07ffbefd6772a68c25f18d35a7fe5b82942e", "html_url": "https://github.com/rust-lang/rust/commit/d37a07ffbefd6772a68c25f18d35a7fe5b82942e"}], "stats": {"total": 193, "additions": 178, "deletions": 15}, "files": [{"sha": "581aa087be9e769f90e497330ef4c54d9d9ab8a9", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 48, "deletions": 7, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a4f832b2755fa1421edd3bf6d8b4d61f2c1732b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4f832b2755fa1421edd3bf6d8b4d61f2c1732b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=a4f832b2755fa1421edd3bf6d8b4d61f2c1732b6", "patch": "@@ -167,7 +167,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n         self.log_capture_analysis_first_pass(closure_def_id, &delegate.capture_information, span);\n \n-        self.compute_min_captures(closure_def_id, delegate.capture_information);\n+        self.compute_min_captures(closure_def_id, capture_clause, delegate.capture_information);\n \n         let closure_hir_id = self.tcx.hir().local_def_id_to_hir_id(local_def_id);\n \n@@ -200,7 +200,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n \n             // This will update the min captures based on this new fake information.\n-            self.compute_min_captures(closure_def_id, capture_information);\n+            self.compute_min_captures(closure_def_id, capture_clause, capture_information);\n         }\n \n         if let Some(closure_substs) = infer_kind {\n@@ -213,7 +213,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // If we have an origin, store it.\n             if let Some(origin) = delegate.current_origin.clone() {\n                 let origin = if enable_precise_capture(self.tcx, span) {\n-                    (origin.0, restrict_capture_precision(origin.1))\n+                    (origin.0, restrict_capture_precision(capture_clause, origin.1))\n                 } else {\n                     (origin.0, Place { projections: vec![], ..origin.1 })\n                 };\n@@ -368,6 +368,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn compute_min_captures(\n         &self,\n         closure_def_id: DefId,\n+        capture_clause: hir::CaptureBy,\n         capture_information: InferredCaptureInformation<'tcx>,\n     ) {\n         if capture_information.is_empty() {\n@@ -385,7 +386,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 base => bug!(\"Expected upvar, found={:?}\", base),\n             };\n \n-            let place = restrict_capture_precision(place);\n+            let place = restrict_capture_precision(capture_clause, place);\n \n             let min_cap_list = match root_var_min_capture_list.get_mut(&var_hir_id) {\n                 None => {\n@@ -1590,7 +1591,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n         if let PlaceBase::Upvar(_) = place.base {\n             // We need to restrict Fake Read precision to avoid fake reading unsafe code,\n             // such as deref of a raw pointer.\n-            let place = restrict_capture_precision(place);\n+            let place = restrict_capture_precision(self.capture_clause, place);\n             let place =\n                 restrict_repr_packed_field_ref_capture(self.fcx.tcx, self.fcx.param_env, &place);\n             self.fake_reads.push((place, cause, diag_expr_id));\n@@ -1625,11 +1626,15 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n             place_with_id, diag_expr_id, bk\n         );\n \n+        // We only want repr packed restriction to be applied to reading references into a packed\n+        // struct, and not when the data is being moved. There for we call this method here instead\n+        // of in `restrict_capture_precision`.\n         let place = restrict_repr_packed_field_ref_capture(\n             self.fcx.tcx,\n             self.fcx.param_env,\n             &place_with_id.place,\n         );\n+\n         let place_with_id = PlaceWithHirId { place, ..*place_with_id };\n \n         if !self.capture_information.contains_key(&place_with_id.place) {\n@@ -1654,11 +1659,46 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n     }\n }\n \n+/// Deref of a box isn't captured in move clousres. This is motivated by:\n+///   1. We only want to capture data that is on the stack\n+///   2. One motivation for the user to use a box might be to reduce the amount of data that gets\n+///      moved (if size of pointer < size of data). We want to make sure that this optimization that\n+///      the user made is respected.\n+fn restrict_precision_for_box<'tcx>(\n+    capture_clause: hir::CaptureBy,\n+    mut place: Place<'tcx>,\n+) -> Place<'tcx> {\n+    match capture_clause {\n+        hir::CaptureBy::Ref => {}\n+        hir::CaptureBy::Value => {\n+            if ty::TyS::is_box(place.base_ty) {\n+                place.projections.truncate(0);\n+            } else {\n+                // Either the box is the last access or there is a deref applied on the box\n+                // In either case we want to stop at the box.\n+                let pos = place.projections.iter().position(|proj| ty::TyS::is_box(proj.ty));\n+                match pos {\n+                    None => {}\n+                    Some(idx) => {\n+                        place.projections.truncate(idx + 1);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    place\n+}\n+\n /// Truncate projections so that following rules are obeyed by the captured `place`:\n /// - No projections are applied to raw pointers, since these require unsafe blocks. We capture\n ///   them completely.\n /// - No Index projections are captured, since arrays are captured completely.\n-fn restrict_capture_precision<'tcx>(mut place: Place<'tcx>) -> Place<'tcx> {\n+/// - Deref of a box isn't captured in move clousres.\n+fn restrict_capture_precision<'tcx>(\n+    capture_clause: hir::CaptureBy,\n+    mut place: Place<'tcx>,\n+) -> Place<'tcx> {\n     if place.projections.is_empty() {\n         // Nothing to do here\n         return place;\n@@ -1693,7 +1733,8 @@ fn restrict_capture_precision<'tcx>(mut place: Place<'tcx>) -> Place<'tcx> {\n \n     place.projections.truncate(length);\n \n-    place\n+    // Dont't capture projections on top of a box in move closures.\n+    restrict_precision_for_box(capture_clause, place)\n }\n \n /// Truncates a place so that the resultant capture doesn't move data out of a reference"}, {"sha": "f96370eb2031548cb29a3e2d9a129142f02bca80", "filename": "src/test/ui/closures/2229_closure_analysis/move_closure.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a4f832b2755fa1421edd3bf6d8b4d61f2c1732b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4f832b2755fa1421edd3bf6d8b4d61f2c1732b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.rs?ref=a4f832b2755fa1421edd3bf6d8b4d61f2c1732b6", "patch": "@@ -114,8 +114,9 @@ fn struct_contains_ref_to_another_struct_3() {\n fn truncate_box_derefs() {\n     struct S(i32);\n \n-    let b = Box::new(S(10));\n \n+    // Content within the box is moved within the closure\n+    let b = Box::new(S(10));\n     let c = #[rustc_capture_analysis]\n     //~^ ERROR: attributes on expressions are experimental\n     //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n@@ -129,6 +130,37 @@ fn truncate_box_derefs() {\n     };\n \n     c();\n+\n+    // Content within the box is used by a shared ref and the box is the root variable\n+    let b = Box::new(S(10));\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    move || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        println!(\"{}\", b.0);\n+        //~^ NOTE: Capturing b[Deref,(0, 0)] -> ByValue\n+        //~| NOTE: Min Capture b[] -> ByValue\n+    };\n+\n+    c();\n+\n+    // Content within the box is used by a shared ref and the box is not the root variable\n+    let b = Box::new(S(10));\n+    let t = (0, b);\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    move || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        println!(\"{}\", t.1.0);\n+        //~^ NOTE: Capturing t[(1, 0),Deref,(0, 0)] -> ByValue\n+        //~| NOTE: Min Capture t[(1, 0)] -> ByValue\n+    };\n }\n \n fn main() {"}, {"sha": "82aa7ab891260d0d9b2739a71c9ef1235d5b418e", "filename": "src/test/ui/closures/2229_closure_analysis/move_closure.stderr", "status": "modified", "additions": 97, "deletions": 7, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/a4f832b2755fa1421edd3bf6d8b4d61f2c1732b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4f832b2755fa1421edd3bf6d8b4d61f2c1732b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.stderr?ref=a4f832b2755fa1421edd3bf6d8b4d61f2c1732b6", "patch": "@@ -44,7 +44,25 @@ LL |     let mut c = #[rustc_capture_analysis]\n    = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n \n error[E0658]: attributes on expressions are experimental\n-  --> $DIR/move_closure.rs:119:13\n+  --> $DIR/move_closure.rs:120:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/move_closure.rs:137:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/move_closure.rs:154:13\n    |\n LL |     let c = #[rustc_capture_analysis]\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -247,7 +265,7 @@ LL |         let _t = t.0.0;\n    |                  ^^^^^\n \n error: First Pass analysis includes:\n-  --> $DIR/move_closure.rs:122:5\n+  --> $DIR/move_closure.rs:123:5\n    |\n LL | /     move || {\n LL | |\n@@ -259,18 +277,18 @@ LL | |     };\n    | |_____^\n    |\n note: Capturing b[Deref,(0, 0)] -> ByValue\n-  --> $DIR/move_closure.rs:125:18\n+  --> $DIR/move_closure.rs:126:18\n    |\n LL |         let _t = b.0;\n    |                  ^^^\n note: Capturing b[] -> ByValue\n-  --> $DIR/move_closure.rs:125:18\n+  --> $DIR/move_closure.rs:126:18\n    |\n LL |         let _t = b.0;\n    |                  ^^^\n \n error: Min Capture analysis includes:\n-  --> $DIR/move_closure.rs:122:5\n+  --> $DIR/move_closure.rs:123:5\n    |\n LL | /     move || {\n LL | |\n@@ -282,11 +300,83 @@ LL | |     };\n    | |_____^\n    |\n note: Min Capture b[] -> ByValue\n-  --> $DIR/move_closure.rs:125:18\n+  --> $DIR/move_closure.rs:126:18\n    |\n LL |         let _t = b.0;\n    |                  ^^^\n \n-error: aborting due to 18 previous errors; 1 warning emitted\n+error: First Pass analysis includes:\n+  --> $DIR/move_closure.rs:140:5\n+   |\n+LL | /     move || {\n+LL | |\n+LL | |\n+LL | |         println!(\"{}\", b.0);\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing b[Deref,(0, 0)] -> ByValue\n+  --> $DIR/move_closure.rs:143:24\n+   |\n+LL |         println!(\"{}\", b.0);\n+   |                        ^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/move_closure.rs:140:5\n+   |\n+LL | /     move || {\n+LL | |\n+LL | |\n+LL | |         println!(\"{}\", b.0);\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture b[] -> ByValue\n+  --> $DIR/move_closure.rs:143:24\n+   |\n+LL |         println!(\"{}\", b.0);\n+   |                        ^^^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/move_closure.rs:157:5\n+   |\n+LL | /     move || {\n+LL | |\n+LL | |\n+LL | |         println!(\"{}\", t.1.0);\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing t[(1, 0),Deref,(0, 0)] -> ByValue\n+  --> $DIR/move_closure.rs:160:24\n+   |\n+LL |         println!(\"{}\", t.1.0);\n+   |                        ^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/move_closure.rs:157:5\n+   |\n+LL | /     move || {\n+LL | |\n+LL | |\n+LL | |         println!(\"{}\", t.1.0);\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture t[(1, 0)] -> ByValue\n+  --> $DIR/move_closure.rs:160:24\n+   |\n+LL |         println!(\"{}\", t.1.0);\n+   |                        ^^^^^\n+\n+error: aborting due to 24 previous errors; 1 warning emitted\n \n For more information about this error, try `rustc --explain E0658`."}]}