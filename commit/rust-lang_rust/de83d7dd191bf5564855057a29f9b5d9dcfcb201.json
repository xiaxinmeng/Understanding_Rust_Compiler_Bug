{"sha": "de83d7dd191bf5564855057a29f9b5d9dcfcb201", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlODNkN2RkMTkxYmY1NTY0ODU1MDU3YTI5ZjliNWQ5ZGNmY2IyMDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-06T20:12:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-06T20:12:13Z"}, "message": "auto merge of #19431 : erickt/rust/buf-writer-error, r=alexcrichton\n\nPreviously, `BufWriter::write` would just return an `std::io::OtherIoError` if someone attempted to write past the end of the wrapped buffer. This pull request changes the error to support partial writes and return a `std::io::ShortWrite`, or an `io::io::EndOfFile` if it's been fully exhausted.\r\n\r\n I've also optimized away a bounds check inside `BufWriter::write`, which should help shave off some nanoseconds in an inner loops.", "tree": {"sha": "b90665fb9f4eeadbe858564f89b9b8c454a9bacf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b90665fb9f4eeadbe858564f89b9b8c454a9bacf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de83d7dd191bf5564855057a29f9b5d9dcfcb201", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de83d7dd191bf5564855057a29f9b5d9dcfcb201", "html_url": "https://github.com/rust-lang/rust/commit/de83d7dd191bf5564855057a29f9b5d9dcfcb201", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de83d7dd191bf5564855057a29f9b5d9dcfcb201/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "358db12a89d6edf4a61cb3c8d170449faea925cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/358db12a89d6edf4a61cb3c8d170449faea925cc", "html_url": "https://github.com/rust-lang/rust/commit/358db12a89d6edf4a61cb3c8d170449faea925cc"}, {"sha": "72bc461ce3f34fca3aac87c83c0a7c606e9aecee", "url": "https://api.github.com/repos/rust-lang/rust/commits/72bc461ce3f34fca3aac87c83c0a7c606e9aecee", "html_url": "https://github.com/rust-lang/rust/commit/72bc461ce3f34fca3aac87c83c0a7c606e9aecee"}], "stats": {"total": 44, "additions": 27, "deletions": 17}, "files": [{"sha": "c5cd95f8501fa6ea043451c58bfdfa1ca13f25c1", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/de83d7dd191bf5564855057a29f9b5d9dcfcb201/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de83d7dd191bf5564855057a29f9b5d9dcfcb201/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=de83d7dd191bf5564855057a29f9b5d9dcfcb201", "patch": "@@ -278,20 +278,29 @@ impl<'a> BufWriter<'a> {\n \n impl<'a> Writer for BufWriter<'a> {\n     #[inline]\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        // return an error if the entire write does not fit in the buffer\n-        let cap = if self.pos >= self.buf.len() { 0 } else { self.buf.len() - self.pos };\n-        if buf.len() > cap {\n-            return Err(IoError {\n-                kind: io::OtherIoError,\n-                desc: \"Trying to write past end of buffer\",\n-                detail: None\n-            })\n+    fn write(&mut self, src: &[u8]) -> IoResult<()> {\n+        let dst = self.buf[mut self.pos..];\n+        let dst_len = dst.len();\n+\n+        if dst_len == 0 {\n+            return Err(io::standard_error(io::EndOfFile));\n         }\n \n-        slice::bytes::copy_memory(self.buf[mut self.pos..], buf);\n-        self.pos += buf.len();\n-        Ok(())\n+        let src_len = src.len();\n+\n+        if dst_len >= src_len {\n+            slice::bytes::copy_memory(dst, src);\n+\n+            self.pos += src_len;\n+\n+            Ok(())\n+        } else {\n+            slice::bytes::copy_memory(dst, src[..dst_len]);\n+\n+            self.pos += dst_len;\n+\n+            Err(io::standard_error(io::ShortWrite(dst_len)))\n+        }\n     }\n }\n \n@@ -302,7 +311,7 @@ impl<'a> Seek for BufWriter<'a> {\n     #[inline]\n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n         let new = try!(combine(style, self.pos, self.buf.len(), pos));\n-        self.pos = new as uint;\n+        self.pos = min(new as uint, self.buf.len());\n         Ok(())\n     }\n }\n@@ -419,7 +428,7 @@ mod test {\n \n     #[test]\n     fn test_buf_writer() {\n-        let mut buf = [0 as u8, ..8];\n+        let mut buf = [0 as u8, ..9];\n         {\n             let mut writer = BufWriter::new(&mut buf);\n             assert_eq!(writer.tell(), Ok(0));\n@@ -431,9 +440,10 @@ mod test {\n             writer.write(&[]).unwrap();\n             assert_eq!(writer.tell(), Ok(8));\n \n-            assert!(writer.write(&[1]).is_err());\n+            assert_eq!(writer.write(&[8, 9]).unwrap_err().kind, io::ShortWrite(1));\n+            assert_eq!(writer.write(&[10]).unwrap_err().kind, io::EndOfFile);\n         }\n-        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n+        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n         assert_eq!(buf.as_slice(), b);\n     }\n \n@@ -474,7 +484,7 @@ mod test {\n \n         match writer.write(&[0, 0]) {\n             Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, io::OtherIoError),\n+            Err(e) => assert_eq!(e.kind, io::ShortWrite(1)),\n         }\n     }\n "}]}