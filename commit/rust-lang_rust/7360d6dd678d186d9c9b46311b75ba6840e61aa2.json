{"sha": "7360d6dd678d186d9c9b46311b75ba6840e61aa2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczNjBkNmRkNjc4ZDE4NmQ5YzliNDYzMTFiNzViYTY4NDBlNjFhYTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-15T12:32:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-15T12:32:13Z"}, "message": "Auto merge of #49833 - oli-obk:incremental_miri_regression, r=michaelwoerister\n\nDon't recurse into allocations, use a global table instead\n\nr? @michaelwoerister\n\nfixes #49663", "tree": {"sha": "d928bac5c64bb741baa1e88553a94e1335984efb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d928bac5c64bb741baa1e88553a94e1335984efb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7360d6dd678d186d9c9b46311b75ba6840e61aa2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7360d6dd678d186d9c9b46311b75ba6840e61aa2", "html_url": "https://github.com/rust-lang/rust/commit/7360d6dd678d186d9c9b46311b75ba6840e61aa2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7360d6dd678d186d9c9b46311b75ba6840e61aa2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "602b3957f152a486e57f7fbaa15265d8a81017bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/602b3957f152a486e57f7fbaa15265d8a81017bc", "html_url": "https://github.com/rust-lang/rust/commit/602b3957f152a486e57f7fbaa15265d8a81017bc"}, {"sha": "7f7d4c376af12f66e09a41d10612dbd0010a6abe", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f7d4c376af12f66e09a41d10612dbd0010a6abe", "html_url": "https://github.com/rust-lang/rust/commit/7f7d4c376af12f66e09a41d10612dbd0010a6abe"}], "stats": {"total": 578, "additions": 271, "deletions": 307}, "files": [{"sha": "99ac5869b2969fbf0675edc7efc997cf0e21e04e", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7360d6dd678d186d9c9b46311b75ba6840e61aa2/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7360d6dd678d186d9c9b46311b75ba6840e61aa2/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=7360d6dd678d186d9c9b46311b75ba6840e61aa2", "patch": "@@ -398,12 +398,12 @@ impl_stable_hash_for!(struct mir::interpret::MemoryPointer {\n \n enum AllocDiscriminant {\n     Alloc,\n-    ExternStatic,\n+    Static,\n     Function,\n }\n impl_stable_hash_for!(enum self::AllocDiscriminant {\n     Alloc,\n-    ExternStatic,\n+    Static,\n     Function\n });\n \n@@ -414,24 +414,25 @@ impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n         hasher: &mut StableHasher<W>,\n     ) {\n         ty::tls::with_opt(|tcx| {\n+            trace!(\"hashing {:?}\", *self);\n             let tcx = tcx.expect(\"can't hash AllocIds during hir lowering\");\n-            if let Some(alloc) = tcx.interpret_interner.get_alloc(*self) {\n+            if let Some(def_id) = tcx.interpret_interner.get_static(*self) {\n+                AllocDiscriminant::Static.hash_stable(hcx, hasher);\n+                trace!(\"hashing {:?} as static {:?}\", *self, def_id);\n+                def_id.hash_stable(hcx, hasher);\n+            } else if let Some(alloc) = tcx.interpret_interner.get_alloc(*self) {\n                 AllocDiscriminant::Alloc.hash_stable(hcx, hasher);\n                 if hcx.alloc_id_recursion_tracker.insert(*self) {\n-                    tcx\n-                        .interpret_interner\n-                        .get_corresponding_static_def_id(*self)\n-                        .hash_stable(hcx, hasher);\n+                    trace!(\"hashing {:?} as alloc {:#?}\", *self, alloc);\n                     alloc.hash_stable(hcx, hasher);\n                     assert!(hcx.alloc_id_recursion_tracker.remove(self));\n+                } else {\n+                    trace!(\"skipping hashing of {:?} due to recursion\", *self);\n                 }\n             } else if let Some(inst) = tcx.interpret_interner.get_fn(*self) {\n+                trace!(\"hashing {:?} as fn {:#?}\", *self, inst);\n                 AllocDiscriminant::Function.hash_stable(hcx, hasher);\n                 inst.hash_stable(hcx, hasher);\n-            } else if let Some(def_id) = tcx.interpret_interner\n-                                            .get_corresponding_static_def_id(*self) {\n-                AllocDiscriminant::ExternStatic.hash_stable(hcx, hasher);\n-                def_id.hash_stable(hcx, hasher);\n             } else {\n                 bug!(\"no allocation for {}\", self);\n             }"}, {"sha": "c9eed0e4a288580a0452c5ca4b647ff9229e07a4", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 23, "deletions": 40, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/7360d6dd678d186d9c9b46311b75ba6840e61aa2/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7360d6dd678d186d9c9b46311b75ba6840e61aa2/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=7360d6dd678d186d9c9b46311b75ba6840e61aa2", "patch": "@@ -154,10 +154,12 @@ pub struct AllocId(pub u64);\n impl ::rustc_serialize::UseSpecializedEncodable for AllocId {}\n impl ::rustc_serialize::UseSpecializedDecodable for AllocId {}\n \n-pub const ALLOC_DISCRIMINANT: usize = 0;\n-pub const FN_DISCRIMINANT: usize = 1;\n-pub const EXTERN_STATIC_DISCRIMINANT: usize = 2;\n-pub const SHORTHAND_START: usize = 3;\n+#[derive(RustcDecodable, RustcEncodable)]\n+enum AllocKind {\n+    Alloc,\n+    Fn,\n+    Static,\n+}\n \n pub fn specialized_encode_alloc_id<\n     'a, 'tcx,\n@@ -166,26 +168,18 @@ pub fn specialized_encode_alloc_id<\n     encoder: &mut E,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     alloc_id: AllocId,\n-    shorthand: Option<usize>,\n ) -> Result<(), E::Error> {\n-    if let Some(shorthand) = shorthand {\n-        return shorthand.encode(encoder);\n-    }\n     if let Some(alloc) = tcx.interpret_interner.get_alloc(alloc_id) {\n         trace!(\"encoding {:?} with {:#?}\", alloc_id, alloc);\n-        ALLOC_DISCRIMINANT.encode(encoder)?;\n+        AllocKind::Alloc.encode(encoder)?;\n         alloc.encode(encoder)?;\n-        // encode whether this allocation is the root allocation of a static\n-        tcx.interpret_interner\n-            .get_corresponding_static_def_id(alloc_id)\n-            .encode(encoder)?;\n     } else if let Some(fn_instance) = tcx.interpret_interner.get_fn(alloc_id) {\n         trace!(\"encoding {:?} with {:#?}\", alloc_id, fn_instance);\n-        FN_DISCRIMINANT.encode(encoder)?;\n+        AllocKind::Fn.encode(encoder)?;\n         fn_instance.encode(encoder)?;\n-    } else if let Some(did) = tcx.interpret_interner.get_corresponding_static_def_id(alloc_id) {\n-        // extern \"C\" statics don't have allocations, just encode its def_id\n-        EXTERN_STATIC_DISCRIMINANT.encode(encoder)?;\n+    } else if let Some(did) = tcx.interpret_interner.get_static(alloc_id) {\n+        // referring to statics doesn't need to know about their allocations, just about its DefId\n+        AllocKind::Static.encode(encoder)?;\n         did.encode(encoder)?;\n     } else {\n         bug!(\"alloc id without corresponding allocation: {}\", alloc_id);\n@@ -196,53 +190,42 @@ pub fn specialized_encode_alloc_id<\n pub fn specialized_decode_alloc_id<\n     'a, 'tcx,\n     D: Decoder,\n-    CACHE: FnOnce(&mut D, usize, AllocId),\n-    SHORT: FnOnce(&mut D, usize) -> Result<AllocId, D::Error>\n+    CACHE: FnOnce(&mut D, AllocId),\n >(\n     decoder: &mut D,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    pos: usize,\n     cache: CACHE,\n-    short: SHORT,\n ) -> Result<AllocId, D::Error> {\n-    match usize::decode(decoder)? {\n-        ALLOC_DISCRIMINANT => {\n+    match AllocKind::decode(decoder)? {\n+        AllocKind::Alloc => {\n             let alloc_id = tcx.interpret_interner.reserve();\n-            trace!(\"creating alloc id {:?} at {}\", alloc_id, pos);\n+            trace!(\"creating alloc id {:?}\", alloc_id);\n             // insert early to allow recursive allocs\n-            cache(decoder, pos, alloc_id);\n+            cache(decoder, alloc_id);\n \n             let allocation = Allocation::decode(decoder)?;\n             trace!(\"decoded alloc {:?} {:#?}\", alloc_id, allocation);\n             let allocation = tcx.intern_const_alloc(allocation);\n             tcx.interpret_interner.intern_at_reserved(alloc_id, allocation);\n \n-            if let Some(glob) = Option::<DefId>::decode(decoder)? {\n-                tcx.interpret_interner.cache(glob, alloc_id);\n-            }\n-\n             Ok(alloc_id)\n         },\n-        FN_DISCRIMINANT => {\n-            trace!(\"creating fn alloc id at {}\", pos);\n+        AllocKind::Fn => {\n+            trace!(\"creating fn alloc id\");\n             let instance = ty::Instance::decode(decoder)?;\n             trace!(\"decoded fn alloc instance: {:?}\", instance);\n             let id = tcx.interpret_interner.create_fn_alloc(instance);\n             trace!(\"created fn alloc id: {:?}\", id);\n-            cache(decoder, pos, id);\n+            cache(decoder, id);\n             Ok(id)\n         },\n-        EXTERN_STATIC_DISCRIMINANT => {\n-            trace!(\"creating extern static alloc id at {}\", pos);\n+        AllocKind::Static => {\n+            trace!(\"creating extern static alloc id at\");\n             let did = DefId::decode(decoder)?;\n-            let alloc_id = tcx.interpret_interner.reserve();\n-            tcx.interpret_interner.cache(did, alloc_id);\n+            let alloc_id = tcx.interpret_interner.cache_static(did);\n+            cache(decoder, alloc_id);\n             Ok(alloc_id)\n         },\n-        shorthand => {\n-            trace!(\"loading shorthand {}\", shorthand);\n-            short(decoder, shorthand)\n-        },\n     }\n }\n "}, {"sha": "ed3332f32d02fd4648a4611086b25276fd0189a9", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7360d6dd678d186d9c9b46311b75ba6840e61aa2/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7360d6dd678d186d9c9b46311b75ba6840e61aa2/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=7360d6dd678d186d9c9b46311b75ba6840e61aa2", "patch": "@@ -956,18 +956,16 @@ struct InterpretInternerInner<'tcx> {\n     /// Allows obtaining const allocs via a unique identifier\n     alloc_by_id: FxHashMap<interpret::AllocId, &'tcx interpret::Allocation>,\n \n-    /// Reverse map of `alloc_cache`\n-    global_cache: FxHashMap<interpret::AllocId, DefId>,\n+    /// Allows obtaining static def ids via a unique id\n+    statics: FxHashMap<interpret::AllocId, DefId>,\n \n     /// The AllocId to assign to the next new regular allocation.\n     /// Always incremented, never gets smaller.\n     next_id: interpret::AllocId,\n \n-    /// Allows checking whether a static already has an allocation\n-    ///\n-    /// This is only important for detecting statics referring to themselves\n-    // FIXME(oli-obk) move it to the EvalContext?\n-    alloc_cache: FxHashMap<DefId, interpret::AllocId>,\n+    /// Inverse map of `statics`\n+    /// Used so we don't allocate a new pointer every time we need one\n+    static_cache: FxHashMap<DefId, interpret::AllocId>,\n \n     /// A cache for basic byte allocations keyed by their contents. This is used to deduplicate\n     /// allocations for string and bytestring literals.\n@@ -1001,30 +999,25 @@ impl<'tcx> InterpretInterner<'tcx> {\n         self.inner.borrow().alloc_by_id.get(&id).cloned()\n     }\n \n-    pub fn get_cached(\n-        &self,\n-        static_id: DefId,\n-    ) -> Option<interpret::AllocId> {\n-        self.inner.borrow().alloc_cache.get(&static_id).cloned()\n-    }\n-\n-    pub fn cache(\n+    pub fn cache_static(\n         &self,\n         static_id: DefId,\n-        alloc_id: interpret::AllocId,\n-    ) {\n-        let mut inner = self.inner.borrow_mut();\n-        inner.global_cache.insert(alloc_id, static_id);\n-        if let Some(old) = inner.alloc_cache.insert(static_id, alloc_id) {\n-            bug!(\"tried to cache {:?}, but was already existing as {:#?}\", static_id, old);\n+    ) -> interpret::AllocId {\n+        if let Some(alloc_id) = self.inner.borrow().static_cache.get(&static_id).cloned() {\n+            return alloc_id;\n         }\n+        let alloc_id = self.reserve();\n+        let mut inner = self.inner.borrow_mut();\n+        inner.static_cache.insert(static_id, alloc_id);\n+        inner.statics.insert(alloc_id, static_id);\n+        alloc_id\n     }\n \n-    pub fn get_corresponding_static_def_id(\n+    pub fn get_static(\n         &self,\n         ptr: interpret::AllocId,\n     ) -> Option<DefId> {\n-        self.inner.borrow().global_cache.get(&ptr).cloned()\n+        self.inner.borrow().statics.get(&ptr).cloned()\n     }\n \n     pub fn intern_at_reserved("}, {"sha": "d60206ffd327cd5eace09920486608118a641b63", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 72, "deletions": 58, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/7360d6dd678d186d9c9b46311b75ba6840e61aa2/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7360d6dd678d186d9c9b46311b75ba6840e61aa2/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=7360d6dd678d186d9c9b46311b75ba6840e61aa2", "patch": "@@ -77,12 +77,11 @@ pub struct OnDiskCache<'sess> {\n     // `serialized_data`.\n     prev_diagnostics_index: FxHashMap<SerializedDepNodeIndex, AbsoluteBytePos>,\n \n-    // A cache to ensure we don't read allocations twice\n-    interpret_alloc_cache: RefCell<FxHashMap<usize, interpret::AllocId>>,\n+    // Alloc indices to memory location map\n+    prev_interpret_alloc_index: Vec<AbsoluteBytePos>,\n \n-    // A map from positions to size of the serialized allocation\n-    // so we can skip over already processed allocations\n-    interpret_alloc_size: RefCell<FxHashMap<usize, usize>>,\n+    /// Deserialization: A cache to ensure we don't read allocations twice\n+    interpret_alloc_cache: RefCell<FxHashMap<usize, interpret::AllocId>>,\n }\n \n // This type is used only for (de-)serialization.\n@@ -92,6 +91,8 @@ struct Footer {\n     prev_cnums: Vec<(u32, String, CrateDisambiguator)>,\n     query_result_index: EncodedQueryResultIndex,\n     diagnostics_index: EncodedQueryResultIndex,\n+    // the location of all allocations\n+    interpret_alloc_index: Vec<AbsoluteBytePos>,\n }\n \n type EncodedQueryResultIndex = Vec<(SerializedDepNodeIndex, AbsoluteBytePos)>;\n@@ -148,8 +149,8 @@ impl<'sess> OnDiskCache<'sess> {\n             query_result_index: footer.query_result_index.into_iter().collect(),\n             prev_diagnostics_index: footer.diagnostics_index.into_iter().collect(),\n             synthetic_expansion_infos: Lock::new(FxHashMap()),\n+            prev_interpret_alloc_index: footer.interpret_alloc_index,\n             interpret_alloc_cache: RefCell::new(FxHashMap::default()),\n-            interpret_alloc_size: RefCell::new(FxHashMap::default()),\n         }\n     }\n \n@@ -165,8 +166,8 @@ impl<'sess> OnDiskCache<'sess> {\n             query_result_index: FxHashMap(),\n             prev_diagnostics_index: FxHashMap(),\n             synthetic_expansion_infos: Lock::new(FxHashMap()),\n+            prev_interpret_alloc_index: Vec::new(),\n             interpret_alloc_cache: RefCell::new(FxHashMap::default()),\n-            interpret_alloc_size: RefCell::new(FxHashMap::default()),\n         }\n     }\n \n@@ -199,7 +200,8 @@ impl<'sess> OnDiskCache<'sess> {\n                 type_shorthands: FxHashMap(),\n                 predicate_shorthands: FxHashMap(),\n                 expn_info_shorthands: FxHashMap(),\n-                interpret_alloc_shorthands: FxHashMap(),\n+                interpret_allocs: FxHashMap(),\n+                interpret_allocs_inverse: Vec::new(),\n                 codemap: CachingCodemapView::new(tcx.sess.codemap()),\n                 file_to_file_index,\n             };\n@@ -277,6 +279,31 @@ impl<'sess> OnDiskCache<'sess> {\n                 diagnostics_index\n             };\n \n+            let interpret_alloc_index = {\n+                let mut interpret_alloc_index = Vec::new();\n+                let mut n = 0;\n+                loop {\n+                    let new_n = encoder.interpret_allocs_inverse.len();\n+                    // if we have found new ids, serialize those, too\n+                    if n == new_n {\n+                        // otherwise, abort\n+                        break;\n+                    }\n+                    for idx in n..new_n {\n+                        let id = encoder.interpret_allocs_inverse[idx];\n+                        let pos = AbsoluteBytePos::new(encoder.position());\n+                        interpret_alloc_index.push(pos);\n+                        interpret::specialized_encode_alloc_id(\n+                            &mut encoder,\n+                            tcx,\n+                            id,\n+                        )?;\n+                    }\n+                    n = new_n;\n+                }\n+                interpret_alloc_index\n+            };\n+\n             let sorted_cnums = sorted_cnums_including_local_crate(tcx);\n             let prev_cnums: Vec<_> = sorted_cnums.iter().map(|&cnum| {\n                 let crate_name = tcx.original_crate_name(cnum).as_str().to_string();\n@@ -291,6 +318,7 @@ impl<'sess> OnDiskCache<'sess> {\n                 prev_cnums,\n                 query_result_index,\n                 diagnostics_index,\n+                interpret_alloc_index,\n             })?;\n \n             // Encode the position of the footer as the last 8 bytes of the\n@@ -396,8 +424,8 @@ impl<'sess> OnDiskCache<'sess> {\n             file_index_to_file: &self.file_index_to_file,\n             file_index_to_stable_id: &self.file_index_to_stable_id,\n             synthetic_expansion_infos: &self.synthetic_expansion_infos,\n+            prev_interpret_alloc_index: &self.prev_interpret_alloc_index,\n             interpret_alloc_cache: &self.interpret_alloc_cache,\n-            interpret_alloc_size: &self.interpret_alloc_size,\n         };\n \n         match decode_tagged(&mut decoder, dep_node_index) {\n@@ -460,7 +488,8 @@ struct CacheDecoder<'a, 'tcx: 'a, 'x> {\n     file_index_to_file: &'x Lock<FxHashMap<FileMapIndex, Lrc<FileMap>>>,\n     file_index_to_stable_id: &'x FxHashMap<FileMapIndex, StableFilemapId>,\n     interpret_alloc_cache: &'x RefCell<FxHashMap<usize, interpret::AllocId>>,\n-    interpret_alloc_size: &'x RefCell<FxHashMap<usize, usize>>,\n+    /// maps from index in the cache file to location in the cache file\n+    prev_interpret_alloc_index: &'x [AbsoluteBytePos],\n }\n \n impl<'a, 'tcx, 'x> CacheDecoder<'a, 'tcx, 'x> {\n@@ -584,36 +613,29 @@ implement_ty_decoder!( CacheDecoder<'a, 'tcx, 'x> );\n impl<'a, 'tcx, 'x> SpecializedDecoder<interpret::AllocId> for CacheDecoder<'a, 'tcx, 'x> {\n     fn specialized_decode(&mut self) -> Result<interpret::AllocId, Self::Error> {\n         let tcx = self.tcx;\n-        let pos = TyDecoder::position(self);\n-        trace!(\"specialized_decode_alloc_id: {:?}\", pos);\n-        if let Some(cached) = self.interpret_alloc_cache.borrow().get(&pos).cloned() {\n-            // if there's no end position we are currently deserializing a recursive\n-            // allocation\n-            if let Some(end) = self.interpret_alloc_size.borrow().get(&pos).cloned() {\n-                trace!(\"{} already cached as {:?}\", pos, cached);\n-                // skip ahead\n-                self.opaque.set_position(end);\n-                return Ok(cached)\n-            }\n+        let idx = usize::decode(self)?;\n+        trace!(\"loading index {}\", idx);\n+\n+        if let Some(cached) = self.interpret_alloc_cache.borrow().get(&idx).cloned() {\n+            trace!(\"loading alloc id {:?} from alloc_cache\", cached);\n+            return Ok(cached);\n         }\n-        let id = interpret::specialized_decode_alloc_id(\n-            self,\n-            tcx,\n-            pos,\n-            |this, pos, alloc_id| {\n-                assert!(this.interpret_alloc_cache.borrow_mut().insert(pos, alloc_id).is_none());\n-            },\n-            |this, shorthand| {\n-                // need to load allocation\n-                this.with_position(shorthand, |this| interpret::AllocId::decode(this))\n-            }\n-        )?;\n-        assert!(self\n-            .interpret_alloc_size\n-            .borrow_mut()\n-            .insert(pos, TyDecoder::position(self))\n-            .is_none());\n-        Ok(id)\n+        let pos = self.prev_interpret_alloc_index[idx].to_usize();\n+        trace!(\"loading position {}\", pos);\n+        self.with_position(pos, |this| {\n+            interpret::specialized_decode_alloc_id(\n+                this,\n+                tcx,\n+                |this, alloc_id| {\n+                    trace!(\"caching idx {} for alloc id {} at position {}\", idx, alloc_id, pos);\n+                    assert!(this\n+                        .interpret_alloc_cache\n+                        .borrow_mut()\n+                        .insert(idx, alloc_id)\n+                        .is_none());\n+                },\n+            )\n+        })\n     }\n }\n impl<'a, 'tcx, 'x> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx, 'x> {\n@@ -777,7 +799,8 @@ struct CacheEncoder<'enc, 'a, 'tcx, E>\n     type_shorthands: FxHashMap<ty::Ty<'tcx>, usize>,\n     predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n     expn_info_shorthands: FxHashMap<Mark, AbsoluteBytePos>,\n-    interpret_alloc_shorthands: FxHashMap<interpret::AllocId, usize>,\n+    interpret_allocs: FxHashMap<interpret::AllocId, usize>,\n+    interpret_allocs_inverse: Vec<interpret::AllocId>,\n     codemap: CachingCodemapView<'tcx>,\n     file_to_file_index: FxHashMap<*const FileMap, FileMapIndex>,\n }\n@@ -815,26 +838,17 @@ impl<'enc, 'a, 'tcx, E> SpecializedEncoder<interpret::AllocId> for CacheEncoder<\n {\n     fn specialized_encode(&mut self, alloc_id: &interpret::AllocId) -> Result<(), Self::Error> {\n         use std::collections::hash_map::Entry;\n-        let tcx = self.tcx;\n-        let pos = self.position();\n-        let shorthand = match self.interpret_alloc_shorthands.entry(*alloc_id) {\n-            Entry::Occupied(entry) => Some(entry.get().clone()),\n-            Entry::Vacant(entry) => {\n-                // ensure that we don't place any AllocIds at the very beginning\n-                // of the metadata file, because that would end up making our indices\n-                // not special. It is essentially impossible for that to happen,\n-                // but let's make sure\n-                assert!(pos >= interpret::SHORTHAND_START);\n-                entry.insert(pos);\n-                None\n+        let index = match self.interpret_allocs.entry(*alloc_id) {\n+            Entry::Occupied(e) => *e.get(),\n+            Entry::Vacant(e) => {\n+                let idx = self.interpret_allocs_inverse.len();\n+                self.interpret_allocs_inverse.push(*alloc_id);\n+                e.insert(idx);\n+                idx\n             },\n         };\n-        interpret::specialized_encode_alloc_id(\n-            self,\n-            tcx,\n-            *alloc_id,\n-            shorthand,\n-        )\n+\n+        index.encode(self)\n     }\n }\n "}, {"sha": "936d680380c993a994cae26b43b69ea08cfc9398", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7360d6dd678d186d9c9b46311b75ba6840e61aa2/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7360d6dd678d186d9c9b46311b75ba6840e61aa2/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=7360d6dd678d186d9c9b46311b75ba6840e61aa2", "patch": "@@ -59,9 +59,9 @@ pub struct DecodeContext<'a, 'tcx: 'a> {\n \n     // interpreter allocation cache\n     interpret_alloc_cache: FxHashMap<usize, interpret::AllocId>,\n-    // a cache for sizes of interpreter allocations\n-    // needed to skip already deserialized allocations\n-    interpret_alloc_size: FxHashMap<usize, usize>,\n+\n+    // Read from the LazySeq CrateRoot::inpterpret_alloc_index on demand\n+    interpret_alloc_index: Option<Vec<u32>>,\n }\n \n /// Abstract over the various ways one can create metadata decoders.\n@@ -81,7 +81,7 @@ pub trait Metadata<'a, 'tcx>: Copy {\n             last_filemap_index: 0,\n             lazy_state: LazyState::NoNode,\n             interpret_alloc_cache: FxHashMap::default(),\n-            interpret_alloc_size: FxHashMap::default(),\n+            interpret_alloc_index: None,\n         }\n     }\n }\n@@ -180,6 +180,17 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n         self.lazy_state = LazyState::Previous(position + min_size);\n         Ok(position)\n     }\n+\n+    fn interpret_alloc(&mut self, idx: usize) -> usize {\n+        if let Some(index) = self.interpret_alloc_index.as_mut() {\n+            return index[idx] as usize;\n+        }\n+        let cdata = self.cdata();\n+        let index: Vec<u32> = cdata.root.interpret_alloc_index.decode(cdata).collect();\n+        let pos = index[idx];\n+        self.interpret_alloc_index = Some(index);\n+        pos as usize\n+    }\n }\n \n impl<'a, 'tcx: 'a> TyDecoder<'a, 'tcx> for DecodeContext<'a, 'tcx> {\n@@ -290,34 +301,22 @@ impl<'a, 'tcx> SpecializedDecoder<LocalDefId> for DecodeContext<'a, 'tcx> {\n \n impl<'a, 'tcx> SpecializedDecoder<interpret::AllocId> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<interpret::AllocId, Self::Error> {\n-        let tcx = self.tcx.expect(\"need tcx for AllocId decoding\");\n-        let pos = self.position();\n-        if let Some(cached) = self.interpret_alloc_cache.get(&pos).cloned() {\n-            // if there's no end position we are currently deserializing a recursive\n-            // allocation\n-            if let Some(end) = self.interpret_alloc_size.get(&pos).cloned() {\n-                trace!(\"{} already cached as {:?}\", pos, cached);\n-                // skip ahead\n-                self.opaque.set_position(end);\n-                return Ok(cached)\n-            }\n+        let tcx = self.tcx.unwrap();\n+        let idx = usize::decode(self)?;\n+\n+        if let Some(cached) = self.interpret_alloc_cache.get(&idx).cloned() {\n+            return Ok(cached);\n         }\n-        let id = interpret::specialized_decode_alloc_id(\n-            self,\n-            tcx,\n-            pos,\n-            |this, pos, alloc_id| { this.interpret_alloc_cache.insert(pos, alloc_id); },\n-            |this, shorthand| {\n-                // need to load allocation\n-                this.with_position(shorthand, |this| interpret::AllocId::decode(this))\n-            }\n-        )?;\n-        let end_pos = self.position();\n-        assert!(self\n-            .interpret_alloc_size\n-            .insert(pos, end_pos)\n-            .is_none());\n-        Ok(id)\n+        let pos = self.interpret_alloc(idx);\n+        self.with_position(pos, |this| {\n+            interpret::specialized_decode_alloc_id(\n+                this,\n+                tcx,\n+                |this, alloc_id| {\n+                    assert!(this.interpret_alloc_cache.insert(idx, alloc_id).is_none());\n+                },\n+            )\n+        })\n     }\n }\n "}, {"sha": "a61428b841fea83748d56fe353982414ca9187ae", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 53, "deletions": 22, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/7360d6dd678d186d9c9b46311b75ba6840e61aa2/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7360d6dd678d186d9c9b46311b75ba6840e61aa2/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=7360d6dd678d186d9c9b46311b75ba6840e61aa2", "patch": "@@ -59,7 +59,9 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     lazy_state: LazyState,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n     predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n-    interpret_alloc_shorthands: FxHashMap<interpret::AllocId, usize>,\n+\n+    interpret_allocs: FxHashMap<interpret::AllocId, usize>,\n+    interpret_allocs_inverse: Vec<interpret::AllocId>,\n \n     // This is used to speed up Span encoding.\n     filemap_cache: Lrc<FileMap>,\n@@ -197,25 +199,17 @@ impl<'a, 'tcx> SpecializedEncoder<Ty<'tcx>> for EncodeContext<'a, 'tcx> {\n impl<'a, 'tcx> SpecializedEncoder<interpret::AllocId> for EncodeContext<'a, 'tcx> {\n     fn specialized_encode(&mut self, alloc_id: &interpret::AllocId) -> Result<(), Self::Error> {\n         use std::collections::hash_map::Entry;\n-        let tcx = self.tcx;\n-        let pos = self.position();\n-        let shorthand = match self.interpret_alloc_shorthands.entry(*alloc_id) {\n-            Entry::Occupied(entry) => Some(entry.get().clone()),\n-            Entry::Vacant(entry) => {\n-                // ensure that we don't place any AllocIds at the very beginning\n-                // of the metadata file, because that would end up making our indices\n-                // not special. This is essentially impossible, but let's make sure\n-                assert!(pos >= interpret::SHORTHAND_START);\n-                entry.insert(pos);\n-                None\n+        let index = match self.interpret_allocs.entry(*alloc_id) {\n+            Entry::Occupied(e) => *e.get(),\n+            Entry::Vacant(e) => {\n+                let idx = self.interpret_allocs_inverse.len();\n+                self.interpret_allocs_inverse.push(*alloc_id);\n+                e.insert(idx);\n+                idx\n             },\n         };\n-        interpret::specialized_encode_alloc_id(\n-            self,\n-            tcx,\n-            *alloc_id,\n-            shorthand,\n-        )\n+\n+        index.encode(self)\n     }\n }\n \n@@ -271,7 +265,11 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 start - min_end\n             }\n             LazyState::Previous(last_min_end) => {\n-                assert!(last_min_end <= position);\n+                assert!(\n+                    last_min_end <= position,\n+                    \"make sure that the calls to `lazy*` \\\n+                    are in the same order as the metadata fields\",\n+                );\n                 position - last_min_end\n             }\n         };\n@@ -445,21 +443,52 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             IsolatedEncoder::encode_wasm_custom_sections,\n             &wasm_custom_sections);\n \n-        // Encode and index the items.\n+        let tcx = self.tcx;\n+\n+        // Encode the items.\n         i = self.position();\n         let items = self.encode_info_for_items();\n         let item_bytes = self.position() - i;\n \n+        // Encode the allocation index\n+        let interpret_alloc_index = {\n+            let mut interpret_alloc_index = Vec::new();\n+            let mut n = 0;\n+            trace!(\"beginning to encode alloc ids\");\n+            loop {\n+                let new_n = self.interpret_allocs_inverse.len();\n+                // if we have found new ids, serialize those, too\n+                if n == new_n {\n+                    // otherwise, abort\n+                    break;\n+                }\n+                trace!(\"encoding {} further alloc ids\", new_n - n);\n+                for idx in n..new_n {\n+                    let id = self.interpret_allocs_inverse[idx];\n+                    let pos = self.position() as u32;\n+                    interpret_alloc_index.push(pos);\n+                    interpret::specialized_encode_alloc_id(\n+                        self,\n+                        tcx,\n+                        id,\n+                    ).unwrap();\n+                }\n+                n = new_n;\n+            }\n+            self.lazy_seq(interpret_alloc_index)\n+        };\n+\n+        // Index the items\n         i = self.position();\n         let index = items.write_index(&mut self.opaque.cursor);\n         let index_bytes = self.position() - i;\n \n-        let tcx = self.tcx;\n         let link_meta = self.link_meta;\n         let is_proc_macro = tcx.sess.crate_types.borrow().contains(&CrateTypeProcMacro);\n         let has_default_lib_allocator =\n             attr::contains_name(tcx.hir.krate_attrs(), \"default_lib_allocator\");\n         let has_global_allocator = *tcx.sess.has_global_allocator.get();\n+\n         let root = self.lazy(&CrateRoot {\n             name: tcx.crate_name(LOCAL_CRATE),\n             extra_filename: tcx.sess.opts.cg.extra_filename.clone(),\n@@ -491,6 +520,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             impls,\n             exported_symbols,\n             wasm_custom_sections,\n+            interpret_alloc_index,\n             index,\n         });\n \n@@ -1760,7 +1790,8 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             type_shorthands: Default::default(),\n             predicate_shorthands: Default::default(),\n             filemap_cache: tcx.sess.codemap().files()[0].clone(),\n-            interpret_alloc_shorthands: Default::default(),\n+            interpret_allocs: Default::default(),\n+            interpret_allocs_inverse: Default::default(),\n         };\n \n         // Encode the rustc version string in a predictable location."}, {"sha": "23ea5e4cc55043b97ef075feb1c90302aaaa1c58", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7360d6dd678d186d9c9b46311b75ba6840e61aa2/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7360d6dd678d186d9c9b46311b75ba6840e61aa2/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=7360d6dd678d186d9c9b46311b75ba6840e61aa2", "patch": "@@ -207,6 +207,7 @@ pub struct CrateRoot {\n     pub impls: LazySeq<TraitImpls>,\n     pub exported_symbols: EncodedExportedSymbols,\n     pub wasm_custom_sections: LazySeq<DefIndex>,\n+    pub interpret_alloc_index: LazySeq<u32>,\n \n     pub index: LazySeq<index::Index>,\n }"}, {"sha": "954a3dbe5b9ab0e78224cb1a508925810b4606a5", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 31, "deletions": 105, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/7360d6dd678d186d9c9b46311b75ba6840e61aa2/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7360d6dd678d186d9c9b46311b75ba6840e61aa2/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=7360d6dd678d186d9c9b46311b75ba6840e61aa2", "patch": "@@ -5,7 +5,6 @@ use rustc::mir;\n use rustc::ty::{self, TyCtxt, Ty, Instance};\n use rustc::ty::layout::{self, LayoutOf};\n use rustc::ty::subst::Subst;\n-use rustc::util::nodemap::FxHashSet;\n \n use syntax::ast::Mutability;\n use syntax::codemap::Span;\n@@ -110,53 +109,38 @@ fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n         }\n         span = mir.span;\n         let layout = ecx.layout_of(mir.return_ty().subst(tcx, cid.instance.substs))?;\n-        let alloc = tcx.interpret_interner.get_cached(cid.instance.def_id());\n-        let is_static = tcx.is_static(cid.instance.def_id()).is_some();\n-        let alloc = match alloc {\n-            Some(alloc) => {\n-                assert!(cid.promoted.is_none());\n-                assert!(param_env.caller_bounds.is_empty());\n-                alloc\n-            },\n-            None => {\n-                assert!(!layout.is_unsized());\n-                let ptr = ecx.memory.allocate(\n-                    layout.size.bytes(),\n-                    layout.align,\n-                    None,\n-                )?;\n-                if is_static {\n-                    tcx.interpret_interner.cache(cid.instance.def_id(), ptr.alloc_id);\n-                }\n-                let internally_mutable = !layout.ty.is_freeze(tcx, param_env, mir.span);\n-                let mutability = tcx.is_static(cid.instance.def_id());\n-                let mutability = if mutability == Some(hir::Mutability::MutMutable) || internally_mutable {\n-                    Mutability::Mutable\n-                } else {\n-                    Mutability::Immutable\n-                };\n-                let cleanup = StackPopCleanup::MarkStatic(mutability);\n-                let name = ty::tls::with(|tcx| tcx.item_path_str(cid.instance.def_id()));\n-                let prom = cid.promoted.map_or(String::new(), |p| format!(\"::promoted[{:?}]\", p));\n-                trace!(\"const_eval: pushing stack frame for global: {}{}\", name, prom);\n-                assert!(mir.arg_count == 0);\n-                ecx.push_stack_frame(\n-                    cid.instance,\n-                    mir.span,\n-                    mir,\n-                    Place::from_ptr(ptr, layout.align),\n-                    cleanup,\n-                )?;\n-\n-                while ecx.step()? {}\n-                ptr.alloc_id\n-            }\n+        assert!(!layout.is_unsized());\n+        let ptr = ecx.memory.allocate(\n+            layout.size.bytes(),\n+            layout.align,\n+            None,\n+        )?;\n+        let internally_mutable = !layout.ty.is_freeze(tcx, param_env, mir.span);\n+        let mutability = tcx.is_static(cid.instance.def_id());\n+        let mutability = if mutability == Some(hir::Mutability::MutMutable) || internally_mutable {\n+            Mutability::Mutable\n+        } else {\n+            Mutability::Immutable\n         };\n-        let ptr = MemoryPointer::new(alloc, 0).into();\n+        let cleanup = StackPopCleanup::MarkStatic(mutability);\n+        let name = ty::tls::with(|tcx| tcx.item_path_str(cid.instance.def_id()));\n+        let prom = cid.promoted.map_or(String::new(), |p| format!(\"::promoted[{:?}]\", p));\n+        trace!(\"const_eval: pushing stack frame for global: {}{}\", name, prom);\n+        assert!(mir.arg_count == 0);\n+        ecx.push_stack_frame(\n+            cid.instance,\n+            mir.span,\n+            mir,\n+            Place::from_ptr(ptr, layout.align),\n+            cleanup,\n+        )?;\n+\n+        while ecx.step()? {}\n+        let ptr = ptr.into();\n         // always try to read the value and report errors\n         let value = match ecx.try_read_value(ptr, layout.align, layout.ty)? {\n             // if it's a constant (so it needs no address, directly compute its value)\n-            Some(val) if !is_static => val,\n+            Some(val) if tcx.is_static(cid.instance.def_id()).is_none() => val,\n             // point at the allocation\n             _ => Value::ByRef(ptr, layout.align),\n         };\n@@ -340,21 +324,10 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         cid: GlobalId<'tcx>,\n     ) -> EvalResult<'tcx, AllocId> {\n-        let alloc = ecx\n-                    .tcx\n-                    .interpret_interner\n-                    .get_cached(cid.instance.def_id());\n-        // Don't evaluate when already cached to prevent cycles\n-        if let Some(alloc) = alloc {\n-            return Ok(alloc)\n-        }\n-        // ensure the static is computed\n-        ecx.const_eval(cid)?;\n         Ok(ecx\n             .tcx\n             .interpret_interner\n-            .get_cached(cid.instance.def_id())\n-            .expect(\"uncached static\"))\n+            .cache_static(cid.instance.def_id()))\n     }\n \n     fn box_alloc<'a>(\n@@ -460,16 +433,7 @@ pub fn const_eval_provider<'a, 'tcx>(\n     let def_id = cid.instance.def.def_id();\n \n     if tcx.is_foreign_item(def_id) {\n-        let id = tcx.interpret_interner.get_cached(def_id);\n-        let id = match id {\n-            // FIXME: due to caches this shouldn't happen, add some assertions\n-            Some(id) => id,\n-            None => {\n-                let id = tcx.interpret_interner.reserve();\n-                tcx.interpret_interner.cache(def_id, id);\n-                id\n-            },\n-        };\n+        let id = tcx.interpret_interner.cache_static(def_id);\n         let ty = tcx.type_of(def_id);\n         let layout = tcx.layout_of(key.param_env.and(ty)).unwrap();\n         let ptr = MemoryPointer::new(id, 0);\n@@ -505,13 +469,7 @@ pub fn const_eval_provider<'a, 'tcx>(\n     };\n \n     let (res, ecx) = eval_body_and_ecx(tcx, cid, None, key.param_env);\n-    res.map(|(miri_value, ptr, miri_ty)| {\n-        if tcx.is_static(def_id).is_some() {\n-            if let Ok(ptr) = ptr.primval.to_ptr() {\n-                let mut seen = FxHashSet::default();\n-                create_depgraph_edges(tcx, ptr.alloc_id, &mut seen);\n-            }\n-        }\n+    res.map(|(miri_value, _, miri_ty)| {\n         tcx.mk_const(ty::Const {\n             val: ConstVal::Value(miri_value),\n             ty: miri_ty,\n@@ -528,35 +486,3 @@ pub fn const_eval_provider<'a, 'tcx>(\n         }\n     })\n }\n-\n-// This function creates dep graph edges from statics to all referred to statics.\n-// This is necessary, because the `const_eval` query cannot directly call itself\n-// for other statics, because we cannot prevent recursion in queries.\n-//\n-// see test/incremental/static_refering_to_other_static2/issue.rs for an example\n-// where not creating those edges would cause static A, which refers to static B\n-// to point to the old allocation of static B, even though B has changed.\n-//\n-// In the future we will want to remove this funcion in favour of a system that\n-// makes sure that statics don't need to have edges to other statics as long as\n-// they are only referring by reference and not inspecting the other static's body.\n-fn create_depgraph_edges<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    alloc_id: AllocId,\n-    seen: &mut FxHashSet<AllocId>,\n-) {\n-    trace!(\"create_depgraph_edges: {:?}, {:?}\", alloc_id, seen);\n-    if seen.insert(alloc_id) {\n-        trace!(\"seen: {:?}, {:?}\", alloc_id, seen);\n-        if let Some(alloc) = tcx.interpret_interner.get_alloc(alloc_id) {\n-            trace!(\"get_alloc: {:?}, {:?}, {:?}\", alloc_id, seen, alloc);\n-            for (_, &reloc) in &alloc.relocations {\n-                if let Some(did) = tcx.interpret_interner.get_corresponding_static_def_id(reloc) {\n-                    trace!(\"get_corresponding: {:?}, {:?}, {:?}, {:?}, {:?}\", alloc_id, seen, alloc, did, reloc);\n-                    let _ = tcx.maybe_optimized_mir(did);\n-                }\n-                create_depgraph_edges(tcx, reloc, seen);\n-            }\n-        }\n-    }\n-}"}, {"sha": "158d674580b530c954fca19005863b9b6c9ba1be", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7360d6dd678d186d9c9b46311b75ba6840e61aa2/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7360d6dd678d186d9c9b46311b75ba6840e61aa2/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=7360d6dd678d186d9c9b46311b75ba6840e61aa2", "patch": "@@ -938,16 +938,14 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     }\n \n     pub fn read_global_as_value(&self, gid: GlobalId<'tcx>, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n-        if gid.promoted.is_none() {\n-            let cached = self\n+        if self.tcx.is_static(gid.instance.def_id()).is_some() {\n+            let alloc_id = self\n                 .tcx\n                 .interpret_interner\n-                .get_cached(gid.instance.def_id());\n-            if let Some(alloc_id) = cached {\n-                let layout = self.layout_of(ty)?;\n-                let ptr = MemoryPointer::new(alloc_id, 0);\n-                return Ok(Value::ByRef(ptr.into(), layout.align))\n-            }\n+                .cache_static(gid.instance.def_id());\n+            let layout = self.layout_of(ty)?;\n+            let ptr = MemoryPointer::new(alloc_id, 0);\n+            return Ok(Value::ByRef(ptr.into(), layout.align))\n         }\n         let cv = self.const_eval(gid)?;\n         self.const_to_value(&cv.val, ty)"}, {"sha": "008165f33b2bbc69f23fffa1c9a7aac0ae907c5b", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7360d6dd678d186d9c9b46311b75ba6840e61aa2/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7360d6dd678d186d9c9b46311b75ba6840e61aa2/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=7360d6dd678d186d9c9b46311b75ba6840e61aa2", "patch": "@@ -1142,7 +1142,7 @@ fn collect_miri<'a, 'tcx>(\n     alloc_id: AllocId,\n     output: &mut Vec<MonoItem<'tcx>>,\n ) {\n-    if let Some(did) = tcx.interpret_interner.get_corresponding_static_def_id(alloc_id) {\n+    if let Some(did) = tcx.interpret_interner.get_static(alloc_id) {\n         let instance = Instance::mono(tcx, did);\n         if should_monomorphize_locally(tcx, &instance) {\n             trace!(\"collecting static {:?}\", did);"}, {"sha": "6e07b8e73ef22c329ea9c8749ede3d649ae14667", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7360d6dd678d186d9c9b46311b75ba6840e61aa2/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7360d6dd678d186d9c9b46311b75ba6840e61aa2/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=7360d6dd678d186d9c9b46311b75ba6840e61aa2", "patch": "@@ -50,7 +50,7 @@ pub fn primval_to_llvm(cx: &CodegenCx,\n                 let static_ = cx\n                     .tcx\n                     .interpret_interner\n-                    .get_corresponding_static_def_id(ptr.alloc_id);\n+                    .get_static(ptr.alloc_id);\n                 let base_addr = if let Some(def_id) = static_ {\n                     assert!(cx.tcx.is_static(def_id).is_some());\n                     consts::get_static(cx, def_id)\n@@ -126,18 +126,17 @@ pub fn trans_static_initializer<'a, 'tcx>(\n         promoted: None\n     };\n     let param_env = ty::ParamEnv::reveal_all();\n-    cx.tcx.const_eval(param_env.and(cid))?;\n+    let static_ = cx.tcx.const_eval(param_env.and(cid))?;\n \n-    let alloc_id = cx\n-        .tcx\n-        .interpret_interner\n-        .get_cached(def_id)\n-        .expect(\"global not cached\");\n+    let ptr = match static_.val {\n+        ConstVal::Value(MiriValue::ByRef(ptr, _)) => ptr,\n+        _ => bug!(\"static const eval returned {:#?}\", static_),\n+    };\n \n     let alloc = cx\n         .tcx\n         .interpret_interner\n-        .get_alloc(alloc_id)\n+        .get_alloc(ptr.primval.to_ptr().expect(\"static has integer pointer\").alloc_id)\n         .expect(\"miri allocation never successfully created\");\n     Ok(global_initializer(cx, alloc))\n }"}, {"sha": "b659703bef004781dc7a25f98bcc0fc20da493c0", "filename": "src/test/incremental/static_cycle/b.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7360d6dd678d186d9c9b46311b75ba6840e61aa2/src%2Ftest%2Fincremental%2Fstatic_cycle%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7360d6dd678d186d9c9b46311b75ba6840e61aa2/src%2Ftest%2Fincremental%2Fstatic_cycle%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstatic_cycle%2Fb.rs?ref=7360d6dd678d186d9c9b46311b75ba6840e61aa2", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions:rpass1 rpass2\n+\n+#![cfg_attr(rpass2, warn(dead_code))]\n+\n+pub static mut BAA: *const i8 = unsafe { &BOO as *const _ as *const i8 };\n+\n+pub static mut BOO: *const i8 = unsafe { &BAA as *const _ as *const i8 };\n+\n+fn main() {}"}]}