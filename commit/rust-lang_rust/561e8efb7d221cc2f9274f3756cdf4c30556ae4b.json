{"sha": "561e8efb7d221cc2f9274f3756cdf4c30556ae4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2MWU4ZWZiN2QyMjFjYzJmOTI3NGYzNzU2Y2RmNGMzMDU1NmFlNGI=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-03-28T15:32:15Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-03-29T11:43:55Z"}, "message": "Add primitive intra-links", "tree": {"sha": "be21b6791b4809e55d03d2e615a1d121cbfc3bdc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be21b6791b4809e55d03d2e615a1d121cbfc3bdc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/561e8efb7d221cc2f9274f3756cdf4c30556ae4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/561e8efb7d221cc2f9274f3756cdf4c30556ae4b", "html_url": "https://github.com/rust-lang/rust/commit/561e8efb7d221cc2f9274f3756cdf4c30556ae4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/561e8efb7d221cc2f9274f3756cdf4c30556ae4b/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bcffdf1b6da161eecd761eb4a3ef703ff05c33f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcffdf1b6da161eecd761eb4a3ef703ff05c33f6", "html_url": "https://github.com/rust-lang/rust/commit/bcffdf1b6da161eecd761eb4a3ef703ff05c33f6"}], "stats": {"total": 104, "additions": 91, "deletions": 13}, "files": [{"sha": "62e5f730cae8271e9502fc11668045d564e30d99", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 72, "deletions": 13, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/561e8efb7d221cc2f9274f3756cdf4c30556ae4b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/561e8efb7d221cc2f9274f3756cdf4c30556ae4b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=561e8efb7d221cc2f9274f3756cdf4c30556ae4b", "patch": "@@ -19,6 +19,7 @@ pub use self::SelfTy::*;\n pub use self::FunctionRetTy::*;\n pub use self::Visibility::*;\n \n+use syntax;\n use syntax::abi::Abi;\n use syntax::ast::{self, AttrStyle};\n use syntax::attr;\n@@ -64,6 +65,7 @@ use std::u32;\n use core::{self, DocContext};\n use doctree;\n use visit_ast;\n+use html::render::{cache, ExternalLocation};\n use html::item_type::ItemType;\n use html::markdown::markdown_links;\n \n@@ -346,7 +348,7 @@ impl Item {\n     }\n \n     pub fn links(&self) -> Vec<(String, String)> {\n-        self.attrs.links()\n+        self.attrs.links(&self.def_id.krate)\n     }\n \n     pub fn is_crate(&self) -> bool {\n@@ -697,7 +699,7 @@ pub struct Attributes {\n     pub cfg: Option<Rc<Cfg>>,\n     pub span: Option<syntax_pos::Span>,\n     /// map from Rust paths to resolved defs and potential URL fragments\n-    pub links: Vec<(String, DefId, Option<String>)>,\n+    pub links: Vec<(String, Option<DefId>, Option<String>)>,\n }\n \n impl Attributes {\n@@ -869,17 +871,41 @@ impl Attributes {\n     /// Get links as a vector\n     ///\n     /// Cache must be populated before call\n-    pub fn links(&self) -> Vec<(String, String)> {\n+    pub fn links(&self, krate: &CrateNum) -> Vec<(String, String)> {\n         use html::format::href;\n         self.links.iter().filter_map(|&(ref s, did, ref fragment)| {\n-            if let Some((mut href, ..)) = href(did) {\n-                if let Some(ref fragment) = *fragment {\n-                    href.push_str(\"#\");\n-                    href.push_str(fragment);\n+            match did {\n+                Some(did) => {\n+                    if let Some((mut href, ..)) = href(did) {\n+                        if let Some(ref fragment) = *fragment {\n+                            href.push_str(\"#\");\n+                            href.push_str(fragment);\n+                        }\n+                        Some((s.clone(), href))\n+                    } else {\n+                        None\n+                    }\n+                }\n+                None => {\n+                    if let Some(ref fragment) = *fragment {\n+                        let cache = cache();\n+                        let url = match cache.extern_locations.get(krate) {\n+                            Some(&(_, ref src, ExternalLocation::Local)) =>\n+                                src.to_str().expect(\"invalid file path\"),\n+                            Some(&(_, _, ExternalLocation::Remote(ref s))) => s,\n+                            Some(&(_, _, ExternalLocation::Unknown)) | None =>\n+                                \"https://doc.rust-lang.org/nightly\",\n+                        };\n+                        // This is a primitive so the url is done \"by hand\".\n+                        Some((s.clone(),\n+                              format!(\"{}{}std/primitive.{}.html\",\n+                                      url,\n+                                      if !url.ends_with('/') { \"/\" } else { \"\" },\n+                                      fragment)))\n+                    } else {\n+                        panic!(\"This isn't a primitive?!\");\n+                    }\n                 }\n-                Some((s.clone(), href))\n-            } else {\n-                None\n             }\n         }).collect()\n     }\n@@ -959,6 +985,34 @@ fn handle_variant(cx: &DocContext, def: Def) -> Result<(Def, Option<String>), ()\n     Ok((parent_def, Some(format!(\"{}.v\", variant.name))))\n }\n \n+const PRIMITIVES: &[(&str, Def)] = &[\n+    (\"u8\",    Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::U8))),\n+    (\"u16\",   Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::U16))),\n+    (\"u32\",   Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::U32))),\n+    (\"u64\",   Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::U64))),\n+    (\"u128\",  Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::U128))),\n+    (\"usize\", Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::Usize))),\n+    (\"i8\",    Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::I8))),\n+    (\"i16\",   Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::I16))),\n+    (\"i32\",   Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::I32))),\n+    (\"i64\",   Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::I64))),\n+    (\"i128\",  Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::I128))),\n+    (\"isize\", Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::Isize))),\n+    (\"f32\",   Def::PrimTy(hir::PrimTy::TyFloat(syntax::ast::FloatTy::F32))),\n+    (\"f64\",   Def::PrimTy(hir::PrimTy::TyFloat(syntax::ast::FloatTy::F64))),\n+    (\"str\",   Def::PrimTy(hir::PrimTy::TyStr)),\n+    (\"bool\",  Def::PrimTy(hir::PrimTy::TyBool)),\n+    (\"char\",  Def::PrimTy(hir::PrimTy::TyChar)),\n+];\n+\n+fn is_primitive(path_str: &str, is_val: bool) -> Option<Def> {\n+    if is_val {\n+        None\n+    } else {\n+        PRIMITIVES.iter().find(|x| x.0 == path_str).map(|x| x.1)\n+    }\n+}\n+\n /// Resolve a given string as a path, along with whether or not it is\n /// in the value namespace. Also returns an optional URL fragment in the case\n /// of variants and methods\n@@ -987,6 +1041,8 @@ fn resolve(cx: &DocContext, path_str: &str, is_val: bool) -> Result<(Def, Option\n             if value != is_val {\n                 return Err(())\n             }\n+        } else if let Some(prim) = is_primitive(path_str, is_val) {\n+            return Ok((prim, Some(path_str.to_owned())))\n         } else {\n             // If resolution failed, it may still be a method\n             // because methods are not handled by the resolver\n@@ -1051,7 +1107,6 @@ fn resolve(cx: &DocContext, path_str: &str, is_val: bool) -> Result<(Def, Option\n             }\n             _ => Err(())\n         }\n-\n     } else {\n         Err(())\n     }\n@@ -1218,8 +1273,12 @@ impl Clean<Attributes> for [ast::Attribute] {\n                     }\n                 };\n \n-                let id = register_def(cx, def);\n-                attrs.links.push((ori_link, id, fragment));\n+                if let Def::PrimTy(_) = def {\n+                    attrs.links.push((ori_link, None, fragment));\n+                } else {\n+                    let id = register_def(cx, def);\n+                    attrs.links.push((ori_link, Some(id), fragment));\n+                }\n             }\n \n             cx.sess().abort_if_errors();"}, {"sha": "b0cf8acc7c0298105944b57cd787b92c3dc4b721", "filename": "src/test/rustdoc/primitive-link.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/561e8efb7d221cc2f9274f3756cdf4c30556ae4b/src%2Ftest%2Frustdoc%2Fprimitive-link.rs", "raw_url": "https://github.com/rust-lang/rust/raw/561e8efb7d221cc2f9274f3756cdf4c30556ae4b/src%2Ftest%2Frustdoc%2Fprimitive-link.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fprimitive-link.rs?ref=561e8efb7d221cc2f9274f3756cdf4c30556ae4b", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_name = \"foo\"]\n+\n+// ignore-tidy-linelength\n+\n+// @has foo/struct.Foo.html '//*[@class=\"docblock\"]/p/a[@href=\"https://doc.rust-lang.org/nightly/std/primitive.u32.html\"]' 'u32'\n+// @has foo/struct.Foo.html '//*[@class=\"docblock\"]/p/a[@href=\"https://doc.rust-lang.org/nightly/std/primitive.i64.html\"]' 'i64'\n+\n+/// It contains [`u32`] and [i64].\n+pub struct Foo;"}]}