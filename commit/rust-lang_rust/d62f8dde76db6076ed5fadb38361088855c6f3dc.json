{"sha": "d62f8dde76db6076ed5fadb38361088855c6f3dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2MmY4ZGRlNzZkYjYwNzZlZDVmYWRiMzgzNjEwODg4NTVjNmYzZGM=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-07-21T09:27:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-21T09:27:01Z"}, "message": "Rollup merge of #34919 - GuillaumeGomez:btree_map_doc, r=steveklabnik\n\nAdd doc for btree_map types\n\nPart of #29348.\n\nr? @steveklabnik", "tree": {"sha": "5852fed3790bedd49335b1d2a9f1a12d9e5bdd2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5852fed3790bedd49335b1d2a9f1a12d9e5bdd2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d62f8dde76db6076ed5fadb38361088855c6f3dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d62f8dde76db6076ed5fadb38361088855c6f3dc", "html_url": "https://github.com/rust-lang/rust/commit/d62f8dde76db6076ed5fadb38361088855c6f3dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d62f8dde76db6076ed5fadb38361088855c6f3dc/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27876c0a1c8eb980ff7d92807f0e7388827330f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/27876c0a1c8eb980ff7d92807f0e7388827330f5", "html_url": "https://github.com/rust-lang/rust/commit/27876c0a1c8eb980ff7d92807f0e7388827330f5"}, {"sha": "9b5db220c899fdd3656c8e28fc747808b8cab7c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b5db220c899fdd3656c8e28fc747808b8cab7c7", "html_url": "https://github.com/rust-lang/rust/commit/9b5db220c899fdd3656c8e28fc747808b8cab7c7"}], "stats": {"total": 191, "additions": 189, "deletions": 2}, "files": [{"sha": "c3a7d4023754aac97d45a0539a9cf0e4a8cfe490", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 189, "deletions": 2, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/d62f8dde76db6076ed5fadb38361088855c6f3dc/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d62f8dde76db6076ed5fadb38361088855c6f3dc/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=d62f8dde76db6076ed5fadb38361088855c6f3dc", "patch": "@@ -313,6 +313,10 @@ pub struct RangeMut<'a, K: 'a, V: 'a> {\n }\n \n /// A view into a single entry in a map, which may either be vacant or occupied.\n+/// This enum is constructed from the [`entry`] method on [`BTreeMap`].\n+///\n+/// [`BTreeMap`]: struct.BTreeMap.html\n+/// [`entry`]: struct.BTreeMap.html#method.entry\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Entry<'a, K: 'a, V: 'a> {\n     /// A vacant Entry\n@@ -340,7 +344,9 @@ impl<'a, K: 'a + Debug + Ord, V: 'a + Debug> Debug for Entry<'a, K, V> {\n     }\n }\n \n-/// A vacant Entry.\n+/// A vacant Entry. It is part of the [`Entry`] enum.\n+///\n+/// [`Entry`]: enum.Entry.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct VacantEntry<'a, K: 'a, V: 'a> {\n     key: K,\n@@ -360,7 +366,9 @@ impl<'a, K: 'a + Debug + Ord, V: 'a> Debug for VacantEntry<'a, K, V> {\n     }\n }\n \n-/// An occupied Entry.\n+/// An occupied Entry. It is part of the [`Entry`] enum.\n+///\n+/// [`Entry`]: enum.Entry.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n     handle: Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV>,\n@@ -1890,6 +1898,17 @@ impl<K, V> BTreeMap<K, V> {\n impl<'a, K: Ord, V> Entry<'a, K, V> {\n     /// Ensures a value is in the entry by inserting the default if empty, and returns\n     /// a mutable reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 12);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn or_insert(self, default: V) -> &'a mut V {\n         match self {\n@@ -1900,6 +1919,19 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n \n     /// Ensures a value is in the entry by inserting the result of the default function if empty,\n     /// and returns a mutable reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, String> = BTreeMap::new();\n+    /// let s = \"hoho\".to_owned();\n+    ///\n+    /// map.entry(\"poneyland\").or_insert_with(|| s);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], \"hoho\".to_owned());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {\n         match self {\n@@ -1909,6 +1941,15 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n     }\n \n     /// Returns a reference to this entry's key.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n+    /// ```\n     #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n     pub fn key(&self) -> &K {\n         match *self {\n@@ -1921,19 +1962,58 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n     /// Gets a reference to the key that would be used when inserting a value\n     /// through the VacantEntry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n+    /// ```\n     #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n     pub fn key(&self) -> &K {\n         &self.key\n     }\n \n     /// Take ownership of the key.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(map_entry_recover_keys)]\n+    ///\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    ///\n+    /// if let Entry::Vacant(v) = map.entry(\"poneyland\") {\n+    ///     v.into_key();\n+    /// }\n+    /// ```\n     #[unstable(feature = \"map_entry_recover_keys\", issue = \"34285\")]\n     pub fn into_key(self) -> K {\n         self.key\n     }\n \n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut count: BTreeMap<&str, usize> = BTreeMap::new();\n+    ///\n+    /// // count the number of occurrences of letters in the vec\n+    /// for x in vec![\"a\",\"b\",\"a\",\"c\",\"a\",\"b\"] {\n+    ///     *count.entry(x).or_insert(0) += 1;\n+    /// }\n+    ///\n+    /// assert_eq!(count[\"a\"], 3);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(self, value: V) -> &'a mut V {\n         *self.length += 1;\n@@ -1979,43 +2059,150 @@ impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n \n impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n     /// Gets a reference to the key in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n+    /// ```\n     #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n     pub fn key(&self) -> &K {\n         self.handle.reborrow().into_kv().0\n     }\n \n     /// Take ownership of the key and value from the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(map_entry_recover_keys)]\n+    ///\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     // We delete the entry from the map.\n+    ///     o.remove_pair();\n+    /// }\n+    ///\n+    /// // If now try to get the value, it will panic:\n+    /// // println!(\"{}\", map[\"poneyland\"]);\n+    /// ```\n     #[unstable(feature = \"map_entry_recover_keys\", issue = \"34285\")]\n     pub fn remove_pair(self) -> (K, V) {\n         self.remove_kv()\n     }\n \n     /// Gets a reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     assert_eq!(o.get(), &12);\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self) -> &V {\n         self.handle.reborrow().into_kv().1\n     }\n \n     /// Gets a mutable reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 12);\n+    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n+    ///      *o.get_mut() += 10;\n+    /// }\n+    /// assert_eq!(map[\"poneyland\"], 22);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self) -> &mut V {\n         self.handle.kv_mut().1\n     }\n \n     /// Converts the entry into a mutable reference to its value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 12);\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     *o.into_mut() += 10;\n+    /// }\n+    /// assert_eq!(map[\"poneyland\"], 22);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_mut(self) -> &'a mut V {\n         self.handle.into_kv_mut().1\n     }\n \n     /// Sets the value of the entry with the OccupiedEntry's key,\n     /// and returns the entry's old value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n+    ///     assert_eq!(o.insert(15), 12);\n+    /// }\n+    /// assert_eq!(map[\"poneyland\"], 15);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, value: V) -> V {\n         mem::replace(self.get_mut(), value)\n     }\n \n     /// Takes the value of the entry out of the map, and returns it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     assert_eq!(o.remove(), 12);\n+    /// }\n+    /// // If we try to get \"poneyland\"'s value, it'll panic:\n+    /// // println!(\"{}\", map[\"poneyland\"]);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(self) -> V {\n         self.remove_kv().1"}]}