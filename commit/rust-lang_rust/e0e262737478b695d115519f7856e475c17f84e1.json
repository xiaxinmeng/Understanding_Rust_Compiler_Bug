{"sha": "e0e262737478b695d115519f7856e475c17f84e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwZTI2MjczNzQ3OGI2OTVkMTE1NTE5Zjc4NTZlNDc1YzE3Zjg0ZTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-27T22:56:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-27T22:56:39Z"}, "message": "Auto merge of #29072 - nagisa:place-arrow, r=pnkfelix\n\nThis commit generalises parsing of associative operators from left-associative\r\nonly (with some ugly hacks to support right-associative assignment) to properly\r\nleft/right-associative operators.\r\n\r\nParsing is still is not general enough to handle non-associative,\r\nnon-highest-precedence prefix or non-highest-precedence\r\npostfix operators (e.g. `..` range syntax) and should be made to be.\r\n\r\nLastly, this commit adds support for parsing right-associative `<-` (left arrow)\r\noperator with precedence higher than assignment as the operator for placement-in\r\nfeature.\r\n\r\n---\r\n\r\nThis PR still needs various non-parser changes (e.g. src/grammar and tests) and I\u2019m still working on these; the meat of the PR can already be reviewed, though, I think.\r\n\r\nPlease review carefully. I made sure that quirks I have discovered so far are preserved (see e.g. https://github.com/rust-lang/rust/issues/29071) and am looking for more corner cases as I continue to work on tests et al, but there may be something I haven\u2019t noticed or accounted for.\r\n\r\nEDIT: I\u2019m also not sure I managed to preserve all the semantics with the range operator inside non-trivial expressions since these are a mess at the moment. Crater runs would be nice.", "tree": {"sha": "9005b7015d0b9311321259ad6d53134d5b33690e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9005b7015d0b9311321259ad6d53134d5b33690e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0e262737478b695d115519f7856e475c17f84e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0e262737478b695d115519f7856e475c17f84e1", "html_url": "https://github.com/rust-lang/rust/commit/e0e262737478b695d115519f7856e475c17f84e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0e262737478b695d115519f7856e475c17f84e1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a72584f977d2d72f752c2a540e160944159e8db", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a72584f977d2d72f752c2a540e160944159e8db", "html_url": "https://github.com/rust-lang/rust/commit/8a72584f977d2d72f752c2a540e160944159e8db"}, {"sha": "99f9bb16ab83519d67deaf4ca8a78feeba67fb53", "url": "https://api.github.com/repos/rust-lang/rust/commits/99f9bb16ab83519d67deaf4ca8a78feeba67fb53", "html_url": "https://github.com/rust-lang/rust/commit/99f9bb16ab83519d67deaf4ca8a78feeba67fb53"}], "stats": {"total": 748, "additions": 525, "deletions": 223}, "files": [{"sha": "a63fc59e50b07145a92b4a0ef9aac1d511dd8478", "filename": "src/grammar/RustLexer.g4", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0e262737478b695d115519f7856e475c17f84e1/src%2Fgrammar%2FRustLexer.g4", "raw_url": "https://github.com/rust-lang/rust/raw/e0e262737478b695d115519f7856e475c17f84e1/src%2Fgrammar%2FRustLexer.g4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2FRustLexer.g4?ref=e0e262737478b695d115519f7856e475c17f84e1", "patch": "@@ -10,7 +10,7 @@ lexer grammar RustLexer;\n tokens {\n     EQ, LT, LE, EQEQ, NE, GE, GT, ANDAND, OROR, NOT, TILDE, PLUS,\n     MINUS, STAR, SLASH, PERCENT, CARET, AND, OR, SHL, SHR, BINOP,\n-    BINOPEQ, AT, DOT, DOTDOT, DOTDOTDOT, COMMA, SEMI, COLON,\n+    BINOPEQ, LARROW, AT, DOT, DOTDOT, DOTDOTDOT, COMMA, SEMI, COLON,\n     MOD_SEP, RARROW, FAT_ARROW, LPAREN, RPAREN, LBRACKET, RBRACKET,\n     LBRACE, RBRACE, POUND, DOLLAR, UNDERSCORE, LIT_CHAR, LIT_BYTE,\n     LIT_INTEGER, LIT_FLOAT, LIT_STR, LIT_STR_RAW, LIT_BYTE_STR,\n@@ -44,6 +44,7 @@ AND     : '&' ;\n OR      : '|' ;\n SHL     : '<<' ;\n SHR     : '>>' ;\n+LARROW  : '<-' ;\n \n BINOP\n     : PLUS\n@@ -56,6 +57,7 @@ BINOP\n     | OR\n     | SHL\n     | SHR\n+    | LARROW\n     ;\n \n BINOPEQ : BINOP EQ ;"}, {"sha": "77737c99496f34757127d29e0040da0ff7f4fa56", "filename": "src/grammar/lexer.l", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0e262737478b695d115519f7856e475c17f84e1/src%2Fgrammar%2Flexer.l", "raw_url": "https://github.com/rust-lang/rust/raw/e0e262737478b695d115519f7856e475c17f84e1/src%2Fgrammar%2Flexer.l", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Flexer.l?ref=e0e262737478b695d115519f7856e475c17f84e1", "patch": "@@ -317,6 +317,7 @@ r/#             {\n <str>\\\\[^n\\nrt\\\\\\x27\\x220]  { return -1; }\n <str>(.|\\n)                 { yymore(); }\n \n+\\<-  { return LARROW; }\n -\\>  { return RARROW; }\n -    { return '-'; }\n -=   { return MINUSEQ; }"}, {"sha": "b310b2b3351c557d296307b0f203d4e8558219b0", "filename": "src/grammar/parser-lalr.y", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e0e262737478b695d115519f7856e475c17f84e1/src%2Fgrammar%2Fparser-lalr.y", "raw_url": "https://github.com/rust-lang/rust/raw/e0e262737478b695d115519f7856e475c17f84e1/src%2Fgrammar%2Fparser-lalr.y", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fparser-lalr.y?ref=e0e262737478b695d115519f7856e475c17f84e1", "patch": "@@ -45,6 +45,7 @@ extern char *yytext;\n %token DOTDOTDOT\n %token MOD_SEP\n %token RARROW\n+%token LARROW\n %token FAT_ARROW\n %token LIT_BYTE\n %token LIT_CHAR\n@@ -167,7 +168,8 @@ extern char *yytext;\n // prefix_exprs\n %precedence RETURN\n \n-%left '=' SHLEQ SHREQ MINUSEQ ANDEQ OREQ PLUSEQ STAREQ SLASHEQ CARETEQ PERCENTEQ\n+%right '=' SHLEQ SHREQ MINUSEQ ANDEQ OREQ PLUSEQ STAREQ SLASHEQ CARETEQ PERCENTEQ\n+%right LARROW\n %left OROR\n %left ANDAND\n %left EQEQ NE\n@@ -1316,6 +1318,7 @@ nonblock_expr\n | RETURN expr                                                   { $$ = mk_node(\"ExprRet\", 1, $2); }\n | BREAK                                                         { $$ = mk_node(\"ExprBreak\", 0); }\n | BREAK lifetime                                                { $$ = mk_node(\"ExprBreak\", 1, $2); }\n+| nonblock_expr LARROW expr                                     { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n | nonblock_expr '=' expr                                        { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n | nonblock_expr SHLEQ expr                                      { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n | nonblock_expr SHREQ expr                                      { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n@@ -1375,6 +1378,7 @@ expr\n | RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n | BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n | BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n+| expr LARROW expr                                    { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n | expr '=' expr                                       { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n | expr SHLEQ expr                                     { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n | expr SHREQ expr                                     { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n@@ -1435,6 +1439,7 @@ nonparen_expr\n | RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n | BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n | BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n+| nonparen_expr LARROW nonparen_expr                  { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n | nonparen_expr '=' nonparen_expr                     { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n | nonparen_expr SHLEQ nonparen_expr                   { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n | nonparen_expr SHREQ nonparen_expr                   { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n@@ -1495,6 +1500,7 @@ expr_nostruct\n | RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n | BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n | BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n+| expr_nostruct LARROW expr_nostruct                  { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n | expr_nostruct '=' expr_nostruct                     { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n | expr_nostruct SHLEQ expr_nostruct                   { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n | expr_nostruct SHREQ expr_nostruct                   { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n@@ -1794,6 +1800,7 @@ unpaired_token\n | GE                         { $$ = mk_atom(yytext); }\n | ANDAND                     { $$ = mk_atom(yytext); }\n | OROR                       { $$ = mk_atom(yytext); }\n+| LARROW                     { $$ = mk_atom(yytext); }\n | SHLEQ                      { $$ = mk_atom(yytext); }\n | SHREQ                      { $$ = mk_atom(yytext); }\n | MINUSEQ                    { $$ = mk_atom(yytext); }"}, {"sha": "fe9c5aaee4ce9bf69ddcdd7c3778c7b9e71e2173", "filename": "src/grammar/verify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0e262737478b695d115519f7856e475c17f84e1/src%2Fgrammar%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e262737478b695d115519f7856e475c17f84e1/src%2Fgrammar%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fverify.rs?ref=e0e262737478b695d115519f7856e475c17f84e1", "patch": "@@ -35,7 +35,7 @@ use syntax::parse::lexer::TokenAndSpan;\n \n fn parse_token_list(file: &str) -> HashMap<String, token::Token> {\n     fn id() -> token::Token {\n-        token::Ident(ast::Ident::with_empty_ctxt(Name(0))), token::Plain)\n+        token::Ident(ast::Ident::with_empty_ctxt(Name(0)), token::Plain)\n     }\n \n     let mut res = HashMap::new();\n@@ -208,7 +208,7 @@ fn parse_antlr_token(s: &str, tokens: &HashMap<String, token::Token>, surrogate_\n         token::Literal(token::ByteStr(..), n)    => token::Literal(token::ByteStr(nm), n),\n         token::Literal(token::ByteStrRaw(..), n) => token::Literal(token::ByteStrRaw(fix(content),\n                                                                                 count(content)), n),\n-        token::Ident(..)           => token::Ident(ast::Ident::with_empty_ctxt(nm)),\n+        token::Ident(..)           => token::Ident(ast::Ident::with_empty_ctxt(nm),\n                                                    token::ModName),\n         token::Lifetime(..)        => token::Lifetime(ast::Ident::with_empty_ctxt(nm)),\n         ref t => t.clone()"}, {"sha": "7f80763fb6ddabdd2be83736017fe05580138585", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0e262737478b695d115519f7856e475c17f84e1/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e262737478b695d115519f7856e475c17f84e1/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=e0e262737478b695d115519f7856e475c17f84e1", "patch": "@@ -369,6 +369,7 @@ impl EarlyLintPass for UnusedParens {\n             ast::ExprRet(Some(ref value)) => (value, \"`return` value\", false),\n             ast::ExprAssign(_, ref value) => (value, \"assigned value\", false),\n             ast::ExprAssignOp(_, _, ref value) => (value, \"assigned value\", false),\n+            ast::ExprInPlace(_, ref value) => (value, \"emplacement value\", false),\n             _ => return\n         };\n         self.check_unused_parens_core(cx, &**value, msg, struct_lit_needs_parens);"}, {"sha": "f1c88232fc45a4b3fad6f2646d5d5d28a48bb2ba", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e0e262737478b695d115519f7856e475c17f84e1/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e262737478b695d115519f7856e475c17f84e1/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=e0e262737478b695d115519f7856e475c17f84e1", "patch": "@@ -242,26 +242,6 @@ pub fn struct_field_visibility(field: ast::StructField) -> Visibility {\n     }\n }\n \n-/// Maps a binary operator to its precedence\n-pub fn operator_prec(op: ast::BinOp_) -> usize {\n-  match op {\n-      // 'as' sits here with 12\n-      BiMul | BiDiv | BiRem     => 11,\n-      BiAdd | BiSub             => 10,\n-      BiShl | BiShr             =>  9,\n-      BiBitAnd                  =>  8,\n-      BiBitXor                  =>  7,\n-      BiBitOr                   =>  6,\n-      BiLt | BiLe | BiGe | BiGt | BiEq | BiNe => 3,\n-      BiAnd                     =>  2,\n-      BiOr                      =>  1\n-  }\n-}\n-\n-/// Precedence of the `as` operator, which is a binary operator\n-/// not appearing in the prior table.\n-pub const AS_PREC: usize = 12;\n-\n pub fn empty_generics() -> Generics {\n     Generics {\n         lifetimes: Vec::new(),"}, {"sha": "406b763ca4654026b97a6167176df5c711e843d9", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0e262737478b695d115519f7856e475c17f84e1/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e262737478b695d115519f7856e475c17f84e1/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=e0e262737478b695d115519f7856e475c17f84e1", "patch": "@@ -66,6 +66,7 @@ pub mod util {\n     #[cfg(test)]\n     pub mod parser_testing;\n     pub mod small_vector;\n+    pub mod parser;\n }\n \n pub mod diagnostics {"}, {"sha": "6cee7b86a6106ddbab73e5dff1f3b52f583b85da", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 195, "deletions": 177, "changes": 372, "blob_url": "https://github.com/rust-lang/rust/blob/e0e262737478b695d115519f7856e475c17f84e1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e262737478b695d115519f7856e475c17f84e1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e0e262737478b695d115519f7856e475c17f84e1", "patch": "@@ -15,7 +15,7 @@ use ast::BareFnTy;\n use ast::{RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n use ast::{Public, Unsafety};\n use ast::{Mod, BiAdd, Arg, Arm, Attribute, BindByRef, BindByValue};\n-use ast::{BiBitAnd, BiBitOr, BiBitXor, BiRem, BiLt, BiGt, Block};\n+use ast::{BiBitAnd, BiBitOr, BiBitXor, BiRem, BiLt, Block};\n use ast::{BlockCheckMode, CaptureByRef, CaptureByValue, CaptureClause};\n use ast::{Constness, ConstImplItem, ConstTraitItem, Crate, CrateConfig};\n use ast::{Decl, DeclItem, DeclLocal, DefaultBlock, DefaultReturn};\n@@ -50,8 +50,7 @@ use ast::{BiSub, StrStyle};\n use ast::{SelfExplicit, SelfRegion, SelfStatic, SelfValue};\n use ast::{Delimited, SequenceRepetition, TokenTree, TraitItem, TraitRef};\n use ast::{TtDelimited, TtSequence, TtToken};\n-use ast::{Ty, Ty_, TypeBinding};\n-use ast::{TyMac};\n+use ast::{Ty, Ty_, TypeBinding, TyMac};\n use ast::{TyFixedLengthVec, TyBareFn, TyTypeof, TyInfer};\n use ast::{TyParam, TyParamBound, TyParen, TyPath, TyPolyTraitRef, TyPtr};\n use ast::{TyRptr, TyTup, TyU32, TyVec};\n@@ -60,7 +59,7 @@ use ast::{UnnamedField, UnsafeBlock};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause};\n use ast;\n-use ast_util::{self, AS_PREC, ident_to_path, operator_prec};\n+use ast_util::{self, ident_to_path};\n use codemap::{self, Span, BytePos, Spanned, spanned, mk_sp, CodeMap};\n use diagnostic;\n use ext::tt::macro_parser;\n@@ -73,6 +72,7 @@ use parse::obsolete::{ParserObsoleteMethods, ObsoleteSyntax};\n use parse::token::{self, MatchNt, SubstNt, SpecialVarNt, InternedString};\n use parse::token::{keywords, special_idents, SpecialMacroVar};\n use parse::{new_sub_parser_from_file, ParseSess};\n+use util::parser::{AssocOp, Fixity};\n use print::pprust;\n use ptr::P;\n use owned_slice::OwnedSlice;\n@@ -2597,117 +2597,189 @@ impl<'a> Parser<'a> {\n         Ok(tts)\n     }\n \n-    /// Parse a prefix-operator expr\n+    /// Parse a prefix-unary-operator expr\n     pub fn parse_prefix_expr(&mut self) -> PResult<P<Expr>> {\n         let lo = self.span.lo;\n         let hi;\n-\n         // Note: when adding new unary operators, don't forget to adjust Token::can_begin_expr()\n-        let ex;\n-        match self.token {\n-          token::Not => {\n-            try!(self.bump());\n-            let e = try!(self.parse_prefix_expr());\n-            hi = e.span.hi;\n-            ex = self.mk_unary(UnNot, e);\n-          }\n-          token::BinOp(token::Minus) => {\n-            try!(self.bump());\n-            let e = try!(self.parse_prefix_expr());\n-            hi = e.span.hi;\n-            ex = self.mk_unary(UnNeg, e);\n-          }\n-          token::BinOp(token::Star) => {\n-            try!(self.bump());\n-            let e = try!(self.parse_prefix_expr());\n-            hi = e.span.hi;\n-            ex = self.mk_unary(UnDeref, e);\n-          }\n-          token::BinOp(token::And) | token::AndAnd => {\n-            try!(self.expect_and());\n-            let m = try!(self.parse_mutability());\n-            let e = try!(self.parse_prefix_expr());\n-            hi = e.span.hi;\n-            ex = ExprAddrOf(m, e);\n-          }\n-          token::Ident(..) if self.token.is_keyword(keywords::In) => {\n-              try!(self.bump());\n-              let place = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n-              let blk = try!(self.parse_block());\n-              hi = blk.span.hi;\n-              let blk_expr = self.mk_expr(blk.span.lo, blk.span.hi, ExprBlock(blk));\n-              ex = ExprInPlace(place, blk_expr);\n-          }\n-          token::Ident(..) if self.token.is_keyword(keywords::Box) => {\n-              try!(self.bump());\n-              let subexpression = try!(self.parse_prefix_expr());\n-              hi = subexpression.span.hi;\n-              ex = ExprBox(subexpression);\n-          }\n-          _ => return self.parse_dot_or_call_expr()\n-        }\n+        let ex = match self.token {\n+            token::Not => {\n+                try!(self.bump());\n+                let e = try!(self.parse_prefix_expr());\n+                hi = e.span.hi;\n+                self.mk_unary(UnNot, e)\n+            }\n+            token::BinOp(token::Minus) => {\n+                try!(self.bump());\n+                let e = try!(self.parse_prefix_expr());\n+                hi = e.span.hi;\n+                self.mk_unary(UnNeg, e)\n+            }\n+            token::BinOp(token::Star) => {\n+                try!(self.bump());\n+                let e = try!(self.parse_prefix_expr());\n+                hi = e.span.hi;\n+                self.mk_unary(UnDeref, e)\n+            }\n+            token::BinOp(token::And) | token::AndAnd => {\n+                try!(self.expect_and());\n+                let m = try!(self.parse_mutability());\n+                let e = try!(self.parse_prefix_expr());\n+                hi = e.span.hi;\n+                ExprAddrOf(m, e)\n+            }\n+            token::Ident(..) if self.token.is_keyword(keywords::In) => {\n+                try!(self.bump());\n+                let place = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n+                let blk = try!(self.parse_block());\n+                let span = blk.span;\n+                hi = span.hi;\n+                let blk_expr = self.mk_expr(span.lo, span.hi, ExprBlock(blk));\n+                ExprInPlace(place, blk_expr)\n+            }\n+            token::Ident(..) if self.token.is_keyword(keywords::Box) => {\n+                try!(self.bump());\n+                let subexpression = try!(self.parse_prefix_expr());\n+                hi = subexpression.span.hi;\n+                ExprBox(subexpression)\n+            }\n+            _ => return self.parse_dot_or_call_expr()\n+        };\n         return Ok(self.mk_expr(lo, hi, ex));\n     }\n \n-    /// Parse an expression of binops\n-    pub fn parse_binops(&mut self) -> PResult<P<Expr>> {\n-        let prefix_expr = try!(self.parse_prefix_expr());\n-        self.parse_more_binops(prefix_expr, 0)\n-    }\n+    /// Parse an associative expression\n+    ///\n+    /// This parses an expression accounting for associativity and precedence of the operators in\n+    /// the expression.\n+    pub fn parse_assoc_expr(&mut self) -> PResult<P<Expr>> {\n+        self.parse_assoc_expr_with(0, None)\n+    }\n+\n+    /// Parse an associative expression with operators of at least `min_prec` precedence\n+    pub fn parse_assoc_expr_with(&mut self,\n+                                 min_prec: usize,\n+                                 lhs: Option<P<Expr>>)\n+                                 -> PResult<P<Expr>> {\n+        let mut lhs = if lhs.is_some() {\n+            lhs.unwrap()\n+        } else if self.token == token::DotDot {\n+            return self.parse_prefix_range_expr();\n+        } else {\n+            try!(self.parse_prefix_expr())\n+        };\n+        if self.expr_is_complete(&*lhs) {\n+            // Semi-statement forms are odd. See https://github.com/rust-lang/rust/issues/29071\n+            return Ok(lhs);\n+        }\n+        let cur_op_span = self.span;\n+        self.expected_tokens.push(TokenType::Operator);\n+        while let Some(op) = AssocOp::from_token(&self.token) {\n+            let restrictions = if op.is_assign_like() {\n+                self.restrictions & Restrictions::RESTRICTION_NO_STRUCT_LITERAL\n+            } else {\n+                self.restrictions\n+            };\n+            if op.precedence() < min_prec {\n+                break;\n+            }\n+            try!(self.bump());\n+            if op.is_comparison() {\n+                self.check_no_chained_comparison(&*lhs, &op);\n+            }\n+            // Special cases:\n+            if op == AssocOp::As {\n+                let rhs = try!(self.parse_ty_nopanic());\n+                lhs = self.mk_expr(lhs.span.lo, rhs.span.hi, ExprCast(lhs, rhs));\n+                continue\n+            } else if op == AssocOp::DotDot {\n+                    // If we didn\u2019t have to handle `x..`, it would be pretty easy to generalise\n+                    // it to the Fixity::None code.\n+                    //\n+                    // We have 2 alternatives here: `x..y` and `x..` The other two variants are\n+                    // handled with `parse_prefix_range_expr` call above.\n+                    let rhs = if self.is_at_start_of_range_notation_rhs() {\n+                        self.parse_assoc_expr_with(op.precedence() + 1, None).ok()\n+                    } else {\n+                        None\n+                    };\n+                    let (lhs_span, rhs_span) = (lhs.span, if let Some(ref x) = rhs {\n+                        x.span\n+                    } else {\n+                        cur_op_span\n+                    });\n+                    let r = self.mk_range(Some(lhs), rhs);\n+                    lhs = self.mk_expr(lhs_span.lo, rhs_span.hi, r);\n+                    break\n+            }\n \n-    /// Parse an expression of binops of at least min_prec precedence\n-    pub fn parse_more_binops(&mut self, lhs: P<Expr>, min_prec: usize) -> PResult<P<Expr>> {\n-        if self.expr_is_complete(&*lhs) { return Ok(lhs); }\n \n-        self.expected_tokens.push(TokenType::Operator);\n+            let rhs = try!(match op.fixity() {\n+                Fixity::Right => self.with_res(restrictions, |this|{\n+                    this.parse_assoc_expr_with(op.precedence(), None)\n+                }),\n+                Fixity::Left => self.with_res(restrictions, |this|{\n+                    this.parse_assoc_expr_with(op.precedence() + 1, None)\n+                }),\n+                // We currently have no non-associative operators that are not handled above by\n+                // the special cases. The code is here only for future convenience.\n+                Fixity::None => self.with_res(restrictions, |this|{\n+                    this.parse_assoc_expr_with(op.precedence() + 1, None)\n+                }),\n+            });\n \n-        let cur_op_span = self.span;\n-        let cur_opt = self.token.to_binop();\n-        match cur_opt {\n-            Some(cur_op) => {\n-                if ast_util::is_comparison_binop(cur_op) {\n-                    self.check_no_chained_comparison(&*lhs, cur_op)\n-                }\n-                let cur_prec = operator_prec(cur_op);\n-                if cur_prec >= min_prec {\n-                    try!(self.bump());\n-                    let expr = try!(self.parse_prefix_expr());\n-                    let rhs = try!(self.parse_more_binops(expr, cur_prec + 1));\n-                    let lhs_span = lhs.span;\n-                    let rhs_span = rhs.span;\n-                    let binary = self.mk_binary(codemap::respan(cur_op_span, cur_op), lhs, rhs);\n-                    let bin = self.mk_expr(lhs_span.lo, rhs_span.hi, binary);\n-                    self.parse_more_binops(bin, min_prec)\n-                } else {\n-                    Ok(lhs)\n+            lhs = match op {\n+                AssocOp::Add | AssocOp::Subtract | AssocOp::Multiply | AssocOp::Divide |\n+                AssocOp::Modulus | AssocOp::LAnd | AssocOp::LOr | AssocOp::BitXor |\n+                AssocOp::BitAnd | AssocOp::BitOr | AssocOp::ShiftLeft | AssocOp::ShiftRight |\n+                AssocOp::Equal | AssocOp::Less | AssocOp::LessEqual | AssocOp::NotEqual |\n+                AssocOp::Greater | AssocOp::GreaterEqual => {\n+                    let ast_op = op.to_ast_binop().unwrap();\n+                    let (lhs_span, rhs_span) = (lhs.span, rhs.span);\n+                    let binary = self.mk_binary(codemap::respan(cur_op_span, ast_op), lhs, rhs);\n+                    self.mk_expr(lhs_span.lo, rhs_span.hi, binary)\n                 }\n-            }\n-            None => {\n-                if AS_PREC >= min_prec && try!(self.eat_keyword_noexpect(keywords::As) ){\n-                    let rhs = try!(self.parse_ty_nopanic());\n-                    let _as = self.mk_expr(lhs.span.lo,\n-                                           rhs.span.hi,\n-                                           ExprCast(lhs, rhs));\n-                    self.parse_more_binops(_as, min_prec)\n-                } else {\n-                    Ok(lhs)\n+                AssocOp::Assign =>\n+                    self.mk_expr(lhs.span.lo, rhs.span.hi, ExprAssign(lhs, rhs)),\n+                AssocOp::Inplace =>\n+                    self.mk_expr(lhs.span.lo, rhs.span.hi, ExprInPlace(lhs, rhs)),\n+                AssocOp::AssignOp(k) => {\n+                    let aop = match k {\n+                        token::Plus =>    BiAdd,\n+                        token::Minus =>   BiSub,\n+                        token::Star =>    BiMul,\n+                        token::Slash =>   BiDiv,\n+                        token::Percent => BiRem,\n+                        token::Caret =>   BiBitXor,\n+                        token::And =>     BiBitAnd,\n+                        token::Or =>      BiBitOr,\n+                        token::Shl =>     BiShl,\n+                        token::Shr =>     BiShr\n+                    };\n+                    let (lhs_span, rhs_span) = (lhs.span, rhs.span);\n+                    let aopexpr = self.mk_assign_op(codemap::respan(cur_op_span, aop), lhs, rhs);\n+                    self.mk_expr(lhs_span.lo, rhs_span.hi, aopexpr)\n                 }\n-            }\n+                AssocOp::As | AssocOp::DotDot => self.bug(\"As or DotDot branch reached\")\n+            };\n+\n+            if op.fixity() == Fixity::None { break }\n         }\n+        Ok(lhs)\n     }\n \n     /// Produce an error if comparison operators are chained (RFC #558).\n     /// We only need to check lhs, not rhs, because all comparison ops\n     /// have same precedence and are left-associative\n-    fn check_no_chained_comparison(&mut self, lhs: &Expr, outer_op: ast::BinOp_) {\n-        debug_assert!(ast_util::is_comparison_binop(outer_op));\n+    fn check_no_chained_comparison(&mut self, lhs: &Expr, outer_op: &AssocOp) {\n+        debug_assert!(outer_op.is_comparison());\n         match lhs.node {\n             ExprBinary(op, _, _) if ast_util::is_comparison_binop(op.node) => {\n                 // respan to include both operators\n                 let op_span = mk_sp(op.span.lo, self.span.hi);\n                 self.span_err(op_span,\n                     \"chained comparison operators require parentheses\");\n-                if op.node == BiLt && outer_op == BiGt {\n+                if op.node == BiLt && *outer_op == AssocOp::Greater {\n                     self.fileline_help(op_span,\n                         \"use `::<...>` instead of `<...>` if you meant to specify type arguments\");\n                 }\n@@ -2716,86 +2788,24 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parse an assignment expression....\n-    /// actually, this seems to be the main entry point for\n-    /// parsing an arbitrary expression.\n-    pub fn parse_assign_expr(&mut self) -> PResult<P<Expr>> {\n-        match self.token {\n-          token::DotDot => {\n-            // prefix-form of range notation '..expr'\n-            // This has the same precedence as assignment expressions\n-            // (much lower than other prefix expressions) to be consistent\n-            // with the postfix-form 'expr..'\n-            let lo = self.span.lo;\n-            let mut hi = self.span.hi;\n-            try!(self.bump());\n-            let opt_end = if self.is_at_start_of_range_notation_rhs() {\n-                let end = try!(self.parse_binops());\n-                hi = end.span.hi;\n-                Some(end)\n-            } else {\n-                None\n-            };\n-            let ex = self.mk_range(None, opt_end);\n-            Ok(self.mk_expr(lo, hi, ex))\n-          }\n-          _ => {\n-            let lhs = try!(self.parse_binops());\n-            self.parse_assign_expr_with(lhs)\n-          }\n-        }\n-    }\n-\n-    pub fn parse_assign_expr_with(&mut self, lhs: P<Expr>) -> PResult<P<Expr>> {\n-        let restrictions = self.restrictions & Restrictions::RESTRICTION_NO_STRUCT_LITERAL;\n-        let op_span = self.span;\n-        match self.token {\n-          token::Eq => {\n-              try!(self.bump());\n-              let rhs = try!(self.parse_expr_res(restrictions));\n-              Ok(self.mk_expr(lhs.span.lo, rhs.span.hi, ExprAssign(lhs, rhs)))\n-          }\n-          token::BinOpEq(op) => {\n-              try!(self.bump());\n-              let rhs = try!(self.parse_expr_res(restrictions));\n-              let aop = match op {\n-                  token::Plus =>    BiAdd,\n-                  token::Minus =>   BiSub,\n-                  token::Star =>    BiMul,\n-                  token::Slash =>   BiDiv,\n-                  token::Percent => BiRem,\n-                  token::Caret =>   BiBitXor,\n-                  token::And =>     BiBitAnd,\n-                  token::Or =>      BiBitOr,\n-                  token::Shl =>     BiShl,\n-                  token::Shr =>     BiShr\n-              };\n-              let rhs_span = rhs.span;\n-              let span = lhs.span;\n-              let assign_op = self.mk_assign_op(codemap::respan(op_span, aop), lhs, rhs);\n-              Ok(self.mk_expr(span.lo, rhs_span.hi, assign_op))\n-          }\n-          // A range expression, either `expr..expr` or `expr..`.\n-          token::DotDot => {\n-            let lo = lhs.span.lo;\n-            let mut hi = self.span.hi;\n-            try!(self.bump());\n-\n-            let opt_end = if self.is_at_start_of_range_notation_rhs() {\n-                let end = try!(self.parse_binops());\n-                hi = end.span.hi;\n-                Some(end)\n-            } else {\n-                None\n-            };\n-            let range = self.mk_range(Some(lhs), opt_end);\n-            return Ok(self.mk_expr(lo, hi, range));\n-          }\n-\n-          _ => {\n-              Ok(lhs)\n-          }\n-        }\n+    /// Parse prefix-forms of range notation: `..expr` and `..`\n+    fn parse_prefix_range_expr(&mut self) -> PResult<P<Expr>> {\n+        debug_assert!(self.token == token::DotDot);\n+        let lo = self.span.lo;\n+        let mut hi = self.span.hi;\n+        try!(self.bump());\n+        let opt_end = if self.is_at_start_of_range_notation_rhs() {\n+            // RHS must be parsed with more associativity than DotDot.\n+            let next_prec = AssocOp::from_token(&token::DotDot).unwrap().precedence() + 1;\n+            Some(try!(self.parse_assoc_expr_with(next_prec, None).map(|x|{\n+                hi = x.span.hi;\n+                x\n+            })))\n+         } else {\n+            None\n+        };\n+        let r = self.mk_range(None, opt_end);\n+        Ok(self.mk_expr(lo, hi, r))\n     }\n \n     fn is_at_start_of_range_notation_rhs(&self) -> bool {\n@@ -2978,13 +2988,22 @@ impl<'a> Parser<'a> {\n         self.parse_expr_res(Restrictions::empty())\n     }\n \n-    /// Parse an expression, subject to the given restrictions\n-    pub fn parse_expr_res(&mut self, r: Restrictions) -> PResult<P<Expr>> {\n+    /// Evaluate the closure with restrictions in place.\n+    ///\n+    /// After the closure is evaluated, restrictions are reset.\n+    pub fn with_res<F>(&mut self, r: Restrictions, f: F) -> PResult<P<Expr>>\n+    where F: FnOnce(&mut Self) -> PResult<P<Expr>> {\n         let old = self.restrictions;\n         self.restrictions = r;\n-        let e = try!(self.parse_assign_expr());\n+        let r = f(self);\n         self.restrictions = old;\n-        return Ok(e);\n+        return r;\n+\n+    }\n+\n+    /// Parse an expression, subject to the given restrictions\n+    pub fn parse_expr_res(&mut self, r: Restrictions) -> PResult<P<Expr>> {\n+        self.with_res(r, |this| this.parse_assoc_expr())\n     }\n \n     /// Parse the RHS of a local variable declaration (e.g. '= 14;')\n@@ -3624,8 +3643,7 @@ impl<'a> Parser<'a> {\n                             let e = self.mk_mac_expr(span.lo, span.hi,\n                                                      mac.and_then(|m| m.node));\n                             let e = try!(self.parse_dot_or_call_expr_with(e));\n-                            let e = try!(self.parse_more_binops(e, 0));\n-                            let e = try!(self.parse_assign_expr_with(e));\n+                            let e = try!(self.parse_assoc_expr_with(0, Some(e)));\n                             try!(self.handle_expression_like_statement(\n                                 e,\n                                 span,"}, {"sha": "0bdbf132cb8d2cff822e07f6e9fb847057a6fb93", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e0e262737478b695d115519f7856e475c17f84e1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e262737478b695d115519f7856e475c17f84e1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e0e262737478b695d115519f7856e475c17f84e1", "patch": "@@ -14,6 +14,7 @@ use abi;\n use ast;\n use ast::{RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n use ast_util;\n+use util::parser::AssocOp;\n use attr;\n use owned_slice::OwnedSlice;\n use attr::{AttrMetaMethods, AttributeMethods};\n@@ -445,7 +446,8 @@ fn needs_parentheses(expr: &ast::Expr) -> bool {\n     match expr.node {\n         ast::ExprAssign(..) | ast::ExprBinary(..) |\n         ast::ExprClosure(..) |\n-        ast::ExprAssignOp(..) | ast::ExprCast(..) => true,\n+        ast::ExprAssignOp(..) | ast::ExprCast(..) |\n+        ast::ExprInPlace(..) => true,\n         _ => false,\n     }\n }\n@@ -1776,8 +1778,8 @@ impl<'a> State<'a> {\n                                       binop: ast::BinOp) -> bool {\n         match sub_expr.node {\n             ast::ExprBinary(ref sub_op, _, _) => {\n-                if ast_util::operator_prec(sub_op.node) <\n-                    ast_util::operator_prec(binop.node) {\n+                if AssocOp::from_ast_binop(sub_op.node).precedence() <\n+                    AssocOp::from_ast_binop(binop.node).precedence() {\n                     true\n                 } else {\n                     false\n@@ -1802,10 +1804,10 @@ impl<'a> State<'a> {\n     fn print_expr_in_place(&mut self,\n                            place: &ast::Expr,\n                            expr: &ast::Expr) -> io::Result<()> {\n-        try!(self.word_space(\"in\"));\n-        try!(self.print_expr(place));\n+        try!(self.print_expr_maybe_paren(place));\n         try!(space(&mut self.s));\n-        self.print_expr(expr)\n+        try!(self.word_space(\"<-\"));\n+        self.print_expr_maybe_paren(expr)\n     }\n \n     fn print_expr_vec(&mut self, exprs: &[P<ast::Expr>]) -> io::Result<()> {"}, {"sha": "bf3a8def39011bc243c8e7f239e55b72ec80b33a", "filename": "src/libsyntax/util/parser.rs", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/e0e262737478b695d115519f7856e475c17f84e1/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e262737478b695d115519f7856e475c17f84e1/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=e0e262737478b695d115519f7856e475c17f84e1", "patch": "@@ -0,0 +1,210 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+use parse::token::{Token, BinOpToken, keywords};\n+use ast;\n+\n+/// Associative operator with precedence.\n+///\n+/// This is the enum which specifies operator precedence and fixity to the parser.\n+#[derive(Debug, PartialEq, Eq)]\n+pub enum AssocOp {\n+    /// `+`\n+    Add,\n+    /// `-`\n+    Subtract,\n+    /// `*`\n+    Multiply,\n+    /// `/`\n+    Divide,\n+    /// `%`\n+    Modulus,\n+    /// `&&`\n+    LAnd,\n+    /// `||`\n+    LOr,\n+    /// `^`\n+    BitXor,\n+    /// `&`\n+    BitAnd,\n+    /// `|`\n+    BitOr,\n+    /// `<<`\n+    ShiftLeft,\n+    /// `>>`\n+    ShiftRight,\n+    /// `==`\n+    Equal,\n+    /// `<`\n+    Less,\n+    /// `<=`\n+    LessEqual,\n+    /// `!=`\n+    NotEqual,\n+    /// `>`\n+    Greater,\n+    /// `>=`\n+    GreaterEqual,\n+    /// `=`\n+    Assign,\n+    /// `<-`\n+    Inplace,\n+    /// `?=` where ? is one of the BinOpToken\n+    AssignOp(BinOpToken),\n+    /// `as`\n+    As,\n+    /// `..` range\n+    DotDot\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub enum Fixity {\n+    /// The operator is left-associative\n+    Left,\n+    /// The operator is right-associative\n+    Right,\n+    /// The operator is not associative\n+    None\n+}\n+\n+impl AssocOp {\n+    /// Create a new AssocOP from a token\n+    pub fn from_token(t: &Token) -> Option<AssocOp> {\n+        use self::AssocOp::*;\n+        match *t {\n+            Token::BinOpEq(k) => Some(AssignOp(k)),\n+            Token::LArrow => Some(Inplace),\n+            Token::Eq => Some(Assign),\n+            Token::BinOp(BinOpToken::Star) => Some(Multiply),\n+            Token::BinOp(BinOpToken::Slash) => Some(Divide),\n+            Token::BinOp(BinOpToken::Percent) => Some(Modulus),\n+            Token::BinOp(BinOpToken::Plus) => Some(Add),\n+            Token::BinOp(BinOpToken::Minus) => Some(Subtract),\n+            Token::BinOp(BinOpToken::Shl) => Some(ShiftLeft),\n+            Token::BinOp(BinOpToken::Shr) => Some(ShiftRight),\n+            Token::BinOp(BinOpToken::And) => Some(BitAnd),\n+            Token::BinOp(BinOpToken::Caret) => Some(BitXor),\n+            Token::BinOp(BinOpToken::Or) => Some(BitOr),\n+            Token::Lt => Some(Less),\n+            Token::Le => Some(LessEqual),\n+            Token::Ge => Some(GreaterEqual),\n+            Token::Gt => Some(Greater),\n+            Token::EqEq => Some(Equal),\n+            Token::Ne => Some(NotEqual),\n+            Token::AndAnd => Some(LAnd),\n+            Token::OrOr => Some(LOr),\n+            Token::DotDot => Some(DotDot),\n+            _ if t.is_keyword(keywords::As) => Some(As),\n+            _ => None\n+        }\n+    }\n+\n+    /// Create a new AssocOp from ast::BinOp_.\n+    pub fn from_ast_binop(op: ast::BinOp_) -> Self {\n+        use self::AssocOp::*;\n+        match op {\n+            ast::BiLt => Less,\n+            ast::BiGt => Greater,\n+            ast::BiLe => LessEqual,\n+            ast::BiGe => GreaterEqual,\n+            ast::BiEq => Equal,\n+            ast::BiNe => NotEqual,\n+            ast::BiMul => Multiply,\n+            ast::BiDiv => Divide,\n+            ast::BiRem => Modulus,\n+            ast::BiAdd => Add,\n+            ast::BiSub => Subtract,\n+            ast::BiShl => ShiftLeft,\n+            ast::BiShr => ShiftRight,\n+            ast::BiBitAnd => BitAnd,\n+            ast::BiBitXor => BitXor,\n+            ast::BiBitOr => BitOr,\n+            ast::BiAnd => LAnd,\n+            ast::BiOr => LOr\n+        }\n+    }\n+\n+    /// Gets the precedence of this operator\n+    pub fn precedence(&self) -> usize {\n+        use self::AssocOp::*;\n+        match *self {\n+            As => 14,\n+            Multiply | Divide | Modulus => 13,\n+            Add | Subtract => 12,\n+            ShiftLeft | ShiftRight => 11,\n+            BitAnd => 10,\n+            BitXor => 9,\n+            BitOr => 8,\n+            Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual => 7,\n+            LAnd => 6,\n+            LOr => 5,\n+            DotDot => 4,\n+            Inplace => 3,\n+            Assign | AssignOp(_) => 2,\n+        }\n+    }\n+\n+    /// Gets the fixity of this operator\n+    pub fn fixity(&self) -> Fixity {\n+        use self::AssocOp::*;\n+        // NOTE: it is a bug to have an operators that has same precedence but different fixities!\n+        match *self {\n+            Inplace | Assign | AssignOp(_) => Fixity::Right,\n+            As | Multiply | Divide | Modulus | Add | Subtract | ShiftLeft | ShiftRight | BitAnd |\n+            BitXor | BitOr | Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual |\n+            LAnd | LOr => Fixity::Left,\n+            DotDot => Fixity::None\n+        }\n+    }\n+\n+    pub fn is_comparison(&self) -> bool {\n+        use self::AssocOp::*;\n+        match *self {\n+            Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual => true,\n+            Inplace | Assign | AssignOp(_) | As | Multiply | Divide | Modulus | Add | Subtract |\n+            ShiftLeft | ShiftRight | BitAnd | BitXor | BitOr | LAnd | LOr | DotDot => false\n+        }\n+    }\n+\n+    pub fn is_assign_like(&self) -> bool {\n+        use self::AssocOp::*;\n+        match *self {\n+            Assign | AssignOp(_) | Inplace => true,\n+            Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual | As | Multiply | Divide |\n+            Modulus | Add | Subtract | ShiftLeft | ShiftRight | BitAnd | BitXor | BitOr | LAnd |\n+            LOr | DotDot => false\n+        }\n+    }\n+\n+    pub fn to_ast_binop(&self) -> Option<ast::BinOp_> {\n+        use self::AssocOp::*;\n+        match *self {\n+            Less => Some(ast::BiLt),\n+            Greater => Some(ast::BiGt),\n+            LessEqual => Some(ast::BiLe),\n+            GreaterEqual => Some(ast::BiGe),\n+            Equal => Some(ast::BiEq),\n+            NotEqual => Some(ast::BiNe),\n+            Multiply => Some(ast::BiMul),\n+            Divide => Some(ast::BiDiv),\n+            Modulus => Some(ast::BiRem),\n+            Add => Some(ast::BiAdd),\n+            Subtract => Some(ast::BiSub),\n+            ShiftLeft => Some(ast::BiShl),\n+            ShiftRight => Some(ast::BiShr),\n+            BitAnd => Some(ast::BiBitAnd),\n+            BitXor => Some(ast::BiBitXor),\n+            BitOr => Some(ast::BiBitOr),\n+            LAnd => Some(ast::BiAnd),\n+            LOr => Some(ast::BiOr),\n+            Inplace | Assign | AssignOp(_) | As | DotDot => None\n+        }\n+    }\n+\n+}"}, {"sha": "080364c08554f98cb1b055922dbda9f9af141d0e", "filename": "src/test/compile-fail/feature-gate-placement-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e262737478b695d115519f7856e475c17f84e1/src%2Ftest%2Fcompile-fail%2Ffeature-gate-placement-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e262737478b695d115519f7856e475c17f84e1/src%2Ftest%2Fcompile-fail%2Ffeature-gate-placement-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-placement-expr.rs?ref=e0e262737478b695d115519f7856e475c17f84e1", "patch": "@@ -19,6 +19,6 @@\n fn main() {\n     use std::boxed::HEAP;\n \n-    let x = in HEAP { 'c' }; //~ ERROR placement-in expression syntax is experimental\n+    let x = HEAP <- 'c'; //~ ERROR placement-in expression syntax is experimental\n     println!(\"x: {}\", x);\n }"}, {"sha": "8cbec549dda96fc9384a49966235fdf972760f51", "filename": "src/test/compile-fail/issue-14084.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e262737478b695d115519f7856e475c17f84e1/src%2Ftest%2Fcompile-fail%2Fissue-14084.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e262737478b695d115519f7856e475c17f84e1/src%2Ftest%2Fcompile-fail%2Fissue-14084.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14084.rs?ref=e0e262737478b695d115519f7856e475c17f84e1", "patch": "@@ -12,6 +12,6 @@\n #![feature(placement_in_syntax)]\n \n fn main() {\n-    in () { 0 };\n+    () <- 0;\n     //~^ ERROR: the trait `core::ops::Placer<_>` is not implemented\n }"}, {"sha": "bf6f4c52f1f9ca15f2662bc646076a0da02dfd38", "filename": "src/test/compile-fail/placement-expr-unsafe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0e262737478b695d115519f7856e475c17f84e1/src%2Ftest%2Fcompile-fail%2Fplacement-expr-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e262737478b695d115519f7856e475c17f84e1/src%2Ftest%2Fcompile-fail%2Fplacement-expr-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fplacement-expr-unsafe.rs?ref=e0e262737478b695d115519f7856e475c17f84e1", "patch": "@@ -17,8 +17,8 @@ fn main() {\n     use std::boxed::HEAP;\n \n     let p: *const i32 = &42;\n-    let _ = in HEAP { *p }; //~ ERROR requires unsafe\n+    let _ = HEAP <- *p; //~ ERROR requires unsafe\n \n     let p: *const _ = &HEAP;\n-    let _ = in *p { 42 }; //~ ERROR requires unsafe\n+    let _ = *p <- 42; //~ ERROR requires unsafe\n }"}, {"sha": "23fc8e7a07e23059568ab2caef8b976918b9c97b", "filename": "src/test/compile-fail/placement-expr-unstable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e262737478b695d115519f7856e475c17f84e1/src%2Ftest%2Fcompile-fail%2Fplacement-expr-unstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e262737478b695d115519f7856e475c17f84e1/src%2Ftest%2Fcompile-fail%2Fplacement-expr-unstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fplacement-expr-unstable.rs?ref=e0e262737478b695d115519f7856e475c17f84e1", "patch": "@@ -18,7 +18,7 @@ extern crate core;\n fn main() {\n     use std::boxed::HEAP; //~ ERROR use of unstable library feature\n \n-    let _ = in HEAP { //~ ERROR use of unstable library feature\n+    let _ = HEAP <- { //~ ERROR use of unstable library feature\n         ::core::raw::Slice { //~ ERROR use of unstable library feature\n             data: &42, //~ ERROR use of unstable library feature\n             len: 1 //~ ERROR use of unstable library feature"}, {"sha": "5c0c47de58aed71c916bb1ccd0d9bbedb048e2b3", "filename": "src/test/parse-fail/assoc-oddities-1.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e0e262737478b695d115519f7856e475c17f84e1/src%2Ftest%2Fparse-fail%2Fassoc-oddities-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e262737478b695d115519f7856e475c17f84e1/src%2Ftest%2Fparse-fail%2Fassoc-oddities-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fassoc-oddities-1.rs?ref=e0e262737478b695d115519f7856e475c17f84e1", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+fn that_odd_parse() {\n+    // following lines below parse and must not fail\n+    x = if c { a } else { b }();\n+    x <- if c { a } else { b }[n];\n+    x = if true { 1 } else { 0 } as *mut _;\n+    // however this does not parse and probably should fail to retain compat?\n+    // NB: `..` here is arbitrary, failure happens/should happen \u2200ops that aren\u2019t `=` or `<-`\n+    // see assoc-oddities-2 and assoc-oddities-3\n+    ..if c { a } else { b }[n]; //~ ERROR expected one of\n+}"}, {"sha": "5679328edc998eaba0b340989524b70cc789068b", "filename": "src/test/parse-fail/assoc-oddities-2.rs", "status": "renamed", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e0e262737478b695d115519f7856e475c17f84e1/src%2Ftest%2Fparse-fail%2Fassoc-oddities-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e262737478b695d115519f7856e475c17f84e1/src%2Ftest%2Fparse-fail%2Fassoc-oddities-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fassoc-oddities-2.rs?ref=e0e262737478b695d115519f7856e475c17f84e1", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,7 @@\n \n // compile-flags: -Z parse-only\n \n-fn removed_moves() {\n-    let mut x = 0;\n-    let y <- x;\n-    //~^ ERROR expected one of `:`, `;`, `=`, or `@`, found `<-`\n+fn that_odd_parse() {\n+    // see assoc-oddities-1 for explanation\n+    x..if c { a } else { b }[n]; //~ ERROR expected one of\n }", "previous_filename": "src/test/parse-fail/removed-syntax-larrow-init.rs"}, {"sha": "0d4f21f0dca260e8858f28bd4e3db7a44ac479ff", "filename": "src/test/parse-fail/assoc-oddities-3.rs", "status": "renamed", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0e262737478b695d115519f7856e475c17f84e1/src%2Ftest%2Fparse-fail%2Fassoc-oddities-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e262737478b695d115519f7856e475c17f84e1/src%2Ftest%2Fparse-fail%2Fassoc-oddities-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fassoc-oddities-3.rs?ref=e0e262737478b695d115519f7856e475c17f84e1", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,9 +10,7 @@\n \n // compile-flags: -Z parse-only\n \n-fn removed_moves() {\n-    let mut x = 0;\n-    let y = 0;\n-    y <- x;\n-    //~^ ERROR expected one of `!`, `.`, `::`, `;`, `{`, `}`, or an operator, found `<-`\n+fn that_odd_parse() {\n+    // see assoc-oddities-1 for explanation\n+    x + if c { a } else { b }[n]; //~ ERROR expected one of\n }", "previous_filename": "src/test/parse-fail/removed-syntax-larrow-move.rs"}, {"sha": "8e69c063f99a01812a44f10837c2fe113cfbc8fb", "filename": "src/test/run-pass/issue-29071-2.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e0e262737478b695d115519f7856e475c17f84e1/src%2Ftest%2Frun-pass%2Fissue-29071-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e262737478b695d115519f7856e475c17f84e1/src%2Ftest%2Frun-pass%2Fissue-29071-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-29071-2.rs?ref=e0e262737478b695d115519f7856e475c17f84e1", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn t1() -> u32 {\n+    let x;\n+    x = if true { [1, 2, 3] } else { [2, 3, 4] }[0];\n+    x\n+}\n+\n+fn t2() -> [u32; 1] {\n+    if true { [1, 2, 3]; } else { [2, 3, 4]; }\n+    [0]\n+}\n+\n+fn t3() -> u32 {\n+    let x;\n+    x = if true { i1 as F } else { i2 as F }();\n+    x\n+}\n+\n+fn t4() -> () {\n+    if true { i1 as F; } else { i2 as F; }\n+    ()\n+}\n+\n+type F = fn() -> u32;\n+fn i1() -> u32 { 1 }\n+fn i2() -> u32 { 2 }\n+\n+fn main() {\n+    assert_eq!(t1(), 1);\n+    assert_eq!(t3(), 1);\n+}"}, {"sha": "09c17a85ab50bcc2f99b3435f59d871ce0ee28ae", "filename": "src/test/run-pass/issue-29071.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e0e262737478b695d115519f7856e475c17f84e1/src%2Ftest%2Frun-pass%2Fissue-29071.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e262737478b695d115519f7856e475c17f84e1/src%2Ftest%2Frun-pass%2Fissue-29071.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-29071.rs?ref=e0e262737478b695d115519f7856e475c17f84e1", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+fn ret() -> u32 {\n+    static x: u32 = 10;\n+    x & if true { 10u32 } else { 20u32 } & x\n+}\n+\n+fn ret2() -> &'static u32 {\n+    static x: u32 = 10;\n+    if true { 10u32; } else { 20u32; }\n+    &x\n+}\n+\n+fn main() {}"}]}