{"sha": "a39912cfbbd682270b5f3d534bc69eedfaa73a7b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzOTkxMmNmYmJkNjgyMjcwYjVmM2Q1MzRiYzY5ZWVkZmFhNzNhN2I=", "commit": {"author": {"name": "xFrednet", "email": "xFrednet@gmail.com", "date": "2021-02-20T12:12:30Z"}, "committer": {"name": "xFrednet", "email": "xFrednet@gmail.com", "date": "2021-05-05T16:35:33Z"}, "message": "Metadata collection: Some refactoring for readability", "tree": {"sha": "289b2bfa81c700cf3a10c454c9f2904e615cc8fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/289b2bfa81c700cf3a10c454c9f2904e615cc8fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a39912cfbbd682270b5f3d534bc69eedfaa73a7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a39912cfbbd682270b5f3d534bc69eedfaa73a7b", "html_url": "https://github.com/rust-lang/rust/commit/a39912cfbbd682270b5f3d534bc69eedfaa73a7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a39912cfbbd682270b5f3d534bc69eedfaa73a7b/comments", "author": {"login": "xFrednet", "id": 17087237, "node_id": "MDQ6VXNlcjE3MDg3MjM3", "avatar_url": "https://avatars.githubusercontent.com/u/17087237?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xFrednet", "html_url": "https://github.com/xFrednet", "followers_url": "https://api.github.com/users/xFrednet/followers", "following_url": "https://api.github.com/users/xFrednet/following{/other_user}", "gists_url": "https://api.github.com/users/xFrednet/gists{/gist_id}", "starred_url": "https://api.github.com/users/xFrednet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xFrednet/subscriptions", "organizations_url": "https://api.github.com/users/xFrednet/orgs", "repos_url": "https://api.github.com/users/xFrednet/repos", "events_url": "https://api.github.com/users/xFrednet/events{/privacy}", "received_events_url": "https://api.github.com/users/xFrednet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xFrednet", "id": 17087237, "node_id": "MDQ6VXNlcjE3MDg3MjM3", "avatar_url": "https://avatars.githubusercontent.com/u/17087237?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xFrednet", "html_url": "https://github.com/xFrednet", "followers_url": "https://api.github.com/users/xFrednet/followers", "following_url": "https://api.github.com/users/xFrednet/following{/other_user}", "gists_url": "https://api.github.com/users/xFrednet/gists{/gist_id}", "starred_url": "https://api.github.com/users/xFrednet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xFrednet/subscriptions", "organizations_url": "https://api.github.com/users/xFrednet/orgs", "repos_url": "https://api.github.com/users/xFrednet/repos", "events_url": "https://api.github.com/users/xFrednet/events{/privacy}", "received_events_url": "https://api.github.com/users/xFrednet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee130d066d362118cd0bf756de42ee08a2bfc301", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee130d066d362118cd0bf756de42ee08a2bfc301", "html_url": "https://github.com/rust-lang/rust/commit/ee130d066d362118cd0bf756de42ee08a2bfc301"}], "stats": {"total": 108, "additions": 57, "deletions": 51}, "files": [{"sha": "de94e47047b47918f5fc80002e294e2bc954d2f4", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 53, "deletions": 51, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/a39912cfbbd682270b5f3d534bc69eedfaa73a7b/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39912cfbbd682270b5f3d534bc69eedfaa73a7b/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=a39912cfbbd682270b5f3d534bc69eedfaa73a7b", "patch": "@@ -37,8 +37,8 @@ use std::path::Path;\n \n use crate::utils::internal_lints::is_lint_ref_type;\n use crate::utils::{\n-    get_enclosing_body, get_parent_expr_for_hir, last_path_segment, match_function_call, match_qpath, match_type,\n-    path_to_local_id, paths, span_lint, walk_ptrs_ty_depth, get_parent_expr\n+    get_enclosing_body, get_parent_expr, get_parent_expr_for_hir, last_path_segment, match_function_call, match_qpath,\n+    match_type, path_to_local_id, paths, span_lint, walk_ptrs_ty_depth,\n };\n \n /// This is the output file of the lint collector.\n@@ -202,39 +202,19 @@ impl<'tcx> LateLintPass<'tcx> for MetadataCollector {\n     /// ```\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if_chain! {\n+            // item validation\n             if let ItemKind::Static(ref ty, Mutability::Not, body_id) = item.kind;\n             if is_lint_ref_type(cx, ty);\n             let expr = &cx.tcx.hir().body(body_id).value;\n             if let ExprKind::AddrOf(_, _, ref inner_exp) = expr.kind;\n             if let ExprKind::Struct(_, _, _) = inner_exp.kind;\n+            // blacklist check\n+            let lint_name = sym_to_string(item.ident.name).to_ascii_lowercase();\n+            if !BLACK_LISTED_LINTS.contains(&lint_name.as_str());\n+            // metadata extraction\n+            if let Some(group) = get_lint_group_or_lint(cx, &lint_name, item);\n+            if let Some(docs) = extract_attr_docs_or_lint(cx, item);\n             then {\n-                let lint_name = sym_to_string(item.ident.name).to_ascii_lowercase();\n-                if BLACK_LISTED_LINTS.contains(&lint_name.as_str()) {\n-                    return;\n-                }\n-\n-                let group: String;\n-                let result = cx.lint_store.check_lint_name(lint_name.as_str(), Some(sym::clippy));\n-                if let CheckLintNameResult::Tool(Ok(lint_lst)) = result {\n-                    if let Some(group_some) = get_lint_group(cx, lint_lst[0]) {\n-                        group = group_some;\n-                    } else {\n-                        lint_collection_error_item(cx, item, \"Unable to determine lint group\");\n-                        return;\n-                    }\n-                } else {\n-                    lint_collection_error_item(cx, item, \"Unable to find lint in lint_store\");\n-                    return;\n-                }\n-\n-                let docs: String;\n-                if let Some(docs_some) = extract_attr_docs(item) {\n-                    docs = docs_some;\n-                } else {\n-                    lint_collection_error_item(cx, item, \"could not collect the lint documentation\");\n-                    return;\n-                };\n-\n                 self.lints.push(LintMetadata::new(\n                     lint_name,\n                     SerializableSpan::from_item(cx, item),\n@@ -301,7 +281,7 @@ impl<'tcx> LateLintPass<'tcx> for MetadataCollector {\n                 let span = SerializableSpan::from_span(cx, local.span);\n                 let local_str = crate::utils::snippet(cx, local.span, \"_\");\n                 log_to_file(&format!(\"{} -- {}\\n\", local_str, span));\n-                \n+\n                 let value_hir_id = local.pat.hir_id;\n                 let mut tracker = ValueTracker::new(cx, value_hir_id);\n                 if let Some(init_expr) = local.init {\n@@ -342,10 +322,21 @@ fn get_local_type<'a>(cx: &'a LateContext<'_>, local: &'a hir::Local<'_>) -> Opt\n     None\n }\n \n+// ==================================================================\n+// Lint definition extraction\n+// ==================================================================\n+\n fn sym_to_string(sym: Symbol) -> String {\n     sym.as_str().to_string()\n }\n \n+fn extract_attr_docs_or_lint(cx: &LateContext<'_>, item: &Item<'_>) -> Option<String> {\n+    extract_attr_docs(item).or_else(|| {\n+        lint_collection_error_item(cx, item, \"could not collect the lint documentation\");\n+        None\n+    })\n+}\n+\n /// This function collects all documentation that has been added to an item using\n /// `#[doc = r\"\"]` attributes. Several attributes are aggravated using line breaks\n ///\n@@ -367,6 +358,19 @@ fn extract_attr_docs(item: &Item<'_>) -> Option<String> {\n         })\n }\n \n+fn get_lint_group_or_lint(cx: &LateContext<'_>, lint_name: &str, item: &'tcx Item<'_>) -> Option<String> {\n+    let result = cx.lint_store.check_lint_name(lint_name, Some(sym::clippy));\n+    if let CheckLintNameResult::Tool(Ok(lint_lst)) = result {\n+        get_lint_group(cx, lint_lst[0]).or_else(|| {\n+            lint_collection_error_item(cx, item, \"Unable to determine lint group\");\n+            None\n+        })\n+    } else {\n+        lint_collection_error_item(cx, item, \"Unable to find lint in lint_store\");\n+        None\n+    }\n+}\n+\n fn get_lint_group(cx: &LateContext<'_>, lint_id: LintId) -> Option<String> {\n     for (group_name, lints, _) in &cx.lint_store.get_lint_groups() {\n         if lints.iter().any(|x| *x == lint_id) {\n@@ -526,19 +530,8 @@ impl<'a, 'hir> ValueTracker<'a, 'hir> {\n         }\n     }\n \n-    fn process_borrow_expr(&mut self, access_hir_id: hir::HirId) {\n-        let borrower: &rustc_hir::Expr<'_>;\n-        if let Some(addr_of_expr) = get_parent_expr_for_hir(self.cx, access_hir_id) {\n-            if let Some(borrower_expr) = get_parent_expr(self.cx, addr_of_expr) {\n-                borrower = borrower_expr\n-            } else {\n-                return;\n-            }\n-        } else {\n-            return;\n-        }\n-\n-        match &borrower.kind {\n+    fn process_borrow_expr(&mut self, borrower_expr: &'hir rustc_hir::Expr<'hir>) {\n+        match &borrower_expr.kind {\n             hir::ExprKind::Call(func_expr, ..) => {\n                 // We only deal with resolved paths as this is the usual case. Other expression kinds like closures\n                 // etc. are hard to track but might be a worthy improvement in the future\n@@ -555,36 +548,45 @@ impl<'a, 'hir> ValueTracker<'a, 'hir> {\n             hir::ExprKind::MethodCall(..) => {\n                 let msg = format!(\n                     \"Unsupported borrow in MethodCall at: {}\",\n-                    SerializableSpan::from_span(self.cx, borrower.span)\n+                    SerializableSpan::from_span(self.cx, borrower_expr.span)\n                 );\n                 self.value_mutations.push(ApplicabilityModifier::Unknown(msg));\n             },\n             _ => {\n                 let msg = format!(\n                     \"Unexpected borrow at: {}\",\n-                    SerializableSpan::from_span(self.cx, borrower.span)\n+                    SerializableSpan::from_span(self.cx, borrower_expr.span)\n                 );\n                 self.value_mutations.push(ApplicabilityModifier::Unknown(msg));\n             },\n         }\n     }\n+\n+    fn process_consume_expr(&mut self, consume_expr: &'hir rustc_hir::Expr<'hir>) {\n+        // We are only interested in lint emissions. Other types like assignments might be\n+        // interesting for further use or improvement but are to complex for now.\n+        if let hir::ExprKind::Call(func_expr, ..) = &consume_expr.kind {}\n+    }\n }\n \n impl<'a, 'hir> Delegate<'hir> for ValueTracker<'a, 'hir> {\n     fn consume(&mut self, _place_with_id: &PlaceWithHirId<'hir>, expr_id: hir::HirId, _: ConsumeMode) {\n         if self.is_value_expr(expr_id) {\n             // TODO xFrednet 2021-02-17: Check if lint emission and extract lint ID\n-            if let Some(hir::Node::Expr(expr)) = self.cx.tcx.hir().find(expr_id) {\n-                let span = SerializableSpan::from_span(self.cx, expr.span);\n-                log_to_file(&format!(\"- consume {}\\n\", span));\n+            if let Some(expr) = get_parent_expr_for_hir(self.cx, expr_id) {\n+                log_to_file(&format!(\"- consume {:?}\\n\", expr));\n             }\n         }\n     }\n \n     fn borrow(&mut self, _place_with_id: &PlaceWithHirId<'hir>, expr_id: hir::HirId, bk: BorrowKind) {\n-        if self.is_value_expr(expr_id) {\n-            if let BorrowKind::MutBorrow = bk {\n-                self.process_borrow_expr(expr_id);\n+        if_chain! {\n+            if self.is_value_expr(expr_id);\n+            if let BorrowKind::MutBorrow = bk;\n+            if let Some(addr_of_expr) = get_parent_expr_for_hir(self.cx, expr_id);\n+            if let Some(borrower_expr) = get_parent_expr(self.cx, addr_of_expr);\n+            then {\n+                self.process_borrow_expr(borrower_expr);\n             }\n         }\n     }"}, {"sha": "b0f59e5cf8a765d07d4d1e382c19960f2ec34d81", "filename": "tests/ui-internal/metadata-collector/track_applicability_value.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39912cfbbd682270b5f3d534bc69eedfaa73a7b/tests%2Fui-internal%2Fmetadata-collector%2Ftrack_applicability_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39912cfbbd682270b5f3d534bc69eedfaa73a7b/tests%2Fui-internal%2Fmetadata-collector%2Ftrack_applicability_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fmetadata-collector%2Ftrack_applicability_value.rs?ref=a39912cfbbd682270b5f3d534bc69eedfaa73a7b", "patch": "@@ -23,6 +23,8 @@ fn modifier_fn(applicability: &mut Applicability) {\n     }\n }\n \n+fn consumer_fn(_applicability: Applicability) {}\n+\n struct Muh;\n \n impl Muh {\n@@ -43,4 +45,6 @@ fn main() {\n     };\n \n     modifier_fn(&mut applicability);\n+\n+    consumer_fn(applicability);\n }"}]}