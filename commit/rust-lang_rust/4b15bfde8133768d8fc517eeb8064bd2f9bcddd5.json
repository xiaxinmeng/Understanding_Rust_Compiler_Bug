{"sha": "4b15bfde8133768d8fc517eeb8064bd2f9bcddd5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiMTViZmRlODEzMzc2OGQ4ZmM1MTdlZWI4MDY0YmQyZjliY2RkZDU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-01-26T03:02:09Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-01-28T18:01:59Z"}, "message": "loan: Track whether or not the current path owns the data being\nlent.  We can be more liberal with respect to the scope of the loan\nif we do not own the data being lent, which used to be impossible\nbut can now occur with `&mut`.\n\nr=pcwalton", "tree": {"sha": "b7709b536e61522546853cf487199a5c5c8711ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7709b536e61522546853cf487199a5c5c8711ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b15bfde8133768d8fc517eeb8064bd2f9bcddd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b15bfde8133768d8fc517eeb8064bd2f9bcddd5", "html_url": "https://github.com/rust-lang/rust/commit/4b15bfde8133768d8fc517eeb8064bd2f9bcddd5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b15bfde8133768d8fc517eeb8064bd2f9bcddd5/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4acde3bf7451cc20d6690ca2d3266f24bf9f477", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4acde3bf7451cc20d6690ca2d3266f24bf9f477", "html_url": "https://github.com/rust-lang/rust/commit/b4acde3bf7451cc20d6690ca2d3266f24bf9f477"}], "stats": {"total": 184, "additions": 128, "deletions": 56}, "files": [{"sha": "d3dc75aad7f911713a082eb633d8c8606b58545a", "filename": "src/librustc/middle/borrowck/loan.rs", "status": "modified", "additions": 128, "deletions": 56, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/4b15bfde8133768d8fc517eeb8064bd2f9bcddd5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b15bfde8133768d8fc517eeb8064bd2f9bcddd5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=4b15bfde8133768d8fc517eeb8064bd2f9bcddd5", "patch": "@@ -8,6 +8,35 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+/*!\n+\n+The `Loan` module deals with borrows of *uniquely mutable* data.  We\n+say that data is uniquely mutable if the current activation (stack\n+frame) controls the only mutable reference to the data.  The most\n+common way that this can occur is if the current activation owns the\n+data being borrowed, but it can also occur with `&mut` pointers.  The\n+primary characteristic of uniquely mutable data is that, at any given\n+time, there is at most one path that can be used to mutate it, and\n+that path is only accessible from the top stack frame.\n+\n+Given that some data found at a path P is being borrowed to a borrowed\n+pointer with mutability M and lifetime L, the job of the code in this\n+module is to compute the set of *loans* that are necessary to ensure\n+that (1) the data found at P outlives L and that (2) if M is mutable\n+then the path P will not be modified directly or indirectly except\n+through that pointer.  A *loan* is the combination of a path P_L, a\n+mutability M_L, and a lifetime L_L where:\n+\n+- The path P_L indicates what data has been lent.\n+- The mutability M_L indicates the access rights on the data:\n+  - const: the data cannot be moved\n+  - immutable/mutable: the data cannot be moved or mutated\n+- The lifetime L_L indicates the *scope* of the loan.\n+\n+XXX --- much more needed, don't have time to write this all up now\n+\n+*/\n+\n // ----------------------------------------------------------------------\n // Loan(Ex, M, S) = Ls holds if ToAddr(Ex) will remain valid for the entirety\n // of the scope S, presuming that the returned set of loans `Ls` are honored.\n@@ -39,7 +68,7 @@ impl borrowck_ctxt {\n             scope_region: scope_region,\n             loans: ~[]\n         };\n-        match lc.loan(cmt, mutbl) {\n+        match lc.loan(cmt, mutbl, true) {\n           Err(ref e) => Err((*e)),\n           Ok(()) => {\n               let LoanContext {loans, _} = move lc;\n@@ -62,46 +91,25 @@ struct LoanContext {\n impl LoanContext {\n     fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n \n-    fn issue_loan(&self,\n-                  cmt: cmt,\n-                  scope_ub: ty::Region,\n-                  req_mutbl: ast::mutability) -> bckres<()> {\n-        if self.bccx.is_subregion_of(self.scope_region, scope_ub) {\n-            match req_mutbl {\n-                m_mutbl => {\n-                    // We do not allow non-mutable data to be loaned\n-                    // out as mutable under any circumstances.\n-                    if cmt.mutbl != m_mutbl {\n-                        return Err({cmt:cmt,\n-                                    code:err_mutbl(req_mutbl)});\n-                    }\n-                }\n-                m_const | m_imm => {\n-                    // However, mutable data can be loaned out as\n-                    // immutable (and any data as const).  The\n-                    // `check_loans` pass will then guarantee that no\n-                    // writes occur for the duration of the loan.\n-                }\n-            }\n+    fn loan(&self,\n+            cmt: cmt,\n+            req_mutbl: ast::mutability,\n+            owns_lent_data: bool) -> bckres<()>\n+    {\n+        /*!\n+         *\n+         * The main routine.\n+         *\n+         * # Parameters\n+         *\n+         * - `cmt`: the categorization of the data being borrowed\n+         * - `req_mutbl`: the mutability of the borrowed pointer\n+         *                that was created\n+         * - `owns_lent_data`: indicates whether `cmt` owns the\n+         *                     data that is being lent.  See\n+         *                     discussion in `issue_loan()`.\n+         */\n \n-            self.loans.push(Loan {\n-                // Note: cmt.lp must be Some(_) because otherwise this\n-                // loan process does not apply at all.\n-                lp: cmt.lp.get(),\n-                cmt: cmt,\n-                mutbl: req_mutbl\n-            });\n-            return Ok(());\n-        } else {\n-            // The loan being requested lives longer than the data\n-            // being loaned out!\n-            return Err({cmt:cmt,\n-                        code:err_out_of_scope(scope_ub,\n-                                              self.scope_region)});\n-        }\n-    }\n-\n-    fn loan(&self, cmt: cmt, req_mutbl: ast::mutability) -> bckres<()> {\n         debug!(\"loan(%s, %s)\",\n                self.bccx.cmt_to_repr(cmt),\n                self.bccx.mut_to_str(req_mutbl));\n@@ -123,13 +131,14 @@ impl LoanContext {\n           }\n           cat_local(local_id) | cat_arg(local_id) | cat_self(local_id) => {\n             let local_scope_id = self.tcx().region_map.get(local_id);\n-            self.issue_loan(cmt, ty::re_scope(local_scope_id), req_mutbl)\n+            self.issue_loan(cmt, ty::re_scope(local_scope_id), req_mutbl,\n+                            owns_lent_data)\n           }\n           cat_stack_upvar(cmt) => {\n-            self.loan(cmt, req_mutbl) // NDM correct?\n+            self.loan(cmt, req_mutbl, owns_lent_data)\n           }\n           cat_discr(base, _) => {\n-            self.loan(base, req_mutbl)\n+            self.loan(base, req_mutbl, owns_lent_data)\n           }\n           cat_comp(cmt_base, comp_field(_, m)) |\n           cat_comp(cmt_base, comp_index(_, m)) => {\n@@ -139,36 +148,41 @@ impl LoanContext {\n             // that case, it must also be embedded in an immutable\n             // location, or else the whole structure could be\n             // overwritten and the component along with it.\n-            self.loan_stable_comp(cmt, cmt_base, req_mutbl, m)\n+            self.loan_stable_comp(cmt, cmt_base, req_mutbl, m,\n+                                  owns_lent_data)\n           }\n           cat_comp(cmt_base, comp_tuple) |\n           cat_comp(cmt_base, comp_anon_field) => {\n             // As above.\n-            self.loan_stable_comp(cmt, cmt_base, req_mutbl, m_imm)\n+            self.loan_stable_comp(cmt, cmt_base, req_mutbl, m_imm,\n+                                  owns_lent_data)\n           }\n           cat_comp(cmt_base, comp_variant(enum_did)) => {\n             // For enums, the memory is unstable if there are multiple\n             // variants, because if the enum value is overwritten then\n             // the memory changes type.\n             if ty::enum_is_univariant(self.bccx.tcx, enum_did) {\n-                self.loan_stable_comp(cmt, cmt_base, req_mutbl, m_imm)\n+                self.loan_stable_comp(cmt, cmt_base, req_mutbl, m_imm,\n+                                      owns_lent_data)\n             } else {\n-                self.loan_unstable_deref(cmt, cmt_base, req_mutbl)\n+                self.loan_unstable_deref(cmt, cmt_base, req_mutbl,\n+                                         owns_lent_data)\n             }\n           }\n           cat_deref(cmt_base, _, uniq_ptr) => {\n             // For unique pointers, the memory being pointed out is\n             // unstable because if the unique pointer is overwritten\n             // then the memory is freed.\n-            self.loan_unstable_deref(cmt, cmt_base, req_mutbl)\n+            self.loan_unstable_deref(cmt, cmt_base, req_mutbl,\n+                                     owns_lent_data)\n           }\n           cat_deref(cmt_base, _, region_ptr(ast::m_mutbl, region)) => {\n             // Mutable data can be loaned out as immutable or const. We must\n             // loan out the base as well as the main memory. For example,\n             // if someone borrows `*b`, we want to borrow `b` as immutable\n             // as well.\n-            do self.loan(cmt_base, m_imm).chain |_| {\n-                self.issue_loan(cmt, region, m_const)\n+            do self.loan(cmt_base, m_imm, false).chain |_| {\n+                self.issue_loan(cmt, region, m_const, owns_lent_data)\n             }\n           }\n           cat_deref(_, _, unsafe_ptr) |\n@@ -189,7 +203,8 @@ impl LoanContext {\n                         cmt: cmt,\n                         cmt_base: cmt,\n                         req_mutbl: ast::mutability,\n-                        comp_mutbl: ast::mutability) -> bckres<()> {\n+                        comp_mutbl: ast::mutability,\n+                        owns_lent_data: bool) -> bckres<()> {\n         // Determine the mutability that the base component must have,\n         // given the required mutability of the pointer (`req_mutbl`)\n         // and the declared mutability of the component (`comp_mutbl`).\n@@ -243,10 +258,11 @@ impl LoanContext {\n             (m_const, _) => m_const        // (5)\n         };\n \n-        do self.loan(cmt_base, base_mutbl).chain |_ok| {\n+        do self.loan(cmt_base, base_mutbl, owns_lent_data).chain |_ok| {\n             // can use static for the scope because the base\n             // determines the lifetime, ultimately\n-            self.issue_loan(cmt, ty::re_static, req_mutbl)\n+            self.issue_loan(cmt, ty::re_static, req_mutbl,\n+                            owns_lent_data)\n         }\n     }\n \n@@ -256,13 +272,69 @@ impl LoanContext {\n     fn loan_unstable_deref(&self,\n                            cmt: cmt,\n                            cmt_base: cmt,\n-                           req_mutbl: ast::mutability) -> bckres<()> {\n+                           req_mutbl: ast::mutability,\n+                           owns_lent_data: bool) -> bckres<()>\n+    {\n         // Variant components: the base must be immutable, because\n         // if it is overwritten, the types of the embedded data\n         // could change.\n-        do self.loan(cmt_base, m_imm).chain |_| {\n+        do self.loan(cmt_base, m_imm, owns_lent_data).chain |_| {\n             // can use static, as in loan_stable_comp()\n-            self.issue_loan(cmt, ty::re_static, req_mutbl)\n+            self.issue_loan(cmt, ty::re_static, req_mutbl,\n+                            owns_lent_data)\n+        }\n+    }\n+\n+    fn issue_loan(&self,\n+                  cmt: cmt,\n+                  scope_ub: ty::Region,\n+                  req_mutbl: ast::mutability,\n+                  owns_lent_data: bool) -> bckres<()>\n+    {\n+        // Subtle: the `scope_ub` is the maximal lifetime of `cmt`.\n+        // Therefore, if `cmt` owns the data being lent, then the\n+        // scope of the loan must be less than `scope_ub`, or else the\n+        // data would be freed while the loan is active.\n+        //\n+        // However, if `cmt` does *not* own the data being lent, then\n+        // it is ok if `cmt` goes out of scope during the loan.  This\n+        // can occur when you have an `&mut` parameter that is being\n+        // reborrowed.\n+\n+        if !owns_lent_data ||\n+            self.bccx.is_subregion_of(self.scope_region, scope_ub)\n+        {\n+            match req_mutbl {\n+                m_mutbl => {\n+                    // We do not allow non-mutable data to be loaned\n+                    // out as mutable under any circumstances.\n+                    if cmt.mutbl != m_mutbl {\n+                        return Err({cmt:cmt,\n+                                    code:err_mutbl(req_mutbl)});\n+                    }\n+                }\n+                m_const | m_imm => {\n+                    // However, mutable data can be loaned out as\n+                    // immutable (and any data as const).  The\n+                    // `check_loans` pass will then guarantee that no\n+                    // writes occur for the duration of the loan.\n+                }\n+            }\n+\n+            self.loans.push(Loan {\n+                // Note: cmt.lp must be Some(_) because otherwise this\n+                // loan process does not apply at all.\n+                lp: cmt.lp.get(),\n+                cmt: cmt,\n+                mutbl: req_mutbl\n+            });\n+            return Ok(());\n+        } else {\n+            // The loan being requested lives longer than the data\n+            // being loaned out!\n+            return Err({cmt:cmt,\n+                        code:err_out_of_scope(scope_ub,\n+                                              self.scope_region)});\n         }\n     }\n }"}]}