{"sha": "609152aa8a9faf2b8177dacd6d673b4bc06d1eda", "node_id": "C_kwDOAAsO6NoAKDYwOTE1MmFhOGE5ZmFmMmI4MTc3ZGFjZDZkNjczYjRiYzA2ZDFlZGE", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-09-29T12:43:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-09-29T12:43:19Z"}, "message": "Rollup merge of #102342 - jmillikin:nonzero-negation, r=scottmcm\n\nAdd negation methods for signed non-zero integers.\n\nPerforming negation with defined wrapping semantics (such as `wrapping_neg()`) on a non-zero integer currently requires unpacking to a primitive and re-wrapping. Since negation of non-zero signed integers always produces a non-zero result, it is safe to implement the various `*_neg()` methods for `NonZeroI{N}`.\n\nI'm not sure what to do about the `#[unstable(..., issue = \"none\")]` here -- should I file a tracking issue, or is that handled by the Rust dev team?\n\nACP: https://github.com/rust-lang/libs-team/issues/105", "tree": {"sha": "54ea9a0275bdfa5ef0c850f3dc3100a11068051e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54ea9a0275bdfa5ef0c850f3dc3100a11068051e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/609152aa8a9faf2b8177dacd6d673b4bc06d1eda", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjNZLnCRBK7hj4Ov3rIwAA3HsIAFuQR3rKUIj0pDMKrZOcp+ov\n4kiYz+jJpE6BQU1BivHp3T/xwD1oKuBbeURXHtelyGRS5TAPxUWwXVw3gKIKpDrr\n6irQhma6Cb+q1vMC+oJq6vBP0icpkry6F3BKUYudljTx613SIn4XjwfzomGxgcs8\nbeDqMNFQP6vz9pYeWaohpHZU1VHLtZUh2KZ0l7KaK6NdkmTgSNzNBs0jyWFKlkZ6\n7p9v3XH5ZtvY6oaxiM9Dp50P8fxwUlHuA4nnlugTWzmuLCfcznQtiF67iAY+Lt2j\ndRYh1LCWgmpJ2KBv58b0H/fPbUp2Spkym0B7crB/Yj5Gp/70ua9ObdGgEqVHQQE=\n=6Ep7\n-----END PGP SIGNATURE-----\n", "payload": "tree 54ea9a0275bdfa5ef0c850f3dc3100a11068051e\nparent 1be9ec54437c396acf64ed9be75270752ab5abad\nparent ceb53a3c4fa9f0c3da7b7e6d24011dee1d15ad09\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1664455399 +0530\ncommitter GitHub <noreply@github.com> 1664455399 +0530\n\nRollup merge of #102342 - jmillikin:nonzero-negation, r=scottmcm\n\nAdd negation methods for signed non-zero integers.\n\nPerforming negation with defined wrapping semantics (such as `wrapping_neg()`) on a non-zero integer currently requires unpacking to a primitive and re-wrapping. Since negation of non-zero signed integers always produces a non-zero result, it is safe to implement the various `*_neg()` methods for `NonZeroI{N}`.\n\nI'm not sure what to do about the `#[unstable(..., issue = \"none\")]` here -- should I file a tracking issue, or is that handled by the Rust dev team?\n\nACP: https://github.com/rust-lang/libs-team/issues/105\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/609152aa8a9faf2b8177dacd6d673b4bc06d1eda", "html_url": "https://github.com/rust-lang/rust/commit/609152aa8a9faf2b8177dacd6d673b4bc06d1eda", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/609152aa8a9faf2b8177dacd6d673b4bc06d1eda/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1be9ec54437c396acf64ed9be75270752ab5abad", "url": "https://api.github.com/repos/rust-lang/rust/commits/1be9ec54437c396acf64ed9be75270752ab5abad", "html_url": "https://github.com/rust-lang/rust/commit/1be9ec54437c396acf64ed9be75270752ab5abad"}, {"sha": "ceb53a3c4fa9f0c3da7b7e6d24011dee1d15ad09", "url": "https://api.github.com/repos/rust-lang/rust/commits/ceb53a3c4fa9f0c3da7b7e6d24011dee1d15ad09", "html_url": "https://github.com/rust-lang/rust/commit/ceb53a3c4fa9f0c3da7b7e6d24011dee1d15ad09"}], "stats": {"total": 154, "additions": 154, "deletions": 0}, "files": [{"sha": "da402d66502a66a2532b5e23d9c2b91bd3cc0903", "filename": "library/core/src/num/nonzero.rs", "status": "modified", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/609152aa8a9faf2b8177dacd6d673b4bc06d1eda/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/609152aa8a9faf2b8177dacd6d673b4bc06d1eda/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs?ref=609152aa8a9faf2b8177dacd6d673b4bc06d1eda", "patch": "@@ -721,6 +721,160 @@ macro_rules! nonzero_signed_operations {\n                     // SAFETY: absolute value of nonzero cannot yield zero values.\n                     unsafe { $Uty::new_unchecked(self.get().unsigned_abs()) }\n                 }\n+\n+                /// Returns `true` if `self` is negative and `false` if the\n+                /// number is positive.\n+                ///\n+                /// # Example\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_negation_ops)]\n+                ///\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let pos_five = \", stringify!($Ty), \"::new(5)?;\")]\n+                #[doc = concat!(\"let neg_five = \", stringify!($Ty), \"::new(-5)?;\")]\n+                ///\n+                /// assert!(neg_five.is_negative());\n+                /// assert!(!pos_five.is_negative());\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[must_use]\n+                #[inline]\n+                #[unstable(feature = \"nonzero_negation_ops\", issue = \"102443\")]\n+                pub const fn is_negative(self) -> bool {\n+                    self.get().is_negative()\n+                }\n+\n+                /// Checked negation. Computes `-self`, returning `None` if `self == i32::MIN`.\n+                ///\n+                /// # Example\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_negation_ops)]\n+                ///\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let pos_five = \", stringify!($Ty), \"::new(5)?;\")]\n+                #[doc = concat!(\"let neg_five = \", stringify!($Ty), \"::new(-5)?;\")]\n+                #[doc = concat!(\"let min = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MIN)?;\")]\n+                ///\n+                /// assert_eq!(pos_five.checked_neg(), Some(neg_five));\n+                /// assert_eq!(min.checked_neg(), None);\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[inline]\n+                #[unstable(feature = \"nonzero_negation_ops\", issue = \"102443\")]\n+                pub const fn checked_neg(self) -> Option<$Ty> {\n+                    if let Some(result) = self.get().checked_neg() {\n+                        // SAFETY: negation of nonzero cannot yield zero values.\n+                        return Some(unsafe { $Ty::new_unchecked(result) });\n+                    }\n+                    None\n+                }\n+\n+                /// Negates self, overflowing if this is equal to the minimum value.\n+                ///\n+                #[doc = concat!(\"See [`\", stringify!($Int), \"::overflowing_neg`]\")]\n+                /// for documentation on overflow behaviour.\n+                ///\n+                /// # Example\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_negation_ops)]\n+                ///\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let pos_five = \", stringify!($Ty), \"::new(5)?;\")]\n+                #[doc = concat!(\"let neg_five = \", stringify!($Ty), \"::new(-5)?;\")]\n+                #[doc = concat!(\"let min = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MIN)?;\")]\n+                ///\n+                /// assert_eq!(pos_five.overflowing_neg(), (neg_five, false));\n+                /// assert_eq!(min.overflowing_neg(), (min, true));\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[inline]\n+                #[unstable(feature = \"nonzero_negation_ops\", issue = \"102443\")]\n+                pub const fn overflowing_neg(self) -> ($Ty, bool) {\n+                    let (result, overflow) = self.get().overflowing_neg();\n+                    // SAFETY: negation of nonzero cannot yield zero values.\n+                    ((unsafe { $Ty::new_unchecked(result) }), overflow)\n+                }\n+\n+                /// Saturating negation. Computes `-self`, returning `MAX` if\n+                /// `self == i32::MIN` instead of overflowing.\n+                ///\n+                /// # Example\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_negation_ops)]\n+                ///\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let pos_five = \", stringify!($Ty), \"::new(5)?;\")]\n+                #[doc = concat!(\"let neg_five = \", stringify!($Ty), \"::new(-5)?;\")]\n+                #[doc = concat!(\"let min = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MIN)?;\")]\n+                #[doc = concat!(\"let min_plus_one = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MIN + 1)?;\")]\n+                #[doc = concat!(\"let max = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MAX)?;\")]\n+                ///\n+                /// assert_eq!(pos_five.saturating_neg(), neg_five);\n+                /// assert_eq!(min.saturating_neg(), max);\n+                /// assert_eq!(max.saturating_neg(), min_plus_one);\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[inline]\n+                #[unstable(feature = \"nonzero_negation_ops\", issue = \"102443\")]\n+                pub const fn saturating_neg(self) -> $Ty {\n+                    if let Some(result) = self.checked_neg() {\n+                        return result;\n+                    }\n+                    $Ty::MAX\n+                }\n+\n+                /// Wrapping (modular) negation. Computes `-self`, wrapping around at the boundary\n+                /// of the type.\n+                ///\n+                #[doc = concat!(\"See [`\", stringify!($Int), \"::wrapping_neg`]\")]\n+                /// for documentation on overflow behaviour.\n+                ///\n+                /// # Example\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_negation_ops)]\n+                ///\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let pos_five = \", stringify!($Ty), \"::new(5)?;\")]\n+                #[doc = concat!(\"let neg_five = \", stringify!($Ty), \"::new(-5)?;\")]\n+                #[doc = concat!(\"let min = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MIN)?;\")]\n+                ///\n+                /// assert_eq!(pos_five.wrapping_neg(), neg_five);\n+                /// assert_eq!(min.wrapping_neg(), min);\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[inline]\n+                #[unstable(feature = \"nonzero_negation_ops\", issue = \"102443\")]\n+                pub const fn wrapping_neg(self) -> $Ty {\n+                    let result = self.get().wrapping_neg();\n+                    // SAFETY: negation of nonzero cannot yield zero values.\n+                    unsafe { $Ty::new_unchecked(result) }\n+                }\n             }\n         )+\n     }"}]}