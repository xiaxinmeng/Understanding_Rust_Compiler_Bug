{"sha": "2b67d88809d9f6ddc4686ee514cb78200db1d737", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiNjdkODg4MDlkOWY2ZGRjNDY4NmVlNTE0Y2I3ODIwMGRiMWQ3Mzc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-01-23T01:20:08Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-01-28T18:01:59Z"}, "message": "Rewrite the coercion code to be more readable, more sound, and to reborrow when\nneeded.\n\nRegarding soundness: there was a subtle bug in how it was done before; see the\ncompile-fail test for an example.\n\nRegarding reborrowing: reborrowing allows mut and const\nslices/borrowed-pointers to be used with pure fns that expect immutable data.\n\nr=brson", "tree": {"sha": "ea8b9e3710f394242678624a0f5f141ab3b33f88", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea8b9e3710f394242678624a0f5f141ab3b33f88"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b67d88809d9f6ddc4686ee514cb78200db1d737", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b67d88809d9f6ddc4686ee514cb78200db1d737", "html_url": "https://github.com/rust-lang/rust/commit/2b67d88809d9f6ddc4686ee514cb78200db1d737", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b67d88809d9f6ddc4686ee514cb78200db1d737/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c07ae16de18ad24004e1d1c425c08bcf3e7c4811", "url": "https://api.github.com/repos/rust-lang/rust/commits/c07ae16de18ad24004e1d1c425c08bcf3e7c4811", "html_url": "https://github.com/rust-lang/rust/commit/c07ae16de18ad24004e1d1c425c08bcf3e7c4811"}], "stats": {"total": 945, "additions": 643, "deletions": 302}, "files": [{"sha": "ebfce27a4c8bb6d3dbbc25bb1332c302fb360a4c", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=2b67d88809d9f6ddc4686ee514cb78200db1d737", "patch": "@@ -15,7 +15,7 @@ use middle::pat_util::{pat_is_variant_or_struct};\n use middle::ty;\n use middle::typeck::check::demand;\n use middle::typeck::check::{check_block, check_expr_has_type, fn_ctxt};\n-use middle::typeck::check::{instantiate_path, lookup_def, lookup_local};\n+use middle::typeck::check::{instantiate_path, lookup_def};\n use middle::typeck::check::{structure_of, valid_range_bounds};\n use middle::typeck::require_same_types;\n \n@@ -365,8 +365,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         fcx.write_ty(pat.id, const_tpt.ty);\n       }\n       ast::pat_ident(bm, name, sub) if pat_is_binding(tcx.def_map, pat) => {\n-        let vid = lookup_local(fcx, pat.span, pat.id);\n-        let mut typ = ty::mk_var(tcx, vid);\n+        let typ = fcx.local_ty(pat.span, pat.id);\n \n         match bm {\n           ast::bind_by_ref(mutbl) => {\n@@ -389,8 +388,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n \n         let canon_id = pcx.map.get(ast_util::path_to_ident(name));\n         if canon_id != pat.id {\n-            let tv_id = lookup_local(fcx, pat.span, canon_id);\n-            let ct = ty::mk_var(tcx, tv_id);\n+            let ct = fcx.local_ty(pat.span, canon_id);\n             demand::eqtype(fcx, pat.span, ct, typ);\n         }\n         fcx.write_ty(pat.id, typ);"}, {"sha": "c8a644fef101ce42493186d829cc74b3a6ba9d69", "filename": "src/librustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=2b67d88809d9f6ddc4686ee514cb78200db1d737", "patch": "@@ -50,7 +50,10 @@ fn eqtype(fcx: @fn_ctxt, sp: span, expected: ty::t, actual: ty::t) {\n }\n \n // Checks that the type `actual` can be coerced to `expected`.\n-fn coerce(fcx: @fn_ctxt, sp: span, expected: ty::t, expr: @ast::expr) {\n+fn coerce(fcx: @fn_ctxt,\n+          sp: span,\n+          expected: ty::t,\n+          expr: @ast::expr) {\n     let expr_ty = fcx.expr_ty(expr);\n     match fcx.mk_assignty(expr, expr_ty, expected) {\n       result::Ok(()) => { /* ok */ }"}, {"sha": "238e4e8c3f7726278811a277fd1dc6761c1b9917", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 74, "deletions": 2, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=2b67d88809d9f6ddc4686ee514cb78200db1d737", "patch": "@@ -700,20 +700,91 @@ impl LookupContext {\n         autoderefs: uint)\n         -> Option<method_map_entry>\n     {\n+        let (self_ty, autoadjust) =\n+            self.consider_reborrow(self_ty, autoderefs);\n         match self.search_for_method(self_ty) {\n             None => None,\n             Some(move mme) => {\n                 debug!(\"(searching for autoderef'd method) writing \\\n                        adjustment (%u) to %d\",\n                        autoderefs,\n                        self.self_expr.id);\n-                self.fcx.write_autoderef_adjustment(\n-                    self.self_expr.id, autoderefs);\n+                self.fcx.write_adjustment(self.self_expr.id, @autoadjust);\n                 Some(mme)\n             }\n         }\n     }\n \n+    fn consider_reborrow(&self,\n+                         self_ty: ty::t,\n+                         autoderefs: uint) -> (ty::t, ty::AutoAdjustment)\n+    {\n+        /*!\n+         *\n+         * In the event that we are invoking a method with a receiver\n+         * of a linear borrowed type like `&mut T` or `&[mut T]`,\n+         * we will \"reborrow\" the receiver implicitly.  For example, if\n+         * you have a call `r.inc()` and where `r` has type `&mut T`,\n+         * then we treat that like `(&mut *r).inc()`.  This avoids\n+         * consuming the original pointer.\n+         *\n+         * You might think that this would be a natural byproduct of\n+         * the auto-deref/auto-ref process.  This is true for `@mut T`\n+         * but not for an `&mut T` receiver.  With `@mut T`, we would\n+         * begin by testing for methods with a self type `@mut T`,\n+         * then autoderef to `T`, then autoref to `&mut T`.  But with\n+         * an `&mut T` receiver the process begins with `&mut T`, only\n+         * without any autoadjustments.\n+         */\n+\n+        let tcx = self.tcx();\n+        return match ty::get(self_ty).sty {\n+            ty::ty_rptr(self_r, self_mt) if self_mt.mutbl == m_mutbl => {\n+                let region = fresh_region(self, self_r);\n+                (ty::mk_rptr(tcx, region, self_mt),\n+                 ty::AutoAdjustment {\n+                     autoderefs: autoderefs+1,\n+                     autoref: Some(ty::AutoRef {kind: AutoPtr,\n+                                                region: region,\n+                                                mutbl: self_mt.mutbl})})\n+            }\n+            ty::ty_evec(self_mt, vstore_slice(self_r))\n+            if self_mt.mutbl == m_mutbl => {\n+                let region = fresh_region(self, self_r);\n+                (ty::mk_evec(tcx, self_mt, vstore_slice(region)),\n+                 ty::AutoAdjustment {\n+                    autoderefs: autoderefs,\n+                    autoref: Some(ty::AutoRef {kind: AutoBorrowVec,\n+                                               region: region,\n+                                               mutbl: self_mt.mutbl})})\n+            }\n+            _ => {\n+                (self_ty, ty::AutoAdjustment {autoderefs: autoderefs,\n+                                              autoref: None})\n+            }\n+        };\n+\n+        fn fresh_region(self: &LookupContext,\n+                        self_r: ty::Region) -> ty::Region {\n+            let region = self.infcx().next_region_var(self.expr.span,\n+                                                      self.expr.id);\n+\n+            // FIXME(#3148)---in principle this dependency should\n+            // be done more generally as part of regionck\n+            match infer::mk_subr(self.infcx(), true, self.expr.span,\n+                                 region, self_r) {\n+                Ok(_) => {}\n+                Err(e) => {\n+                    self.tcx().sess.span_bug(\n+                        self.expr.span,\n+                        fmt!(\"Failed with error: %?\", e));\n+                }\n+            }\n+\n+            return region;\n+        }\n+    }\n+\n     fn search_for_autosliced_method(\n         &self,\n         self_ty: ty::t,\n@@ -729,6 +800,7 @@ impl LookupContext {\n         match ty::get(self_ty).sty {\n             ty_evec(mt, vstore_box) |\n             ty_evec(mt, vstore_uniq) |\n+            ty_evec(mt, vstore_slice(_)) | // NDM(#3148)\n             ty_evec(mt, vstore_fixed(_)) => {\n                 // First try to borrow to a slice\n                 let entry = self.search_for_some_kind_of_autorefd_method("}, {"sha": "cf13fcb86e8180cddd356f201774525ed34f112b", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 41, "deletions": 43, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=2b67d88809d9f6ddc4686ee514cb78200db1d737", "patch": "@@ -139,7 +139,6 @@ export regionck;\n export demand;\n export method;\n export fn_ctxt;\n-export lookup_local;\n export impl_self_ty;\n export DerefArgs;\n export DontDerefArgs;\n@@ -189,7 +188,7 @@ type self_info = {\n /// share the inherited fields.\n struct inherited {\n     infcx: @infer::InferCtxt,\n-    locals: HashMap<ast::node_id, TyVid>,\n+    locals: HashMap<ast::node_id, ty::t>,\n     node_types: HashMap<ast::node_id, ty::t>,\n     node_type_substs: HashMap<ast::node_id, ty::substs>,\n     adjustments: HashMap<ast::node_id, @ty::AutoAdjustment>\n@@ -376,8 +375,7 @@ fn check_fn(ccx: @crate_ctxt,\n         }\n     };\n \n-    // XXX: Bad copy.\n-    gather_locals(fcx, decl, body, copy arg_tys, self_info);\n+    gather_locals(fcx, decl, body, arg_tys, self_info);\n     check_block(fcx, body);\n \n     // We unify the tail expr's type with the\n@@ -414,38 +412,39 @@ fn check_fn(ccx: @crate_ctxt,\n     fn gather_locals(fcx: @fn_ctxt,\n                      decl: &ast::fn_decl,\n                      body: ast::blk,\n-                     arg_tys: ~[ty::t],\n+                     arg_tys: &[ty::t],\n                      self_info: Option<self_info>) {\n         let tcx = fcx.ccx.tcx;\n \n-        let assign = fn@(span: span, nid: ast::node_id,\n-                         ty_opt: Option<ty::t>) {\n-            let var_id = fcx.infcx().next_ty_var_id();\n-            fcx.inh.locals.insert(nid, var_id);\n+        let assign = fn@(nid: ast::node_id, ty_opt: Option<ty::t>) {\n             match ty_opt {\n-                None => {/* nothing to do */ }\n+                None => {\n+                    // infer the variable's type\n+                    let var_id = fcx.infcx().next_ty_var_id();\n+                    let var_ty = ty::mk_var(fcx.tcx(), var_id);\n+                    fcx.inh.locals.insert(nid, var_ty);\n+                }\n                 Some(typ) => {\n-                    infer::mk_eqty(fcx.infcx(), false, span,\n-                                   ty::mk_var(tcx, var_id), typ);\n+                    // take type that the user specified\n+                    fcx.inh.locals.insert(nid, typ);\n                 }\n             }\n         };\n \n         // Add the self parameter\n         for self_info.each |self_info| {\n-            assign(self_info.explicit_self.span,\n-                   self_info.self_id,\n-                   Some(self_info.self_ty));\n+            assign(self_info.self_id, Some(self_info.self_ty));\n             debug!(\"self is assigned to %s\",\n-                   fcx.inh.locals.get(self_info.self_id).to_str());\n+                   fcx.infcx().ty_to_str(\n+                       fcx.inh.locals.get(self_info.self_id)));\n         }\n \n         // Add formal parameters.\n         for vec::each2(arg_tys, decl.inputs) |arg_ty, input| {\n             // Create type variables for each argument.\n             do pat_util::pat_bindings(tcx.def_map, input.pat)\n                     |_bm, pat_id, _sp, _path| {\n-                assign(input.ty.span, pat_id, None);\n+                assign(pat_id, None);\n             }\n \n             // Check the pattern.\n@@ -466,10 +465,11 @@ fn check_fn(ccx: @crate_ctxt,\n               ast::ty_infer => None,\n               _ => Some(fcx.to_ty(local.node.ty))\n             };\n-            assign(local.span, local.node.id, o_ty);\n-            debug!(\"Local variable %s is assigned to %s\",\n+            assign(local.node.id, o_ty);\n+            debug!(\"Local variable %s is assigned type %s\",\n                    fcx.pat_to_str(local.node.pat),\n-                   fcx.inh.locals.get(local.node.id).to_str());\n+                   fcx.infcx().ty_to_str(\n+                       fcx.inh.locals.get(local.node.id)));\n             visit::visit_local(local, e, v);\n         };\n \n@@ -478,10 +478,11 @@ fn check_fn(ccx: @crate_ctxt,\n             match p.node {\n               ast::pat_ident(_, path, _)\n                   if pat_util::pat_is_binding(fcx.ccx.tcx.def_map, p) => {\n-                assign(p.span, p.id, None);\n+                assign(p.id, None);\n                 debug!(\"Pattern binding %s is assigned to %s\",\n                        tcx.sess.str_of(path.idents[0]),\n-                       fcx.inh.locals.get(p.id).to_str());\n+                       fcx.infcx().ty_to_str(\n+                           fcx.inh.locals.get(p.id)));\n               }\n               _ => {}\n             }\n@@ -694,6 +695,17 @@ impl @fn_ctxt: region_scope {\n impl @fn_ctxt {\n     fn tag() -> ~str { fmt!(\"%x\", ptr::addr_of(&(*self)) as uint) }\n \n+    fn local_ty(span: span, nid: ast::node_id) -> ty::t {\n+        match self.inh.locals.find(nid) {\n+            Some(t) => t,\n+            None => {\n+                self.tcx().sess.span_bug(\n+                    span,\n+                    fmt!(\"No type for local variable %?\", nid));\n+            }\n+        }\n+    }\n+\n     fn expr_to_str(expr: @ast::expr) -> ~str {\n         fmt!(\"expr(%?:%s)\", expr.id,\n              pprust::expr_to_str(expr, self.tcx().sess.intr()))\n@@ -1359,10 +1371,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n     fn check_for(fcx: @fn_ctxt, local: @ast::local,\n                  element_ty: ty::t, body: ast::blk,\n                  node_id: ast::node_id) -> bool {\n-        let locid = lookup_local(fcx, local.span, local.node.id);\n-        demand::suptype(fcx, local.span,\n-                       ty::mk_var(fcx.ccx.tcx, locid),\n-                       element_ty);\n+        let local_ty = fcx.local_ty(local.span, local.node.id);\n+        demand::suptype(fcx, local.span, local_ty, element_ty);\n         let bot = check_decl_local(fcx, local);\n         check_block_no_value(fcx, body);\n         fcx.write_nil(node_id);\n@@ -2551,15 +2561,15 @@ fn require_integral(fcx: @fn_ctxt, sp: span, t: ty::t) {\n \n fn check_decl_initializer(fcx: @fn_ctxt, nid: ast::node_id,\n                           init: @ast::expr) -> bool {\n-    let lty = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, init.span, nid));\n-    return check_expr_coercable_to_type(fcx, init, lty);\n+    let local_ty = fcx.local_ty(init.span, nid);\n+    return check_expr_coercable_to_type(fcx, init, local_ty);\n }\n \n fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {\n     let mut bot = false;\n     let tcx = fcx.ccx.tcx;\n \n-    let t = ty::mk_var(tcx, fcx.inh.locals.get(local.node.id));\n+    let t = fcx.local_ty(local.span, local.node.id);\n     fcx.write_ty(local.node.id, t);\n \n     match local.node.init {\n@@ -2819,17 +2829,6 @@ fn check_enum_variants(ccx: @crate_ctxt,\n     check_instantiable(ccx.tcx, sp, id);\n }\n \n-pub fn lookup_local(fcx: @fn_ctxt, sp: span, id: ast::node_id) -> TyVid {\n-    match fcx.inh.locals.find(id) {\n-        Some(x) => x,\n-        _ => {\n-            fcx.ccx.tcx.sess.span_fatal(\n-                sp,\n-                ~\"internal error looking up a local var\")\n-        }\n-    }\n-}\n-\n fn lookup_def(fcx: @fn_ctxt, sp: span, id: ast::node_id) -> ast::def {\n     lookup_def_ccx(fcx.ccx, sp, id)\n }\n@@ -2841,9 +2840,8 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n     match defn {\n       ast::def_arg(nid, _, _) | ast::def_local(nid, _) |\n       ast::def_self(nid, _) | ast::def_binding(nid, _) => {\n-        assert (fcx.inh.locals.contains_key(nid));\n-        let typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, nid));\n-        return no_params(typ);\n+          let typ = fcx.local_ty(sp, nid);\n+          return no_params(typ);\n       }\n       ast::def_fn(_, ast::extern_fn) => {\n         // extern functions are just u8 pointers"}, {"sha": "e5dc91b7f179a41fbe10dab6667be10d40b629c3", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=2b67d88809d9f6ddc4686ee514cb78200db1d737", "patch": "@@ -16,7 +16,7 @@ use core::prelude::*;\n \n use middle::pat_util;\n use middle::ty;\n-use middle::typeck::check::{fn_ctxt, lookup_local, self_info};\n+use middle::typeck::check::{fn_ctxt, self_info};\n use middle::typeck::infer::{force_all, resolve_all, resolve_region};\n use middle::typeck::infer::{resolve_type};\n use middle::typeck::infer;\n@@ -216,8 +216,7 @@ fn visit_pat(p: @ast::pat, wbcx: wb_ctxt, v: wb_vt) {\n }\n fn visit_local(l: @ast::local, wbcx: wb_ctxt, v: wb_vt) {\n     if !wbcx.success { return; }\n-    let var_id = lookup_local(wbcx.fcx, l.span, l.node.id);\n-    let var_ty = ty::mk_var(wbcx.fcx.tcx(), var_id);\n+    let var_ty = wbcx.fcx.local_ty(l.span, l.node.id);\n     match resolve_type(wbcx.fcx.infcx(), var_ty, resolve_all | force_all) {\n         Ok(lty) => {\n             debug!(\"Type for local %s (id %d) resolved to %s\","}, {"sha": "9c319bdc733aea0d35c35e0bb4603a1d5e4b464c", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 332, "deletions": 223, "changes": 555, "blob_url": "https://github.com/rust-lang/rust/blob/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=2b67d88809d9f6ddc4686ee514cb78200db1d737", "patch": "@@ -8,280 +8,389 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ______________________________________________________________________\n-// Type assignment\n-//\n-// True if rvalues of type `a` can be assigned to lvalues of type `b`.\n-// This may cause borrowing to the region scope enclosing `a_node_id`.\n-//\n-// The strategy here is somewhat non-obvious.  The problem is\n-// that the constraint we wish to contend with is not a subtyping\n-// constraint.  Currently, for variables, we only track what it\n-// must be a subtype of, not what types it must be assignable to\n-// (or from).  Possibly, we should track that, but I leave that\n-// refactoring for another day.\n-//\n-// Instead, we look at each variable involved and try to extract\n-// *some* sort of bound.  Typically, the type a is the argument\n-// supplied to a call; it typically has a *lower bound* (which\n-// comes from having been assigned a value).  What we'd actually\n-// *like* here is an upper-bound, but we generally don't have\n-// one.  The type b is the expected type and it typically has a\n-// lower-bound too, which is good.\n-//\n-// The way we deal with the fact that we often don't have the\n-// bounds we need is to be a bit careful.  We try to get *some*\n-// bound from each side, preferring the upper from a and the\n-// lower from b.  If we fail to get a bound from both sides, then\n-// we just fall back to requiring that a <: b.\n-//\n-// Assuming we have a bound from both sides, we will then examine\n-// these bounds and see if they have the form (@M_a T_a, &rb.M_b T_b)\n-// (resp. ~M_a T_a, ~[M_a T_a], etc).  If they do not, we fall back to\n-// subtyping.\n-//\n-// If they *do*, then we know that the two types could never be\n-// subtypes of one another.  We will then construct a type @const T_b\n-// and ensure that type a is a subtype of that.  This allows for the\n-// possibility of assigning from a type like (say) @~[mut T1] to a type\n-// &~[T2] where T1 <: T2.  This might seem surprising, since the `@`\n-// points at mutable memory but the `&` points at immutable memory.\n-// This would in fact be unsound, except for the borrowck, which comes\n-// later and guarantees that such mutability conversions are safe.\n-// See borrowck for more details.  Next we require that the region for\n-// the enclosing scope be a superregion of the region r.\n-//\n-// You might wonder why we don't make the type &e.const T_a where e is\n-// the enclosing region and check that &e.const T_a <: B.  The reason\n-// is that the type of A is (generally) just a *lower-bound*, so this\n-// would be imposing that lower-bound also as the upper-bound on type\n-// A.  But this upper-bound might be stricter than what is truly\n-// needed.\n+/*!\n+\n+# Type Coercion\n+\n+Under certain circumstances we will coerce from one type to another,\n+for example by auto-borrowing.  This occurs in situations where the\n+compiler has a firm 'expected type' that was supplied from the user,\n+and where the actual type is similar to that expected type in purpose\n+but not in representation (so actual subtyping is inappropriate).\n+\n+## Reborrowing\n+\n+Note that if we are expecting a borrowed pointer, we will *reborrow*\n+even if the argument provided was already a borrowed pointer.  This is\n+useful for freezing mut/const things (that is, when the expected is &T\n+but you have &const T or &mut T) and also for avoiding the linearity\n+of mut things (when the expected is &mut T and you have &mut T).  See\n+the various `src/test/run-pass/coerce-reborrow-*.rs` tests for\n+examples of where this is useful.\n+\n+## Subtle note\n+\n+When deciding what type coercions to consider, we do not attempt to\n+resolve any type variables we may encounter.  This is because `b`\n+represents the expected type \"as the user wrote it\", meaning that if\n+the user defined a generic function like\n+\n+   fn foo<A>(a: A, b: A) { ... }\n+\n+and then we wrote `foo(&1, @2)`, we will not auto-borrow\n+either argument.  In older code we went to some lengths to\n+resolve the `b` variable, which could mean that we'd\n+auto-borrow later arguments but not earlier ones, which\n+seems very confusing.\n+\n+## Subtler note\n+\n+However, right now, if the user manually specifies the\n+values for the type variables, as so:\n+\n+   foo::<&int>(@1, @2)\n+\n+then we *will* auto-borrow, because we can't distinguish this from a\n+function that declared `&int`.  This is inconsistent but it's easiest\n+at the moment. The right thing to do, I think, is to consider the\n+*unsubstituted* type when deciding whether to auto-borrow, but the\n+*substituted* type when considering the bounds and so forth. But most\n+of our methods don't give access to the unsubstituted type, and\n+rightly so because they'd be error-prone.  So maybe the thing to do is\n+to actually determine the kind of coercions that should occur\n+separately and pass them in.  Or maybe it's ok as is.  Anyway, it's\n+sort of a minor point so I've opted to leave it for later---after all\n+we may want to adjust precisely when coercions occur.\n+\n+*/\n \n use core::prelude::*;\n \n-use middle::ty::TyVar;\n+use middle::ty::{TyVar, AutoPtr, AutoBorrowVec, AutoBorrowFn};\n+use middle::ty::{AutoAdjustment, AutoRef};\n+use middle::ty::{vstore_slice, vstore_box, vstore_uniq, vstore_fixed};\n+use middle::ty::{FnMeta, FnTyBase, mt};\n use middle::ty;\n-use middle::typeck::infer::{ares, cres};\n+use middle::typeck::infer::{CoerceResult, resolve_type};\n use middle::typeck::infer::combine::CombineFields;\n use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::to_str::InferStr;\n+use middle::typeck::infer::resolve::try_resolve_tvar_shallow;\n use util::common::{indent, indenter};\n \n use core::option;\n use syntax::ast::{m_const, m_imm, m_mutbl};\n use syntax::ast;\n \n-fn to_ares<T>(+c: cres<T>) -> ares {\n-    match c {\n-        Ok(_) => Ok(None),\n-        Err(ref e) => Err((*e))\n-    }\n-}\n-\n // Note: Coerce is not actually a combiner, in that it does not\n // conform to the same interface, though it performs a similar\n // function.\n pub enum Coerce = CombineFields;\n \n impl Coerce {\n-    fn tys(&self, a: ty::t, b: ty::t) -> ares {\n+    fn tys(&self, a: ty::t, b: ty::t) -> CoerceResult {\n         debug!(\"Coerce.tys(%s => %s)\",\n                a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n         let _indent = indenter();\n-        let r = match (&ty::get(a).sty, &ty::get(b).sty) {\n-            (&ty::ty_bot, _) => {\n-                Ok(None)\n+\n+        // Examine the supertype and consider auto-borrowing.\n+        //\n+        // Note: does not attempt to resolve type variables we encounter.\n+        // See above for details.\n+        match ty::get(b).sty {\n+            ty::ty_rptr(_, mt_b) => {\n+                return do self.unpack_actual_value(a) |sty_a| {\n+                    self.coerce_borrowed_pointer(a, sty_a, b, mt_b)\n+                };\n             }\n \n-            (&ty::ty_infer(TyVar(a_id)), &ty::ty_infer(TyVar(b_id))) => {\n-                let nde_a = self.infcx.get(a_id);\n-                let nde_b = self.infcx.get(b_id);\n-                let a_bounds = nde_a.possible_types;\n-                let b_bounds = nde_b.possible_types;\n+            ty::ty_estr(vstore_slice(_)) => {\n+                return do self.unpack_actual_value(a) |sty_a| {\n+                    self.coerce_borrowed_string(a, sty_a, b)\n+                };\n+            }\n \n-                let a_bnd = option::or(a_bounds.ub, a_bounds.lb);\n-                let b_bnd = option::or(b_bounds.lb, b_bounds.ub);\n-                self.coerce_tys_or_sub(a, b, a_bnd, b_bnd)\n+            ty::ty_evec(mt_b, vstore_slice(_)) => {\n+                return do self.unpack_actual_value(a) |sty_a| {\n+                    self.coerce_borrowed_vector(a, sty_a, b, mt_b)\n+                };\n             }\n \n-            (&ty::ty_infer(TyVar(a_id)), _) => {\n-                let nde_a = self.infcx.get(a_id);\n-                let a_bounds = nde_a.possible_types;\n+            ty::ty_fn(ref b_f) if b_f.meta.proto == ast::ProtoBorrowed => {\n+                return do self.unpack_actual_value(a) |sty_a| {\n+                    self.coerce_borrowed_fn(a, sty_a, b)\n+                };\n+            }\n \n-                let a_bnd = option::or(a_bounds.ub, a_bounds.lb);\n-                self.coerce_tys_or_sub(a, b, a_bnd, Some(b))\n+            ty::ty_ptr(_) => {\n+                return do self.unpack_actual_value(a) |sty_a| {\n+                    self.coerce_unsafe_ptr(a, sty_a, b)\n+                };\n             }\n \n-            (_, &ty::ty_infer(TyVar(b_id))) => {\n-                let nde_b = self.infcx.get(b_id);\n-                let b_bounds = nde_b.possible_types;\n+            _ => {}\n+        }\n \n-                let b_bnd = option::or(b_bounds.lb, b_bounds.ub);\n-                self.coerce_tys_or_sub(a, b, Some(a), b_bnd)\n+        do self.unpack_actual_value(a) |sty_a| {\n+            match *sty_a {\n+                ty::ty_fn(ref a_f) if a_f.meta.proto == ast::ProtoBare => {\n+                    // Bare functions are coercable to any closure type.\n+                    //\n+                    // FIXME(#3320) this should go away and be\n+                    // replaced with proper inference, got a patch\n+                    // underway - ndm\n+                    self.coerce_from_bare_fn(a, a_f, b)\n+                }\n+                _ => {\n+                    // Otherwise, just use subtyping rules.\n+                    self.subtype(a, b)\n+                }\n             }\n+        }\n+    }\n+\n+    fn subtype(&self, a: ty::t, b: ty::t) -> CoerceResult {\n+        match Sub(**self).tys(a, b) {\n+            Ok(_) => Ok(None),         // No coercion required.\n+            Err(ref e) => Err(*e)\n+        }\n+    }\n \n-            (_, _) => {\n-                self.coerce_tys_or_sub(a, b, Some(a), Some(b))\n+    fn unpack_actual_value(&self,\n+                           a: ty::t,\n+                           f: &fn(&ty::sty) -> CoerceResult) -> CoerceResult\n+    {\n+        match resolve_type(self.infcx, a, try_resolve_tvar_shallow) {\n+            Ok(t) => {\n+                f(&ty::get(t).sty)\n             }\n-        };\n+            Err(e) => {\n+                self.infcx.tcx.sess.span_bug(\n+                    self.span,\n+                    fmt!(\"Failed to resolve even without \\\n+                          any force options: %?\", e));\n+            }\n+        }\n+    }\n+\n+    fn coerce_borrowed_pointer(&self,\n+                               a: ty::t,\n+                               sty_a: &ty::sty,\n+                               b: ty::t,\n+                               mt_b: ty::mt) -> CoerceResult\n+    {\n+        debug!(\"coerce_borrowed_pointer(a=%s, sty_a=%?, b=%s, mt_b=%?)\",\n+               a.inf_str(self.infcx), sty_a,\n+               b.inf_str(self.infcx), mt_b);\n \n-        debug!(\"Coerce.tys end\");\n+        // If we have a parameter of type `&M T_a` and the value\n+        // provided is `expr`, we will be adding an implicit borrow,\n+        // meaning that we convert `f(expr)` to `f(&M *expr)`.  Therefore,\n+        // to type check, we will construct the type that `&M*expr` would\n+        // yield.\n+\n+        let sub = Sub(**self);\n+        let r_borrow = self.infcx.next_region_var_nb(self.span);\n+\n+        let inner_ty = match *sty_a {\n+            ty::ty_box(mt_a) => mt_a.ty,\n+            ty::ty_uniq(mt_a) => mt_a.ty,\n+            ty::ty_rptr(r_a, mt_a) => {\n+                // Ensure that the pointer we are borrowing from lives\n+                // at least as long as the borrowed result.\n+                //\n+                // FIXME(#3148)---in principle this dependency should\n+                // be done more generally\n+                if_ok!(sub.contraregions(r_a, r_borrow));\n+                mt_a.ty\n+            }\n+            _ => {\n+                return self.subtype(a, b);\n+            }\n+        };\n \n-        move r\n+        let a_borrowed = ty::mk_rptr(self.infcx.tcx,\n+                                     r_borrow,\n+                                     mt {ty: inner_ty, mutbl: mt_b.mutbl});\n+        if_ok!(sub.tys(a_borrowed, b));\n+        Ok(Some(@AutoAdjustment {\n+            autoderefs: 1,\n+            autoref: Some(AutoRef {\n+                kind: AutoPtr,\n+                region: r_borrow,\n+                mutbl: mt_b.mutbl\n+            })\n+        }))\n     }\n-}\n \n-impl Coerce {\n-    fn coerce_tys_or_sub(\n-        &self,\n-        +a: ty::t,\n-        +b: ty::t,\n-        +a_bnd: Option<ty::t>,\n-        +b_bnd: Option<ty::t>) -> ares\n+    fn coerce_borrowed_string(&self,\n+                              a: ty::t,\n+                              sty_a: &ty::sty,\n+                              b: ty::t) -> CoerceResult\n     {\n-        debug!(\"Coerce.coerce_tys_or_sub(%s => %s, %s => %s)\",\n-               a.inf_str(self.infcx), b.inf_str(self.infcx),\n-               a_bnd.inf_str(self.infcx), b_bnd.inf_str(self.infcx));\n-        let _r = indenter();\n-\n-        fn is_borrowable(v: ty::vstore) -> bool {\n-            match v {\n-              ty::vstore_fixed(_) | ty::vstore_uniq | ty::vstore_box => true,\n-              ty::vstore_slice(_) => false\n+        debug!(\"coerce_borrowed_string(a=%s, sty_a=%?, b=%s)\",\n+               a.inf_str(self.infcx), sty_a,\n+               b.inf_str(self.infcx));\n+\n+        match *sty_a {\n+            ty::ty_estr(vstore_box) |\n+            ty::ty_estr(vstore_uniq) => {}\n+            _ => {\n+                return self.subtype(a, b);\n             }\n-        }\n+        };\n+\n+        let r_a = self.infcx.next_region_var_nb(self.span);\n+        let a_borrowed = ty::mk_estr(self.infcx.tcx, vstore_slice(r_a));\n+        if_ok!(self.subtype(a_borrowed, b));\n+        Ok(Some(@AutoAdjustment {\n+            autoderefs: 0,\n+            autoref: Some(AutoRef {\n+                kind: AutoBorrowVec,\n+                region: r_a,\n+                mutbl: m_imm\n+            })\n+        }))\n+    }\n \n-        fn borrowable_protos(a_p: ast::Proto, b_p: ast::Proto) -> bool {\n-            match (a_p, b_p) {\n-                (ast::ProtoBox, ast::ProtoBorrowed) => true,\n-                (ast::ProtoUniq, ast::ProtoBorrowed) => true,\n-                _ => false\n+    fn coerce_borrowed_vector(&self,\n+                              a: ty::t,\n+                              sty_a: &ty::sty,\n+                              b: ty::t,\n+                              mt_b: ty::mt) -> CoerceResult\n+    {\n+        debug!(\"coerce_borrowed_vector(a=%s, sty_a=%?, b=%s)\",\n+               a.inf_str(self.infcx), sty_a,\n+               b.inf_str(self.infcx));\n+\n+        let sub = Sub(**self);\n+        let r_borrow = self.infcx.next_region_var_nb(self.span);\n+        let ty_inner = match *sty_a {\n+            ty::ty_evec(mt, vstore_box) => mt.ty,\n+            ty::ty_evec(mt, vstore_uniq) => mt.ty,\n+            ty::ty_evec(mt, vstore_fixed(_)) => mt.ty,\n+            ty::ty_evec(mt, vstore_slice(r_a)) => {\n+                // Ensure that the pointer we are borrowing from lives\n+                // at least as long as the borrowed result.\n+                //\n+                // FIXME(#3148)---in principle this dependency should\n+                // be done more generally\n+                if_ok!(sub.contraregions(r_a, r_borrow));\n+                mt.ty\n             }\n-        }\n+            _ => {\n+                return self.subtype(a, b);\n+            }\n+        };\n \n-        match (a_bnd, b_bnd) {\n-            (Some(a_bnd), Some(b_bnd)) => {\n-                match (&ty::get(a_bnd).sty, &ty::get(b_bnd).sty) {\n-                    // check for a case where a non-region pointer (@, ~) is\n-                    // being coerceed to a region pointer:\n-                    (&ty::ty_box(_), &ty::ty_rptr(r_b, mt_b)) => {\n-                        let nr_b = ty::mk_box(self.infcx.tcx,\n-                                              ty::mt {ty: mt_b.ty,\n-                                                      mutbl: m_const});\n-                        self.try_coerce(1, ty::AutoPtr,\n-                                        a, nr_b,\n-                                        mt_b.mutbl, r_b)\n-                    }\n-                    (&ty::ty_uniq(_), &ty::ty_rptr(r_b, mt_b)) => {\n-                        let nr_b = ty::mk_uniq(self.infcx.tcx,\n-                                               ty::mt {ty: mt_b.ty,\n-                                                       mutbl: m_const});\n-                        self.try_coerce(1, ty::AutoPtr,\n-                                        a, nr_b,\n-                                        mt_b.mutbl, r_b)\n-                    }\n-                    (&ty::ty_estr(vs_a),\n-                     &ty::ty_estr(ty::vstore_slice(r_b)))\n-                    if is_borrowable(vs_a) => {\n-                        let nr_b = ty::mk_estr(self.infcx.tcx, vs_a);\n-                        self.try_coerce(0, ty::AutoBorrowVec,\n-                                        a, nr_b,\n-                                        m_imm, r_b)\n-                    }\n-\n-                    (&ty::ty_evec(_, vs_a),\n-                     &ty::ty_evec(mt_b, ty::vstore_slice(r_b)))\n-                    if is_borrowable(vs_a) => {\n-                        let nr_b = ty::mk_evec(self.infcx.tcx,\n-                                               ty::mt {ty: mt_b.ty,\n-                                                       mutbl: m_const},\n-                                               vs_a);\n-                        self.try_coerce(0, ty::AutoBorrowVec,\n-                                        a, nr_b,\n-                                        mt_b.mutbl, r_b)\n-                    }\n-\n-                    (&ty::ty_fn(ref a_f), &ty::ty_fn(ref b_f))\n-                    if borrowable_protos(a_f.meta.proto, b_f.meta.proto) => {\n-                        let nr_b = ty::mk_fn(self.infcx.tcx, ty::FnTyBase {\n-                            meta: ty::FnMeta {proto: a_f.meta.proto,\n-                                              ..b_f.meta},\n-                            sig: copy b_f.sig\n-                        });\n-                        self.try_coerce(0, ty::AutoBorrowFn,\n-                                        a, nr_b, m_imm, b_f.meta.region)\n-                    }\n-\n-                    (&ty::ty_fn(ref a_f), &ty::ty_fn(ref b_f))\n-                    if a_f.meta.proto == ast::ProtoBare => {\n-                        let b1_f = ty::FnTyBase {\n-                            meta: ty::FnMeta {proto: ast::ProtoBare,\n-                                              ..b_f.meta},\n-                            sig: copy b_f.sig\n-                        };\n-                        // Eventually we will need to add some sort of\n-                        // adjustment here so that trans can add an\n-                        // extra NULL env pointer:\n-                        to_ares(Sub(**self).fns(a_f, &b1_f))\n-                    }\n-\n-                    // check for &T being coerced to *T:\n-                    (&ty::ty_rptr(_, ref a_t), &ty::ty_ptr(ref b_t)) => {\n-                        to_ares(Sub(**self).mts(*a_t, *b_t))\n-                    }\n-\n-                    // otherwise, coercement follows normal subtype rules:\n-                    _ => {\n-                        to_ares(Sub(**self).tys(a, b))\n-                    }\n-                }\n+        let a_borrowed = ty::mk_evec(self.infcx.tcx,\n+                                     mt {ty: ty_inner, mutbl: mt_b.mutbl},\n+                                     vstore_slice(r_borrow));\n+        if_ok!(sub.tys(a_borrowed, b));\n+        Ok(Some(@AutoAdjustment {\n+            autoderefs: 0,\n+            autoref: Some(AutoRef {\n+                kind: AutoBorrowVec,\n+                region: r_borrow,\n+                mutbl: mt_b.mutbl\n+            })\n+        }))\n+    }\n+\n+    fn coerce_borrowed_fn(&self,\n+                          a: ty::t,\n+                          sty_a: &ty::sty,\n+                          b: ty::t) -> CoerceResult\n+    {\n+        debug!(\"coerce_borrowed_fn(a=%s, sty_a=%?, b=%s)\",\n+               a.inf_str(self.infcx), sty_a,\n+               b.inf_str(self.infcx));\n+\n+        let fn_ty = match *sty_a {\n+            ty::ty_fn(ref f) if f.meta.proto == ast::ProtoBox => {f}\n+            ty::ty_fn(ref f) if f.meta.proto == ast::ProtoUniq => {f}\n+            ty::ty_fn(ref f) if f.meta.proto == ast::ProtoBare => {\n+                return self.coerce_from_bare_fn(a, f, b);\n             }\n             _ => {\n-                // if insufficient bounds were available, just follow\n-                // normal subtype rules:\n-                to_ares(Sub(**self).tys(a, b))\n+                return self.subtype(a, b);\n             }\n+        };\n+\n+        let r_borrow = self.infcx.next_region_var_nb(self.span);\n+        let meta = FnMeta {proto: ast::ProtoBorrowed,\n+                           region: r_borrow,\n+                           ..fn_ty.meta};\n+        let a_borrowed = ty::mk_fn(self.infcx.tcx,\n+                                   FnTyBase {meta: meta,\n+                                             sig: copy fn_ty.sig});\n+\n+        if_ok!(self.subtype(a_borrowed, b));\n+        Ok(Some(@AutoAdjustment {\n+            autoderefs: 0,\n+            autoref: Some(AutoRef {\n+                kind: AutoBorrowFn,\n+                region: r_borrow,\n+                mutbl: m_imm\n+            })\n+        }))\n+    }\n+\n+    fn coerce_from_bare_fn(&self,\n+                           a: ty::t,\n+                           fn_ty_a: &ty::FnTy,\n+                           b: ty::t) -> CoerceResult\n+    {\n+        do self.unpack_actual_value(b) |sty_b| {\n+            self.coerce_from_bare_fn_post_unpack(a, fn_ty_a, b, sty_b)\n         }\n     }\n \n-    /// Given an coercement from a type like `@a` to `&r_b/m nr_b`,\n-    /// this function checks that `a <: nr_b`.  In that case, the\n-    /// coercement is permitted, so it constructs a fresh region\n-    /// variable `r_a >= r_b` and returns a corresponding coercement\n-    /// record.  See the discussion at the top of this file for more\n-    /// details.\n-    fn try_coerce(&self,\n-                  autoderefs: uint,\n-                  kind: ty::AutoRefKind,\n-                  a: ty::t,\n-                  nr_b: ty::t,\n-                  m: ast::mutability,\n-                  r_b: ty::Region) -> ares\n+    fn coerce_from_bare_fn_post_unpack(&self,\n+                                       a: ty::t,\n+                                       fn_ty_a: &ty::FnTy,\n+                                       b: ty::t,\n+                                       sty_b: &ty::sty) -> CoerceResult\n     {\n-        debug!(\"try_coerce(a=%s, nr_b=%s, m=%?, r_b=%s)\",\n-               a.inf_str(self.infcx),\n-               nr_b.inf_str(self.infcx),\n-               m,\n-               r_b.inf_str(self.infcx));\n-\n-        do indent {\n-            let sub = Sub(**self);\n-            do sub.tys(a, nr_b).chain |_t| {\n-                let r_a = self.infcx.next_region_var_nb(self.span);\n-                do sub.contraregions(r_a, r_b).chain |_r| {\n-                    Ok(Some(@ty::AutoAdjustment {\n-                        autoderefs: autoderefs,\n-                        autoref: Some(ty::AutoRef {\n-                            kind: kind,\n-                            region: r_a,\n-                            mutbl: m\n-                        })\n-                    }))\n-                }\n+        debug!(\"coerce_from_bare_fn(a=%s, b=%s)\",\n+               a.inf_str(self.infcx), b.inf_str(self.infcx));\n+\n+        let fn_ty_b = match *sty_b {\n+            ty::ty_fn(ref f) if f.meta.proto != ast::ProtoBare => {f}\n+            _ => {\n+                return self.subtype(a, b);\n             }\n-        }\n+        };\n+\n+            // for now, bare fn and closures have the same\n+            // representation\n+        let a_adapted = ty::mk_fn(self.infcx.tcx,\n+                                  FnTyBase {meta: copy fn_ty_b.meta,\n+                                            sig: copy fn_ty_a.sig});\n+        self.subtype(a_adapted, b)\n     }\n-}\n \n+    fn coerce_unsafe_ptr(&self,\n+                         a: ty::t,\n+                         sty_a: &ty::sty,\n+                         b: ty::t) -> CoerceResult\n+    {\n+        debug!(\"coerce_unsafe_ptr(a=%s, sty_a=%?, b=%s)\",\n+               a.inf_str(self.infcx), sty_a,\n+               b.inf_str(self.infcx));\n+\n+        let mt_a = match *sty_a {\n+            ty::ty_rptr(_, mt) => mt,\n+            _ => {\n+                return self.subtype(a, b);\n+            }\n+        };\n+\n+        // borrowed pointers and unsafe pointers have the same\n+        // representation, so just check that the types which they\n+        // point at are compatible:\n+        let a_unsafe = ty::mk_ptr(self.infcx.tcx, mt_a);\n+        self.subtype(a_unsafe, b)\n+    }\n+}"}, {"sha": "cac5fa5feb1c1a6412b06d51a25d580d42c32137", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=2b67d88809d9f6ddc4686ee514cb78200db1d737", "patch": "@@ -317,12 +317,11 @@ export uok;\n export cyclic_ty, unresolved_ty, region_var_bound_by_region_var;\n export Bound, Bounds;\n export ures;\n-export ares;\n+export CoerceResult;\n export infer_ctxt;\n export fixup_err;\n export IntVarValue, IntType, UintType;\n \n-mod coercion;\n #[legacy_exports]\n mod combine;\n #[legacy_exports]\n@@ -341,14 +340,15 @@ mod sub;\n mod to_str;\n #[legacy_exports]\n mod unify;\n+mod coercion;\n \n type Bound<T> = Option<T>;\n type Bounds<T> = {lb: Bound<T>, ub: Bound<T>};\n \n type cres<T> = Result<T,ty::type_err>; // \"combine result\"\n type ures = cres<()>; // \"unify result\"\n type fres<T> = Result<T, fixup_err>; // \"fixup result\"\n-type ares = cres<Option<@ty::AutoAdjustment>>; // \"assignment result\"\n+type CoerceResult = cres<Option<@ty::AutoAdjustment>>;\n \n struct InferCtxt {\n     tcx: ty::ctxt,\n@@ -457,7 +457,8 @@ fn mk_eqty(cx: @InferCtxt, a_is_expected: bool, span: span,\n }\n \n fn mk_coercety(cx: @InferCtxt, a_is_expected: bool, span: span,\n-               a: ty::t, b: ty::t) -> ares {\n+               a: ty::t, b: ty::t) -> CoerceResult\n+{\n     debug!(\"mk_coercety(%s -> %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {"}, {"sha": "b25c4db8a90b767b546403256f6a2292f88584ea", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=2b67d88809d9f6ddc4686ee514cb78200db1d737", "patch": "@@ -78,6 +78,7 @@ const force_all: uint           = 0b1111100000;\n \n const not_regions: uint         = !(force_rvar | resolve_rvar);\n \n+const try_resolve_tvar_shallow: uint = 0;\n const resolve_and_force_all_but_regions: uint =\n     (resolve_all | force_all) & not_regions;\n "}, {"sha": "19cdfe784d2b03a2078c6c224c321e66f7277db6", "filename": "src/test/compile-fail/borrowck-borrowed-uniq-rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs?ref=2b67d88809d9f6ddc4686ee514cb78200db1d737", "patch": "@@ -16,9 +16,9 @@ use std::map;\n fn main() {\n     let buggy_map :HashMap<uint, &uint> =\n       HashMap::<uint, &uint>();\n-    buggy_map.insert(42, ~1); //~ ERROR illegal borrow\n-    \n+    buggy_map.insert(42, &*~1); //~ ERROR illegal borrow\n+\n     // but it is ok if we use a temporary\n     let tmp = ~2;\n-    buggy_map.insert(43, tmp);\n+    buggy_map.insert(43, &*tmp);\n }"}, {"sha": "c4cdbcb67e2bed1ac07c3215e295f8ce4fbba596", "filename": "src/test/compile-fail/coerce-bad-variance.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Ftest%2Fcompile-fail%2Fcoerce-bad-variance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Ftest%2Fcompile-fail%2Fcoerce-bad-variance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoerce-bad-variance.rs?ref=2b67d88809d9f6ddc4686ee514cb78200db1d737", "patch": "@@ -0,0 +1,17 @@\n+fn mutate(x: &mut @const int) {\n+    *x = @3;\n+}\n+\n+fn give_away1(y: @mut @mut int) {\n+    mutate(y); //~ ERROR values differ in mutability\n+}\n+\n+fn give_away2(y: @mut @const int) {\n+    mutate(y);\n+}\n+\n+fn give_away3(y: @mut @int) {\n+    mutate(y); //~ ERROR values differ in mutability\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "356a64498219ab9a5c347e9571dd54c927caa15a", "filename": "src/test/compile-fail/issue-4500.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Ftest%2Fcompile-fail%2Fissue-4500.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Ftest%2Fcompile-fail%2Fissue-4500.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4500.rs?ref=2b67d88809d9f6ddc4686ee514cb78200db1d737", "patch": "@@ -10,6 +10,5 @@\n \n fn main () {\n     let mut _p: & int = & 4;\n-    _p = ~3; //~ ERROR illegal borrow: borrowed value does not live long enough\n-    //~^ NOTE ...but borrowed value is only valid for the statement\n+    _p = &*~3; //~ ERROR illegal borrow\n }"}, {"sha": "69f07e3e77492bac15bea532ee44dbde83cd7e40", "filename": "src/test/compile-fail/kindck-owned-trait-contains.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs?ref=2b67d88809d9f6ddc4686ee514cb78200db1d737", "patch": "@@ -20,11 +20,12 @@ fn repeater<A:Copy>(v: @A) -> repeat<A> {\n }\n \n fn main() {\n-    // Here, an error results as the type of y is inferred to\n-    // repeater<&lt/3> where lt is the block.\n-    let y = {\n-        let x: &blk/int = &3; //~ ERROR cannot infer an appropriate lifetime\n+    // Error results because the type of is inferred to be\n+    // repeat<&blk/int> where blk is the lifetime of the block below.\n+\n+    let y = { //~ ERROR reference is not valid\n+        let x: &blk/int = &3;\n         repeater(@x)\n     };\n-    assert 3 == *(y.get());\n+    assert 3 == *(y.get()); //~ ERROR reference is not valid\n }\n\\ No newline at end of file"}, {"sha": "f9992429733450371a41cee900a79929a0d05e52", "filename": "src/test/compile-fail/regions-scoping.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Ftest%2Fcompile-fail%2Fregions-scoping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Ftest%2Fcompile-fail%2Fregions-scoping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-scoping.rs?ref=2b67d88809d9f6ddc4686ee514cb78200db1d737", "patch": "@@ -25,8 +25,7 @@ fn nested(x: &x/int) {  // (1)\n             //~^ ERROR cannot infer an appropriate lifetime\n \n             return z(y, x, x);\n-            //~^ ERROR mismatched types: expected `&x/int` but found `&y/int`\n-            //~^^ ERROR mismatched types: expected `&y/int` but found `&x/int`\n+            //~^ ERROR cannot infer an appropriate lifetime\n         }\n     ) |foo| {\n "}, {"sha": "3c9748f29d9862a36a0f46ab1908966cb7342546", "filename": "src/test/run-pass/coerce-reborrow-imm-ptr-arg.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-ptr-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-ptr-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-ptr-arg.rs?ref=2b67d88809d9f6ddc4686ee514cb78200db1d737", "patch": "@@ -0,0 +1,17 @@\n+pure fn negate(x: &int) -> int {\n+    -*x\n+}\n+\n+fn negate_mut(y: &mut int) -> int {\n+    negate(y)\n+}\n+\n+fn negate_imm(y: &int) -> int {\n+    negate(y)\n+}\n+\n+fn negate_const(y: &const int) -> int {\n+    negate(y)\n+}\n+\n+fn main() {}"}, {"sha": "0d8f40677f8b8d125d302567234f281ae3872cf5", "filename": "src/test/run-pass/coerce-reborrow-imm-ptr-rcvr.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-ptr-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-ptr-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-ptr-rcvr.rs?ref=2b67d88809d9f6ddc4686ee514cb78200db1d737", "patch": "@@ -0,0 +1,16 @@\n+struct SpeechMaker {\n+    speeches: uint\n+}\n+\n+impl SpeechMaker {\n+    pure fn how_many(&self) -> uint { self.speeches }\n+}\n+\n+fn foo(speaker: &const SpeechMaker) -> uint {\n+    speaker.how_many() + 33\n+}\n+\n+fn main() {\n+    let mut lincoln = SpeechMaker {speeches: 22};\n+    assert foo(&const lincoln) == 55;\n+}"}, {"sha": "54a6b35b8baa7449ccb21a1a9aa5bf581052ac4c", "filename": "src/test/run-pass/coerce-reborrow-imm-vec-arg.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-arg.rs?ref=2b67d88809d9f6ddc4686ee514cb78200db1d737", "patch": "@@ -0,0 +1,19 @@\n+pure fn sum(x: &[int]) -> int {\n+    let mut sum = 0;\n+    for x.each |y| { sum += *y; }\n+    return sum;\n+}\n+\n+fn sum_mut(y: &[mut int]) -> int {\n+    sum(y)\n+}\n+\n+fn sum_imm(y: &[int]) -> int {\n+    sum(y)\n+}\n+\n+fn sum_const(y: &[const int]) -> int {\n+    sum(y)\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "24fb5cbd883018c2c62672229500086c10e0ba22", "filename": "src/test/run-pass/coerce-reborrow-imm-vec-rcvr.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-rcvr.rs?ref=2b67d88809d9f6ddc4686ee514cb78200db1d737", "patch": "@@ -0,0 +1,18 @@\n+fn foo(v: &[const uint]) -> ~[uint] {\n+    v.to_vec()\n+}\n+\n+fn bar(v: &[mut uint]) -> ~[uint] {\n+    v.to_vec()\n+}\n+\n+fn bip(v: &[uint]) -> ~[uint] {\n+    v.to_vec()\n+}\n+\n+fn main() {\n+    let mut the_vec = ~[1, 2, 3, 100];\n+    assert the_vec == foo(the_vec);\n+    assert the_vec == bar(the_vec);\n+    assert the_vec == bip(the_vec);\n+}"}, {"sha": "4579907dfbd4998334d28eae22057a3af11a7d31", "filename": "src/test/run-pass/coerce-reborrow-mut-ptr-arg.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-ptr-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-ptr-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-ptr-arg.rs?ref=2b67d88809d9f6ddc4686ee514cb78200db1d737", "patch": "@@ -0,0 +1,22 @@\n+struct SpeechMaker {\n+    speeches: uint\n+}\n+\n+fn talk(x: &mut SpeechMaker) {\n+    x.speeches += 1;\n+}\n+\n+fn give_a_few_speeches(speaker: &mut SpeechMaker) {\n+\n+    // Here speaker is reborrowed for each call, so we don't get errors\n+    // about speaker being moved.\n+\n+    talk(speaker);\n+    talk(speaker);\n+    talk(speaker);\n+}\n+\n+fn main() {\n+    let mut lincoln = SpeechMaker {speeches: 22};\n+    give_a_few_speeches(&mut lincoln);\n+}"}, {"sha": "c915c01416e8ede7618ddc72d27140562ef77985", "filename": "src/test/run-pass/coerce-reborrow-mut-ptr-rcvr.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-ptr-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-ptr-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-ptr-rcvr.rs?ref=2b67d88809d9f6ddc4686ee514cb78200db1d737", "patch": "@@ -0,0 +1,24 @@\n+struct SpeechMaker {\n+    speeches: uint\n+}\n+\n+impl SpeechMaker {\n+    fn talk(&mut self) {\n+        self.speeches += 1;\n+    }\n+}\n+\n+fn give_a_few_speeches(speaker: &mut SpeechMaker) {\n+\n+    // Here speaker is reborrowed for each call, so we don't get errors\n+    // about speaker being moved.\n+\n+    speaker.talk();\n+    speaker.talk();\n+    speaker.talk();\n+}\n+\n+fn main() {\n+    let mut lincoln = SpeechMaker {speeches: 22};\n+    give_a_few_speeches(&mut lincoln);\n+}"}, {"sha": "0cce52e7dc8d3a0f142e4769e0fa98c71d771787", "filename": "src/test/run-pass/coerce-reborrow-mut-vec-arg.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-arg.rs?ref=2b67d88809d9f6ddc4686ee514cb78200db1d737", "patch": "@@ -0,0 +1,15 @@\n+trait Reverser {\n+    fn reverse(&self);\n+}\n+\n+fn bar(v: &[mut uint]) {\n+    vec::reverse(v);\n+    vec::reverse(v);\n+    vec::reverse(v);\n+}\n+\n+fn main() {\n+    let mut the_vec = ~[1, 2, 3, 100];\n+    bar(the_vec);\n+    assert the_vec == ~[100, 3, 2, 1];\n+}"}, {"sha": "9fb748f049fd624a3a6edcb2d2d71df522cb5774", "filename": "src/test/run-pass/coerce-reborrow-mut-vec-rcvr.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs?ref=2b67d88809d9f6ddc4686ee514cb78200db1d737", "patch": "@@ -0,0 +1,21 @@\n+trait Reverser {\n+    fn reverse(&self);\n+}\n+\n+impl &[mut uint] : Reverser {\n+    fn reverse(&self) {\n+        vec::reverse(*self);\n+    }\n+}\n+\n+fn bar(v: &[mut uint]) {\n+    v.reverse();\n+    v.reverse();\n+    v.reverse();\n+}\n+\n+fn main() {\n+    let mut the_vec = ~[1, 2, 3, 100];\n+    bar(the_vec);\n+    assert the_vec == ~[100, 3, 2, 1];\n+}"}, {"sha": "8a7ebb8d129e00b75019eafb98d9b7801d828ab4", "filename": "src/test/run-pass/issue-3026.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Ftest%2Frun-pass%2Fissue-3026.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Ftest%2Frun-pass%2Fissue-3026.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3026.rs?ref=2b67d88809d9f6ddc4686ee514cb78200db1d737", "patch": "@@ -17,5 +17,5 @@ use std::map;\n fn main() {\n     let buggy_map :HashMap<uint, &uint> = HashMap::<uint, &uint>();\n     let x = ~1;\n-    buggy_map.insert(42, x);\n+    buggy_map.insert(42, &*x);\n }"}, {"sha": "453d556b13c994d0a2b468af5918327a9296e88e", "filename": "src/test/run-pass/let-assignability.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Ftest%2Frun-pass%2Flet-assignability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b67d88809d9f6ddc4686ee514cb78200db1d737/src%2Ftest%2Frun-pass%2Flet-assignability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flet-assignability.rs?ref=2b67d88809d9f6ddc4686ee514cb78200db1d737", "patch": "@@ -14,15 +14,7 @@ fn f() {\n     io::println(b);\n }\n \n-fn g() {\n-    let c = ~\"world\";\n-    let d: &str;\n-    d = c;\n-    io::println(d);\n-}\n-\n fn main() {\n     f();\n-    g();\n }\n "}]}