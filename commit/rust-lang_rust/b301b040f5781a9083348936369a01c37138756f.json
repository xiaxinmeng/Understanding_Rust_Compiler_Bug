{"sha": "b301b040f5781a9083348936369a01c37138756f", "node_id": "C_kwDOAAsO6NoAKGIzMDFiMDQwZjU3ODFhOTA4MzM0ODkzNjM2OWEwMWMzNzEzODc1NmY", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2022-03-09T18:50:24Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2022-03-14T11:08:37Z"}, "message": "Add const generics", "tree": {"sha": "c231ce85a1f884b01b29e3e2d043f14faf88aaea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c231ce85a1f884b01b29e3e2d043f14faf88aaea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b301b040f5781a9083348936369a01c37138756f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b301b040f5781a9083348936369a01c37138756f", "html_url": "https://github.com/rust-lang/rust/commit/b301b040f5781a9083348936369a01c37138756f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b301b040f5781a9083348936369a01c37138756f/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e8515870674983cce5b945946045bc1e9b80200", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e8515870674983cce5b945946045bc1e9b80200", "html_url": "https://github.com/rust-lang/rust/commit/5e8515870674983cce5b945946045bc1e9b80200"}], "stats": {"total": 1799, "additions": 1272, "deletions": 527}, "files": [{"sha": "5d084bcf1c499709d57e2bc0918ad402e081decd", "filename": "Cargo.lock", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b301b040f5781a9083348936369a01c37138756f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b301b040f5781a9083348936369a01c37138756f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b301b040f5781a9083348936369a01c37138756f", "patch": "@@ -171,9 +171,9 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"chalk-derive\"\n-version = \"0.76.0\"\n+version = \"0.79.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"58c24b8052ea1e3adbb6f9ab7ba5fcc18b9d12591c042de4c833f709ce81e0e0\"\n+checksum = \"0b14364774396379d5c488e73d88e0a6d2b51acd0dac9c8359e2f84c58cf3a16\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -183,9 +183,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-ir\"\n-version = \"0.76.0\"\n+version = \"0.79.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f3cad5c3f1edd4b4a2c9bda24ae558ceb4f88336f88f944c2e35d0bfeb13c818\"\n+checksum = \"cd571e8931d3075f562a2d460bfe3028a9c7b343876765cce95b6143a76b882e\"\n dependencies = [\n  \"bitflags\",\n  \"chalk-derive\",\n@@ -194,9 +194,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-recursive\"\n-version = \"0.76.0\"\n+version = \"0.79.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e68ba0c7219f34738b66c0c992438c644ca33f4d8a29da3d41604299c7eaf419\"\n+checksum = \"54ceedab35607f4680d02de80f8be005af0ad5c1dcfec56cfd849d33da5fe736\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n@@ -207,9 +207,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-solve\"\n-version = \"0.76.0\"\n+version = \"0.79.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"94533188d3452bc72cbd5618d166f45fc7646b674ad3fe9667d557bc25236dee\"\n+checksum = \"9e31bb853cf921365759346db05d833f969e330462432bf38c9c2be1e78a9abd\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\","}, {"sha": "9edb6de9dfbcfe92c2fd837875b7cdd429171dc7", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=b301b040f5781a9083348936369a01c37138756f", "patch": "@@ -256,7 +256,7 @@ impl HirDisplay for TypeParam {\n         }\n \n         let bounds = f.db.generic_predicates_for_param(self.id.parent(), self.id.into(), None);\n-        let substs = TyBuilder::type_params_subst(f.db, self.id.parent());\n+        let substs = TyBuilder::placeholder_subst(f.db, self.id.parent());\n         let predicates: Vec<_> =\n             bounds.iter().cloned().map(|b| b.substitute(Interner, &substs)).collect();\n         let krate = self.id.parent().krate(f.db).id;\n@@ -292,8 +292,9 @@ impl HirDisplay for ConstParam {\n fn write_generic_params(def: GenericDefId, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n     let params = f.db.generic_params(def);\n     if params.lifetimes.is_empty()\n+        && params.type_or_consts.iter().all(|x| x.1.const_param().is_none())\n         && params\n-            .tocs\n+            .type_or_consts\n             .iter()\n             .filter_map(|x| x.1.type_param())\n             .all(|param| !matches!(param.provenance, TypeParamProvenance::TypeParamList))\n@@ -315,7 +316,7 @@ fn write_generic_params(def: GenericDefId, f: &mut HirFormatter) -> Result<(), H\n         delim(f)?;\n         write!(f, \"{}\", lifetime.name)?;\n     }\n-    for (_, ty) in params.tocs.iter() {\n+    for (_, ty) in params.type_or_consts.iter() {\n         if let Some(name) = &ty.name() {\n             match ty {\n                 TypeOrConstParamData::TypeParamData(ty) => {\n@@ -348,7 +349,9 @@ fn write_where_clause(def: GenericDefId, f: &mut HirFormatter) -> Result<(), Hir\n     // unnamed type targets are displayed inline with the argument itself, e.g. `f: impl Y`.\n     let is_unnamed_type_target = |target: &WherePredicateTypeTarget| match target {\n         WherePredicateTypeTarget::TypeRef(_) => false,\n-        WherePredicateTypeTarget::TypeOrConstParam(id) => params.tocs[*id].name().is_none(),\n+        WherePredicateTypeTarget::TypeOrConstParam(id) => {\n+            params.type_or_consts[*id].name().is_none()\n+        }\n     };\n \n     let has_displayable_predicate = params\n@@ -364,10 +367,12 @@ fn write_where_clause(def: GenericDefId, f: &mut HirFormatter) -> Result<(), Hir\n \n     let write_target = |target: &WherePredicateTypeTarget, f: &mut HirFormatter| match target {\n         WherePredicateTypeTarget::TypeRef(ty) => ty.hir_fmt(f),\n-        WherePredicateTypeTarget::TypeOrConstParam(id) => match &params.tocs[*id].name() {\n-            Some(name) => write!(f, \"{}\", name),\n-            None => write!(f, \"{{unnamed}}\"),\n-        },\n+        WherePredicateTypeTarget::TypeOrConstParam(id) => {\n+            match &params.type_or_consts[*id].name() {\n+                Some(name) => write!(f, \"{}\", name),\n+                None => write!(f, \"{{unnamed}}\"),\n+            }\n+        }\n     };\n \n     write!(f, \"\\nwhere\")?;"}, {"sha": "ee4ff0aebbd4884dcec626f0c95398fac5175c68", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 50, "deletions": 18, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=b301b040f5781a9083348936369a01c37138756f", "patch": "@@ -55,17 +55,19 @@ use hir_def::{\n use hir_expand::{name::name, MacroCallKind};\n use hir_ty::{\n     autoderef,\n-    consteval::{eval_const, ComputedExpr, ConstEvalCtx, ConstEvalError, ConstExt},\n+    consteval::{\n+        eval_const, unknown_const_as_generic, ComputedExpr, ConstEvalCtx, ConstEvalError, ConstExt,\n+    },\n     could_unify,\n     diagnostics::BodyValidationDiagnostic,\n     method_resolution::{self, TyFingerprint},\n     primitive::UintTy,\n     subst_prefix,\n     traits::FnTrait,\n     AliasEq, AliasTy, BoundVar, CallableDefId, CallableSig, Canonical, CanonicalVarKinds, Cast,\n-    DebruijnIndex, InEnvironment, Interner, QuantifiedWhereClause, Scalar, Solution, Substitution,\n-    TraitEnvironment, TraitRefExt, Ty, TyBuilder, TyDefId, TyExt, TyKind, TyVariableKind,\n-    WhereClause,\n+    DebruijnIndex, GenericArgData, InEnvironment, Interner, ParamKind, QuantifiedWhereClause,\n+    Scalar, Solution, Substitution, TraitEnvironment, TraitRefExt, Ty, TyBuilder, TyDefId, TyExt,\n+    TyKind, TyVariableKind, WhereClause,\n };\n use itertools::Itertools;\n use nameres::diagnostics::DefDiagnosticKind;\n@@ -796,7 +798,7 @@ impl Field {\n             VariantDef::Union(it) => it.id.into(),\n             VariantDef::Variant(it) => it.parent.id.into(),\n         };\n-        let substs = TyBuilder::type_params_subst(db, generic_def_id);\n+        let substs = TyBuilder::placeholder_subst(db, generic_def_id);\n         let ty = db.field_types(var_id)[self.id].clone().substitute(Interner, &substs);\n         Type::new(db, self.parent.module(db).id.krate(), var_id, ty)\n     }\n@@ -983,7 +985,10 @@ impl_from!(Struct, Union, Enum for Adt);\n impl Adt {\n     pub fn has_non_default_type_params(self, db: &dyn HirDatabase) -> bool {\n         let subst = db.generic_defaults(self.into());\n-        subst.iter().any(|ty| ty.skip_binders().is_unknown())\n+        subst.iter().any(|ty| match ty.skip_binders().data(Interner) {\n+            GenericArgData::Ty(x) => x.is_unknown(),\n+            _ => false,\n+        })\n     }\n \n     /// Turns this ADT into a type. Any type parameters of the ADT will be\n@@ -1680,7 +1685,10 @@ pub struct TypeAlias {\n impl TypeAlias {\n     pub fn has_non_default_type_params(self, db: &dyn HirDatabase) -> bool {\n         let subst = db.generic_defaults(self.id.into());\n-        subst.iter().any(|ty| ty.skip_binders().is_unknown())\n+        subst.iter().any(|ty| match ty.skip_binders().data(Interner) {\n+            GenericArgData::Ty(x) => x.is_unknown(),\n+            _ => false,\n+        })\n     }\n \n     pub fn module(self, db: &dyn HirDatabase) -> Module {\n@@ -2047,7 +2055,7 @@ impl_from!(\n impl GenericDef {\n     pub fn params(self, db: &dyn HirDatabase) -> Vec<GenericParam> {\n         let generics = db.generic_params(self.into());\n-        let ty_params = generics.tocs.iter().map(|(local_id, _)| {\n+        let ty_params = generics.type_or_consts.iter().map(|(local_id, _)| {\n             let toc = TypeOrConstParam { id: TypeOrConstParamId { parent: self.into(), local_id } };\n             match toc.split(db) {\n                 Either::Left(x) => GenericParam::ConstParam(x),\n@@ -2067,7 +2075,7 @@ impl GenericDef {\n     pub fn type_params(self, db: &dyn HirDatabase) -> Vec<TypeOrConstParam> {\n         let generics = db.generic_params(self.into());\n         generics\n-            .tocs\n+            .type_or_consts\n             .iter()\n             .map(|(local_id, _)| TypeOrConstParam {\n                 id: TypeOrConstParamId { parent: self.into(), local_id },\n@@ -2351,9 +2359,14 @@ impl TypeParam {\n         let resolver = self.id.parent().resolver(db.upcast());\n         let krate = self.id.parent().module(db.upcast()).krate();\n         let ty = params.get(local_idx)?.clone();\n-        let subst = TyBuilder::type_params_subst(db, self.id.parent());\n+        let subst = TyBuilder::placeholder_subst(db, self.id.parent());\n         let ty = ty.substitute(Interner, &subst_prefix(&subst, local_idx));\n-        Some(Type::new_with_resolver_inner(db, krate, &resolver, ty))\n+        match ty.data(Interner) {\n+            GenericArgData::Ty(x) => {\n+                Some(Type::new_with_resolver_inner(db, krate, &resolver, x.clone()))\n+            }\n+            _ => None,\n+        }\n     }\n }\n \n@@ -2389,7 +2402,7 @@ impl ConstParam {\n \n     pub fn name(self, db: &dyn HirDatabase) -> Name {\n         let params = db.generic_params(self.id.parent());\n-        match params.tocs[self.id.local_id()].name() {\n+        match params.type_or_consts[self.id.local_id()].name() {\n             Some(x) => x.clone(),\n             None => {\n                 never!();\n@@ -2421,7 +2434,7 @@ pub struct TypeOrConstParam {\n impl TypeOrConstParam {\n     pub fn name(self, db: &dyn HirDatabase) -> Name {\n         let params = db.generic_params(self.id.parent);\n-        match params.tocs[self.id.local_id].name() {\n+        match params.type_or_consts[self.id.local_id].name() {\n             Some(n) => n.clone(),\n             _ => Name::missing(),\n         }\n@@ -2437,12 +2450,12 @@ impl TypeOrConstParam {\n \n     pub fn split(self, db: &dyn HirDatabase) -> Either<ConstParam, TypeParam> {\n         let params = db.generic_params(self.id.parent);\n-        match &params.tocs[self.id.local_id] {\n+        match &params.type_or_consts[self.id.local_id] {\n             hir_def::generics::TypeOrConstParamData::TypeParamData(_) => {\n-                Either::Right(TypeParam { id: self.id.into() })\n+                Either::Right(TypeParam { id: TypeParamId::from_unchecked(self.id) })\n             }\n             hir_def::generics::TypeOrConstParamData::ConstParamData(_) => {\n-                Either::Left(ConstParam { id: self.id.into() })\n+                Either::Left(ConstParam { id: ConstParamId::from_unchecked(self.id) })\n             }\n         }\n     }\n@@ -2688,9 +2701,19 @@ impl Type {\n     }\n \n     pub fn impls_trait(&self, db: &dyn HirDatabase, trait_: Trait, args: &[Type]) -> bool {\n+        let mut it = args.iter().map(|t| t.ty.clone());\n         let trait_ref = TyBuilder::trait_ref(db, trait_.id)\n             .push(self.ty.clone())\n-            .fill(args.iter().map(|t| t.ty.clone()))\n+            .fill(|x| {\n+                let r = it.next().unwrap();\n+                match x {\n+                    ParamKind::Type => GenericArgData::Ty(r).intern(Interner),\n+                    ParamKind::Const(ty) => {\n+                        // FIXME: this code is not covered in tests.\n+                        unknown_const_as_generic(ty.clone())\n+                    }\n+                }\n+            })\n             .build();\n \n         let goal = Canonical {\n@@ -2707,9 +2730,18 @@ impl Type {\n         args: &[Type],\n         alias: TypeAlias,\n     ) -> Option<Type> {\n+        let mut args = args.iter();\n         let projection = TyBuilder::assoc_type_projection(db, alias.id)\n             .push(self.ty.clone())\n-            .fill(args.iter().map(|t| t.ty.clone()))\n+            .fill(|x| {\n+                // FIXME: this code is not covered in tests.\n+                match x {\n+                    ParamKind::Type => {\n+                        GenericArgData::Ty(args.next().unwrap().ty.clone()).intern(Interner)\n+                    }\n+                    ParamKind::Const(ty) => unknown_const_as_generic(ty.clone()),\n+                }\n+            })\n             .build();\n         let goal = hir_ty::make_canonical(\n             InEnvironment::new("}, {"sha": "4672e7db40c25fe30a4c3cf245221dcdf3f9d23a", "filename": "crates/hir/src/semantics/source_to_def.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=b301b040f5781a9083348936369a01c37138756f", "patch": "@@ -279,7 +279,7 @@ impl SourceToDefCtx<'_, '_> {\n     pub(super) fn type_param_to_def(&mut self, src: InFile<ast::TypeParam>) -> Option<TypeParamId> {\n         let container: ChildContainer = self.find_generic_param_container(src.syntax())?.into();\n         let dyn_map = self.cache_for(container, src.file_id);\n-        dyn_map[keys::TYPE_PARAM].get(&src.value).copied().map(|x| x.into())\n+        dyn_map[keys::TYPE_PARAM].get(&src.value).copied().map(|x| TypeParamId::from_unchecked(x))\n     }\n \n     pub(super) fn lifetime_param_to_def(\n@@ -297,7 +297,7 @@ impl SourceToDefCtx<'_, '_> {\n     ) -> Option<ConstParamId> {\n         let container: ChildContainer = self.find_generic_param_container(src.syntax())?.into();\n         let dyn_map = self.cache_for(container, src.file_id);\n-        dyn_map[keys::CONST_PARAM].get(&src.value).copied().map(|x| x.into())\n+        dyn_map[keys::CONST_PARAM].get(&src.value).copied().map(|x| ConstParamId::from_unchecked(x))\n     }\n \n     pub(super) fn generic_param_to_def("}, {"sha": "04b77894ae92698938ba14a8e34905a8fd990f95", "filename": "crates/hir_def/src/generics.rs", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fgenerics.rs?ref=b301b040f5781a9083348936369a01c37138756f", "patch": "@@ -24,8 +24,8 @@ use crate::{\n     keys,\n     src::{HasChildSource, HasSource},\n     type_ref::{LifetimeRef, TypeBound, TypeRef},\n-    AdtId, GenericDefId, HasModule, LifetimeParamId, LocalLifetimeParamId, LocalTypeOrConstParamId,\n-    Lookup, TypeOrConstParamId,\n+    AdtId, ConstParamId, GenericDefId, HasModule, LifetimeParamId, LocalLifetimeParamId,\n+    LocalTypeOrConstParamId, Lookup, TypeOrConstParamId, TypeParamId,\n };\n \n /// Data about a generic type parameter (to a function, struct, impl, ...).\n@@ -99,7 +99,7 @@ impl_from!(TypeParamData, ConstParamData for TypeOrConstParamData);\n /// Data about the generic parameters of a function, struct, impl, etc.\n #[derive(Clone, PartialEq, Eq, Debug, Default, Hash)]\n pub struct GenericParams {\n-    pub tocs: Arena<TypeOrConstParamData>,\n+    pub type_or_consts: Arena<TypeOrConstParamData>,\n     pub lifetimes: Arena<LifetimeParamData>,\n     pub where_predicates: Vec<WherePredicate>,\n }\n@@ -138,13 +138,14 @@ impl GenericParams {\n     pub fn type_iter<'a>(\n         &'a self,\n     ) -> impl Iterator<Item = (Idx<TypeOrConstParamData>, &TypeParamData)> {\n-        self.tocs.iter().filter_map(|x| x.1.type_param().map(|y| (x.0, y)))\n+        self.type_or_consts.iter().filter_map(|x| x.1.type_param().map(|y| (x.0, y)))\n     }\n \n-    pub fn toc_iter<'a>(\n+    /// Iterator of type_or_consts field\n+    pub fn iter<'a>(\n         &'a self,\n-    ) -> impl Iterator<Item = (Idx<TypeOrConstParamData>, &TypeOrConstParamData)> {\n-        self.tocs.iter()\n+    ) -> impl DoubleEndedIterator<Item = (Idx<TypeOrConstParamData>, &TypeOrConstParamData)> {\n+        self.type_or_consts.iter()\n     }\n \n     pub(crate) fn generic_params_query(\n@@ -251,7 +252,7 @@ impl GenericParams {\n                         default,\n                         provenance: TypeParamProvenance::TypeParamList,\n                     };\n-                    self.tocs.alloc(param.into());\n+                    self.type_or_consts.alloc(param.into());\n                     let type_ref = TypeRef::Path(name.into());\n                     self.fill_bounds(lower_ctx, &type_param, Either::Left(type_ref));\n                 }\n@@ -261,7 +262,7 @@ impl GenericParams {\n                         .ty()\n                         .map_or(TypeRef::Error, |it| TypeRef::from_ast(lower_ctx, it));\n                     let param = ConstParamData { name, ty: Interned::new(ty) };\n-                    self.tocs.alloc(param.into());\n+                    self.type_or_consts.alloc(param.into());\n                 }\n             }\n         }\n@@ -348,7 +349,7 @@ impl GenericParams {\n                     default: None,\n                     provenance: TypeParamProvenance::ArgumentImplTrait,\n                 };\n-                let param_id = self.tocs.alloc(param.into());\n+                let param_id = self.type_or_consts.alloc(param.into());\n                 for bound in bounds {\n                     self.where_predicates.push(WherePredicate::TypeBound {\n                         target: WherePredicateTypeTarget::TypeOrConstParam(param_id),\n@@ -372,27 +373,34 @@ impl GenericParams {\n     }\n \n     pub(crate) fn shrink_to_fit(&mut self) {\n-        let Self { lifetimes, tocs: types, where_predicates } = self;\n+        let Self { lifetimes, type_or_consts: types, where_predicates } = self;\n         lifetimes.shrink_to_fit();\n         types.shrink_to_fit();\n         where_predicates.shrink_to_fit();\n     }\n \n-    pub fn find_type_by_name(&self, name: &Name) -> Option<LocalTypeOrConstParamId> {\n-        self.tocs\n-            .iter()\n-            .filter(|x| matches!(x.1, TypeOrConstParamData::TypeParamData(_)))\n-            .find_map(|(id, p)| if p.name().as_ref() == Some(&name) { Some(id) } else { None })\n+    pub fn find_type_by_name(&self, name: &Name, parent: GenericDefId) -> Option<TypeParamId> {\n+        self.type_or_consts.iter().find_map(|(id, p)| {\n+            if p.name().as_ref() == Some(&name) && p.type_param().is_some() {\n+                Some(TypeParamId::from_unchecked(TypeOrConstParamId { local_id: id, parent }))\n+            } else {\n+                None\n+            }\n+        })\n     }\n \n-    pub fn find_type_or_const_by_name(&self, name: &Name) -> Option<LocalTypeOrConstParamId> {\n-        self.tocs\n-            .iter()\n-            .find_map(|(id, p)| if p.name().as_ref() == Some(&name) { Some(id) } else { None })\n+    pub fn find_const_by_name(&self, name: &Name, parent: GenericDefId) -> Option<ConstParamId> {\n+        self.type_or_consts.iter().find_map(|(id, p)| {\n+            if p.name().as_ref() == Some(&name) && p.const_param().is_some() {\n+                Some(ConstParamId::from_unchecked(TypeOrConstParamId { local_id: id, parent }))\n+            } else {\n+                None\n+            }\n+        })\n     }\n \n     pub fn find_trait_self_param(&self) -> Option<LocalTypeOrConstParamId> {\n-        self.tocs.iter().find_map(|(id, p)| {\n+        self.type_or_consts.iter().find_map(|(id, p)| {\n             if let TypeOrConstParamData::TypeParamData(p) = p {\n                 if p.provenance == TypeParamProvenance::TraitSelf {\n                     Some(id)\n@@ -451,7 +459,7 @@ impl HasChildSource<LocalTypeOrConstParamId> for GenericDefId {\n         db: &dyn DefDatabase,\n     ) -> InFile<ArenaMap<LocalTypeOrConstParamId, Self::Value>> {\n         let generic_params = db.generic_params(*self);\n-        let mut idx_iter = generic_params.tocs.iter().map(|(idx, _)| idx);\n+        let mut idx_iter = generic_params.type_or_consts.iter().map(|(idx, _)| idx);\n \n         let (file_id, generic_params_list) = file_id_and_params_of(*self, db);\n \n@@ -505,7 +513,7 @@ impl ChildBySource for GenericDefId {\n         }\n \n         let generic_params = db.generic_params(*self);\n-        let mut toc_idx_iter = generic_params.tocs.iter().map(|(idx, _)| idx);\n+        let mut toc_idx_iter = generic_params.type_or_consts.iter().map(|(idx, _)| idx);\n         let lts_idx_iter = generic_params.lifetimes.iter().map(|(idx, _)| idx);\n \n         // For traits the first type index is `Self`, skip it."}, {"sha": "379e03504b2e656fd03edf84fe1c2f3f24bc30da", "filename": "crates/hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=b301b040f5781a9083348936369a01c37138756f", "patch": "@@ -582,7 +582,7 @@ impl<'a> Ctx<'a> {\n             }\n             GenericsOwner::Trait(trait_def) => {\n                 // traits get the Self type as an implicit first type parameter\n-                generics.tocs.alloc(\n+                generics.type_or_consts.alloc(\n                     TypeParamData {\n                         name: Some(name![Self]),\n                         default: None,"}, {"sha": "b24ba61ea069fd49d30807a60c4d50aa0a29b0b9", "filename": "crates/hir_def/src/item_tree/pretty.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Fpretty.rs?ref=b301b040f5781a9083348936369a01c37138756f", "patch": "@@ -621,12 +621,13 @@ impl<'a> Printer<'a> {\n     fn print_generic_arg(&mut self, arg: &GenericArg) {\n         match arg {\n             GenericArg::Type(ty) => self.print_type_ref(ty),\n+            GenericArg::Const(c) => w!(self, \"{}\", c),\n             GenericArg::Lifetime(lt) => w!(self, \"{}\", lt.name),\n         }\n     }\n \n     fn print_generic_params(&mut self, params: &GenericParams) {\n-        if params.tocs.is_empty() && params.lifetimes.is_empty() {\n+        if params.type_or_consts.is_empty() && params.lifetimes.is_empty() {\n             return;\n         }\n \n@@ -639,7 +640,7 @@ impl<'a> Printer<'a> {\n             first = false;\n             w!(self, \"{}\", lt.name);\n         }\n-        for (idx, x) in params.tocs.iter() {\n+        for (idx, x) in params.type_or_consts.iter() {\n             if !first {\n                 w!(self, \", \");\n             }\n@@ -701,7 +702,7 @@ impl<'a> Printer<'a> {\n                 match target {\n                     WherePredicateTypeTarget::TypeRef(ty) => this.print_type_ref(ty),\n                     WherePredicateTypeTarget::TypeOrConstParam(id) => {\n-                        match &params.tocs[*id].name() {\n+                        match &params.type_or_consts[*id].name() {\n                             Some(name) => w!(this, \"{}\", name),\n                             None => w!(this, \"_anon_{}\", id.into_raw()),\n                         }"}, {"sha": "974a2ab8f25c8498763b31b852a1caff8dacf896", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=b301b040f5781a9083348936369a01c37138756f", "patch": "@@ -343,11 +343,13 @@ impl TypeParamId {\n     }\n }\n \n-impl From<TypeOrConstParamId> for TypeParamId {\n-    fn from(x: TypeOrConstParamId) -> Self {\n+impl TypeParamId {\n+    /// Caller should check if this toc id really belongs to a type\n+    pub fn from_unchecked(x: TypeOrConstParamId) -> Self {\n         Self(x)\n     }\n }\n+\n impl From<TypeParamId> for TypeOrConstParamId {\n     fn from(x: TypeParamId) -> Self {\n         x.0\n@@ -367,11 +369,13 @@ impl ConstParamId {\n     }\n }\n \n-impl From<TypeOrConstParamId> for ConstParamId {\n-    fn from(x: TypeOrConstParamId) -> Self {\n+impl ConstParamId {\n+    /// Caller should check if this toc id really belongs to a const\n+    pub fn from_unchecked(x: TypeOrConstParamId) -> Self {\n         Self(x)\n     }\n }\n+\n impl From<ConstParamId> for TypeOrConstParamId {\n     fn from(x: ConstParamId) -> Self {\n         x.0"}, {"sha": "37c09a0984578b5556ae64df695102eb736d5562", "filename": "crates/hir_def/src/path.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath.rs?ref=b301b040f5781a9083348936369a01c37138756f", "patch": "@@ -6,7 +6,11 @@ use std::{\n     iter,\n };\n \n-use crate::{body::LowerCtx, intern::Interned, type_ref::LifetimeRef};\n+use crate::{\n+    body::LowerCtx,\n+    intern::Interned,\n+    type_ref::{ConstScalarOrPath, LifetimeRef},\n+};\n use hir_expand::name::{name, Name};\n use syntax::ast;\n \n@@ -78,6 +82,7 @@ pub struct AssociatedTypeBinding {\n pub enum GenericArg {\n     Type(TypeRef),\n     Lifetime(LifetimeRef),\n+    Const(ConstScalarOrPath),\n }\n \n impl Path {"}, {"sha": "b6a24cd4ab17ad44a2e0e13a3ce1974022be7137", "filename": "crates/hir_def/src/path/lower.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs?ref=b301b040f5781a9083348936369a01c37138756f", "patch": "@@ -1,6 +1,6 @@\n //! Transforms syntax into `Path` objects, ideally with accounting for hygiene\n \n-use crate::intern::Interned;\n+use crate::{intern::Interned, type_ref::ConstScalarOrPath};\n \n use either::Either;\n use hir_expand::name::{name, AsName};\n@@ -180,8 +180,10 @@ pub(super) fn lower_generic_args(\n                     args.push(GenericArg::Lifetime(lifetime_ref))\n                 }\n             }\n-            // constants are ignored for now.\n-            ast::GenericArg::ConstArg(_) => (),\n+            ast::GenericArg::ConstArg(arg) => {\n+                let arg = ConstScalarOrPath::from_expr_opt(arg.expr());\n+                args.push(GenericArg::Const(arg))\n+            }\n         }\n     }\n "}, {"sha": "72856a1bfe73060e87e6ff0deb0089f9133d26ac", "filename": "crates/hir_def/src/resolver.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fresolver.rs?ref=b301b040f5781a9083348936369a01c37138756f", "patch": "@@ -189,14 +189,9 @@ impl Resolver {\n                 Scope::GenericParams { .. } | Scope::ImplDefScope(_) if skip_to_mod => continue,\n \n                 Scope::GenericParams { params, def } => {\n-                    if let Some(local_id) = params.find_type_by_name(first_name) {\n+                    if let Some(id) = params.find_type_by_name(first_name, *def) {\n                         let idx = if path.segments().len() == 1 { None } else { Some(1) };\n-                        return Some((\n-                            TypeNs::GenericParam(\n-                                TypeOrConstParamId { local_id, parent: *def }.into(),\n-                            ),\n-                            idx,\n-                        ));\n+                        return Some((TypeNs::GenericParam(id), idx));\n                     }\n                 }\n                 Scope::ImplDefScope(impl_) => {\n@@ -284,18 +279,14 @@ impl Resolver {\n                 Scope::ExprScope(_) => continue,\n \n                 Scope::GenericParams { params, def } if n_segments > 1 => {\n-                    if let Some(local_id) = params.find_type_or_const_by_name(first_name) {\n-                        let ty = TypeNs::GenericParam(\n-                            TypeOrConstParamId { local_id, parent: *def }.into(),\n-                        );\n+                    if let Some(id) = params.find_type_by_name(first_name, *def) {\n+                        let ty = TypeNs::GenericParam(id);\n                         return Some(ResolveValueResult::Partial(ty, 1));\n                     }\n                 }\n                 Scope::GenericParams { params, def } if n_segments == 1 => {\n-                    if let Some(local_id) = params.find_type_or_const_by_name(first_name) {\n-                        let val = ValueNs::GenericParam(\n-                            TypeOrConstParamId { local_id, parent: *def }.into(),\n-                        );\n+                    if let Some(id) = params.find_const_by_name(first_name, *def) {\n+                        let val = ValueNs::GenericParam(id);\n                         return Some(ResolveValueResult::ValueNs(val));\n                     }\n                 }\n@@ -518,18 +509,18 @@ impl Scope {\n             }\n             Scope::GenericParams { params, def: parent } => {\n                 let parent = *parent;\n-                for (local_id, param) in params.tocs.iter() {\n+                for (local_id, param) in params.type_or_consts.iter() {\n                     if let Some(name) = &param.name() {\n                         let id = TypeOrConstParamId { parent, local_id };\n-                        let data = &db.generic_params(parent).tocs[local_id];\n+                        let data = &db.generic_params(parent).type_or_consts[local_id];\n                         acc.add(\n                             name,\n                             ScopeDef::GenericParam(match data {\n                                 TypeOrConstParamData::TypeParamData(_) => {\n-                                    GenericParamId::TypeParamId(id.into())\n+                                    GenericParamId::TypeParamId(TypeParamId::from_unchecked(id))\n                                 }\n                                 TypeOrConstParamData::ConstParamData(_) => {\n-                                    GenericParamId::ConstParamId(id.into())\n+                                    GenericParamId::ConstParamId(ConstParamId::from_unchecked(id))\n                                 }\n                             }),\n                         );"}, {"sha": "b9fadcfa8da260e07f2be85a43ca1d400b5f5857", "filename": "crates/hir_def/src/type_ref.rs", "status": "modified", "additions": 58, "deletions": 27, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ftype_ref.rs?ref=b301b040f5781a9083348936369a01c37138756f", "patch": "@@ -89,7 +89,7 @@ pub enum TypeRef {\n     Reference(Box<TypeRef>, Option<LifetimeRef>, Mutability),\n     // FIXME: for full const generics, the latter element (length) here is going to have to be an\n     // expression that is further lowered later in hir_ty.\n-    Array(Box<TypeRef>, ConstScalar),\n+    Array(Box<TypeRef>, ConstScalarOrPath),\n     Slice(Box<TypeRef>),\n     /// A fn pointer. Last element of the vector is the return type.\n     Fn(Vec<(Option<Name>, TypeRef)>, bool /*varargs*/),\n@@ -162,10 +162,7 @@ impl TypeRef {\n                 // `hir_def::body::lower` to lower this into an `Expr` and then evaluate it at the\n                 // `hir_ty` level, which would allow knowing the type of:\n                 // let v: [u8; 2 + 2] = [0u8; 4];\n-                let len = inner\n-                    .expr()\n-                    .map(ConstScalar::usize_from_literal_expr)\n-                    .unwrap_or(ConstScalar::Unknown);\n+                let len = ConstScalarOrPath::from_expr_opt(inner.expr());\n \n                 TypeRef::Array(Box::new(TypeRef::from_ast_opt(ctx, inner.ty())), len)\n             }\n@@ -278,7 +275,8 @@ impl TypeRef {\n                             crate::path::GenericArg::Type(type_ref) => {\n                                 go(type_ref, f);\n                             }\n-                            crate::path::GenericArg::Lifetime(_) => {}\n+                            crate::path::GenericArg::Const(_)\n+                            | crate::path::GenericArg::Lifetime(_) => {}\n                         }\n                     }\n                     for binding in &args_and_bindings.bindings {\n@@ -357,6 +355,60 @@ impl TypeBound {\n     }\n }\n \n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum ConstScalarOrPath {\n+    Scalar(ConstScalar),\n+    Path(Name),\n+}\n+\n+impl std::fmt::Display for ConstScalarOrPath {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match self {\n+            ConstScalarOrPath::Scalar(s) => write!(f, \"{}\", s),\n+            ConstScalarOrPath::Path(n) => write!(f, \"{}\", n),\n+        }\n+    }\n+}\n+\n+impl ConstScalarOrPath {\n+    pub(crate) fn from_expr_opt(expr: Option<ast::Expr>) -> Self {\n+        match expr {\n+            Some(x) => Self::from_expr(x),\n+            None => Self::Scalar(ConstScalar::Unknown),\n+        }\n+    }\n+\n+    // FIXME: as per the comments on `TypeRef::Array`, this evaluation should not happen at this\n+    // parse stage.\n+    fn from_expr(expr: ast::Expr) -> Self {\n+        match expr {\n+            ast::Expr::PathExpr(p) => {\n+                match p.path().and_then(|x| x.segment()).and_then(|x| x.name_ref()) {\n+                    Some(x) => Self::Path(x.as_name()),\n+                    None => Self::Scalar(ConstScalar::Unknown),\n+                }\n+            }\n+            ast::Expr::Literal(lit) => {\n+                let lkind = lit.kind();\n+                match lkind {\n+                    ast::LiteralKind::IntNumber(num)\n+                        if num.suffix() == None || num.suffix() == Some(\"usize\") =>\n+                    {\n+                        Self::Scalar(\n+                            num.value()\n+                                .and_then(|v| v.try_into().ok())\n+                                .map(ConstScalar::Usize)\n+                                .unwrap_or(ConstScalar::Unknown),\n+                        )\n+                    }\n+                    _ => Self::Scalar(ConstScalar::Unknown),\n+                }\n+            }\n+            _ => Self::Scalar(ConstScalar::Unknown),\n+        }\n+    }\n+}\n+\n /// A concrete constant value\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub enum ConstScalar {\n@@ -389,25 +441,4 @@ impl ConstScalar {\n             _ => None,\n         }\n     }\n-\n-    // FIXME: as per the comments on `TypeRef::Array`, this evaluation should not happen at this\n-    // parse stage.\n-    fn usize_from_literal_expr(expr: ast::Expr) -> ConstScalar {\n-        match expr {\n-            ast::Expr::Literal(lit) => {\n-                let lkind = lit.kind();\n-                match lkind {\n-                    ast::LiteralKind::IntNumber(num)\n-                        if num.suffix() == None || num.suffix() == Some(\"usize\") =>\n-                    {\n-                        num.value().and_then(|v| v.try_into().ok())\n-                    }\n-                    _ => None,\n-                }\n-            }\n-            _ => None,\n-        }\n-        .map(ConstScalar::Usize)\n-        .unwrap_or(ConstScalar::Unknown)\n-    }\n }"}, {"sha": "d2bfca53adaa1cb8d2a3b774e327293ef762125f", "filename": "crates/hir_ty/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2FCargo.toml?ref=b301b040f5781a9083348936369a01c37138756f", "patch": "@@ -18,9 +18,9 @@ ena = \"0.14.0\"\n tracing = \"0.1\"\n rustc-hash = \"1.1.0\"\n scoped-tls = \"1\"\n-chalk-solve = { version = \"0.76\", default-features = false }\n-chalk-ir = \"0.76\"\n-chalk-recursive = { version = \"0.76\", default-features = false }\n+chalk-solve = { version = \"0.79\", default-features = false }\n+chalk-ir = \"0.79\"\n+chalk-recursive = { version = \"0.79\", default-features = false }\n la-arena = { version = \"0.3.0\", path = \"../../lib/arena\" }\n once_cell = { version = \"1.5.0\" }\n typed-arena = \"2.0.1\""}, {"sha": "c507c42f5b79533ce1f844214c3681547de1503e", "filename": "crates/hir_ty/src/builder.rs", "status": "modified", "additions": 128, "deletions": 49, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs?ref=b301b040f5781a9083348936369a01c37138756f", "patch": "@@ -8,67 +8,136 @@ use chalk_ir::{\n     interner::HasInterner,\n     AdtId, BoundVar, DebruijnIndex, Scalar,\n };\n-use hir_def::{builtin_type::BuiltinType, GenericDefId, TraitId, TypeAliasId};\n+use hir_def::{\n+    builtin_type::BuiltinType, generics::TypeOrConstParamData, ConstParamId, GenericDefId, TraitId,\n+    TypeAliasId,\n+};\n use smallvec::SmallVec;\n \n use crate::{\n-    db::HirDatabase, primitive, to_assoc_type_id, to_chalk_trait_id, utils::generics, Binders,\n-    CallableSig, GenericArg, Interner, ProjectionTy, Substitution, TraitRef, Ty, TyDefId, TyExt,\n-    TyKind, ValueTyDefId,\n+    consteval::unknown_const_as_generic, db::HirDatabase, primitive, to_assoc_type_id,\n+    to_chalk_trait_id, utils::generics, Binders, CallableSig, ConstData, ConstValue, GenericArg,\n+    GenericArgData, Interner, ProjectionTy, Substitution, TraitRef, Ty, TyDefId, TyExt, TyKind,\n+    ValueTyDefId,\n };\n \n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum ParamKind {\n+    Type,\n+    Const(Ty),\n+}\n+\n /// This is a builder for `Ty` or anything that needs a `Substitution`.\n pub struct TyBuilder<D> {\n     /// The `data` field is used to keep track of what we're building (e.g. an\n     /// ADT, a `TraitRef`, ...).\n     data: D,\n     vec: SmallVec<[GenericArg; 2]>,\n-    param_count: usize,\n+    param_kinds: SmallVec<[ParamKind; 2]>,\n+}\n+\n+impl<A> TyBuilder<A> {\n+    fn with_data<B>(self, data: B) -> TyBuilder<B> {\n+        TyBuilder { data, param_kinds: self.param_kinds, vec: self.vec }\n+    }\n }\n \n impl<D> TyBuilder<D> {\n-    fn new(data: D, param_count: usize) -> TyBuilder<D> {\n-        TyBuilder { data, param_count, vec: SmallVec::with_capacity(param_count) }\n+    fn new(data: D, param_kinds: SmallVec<[ParamKind; 2]>) -> TyBuilder<D> {\n+        TyBuilder { data, vec: SmallVec::with_capacity(param_kinds.len()), param_kinds }\n     }\n \n     fn build_internal(self) -> (D, Substitution) {\n-        assert_eq!(self.vec.len(), self.param_count);\n+        assert_eq!(self.vec.len(), self.param_kinds.len());\n+        for (a, e) in self.vec.iter().zip(self.param_kinds.iter()) {\n+            self.assert_match_kind(a, e);\n+        }\n         let subst = Substitution::from_iter(Interner, self.vec);\n         (self.data, subst)\n     }\n \n     pub fn push(mut self, arg: impl CastTo<GenericArg>) -> Self {\n-        self.vec.push(arg.cast(Interner));\n+        let arg = arg.cast(Interner);\n+        let expected_kind = &self.param_kinds[self.vec.len()];\n+        let arg_kind = match arg.data(Interner) {\n+            chalk_ir::GenericArgData::Ty(_) => ParamKind::Type,\n+            chalk_ir::GenericArgData::Lifetime(_) => panic!(\"Got lifetime in TyBuilder::push\"),\n+            chalk_ir::GenericArgData::Const(c) => {\n+                let c = c.data(Interner);\n+                ParamKind::Const(c.ty.clone())\n+            }\n+        };\n+        assert_eq!(*expected_kind, arg_kind);\n+        self.vec.push(arg);\n         self\n     }\n \n     pub fn remaining(&self) -> usize {\n-        self.param_count - self.vec.len()\n+        self.param_kinds.len() - self.vec.len()\n     }\n \n     pub fn fill_with_bound_vars(self, debruijn: DebruijnIndex, starting_from: usize) -> Self {\n-        self.fill(\n-            (starting_from..)\n-                .map(|idx| TyKind::BoundVar(BoundVar::new(debruijn, idx)).intern(Interner)),\n-        )\n+        // self.fill is inlined to make borrow checker happy\n+        let mut this = self;\n+        let other = this.param_kinds.iter().skip(this.vec.len());\n+        let filler = (starting_from..).zip(other).map(|(idx, kind)| match kind {\n+            ParamKind::Type => {\n+                GenericArgData::Ty(TyKind::BoundVar(BoundVar::new(debruijn, idx)).intern(Interner))\n+                    .intern(Interner)\n+            }\n+            ParamKind::Const(ty) => GenericArgData::Const(\n+                ConstData {\n+                    value: ConstValue::BoundVar(BoundVar::new(debruijn, idx)),\n+                    ty: ty.clone(),\n+                }\n+                .intern(Interner),\n+            )\n+            .intern(Interner),\n+        });\n+        this.vec.extend(filler.take(this.remaining()).casted(Interner));\n+        assert_eq!(this.remaining(), 0);\n+        this\n     }\n \n     pub fn fill_with_unknown(self) -> Self {\n-        self.fill(iter::repeat(TyKind::Error.intern(Interner)))\n+        // self.fill is inlined to make borrow checker happy\n+        let mut this = self;\n+        let filler = this.param_kinds.iter().skip(this.vec.len()).map(|x| match x {\n+            ParamKind::Type => GenericArgData::Ty(TyKind::Error.intern(Interner)).intern(Interner),\n+            ParamKind::Const(ty) => unknown_const_as_generic(ty.clone()),\n+        });\n+        this.vec.extend(filler.casted(Interner));\n+        assert_eq!(this.remaining(), 0);\n+        this\n     }\n \n-    pub fn fill(mut self, filler: impl Iterator<Item = impl CastTo<GenericArg>>) -> Self {\n-        self.vec.extend(filler.take(self.remaining()).casted(Interner));\n+    pub fn fill(mut self, filler: impl FnMut(&ParamKind) -> GenericArg) -> Self {\n+        self.vec.extend(self.param_kinds.iter().skip(self.vec.len()).map(filler));\n         assert_eq!(self.remaining(), 0);\n         self\n     }\n \n     pub fn use_parent_substs(mut self, parent_substs: &Substitution) -> Self {\n         assert!(self.vec.is_empty());\n-        assert!(parent_substs.len(Interner) <= self.param_count);\n-        self.vec.extend(parent_substs.iter(Interner).cloned());\n+        assert!(parent_substs.len(Interner) <= self.param_kinds.len());\n+        self.extend(parent_substs.iter(Interner).cloned());\n         self\n     }\n+\n+    fn extend(&mut self, it: impl Iterator<Item = GenericArg> + Clone) {\n+        for x in it.clone().zip(self.param_kinds.iter().skip(self.vec.len())) {\n+            self.assert_match_kind(&x.0, &x.1);\n+        }\n+        self.vec.extend(it);\n+    }\n+\n+    fn assert_match_kind(&self, a: &chalk_ir::GenericArg<Interner>, e: &ParamKind) {\n+        match (a.data(Interner), e) {\n+            (chalk_ir::GenericArgData::Ty(_), ParamKind::Type)\n+            | (chalk_ir::GenericArgData::Const(_), ParamKind::Const(_)) => (),\n+            _ => panic!(\"Mismatched kinds: {:?}, {:?}, {:?}\", a, self.vec, self.param_kinds),\n+        }\n+    }\n }\n \n impl TyBuilder<()> {\n@@ -101,16 +170,26 @@ impl TyBuilder<()> {\n         TyKind::Slice(argument).intern(Interner)\n     }\n \n-    pub fn type_params_subst(db: &dyn HirDatabase, def: impl Into<GenericDefId>) -> Substitution {\n+    pub fn placeholder_subst(db: &dyn HirDatabase, def: impl Into<GenericDefId>) -> Substitution {\n         let params = generics(db.upcast(), def.into());\n-        params.type_params_subst(db)\n+        params.placeholder_subst(db)\n     }\n \n     pub fn subst_for_def(db: &dyn HirDatabase, def: impl Into<GenericDefId>) -> TyBuilder<()> {\n         let def = def.into();\n         let params = generics(db.upcast(), def);\n-        let param_count = params.len();\n-        TyBuilder::new((), param_count)\n+        TyBuilder::new(\n+            (),\n+            params\n+                .iter()\n+                .map(|(id, data)| match data {\n+                    TypeOrConstParamData::TypeParamData(_) => ParamKind::Type,\n+                    TypeOrConstParamData::ConstParamData(_) => {\n+                        ParamKind::Const(db.const_param_ty(ConstParamId::from_unchecked(id)))\n+                    }\n+                })\n+                .collect(),\n+        )\n     }\n \n     pub fn build(self) -> Substitution {\n@@ -120,10 +199,8 @@ impl TyBuilder<()> {\n }\n \n impl TyBuilder<hir_def::AdtId> {\n-    pub fn adt(db: &dyn HirDatabase, adt: hir_def::AdtId) -> TyBuilder<hir_def::AdtId> {\n-        let generics = generics(db.upcast(), adt.into());\n-        let param_count = generics.len();\n-        TyBuilder::new(adt, param_count)\n+    pub fn adt(db: &dyn HirDatabase, def: hir_def::AdtId) -> TyBuilder<hir_def::AdtId> {\n+        TyBuilder::subst_for_def(db, def).with_data(def)\n     }\n \n     pub fn fill_with_defaults(\n@@ -133,14 +210,15 @@ impl TyBuilder<hir_def::AdtId> {\n     ) -> Self {\n         let defaults = db.generic_defaults(self.data.into());\n         for default_ty in defaults.iter().skip(self.vec.len()) {\n-            if default_ty.skip_binders().is_unknown() {\n-                self.vec.push(fallback().cast(Interner));\n-            } else {\n-                // each default can depend on the previous parameters\n-                let subst_so_far = Substitution::from_iter(Interner, self.vec.clone());\n-                self.vec\n-                    .push(default_ty.clone().substitute(Interner, &subst_so_far).cast(Interner));\n-            }\n+            if let GenericArgData::Ty(x) = default_ty.skip_binders().data(Interner) {\n+                if x.is_unknown() {\n+                    self.vec.push(fallback().cast(Interner));\n+                    continue;\n+                }\n+            };\n+            // each default can depend on the previous parameters\n+            let subst_so_far = Substitution::from_iter(Interner, self.vec.clone());\n+            self.vec.push(default_ty.clone().substitute(Interner, &subst_so_far).cast(Interner));\n         }\n         self\n     }\n@@ -154,7 +232,7 @@ impl TyBuilder<hir_def::AdtId> {\n pub struct Tuple(usize);\n impl TyBuilder<Tuple> {\n     pub fn tuple(size: usize) -> TyBuilder<Tuple> {\n-        TyBuilder::new(Tuple(size), size)\n+        TyBuilder::new(Tuple(size), iter::repeat(ParamKind::Type).take(size).collect())\n     }\n \n     pub fn build(self) -> Ty {\n@@ -164,10 +242,8 @@ impl TyBuilder<Tuple> {\n }\n \n impl TyBuilder<TraitId> {\n-    pub fn trait_ref(db: &dyn HirDatabase, trait_id: TraitId) -> TyBuilder<TraitId> {\n-        let generics = generics(db.upcast(), trait_id.into());\n-        let param_count = generics.len();\n-        TyBuilder::new(trait_id, param_count)\n+    pub fn trait_ref(db: &dyn HirDatabase, def: TraitId) -> TyBuilder<TraitId> {\n+        TyBuilder::subst_for_def(db, def).with_data(def)\n     }\n \n     pub fn build(self) -> TraitRef {\n@@ -177,13 +253,8 @@ impl TyBuilder<TraitId> {\n }\n \n impl TyBuilder<TypeAliasId> {\n-    pub fn assoc_type_projection(\n-        db: &dyn HirDatabase,\n-        type_alias: TypeAliasId,\n-    ) -> TyBuilder<TypeAliasId> {\n-        let generics = generics(db.upcast(), type_alias.into());\n-        let param_count = generics.len();\n-        TyBuilder::new(type_alias, param_count)\n+    pub fn assoc_type_projection(db: &dyn HirDatabase, def: TypeAliasId) -> TyBuilder<TypeAliasId> {\n+        TyBuilder::subst_for_def(db, def).with_data(def)\n     }\n \n     pub fn build(self) -> ProjectionTy {\n@@ -194,8 +265,16 @@ impl TyBuilder<TypeAliasId> {\n \n impl<T: HasInterner<Interner = Interner> + Fold<Interner>> TyBuilder<Binders<T>> {\n     fn subst_binders(b: Binders<T>) -> Self {\n-        let param_count = b.binders.len(Interner);\n-        TyBuilder::new(b, param_count)\n+        let param_kinds = b\n+            .binders\n+            .iter(Interner)\n+            .map(|x| match x {\n+                chalk_ir::VariableKind::Ty(_) => ParamKind::Type,\n+                chalk_ir::VariableKind::Lifetime => panic!(\"Got lifetime parameter\"),\n+                chalk_ir::VariableKind::Const(ty) => ParamKind::Const(ty.clone()),\n+            })\n+            .collect();\n+        TyBuilder::new(b, param_kinds)\n     }\n \n     pub fn build(self) -> <T as Fold<Interner>>::Result {"}, {"sha": "1b67e5a86b493bbb44b3e5d155f1ca679288d79c", "filename": "crates/hir_ty/src/chalk_db.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Fchalk_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Fchalk_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fchalk_db.rs?ref=b301b040f5781a9083348936369a01c37138756f", "patch": "@@ -19,7 +19,8 @@ use hir_expand::name::name;\n use crate::{\n     db::HirDatabase,\n     display::HirDisplay,\n-    from_assoc_type_id, from_chalk_trait_id, from_foreign_def_id, make_only_type_binders,\n+    from_assoc_type_id, from_chalk_trait_id, from_foreign_def_id, make_binders,\n+    make_single_type_binders,\n     mapping::{from_chalk, ToChalk, TypeAliasAsValue},\n     method_resolution::{TraitImpls, TyFingerprint, ALL_FLOAT_FPS, ALL_INT_FPS},\n     to_assoc_type_id, to_chalk_trait_id,\n@@ -206,8 +207,8 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n                 let (datas, binders) = (*datas).as_ref().into_value_and_skipped_binders();\n                 let data = &datas.impl_traits[idx as usize];\n                 let bound = OpaqueTyDatumBound {\n-                    bounds: make_only_type_binders(1, data.bounds.skip_binders().to_vec()),\n-                    where_clauses: make_only_type_binders(0, vec![]),\n+                    bounds: make_single_type_binders(data.bounds.skip_binders().to_vec()),\n+                    where_clauses: chalk_ir::Binders::empty(Interner, vec![]),\n                 };\n                 chalk_ir::Binders::new(binders, bound)\n             }\n@@ -255,25 +256,22 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n                             .intern(Interner),\n                     });\n                     let bound = OpaqueTyDatumBound {\n-                        bounds: make_only_type_binders(\n-                            1,\n-                            vec![\n-                                crate::wrap_empty_binders(impl_bound),\n-                                crate::wrap_empty_binders(proj_bound),\n-                            ],\n-                        ),\n-                        where_clauses: make_only_type_binders(0, vec![]),\n+                        bounds: make_single_type_binders(vec![\n+                            crate::wrap_empty_binders(impl_bound),\n+                            crate::wrap_empty_binders(proj_bound),\n+                        ]),\n+                        where_clauses: chalk_ir::Binders::empty(Interner, vec![]),\n                     };\n                     // The opaque type has 1 parameter.\n-                    make_only_type_binders(1, bound)\n+                    make_single_type_binders(bound)\n                 } else {\n                     // If failed to find Symbol\u2019s value as variable is void: Future::Output, return empty bounds as fallback.\n                     let bound = OpaqueTyDatumBound {\n-                        bounds: make_only_type_binders(0, vec![]),\n-                        where_clauses: make_only_type_binders(0, vec![]),\n+                        bounds: chalk_ir::Binders::empty(Interner, vec![]),\n+                        where_clauses: chalk_ir::Binders::empty(Interner, vec![]),\n                     };\n                     // The opaque type has 1 parameter.\n-                    make_only_type_binders(1, bound)\n+                    make_single_type_binders(bound)\n                 }\n             }\n         };\n@@ -310,15 +308,15 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n             argument_types: sig.params().to_vec(),\n             return_type: sig.ret().clone(),\n         };\n-        make_only_type_binders(0, io.shifted_in(Interner))\n+        chalk_ir::Binders::empty(Interner, io.shifted_in(Interner))\n     }\n     fn closure_upvars(\n         &self,\n         _closure_id: chalk_ir::ClosureId<Interner>,\n         _substs: &chalk_ir::Substitution<Interner>,\n     ) -> chalk_ir::Binders<chalk_ir::Ty<Interner>> {\n         let ty = TyBuilder::unit();\n-        make_only_type_binders(0, ty)\n+        chalk_ir::Binders::empty(Interner, ty)\n     }\n     fn closure_fn_substitution(\n         &self,\n@@ -407,7 +405,7 @@ pub(crate) fn associated_ty_data_query(\n     // let bound_vars = generic_params.bound_vars_subst(DebruijnIndex::INNERMOST);\n     let resolver = hir_def::resolver::HasResolver::resolver(type_alias, db.upcast());\n     let ctx = crate::TyLoweringContext::new(db, &resolver)\n-        .with_type_param_mode(crate::lower::TypeParamLoweringMode::Variable);\n+        .with_type_param_mode(crate::lower::ParamLoweringMode::Variable);\n     let self_ty =\n         TyKind::BoundVar(BoundVar::new(crate::DebruijnIndex::INNERMOST, 0)).intern(Interner);\n     let mut bounds: Vec<_> = type_alias_data\n@@ -440,7 +438,7 @@ pub(crate) fn associated_ty_data_query(\n         trait_id: to_chalk_trait_id(trait_),\n         id,\n         name: type_alias,\n-        binders: make_only_type_binders(generic_params.len(), bound_data),\n+        binders: make_binders(db, &generic_params, bound_data),\n     };\n     Arc::new(datum)\n }\n@@ -455,7 +453,7 @@ pub(crate) fn trait_datum_query(\n     let trait_data = db.trait_data(trait_);\n     debug!(\"trait {:?} = {:?}\", trait_id, trait_data.name);\n     let generic_params = generics(db.upcast(), trait_.into());\n-    let bound_vars = generic_params.bound_vars_subst(DebruijnIndex::INNERMOST);\n+    let bound_vars = generic_params.bound_vars_subst(db, DebruijnIndex::INNERMOST);\n     let flags = rust_ir::TraitFlags {\n         auto: trait_data.is_auto,\n         upstream: trait_.lookup(db.upcast()).container.krate() != krate,\n@@ -472,7 +470,7 @@ pub(crate) fn trait_datum_query(\n         lang_attr(db.upcast(), trait_).and_then(|name| well_known_trait_from_lang_attr(&name));\n     let trait_datum = TraitDatum {\n         id: trait_id,\n-        binders: make_only_type_binders(bound_vars.len(Interner), trait_datum_bound),\n+        binders: make_binders(db, &generic_params, trait_datum_bound),\n         flags,\n         associated_ty_ids,\n         well_known,\n@@ -520,11 +518,11 @@ pub(crate) fn struct_datum_query(\n ) -> Arc<StructDatum> {\n     debug!(\"struct_datum {:?}\", struct_id);\n     let chalk_ir::AdtId(adt_id) = struct_id;\n-    let num_params = generics(db.upcast(), adt_id.into()).len();\n+    let generic_params = generics(db.upcast(), adt_id.into());\n     let upstream = adt_id.module(db.upcast()).krate() != krate;\n     let where_clauses = {\n         let generic_params = generics(db.upcast(), adt_id.into());\n-        let bound_vars = generic_params.bound_vars_subst(DebruijnIndex::INNERMOST);\n+        let bound_vars = generic_params.bound_vars_subst(db, DebruijnIndex::INNERMOST);\n         convert_where_clauses(db, adt_id.into(), &bound_vars)\n     };\n     let flags = rust_ir::AdtFlags {\n@@ -542,7 +540,7 @@ pub(crate) fn struct_datum_query(\n         // FIXME set ADT kind\n         kind: rust_ir::AdtKind::Struct,\n         id: struct_id,\n-        binders: make_only_type_binders(num_params, struct_datum_bound),\n+        binders: make_binders(db, &generic_params, struct_datum_bound),\n         flags,\n     };\n     Arc::new(struct_datum)\n@@ -574,7 +572,7 @@ fn impl_def_datum(\n     let impl_data = db.impl_data(impl_id);\n \n     let generic_params = generics(db.upcast(), impl_id.into());\n-    let bound_vars = generic_params.bound_vars_subst(DebruijnIndex::INNERMOST);\n+    let bound_vars = generic_params.bound_vars_subst(db, DebruijnIndex::INNERMOST);\n     let trait_ = trait_ref.hir_trait_id();\n     let impl_type = if impl_id.lookup(db.upcast()).container.krate() == krate {\n         rust_ir::ImplType::Local\n@@ -611,7 +609,7 @@ fn impl_def_datum(\n         .collect();\n     debug!(\"impl_datum: {:?}\", impl_datum_bound);\n     let impl_datum = ImplDatum {\n-        binders: make_only_type_binders(bound_vars.len(Interner), impl_datum_bound),\n+        binders: make_binders(db, &generic_params, impl_datum_bound),\n         impl_type,\n         polarity,\n         associated_ty_value_ids,\n@@ -667,12 +665,12 @@ pub(crate) fn fn_def_datum_query(\n     let callable_def: CallableDefId = from_chalk(db, fn_def_id);\n     let generic_params = generics(db.upcast(), callable_def.into());\n     let (sig, binders) = db.callable_item_signature(callable_def).into_value_and_skipped_binders();\n-    let bound_vars = generic_params.bound_vars_subst(DebruijnIndex::INNERMOST);\n+    let bound_vars = generic_params.bound_vars_subst(db, DebruijnIndex::INNERMOST);\n     let where_clauses = convert_where_clauses(db, callable_def.into(), &bound_vars);\n     let bound = rust_ir::FnDefDatumBound {\n         // Note: Chalk doesn't actually use this information yet as far as I am aware, but we provide it anyway\n-        inputs_and_output: make_only_type_binders(\n-            0,\n+        inputs_and_output: chalk_ir::Binders::empty(\n+            Interner,\n             rust_ir::FnDefInputsAndOutputDatum {\n                 argument_types: sig.params().to_vec(),\n                 return_type: sig.ret().clone(),"}, {"sha": "b0885ab003f71317db3669607aaf5515673a81f1", "filename": "crates/hir_ty/src/chalk_ext.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fchalk_ext.rs?ref=b301b040f5781a9083348936369a01c37138756f", "patch": "@@ -237,11 +237,11 @@ impl TyExt for Ty {\n             TyKind::Placeholder(idx) => {\n                 let id = from_placeholder_idx(db, *idx);\n                 let generic_params = db.generic_params(id.parent);\n-                let param_data = &generic_params.tocs[id.local_id];\n+                let param_data = &generic_params.type_or_consts[id.local_id];\n                 match param_data {\n                     TypeOrConstParamData::TypeParamData(p) => match p.provenance {\n                         hir_def::generics::TypeParamProvenance::ArgumentImplTrait => {\n-                            let substs = TyBuilder::type_params_subst(db, id.parent);\n+                            let substs = TyBuilder::placeholder_subst(db, id.parent);\n                             let predicates = db\n                                 .generic_predicates(id.parent)\n                                 .iter()"}, {"sha": "24296c6b7b354d568e508905ff0e20c1e323fa77", "filename": "crates/hir_ty/src/consteval.rs", "status": "modified", "additions": 87, "deletions": 2, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Fconsteval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Fconsteval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fconsteval.rs?ref=b301b040f5781a9083348936369a01c37138756f", "patch": "@@ -2,15 +2,25 @@\n \n use std::{collections::HashMap, convert::TryInto, fmt::Display};\n \n-use chalk_ir::{IntTy, Scalar};\n+use chalk_ir::{BoundVar, DebruijnIndex, GenericArgData, IntTy, Scalar};\n use hir_def::{\n     expr::{ArithOp, BinaryOp, Expr, Literal, Pat},\n+    path::ModPath,\n+    resolver::{Resolver, ValueNs},\n     type_ref::ConstScalar,\n };\n use hir_expand::name::Name;\n use la_arena::{Arena, Idx};\n+use stdx::never;\n \n-use crate::{Const, ConstData, ConstValue, Interner, Ty, TyKind};\n+use crate::{\n+    db::HirDatabase,\n+    infer::{Expectation, InferenceContext},\n+    lower::ParamLoweringMode,\n+    to_placeholder_idx,\n+    utils::Generics,\n+    Const, ConstData, ConstValue, GenericArg, Interner, Ty, TyKind,\n+};\n \n /// Extension trait for [`Const`]\n pub trait ConstExt {\n@@ -303,6 +313,57 @@ pub fn eval_usize(expr: Idx<Expr>, mut ctx: ConstEvalCtx<'_>) -> Option<u64> {\n     None\n }\n \n+pub(crate) fn path_to_const(\n+    db: &dyn HirDatabase,\n+    resolver: &Resolver,\n+    path: &ModPath,\n+    mode: ParamLoweringMode,\n+    args_lazy: impl FnOnce() -> Generics,\n+    debruijn: DebruijnIndex,\n+) -> Option<Const> {\n+    match resolver.resolve_path_in_value_ns_fully(db.upcast(), &path) {\n+        Some(ValueNs::GenericParam(p)) => {\n+            let ty = db.const_param_ty(p);\n+            let args = args_lazy();\n+            let value = match mode {\n+                ParamLoweringMode::Placeholder => {\n+                    ConstValue::Placeholder(to_placeholder_idx(db, p.into()))\n+                }\n+                ParamLoweringMode::Variable => match args.param_idx(p.into()) {\n+                    Some(x) => ConstValue::BoundVar(BoundVar::new(debruijn, x)),\n+                    None => {\n+                        never!(\n+                            \"Generic list doesn't contain this param: {:?}, {}, {:?}\",\n+                            args,\n+                            path,\n+                            p\n+                        );\n+                        return None;\n+                    }\n+                },\n+            };\n+            Some(ConstData { ty, value }.intern(Interner))\n+        }\n+        _ => None,\n+    }\n+}\n+\n+pub fn unknown_const(ty: Ty) -> Const {\n+    ConstData {\n+        ty,\n+        value: ConstValue::Concrete(chalk_ir::ConcreteConst { interned: ConstScalar::Unknown }),\n+    }\n+    .intern(Interner)\n+}\n+\n+pub fn unknown_const_usize() -> Const {\n+    unknown_const(TyKind::Scalar(chalk_ir::Scalar::Uint(chalk_ir::UintTy::Usize)).intern(Interner))\n+}\n+\n+pub fn unknown_const_as_generic(ty: Ty) -> GenericArg {\n+    GenericArgData::Const(unknown_const(ty)).intern(Interner)\n+}\n+\n /// Interns a possibly-unknown target usize\n pub fn usize_const(value: Option<u64>) -> Const {\n     ConstData {\n@@ -313,3 +374,27 @@ pub fn usize_const(value: Option<u64>) -> Const {\n     }\n     .intern(Interner)\n }\n+\n+pub(crate) fn eval_to_const(\n+    expr: Idx<Expr>,\n+    mode: ParamLoweringMode,\n+    ctx: &mut InferenceContext,\n+    args: impl FnOnce() -> Generics,\n+    debruijn: DebruijnIndex,\n+) -> Const {\n+    if let Expr::Path(p) = &ctx.body.exprs[expr] {\n+        let db = ctx.db;\n+        let resolver = &ctx.resolver;\n+        if let Some(c) = path_to_const(db, resolver, p.mod_path(), mode, args, debruijn) {\n+            return c;\n+        }\n+    }\n+    let body = ctx.body.clone();\n+    let ctx = ConstEvalCtx {\n+        exprs: &body.exprs,\n+        pats: &body.pats,\n+        local_data: HashMap::default(),\n+        infer: &mut |x| ctx.infer_expr(x, &Expectation::None),\n+    };\n+    usize_const(eval_usize(expr, ctx))\n+}"}, {"sha": "599fd16dd0505d079b4e7119dc4266fe30c14407", "filename": "crates/hir_ty/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdb.rs?ref=b301b040f5781a9083348936369a01c37138756f", "patch": "@@ -13,7 +13,7 @@ use la_arena::ArenaMap;\n use crate::{\n     chalk_db,\n     method_resolution::{InherentImpls, TraitImpls},\n-    Binders, CallableDefId, FnDefId, ImplTraitId, InferenceResult, Interner, PolyFnSig,\n+    Binders, CallableDefId, FnDefId, GenericArg, ImplTraitId, InferenceResult, Interner, PolyFnSig,\n     QuantifiedWhereClause, ReturnTypeImplTraits, TraitRef, Ty, TyDefId, ValueTyDefId,\n };\n use hir_expand::name::Name;\n@@ -73,7 +73,7 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n \n     #[salsa::invoke(crate::lower::generic_defaults_query)]\n     #[salsa::cycle(crate::lower::generic_defaults_recover)]\n-    fn generic_defaults(&self, def: GenericDefId) -> Arc<[Binders<Ty>]>;\n+    fn generic_defaults(&self, def: GenericDefId) -> Arc<[Binders<GenericArg>]>;\n \n     #[salsa::invoke(InherentImpls::inherent_impls_in_crate_query)]\n     fn inherent_impls_in_crate(&self, krate: CrateId) -> Arc<InherentImpls>;"}, {"sha": "eb74809bfe3845f8f94aa4feeae9393199f7d144", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 39, "deletions": 25, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=b301b040f5781a9083348936369a01c37138756f", "patch": "@@ -14,7 +14,7 @@ use hir_def::{\n     intern::{Internable, Interned},\n     item_scope::ItemInNs,\n     path::{Path, PathKind},\n-    type_ref::{TraitBoundModifier, TypeBound, TypeRef},\n+    type_ref::{ConstScalar, TraitBoundModifier, TypeBound, TypeRef},\n     visibility::Visibility,\n     HasModule, ItemContainerId, Lookup, ModuleId, TraitId,\n };\n@@ -28,10 +28,10 @@ use crate::{\n     mapping::from_chalk,\n     primitive, subst_prefix, to_assoc_type_id,\n     utils::{self, generics},\n-    AdtId, AliasEq, AliasTy, CallableDefId, CallableSig, Const, ConstValue, DomainGoal, GenericArg,\n-    ImplTraitId, Interner, Lifetime, LifetimeData, LifetimeOutlives, Mutability, OpaqueTy,\n-    ProjectionTy, ProjectionTyExt, QuantifiedWhereClause, Scalar, TraitRef, TraitRefExt, Ty, TyExt,\n-    TyKind, WhereClause,\n+    AdtId, AliasEq, AliasTy, Binders, CallableDefId, CallableSig, Const, ConstValue, DomainGoal,\n+    GenericArg, ImplTraitId, Interner, Lifetime, LifetimeData, LifetimeOutlives, Mutability,\n+    OpaqueTy, ProjectionTy, ProjectionTyExt, QuantifiedWhereClause, Scalar, Substitution, TraitRef,\n+    TraitRefExt, Ty, TyExt, TyKind, WhereClause,\n };\n \n pub struct HirFormatter<'a> {\n@@ -316,11 +316,11 @@ impl HirDisplay for Const {\n         let data = self.interned();\n         match data.value {\n             ConstValue::BoundVar(idx) => idx.hir_fmt(f),\n-            ConstValue::InferenceVar(..) => write!(f, \"_\"),\n+            ConstValue::InferenceVar(..) => write!(f, \"#c#\"),\n             ConstValue::Placeholder(idx) => {\n                 let id = from_placeholder_idx(f.db, idx);\n                 let generics = generics(f.db.upcast(), id.parent);\n-                let param_data = &generics.params.tocs[id.local_id];\n+                let param_data = &generics.params.type_or_consts[id.local_id];\n                 write!(f, \"{}\", param_data.name().unwrap())\n             }\n             ConstValue::Concrete(c) => write!(f, \"{}\", c.interned),\n@@ -544,24 +544,37 @@ impl HirDisplay for Ty {\n                         {\n                             None => parameters.as_slice(Interner),\n                             Some(default_parameters) => {\n+                                fn should_show(\n+                                    parameter: &GenericArg,\n+                                    default_parameters: &[Binders<GenericArg>],\n+                                    i: usize,\n+                                    parameters: &Substitution,\n+                                ) -> bool {\n+                                    if parameter.ty(Interner).map(|x| x.kind(Interner))\n+                                        == Some(&TyKind::Error)\n+                                    {\n+                                        return true;\n+                                    }\n+                                    if let Some(ConstValue::Concrete(c)) =\n+                                        parameter.constant(Interner).map(|x| x.data(Interner).value)\n+                                    {\n+                                        if c.interned == ConstScalar::Unknown {\n+                                            return true;\n+                                        }\n+                                    }\n+                                    let default_parameter = match default_parameters.get(i) {\n+                                        Some(x) => x,\n+                                        None => return true,\n+                                    };\n+                                    let actual_default = default_parameter\n+                                        .clone()\n+                                        .substitute(Interner, &subst_prefix(parameters, i));\n+                                    parameter != &actual_default\n+                                }\n                                 let mut default_from = 0;\n                                 for (i, parameter) in parameters.iter(Interner).enumerate() {\n-                                    match (\n-                                        parameter.assert_ty_ref(Interner).kind(Interner),\n-                                        default_parameters.get(i),\n-                                    ) {\n-                                        (&TyKind::Error, _) | (_, None) => {\n-                                            default_from = i + 1;\n-                                        }\n-                                        (_, Some(default_parameter)) => {\n-                                            let actual_default = default_parameter\n-                                                .clone()\n-                                                .substitute(Interner, &subst_prefix(parameters, i));\n-                                            if parameter.assert_ty_ref(Interner) != &actual_default\n-                                            {\n-                                                default_from = i + 1;\n-                                            }\n-                                        }\n+                                    if should_show(parameter, &default_parameters, i, parameters) {\n+                                        default_from = i + 1;\n                                     }\n                                 }\n                                 &parameters.as_slice(Interner)[0..default_from]\n@@ -680,14 +693,14 @@ impl HirDisplay for Ty {\n             TyKind::Placeholder(idx) => {\n                 let id = from_placeholder_idx(f.db, *idx);\n                 let generics = generics(f.db.upcast(), id.parent);\n-                let param_data = &generics.params.tocs[id.local_id];\n+                let param_data = &generics.params.type_or_consts[id.local_id];\n                 match param_data {\n                     TypeOrConstParamData::TypeParamData(p) => match p.provenance {\n                         TypeParamProvenance::TypeParamList | TypeParamProvenance::TraitSelf => {\n                             write!(f, \"{}\", p.name.clone().unwrap_or_else(Name::missing))?\n                         }\n                         TypeParamProvenance::ArgumentImplTrait => {\n-                            let substs = generics.type_params_subst(f.db);\n+                            let substs = generics.placeholder_subst(f.db);\n                             let bounds =\n                                 f.db.generic_predicates(id.parent)\n                                     .iter()\n@@ -1281,6 +1294,7 @@ impl HirDisplay for hir_def::path::GenericArg {\n     fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         match self {\n             hir_def::path::GenericArg::Type(ty) => ty.hir_fmt(f),\n+            hir_def::path::GenericArg::Const(c) => write!(f, \"{}\", c),\n             hir_def::path::GenericArg::Lifetime(lifetime) => write!(f, \"{}\", lifetime.name),\n         }\n     }"}, {"sha": "4ee53910573734265e89dc01275d9a7636c8a378", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 46, "deletions": 14, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=b301b040f5781a9083348936369a01c37138756f", "patch": "@@ -16,7 +16,7 @@\n use std::ops::Index;\n use std::sync::Arc;\n \n-use chalk_ir::{cast::Cast, DebruijnIndex, Mutability, Safety, Scalar, TypeFlags};\n+use chalk_ir::{cast::Cast, ConstValue, DebruijnIndex, Mutability, Safety, Scalar, TypeFlags};\n use hir_def::{\n     body::Body,\n     data::{ConstData, FunctionData, StaticData},\n@@ -29,14 +29,16 @@ use hir_def::{\n     TraitId, TypeAliasId, VariantId,\n };\n use hir_expand::name::{name, Name};\n+use itertools::Either;\n use la_arena::ArenaMap;\n use rustc_hash::FxHashMap;\n use stdx::impl_from;\n \n use crate::{\n-    db::HirDatabase, fold_tys, infer::coerce::CoerceMany, lower::ImplTraitLoweringMode,\n-    to_assoc_type_id, AliasEq, AliasTy, DomainGoal, Goal, InEnvironment, Interner, ProjectionTy,\n-    Substitution, TraitEnvironment, TraitRef, Ty, TyBuilder, TyExt, TyKind,\n+    builder::ParamKind, db::HirDatabase, fold_tys_and_consts, infer::coerce::CoerceMany,\n+    lower::ImplTraitLoweringMode, to_assoc_type_id, AliasEq, AliasTy, Const, DomainGoal,\n+    GenericArg, GenericArgData, Goal, InEnvironment, Interner, ProjectionTy, Substitution,\n+    TraitEnvironment, TraitRef, Ty, TyBuilder, TyExt, TyKind,\n };\n \n // This lint has a false positive here. See the link below for details.\n@@ -354,11 +356,11 @@ impl Index<PatId> for InferenceResult {\n \n /// The inference context contains all information needed during type inference.\n #[derive(Clone, Debug)]\n-struct InferenceContext<'a> {\n-    db: &'a dyn HirDatabase,\n+pub(crate) struct InferenceContext<'a> {\n+    pub(crate) db: &'a dyn HirDatabase,\n     owner: DefWithBodyId,\n-    body: Arc<Body>,\n-    resolver: Resolver,\n+    pub(crate) body: Arc<Body>,\n+    pub(crate) resolver: Resolver,\n     table: unify::InferenceTable<'a>,\n     trait_env: Arc<TraitEnvironment>,\n     result: InferenceResult,\n@@ -488,6 +490,20 @@ impl<'a> InferenceContext<'a> {\n         self.make_ty_with_mode(type_ref, ImplTraitLoweringMode::Disallowed)\n     }\n \n+    /// Replaces ConstScalar::Unknown by a new type var, so we can maybe still infer it.\n+    fn insert_const_vars_shallow(&mut self, c: Const) -> Const {\n+        let data = c.data(Interner);\n+        match data.value {\n+            ConstValue::Concrete(cc) => match cc.interned {\n+                hir_def::type_ref::ConstScalar::Usize(_) => c,\n+                hir_def::type_ref::ConstScalar::Unknown => {\n+                    self.table.new_const_var(data.ty.clone())\n+                }\n+            },\n+            _ => c,\n+        }\n+    }\n+\n     /// Replaces Ty::Unknown by a new type var, so we can maybe still infer it.\n     fn insert_type_vars_shallow(&mut self, ty: Ty) -> Ty {\n         match ty.kind(Interner) {\n@@ -505,7 +521,14 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     fn insert_type_vars(&mut self, ty: Ty) -> Ty {\n-        fold_tys(ty, |ty, _| self.insert_type_vars_shallow(ty), DebruijnIndex::INNERMOST)\n+        fold_tys_and_consts(\n+            ty,\n+            |x, _| match x {\n+                Either::Left(ty) => Either::Left(self.insert_type_vars_shallow(ty)),\n+                Either::Right(c) => Either::Right(self.insert_const_vars_shallow(c)),\n+            },\n+            DebruijnIndex::INNERMOST,\n+        )\n     }\n \n     fn resolve_obligations_as_possible(&mut self) {\n@@ -533,7 +556,7 @@ impl<'a> InferenceContext<'a> {\n         &mut self,\n         inner_ty: Ty,\n         assoc_ty: Option<TypeAliasId>,\n-        params: &[Ty],\n+        params: &[GenericArg],\n     ) -> Ty {\n         match assoc_ty {\n             Some(res_assoc_ty) => {\n@@ -542,9 +565,10 @@ impl<'a> InferenceContext<'a> {\n                     _ => panic!(\"resolve_associated_type called with non-associated type\"),\n                 };\n                 let ty = self.table.new_type_var();\n+                let mut param_iter = params.iter().cloned();\n                 let trait_ref = TyBuilder::trait_ref(self.db, trait_)\n                     .push(inner_ty)\n-                    .fill(params.iter().cloned())\n+                    .fill(|_| param_iter.next().unwrap())\n                     .build();\n                 let alias_eq = AliasEq {\n                     alias: AliasTy::Projection(ProjectionTy {\n@@ -627,13 +651,21 @@ impl<'a> InferenceContext<'a> {\n             }\n             TypeNs::SelfType(impl_id) => {\n                 let generics = crate::utils::generics(self.db.upcast(), impl_id.into());\n-                let substs = generics.type_params_subst(self.db);\n+                let substs = generics.placeholder_subst(self.db);\n                 let ty = self.db.impl_self_ty(impl_id).substitute(Interner, &substs);\n                 self.resolve_variant_on_alias(ty, unresolved, path)\n             }\n             TypeNs::TypeAliasId(it) => {\n                 let ty = TyBuilder::def_ty(self.db, it.into())\n-                    .fill(std::iter::repeat_with(|| self.table.new_type_var()))\n+                    .fill(|x| match x {\n+                        ParamKind::Type => {\n+                            GenericArgData::Ty(self.table.new_type_var()).intern(Interner)\n+                        }\n+                        ParamKind::Const(ty) => {\n+                            GenericArgData::Const(self.table.new_const_var(ty.clone()))\n+                                .intern(Interner)\n+                        }\n+                    })\n                     .build();\n                 self.resolve_variant_on_alias(ty, unresolved, path)\n             }\n@@ -827,7 +859,7 @@ impl<'a> InferenceContext<'a> {\n /// When inferring an expression, we propagate downward whatever type hint we\n /// are able in the form of an `Expectation`.\n #[derive(Clone, PartialEq, Eq, Debug)]\n-enum Expectation {\n+pub(crate) enum Expectation {\n     None,\n     HasType(Ty),\n     // Castable(Ty), // rustc has this, we currently just don't propagate an expectation for casts"}, {"sha": "e78a6377e5e6d99d1b892a46c39a21f2da73ba46", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 52, "deletions": 31, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=b301b040f5781a9083348936369a01c37138756f", "patch": "@@ -7,13 +7,15 @@ use std::{\n     sync::Arc,\n };\n \n-use chalk_ir::{cast::Cast, fold::Shift, Mutability, TyVariableKind};\n+use chalk_ir::{\n+    cast::Cast, fold::Shift, DebruijnIndex, GenericArgData, Mutability, TyVariableKind,\n+};\n use hir_def::{\n     expr::{ArithOp, Array, BinaryOp, CmpOp, Expr, ExprId, Literal, Ordering, Statement, UnaryOp},\n     generics::TypeOrConstParamData,\n     path::{GenericArg, GenericArgs},\n     resolver::resolver_for_expr,\n-    FieldId, FunctionId, ItemContainerId, Lookup,\n+    ConstParamId, FieldId, FunctionId, ItemContainerId, Lookup,\n };\n use hir_expand::name::{name, Name};\n use stdx::always;\n@@ -23,7 +25,9 @@ use crate::{\n     autoderef::{self, Autoderef},\n     consteval,\n     infer::coerce::CoerceMany,\n-    lower::lower_to_chalk_mutability,\n+    lower::{\n+        const_or_path_to_chalk, generic_arg_to_chalk, lower_to_chalk_mutability, ParamLoweringMode,\n+    },\n     mapping::from_chalk,\n     method_resolution,\n     primitive::{self, UintTy},\n@@ -39,7 +43,7 @@ use super::{\n };\n \n impl<'a> InferenceContext<'a> {\n-    pub(super) fn infer_expr(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n+    pub(crate) fn infer_expr(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n         let ty = self.infer_expr_inner(tgt_expr, expected);\n         if self.resolve_ty_shallow(&ty).is_never() {\n             // Any expression that produces a value of type `!` must have diverged\n@@ -662,7 +666,7 @@ impl<'a> InferenceContext<'a> {\n                     self.resolve_associated_type_with_params(\n                         self_ty,\n                         self.resolve_ops_index_output(),\n-                        &[index_ty],\n+                        &[GenericArgData::Ty(index_ty).intern(Interner)],\n                     )\n                 } else {\n                     self.err_ty()\n@@ -704,7 +708,7 @@ impl<'a> InferenceContext<'a> {\n                             let cur_elem_ty = self.infer_expr_inner(expr, &expected);\n                             coerce.coerce(self, Some(expr), &cur_elem_ty);\n                         }\n-                        Some(items.len() as u64)\n+                        consteval::usize_const(Some(items.len() as u64))\n                     }\n                     &Array::Repeat { initializer, repeat } => {\n                         self.infer_expr_coerce(initializer, &Expectation::has_type(elem_ty));\n@@ -715,19 +719,22 @@ impl<'a> InferenceContext<'a> {\n                             ),\n                         );\n \n-                        consteval::eval_usize(\n-                            repeat,\n-                            consteval::ConstEvalCtx {\n-                                exprs: &body.exprs,\n-                                pats: &body.pats,\n-                                local_data: Default::default(),\n-                                infer: &mut |x| self.infer_expr(x, &expected),\n-                            },\n-                        )\n+                        if let Some(g_def) = self.owner.as_generic_def_id() {\n+                            let generics = generics(self.db.upcast(), g_def);\n+                            consteval::eval_to_const(\n+                                repeat,\n+                                ParamLoweringMode::Placeholder,\n+                                self,\n+                                || generics,\n+                                DebruijnIndex::INNERMOST,\n+                            )\n+                        } else {\n+                            consteval::usize_const(None)\n+                        }\n                     }\n                 };\n \n-                TyKind::Array(coerce.complete(), consteval::usize_const(len)).intern(Interner)\n+                TyKind::Array(coerce.complete(), len).intern(Interner)\n             }\n             Expr::Literal(lit) => match lit {\n                 Literal::Bool(..) => TyKind::Scalar(Scalar::Bool).intern(Interner),\n@@ -1038,38 +1045,52 @@ impl<'a> InferenceContext<'a> {\n         let total_len = parent_params + type_params + const_params + impl_trait_params;\n         let mut substs = Vec::with_capacity(total_len);\n         // Parent arguments are unknown\n-        for (_id, param) in def_generics.iter_parent() {\n+        for (id, param) in def_generics.iter_parent() {\n             match param {\n                 TypeOrConstParamData::TypeParamData(_) => {\n-                    substs.push(self.table.new_type_var());\n+                    substs.push(GenericArgData::Ty(self.table.new_type_var()).intern(Interner));\n                 }\n                 TypeOrConstParamData::ConstParamData(_) => {\n-                    // FIXME: here we should do something else\n-                    substs.push(self.table.new_type_var());\n+                    let ty = self.db.const_param_ty(ConstParamId::from_unchecked(id));\n+                    substs\n+                        .push(GenericArgData::Const(self.table.new_const_var(ty)).intern(Interner));\n                 }\n             }\n         }\n-        // handle provided type arguments\n+        // handle provided arguments\n         if let Some(generic_args) = generic_args {\n             // if args are provided, it should be all of them, but we can't rely on that\n-            for arg in generic_args\n+            for (arg, kind_id) in generic_args\n                 .args\n                 .iter()\n-                .filter(|arg| matches!(arg, GenericArg::Type(_)))\n-                .take(type_params)\n+                .filter(|arg| !matches!(arg, GenericArg::Lifetime(_)))\n+                .take(type_params + const_params)\n+                .zip(def_generics.iter_id().skip(parent_params))\n             {\n-                match arg {\n-                    GenericArg::Type(type_ref) => {\n-                        let ty = self.make_ty(type_ref);\n-                        substs.push(ty);\n-                    }\n-                    GenericArg::Lifetime(_) => {}\n+                if let Some(g) = generic_arg_to_chalk(\n+                    self.db,\n+                    kind_id,\n+                    arg,\n+                    self,\n+                    |this, type_ref| this.make_ty(type_ref),\n+                    |this, c| {\n+                        const_or_path_to_chalk(\n+                            this.db,\n+                            &this.resolver,\n+                            c,\n+                            ParamLoweringMode::Placeholder,\n+                            || generics(this.db.upcast(), (&this.resolver).generic_def().unwrap()),\n+                            DebruijnIndex::INNERMOST,\n+                        )\n+                    },\n+                ) {\n+                    substs.push(g);\n                 }\n             }\n         };\n         let supplied_params = substs.len();\n         for _ in supplied_params..total_len {\n-            substs.push(self.table.new_type_var());\n+            substs.push(GenericArgData::Ty(self.table.new_type_var()).intern(Interner));\n         }\n         assert_eq!(substs.len(), total_len);\n         Substitution::from_iter(Interner, substs)"}, {"sha": "1d236545769ed997c1aa6879e478a97bf068e02a", "filename": "crates/hir_ty/src/infer/path.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=b301b040f5781a9083348936369a01c37138756f", "patch": "@@ -1,7 +1,5 @@\n //! Path expression resolution.\n \n-use std::iter;\n-\n use chalk_ir::cast::Cast;\n use hir_def::{\n     path::{Path, PathSegment},\n@@ -11,8 +9,8 @@ use hir_def::{\n use hir_expand::name::Name;\n \n use crate::{\n-    method_resolution, Interner, Substitution, TraitRefExt, Ty, TyBuilder, TyExt, TyKind,\n-    ValueTyDefId,\n+    builder::ParamKind, consteval, method_resolution, GenericArgData, Interner, Substitution,\n+    TraitRefExt, Ty, TyBuilder, TyExt, TyKind, ValueTyDefId,\n };\n \n use super::{ExprOrPatId, InferenceContext, TraitRef};\n@@ -82,7 +80,7 @@ impl<'a> InferenceContext<'a> {\n             }\n             ValueNs::ImplSelf(impl_id) => {\n                 let generics = crate::utils::generics(self.db.upcast(), impl_id.into());\n-                let substs = generics.type_params_subst(self.db);\n+                let substs = generics.placeholder_subst(self.db);\n                 let ty = self.db.impl_self_ty(impl_id).substitute(Interner, &substs);\n                 if let Some((AdtId::StructId(struct_id), substs)) = ty.as_adt() {\n                     let ty = self.db.value_ty(struct_id.into()).substitute(Interner, &substs);\n@@ -98,9 +96,19 @@ impl<'a> InferenceContext<'a> {\n         let parent_substs = self_subst.unwrap_or_else(|| Substitution::empty(Interner));\n         let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n         let substs = ctx.substs_from_path(path, typable, true);\n+        let mut it = substs.as_slice(Interner)[parent_substs.len(Interner)..].iter().cloned();\n         let ty = TyBuilder::value_ty(self.db, typable)\n             .use_parent_substs(&parent_substs)\n-            .fill(substs.as_slice(Interner)[parent_substs.len(Interner)..].iter().cloned())\n+            .fill(|x| {\n+                it.next().unwrap_or_else(|| match x {\n+                    ParamKind::Type => {\n+                        GenericArgData::Ty(TyKind::Error.intern(Interner)).intern(Interner)\n+                    }\n+                    ParamKind::Const(_) => {\n+                        GenericArgData::Const(consteval::usize_const(None)).intern(Interner)\n+                    }\n+                })\n+            })\n             .build();\n         Some(ty)\n     }\n@@ -241,7 +249,15 @@ impl<'a> InferenceContext<'a> {\n                 let substs = match container {\n                     ItemContainerId::ImplId(impl_id) => {\n                         let impl_substs = TyBuilder::subst_for_def(self.db, impl_id)\n-                            .fill(iter::repeat_with(|| self.table.new_type_var()))\n+                            .fill(|x| match x {\n+                                ParamKind::Type => {\n+                                    GenericArgData::Ty(self.table.new_type_var()).intern(Interner)\n+                                }\n+                                ParamKind::Const(ty) => {\n+                                    GenericArgData::Const(self.table.new_const_var(ty.clone()))\n+                                        .intern(Interner)\n+                                }\n+                            })\n                             .build();\n                         let impl_self_ty =\n                             self.db.impl_self_ty(impl_id).substitute(Interner, &impl_substs);\n@@ -252,7 +268,15 @@ impl<'a> InferenceContext<'a> {\n                         // we're picking this method\n                         let trait_ref = TyBuilder::trait_ref(self.db, trait_)\n                             .push(ty.clone())\n-                            .fill(std::iter::repeat_with(|| self.table.new_type_var()))\n+                            .fill(|x| match x {\n+                                ParamKind::Type => {\n+                                    GenericArgData::Ty(self.table.new_type_var()).intern(Interner)\n+                                }\n+                                ParamKind::Const(ty) => {\n+                                    GenericArgData::Const(self.table.new_const_var(ty.clone()))\n+                                        .intern(Interner)\n+                                }\n+                            })\n                             .build();\n                         self.push_obligation(trait_ref.clone().cast(Interner));\n                         Some(trait_ref.substitution)"}, {"sha": "deb536e5114be30346b75279cf97d4871ab50c7a", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 30, "deletions": 17, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=b301b040f5781a9083348936369a01c37138756f", "patch": "@@ -1,6 +1,6 @@\n //! Unification and canonicalization logic.\n \n-use std::{fmt, iter, mem, sync::Arc};\n+use std::{fmt, mem, sync::Arc};\n \n use chalk_ir::{\n     cast::Cast, fold::Fold, interner::HasInterner, zip::Zip, FloatTy, IntTy, NoSolution,\n@@ -9,13 +9,14 @@ use chalk_ir::{\n use chalk_solve::infer::ParameterEnaVariableExt;\n use ena::unify::UnifyKey;\n use hir_expand::name;\n+use stdx::never;\n \n use super::{InferOk, InferResult, InferenceContext, TypeError};\n use crate::{\n     db::HirDatabase, fold_tys, static_lifetime, traits::FnTrait, AliasEq, AliasTy, BoundVar,\n-    Canonical, Const, DebruijnIndex, GenericArg, Goal, Guidance, InEnvironment, InferenceVar,\n-    Interner, Lifetime, ProjectionTy, ProjectionTyExt, Scalar, Solution, Substitution,\n-    TraitEnvironment, Ty, TyBuilder, TyExt, TyKind, VariableKind,\n+    Canonical, Const, DebruijnIndex, GenericArg, GenericArgData, Goal, Guidance, InEnvironment,\n+    InferenceVar, Interner, Lifetime, ParamKind, ProjectionTy, ProjectionTyExt, Scalar, Solution,\n+    Substitution, TraitEnvironment, Ty, TyBuilder, TyExt, TyKind, VariableKind,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -48,13 +49,13 @@ impl<T: HasInterner<Interner = Interner>> Canonicalized<T> {\n         // the solution may contain new variables, which we need to convert to new inference vars\n         let new_vars = Substitution::from_iter(\n             Interner,\n-            solution.binders.iter(Interner).map(|k| match k.kind {\n+            solution.binders.iter(Interner).map(|k| match &k.kind {\n                 VariableKind::Ty(TyVariableKind::General) => ctx.new_type_var().cast(Interner),\n                 VariableKind::Ty(TyVariableKind::Integer) => ctx.new_integer_var().cast(Interner),\n                 VariableKind::Ty(TyVariableKind::Float) => ctx.new_float_var().cast(Interner),\n                 // Chalk can sometimes return new lifetime variables. We just use the static lifetime everywhere\n                 VariableKind::Lifetime => static_lifetime().cast(Interner),\n-                _ => panic!(\"const variable in solution\"),\n+                VariableKind::Const(ty) => ctx.new_const_var(ty.clone()).cast(Interner),\n             }),\n         );\n         for (i, v) in solution.value.iter(Interner).enumerate() {\n@@ -87,11 +88,17 @@ pub(crate) fn unify(\n     let mut table = InferenceTable::new(db, env);\n     let vars = Substitution::from_iter(\n         Interner,\n-        tys.binders\n-            .iter(Interner)\n-            // we always use type vars here because we want everything to\n-            // fallback to Unknown in the end (kind of hacky, as below)\n-            .map(|_| table.new_type_var()),\n+        tys.binders.iter(Interner).map(|x| match &x.kind {\n+            chalk_ir::VariableKind::Ty(_) => {\n+                GenericArgData::Ty(table.new_type_var()).intern(Interner)\n+            }\n+            chalk_ir::VariableKind::Lifetime => {\n+                GenericArgData::Ty(table.new_type_var()).intern(Interner)\n+            } // FIXME: maybe wrong?\n+            chalk_ir::VariableKind::Const(ty) => {\n+                GenericArgData::Const(table.new_const_var(ty.clone())).intern(Interner)\n+            }\n+        }),\n     );\n     let ty1_with_vars = vars.apply(tys.value.0.clone(), Interner);\n     let ty2_with_vars = vars.apply(tys.value.1.clone(), Interner);\n@@ -117,8 +124,7 @@ pub(crate) fn unify(\n     };\n     Some(Substitution::from_iter(\n         Interner,\n-        vars.iter(Interner)\n-            .map(|v| table.resolve_with_fallback(v.assert_ty_ref(Interner).clone(), &fallback)),\n+        vars.iter(Interner).map(|v| table.resolve_with_fallback(v.clone(), &fallback)),\n     ))\n }\n \n@@ -552,11 +558,18 @@ impl<'a> InferenceTable<'a> {\n \n         let mut arg_tys = vec![];\n         let arg_ty = TyBuilder::tuple(num_args)\n-            .fill(iter::repeat_with(|| {\n-                let arg = self.new_type_var();\n+            .fill(|x| {\n+                let arg = match x {\n+                    ParamKind::Type => self.new_type_var(),\n+                    ParamKind::Const(ty) => {\n+                        never!(\"Tuple with const parameter\");\n+                        return GenericArgData::Const(self.new_const_var(ty.clone()))\n+                            .intern(Interner);\n+                    }\n+                };\n                 arg_tys.push(arg.clone());\n-                arg\n-            }))\n+                GenericArgData::Ty(arg).intern(Interner)\n+            })\n             .build();\n \n         let projection = {"}, {"sha": "d6a524d5939bfccb2e6f10ad1574c3251adcd072", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 89, "deletions": 12, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=b301b040f5781a9083348936369a01c37138756f", "patch": "@@ -42,11 +42,13 @@ use hir_def::{\n     type_ref::{ConstScalar, Rawness},\n     TypeOrConstParamId,\n };\n+use itertools::Either;\n+use utils::Generics;\n \n use crate::{db::HirDatabase, utils::generics};\n \n pub use autoderef::autoderef;\n-pub use builder::TyBuilder;\n+pub use builder::{ParamKind, TyBuilder};\n pub use chalk_ext::*;\n pub use infer::{could_unify, InferenceDiagnostic, InferenceResult};\n pub use interner::Interner;\n@@ -140,20 +142,58 @@ where\n     Binders::empty(Interner, value.shifted_in_from(Interner, DebruijnIndex::ONE))\n }\n \n-pub(crate) fn make_only_type_binders<T: HasInterner<Interner = Interner>>(\n-    num_vars: usize,\n+pub(crate) fn make_type_and_const_binders<T: HasInterner<Interner = Interner>>(\n+    which_is_const: impl Iterator<Item = Option<Ty>>,\n     value: T,\n ) -> Binders<T> {\n     Binders::new(\n         VariableKinds::from_iter(\n             Interner,\n-            std::iter::repeat(chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General))\n-                .take(num_vars),\n+            which_is_const.map(|x| {\n+                if let Some(ty) = x {\n+                    chalk_ir::VariableKind::Const(ty)\n+                } else {\n+                    chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General)\n+                }\n+            }),\n         ),\n         value,\n     )\n }\n \n+pub(crate) fn make_single_type_binders<T: HasInterner<Interner = Interner>>(\n+    value: T,\n+) -> Binders<T> {\n+    Binders::new(\n+        VariableKinds::from_iter(\n+            Interner,\n+            std::iter::once(chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General)),\n+        ),\n+        value,\n+    )\n+}\n+\n+pub(crate) fn make_binders_with_count<T: HasInterner<Interner = Interner>>(\n+    db: &dyn HirDatabase,\n+    count: usize,\n+    generics: &Generics,\n+    value: T,\n+) -> Binders<T> {\n+    let it = generics.iter_id().take(count).map(|id| match id {\n+        Either::Left(_) => None,\n+        Either::Right(id) => Some(db.const_param_ty(id)),\n+    });\n+    crate::make_type_and_const_binders(it, value)\n+}\n+\n+pub(crate) fn make_binders<T: HasInterner<Interner = Interner>>(\n+    db: &dyn HirDatabase,\n+    generics: &Generics,\n+    value: T,\n+) -> Binders<T> {\n+    make_binders_with_count(db, usize::MAX, generics, value)\n+}\n+\n // FIXME: get rid of this\n pub fn make_canonical<T: HasInterner<Interner = Interner>>(\n     value: T,\n@@ -288,11 +328,17 @@ pub fn dummy_usize_const() -> Const {\n \n pub(crate) fn fold_free_vars<T: HasInterner<Interner = Interner> + Fold<Interner>>(\n     t: T,\n-    f: impl FnMut(BoundVar, DebruijnIndex) -> Ty,\n+    for_ty: impl FnMut(BoundVar, DebruijnIndex) -> Ty,\n+    for_const: impl FnMut(Ty, BoundVar, DebruijnIndex) -> Const,\n ) -> T::Result {\n     use chalk_ir::{fold::Folder, Fallible};\n-    struct FreeVarFolder<F>(F);\n-    impl<'i, F: FnMut(BoundVar, DebruijnIndex) -> Ty + 'i> Folder<Interner> for FreeVarFolder<F> {\n+    struct FreeVarFolder<F1, F2>(F1, F2);\n+    impl<\n+            'i,\n+            F1: FnMut(BoundVar, DebruijnIndex) -> Ty + 'i,\n+            F2: FnMut(Ty, BoundVar, DebruijnIndex) -> Const + 'i,\n+        > Folder<Interner> for FreeVarFolder<F1, F2>\n+    {\n         type Error = NoSolution;\n \n         fn as_dyn(&mut self) -> &mut dyn Folder<Interner, Error = Self::Error> {\n@@ -310,21 +356,48 @@ pub(crate) fn fold_free_vars<T: HasInterner<Interner = Interner> + Fold<Interner\n         ) -> Fallible<Ty> {\n             Ok(self.0(bound_var, outer_binder))\n         }\n+\n+        fn fold_free_var_const(\n+            &mut self,\n+            ty: Ty,\n+            bound_var: BoundVar,\n+            outer_binder: DebruijnIndex,\n+        ) -> Fallible<Const> {\n+            Ok(self.1(ty, bound_var, outer_binder))\n+        }\n     }\n-    t.fold_with(&mut FreeVarFolder(f), DebruijnIndex::INNERMOST).expect(\"fold failed unexpectedly\")\n+    t.fold_with(&mut FreeVarFolder(for_ty, for_const), DebruijnIndex::INNERMOST)\n+        .expect(\"fold failed unexpectedly\")\n }\n \n pub(crate) fn fold_tys<T: HasInterner<Interner = Interner> + Fold<Interner>>(\n     t: T,\n-    f: impl FnMut(Ty, DebruijnIndex) -> Ty,\n+    mut for_ty: impl FnMut(Ty, DebruijnIndex) -> Ty,\n+    binders: DebruijnIndex,\n+) -> T::Result {\n+    fold_tys_and_consts(\n+        t,\n+        |x, d| match x {\n+            Either::Left(x) => Either::Left(for_ty(x, d)),\n+            Either::Right(x) => Either::Right(x),\n+        },\n+        binders,\n+    )\n+}\n+\n+pub(crate) fn fold_tys_and_consts<T: HasInterner<Interner = Interner> + Fold<Interner>>(\n+    t: T,\n+    f: impl FnMut(Either<Ty, Const>, DebruijnIndex) -> Either<Ty, Const>,\n     binders: DebruijnIndex,\n ) -> T::Result {\n     use chalk_ir::{\n         fold::{Folder, SuperFold},\n         Fallible,\n     };\n     struct TyFolder<F>(F);\n-    impl<'i, F: FnMut(Ty, DebruijnIndex) -> Ty + 'i> Folder<Interner> for TyFolder<F> {\n+    impl<'i, F: FnMut(Either<Ty, Const>, DebruijnIndex) -> Either<Ty, Const> + 'i> Folder<Interner>\n+        for TyFolder<F>\n+    {\n         type Error = NoSolution;\n \n         fn as_dyn(&mut self) -> &mut dyn Folder<Interner, Error = Self::Error> {\n@@ -337,7 +410,11 @@ pub(crate) fn fold_tys<T: HasInterner<Interner = Interner> + Fold<Interner>>(\n \n         fn fold_ty(&mut self, ty: Ty, outer_binder: DebruijnIndex) -> Fallible<Ty> {\n             let ty = ty.super_fold_with(self.as_dyn(), outer_binder)?;\n-            Ok(self.0(ty, outer_binder))\n+            Ok(self.0(Either::Left(ty), outer_binder).left().unwrap())\n+        }\n+\n+        fn fold_const(&mut self, c: Const, outer_binder: DebruijnIndex) -> Fallible<Const> {\n+            Ok(self.0(Either::Right(c), outer_binder).right().unwrap())\n         }\n     }\n     t.fold_with(&mut TyFolder(f), binders).expect(\"fold failed unexpectedly\")"}, {"sha": "9e69785ac29c4b4ecae51b574784be3cdc551c2d", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 234, "deletions": 116, "changes": 350, "blob_url": "https://github.com/rust-lang/rust/blob/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=b301b040f5781a9083348936369a01c37138756f", "patch": "@@ -9,9 +9,11 @@ use std::cell::{Cell, RefCell};\n use std::{iter, sync::Arc};\n \n use base_db::CrateId;\n-use chalk_ir::{cast::Cast, fold::Shift, interner::HasInterner, Mutability, Safety};\n+use chalk_ir::{cast::Cast, fold::Shift, Mutability, Safety};\n use hir_def::generics::TypeOrConstParamData;\n use hir_def::intern::Interned;\n+use hir_def::path::{ModPath, PathKind};\n+use hir_def::type_ref::ConstScalarOrPath;\n use hir_def::{\n     adt::StructKind,\n     body::{Expander, LowerCtx},\n@@ -24,23 +26,25 @@ use hir_def::{\n     ImplId, ItemContainerId, LocalFieldId, Lookup, StaticId, StructId, TraitId, TypeAliasId,\n     UnionId, VariantId,\n };\n-use hir_def::{ConstParamId, TypeOrConstParamId};\n+use hir_def::{ConstParamId, TypeOrConstParamId, TypeParamId};\n use hir_expand::{name::Name, ExpandResult};\n+use itertools::Either;\n use la_arena::ArenaMap;\n use rustc_hash::FxHashSet;\n use smallvec::SmallVec;\n use stdx::{impl_from, never};\n use syntax::{ast, SmolStr};\n \n-use crate::all_super_traits;\n+use crate::consteval::{path_to_const, unknown_const_as_generic, unknown_const_usize, usize_const};\n+use crate::method_resolution::fallback_bound_vars;\n+use crate::utils::Generics;\n+use crate::{all_super_traits, make_binders, Const, GenericArgData, ParamKind};\n use crate::{\n     consteval,\n     db::HirDatabase,\n     mapping::ToChalk,\n     static_lifetime, to_assoc_type_id, to_chalk_trait_id, to_placeholder_idx,\n-    utils::{\n-        all_super_trait_refs, associated_type_by_name_including_super_traits, generics, Generics,\n-    },\n+    utils::{all_super_trait_refs, associated_type_by_name_including_super_traits, generics},\n     AliasEq, AliasTy, Binders, BoundVar, CallableSig, DebruijnIndex, DynTy, FnPointer, FnSig,\n     FnSubst, ImplTraitId, Interner, PolyFnSig, ProjectionTy, QuantifiedWhereClause,\n     QuantifiedWhereClauses, ReturnTypeImplTrait, ReturnTypeImplTraits, Substitution,\n@@ -56,7 +60,7 @@ pub struct TyLoweringContext<'a> {\n     /// some type params should be represented as placeholders, and others\n     /// should be converted to variables. I think in practice, this isn't\n     /// possible currently, so this should be fine for now.\n-    pub type_param_mode: TypeParamLoweringMode,\n+    pub type_param_mode: ParamLoweringMode,\n     pub impl_trait_mode: ImplTraitLoweringMode,\n     impl_trait_counter: Cell<u16>,\n     /// When turning `impl Trait` into opaque types, we have to collect the\n@@ -77,7 +81,7 @@ impl<'a> TyLoweringContext<'a> {\n     pub fn new(db: &'a dyn HirDatabase, resolver: &'a Resolver) -> Self {\n         let impl_trait_counter = Cell::new(0);\n         let impl_trait_mode = ImplTraitLoweringMode::Disallowed;\n-        let type_param_mode = TypeParamLoweringMode::Placeholder;\n+        let type_param_mode = ParamLoweringMode::Placeholder;\n         let in_binders = DebruijnIndex::INNERMOST;\n         let opaque_type_data = RefCell::new(Vec::new());\n         Self {\n@@ -129,7 +133,7 @@ impl<'a> TyLoweringContext<'a> {\n         Self { impl_trait_mode, ..self }\n     }\n \n-    pub fn with_type_param_mode(self, type_param_mode: TypeParamLoweringMode) -> Self {\n+    pub fn with_type_param_mode(self, type_param_mode: ParamLoweringMode) -> Self {\n         Self { type_param_mode, ..self }\n     }\n }\n@@ -155,7 +159,7 @@ pub enum ImplTraitLoweringMode {\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum TypeParamLoweringMode {\n+pub enum ParamLoweringMode {\n     Placeholder,\n     Variable,\n }\n@@ -165,6 +169,15 @@ impl<'a> TyLoweringContext<'a> {\n         self.lower_ty_ext(type_ref).0\n     }\n \n+    fn generics(&self) -> Generics {\n+        generics(\n+            self.db.upcast(),\n+            self.resolver\n+                .generic_def()\n+                .expect(\"there should be generics if there's a generic param\"),\n+        )\n+    }\n+\n     pub fn lower_ty_ext(&self, type_ref: &TypeRef) -> (Ty, Option<TypeNs>) {\n         let mut res = None;\n         let ty = match type_ref {\n@@ -185,8 +198,14 @@ impl<'a> TyLoweringContext<'a> {\n             }\n             TypeRef::Array(inner, len) => {\n                 let inner_ty = self.lower_ty(inner);\n-\n-                let const_len = consteval::usize_const(len.as_usize());\n+                let const_len = const_or_path_to_chalk(\n+                    self.db,\n+                    self.resolver,\n+                    len,\n+                    self.type_param_mode,\n+                    || self.generics(),\n+                    DebruijnIndex::INNERMOST,\n+                );\n \n                 TyKind::Array(inner_ty, const_len).intern(Interner)\n             }\n@@ -221,7 +240,7 @@ impl<'a> TyLoweringContext<'a> {\n                         bounds.iter().flat_map(|b| ctx.lower_type_bound(b, self_ty.clone(), false)),\n                     )\n                 });\n-                let bounds = crate::make_only_type_binders(1, bounds);\n+                let bounds = crate::make_single_type_binders(bounds);\n                 TyKind::Dyn(DynTy { bounds, lifetime: static_lifetime() }).intern(Interner)\n             }\n             TypeRef::ImplTrait(bounds) => {\n@@ -239,7 +258,7 @@ impl<'a> TyLoweringContext<'a> {\n                         // place even if we encounter more opaque types while\n                         // lowering the bounds\n                         self.opaque_type_data.borrow_mut().push(ReturnTypeImplTrait {\n-                            bounds: crate::make_only_type_binders(1, Vec::new()),\n+                            bounds: crate::make_single_type_binders(Vec::new()),\n                         });\n                         // We don't want to lower the bounds inside the binders\n                         // we're currently in, because they don't end up inside\n@@ -259,7 +278,7 @@ impl<'a> TyLoweringContext<'a> {\n                         let impl_trait_id = ImplTraitId::ReturnTypeImplTrait(func, idx);\n                         let opaque_ty_id = self.db.intern_impl_trait_id(impl_trait_id).into();\n                         let generics = generics(self.db.upcast(), func.into());\n-                        let parameters = generics.bound_vars_subst(self.in_binders);\n+                        let parameters = generics.bound_vars_subst(self.db, self.in_binders);\n                         TyKind::OpaqueType(opaque_ty_id, parameters).intern(Interner)\n                     }\n                     ImplTraitLoweringMode::Param => {\n@@ -449,8 +468,7 @@ impl<'a> TyLoweringContext<'a> {\n                             )\n                         });\n                         let dyn_ty = DynTy {\n-                            bounds: crate::make_only_type_binders(\n-                                1,\n+                            bounds: crate::make_single_type_binders(\n                                 QuantifiedWhereClauses::from_iter(\n                                     Interner,\n                                     Some(crate::wrap_empty_binders(WhereClause::Implemented(\n@@ -475,10 +493,10 @@ impl<'a> TyLoweringContext<'a> {\n                     self.resolver.generic_def().expect(\"generics in scope\"),\n                 );\n                 match self.type_param_mode {\n-                    TypeParamLoweringMode::Placeholder => {\n+                    ParamLoweringMode::Placeholder => {\n                         TyKind::Placeholder(to_placeholder_idx(self.db, param_id.into()))\n                     }\n-                    TypeParamLoweringMode::Variable => {\n+                    ParamLoweringMode::Variable => {\n                         let idx = generics.param_idx(param_id.into()).expect(\"matching generics\");\n                         TyKind::BoundVar(BoundVar::new(self.in_binders, idx))\n                     }\n@@ -488,16 +506,20 @@ impl<'a> TyLoweringContext<'a> {\n             TypeNs::SelfType(impl_id) => {\n                 let generics = generics(self.db.upcast(), impl_id.into());\n                 let substs = match self.type_param_mode {\n-                    TypeParamLoweringMode::Placeholder => generics.type_params_subst(self.db),\n-                    TypeParamLoweringMode::Variable => generics.bound_vars_subst(self.in_binders),\n+                    ParamLoweringMode::Placeholder => generics.placeholder_subst(self.db),\n+                    ParamLoweringMode::Variable => {\n+                        generics.bound_vars_subst(self.db, self.in_binders)\n+                    }\n                 };\n                 self.db.impl_self_ty(impl_id).substitute(Interner, &substs)\n             }\n             TypeNs::AdtSelfType(adt) => {\n                 let generics = generics(self.db.upcast(), adt.into());\n                 let substs = match self.type_param_mode {\n-                    TypeParamLoweringMode::Placeholder => generics.type_params_subst(self.db),\n-                    TypeParamLoweringMode::Variable => generics.bound_vars_subst(self.in_binders),\n+                    ParamLoweringMode::Placeholder => generics.placeholder_subst(self.db),\n+                    ParamLoweringMode::Variable => {\n+                        generics.bound_vars_subst(self.db, self.in_binders)\n+                    }\n                 };\n                 self.db.ty(adt.into()).substitute(Interner, &substs)\n             }\n@@ -549,7 +571,7 @@ impl<'a> TyLoweringContext<'a> {\n             move |name, t, associated_ty| {\n                 if name == segment.name {\n                     let substs = match self.type_param_mode {\n-                        TypeParamLoweringMode::Placeholder => {\n+                        ParamLoweringMode::Placeholder => {\n                             // if we're lowering to placeholders, we have to put\n                             // them in now\n                             let generics = generics(\n@@ -558,10 +580,10 @@ impl<'a> TyLoweringContext<'a> {\n                                     .generic_def()\n                                     .expect(\"there should be generics if there's a generic param\"),\n                             );\n-                            let s = generics.type_params_subst(self.db);\n+                            let s = generics.placeholder_subst(self.db);\n                             s.apply(t.substitution.clone(), Interner)\n                         }\n-                        TypeParamLoweringMode::Variable => t.substitution.clone(),\n+                        ParamLoweringMode::Variable => t.substitution.clone(),\n                     };\n                     // We need to shift in the bound vars, since\n                     // associated_type_shorthand_candidates does not do that\n@@ -642,47 +664,75 @@ impl<'a> TyLoweringContext<'a> {\n         explicit_self_ty: Option<Ty>,\n     ) -> Substitution {\n         let mut substs = Vec::new();\n-        let def_generics = def_generic.map(|def| generics(self.db.upcast(), def));\n-\n+        let def_generics = if let Some(def) = def_generic {\n+            generics(self.db.upcast(), def)\n+        } else {\n+            return Substitution::empty(Interner);\n+        };\n         let (parent_params, self_params, type_params, const_params, impl_trait_params) =\n-            def_generics.map_or((0, 0, 0, 0, 0), |g| g.provenance_split());\n+            def_generics.provenance_split();\n         let total_len =\n             parent_params + self_params + type_params + const_params + impl_trait_params;\n \n-        substs.extend(iter::repeat(TyKind::Error.intern(Interner)).take(parent_params));\n+        let ty_error = GenericArgData::Ty(TyKind::Error.intern(Interner)).intern(Interner);\n+        let const_error = GenericArgData::Const(consteval::usize_const(None)).intern(Interner);\n+\n+        for (_, data) in def_generics.iter().take(parent_params) {\n+            match data {\n+                TypeOrConstParamData::TypeParamData(_) => substs.push(ty_error.clone()),\n+                TypeOrConstParamData::ConstParamData(_) => substs.push(const_error.clone()),\n+            }\n+        }\n \n         let fill_self_params = || {\n             substs.extend(\n                 explicit_self_ty\n                     .into_iter()\n-                    .chain(iter::repeat(TyKind::Error.intern(Interner)))\n+                    .map(|x| GenericArgData::Ty(x).intern(Interner))\n+                    .chain(iter::repeat(ty_error.clone()))\n                     .take(self_params),\n             )\n         };\n-        let mut had_explicit_type_args = false;\n+        let mut had_explicit_args = false;\n \n         if let Some(generic_args) = &segment.args_and_bindings {\n             if !generic_args.has_self_type {\n                 fill_self_params();\n             }\n-            let expected_num =\n-                if generic_args.has_self_type { self_params + type_params } else { type_params };\n+            let expected_num = if generic_args.has_self_type {\n+                self_params + type_params + const_params\n+            } else {\n+                type_params + const_params\n+            };\n             let skip = if generic_args.has_self_type && self_params == 0 { 1 } else { 0 };\n             // if args are provided, it should be all of them, but we can't rely on that\n-            for arg in generic_args\n+            for (arg, id) in generic_args\n                 .args\n                 .iter()\n-                .filter(|arg| matches!(arg, GenericArg::Type(_)))\n+                .filter(|arg| !matches!(arg, GenericArg::Lifetime(_)))\n                 .skip(skip)\n                 .take(expected_num)\n+                .zip(def_generics.iter_id().skip(skip))\n             {\n-                match arg {\n-                    GenericArg::Type(type_ref) => {\n-                        had_explicit_type_args = true;\n-                        let ty = self.lower_ty(type_ref);\n-                        substs.push(ty);\n-                    }\n-                    GenericArg::Lifetime(_) => {}\n+                if let Some(x) = generic_arg_to_chalk(\n+                    self.db,\n+                    id,\n+                    arg,\n+                    &mut (),\n+                    |_, type_ref| self.lower_ty(type_ref),\n+                    |_, c| {\n+                        const_or_path_to_chalk(\n+                            self.db,\n+                            &self.resolver,\n+                            c,\n+                            self.type_param_mode,\n+                            || self.generics(),\n+                            DebruijnIndex::INNERMOST,\n+                        )\n+                    },\n+                ) {\n+                    had_explicit_args = true;\n+                    substs.push(x);\n                 }\n             }\n         } else {\n@@ -692,7 +742,7 @@ impl<'a> TyLoweringContext<'a> {\n         // handle defaults. In expression or pattern path segments without\n         // explicitly specified type arguments, missing type arguments are inferred\n         // (i.e. defaults aren't used).\n-        if !infer_args || had_explicit_type_args {\n+        if !infer_args || had_explicit_args {\n             if let Some(def_generic) = def_generic {\n                 let defaults = self.db.generic_defaults(def_generic);\n                 assert_eq!(total_len, defaults.len());\n@@ -707,8 +757,11 @@ impl<'a> TyLoweringContext<'a> {\n \n         // add placeholders for args that were not provided\n         // FIXME: emit diagnostics in contexts where this is not allowed\n-        for _ in substs.len()..total_len {\n-            substs.push(TyKind::Error.intern(Interner));\n+        for (_, data) in def_generics.iter().skip(substs.len()) {\n+            match data {\n+                TypeOrConstParamData::TypeParamData(_) => substs.push(ty_error.clone()),\n+                TypeOrConstParamData::ConstParamData(_) => substs.push(const_error.clone()),\n+            }\n         }\n         assert_eq!(substs.len(), total_len);\n \n@@ -775,8 +828,8 @@ impl<'a> TyLoweringContext<'a> {\n                         };\n                         let placeholder = to_placeholder_idx(self.db, param_id);\n                         match self.type_param_mode {\n-                            TypeParamLoweringMode::Placeholder => TyKind::Placeholder(placeholder),\n-                            TypeParamLoweringMode::Variable => {\n+                            ParamLoweringMode::Placeholder => TyKind::Placeholder(placeholder),\n+                            ParamLoweringMode::Variable => {\n                                 let idx = generics.param_idx(param_id).expect(\"matching generics\");\n                                 TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, idx))\n                             }\n@@ -919,8 +972,7 @@ impl<'a> TyLoweringContext<'a> {\n             }\n             predicates\n         });\n-\n-        ReturnTypeImplTrait { bounds: crate::make_only_type_binders(1, predicates) }\n+        ReturnTypeImplTrait { bounds: crate::make_single_type_binders(predicates) }\n     }\n }\n \n@@ -999,7 +1051,7 @@ fn named_associated_type_shorthand_candidates<R>(\n             // Handle `Self::Type` referring to own associated type in trait definitions\n             if let GenericDefId::TraitId(trait_id) = param_id.parent() {\n                 let generics = generics(db.upcast(), trait_id.into());\n-                if generics.params.tocs[param_id.local_id()].is_trait_self() {\n+                if generics.params.type_or_consts[param_id.local_id()].is_trait_self() {\n                     let trait_ref = TyBuilder::trait_ref(db, trait_id)\n                         .fill_with_bound_vars(DebruijnIndex::INNERMOST, 0)\n                         .build();\n@@ -1026,9 +1078,9 @@ pub(crate) fn field_types_query(\n     let generics = generics(db.upcast(), def);\n     let mut res = ArenaMap::default();\n     let ctx =\n-        TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(ParamLoweringMode::Variable);\n     for (field_id, field_data) in var_data.fields().iter() {\n-        res.insert(field_id, make_binders(&generics, ctx.lower_ty(&field_data.type_ref)))\n+        res.insert(field_id, make_binders(db, &generics, ctx.lower_ty(&field_data.type_ref)))\n     }\n     Arc::new(res)\n }\n@@ -1049,7 +1101,7 @@ pub(crate) fn generic_predicates_for_param_query(\n ) -> Arc<[Binders<QuantifiedWhereClause>]> {\n     let resolver = def.resolver(db.upcast());\n     let ctx =\n-        TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(ParamLoweringMode::Variable);\n     let generics = generics(db.upcast(), def);\n     let mut predicates: Vec<_> = resolver\n         .where_predicates_in_scope()\n@@ -1097,14 +1149,16 @@ pub(crate) fn generic_predicates_for_param_query(\n             }\n             WherePredicate::Lifetime { .. } => false,\n         })\n-        .flat_map(|pred| ctx.lower_where_predicate(pred, true).map(|p| make_binders(&generics, p)))\n+        .flat_map(|pred| {\n+            ctx.lower_where_predicate(pred, true).map(|p| make_binders(db, &generics, p))\n+        })\n         .collect();\n \n-    let subst = generics.bound_vars_subst(DebruijnIndex::INNERMOST);\n+    let subst = generics.bound_vars_subst(db, DebruijnIndex::INNERMOST);\n     let explicitly_unsized_tys = ctx.unsized_types.into_inner();\n     let implicitly_sized_predicates =\n         implicitly_sized_clauses(db, param_id.parent, &explicitly_unsized_tys, &subst, &resolver)\n-            .map(|p| make_binders(&generics, crate::wrap_empty_binders(p)));\n+            .map(|p| make_binders(db, &generics, crate::wrap_empty_binders(p)));\n     predicates.extend(implicitly_sized_predicates);\n     predicates.into()\n }\n@@ -1124,8 +1178,8 @@ pub(crate) fn trait_environment_query(\n     def: GenericDefId,\n ) -> Arc<TraitEnvironment> {\n     let resolver = def.resolver(db.upcast());\n-    let ctx = TyLoweringContext::new(db, &resolver)\n-        .with_type_param_mode(TypeParamLoweringMode::Placeholder);\n+    let ctx =\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(ParamLoweringMode::Placeholder);\n     let mut traits_in_scope = Vec::new();\n     let mut clauses = Vec::new();\n     for pred in resolver.where_predicates_in_scope() {\n@@ -1153,14 +1207,14 @@ pub(crate) fn trait_environment_query(\n         // function default implementations (and speculative code\n         // inside consts or type aliases)\n         cov_mark::hit!(trait_self_implements_self);\n-        let substs = TyBuilder::type_params_subst(db, trait_id);\n+        let substs = TyBuilder::placeholder_subst(db, trait_id);\n         let trait_ref = TraitRef { trait_id: to_chalk_trait_id(trait_id), substitution: substs };\n         let pred = WhereClause::Implemented(trait_ref);\n         let program_clause: chalk_ir::ProgramClause<Interner> = pred.cast(Interner);\n         clauses.push(program_clause.into_from_env_clause(Interner));\n     }\n \n-    let subst = generics(db.upcast(), def).type_params_subst(db);\n+    let subst = generics(db.upcast(), def).placeholder_subst(db);\n     let explicitly_unsized_tys = ctx.unsized_types.into_inner();\n     let implicitly_sized_clauses =\n         implicitly_sized_clauses(db, def, &explicitly_unsized_tys, &subst, &resolver).map(|pred| {\n@@ -1183,19 +1237,21 @@ pub(crate) fn generic_predicates_query(\n ) -> Arc<[Binders<QuantifiedWhereClause>]> {\n     let resolver = def.resolver(db.upcast());\n     let ctx =\n-        TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(ParamLoweringMode::Variable);\n     let generics = generics(db.upcast(), def);\n \n     let mut predicates = resolver\n         .where_predicates_in_scope()\n-        .flat_map(|pred| ctx.lower_where_predicate(pred, false).map(|p| make_binders(&generics, p)))\n+        .flat_map(|pred| {\n+            ctx.lower_where_predicate(pred, false).map(|p| make_binders(db, &generics, p))\n+        })\n         .collect::<Vec<_>>();\n \n-    let subst = generics.bound_vars_subst(DebruijnIndex::INNERMOST);\n+    let subst = generics.bound_vars_subst(db, DebruijnIndex::INNERMOST);\n     let explicitly_unsized_tys = ctx.unsized_types.into_inner();\n     let implicitly_sized_predicates =\n         implicitly_sized_clauses(db, def, &explicitly_unsized_tys, &subst, &resolver)\n-            .map(|p| make_binders(&generics, crate::wrap_empty_binders(p)));\n+            .map(|p| make_binders(db, &generics, crate::wrap_empty_binders(p)));\n     predicates.extend(implicitly_sized_predicates);\n     predicates.into()\n }\n@@ -1234,40 +1290,36 @@ fn implicitly_sized_clauses<'a>(\n pub(crate) fn generic_defaults_query(\n     db: &dyn HirDatabase,\n     def: GenericDefId,\n-) -> Arc<[Binders<Ty>]> {\n+) -> Arc<[Binders<chalk_ir::GenericArg<Interner>>]> {\n     let resolver = def.resolver(db.upcast());\n     let ctx =\n-        TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(ParamLoweringMode::Variable);\n     let generic_params = generics(db.upcast(), def);\n \n     let defaults = generic_params\n-        .toc_iter()\n+        .iter()\n         .enumerate()\n-        .map(|(idx, (_, p))| {\n+        .map(|(idx, (id, p))| {\n             let p = match p {\n                 TypeOrConstParamData::TypeParamData(p) => p,\n                 TypeOrConstParamData::ConstParamData(_) => {\n-                    // FIXME: here we should add const generic parameters\n-                    let ty = TyKind::Error.intern(Interner);\n-                    return crate::make_only_type_binders(idx, ty);\n+                    // FIXME: implement const generic defaults\n+                    let val = unknown_const_as_generic(\n+                        db.const_param_ty(ConstParamId::from_unchecked(id)),\n+                    );\n+                    return crate::make_binders_with_count(db, idx, &generic_params, val);\n                 }\n             };\n             let mut ty =\n                 p.default.as_ref().map_or(TyKind::Error.intern(Interner), |t| ctx.lower_ty(t));\n \n             // Each default can only refer to previous parameters.\n-            ty = crate::fold_free_vars(ty, |bound, binders| {\n-                if bound.index >= idx && bound.debruijn == DebruijnIndex::INNERMOST {\n-                    // type variable default referring to parameter coming\n-                    // after it. This is forbidden (FIXME: report\n-                    // diagnostic)\n-                    TyKind::Error.intern(Interner)\n-                } else {\n-                    bound.shifted_in_from(binders).to_ty(Interner)\n-                }\n-            });\n-\n-            crate::make_only_type_binders(idx, ty)\n+            // type variable default referring to parameter coming\n+            // after it. This is forbidden (FIXME: report\n+            // diagnostic)\n+            ty = fallback_bound_vars(ty, idx);\n+            let val = GenericArgData::Ty(ty).intern(Interner);\n+            crate::make_binders_with_count(db, idx, &generic_params, val)\n         })\n         .collect();\n \n@@ -1278,17 +1330,21 @@ pub(crate) fn generic_defaults_recover(\n     db: &dyn HirDatabase,\n     _cycle: &[String],\n     def: &GenericDefId,\n-) -> Arc<[Binders<Ty>]> {\n+) -> Arc<[Binders<crate::GenericArg>]> {\n     let generic_params = generics(db.upcast(), *def);\n-\n+    // FIXME: this code is not covered in tests.\n     // we still need one default per parameter\n     let defaults = generic_params\n-        .toc_iter()\n+        .iter_id()\n         .enumerate()\n-        .map(|(idx, _)| {\n-            let ty = TyKind::Error.intern(Interner);\n-\n-            crate::make_only_type_binders(idx, ty)\n+        .map(|(count, id)| {\n+            let val = match id {\n+                itertools::Either::Left(_) => {\n+                    GenericArgData::Ty(TyKind::Error.intern(Interner)).intern(Interner)\n+                }\n+                itertools::Either::Right(id) => unknown_const_as_generic(db.const_param_ty(id)),\n+            };\n+            crate::make_binders_with_count(db, count, &generic_params, val)\n         })\n         .collect();\n \n@@ -1300,26 +1356,27 @@ fn fn_sig_for_fn(db: &dyn HirDatabase, def: FunctionId) -> PolyFnSig {\n     let resolver = def.resolver(db.upcast());\n     let ctx_params = TyLoweringContext::new(db, &resolver)\n         .with_impl_trait_mode(ImplTraitLoweringMode::Variable)\n-        .with_type_param_mode(TypeParamLoweringMode::Variable);\n+        .with_type_param_mode(ParamLoweringMode::Variable);\n     let params = data.params.iter().map(|(_, tr)| ctx_params.lower_ty(tr)).collect::<Vec<_>>();\n     let ctx_ret = TyLoweringContext::new(db, &resolver)\n         .with_impl_trait_mode(ImplTraitLoweringMode::Opaque)\n-        .with_type_param_mode(TypeParamLoweringMode::Variable);\n+        .with_type_param_mode(ParamLoweringMode::Variable);\n     let ret = ctx_ret.lower_ty(&data.ret_type);\n     let generics = generics(db.upcast(), def.into());\n     let mut sig = CallableSig::from_params_and_return(params, ret, data.is_varargs());\n     if !data.legacy_const_generics_indices.is_empty() {\n         sig.set_legacy_const_generics_indices(&data.legacy_const_generics_indices);\n     }\n-    make_binders(&generics, sig)\n+    make_binders(db, &generics, sig)\n }\n \n /// Build the declared type of a function. This should not need to look at the\n /// function body.\n fn type_for_fn(db: &dyn HirDatabase, def: FunctionId) -> Binders<Ty> {\n     let generics = generics(db.upcast(), def.into());\n-    let substs = generics.bound_vars_subst(DebruijnIndex::INNERMOST);\n+    let substs = generics.bound_vars_subst(db, DebruijnIndex::INNERMOST);\n     make_binders(\n+        db,\n         &generics,\n         TyKind::FnDef(CallableDefId::FunctionId(def).to_chalk(db), substs).intern(Interner),\n     )\n@@ -1331,9 +1388,9 @@ fn type_for_const(db: &dyn HirDatabase, def: ConstId) -> Binders<Ty> {\n     let generics = generics(db.upcast(), def.into());\n     let resolver = def.resolver(db.upcast());\n     let ctx =\n-        TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(ParamLoweringMode::Variable);\n \n-    make_binders(&generics, ctx.lower_ty(&data.type_ref))\n+    make_binders(db, &generics, ctx.lower_ty(&data.type_ref))\n }\n \n /// Build the declared type of a static.\n@@ -1350,7 +1407,7 @@ fn fn_sig_for_struct_constructor(db: &dyn HirDatabase, def: StructId) -> PolyFnS\n     let fields = struct_data.variant_data.fields();\n     let resolver = def.resolver(db.upcast());\n     let ctx =\n-        TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(ParamLoweringMode::Variable);\n     let params = fields.iter().map(|(_, field)| ctx.lower_ty(&field.type_ref)).collect::<Vec<_>>();\n     let (ret, binders) = type_for_adt(db, def.into()).into_value_and_skipped_binders();\n     Binders::new(binders, CallableSig::from_params_and_return(params, ret, false))\n@@ -1363,8 +1420,9 @@ fn type_for_struct_constructor(db: &dyn HirDatabase, def: StructId) -> Binders<T\n         return type_for_adt(db, def.into());\n     }\n     let generics = generics(db.upcast(), def.into());\n-    let substs = generics.bound_vars_subst(DebruijnIndex::INNERMOST);\n+    let substs = generics.bound_vars_subst(db, DebruijnIndex::INNERMOST);\n     make_binders(\n+        db,\n         &generics,\n         TyKind::FnDef(CallableDefId::StructId(def).to_chalk(db), substs).intern(Interner),\n     )\n@@ -1376,7 +1434,7 @@ fn fn_sig_for_enum_variant_constructor(db: &dyn HirDatabase, def: EnumVariantId)\n     let fields = var_data.variant_data.fields();\n     let resolver = def.parent.resolver(db.upcast());\n     let ctx =\n-        TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(ParamLoweringMode::Variable);\n     let params = fields.iter().map(|(_, field)| ctx.lower_ty(&field.type_ref)).collect::<Vec<_>>();\n     let (ret, binders) = type_for_adt(db, def.parent.into()).into_value_and_skipped_binders();\n     Binders::new(binders, CallableSig::from_params_and_return(params, ret, false))\n@@ -1390,31 +1448,32 @@ fn type_for_enum_variant_constructor(db: &dyn HirDatabase, def: EnumVariantId) -\n         return type_for_adt(db, def.parent.into());\n     }\n     let generics = generics(db.upcast(), def.parent.into());\n-    let substs = generics.bound_vars_subst(DebruijnIndex::INNERMOST);\n+    let substs = generics.bound_vars_subst(db, DebruijnIndex::INNERMOST);\n     make_binders(\n+        db,\n         &generics,\n         TyKind::FnDef(CallableDefId::EnumVariantId(def).to_chalk(db), substs).intern(Interner),\n     )\n }\n \n fn type_for_adt(db: &dyn HirDatabase, adt: AdtId) -> Binders<Ty> {\n     let generics = generics(db.upcast(), adt.into());\n-    let b = TyBuilder::adt(db, adt);\n-    let ty = b.fill_with_bound_vars(DebruijnIndex::INNERMOST, 0).build();\n-    make_binders(&generics, ty)\n+    let subst = generics.bound_vars_subst(db, DebruijnIndex::INNERMOST);\n+    let ty = TyKind::Adt(crate::AdtId(adt), subst).intern(Interner);\n+    make_binders(db, &generics, ty)\n }\n \n fn type_for_type_alias(db: &dyn HirDatabase, t: TypeAliasId) -> Binders<Ty> {\n     let generics = generics(db.upcast(), t.into());\n     let resolver = t.resolver(db.upcast());\n     let ctx =\n-        TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(ParamLoweringMode::Variable);\n     if db.type_alias_data(t).is_extern {\n         Binders::empty(Interner, TyKind::Foreign(crate::to_foreign_def_id(t)).intern(Interner))\n     } else {\n         let type_ref = &db.type_alias_data(t).type_ref;\n         let inner = ctx.lower_ty(type_ref.as_deref().unwrap_or(&TypeRef::Error));\n-        make_binders(&generics, inner)\n+        make_binders(db, &generics, inner)\n     }\n }\n \n@@ -1485,7 +1544,7 @@ pub(crate) fn ty_recover(db: &dyn HirDatabase, _cycle: &[String], def: &TyDefId)\n         TyDefId::AdtId(it) => generics(db.upcast(), it.into()),\n         TyDefId::TypeAliasId(it) => generics(db.upcast(), it.into()),\n     };\n-    make_binders(&generics, TyKind::Error.intern(Interner))\n+    make_binders(db, &generics, TyKind::Error.intern(Interner))\n }\n \n pub(crate) fn value_ty_query(db: &dyn HirDatabase, def: ValueTyDefId) -> Binders<Ty> {\n@@ -1509,14 +1568,14 @@ pub(crate) fn impl_self_ty_query(db: &dyn HirDatabase, impl_id: ImplId) -> Binde\n     ));\n     let generics = generics(db.upcast(), impl_id.into());\n     let ctx =\n-        TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n-    make_binders(&generics, ctx.lower_ty(&impl_data.self_ty))\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(ParamLoweringMode::Variable);\n+    make_binders(db, &generics, ctx.lower_ty(&impl_data.self_ty))\n }\n \n // returns None if def is a type arg\n pub(crate) fn const_param_ty_query(db: &dyn HirDatabase, def: ConstParamId) -> Ty {\n     let parent_data = db.generic_params(def.parent());\n-    let data = &parent_data.tocs[def.local_id()];\n+    let data = &parent_data.type_or_consts[def.local_id()];\n     let resolver = def.parent().resolver(db.upcast());\n     let ctx = TyLoweringContext::new(db, &resolver);\n     match data {\n@@ -1534,7 +1593,7 @@ pub(crate) fn impl_self_ty_recover(\n     impl_id: &ImplId,\n ) -> Binders<Ty> {\n     let generics = generics(db.upcast(), (*impl_id).into());\n-    make_binders(&generics, TyKind::Error.intern(Interner))\n+    make_binders(db, &generics, TyKind::Error.intern(Interner))\n }\n \n pub(crate) fn impl_trait_query(db: &dyn HirDatabase, impl_id: ImplId) -> Option<Binders<TraitRef>> {\n@@ -1546,7 +1605,7 @@ pub(crate) fn impl_trait_query(db: &dyn HirDatabase, impl_id: ImplId) -> Option<\n         impl_id, impl_loc, impl_data\n     ));\n     let ctx =\n-        TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(ParamLoweringMode::Variable);\n     let (self_ty, binders) = db.impl_self_ty(impl_id).into_value_and_skipped_binders();\n     let target_trait = impl_data.target_trait.as_ref()?;\n     Some(Binders::new(binders, ctx.lower_trait_ref(target_trait, Some(self_ty))?))\n@@ -1561,15 +1620,15 @@ pub(crate) fn return_type_impl_traits(\n     let resolver = def.resolver(db.upcast());\n     let ctx_ret = TyLoweringContext::new(db, &resolver)\n         .with_impl_trait_mode(ImplTraitLoweringMode::Opaque)\n-        .with_type_param_mode(TypeParamLoweringMode::Variable);\n+        .with_type_param_mode(ParamLoweringMode::Variable);\n     let _ret = (&ctx_ret).lower_ty(&data.ret_type);\n     let generics = generics(db.upcast(), def.into());\n     let return_type_impl_traits =\n         ReturnTypeImplTraits { impl_traits: ctx_ret.opaque_type_data.into_inner() };\n     if return_type_impl_traits.impl_traits.is_empty() {\n         None\n     } else {\n-        Some(Arc::new(make_binders(&generics, return_type_impl_traits)))\n+        Some(Arc::new(make_binders(db, &generics, return_type_impl_traits)))\n     }\n }\n \n@@ -1580,6 +1639,65 @@ pub(crate) fn lower_to_chalk_mutability(m: hir_def::type_ref::Mutability) -> Mut\n     }\n }\n \n-fn make_binders<T: HasInterner<Interner = Interner>>(generics: &Generics, value: T) -> Binders<T> {\n-    crate::make_only_type_binders(generics.len(), value)\n+pub(crate) fn generic_arg_to_chalk<'a, T>(\n+    db: &dyn HirDatabase,\n+    kind_id: Either<TypeParamId, ConstParamId>,\n+    arg: &'a GenericArg,\n+    this: &mut T,\n+    for_type: impl FnOnce(&mut T, &TypeRef) -> Ty + 'a,\n+    for_const: impl FnOnce(&mut T, &ConstScalarOrPath) -> Const + 'a,\n+) -> Option<crate::GenericArg> {\n+    let kind = match kind_id {\n+        Either::Left(_) => ParamKind::Type,\n+        Either::Right(id) => {\n+            let ty = db.const_param_ty(id);\n+            ParamKind::Const(ty)\n+        }\n+    };\n+    Some(match (arg, kind) {\n+        (GenericArg::Type(type_ref), ParamKind::Type) => {\n+            let ty = for_type(this, type_ref);\n+            GenericArgData::Ty(ty).intern(Interner)\n+        }\n+        (GenericArg::Const(c), ParamKind::Const(_)) => {\n+            GenericArgData::Const(for_const(this, c)).intern(Interner)\n+        }\n+        (GenericArg::Const(_), ParamKind::Type) => {\n+            GenericArgData::Ty(TyKind::Error.intern(Interner)).intern(Interner)\n+        }\n+        (GenericArg::Type(t), ParamKind::Const(ty)) => {\n+            // We want to recover simple idents, which parser detects them\n+            // as types. Maybe here is not the best place to do it, but\n+            // it works.\n+            if let TypeRef::Path(p) = t {\n+                let p = p.mod_path();\n+                if p.kind == PathKind::Plain {\n+                    if let [n] = p.segments() {\n+                        let c = ConstScalarOrPath::Path(n.clone());\n+                        return Some(GenericArgData::Const(for_const(this, &c)).intern(Interner));\n+                    }\n+                }\n+            }\n+            unknown_const_as_generic(ty)\n+        }\n+        (GenericArg::Lifetime(_), _) => return None,\n+    })\n+}\n+\n+pub(crate) fn const_or_path_to_chalk(\n+    db: &dyn HirDatabase,\n+    resolver: &Resolver,\n+    value: &ConstScalarOrPath,\n+    mode: ParamLoweringMode,\n+    args: impl FnOnce() -> Generics,\n+    debruijn: DebruijnIndex,\n+) -> Const {\n+    match value {\n+        ConstScalarOrPath::Scalar(s) => usize_const(s.as_usize()),\n+        ConstScalarOrPath::Path(n) => {\n+            let path = ModPath::from_segments(PathKind::Plain, Some(n.clone()));\n+            path_to_const(db, resolver, &path, mode, args, debruijn)\n+                .unwrap_or_else(|| unknown_const_usize())\n+        }\n+    }\n }"}, {"sha": "06c834fbc89e1702cea99de5b229a2f0bbe8932c", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 45, "deletions": 25, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=b301b040f5781a9083348936369a01c37138756f", "patch": "@@ -6,7 +6,7 @@ use std::{iter, ops::ControlFlow, sync::Arc};\n \n use arrayvec::ArrayVec;\n use base_db::{CrateId, Edition};\n-use chalk_ir::{cast::Cast, Mutability, UniverseIndex};\n+use chalk_ir::{cast::Cast, fold::Fold, interner::HasInterner, Mutability, UniverseIndex};\n use hir_def::{\n     item_scope::ItemScope, lang_item::LangItemTarget, nameres::DefMap, AssocItemId, BlockId,\n     ConstId, FunctionId, GenericDefId, HasModule, ImplId, ItemContainerId, Lookup, ModuleDefId,\n@@ -25,8 +25,9 @@ use crate::{\n     primitive::{self, FloatTy, IntTy, UintTy},\n     static_lifetime,\n     utils::all_super_traits,\n-    AdtId, Canonical, CanonicalVarKinds, DebruijnIndex, ForeignDefId, InEnvironment, Interner,\n-    Scalar, Substitution, TraitEnvironment, TraitRefExt, Ty, TyBuilder, TyExt, TyKind,\n+    AdtId, Canonical, CanonicalVarKinds, DebruijnIndex, ForeignDefId, GenericArgData,\n+    InEnvironment, Interner, Scalar, Substitution, TraitEnvironment, TraitRefExt, Ty, TyBuilder,\n+    TyExt, TyKind,\n };\n \n /// This is used as a key for indexing impls.\n@@ -1087,13 +1088,14 @@ pub(crate) fn inherent_impl_substs(\n         .build();\n     let self_ty_with_vars = db.impl_self_ty(impl_id).substitute(Interner, &vars);\n     let mut kinds = self_ty.binders.interned().to_vec();\n-    kinds.extend(\n-        iter::repeat(chalk_ir::WithKind::new(\n-            chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General),\n-            UniverseIndex::ROOT,\n-        ))\n-        .take(vars.len(Interner)),\n-    );\n+    kinds.extend(vars.iter(Interner).map(|x| {\n+        let kind = match x.data(Interner) {\n+            GenericArgData::Ty(_) => chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General),\n+            GenericArgData::Const(c) => chalk_ir::VariableKind::Const(c.data(Interner).ty.clone()),\n+            GenericArgData::Lifetime(_) => chalk_ir::VariableKind::Lifetime,\n+        };\n+        chalk_ir::WithKind::new(kind, UniverseIndex::ROOT)\n+    }));\n     let tys = Canonical {\n         binders: CanonicalVarKinds::from_iter(Interner, kinds),\n         value: (self_ty_with_vars, self_ty.value.clone()),\n@@ -1111,14 +1113,27 @@ pub(crate) fn inherent_impl_substs(\n \n /// This replaces any 'free' Bound vars in `s` (i.e. those with indices past\n /// num_vars_to_keep) by `TyKind::Unknown`.\n-fn fallback_bound_vars(s: Substitution, num_vars_to_keep: usize) -> Substitution {\n-    crate::fold_free_vars(s, |bound, binders| {\n-        if bound.index >= num_vars_to_keep && bound.debruijn == DebruijnIndex::INNERMOST {\n-            TyKind::Error.intern(Interner)\n-        } else {\n-            bound.shifted_in_from(binders).to_ty(Interner)\n-        }\n-    })\n+pub(crate) fn fallback_bound_vars<T: Fold<Interner> + HasInterner<Interner = Interner>>(\n+    s: T,\n+    num_vars_to_keep: usize,\n+) -> T::Result {\n+    crate::fold_free_vars(\n+        s,\n+        |bound, binders| {\n+            if bound.index >= num_vars_to_keep && bound.debruijn == DebruijnIndex::INNERMOST {\n+                TyKind::Error.intern(Interner)\n+            } else {\n+                bound.shifted_in_from(binders).to_ty(Interner)\n+            }\n+        },\n+        |ty, bound, binders| {\n+            if bound.index >= num_vars_to_keep && bound.debruijn == DebruijnIndex::INNERMOST {\n+                consteval::usize_const(None)\n+            } else {\n+                bound.shifted_in_from(binders).to_const(Interner, ty)\n+            }\n+        },\n+    )\n }\n \n fn transform_receiver_ty(\n@@ -1183,13 +1198,18 @@ fn generic_implements_goal(\n         .push(self_ty.value.clone())\n         .fill_with_bound_vars(DebruijnIndex::INNERMOST, kinds.len())\n         .build();\n-    kinds.extend(\n-        iter::repeat(chalk_ir::WithKind::new(\n-            chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General),\n-            UniverseIndex::ROOT,\n-        ))\n-        .take(trait_ref.substitution.len(Interner) - 1),\n-    );\n+    kinds.extend(trait_ref.substitution.iter(Interner).skip(1).map(|x| {\n+        let vk = match x.data(Interner) {\n+            chalk_ir::GenericArgData::Ty(_) => {\n+                chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General)\n+            }\n+            chalk_ir::GenericArgData::Lifetime(_) => chalk_ir::VariableKind::Lifetime,\n+            chalk_ir::GenericArgData::Const(c) => {\n+                chalk_ir::VariableKind::Const(c.data(Interner).ty.clone())\n+            }\n+        };\n+        chalk_ir::WithKind::new(vk, UniverseIndex::ROOT)\n+    }));\n     let obligation = trait_ref.cast(Interner);\n     Canonical {\n         binders: CanonicalVarKinds::from_iter(Interner, kinds),"}, {"sha": "9700b388aa74d59fbb78ea8b2d96079e3fc5693b", "filename": "crates/hir_ty/src/tests/method_resolution.rs", "status": "modified", "additions": 63, "deletions": 1, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=b301b040f5781a9083348936369a01c37138756f", "patch": "@@ -1359,7 +1359,69 @@ impl<T> [T] {\n fn f() {\n     let v = [1, 2].map::<_, usize>(|x| -> x * 2);\n     v;\n-  //^ [usize; _]\n+  //^ [usize; 2]\n+}\n+    \"#,\n+    );\n+}\n+\n+#[test]\n+fn resolve_const_generic_method() {\n+    check_types(\n+        r#\"\n+struct Const<const N: usize>;\n+\n+#[lang = \"array\"]\n+impl<T, const N: usize> [T; N] {\n+    pub fn my_map<F, U, const X: usize>(self, f: F, c: Const<X>) -> [U; X]\n+    where\n+        F: FnMut(T) -> U,\n+    { loop {} }\n+}\n+\n+#[lang = \"slice\"]\n+impl<T> [T] {\n+    pub fn my_map<F, const X: usize, U>(self, f: F, c: Const<X>) -> &[U]\n+    where\n+        F: FnMut(T) -> U,\n+    { loop {} }\n+}\n+\n+fn f<const C: usize, P>() {\n+    let v = [1, 2].my_map::<_, (), 12>(|x| -> x * 2, Const::<12>);\n+    v;\n+  //^ [(); 12]\n+    let v = [1, 2].my_map::<_, P, C>(|x| -> x * 2, Const::<C>);\n+    v;\n+  //^ [P; C]\n+}\n+    \"#,\n+    );\n+}\n+\n+#[test]\n+fn const_generic_type_alias() {\n+    check_types(\n+        r#\"\n+struct Const<const N: usize>;\n+type U2 = Const<2>;\n+type U5 = Const<5>;\n+\n+impl U2 {\n+    fn f(self) -> Const<12> {\n+        loop {}\n+    }\n+}\n+\n+impl U5 {\n+    fn f(self) -> Const<15> {\n+        loop {}\n+    }\n+}\n+\n+fn f(x: U2) {\n+    let y = x.f();\n+      //^ Const<12>\n }\n     \"#,\n     );"}, {"sha": "4a65b927ba9d95559fc763440ad3d53607aad64f", "filename": "crates/hir_ty/src/tests/regression.rs", "status": "modified", "additions": 103, "deletions": 38, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs?ref=b301b040f5781a9083348936369a01c37138756f", "patch": "@@ -1301,7 +1301,7 @@ impl<I: Iterator> IntoIterator for I {\n \n #[test]\n fn bug_11659() {\n-    check_infer(\n+    check_no_mismatches(\n         r#\"\n struct LinkArray<const N: usize, LD>(LD);\n fn f<const N: usize, LD>(x: LD) -> LinkArray<N, LD> {\n@@ -1314,26 +1314,8 @@ fn test() {\n     let y = LinkArray::<52, LinkArray<2, i32>>(x);\n }\n         \"#,\n-        expect![[r#\"\n-        67..68 'x': LD\n-        94..138 '{     ...   r }': LinkArray<{unknown}, LD>\n-        104..105 'r': LinkArray<{unknown}, LD>\n-        108..126 'LinkAr...N, LD>': LinkArray<{unknown}, LD>(LD) -> LinkArray<{unknown}, LD>\n-        108..129 'LinkAr...LD>(x)': LinkArray<{unknown}, LD>\n-        127..128 'x': LD\n-        135..136 'r': LinkArray<{unknown}, LD>\n-        150..232 '{     ...(x); }': ()\n-        160..161 'x': LinkArray<{unknown}, {unknown}>\n-        164..175 'f::<2, i32>': fn f<i32, i32>(i32) -> LinkArray<{unknown}, {unknown}>\n-        164..178 'f::<2, i32>(5)': LinkArray<{unknown}, {unknown}>\n-        176..177 '5': i32\n-        188..189 'y': LinkArray<LinkArray<i32, {unknown}>, LinkArray<{unknown}, {unknown}>>\n-        192..226 'LinkAr... i32>>': LinkArray<LinkArray<i32, {unknown}>, LinkArray<{unknown}, {unknown}>>(LinkArray<{unknown}, {unknown}>) -> LinkArray<LinkArray<i32, {unknown}>, LinkArray<{unknown}, {unknown}>>\n-        192..229 'LinkAr...2>>(x)': LinkArray<LinkArray<i32, {unknown}>, LinkArray<{unknown}, {unknown}>>\n-        227..228 'x': LinkArray<{unknown}, {unknown}>\n-        \"#]],\n     );\n-    check_infer(\n+    check_no_mismatches(\n         r#\"\n struct LinkArray<LD, const N: usize>(LD);\n fn f<const N: usize, LD>(x: LD) -> LinkArray<LD, N> {\n@@ -1346,23 +1328,106 @@ fn test() {\n     let y = LinkArray::<LinkArray<i32, 2>, 52>(x);\n }\n         \"#,\n-        expect![[r#\"\n-        67..68 'x': LD\n-        94..138 '{     ...   r }': LinkArray<LD, {unknown}>\n-        104..105 'r': LinkArray<LD, {unknown}>\n-        108..126 'LinkAr...LD, N>': LinkArray<LD, {unknown}>(LD) -> LinkArray<LD, {unknown}>\n-        108..129 'LinkAr... N>(x)': LinkArray<LD, {unknown}>\n-        127..128 'x': LD\n-        135..136 'r': LinkArray<LD, {unknown}>\n-        150..232 '{     ...(x); }': ()\n-        160..161 'x': LinkArray<i32, {unknown}>\n-        164..175 'f::<i32, 2>': fn f<i32, i32>(i32) -> LinkArray<i32, {unknown}>\n-        164..178 'f::<i32, 2>(5)': LinkArray<i32, {unknown}>\n-        176..177 '5': i32\n-        188..189 'y': LinkArray<LinkArray<i32, {unknown}>, {unknown}>\n-        192..226 'LinkAr...>, 52>': LinkArray<LinkArray<i32, {unknown}>, {unknown}>(LinkArray<i32, {unknown}>) -> LinkArray<LinkArray<i32, {unknown}>, {unknown}>\n-        192..229 'LinkAr...52>(x)': LinkArray<LinkArray<i32, {unknown}>, {unknown}>\n-        227..228 'x': LinkArray<i32, {unknown}>\n-        \"#]],\n     );\n }\n+\n+#[test]\n+fn const_generic_error_tolerance() {\n+    check_no_mismatches(\n+        r#\"\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+\n+struct CT<const N: usize, T>(T);\n+struct TC<T, const N: usize>(T);\n+fn f<const N: usize, T>(x: T) -> (CT<N, T>, TC<T, N>) {\n+    let l = CT::<N, T>(x);\n+    let r = TC::<N, T>(x);\n+    (l, r)\n+}\n+\n+trait TR1<const N: usize>;\n+trait TR2<const N: usize>;\n+\n+impl<const N: usize, T> TR1<N> for CT<N, T>;\n+impl<const N: usize, T> TR1<5> for TC<T, N>;\n+impl<const N: usize, T> TR2<N> for CT<T, N>;\n+\n+trait TR3<const N: usize> {\n+    fn tr3(&self) -> &Self;\n+}\n+\n+impl<const N: usize, T> TR3<5> for TC<T, N> {\n+    fn tr3(&self) -> &Self {\n+        self\n+    }\n+}\n+\n+impl<const N: usize, T> TR3<Item = 5> for TC<T, N> {}\n+impl<const N: usize, T> TR3<T> for TC<T, N> {}\n+\n+fn impl_trait<const N: usize>(inp: impl TR1<N>) {}\n+fn dyn_trait<const N: usize>(inp: &dyn TR2<N>) {}\n+fn impl_trait_bad<'a, const N: usize>(inp: impl TR1<i32>) -> impl TR1<'a, i32> {}\n+fn impl_trait_very_bad<const N: usize>(inp: impl TR1<Item = i32>) -> impl TR1<'a, Item = i32, 5, Foo = N> {}\n+\n+fn test() {\n+    f::<2, i32>(5);\n+    f::<2, 2>(5);\n+    f(5);\n+    f::<i32>(5);\n+    CT::<52, CT<2, i32>>(x);\n+    CT::<CT<2, i32>>(x);\n+    impl_trait_bad(5);\n+    impl_trait_bad(12);\n+    TR3<5>::tr3();\n+    TR3<{ 2+3 }>::tr3();\n+    TC::<i32, 10>(5).tr3();\n+    TC::<i32, 20>(5).tr3();\n+    TC::<i32, i32>(5).tr3();\n+    TC::<i32, { 7 + 3 }>(5).tr3();\n+}\n+        \"#,\n+    );\n+}\n+\n+#[test]\n+fn const_generic_impl_trait() {\n+    check_no_mismatches(\n+        r#\"\n+        //- minicore: from\n+\n+        struct Foo<T, const M: usize>;\n+\n+        trait Tr<T> {\n+            fn f(T) -> Self;\n+        }\n+\n+        impl<T, const M: usize> Tr<[T; M]> for Foo<T, M> {\n+            fn f(_: [T; M]) -> Self {\n+                Self\n+            }\n+        }\n+\n+        fn test() {\n+            Foo::f([1, 2, 7, 10]);\n+        }\n+        \"#,\n+    );\n+}\n+\n+#[test]\n+fn nalgebra_factorial() {\n+    check_no_mismatches(\n+        r#\"\n+        const FACTORIAL: [u128; 4] = [1, 1, 2, 6];\n+\n+        fn factorial(n: usize) -> u128 {\n+            match FACTORIAL.get(n) {\n+                Some(f) => *f,\n+                None => panic!(\"{}! is greater than u128::MAX\", n),\n+            }\n+        }\n+        \"#,\n+    )\n+}"}, {"sha": "0d050f7461bc0eb5f610230ccac6e9b8b870bc04", "filename": "crates/hir_ty/src/tests/simple.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=b301b040f5781a9083348936369a01c37138756f", "patch": "@@ -1202,14 +1202,13 @@ fn infer_array() {\n \n             let b = [a, [\"b\"]];\n             let x: [u8; 0] = [];\n-            // FIXME: requires const evaluation/taking type from rhs somehow\n             let y: [u8; 2+2] = [1,2,3,4];\n         }\n         \"#,\n         expect![[r#\"\n             8..9 'x': &str\n             17..18 'y': isize\n-            27..395 '{     ...,4]; }': ()\n+            27..326 '{     ...,4]; }': ()\n             37..38 'a': [&str; 1]\n             41..44 '[x]': [&str; 1]\n             42..43 'x': &str\n@@ -1259,12 +1258,12 @@ fn infer_array() {\n             259..262 '\"b\"': &str\n             274..275 'x': [u8; 0]\n             287..289 '[]': [u8; 0]\n-            368..369 'y': [u8; _]\n-            383..392 '[1,2,3,4]': [u8; 4]\n-            384..385 '1': u8\n-            386..387 '2': u8\n-            388..389 '3': u8\n-            390..391 '4': u8\n+            299..300 'y': [u8; 4]\n+            314..323 '[1,2,3,4]': [u8; 4]\n+            315..316 '1': u8\n+            317..318 '2': u8\n+            319..320 '3': u8\n+            321..322 '4': u8\n         \"#]],\n     );\n }"}, {"sha": "5daffb2c5e6ee210624f1d22942c1c1ea25de3f5", "filename": "crates/hir_ty/src/tests/traits.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=b301b040f5781a9083348936369a01c37138756f", "patch": "@@ -3394,7 +3394,6 @@ fn main() {\n     )\n }\n \n-// FIXME: We should infer the length of the returned array :)\n #[test]\n fn const_generics() {\n     check_infer(\n@@ -3418,18 +3417,18 @@ fn main() {\n \"#,\n         expect![[r#\"\n             44..48 'self': &Self\n-            151..155 'self': &[u8; _]\n-            173..194 '{     ...     }': [u8; _]\n-            183..188 '*self': [u8; _]\n-            184..188 'self': &[u8; _]\n+            151..155 'self': &[u8; L]\n+            173..194 '{     ...     }': [u8; L]\n+            183..188 '*self': [u8; L]\n+            184..188 'self': &[u8; L]\n             208..260 '{     ...g(); }': ()\n             218..219 'v': [u8; 2]\n             222..230 '[0u8; 2]': [u8; 2]\n             223..226 '0u8': u8\n             228..229 '2': usize\n-            240..242 'v2': [u8; _]\n+            240..242 'v2': [u8; 2]\n             245..246 'v': [u8; 2]\n-            245..257 'v.do_thing()': [u8; _]\n+            245..257 'v.do_thing()': [u8; 2]\n         \"#]],\n     )\n }"}, {"sha": "343e89eb9bbedce5044c35b3a5acf5433cafd68c", "filename": "crates/hir_ty/src/utils.rs", "status": "modified", "additions": 60, "deletions": 21, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b301b040f5781a9083348936369a01c37138756f/crates%2Fhir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Futils.rs?ref=b301b040f5781a9083348936369a01c37138756f", "patch": "@@ -15,16 +15,18 @@ use hir_def::{\n     path::Path,\n     resolver::{HasResolver, TypeNs},\n     type_ref::{TraitBoundModifier, TypeRef},\n-    GenericDefId, ItemContainerId, Lookup, TraitId, TypeAliasId, TypeOrConstParamId,\n+    ConstParamId, GenericDefId, ItemContainerId, Lookup, TraitId, TypeAliasId, TypeOrConstParamId,\n+    TypeParamId,\n };\n use hir_expand::name::{name, Name};\n+use itertools::Either;\n use rustc_hash::FxHashSet;\n use smallvec::{smallvec, SmallVec};\n use syntax::SmolStr;\n \n use crate::{\n-    db::HirDatabase, ChalkTraitId, Interner, Substitution, TraitRef, TraitRefExt, TyKind,\n-    WhereClause,\n+    db::HirDatabase, ChalkTraitId, ConstData, ConstValue, GenericArgData, Interner, Substitution,\n+    TraitRef, TraitRefExt, TyKind, WhereClause,\n };\n \n pub(crate) fn fn_traits(db: &dyn DefDatabase, krate: CrateId) -> impl Iterator<Item = TraitId> {\n@@ -203,30 +205,43 @@ impl Generics {\n             )\n     }\n \n-    pub(crate) fn toc_iter<'a>(\n+    pub(crate) fn iter_id<'a>(\n         &'a self,\n-    ) -> impl Iterator<Item = (TypeOrConstParamId, &'a TypeOrConstParamData)> + 'a {\n+    ) -> impl Iterator<Item = Either<TypeParamId, ConstParamId>> + 'a {\n+        self.iter().map(|(id, data)| match data {\n+            TypeOrConstParamData::TypeParamData(_) => Either::Left(TypeParamId::from_unchecked(id)),\n+            TypeOrConstParamData::ConstParamData(_) => {\n+                Either::Right(ConstParamId::from_unchecked(id))\n+            }\n+        })\n+    }\n+\n+    /// Iterator over types and const params of parent, then self.\n+    pub(crate) fn iter<'a>(\n+        &'a self,\n+    ) -> impl DoubleEndedIterator<Item = (TypeOrConstParamId, &'a TypeOrConstParamData)> + 'a {\n         self.parent_generics\n             .as_ref()\n             .into_iter()\n             .flat_map(|it| {\n                 it.params\n-                    .toc_iter()\n+                    .iter()\n                     .map(move |(local_id, p)| (TypeOrConstParamId { parent: it.def, local_id }, p))\n             })\n             .chain(\n-                self.params.toc_iter().map(move |(local_id, p)| {\n+                self.params.iter().map(move |(local_id, p)| {\n                     (TypeOrConstParamId { parent: self.def, local_id }, p)\n                 }),\n             )\n     }\n \n+    /// Iterator over types and const params of parent.\n     pub(crate) fn iter_parent<'a>(\n         &'a self,\n     ) -> impl Iterator<Item = (TypeOrConstParamId, &'a TypeOrConstParamData)> + 'a {\n         self.parent_generics.as_ref().into_iter().flat_map(|it| {\n             it.params\n-                .tocs\n+                .type_or_consts\n                 .iter()\n                 .map(move |(local_id, p)| (TypeOrConstParamId { parent: it.def, local_id }, p))\n         })\n@@ -239,7 +254,7 @@ impl Generics {\n     /// (total, parents, child)\n     pub(crate) fn len_split(&self) -> (usize, usize, usize) {\n         let parent = self.parent_generics.as_ref().map_or(0, |p| p.len());\n-        let child = self.params.tocs.len();\n+        let child = self.params.type_or_consts.len();\n         (parent + child, parent, child)\n     }\n \n@@ -248,22 +263,20 @@ impl Generics {\n         let parent = self.parent_generics.as_ref().map_or(0, |p| p.len());\n         let self_params = self\n             .params\n-            .tocs\n             .iter()\n             .filter_map(|x| x.1.type_param())\n             .filter(|p| p.provenance == TypeParamProvenance::TraitSelf)\n             .count();\n         let type_params = self\n             .params\n-            .tocs\n+            .type_or_consts\n             .iter()\n             .filter_map(|x| x.1.type_param())\n             .filter(|p| p.provenance == TypeParamProvenance::TypeParamList)\n             .count();\n-        let const_params = self.params.tocs.iter().filter_map(|x| x.1.const_param()).count();\n+        let const_params = self.params.iter().filter_map(|x| x.1.const_param()).count();\n         let impl_trait_params = self\n             .params\n-            .tocs\n             .iter()\n             .filter_map(|x| x.1.type_param())\n             .filter(|p| p.provenance == TypeParamProvenance::ArgumentImplTrait)\n@@ -279,7 +292,7 @@ impl Generics {\n         if param.parent == self.def {\n             let (idx, (_local_id, data)) = self\n                 .params\n-                .tocs\n+                .type_or_consts\n                 .iter()\n                 .enumerate()\n                 .find(|(_, (idx, _))| *idx == param.local_id)\n@@ -292,21 +305,47 @@ impl Generics {\n     }\n \n     /// Returns a Substitution that replaces each parameter by a bound variable.\n-    pub(crate) fn bound_vars_subst(&self, debruijn: DebruijnIndex) -> Substitution {\n+    pub(crate) fn bound_vars_subst(\n+        &self,\n+        db: &dyn HirDatabase,\n+        debruijn: DebruijnIndex,\n+    ) -> Substitution {\n         Substitution::from_iter(\n             Interner,\n-            self.toc_iter()\n-                .enumerate()\n-                .map(|(idx, _)| TyKind::BoundVar(BoundVar::new(debruijn, idx)).intern(Interner)),\n+            self.iter_id().enumerate().map(|(idx, id)| match id {\n+                Either::Left(_) => GenericArgData::Ty(\n+                    TyKind::BoundVar(BoundVar::new(debruijn, idx)).intern(Interner),\n+                )\n+                .intern(Interner),\n+                Either::Right(id) => GenericArgData::Const(\n+                    ConstData {\n+                        value: ConstValue::BoundVar(BoundVar::new(debruijn, idx)),\n+                        ty: db.const_param_ty(id),\n+                    }\n+                    .intern(Interner),\n+                )\n+                .intern(Interner),\n+            }),\n         )\n     }\n \n     /// Returns a Substitution that replaces each parameter by itself (i.e. `Ty::Param`).\n-    pub(crate) fn type_params_subst(&self, db: &dyn HirDatabase) -> Substitution {\n+    pub(crate) fn placeholder_subst(&self, db: &dyn HirDatabase) -> Substitution {\n         Substitution::from_iter(\n             Interner,\n-            self.toc_iter().map(|(id, _)| {\n-                TyKind::Placeholder(crate::to_placeholder_idx(db, id)).intern(Interner)\n+            self.iter_id().map(|id| match id {\n+                Either::Left(id) => GenericArgData::Ty(\n+                    TyKind::Placeholder(crate::to_placeholder_idx(db, id.into())).intern(Interner),\n+                )\n+                .intern(Interner),\n+                Either::Right(id) => GenericArgData::Const(\n+                    ConstData {\n+                        value: ConstValue::Placeholder(crate::to_placeholder_idx(db, id.into())),\n+                        ty: db.const_param_ty(id),\n+                    }\n+                    .intern(Interner),\n+                )\n+                .intern(Interner),\n             }),\n         )\n     }"}, {"sha": "96cd83b924b09591de5052733e27ca32aa654249", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b301b040f5781a9083348936369a01c37138756f/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b301b040f5781a9083348936369a01c37138756f/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=b301b040f5781a9083348936369a01c37138756f", "patch": "@@ -3361,6 +3361,27 @@ fn foo<T$0: Sized + ?Sized + Sized + Trait>() {}\n     }\n }\n \n+#[test]\n+fn hover_const_generic_type_alias() {\n+    check(\n+        r#\"\n+struct Foo<const LEN: usize>;\n+type Fo$0o2 = Foo<2>;\n+\"#,\n+        expect![[r#\"\n+                *Foo2*\n+\n+                ```rust\n+                test\n+                ```\n+\n+                ```rust\n+                type Foo2 = Foo<2>\n+                ```\n+            \"#]],\n+    );\n+}\n+\n #[test]\n fn hover_const_param() {\n     check("}]}